LavaPack.loadBundle([
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\x509.js", {"./aes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\aes.js","./asn1":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\asn1.js","./des":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\des.js","./forge":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\forge.js","./md":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\md.js","./mgf":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\mgf.js","./oids":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\oids.js","./pem":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\pem.js","./pss":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\pss.js","./rsa":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\rsa.js","./util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\node-forge\lib\x509.js
      return function (require, module, exports) {
/**
 * Javascript implementation of X.509 and related components (such as
 * Certification Signing Requests) of a Public Key Infrastructure.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 *
 * The ASN.1 representation of an X.509v3 certificate is as follows
 * (see RFC 2459):
 *
 * Certificate ::= SEQUENCE {
 *   tbsCertificate       TBSCertificate,
 *   signatureAlgorithm   AlgorithmIdentifier,
 *   signatureValue       BIT STRING
 * }
 *
 * TBSCertificate ::= SEQUENCE {
 *   version         [0]  EXPLICIT Version DEFAULT v1,
 *   serialNumber         CertificateSerialNumber,
 *   signature            AlgorithmIdentifier,
 *   issuer               Name,
 *   validity             Validity,
 *   subject              Name,
 *   subjectPublicKeyInfo SubjectPublicKeyInfo,
 *   issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
 *                        -- If present, version shall be v2 or v3
 *   subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
 *                        -- If present, version shall be v2 or v3
 *   extensions      [3]  EXPLICIT Extensions OPTIONAL
 *                        -- If present, version shall be v3
 * }
 *
 * Version ::= INTEGER  { v1(0), v2(1), v3(2) }
 *
 * CertificateSerialNumber ::= INTEGER
 *
 * Name ::= CHOICE {
 *   // only one possible choice for now
 *   RDNSequence
 * }
 *
 * RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
 *
 * RelativeDistinguishedName ::= SET OF AttributeTypeAndValue
 *
 * AttributeTypeAndValue ::= SEQUENCE {
 *   type     AttributeType,
 *   value    AttributeValue
 * }
 * AttributeType ::= OBJECT IDENTIFIER
 * AttributeValue ::= ANY DEFINED BY AttributeType
 *
 * Validity ::= SEQUENCE {
 *   notBefore      Time,
 *   notAfter       Time
 * }
 *
 * Time ::= CHOICE {
 *   utcTime        UTCTime,
 *   generalTime    GeneralizedTime
 * }
 *
 * UniqueIdentifier ::= BIT STRING
 *
 * SubjectPublicKeyInfo ::= SEQUENCE {
 *   algorithm            AlgorithmIdentifier,
 *   subjectPublicKey     BIT STRING
 * }
 *
 * Extensions ::= SEQUENCE SIZE (1..MAX) OF Extension
 *
 * Extension ::= SEQUENCE {
 *   extnID      OBJECT IDENTIFIER,
 *   critical    BOOLEAN DEFAULT FALSE,
 *   extnValue   OCTET STRING
 * }
 *
 * The only key algorithm currently supported for PKI is RSA.
 *
 * RSASSA-PSS signatures are described in RFC 3447 and RFC 4055.
 *
 * PKCS#10 v1.7 describes certificate signing requests:
 *
 * CertificationRequestInfo:
 *
 * CertificationRequestInfo ::= SEQUENCE {
 *   version       INTEGER { v1(0) } (v1,...),
 *   subject       Name,
 *   subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
 *   attributes    [0] Attributes{{ CRIAttributes }}
 * }
 *
 * Attributes { ATTRIBUTE:IOSet } ::= SET OF Attribute{{ IOSet }}
 *
 * CRIAttributes  ATTRIBUTE  ::= {
 *   ... -- add any locally defined attributes here -- }
 *
 * Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE {
 *   type   ATTRIBUTE.&id({IOSet}),
 *   values SET SIZE(1..MAX) OF ATTRIBUTE.&Type({IOSet}{@type})
 * }
 *
 * CertificationRequest ::= SEQUENCE {
 *   certificationRequestInfo CertificationRequestInfo,
 *   signatureAlgorithm AlgorithmIdentifier{{ SignatureAlgorithms }},
 *   signature          BIT STRING
 * }
 */
var forge = require('./forge');
require('./aes');
require('./asn1');
require('./des');
require('./md');
require('./mgf');
require('./oids');
require('./pem');
require('./pss');
require('./rsa');
require('./util');

// shortcut for asn.1 API
var asn1 = forge.asn1;

/* Public Key Infrastructure (PKI) implementation. */
var pki = module.exports = forge.pki = forge.pki || {};
var oids = pki.oids;

// short name OID mappings
var _shortNames = {};
_shortNames['CN'] = oids['commonName'];
_shortNames['commonName'] = 'CN';
_shortNames['C'] = oids['countryName'];
_shortNames['countryName'] = 'C';
_shortNames['L'] = oids['localityName'];
_shortNames['localityName'] = 'L';
_shortNames['ST'] = oids['stateOrProvinceName'];
_shortNames['stateOrProvinceName'] = 'ST';
_shortNames['O'] = oids['organizationName'];
_shortNames['organizationName'] = 'O';
_shortNames['OU'] = oids['organizationalUnitName'];
_shortNames['organizationalUnitName'] = 'OU';
_shortNames['E'] = oids['emailAddress'];
_shortNames['emailAddress'] = 'E';

// validator for an SubjectPublicKeyInfo structure
// Note: Currently only works with an RSA public key
var publicKeyValidator = forge.pki.rsa.publicKeyValidator;

// validator for an X.509v3 certificate
var x509CertificateValidator = {
  name: 'Certificate',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'Certificate.TBSCertificate',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    captureAsn1: 'tbsCertificate',
    value: [{
      name: 'Certificate.TBSCertificate.version',
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 0,
      constructed: true,
      optional: true,
      value: [{
        name: 'Certificate.TBSCertificate.version.integer',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'certVersion'
      }]
    }, {
      name: 'Certificate.TBSCertificate.serialNumber',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: 'certSerialNumber'
    }, {
      name: 'Certificate.TBSCertificate.signature',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'Certificate.TBSCertificate.signature.algorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'certinfoSignatureOid'
      }, {
        name: 'Certificate.TBSCertificate.signature.parameters',
        tagClass: asn1.Class.UNIVERSAL,
        optional: true,
        captureAsn1: 'certinfoSignatureParams'
      }]
    }, {
      name: 'Certificate.TBSCertificate.issuer',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: 'certIssuer'
    }, {
      name: 'Certificate.TBSCertificate.validity',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      // Note: UTC and generalized times may both appear so the capture
      // names are based on their detected order, the names used below
      // are only for the common case, which validity time really means
      // "notBefore" and which means "notAfter" will be determined by order
      value: [{
        // notBefore (Time) (UTC time case)
        name: 'Certificate.TBSCertificate.validity.notBefore (utc)',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.UTCTIME,
        constructed: false,
        optional: true,
        capture: 'certValidity1UTCTime'
      }, {
        // notBefore (Time) (generalized time case)
        name: 'Certificate.TBSCertificate.validity.notBefore (generalized)',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.GENERALIZEDTIME,
        constructed: false,
        optional: true,
        capture: 'certValidity2GeneralizedTime'
      }, {
        // notAfter (Time) (only UTC time is supported)
        name: 'Certificate.TBSCertificate.validity.notAfter (utc)',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.UTCTIME,
        constructed: false,
        optional: true,
        capture: 'certValidity3UTCTime'
      }, {
        // notAfter (Time) (only UTC time is supported)
        name: 'Certificate.TBSCertificate.validity.notAfter (generalized)',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.GENERALIZEDTIME,
        constructed: false,
        optional: true,
        capture: 'certValidity4GeneralizedTime'
      }]
    }, {
      // Name (subject) (RDNSequence)
      name: 'Certificate.TBSCertificate.subject',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: 'certSubject'
    },
    // SubjectPublicKeyInfo
    publicKeyValidator,
    {
      // issuerUniqueID (optional)
      name: 'Certificate.TBSCertificate.issuerUniqueID',
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 1,
      constructed: true,
      optional: true,
      value: [{
        name: 'Certificate.TBSCertificate.issuerUniqueID.id',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        // TODO: support arbitrary bit length ids
        captureBitStringValue: 'certIssuerUniqueId'
      }]
    }, {
      // subjectUniqueID (optional)
      name: 'Certificate.TBSCertificate.subjectUniqueID',
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 2,
      constructed: true,
      optional: true,
      value: [{
        name: 'Certificate.TBSCertificate.subjectUniqueID.id',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        // TODO: support arbitrary bit length ids
        captureBitStringValue: 'certSubjectUniqueId'
      }]
    }, {
      // Extensions (optional)
      name: 'Certificate.TBSCertificate.extensions',
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 3,
      constructed: true,
      captureAsn1: 'certExtensions',
      optional: true
    }]
  }, {
    // AlgorithmIdentifier (signature algorithm)
    name: 'Certificate.signatureAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      // algorithm
      name: 'Certificate.signatureAlgorithm.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'certSignatureOid'
    }, {
      name: 'Certificate.TBSCertificate.signature.parameters',
      tagClass: asn1.Class.UNIVERSAL,
      optional: true,
      captureAsn1: 'certSignatureParams'
    }]
  }, {
    // SignatureValue
    name: 'Certificate.signatureValue',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.BITSTRING,
    constructed: false,
    captureBitStringValue: 'certSignature'
  }]
};

var rsassaPssParameterValidator = {
  name: 'rsapss',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'rsapss.hashAlgorithm',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: true,
    value: [{
      name: 'rsapss.hashAlgorithm.AlgorithmIdentifier',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Class.SEQUENCE,
      constructed: true,
      optional: true,
      value: [{
        name: 'rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'hashOid'
        /* parameter block omitted, for SHA1 NULL anyhow. */
      }]
    }]
  }, {
    name: 'rsapss.maskGenAlgorithm',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 1,
    constructed: true,
    value: [{
      name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Class.SEQUENCE,
      constructed: true,
      optional: true,
      value: [{
        name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'maskGenOid'
      }, {
        name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'maskGenHashOid'
          /* parameter block omitted, for SHA1 NULL anyhow. */
        }]
      }]
    }]
  }, {
    name: 'rsapss.saltLength',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 2,
    optional: true,
    value: [{
      name: 'rsapss.saltLength.saltLength',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Class.INTEGER,
      constructed: false,
      capture: 'saltLength'
    }]
  }, {
    name: 'rsapss.trailerField',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 3,
    optional: true,
    value: [{
      name: 'rsapss.trailer.trailer',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Class.INTEGER,
      constructed: false,
      capture: 'trailer'
    }]
  }]
};

// validator for a CertificationRequestInfo structure
var certificationRequestInfoValidator = {
  name: 'CertificationRequestInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  captureAsn1: 'certificationRequestInfo',
  value: [{
    name: 'CertificationRequestInfo.integer',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'certificationRequestInfoVersion'
  }, {
    // Name (subject) (RDNSequence)
    name: 'CertificationRequestInfo.subject',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    captureAsn1: 'certificationRequestInfoSubject'
  },
  // SubjectPublicKeyInfo
  publicKeyValidator,
  {
    name: 'CertificationRequestInfo.attributes',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: true,
    optional: true,
    capture: 'certificationRequestInfoAttributes',
    value: [{
      name: 'CertificationRequestInfo.attributes',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'CertificationRequestInfo.attributes.type',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false
      }, {
        name: 'CertificationRequestInfo.attributes.value',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true
      }]
    }]
  }]
};

// validator for a CertificationRequest structure
var certificationRequestValidator = {
  name: 'CertificationRequest',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  captureAsn1: 'csr',
  value: [
    certificationRequestInfoValidator, {
      // AlgorithmIdentifier (signature algorithm)
      name: 'CertificationRequest.signatureAlgorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // algorithm
        name: 'CertificationRequest.signatureAlgorithm.algorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'csrSignatureOid'
      }, {
        name: 'CertificationRequest.signatureAlgorithm.parameters',
        tagClass: asn1.Class.UNIVERSAL,
        optional: true,
        captureAsn1: 'csrSignatureParams'
      }]
    }, {
      // signature
      name: 'CertificationRequest.signature',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.BITSTRING,
      constructed: false,
      captureBitStringValue: 'csrSignature'
    }
  ]
};

/**
 * Converts an RDNSequence of ASN.1 DER-encoded RelativeDistinguishedName
 * sets into an array with objects that have type and value properties.
 *
 * @param rdn the RDNSequence to convert.
 * @param md a message digest to append type and value to if provided.
 */
pki.RDNAttributesAsArray = function(rdn, md) {
  var rval = [];

  // each value in 'rdn' in is a SET of RelativeDistinguishedName
  var set, attr, obj;
  for(var si = 0; si < rdn.value.length; ++si) {
    // get the RelativeDistinguishedName set
    set = rdn.value[si];

    // each value in the SET is an AttributeTypeAndValue sequence
    // containing first a type (an OID) and second a value (defined by
    // the OID)
    for(var i = 0; i < set.value.length; ++i) {
      obj = {};
      attr = set.value[i];
      obj.type = asn1.derToOid(attr.value[0].value);
      obj.value = attr.value[1].value;
      obj.valueTagClass = attr.value[1].type;
      // if the OID is known, get its name and short name
      if(obj.type in oids) {
        obj.name = oids[obj.type];
        if(obj.name in _shortNames) {
          obj.shortName = _shortNames[obj.name];
        }
      }
      if(md) {
        md.update(obj.type);
        md.update(obj.value);
      }
      rval.push(obj);
    }
  }

  return rval;
};

/**
 * Converts ASN.1 CRIAttributes into an array with objects that have type and
 * value properties.
 *
 * @param attributes the CRIAttributes to convert.
 */
pki.CRIAttributesAsArray = function(attributes) {
  var rval = [];

  // each value in 'attributes' in is a SEQUENCE with an OID and a SET
  for(var si = 0; si < attributes.length; ++si) {
    // get the attribute sequence
    var seq = attributes[si];

    // each value in the SEQUENCE containing first a type (an OID) and
    // second a set of values (defined by the OID)
    var type = asn1.derToOid(seq.value[0].value);
    var values = seq.value[1].value;
    for(var vi = 0; vi < values.length; ++vi) {
      var obj = {};
      obj.type = type;
      obj.value = values[vi].value;
      obj.valueTagClass = values[vi].type;
      // if the OID is known, get its name and short name
      if(obj.type in oids) {
        obj.name = oids[obj.type];
        if(obj.name in _shortNames) {
          obj.shortName = _shortNames[obj.name];
        }
      }
      // parse extensions
      if(obj.type === oids.extensionRequest) {
        obj.extensions = [];
        for(var ei = 0; ei < obj.value.length; ++ei) {
          obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));
        }
      }
      rval.push(obj);
    }
  }

  return rval;
};

/**
 * Gets an issuer or subject attribute from its name, type, or short name.
 *
 * @param obj the issuer or subject object.
 * @param options a short name string or an object with:
 *          shortName the short name for the attribute.
 *          name the name for the attribute.
 *          type the type for the attribute.
 *
 * @return the attribute.
 */
function _getAttribute(obj, options) {
  if(typeof options === 'string') {
    options = {shortName: options};
  }

  var rval = null;
  var attr;
  for(var i = 0; rval === null && i < obj.attributes.length; ++i) {
    attr = obj.attributes[i];
    if(options.type && options.type === attr.type) {
      rval = attr;
    } else if(options.name && options.name === attr.name) {
      rval = attr;
    } else if(options.shortName && options.shortName === attr.shortName) {
      rval = attr;
    }
  }
  return rval;
}

/**
 * Converts signature parameters from ASN.1 structure.
 *
 * Currently only RSASSA-PSS supported.  The PKCS#1 v1.5 signature scheme had
 * no parameters.
 *
 * RSASSA-PSS-params  ::=  SEQUENCE  {
 *   hashAlgorithm      [0] HashAlgorithm DEFAULT
 *                             sha1Identifier,
 *   maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT
 *                             mgf1SHA1Identifier,
 *   saltLength         [2] INTEGER DEFAULT 20,
 *   trailerField       [3] INTEGER DEFAULT 1
 * }
 *
 * HashAlgorithm  ::=  AlgorithmIdentifier
 *
 * MaskGenAlgorithm  ::=  AlgorithmIdentifier
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *   algorithm OBJECT IDENTIFIER,
 *   parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * @param oid The OID specifying the signature algorithm
 * @param obj The ASN.1 structure holding the parameters
 * @param fillDefaults Whether to use return default values where omitted
 * @return signature parameter object
 */
var _readSignatureParameters = function(oid, obj, fillDefaults) {
  var params = {};

  if(oid !== oids['RSASSA-PSS']) {
    return params;
  }

  if(fillDefaults) {
    params = {
      hash: {
        algorithmOid: oids['sha1']
      },
      mgf: {
        algorithmOid: oids['mgf1'],
        hash: {
          algorithmOid: oids['sha1']
        }
      },
      saltLength: 20
    };
  }

  var capture = {};
  var errors = [];
  if(!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {
    var error = new Error('Cannot read RSASSA-PSS parameter block.');
    error.errors = errors;
    throw error;
  }

  if(capture.hashOid !== undefined) {
    params.hash = params.hash || {};
    params.hash.algorithmOid = asn1.derToOid(capture.hashOid);
  }

  if(capture.maskGenOid !== undefined) {
    params.mgf = params.mgf || {};
    params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);
    params.mgf.hash = params.mgf.hash || {};
    params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);
  }

  if(capture.saltLength !== undefined) {
    params.saltLength = capture.saltLength.charCodeAt(0);
  }

  return params;
};

/**
 * Create signature digest for OID.
 *
 * @param options
 *   signatureOid: the OID specifying the signature algorithm.
 *   type: a human readable type for error messages
 * @return a created md instance. throws if unknown oid.
 */
var _createSignatureDigest = function(options) {
  switch(oids[options.signatureOid]) {
    case 'sha1WithRSAEncryption':
    // deprecated alias
    case 'sha1WithRSASignature':
      return forge.md.sha1.create();
    case 'md5WithRSAEncryption':
      return forge.md.md5.create();
    case 'sha256WithRSAEncryption':
      return forge.md.sha256.create();
    case 'sha384WithRSAEncryption':
      return forge.md.sha384.create();
    case 'sha512WithRSAEncryption':
      return forge.md.sha512.create();
    case 'RSASSA-PSS':
      return forge.md.sha256.create();
    default:
      var error = new Error(
        'Could not compute ' + options.type + ' digest. ' +
        'Unknown signature OID.');
      error.signatureOid = options.signatureOid;
      throw error;
  }
};

/**
 * Verify signature on certificate or CSR.
 *
 * @param options:
 *   certificate the certificate or CSR to verify.
 *   md the signature digest.
 *   signature the signature
 * @return a created md instance. throws if unknown oid.
 */
var _verifySignature = function(options) {
  var cert = options.certificate;
  var scheme;

  switch(cert.signatureOid) {
    case oids.sha1WithRSAEncryption:
    // deprecated alias
    case oids.sha1WithRSASignature:
      /* use PKCS#1 v1.5 padding scheme */
      break;
    case oids['RSASSA-PSS']:
      var hash, mgf;

      /* initialize mgf */
      hash = oids[cert.signatureParameters.mgf.hash.algorithmOid];
      if(hash === undefined || forge.md[hash] === undefined) {
        var error = new Error('Unsupported MGF hash function.');
        error.oid = cert.signatureParameters.mgf.hash.algorithmOid;
        error.name = hash;
        throw error;
      }

      mgf = oids[cert.signatureParameters.mgf.algorithmOid];
      if(mgf === undefined || forge.mgf[mgf] === undefined) {
        var error = new Error('Unsupported MGF function.');
        error.oid = cert.signatureParameters.mgf.algorithmOid;
        error.name = mgf;
        throw error;
      }

      mgf = forge.mgf[mgf].create(forge.md[hash].create());

      /* initialize hash function */
      hash = oids[cert.signatureParameters.hash.algorithmOid];
      if(hash === undefined || forge.md[hash] === undefined) {
        var error = new Error('Unsupported RSASSA-PSS hash function.');
        error.oid = cert.signatureParameters.hash.algorithmOid;
        error.name = hash;
        throw error;
      }

      scheme = forge.pss.create(
        forge.md[hash].create(), mgf, cert.signatureParameters.saltLength
      );
      break;
  }

  // verify signature on cert using public key
  return cert.publicKey.verify(
    options.md.digest().getBytes(), options.signature, scheme
  );
};

/**
 * Converts an X.509 certificate from PEM format.
 *
 * Note: If the certificate is to be verified then compute hash should
 * be set to true. This will scan the TBSCertificate part of the ASN.1
 * object while it is converted so it doesn't need to be converted back
 * to ASN.1-DER-encoding later.
 *
 * @param pem the PEM-formatted certificate.
 * @param computeHash true to compute the hash for verification.
 * @param strict true to be strict when checking ASN.1 value lengths, false to
 *          allow truncated values (default: true).
 *
 * @return the certificate.
 */
pki.certificateFromPem = function(pem, computeHash, strict) {
  var msg = forge.pem.decode(pem)[0];

  if(msg.type !== 'CERTIFICATE' &&
    msg.type !== 'X509 CERTIFICATE' &&
    msg.type !== 'TRUSTED CERTIFICATE') {
    var error = new Error(
      'Could not convert certificate from PEM; PEM header type ' +
      'is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
    error.headerType = msg.type;
    throw error;
  }
  if(msg.procType && msg.procType.type === 'ENCRYPTED') {
    throw new Error(
      'Could not convert certificate from PEM; PEM is encrypted.');
  }

  // convert DER to ASN.1 object
  var obj = asn1.fromDer(msg.body, strict);

  return pki.certificateFromAsn1(obj, computeHash);
};

/**
 * Converts an X.509 certificate to PEM format.
 *
 * @param cert the certificate.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted certificate.
 */
pki.certificateToPem = function(cert, maxline) {
  // convert to ASN.1, then DER, then PEM-encode
  var msg = {
    type: 'CERTIFICATE',
    body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes()
  };
  return forge.pem.encode(msg, {maxline: maxline});
};

/**
 * Converts an RSA public key from PEM format.
 *
 * @param pem the PEM-formatted public key.
 *
 * @return the public key.
 */
pki.publicKeyFromPem = function(pem) {
  var msg = forge.pem.decode(pem)[0];

  if(msg.type !== 'PUBLIC KEY' && msg.type !== 'RSA PUBLIC KEY') {
    var error = new Error('Could not convert public key from PEM; PEM header ' +
      'type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
    error.headerType = msg.type;
    throw error;
  }
  if(msg.procType && msg.procType.type === 'ENCRYPTED') {
    throw new Error('Could not convert public key from PEM; PEM is encrypted.');
  }

  // convert DER to ASN.1 object
  var obj = asn1.fromDer(msg.body);

  return pki.publicKeyFromAsn1(obj);
};

/**
 * Converts an RSA public key to PEM format (using a SubjectPublicKeyInfo).
 *
 * @param key the public key.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted public key.
 */
pki.publicKeyToPem = function(key, maxline) {
  // convert to ASN.1, then DER, then PEM-encode
  var msg = {
    type: 'PUBLIC KEY',
    body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()
  };
  return forge.pem.encode(msg, {maxline: maxline});
};

/**
 * Converts an RSA public key to PEM format (using an RSAPublicKey).
 *
 * @param key the public key.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted public key.
 */
pki.publicKeyToRSAPublicKeyPem = function(key, maxline) {
  // convert to ASN.1, then DER, then PEM-encode
  var msg = {
    type: 'RSA PUBLIC KEY',
    body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()
  };
  return forge.pem.encode(msg, {maxline: maxline});
};

/**
 * Gets a fingerprint for the given public key.
 *
 * @param options the options to use.
 *          [md] the message digest object to use (defaults to forge.md.sha1).
 *          [type] the type of fingerprint, such as 'RSAPublicKey',
 *            'SubjectPublicKeyInfo' (defaults to 'RSAPublicKey').
 *          [encoding] an alternative output encoding, such as 'hex'
 *            (defaults to none, outputs a byte buffer).
 *          [delimiter] the delimiter to use between bytes for 'hex' encoded
 *            output, eg: ':' (defaults to none).
 *
 * @return the fingerprint as a byte buffer or other encoding based on options.
 */
pki.getPublicKeyFingerprint = function(key, options) {
  options = options || {};
  var md = options.md || forge.md.sha1.create();
  var type = options.type || 'RSAPublicKey';

  var bytes;
  switch(type) {
    case 'RSAPublicKey':
      bytes = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();
      break;
    case 'SubjectPublicKeyInfo':
      bytes = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();
      break;
    default:
      throw new Error('Unknown fingerprint type "' + options.type + '".');
  }

  // hash public key bytes
  md.start();
  md.update(bytes);
  var digest = md.digest();
  if(options.encoding === 'hex') {
    var hex = digest.toHex();
    if(options.delimiter) {
      return hex.match(/.{2}/g).join(options.delimiter);
    }
    return hex;
  } else if(options.encoding === 'binary') {
    return digest.getBytes();
  } else if(options.encoding) {
    throw new Error('Unknown encoding "' + options.encoding + '".');
  }
  return digest;
};

/**
 * Converts a PKCS#10 certification request (CSR) from PEM format.
 *
 * Note: If the certification request is to be verified then compute hash
 * should be set to true. This will scan the CertificationRequestInfo part of
 * the ASN.1 object while it is converted so it doesn't need to be converted
 * back to ASN.1-DER-encoding later.
 *
 * @param pem the PEM-formatted certificate.
 * @param computeHash true to compute the hash for verification.
 * @param strict true to be strict when checking ASN.1 value lengths, false to
 *          allow truncated values (default: true).
 *
 * @return the certification request (CSR).
 */
pki.certificationRequestFromPem = function(pem, computeHash, strict) {
  var msg = forge.pem.decode(pem)[0];

  if(msg.type !== 'CERTIFICATE REQUEST') {
    var error = new Error('Could not convert certification request from PEM; ' +
      'PEM header type is not "CERTIFICATE REQUEST".');
    error.headerType = msg.type;
    throw error;
  }
  if(msg.procType && msg.procType.type === 'ENCRYPTED') {
    throw new Error('Could not convert certification request from PEM; ' +
      'PEM is encrypted.');
  }

  // convert DER to ASN.1 object
  var obj = asn1.fromDer(msg.body, strict);

  return pki.certificationRequestFromAsn1(obj, computeHash);
};

/**
 * Converts a PKCS#10 certification request (CSR) to PEM format.
 *
 * @param csr the certification request.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted certification request.
 */
pki.certificationRequestToPem = function(csr, maxline) {
  // convert to ASN.1, then DER, then PEM-encode
  var msg = {
    type: 'CERTIFICATE REQUEST',
    body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()
  };
  return forge.pem.encode(msg, {maxline: maxline});
};

/**
 * Creates an empty X.509v3 RSA certificate.
 *
 * @return the certificate.
 */
pki.createCertificate = function() {
  var cert = {};
  cert.version = 0x02;
  cert.serialNumber = '00';
  cert.signatureOid = null;
  cert.signature = null;
  cert.siginfo = {};
  cert.siginfo.algorithmOid = null;
  cert.validity = {};
  cert.validity.notBefore = new Date();
  cert.validity.notAfter = new Date();

  cert.issuer = {};
  cert.issuer.getField = function(sn) {
    return _getAttribute(cert.issuer, sn);
  };
  cert.issuer.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.issuer.attributes.push(attr);
  };
  cert.issuer.attributes = [];
  cert.issuer.hash = null;

  cert.subject = {};
  cert.subject.getField = function(sn) {
    return _getAttribute(cert.subject, sn);
  };
  cert.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.subject.attributes.push(attr);
  };
  cert.subject.attributes = [];
  cert.subject.hash = null;

  cert.extensions = [];
  cert.publicKey = null;
  cert.md = null;

  /**
   * Sets the subject of this certificate.
   *
   * @param attrs the array of subject attributes to use.
   * @param uniqueId an optional a unique ID to use.
   */
  cert.setSubject = function(attrs, uniqueId) {
    // set new attributes, clear hash
    _fillMissingFields(attrs);
    cert.subject.attributes = attrs;
    delete cert.subject.uniqueId;
    if(uniqueId) {
      // TODO: support arbitrary bit length ids
      cert.subject.uniqueId = uniqueId;
    }
    cert.subject.hash = null;
  };

  /**
   * Sets the issuer of this certificate.
   *
   * @param attrs the array of issuer attributes to use.
   * @param uniqueId an optional a unique ID to use.
   */
  cert.setIssuer = function(attrs, uniqueId) {
    // set new attributes, clear hash
    _fillMissingFields(attrs);
    cert.issuer.attributes = attrs;
    delete cert.issuer.uniqueId;
    if(uniqueId) {
      // TODO: support arbitrary bit length ids
      cert.issuer.uniqueId = uniqueId;
    }
    cert.issuer.hash = null;
  };

  /**
   * Sets the extensions of this certificate.
   *
   * @param exts the array of extensions to use.
   */
  cert.setExtensions = function(exts) {
    for(var i = 0; i < exts.length; ++i) {
      _fillMissingExtensionFields(exts[i], {cert: cert});
    }
    // set new extensions
    cert.extensions = exts;
  };

  /**
   * Gets an extension by its name or id.
   *
   * @param options the name to use or an object with:
   *          name the name to use.
   *          id the id to use.
   *
   * @return the extension or null if not found.
   */
  cert.getExtension = function(options) {
    if(typeof options === 'string') {
      options = {name: options};
    }

    var rval = null;
    var ext;
    for(var i = 0; rval === null && i < cert.extensions.length; ++i) {
      ext = cert.extensions[i];
      if(options.id && ext.id === options.id) {
        rval = ext;
      } else if(options.name && ext.name === options.name) {
        rval = ext;
      }
    }
    return rval;
  };

  /**
   * Signs this certificate using the given private key.
   *
   * @param key the private key to sign with.
   * @param md the message digest object to use (defaults to forge.md.sha1).
   */
  cert.sign = function(key, md) {
    // TODO: get signature OID from private key
    cert.md = md || forge.md.sha1.create();
    var algorithmOid = oids[cert.md.algorithm + 'WithRSAEncryption'];
    if(!algorithmOid) {
      var error = new Error('Could not compute certificate digest. ' +
        'Unknown message digest algorithm OID.');
      error.algorithm = cert.md.algorithm;
      throw error;
    }
    cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;

    // get TBSCertificate, convert to DER
    cert.tbsCertificate = pki.getTBSCertificate(cert);
    var bytes = asn1.toDer(cert.tbsCertificate);

    // digest and sign
    cert.md.update(bytes.getBytes());
    cert.signature = key.sign(cert.md);
  };

  /**
   * Attempts verify the signature on the passed certificate using this
   * certificate's public key.
   *
   * @param child the certificate to verify.
   *
   * @return true if verified, false if not.
   */
  cert.verify = function(child) {
    var rval = false;

    if(!cert.issued(child)) {
      var issuer = child.issuer;
      var subject = cert.subject;
      var error = new Error(
        'The parent certificate did not issue the given child ' +
        'certificate; the child certificate\'s issuer does not match the ' +
        'parent\'s subject.');
      error.expectedIssuer = subject.attributes;
      error.actualIssuer = issuer.attributes;
      throw error;
    }

    var md = child.md;
    if(md === null) {
      // create digest for OID signature types
      md = _createSignatureDigest({
        signatureOid: child.signatureOid,
        type: 'certificate'
      });

      // produce DER formatted TBSCertificate and digest it
      var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child);
      var bytes = asn1.toDer(tbsCertificate);
      md.update(bytes.getBytes());
    }

    if(md !== null) {
      rval = _verifySignature({
        certificate: cert, md: md, signature: child.signature
      });
    }

    return rval;
  };

  /**
   * Returns true if this certificate's issuer matches the passed
   * certificate's subject. Note that no signature check is performed.
   *
   * @param parent the certificate to check.
   *
   * @return true if this certificate's issuer matches the passed certificate's
   *         subject.
   */
  cert.isIssuer = function(parent) {
    var rval = false;

    var i = cert.issuer;
    var s = parent.subject;

    // compare hashes if present
    if(i.hash && s.hash) {
      rval = (i.hash === s.hash);
    } else if(i.attributes.length === s.attributes.length) {
      // all attributes are the same so issuer matches subject
      rval = true;
      var iattr, sattr;
      for(var n = 0; rval && n < i.attributes.length; ++n) {
        iattr = i.attributes[n];
        sattr = s.attributes[n];
        if(iattr.type !== sattr.type || iattr.value !== sattr.value) {
          // attribute mismatch
          rval = false;
        }
      }
    }

    return rval;
  };

  /**
   * Returns true if this certificate's subject matches the issuer of the
   * given certificate). Note that not signature check is performed.
   *
   * @param child the certificate to check.
   *
   * @return true if this certificate's subject matches the passed
   *         certificate's issuer.
   */
  cert.issued = function(child) {
    return child.isIssuer(cert);
  };

  /**
   * Generates the subjectKeyIdentifier for this certificate as byte buffer.
   *
   * @return the subjectKeyIdentifier for this certificate as byte buffer.
   */
  cert.generateSubjectKeyIdentifier = function() {
    /* See: 4.2.1.2 section of the the RFC3280, keyIdentifier is either:

      (1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the
        value of the BIT STRING subjectPublicKey (excluding the tag,
        length, and number of unused bits).

      (2) The keyIdentifier is composed of a four bit type field with
        the value 0100 followed by the least significant 60 bits of the
        SHA-1 hash of the value of the BIT STRING subjectPublicKey
        (excluding the tag, length, and number of unused bit string bits).
    */

    // skipping the tag, length, and number of unused bits is the same
    // as just using the RSAPublicKey (for RSA keys, which are the
    // only ones supported)
    return pki.getPublicKeyFingerprint(cert.publicKey, {type: 'RSAPublicKey'});
  };

  /**
   * Verifies the subjectKeyIdentifier extension value for this certificate
   * against its public key. If no extension is found, false will be
   * returned.
   *
   * @return true if verified, false if not.
   */
  cert.verifySubjectKeyIdentifier = function() {
    var oid = oids['subjectKeyIdentifier'];
    for(var i = 0; i < cert.extensions.length; ++i) {
      var ext = cert.extensions[i];
      if(ext.id === oid) {
        var ski = cert.generateSubjectKeyIdentifier().getBytes();
        return (forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski);
      }
    }
    return false;
  };

  return cert;
};

/**
 * Converts an X.509v3 RSA certificate from an ASN.1 object.
 *
 * Note: If the certificate is to be verified then compute hash should
 * be set to true. There is currently no implementation for converting
 * a certificate back to ASN.1 so the TBSCertificate part of the ASN.1
 * object needs to be scanned before the cert object is created.
 *
 * @param obj the asn1 representation of an X.509v3 RSA certificate.
 * @param computeHash true to compute the hash for verification.
 *
 * @return the certificate.
 */
pki.certificateFromAsn1 = function(obj, computeHash) {
  // validate certificate and capture data
  var capture = {};
  var errors = [];
  if(!asn1.validate(obj, x509CertificateValidator, capture, errors)) {
    var error = new Error('Cannot read X.509 certificate. ' +
      'ASN.1 object is not an X509v3 Certificate.');
    error.errors = errors;
    throw error;
  }

  // get oid
  var oid = asn1.derToOid(capture.publicKeyOid);
  if(oid !== pki.oids.rsaEncryption) {
    throw new Error('Cannot read public key. OID is not RSA.');
  }

  // create certificate
  var cert = pki.createCertificate();
  cert.version = capture.certVersion ?
    capture.certVersion.charCodeAt(0) : 0;
  var serial = forge.util.createBuffer(capture.certSerialNumber);
  cert.serialNumber = serial.toHex();
  cert.signatureOid = forge.asn1.derToOid(capture.certSignatureOid);
  cert.signatureParameters = _readSignatureParameters(
    cert.signatureOid, capture.certSignatureParams, true);
  cert.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid);
  cert.siginfo.parameters = _readSignatureParameters(cert.siginfo.algorithmOid,
    capture.certinfoSignatureParams, false);
  cert.signature = capture.certSignature;

  var validity = [];
  if(capture.certValidity1UTCTime !== undefined) {
    validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
  }
  if(capture.certValidity2GeneralizedTime !== undefined) {
    validity.push(asn1.generalizedTimeToDate(
      capture.certValidity2GeneralizedTime));
  }
  if(capture.certValidity3UTCTime !== undefined) {
    validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
  }
  if(capture.certValidity4GeneralizedTime !== undefined) {
    validity.push(asn1.generalizedTimeToDate(
      capture.certValidity4GeneralizedTime));
  }
  if(validity.length > 2) {
    throw new Error('Cannot read notBefore/notAfter validity times; more ' +
      'than two times were provided in the certificate.');
  }
  if(validity.length < 2) {
    throw new Error('Cannot read notBefore/notAfter validity times; they ' +
      'were not provided as either UTCTime or GeneralizedTime.');
  }
  cert.validity.notBefore = validity[0];
  cert.validity.notAfter = validity[1];

  // keep TBSCertificate to preserve signature when exporting
  cert.tbsCertificate = capture.tbsCertificate;

  if(computeHash) {
    // create digest for OID signature type
    cert.md = _createSignatureDigest({
      signatureOid: cert.signatureOid,
      type: 'certificate'
    });

    // produce DER formatted TBSCertificate and digest it
    var bytes = asn1.toDer(cert.tbsCertificate);
    cert.md.update(bytes.getBytes());
  }

  // handle issuer, build issuer message digest
  var imd = forge.md.sha1.create();
  var ibytes = asn1.toDer(capture.certIssuer);
  imd.update(ibytes.getBytes());
  cert.issuer.getField = function(sn) {
    return _getAttribute(cert.issuer, sn);
  };
  cert.issuer.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.issuer.attributes.push(attr);
  };
  cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer);
  if(capture.certIssuerUniqueId) {
    cert.issuer.uniqueId = capture.certIssuerUniqueId;
  }
  cert.issuer.hash = imd.digest().toHex();

  // handle subject, build subject message digest
  var smd = forge.md.sha1.create();
  var sbytes = asn1.toDer(capture.certSubject);
  smd.update(sbytes.getBytes());
  cert.subject.getField = function(sn) {
    return _getAttribute(cert.subject, sn);
  };
  cert.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.subject.attributes.push(attr);
  };
  cert.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject);
  if(capture.certSubjectUniqueId) {
    cert.subject.uniqueId = capture.certSubjectUniqueId;
  }
  cert.subject.hash = smd.digest().toHex();

  // handle extensions
  if(capture.certExtensions) {
    cert.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions);
  } else {
    cert.extensions = [];
  }

  // convert RSA public key from ASN.1
  cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);

  return cert;
};

/**
 * Converts an ASN.1 extensions object (with extension sequences as its
 * values) into an array of extension objects with types and values.
 *
 * Supported extensions:
 *
 * id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }
 * KeyUsage ::= BIT STRING {
 *   digitalSignature        (0),
 *   nonRepudiation          (1),
 *   keyEncipherment         (2),
 *   dataEncipherment        (3),
 *   keyAgreement            (4),
 *   keyCertSign             (5),
 *   cRLSign                 (6),
 *   encipherOnly            (7),
 *   decipherOnly            (8)
 * }
 *
 * id-ce-basicConstraints OBJECT IDENTIFIER ::=  { id-ce 19 }
 * BasicConstraints ::= SEQUENCE {
 *   cA                      BOOLEAN DEFAULT FALSE,
 *   pathLenConstraint       INTEGER (0..MAX) OPTIONAL
 * }
 *
 * subjectAltName EXTENSION ::= {
 *   SYNTAX GeneralNames
 *   IDENTIFIED BY id-ce-subjectAltName
 * }
 *
 * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName
 *
 * GeneralName ::= CHOICE {
 *   otherName      [0] INSTANCE OF OTHER-NAME,
 *   rfc822Name     [1] IA5String,
 *   dNSName        [2] IA5String,
 *   x400Address    [3] ORAddress,
 *   directoryName  [4] Name,
 *   ediPartyName   [5] EDIPartyName,
 *   uniformResourceIdentifier [6] IA5String,
 *   IPAddress      [7] OCTET STRING,
 *   registeredID   [8] OBJECT IDENTIFIER
 * }
 *
 * OTHER-NAME ::= TYPE-IDENTIFIER
 *
 * EDIPartyName ::= SEQUENCE {
 *   nameAssigner [0] DirectoryString {ub-name} OPTIONAL,
 *   partyName    [1] DirectoryString {ub-name}
 * }
 *
 * @param exts the extensions ASN.1 with extension sequences to parse.
 *
 * @return the array.
 */
pki.certificateExtensionsFromAsn1 = function(exts) {
  var rval = [];
  for(var i = 0; i < exts.value.length; ++i) {
    // get extension sequence
    var extseq = exts.value[i];
    for(var ei = 0; ei < extseq.value.length; ++ei) {
      rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));
    }
  }

  return rval;
};

/**
 * Parses a single certificate extension from ASN.1.
 *
 * @param ext the extension in ASN.1 format.
 *
 * @return the parsed extension as an object.
 */
pki.certificateExtensionFromAsn1 = function(ext) {
  // an extension has:
  // [0] extnID      OBJECT IDENTIFIER
  // [1] critical    BOOLEAN DEFAULT FALSE
  // [2] extnValue   OCTET STRING
  var e = {};
  e.id = asn1.derToOid(ext.value[0].value);
  e.critical = false;
  if(ext.value[1].type === asn1.Type.BOOLEAN) {
    e.critical = (ext.value[1].value.charCodeAt(0) !== 0x00);
    e.value = ext.value[2].value;
  } else {
    e.value = ext.value[1].value;
  }
  // if the oid is known, get its name
  if(e.id in oids) {
    e.name = oids[e.id];

    // handle key usage
    if(e.name === 'keyUsage') {
      // get value as BIT STRING
      var ev = asn1.fromDer(e.value);
      var b2 = 0x00;
      var b3 = 0x00;
      if(ev.value.length > 1) {
        // skip first byte, just indicates unused bits which
        // will be padded with 0s anyway
        // get bytes with flag bits
        b2 = ev.value.charCodeAt(1);
        b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
      }
      // set flags
      e.digitalSignature = (b2 & 0x80) === 0x80;
      e.nonRepudiation = (b2 & 0x40) === 0x40;
      e.keyEncipherment = (b2 & 0x20) === 0x20;
      e.dataEncipherment = (b2 & 0x10) === 0x10;
      e.keyAgreement = (b2 & 0x08) === 0x08;
      e.keyCertSign = (b2 & 0x04) === 0x04;
      e.cRLSign = (b2 & 0x02) === 0x02;
      e.encipherOnly = (b2 & 0x01) === 0x01;
      e.decipherOnly = (b3 & 0x80) === 0x80;
    } else if(e.name === 'basicConstraints') {
      // handle basic constraints
      // get value as SEQUENCE
      var ev = asn1.fromDer(e.value);
      // get cA BOOLEAN flag (defaults to false)
      if(ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {
        e.cA = (ev.value[0].value.charCodeAt(0) !== 0x00);
      } else {
        e.cA = false;
      }
      // get path length constraint
      var value = null;
      if(ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {
        value = ev.value[0].value;
      } else if(ev.value.length > 1) {
        value = ev.value[1].value;
      }
      if(value !== null) {
        e.pathLenConstraint = asn1.derToInteger(value);
      }
    } else if(e.name === 'extKeyUsage') {
      // handle extKeyUsage
      // value is a SEQUENCE of OIDs
      var ev = asn1.fromDer(e.value);
      for(var vi = 0; vi < ev.value.length; ++vi) {
        var oid = asn1.derToOid(ev.value[vi].value);
        if(oid in oids) {
          e[oids[oid]] = true;
        } else {
          e[oid] = true;
        }
      }
    } else if(e.name === 'nsCertType') {
      // handle nsCertType
      // get value as BIT STRING
      var ev = asn1.fromDer(e.value);
      var b2 = 0x00;
      if(ev.value.length > 1) {
        // skip first byte, just indicates unused bits which
        // will be padded with 0s anyway
        // get bytes with flag bits
        b2 = ev.value.charCodeAt(1);
      }
      // set flags
      e.client = (b2 & 0x80) === 0x80;
      e.server = (b2 & 0x40) === 0x40;
      e.email = (b2 & 0x20) === 0x20;
      e.objsign = (b2 & 0x10) === 0x10;
      e.reserved = (b2 & 0x08) === 0x08;
      e.sslCA = (b2 & 0x04) === 0x04;
      e.emailCA = (b2 & 0x02) === 0x02;
      e.objCA = (b2 & 0x01) === 0x01;
    } else if(
      e.name === 'subjectAltName' ||
      e.name === 'issuerAltName') {
      // handle subjectAltName/issuerAltName
      e.altNames = [];

      // ev is a SYNTAX SEQUENCE
      var gn;
      var ev = asn1.fromDer(e.value);
      for(var n = 0; n < ev.value.length; ++n) {
        // get GeneralName
        gn = ev.value[n];

        var altName = {
          type: gn.type,
          value: gn.value
        };
        e.altNames.push(altName);

        // Note: Support for types 1,2,6,7,8
        switch(gn.type) {
          // rfc822Name
          case 1:
          // dNSName
          case 2:
          // uniformResourceIdentifier (URI)
          case 6:
            break;
          // IPAddress
          case 7:
            // convert to IPv4/IPv6 string representation
            altName.ip = forge.util.bytesToIP(gn.value);
            break;
          // registeredID
          case 8:
            altName.oid = asn1.derToOid(gn.value);
            break;
          default:
            // unsupported
        }
      }
    } else if(e.name === 'subjectKeyIdentifier') {
      // value is an OCTETSTRING w/the hash of the key-type specific
      // public key structure (eg: RSAPublicKey)
      var ev = asn1.fromDer(e.value);
      e.subjectKeyIdentifier = forge.util.bytesToHex(ev.value);
    }
  }
  return e;
};

/**
 * Converts a PKCS#10 certification request (CSR) from an ASN.1 object.
 *
 * Note: If the certification request is to be verified then compute hash
 * should be set to true. There is currently no implementation for converting
 * a certificate back to ASN.1 so the CertificationRequestInfo part of the
 * ASN.1 object needs to be scanned before the csr object is created.
 *
 * @param obj the asn1 representation of a PKCS#10 certification request (CSR).
 * @param computeHash true to compute the hash for verification.
 *
 * @return the certification request (CSR).
 */
pki.certificationRequestFromAsn1 = function(obj, computeHash) {
  // validate certification request and capture data
  var capture = {};
  var errors = [];
  if(!asn1.validate(obj, certificationRequestValidator, capture, errors)) {
    var error = new Error('Cannot read PKCS#10 certificate request. ' +
      'ASN.1 object is not a PKCS#10 CertificationRequest.');
    error.errors = errors;
    throw error;
  }

  // get oid
  var oid = asn1.derToOid(capture.publicKeyOid);
  if(oid !== pki.oids.rsaEncryption) {
    throw new Error('Cannot read public key. OID is not RSA.');
  }

  // create certification request
  var csr = pki.createCertificationRequest();
  csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
  csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid);
  csr.signatureParameters = _readSignatureParameters(
    csr.signatureOid, capture.csrSignatureParams, true);
  csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid);
  csr.siginfo.parameters = _readSignatureParameters(
    csr.siginfo.algorithmOid, capture.csrSignatureParams, false);
  csr.signature = capture.csrSignature;

  // keep CertificationRequestInfo to preserve signature when exporting
  csr.certificationRequestInfo = capture.certificationRequestInfo;

  if(computeHash) {
    // create digest for OID signature type
    csr.md = _createSignatureDigest({
      signatureOid: csr.signatureOid,
      type: 'certification request'
    });

    // produce DER formatted CertificationRequestInfo and digest it
    var bytes = asn1.toDer(csr.certificationRequestInfo);
    csr.md.update(bytes.getBytes());
  }

  // handle subject, build subject message digest
  var smd = forge.md.sha1.create();
  csr.subject.getField = function(sn) {
    return _getAttribute(csr.subject, sn);
  };
  csr.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    csr.subject.attributes.push(attr);
  };
  csr.subject.attributes = pki.RDNAttributesAsArray(
    capture.certificationRequestInfoSubject, smd);
  csr.subject.hash = smd.digest().toHex();

  // convert RSA public key from ASN.1
  csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);

  // convert attributes from ASN.1
  csr.getAttribute = function(sn) {
    return _getAttribute(csr, sn);
  };
  csr.addAttribute = function(attr) {
    _fillMissingFields([attr]);
    csr.attributes.push(attr);
  };
  csr.attributes = pki.CRIAttributesAsArray(
    capture.certificationRequestInfoAttributes || []);

  return csr;
};

/**
 * Creates an empty certification request (a CSR or certificate signing
 * request). Once created, its public key and attributes can be set and then
 * it can be signed.
 *
 * @return the empty certification request.
 */
pki.createCertificationRequest = function() {
  var csr = {};
  csr.version = 0x00;
  csr.signatureOid = null;
  csr.signature = null;
  csr.siginfo = {};
  csr.siginfo.algorithmOid = null;

  csr.subject = {};
  csr.subject.getField = function(sn) {
    return _getAttribute(csr.subject, sn);
  };
  csr.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    csr.subject.attributes.push(attr);
  };
  csr.subject.attributes = [];
  csr.subject.hash = null;

  csr.publicKey = null;
  csr.attributes = [];
  csr.getAttribute = function(sn) {
    return _getAttribute(csr, sn);
  };
  csr.addAttribute = function(attr) {
    _fillMissingFields([attr]);
    csr.attributes.push(attr);
  };
  csr.md = null;

  /**
   * Sets the subject of this certification request.
   *
   * @param attrs the array of subject attributes to use.
   */
  csr.setSubject = function(attrs) {
    // set new attributes
    _fillMissingFields(attrs);
    csr.subject.attributes = attrs;
    csr.subject.hash = null;
  };

  /**
   * Sets the attributes of this certification request.
   *
   * @param attrs the array of attributes to use.
   */
  csr.setAttributes = function(attrs) {
    // set new attributes
    _fillMissingFields(attrs);
    csr.attributes = attrs;
  };

  /**
   * Signs this certification request using the given private key.
   *
   * @param key the private key to sign with.
   * @param md the message digest object to use (defaults to forge.md.sha1).
   */
  csr.sign = function(key, md) {
    // TODO: get signature OID from private key
    csr.md = md || forge.md.sha1.create();
    var algorithmOid = oids[csr.md.algorithm + 'WithRSAEncryption'];
    if(!algorithmOid) {
      var error = new Error('Could not compute certification request digest. ' +
        'Unknown message digest algorithm OID.');
      error.algorithm = csr.md.algorithm;
      throw error;
    }
    csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;

    // get CertificationRequestInfo, convert to DER
    csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);
    var bytes = asn1.toDer(csr.certificationRequestInfo);

    // digest and sign
    csr.md.update(bytes.getBytes());
    csr.signature = key.sign(csr.md);
  };

  /**
   * Attempts verify the signature on the passed certification request using
   * its public key.
   *
   * A CSR that has been exported to a file in PEM format can be verified using
   * OpenSSL using this command:
   *
   * openssl req -in <the-csr-pem-file> -verify -noout -text
   *
   * @return true if verified, false if not.
   */
  csr.verify = function() {
    var rval = false;

    var md = csr.md;
    if(md === null) {
      md = _createSignatureDigest({
        signatureOid: csr.signatureOid,
        type: 'certification request'
      });

      // produce DER formatted CertificationRequestInfo and digest it
      var cri = csr.certificationRequestInfo ||
        pki.getCertificationRequestInfo(csr);
      var bytes = asn1.toDer(cri);
      md.update(bytes.getBytes());
    }

    if(md !== null) {
      rval = _verifySignature({
        certificate: csr, md: md, signature: csr.signature
      });
    }

    return rval;
  };

  return csr;
};

/**
 * Converts an X.509 subject or issuer to an ASN.1 RDNSequence.
 *
 * @param obj the subject or issuer (distinguished name).
 *
 * @return the ASN.1 RDNSequence.
 */
function _dnToAsn1(obj) {
  // create an empty RDNSequence
  var rval = asn1.create(
    asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);

  // iterate over attributes
  var attr, set;
  var attrs = obj.attributes;
  for(var i = 0; i < attrs.length; ++i) {
    attr = attrs[i];
    var value = attr.value;

    // reuse tag class for attribute value if available
    var valueTagClass = asn1.Type.PRINTABLESTRING;
    if('valueTagClass' in attr) {
      valueTagClass = attr.valueTagClass;

      if(valueTagClass === asn1.Type.UTF8) {
        value = forge.util.encodeUtf8(value);
      }
      // FIXME: handle more encodings
    }

    // create a RelativeDistinguishedName set
    // each value in the set is an AttributeTypeAndValue first
    // containing the type (an OID) and second the value
    set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // AttributeType
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
          asn1.oidToDer(attr.type).getBytes()),
        // AttributeValue
        asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)
      ])
    ]);
    rval.value.push(set);
  }

  return rval;
}

/**
 * Gets all printable attributes (typically of an issuer or subject) in a
 * simplified JSON format for display.
 *
 * @param attrs the attributes.
 *
 * @return the JSON for display.
 */
function _getAttributesAsJson(attrs) {
  var rval = {};
  for(var i = 0; i < attrs.length; ++i) {
    var attr = attrs[i];
    if(attr.shortName && (
      attr.valueTagClass === asn1.Type.UTF8 ||
      attr.valueTagClass === asn1.Type.PRINTABLESTRING ||
      attr.valueTagClass === asn1.Type.IA5STRING)) {
      var value = attr.value;
      if(attr.valueTagClass === asn1.Type.UTF8) {
        value = forge.util.encodeUtf8(attr.value);
      }
      if(!(attr.shortName in rval)) {
        rval[attr.shortName] = value;
      } else if(forge.util.isArray(rval[attr.shortName])) {
        rval[attr.shortName].push(value);
      } else {
        rval[attr.shortName] = [rval[attr.shortName], value];
      }
    }
  }
  return rval;
}

/**
 * Fills in missing fields in attributes.
 *
 * @param attrs the attributes to fill missing fields in.
 */
function _fillMissingFields(attrs) {
  var attr;
  for(var i = 0; i < attrs.length; ++i) {
    attr = attrs[i];

    // populate missing name
    if(typeof attr.name === 'undefined') {
      if(attr.type && attr.type in pki.oids) {
        attr.name = pki.oids[attr.type];
      } else if(attr.shortName && attr.shortName in _shortNames) {
        attr.name = pki.oids[_shortNames[attr.shortName]];
      }
    }

    // populate missing type (OID)
    if(typeof attr.type === 'undefined') {
      if(attr.name && attr.name in pki.oids) {
        attr.type = pki.oids[attr.name];
      } else {
        var error = new Error('Attribute type not specified.');
        error.attribute = attr;
        throw error;
      }
    }

    // populate missing shortname
    if(typeof attr.shortName === 'undefined') {
      if(attr.name && attr.name in _shortNames) {
        attr.shortName = _shortNames[attr.name];
      }
    }

    // convert extensions to value
    if(attr.type === oids.extensionRequest) {
      attr.valueConstructed = true;
      attr.valueTagClass = asn1.Type.SEQUENCE;
      if(!attr.value && attr.extensions) {
        attr.value = [];
        for(var ei = 0; ei < attr.extensions.length; ++ei) {
          attr.value.push(pki.certificateExtensionToAsn1(
            _fillMissingExtensionFields(attr.extensions[ei])));
        }
      }
    }

    if(typeof attr.value === 'undefined') {
      var error = new Error('Attribute value not specified.');
      error.attribute = attr;
      throw error;
    }
  }
}

/**
 * Fills in missing fields in certificate extensions.
 *
 * @param e the extension.
 * @param [options] the options to use.
 *          [cert] the certificate the extensions are for.
 *
 * @return the extension.
 */
function _fillMissingExtensionFields(e, options) {
  options = options || {};

  // populate missing name
  if(typeof e.name === 'undefined') {
    if(e.id && e.id in pki.oids) {
      e.name = pki.oids[e.id];
    }
  }

  // populate missing id
  if(typeof e.id === 'undefined') {
    if(e.name && e.name in pki.oids) {
      e.id = pki.oids[e.name];
    } else {
      var error = new Error('Extension ID not specified.');
      error.extension = e;
      throw error;
    }
  }

  if(typeof e.value !== 'undefined') {
    return e;
  }

  // handle missing value:

  // value is a BIT STRING
  if(e.name === 'keyUsage') {
    // build flags
    var unused = 0;
    var b2 = 0x00;
    var b3 = 0x00;
    if(e.digitalSignature) {
      b2 |= 0x80;
      unused = 7;
    }
    if(e.nonRepudiation) {
      b2 |= 0x40;
      unused = 6;
    }
    if(e.keyEncipherment) {
      b2 |= 0x20;
      unused = 5;
    }
    if(e.dataEncipherment) {
      b2 |= 0x10;
      unused = 4;
    }
    if(e.keyAgreement) {
      b2 |= 0x08;
      unused = 3;
    }
    if(e.keyCertSign) {
      b2 |= 0x04;
      unused = 2;
    }
    if(e.cRLSign) {
      b2 |= 0x02;
      unused = 1;
    }
    if(e.encipherOnly) {
      b2 |= 0x01;
      unused = 0;
    }
    if(e.decipherOnly) {
      b3 |= 0x80;
      unused = 7;
    }

    // create bit string
    var value = String.fromCharCode(unused);
    if(b3 !== 0) {
      value += String.fromCharCode(b2) + String.fromCharCode(b3);
    } else if(b2 !== 0) {
      value += String.fromCharCode(b2);
    }
    e.value = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
  } else if(e.name === 'basicConstraints') {
    // basicConstraints is a SEQUENCE
    e.value = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
    // cA BOOLEAN flag defaults to false
    if(e.cA) {
      e.value.value.push(asn1.create(
        asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false,
        String.fromCharCode(0xFF)));
    }
    if('pathLenConstraint' in e) {
      e.value.value.push(asn1.create(
        asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
        asn1.integerToDer(e.pathLenConstraint).getBytes()));
    }
  } else if(e.name === 'extKeyUsage') {
    // extKeyUsage is a SEQUENCE of OIDs
    e.value = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
    var seq = e.value.value;
    for(var key in e) {
      if(e[key] !== true) {
        continue;
      }
      // key is name in OID map
      if(key in oids) {
        seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID,
          false, asn1.oidToDer(oids[key]).getBytes()));
      } else if(key.indexOf('.') !== -1) {
        // assume key is an OID
        seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID,
          false, asn1.oidToDer(key).getBytes()));
      }
    }
  } else if(e.name === 'nsCertType') {
    // nsCertType is a BIT STRING
    // build flags
    var unused = 0;
    var b2 = 0x00;

    if(e.client) {
      b2 |= 0x80;
      unused = 7;
    }
    if(e.server) {
      b2 |= 0x40;
      unused = 6;
    }
    if(e.email) {
      b2 |= 0x20;
      unused = 5;
    }
    if(e.objsign) {
      b2 |= 0x10;
      unused = 4;
    }
    if(e.reserved) {
      b2 |= 0x08;
      unused = 3;
    }
    if(e.sslCA) {
      b2 |= 0x04;
      unused = 2;
    }
    if(e.emailCA) {
      b2 |= 0x02;
      unused = 1;
    }
    if(e.objCA) {
      b2 |= 0x01;
      unused = 0;
    }

    // create bit string
    var value = String.fromCharCode(unused);
    if(b2 !== 0) {
      value += String.fromCharCode(b2);
    }
    e.value = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
  } else if(e.name === 'subjectAltName' || e.name === 'issuerAltName') {
    // SYNTAX SEQUENCE
    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);

    var altName;
    for(var n = 0; n < e.altNames.length; ++n) {
      altName = e.altNames[n];
      var value = altName.value;
      // handle IP
      if(altName.type === 7 && altName.ip) {
        value = forge.util.bytesFromIP(altName.ip);
        if(value === null) {
          var error = new Error(
            'Extension "ip" value is not a valid IPv4 or IPv6 address.');
          error.extension = e;
          throw error;
        }
      } else if(altName.type === 8) {
        // handle OID
        if(altName.oid) {
          value = asn1.oidToDer(asn1.oidToDer(altName.oid));
        } else {
          // deprecated ... convert value to OID
          value = asn1.oidToDer(value);
        }
      }
      e.value.value.push(asn1.create(
        asn1.Class.CONTEXT_SPECIFIC, altName.type, false,
        value));
    }
  } else if(e.name === 'nsComment' && options.cert) {
    // sanity check value is ASCII (req'd) and not too big
    if(!(/^[\x00-\x7F]*$/.test(e.comment)) ||
      (e.comment.length < 1) || (e.comment.length > 128)) {
      throw new Error('Invalid "nsComment" content.');
    }
    // IA5STRING opaque comment
    e.value = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.IA5STRING, false, e.comment);
  } else if(e.name === 'subjectKeyIdentifier' && options.cert) {
    var ski = options.cert.generateSubjectKeyIdentifier();
    e.subjectKeyIdentifier = ski.toHex();
    // OCTETSTRING w/digest
    e.value = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ski.getBytes());
  } else if(e.name === 'authorityKeyIdentifier' && options.cert) {
    // SYNTAX SEQUENCE
    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
    var seq = e.value.value;

    if(e.keyIdentifier) {
      var keyIdentifier = (e.keyIdentifier === true ?
        options.cert.generateSubjectKeyIdentifier().getBytes() :
        e.keyIdentifier);
      seq.push(
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier));
    }

    if(e.authorityCertIssuer) {
      var authorityCertIssuer = [
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [
          _dnToAsn1(e.authorityCertIssuer === true ?
            options.cert.issuer : e.authorityCertIssuer)
        ])
      ];
      seq.push(
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer));
    }

    if(e.serialNumber) {
      var serialNumber = forge.util.hexToBytes(e.serialNumber === true ?
        options.cert.serialNumber : e.serialNumber);
      seq.push(
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber));
    }
  } else if(e.name === 'cRLDistributionPoints') {
    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
    var seq = e.value.value;

    // Create sub SEQUENCE of DistributionPointName
    var subSeq = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);

    // Create fullName CHOICE
    var fullNameGeneralNames = asn1.create(
      asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
    var altName;
    for(var n = 0; n < e.altNames.length; ++n) {
      altName = e.altNames[n];
      var value = altName.value;
      // handle IP
      if(altName.type === 7 && altName.ip) {
        value = forge.util.bytesFromIP(altName.ip);
        if(value === null) {
          var error = new Error(
            'Extension "ip" value is not a valid IPv4 or IPv6 address.');
          error.extension = e;
          throw error;
        }
      } else if(altName.type === 8) {
        // handle OID
        if(altName.oid) {
          value = asn1.oidToDer(asn1.oidToDer(altName.oid));
        } else {
          // deprecated ... convert value to OID
          value = asn1.oidToDer(value);
        }
      }
      fullNameGeneralNames.value.push(asn1.create(
        asn1.Class.CONTEXT_SPECIFIC, altName.type, false,
        value));
    }

    // Add to the parent SEQUENCE
    subSeq.value.push(asn1.create(
      asn1.Class.CONTEXT_SPECIFIC, 0, true, [fullNameGeneralNames]));
    seq.push(subSeq);
  }

  // ensure value has been defined by now
  if(typeof e.value === 'undefined') {
    var error = new Error('Extension value not specified.');
    error.extension = e;
    throw error;
  }

  return e;
}

/**
 * Convert signature parameters object to ASN.1
 *
 * @param {String} oid Signature algorithm OID
 * @param params The signature parametrs object
 * @return ASN.1 object representing signature parameters
 */
function _signatureParametersToAsn1(oid, params) {
  switch(oid) {
    case oids['RSASSA-PSS']:
      var parts = [];

      if(params.hash.algorithmOid !== undefined) {
        parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
              asn1.oidToDer(params.hash.algorithmOid).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')
          ])
        ]));
      }

      if(params.mgf.algorithmOid !== undefined) {
        parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
              asn1.oidToDer(params.mgf.algorithmOid).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
                asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')
            ])
          ])
        ]));
      }

      if(params.saltLength !== undefined) {
        parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
            asn1.integerToDer(params.saltLength).getBytes())
        ]));
      }

      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);

    default:
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '');
  }
}

/**
 * Converts a certification request's attributes to an ASN.1 set of
 * CRIAttributes.
 *
 * @param csr certification request.
 *
 * @return the ASN.1 set of CRIAttributes.
 */
function _CRIAttributesToAsn1(csr) {
  // create an empty context-specific container
  var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);

  // no attributes, return empty container
  if(csr.attributes.length === 0) {
    return rval;
  }

  // each attribute has a sequence with a type and a set of values
  var attrs = csr.attributes;
  for(var i = 0; i < attrs.length; ++i) {
    var attr = attrs[i];
    var value = attr.value;

    // reuse tag class for attribute value if available
    var valueTagClass = asn1.Type.UTF8;
    if('valueTagClass' in attr) {
      valueTagClass = attr.valueTagClass;
    }
    if(valueTagClass === asn1.Type.UTF8) {
      value = forge.util.encodeUtf8(value);
    }
    var valueConstructed = false;
    if('valueConstructed' in attr) {
      valueConstructed = attr.valueConstructed;
    }
    // FIXME: handle more encodings

    // create a RelativeDistinguishedName set
    // each value in the set is an AttributeTypeAndValue first
    // containing the type (an OID) and second the value
    var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // AttributeType
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(attr.type).getBytes()),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
        // AttributeValue
        asn1.create(
          asn1.Class.UNIVERSAL, valueTagClass, valueConstructed, value)
      ])
    ]);
    rval.value.push(seq);
  }

  return rval;
}

var jan_1_1950 = new Date('1950-01-01T00:00:00Z');
var jan_1_2050 = new Date('2050-01-01T00:00:00Z');

/**
 * Converts a Date object to ASN.1
 * Handles the different format before and after 1st January 2050
 *
 * @param date date object.
 *
 * @return the ASN.1 object representing the date.
 */
function _dateToAsn1(date) {
  if(date >= jan_1_1950 && date < jan_1_2050) {
    return asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false,
      asn1.dateToUtcTime(date));
  } else {
    return asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false,
      asn1.dateToGeneralizedTime(date));
  }
}

/**
 * Gets the ASN.1 TBSCertificate part of an X.509v3 certificate.
 *
 * @param cert the certificate.
 *
 * @return the asn1 TBSCertificate.
 */
pki.getTBSCertificate = function(cert) {
  // TBSCertificate
  var notBefore = _dateToAsn1(cert.validity.notBefore);
  var notAfter = _dateToAsn1(cert.validity.notAfter);
  var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // version
    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
      // integer
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
        asn1.integerToDer(cert.version).getBytes())
    ]),
    // serialNumber
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      forge.util.hexToBytes(cert.serialNumber)),
    // signature
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // algorithm
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()),
      // parameters
      _signatureParametersToAsn1(
        cert.siginfo.algorithmOid, cert.siginfo.parameters)
    ]),
    // issuer
    _dnToAsn1(cert.issuer),
    // validity
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      notBefore,
      notAfter
    ]),
    // subject
    _dnToAsn1(cert.subject),
    // SubjectPublicKeyInfo
    pki.publicKeyToAsn1(cert.publicKey)
  ]);

  if(cert.issuer.uniqueId) {
    // issuerUniqueID (optional)
    tbs.value.push(
      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,
          // TODO: support arbitrary bit length ids
          String.fromCharCode(0x00) +
          cert.issuer.uniqueId
        )
      ])
    );
  }
  if(cert.subject.uniqueId) {
    // subjectUniqueID (optional)
    tbs.value.push(
      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,
          // TODO: support arbitrary bit length ids
          String.fromCharCode(0x00) +
          cert.subject.uniqueId
        )
      ])
    );
  }

  if(cert.extensions.length > 0) {
    // extensions (optional)
    tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));
  }

  return tbs;
};

/**
 * Gets the ASN.1 CertificationRequestInfo part of a
 * PKCS#10 CertificationRequest.
 *
 * @param csr the certification request.
 *
 * @return the asn1 CertificationRequestInfo.
 */
pki.getCertificationRequestInfo = function(csr) {
  // CertificationRequestInfo
  var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // version
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      asn1.integerToDer(csr.version).getBytes()),
    // subject
    _dnToAsn1(csr.subject),
    // SubjectPublicKeyInfo
    pki.publicKeyToAsn1(csr.publicKey),
    // attributes
    _CRIAttributesToAsn1(csr)
  ]);

  return cri;
};

/**
 * Converts a DistinguishedName (subject or issuer) to an ASN.1 object.
 *
 * @param dn the DistinguishedName.
 *
 * @return the asn1 representation of a DistinguishedName.
 */
pki.distinguishedNameToAsn1 = function(dn) {
  return _dnToAsn1(dn);
};

/**
 * Converts an X.509v3 RSA certificate to an ASN.1 object.
 *
 * @param cert the certificate.
 *
 * @return the asn1 representation of an X.509v3 RSA certificate.
 */
pki.certificateToAsn1 = function(cert) {
  // prefer cached TBSCertificate over generating one
  var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert);

  // Certificate
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // TBSCertificate
    tbsCertificate,
    // AlgorithmIdentifier (signature algorithm)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // algorithm
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(cert.signatureOid).getBytes()),
      // parameters
      _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
    ]),
    // SignatureValue
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,
      String.fromCharCode(0x00) + cert.signature)
  ]);
};

/**
 * Converts X.509v3 certificate extensions to ASN.1.
 *
 * @param exts the extensions to convert.
 *
 * @return the extensions in ASN.1 format.
 */
pki.certificateExtensionsToAsn1 = function(exts) {
  // create top-level extension container
  var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);

  // create extension sequence (stores a sequence for each extension)
  var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
  rval.value.push(seq);

  for(var i = 0; i < exts.length; ++i) {
    seq.value.push(pki.certificateExtensionToAsn1(exts[i]));
  }

  return rval;
};

/**
 * Converts a single certificate extension to ASN.1.
 *
 * @param ext the extension to convert.
 *
 * @return the extension in ASN.1 format.
 */
pki.certificateExtensionToAsn1 = function(ext) {
  // create a sequence for each extension
  var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);

  // extnID (OID)
  extseq.value.push(asn1.create(
    asn1.Class.UNIVERSAL, asn1.Type.OID, false,
    asn1.oidToDer(ext.id).getBytes()));

  // critical defaults to false
  if(ext.critical) {
    // critical BOOLEAN DEFAULT FALSE
    extseq.value.push(asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false,
      String.fromCharCode(0xFF)));
  }

  var value = ext.value;
  if(typeof ext.value !== 'string') {
    // value is asn.1
    value = asn1.toDer(value).getBytes();
  }

  // extnValue (OCTET STRING)
  extseq.value.push(asn1.create(
    asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, value));

  return extseq;
};

/**
 * Converts a PKCS#10 certification request to an ASN.1 object.
 *
 * @param csr the certification request.
 *
 * @return the asn1 representation of a certification request.
 */
pki.certificationRequestToAsn1 = function(csr) {
  // prefer cached CertificationRequestInfo over generating one
  var cri = csr.certificationRequestInfo ||
    pki.getCertificationRequestInfo(csr);

  // Certificate
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // CertificationRequestInfo
    cri,
    // AlgorithmIdentifier (signature algorithm)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // algorithm
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(csr.signatureOid).getBytes()),
      // parameters
      _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
    ]),
    // signature
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,
      String.fromCharCode(0x00) + csr.signature)
  ]);
};

/**
 * Creates a CA store.
 *
 * @param certs an optional array of certificate objects or PEM-formatted
 *          certificate strings to add to the CA store.
 *
 * @return the CA store.
 */
pki.createCaStore = function(certs) {
  // create CA store
  var caStore = {
    // stored certificates
    certs: {}
  };

  /**
   * Gets the certificate that issued the passed certificate or its
   * 'parent'.
   *
   * @param cert the certificate to get the parent for.
   *
   * @return the parent certificate or null if none was found.
   */
  caStore.getIssuer = function(cert) {
    var rval = getBySubject(cert.issuer);

    // see if there are multiple matches
    /*if(forge.util.isArray(rval)) {
      // TODO: resolve multiple matches by checking
      // authorityKey/subjectKey/issuerUniqueID/other identifiers, etc.
      // FIXME: or alternatively do authority key mapping
      // if possible (X.509v1 certs can't work?)
      throw new Error('Resolving multiple issuer matches not implemented yet.');
    }*/

    return rval;
  };

  /**
   * Adds a trusted certificate to the store.
   *
   * @param cert the certificate to add as a trusted certificate (either a
   *          pki.certificate object or a PEM-formatted certificate).
   */
  caStore.addCertificate = function(cert) {
    // convert from pem if necessary
    if(typeof cert === 'string') {
      cert = forge.pki.certificateFromPem(cert);
    }

    ensureSubjectHasHash(cert.subject);

    if(!caStore.hasCertificate(cert)) { // avoid duplicate certificates in store
      if(cert.subject.hash in caStore.certs) {
        // subject hash already exists, append to array
        var tmp = caStore.certs[cert.subject.hash];
        if(!forge.util.isArray(tmp)) {
          tmp = [tmp];
        }
        tmp.push(cert);
        caStore.certs[cert.subject.hash] = tmp;
      } else {
        caStore.certs[cert.subject.hash] = cert;
      }
    }
  };

  /**
   * Checks to see if the given certificate is in the store.
   *
   * @param cert the certificate to check (either a pki.certificate or a
   *          PEM-formatted certificate).
   *
   * @return true if the certificate is in the store, false if not.
   */
  caStore.hasCertificate = function(cert) {
    // convert from pem if necessary
    if(typeof cert === 'string') {
      cert = forge.pki.certificateFromPem(cert);
    }

    var match = getBySubject(cert.subject);
    if(!match) {
      return false;
    }
    if(!forge.util.isArray(match)) {
      match = [match];
    }
    // compare DER-encoding of certificates
    var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes();
    for(var i = 0; i < match.length; ++i) {
      var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();
      if(der1 === der2) {
        return true;
      }
    }
    return false;
  };

  /**
   * Lists all of the certificates kept in the store.
   *
   * @return an array of all of the pki.certificate objects in the store.
   */
  caStore.listAllCertificates = function() {
    var certList = [];

    for(var hash in caStore.certs) {
      if(caStore.certs.hasOwnProperty(hash)) {
        var value = caStore.certs[hash];
        if(!forge.util.isArray(value)) {
          certList.push(value);
        } else {
          for(var i = 0; i < value.length; ++i) {
            certList.push(value[i]);
          }
        }
      }
    }

    return certList;
  };

  /**
   * Removes a certificate from the store.
   *
   * @param cert the certificate to remove (either a pki.certificate or a
   *          PEM-formatted certificate).
   *
   * @return the certificate that was removed or null if the certificate
   *           wasn't in store.
   */
  caStore.removeCertificate = function(cert) {
    var result;

    // convert from pem if necessary
    if(typeof cert === 'string') {
      cert = forge.pki.certificateFromPem(cert);
    }
    ensureSubjectHasHash(cert.subject);
    if(!caStore.hasCertificate(cert)) {
      return null;
    }

    var match = getBySubject(cert.subject);

    if(!forge.util.isArray(match)) {
      result = caStore.certs[cert.subject.hash];
      delete caStore.certs[cert.subject.hash];
      return result;
    }

    // compare DER-encoding of certificates
    var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes();
    for(var i = 0; i < match.length; ++i) {
      var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();
      if(der1 === der2) {
        result = match[i];
        match.splice(i, 1);
      }
    }
    if(match.length === 0) {
      delete caStore.certs[cert.subject.hash];
    }

    return result;
  };

  function getBySubject(subject) {
    ensureSubjectHasHash(subject);
    return caStore.certs[subject.hash] || null;
  }

  function ensureSubjectHasHash(subject) {
    // produce subject hash if it doesn't exist
    if(!subject.hash) {
      var md = forge.md.sha1.create();
      subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(subject), md);
      subject.hash = md.digest().toHex();
    }
  }

  // auto-add passed in certs
  if(certs) {
    // parse PEM-formatted certificates as necessary
    for(var i = 0; i < certs.length; ++i) {
      var cert = certs[i];
      caStore.addCertificate(cert);
    }
  }

  return caStore;
};

/**
 * Certificate verification errors, based on TLS.
 */
pki.certificateError = {
  bad_certificate: 'forge.pki.BadCertificate',
  unsupported_certificate: 'forge.pki.UnsupportedCertificate',
  certificate_revoked: 'forge.pki.CertificateRevoked',
  certificate_expired: 'forge.pki.CertificateExpired',
  certificate_unknown: 'forge.pki.CertificateUnknown',
  unknown_ca: 'forge.pki.UnknownCertificateAuthority'
};

/**
 * Verifies a certificate chain against the given Certificate Authority store
 * with an optional custom verify callback.
 *
 * @param caStore a certificate store to verify against.
 * @param chain the certificate chain to verify, with the root or highest
 *          authority at the end (an array of certificates).
 * @param options a callback to be called for every certificate in the chain or
 *                  an object with:
 *                  verify a callback to be called for every certificate in the
 *                    chain
 *                  validityCheckDate the date against which the certificate
 *                    validity period should be checked. Pass null to not check
 *                    the validity period. By default, the current date is used.
 *
 * The verify callback has the following signature:
 *
 * verified - Set to true if certificate was verified, otherwise the
 *   pki.certificateError for why the certificate failed.
 * depth - The current index in the chain, where 0 is the end point's cert.
 * certs - The certificate chain, *NOTE* an empty chain indicates an anonymous
 *   end point.
 *
 * The function returns true on success and on failure either the appropriate
 * pki.certificateError or an object with 'error' set to the appropriate
 * pki.certificateError and 'message' set to a custom error message.
 *
 * @return true if successful, error thrown if not.
 */
pki.verifyCertificateChain = function(caStore, chain, options) {
  /* From: RFC3280 - Internet X.509 Public Key Infrastructure Certificate
    Section 6: Certification Path Validation
    See inline parentheticals related to this particular implementation.

    The primary goal of path validation is to verify the binding between
    a subject distinguished name or a subject alternative name and subject
    public key, as represented in the end entity certificate, based on the
    public key of the trust anchor. This requires obtaining a sequence of
    certificates that support that binding. That sequence should be provided
    in the passed 'chain'. The trust anchor should be in the given CA
    store. The 'end entity' certificate is the certificate provided by the
    end point (typically a server) and is the first in the chain.

    To meet this goal, the path validation process verifies, among other
    things, that a prospective certification path (a sequence of n
    certificates or a 'chain') satisfies the following conditions:

    (a) for all x in {1, ..., n-1}, the subject of certificate x is
          the issuer of certificate x+1;

    (b) certificate 1 is issued by the trust anchor;

    (c) certificate n is the certificate to be validated; and

    (d) for all x in {1, ..., n}, the certificate was valid at the
          time in question.

    Note that here 'n' is index 0 in the chain and 1 is the last certificate
    in the chain and it must be signed by a certificate in the connection's
    CA store.

    The path validation process also determines the set of certificate
    policies that are valid for this path, based on the certificate policies
    extension, policy mapping extension, policy constraints extension, and
    inhibit any-policy extension.

    Note: Policy mapping extension not supported (Not Required).

    Note: If the certificate has an unsupported critical extension, then it
    must be rejected.

    Note: A certificate is self-issued if the DNs that appear in the subject
    and issuer fields are identical and are not empty.

    The path validation algorithm assumes the following seven inputs are
    provided to the path processing logic. What this specific implementation
    will use is provided parenthetically:

    (a) a prospective certification path of length n (the 'chain')
    (b) the current date/time: ('now').
    (c) user-initial-policy-set: A set of certificate policy identifiers
          naming the policies that are acceptable to the certificate user.
          The user-initial-policy-set contains the special value any-policy
          if the user is not concerned about certificate policy
          (Not implemented. Any policy is accepted).
    (d) trust anchor information, describing a CA that serves as a trust
          anchor for the certification path. The trust anchor information
          includes:

      (1)  the trusted issuer name,
      (2)  the trusted public key algorithm,
      (3)  the trusted public key, and
      (4)  optionally, the trusted public key parameters associated
             with the public key.

      (Trust anchors are provided via certificates in the CA store).

      The trust anchor information may be provided to the path processing
      procedure in the form of a self-signed certificate. The trusted anchor
      information is trusted because it was delivered to the path processing
      procedure by some trustworthy out-of-band procedure. If the trusted
      public key algorithm requires parameters, then the parameters are
      provided along with the trusted public key (No parameters used in this
      implementation).

    (e) initial-policy-mapping-inhibit, which indicates if policy mapping is
          allowed in the certification path.
          (Not implemented, no policy checking)

    (f) initial-explicit-policy, which indicates if the path must be valid
          for at least one of the certificate policies in the user-initial-
          policy-set.
          (Not implemented, no policy checking)

    (g) initial-any-policy-inhibit, which indicates whether the
          anyPolicy OID should be processed if it is included in a
          certificate.
          (Not implemented, so any policy is valid provided that it is
          not marked as critical) */

  /* Basic Path Processing:

    For each certificate in the 'chain', the following is checked:

    1. The certificate validity period includes the current time.
    2. The certificate was signed by its parent (where the parent is either
       the next in the chain or from the CA store). Allow processing to
       continue to the next step if no parent is found but the certificate is
       in the CA store.
    3. TODO: The certificate has not been revoked.
    4. The certificate issuer name matches the parent's subject name.
    5. TODO: If the certificate is self-issued and not the final certificate
       in the chain, skip this step, otherwise verify that the subject name
       is within one of the permitted subtrees of X.500 distinguished names
       and that each of the alternative names in the subjectAltName extension
       (critical or non-critical) is within one of the permitted subtrees for
       that name type.
    6. TODO: If the certificate is self-issued and not the final certificate
       in the chain, skip this step, otherwise verify that the subject name
       is not within one of the excluded subtrees for X.500 distinguished
       names and none of the subjectAltName extension names are excluded for
       that name type.
    7. The other steps in the algorithm for basic path processing involve
       handling the policy extension which is not presently supported in this
       implementation. Instead, if a critical policy extension is found, the
       certificate is rejected as not supported.
    8. If the certificate is not the first or if its the only certificate in
       the chain (having no parent from the CA store or is self-signed) and it
       has a critical key usage extension, verify that the keyCertSign bit is
       set. If the key usage extension exists, verify that the basic
       constraints extension exists. If the basic constraints extension exists,
       verify that the cA flag is set. If pathLenConstraint is set, ensure that
       the number of certificates that precede in the chain (come earlier
       in the chain as implemented below), excluding the very first in the
       chain (typically the end-entity one), isn't greater than the
       pathLenConstraint. This constraint limits the number of intermediate
       CAs that may appear below a CA before only end-entity certificates
       may be issued. */

  // if a verify callback is passed as the third parameter, package it within
  // the options object. This is to support a legacy function signature that
  // expected the verify callback as the third parameter.
  if(typeof options === 'function') {
    options = {verify: options};
  }
  options = options || {};

  // copy cert chain references to another array to protect against changes
  // in verify callback
  chain = chain.slice(0);
  var certs = chain.slice(0);

  var validityCheckDate = options.validityCheckDate;
  // if no validityCheckDate is specified, default to the current date. Make
  // sure to maintain the value null because it indicates that the validity
  // period should not be checked.
  if(typeof validityCheckDate === 'undefined') {
    validityCheckDate = new Date();
  }

  // verify each cert in the chain using its parent, where the parent
  // is either the next in the chain or from the CA store
  var first = true;
  var error = null;
  var depth = 0;
  do {
    var cert = chain.shift();
    var parent = null;
    var selfSigned = false;

    if(validityCheckDate) {
      // 1. check valid time
      if(validityCheckDate < cert.validity.notBefore ||
         validityCheckDate > cert.validity.notAfter) {
        error = {
          message: 'Certificate is not valid yet or has expired.',
          error: pki.certificateError.certificate_expired,
          notBefore: cert.validity.notBefore,
          notAfter: cert.validity.notAfter,
          // TODO: we might want to reconsider renaming 'now' to
          // 'validityCheckDate' should this API be changed in the future.
          now: validityCheckDate
        };
      }
    }

    // 2. verify with parent from chain or CA store
    if(error === null) {
      parent = chain[0] || caStore.getIssuer(cert);
      if(parent === null) {
        // check for self-signed cert
        if(cert.isIssuer(cert)) {
          selfSigned = true;
          parent = cert;
        }
      }

      if(parent) {
        // FIXME: current CA store implementation might have multiple
        // certificates where the issuer can't be determined from the
        // certificate (happens rarely with, eg: old certificates) so normalize
        // by always putting parents into an array
        // TODO: there's may be an extreme degenerate case currently uncovered
        // where an old intermediate certificate seems to have a matching parent
        // but none of the parents actually verify ... but the intermediate
        // is in the CA and it should pass this check; needs investigation
        var parents = parent;
        if(!forge.util.isArray(parents)) {
          parents = [parents];
        }

        // try to verify with each possible parent (typically only one)
        var verified = false;
        while(!verified && parents.length > 0) {
          parent = parents.shift();
          try {
            verified = parent.verify(cert);
          } catch(ex) {
            // failure to verify, don't care why, try next one
          }
        }

        if(!verified) {
          error = {
            message: 'Certificate signature is invalid.',
            error: pki.certificateError.bad_certificate
          };
        }
      }

      if(error === null && (!parent || selfSigned) &&
        !caStore.hasCertificate(cert)) {
        // no parent issuer and certificate itself is not trusted
        error = {
          message: 'Certificate is not trusted.',
          error: pki.certificateError.unknown_ca
        };
      }
    }

    // TODO: 3. check revoked

    // 4. check for matching issuer/subject
    if(error === null && parent && !cert.isIssuer(parent)) {
      // parent is not issuer
      error = {
        message: 'Certificate issuer is invalid.',
        error: pki.certificateError.bad_certificate
      };
    }

    // 5. TODO: check names with permitted names tree

    // 6. TODO: check names against excluded names tree

    // 7. check for unsupported critical extensions
    if(error === null) {
      // supported extensions
      var se = {
        keyUsage: true,
        basicConstraints: true
      };
      for(var i = 0; error === null && i < cert.extensions.length; ++i) {
        var ext = cert.extensions[i];
        if(ext.critical && !(ext.name in se)) {
          error = {
            message:
              'Certificate has an unsupported critical extension.',
            error: pki.certificateError.unsupported_certificate
          };
        }
      }
    }

    // 8. check for CA if cert is not first or is the only certificate
    // remaining in chain with no parent or is self-signed
    if(error === null &&
      (!first || (chain.length === 0 && (!parent || selfSigned)))) {
      // first check keyUsage extension and then basic constraints
      var bcExt = cert.getExtension('basicConstraints');
      var keyUsageExt = cert.getExtension('keyUsage');
      if(keyUsageExt !== null) {
        // keyCertSign must be true and there must be a basic
        // constraints extension
        if(!keyUsageExt.keyCertSign || bcExt === null) {
          // bad certificate
          error = {
            message:
              'Certificate keyUsage or basicConstraints conflict ' +
              'or indicate that the certificate is not a CA. ' +
              'If the certificate is the only one in the chain or ' +
              'isn\'t the first then the certificate must be a ' +
              'valid CA.',
            error: pki.certificateError.bad_certificate
          };
        }
      }
      // basic constraints cA flag must be set
      if(error === null && bcExt !== null && !bcExt.cA) {
        // bad certificate
        error = {
          message:
            'Certificate basicConstraints indicates the certificate ' +
            'is not a CA.',
          error: pki.certificateError.bad_certificate
        };
      }
      // if error is not null and keyUsage is available, then we know it
      // has keyCertSign and there is a basic constraints extension too,
      // which means we can check pathLenConstraint (if it exists)
      if(error === null && keyUsageExt !== null &&
        'pathLenConstraint' in bcExt) {
        // pathLen is the maximum # of intermediate CA certs that can be
        // found between the current certificate and the end-entity (depth 0)
        // certificate; this number does not include the end-entity (depth 0,
        // last in the chain) even if it happens to be a CA certificate itself
        var pathLen = depth - 1;
        if(pathLen > bcExt.pathLenConstraint) {
          // pathLenConstraint violated, bad certificate
          error = {
            message:
              'Certificate basicConstraints pathLenConstraint violated.',
            error: pki.certificateError.bad_certificate
          };
        }
      }
    }

    // call application callback
    var vfd = (error === null) ? true : error.error;
    var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
    if(ret === true) {
      // clear any set error
      error = null;
    } else {
      // if passed basic tests, set default message and alert
      if(vfd === true) {
        error = {
          message: 'The application rejected the certificate.',
          error: pki.certificateError.bad_certificate
        };
      }

      // check for custom error info
      if(ret || ret === 0) {
        // set custom message and error
        if(typeof ret === 'object' && !forge.util.isArray(ret)) {
          if(ret.message) {
            error.message = ret.message;
          }
          if(ret.error) {
            error.error = ret.error;
          }
        } else if(typeof ret === 'string') {
          // set custom error
          error.error = ret;
        }
      }

      // throw error
      throw error;
    }

    // no longer first cert in chain
    first = false;
    ++depth;
  } while(chain.length > 0);

  return true;
};

      };
    };
  }
}, {package:"node-forge",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\x509.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\pkcs7asn1.js", {"./asn1":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\asn1.js","./forge":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\forge.js","./util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\node-forge\lib\pkcs7asn1.js
      return function (require, module, exports) {
/**
 * Javascript implementation of ASN.1 validators for PKCS#7 v1.5.
 *
 * @author Dave Longley
 * @author Stefan Siegl
 *
 * Copyright (c) 2012-2015 Digital Bazaar, Inc.
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * The ASN.1 representation of PKCS#7 is as follows
 * (see RFC #2315 for details, http://www.ietf.org/rfc/rfc2315.txt):
 *
 * A PKCS#7 message consists of a ContentInfo on root level, which may
 * contain any number of further ContentInfo nested into it.
 *
 * ContentInfo ::= SEQUENCE {
 *   contentType                ContentType,
 *   content               [0]  EXPLICIT ANY DEFINED BY contentType OPTIONAL
 * }
 *
 * ContentType ::= OBJECT IDENTIFIER
 *
 * EnvelopedData ::= SEQUENCE {
 *   version                    Version,
 *   recipientInfos             RecipientInfos,
 *   encryptedContentInfo       EncryptedContentInfo
 * }
 *
 * EncryptedData ::= SEQUENCE {
 *   version                    Version,
 *   encryptedContentInfo       EncryptedContentInfo
 * }
 *
 * id-signedData OBJECT IDENTIFIER ::= { iso(1) member-body(2)
 *   us(840) rsadsi(113549) pkcs(1) pkcs7(7) 2 }
 *
 * SignedData ::= SEQUENCE {
 *   version           INTEGER,
 *   digestAlgorithms  DigestAlgorithmIdentifiers,
 *   contentInfo       ContentInfo,
 *   certificates      [0] IMPLICIT Certificates OPTIONAL,
 *   crls              [1] IMPLICIT CertificateRevocationLists OPTIONAL,
 *   signerInfos       SignerInfos
 * }
 *
 * SignerInfos ::= SET OF SignerInfo
 *
 * SignerInfo ::= SEQUENCE {
 *   version                    Version,
 *   issuerAndSerialNumber      IssuerAndSerialNumber,
 *   digestAlgorithm            DigestAlgorithmIdentifier,
 *   authenticatedAttributes    [0] IMPLICIT Attributes OPTIONAL,
 *   digestEncryptionAlgorithm  DigestEncryptionAlgorithmIdentifier,
 *   encryptedDigest            EncryptedDigest,
 *   unauthenticatedAttributes  [1] IMPLICIT Attributes OPTIONAL
 * }
 *
 * EncryptedDigest ::= OCTET STRING
 *
 * Attributes ::= SET OF Attribute
 *
 * Attribute ::= SEQUENCE {
 *   attrType    OBJECT IDENTIFIER,
 *   attrValues  SET OF AttributeValue
 * }
 *
 * AttributeValue ::= ANY
 *
 * Version ::= INTEGER
 *
 * RecipientInfos ::= SET OF RecipientInfo
 *
 * EncryptedContentInfo ::= SEQUENCE {
 *   contentType                 ContentType,
 *   contentEncryptionAlgorithm  ContentEncryptionAlgorithmIdentifier,
 *   encryptedContent       [0]  IMPLICIT EncryptedContent OPTIONAL
 * }
 *
 * ContentEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters
 * for the algorithm, if any. In the case of AES and DES3, there is only one,
 * the IV.
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *    algorithm OBJECT IDENTIFIER,
 *    parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * EncryptedContent ::= OCTET STRING
 *
 * RecipientInfo ::= SEQUENCE {
 *   version                     Version,
 *   issuerAndSerialNumber       IssuerAndSerialNumber,
 *   keyEncryptionAlgorithm      KeyEncryptionAlgorithmIdentifier,
 *   encryptedKey                EncryptedKey
 * }
 *
 * IssuerAndSerialNumber ::= SEQUENCE {
 *   issuer                      Name,
 *   serialNumber                CertificateSerialNumber
 * }
 *
 * CertificateSerialNumber ::= INTEGER
 *
 * KeyEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * EncryptedKey ::= OCTET STRING
 */
var forge = require('./forge');
require('./asn1');
require('./util');

// shortcut for ASN.1 API
var asn1 = forge.asn1;

// shortcut for PKCS#7 API
var p7v = module.exports = forge.pkcs7asn1 = forge.pkcs7asn1 || {};
forge.pkcs7 = forge.pkcs7 || {};
forge.pkcs7.asn1 = p7v;

var contentInfoValidator = {
  name: 'ContentInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'ContentInfo.ContentType',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OID,
    constructed: false,
    capture: 'contentType'
  }, {
    name: 'ContentInfo.content',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: true,
    optional: true,
    captureAsn1: 'content'
  }]
};
p7v.contentInfoValidator = contentInfoValidator;

var encryptedContentInfoValidator = {
  name: 'EncryptedContentInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'EncryptedContentInfo.contentType',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OID,
    constructed: false,
    capture: 'contentType'
  }, {
    name: 'EncryptedContentInfo.contentEncryptionAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'EncryptedContentInfo.contentEncryptionAlgorithm.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'encAlgorithm'
    }, {
      name: 'EncryptedContentInfo.contentEncryptionAlgorithm.parameter',
      tagClass: asn1.Class.UNIVERSAL,
      captureAsn1: 'encParameter'
    }]
  }, {
    name: 'EncryptedContentInfo.encryptedContent',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 0,
    /* The PKCS#7 structure output by OpenSSL somewhat differs from what
     * other implementations do generate.
     *
     * OpenSSL generates a structure like this:
     * SEQUENCE {
     *    ...
     *    [0]
     *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
     *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
     *       ...
     * }
     *
     * Whereas other implementations (and this PKCS#7 module) generate:
     * SEQUENCE {
     *    ...
     *    [0] {
     *       OCTET STRING
     *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
     *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
     *          ...
     *    }
     * }
     *
     * In order to support both, we just capture the context specific
     * field here.  The OCTET STRING bit is removed below.
     */
    capture: 'encryptedContent',
    captureAsn1: 'encryptedContentAsn1'
  }]
};

p7v.envelopedDataValidator = {
  name: 'EnvelopedData',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'EnvelopedData.Version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'version'
  }, {
    name: 'EnvelopedData.RecipientInfos',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SET,
    constructed: true,
    captureAsn1: 'recipientInfos'
  }].concat(encryptedContentInfoValidator)
};

p7v.encryptedDataValidator = {
  name: 'EncryptedData',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'EncryptedData.Version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'version'
  }].concat(encryptedContentInfoValidator)
};

var signerValidator = {
  name: 'SignerInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'SignerInfo.version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false
  }, {
    name: 'SignerInfo.issuerAndSerialNumber',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'SignerInfo.issuerAndSerialNumber.issuer',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: 'issuer'
    }, {
      name: 'SignerInfo.issuerAndSerialNumber.serialNumber',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: 'serial'
    }]
  }, {
    name: 'SignerInfo.digestAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'SignerInfo.digestAlgorithm.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'digestAlgorithm'
    }, {
      name: 'SignerInfo.digestAlgorithm.parameter',
      tagClass: asn1.Class.UNIVERSAL,
      constructed: false,
      captureAsn1: 'digestParameter',
      optional: true
    }]
  }, {
    name: 'SignerInfo.authenticatedAttributes',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: true,
    optional: true,
    capture: 'authenticatedAttributes'
  }, {
    name: 'SignerInfo.digestEncryptionAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    capture: 'signatureAlgorithm'
  }, {
    name: 'SignerInfo.encryptedDigest',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OCTETSTRING,
    constructed: false,
    capture: 'signature'
  }, {
    name: 'SignerInfo.unauthenticatedAttributes',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 1,
    constructed: true,
    optional: true,
    capture: 'unauthenticatedAttributes'
  }]
};

p7v.signedDataValidator = {
  name: 'SignedData',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'SignedData.Version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'version'
  }, {
    name: 'SignedData.DigestAlgorithms',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SET,
    constructed: true,
    captureAsn1: 'digestAlgorithms'
  },
  contentInfoValidator,
  {
    name: 'SignedData.Certificates',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 0,
    optional: true,
    captureAsn1: 'certificates'
  }, {
    name: 'SignedData.CertificateRevocationLists',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 1,
    optional: true,
    captureAsn1: 'crls'
  }, {
    name: 'SignedData.SignerInfos',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SET,
    capture: 'signerInfos',
    optional: true,
    value: [signerValidator]
  }]
};

p7v.recipientInfoValidator = {
  name: 'RecipientInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'RecipientInfo.version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'version'
  }, {
    name: 'RecipientInfo.issuerAndSerial',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'RecipientInfo.issuerAndSerial.issuer',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: 'issuer'
    }, {
      name: 'RecipientInfo.issuerAndSerial.serialNumber',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: 'serial'
    }]
  }, {
    name: 'RecipientInfo.keyEncryptionAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'RecipientInfo.keyEncryptionAlgorithm.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'encAlgorithm'
    }, {
      name: 'RecipientInfo.keyEncryptionAlgorithm.parameter',
      tagClass: asn1.Class.UNIVERSAL,
      constructed: false,
      captureAsn1: 'encParameter',
      optional: true
    }]
  }, {
    name: 'RecipientInfo.encryptedKey',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OCTETSTRING,
    constructed: false,
    capture: 'encKey'
  }]
};

      };
    };
  }
}, {package:"node-forge",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\pkcs7asn1.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-bitswap\\node_modules\\multihashing-async\\src\\crypto.js", {"./blake":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-bitswap\\node_modules\\multihashing-async\\src\\blake.js","./crypto-sha1-2":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-bitswap\\node_modules\\multihashing-async\\src\\crypto-sha1-2-browser.js","./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-bitswap\\node_modules\\multihashing-async\\src\\utils.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","js-sha3":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\js-sha3\\src\\sha3.js","murmurhash3js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\murmurhash3js\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-bitswap\node_modules\multihashing-async\src\crypto.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const sha3 = require('js-sha3')
const murmur3 = require('murmurhash3js')

const utils = require('./utils')
const sha = require('./crypto-sha1-2')

const toCallback = utils.toCallback
const toBuf = utils.toBuf
const fromString = utils.fromString
const fromNumberTo32BitBuf = utils.fromNumberTo32BitBuf

const dblSha2256 = (buf, cb) => {
  sha.sha2256(buf, (err, firstHash) => {
    if (err) {
      cb(err)
    }
    sha.sha2256((Buffer.from(firstHash)), cb)
  })
}

module.exports = {
  sha1: sha.sha1,
  sha2256: sha.sha2256,
  sha2512: sha.sha2512,
  sha3512: toCallback(toBuf(sha3.sha3_512)),
  sha3384: toCallback(toBuf(sha3.sha3_384)),
  sha3256: toCallback(toBuf(sha3.sha3_256)),
  sha3224: toCallback(toBuf(sha3.sha3_224)),
  shake128: toCallback(toBuf(sha3.shake_128, 128)),
  shake256: toCallback(toBuf(sha3.shake_256, 256)),
  keccak224: toCallback(toBuf(sha3.keccak_224)),
  keccak256: toCallback(toBuf(sha3.keccak_256)),
  keccak384: toCallback(toBuf(sha3.keccak_384)),
  keccak512: toCallback(toBuf(sha3.keccak_512)),
  murmur3128: toCallback(toBuf(fromString(murmur3.x64.hash128))),
  murmur332: toCallback(fromNumberTo32BitBuf(fromString(murmur3.x86.hash32))),
  addBlake: require('./blake'),
  dblSha2256: dblSha2256
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-bitswap\\node_modules\\multihashing-async\\src\\crypto.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-reader\\index.js", {"./state":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-reader\\state.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\pull-reader\index.js
      return function (require, module, exports) {
'use strict'
var State = require('./state')

function isInteger (i) {
  return Number.isFinite(i)
}

function isFunction (f) {
  return 'function' === typeof f
}

function maxDelay(fn, delay) {
  if(!delay) return fn
  return function (a, cb) {
    var timer = setTimeout(function () {
      fn(new Error('pull-reader: read exceeded timeout'), cb)
    }, delay)
    fn(a, function (err, value) {
      clearTimeout(timer)
      cb(err, value)
    })

  }

}

module.exports = function (timeout) {

  var queue = [], read, readTimed, reading = false
  var state = State(), ended, streaming, abort

  function drain () {
    while (queue.length) {
      if(null == queue[0].length && state.has(1)) {
        queue.shift().cb(null, state.get())
      }
      else if(state.has(queue[0].length)) {
        var next = queue.shift()
        next.cb(null, state.get(next.length))
      }
      else if(ended == true && queue[0].length && state.length < queue[0].length) {
        var msg = 'stream ended with:'+state.length+' but wanted:'+queue[0].length
        queue.shift().cb(new Error(msg))
      }
      else if(ended)
        queue.shift().cb(ended)
      else
        return !!queue.length
    }
    //always read a little data
    return queue.length || !state.has(1) || abort
  }

  function more () {
    var d = drain()
    if(d && !reading)
    if(read && !reading && !streaming) {
      reading = true
      readTimed (null, function (err, data) {
        reading = false
        if(err) {
          ended = err
          return drain()
        }
        state.add(data)
        more()
      })
    }
  }

  function reader (_read) {
    if(abort) {
      while(queue.length) queue.shift().cb(abort)
      return cb && cb(abort)
    }
    readTimed = maxDelay(_read, timeout)
    read = _read
    more()
  }

  reader.abort = function (err, cb) {
    abort = err || true
    if(read) {
      reading = true
      read(abort, function () {
        while(queue.length) queue.shift().cb(abort)
        cb && cb(abort)
      })
    }
    else
      cb()
  }

  reader.read = function (len, _timeout, cb) {
    if(isFunction(_timeout))
      cb = _timeout, _timeout = timeout
    if(isFunction(cb)) {
      queue.push({length: isInteger(len) ? len : null, cb: cb})
      more()
    }
    else {
      //switch into streaming mode for the rest of the stream.
      streaming = true
      //wait for the current read to complete
      return function (abort, cb) {
        //if there is anything still in the queue,
        if(reading || state.has(1)) {
          if(abort) return read(abort, cb)
          queue.push({length: null, cb: cb})
          more()
        }
        else
          maxDelay(read, _timeout)(abort, function (err, data) {
            cb(err, data)
          })
      }
    }
  }

  return reader
}







      };
    };
  }
}, {package:"pull-reader",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-reader\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-record\\src\\selectors\\public-key.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-record\src\selectors\public-key.js
      return function (require, module, exports) {
'use strict'

/**
 * Best record selector, for public key records.
 * Simply returns the first record, as all valid public key
 * records are equal.
 *
 * @param {Buffer} k
 * @param {Array<Buffer>} records
 * @returns {number}
 */
const publicKeySelector = (k, records) => {
  return 0
}

module.exports = publicKeySelector

      };
    };
  }
}, {package:"libp2p-record",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-record\\src\\selectors\\public-key.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\buffer-indexof\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\buffer-indexof\index.js
      return function (require, module, exports) {
module.exports = function bufferIndexOf(buf,search,offset){
  offset = offset||0
  
  var m = 0;
  var s = -1;
  for(var i=offset;i<buf.length;++i){
    if(buf[i] == search[m]) {
      if(s == -1) s = i;
      ++m;
      if(m == search.length) break;
    } else {
      s = -1;
      m = 0;
    }
  }

  if (s > -1 && buf.length - s < search.length) return -1;
  return s;
}

      };
    };
  }
}, {package:"buffer-indexof",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\buffer-indexof\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-record\\src\\validators\\public-key.js", {"../../../is-buffer/index.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-buffer\\index.js","async/setImmediate":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\setImmediate.js","multihashing-async":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-record\\node_modules\\multihashing-async\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-record\src\validators\public-key.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const setImmediate = require('async/setImmediate')
const multihashing = require('multihashing-async')

/**
 * Validator for publick key records.
 * Verifies that the passed in record value is the PublicKey
 * that matches the passed in key.
 *
 * @param {Buffer} key - A valid key is of the form `'/pk/<keymultihash>'`
 * @param {Buffer} publicKey - The public key to validate against (protobuf encoded).
 * @param {function(Error)} callback
 * @returns {undefined}
 */
const validatePublicKeyRecord = (key, publicKey, callback) => {
  const done = (err) => setImmediate(() => callback(err))

  if (!Buffer.isBuffer(key)) {
    return done(new Error('"key" must be a Buffer'))
  }

  if (key.length < 3) {
    return done(new Error('invalid public key record'))
  }

  const prefix = key.slice(0, 4).toString()

  if (prefix !== '/pk/') {
    return done(new Error('key was not prefixed with /pk/'))
  }

  const keyhash = key.slice(4)

  multihashing(publicKey, 'sha2-256', (err, publicKeyHash) => {
    if (err) {
      return done(err)
    }

    if (!keyhash.equals(publicKeyHash)) {
      return done(new Error('public key does not match passed in key'))
    }

    done()
  })
}

module.exports = {
  func: validatePublicKeyRecord,
  sign: false
}

}).call(this)}).call(this,{"isBuffer":require("../../../is-buffer/index.js")})

      };
    };
  }
}, {package:"libp2p-record",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-record\\src\\validators\\public-key.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-ws\\index.js", {"./client":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-ws\\client.js","./duplex":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-ws\\duplex.js","./server":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js","./sink":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-ws\\sink.js","./source":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-ws\\source.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\pull-ws\index.js
      return function (require, module, exports) {
var exports = module.exports = require('./duplex')

exports.source = require('./source');
exports.sink = require('./sink');
exports.createServer = require('./server')
exports.connect = require('./client')

      };
    };
  }
}, {package:"pull-ws",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-ws\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\relative-url\\index.js", {"url":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\url\\url.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\relative-url\index.js
      return function (require, module, exports) {

//normalize a ws url.
var URL = require('url')
module.exports = function (url, location, protocolMap, defaultProtocol) {
  protocolMap = protocolMap ||{}
  /*

  https://nodejs.org/dist/latest-v6.x/docs/api/url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost

  I didn't know this, but url.parse takes a 3rd
  argument which interprets "//foo.com" as the hostname,
  but without the protocol. by default, // is interpreted
  as the path.

  that lets us do what the wsurl module does.
  https://www.npmjs.com/package/wsurl

  but most of the time, I want to write js
  that will work on localhost, and will work
  on a server...

  so I want to just do createWebSocket('/')
  and get "ws://mydomain.com/"

  */

  var url = URL.parse(url, false, true)

  var proto
  if(url.protocol) proto = url.protocol
  else {
    proto = location.protocol ? location.protocol.replace(/:$/,'') : 'http'
    proto = ((protocolMap)[proto] || defaultProtocol || proto) + ':'
  }

  //handle quirk in url package
  if(url.host && url.host[0] === ':')
    url.host = null

  //useful for websockets
  if(url.hostname) {
    return URL.format({
      protocol: proto,
      slashes: true,
      hostname: url.hostname,
      port: url.port,
      pathname: url.pathname,
      search: url.search
    })
  }
  else url.host = location.host

  //included for completeness. would you want to do this?
  if(url.port) {
    return URL.format({
      protocol: proto,
      slashes: true,
      host: location.hostname + ':' + url.port,
      port: url.port,
      pathname: url.pathname,
      search: url.search
    })
  }

  //definately useful for websockets
  if(url.pathname) {
    return URL.format({
      protocol: proto,
      slashes: true,
      host: url.host,
      pathname: url.pathname,
      search: url.search
    })
  }
  else
    url.pathname = location.pathname

  //included for completeness. would you want to do this?
  if(url.search) {
    return URL.format({
      protocol: proto,
      slashes: true,
      host: url.host,
      pathname: url.pathname,
      search: url.search
    })
  }
  else url.search = location.search

  return url.format(url)
}






      };
    };
  }
}, {package:"relative-url",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\relative-url\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-ws\\sink.js", {"./ready":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-ws\\ready.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","timers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\timers-browserify\\main.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\pull-ws\sink.js
      return function (require, module, exports) {
(function (process,setImmediate){(function (){
var ready = require('./ready');

/**
  ### `sink(socket, opts?)`

  Create a pull-stream `Sink` that will write data to the `socket`.

  <<< examples/write.js

**/

var nextTick = typeof setImmediate !== 'undefined' ? setImmediate : process.nextTick

module.exports = function(socket, opts) {
  return function (read) {
    opts = opts || {}
    var closeOnEnd = opts.closeOnEnd !== false;
    var onClose = 'function' === typeof opts ? opts : opts.onClose;

    function next(end, data) {
      // if the stream has ended, simply return
      if (end) {
        if (closeOnEnd && socket.readyState <= 1) {
          if(onClose)
            socket.addEventListener('close', function (ev) {
              if(ev.wasClean || ev.code === 1006) onClose()
              else {
                var err = new Error('ws error')
                err.event = ev
                onClose(err)
              }
            });

          socket.close()
        }

        return;
      }

      // socket ready?
      ready(socket, function(end) {
        if (end) {
          return read(end, function () {});
        }
        socket.send(data);
        nextTick(function() {
          read(null, next);
        });
      });
    }

    read(null, next);
  }
}

}).call(this)}).call(this,require('_process'),require("timers").setImmediate)

      };
    };
  }
}, {package:"pull-ws",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-ws\\sink.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-ws\\source.js", {"safe-buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\pull-ws\source.js
      return function (require, module, exports) {
/**
  ### `source(socket)`

  Create a pull-stream `Source` that will read data from the `socket`.

  <<< examples/read.js

**/
var Buffer = require('safe-buffer').Buffer;

// copied from github.com/feross/buffer
// Some ArrayBuffers are not passing the instanceof check, so we need to do a bit more work :(
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

module.exports = function(socket, cb) {
  var buffer = [];
  var receiver;
  var ended;
  var started = false;
  socket.addEventListener('message', function(evt) {
    var data = evt.data;
    if (isArrayBuffer(data)) {
      data = Buffer.from(data);
    }

    if (receiver) {
      return receiver(null, data);
    }

    buffer.push(data);
  });

  socket.addEventListener('close', function(evt) {
    if (ended) return
    if (receiver) {
      receiver(ended = true)
    }
  });

  socket.addEventListener('error', function (evt) {
    if (ended) return;
    ended = evt;
    if(!started) {
      started = true
      cb && cb(evt)
    }
    if (receiver) {
      receiver(ended)
    }
  });

  socket.addEventListener('open', function (evt) {
    if(started || ended) return
    started = true
  })

  function read(abort, cb) {
    receiver = null;

    //if stream has already ended.
    if (ended)
      return cb(ended);

    // if ended, abort
    else if (abort) {
      //this will callback when socket closes
      receiver = cb
      socket.close()
    }

    // return data, if any
    else if(buffer.length > 0)
      cb(null, buffer.shift());

    // wait for more data (or end)
    else
      receiver = cb;

  };

  return read;
};

      };
    };
  }
}, {package:"pull-ws",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-ws\\source.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\peer-list.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-kad-dht\src\peer-list.js
      return function (require, module, exports) {
'use strict'

/**
 * A list of unique peer infos.
 */
class PeerList {
  constructor () {
    this.list = []
  }

  /**
   * Add a new info. Returns `true` if it was a new one
   *
   * @param {PeerInfo} info
   * @returns {bool}
   */
  push (info) {
    if (!this.has(info)) {
      this.list.push(info)
      return true
    }
    return false
  }

  /**
   * Check if this PeerInfo is already in here.
   *
   * @param {PeerInfo} info
   * @returns {bool}
   */
  has (info) {
    const match = this.list.find((i) => i.id.isEqual(info.id))
    return Boolean(match)
  }

  /**
   * Get the list as an array.
   *
   * @returns {Array<PeerInfo>}
   */
  toArray () {
    return this.list.slice()
  }

  /**
   * Remove the last element
   *
   * @returns {PeerInfo}
   */
  pop () {
    return this.list.pop()
  }

  /**
   * The length of the list
   *
   * @type {number}
   */
  get length () {
    return this.list.length
  }
}

module.exports = PeerList

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\peer-list.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\node_modules\\multihashing-async\\src\\crypto.js", {"./blake":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\node_modules\\multihashing-async\\src\\blake.js","./crypto-sha1-2":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\node_modules\\multihashing-async\\src\\crypto-sha1-2-browser.js","./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\node_modules\\multihashing-async\\src\\utils.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","js-sha3":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\js-sha3\\src\\sha3.js","murmurhash3js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\murmurhash3js\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-kad-dht\node_modules\multihashing-async\src\crypto.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const sha3 = require('js-sha3')
const murmur3 = require('murmurhash3js')

const utils = require('./utils')
const sha = require('./crypto-sha1-2')

const toCallback = utils.toCallback
const toBuf = utils.toBuf
const fromString = utils.fromString
const fromNumberTo32BitBuf = utils.fromNumberTo32BitBuf

const dblSha2256 = (buf, cb) => {
  sha.sha2256(buf, (err, firstHash) => {
    if (err) {
      cb(err)
    }
    sha.sha2256((Buffer.from(firstHash)), cb)
  })
}

module.exports = {
  sha1: sha.sha1,
  sha2256: sha.sha2256,
  sha2512: sha.sha2512,
  sha3512: toCallback(toBuf(sha3.sha3_512)),
  sha3384: toCallback(toBuf(sha3.sha3_384)),
  sha3256: toCallback(toBuf(sha3.sha3_256)),
  sha3224: toCallback(toBuf(sha3.sha3_224)),
  shake128: toCallback(toBuf(sha3.shake_128, 128)),
  shake256: toCallback(toBuf(sha3.shake_256, 256)),
  keccak224: toCallback(toBuf(sha3.keccak_224)),
  keccak256: toCallback(toBuf(sha3.keccak_256)),
  keccak384: toCallback(toBuf(sha3.keccak_384)),
  keccak512: toCallback(toBuf(sha3.keccak_512)),
  murmur3128: toCallback(toBuf(fromString(murmur3.x64.hash128))),
  murmur332: toCallback(fromNumberTo32BitBuf(fromString(murmur3.x86.hash32))),
  addBlake: require('./blake'),
  dblSha2256: dblSha2256
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\node_modules\\multihashing-async\\src\\crypto.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eventemitter3\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eventemitter3\index.js
      return function (require, module, exports) {
'use strict';

var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if ('undefined' !== typeof module) {
  module.exports = EventEmitter;
}

      };
    };
  }
}, {package:"eventemitter3",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eventemitter3\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\peer-distance-list.js", {"./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\utils.js","async/map":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\map.js","xor-distance":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\xor-distance\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-kad-dht\src\peer-distance-list.js
      return function (require, module, exports) {
'use strict'

const distance = require('xor-distance')
const utils = require('./utils')
const map = require('async/map')

/**
 * Maintains a list of peerIds sorted by distance from a DHT key.
 */
class PeerDistanceList {
  /**
   * Creates a new PeerDistanceList.
   *
   * @param {Buffer} originDhtKey - the DHT key from which distance is calculated
   * @param {number} capacity - the maximum size of the list
   */
  constructor (originDhtKey, capacity) {
    this.originDhtKey = originDhtKey
    this.capacity = capacity
    this.peerDistances = []
  }

  /**
   * The length of the list
   */
  get length () {
    return this.peerDistances.length
  }

  /**
   * The peerIds in the list, in order of distance from the origin key
   */
  get peers () {
    return this.peerDistances.map(pd => pd.peerId)
  }

  /**
   * Add a peerId to the list.
   *
   * @param {PeerId} peerId
   * @param {function(Error)} callback
   * @returns {void}
   */
  add (peerId, callback) {
    if (this.peerDistances.find(pd => pd.peerId.id.equals(peerId.id))) {
      return callback()
    }

    utils.convertPeerId(peerId, (err, dhtKey) => {
      if (err) {
        return callback(err)
      }

      const el = {
        peerId,
        distance: distance(this.originDhtKey, dhtKey)
      }

      this.peerDistances.push(el)
      this.peerDistances.sort((a, b) => distance.compare(a.distance, b.distance))
      this.peerDistances = this.peerDistances.slice(0, this.capacity)

      callback()
    })
  }

  /**
   * Indicates whether any of the peerIds passed as a parameter are closer
   * to the origin key than the furthest peerId in the PeerDistanceList.
   *
   * @param {Array<PeerId>} peerIds
   * @param {function(Error, Boolean)} callback
   * @returns {void}
   */
  anyCloser (peerIds, callback) {
    if (!peerIds.length) {
      return callback(null, false)
    }

    if (!this.length) {
      return callback(null, true)
    }

    map(peerIds, (peerId, cb) => utils.convertPeerId(peerId, cb), (err, dhtKeys) => {
      if (err) {
        return callback(err)
      }

      const furthestDistance = this.peerDistances[this.peerDistances.length - 1].distance
      for (const dhtKey of dhtKeys) {
        const keyDistance = distance(this.originDhtKey, dhtKey)
        if (distance.compare(keyDistance, furthestDistance) < 0) {
          return callback(null, true)
        }
      }
      return callback(null, false)
    })
  }
}

module.exports = PeerDistanceList

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\peer-distance-list.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\query\\workerQueue.js", {"async/queue":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\queue.js","promise-to-callback":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\promise-to-callback\\index.js","promisify-es6":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\promisify-es6\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-kad-dht\src\query\workerQueue.js
      return function (require, module, exports) {
'use strict'

const queue = require('async/queue')
const promisify = require('promisify-es6')
const promiseToCallback = require('promise-to-callback')

class WorkerQueue {
  /**
   * Creates a new WorkerQueue.
   *
   * @param {DHT} dht
   * @param {Run} run
   * @param {Object} path
   * @param {function} log
   */
  constructor (dht, run, path, log) {
    this.dht = dht
    this.run = run
    this.path = path
    this.log = log

    this.concurrency = this.dht.concurrency
    this.queue = this.setupQueue()
    // a container for resolve/reject functions that will be populated
    // when execute() is called
    this.execution = null
  }

  /**
   * Create the underlying async queue.
   *
   * @returns {Object}
   */
  setupQueue () {
    const q = queue((peer, cb) => {
      promiseToCallback(this.processNext(peer))(cb)
    }, this.concurrency)

    // If there's an error, stop the worker
    q.error = (err) => {
      this.log.error('queue', err)
      this.stop(err)
    }

    // When all peers in the queue have been processed, stop the worker
    q.drain = () => {
      this.log('queue:drain')
      this.stop()
    }

    // When a space opens up in the queue, add some more peers
    q.unsaturated = () => {
      if (this.running) {
        this.fill()
      }
    }

    q.buffer = 0

    return q
  }

  /**
   * Stop the worker, optionally providing an error to pass to the worker's
   * callback.
   *
   * @param {Error} err
   */
  stop (err) {
    if (!this.running) {
      return
    }

    this.running = false
    this.queue.kill()
    this.log('worker:stop, %d workers still running', this.run.workers.filter(w => w.running).length)
    if (err) {
      this.execution.reject(err)
    } else {
      this.execution.resolve()
    }
  }

  /**
   * Use the queue from async to keep `concurrency` amount items running
   * per path.
   *
   * @return {Promise<void>}
   */
  async execute () {
    this.running = true
    // store the promise resolution functions to be resolved at end of queue
    this.execution = {}
    const execPromise = new Promise((resolve, reject) => Object.assign(this.execution, { resolve, reject }))
    // start queue
    this.fill()
    // await completion
    await execPromise
  }

  /**
   * Add peers to the worker queue until there are enough to satisfy the
   * worker queue concurrency.
   * Note that we don't want to take any more than those required to satisfy
   * concurrency from the peers-to-query queue, because we always want to
   * query the closest peers to the key first, and new peers are continously
   * being added to the peers-to-query queue.
   */
  fill () {
    // Note:
    // - queue.running(): number of items that are currently running
    // - queue.length(): the number of items that are waiting to be run
    while (this.queue.running() + this.queue.length() < this.concurrency &&
           this.path.peersToQuery.length > 0) {
      this.queue.push(this.path.peersToQuery.dequeue())
    }
  }

  /**
   * Process the next peer in the queue
   *
   * @param {PeerId} peer
   * @returns {Promise<void>}
   */
  async processNext (peer) {
    if (!this.running) {
      return
    }

    // The paths must be disjoint, meaning that no two paths in the Query may
    // traverse the same peer
    if (this.run.peersSeen.has(peer)) {
      return
    }

    // Check if we've queried enough peers already
    let continueQuerying, continueQueryingError
    try {
      continueQuerying = await this.run.continueQuerying(this)
    } catch (err) {
      continueQueryingError = err
    }

    // Abort and ignore any error if we're no longer running
    if (!this.running) {
      return
    }

    if (continueQueryingError) {
      throw continueQueryingError
    }

    // No peer we're querying is closer, stop the queue
    // This will cause queries that may potentially result in
    // closer nodes to be ended, but it reduces overall query time
    if (!continueQuerying) {
      this.stop()
      return
    }

    // Check if another path has queried this peer in the mean time
    if (this.run.peersSeen.has(peer)) {
      return
    }
    this.run.peersSeen.add(peer)

    // Execute the query on the next peer
    this.log('queue:work')
    let state, execError
    try {
      state = await this.execQuery(peer)
    } catch (err) {
      execError = err
    }

    // Abort and ignore any error if we're no longer running
    if (!this.running) {
      return
    }

    this.log('queue:work:done', execError, state)

    if (execError) {
      throw execError
    }

    // If query is complete, stop all workers.
    // Note: run.stop() calls stop() on all the workers, which kills the
    // queue and resolves execution
    if (state && state.queryComplete) {
      this.log('query:complete')
      this.run.stop()
      return
    }

    // If path is complete, just stop this worker.
    // Note: this.stop() kills the queue and resolves execution
    if (state && state.pathComplete) {
      this.stop()
    }
  }

  /**
   * Execute a query on the next peer.
   *
   * @param {PeerId} peer
   * @returns {Promise<void>}
   * @private
   */
  async execQuery (peer) {
    let res, queryError
    try {
      res = await this.path.queryFunc(peer)
    } catch (err) {
      queryError = err
    }

    // Abort and ignore any error if we're no longer running
    if (!this.running) {
      return
    }

    if (queryError) {
      this.run.errors.push(queryError)
      return
    }

    // Add the peer to the closest peers we have successfully queried
    await promisify(cb => this.run.peersQueried.add(peer, cb))()

    // If the query indicates that this path or the whole query is complete
    // set the path result and bail out
    if (res.pathComplete || res.queryComplete) {
      this.path.res = res
      return {
        pathComplete: res.pathComplete,
        queryComplete: res.queryComplete
      }
    }

    // If there are closer peers to query, add them to the queue
    if (res.closerPeers && res.closerPeers.length > 0) {
      await Promise.all(res.closerPeers.map(async (closer) => {
        // don't add ourselves
        if (this.dht._isSelf(closer.id)) {
          return
        }
        closer = this.dht.peerBook.put(closer)
        this.dht._peerDiscovered(closer)
        await this.path.addPeerToQuery(closer.id)
      }))
    }
  }
}

module.exports = WorkerQueue

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\query\\workerQueue.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\query\\path.js", {"../peer-queue":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\peer-queue.js","../utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-kad-dht\src\query\path.js
      return function (require, module, exports) {
'use strict'

const PeerQueue = require('../peer-queue')
const utils = require('../utils')

// TODO: Temporary until parallel dial in Switch have a proper
// timeout. Requires async/await refactor of transports and
// dial abort logic. This gives us 30s to complete the `queryFunc`.
// This should help reduce the high end call times of queries
const QUERY_FUNC_TIMEOUT = 30e3

/**
 * Manages a single Path through the DHT.
 */
class Path {
  /**
   * Creates a Path.
   *
   * @param {Run} run
   * @param {queryFunc} queryFunc
   */
  constructor (run, queryFunc) {
    this.run = run
    this.queryFunc = utils.withTimeout(queryFunc, QUERY_FUNC_TIMEOUT)
    if (!this.queryFunc) throw new Error('Path requires a `queryFn` to be specified')
    if (typeof this.queryFunc !== 'function') throw new Error('Path expected `queryFn` to be a function. Got ' + typeof this.queryFunc)

    /**
     * @type {Array<PeerId>}
     */
    this.initialPeers = []

    /**
     * @type {PeerQueue}
     */
    this.peersToQuery = null
  }

  /**
   * Add a peer to the set of peers that are used to intialize the path.
   *
   * @param {PeerId} peer
   */
  addInitialPeer (peer) {
    this.initialPeers.push(peer)
  }

  /**
   * Execute the path.
   *
   * @returns {Promise}
   *
   */
  async execute () {
    // Create a queue of peers ordered by distance from the key
    const queue = await PeerQueue.fromKey(this.run.query.key)
    // Add initial peers to the queue
    this.peersToQuery = queue
    await Promise.all(this.initialPeers.map(peer => this.addPeerToQuery(peer)))
    await this.run.workerQueue(this)
  }

  /**
   * Add a peer to the peers to be queried.
   *
   * @param {PeerId} peer
   * @returns {Promise<void>}
   */
  async addPeerToQuery (peer) {
    // Don't add self
    if (this.run.query.dht._isSelf(peer)) {
      return
    }

    // The paths must be disjoint, meaning that no two paths in the Query may
    // traverse the same peer
    if (this.run.peersSeen.has(peer)) {
      return
    }

    await this.peersToQuery.enqueue(peer)
  }
}

module.exports = Path

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\query\\path.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\rpc\\handlers\\index.js", {"../../message":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\message\\index.js","./add-provider":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\rpc\\handlers\\add-provider.js","./find-node":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\rpc\\handlers\\find-node.js","./get-providers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\rpc\\handlers\\get-providers.js","./get-value":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\rpc\\handlers\\get-value.js","./ping":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\rpc\\handlers\\ping.js","./put-value":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\rpc\\handlers\\put-value.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-kad-dht\src\rpc\handlers\index.js
      return function (require, module, exports) {
'use strict'

const T = require('../../message').TYPES

module.exports = (dht) => {
  const handlers = {
    [T.GET_VALUE]: require('./get-value')(dht),
    [T.PUT_VALUE]: require('./put-value')(dht),
    [T.FIND_NODE]: require('./find-node')(dht),
    [T.ADD_PROVIDER]: require('./add-provider')(dht),
    [T.GET_PROVIDERS]: require('./get-providers')(dht),
    [T.PING]: require('./ping')(dht)
  }

  /**
   * Get the message handler matching the passed in type.
   *
   * @param {number} type
   *
   * @returns {function(PeerInfo, Message, function(Error, Message))}
   *
   * @private
   */
  return function getMessageHandler (type) {
    return handlers[type]
  }
}

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\rpc\\handlers\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-websocket-star\\src\\errors\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-websocket-star\src\errors\index.js
      return function (require, module, exports) {
'use strict'

exports.ERR_WS_STAR_WEBSOCKET_CONNECTION = 'ERR_WS_STAR_WEBSOCKET_CONNECTION'

      };
    };
  }
}, {package:"libp2p-websocket-star",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-websocket-star\\src\\errors\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-pull-stream\\src\\index.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","data-queue":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\data-queue\\index.js","debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-pull-stream\\node_modules\\debug\\src\\browser.js","pull-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\index.js","uuid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-pull-stream\\node_modules\\uuid\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\socket.io-pull-stream\src\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

// socket.io-pull-stream
const Queue = require('data-queue')
const uuid = require('uuid')
const pull = require('pull-stream')
const sioname = (type, name) => 'socket.io-pull-stream.' + type + (name ? '.' + name : '')
const debug = require('debug')
const _log = debug('socket.io-pull-stream')

function doCodec (codec, data) {
  if (data == null) return data
  try {
    return codec(data)
  } catch (e) {
    console.error('Codec Error')
    console.error(e)
    return false
  }
}

const codecs = {
  hex: {
    encode: v => v.toString('hex'),
    decode: v => Buffer.from(v, 'hex')
  },
  plain: {
    encode: v => v,
    decode: v => v
  },
  buffer: { // always do Buffer.from because browsers
    encode: v => Buffer.from(v),
    decode: v => Buffer.from(v)
  }
}

function getCodec (c) {
  if (!c) c = 'plain'
  if (typeof c === 'object') return c
  const co = codecs[c]
  if (!co) throw new Error('Invalid codec ' + c)
  return co
}

function SIOSource (sio, id, opt) {
  const q = Queue()
  const log = sio.sioplog.bind(sio.sioplog, 'source(' + id + ')')
  const codec = getCodec(opt.codec).decode
  log('create source')
  sio.emit(sioname('accept', id))

  function unlisten () {
    sio.removeAllListeners(sioname('error', id))
    sio.removeAllListeners(sioname('queue', id))
  }

  sio.on(sioname('error', id), err => {
    if (err === true) log('finish')
    else log('error')
    unlisten()
    q.append({end: err})
  })
  sio.on(sioname('queue', id), data => {
    log('queue data')
    q.append({data: doCodec(codec, data)})
  })
  sio.once('disconnect', () => {
    unlisten()
    q.append({end: true})
  })
  return function (end, cb) {
    log('reading')
    if (end) return cb(end)
    q.get((err, data) => {
      if (err) return cb(err)
      if (data.end) {
        q.error(data.end)
        return cb(data.end)
      }
      return cb(null, data.data)
    })
  }
}

function SIOSink (sio, id, opt) {
  const q = Queue()
  const log = sio.sioplog.bind(sio.sioplog, '  sink(' + id + ')')
  const codec = getCodec(opt.codec).encode
  let ended
  log('create sink')
  sio.once(sioname('accept', id), () => {
    log('start transmission')

    function loop () {
      q.get((_, val) => {
        let {data, err} = val || {}
        if (_) err = _
        log('send', err && err === true ? 'finish' : err ? 'error' : data ? 'data' : '<invalid>')
        if (err && !_) q.error(err)
        if (err) return sio.emit(sioname('error', id), err)
        if (data) sio.emit(sioname('queue', id), doCodec(codec, data))
        loop()
      })
    }
    loop()
  })

  function doErr (end) {
    q.append({err: end})
    ended = end
  }

  sio.once('disconnect', () => doErr(true))

  return function (read) {
    read(null, function next (end, data) {
      if (end) return doErr(end)
      if (ended) return read(ended, next)
      q.append({data})
      read(null, next)
    })
  }
}

module.exports = function SIOPullStream (sio, opt) {
  if (sio.createSink) return
  sio.sioplog = sio.id ? _log.bind(_log, '[' + sio.id + ']') : _log
  sio.createSink = (id, _) => {
    if (!id) id = uuid()
    const sink = SIOSink(sio, id, opt || _)
    sink.id = id
    return sink
  }
  sio.createSource = (id, _) => {
    const source = SIOSource(sio, id, opt || _)
    source.id = id
    return source
  }
  sio.createProxy = (id, tsio, _) => {
    pull(
      sio.createSource(id, _),
      tsio.createSink(id, _)
    )
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"socket.io-pull-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-pull-stream\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-pair\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\pull-pair\index.js
      return function (require, module, exports) {
'use strict'

//a pair of pull streams where one drains from the other
module.exports = function () {
  var _read, waiting
  function sink (read) {
    if('function' !== typeof read)
      throw new Error('read must be function')

    if(_read)
      throw new Error('already piped')
    _read = read
    if(waiting) {
      var _waiting = waiting
      waiting = null
      _read.apply(null, _waiting)
    }
  }
  function source (abort, cb) {
    if(_read)
      _read(abort, cb)
    else
      waiting = [abort, cb]
  }

  return {
    source: source, sink: sink
  }
}


      };
    };
  }
}, {package:"pull-pair",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-pair\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-secio\\src\\support.js", {"async/parallel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\parallel.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","libp2p-crypto":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\src\\index.js","multihashing-async":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-secio\\node_modules\\multihashing-async\\src\\index.js","pull-length-prefixed":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-length-prefixed\\src\\index.js","pull-stream/pull":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\pull.js","pull-stream/sinks/collect":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\sinks\\collect.js","pull-stream/sources/values":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\sources\\values.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-secio\src\support.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const mh = require('multihashing-async')
const lp = require('pull-length-prefixed')
const pull = require('pull-stream/pull')
const values = require('pull-stream/sources/values')
const collect = require('pull-stream/sinks/collect')
const crypto = require('libp2p-crypto')
const parallel = require('async/parallel')

exports.exchanges = [
  'P-256',
  'P-384',
  'P-521'
]

exports.ciphers = [
  'AES-256',
  'AES-128'
]

exports.hashes = [
  'SHA256',
  'SHA512'
]

// Determines which algorithm to use.  Note:  f(a, b) = f(b, a)
exports.theBest = (order, p1, p2) => {
  let first
  let second

  if (order < 0) {
    first = p2
    second = p1
  } else if (order > 0) {
    first = p1
    second = p2
  } else {
    return p1[0]
  }

  for (let firstCandidate of first) {
    for (let secondCandidate of second) {
      if (firstCandidate === secondCandidate) {
        return firstCandidate
      }
    }
  }

  throw new Error('No algorithms in common!')
}

exports.makeMacAndCipher = (target, callback) => {
  parallel([
    (cb) => makeMac(target.hashT, target.keys.macKey, cb),
    (cb) => makeCipher(target.cipherT, target.keys.iv, target.keys.cipherKey, cb)
  ], (err, macAndCipher) => {
    if (err) {
      return callback(err)
    }

    target.mac = macAndCipher[0]
    target.cipher = macAndCipher[1]
    callback()
  })
}

function makeMac (hash, key, callback) {
  crypto.hmac.create(hash, key, callback)
}

function makeCipher (cipherType, iv, key, callback) {
  if (cipherType === 'AES-128' || cipherType === 'AES-256') {
    return crypto.aes.create(key, iv, callback)
  }

  // TODO: figure out if Blowfish is needed and if so find a library for it.
  callback(new Error(`unrecognized cipher type: ${cipherType}`))
}

exports.selectBest = (local, remote, cb) => {
  exports.digest(Buffer.concat([
    remote.pubKeyBytes,
    local.nonce
  ]), (err, oh1) => {
    if (err) {
      return cb(err)
    }

    exports.digest(Buffer.concat([
      local.pubKeyBytes,
      remote.nonce
    ]), (err, oh2) => {
      if (err) {
        return cb(err)
      }

      const order = Buffer.compare(oh1, oh2)

      if (order === 0) {
        return cb(new Error('you are trying to talk to yourself'))
      }

      cb(null, {
        curveT: exports.theBest(order, local.exchanges, remote.exchanges),
        cipherT: exports.theBest(order, local.ciphers, remote.ciphers),
        hashT: exports.theBest(order, local.hashes, remote.hashes),
        order
      })
    })
  })
}

exports.digest = (buf, cb) => {
  mh.digest(buf, 'sha2-256', buf.length, cb)
}

exports.write = function write (state, msg, cb) {
  cb = cb || (() => {})
  pull(
    values([msg]),
    lp.encode({ fixed: true, bytes: 4 }),
    collect((err, res) => {
      if (err) {
        return cb(err)
      }
      state.shake.write(res[0])
      cb()
    })
  )
}

exports.read = function read (reader, cb) {
  lp.decodeFromReader(reader, { fixed: true, bytes: 4 }, cb)
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"libp2p-secio",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-secio\\src\\support.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-secio\\src\\handshake\\crypto.js", {"../support":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-secio\\src\\support.js","./secio.proto":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-secio\\src\\handshake\\secio.proto.js","async/parallel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\parallel.js","async/waterfall":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\waterfall.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debug\\src\\browser.js","libp2p-crypto":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\src\\index.js","peer-id":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-id\\src\\index.js","protons":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\protons\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-secio\src\handshake\crypto.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const protons = require('protons')
const PeerId = require('peer-id')
const crypto = require('libp2p-crypto')
const parallel = require('async/parallel')
const waterfall = require('async/waterfall')
const debug = require('debug')
const log = debug('libp2p:secio')
log.error = debug('libp2p:secio:error')

const pbm = protons(require('./secio.proto'))

const support = require('../support')

// nonceSize is the size of our nonces (in bytes)
const nonceSize = 16

exports.createProposal = (state) => {
  state.proposal.out = {
    rand: crypto.randomBytes(nonceSize),
    pubkey: state.key.local.public.bytes,
    exchanges: support.exchanges.join(','),
    ciphers: support.ciphers.join(','),
    hashes: support.hashes.join(',')
  }

  state.proposalEncoded.out = pbm.Propose.encode(state.proposal.out)
  return state.proposalEncoded.out
}

exports.createExchange = (state, callback) => {
  crypto.keys.generateEphemeralKeyPair(state.protocols.local.curveT, (err, res) => {
    if (err) {
      return callback(err)
    }

    state.ephemeralKey.local = res.key
    state.shared.generate = res.genSharedKey

    // Gather corpus to sign.
    const selectionOut = Buffer.concat([
      state.proposalEncoded.out,
      state.proposalEncoded.in,
      state.ephemeralKey.local
    ])

    state.key.local.sign(selectionOut, (err, sig) => {
      if (err) {
        return callback(err)
      }

      state.exchange.out = {
        epubkey: state.ephemeralKey.local,
        signature: sig
      }

      callback(null, pbm.Exchange.encode(state.exchange.out))
    })
  })
}

exports.identify = (state, msg, callback) => {
  log('1.1 identify')

  state.proposalEncoded.in = msg
  state.proposal.in = pbm.Propose.decode(msg)
  const pubkey = state.proposal.in.pubkey

  state.key.remote = crypto.keys.unmarshalPublicKey(pubkey)

  PeerId.createFromPubKey(pubkey.toString('base64'), (err, remoteId) => {
    if (err) {
      return callback(err)
    }

    // If we know who we are dialing to, double check
    if (state.id.remote) {
      if (state.id.remote.toB58String() !== remoteId.toB58String()) {
        return callback(new Error('dialed to the wrong peer, Ids do not match'))
      }
    } else {
      state.id.remote = remoteId
    }

    log('1.1 identify - %s - identified remote peer as %s', state.id.local.toB58String(), state.id.remote.toB58String())
    callback()
  })
}

exports.selectProtocols = (state, callback) => {
  log('1.2 selection')

  const local = {
    pubKeyBytes: state.key.local.public.bytes,
    exchanges: support.exchanges,
    hashes: support.hashes,
    ciphers: support.ciphers,
    nonce: state.proposal.out.rand
  }

  const remote = {
    pubKeyBytes: state.proposal.in.pubkey,
    exchanges: state.proposal.in.exchanges.split(','),
    hashes: state.proposal.in.hashes.split(','),
    ciphers: state.proposal.in.ciphers.split(','),
    nonce: state.proposal.in.rand
  }

  support.selectBest(local, remote, (err, selected) => {
    if (err) {
      return callback(err)
    }
    // we use the same params for both directions (must choose same curve)
    // WARNING: if they dont SelectBest the same way, this won't work...
    state.protocols.remote = {
      order: selected.order,
      curveT: selected.curveT,
      cipherT: selected.cipherT,
      hashT: selected.hashT
    }

    state.protocols.local = {
      order: selected.order,
      curveT: selected.curveT,
      cipherT: selected.cipherT,
      hashT: selected.hashT
    }
    callback()
  })
}

exports.verify = (state, msg, callback) => {
  log('2.1. verify')

  state.exchange.in = pbm.Exchange.decode(msg)
  state.ephemeralKey.remote = state.exchange.in.epubkey

  const selectionIn = Buffer.concat([
    state.proposalEncoded.in,
    state.proposalEncoded.out,
    state.ephemeralKey.remote
  ])

  state.key.remote.verify(selectionIn, state.exchange.in.signature, (err, sigOk) => {
    if (err) {
      return callback(err)
    }

    if (!sigOk) {
      return callback(new Error('Bad signature'))
    }

    log('2.1. verify - signature verified')
    callback()
  })
}

exports.generateKeys = (state, callback) => {
  log('2.2. keys')

  waterfall([
    (cb) => state.shared.generate(state.exchange.in.epubkey, cb),
    (secret, cb) => {
      state.shared.secret = secret

      crypto.keys.keyStretcher(
        state.protocols.local.cipherT,
        state.protocols.local.hashT,
        state.shared.secret,
        cb
      )
    },
    (keys, cb) => {
      // use random nonces to decide order.
      if (state.protocols.local.order > 0) {
        state.protocols.local.keys = keys.k1
        state.protocols.remote.keys = keys.k2
      } else if (state.protocols.local.order < 0) {
        // swap
        state.protocols.local.keys = keys.k2
        state.protocols.remote.keys = keys.k1
      } else {
        // we should've bailed before state. but if not, bail here.
        return cb(new Error('you are trying to talk to yourself'))
      }

      log('2.3. mac + cipher')

      parallel([
        (_cb) => support.makeMacAndCipher(state.protocols.local, _cb),
        (_cb) => support.makeMacAndCipher(state.protocols.remote, _cb)
      ], cb)
    }
  ], callback)
}

exports.verifyNonce = (state, n2) => {
  const n1 = state.proposal.out.rand

  if (n1.equals(n2)) return

  throw new Error(
    `Failed to read our encrypted nonce: ${n1.toString('hex')} != ${n2.toString('hex')}`
  )
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"libp2p-secio",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-secio\\src\\handshake\\crypto.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-secio\\src\\etm.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","pull-length-prefixed":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-length-prefixed\\src\\index.js","pull-stream/pull":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\pull.js","pull-stream/throughs/async-map":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\throughs\\async-map.js","pull-stream/throughs/map":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\throughs\\map.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-secio\src\etm.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const pull = require('pull-stream/pull')
const map = require('pull-stream/throughs/map')
const asyncMap = require('pull-stream/throughs/async-map')
const lp = require('pull-length-prefixed')

const lpOpts = {
  fixed: true,
  bytes: 4
}

exports.createBoxStream = (cipher, mac) => {
  return pull(
    ensureBuffer(),
    asyncMap((chunk, cb) => {
      cipher.encrypt(chunk, (err, data) => {
        if (err) {
          return cb(err)
        }

        mac.digest(data, (err, digest) => {
          if (err) {
            return cb(err)
          }

          cb(null, Buffer.concat([data, digest]))
        })
      })
    }),
    lp.encode(lpOpts)
  )
}

exports.createUnboxStream = (decipher, mac) => {
  return pull(
    ensureBuffer(),
    lp.decode(lpOpts),
    asyncMap((chunk, cb) => {
      const l = chunk.length
      const macSize = mac.length

      if (l < macSize) {
        return cb(new Error(`buffer (${l}) shorter than MAC size (${macSize})`))
      }

      const mark = l - macSize
      const data = chunk.slice(0, mark)
      const macd = chunk.slice(mark)

      mac.digest(data, (err, expected) => {
        if (err) {
          return cb(err)
        }

        if (!macd.equals(expected)) {
          return cb(new Error(`MAC Invalid: ${macd.toString('hex')} != ${expected.toString('hex')}`))
        }

        // all good, decrypt
        decipher.decrypt(data, (err, decrypted) => {
          if (err) {
            return cb(err)
          }

          cb(null, decrypted)
        })
      })
    })
  )
}

function ensureBuffer () {
  return map((c) => {
    if (typeof c === 'string') {
      return Buffer.from(c, 'utf-8')
    }

    return c
  })
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"libp2p-secio",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-secio\\src\\etm.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\end-of-stream.js", {"../../../errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\errors-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\simple-peer\node_modules\readable-stream\lib\internal\streams\end-of-stream.js
      return function (require, module, exports) {
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\end-of-stream.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\pipeline.js", {"../../../errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\errors-browser.js","./end-of-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\end-of-stream.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\simple-peer\node_modules\readable-stream\lib\internal\streams\pipeline.js
      return function (require, module, exports) {
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\pipeline.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\_stream_transform.js", {"../errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\errors-browser.js","./_stream_duplex":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\_stream_duplex.js","inherits":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\inherits\\inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\simple-peer\node_modules\readable-stream\lib\_stream_transform.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\_stream_transform.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\_stream_passthrough.js", {"./_stream_transform":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\_stream_transform.js","inherits":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\inherits\\inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\simple-peer\node_modules\readable-stream\lib\_stream_passthrough.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\_stream_passthrough.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\_stream_duplex.js", {"./_stream_readable":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\_stream_readable.js","./_stream_writable":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\_stream_writable.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","inherits":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\inherits\\inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\simple-peer\node_modules\readable-stream\lib\_stream_duplex.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\_stream_duplex.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\_stream_writable.js", {"../errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\errors-browser.js","./_stream_duplex":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\_stream_duplex.js","./internal/streams/destroy":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\destroy.js","./internal/streams/state":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\state.js","./internal/streams/stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\stream-browser.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","inherits":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\inherits\\inherits_browser.js","util-deprecate":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\util-deprecate\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\simple-peer\node_modules\readable-stream\lib\_stream_writable.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\_stream_writable.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\_stream_readable.js", {"../errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\errors-browser.js","./_stream_duplex":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\_stream_duplex.js","./internal/streams/async_iterator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\async_iterator.js","./internal/streams/buffer_list":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\buffer_list.js","./internal/streams/destroy":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\destroy.js","./internal/streams/from":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\from-browser.js","./internal/streams/state":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\state.js","./internal/streams/stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\stream-browser.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","inherits":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\inherits\\inherits_browser.js","string_decoder/":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\string_decoder\\lib\\string_decoder.js","util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\simple-peer\node_modules\readable-stream\lib\_stream_readable.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\_stream_readable.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\parseuri\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\parseuri\index.js
      return function (require, module, exports) {
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    uri.pathNames = pathNames(uri, uri['path']);
    uri.queryKey = queryKey(uri, uri['query']);

    return uri;
};

function pathNames(obj, path) {
    var regx = /\/{2,9}/g,
        names = path.replace(regx, "/").split("/");

    if (path.substr(0, 1) == '/' || path.length === 0) {
        names.splice(0, 1);
    }
    if (path.substr(path.length - 1, 1) == '/') {
        names.splice(names.length - 1, 1);
    }

    return names;
}

function queryKey(uri, query) {
    var data = {};

    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
        if ($1) {
            data[$1] = $2;
        }
    });

    return data;
}

      };
    };
  }
}, {package:"parseuri",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\parseuri\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-client\\lib\\on.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\socket.io-client\lib\on.js
      return function (require, module, exports) {

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on (obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function () {
      obj.removeListener(ev, fn);
    }
  };
}

      };
    };
  }
}, {package:"socket.io-client",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-client\\lib\\on.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\component-bind\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\component-bind\index.js
      return function (require, module, exports) {
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

      };
    };
  }
}, {package:"component-bind",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\component-bind\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\parseqs\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\parseqs\index.js
      return function (require, module, exports) {
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

      };
    };
  }
}, {package:"parseqs",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\parseqs\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\to-array\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\to-array\index.js
      return function (require, module, exports) {
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

      };
    };
  }
}, {package:"to-array",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\to-array\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\has-binary2\\index.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","isarray":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\has-binary2\\node_modules\\isarray\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\has-binary2\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/* global Blob File */

/*
 * Module requirements.
 */

var isArray = require('isarray');

var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' ||
                        typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]';
var withNativeFile = typeof File === 'function' ||
                        typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]';

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Supports Buffer, ArrayBuffer, Blob and File.
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary (obj) {
  if (!obj || typeof obj !== 'object') {
    return false;
  }

  if (isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }

  if ((typeof Buffer === 'function' && Buffer.isBuffer && Buffer.isBuffer(obj)) ||
    (typeof ArrayBuffer === 'function' && obj instanceof ArrayBuffer) ||
    (withNativeBlob && obj instanceof Blob) ||
    (withNativeFile && obj instanceof File)
  ) {
    return true;
  }

  // see: https://github.com/Automattic/has-binary/pull/4
  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }

  return false;
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"has-binary2",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\has-binary2\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-client\\node_modules\\debug\\src\\debug.js", {"ms":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-client\\node_modules\\ms\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\socket.io-client\node_modules\debug\src\debug.js
      return function (require, module, exports) {

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

      };
    };
  }
}, {package:"debug",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-client\\node_modules\\debug\\src\\debug.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-parser\\node_modules\\isarray\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\socket.io-parser\node_modules\isarray\index.js
      return function (require, module, exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

      };
    };
  }
}, {package:"isarray",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-parser\\node_modules\\isarray\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-parser\\is-buffer.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\socket.io-parser\is-buffer.js
      return function (require, module, exports) {
(function (Buffer){(function (){

module.exports = isBuf;

var withNativeBuffer = typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function';
var withNativeArrayBuffer = typeof ArrayBuffer === 'function';

var isView = function (obj) {
  return typeof ArrayBuffer.isView === 'function' ? ArrayBuffer.isView(obj) : (obj.buffer instanceof ArrayBuffer);
};

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (withNativeBuffer && Buffer.isBuffer(obj)) ||
          (withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)));
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"socket.io-parser",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-parser\\is-buffer.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-parser\\binary.js", {"./is-buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-parser\\is-buffer.js","isarray":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-parser\\node_modules\\isarray\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\socket.io-parser\binary.js
      return function (require, module, exports) {
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = require('isarray');
var isBuf = require('./is-buffer');
var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' || (typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]');
var withNativeFile = typeof File === 'function' || (typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

function _deconstructPacket(data, buffers) {
  if (!data) return data;

  if (isBuf(data)) {
    var placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (isArray(data)) {
    var newData = new Array(data.length);
    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (typeof data === 'object' && !(data instanceof Date)) {
    var newData = {};
    for (var key in data) {
      newData[key] = _deconstructPacket(data[key], buffers);
    }
    return newData;
  }
  return data;
}

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = undefined; // no longer useful
  return packet;
};

function _reconstructPacket(data, buffers) {
  if (!data) return data;

  if (data && data._placeholder) {
    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
  } else if (isArray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === 'object') {
    for (var key in data) {
      data[key] = _reconstructPacket(data[key], buffers);
    }
  }

  return data;
}

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (typeof obj === 'object' && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

      };
    };
  }
}, {package:"socket.io-parser",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-parser\\binary.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-parser\\node_modules\\debug\\src\\browser.js", {"./debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-parser\\node_modules\\debug\\src\\debug.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\socket.io-parser\node_modules\debug\src\browser.js
      return function (require, module, exports) {
(function (process){(function (){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"debug",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-parser\\node_modules\\debug\\src\\browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\backo2\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\backo2\index.js
      return function (require, module, exports) {

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


      };
    };
  }
}, {package:"backo2",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\backo2\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\indexof\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\indexof\index.js
      return function (require, module, exports) {

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
      };
    };
  }
}, {package:"indexof",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\indexof\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\index.js", {"./socket":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\socket.js","engine.io-parser":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-parser\\lib\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\engine.io-client\lib\index.js
      return function (require, module, exports) {

module.exports = require('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = require('engine.io-parser');

      };
    };
  }
}, {package:"engine.io-client",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-ping\\src\\constants.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-ping\src\constants.js
      return function (require, module, exports) {
'use strict'

module.exports = {
  PROTOCOL: '/ipfs/ping/1.0.0',
  PING_LENGTH: 32
}

      };
    };
  }
}, {package:"libp2p-ping",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-ping\\src\\constants.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-ping\\src\\util.js", {"./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-ping\\src\\constants.js","libp2p-crypto":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-ping\src\util.js
      return function (require, module, exports) {
'use strict'

const crypto = require('libp2p-crypto')
const constants = require('./constants')

exports = module.exports

exports.rnd = (length) => {
  if (!length) {
    length = constants.PING_LENGTH
  }
  return crypto.randomBytes(length)
}

      };
    };
  }
}, {package:"libp2p-ping",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-ping\\src\\util.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-floodsub\\src\\config.js", {"debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debug\\src\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-floodsub\src\config.js
      return function (require, module, exports) {
'use strict'

const debug = require('debug')

const log = debug('libp2p:floodsub')
log.err = debug('libp2p:floodsub:error')

module.exports = {
  log: log,
  multicodec: '/floodsub/1.0.0'
}

      };
    };
  }
}, {package:"libp2p-floodsub",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-floodsub\\src\\config.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-pubsub\\src\\index.js", {"./message":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-pubsub\\src\\message\\index.js","./message/sign":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-pubsub\\src\\message\\sign.js","./peer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-pubsub\\src\\peer.js","./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-pubsub\\src\\utils.js","async/each":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\each.js","async/nextTick":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\nextTick.js","debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debug\\src\\browser.js","err-code":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\err-code\\index.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","pull-stream/pull":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\pull.js","pull-stream/sources/empty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\sources\\empty.js","time-cache":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\time-cache\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-pubsub\src\index.js
      return function (require, module, exports) {
'use strict'

const EventEmitter = require('events')
const pull = require('pull-stream/pull')
const empty = require('pull-stream/sources/empty')
const asyncEach = require('async/each')
const TimeCache = require('time-cache')
const debug = require('debug')
const errcode = require('err-code')

const Peer = require('./peer')
const message = require('./message')
const { signMessage } = require('./message/sign')
const utils = require('./utils')

const nextTick = require('async/nextTick')

/**
 * PubsubBaseProtocol handles the peers and connections logic for pubsub routers
 */
class PubsubBaseProtocol extends EventEmitter {
  /**
   * @param {String} debugName
   * @param {String} multicodec
   * @param {Object} libp2p libp2p implementation
   * @param {Object} options
   * @param {boolean} options.signMessages if messages should be signed, defaults to true
   * @constructor
   */
  constructor (debugName, multicodec, libp2p, options) {
    super()

    options = {
      signMessages: true,
      ...options
    }

    this.log = debug(debugName)
    this.log.err = debug(`${debugName}:error`)
    this.multicodec = multicodec
    this.libp2p = libp2p
    this.started = false

    if (options.signMessages) {
      this.peerId = this.libp2p.peerInfo.id
    }

    /**
     * Map of topics to which peers are subscribed to
     *
     * @type {Map<string, Peer>}
     */
    this.topics = new Map()

    /**
     * Cache of seen messages
     *
     * @type {TimeCache}
     */
    this.seenCache = new TimeCache()

    /**
     * Map of peers.
     *
     * @type {Map<string, Peer>}
     */
    this.peers = new Map()

    // Dials that are currently in progress
    this._dials = new Set()

    this._onConnection = this._onConnection.bind(this)
    this._dialPeer = this._dialPeer.bind(this)
  }

  /**
   * Add a new connected peer to the peers map.
   * @private
   * @param {PeerInfo} peer peer info
   * @returns {PeerInfo}
   */
  _addPeer (peer) {
    const id = peer.info.id.toB58String()

    /*
      Always use an existing peer.

      What is happening here is: "If the other peer has already dialed to me, we already have
      an establish link between the two, what might be missing is a
      Connection specifically between me and that Peer"
     */
    let existing = this.peers.get(id)
    if (!existing) {
      this.log('new peer', id)
      this.peers.set(id, peer)
      existing = peer

      peer.once('close', () => this._removePeer(peer))
    }
    ++existing._references

    return existing
  }

  /**
   * Remove a peer from the peers map if it has no references.
   * @private
   * @param {Peer} peer peer state
   * @returns {PeerInfo}
   */
  _removePeer (peer) {
    const id = peer.info.id.toB58String()

    this.log('remove', id, peer._references)
    // Only delete when no one else is referencing this peer.
    if (--peer._references === 0) {
      this.log('delete peer', id)
      this.peers.delete(id)
    }

    return peer
  }

  /**
   * Dial a received peer.
   * @private
   * @param {PeerInfo} peerInfo peer info
   * @param {function} callback
   * @returns {void}
   */
  _dialPeer (peerInfo, callback) {
    callback = callback || function noop () { }
    const idB58Str = peerInfo.id.toB58String()

    // If already have a PubSub conn, ignore
    const peer = this.peers.get(idB58Str)
    if (peer && peer.isConnected) {
      return nextTick(() => callback())
    }

    // If already dialing this peer, ignore
    if (this._dials.has(idB58Str)) {
      this.log('already dialing %s, ignoring dial attempt', idB58Str)
      return nextTick(() => callback())
    }
    this._dials.add(idB58Str)

    this.log('dialing %s', idB58Str)
    this.libp2p.dialProtocol(peerInfo, this.multicodec, (err, conn) => {
      this.log('dial to %s complete', idB58Str)

      // If the dial is not in the set, it means that pubsub has been
      // stopped
      const pubsubStopped = !this._dials.has(idB58Str)
      this._dials.delete(idB58Str)

      if (err) {
        this.log.err(err)
        return callback()
      }

      // pubsub has been stopped, so we should just bail out
      if (pubsubStopped) {
        this.log('pubsub was stopped, not processing dial to %s', idB58Str)
        return callback()
      }

      this._onDial(peerInfo, conn, callback)
    })
  }

  /**
   * Dial a received peer.
   * @private
   * @param {PeerInfo} peerInfo peer info
   * @param {Connection} conn connection to the peer
   * @param {function} callback
   */
  _onDial (peerInfo, conn, callback) {
    const idB58Str = peerInfo.id.toB58String()
    this.log('connected', idB58Str)

    const peer = this._addPeer(new Peer(peerInfo))
    peer.attachConnection(conn)

    nextTick(() => callback())
  }

  /**
   * On successful connection event.
   * @private
   * @param {String} protocol connection protocol
   * @param {Connection} conn connection to the peer
   */
  _onConnection (protocol, conn) {
    conn.getPeerInfo((err, peerInfo) => {
      if (err) {
        this.log.err('Failed to identify incomming conn', err)
        return pull(empty(), conn)
      }

      const idB58Str = peerInfo.id.toB58String()
      const peer = this._addPeer(new Peer(peerInfo))

      this._processConnection(idB58Str, conn, peer)
    })
  }

  /**
   * Overriding the implementation of _processConnection should keep the connection and is
   * responsible for processing each RPC message received by other peers.
   * @abstract
   * @param {string} idB58Str peer id string in base58
   * @param {Connection} conn connection
   * @param {PeerInfo} peer peer info
   * @returns {undefined}
   *
   */
  _processConnection (idB58Str, conn, peer) {
    throw errcode('_processConnection must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED')
  }

  /**
   * On connection end event.
   * @private
   * @param {string} idB58Str peer id string in base58
   * @param {PeerInfo} peer peer info
   * @param {Error} err error for connection end
   */
  _onConnectionEnd (idB58Str, peer, err) {
    // socket hang up, means the one side canceled
    if (err && err.message !== 'socket hang up') {
      this.log.err(err)
    }

    this.log('connection ended', idB58Str, err ? err.message : '')
    this._removePeer(peer)
  }

  /**
   * Normalizes the message and signs it, if signing is enabled
   *
   * @param {Message} message
   * @param {function(Error, Message)} callback
   */
  _buildMessage (message, callback) {
    const msg = utils.normalizeOutRpcMessage(message)
    if (this.peerId) {
      signMessage(this.peerId, msg, callback)
    } else {
      nextTick(callback, null, msg)
    }
  }

  /**
   * Overriding the implementation of publish should handle the appropriate algorithms for the publish/subscriber implementation.
   * For example, a Floodsub implementation might simply publish each message to each topic for every peer
   * @abstract
   * @param {Array<string>|string} topics
   * @param {Array<any>|any} messages
   * @param {function(Error)} callback
   * @returns {undefined}
   *
   */
  publish (topics, messages, callback) {
    throw errcode('publish must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED')
  }

  /**
   * Overriding the implementation of subscribe should handle the appropriate algorithms for the publish/subscriber implementation.
   * For example, a Floodsub implementation might simply send a message for every peer showing interest in the topics
   * @abstract
   * @param {Array<string>|string} topics
   * @returns {undefined}
   */
  subscribe (topics) {
    throw errcode('subscribe must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED')
  }

  /**
   * Overriding the implementation of unsubscribe should handle the appropriate algorithms for the publish/subscriber implementation.
   * For example, a Floodsub implementation might simply send a message for every peer revoking interest in the topics
   * @abstract
   * @param {Array<string>|string} topics
   * @returns {undefined}
   */
  unsubscribe (topics) {
    throw errcode('unsubscribe must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED')
  }

  /**
   * Mounts the pubsub protocol onto the libp2p node and sends our
   * subscriptions to every peer conneceted
   *
   * @param {Function} callback
   * @returns {undefined}
   *
   */
  start (callback) {
    if (this.started) {
      return nextTick(() => callback(new Error('already started')))
    }
    this.log('starting')

    this.libp2p.handle(this.multicodec, this._onConnection)

    // Speed up any new peer that comes in my way
    this.libp2p.on('peer:connect', this._dialPeer)

    // Dial already connected peers
    const peerInfos = Object.values(this.libp2p.peerBook.getAll())

    asyncEach(peerInfos, (peer, cb) => this._dialPeer(peer, cb), (err) => {
      nextTick(() => {
        this.log('started')
        this.started = true
        callback(err)
      })
    })
  }

  /**
   * Unmounts the pubsub protocol and shuts down every connection
   *
   * @param {Function} callback
   * @returns {undefined}
   *
   */
  stop (callback) {
    if (!this.started) {
      return nextTick(() => callback(new Error('not started yet')))
    }

    this.libp2p.unhandle(this.multicodec)
    this.libp2p.removeListener('peer:connect', this._dialPeer)

    // Prevent any dials that are in flight from being processed
    this._dials = new Set()

    this.log('stopping')
    asyncEach(this.peers.values(), (peer, cb) => peer.close(cb), (err) => {
      if (err) {
        return callback(err)
      }

      this.log('stopped')
      this.peers = new Map()
      this.started = false
      callback()
    })
  }
}

module.exports = PubsubBaseProtocol
module.exports.message = message
module.exports.utils = utils

      };
    };
  }
}, {package:"libp2p-pubsub",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-pubsub\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\latency-monitor\\dist\\LatencyMonitor.js", {"./VisibilityChangeEmitter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\latency-monitor\\dist\\VisibilityChangeEmitter.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\latency-monitor\\node_modules\\debug\\src\\browser.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","lodash/get":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\get.js","lodash/isFunction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\isFunction.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\latency-monitor\dist\LatencyMonitor.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _get = require('lodash/get');

var _get2 = _interopRequireDefault(_get);

var _isFunction = require('lodash/isFunction');

var _isFunction2 = _interopRequireDefault(_isFunction);

var _VisibilityChangeEmitter = require('./VisibilityChangeEmitter');

var _VisibilityChangeEmitter2 = _interopRequireDefault(_VisibilityChangeEmitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* global window */


var debug = require('debug')('latency-monitor:LatencyMonitor');

/**
 * @typedef {Object} SummaryObject
 * @property {Number} events How many events were called
 * @property {Number} minMS What was the min time for a cb to be called
 * @property {Number} maxMS What was the max time for a cb to be called
 * @property {Number} avgMs What was the average time for a cb to be called
 * @property {Number} lengthMs How long this interval was in ms
 */

/**
 * A class to monitor latency of any async function which works in a browser or node. This works by periodically calling
 * the asyncTestFn and timing how long it takes the callback to be called. It can also periodically emit stats about this.
 * This can be disabled and stats can be pulled via setting dataEmitIntervalMs = 0.
 *
 * The default implementation is an event loop latency monitor. This works by firing periodic events into the event loop
 * and timing how long it takes to get back.
 *
 * @example
 * const monitor = new LatencyMonitor();
 * monitor.on('data', (summary) => console.log('Event Loop Latency: %O', summary));
 *
 * @example
 * const monitor = new LatencyMonitor({latencyCheckIntervalMs: 1000, dataEmitIntervalMs: 60000, asyncTestFn:ping});
 * monitor.on('data', (summary) => console.log('Ping Pong Latency: %O', summary));
 */

var LatencyMonitor = function (_EventEmitter) {
    _inherits(LatencyMonitor, _EventEmitter);

    /**
     * @param {Number} [latencyCheckIntervalMs=500] How often to add a latency check event (ms)
     * @param {Number} [dataEmitIntervalMs=5000] How often to summarize latency check events. null or 0 disables event firing
     * @param {function} [asyncTestFn] What cb-style async function to use
     * @param {Number} [latencyRandomPercentage=5] What percent (+/-) of latencyCheckIntervalMs should we randomly use? This helps avoid alignment to other events.
     */
    function LatencyMonitor() {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            latencyCheckIntervalMs = _ref.latencyCheckIntervalMs,
            dataEmitIntervalMs = _ref.dataEmitIntervalMs,
            asyncTestFn = _ref.asyncTestFn,
            latencyRandomPercentage = _ref.latencyRandomPercentage;

        _classCallCheck(this, LatencyMonitor);

        var _this = _possibleConstructorReturn(this, (LatencyMonitor.__proto__ || Object.getPrototypeOf(LatencyMonitor)).call(this));

        var that = _this;

        // 0 isn't valid here, so its ok to use ||
        that.latencyCheckIntervalMs = latencyCheckIntervalMs || 500; // 0.5s
        that.latencyRandomPercentage = latencyRandomPercentage || 10;
        that._latecyCheckMultiply = 2 * (that.latencyRandomPercentage / 100.0) * that.latencyCheckIntervalMs;
        that._latecyCheckSubtract = that._latecyCheckMultiply / 2;

        that.dataEmitIntervalMs = dataEmitIntervalMs === null || dataEmitIntervalMs === 0 ? undefined : dataEmitIntervalMs || 5 * 1000; // 5s
        debug('latencyCheckIntervalMs: %s dataEmitIntervalMs: %s', that.latencyCheckIntervalMs, that.dataEmitIntervalMs);
        if (that.dataEmitIntervalMs) {
            debug('Expecting ~%s events per summary', that.latencyCheckIntervalMs / that.dataEmitIntervalMs);
        } else {
            debug('Not emitting summaries');
        }

        that.asyncTestFn = asyncTestFn; // If there is no asyncFn, we measure latency

        // If process: use high resolution timer
        if (process && process.hrtime) {
            debug('Using process.hrtime for timing');
            that.now = process.hrtime;
            that.getDeltaMS = function (startTime) {
                var hrtime = that.now(startTime);
                return hrtime[0] * 1000 + hrtime[1] / 1000000;
            };
            // Let's try for a timer that only monotonically increases
        } else if (typeof window !== 'undefined' && (0, _get2.default)(window, 'performance.now')) {
            debug('Using performance.now for timing');
            that.now = window.performance.now.bind(window.performance);
            that.getDeltaMS = function (startTime) {
                return Math.round(that.now() - startTime);
            };
        } else {
            debug('Using Date.now for timing');
            that.now = Date.now;
            that.getDeltaMS = function (startTime) {
                return that.now() - startTime;
            };
        }

        that._latencyData = that._initLatencyData();

        // We check for isBrowser because of browsers set max rates of timeouts when a page is hidden,
        // so we fall back to another library
        // See: http://stackoverflow.com/questions/6032429/chrome-timeouts-interval-suspended-in-background-tabs
        if (isBrowser()) {
            that._visibilityChangeEmitter = new _VisibilityChangeEmitter2.default();
            that._visibilityChangeEmitter.on('visibilityChange', function (pageInFocus) {
                if (pageInFocus) {
                    that._startTimers();
                } else {
                    that._emitSummary();
                    that._stopTimers();
                }
            });
        }

        if (!that._visibilityChangeEmitter || that._visibilityChangeEmitter.isVisible()) {
            that._startTimers();
        }
        return _this;
    }

    /**
     * Start internal timers
     * @private
     */


    _createClass(LatencyMonitor, [{
        key: '_startTimers',
        value: function _startTimers() {
            var _this2 = this;

            // Timer already started, ignore this
            if (this._checkLatencyID) {
                return;
            }
            this._checkLatency();
            if (this.dataEmitIntervalMs) {
                this._emitIntervalID = setInterval(function () {
                    return _this2._emitSummary();
                }, this.dataEmitIntervalMs);
                if ((0, _isFunction2.default)(this._emitIntervalID.unref)) {
                    this._emitIntervalID.unref(); // Doesn't block exit
                }
            }
        }

        /**
         * Stop internal timers
         * @private
         */

    }, {
        key: '_stopTimers',
        value: function _stopTimers() {
            if (this._checkLatencyID) {
                clearTimeout(this._checkLatencyID);
                this._checkLatencyID = undefined;
            }
            if (this._emitIntervalID) {
                clearInterval(this._emitIntervalID);
                this._emitIntervalID = undefined;
            }
        }

        /**
         * Emit summary only if there were events. It might not have any events if it was forced via a page hidden/show
         * @private
         */

    }, {
        key: '_emitSummary',
        value: function _emitSummary() {
            var summary = this.getSummary();
            if (summary.events > 0) {
                this.emit('data', summary);
            }
        }

        /**
         * Calling this function will end the collection period. If a timing event was already fired and somewhere in the queue,
         * it will not count for this time period
         * @returns {SummaryObject}
         */

    }, {
        key: 'getSummary',
        value: function getSummary() {
            // We might want to adjust for the number of expected events
            // Example: first 1 event it comes back, then such a long blocker that the next emit check comes
            // Then this fires - looks like no latency!!
            var latency = {
                events: this._latencyData.events,
                minMs: this._latencyData.minMs,
                maxMs: this._latencyData.maxMs,
                avgMs: this._latencyData.events ? this._latencyData.totalMs / this._latencyData.events : Number.POSITIVE_INFINITY,
                lengthMs: this.getDeltaMS(this._latencyData.startTime)
            };
            this._latencyData = this._initLatencyData(); // Clear

            debug('Summary: %O', latency);
            return latency;
        }

        /**
         * Randomly calls an async fn every roughly latencyCheckIntervalMs (plus some randomness). If no async fn is found,
         * it will simply report on event loop latency.
         *
         * @private
         */

    }, {
        key: '_checkLatency',
        value: function _checkLatency() {
            var _this3 = this;

            var that = this;
            // Randomness is needed to avoid alignment by accident to regular things in the event loop
            var randomness = Math.random() * that._latecyCheckMultiply - that._latecyCheckSubtract;

            // We use this to ensure that in case some overlap somehow, we don't take the wrong startTime/offset
            var localData = {
                deltaOffset: Math.ceil(that.latencyCheckIntervalMs + randomness),
                startTime: that.now()
            };

            var cb = function cb() {
                // We are already stopped, ignore this datapoint
                if (!_this3._checkLatencyID) {
                    return;
                }
                var deltaMS = that.getDeltaMS(localData.startTime) - localData.deltaOffset;
                that._checkLatency(); // Start again ASAP

                // Add the data point. If this gets complex, refactor it
                that._latencyData.events++;
                that._latencyData.minMs = Math.min(that._latencyData.minMs, deltaMS);
                that._latencyData.maxMs = Math.max(that._latencyData.maxMs, deltaMS);
                that._latencyData.totalMs += deltaMS;
                debug('MS: %s Data: %O', deltaMS, that._latencyData);
            };
            debug('localData: %O', localData);

            this._checkLatencyID = setTimeout(function () {
                // This gets rid of including event loop
                if (that.asyncTestFn) {
                    // Clear timing related things
                    localData.deltaOffset = 0;
                    localData.startTime = that.now();
                    that.asyncTestFn(cb);
                } else {
                    // setTimeout is not more accurate than 1ms, so this will ensure positive numbers. Add 1 to emitted data to remove.
                    // This is not the best, but for now it'll be just fine. This isn't meant to be sub ms accurate.
                    localData.deltaOffset -= 1;
                    // If there is no function to test, we mean check latency which is a special case that is really cb => cb()
                    // We avoid that for the few extra function all overheads. Also, we want to keep the timers different
                    cb();
                }
            }, localData.deltaOffset);

            if ((0, _isFunction2.default)(this._checkLatencyID.unref)) {
                this._checkLatencyID.unref(); // Doesn't block exit
            }
        }
    }, {
        key: '_initLatencyData',
        value: function _initLatencyData() {
            return {
                startTime: this.now(),
                minMs: Number.POSITIVE_INFINITY,
                maxMs: Number.NEGATIVE_INFINITY,
                events: 0,
                totalMs: 0
            };
        }
    }]);

    return LatencyMonitor;
}(_events2.default);

function isBrowser() {
    return typeof window !== 'undefined';
}

exports.default = LatencyMonitor;


}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"latency-monitor",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\latency-monitor\\dist\\LatencyMonitor.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\observe-connection.js", {"interface-connection":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\interface-connection\\src\\index.js","pull-stream/pull":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\pull.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-switch\src\observe-connection.js
      return function (require, module, exports) {
'use strict'

const Connection = require('interface-connection').Connection
const pull = require('pull-stream/pull')

/**
 * Creates a pull stream to run the given Connection stream through
 * the given Observer. This provides a way to more easily monitor connections
 * and their metadata. A new Connection will be returned that contains
 * has the attached Observer.
 *
 * @param {Transport} transport
 * @param {string} protocol
 * @param {Connection} connection
 * @param {Observer} observer
 * @returns {Connection}
 */
module.exports = (transport, protocol, connection, observer) => {
  const peerInfo = new Promise((resolve, reject) => {
    connection.getPeerInfo((err, peerInfo) => {
      if (!err && peerInfo) {
        resolve(peerInfo)
        return
      }

      const setPeerInfo = connection.setPeerInfo
      connection.setPeerInfo = (pi) => {
        setPeerInfo.call(connection, pi)
        resolve(pi)
      }
    })
  })

  const stream = {
    source: pull(
      connection,
      observer.incoming(transport, protocol, peerInfo)),
    sink: pull(
      observer.outgoing(transport, protocol, peerInfo),
      connection)
  }

  return new Connection(stream, connection)
}

      };
    };
  }
}, {package:"libp2p-switch",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\observe-connection.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\connection\\incoming.js", {"./base":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\connection\\base.js","class-is":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\class-is\\index.js","fsm-event":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\fsm-event\\index.js","multistream-select":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-switch\src\connection\incoming.js
      return function (require, module, exports) {
'use strict'

const FSM = require('fsm-event')
const multistream = require('multistream-select')
const withIs = require('class-is')

const BaseConnection = require('./base')

class IncomingConnectionFSM extends BaseConnection {
  constructor ({ connection, _switch, transportKey, peerInfo }) {
    super({
      _switch,
      name: `inc:${_switch._peerInfo.id.toB58String().slice(0, 8)}`
    })
    this.conn = connection
    this.theirPeerInfo = peerInfo || null
    this.theirB58Id = this.theirPeerInfo ? this.theirPeerInfo.id.toB58String() : null
    this.ourPeerInfo = this.switch._peerInfo
    this.transportKey = transportKey
    this.protocolMuxer = this.switch.protocolMuxer(this.transportKey)
    this.msListener = new multistream.Listener()

    this._state = FSM('DIALED', {
      DISCONNECTED: {
        disconnect: 'DISCONNECTED'
      },
      DIALED: { // Base connection to peer established
        privatize: 'PRIVATIZING',
        encrypt: 'ENCRYPTING'
      },
      PRIVATIZING: { // Protecting the base connection
        done: 'PRIVATIZED',
        disconnect: 'DISCONNECTING'
      },
      PRIVATIZED: { // Base connection is protected
        encrypt: 'ENCRYPTING'
      },
      ENCRYPTING: { // Encrypting the base connection
        done: 'ENCRYPTED',
        disconnect: 'DISCONNECTING'
      },
      ENCRYPTED: { // Upgrading could not happen, the connection is encrypted and waiting
        upgrade: 'UPGRADING',
        disconnect: 'DISCONNECTING'
      },
      UPGRADING: { // Attempting to upgrade the connection with muxers
        done: 'MUXED'
      },
      MUXED: {
        disconnect: 'DISCONNECTING'
      },
      DISCONNECTING: { // Shutting down the connection
        done: 'DISCONNECTED'
      }
    })

    this._state.on('DISCONNECTED', () => this._onDisconnected())
    this._state.on('PRIVATIZING', () => this._onPrivatizing())
    this._state.on('PRIVATIZED', () => this._onPrivatized())
    this._state.on('ENCRYPTING', () => this._onEncrypting())
    this._state.on('ENCRYPTED', () => {
      this.log('successfully encrypted connection to %s', this.theirB58Id || 'unknown peer')
      this.emit('encrypted', this.conn)
    })
    this._state.on('UPGRADING', () => this._onUpgrading())
    this._state.on('MUXED', () => {
      this.log('successfully muxed connection to %s', this.theirB58Id || 'unknown peer')
      this.emit('muxed', this.conn)
    })
    this._state.on('DISCONNECTING', () => {
      this._state('done')
    })
  }

  /**
   * Attempts to encrypt `this.conn` with the Switch's crypto.
   *
   * @private
   * @fires IncomingConnectionFSM#error
   * @returns {void}
   */
  _onEncrypting () {
    this.log('encrypting connection via %s', this.switch.crypto.tag)

    this.msListener.addHandler(this.switch.crypto.tag, (protocol, _conn) => {
      this.conn = this.switch.crypto.encrypt(this.ourPeerInfo.id, _conn, undefined, (err) => {
        if (err) {
          return this.close(err)
        }
        this.conn.getPeerInfo((_, peerInfo) => {
          this.theirPeerInfo = peerInfo
          this._state('done')
        })
      })
    }, null)

    // Start handling the connection
    this.msListener.handle(this.conn, (err) => {
      if (err) {
        this.emit('crypto handshaking failed', err)
      }
    })
  }

  _onUpgrading () {
    this.log('adding the protocol muxer to the connection')
    this.protocolMuxer(this.conn, this.msListener)
    this._state('done')
  }
}

module.exports = withIs(IncomingConnectionFSM, {
  className: 'IncomingConnectionFSM',
  symbolName: 'libp2p-switch/IncomingConnectionFSM'
})

      };
    };
  }
}, {package:"libp2p-switch",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\connection\\incoming.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\stats\\old-peers.js", {"hashlru":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\hashlru\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-switch\src\stats\old-peers.js
      return function (require, module, exports) {
'use strict'

const LRU = require('hashlru')

/**
 * Creates and returns a Least Recently Used Cache
 *
 * @param {Number} maxSize
 * @returns {LRUCache}
 */
module.exports = (maxSize) => {
  const patched = LRU(maxSize)
  patched.delete = patched.remove
  return patched
}

      };
    };
  }
}, {package:"libp2p-switch",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\stats\\old-peers.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\stats\\stat.js", {"bignumber.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\node_modules\\bignumber.js\\bignumber.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","moving-average":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\moving-average\\index.js","retimer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\retimer\\retimer.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-switch\src\stats\stat.js
      return function (require, module, exports) {
'use strict'

const EventEmitter = require('events')
const Big = require('bignumber.js')
const MovingAverage = require('moving-average')
const retimer = require('retimer')

/**
 * A queue based manager for stat processing
 *
 * @param {Array<string>} initialCounters
 * @param {any} options
 */
class Stats extends EventEmitter {
  constructor (initialCounters, options) {
    super()

    this._options = options
    this._queue = []
    this._stats = {}

    this._frequencyLastTime = Date.now()
    this._frequencyAccumulators = {}
    this._movingAverages = {}

    this._update = this._update.bind(this)

    const intervals = this._options.movingAverageIntervals

    for (var i = 0; i < initialCounters.length; i++) {
      var key = initialCounters[i]
      this._stats[key] = Big(0)
      this._movingAverages[key] = {}
      for (var k = 0; k < intervals.length; k++) {
        var interval = intervals[k]
        var ma = this._movingAverages[key][interval] = MovingAverage(interval)
        ma.push(this._frequencyLastTime, 0)
      }
    }
  }

  /**
   * Initializes the internal timer if there are items in the queue. This
   * should only need to be called if `Stats.stop` was previously called, as
   * `Stats.push` will also start the processing.
   *
   * @returns {void}
   */
  start () {
    if (this._queue.length) {
      this._resetComputeTimeout()
    }
  }

  /**
   * Stops processing and computing of stats by clearing the internal
   * timer.
   *
   * @returns {void}
   */
  stop () {
    if (this._timeout) {
      this._timeout.clear()
      this._timeout = null
    }
  }

  /**
   * Returns a clone of the current stats.
   *
   * @returns {Map<string, Stat>}
   */
  get snapshot () {
    return Object.assign({}, this._stats)
  }

  /**
   * Returns a clone of the internal movingAverages
   *
   * @returns {Array<MovingAverage>}
   */
  get movingAverages () {
    return Object.assign({}, this._movingAverages)
  }

  /**
   * Pushes the given operation data to the queue, along with the
   * current Timestamp, then resets the update timer.
   *
   * @param {string} counter
   * @param {number} inc
   * @returns {void}
   */
  push (counter, inc) {
    this._queue.push([counter, inc, Date.now()])
    this._resetComputeTimeout()
  }

  /**
   * Resets the timeout for triggering updates.
   *
   * @private
   * @returns {void}
   */
  _resetComputeTimeout () {
    if (this._timeout) {
      this._timeout.reschedule(this._nextTimeout())
    } else {
      this._timeout = retimer(this._update, this._nextTimeout())
    }
  }

  /**
   * Calculates and returns the timeout for the next update based on
   * the urgency of the update.
   *
   * @private
   * @returns {number}
   */
  _nextTimeout () {
    // calculate the need for an update, depending on the queue length
    const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize
    const timeout = Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0)
    return timeout
  }

  /**
   * If there are items in the queue, they will will be processed and
   * the frequency for all items will be updated based on the Timestamp
   * of the last item in the queue. The `update` event will also be emitted
   * with the latest stats.
   *
   * If there are no items in the queue, no action is taken.
   *
   * @private
   * @returns {void}
   */
  _update () {
    this._timeout = null
    if (this._queue.length) {
      let last
      while (this._queue.length) {
        const op = last = this._queue.shift()
        this._applyOp(op)
      }

      this._updateFrequency(last[2]) // contains timestamp of last op

      this.emit('update', this._stats)
    }
  }

  /**
   * For each key in the stats, the frequncy and moving averages
   * will be updated via Stats._updateFrequencyFor based on the time
   * difference between calls to this method.
   *
   * @private
   * @param {Timestamp} latestTime
   * @returns {void}
   */
  _updateFrequency (latestTime) {
    const timeDiff = latestTime - this._frequencyLastTime

    Object.keys(this._stats).forEach((key) => {
      this._updateFrequencyFor(key, timeDiff, latestTime)
    })

    this._frequencyLastTime = latestTime
  }

  /**
   * Updates the `movingAverages` for the given `key` and also
   * resets the `frequencyAccumulator` for the `key`.
   *
   * @private
   * @param {string} key
   * @param {number} timeDiffMS Time in milliseconds
   * @param {Timestamp} latestTime Time in ticks
   * @returns {void}
   */
  _updateFrequencyFor (key, timeDiffMS, latestTime) {
    const count = this._frequencyAccumulators[key] || 0
    this._frequencyAccumulators[key] = 0
    // if `timeDiff` is zero, `hz` becomes Infinity, so we fallback to 1ms
    const safeTimeDiff = timeDiffMS || 1
    const hz = (count / safeTimeDiff) * 1000

    let movingAverages = this._movingAverages[key]
    if (!movingAverages) {
      movingAverages = this._movingAverages[key] = {}
    }

    const intervals = this._options.movingAverageIntervals

    for (var i = 0; i < intervals.length; i++) {
      var movingAverageInterval = intervals[i]
      var movingAverage = movingAverages[movingAverageInterval]
      if (!movingAverage) {
        movingAverage = movingAverages[movingAverageInterval] = MovingAverage(movingAverageInterval)
      }
      movingAverage.push(latestTime, hz)
    }
  }

  /**
   * For the given operation, `op`, the stats and `frequencyAccumulator`
   * will be updated or initialized if they don't already exist.
   *
   * @private
   * @param {Array<string, number>} op
   * @throws {InvalidNumber}
   * @returns {void}
   */
  _applyOp (op) {
    const key = op[0]
    const inc = op[1]

    if (typeof inc !== 'number') {
      throw new Error('invalid increment number:', inc)
    }

    let n

    if (!this._stats.hasOwnProperty(key)) {
      n = this._stats[key] = Big(0)
    } else {
      n = this._stats[key]
    }
    this._stats[key] = n.plus(inc)

    if (!this._frequencyAccumulators[key]) {
      this._frequencyAccumulators[key] = 0
    }
    this._frequencyAccumulators[key] += inc
  }
}

module.exports = Stats

      };
    };
  }
}, {package:"libp2p-switch",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\stats\\stat.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\constants.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-switch\src\constants.js
      return function (require, module, exports) {
'use strict'

module.exports = {
  BLACK_LIST_TTL: 5 * 60 * 1e3, // How long before an errored peer can be dialed again
  BLACK_LIST_ATTEMPTS: 5, // Num of unsuccessful dials before a peer is permanently blacklisted
  DIAL_TIMEOUT: 30e3, // How long in ms a dial attempt is allowed to take
  MAX_COLD_CALLS: 50, // How many dials w/o protocols that can be queued
  MAX_PARALLEL_DIALS: 100, // Maximum allowed concurrent dials
  QUARTER_HOUR: 15 * 60e3,
  PRIORITY_HIGH: 10,
  PRIORITY_LOW: 20
}

      };
    };
  }
}, {package:"libp2p-switch",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\constants.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\dialer\\queueManager.js", {"../constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\constants.js","../errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\errors.js","./queue":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\dialer\\queue.js","async/nextTick":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\nextTick.js","debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debug\\src\\browser.js","once":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\once\\once.js","retimer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\retimer\\retimer.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-switch\src\dialer\queueManager.js
      return function (require, module, exports) {
'use strict'

const once = require('once')
const Queue = require('./queue')
const { DIAL_ABORTED } = require('../errors')
const nextTick = require('async/nextTick')
const retimer = require('retimer')
const { QUARTER_HOUR, PRIORITY_HIGH } = require('../constants')
const debug = require('debug')
const log = debug('libp2p:switch:dial:manager')
const noop = () => {}

class DialQueueManager {
  /**
   * @constructor
   * @param {Switch} _switch
   */
  constructor (_switch) {
    this._queue = new Set()
    this._coldCallQueue = new Set()
    this._dialingQueues = new Set()
    this._queues = {}
    this.switch = _switch
    this._cleanInterval = retimer(this._clean.bind(this), QUARTER_HOUR)
    this.start()
  }

  /**
   * Runs through all queues, aborts and removes them if they
   * are no longer valid. A queue that is blacklisted indefinitely,
   * is considered no longer valid.
   * @private
   */
  _clean () {
    const queues = Object.values(this._queues)
    queues.forEach(dialQueue => {
      // Clear if the queue has reached max blacklist
      if (dialQueue.blackListed === Infinity) {
        dialQueue.abort()
        delete this._queues[dialQueue.id]
        return
      }

      // Keep track of blacklisted queues
      if (dialQueue.blackListed) return

      // Clear if peer is no longer active
      // To avoid reallocating memory, dont delete queues of
      // connected peers, as these are highly likely to leverage the
      // queues in the immediate term
      if (!dialQueue.isRunning && dialQueue.length < 1) {
        let isConnected = false
        try {
          const peerInfo = this.switch._peerBook.get(dialQueue.id)
          isConnected = Boolean(peerInfo.isConnected())
        } catch (_) {
          // If we get an error, that means the peerbook doesnt have the peer
        }

        if (!isConnected) {
          dialQueue.abort()
          delete this._queues[dialQueue.id]
        }
      }
    })

    this._cleanInterval.reschedule(QUARTER_HOUR)
  }

  /**
   * Allows the `DialQueueManager` to execute dials
   */
  start () {
    this.isRunning = true
  }

  /**
   * Iterates over all items in the DialerQueue
   * and executes there callback with an error.
   *
   * This causes the entire DialerQueue to be drained
   */
  stop () {
    this.isRunning = false
    // Clear the general queue
    this._queue.clear()
    // Clear the cold call queue
    this._coldCallQueue.clear()

    this._cleanInterval.clear()

    // Abort the individual peer queues
    const queues = Object.values(this._queues)
    queues.forEach(dialQueue => {
      dialQueue.abort()
      delete this._queues[dialQueue.id]
    })
  }

  /**
   * Adds the `dialRequest` to the queue and ensures queue is running
   *
   * @param {DialRequest} dialRequest
   * @returns {void}
   */
  add ({ peerInfo, protocol, options, callback }) {
    callback = callback ? once(callback) : noop

    // Add the dial to its respective queue
    const targetQueue = this.getQueue(peerInfo)

    // Cold Call
    if (options.priority > PRIORITY_HIGH) {
      // If we have too many cold calls, abort the dial immediately
      if (this._coldCallQueue.size >= this.switch.dialer.MAX_COLD_CALLS) {
        return nextTick(callback, DIAL_ABORTED())
      }

      if (this._queue.has(targetQueue.id)) {
        return nextTick(callback, DIAL_ABORTED())
      }
    }

    targetQueue.add(protocol, options.useFSM, callback)

    // If we're already connected to the peer, start the queue now
    // While it might cause queues to go over the max parallel amount,
    // it avoids blocking peers we're already connected to
    if (peerInfo.isConnected()) {
      targetQueue.start()
      return
    }

    // If dialing is not allowed, abort
    if (!targetQueue.isDialAllowed()) {
      return
    }

    // Add the id to its respective queue set if the queue isn't running
    if (!targetQueue.isRunning) {
      if (options.priority <= PRIORITY_HIGH) {
        this._queue.add(targetQueue.id)
        this._coldCallQueue.delete(targetQueue.id)
      // Only add it to the cold queue if it's not in the normal queue
      } else {
        this._coldCallQueue.add(targetQueue.id)
      }
    }

    this.run()
  }

  /**
   * Will execute up to `MAX_PARALLEL_DIALS` dials
   */
  run () {
    if (!this.isRunning) return

    if (this._dialingQueues.size < this.switch.dialer.MAX_PARALLEL_DIALS) {
      let nextQueue = { done: true }
      // Check the queue first and fall back to the cold call queue
      if (this._queue.size > 0) {
        nextQueue = this._queue.values().next()
        this._queue.delete(nextQueue.value)
      } else if (this._coldCallQueue.size > 0) {
        nextQueue = this._coldCallQueue.values().next()
        this._coldCallQueue.delete(nextQueue.value)
      }

      if (nextQueue.done) {
        return
      }

      let targetQueue = this._queues[nextQueue.value]

      if (!targetQueue) {
        log('missing queue %s, maybe it was aborted?', nextQueue.value)
        return
      }

      this._dialingQueues.add(targetQueue.id)
      targetQueue.start()
    }
  }

  /**
   * Will remove the `peerInfo` from the dial blacklist
   * @param {PeerInfo} peerInfo
   */
  clearBlacklist (peerInfo) {
    const queue = this.getQueue(peerInfo)
    queue.blackListed = null
    queue.blackListCount = 0
  }

  /**
   * A handler for when dialing queues stop. This will trigger
   * `run()` in order to keep the queue processing.
   * @private
   * @param {string} id peer id of the queue that stopped
   */
  _onQueueStopped (id) {
    this._dialingQueues.delete(id)
    this.run()
  }

  /**
   * Returns the `Queue` for the given `peerInfo`
   * @param {PeerInfo} peerInfo
   * @returns {Queue}
   */
  getQueue (peerInfo) {
    const id = peerInfo.id.toB58String()

    this._queues[id] = this._queues[id] || new Queue(id, this.switch, this._onQueueStopped.bind(this))
    return this._queues[id]
  }
}

module.exports = DialQueueManager

      };
    };
  }
}, {package:"libp2p-switch",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\dialer\\queueManager.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\utils.js", {"libp2p-identify":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-identify\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-switch\src\utils.js
      return function (require, module, exports) {
'use strict'

const Identify = require('libp2p-identify')

/**
 * For a given multistream, registers to handle the given connection
 * @param {MultistreamDialer} multistream
 * @param {Connection} connection
 * @returns {Promise}
 */
module.exports.msHandle = (multistream, connection) => {
  return new Promise((resolve, reject) => {
    multistream.handle(connection, (err) => {
      if (err) return reject(err)
      resolve()
    })
  })
}

/**
 * For a given multistream, selects the given protocol
 * @param {MultistreamDialer} multistream
 * @param {string} protocol
 * @returns {Promise} Resolves the selected Connection
 */
module.exports.msSelect = (multistream, protocol) => {
  return new Promise((resolve, reject) => {
    multistream.select(protocol, (err, connection) => {
      if (err) return reject(err)
      resolve(connection)
    })
  })
}

/**
 * Runs identify for the given connection and verifies it against the
 * PeerInfo provided
 * @param {Connection} connection
 * @param {PeerInfo} cryptoPeerInfo The PeerInfo determined during crypto exchange
 * @returns {Promise} Resolves {peerInfo, observedAddrs}
 */
module.exports.identifyDialer = (connection, cryptoPeerInfo) => {
  return new Promise((resolve, reject) => {
    Identify.dialer(connection, cryptoPeerInfo, (err, peerInfo, observedAddrs) => {
      if (err) return reject(err)
      resolve({ peerInfo, observedAddrs })
    })
  })
}

/**
 * Get unique values from `arr` using `getValue` to determine
 * what is used for uniqueness
 * @param {Array} arr The array to get unique values for
 * @param {function(value)} getValue The function to determine what is compared
 * @returns {Array}
 */
module.exports.uniqueBy = (arr, getValue) => {
  return [...new Map(arr.map((i) => [getValue(i), i])).values()]
}

      };
    };
  }
}, {package:"libp2p-switch",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\utils.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\index.js", {"./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\constants.js","./dialer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\dialer\\index.js","./listener":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\listener\\index.js","./listener/match-exact":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\listener\\match-exact.js","./listener/match-semver":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\listener\\match-semver.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\multistream-select\src\index.js
      return function (require, module, exports) {
'use strict'

exports.Listener = exports.listener = require('./listener')
exports.Dialer = exports.dialer = require('./dialer')
exports.matchSemver = require('./listener/match-semver')
exports.matchExact = require('./listener/match-exact')
exports.constants = require('./constants')

      };
    };
  }
}, {package:"multistream-select",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\connection\\index.js", {"../errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\errors.js","../observe-connection":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\observe-connection.js","../utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\utils.js","./base":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\connection\\base.js","async/nextTick":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\nextTick.js","async/parallel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\parallel.js","class-is":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\class-is\\index.js","err-code":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\err-code\\index.js","fsm-event":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\fsm-event\\index.js","libp2p-circuit":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\index.js","libp2p-identify":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-identify\\src\\index.js","multistream-select":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-switch\src\connection\index.js
      return function (require, module, exports) {
'use strict'

const FSM = require('fsm-event')
const Circuit = require('libp2p-circuit')
const multistream = require('multistream-select')
const withIs = require('class-is')
const BaseConnection = require('./base')
const parallel = require('async/parallel')
const nextTick = require('async/nextTick')
const identify = require('libp2p-identify')
const errCode = require('err-code')
const { msHandle, msSelect, identifyDialer } = require('../utils')

const observeConnection = require('../observe-connection')
const {
  CONNECTION_FAILED,
  DIAL_SELF,
  INVALID_STATE_TRANSITION,
  NO_TRANSPORTS_REGISTERED,
  maybeUnexpectedEnd
} = require('../errors')

/**
 * @typedef {Object} ConnectionOptions
 * @property {Switch} _switch Our switch instance
 * @property {PeerInfo} peerInfo The PeerInfo of the peer to dial
 * @property {Muxer} muxer Optional - A muxed connection
 * @property {Connection} conn Optional - The base connection
 * @property {string} type Optional - identify the connection as incoming or outgoing. Defaults to out.
 */

/**
 * ConnectionFSM handles the complex logic of managing a connection
 * between peers. ConnectionFSM is internally composed of a state machine
 * to help improve the usability and debuggability of connections. The
 * state machine also helps to improve the ability to handle dial backoff,
 * coalescing dials and dial locks.
 */
class ConnectionFSM extends BaseConnection {
  /**
   * @param {ConnectionOptions} connectionOptions
   * @constructor
   */
  constructor ({ _switch, peerInfo, muxer, conn, type = 'out' }) {
    super({
      _switch,
      name: `${type}:${_switch._peerInfo.id.toB58String().slice(0, 8)}`
    })

    this.theirPeerInfo = peerInfo
    this.theirB58Id = this.theirPeerInfo.id.toB58String()

    this.conn = conn // The base connection
    this.muxer = muxer // The upgraded/muxed connection

    let startState = 'DISCONNECTED'
    if (this.muxer) {
      startState = 'MUXED'
    }

    this._state = FSM(startState, {
      DISCONNECTED: { // No active connections exist for the peer
        dial: 'DIALING',
        disconnect: 'DISCONNECTED',
        done: 'DISCONNECTED'
      },
      DIALING: { // Creating an initial connection
        abort: 'ABORTED',
        // emit events for different transport dials?
        done: 'DIALED',
        error: 'ERRORED',
        disconnect: 'DISCONNECTING'
      },
      DIALED: { // Base connection to peer established
        encrypt: 'ENCRYPTING',
        privatize: 'PRIVATIZING'
      },
      PRIVATIZING: { // Protecting the base connection
        done: 'PRIVATIZED',
        abort: 'ABORTED',
        disconnect: 'DISCONNECTING'
      },
      PRIVATIZED: { // Base connection is protected
        encrypt: 'ENCRYPTING'
      },
      ENCRYPTING: { // Encrypting the base connection
        done: 'ENCRYPTED',
        error: 'ERRORED',
        disconnect: 'DISCONNECTING'
      },
      ENCRYPTED: { // Upgrading could not happen, the connection is encrypted and waiting
        upgrade: 'UPGRADING',
        disconnect: 'DISCONNECTING'
      },
      UPGRADING: { // Attempting to upgrade the connection with muxers
        stop: 'CONNECTED', // If we cannot mux, stop upgrading
        done: 'MUXED',
        error: 'ERRORED',
        disconnect: 'DISCONNECTING'
      },
      MUXED: {
        disconnect: 'DISCONNECTING'
      },
      CONNECTED: { // A non muxed connection is established
        disconnect: 'DISCONNECTING'
      },
      DISCONNECTING: { // Shutting down the connection
        done: 'DISCONNECTED',
        disconnect: 'DISCONNECTING'
      },
      ABORTED: { }, // A severe event occurred
      ERRORED: { // An error occurred, but future dials may be allowed
        disconnect: 'DISCONNECTING' // There could be multiple options here, but this is a likely action
      }
    })

    this._state.on('DISCONNECTED', () => this._onDisconnected())
    this._state.on('DIALING', () => this._onDialing())
    this._state.on('DIALED', () => this._onDialed())
    this._state.on('PRIVATIZING', () => this._onPrivatizing())
    this._state.on('PRIVATIZED', () => this._onPrivatized())
    this._state.on('ENCRYPTING', () => this._onEncrypting())
    this._state.on('ENCRYPTED', () => {
      this.log('successfully encrypted connection to %s', this.theirB58Id)
      this.emit('encrypted', this.conn)
    })
    this._state.on('UPGRADING', () => this._onUpgrading())
    this._state.on('MUXED', () => {
      this.log('successfully muxed connection to %s', this.theirB58Id)
      delete this.switch.conns[this.theirB58Id]
      this.emit('muxed', this.muxer)
    })
    this._state.on('CONNECTED', () => {
      this.log('unmuxed connection opened to %s', this.theirB58Id)
      this.emit('unmuxed', this.conn)
    })
    this._state.on('DISCONNECTING', () => this._onDisconnecting())
    this._state.on('ABORTED', () => this._onAborted())
    this._state.on('ERRORED', () => this._onErrored())
    this._state.on('error', (err) => this._onStateError(err))
  }

  /**
   * Puts the state into dialing mode
   *
   * @fires ConnectionFSM#Error May emit a DIAL_SELF error
   * @returns {void}
   */
  dial () {
    if (this.theirB58Id === this.ourPeerInfo.id.toB58String()) {
      return this.emit('error', DIAL_SELF())
    } else if (this.getState() === 'DIALING') {
      return this.log('attempted to dial while already dialing, ignoring')
    }

    this._state('dial')
  }

  /**
   * Initiates a handshake for the given protocol
   *
   * @param {string} protocol The protocol to negotiate
   * @param {function(Error, Connection)} callback
   * @returns {void}
   */
  shake (protocol, callback) {
    // If there is no protocol set yet, don't perform the handshake
    if (!protocol) {
      return callback(null, null)
    }

    if (this.muxer && this.muxer.newStream) {
      return this.muxer.newStream((err, stream) => {
        if (err) {
          return callback(err, null)
        }

        this.log('created new stream to %s', this.theirB58Id)
        this._protocolHandshake(protocol, stream, callback)
      })
    }

    this._protocolHandshake(protocol, this.conn, callback)
  }

  /**
   * Puts the state into muxing mode
   *
   * @returns {void}
   */
  upgrade () {
    this._state('upgrade')
  }

  /**
   * Event handler for dialing. Transitions state when successful.
   *
   * @private
   * @fires ConnectionFSM#error
   * @returns {void}
   */
  _onDialing () {
    this.log('dialing %s', this.theirB58Id)

    if (!this.switch.hasTransports()) {
      return this.close(NO_TRANSPORTS_REGISTERED())
    }

    const tKeys = this.switch.availableTransports(this.theirPeerInfo)

    const circuitEnabled = Boolean(this.switch.transports[Circuit.tag])

    if (circuitEnabled && !tKeys.includes(Circuit.tag)) {
      tKeys.push(Circuit.tag)
    }

    const nextTransport = (key) => {
      let transport = key
      if (!transport) {
        if (!circuitEnabled) {
          return this.close(
            CONNECTION_FAILED(`Circuit not enabled and all transports failed to dial peer ${this.theirB58Id}!`)
          )
        }

        return this.close(
          CONNECTION_FAILED(`No available transports to dial peer ${this.theirB58Id}!`)
        )
      }

      if (transport === Circuit.tag) {
        this.theirPeerInfo.multiaddrs.add(`/p2p-circuit/p2p/${this.theirB58Id}`)
      }

      this.log('dialing transport %s', transport)
      this.switch.transport.dial(transport, this.theirPeerInfo, (errors, _conn) => {
        if (errors) {
          this.emit('error:connection_attempt_failed', errors)
          this.log(errors)
          return nextTransport(tKeys.shift())
        }

        this.conn = observeConnection(transport, null, _conn, this.switch.observer)
        this._state('done')
      })
    }

    nextTransport(tKeys.shift())
  }

  /**
   * Once a connection has been successfully dialed, the connection
   * will be privatized or encrypted depending on the presence of the
   * Switch.protector.
   *
   * @returns {void}
   */
  _onDialed () {
    this.log('successfully dialed %s', this.theirB58Id)

    this.emit('connected', this.conn)
  }

  /**
   * Event handler for disconnecting. Handles any needed cleanup
   *
   * @returns {void}
   */
  _onDisconnecting () {
    this.log('disconnecting from %s', this.theirB58Id, Boolean(this.muxer))

    delete this.switch.conns[this.theirB58Id]

    let tasks = []

    // Clean up stored connections
    if (this.muxer) {
      tasks.push((cb) => {
        this.muxer.end(() => {
          delete this.muxer
          cb()
        })
      })
    }

    // If we have the base connection, abort it
    // Ignore abort errors, since we're closing
    if (this.conn) {
      try {
        this.conn.source.abort()
      } catch (_) { }
      delete this.conn
    }

    parallel(tasks, () => {
      this._state('done')
    })
  }

  /**
   * Attempts to encrypt `this.conn` with the Switch's crypto.
   *
   * @private
   * @fires ConnectionFSM#error
   * @returns {void}
   */
  _onEncrypting () {
    const msDialer = new multistream.Dialer()
    msDialer.handle(this.conn, (err) => {
      if (err) {
        return this.close(maybeUnexpectedEnd(err))
      }

      this.log('selecting crypto %s to %s', this.switch.crypto.tag, this.theirB58Id)

      msDialer.select(this.switch.crypto.tag, (err, _conn) => {
        if (err) {
          return this.close(maybeUnexpectedEnd(err))
        }

        const observedConn = observeConnection(null, this.switch.crypto.tag, _conn, this.switch.observer)
        const encryptedConn = this.switch.crypto.encrypt(this.ourPeerInfo.id, observedConn, this.theirPeerInfo.id, (err) => {
          if (err) {
            return this.close(err)
          }

          this.conn = encryptedConn
          this.conn.setPeerInfo(this.theirPeerInfo)
          this._state('done')
        })
      })
    })
  }

  /**
   * Iterates over each Muxer on the Switch and attempts to upgrade
   * the given `connection`. Successful muxed connections will be stored
   * on the Switch.muxedConns with `b58Id` as their key for future reference.
   *
   * @private
   * @returns {void}
   */
  _onUpgrading () {
    const muxers = Object.keys(this.switch.muxers)
    this.log('upgrading connection to %s', this.theirB58Id)

    if (muxers.length === 0) {
      return this._state('stop')
    }

    const msDialer = new multistream.Dialer()
    msDialer.handle(this.conn, (err) => {
      if (err) {
        return this._didUpgrade(err)
      }

      // 1. try to handshake in one of the muxers available
      // 2. if succeeds
      //  - add the muxedConn to the list of muxedConns
      //  - add incomming new streams to connHandler
      const nextMuxer = (key) => {
        this.log('selecting %s', key)
        msDialer.select(key, (err, _conn) => {
          if (err) {
            if (muxers.length === 0) {
              return this._didUpgrade(err)
            }

            return nextMuxer(muxers.shift())
          }

          // observe muxed connections
          const conn = observeConnection(null, key, _conn, this.switch.observer)

          this.muxer = this.switch.muxers[key].dialer(conn)

          this.muxer.once('close', () => {
            this.close()
          })

          // For incoming streams, in case identify is on
          this.muxer.on('stream', (conn) => {
            this.log('new stream created via muxer to %s', this.theirB58Id)
            conn.setPeerInfo(this.theirPeerInfo)
            this.switch.protocolMuxer(null)(conn)
          })

          this._didUpgrade(null)

          // Run identify on the connection
          if (this.switch.identify) {
            this._identify((err, results) => {
              if (err) {
                return this.close(err)
              }
              this.theirPeerInfo = this.switch._peerBook.put(results.peerInfo)
            })
          }
        })
      }

      nextMuxer(muxers.shift())
    })
  }

  /**
   * Runs the identify protocol on the connection
   * @private
   * @param {function(error, { PeerInfo })} callback
   * @returns {void}
   */
  _identify (callback) {
    if (!this.muxer) {
      return nextTick(callback, errCode('The connection was already closed', 'ERR_CONNECTION_CLOSED'))
    }
    this.muxer.newStream(async (err, conn) => {
      if (err) return callback(err)
      const ms = new multistream.Dialer()
      let results
      try {
        await msHandle(ms, conn)
        const msConn = await msSelect(ms, identify.multicodec)
        results = await identifyDialer(msConn, this.theirPeerInfo)
      } catch (err) {
        return callback(err)
      }
      callback(null, results)
    })
  }

  /**
   * Analyses the given error, if it exists, to determine where the state machine
   * needs to go.
   *
   * @param {Error} err
   * @returns {void}
   */
  _didUpgrade (err) {
    if (err) {
      this.log('Error upgrading connection:', err)
      this.switch.conns[this.theirB58Id] = this
      this.emit('error:upgrade_failed', err)
      // Cant upgrade, hold the encrypted connection
      return this._state('stop')
    }

    // move the state machine forward
    this._state('done')
  }

  /**
   * Performs the protocol handshake for the given protocol
   * over the given connection. The resulting error or connection
   * will be returned via the callback.
   *
   * @private
   * @param {string} protocol
   * @param {Connection} connection
   * @param {function(Error, Connection)} callback
   * @returns {void}
   */
  _protocolHandshake (protocol, connection, callback) {
    const msDialer = new multistream.Dialer()
    msDialer.handle(connection, (err) => {
      if (err) {
        return callback(err, null)
      }

      msDialer.select(protocol, (err, _conn) => {
        if (err) {
          this.log('could not perform protocol handshake:', err)
          return callback(err, null)
        }

        const conn = observeConnection(null, protocol, _conn, this.switch.observer)
        this.log('successfully performed handshake of %s to %s', protocol, this.theirB58Id)
        this.emit('connection', conn)
        callback(null, conn)
      })
    })
  }

  /**
   * Event handler for state transition errors
   *
   * @param {Error} err
   * @returns {void}
   */
  _onStateError (err) {
    this.emit('error', INVALID_STATE_TRANSITION(err))
    this.log(err)
  }
}

module.exports = withIs(ConnectionFSM, {
  className: 'ConnectionFSM',
  symbolName: 'libp2p-switch/ConnectionFSM'
})

      };
    };
  }
}, {package:"libp2p-switch",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\connection\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-identify\\src\\index.js", {"./dialer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-identify\\src\\dialer.js","./listener":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-identify\\src\\listener.js","./message":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-identify\\src\\message.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-identify\src\index.js
      return function (require, module, exports) {
'use strict'

exports = module.exports
exports.multicodec = '/ipfs/id/1.0.0'
exports.listener = require('./listener')
exports.dialer = require('./dialer')
exports.message = require('./message')

      };
    };
  }
}, {package:"libp2p-identify",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-identify\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\limit-dialer\\index.js", {"./queue":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\limit-dialer\\queue.js","async/tryEach":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\tryEach.js","debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debug\\src\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-switch\src\limit-dialer\index.js
      return function (require, module, exports) {
'use strict'

const tryEach = require('async/tryEach')
const debug = require('debug')

const log = debug('libp2p:switch:dialer')

const DialQueue = require('./queue')

/**
 * Track dials per peer and limited them.
 */
class LimitDialer {
  /**
   * Create a new dialer.
   *
   * @param {number} perPeerLimit
   * @param {number} dialTimeout
   */
  constructor (perPeerLimit, dialTimeout) {
    log('create: %s peer limit, %s dial timeout', perPeerLimit, dialTimeout)
    this.perPeerLimit = perPeerLimit
    this.dialTimeout = dialTimeout
    this.queues = new Map()
  }

  /**
   * Dial a list of multiaddrs on the given transport.
   *
   * @param {PeerId} peer
   * @param {SwarmTransport} transport
   * @param {Array<Multiaddr>} addrs
   * @param {function(Error, Connection)} callback
   * @returns {void}
   */
  dialMany (peer, transport, addrs, callback) {
    log('dialMany:start')
    // we use a token to track if we want to cancel following dials
    const token = { cancel: false }

    let errors = []
    const tasks = addrs.map((m) => {
      return (cb) => this.dialSingle(peer, transport, m, token, (err, result) => {
        if (err) {
          errors.push(err)
          return cb(err)
        }
        return cb(null, result)
      })
    })

    tryEach(tasks, (_, result) => {
      if (result && result.conn) {
        log('dialMany:success')
        return callback(null, result)
      }

      log('dialMany:error')
      callback(errors)
    })
  }

  /**
   * Dial a single multiaddr on the given transport.
   *
   * @param {PeerId} peer
   * @param {SwarmTransport} transport
   * @param {Multiaddr} addr
   * @param {CancelToken} token
   * @param {function(Error, Connection)} callback
   * @returns {void}
   */
  dialSingle (peer, transport, addr, token, callback) {
    const ps = peer.toB58String()
    log('dialSingle: %s:%s', ps, addr.toString())
    let q
    if (this.queues.has(ps)) {
      q = this.queues.get(ps)
    } else {
      q = new DialQueue(this.perPeerLimit, this.dialTimeout)
      this.queues.set(ps, q)
    }

    q.push(transport, addr, token, callback)
  }
}

module.exports = LimitDialer

      };
    };
  }
}, {package:"libp2p-switch",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\limit-dialer\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\circuit.js", {"./circuit/dialer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\circuit\\dialer.js","./circuit/utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\circuit\\utils.js","./listener":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\listener.js","debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debug\\src\\browser.js","mafmt":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\mafmt\\src\\index.js","multiaddr":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multiaddr\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-circuit\src\circuit.js
      return function (require, module, exports) {
'use strict'

const mafmt = require('mafmt')
const multiaddr = require('multiaddr')

const CircuitDialer = require('./circuit/dialer')
const utilsFactory = require('./circuit/utils')

const debug = require('debug')
const log = debug('libp2p:circuit:transportdialer')
log.err = debug('libp2p:circuit:error:transportdialer')

const createListener = require('./listener')

class Circuit {
  static get tag () {
    return 'Circuit'
  }

  /**
   * Creates an instance of Dialer.
   *
   * @param {Swarm} swarm - the swarm
   * @param {any} options - config options
   *
   * @memberOf Dialer
   */
  constructor (swarm, options) {
    this.options = options || {}

    this.swarm = swarm
    this.dialer = null
    this.utils = utilsFactory(swarm)
    this.peerInfo = this.swarm._peerInfo
    this.relays = this.filter(this.peerInfo.multiaddrs.toArray())

    // if no explicit relays, add a default relay addr
    if (this.relays.length === 0) {
      this.peerInfo
        .multiaddrs
        .add(`/p2p-circuit/ipfs/${this.peerInfo.id.toB58String()}`)
    }

    this.dialer = new CircuitDialer(swarm, options)

    this.swarm.on('peer-mux-established', (peerInfo) => {
      this.dialer.canHop(peerInfo)
    })
    this.swarm.on('peer-mux-closed', (peerInfo) => {
      this.dialer.relayPeers.delete(peerInfo.id.toB58String())
    })
  }

  /**
   * Dial the relays in the Addresses.Swarm config
   *
   * @param {Array} relays
   * @return {void}
   */
  _dialSwarmRelays () {
    // if we have relay addresses in swarm config, then dial those relays
    this.relays.forEach((relay) => {
      let relaySegments = relay
        .toString()
        .split('/p2p-circuit')
        .filter(segment => segment.length)

      relaySegments.forEach((relaySegment) => {
        const ma = this.utils.peerInfoFromMa(multiaddr(relaySegment))
        this.dialer._dialRelay(ma)
      })
    })
  }

  /**
   * Dial a peer over a relay
   *
   * @param {multiaddr} ma - the multiaddr of the peer to dial
   * @param {Object} options - dial options
   * @param {Function} cb - a callback called once dialed
   * @returns {Connection} - the connection
   *
   * @memberOf Dialer
   */
  dial (ma, options, cb) {
    return this.dialer.dial(ma, options, cb)
  }

  /**
   * Create a listener
   *
   * @param {any} options
   * @param {Function} handler
   * @return {listener}
   */
  createListener (options, handler) {
    if (typeof options === 'function') {
      handler = options
      options = this.options || {}
    }

    const listener = createListener(this.swarm, options, handler)
    listener.on('listen', this._dialSwarmRelays.bind(this))
    return listener
  }

  /**
   * Filter check for all multiaddresses
   * that this transport can dial on
   *
   * @param {any} multiaddrs
   * @returns {Array<multiaddr>}
   *
   * @memberOf Dialer
   */
  filter (multiaddrs) {
    if (!Array.isArray(multiaddrs)) {
      multiaddrs = [multiaddrs]
    }
    return multiaddrs.filter((ma) => {
      return mafmt.Circuit.matches(ma)
    })
  }
}

module.exports = Circuit

      };
    };
  }
}, {package:"libp2p-circuit",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\circuit.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-exporter\\src\\utils\\extract-data-from-block.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-unixfs-exporter\src\utils\extract-data-from-block.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

module.exports = function extractDataFromBlock (block, blockStart, requestedStart, requestedEnd) {
  const blockLength = block.length
  const blockEnd = blockStart + blockLength

  if (requestedStart >= blockEnd || requestedEnd < blockStart) {
    // If we are looking for a byte range that is starts after the start of the block,
    // return an empty block.  This can happen when internal nodes contain data
    return Buffer.alloc(0)
  }

  if (requestedEnd >= blockStart && requestedEnd < blockEnd) {
    // If the end byte is in the current block, truncate the block to the end byte
    block = block.slice(0, requestedEnd - blockStart)
  }

  if (requestedStart >= blockStart && requestedStart < blockEnd) {
    // If the start byte is in the current block, skip to the start byte
    block = block.slice(requestedStart - blockStart)
  }

  return block
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs-unixfs-exporter",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-exporter\\src\\utils\\extract-data-from-block.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-exporter\\src\\utils\\validate-offset-and-length.js", {"err-code":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\err-code\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-unixfs-exporter\src\utils\validate-offset-and-length.js
      return function (require, module, exports) {
'use strict'

const errCode = require('err-code')

const validateOffsetAndLength = (size, offset, length) => {
  if (!offset) {
    offset = 0
  }

  if (offset < 0) {
    throw errCode(new Error('Offset must be greater than or equal to 0'), 'ERR_INVALID_PARAMS')
  }

  if (offset > size) {
    throw errCode(new Error('Offset must be less than the file size'), 'ERR_INVALID_PARAMS')
  }

  if (!length && length !== 0) {
    length = size - offset
  }

  if (length < 0) {
    throw errCode(new Error('Length must be greater than or equal to 0'), 'ERR_INVALID_PARAMS')
  }

  if (offset + length > size) {
    length = size - offset
  }

  return {
    offset,
    length
  }
}

module.exports = validateOffsetAndLength

      };
    };
  }
}, {package:"ipfs-unixfs-exporter",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-exporter\\src\\utils\\validate-offset-and-length.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-exporter\\src\\resolvers\\unixfs-v1\\content\\directory.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-unixfs-exporter\src\resolvers\unixfs-v1\content\directory.js
      return function (require, module, exports) {
'use strict'

const directoryContent = (cid, node, unixfs, path, resolve, depth, ipld) => {
  return async function * (options = {}) {
    const offset = options.offset || 0
    const length = options.length || node.Links.length
    const links = node.Links.slice(offset, length)

    for (const link of links) {
      const result = await resolve(link.Hash, link.Name, `${path}/${link.Name}`, [], depth + 1, ipld)

      yield result.entry
    }
  }
}

module.exports = directoryContent

      };
    };
  }
}, {package:"ipfs-unixfs-exporter",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-exporter\\src\\resolvers\\unixfs-v1\\content\\directory.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-exporter\\src\\resolvers\\unixfs-v1\\content\\hamt-sharded-directory.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-unixfs-exporter\src\resolvers\unixfs-v1\content\hamt-sharded-directory.js
      return function (require, module, exports) {
'use strict'

const hamtShardedDirectoryContent = (cid, node, unixfs, path, resolve, depth, ipld) => {
  return (options = {}) => {
    return listDirectory(node, path, resolve, depth, ipld, options)
  }
}

async function * listDirectory (node, path, resolve, depth, ipld, options) {
  const links = node.Links

  for (const link of links) {
    const name = link.Name.substring(2)

    if (name) {
      const result = await resolve(link.Hash, name, `${path}/${name}`, [], depth + 1, ipld)

      yield result.entry
    } else {
      // descend into subshard
      node = await ipld.get(link.Hash)

      for await (const file of listDirectory(node, path, resolve, depth, ipld, options)) {
        yield file
      }
    }
  }
}

module.exports = hamtShardedDirectoryContent

      };
    };
  }
}, {package:"ipfs-unixfs-exporter",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-exporter\\src\\resolvers\\unixfs-v1\\content\\hamt-sharded-directory.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-exporter\\src\\resolvers\\unixfs-v1\\content\\file.js", {"../../../../../is-buffer/index.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-buffer\\index.js","../../../utils/extract-data-from-block":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-exporter\\src\\utils\\extract-data-from-block.js","../../../utils/validate-offset-and-length":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-exporter\\src\\utils\\validate-offset-and-length.js","err-code":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\err-code\\index.js","ipfs-unixfs":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-unixfs-exporter\src\resolvers\unixfs-v1\content\file.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const extractDataFromBlock = require('../../../utils/extract-data-from-block')
const validateOffsetAndLength = require('../../../utils/validate-offset-and-length')
const UnixFS = require('ipfs-unixfs')
const errCode = require('err-code')

async function * emitBytes (ipld, node, start, end, streamPosition = 0) {
  // a `raw` node
  if (Buffer.isBuffer(node)) {
    const buf = extractDataFromBlock(node, streamPosition, start, end)

    if (buf.length) {
      yield buf
    }

    streamPosition += buf.length

    return streamPosition
  }

  let file

  try {
    file = UnixFS.unmarshal(node.Data)
  } catch (err) {
    throw errCode(err, 'ERR_NOT_UNIXFS')
  }

  // might be a unixfs `raw` node or have data on intermediate nodes
  const nodeHasData = Boolean(file.data && file.data.length)

  if (nodeHasData) {
    const buf = extractDataFromBlock(file.data, streamPosition, start, end)

    if (buf.length) {
      yield buf
    }

    streamPosition += file.data.length
  }

  let childStart = streamPosition

  // work out which child nodes contain the requested data
  for (let i = 0; i < node.Links.length; i++) {
    const childLink = node.Links[i]
    const childEnd = streamPosition + file.blockSizes[i]

    if ((start >= childStart && start < childEnd) || // child has offset byte
        (end > childStart && end <= childEnd) || // child has end byte
        (start < childStart && end > childEnd)) { // child is between offset and end bytes
      const child = await ipld.get(childLink.Hash)

      for await (const buf of emitBytes(ipld, child, start, end, streamPosition)) {
        streamPosition += buf.length

        yield buf
      }
    }

    streamPosition = childEnd
    childStart = childEnd + 1
  }
}

const fileContent = (cid, node, unixfs, path, resolve, depth, ipld) => {
  return (options = {}) => {
    const fileSize = unixfs.fileSize()

    const {
      offset,
      length
    } = validateOffsetAndLength(fileSize, options.offset, options.length)

    const start = offset
    const end = offset + length

    return emitBytes(ipld, node, start, end)
  }
}

module.exports = fileContent

}).call(this)}).call(this,{"isBuffer":require("../../../../../is-buffer/index.js")})

      };
    };
  }
}, {package:"ipfs-unixfs-exporter",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-exporter\\src\\resolvers\\unixfs-v1\\content\\file.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-exporter\\src\\utils\\find-cid-in-shard.js", {"hamt-sharding/src/bucket":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\hamt-sharding\\src\\bucket.js","ipfs-unixfs-importer/src/dir-sharded":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-importer\\src\\dir-sharded.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-unixfs-exporter\src\utils\find-cid-in-shard.js
      return function (require, module, exports) {
'use strict'

const Bucket = require('hamt-sharding/src/bucket')
const DirSharded = require('ipfs-unixfs-importer/src/dir-sharded')

const addLinksToHamtBucket = (links, bucket, rootBucket) => {
  return Promise.all(
    links.map(link => {
      if (link.Name.length === 2) {
        const pos = parseInt(link.Name, 16)

        return bucket._putObjectAt(pos, new Bucket({
          hashFn: DirSharded.hashFn
        }, bucket, pos))
      }

      return rootBucket.put(link.Name.substring(2), true)
    })
  )
}

const toPrefix = (position) => {
  return position
    .toString('16')
    .toUpperCase()
    .padStart(2, '0')
    .substring(0, 2)
}

const toBucketPath = (position) => {
  let bucket = position.bucket
  const path = []

  while (bucket._parent) {
    path.push(bucket)

    bucket = bucket._parent
  }

  path.push(bucket)

  return path.reverse()
}

const findShardCid = async (node, name, ipld, context) => {
  if (!context) {
    context = {
      rootBucket: new Bucket({
        hashFn: DirSharded.hashFn
      }),
      hamtDepth: 1
    }

    context.lastBucket = context.rootBucket
  }

  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket)

  const position = await context.rootBucket._findNewBucketAndPos(name)
  let prefix = toPrefix(position.pos)
  const bucketPath = toBucketPath(position)

  if (bucketPath.length > (context.hamtDepth)) {
    context.lastBucket = bucketPath[context.hamtDepth]

    prefix = toPrefix(context.lastBucket._posAtParent)
  }

  const link = node.Links.find(link => {
    const entryPrefix = link.Name.substring(0, 2)
    const entryName = link.Name.substring(2)

    if (entryPrefix !== prefix) {
      // not the entry or subshard we're looking for
      return
    }

    if (entryName && entryName !== name) {
      // not the entry we're looking for
      return
    }

    return true
  })

  if (!link) {
    return null
  }

  if (link.Name.substring(2) === name) {
    return link.Hash
  }

  context.hamtDepth++

  node = await ipld.get(link.Hash)

  return findShardCid(node, name, ipld, context)
}

module.exports = findShardCid

      };
    };
  }
}, {package:"ipfs-unixfs-exporter",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-exporter\\src\\utils\\find-cid-in-shard.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-utils\\node_modules\\readable-stream\\errors-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-utils\node_modules\readable-stream\errors-browser.js
      return function (require, module, exports) {
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-utils\\node_modules\\readable-stream\\errors-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-utils\\node_modules\\readable-stream\\lib\\internal\\streams\\destroy.js", {"_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-utils\node_modules\readable-stream\lib\internal\streams\destroy.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-utils\\node_modules\\readable-stream\\lib\\internal\\streams\\destroy.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-utils\\node_modules\\readable-stream\\lib\\internal\\streams\\stream-browser.js", {"events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-utils\node_modules\readable-stream\lib\internal\streams\stream-browser.js
      return function (require, module, exports) {
module.exports = require('events').EventEmitter;

      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-utils\\node_modules\\readable-stream\\lib\\internal\\streams\\stream-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-utils\\node_modules\\readable-stream\\lib\\internal\\streams\\state.js", {"../../../errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-utils\\node_modules\\readable-stream\\errors-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-utils\node_modules\readable-stream\lib\internal\streams\state.js
      return function (require, module, exports) {
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};
      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-utils\\node_modules\\readable-stream\\lib\\internal\\streams\\state.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-utils\\node_modules\\readable-stream\\lib\\internal\\streams\\from-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-utils\node_modules\readable-stream\lib\internal\streams\from-browser.js
      return function (require, module, exports) {
module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};

      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-utils\\node_modules\\readable-stream\\lib\\internal\\streams\\from-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-utils\\node_modules\\readable-stream\\lib\\internal\\streams\\buffer_list.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-utils\node_modules\readable-stream\lib\internal\streams\buffer_list.js
      return function (require, module, exports) {
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();
      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-utils\\node_modules\\readable-stream\\lib\\internal\\streams\\buffer_list.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-utils\\node_modules\\readable-stream\\lib\\internal\\streams\\async_iterator.js", {"./end-of-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-utils\\node_modules\\readable-stream\\lib\\internal\\streams\\end-of-stream.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-utils\node_modules\readable-stream\lib\internal\streams\async_iterator.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-utils\\node_modules\\readable-stream\\lib\\internal\\streams\\async_iterator.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-importer\\src\\utils\\persist.js", {"multicodec":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\index.js","multihashes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multihashes\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-unixfs-importer\src\utils\persist.js
      return function (require, module, exports) {
'use strict'

const mh = require('multihashes')
const mc = require('multicodec')

const persist = (node, ipld, options) => {
  if (!options.codec && node.length) {
    options.cidVersion = 1
    options.codec = 'raw'
  }

  if (isNaN(options.hashAlg)) {
    options.hashAlg = mh.names[options.hashAlg]
  }

  if (options.hashAlg !== mh.names['sha2-256']) {
    options.cidVersion = 1
  }

  if (options.format) {
    options.codec = options.format
  }

  const format = mc[options.codec.toUpperCase().replace(/-/g, '_')]

  return ipld.put(node, format, options)
}

module.exports = persist

      };
    };
  }
}, {package:"ipfs-unixfs-importer",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-importer\\src\\utils\\persist.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-importer\\src\\dir-sharded.js", {"./dir":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-importer\\src\\dir.js","./utils/persist":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-importer\\src\\utils\\persist.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","deep-extend":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\deep-extend\\lib\\deep-extend.js","hamt-sharding":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\hamt-sharding\\src\\index.js","ipfs-unixfs":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs\\src\\index.js","ipld-dag-pb":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld-dag-pb\\src\\index.js","multihashing-async":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multihashing-async\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-unixfs-importer\src\dir-sharded.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const {
  DAGLink,
  DAGNode
} = require('ipld-dag-pb')
const UnixFS = require('ipfs-unixfs')
const multihashing = require('multihashing-async')
const Dir = require('./dir')
const persist = require('./utils/persist')
const Bucket = require('hamt-sharding')
const extend = require('deep-extend')

const hashFn = async function (value) {
  const hash = await multihashing(Buffer.from(value, 'utf8'), 'murmur3-128')

  // Multihashing inserts preamble of 2 bytes. Remove it.
  // Also, murmur3 outputs 128 bit but, accidently, IPFS Go's
  // implementation only uses the first 64, so we must do the same
  // for parity..
  const justHash = hash.slice(2, 10)
  const length = justHash.length
  const result = Buffer.alloc(length)
  // TODO: invert buffer because that's how Go impl does it
  for (let i = 0; i < length; i++) {
    result[length - i - 1] = justHash[i]
  }

  return result
}
hashFn.code = 0x22 // TODO: get this from multihashing-async?

const defaultOptions = {
  hashFn: hashFn
}

class DirSharded extends Dir {
  constructor (props, options) {
    options = extend({}, defaultOptions, options)

    super(props, options)

    this._bucket = Bucket(options)
  }

  async put (name, value) {
    await this._bucket.put(name, value)
  }

  get (name) {
    return this._bucket.get(name)
  }

  childCount () {
    return this._bucket.leafCount()
  }

  directChildrenCount () {
    return this._bucket.childrenCount()
  }

  onlyChild () {
    return this._bucket.onlyChild()
  }

  async * eachChildSeries () {
    for await (const { key, value } of this._bucket.eachLeafSeries()) {
      yield {
        key,
        child: value
      }
    }
  }

  async * flush (path, ipld) {
    for await (const entry of flush(path, this._bucket, ipld, this.options)) {
      yield entry
    }
  }
}

module.exports = DirSharded

module.exports.hashFn = hashFn

async function * flush (path, bucket, ipld, options) {
  const children = bucket._children
  const links = []

  for (let i = 0; i < children.length; i++) {
    const child = children.get(i)

    if (!child) {
      continue
    }

    const labelPrefix = i.toString(16).toUpperCase().padStart(2, '0')

    if (Bucket.isBucket(child)) {
      let shard

      for await (const subShard of await flush('', child, ipld, options)) {
        shard = subShard
      }

      links.push(await new DAGLink(labelPrefix, shard.node.size, shard.cid))
    } else if (typeof child.value.flush === 'function') {
      const dir = child.value
      let flushedDir

      for await (const entry of dir.flush(dir.path, ipld)) {
        flushedDir = entry

        yield flushedDir
      }

      const label = labelPrefix + child.key
      links.push(new DAGLink(label, flushedDir.node.size, flushedDir.cid))
    } else {
      const value = child.value

      if (!value.node) {
        if (value.cid) {
          value.node = await ipld.get(value.cid)
        } else {
          continue
        }
      }

      const label = labelPrefix + child.key
      const size = value.node.length || value.node.size || value.node.Size

      links.push(await new DAGLink(label, size, value.cid))
    }
  }

  // go-ipfs uses little endian, that's why we have to
  // reverse the bit field before storing it
  const data = Buffer.from(children.bitField().reverse())
  const dir = new UnixFS('hamt-sharded-directory', data)
  dir.fanout = bucket.tableSize()
  dir.hashType = options.hashFn.code

  const node = DAGNode.create(dir.marshal(), links)
  const cid = await persist(node, ipld, options)

  yield {
    cid,
    node,
    unixfs: dir,
    path
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs-unixfs-importer",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-importer\\src\\dir-sharded.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-importer\\src\\dag-builder\\file\\flat.js", {"async-iterator-batch":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async-iterator-batch\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-unixfs-importer\src\dag-builder\file\flat.js
      return function (require, module, exports) {
'use strict'

const batch = require('async-iterator-batch')

module.exports = async function * (source, reduce) {
  const roots = []

  for await (const chunk of batch(source, Infinity)) {
    roots.push(await reduce(chunk))
  }

  yield roots[0]
}

      };
    };
  }
}, {package:"ipfs-unixfs-importer",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-importer\\src\\dag-builder\\file\\flat.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-importer\\src\\dag-builder\\file\\trickle.js", {"async-iterator-batch":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async-iterator-batch\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-unixfs-importer\src\dag-builder\file\trickle.js
      return function (require, module, exports) {
'use strict'

const batch = require('async-iterator-batch')

module.exports = function * trickleReduceToRoot (source, reduce, options) {
  yield trickleStream(source, reduce, options)
}

async function trickleStream (source, reduce, options) {
  let root
  let iteration = 0
  let maxDepth = 1
  let subTree = root = new Root(options.layerRepeat)

  for await (const layer of batch(source, options.maxChildrenPerNode)) {
    if (subTree.isFull()) {
      if (subTree !== root) {
        root.addChild(await subTree.reduce(reduce))
      }

      if (iteration && iteration % options.layerRepeat === 0) {
        maxDepth++
      }

      subTree = new SubTree(maxDepth, options.layerRepeat, iteration)

      iteration++
    }

    subTree.append(layer)
  }

  if (subTree && subTree !== root) {
    root.addChild(await subTree.reduce(reduce))
  }

  return root.reduce(reduce)
}

class SubTree {
  constructor (maxDepth, layerRepeat, iteration) {
    this.maxDepth = maxDepth
    this.layerRepeat = layerRepeat
    this.currentDepth = 1
    this.iteration = iteration

    this.root = this.node = this.parent = {
      children: [],
      depth: this.currentDepth,
      maxDepth,
      maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat
    }
  }

  isFull () {
    if (!this.root.data) {
      return false
    }

    if (this.currentDepth < this.maxDepth && this.node.maxChildren) {
      // can descend
      this._addNextNodeToParent(this.node)

      return false
    }

    // try to find new node from node.parent
    const distantRelative = this._findParent(this.node, this.currentDepth)

    if (distantRelative) {
      this._addNextNodeToParent(distantRelative)

      return false
    }

    return true
  }

  _addNextNodeToParent (parent) {
    this.parent = parent

    // find site for new node
    const nextNode = {
      children: [],
      depth: parent.depth + 1,
      parent,
      maxDepth: this.maxDepth,
      maxChildren: Math.floor(parent.children.length / this.layerRepeat) * this.layerRepeat
    }

    parent.children.push(nextNode)

    this.currentDepth = nextNode.depth
    this.node = nextNode
  }

  append (layer) {
    this.node.data = layer
  }

  reduce (reduce) {
    return this._reduce(this.root, reduce)
  }

  async _reduce (node, reduce) {
    let children = []

    if (node.children.length) {
      children = await Promise.all(
        node.children
          .filter(child => child.data)
          .map(child => this._reduce(child, reduce))
      )
    }

    return reduce(node.data.concat(children))
  }

  _findParent (node, depth) {
    const parent = node.parent

    if (!parent || parent.depth === 0) {
      return
    }

    if (parent.children.length === parent.maxChildren || !parent.maxChildren) {
      // this layer is full, may be able to traverse to a different branch
      return this._findParent(parent, depth)
    }

    return parent
  }
}

class Root extends SubTree {
  constructor (layerRepeat) {
    super(0, layerRepeat)

    this.root.depth = 0
    this.currentDepth = 1
  }

  addChild (child) {
    this.root.children.push(child)
  }

  reduce (reduce) {
    return reduce(this.root.data.concat(this.root.children))
  }
}

      };
    };
  }
}, {package:"ipfs-unixfs-importer",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-importer\\src\\dag-builder\\file\\trickle.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-importer\\src\\dag-builder\\file\\balanced.js", {"async-iterator-batch":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async-iterator-batch\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-unixfs-importer\src\dag-builder\file\balanced.js
      return function (require, module, exports) {
'use strict'

const batch = require('async-iterator-batch')

async function * balanced (source, reduce, options) {
  yield await reduceToParents(source, reduce, options)
}

async function reduceToParents (source, reduce, options) {
  const roots = []

  for await (const chunked of batch(source, options.maxChildrenPerNode)) {
    roots.push(await reduce(chunked))
  }

  if (roots.length > 1) {
    return reduceToParents(roots, reduce, options)
  }

  return roots[0]
}

module.exports = balanced

      };
    };
  }
}, {package:"ipfs-unixfs-importer",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-importer\\src\\dag-builder\\file\\balanced.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-importer\\src\\chunker\\fixed-size.js", {"bl":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\bl.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-unixfs-importer\src\chunker\fixed-size.js
      return function (require, module, exports) {
'use strict'

const BufferList = require('bl')

module.exports = async function * fixedSizeChunker (source, options) {
  let bl = new BufferList()
  let currentLength = 0
  let emitted = false
  const maxChunkSize = options.maxChunkSize

  for await (const buffer of source) {
    bl.append(buffer)

    currentLength += buffer.length

    while (currentLength >= maxChunkSize) {
      yield bl.slice(0, maxChunkSize)
      emitted = true

      // throw away consumed bytes
      if (maxChunkSize === bl.length) {
        bl = new BufferList()
        currentLength = 0
      } else {
        const newBl = new BufferList()
        newBl.append(bl.shallowSlice(maxChunkSize))
        bl = newBl

        // update our offset
        currentLength -= maxChunkSize
      }
    }
  }

  if (!emitted || currentLength) {
    // return any remaining bytes or an empty buffer
    yield bl.slice(0, currentLength)
  }
}

      };
    };
  }
}, {package:"ipfs-unixfs-importer",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-importer\\src\\chunker\\fixed-size.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-importer\\src\\chunker\\rabin.js", {"bl":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\bl.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","err-code":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\err-code\\index.js","rabin-wasm":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\rabin-wasm\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-unixfs-importer\src\chunker\rabin.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const BufferList = require('bl')
const { create } = require('rabin-wasm')
const errcode = require('err-code')

module.exports = async function * rabinChunker (source, options) {
  const rabin = jsRabin()

  let min, max, avg

  if (options.minChunkSize && options.maxChunkSize && options.avgChunkSize) {
    avg = options.avgChunkSize
    min = options.minChunkSize
    max = options.maxChunkSize
  } else if (!options.avgChunkSize) {
    throw errcode(new Error('please specify an average chunk size'), 'ERR_INVALID_AVG_CHUNK_SIZE')
  } else {
    avg = options.avgChunkSize
    min = avg / 3
    max = avg + (avg / 2)
  }

  // validate min/max/avg in the same way as go
  if (min < 16) {
    throw errcode(new Error('rabin min must be greater than 16'), 'ERR_INVALID_MIN_CHUNK_SIZE')
  }

  if (max < min) {
    max = min
  }

  if (avg < min) {
    avg = min
  }

  const sizepow = Math.floor(Math.log2(avg))

  for await (const chunk of rabin(source, {
    min: min,
    max: max,
    bits: sizepow,
    window: options.window,
    polynomial: options.polynomial
  })) {
    yield chunk
  }
}

const jsRabin = () => {
  return async function * (source, options) {
    const r = await create(options.bits, options.min, options.max, options.window)
    const buffers = new BufferList()
    let pending = []

    for await (const chunk of source) {
      buffers.append(chunk)
      pending.push(chunk)

      const sizes = r.fingerprint(Buffer.concat(pending))
      pending = []

      for (let i = 0; i < sizes.length; i++) {
        var size = sizes[i]
        var buf = buffers.slice(0, size)
        buffers.consume(size)

        yield buf
      }
    }

    if (buffers.length) {
      yield buffers.slice(0)
    }
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs-unixfs-importer",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-importer\\src\\chunker\\rabin.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-mfs\\src\\core\\utils\\hamt-utils.js", {"async-iterator-last":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async-iterator-last\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debug\\src\\browser.js","hamt-sharding/src/bucket":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\hamt-sharding\\src\\bucket.js","ipfs-unixfs":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs\\src\\index.js","ipfs-unixfs-importer/src/dir-sharded":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-unixfs-importer\\src\\dir-sharded.js","ipld-dag-pb":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipld-dag-pb\\src\\index.js","multicodec":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multicodec\\src\\index.js","multihashes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multihashes\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-mfs\src\core\utils\hamt-utils.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const {
  DAGNode
} = require('ipld-dag-pb')
const Bucket = require('hamt-sharding/src/bucket')
const DirSharded = require('ipfs-unixfs-importer/src/dir-sharded')
const log = require('debug')('ipfs:mfs:core:utils:hamt-utils')
const UnixFS = require('ipfs-unixfs')
const mc = require('multicodec')
const mh = require('multihashes')
const last = require('async-iterator-last')

const updateHamtDirectory = async (context, links, bucket, options) => {
  // update parent with new bit field
  const data = Buffer.from(bucket._children.bitField().reverse())
  const dir = new UnixFS('hamt-sharded-directory', data)
  dir.fanout = bucket.tableSize()
  dir.hashType = DirSharded.hashFn.code

  const format = mc[options.format.toUpperCase().replace(/-/g, '_')]
  const hashAlg = mh.names[options.hashAlg]

  const parent = DAGNode.create(dir.marshal(), links)
  const cid = await context.ipld.put(parent, format, {
    cidVersion: options.cidVersion,
    hashAlg,
    hashOnly: !options.flush
  })

  return {
    node: parent,
    cid
  }
}

const recreateHamtLevel = async (links, rootBucket, parentBucket, positionAtParent) => {
  // recreate this level of the HAMT
  const bucket = new Bucket({
    hashFn: DirSharded.hashFn,
    hash: parentBucket ? parentBucket._options.hash : undefined
  }, parentBucket, positionAtParent)

  if (parentBucket) {
    parentBucket._putObjectAt(positionAtParent, bucket)
  }

  await addLinksToHamtBucket(links, bucket, rootBucket)

  return bucket
}

const addLinksToHamtBucket = async (links, bucket, rootBucket) => {
  await Promise.all(
    links.map(link => {
      if (link.Name.length === 2) {
        const pos = parseInt(link.Name, 16)

        bucket._putObjectAt(pos, new Bucket({
          hashFn: DirSharded.hashFn
        }, bucket, pos))

        return Promise.resolve()
      }

      return (rootBucket || bucket).put(link.Name.substring(2), {
        size: link.TSize,
        cid: link.Hash
      })
    })
  )
}

const toPrefix = (position) => {
  return position
    .toString('16')
    .toUpperCase()
    .padStart(2, '0')
    .substring(0, 2)
}

const generatePath = async (context, fileName, rootNode) => {
  // start at the root bucket and descend, loading nodes as we go
  const rootBucket = await recreateHamtLevel(rootNode.Links, null, null, null)
  const position = await rootBucket._findNewBucketAndPos(fileName)

  // the path to the root bucket
  let path = [{
    bucket: position.bucket,
    prefix: toPrefix(position.pos)
  }]
  let currentBucket = position.bucket

  while (currentBucket !== rootBucket) {
    path.push({
      bucket: currentBucket,
      prefix: toPrefix(currentBucket._posAtParent)
    })

    currentBucket = currentBucket._parent
  }

  path.reverse()
  path[0].node = rootNode

  // load DAGNode for each path segment
  for (let i = 0; i < path.length; i++) {
    const segment = path[i]

    // find prefix in links
    const link = segment.node.Links
      .filter(link => link.Name.substring(0, 2) === segment.prefix)
      .pop()

    // entry was not in shard
    if (!link) {
      // reached bottom of tree, file will be added to the current bucket
      log(`Link ${segment.prefix}${fileName} will be added`)
      // return path
      continue
    }

    // found entry
    if (link.Name === `${segment.prefix}${fileName}`) {
      log(`Link ${segment.prefix}${fileName} will be replaced`)
      // file already existed, file will be added to the current bucket
      // return path
      continue
    }

    // found subshard
    log(`Found subshard ${segment.prefix}`)
    const node = await context.ipld.get(link.Hash)

    // subshard hasn't been loaded, descend to the next level of the HAMT
    if (!path[i + 1]) {
      log(`Loaded new subshard ${segment.prefix}`)

      await recreateHamtLevel(node.Links, rootBucket, segment.bucket, parseInt(segment.prefix, 16))
      const position = await rootBucket._findNewBucketAndPos(fileName)

      // i--
      path.push({
        bucket: position.bucket,
        prefix: toPrefix(position.pos),
        node: node
      })

      continue
    }

    const nextSegment = path[i + 1]

    // add intermediate links to bucket
    await addLinksToHamtBucket(node.Links, nextSegment.bucket, rootBucket)

    nextSegment.node = node
  }

  await rootBucket.put(fileName, true)

  path.reverse()

  return {
    rootBucket,
    path
  }
}

const createShard = async (context, contents, options) => {
  const shard = new DirSharded({
    root: true,
    dir: true,
    parent: null,
    parentKey: null,
    path: '',
    dirty: true,
    flat: false
  }, options)

  for (let i = 0; i < contents.length; i++) {
    await shard._bucket.put(contents[i].name, {
      size: contents[i].size,
      cid: contents[i].cid
    })
  }

  return last(shard.flush('', context.ipld, null))
}

module.exports = {
  generatePath,
  updateHamtDirectory,
  recreateHamtLevel,
  addLinksToHamtBucket,
  toPrefix,
  createShard
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs-mfs",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-mfs\\src\\core\\utils\\hamt-utils.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\promise-timeout\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\promise-timeout\index.js
      return function (require, module, exports) {
// Copyright (c) 2015-2017 David M. Lee, II
'use strict';

/**
 * Local reference to TimeoutError
 * @private
 */
var TimeoutError;

/**
 * Rejects a promise with a {@link TimeoutError} if it does not settle within
 * the specified timeout.
 *
 * @param {Promise} promise The promise.
 * @param {number} timeoutMillis Number of milliseconds to wait on settling.
 * @returns {Promise} Either resolves/rejects with `promise`, or rejects with
 *                   `TimeoutError`, whichever settles first.
 */
var timeout = module.exports.timeout = function(promise, timeoutMillis) {
  var error = new TimeoutError(),
      timeout;

  return Promise.race([
    promise,
    new Promise(function(resolve, reject) {
      timeout = setTimeout(function() {
        reject(error);
      }, timeoutMillis);
    }),
  ]).then(function(v) {
    clearTimeout(timeout);
    return v;
  }, function(err) {
    clearTimeout(timeout);
    throw err;
  });
};

/**
 * Exception indicating that the timeout expired.
 */
TimeoutError = module.exports.TimeoutError = function() {
  Error.call(this)
  this.stack = Error().stack
  this.message = 'Timeout';
};

TimeoutError.prototype = Object.create(Error.prototype);
TimeoutError.prototype.name = "TimeoutError";

      };
    };
  }
}, {package:"promise-timeout",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\promise-timeout\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\observable-webworkers\\lib\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\observable-webworkers\lib\index.js
      return function (require, module, exports) {
const events = {}

const observable = (worker) => {
  worker.addEventListener('message', (event) => {
    observable.dispatchEvent('message', worker, event)
  })

  if (worker.port) {
    worker.port.addEventListener('message', (event) => {
      observable.dispatchEvent('message', worker, event)
    })
  }
}

observable.addEventListener = (type, fn) => {
  if (!events[type]) {
    events[type] = []
  }

  events[type].push(fn)
}

observable.removeEventListener = (type, fn) => {
  if (!events[type]) {
    return
  }

  events[type] = events[type]
    .filter(listener => listener === fn)
}

observable.dispatchEvent = function () {
  const args = Array.prototype.slice.call(arguments)
  const type = args.shift()

  if (!events[type]) {
    return
  }

  events[type].forEach(fn => fn.apply(null, args))
}

module.exports = observable

      };
    };
  }
}, {package:"observable-webworkers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\observable-webworkers\\lib\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\mortice\\lib\\browser.js", {"./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\mortice\\lib\\constants.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","observable-webworkers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\observable-webworkers\\lib\\index.js","shortid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\mortice\lib\browser.js
      return function (require, module, exports) {
const EventEmitter = require('events').EventEmitter
const shortid = require('shortid')
const {
  WORKER_REQUEST_READ_LOCK,
  WORKER_RELEASE_READ_LOCK,
  MASTER_GRANT_READ_LOCK,
  WORKER_REQUEST_WRITE_LOCK,
  WORKER_RELEASE_WRITE_LOCK,
  MASTER_GRANT_WRITE_LOCK
} = require('./constants')
const observer = require('observable-webworkers')

const handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {
  return (worker, event) => {
    if (!event || !event.data || event.data.type !== requestType) {
      return
    }

    const requestEvent = {
      type: event.data.type,
      name: event.data.name,
      identifier: event.data.identifier
    }

    emitter.emit(masterEvent, requestEvent.name, () => {
      // grant lock to worker
      worker.postMessage({
        type: grantType,
        name: requestEvent.name,
        identifier: requestEvent.identifier
      })

      // wait for worker to finish
      return new Promise((resolve) => {
        const releaseEventListener = (event) => {
          if (!event || !event.data) {
            return
          }

          const releaseEvent = {
            type: event.data.type,
            name: event.data.name,
            identifier: event.data.identifier
          }

          if (releaseEvent && releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
            worker.removeEventListener('message', releaseEventListener)
            resolve()
          }
        }

        worker.addEventListener('message', releaseEventListener)
      })
    })
  }
}

const makeWorkerLockRequest = (global, name, requestType, grantType, releaseType) => {
  return (fn) => {
    const id = shortid.generate()

    global.postMessage({
      type: requestType,
      identifier: id,
      name
    })

    return new Promise((resolve, reject) => {
      const listener = (event) => {
        if (!event || !event.data) {
          return
        }

        const responseEvent = {
          type: event.data.type,
          identifier: event.data.identifier
        }

        if (responseEvent && responseEvent.type === grantType && responseEvent.identifier === id) {
          global.removeEventListener('message', listener)

          let error

          fn()
            .catch((err) => {
              error = err
            })
            .then((result) => {
              global.postMessage({
                type: releaseType,
                identifier: id,
                name
              })

              if (error) {
                return reject(error)
              }

              return resolve(result)
            })
        }
      }

      global.addEventListener('message', listener)
    })
  }
}

const defaultOptions = {
  global: global,
  singleProcess: false
}

module.exports = (options) => {
  options = Object.assign({}, defaultOptions, options)
  const isMaster = !!options.global.document || options.singleProcess

  if (isMaster) {
    const emitter = new EventEmitter()

    observer.addEventListener('message', handleWorkerLockRequest(emitter, 'requestReadLock', WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK))
    observer.addEventListener('message', handleWorkerLockRequest(emitter, 'requestWriteLock', WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK))

    return emitter
  }

  return {
    isWorker: true,
    readLock: (name, options) => makeWorkerLockRequest(options.global, name, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),
    writeLock: (name, options) => makeWorkerLockRequest(options.global, name, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)
  }
}

      };
    };
  }
}, {package:"mortice",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\mortice\\lib\\browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\mortice\\lib\\node.js", {"./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\mortice\\lib\\constants.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","cluster":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","shortid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\mortice\lib\node.js
      return function (require, module, exports) {
(function (process){(function (){
const EventEmitter = require('events').EventEmitter
const shortid = require('shortid')
const {
  WORKER_REQUEST_READ_LOCK,
  WORKER_RELEASE_READ_LOCK,
  MASTER_GRANT_READ_LOCK,
  WORKER_REQUEST_WRITE_LOCK,
  WORKER_RELEASE_WRITE_LOCK,
  MASTER_GRANT_WRITE_LOCK
} = require('./constants')
let cluster

const handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {
  return (worker, requestEvent) => {
    if (requestEvent && requestEvent.type === requestType) {
      emitter.emit(masterEvent, requestEvent.name, () => {
        // grant lock to worker
        worker.send({
          type: grantType,
          name: requestEvent.name,
          identifier: requestEvent.identifier
        })

        // wait for worker to finish
        return new Promise((resolve) => {
          const releaseEventListener = (releaseEvent) => {
            if (releaseEvent && releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
              worker.removeListener('message', releaseEventListener)
              resolve()
            }
          }

          worker.on('message', releaseEventListener)
        })
      })
    }
  }
}

const makeWorkerLockRequest = (name, requestType, grantType, releaseType) => {
  return (fn) => {
    const id = shortid.generate()

    process.send({
      type: requestType,
      identifier: id,
      name
    })

    return new Promise((resolve, reject) => {
      const listener = (event) => {
        if (event && event.type === grantType && event.identifier === id) {
          process.removeListener('message', listener)

          let error = null

          fn()
            .catch((err) => {
              error = err
            })
            .then((result) => {
              process.send({
                type: releaseType,
                identifier: id,
                name
              })

              if (error) {
                return reject(error)
              }

              resolve(result)
            })
        }
      }

      process.on('message', listener)
    })
  }
}

module.exports = (options) => {
  try {
    cluster = require('cluster')

    if (!Object.keys(cluster).length) {
      return
    }
  } catch (_) {
    return
  }

  if (cluster.isMaster || options.singleProcess) {
    const emitter = new EventEmitter()

    cluster.on('message', handleWorkerLockRequest(emitter, 'requestReadLock', WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK))
    cluster.on('message', handleWorkerLockRequest(emitter, 'requestWriteLock', WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK))

    return emitter
  }

  return {
    isWorker: true,
    readLock: (name, options) => makeWorkerLockRequest(name, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),
    writeLock: (name, options) => makeWorkerLockRequest(name, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)
  }
}

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"mortice",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\mortice\\lib\\node.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\index.js", {"./_wordlists":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\_wordlists.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","create-hash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\create-hash\\browser.js","pbkdf2":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pbkdf2\\browser.js","randombytes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\randombytes\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\key-tree\node_modules\bip39\src\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const createHash = require("create-hash");
const pbkdf2_1 = require("pbkdf2");
const randomBytes = require("randombytes");
const _wordlists_1 = require("./_wordlists");
let DEFAULT_WORDLIST = _wordlists_1._default;
const INVALID_MNEMONIC = 'Invalid mnemonic';
const INVALID_ENTROPY = 'Invalid entropy';
const INVALID_CHECKSUM = 'Invalid mnemonic checksum';
const WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\n' +
    'Please pass a 2048 word array explicitly.';
function pbkdf2Promise(password, saltMixin, iterations, keylen, digest) {
    return Promise.resolve().then(() => new Promise((resolve, reject) => {
        const callback = (err, derivedKey) => {
            if (err) {
                return reject(err);
            }
            else {
                return resolve(derivedKey);
            }
        };
        pbkdf2_1.pbkdf2(password, saltMixin, iterations, keylen, digest, callback);
    }));
}
function normalize(str) {
    return (str || '').normalize('NFKD');
}
function lpad(str, padString, length) {
    while (str.length < length) {
        str = padString + str;
    }
    return str;
}
function binaryToByte(bin) {
    return parseInt(bin, 2);
}
function bytesToBinary(bytes) {
    return bytes.map((x) => lpad(x.toString(2), '0', 8)).join('');
}
function deriveChecksumBits(entropyBuffer) {
    const ENT = entropyBuffer.length * 8;
    const CS = ENT / 32;
    const hash = createHash('sha256')
        .update(entropyBuffer)
        .digest();
    return bytesToBinary(Array.from(hash)).slice(0, CS);
}
function salt(password) {
    return 'mnemonic' + (password || '');
}
function mnemonicToSeedSync(mnemonic, password) {
    const mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');
    const saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');
    return pbkdf2_1.pbkdf2Sync(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');
}
exports.mnemonicToSeedSync = mnemonicToSeedSync;
function mnemonicToSeed(mnemonic, password) {
    return Promise.resolve().then(() => {
        const mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');
        const saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');
        return pbkdf2Promise(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');
    });
}
exports.mnemonicToSeed = mnemonicToSeed;
function mnemonicToEntropy(mnemonic, wordlist) {
    wordlist = wordlist || DEFAULT_WORDLIST;
    if (!wordlist) {
        throw new Error(WORDLIST_REQUIRED);
    }
    const words = normalize(mnemonic).split(' ');
    if (words.length % 3 !== 0) {
        throw new Error(INVALID_MNEMONIC);
    }
    // convert word indices to 11 bit binary strings
    const bits = words
        .map((word) => {
        const index = wordlist.indexOf(word);
        if (index === -1) {
            throw new Error(INVALID_MNEMONIC);
        }
        return lpad(index.toString(2), '0', 11);
    })
        .join('');
    // split the binary string into ENT/CS
    const dividerIndex = Math.floor(bits.length / 33) * 32;
    const entropyBits = bits.slice(0, dividerIndex);
    const checksumBits = bits.slice(dividerIndex);
    // calculate the checksum and compare
    const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
    if (entropyBytes.length < 16) {
        throw new Error(INVALID_ENTROPY);
    }
    if (entropyBytes.length > 32) {
        throw new Error(INVALID_ENTROPY);
    }
    if (entropyBytes.length % 4 !== 0) {
        throw new Error(INVALID_ENTROPY);
    }
    const entropy = Buffer.from(entropyBytes);
    const newChecksum = deriveChecksumBits(entropy);
    if (newChecksum !== checksumBits) {
        throw new Error(INVALID_CHECKSUM);
    }
    return entropy.toString('hex');
}
exports.mnemonicToEntropy = mnemonicToEntropy;
function entropyToMnemonic(entropy, wordlist) {
    if (!Buffer.isBuffer(entropy)) {
        entropy = Buffer.from(entropy, 'hex');
    }
    wordlist = wordlist || DEFAULT_WORDLIST;
    if (!wordlist) {
        throw new Error(WORDLIST_REQUIRED);
    }
    // 128 <= ENT <= 256
    if (entropy.length < 16) {
        throw new TypeError(INVALID_ENTROPY);
    }
    if (entropy.length > 32) {
        throw new TypeError(INVALID_ENTROPY);
    }
    if (entropy.length % 4 !== 0) {
        throw new TypeError(INVALID_ENTROPY);
    }
    const entropyBits = bytesToBinary(Array.from(entropy));
    const checksumBits = deriveChecksumBits(entropy);
    const bits = entropyBits + checksumBits;
    const chunks = bits.match(/(.{1,11})/g);
    const words = chunks.map((binary) => {
        const index = binaryToByte(binary);
        return wordlist[index];
    });
    return wordlist[0] === '\u3042\u3044\u3053\u304f\u3057\u3093' // Japanese wordlist
        ? words.join('\u3000')
        : words.join(' ');
}
exports.entropyToMnemonic = entropyToMnemonic;
function generateMnemonic(strength, rng, wordlist) {
    strength = strength || 128;
    if (strength % 32 !== 0) {
        throw new TypeError(INVALID_ENTROPY);
    }
    rng = rng || randomBytes;
    return entropyToMnemonic(rng(strength / 8), wordlist);
}
exports.generateMnemonic = generateMnemonic;
function validateMnemonic(mnemonic, wordlist) {
    try {
        mnemonicToEntropy(mnemonic, wordlist);
    }
    catch (e) {
        return false;
    }
    return true;
}
exports.validateMnemonic = validateMnemonic;
function setDefaultWordlist(language) {
    const result = _wordlists_1.wordlists[language];
    if (result) {
        DEFAULT_WORDLIST = result;
    }
    else {
        throw new Error('Could not find wordlist for language "' + language + '"');
    }
}
exports.setDefaultWordlist = setDefaultWordlist;
function getDefaultWordlist() {
    if (!DEFAULT_WORDLIST) {
        throw new Error('No Default Wordlist set');
    }
    return Object.keys(_wordlists_1.wordlists).filter((lang) => {
        if (lang === 'JA' || lang === 'EN') {
            return false;
        }
        return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);
    })[0];
}
exports.getDefaultWordlist = getDefaultWordlist;
var _wordlists_2 = require("./_wordlists");
exports.wordlists = _wordlists_2.wordlists;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"bip39",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\encoding-down\\node_modules\\abstract-leveldown\\next-tick-browser.js", {"immediate":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\immediate\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\encoding-down\node_modules\abstract-leveldown\next-tick-browser.js
      return function (require, module, exports) {
module.exports = require('immediate')

      };
    };
  }
}, {package:"abstract-leveldown",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\encoding-down\\node_modules\\abstract-leveldown\\next-tick-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\encoding-down\\node_modules\\level-supports\\index.js", {"xtend":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\xtend\\immutable.js","xtend/mutable":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\xtend\\mutable.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\encoding-down\node_modules\level-supports\index.js
      return function (require, module, exports) {
'use strict'

// For (old) browser support
var xtend = require('xtend')
var assign = require('xtend/mutable')

module.exports = function supports () {
  var manifest = xtend.apply(null, arguments)

  return assign(manifest, {
    // Features of abstract-leveldown
    bufferKeys: manifest.bufferKeys || false,
    snapshots: manifest.snapshots || false,
    permanence: manifest.permanence || false,
    seek: manifest.seek || false,
    clear: manifest.clear || false,

    // Features of abstract-leveldown that levelup doesn't have
    status: manifest.status || false,

    // Features of disk-based implementations
    createIfMissing: manifest.createIfMissing || false,
    errorIfExists: manifest.errorIfExists || false,

    // Features of level(up) that abstract-leveldown doesn't have yet
    deferredOpen: manifest.deferredOpen || false,
    openCallback: manifest.openCallback || false,
    promises: manifest.promises || false,
    streams: manifest.streams || false,
    encodings: manifest.encodings || false,

    // Methods that are not part of abstract-leveldown or levelup
    additionalMethods: xtend(manifest.additionalMethods)
  })
}

      };
    };
  }
}, {package:"level-supports",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\encoding-down\\node_modules\\level-supports\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\node_modules\\secp256k1\\lib\\js\\ecjpoint.js", {"./bn":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\node_modules\\secp256k1\\lib\\js\\bn\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-crypto\node_modules\secp256k1\lib\js\ecjpoint.js
      return function (require, module, exports) {
'use strict'
var BN = require('./bn')

function ECJPoint (x, y, z) {
  if (x === null && y === null && z === null) {
    this.x = ECJPoint.one
    this.y = ECJPoint.one
    this.z = ECJPoint.zero
  } else {
    this.x = x
    this.y = y
    this.z = z
  }

  this.zOne = this.z === ECJPoint.one
}

ECJPoint.zero = BN.fromNumber(0)
ECJPoint.one = BN.fromNumber(1)

ECJPoint.prototype.neg = function () {
  if (this.inf) return this

  return new ECJPoint(this.x, this.y.redNeg(), this.z)
}

ECJPoint.prototype.add = function (p) {
  // O + P = P
  if (this.inf) return p

  // P + O = P
  if (p.inf) return this

  // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#addition-add-1998-cmo-2
  // 12M + 4S + 7A
  var pz2 = p.z.redSqr()
  var z2 = this.z.redSqr()
  var u1 = this.x.redMul(pz2)
  var u2 = p.x.redMul(z2)
  var s1 = this.y.redMul(pz2).redMul(p.z)
  var s2 = p.y.redMul(z2).redMul(this.z)

  var h = u1.redSub(u2)
  var r = s1.redSub(s2)
  if (h.isZero()) {
    if (r.isZero()) return this.dbl()
    return new ECJPoint(null, null, null)
  }

  var h2 = h.redSqr()
  var v = u1.redMul(h2)
  var h3 = h2.redMul(h)

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v)
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3))
  var nz = this.z.redMul(p.z).redMul(h)

  return new ECJPoint(nx, ny, nz)
}

ECJPoint.prototype.mixedAdd = function (p) {
  // O + P = P
  if (this.inf) return p.toECJPoint()

  // P + O = P
  if (p.inf) return this

  // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#addition-add-1998-cmo-2
  //   with p.z = 1
  // 8M + 3S + 7A
  var z2 = this.z.redSqr()
  var u1 = this.x
  var u2 = p.x.redMul(z2)
  var s1 = this.y
  var s2 = p.y.redMul(z2).redMul(this.z)

  var h = u1.redSub(u2)
  var r = s1.redSub(s2)
  if (h.isZero()) {
    if (r.isZero()) return this.dbl()
    return new ECJPoint(null, null, null)
  }

  var h2 = h.redSqr()
  var v = u1.redMul(h2)
  var h3 = h2.redMul(h)

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v)
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3))
  var nz = this.z.redMul(h)

  return new ECJPoint(nx, ny, nz)
}

ECJPoint.prototype.dbl = function () {
  if (this.inf) return this

  var nx
  var ny
  var nz

  // Z = 1
  if (this.zOne) {
    // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-mdbl-2007-bl
    // 1M + 5S + 6A + 3*2 + 1*3 + 1*8

    // XX = X1^2
    var xx = this.x.redSqr()
    // YY = Y1^2
    var yy = this.y.redSqr()
    // YYYY = YY^2
    var yyyy = yy.redSqr()
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy)
    s = s.redIAdd(s)
    // M = 3 * XX
    var m = xx.redAdd(xx).redIAdd(xx)
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s)

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy).redIAdd(yyyy).redIAdd(yyyy)

    // X3 = T
    nx = t
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8)
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y)
  } else {
    // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l
    // 2M + 5S + 6A + 3*2 + 1*3 + 1*8

    // A = X1^2
    var a = this.x.redSqr()
    // B = Y1^2
    var b = this.y.redSqr()
    // C = B^2
    var c = b.redSqr()
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c)
    d = d.redIAdd(d)
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a)
    // F = E^2
    var f = e.redSqr()

    // 8 * C
    var c8 = c.redIAdd(c).redIAdd(c).redIAdd(c)

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d)
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8)
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z)
    nz = nz.redIAdd(nz)
  }

  return new ECJPoint(nx, ny, nz)
}

ECJPoint.prototype.dblp = function (pow) {
  if (pow === 0 || this.inf) return this

  var point = this
  for (var i = 0; i < pow; i++) point = point.dbl()

  return point
}

Object.defineProperty(ECJPoint.prototype, 'inf', {
  enumerable: true,
  get: function () {
    return this.z.isZero()
  }
})

module.exports = ECJPoint

      };
    };
  }
}, {package:"secp256k1",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\node_modules\\secp256k1\\lib\\js\\ecjpoint.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\node_modules\\secp256k1\\lib\\js\\bn\\optimized.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-crypto\node_modules\secp256k1\lib\js\bn\optimized.js
      return function (require, module, exports) {
'use strict'
exports.umulTo10x10 = function (num1, num2, out) {
  var a = num1.words
  var b = num2.words
  var o = out.words
  var c = 0
  var lo
  var mid
  var hi
  var a0 = a[0] | 0
  var al0 = a0 & 0x1fff
  var ah0 = a0 >>> 13
  var a1 = a[1] | 0
  var al1 = a1 & 0x1fff
  var ah1 = a1 >>> 13
  var a2 = a[2] | 0
  var al2 = a2 & 0x1fff
  var ah2 = a2 >>> 13
  var a3 = a[3] | 0
  var al3 = a3 & 0x1fff
  var ah3 = a3 >>> 13
  var a4 = a[4] | 0
  var al4 = a4 & 0x1fff
  var ah4 = a4 >>> 13
  var a5 = a[5] | 0
  var al5 = a5 & 0x1fff
  var ah5 = a5 >>> 13
  var a6 = a[6] | 0
  var al6 = a6 & 0x1fff
  var ah6 = a6 >>> 13
  var a7 = a[7] | 0
  var al7 = a7 & 0x1fff
  var ah7 = a7 >>> 13
  var a8 = a[8] | 0
  var al8 = a8 & 0x1fff
  var ah8 = a8 >>> 13
  var a9 = a[9] | 0
  var al9 = a9 & 0x1fff
  var ah9 = a9 >>> 13
  var b0 = b[0] | 0
  var bl0 = b0 & 0x1fff
  var bh0 = b0 >>> 13
  var b1 = b[1] | 0
  var bl1 = b1 & 0x1fff
  var bh1 = b1 >>> 13
  var b2 = b[2] | 0
  var bl2 = b2 & 0x1fff
  var bh2 = b2 >>> 13
  var b3 = b[3] | 0
  var bl3 = b3 & 0x1fff
  var bh3 = b3 >>> 13
  var b4 = b[4] | 0
  var bl4 = b4 & 0x1fff
  var bh4 = b4 >>> 13
  var b5 = b[5] | 0
  var bl5 = b5 & 0x1fff
  var bh5 = b5 >>> 13
  var b6 = b[6] | 0
  var bl6 = b6 & 0x1fff
  var bh6 = b6 >>> 13
  var b7 = b[7] | 0
  var bl7 = b7 & 0x1fff
  var bh7 = b7 >>> 13
  var b8 = b[8] | 0
  var bl8 = b8 & 0x1fff
  var bh8 = b8 >>> 13
  var b9 = b[9] | 0
  var bl9 = b9 & 0x1fff
  var bh9 = b9 >>> 13

  out.length = 19
  /* k = 0 */
  lo = Math.imul(al0, bl0)
  mid = Math.imul(al0, bh0)
  mid += Math.imul(ah0, bl0)
  hi = Math.imul(ah0, bh0)
  var w0 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w0 >>> 26)
  w0 &= 0x3ffffff
  /* k = 1 */
  lo = Math.imul(al1, bl0)
  mid = Math.imul(al1, bh0)
  mid += Math.imul(ah1, bl0)
  hi = Math.imul(ah1, bh0)
  lo += Math.imul(al0, bl1)
  mid += Math.imul(al0, bh1)
  mid += Math.imul(ah0, bl1)
  hi += Math.imul(ah0, bh1)
  var w1 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w1 >>> 26)
  w1 &= 0x3ffffff
  /* k = 2 */
  lo = Math.imul(al2, bl0)
  mid = Math.imul(al2, bh0)
  mid += Math.imul(ah2, bl0)
  hi = Math.imul(ah2, bh0)
  lo += Math.imul(al1, bl1)
  mid += Math.imul(al1, bh1)
  mid += Math.imul(ah1, bl1)
  hi += Math.imul(ah1, bh1)
  lo += Math.imul(al0, bl2)
  mid += Math.imul(al0, bh2)
  mid += Math.imul(ah0, bl2)
  hi += Math.imul(ah0, bh2)
  var w2 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w2 >>> 26)
  w2 &= 0x3ffffff
  /* k = 3 */
  lo = Math.imul(al3, bl0)
  mid = Math.imul(al3, bh0)
  mid += Math.imul(ah3, bl0)
  hi = Math.imul(ah3, bh0)
  lo += Math.imul(al2, bl1)
  mid += Math.imul(al2, bh1)
  mid += Math.imul(ah2, bl1)
  hi += Math.imul(ah2, bh1)
  lo += Math.imul(al1, bl2)
  mid += Math.imul(al1, bh2)
  mid += Math.imul(ah1, bl2)
  hi += Math.imul(ah1, bh2)
  lo += Math.imul(al0, bl3)
  mid += Math.imul(al0, bh3)
  mid += Math.imul(ah0, bl3)
  hi += Math.imul(ah0, bh3)
  var w3 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w3 >>> 26)
  w3 &= 0x3ffffff
  /* k = 4 */
  lo = Math.imul(al4, bl0)
  mid = Math.imul(al4, bh0)
  mid += Math.imul(ah4, bl0)
  hi = Math.imul(ah4, bh0)
  lo += Math.imul(al3, bl1)
  mid += Math.imul(al3, bh1)
  mid += Math.imul(ah3, bl1)
  hi += Math.imul(ah3, bh1)
  lo += Math.imul(al2, bl2)
  mid += Math.imul(al2, bh2)
  mid += Math.imul(ah2, bl2)
  hi += Math.imul(ah2, bh2)
  lo += Math.imul(al1, bl3)
  mid += Math.imul(al1, bh3)
  mid += Math.imul(ah1, bl3)
  hi += Math.imul(ah1, bh3)
  lo += Math.imul(al0, bl4)
  mid += Math.imul(al0, bh4)
  mid += Math.imul(ah0, bl4)
  hi += Math.imul(ah0, bh4)
  var w4 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w4 >>> 26)
  w4 &= 0x3ffffff
  /* k = 5 */
  lo = Math.imul(al5, bl0)
  mid = Math.imul(al5, bh0)
  mid += Math.imul(ah5, bl0)
  hi = Math.imul(ah5, bh0)
  lo += Math.imul(al4, bl1)
  mid += Math.imul(al4, bh1)
  mid += Math.imul(ah4, bl1)
  hi += Math.imul(ah4, bh1)
  lo += Math.imul(al3, bl2)
  mid += Math.imul(al3, bh2)
  mid += Math.imul(ah3, bl2)
  hi += Math.imul(ah3, bh2)
  lo += Math.imul(al2, bl3)
  mid += Math.imul(al2, bh3)
  mid += Math.imul(ah2, bl3)
  hi += Math.imul(ah2, bh3)
  lo += Math.imul(al1, bl4)
  mid += Math.imul(al1, bh4)
  mid += Math.imul(ah1, bl4)
  hi += Math.imul(ah1, bh4)
  lo += Math.imul(al0, bl5)
  mid += Math.imul(al0, bh5)
  mid += Math.imul(ah0, bl5)
  hi += Math.imul(ah0, bh5)
  var w5 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w5 >>> 26)
  w5 &= 0x3ffffff
  /* k = 6 */
  lo = Math.imul(al6, bl0)
  mid = Math.imul(al6, bh0)
  mid += Math.imul(ah6, bl0)
  hi = Math.imul(ah6, bh0)
  lo += Math.imul(al5, bl1)
  mid += Math.imul(al5, bh1)
  mid += Math.imul(ah5, bl1)
  hi += Math.imul(ah5, bh1)
  lo += Math.imul(al4, bl2)
  mid += Math.imul(al4, bh2)
  mid += Math.imul(ah4, bl2)
  hi += Math.imul(ah4, bh2)
  lo += Math.imul(al3, bl3)
  mid += Math.imul(al3, bh3)
  mid += Math.imul(ah3, bl3)
  hi += Math.imul(ah3, bh3)
  lo += Math.imul(al2, bl4)
  mid += Math.imul(al2, bh4)
  mid += Math.imul(ah2, bl4)
  hi += Math.imul(ah2, bh4)
  lo += Math.imul(al1, bl5)
  mid += Math.imul(al1, bh5)
  mid += Math.imul(ah1, bl5)
  hi += Math.imul(ah1, bh5)
  lo += Math.imul(al0, bl6)
  mid += Math.imul(al0, bh6)
  mid += Math.imul(ah0, bl6)
  hi += Math.imul(ah0, bh6)
  var w6 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w6 >>> 26)
  w6 &= 0x3ffffff
  /* k = 7 */
  lo = Math.imul(al7, bl0)
  mid = Math.imul(al7, bh0)
  mid += Math.imul(ah7, bl0)
  hi = Math.imul(ah7, bh0)
  lo += Math.imul(al6, bl1)
  mid += Math.imul(al6, bh1)
  mid += Math.imul(ah6, bl1)
  hi += Math.imul(ah6, bh1)
  lo += Math.imul(al5, bl2)
  mid += Math.imul(al5, bh2)
  mid += Math.imul(ah5, bl2)
  hi += Math.imul(ah5, bh2)
  lo += Math.imul(al4, bl3)
  mid += Math.imul(al4, bh3)
  mid += Math.imul(ah4, bl3)
  hi += Math.imul(ah4, bh3)
  lo += Math.imul(al3, bl4)
  mid += Math.imul(al3, bh4)
  mid += Math.imul(ah3, bl4)
  hi += Math.imul(ah3, bh4)
  lo += Math.imul(al2, bl5)
  mid += Math.imul(al2, bh5)
  mid += Math.imul(ah2, bl5)
  hi += Math.imul(ah2, bh5)
  lo += Math.imul(al1, bl6)
  mid += Math.imul(al1, bh6)
  mid += Math.imul(ah1, bl6)
  hi += Math.imul(ah1, bh6)
  lo += Math.imul(al0, bl7)
  mid += Math.imul(al0, bh7)
  mid += Math.imul(ah0, bl7)
  hi += Math.imul(ah0, bh7)
  var w7 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w7 >>> 26)
  w7 &= 0x3ffffff
  /* k = 8 */
  lo = Math.imul(al8, bl0)
  mid = Math.imul(al8, bh0)
  mid += Math.imul(ah8, bl0)
  hi = Math.imul(ah8, bh0)
  lo += Math.imul(al7, bl1)
  mid += Math.imul(al7, bh1)
  mid += Math.imul(ah7, bl1)
  hi += Math.imul(ah7, bh1)
  lo += Math.imul(al6, bl2)
  mid += Math.imul(al6, bh2)
  mid += Math.imul(ah6, bl2)
  hi += Math.imul(ah6, bh2)
  lo += Math.imul(al5, bl3)
  mid += Math.imul(al5, bh3)
  mid += Math.imul(ah5, bl3)
  hi += Math.imul(ah5, bh3)
  lo += Math.imul(al4, bl4)
  mid += Math.imul(al4, bh4)
  mid += Math.imul(ah4, bl4)
  hi += Math.imul(ah4, bh4)
  lo += Math.imul(al3, bl5)
  mid += Math.imul(al3, bh5)
  mid += Math.imul(ah3, bl5)
  hi += Math.imul(ah3, bh5)
  lo += Math.imul(al2, bl6)
  mid += Math.imul(al2, bh6)
  mid += Math.imul(ah2, bl6)
  hi += Math.imul(ah2, bh6)
  lo += Math.imul(al1, bl7)
  mid += Math.imul(al1, bh7)
  mid += Math.imul(ah1, bl7)
  hi += Math.imul(ah1, bh7)
  lo += Math.imul(al0, bl8)
  mid += Math.imul(al0, bh8)
  mid += Math.imul(ah0, bl8)
  hi += Math.imul(ah0, bh8)
  var w8 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w8 >>> 26)
  w8 &= 0x3ffffff
  /* k = 9 */
  lo = Math.imul(al9, bl0)
  mid = Math.imul(al9, bh0)
  mid += Math.imul(ah9, bl0)
  hi = Math.imul(ah9, bh0)
  lo += Math.imul(al8, bl1)
  mid += Math.imul(al8, bh1)
  mid += Math.imul(ah8, bl1)
  hi += Math.imul(ah8, bh1)
  lo += Math.imul(al7, bl2)
  mid += Math.imul(al7, bh2)
  mid += Math.imul(ah7, bl2)
  hi += Math.imul(ah7, bh2)
  lo += Math.imul(al6, bl3)
  mid += Math.imul(al6, bh3)
  mid += Math.imul(ah6, bl3)
  hi += Math.imul(ah6, bh3)
  lo += Math.imul(al5, bl4)
  mid += Math.imul(al5, bh4)
  mid += Math.imul(ah5, bl4)
  hi += Math.imul(ah5, bh4)
  lo += Math.imul(al4, bl5)
  mid += Math.imul(al4, bh5)
  mid += Math.imul(ah4, bl5)
  hi += Math.imul(ah4, bh5)
  lo += Math.imul(al3, bl6)
  mid += Math.imul(al3, bh6)
  mid += Math.imul(ah3, bl6)
  hi += Math.imul(ah3, bh6)
  lo += Math.imul(al2, bl7)
  mid += Math.imul(al2, bh7)
  mid += Math.imul(ah2, bl7)
  hi += Math.imul(ah2, bh7)
  lo += Math.imul(al1, bl8)
  mid += Math.imul(al1, bh8)
  mid += Math.imul(ah1, bl8)
  hi += Math.imul(ah1, bh8)
  lo += Math.imul(al0, bl9)
  mid += Math.imul(al0, bh9)
  mid += Math.imul(ah0, bl9)
  hi += Math.imul(ah0, bh9)
  var w9 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w9 >>> 26)
  w9 &= 0x3ffffff
  /* k = 10 */
  lo = Math.imul(al9, bl1)
  mid = Math.imul(al9, bh1)
  mid += Math.imul(ah9, bl1)
  hi = Math.imul(ah9, bh1)
  lo += Math.imul(al8, bl2)
  mid += Math.imul(al8, bh2)
  mid += Math.imul(ah8, bl2)
  hi += Math.imul(ah8, bh2)
  lo += Math.imul(al7, bl3)
  mid += Math.imul(al7, bh3)
  mid += Math.imul(ah7, bl3)
  hi += Math.imul(ah7, bh3)
  lo += Math.imul(al6, bl4)
  mid += Math.imul(al6, bh4)
  mid += Math.imul(ah6, bl4)
  hi += Math.imul(ah6, bh4)
  lo += Math.imul(al5, bl5)
  mid += Math.imul(al5, bh5)
  mid += Math.imul(ah5, bl5)
  hi += Math.imul(ah5, bh5)
  lo += Math.imul(al4, bl6)
  mid += Math.imul(al4, bh6)
  mid += Math.imul(ah4, bl6)
  hi += Math.imul(ah4, bh6)
  lo += Math.imul(al3, bl7)
  mid += Math.imul(al3, bh7)
  mid += Math.imul(ah3, bl7)
  hi += Math.imul(ah3, bh7)
  lo += Math.imul(al2, bl8)
  mid += Math.imul(al2, bh8)
  mid += Math.imul(ah2, bl8)
  hi += Math.imul(ah2, bh8)
  lo += Math.imul(al1, bl9)
  mid += Math.imul(al1, bh9)
  mid += Math.imul(ah1, bl9)
  hi += Math.imul(ah1, bh9)
  var w10 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w10 >>> 26)
  w10 &= 0x3ffffff
  /* k = 11 */
  lo = Math.imul(al9, bl2)
  mid = Math.imul(al9, bh2)
  mid += Math.imul(ah9, bl2)
  hi = Math.imul(ah9, bh2)
  lo += Math.imul(al8, bl3)
  mid += Math.imul(al8, bh3)
  mid += Math.imul(ah8, bl3)
  hi += Math.imul(ah8, bh3)
  lo += Math.imul(al7, bl4)
  mid += Math.imul(al7, bh4)
  mid += Math.imul(ah7, bl4)
  hi += Math.imul(ah7, bh4)
  lo += Math.imul(al6, bl5)
  mid += Math.imul(al6, bh5)
  mid += Math.imul(ah6, bl5)
  hi += Math.imul(ah6, bh5)
  lo += Math.imul(al5, bl6)
  mid += Math.imul(al5, bh6)
  mid += Math.imul(ah5, bl6)
  hi += Math.imul(ah5, bh6)
  lo += Math.imul(al4, bl7)
  mid += Math.imul(al4, bh7)
  mid += Math.imul(ah4, bl7)
  hi += Math.imul(ah4, bh7)
  lo += Math.imul(al3, bl8)
  mid += Math.imul(al3, bh8)
  mid += Math.imul(ah3, bl8)
  hi += Math.imul(ah3, bh8)
  lo += Math.imul(al2, bl9)
  mid += Math.imul(al2, bh9)
  mid += Math.imul(ah2, bl9)
  hi += Math.imul(ah2, bh9)
  var w11 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w11 >>> 26)
  w11 &= 0x3ffffff
  /* k = 12 */
  lo = Math.imul(al9, bl3)
  mid = Math.imul(al9, bh3)
  mid += Math.imul(ah9, bl3)
  hi = Math.imul(ah9, bh3)
  lo += Math.imul(al8, bl4)
  mid += Math.imul(al8, bh4)
  mid += Math.imul(ah8, bl4)
  hi += Math.imul(ah8, bh4)
  lo += Math.imul(al7, bl5)
  mid += Math.imul(al7, bh5)
  mid += Math.imul(ah7, bl5)
  hi += Math.imul(ah7, bh5)
  lo += Math.imul(al6, bl6)
  mid += Math.imul(al6, bh6)
  mid += Math.imul(ah6, bl6)
  hi += Math.imul(ah6, bh6)
  lo += Math.imul(al5, bl7)
  mid += Math.imul(al5, bh7)
  mid += Math.imul(ah5, bl7)
  hi += Math.imul(ah5, bh7)
  lo += Math.imul(al4, bl8)
  mid += Math.imul(al4, bh8)
  mid += Math.imul(ah4, bl8)
  hi += Math.imul(ah4, bh8)
  lo += Math.imul(al3, bl9)
  mid += Math.imul(al3, bh9)
  mid += Math.imul(ah3, bl9)
  hi += Math.imul(ah3, bh9)
  var w12 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w12 >>> 26)
  w12 &= 0x3ffffff
  /* k = 13 */
  lo = Math.imul(al9, bl4)
  mid = Math.imul(al9, bh4)
  mid += Math.imul(ah9, bl4)
  hi = Math.imul(ah9, bh4)
  lo += Math.imul(al8, bl5)
  mid += Math.imul(al8, bh5)
  mid += Math.imul(ah8, bl5)
  hi += Math.imul(ah8, bh5)
  lo += Math.imul(al7, bl6)
  mid += Math.imul(al7, bh6)
  mid += Math.imul(ah7, bl6)
  hi += Math.imul(ah7, bh6)
  lo += Math.imul(al6, bl7)
  mid += Math.imul(al6, bh7)
  mid += Math.imul(ah6, bl7)
  hi += Math.imul(ah6, bh7)
  lo += Math.imul(al5, bl8)
  mid += Math.imul(al5, bh8)
  mid += Math.imul(ah5, bl8)
  hi += Math.imul(ah5, bh8)
  lo += Math.imul(al4, bl9)
  mid += Math.imul(al4, bh9)
  mid += Math.imul(ah4, bl9)
  hi += Math.imul(ah4, bh9)
  var w13 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w13 >>> 26)
  w13 &= 0x3ffffff
  /* k = 14 */
  lo = Math.imul(al9, bl5)
  mid = Math.imul(al9, bh5)
  mid += Math.imul(ah9, bl5)
  hi = Math.imul(ah9, bh5)
  lo += Math.imul(al8, bl6)
  mid += Math.imul(al8, bh6)
  mid += Math.imul(ah8, bl6)
  hi += Math.imul(ah8, bh6)
  lo += Math.imul(al7, bl7)
  mid += Math.imul(al7, bh7)
  mid += Math.imul(ah7, bl7)
  hi += Math.imul(ah7, bh7)
  lo += Math.imul(al6, bl8)
  mid += Math.imul(al6, bh8)
  mid += Math.imul(ah6, bl8)
  hi += Math.imul(ah6, bh8)
  lo += Math.imul(al5, bl9)
  mid += Math.imul(al5, bh9)
  mid += Math.imul(ah5, bl9)
  hi += Math.imul(ah5, bh9)
  var w14 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w14 >>> 26)
  w14 &= 0x3ffffff
  /* k = 15 */
  lo = Math.imul(al9, bl6)
  mid = Math.imul(al9, bh6)
  mid += Math.imul(ah9, bl6)
  hi = Math.imul(ah9, bh6)
  lo += Math.imul(al8, bl7)
  mid += Math.imul(al8, bh7)
  mid += Math.imul(ah8, bl7)
  hi += Math.imul(ah8, bh7)
  lo += Math.imul(al7, bl8)
  mid += Math.imul(al7, bh8)
  mid += Math.imul(ah7, bl8)
  hi += Math.imul(ah7, bh8)
  lo += Math.imul(al6, bl9)
  mid += Math.imul(al6, bh9)
  mid += Math.imul(ah6, bl9)
  hi += Math.imul(ah6, bh9)
  var w15 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w15 >>> 26)
  w15 &= 0x3ffffff
  /* k = 16 */
  lo = Math.imul(al9, bl7)
  mid = Math.imul(al9, bh7)
  mid += Math.imul(ah9, bl7)
  hi = Math.imul(ah9, bh7)
  lo += Math.imul(al8, bl8)
  mid += Math.imul(al8, bh8)
  mid += Math.imul(ah8, bl8)
  hi += Math.imul(ah8, bh8)
  lo += Math.imul(al7, bl9)
  mid += Math.imul(al7, bh9)
  mid += Math.imul(ah7, bl9)
  hi += Math.imul(ah7, bh9)
  var w16 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w16 >>> 26)
  w16 &= 0x3ffffff
  /* k = 17 */
  lo = Math.imul(al9, bl8)
  mid = Math.imul(al9, bh8)
  mid += Math.imul(ah9, bl8)
  hi = Math.imul(ah9, bh8)
  lo += Math.imul(al8, bl9)
  mid += Math.imul(al8, bh9)
  mid += Math.imul(ah8, bl9)
  hi += Math.imul(ah8, bh9)
  var w17 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w17 >>> 26)
  w17 &= 0x3ffffff
  /* k = 18 */
  lo = Math.imul(al9, bl9)
  mid = Math.imul(al9, bh9)
  mid += Math.imul(ah9, bl9)
  hi = Math.imul(ah9, bh9)
  var w18 = c + lo + ((mid & 0x1fff) << 13)
  c = hi + (mid >>> 13) + (w18 >>> 26)
  w18 &= 0x3ffffff
  o[0] = w0
  o[1] = w1
  o[2] = w2
  o[3] = w3
  o[4] = w4
  o[5] = w5
  o[6] = w6
  o[7] = w7
  o[8] = w8
  o[9] = w9
  o[10] = w10
  o[11] = w11
  o[12] = w12
  o[13] = w13
  o[14] = w14
  o[15] = w15
  o[16] = w16
  o[17] = w17
  o[18] = w18
  if (c !== 0) {
    o[19] = c
    out.length++
  }
  return out
}

      };
    };
  }
}, {package:"secp256k1",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\node_modules\\secp256k1\\lib\\js\\bn\\optimized.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\drbg.js\\lib\\hash-info.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\drbg.js\lib\hash-info.json
      return function (require, module, exports) {
module.exports={
  "sha1": {
    "securityStrength": 128,
    "outlen": 160,
    "seedlen": 440
  },
  "sha224": {
    "securityStrength": 192,
    "outlen": 224,
    "seedlen": 440
  },
  "sha256": {
    "securityStrength": 256,
    "outlen": 256,
    "seedlen": 440
  },
  "sha384": {
    "securityStrength": 256,
    "outlen": 384,
    "seedlen": 888
  },
  "sha512": {
    "securityStrength": 256,
    "outlen": 512,
    "seedlen": 888
  }
}

      };
    };
  }
}, {package:"drbg.js",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\drbg.js\\lib\\hash-info.json",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\pss.js", {"./forge":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\forge.js","./random":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\random.js","./util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\node-forge\lib\pss.js
      return function (require, module, exports) {
/**
 * Javascript implementation of PKCS#1 PSS signature padding.
 *
 * @author Stefan Siegl
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 */
var forge = require('./forge');
require('./random');
require('./util');

// shortcut for PSS API
var pss = module.exports = forge.pss = forge.pss || {};

/**
 * Creates a PSS signature scheme object.
 *
 * There are several ways to provide a salt for encoding:
 *
 * 1. Specify the saltLength only and the built-in PRNG will generate it.
 * 2. Specify the saltLength and a custom PRNG with 'getBytesSync' defined that
 *   will be used.
 * 3. Specify the salt itself as a forge.util.ByteBuffer.
 *
 * @param options the options to use:
 *          md the message digest object to use, a forge md instance.
 *          mgf the mask generation function to use, a forge mgf instance.
 *          [saltLength] the length of the salt in octets.
 *          [prng] the pseudo-random number generator to use to produce a salt.
 *          [salt] the salt to use when encoding.
 *
 * @return a signature scheme object.
 */
pss.create = function(options) {
  // backwards compatibility w/legacy args: hash, mgf, sLen
  if(arguments.length === 3) {
    options = {
      md: arguments[0],
      mgf: arguments[1],
      saltLength: arguments[2]
    };
  }

  var hash = options.md;
  var mgf = options.mgf;
  var hLen = hash.digestLength;

  var salt_ = options.salt || null;
  if(typeof salt_ === 'string') {
    // assume binary-encoded string
    salt_ = forge.util.createBuffer(salt_);
  }

  var sLen;
  if('saltLength' in options) {
    sLen = options.saltLength;
  } else if(salt_ !== null) {
    sLen = salt_.length();
  } else {
    throw new Error('Salt length not specified or specific salt not given.');
  }

  if(salt_ !== null && salt_.length() !== sLen) {
    throw new Error('Given salt length does not match length of given salt.');
  }

  var prng = options.prng || forge.random;

  var pssobj = {};

  /**
   * Encodes a PSS signature.
   *
   * This function implements EMSA-PSS-ENCODE as per RFC 3447, section 9.1.1.
   *
   * @param md the message digest object with the hash to sign.
   * @param modsBits the length of the RSA modulus in bits.
   *
   * @return the encoded message as a binary-encoded string of length
   *           ceil((modBits - 1) / 8).
   */
  pssobj.encode = function(md, modBits) {
    var i;
    var emBits = modBits - 1;
    var emLen = Math.ceil(emBits / 8);

    /* 2. Let mHash = Hash(M), an octet string of length hLen. */
    var mHash = md.digest().getBytes();

    /* 3. If emLen < hLen + sLen + 2, output "encoding error" and stop. */
    if(emLen < hLen + sLen + 2) {
      throw new Error('Message is too long to encrypt.');
    }

    /* 4. Generate a random octet string salt of length sLen; if sLen = 0,
     *    then salt is the empty string. */
    var salt;
    if(salt_ === null) {
      salt = prng.getBytesSync(sLen);
    } else {
      salt = salt_.bytes();
    }

    /* 5. Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt; */
    var m_ = new forge.util.ByteBuffer();
    m_.fillWithByte(0, 8);
    m_.putBytes(mHash);
    m_.putBytes(salt);

    /* 6. Let H = Hash(M'), an octet string of length hLen. */
    hash.start();
    hash.update(m_.getBytes());
    var h = hash.digest().getBytes();

    /* 7. Generate an octet string PS consisting of emLen - sLen - hLen - 2
     *    zero octets.  The length of PS may be 0. */
    var ps = new forge.util.ByteBuffer();
    ps.fillWithByte(0, emLen - sLen - hLen - 2);

    /* 8. Let DB = PS || 0x01 || salt; DB is an octet string of length
     *    emLen - hLen - 1. */
    ps.putByte(0x01);
    ps.putBytes(salt);
    var db = ps.getBytes();

    /* 9. Let dbMask = MGF(H, emLen - hLen - 1). */
    var maskLen = emLen - hLen - 1;
    var dbMask = mgf.generate(h, maskLen);

    /* 10. Let maskedDB = DB \xor dbMask. */
    var maskedDB = '';
    for(i = 0; i < maskLen; i++) {
      maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));
    }

    /* 11. Set the leftmost 8emLen - emBits bits of the leftmost octet in
     *     maskedDB to zero. */
    var mask = (0xFF00 >> (8 * emLen - emBits)) & 0xFF;
    maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) +
      maskedDB.substr(1);

    /* 12. Let EM = maskedDB || H || 0xbc.
     * 13. Output EM. */
    return maskedDB + h + String.fromCharCode(0xbc);
  };

  /**
   * Verifies a PSS signature.
   *
   * This function implements EMSA-PSS-VERIFY as per RFC 3447, section 9.1.2.
   *
   * @param mHash the message digest hash, as a binary-encoded string, to
   *         compare against the signature.
   * @param em the encoded message, as a binary-encoded string
   *          (RSA decryption result).
   * @param modsBits the length of the RSA modulus in bits.
   *
   * @return true if the signature was verified, false if not.
   */
  pssobj.verify = function(mHash, em, modBits) {
    var i;
    var emBits = modBits - 1;
    var emLen = Math.ceil(emBits / 8);

    /* c. Convert the message representative m to an encoded message EM
     *    of length emLen = ceil((modBits - 1) / 8) octets, where modBits
     *    is the length in bits of the RSA modulus n */
    em = em.substr(-emLen);

    /* 3. If emLen < hLen + sLen + 2, output "inconsistent" and stop. */
    if(emLen < hLen + sLen + 2) {
      throw new Error('Inconsistent parameters to PSS signature verification.');
    }

    /* 4. If the rightmost octet of EM does not have hexadecimal value
     *    0xbc, output "inconsistent" and stop. */
    if(em.charCodeAt(emLen - 1) !== 0xbc) {
      throw new Error('Encoded message does not end in 0xBC.');
    }

    /* 5. Let maskedDB be the leftmost emLen - hLen - 1 octets of EM, and
     *    let H be the next hLen octets. */
    var maskLen = emLen - hLen - 1;
    var maskedDB = em.substr(0, maskLen);
    var h = em.substr(maskLen, hLen);

    /* 6. If the leftmost 8emLen - emBits bits of the leftmost octet in
     *    maskedDB are not all equal to zero, output "inconsistent" and stop. */
    var mask = (0xFF00 >> (8 * emLen - emBits)) & 0xFF;
    if((maskedDB.charCodeAt(0) & mask) !== 0) {
      throw new Error('Bits beyond keysize not zero as expected.');
    }

    /* 7. Let dbMask = MGF(H, emLen - hLen - 1). */
    var dbMask = mgf.generate(h, maskLen);

    /* 8. Let DB = maskedDB \xor dbMask. */
    var db = '';
    for(i = 0; i < maskLen; i++) {
      db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));
    }

    /* 9. Set the leftmost 8emLen - emBits bits of the leftmost octet
     * in DB to zero. */
    db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);

    /* 10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero
     * or if the octet at position emLen - hLen - sLen - 1 (the leftmost
     * position is "position 1") does not have hexadecimal value 0x01,
     * output "inconsistent" and stop. */
    var checkLen = emLen - hLen - sLen - 2;
    for(i = 0; i < checkLen; i++) {
      if(db.charCodeAt(i) !== 0x00) {
        throw new Error('Leftmost octets not zero as expected');
      }
    }

    if(db.charCodeAt(checkLen) !== 0x01) {
      throw new Error('Inconsistent PSS signature, 0x01 marker not found');
    }

    /* 11. Let salt be the last sLen octets of DB. */
    var salt = db.substr(-sLen);

    /* 12.  Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt */
    var m_ = new forge.util.ByteBuffer();
    m_.fillWithByte(0, 8);
    m_.putBytes(mHash);
    m_.putBytes(salt);

    /* 13. Let H' = Hash(M'), an octet string of length hLen. */
    hash.start();
    hash.update(m_.getBytes());
    var h_ = hash.digest().getBytes();

    /* 14. If H = H', output "consistent." Otherwise, output "inconsistent." */
    return h === h_;
  };

  return pssobj;
};

      };
    };
  }
}, {package:"node-forge",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\pss.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\mgf.js", {"./forge":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\forge.js","./mgf1":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\mgf1.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\node-forge\lib\mgf.js
      return function (require, module, exports) {
/**
 * Node.js module for Forge mask generation functions.
 *
 * @author Stefan Siegl
 *
 * Copyright 2012 Stefan Siegl <stesie@brokenpipe.de>
 */
var forge = require('./forge');
require('./mgf1');

module.exports = forge.mgf = forge.mgf || {};
forge.mgf.mgf1 = forge.mgf1;

      };
    };
  }
}, {package:"node-forge",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\mgf.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-bitswap\\node_modules\\multihashing-async\\src\\utils.js", {"_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-bitswap\node_modules\multihashing-async\src\utils.js
      return function (require, module, exports) {
(function (process,Buffer){(function (){
'use strict'

exports.toCallback = (doWork) => {
  return function (input, callback) {
    let res
    try {
      res = doWork(input)
    } catch (err) {
      process.nextTick(callback, err)
      return
    }

    process.nextTick(callback, null, res)
  }
}

exports.toBuf = (doWork, other) => (input) => {
  let result = doWork(input, other)
  return Buffer.from(result, 'hex')
}

exports.fromString = (doWork, other) => (_input) => {
  const input = Buffer.isBuffer(_input) ? _input.toString() : _input
  return doWork(input, other)
}

exports.fromNumberTo32BitBuf = (doWork, other) => (input) => {
  let number = doWork(input, other)
  const bytes = new Array(4)

  for (let i = 0; i < 4; i++) {
    bytes[i] = number & 0xff
    number = number >> 8
  }

  return Buffer.from(bytes)
}

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-bitswap\\node_modules\\multihashing-async\\src\\utils.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-bitswap\\node_modules\\multihashing-async\\src\\blake.js", {"./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-bitswap\\node_modules\\multihashing-async\\src\\utils.js","blakejs":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\blakejs\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-bitswap\node_modules\multihashing-async\src\blake.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const blake = require('blakejs')

const toCallback = require('./utils').toCallback

const minB = 0xb201
const minS = 0xb241

const blake2b = {
  init: blake.blake2bInit,
  update: blake.blake2bUpdate,
  digest: blake.blake2bFinal
}

const blake2s = {
  init: blake.blake2sInit,
  update: blake.blake2sUpdate,
  digest: blake.blake2sFinal
}

const makeB2Hash = (size, hf) => toCallback((buf) => {
  const ctx = hf.init(size, null)
  hf.update(ctx, buf)
  return Buffer.from(hf.digest(ctx))
})

module.exports = (table) => {
  for (let i = 0; i < 64; i++) {
    table[minB + i] = makeB2Hash(i + 1, blake2b)
  }
  for (let i = 0; i < 32; i++) {
    table[minS + i] = makeB2Hash(i + 1, blake2s)
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-bitswap\\node_modules\\multihashing-async\\src\\blake.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-bitswap\\node_modules\\multihashing-async\\src\\crypto-sha1-2-browser.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","nodeify":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\nodeify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ipfs-bitswap\node_modules\multihashing-async\src\crypto-sha1-2-browser.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/* global self */

'use strict'

const nodeify = require('nodeify')

const webCrypto = getWebCrypto()

function getWebCrypto () {
  if (self.crypto) {
    return self.crypto.subtle || self.crypto.webkitSubtle
  }

  if (self.msCrypto) {
    return self.msCrypto.subtle
  }
}

function webCryptoHash (type) {
  if (!webCrypto) {
    throw new Error('Please use a browser with webcrypto support and ensure the code has been delivered securely via HTTPS/TLS and run within a Secure Context')
  }

  return (data, callback) => {
    const res = webCrypto.digest({ name: type }, data)

    if (typeof res.then !== 'function') { // IE11
      res.onerror = () => {
        callback(new Error(`hashing data using ${type}`))
      }
      res.oncomplete = (e) => {
        callback(null, e.target.result)
      }
      return
    }

    nodeify(
      res.then((raw) => Buffer.from(new Uint8Array(raw))),
      callback
    )
  }
}

function sha1 (buf, callback) {
  webCryptoHash('SHA-1')(buf, callback)
}

function sha2256 (buf, callback) {
  webCryptoHash('SHA-256')(buf, callback)
}

function sha2512 (buf, callback) {
  webCryptoHash('SHA-512')(buf, callback)
}

module.exports = {
  sha1: sha1,
  sha2256: sha2256,
  sha2512: sha2512
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ipfs-bitswap\\node_modules\\multihashing-async\\src\\crypto-sha1-2-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-reader\\state.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\pull-reader\state.js
      return function (require, module, exports) {
(function (Buffer){(function (){

module.exports = function () {

  var buffers = [], length = 0

  //just used for debugging...
  function calcLength () {
    return buffers.reduce(function (a, b) {
      return a + b.length
    }, 0)
  }

  return {
    length: length,
    data: this,
    add: function (data) {
      if(!Buffer.isBuffer(data))
        throw new Error('data must be a buffer, was: ' + JSON.stringify(data))
      this.length = length = length + data.length
      buffers.push(data)
      return this
    },
    has: function (n) {
      if(null == n) return length > 0
      return length >= n
    },
    get: function (n) {
      var _length
      if(n == null || n === length) {
        length = 0
        var _buffers = buffers
        buffers = []
        if(_buffers.length == 1)
          return _buffers[0]
        else
          return Buffer.concat(_buffers)
      } else if (buffers.length > 1 && n <= (_length = buffers[0].length)) {
        var buf = buffers[0].slice(0, n)
        if(n === _length) {
          buffers.shift()
        }
        else {
          buffers[0] = buffers[0].slice(n, _length)
        }
        length -= n
        return buf
      }  else if(n < length) {
        var out = [], len = 0

        while((len + buffers[0].length) < n) {
          var b = buffers.shift()
          len += b.length
          out.push(b)
        }

        if(len < n) {
          out.push(buffers[0].slice(0, n - len))
          buffers[0] = buffers[0].slice(n - len, buffers[0].length)
          this.length = length = length - n
        }
        return Buffer.concat(out)
      }
      else
        throw new Error('could not get ' + n + ' bytes')
    }
  }

}






}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"pull-reader",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-reader\\state.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-record\\node_modules\\multihashing-async\\src\\index.js", {"./crypto":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-record\\node_modules\\multihashing-async\\src\\crypto.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","multihashes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multihashes\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-record\node_modules\multihashing-async\src\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const multihash = require('multihashes')
const crypto = require('./crypto')

module.exports = Multihashing

/**
 * Hash the given `buf` using the algorithm specified
 * by `func`.
 *
 * @param {Buffer} buf - The value to hash.
 * @param {number|string} func - The algorithm to use.
 * @param {number} [length] - Optionally trim the result to this length.
 * @param {function(Error, Buffer)} callback
 * @returns {undefined}
 */
function Multihashing (buf, func, length, callback) {
  if (typeof length === 'function') {
    callback = length
    length = undefined
  }

  if (!callback) {
    throw new Error('Missing callback')
  }

  Multihashing.digest(buf, func, length, (err, digest) => {
    if (err) {
      return callback(err)
    }

    callback(null, multihash.encode(digest, func, length))
  })
}

/**
 * The `buffer` module for easy use in the browser.
 *
 * @type {Buffer}
 */
Multihashing.Buffer = Buffer // for browser things

/**
 * Expose multihash itself, to avoid silly double requires.
 */
Multihashing.multihash = multihash

/**
 * @param {Buffer} buf - The value to hash.
 * @param {number|string} func - The algorithm to use.
 * @param {number} [length] - Optionally trim the result to this length.
 * @param {function(Error, Buffer)} callback
 * @returns {undefined}
 */
Multihashing.digest = function (buf, func, length, callback) {
  if (typeof length === 'function') {
    callback = length
    length = undefined
  }

  if (!callback) {
    throw new Error('Missing callback')
  }

  let cb = callback
  if (length) {
    cb = (err, digest) => {
      if (err) {
        return callback(err)
      }

      callback(null, digest.slice(0, length))
    }
  }

  let hash
  try {
    hash = Multihashing.createHash(func)
  } catch (err) {
    return cb(err)
  }

  hash(buf, cb)
}

/**
 * @param {string|number} func
 *
 * @returns {function} - The to `func` corresponding hash function.
 */
Multihashing.createHash = function (func) {
  func = multihash.coerceCode(func)
  if (!Multihashing.functions[func]) {
    throw new Error('multihash function ' + func + ' not yet supported')
  }

  return Multihashing.functions[func]
}

/**
 * Mapping of multihash codes to their hashing functions.
 * @type {Object}
 */
Multihashing.functions = {
  // sha1
  0x11: crypto.sha1,
  // sha2-256
  0x12: crypto.sha2256,
  // sha2-512
  0x13: crypto.sha2512,
  // sha3-512
  0x14: crypto.sha3512,
  // sha3-384
  0x15: crypto.sha3384,
  // sha3-256
  0x16: crypto.sha3256,
  // sha3-224
  0x17: crypto.sha3224,
  // shake-128
  0x18: crypto.shake128,
  // shake-256
  0x19: crypto.shake256,
  // keccak-224
  0x1A: crypto.keccak224,
  // keccak-256
  0x1B: crypto.keccak256,
  // keccak-384
  0x1C: crypto.keccak384,
  // keccak-512
  0x1D: crypto.keccak512,
  // murmur3-128
  0x22: crypto.murmur3128,
  // murmur3-32
  0x23: crypto.murmur332,
  // dbl-sha2-256
  0x56: crypto.dblSha2256
}

// add blake functions
crypto.addBlake(Multihashing.functions)

Multihashing.validate = (data, hash, callback) => {
  let algo = multihash.decode(hash).name
  Multihashing(data, algo, (err, newHash) => {
    if (err) return callback(err)
    callback(err, Buffer.compare(hash, newHash) === 0)
  })
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-record\\node_modules\\multihashing-async\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-ws\\ready.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\pull-ws\ready.js
      return function (require, module, exports) {
module.exports = function(socket, callback) {
  var remove = socket && (socket.removeEventListener || socket.removeListener);

  function cleanup () {
    if (typeof remove == 'function') {
      remove.call(socket, 'open', handleOpen);
      remove.call(socket, 'error', handleErr);
    }
  }

  function handleOpen(evt) {
    cleanup(); callback();
  }

  function handleErr (evt) {
    cleanup(); callback(evt);
  }

  // if the socket is closing or closed, return end
  if (socket.readyState >= 2) {
    return callback(true);
  }

  // if open, trigger the callback
  if (socket.readyState === 1) {
    return callback();
  }

  socket.addEventListener('open', handleOpen);
  socket.addEventListener('error', handleErr);
};

      };
    };
  }
}, {package:"pull-ws",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-ws\\ready.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\node_modules\\multihashing-async\\src\\utils.js", {"_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-kad-dht\node_modules\multihashing-async\src\utils.js
      return function (require, module, exports) {
(function (process,Buffer){(function (){
'use strict'

exports.toCallback = (doWork) => {
  return function (input, callback) {
    let res
    try {
      res = doWork(input)
    } catch (err) {
      process.nextTick(callback, err)
      return
    }

    process.nextTick(callback, null, res)
  }
}

exports.toBuf = (doWork, other) => (input) => {
  let result = doWork(input, other)
  return Buffer.from(result, 'hex')
}

exports.fromString = (doWork, other) => (_input) => {
  const input = Buffer.isBuffer(_input) ? _input.toString() : _input
  return doWork(input, other)
}

exports.fromNumberTo32BitBuf = (doWork, other) => (input) => {
  let number = doWork(input, other)
  const bytes = new Array(4)

  for (let i = 0; i < 4; i++) {
    bytes[i] = number & 0xff
    number = number >> 8
  }

  return Buffer.from(bytes)
}

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\node_modules\\multihashing-async\\src\\utils.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\node_modules\\multihashing-async\\src\\blake.js", {"./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\node_modules\\multihashing-async\\src\\utils.js","blakejs":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\blakejs\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-kad-dht\node_modules\multihashing-async\src\blake.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const blake = require('blakejs')

const toCallback = require('./utils').toCallback

const minB = 0xb201
const minS = 0xb241

const blake2b = {
  init: blake.blake2bInit,
  update: blake.blake2bUpdate,
  digest: blake.blake2bFinal
}

const blake2s = {
  init: blake.blake2sInit,
  update: blake.blake2sUpdate,
  digest: blake.blake2sFinal
}

const makeB2Hash = (size, hf) => toCallback((buf) => {
  const ctx = hf.init(size, null)
  hf.update(ctx, buf)
  return Buffer.from(hf.digest(ctx))
})

module.exports = (table) => {
  for (let i = 0; i < 64; i++) {
    table[minB + i] = makeB2Hash(i + 1, blake2b)
  }
  for (let i = 0; i < 32; i++) {
    table[minS + i] = makeB2Hash(i + 1, blake2s)
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\node_modules\\multihashing-async\\src\\blake.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\node_modules\\multihashing-async\\src\\crypto-sha1-2-browser.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","nodeify":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\nodeify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-kad-dht\node_modules\multihashing-async\src\crypto-sha1-2-browser.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/* global self */

'use strict'

const nodeify = require('nodeify')

const webCrypto = getWebCrypto()

function getWebCrypto () {
  if (self.crypto) {
    return self.crypto.subtle || self.crypto.webkitSubtle
  }

  if (self.msCrypto) {
    return self.msCrypto.subtle
  }
}

function webCryptoHash (type) {
  if (!webCrypto) {
    throw new Error('Please use a browser with webcrypto support and ensure the code has been delivered securely via HTTPS/TLS and run within a Secure Context')
  }

  return (data, callback) => {
    const res = webCrypto.digest({ name: type }, data)

    if (typeof res.then !== 'function') { // IE11
      res.onerror = () => {
        callback(new Error(`hashing data using ${type}`))
      }
      res.oncomplete = (e) => {
        callback(null, e.target.result)
      }
      return
    }

    nodeify(
      res.then((raw) => Buffer.from(new Uint8Array(raw))),
      callback
    )
  }
}

function sha1 (buf, callback) {
  webCryptoHash('SHA-1')(buf, callback)
}

function sha2256 (buf, callback) {
  webCryptoHash('SHA-256')(buf, callback)
}

function sha2512 (buf, callback) {
  webCryptoHash('SHA-512')(buf, callback)
}

module.exports = {
  sha1: sha1,
  sha2256: sha2256,
  sha2512: sha2512
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\node_modules\\multihashing-async\\src\\crypto-sha1-2-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\peer-queue.js", {"./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\utils.js","debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debug\\src\\browser.js","heap":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\heap\\index.js","promisify-es6":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\promisify-es6\\index.js","xor-distance":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\xor-distance\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-kad-dht\src\peer-queue.js
      return function (require, module, exports) {
'use strict'

const Heap = require('heap')
const distance = require('xor-distance')
const debug = require('debug')
const promisify = require('promisify-es6')

const utils = require('./utils')

const log = debug('libp2p:dht:peer-queue')

/**
 * PeerQueue is a heap that sorts its entries (PeerIds) by their
 * xor distance to the inital provided key.
 */
class PeerQueue {
  /**
   * Create from a given peer id.
   *
   * @param {PeerId} id
   * @returns {Promise<PeerQueue>}
   */
  static async fromPeerId (id) {
    const key = await promisify(cb => utils.convertPeerId(id, cb))()
    return new PeerQueue(key)
  }

  /**
   * Create from a given buffer.
   *
   * @param {Buffer} keyBuffer
   * @returns {Promise<PeerQueue>}
   */
  static async fromKey (keyBuffer) {
    const key = await promisify(cb => utils.convertBuffer(keyBuffer, cb))()
    return new PeerQueue(key)
  }

  /**
   * Create a new PeerQueue.
   *
   * @param {Buffer} from - The sha2-256 encoded peer id
   */
  constructor (from) {
    log('create: %b', from)
    this.from = from
    this.heap = new Heap(utils.xorCompare)
  }

  /**
   * Add a new PeerId to the queue.
   *
   * @param {PeerId} id
   * @returns {Promise}
   */
  async enqueue (id) {
    log('enqueue %s', id.toB58String())
    const key = await promisify(cb => utils.convertPeerId(id, cb))()

    const el = {
      id: id,
      distance: distance(this.from, key)
    }

    this.heap.push(el)
  }

  /**
   * Returns the closest peer to the `from` peer.
   *
   * @returns {PeerId}
   */
  dequeue () {
    const el = this.heap.pop()
    log('dequeue %s', el.id.toB58String())
    return el.id
  }

  get length () {
    return this.heap.size()
  }
}

module.exports = PeerQueue

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\peer-queue.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\rpc\\handlers\\ping.js", {"../../utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-kad-dht\src\rpc\handlers\ping.js
      return function (require, module, exports) {
'use strict'

const utils = require('../../utils')

module.exports = (dht) => {
  const log = utils.logger(dht.peerInfo.id, 'rpc:ping')

  /**
   * Process `Ping` DHT messages.
   *
   * @param {PeerInfo} peer
   * @param {Message} msg
   * @param {function(Error, Message)} callback
   * @returns {undefined}
   */
  return function ping (peer, msg, callback) {
    log('from %s', peer.id.toB58String())
    callback(null, msg)
  }
}

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\rpc\\handlers\\ping.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\rpc\\handlers\\put-value.js", {"../../utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\utils.js","err-code":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\err-code\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-kad-dht\src\rpc\handlers\put-value.js
      return function (require, module, exports) {
'use strict'

const utils = require('../../utils')
const errcode = require('err-code')

module.exports = (dht) => {
  const log = utils.logger(dht.peerInfo.id, 'rpc:put-value')

  /**
   * Process `PutValue` DHT messages.
   *
   * @param {PeerInfo} peer
   * @param {Message} msg
   * @param {function(Error, Message)} callback
   * @returns {undefined}
   */
  return function putValue (peer, msg, callback) {
    const key = msg.key
    log('key: %b', key)

    const record = msg.record

    if (!record) {
      const errMsg = `Empty record from: ${peer.id.toB58String()}`

      log.error(errMsg)
      return callback(errcode(new Error(errMsg), 'ERR_EMPTY_RECORD'))
    }

    dht._verifyRecordLocally(record, (err) => {
      if (err) {
        log.error(err.message)
        return callback(err)
      }

      record.timeReceived = new Date()

      const key = utils.bufferToKey(record.key)

      dht.datastore.put(key, record.serialize(), (err) => {
        if (err) {
          return callback(err)
        }

        callback(null, msg)
      })
    })
  }
}

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\rpc\\handlers\\put-value.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\rpc\\handlers\\add-provider.js", {"../../utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\utils.js","cids":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\cids\\src\\index.js","err-code":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\err-code\\index.js","promise-to-callback":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\promise-to-callback\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-kad-dht\src\rpc\handlers\add-provider.js
      return function (require, module, exports) {
'use strict'

const CID = require('cids')
const errcode = require('err-code')
const promiseToCallback = require('promise-to-callback')

const utils = require('../../utils')

module.exports = (dht) => {
  const log = utils.logger(dht.peerInfo.id, 'rpc:add-provider')
  /**
   * Process `AddProvider` DHT messages.
   *
   * @param {PeerInfo} peer
   * @param {Message} msg
   * @param {function(Error)} callback
   * @returns {undefined}
   */
  return function addProvider (peer, msg, callback) {
    log('start')

    if (!msg.key || msg.key.length === 0) {
      return callback(errcode(new Error('Missing key'), 'ERR_MISSING_KEY'))
    }

    let cid
    try {
      cid = new CID(msg.key)
    } catch (err) {
      const errMsg = `Invalid CID: ${err.message}`

      return callback(errcode(new Error(errMsg), 'ERR_INVALID_CID'))
    }

    let foundProvider = false
    msg.providerPeers.forEach((pi) => {
      // Ignore providers not from the originator
      if (!pi.id.isEqual(peer.id)) {
        log('invalid provider peer %s from %s', pi.id.toB58String(), peer.id.toB58String())
        return
      }

      if (pi.multiaddrs.size < 1) {
        log('no valid addresses for provider %s. Ignore', peer.id.toB58String())
        return
      }

      log('received provider %s for %s (addrs %s)', peer.id.toB58String(), cid.toBaseEncodedString(), pi.multiaddrs.toArray().map((m) => m.toString()))

      if (!dht._isSelf(pi.id)) {
        foundProvider = true
        dht.peerBook.put(pi)
        promiseToCallback(dht.providers.addProvider(cid, pi.id))(err => callback(err))
      }
    })

    // Previous versions of the JS DHT sent erroneous providers in the
    // `providerPeers` field. In order to accommodate older clients that have
    // this bug, we fall back to assuming the originator is the provider if
    // we can't find any valid providers in the payload.
    // https://github.com/libp2p/js-libp2p-kad-dht/pull/127
    // https://github.com/libp2p/js-libp2p-kad-dht/issues/128
    if (!foundProvider) {
      promiseToCallback(dht.providers.addProvider(cid, peer.id))(err => callback(err))
    }
  }
}

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\rpc\\handlers\\add-provider.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\rpc\\handlers\\find-node.js", {"../../message":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\message\\index.js","../../utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\utils.js","async/waterfall":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\waterfall.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-kad-dht\src\rpc\handlers\find-node.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const waterfall = require('async/waterfall')

const Message = require('../../message')
const utils = require('../../utils')

module.exports = (dht) => {
  const log = utils.logger(dht.peerInfo.id, 'rpc:find-node')

  /**
   * Process `FindNode` DHT messages.
   *
   * @param {PeerInfo} peer
   * @param {Message} msg
   * @param {function(Error, Message)} callback
   * @returns {undefined}
   */
  return function findNode (peer, msg, callback) {
    log('start')

    waterfall([
      (cb) => {
        if (msg.key.equals(dht.peerInfo.id.id)) {
          return cb(null, [dht.peerInfo])
        }

        dht._betterPeersToQuery(msg, peer, cb)
      },
      (closer, cb) => {
        const response = new Message(msg.type, Buffer.alloc(0), msg.clusterLevel)

        if (closer.length > 0) {
          response.closerPeers = closer
        } else {
          log('handle FindNode %s: could not find anything', peer.id.toB58String())
        }

        cb(null, response)
      }
    ], callback)
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\rpc\\handlers\\find-node.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\rpc\\handlers\\get-providers.js", {"../../message":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\message\\index.js","../../utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\utils.js","async/parallel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\parallel.js","cids":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\cids\\src\\index.js","err-code":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\err-code\\index.js","peer-info":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-info\\src\\index.js","promise-to-callback":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\promise-to-callback\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-kad-dht\src\rpc\handlers\get-providers.js
      return function (require, module, exports) {
'use strict'

const CID = require('cids')
const parallel = require('async/parallel')
const PeerInfo = require('peer-info')
const promiseToCallback = require('promise-to-callback')
const errcode = require('err-code')

const Message = require('../../message')
const utils = require('../../utils')

module.exports = (dht) => {
  const log = utils.logger(dht.peerInfo.id, 'rpc:get-providers')

  /**
   * Process `GetProviders` DHT messages.
   *
   * @param {PeerInfo} peer
   * @param {Message} msg
   * @param {function(Error, Message)} callback
   * @returns {undefined}
   */
  return function getProviders (peer, msg, callback) {
    let cid
    try {
      cid = new CID(msg.key)
    } catch (err) {
      return callback(errcode(new Error(`Invalid CID: ${err.message}`), 'ERR_INVALID_CID'))
    }

    log('%s', cid.toBaseEncodedString())

    const dsKey = utils.bufferToKey(cid.buffer)

    parallel([
      (cb) => dht.datastore.has(dsKey, (err, exists) => {
        if (err) {
          log.error('Failed to check datastore existence', err)
          return cb(null, false)
        }

        cb(null, exists)
      }),
      (cb) => promiseToCallback(dht.providers.getProviders(cid))(cb),
      (cb) => dht._betterPeersToQuery(msg, peer, cb)
    ], (err, res) => {
      if (err) {
        return callback(err)
      }
      const has = res[0]
      const closer = res[2]
      const providers = res[1].map((p) => {
        if (dht.peerBook.has(p)) {
          return dht.peerBook.get(p)
        }

        return dht.peerBook.put(new PeerInfo(p))
      })

      if (has) {
        providers.push(dht.peerInfo)
      }

      const response = new Message(msg.type, msg.key, msg.clusterLevel)

      if (providers.length > 0) {
        response.providerPeers = providers
      }

      if (closer.length > 0) {
        response.closerPeers = closer
      }

      log('got %s providers %s closerPeers', providers.length, closer.length)

      callback(null, response)
    })
  }
}

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\rpc\\handlers\\get-providers.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\rpc\\handlers\\get-value.js", {"../../message":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\message\\index.js","../../utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\utils.js","async/parallel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\parallel.js","err-code":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\err-code\\index.js","libp2p-record":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-record\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-kad-dht\src\rpc\handlers\get-value.js
      return function (require, module, exports) {
'use strict'

const parallel = require('async/parallel')
const Record = require('libp2p-record').Record

const errcode = require('err-code')

const Message = require('../../message')
const utils = require('../../utils')

module.exports = (dht) => {
  const log = utils.logger(dht.peerInfo.id, 'rpc:get-value')

  /**
   * Process `GetValue` DHT messages.
   *
   * @param {PeerInfo} peer
   * @param {Message} msg
   * @param {function(Error, Message)} callback
   * @returns {undefined}
   */
  return function getValue (peer, msg, callback) {
    const key = msg.key

    log('key: %b', key)

    if (!key || key.length === 0) {
      return callback(errcode(new Error('Invalid key'), 'ERR_INVALID_KEY'))
    }

    const response = new Message(Message.TYPES.GET_VALUE, key, msg.clusterLevel)

    if (utils.isPublicKeyKey(key)) {
      log('is public key')
      const id = utils.fromPublicKeyKey(key)
      let info

      if (dht._isSelf(id)) {
        info = dht.peerInfo
      } else if (dht.peerBook.has(id)) {
        info = dht.peerBook.get(id)
      }

      if (info && info.id.pubKey) {
        log('returning found public key')
        response.record = new Record(key, info.id.pubKey.bytes)
        return callback(null, response)
      }
    }

    parallel([
      (cb) => dht._checkLocalDatastore(key, cb),
      (cb) => dht._betterPeersToQuery(msg, peer, cb)
    ], (err, res) => {
      if (err) {
        return callback(err)
      }

      const record = res[0]
      const closer = res[1]

      if (record) {
        log('got record')
        response.record = record
      }

      if (closer.length > 0) {
        log('got closer %s', closer.length)
        response.closerPeers = closer
      }

      callback(null, response)
    })
  }
}

      };
    };
  }
}, {package:"libp2p-kad-dht",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-kad-dht\\src\\rpc\\handlers\\get-value.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\data-queue\\index.js", {"events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\data-queue\index.js
      return function (require, module, exports) {
"use strict"

const EE = require("events").EventEmitter

function DataQueue() {
  const ee = new EE()
  let q = []
  let ed

  function unleak() {
    ee.removeAllListeners("err")
    ee.removeAllListeners("data")
  }

  return {
    append: data => {
      if (ed) return ed
      q.push(data)
      ee.emit("data")
    },
    prepend: data => { //better only call this before the get queue starts
      if (ed) return ed
      q.unshift(data)
    },
    error: e => {
      ed = e
      ee.emit("err", e)
    },
    get: cb => {
      unleak()
      if (ed) return cb(ed)
      if (q.length) return cb(null, q.shift())
      ee.once("err", e => {
        unleak()
        cb(e)
      })
      ee.once("data", () => {
        unleak()
        return cb(null, q.shift())
      })
    },
    height: () => q.length
  }
}
module.exports = DataQueue

      };
    };
  }
}, {package:"data-queue",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\data-queue\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-pull-stream\\node_modules\\uuid\\index.js", {"./v1":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-pull-stream\\node_modules\\uuid\\v1.js","./v4":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-pull-stream\\node_modules\\uuid\\v4.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\socket.io-pull-stream\node_modules\uuid\index.js
      return function (require, module, exports) {
var v1 = require('./v1');
var v4 = require('./v4');

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;

      };
    };
  }
}, {package:"uuid",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-pull-stream\\node_modules\\uuid\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-pull-stream\\node_modules\\debug\\src\\browser.js", {"./common":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-pull-stream\\node_modules\\debug\\src\\common.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\socket.io-pull-stream\node_modules\debug\src\browser.js
      return function (require, module, exports) {
(function (process){(function (){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */


function log() {
  var _console;

  // This hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {} // Swallow
  // XXX (@Qix-) should we be logging these?
  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = require('./common')(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};


}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"debug",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-pull-stream\\node_modules\\debug\\src\\browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-secio\\node_modules\\multihashing-async\\src\\index.js", {"./crypto":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-secio\\node_modules\\multihashing-async\\src\\crypto.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","multihashes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multihashes\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-secio\node_modules\multihashing-async\src\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const multihash = require('multihashes')
const crypto = require('./crypto')

module.exports = Multihashing

/**
 * Hash the given `buf` using the algorithm specified
 * by `func`.
 *
 * @param {Buffer} buf - The value to hash.
 * @param {number|string} func - The algorithm to use.
 * @param {number} [length] - Optionally trim the result to this length.
 * @param {function(Error, Buffer)} callback
 * @returns {undefined}
 */
function Multihashing (buf, func, length, callback) {
  if (typeof length === 'function') {
    callback = length
    length = undefined
  }

  if (!callback) {
    throw new Error('Missing callback')
  }

  Multihashing.digest(buf, func, length, (err, digest) => {
    if (err) {
      return callback(err)
    }

    callback(null, multihash.encode(digest, func, length))
  })
}

/**
 * The `buffer` module for easy use in the browser.
 *
 * @type {Buffer}
 */
Multihashing.Buffer = Buffer // for browser things

/**
 * Expose multihash itself, to avoid silly double requires.
 */
Multihashing.multihash = multihash

/**
 * @param {Buffer} buf - The value to hash.
 * @param {number|string} func - The algorithm to use.
 * @param {number} [length] - Optionally trim the result to this length.
 * @param {function(Error, Buffer)} callback
 * @returns {undefined}
 */
Multihashing.digest = function (buf, func, length, callback) {
  if (typeof length === 'function') {
    callback = length
    length = undefined
  }

  if (!callback) {
    throw new Error('Missing callback')
  }

  let cb = callback
  if (length) {
    cb = (err, digest) => {
      if (err) {
        return callback(err)
      }

      callback(null, digest.slice(0, length))
    }
  }

  let hash
  try {
    hash = Multihashing.createHash(func)
  } catch (err) {
    return cb(err)
  }

  hash(buf, cb)
}

/**
 * @param {string|number} func
 *
 * @returns {function} - The to `func` corresponding hash function.
 */
Multihashing.createHash = function (func) {
  func = multihash.coerceCode(func)
  if (!Multihashing.functions[func]) {
    throw new Error('multihash function ' + func + ' not yet supported')
  }

  return Multihashing.functions[func]
}

/**
 * Mapping of multihash codes to their hashing functions.
 * @type {Object}
 */
Multihashing.functions = {
  // sha1
  0x11: crypto.sha1,
  // sha2-256
  0x12: crypto.sha2256,
  // sha2-512
  0x13: crypto.sha2512,
  // sha3-512
  0x14: crypto.sha3512,
  // sha3-384
  0x15: crypto.sha3384,
  // sha3-256
  0x16: crypto.sha3256,
  // sha3-224
  0x17: crypto.sha3224,
  // shake-128
  0x18: crypto.shake128,
  // shake-256
  0x19: crypto.shake256,
  // keccak-224
  0x1A: crypto.keccak224,
  // keccak-256
  0x1B: crypto.keccak256,
  // keccak-384
  0x1C: crypto.keccak384,
  // keccak-512
  0x1D: crypto.keccak512,
  // murmur3-128
  0x22: crypto.murmur3128,
  // murmur3-32
  0x23: crypto.murmur332,
  // dbl-sha2-256
  0x56: crypto.dblSha2256
}

// add blake functions
crypto.addBlake(Multihashing.functions)

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-secio\\node_modules\\multihashing-async\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-secio\\src\\handshake\\secio.proto.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-secio\src\handshake\secio.proto.js
      return function (require, module, exports) {
'use strict'

module.exports = `message Propose {
  optional bytes rand = 1;
  optional bytes pubkey = 2;
  optional string exchanges = 3;
  optional string ciphers = 4;
  optional string hashes = 5;
}

message Exchange {
  optional bytes epubkey = 1;
  optional bytes signature = 2;
}`

      };
    };
  }
}, {package:"libp2p-secio",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-secio\\src\\handshake\\secio.proto.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\errors-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\simple-peer\node_modules\readable-stream\errors-browser.js
      return function (require, module, exports) {
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\errors-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\destroy.js", {"_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\simple-peer\node_modules\readable-stream\lib\internal\streams\destroy.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\destroy.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\stream-browser.js", {"events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\simple-peer\node_modules\readable-stream\lib\internal\streams\stream-browser.js
      return function (require, module, exports) {
module.exports = require('events').EventEmitter;

      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\stream-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\state.js", {"../../../errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\errors-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\simple-peer\node_modules\readable-stream\lib\internal\streams\state.js
      return function (require, module, exports) {
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};
      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\state.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\from-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\simple-peer\node_modules\readable-stream\lib\internal\streams\from-browser.js
      return function (require, module, exports) {
module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};

      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\from-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\buffer_list.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\simple-peer\node_modules\readable-stream\lib\internal\streams\buffer_list.js
      return function (require, module, exports) {
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();
      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\buffer_list.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\async_iterator.js", {"./end-of-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\end-of-stream.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\simple-peer\node_modules\readable-stream\lib\internal\streams\async_iterator.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\simple-peer\\node_modules\\readable-stream\\lib\\internal\\streams\\async_iterator.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\has-binary2\\node_modules\\isarray\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\has-binary2\node_modules\isarray\index.js
      return function (require, module, exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

      };
    };
  }
}, {package:"isarray",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\has-binary2\\node_modules\\isarray\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-client\\node_modules\\ms\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\socket.io-client\node_modules\ms\index.js
      return function (require, module, exports) {
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

      };
    };
  }
}, {package:"ms",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-client\\node_modules\\ms\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-parser\\node_modules\\debug\\src\\debug.js", {"ms":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-parser\\node_modules\\ms\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\socket.io-parser\node_modules\debug\src\debug.js
      return function (require, module, exports) {

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

      };
    };
  }
}, {package:"debug",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-parser\\node_modules\\debug\\src\\debug.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-parser\\lib\\browser.js", {"./keys":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-parser\\lib\\keys.js","./utf8":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-parser\\lib\\utf8.js","after":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\after\\index.js","arraybuffer.slice":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\arraybuffer.slice\\index.js","base64-arraybuffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\base64-arraybuffer\\lib\\base64-arraybuffer.js","blob":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\blob\\index.js","has-binary2":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\has-binary2\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\engine.io-parser\lib\browser.js
      return function (require, module, exports) {
/**
 * Module dependencies.
 */

var keys = require('./keys');
var hasBinary = require('has-binary2');
var sliceBuffer = require('arraybuffer.slice');
var after = require('after');
var utf8 = require('./utf8');

var base64encoder;
if (typeof ArrayBuffer !== 'undefined') {
  base64encoder = require('base64-arraybuffer');
}

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = require('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if (typeof utf8encode === 'function') {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (typeof Blob !== 'undefined' && data instanceof Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    exports.encodePacket({ type: packet.type, data: fr.result }, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (typeof Blob !== 'undefined' && packet.data instanceof Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  if (data === undefined) {
    return err;
  }
  // String data
  if (typeof data === 'string') {
    if (data.charAt(0) === 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      data = tryDecode(data);
      if (data === false) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

function tryDecode(data) {
  try {
    data = utf8.decode(data, { strict: false });
  } catch (e) {
    return false;
  }
  return data;
}

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!base64encoder) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data !== 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data === '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = '', n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (chr !== ':') {
      length += chr;
      continue;
    }

    if (length === '' || (length != (n = Number(length)))) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    msg = data.substr(i + 1, n);

    if (length != msg.length) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    if (msg.length) {
      packet = exports.decodePacket(msg, binaryType, false);

      if (err.type === packet.type && err.data === packet.data) {
        // parser error in individual packet - ignoring payload
        return callback(err, 0, 1);
      }

      var ret = callback(packet, i + n, l);
      if (false === ret) return;
    }

    // advance cursor
    i += n;
    length = '';
  }

  if (length !== '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] === 255) break;

      // 310 = char length of Number.MAX_VALUE
      if (msgLength.length > 310) {
        return callback(err, 0, 1);
      }

      msgLength += tailArray[i];
    }

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

      };
    };
  }
}, {package:"engine.io-parser",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-parser\\lib\\browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\socket.js", {"./transport":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\transport.js","./transports/index":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\transports\\index.js","component-emitter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\component-emitter\\index.js","debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\node_modules\\debug\\src\\browser.js","engine.io-parser":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-parser\\lib\\browser.js","indexof":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\indexof\\index.js","parseqs":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\parseqs\\index.js","parseuri":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\parseuri\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\engine.io-client\lib\socket.js
      return function (require, module, exports) {
/**
 * Module dependencies.
 */

var transports = require('./transports/index');
var Emitter = require('component-emitter');
var debug = require('debug')('engine.io-client:socket');
var index = require('indexof');
var parser = require('engine.io-parser');
var parseuri = require('parseuri');
var parseqs = require('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket (uri, opts) {
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' === typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure
    : (typeof location !== 'undefined' && 'https:' === location.protocol);

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (typeof location !== 'undefined' ? location.hostname : 'localhost');
  this.port = opts.port || (typeof location !== 'undefined' && location.port
      ? location.port
      : (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.withCredentials = false !== opts.withCredentials;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.transportOptions = opts.transportOptions || {};
  this.readyState = '';
  this.writeBuffer = [];
  this.prevBufferLen = 0;
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  }

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
  this.forceNode = !!opts.forceNode;

  // detect ReactNative environment
  this.isReactNative = (typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative');

  // other options for Node.js or ReactNative client
  if (typeof self === 'undefined' || this.isReactNative) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }

    if (opts.localAddress) {
      this.localAddress = opts.localAddress;
    }
  }

  // set on handshake
  this.id = null;
  this.upgrades = null;
  this.pingInterval = null;
  this.pingTimeout = null;

  // set on heartbeat
  this.pingIntervalTimer = null;
  this.pingTimeoutTimer = null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = require('./transport');
Socket.transports = require('./transports/index');
Socket.parser = require('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // per-transport options
  var options = this.transportOptions[name] || {};

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    query: query,
    socket: this,
    agent: options.agent || this.agent,
    hostname: options.hostname || this.hostname,
    port: options.port || this.port,
    secure: options.secure || this.secure,
    path: options.path || this.path,
    forceJSONP: options.forceJSONP || this.forceJSONP,
    jsonp: options.jsonp || this.jsonp,
    forceBase64: options.forceBase64 || this.forceBase64,
    enablesXDR: options.enablesXDR || this.enablesXDR,
    withCredentials: options.withCredentials || this.withCredentials,
    timestampRequests: options.timestampRequests || this.timestampRequests,
    timestampParam: options.timestampParam || this.timestampParam,
    policyPort: options.policyPort || this.policyPort,
    pfx: options.pfx || this.pfx,
    key: options.key || this.key,
    passphrase: options.passphrase || this.passphrase,
    cert: options.cert || this.cert,
    ca: options.ca || this.ca,
    ciphers: options.ciphers || this.ciphers,
    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
    extraHeaders: options.extraHeaders || this.extraHeaders,
    forceNode: options.forceNode || this.forceNode,
    localAddress: options.localAddress || this.localAddress,
    requestTimeout: options.requestTimeout || this.requestTimeout,
    protocols: options.protocols || void (0),
    isReactNative: this.isReactNative
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
    transport = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function () {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function (transport) {
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function () {
    self.onDrain();
  })
  .on('packet', function (packet) {
    self.onPacket(packet);
  })
  .on('error', function (e) {
    self.onError(e);
  })
  .on('close', function () {
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 });
  var failed = false;
  var self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen () {
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' === msg.type && 'probe' === msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' === transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' === self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport () {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  // Handle any error that happens while probing
  function onerror (err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose () {
    onerror('transport closed');
  }

  // When the socket is closed while we're probing
  function onclose () {
    onerror('socket closed');
  }

  // When the socket is upgraded while we're probing
  function onupgrade (to) {
    if (transport && to.name !== transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  // Remove all listeners on the transport and on self
  function cleanup () {
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();
};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' === this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' === this.readyState || 'open' === this.readyState ||
      'closing' === this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(JSON.parse(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if ('closed' === this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' === self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api private
*/

Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function () {
    self.emit('ping');
  });
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function () {
  this.writeBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' !== this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, options, fn) {
  if ('function' === typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' === typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' === this.readyState || 'closed' === this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;

  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.readyState = 'closing';

    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function () {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close () {
    self.onClose('forced close');
    debug('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose () {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade () {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);

    // clean buffers after, so users can still
    // grab the buffers on `close` event
    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i < j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

      };
    };
  }
}, {package:"engine.io-client",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\socket.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-pubsub\\src\\message\\sign.js", {"./index":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-pubsub\\src\\message\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-pubsub\src\message\sign.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const { Message } = require('./index')
const SignPrefix = Buffer.from('libp2p-pubsub:')

module.exports.SignPrefix = SignPrefix

/**
 * Signs the provided message with the given `peerId`
 *
 * @param {PeerId} peerId
 * @param {Message} message
 * @param {function(Error, Message)} callback
 * @returns {void}
 */
module.exports.signMessage = function (peerId, message, callback) {
  // Get the message in bytes, and prepend with the pubsub prefix
  const bytes = Buffer.concat([
    SignPrefix,
    Message.encode(message)
  ])

  // Sign the bytes with the private key
  peerId.privKey.sign(bytes, (err, signature) => {
    if (err) return callback(err)

    callback(null, {
      ...message,
      signature: signature,
      key: peerId.pubKey.bytes
    })
  })
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"libp2p-pubsub",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-pubsub\\src\\message\\sign.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-pubsub\\src\\utils.js", {"../../is-buffer/index.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-buffer\\index.js","bs58":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bs58\\index.js","libp2p-crypto":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-crypto\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-pubsub\src\utils.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const crypto = require('libp2p-crypto')
const bs58 = require('bs58')

exports = module.exports

/**
 * Generatea random sequence number.
 *
 * @returns {Buffer}
 * @private
 */
exports.randomSeqno = () => {
  return crypto.randomBytes(20)
}

/**
 * Generate a message id, based on the `from` and `seqno`.
 *
 * @param {string} from
 * @param {Buffer} seqno
 * @returns {string}
 * @private
 */
exports.msgId = (from, seqno) => {
  return from + seqno.toString('hex')
}

/**
 * Check if any member of the first set is also a member
 * of the second set.
 *
 * @param {Set|Array} a
 * @param {Set|Array} b
 * @returns {boolean}
 * @private
 */
exports.anyMatch = (a, b) => {
  let bHas
  if (Array.isArray(b)) {
    bHas = (val) => b.indexOf(val) > -1
  } else {
    bHas = (val) => b.has(val)
  }

  for (let val of a) {
    if (bHas(val)) {
      return true
    }
  }

  return false
}

/**
 * Make everything an array.
 *
 * @param {any} maybeArray
 * @returns {Array}
 * @private
 */
exports.ensureArray = (maybeArray) => {
  if (!Array.isArray(maybeArray)) {
    return [maybeArray]
  }

  return maybeArray
}

exports.normalizeInRpcMessages = (messages) => {
  if (!messages) {
    return messages
  }
  return messages.map((msg) => {
    const m = Object.assign({}, msg)
    if (Buffer.isBuffer(msg.from)) {
      m.from = bs58.encode(msg.from)
    }
    return m
  })
}

exports.normalizeOutRpcMessage = (message) => {
  const m = Object.assign({}, message)
  if (typeof message.from === 'string' || message.from instanceof String) {
    m.from = bs58.decode(message.from)
  }
  return m
}

exports.normalizeOutRpcMessages = (messages) => {
  if (!messages) {
    return messages
  }
  return messages.map(exports.normalizeOutRpcMessage)
}

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

      };
    };
  }
}, {package:"libp2p-pubsub",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-pubsub\\src\\utils.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-pubsub\\src\\peer.js", {"./message":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-pubsub\\src\\message\\index.js","async/setImmediate":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\setImmediate.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","pull-length-prefixed":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-length-prefixed\\src\\index.js","pull-pushable":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-pushable\\index.js","pull-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-pubsub\src\peer.js
      return function (require, module, exports) {
'use strict'

const lp = require('pull-length-prefixed')
const Pushable = require('pull-pushable')
const pull = require('pull-stream')
const setImmediate = require('async/setImmediate')
const EventEmitter = require('events')

const { RPC } = require('./message')

/**
 * The known state of a connected peer.
 */
class Peer extends EventEmitter {
  /**
   * @param {PeerInfo} info
   */
  constructor (info) {
    super()

    /**
     * @type {PeerInfo}
     */
    this.info = info
    /**
     * @type {Connection}
     */
    this.conn = null
    /**
     * @type {Set}
     */
    this.topics = new Set()
    /**
     * @type {Pushable}
     */
    this.stream = null

    this._references = 0
  }

  /**
   * Is the peer connected currently?
   *
   * @type {boolean}
   */
  get isConnected () {
    return Boolean(this.conn)
  }

  /**
   * Do we have a connection to write on?
   *
   * @type {boolean}
   */
  get isWritable () {
    return Boolean(this.stream)
  }

  /**
   * Send a message to this peer.
   * Throws if there is no `stream` to write to available.
   *
   * @param {Buffer} msg
   * @returns {undefined}
   */
  write (msg) {
    if (!this.isWritable) {
      const id = this.info.id.toB58String()
      throw new Error('No writable connection to ' + id)
    }

    this.stream.push(msg)
  }

  /**
   * Attach the peer to a connection and setup a write stream
   *
   * @param {Connection} conn
   * @returns {undefined}
   */
  attachConnection (conn) {
    this.conn = conn
    this.stream = new Pushable()

    pull(
      this.stream,
      lp.encode(),
      conn,
      pull.onEnd(() => {
        this.conn = null
        this.stream = null
        this.emit('close')
      })
    )

    this.emit('connection')
  }

  _sendRawSubscriptions (topics, subscribe) {
    if (topics.size === 0) {
      return
    }

    const subs = []
    topics.forEach((topic) => {
      subs.push({
        subscribe: subscribe,
        topicID: topic
      })
    })

    this.write(RPC.encode({
      subscriptions: subs
    }))
  }

  /**
   * Send the given subscriptions to this peer.
   * @param {Set|Array} topics
   * @returns {undefined}
   */
  sendSubscriptions (topics) {
    this._sendRawSubscriptions(topics, true)
  }

  /**
   * Send the given unsubscriptions to this peer.
   * @param {Set|Array} topics
   * @returns {undefined}
   */
  sendUnsubscriptions (topics) {
    this._sendRawSubscriptions(topics, false)
  }

  /**
   * Send messages to this peer.
   *
   * @param {Array<any>} msgs
   * @returns {undefined}
   */
  sendMessages (msgs) {
    this.write(RPC.encode({
      msgs: msgs
    }))
  }

  /**
   * Bulk process subscription updates.
   *
   * @param {Array} changes
   * @returns {undefined}
   */
  updateSubscriptions (changes) {
    changes.forEach((subopt) => {
      if (subopt.subscribe) {
        this.topics.add(subopt.topicID)
      } else {
        this.topics.delete(subopt.topicID)
      }
    })
  }

  /**
   * Closes the open connection to peer
   *
   * @param {Function} callback
   * @returns {undefined}
   */
  close (callback) {
    // Force removal of peer
    this._references = 1

    // End the pushable
    if (this.stream) {
      this.stream.end()
    }

    setImmediate(() => {
      this.conn = null
      this.stream = null
      this.emit('close')
      callback()
    })
  }
}

module.exports = Peer

      };
    };
  }
}, {package:"libp2p-pubsub",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-pubsub\\src\\peer.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-pubsub\\src\\message\\index.js", {"./rpc.proto.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-pubsub\\src\\message\\rpc.proto.js","./topic-descriptor.proto.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-pubsub\\src\\message\\topic-descriptor.proto.js","protons":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\protons\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-pubsub\src\message\index.js
      return function (require, module, exports) {
'use strict'

const protons = require('protons')

const rpcProto = protons(require('./rpc.proto.js'))
const RPC = rpcProto.RPC
const topicDescriptorProto = protons(require('./topic-descriptor.proto.js'))

exports = module.exports
exports.rpc = rpcProto
exports.td = topicDescriptorProto
exports.RPC = RPC
exports.Message = RPC.Message
exports.SubOpts = RPC.SubOpts

      };
    };
  }
}, {package:"libp2p-pubsub",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-pubsub\\src\\message\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\time-cache\\src\\index.js", {"lodash.throttle":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash.throttle\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\time-cache\src\index.js
      return function (require, module, exports) {
'use strict'

const throttle = require('lodash.throttle')
exports = module.exports = TimeCache

function TimeCache (options) {
  if (!(this instanceof TimeCache)) {
    return new TimeCache(options)
  }

  options = options || {}

  const validity = options.validity || 30 // seconds

  const entries = new Map()

  const sweep = throttle(() => {
    entries.forEach((entry, key) => {
      const v = entry.validity || validity
      const delta = getTimeElapsed(entry.timestamp)
      if (delta > v) {
        entries.delete(key)
      }
    })
  }, 200)

  this.put = (key, value, validity) => {
    if (!this.has(key)) {
      entries.set(key, {
        value: value,
        timestamp: new Date(),
        validity: validity
      })
    }

    sweep()
  }

  this.get = (key) => {
    if (entries.has(key)) {
      return entries.get(key).value
    } else {
      throw new Error('key does not exist')
    }
  }

  this.has = (key) => {
    return entries.has(key)
  }
}

function getTimeElapsed (prevTime) {
  const currentTime = new Date()
  const a = currentTime.getTime() - prevTime.getTime()

  return Math.floor(a / 1000)
}

      };
    };
  }
}, {package:"time-cache",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\time-cache\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\latency-monitor\\dist\\VisibilityChangeEmitter.js", {"debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\latency-monitor\\node_modules\\debug\\src\\browser.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\latency-monitor\dist\VisibilityChangeEmitter.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* global document */

var debug = require('debug')('latency-monitor:VisibilityChangeEmitter');

/**
 * Listen to page visibility change events (i.e. when the page is focused / blurred) by an event emitter.
 *
 * Warning: This does not work on all browsers, but should work on all modern browsers
 *
 * @example
 *
 *     const myVisibilityEmitter = new VisibilityChangeEmitter();
 *
 *     myVisibilityEmitter.on('visibilityChange', (pageInFocus) => {
 *        if ( pageInFocus ){
 *            // Page is in focus
 *            console.log('In focus');
 *        }
 *        else {
 *            // Page is blurred
 *            console.log('Out of focus');
 *        }
 *     });
 *     // To access the visibility state directly, call:
 *     console.log('Am I focused now? ' + myVisibilityEmitter.isVisible());
 *
 * @class VisibilityChangeEmitter
 */

var VisibilityChangeEmitter = function (_EventEmitter) {
    _inherits(VisibilityChangeEmitter, _EventEmitter);

    /**
     * Creates a VisibilityChangeEmitter
     */
    function VisibilityChangeEmitter() {
        _classCallCheck(this, VisibilityChangeEmitter);

        var _this = _possibleConstructorReturn(this, (VisibilityChangeEmitter.__proto__ || Object.getPrototypeOf(VisibilityChangeEmitter)).call(this));

        if (typeof document === 'undefined') {
            debug('This is not a browser, no "document" found. Stopping.');
            return _possibleConstructorReturn(_this);
        }
        _this._initializeVisibilityVarNames();
        _this._addVisibilityChangeListener();
        return _this;
    }

    /**
     * document.hidden and document.visibilityChange are the two variables we need to check for;
     * Since these variables are named differently in different browsers, this function sets
     * the appropriate name based on the browser being used. Once executed, tha actual names of
     * document.hidden and document.visibilityChange are found in this._hidden and this._visibilityChange
     * respectively
     * @private
     */


    _createClass(VisibilityChangeEmitter, [{
        key: '_initializeVisibilityVarNames',
        value: function _initializeVisibilityVarNames() {
            var hidden = void 0;
            var visibilityChange = void 0;
            if (typeof document.hidden !== 'undefined') {
                // Opera 12.10 and Firefox 18 and later support
                hidden = 'hidden';
                visibilityChange = 'visibilitychange';
            } else if (typeof document.mozHidden !== 'undefined') {
                hidden = 'mozHidden';
                visibilityChange = 'mozvisibilitychange';
            } else if (typeof document.msHidden !== 'undefined') {
                hidden = 'msHidden';
                visibilityChange = 'msvisibilitychange';
            } else if (typeof document.webkitHidden !== 'undefined') {
                hidden = 'webkitHidden';
                visibilityChange = 'webkitvisibilitychange';
            }
            this._hidden = hidden;
            this._visibilityChange = visibilityChange;
        }

        /**
         * Adds an event listener on the document that listens to changes in document.visibilityChange
         * (or whatever name by which the visibilityChange variable is known in the browser)
         * @private
         */

    }, {
        key: '_addVisibilityChangeListener',
        value: function _addVisibilityChangeListener() {
            if (typeof document.addEventListener === 'undefined' || typeof document[this._hidden] === 'undefined') {
                debug('Checking page visibility requires a browser that supports the Page Visibility API.');
            } else {
                // Handle page visibility change
                document.addEventListener(this._visibilityChange, this._handleVisibilityChange.bind(this), false);
            }
        }

        /**
         * The function returns ```true``` if the page is visible or ```false``` if the page is not visible and
         * ```undefined``` if the page visibility API is not supported by the browser.
         * @returns {Boolean|void} whether the page is now visible or not (undefined is unknown)
         */

    }, {
        key: 'isVisible',
        value: function isVisible() {
            if (this._hidden === undefined || document[this._hidden] === undefined) {
                return undefined;
            }

            return !document[this._hidden];
        }

        /**
         * The function that is called when document.visibilityChange has changed
         * It emits an event called visibilityChange and sends the value of document.hidden as a
         * parameter
         *
         * @private
         */

    }, {
        key: '_handleVisibilityChange',
        value: function _handleVisibilityChange() {
            var visible = !document[this._hidden];
            debug(visible ? 'Page Visible' : 'Page Hidden');
            // Emit the event
            this.emit('visibilityChange', visible);
        }
    }]);

    return VisibilityChangeEmitter;
}(_events2.default);

exports.default = VisibilityChangeEmitter;
//# sourceMappingURL=VisibilityChangeEmitter.js.map

      };
    };
  }
}, {package:"latency-monitor",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\latency-monitor\\dist\\VisibilityChangeEmitter.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\latency-monitor\\node_modules\\debug\\src\\browser.js", {"./debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\latency-monitor\\node_modules\\debug\\src\\debug.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\latency-monitor\node_modules\debug\src\browser.js
      return function (require, module, exports) {
(function (process){(function (){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"debug",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\latency-monitor\\node_modules\\debug\\src\\browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\connection\\base.js", {"class-is":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\class-is\\index.js","debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debug\\src\\browser.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-switch\src\connection\base.js
      return function (require, module, exports) {
'use strict'

const EventEmitter = require('events').EventEmitter
const debug = require('debug')
const withIs = require('class-is')

class BaseConnection extends EventEmitter {
  constructor ({ _switch, name }) {
    super()

    this.switch = _switch
    this.ourPeerInfo = this.switch._peerInfo
    this.log = debug(`libp2p:conn:${name}`)
    this.log.error = debug(`libp2p:conn:${name}:error`)
  }

  /**
   * Puts the state into its disconnecting flow
   *
   * @param {Error} err Will be emitted if provided
   * @returns {void}
   */
  close (err) {
    if (this._state._state === 'DISCONNECTING') return
    this.log('closing connection to %s', this.theirB58Id)
    if (err && this._events.error) {
      this.emit('error', err)
    }
    this._state('disconnect')
  }

  emit (eventName, ...args) {
    if (eventName === 'error' && !this._events.error) {
      this.log.error(...args)
    } else {
      super.emit(eventName, ...args)
    }
  }

  /**
   * Gets the current state of the connection
   *
   * @returns {string} The current state of the connection
   */
  getState () {
    return this._state._state
  }

  /**
   * Puts the state into encrypting mode
   *
   * @returns {void}
   */
  encrypt () {
    this._state('encrypt')
  }

  /**
   * Puts the state into privatizing mode
   *
   * @returns {void}
   */
  protect () {
    this._state('privatize')
  }

  /**
   * Puts the state into muxing mode
   *
   * @returns {void}
   */
  upgrade () {
    this._state('upgrade')
  }

  /**
   * Event handler for disconnected.
   *
   * @fires BaseConnection#close
   * @returns {void}
   */
  _onDisconnected () {
    this.switch.connection.remove(this)
    this.log('disconnected from %s', this.theirB58Id)
    this.emit('close')
    this.removeAllListeners()
  }

  /**
   * Event handler for privatized
   *
   * @fires BaseConnection#private
   * @returns {void}
   */
  _onPrivatized () {
    this.emit('private', this.conn)
  }

  /**
   * Wraps this.conn with the Switch.protector for private connections
   *
   * @private
   * @fires ConnectionFSM#error
   * @returns {void}
   */
  _onPrivatizing () {
    if (!this.switch.protector) {
      return this._state('done')
    }

    this.conn = this.switch.protector.protect(this.conn, (err) => {
      if (err) {
        return this.close(err)
      }

      this.log('successfully privatized conn to %s', this.theirB58Id)
      this.conn.setPeerInfo(this.theirPeerInfo)
      this._state('done')
    })
  }
}

module.exports = withIs(BaseConnection, {
  className: 'BaseConnection',
  symbolName: 'libp2p-switch/BaseConnection'
})

      };
    };
  }
}, {package:"libp2p-switch",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\connection\\base.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\node_modules\\bignumber.js\\bignumber.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-switch\node_modules\bignumber.js\bignumber.js
      return function (require, module, exports) {
;(function (globalObject) {
  'use strict';

/*
 *      bignumber.js v8.1.1
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2019 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


  var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    hasSymbol = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol',

    mathceil = Math.ceil,
    mathfloor = Math.floor,

    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,

    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9;                                   // 0 to MAX_INT32


  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div, convertBase, parseNumeric,
      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
      ONE = new BigNumber(1),


      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,                     // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,                       // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,                         // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,                         // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,                          // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,                           // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,                          // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,                         // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,                    // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',      // non-breaking space
        suffix: ''
      },

      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';


    //------------------------------------------------------------------------------------------


    // CONSTRUCTOR


    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str,
        x = this;

      // Enable constructor call without `new`.
      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

      if (b == null) {

        if (v && v._isBigNumber === true) {
          x.s = v.s;

          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }

          return;
        }

        if ((isNum = typeof v == 'number') && v * 0 == 0) {

          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

          // Fast path for integers, where n < 2147483648 (2**31).
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++);

            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }

            return;
          }

          str = String(v);
        } else {

          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {

          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {

          // Integer.
          e = str.length;
        }

      } else {

        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }

        str = String(v);

        if (isNum = typeof v == 'number') {

          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error
             (tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }

        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {

              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {

              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                  str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }

            return parseNumeric(x, String(v), isNum, b);
          }
        }

        // Prevent later check for length on converted number.
        isNum = false;
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
        else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);

      if (str = str.slice(i, ++len)) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG &&
          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error
             (tooManyDigits + (x.s * v));
        }

         // Overflow?
        if ((e = e - i - 1) > MAX_EXP) {

          // Infinity.
          x.c = x.e = null;

        // Underflow?
        } else if (e < MIN_EXP) {

          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;  // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }

            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {

        // Zero.
        x.c = [x.e = 0];
      }
    }


    // CONSTRUCTOR PROPERTIES


    BigNumber.clone = clone;

    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;


    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;

      if (obj != null) {

        if (typeof obj == 'object') {

          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error
                 (bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto &&
                 (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error
                   (bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error
               (bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;
            else throw Error
             (bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if only one character,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.$|[+-.\s]|(.).*\1/.test(v)) {
              ALPHABET = v;
            } else {
              throw Error
               (bignumberError + p + ' invalid: ' + v);
            }
          }

        } else {

          // '[BigNumber Error] Object expected: {v}'
          throw Error
           (bignumberError + 'Object expected: ' + obj);
        }
      }

      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };


    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */
    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;

      var i, n,
        c = v.c,
        e = v.e,
        s = v.s;

      out: if ({}.toString.call(c) == '[object Array]') {

        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }

          // Calculate number of digits that c[0] should have, based on the exponent.
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;

          // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
          if (String(c[0]).length == i) {

            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }

            // Last element cannot be zero, unless it is the only element.
            if (n !== 0) return true;
          }
        }

      // Infinity/NaN
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }

      throw Error
        (bignumberError + 'Invalid BigNumber: ' + v);
    };


    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, P.lt);
    };


    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, P.gt);
    };


    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = (function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
       ? function () { return mathfloor(Math.random() * pow2_53); }
       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
         (Math.random() * 0x800000 | 0); };

      return function (dp) {
        var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);

        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);

        k = mathceil(dp / LOG_BASE);

        if (CRYPTO) {

          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {

            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {

                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

          // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes(k *= 7);

            for (; i < k;) {

              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {

                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error
             (bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {

          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }

        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {

          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }

        rand.e = e;
        rand.c = c;
        return rand;
      };
    })();


    /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };


    // PRIVATE FUNCTIONS


    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = (function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
           10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
         ? (alphabet = ALPHABET, decimal)
         : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // THe index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;

        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {

          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {

          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    })();


    // Perform division in the specified base. Called by div and convertBase.
    div = (function () {

      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m, temp, xlo, xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }

        if (carry) x = [carry].concat(x);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, cmp;

        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {

          for (i = cmp = 0; i < aL; i++) {

            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return cmp;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
          yL, yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {

          return new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         );
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);

        if (yc[i] > (xc[i] || 0)) e--;

        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {

                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {

                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {

                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }

              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

               // If product was < remainder.
              if (cmp == -1) {

                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);

          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }

        if (base == BASE) {

          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

        // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }

        return q;
      };
    })();


    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;

      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      if (!n.c) return n.toString();

      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
         ? toExponential(str, ne)
         : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;

        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

        // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }

      return n.s < 0 && c0 ? '-' + str : str;
    }


    // Handle BigNumber.max and BigNumber.min.
    function maxOrMin(args, method) {
      var n,
        i = 1,
        m = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        n = new BigNumber(args[i]);

        // If any number is NaN, return NaN.
        if (!n.s) {
          m = n;
          break;
        } else if (method.call(m, n)) {
          m = n;
        }
      }

      return m;
    }


    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

       // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

        // Infinity.
        n.c = n.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }

      return n;
    }


    // Handle values that fail the validity test in BigNumber.
    parseNumeric = (function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on ±Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {

            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }

            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error
              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.s = null;
        }

        x.c = x.e = null;
      }
    })();


    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {

        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {

          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE);

            if (ni >= xc.length) {

              if (r) {

                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }

          r = r || sd < 0 ||

          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

          r = rm < 4
           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xc[0]) {
            xc.length = 0;

            if (r) {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {

              // Zero.
              xc[0] = x.e = 0;
            }

            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {

            for (; ;) {

              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {

                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }

                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

        // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }

      return x;
    }


    function valueOf(n) {
      var str,
        e = n.e;

      if (e === null) return n.toString();

      str = coeffToString(n.c);

      str = e <= TO_EXP_NEG || e >= TO_EXP_POS
        ? toExponential(str, e)
        : toFixedPoint(str, e, '0');

      return n.s < 0 ? '-' + str : str;
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };


    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };


    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c, n, v,
        x = this;

      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), dp + x.e + 1, rm);
      }

      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };


    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };


    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
        x = this;

      n = new BigNumber(n);

      // Allow NaN and ±Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error
          (bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }

      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to ±Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }

      nIsNeg = n.s < 0;

      if (m) {

        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

        isModExp = !nIsNeg && x.isInteger() && m.isInteger();

        if (isModExp) x = x.mod(m);

      // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
        // [1, 240000000]
        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
        // [80000000000000]  [99999750000000]
        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = ±Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return ±0, else return ±Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);

      } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }

      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }

      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (; ;) {

        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;

          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }

        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);

          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }

        x = x.times(x);

        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }

      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);

      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };


    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };


    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };


    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };


    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

    };


    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };


    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };


    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };


    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i, j, t, xLTy,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {

          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
           ROUNDING_MODE == 3 ? -0 : 0);
        }
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {

        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {

        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

        for (a = b = 0; b < j; b++) {

          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {

        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }

        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q, s,
        x = this;

      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

      // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }

      if (MODULO_MODE == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }

      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

      return y;
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, ±Infinity or ±0?
      if (!xc || !yc || !xc[0] || !yc[0]) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return ±Infinity if either is ±Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

          // Return ±0 if either is ±0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }

        return y;
      }

      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));

      base = BASE;
      sqrtBase = SQRT_BASE;

      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }

      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }

      return normalise(y, zc, e);
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
       if (a != b) {
        y.s = -b;
        return x.minus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Return ±Infinity if either ±Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }

      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }

      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };


    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c, n, v,
        x = this;

      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), sd, rm);
      }

      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;

      if (v = c[v]) {

        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }

      if (sd && x.e + 1 > n) n = x.e + 1;

      return n;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times('1e' + k);
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '1e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (; ;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));

          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) -- > 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              dp += 4;
              s += 4;
              rep = 1;
            } else {

              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }
      }

      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };


    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;

      if (format == null) {
        if (dp != null && rm && typeof rm == 'object') {
          format = rm;
          rm = null;
        } else if (dp && typeof dp == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (typeof format != 'object') {
        throw Error
          (bignumberError + 'Argument not an object: ' + format);
      }

      str = x.toFixed(dp, rm);

      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;

        if (g2) i = g1, g1 = g2, g2 = i, len -= i;

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
           '$&' + (format.fractionGroupSeparator || ''))
          : fractionPart)
         : intPart;
      }

      return (format.prefix || '') + str + (format.suffix || '');
    };


    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
        x = this,
        xc = x.c;

      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error
            (bignumberError + 'Argument ' +
              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);

      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;

      for (; ;)  {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }

      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

      MAX_EXP = exp;

      return r;
    };


    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };


    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };


    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
           ? toExponential(coeffToString(n.c), e)
           : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }

        if (s < 0 && n.c[0]) str = '-' + str;
      }

      return str;
    };


    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };


    P._isBigNumber = true;

    if (hasSymbol) {
      P[Symbol.toStringTag] = 'BigNumber';

      // Node.js v10.12.0+
      P[Symbol.for('nodejs.util.inspect.custom')] = P.valueOf;
    }

    if (configObject != null) BigNumber.set(configObject);

    return BigNumber;
  }


  // PRIVATE HELPER FUNCTIONS

  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }


  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);

    return r.slice(0, j + 1 || 1);
  }


  // Compare the value of BigNumbers x and y.
  function compare(x, y) {
    var a, b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;

    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }


  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error
       (bignumberError + (name || 'Argument') + (typeof n == 'number'
         ? n < min || n > max ? ' out of range: ' : ' not an integer: '
         : ' not a primitive number: ') + String(n));
    }
  }


  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }


  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
     (e < 0 ? 'e' : 'e+') + e;
  }


  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {

      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

    // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    return str;
  }


  // EXPORT


  BigNumber = clone();
  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

  // AMD.
  if (typeof define == 'function' && define.amd) {
    define(function () { return BigNumber; });

  // Node.js and other environments that support module.exports.
  } else if (typeof module != 'undefined' && module.exports) {
    module.exports = BigNumber;

  // Browser.
  } else {
    if (!globalObject) {
      globalObject = typeof self != 'undefined' && self ? self : window;
    }

    globalObject.BigNumber = BigNumber;
  }
})(this);

      };
    };
  }
}, {package:"bignumber.js",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\node_modules\\bignumber.js\\bignumber.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\retimer\\retimer.js", {"./time":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\retimer\\time-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\retimer\retimer.js
      return function (require, module, exports) {
'use strict'

var getTime = require('./time')

function Retimer (callback, timeout, args) {
  var that = this

  this._started = getTime()
  this._rescheduled = 0
  this._scheduled = timeout
  this._args = args

  this._timer = setTimeout(timerWrapper, timeout)

  function timerWrapper () {
    if (that._rescheduled > 0) {
      that._scheduled = that._rescheduled - (getTime() - that._started)
      that._timer = setTimeout(timerWrapper, that._scheduled)
      that._rescheduled = 0
    } else {
      callback.apply(null, that._args)
    }
  }
}

Retimer.prototype.reschedule = function (timeout) {
  var now = getTime()
  if ((now + timeout) - (this._started + this._scheduled) < 0) {
    return false
  } else {
    this._started = now
    this._rescheduled = timeout
    return true
  }
}

Retimer.prototype.clear = function () {
  clearTimeout(this._timer)
}

function retimer () {
  if (typeof arguments[0] !== 'function') {
    throw new Error('callback needed')
  }

  if (typeof arguments[1] !== 'number') {
    throw new Error('timeout needed')
  }

  var args

  if (arguments.length > 0) {
    args = new Array(arguments.length - 2)

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 2]
    }
  }

  return new Retimer(arguments[0], arguments[1], args)
}

module.exports = retimer

      };
    };
  }
}, {package:"retimer",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\retimer\\retimer.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\dialer\\queue.js", {"../connection":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\connection\\index.js","../errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\errors.js","async/nextTick":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\nextTick.js","debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debug\\src\\browser.js","once":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\once\\once.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-switch\src\dialer\queue.js
      return function (require, module, exports) {
'use strict'

const ConnectionFSM = require('../connection')
const { DIAL_ABORTED, ERR_BLACKLISTED } = require('../errors')
const nextTick = require('async/nextTick')
const once = require('once')
const debug = require('debug')
const log = debug('libp2p:switch:dial')
log.error = debug('libp2p:switch:dial:error')

/**
 * Components required to execute a dial
 * @typedef {Object} DialRequest
 * @property {PeerInfo} peerInfo - The peer to dial to
 * @property {string} [protocol] - The protocol to create a stream for
 * @property {object} options
 * @property {boolean} options.useFSM - If `callback` should return a ConnectionFSM
 * @property {number} options.priority - The priority of the dial
 * @property {function(Error, Connection|ConnectionFSM)} callback
 */

/**
 * @typedef {Object} NewConnection
 * @property {ConnectionFSM} connectionFSM
 * @property {boolean} didCreate
 */

/**
 * Attempts to create a new connection or stream (when muxed),
 * via negotiation of the given `protocol`. If no `protocol` is
 * provided, no action will be taken and `callback` will be called
 * immediately with no error or values.
 *
 * @param {object} options
 * @param {string} options.protocol
 * @param {ConnectionFSM} options.connection
 * @param {function(Error, Connection)} options.callback
 * @returns {void}
 */
function createConnectionWithProtocol ({ protocol, connection, callback }) {
  if (!protocol) {
    return callback()
  }
  connection.shake(protocol, (err, conn) => {
    if (!conn) {
      return callback(err)
    }

    conn.setPeerInfo(connection.theirPeerInfo)
    callback(null, conn)
  })
}

/**
 * A convenience array wrapper for controlling
 * a per peer queue
 *
 * @returns {Queue}
 */
class Queue {
  /**
   * @constructor
   * @param {string} peerId
   * @param {Switch} _switch
   * @param {function(string)} onStopped Called when the queue stops
   */
  constructor (peerId, _switch, onStopped) {
    this.id = peerId
    this.switch = _switch
    this._queue = []
    this.blackListed = null
    this.blackListCount = 0
    this.isRunning = false
    this.onStopped = onStopped
  }
  get length () {
    return this._queue.length
  }

  /**
   * Adds the dial request to the queue. The queue is not automatically started
   * @param {string} protocol
   * @param {boolean} useFSM If callback should use a ConnectionFSM instead
   * @param {function(Error, Connection)} callback
   * @returns {void}
   */
  add (protocol, useFSM, callback) {
    if (!this.isDialAllowed()) {
      return nextTick(callback, ERR_BLACKLISTED())
    }
    this._queue.push({ protocol, useFSM, callback })
  }

  /**
   * Determines whether or not dialing is currently allowed
   * @returns {boolean}
   */
  isDialAllowed () {
    if (this.blackListed) {
      // If the blacklist ttl has passed, reset it
      if (Date.now() > this.blackListed) {
        this.blackListed = null
        return true
      }
      // Dial is not allowed
      return false
    }
    return true
  }

  /**
   * Starts the queue. If the queue was started `true` will be returned.
   * If the queue was already running `false` is returned.
   * @returns {boolean}
   */
  start () {
    if (!this.isRunning) {
      log('starting dial queue to %s', this.id)
      this.isRunning = true
      this._run()
      return true
    }
    return false
  }

  /**
   * Stops the queue
   */
  stop () {
    if (this.isRunning) {
      log('stopping dial queue to %s', this.id)
      this.isRunning = false
      this.onStopped(this.id)
    }
  }

  /**
   * Stops the queue and errors the callback for each dial request
   */
  abort () {
    while (this.length > 0) {
      let dial = this._queue.shift()
      dial.callback(DIAL_ABORTED())
    }
    this.stop()
  }

  /**
   * Marks the queue as blacklisted. The queue will be immediately aborted.
   * @returns {void}
   */
  blacklist () {
    this.blackListCount++

    if (this.blackListCount >= this.switch.dialer.BLACK_LIST_ATTEMPTS) {
      this.blackListed = Infinity
      return
    }

    let ttl = this.switch.dialer.BLACK_LIST_TTL * Math.pow(this.blackListCount, 3)
    const minTTL = ttl * 0.9
    const maxTTL = ttl * 1.1

    // Add a random jitter of 20% to the ttl
    ttl = Math.floor(Math.random() * (maxTTL - minTTL) + minTTL)

    this.blackListed = Date.now() + ttl
    this.abort()
  }

  /**
   * Attempts to find a muxed connection for the given peer. If one
   * isn't found, a new one will be created.
   *
   * Returns an array containing two items. The ConnectionFSM and wether
   * or not the ConnectionFSM was just created. The latter can be used
   * to determine dialing needs.
   *
   * @private
   * @param {PeerInfo} peerInfo
   * @returns {NewConnection}
   */
  _getOrCreateConnection (peerInfo) {
    let connectionFSM = this.switch.connection.getOne(this.id)
    let didCreate = false

    if (!connectionFSM) {
      connectionFSM = new ConnectionFSM({
        _switch: this.switch,
        peerInfo,
        muxer: null,
        conn: null
      })

      this.switch.connection.add(connectionFSM)

      // Add control events and start the dialer
      connectionFSM.once('connected', () => connectionFSM.protect())
      connectionFSM.once('private', () => connectionFSM.encrypt())
      connectionFSM.once('encrypted', () => connectionFSM.upgrade())

      didCreate = true
    }

    return { connectionFSM, didCreate }
  }

  /**
   * Executes the next dial in the queue for the given peer
   * @private
   * @returns {void}
   */
  _run () {
    // If we have no items in the queue or we're stopped, exit
    if (this.length < 1 || !this.isRunning) {
      log('stopping the queue for %s', this.id)
      return this.stop()
    }

    const next = once(() => {
      log('starting next dial to %s', this.id)
      this._run()
    })

    const peerInfo = this.switch._peerBook.get(this.id)
    let queuedDial = this._queue.shift()
    let { connectionFSM, didCreate } = this._getOrCreateConnection(peerInfo)

    // If the dial expects a ConnectionFSM, we can provide that back now
    if (queuedDial.useFSM) {
      nextTick(queuedDial.callback, null, connectionFSM)
    }

    // If we can handshake protocols, get a new stream and call run again
    if (['MUXED', 'CONNECTED'].includes(connectionFSM.getState())) {
      queuedDial.connection = connectionFSM
      createConnectionWithProtocol(queuedDial)
      next()
      return
    }

    // If we error, error the queued dial
    // In the future, it may be desired to error the other queued dials,
    // depending on the error.
    connectionFSM.once('error', (err) => {
      queuedDial.callback(err)
      // Dont blacklist peers we have identified and that we are connected to
      if (peerInfo.protocols.size > 0 && peerInfo.isConnected()) {
        return
      }
      this.blacklist()
    })

    connectionFSM.once('close', () => {
      next()
    })

    // If we're not muxed yet, add listeners
    connectionFSM.once('muxed', () => {
      this.blackListCount = 0 // reset blacklisting on good connections
      queuedDial.connection = connectionFSM
      createConnectionWithProtocol(queuedDial)
      next()
    })

    connectionFSM.once('unmuxed', () => {
      this.blackListCount = 0
      queuedDial.connection = connectionFSM
      createConnectionWithProtocol(queuedDial)
      next()
    })

    // If we have a new connection, start dialing
    if (didCreate) {
      connectionFSM.dial()
    }
  }
}

module.exports = Queue

      };
    };
  }
}, {package:"libp2p-switch",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\dialer\\queue.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\constants.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\multistream-select\src\constants.js
      return function (require, module, exports) {
'use strict'

exports = module.exports

exports.PROTOCOL_ID = '/multistream/1.0.0'

exports.errors = {
  MULTICODEC_NOT_SUPPORTED: 'ERR_MULTICODEC_NOT_SUPPORTED'
}

      };
    };
  }
}, {package:"multistream-select",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\constants.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\listener\\match-exact.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\multistream-select\src\listener\match-exact.js
      return function (require, module, exports) {
'use strict'

/**
 * Match protocols exactly.
 *
 * @param {string} myProtocol
 * @param {string} senderProtocol
 * @param {function(Error, boolean)} callback
 * @returns {undefined}
 * @type {matchHandler}
 */
function matchExact (myProtocol, senderProtocol, callback) {
  const result = myProtocol === senderProtocol
  callback(null, result)
}

module.exports = matchExact

      };
    };
  }
}, {package:"multistream-select",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\listener\\match-exact.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\listener\\match-semver.js", {"semver":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\node_modules\\semver\\semver.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\multistream-select\src\listener\match-semver.js
      return function (require, module, exports) {
'use strict'

const semver = require('semver')

/**
 * Match protocols using semver `~` matching.
 *
 * @param {string} myProtocol
 * @param {string} senderProtocol
 * @param {function(Error, boolean)} callback
 * @returns {undefined}
 * @type {matchHandler}
 */
function matchSemver (myProtocol, senderProtocol, callback) {
  const mps = myProtocol.split('/')
  const sps = senderProtocol.split('/')
  const myName = mps[1]
  const myVersion = mps[2]

  const senderName = sps[1]
  const senderVersion = sps[2]

  if (myName !== senderName) {
    return callback(null, false)
  }
  // does my protocol satisfy the sender?
  const valid = semver.satisfies(myVersion, '~' + senderVersion)

  callback(null, valid)
}

module.exports = matchSemver

      };
    };
  }
}, {package:"multistream-select",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\listener\\match-semver.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\dialer\\index.js", {"../select":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\select.js","../util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\util.js","./../constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\constants.js","interface-connection":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\interface-connection\\src\\index.js","once":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\once\\once.js","pull-length-prefixed":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-length-prefixed\\src\\index.js","pull-stream/pull":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\pull.js","pull-stream/sinks/collect":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\sinks\\collect.js","pull-stream/throughs/map":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\throughs\\map.js","pull-stream/throughs/take":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\throughs\\take.js","varint":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\varint\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\multistream-select\src\dialer\index.js
      return function (require, module, exports) {
'use strict'

const varint = require('varint')
const pull = require('pull-stream/pull')
const map = require('pull-stream/throughs/map')
const collect = require('pull-stream/sinks/collect')
const take = require('pull-stream/throughs/take')
const pullLP = require('pull-length-prefixed')
const Connection = require('interface-connection').Connection
const util = require('../util')
const select = require('../select')
const once = require('once')

const PROTOCOL_ID = require('./../constants').PROTOCOL_ID

/**
 *
 */
class Dialer {
  /**
   * Create a new Dialer.
   */
  constructor () {
    this.conn = null
    this.log = util.log.dialer()
  }

  /**
   * Perform the multistream handshake.
   *
   * @param {Connection} rawConn - The connection on which
   * to perform the handshake.
   * @param {function(Error)} callback - Called when the handshake completed.
   * @returns {undefined}
   */
  handle (rawConn, callback) {
    this.log('dialer handle conn')
    callback = once(callback)
    const s = select(PROTOCOL_ID, (err, conn) => {
      if (err) {
        return callback(err)
      }
      this.log('handshake success')

      this.conn = new Connection(conn, rawConn)

      callback()
    }, this.log)

    // Handle unexpected errors from pull, like 'already piped'
    try {
      pull(
        rawConn,
        s,
        rawConn
      )
    } catch (err) {
      this.log.error(err)
      callback(err)
    }
  }

  /**
   * Select a protocol
   *
   * @param {string} protocol - A string of the protocol that we want to handshake.
   * @param {function(Error, Connection)} callback - `err` is
   * an error object that gets passed if something wrong happ
   * end (e.g: if the protocol selected is not supported by
   * the other end) and conn is the connection handshaked
   * with the other end.
   *
   * @returns {undefined}
   */
  select (protocol, callback) {
    this.log('dialer select ' + protocol)
    callback = once(callback)
    if (!this.conn) {
      return callback(new Error('multistream handshake has not finalized yet'))
    }

    const s = select(protocol, (err, conn) => {
      if (err) {
        this.conn = new Connection(conn, this.conn)
        return callback(err)
      }
      callback(null, new Connection(conn, this.conn))
    }, this.log)

    pull(
      this.conn,
      s,
      this.conn
    )
  }

  /**
   * List all available protocols.
   *
   * @param {function(Error, Array<string>)} callback - If
   * something wrong happend `Error` exists, otherwise
   * `protocols` is a list of the supported
   * protocols on the other end.
   *
   * @returns {undefined}
   */
  ls (callback) {
    callback = once(callback)

    const lsStream = select('ls', (err, conn) => {
      if (err) {
        return callback(err)
      }

      pull(
        conn,
        pullLP.decode(),
        collectLs(conn),
        map(stringify),
        collect((err, list) => {
          if (err) {
            return callback(err)
          }
          callback(null, list.slice(1))
        })
      )
    }, this.log)

    pull(
      this.conn,
      lsStream,
      this.conn
    )
  }
}

function stringify (buf) {
  return buf.toString().slice(0, -1)
}

function collectLs (conn) {
  let first = true
  let counter = 0

  return take((msg) => {
    if (first) {
      varint.decode(msg)
      counter = varint.decode(msg, varint.decode.bytes)
      return true
    }

    return counter-- > 0
  })
}

module.exports = Dialer

      };
    };
  }
}, {package:"multistream-select",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\dialer\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\listener\\index.js", {"../select":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\select.js","./../constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\constants.js","./../util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\util.js","./ls-handler":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\listener\\ls-handler.js","./match-exact":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\listener\\match-exact.js","./select-handler":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\listener\\select-handler.js","assert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\assert.js","interface-connection":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\interface-connection\\src\\index.js","pull-stream/pull":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\pull.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\multistream-select\src\listener\index.js
      return function (require, module, exports) {
'use strict'

const pull = require('pull-stream/pull')
const assert = require('assert')
const select = require('../select')
const selectHandler = require('./select-handler')
const lsHandler = require('./ls-handler')
const matchExact = require('./match-exact')

const util = require('./../util')
const Connection = require('interface-connection').Connection

const PROTOCOL_ID = require('./../constants').PROTOCOL_ID

/**
 * Listener
 */
class Listener {
  /**
   * Create a new Listener.
   */
  constructor () {
    this.handlers = {
      ls: {
        handlerFunc: (protocol, conn) => lsHandler(this, conn),
        matchFunc: matchExact

      }
    }
    this.log = util.log.listener()
  }

  /**
   * Perform the multistream handshake.
   *
   * @param {Connection} rawConn - The connection on which
   * to perform the handshake.
   * @param {function(Error)} callback - Called when the handshake completed.
   * @returns {undefined}
   */
  handle (rawConn, callback) {
    this.log('listener handle conn')

    const selectStream = select(PROTOCOL_ID, (err, conn) => {
      if (err) {
        return callback(err)
      }

      const shConn = new Connection(conn, rawConn)

      const sh = selectHandler(shConn, this.handlers, this.log)

      pull(
        shConn,
        sh,
        shConn
      )

      callback()
    }, this.log)

    pull(
      rawConn,
      selectStream,
      rawConn
    )
  }

  /**
   * Handle a given `protocol`.
   *
   * @param {string} protocol - A string identifying the protocol.
   * @param {function(string, Connection)} handlerFunc - Will be called if there is a handshake performed on `protocol`.
   * @param {matchHandler} [matchFunc=matchExact]
   * @returns {undefined}
   */
  addHandler (protocol, handlerFunc, matchFunc) {
    this.log('adding handler: ' + protocol)
    assert(typeof handlerFunc === 'function', 'handler must be a function')

    if (this.handlers[protocol]) {
      this.log('overwriting handler for ' + protocol)
    }

    if (!matchFunc) {
      matchFunc = matchExact
    }

    this.handlers[protocol] = {
      handlerFunc: handlerFunc,
      matchFunc: matchFunc
    }
  }

  /**
   * Receives a protocol and a callback and should
   * call `callback(err, result)` where `err` is if
   * there was a error on the matching function, and
   * `result` is a boolean that represents if a
   * match happened.
   *
   * @callback matchHandler
   * @param {string} myProtocol
   * @param {string} senderProtocol
   * @param {function(Error, boolean)} callback
   * @returns {undefined}
   */
}

module.exports = Listener

      };
    };
  }
}, {package:"multistream-select",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\listener\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-identify\\src\\message.js", {"protons":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\protons\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-identify\src\message.js
      return function (require, module, exports) {
'use strict'

const protons = require('protons')
const schema = `
message Identify {
  // protocolVersion determines compatibility between peers
  optional string protocolVersion = 5; // e.g. ipfs/1.0.0

  // agentVersion is like a UserAgent string in browsers, or client version in bittorrent
  // includes the client name and client.
  optional string agentVersion = 6; // e.g. go-ipfs/0.1.0

  // publicKey is this node's public key (which also gives its node.ID)
  // - may not need to be sent, as secure channel implies it has been sent.
  // - then again, if we change / disable secure channel, may still want it.
  optional bytes publicKey = 1;

  // listenAddrs are the multiaddrs the sender node listens for open connections on
  repeated bytes listenAddrs = 2;

  // oservedAddr is the multiaddr of the remote endpoint that the sender node perceives
  // this is useful information to convey to the other side, as it helps the remote endpoint
  // determine whether its connection to the local peer goes through NAT.
  optional bytes observedAddr = 4;

  repeated string protocols = 3;
}
`

module.exports = protons(schema).Identify

      };
    };
  }
}, {package:"libp2p-identify",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-identify\\src\\message.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-identify\\src\\dialer.js", {"./message":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-identify\\src\\message.js","multiaddr":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multiaddr\\src\\index.js","peer-id":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-id\\src\\index.js","peer-info":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-info\\src\\index.js","pull-length-prefixed":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-length-prefixed\\src\\index.js","pull-stream/pull":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\pull.js","pull-stream/sinks/collect":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\sinks\\collect.js","pull-stream/throughs/take":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\throughs\\take.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-identify\src\dialer.js
      return function (require, module, exports) {
'use strict'
const PeerInfo = require('peer-info')
const PeerId = require('peer-id')
const multiaddr = require('multiaddr')
const pull = require('pull-stream/pull')
const take = require('pull-stream/throughs/take')
const collect = require('pull-stream/sinks/collect')
const lp = require('pull-length-prefixed')

const msg = require('./message')

module.exports = (conn, expectedPeerInfo, callback) => {
  if (typeof expectedPeerInfo === 'function') {
    callback = expectedPeerInfo
    expectedPeerInfo = null
    console.warn('WARNING: no expected peer info was given, identify will not be able to verify peer integrity')
  }

  pull(
    conn,
    lp.decode(),
    take(1),
    collect((err, data) => {
      if (err) {
        return callback(err)
      }

      // connection got closed graciously
      if (data.length === 0) {
        return callback(new Error('conn was closed, did not receive data'))
      }

      const input = msg.decode(data[0])

      PeerId.createFromPubKey(input.publicKey, (err, id) => {
        if (err) {
          return callback(err)
        }

        const peerInfo = new PeerInfo(id)
        if (expectedPeerInfo && expectedPeerInfo.id.toB58String() !== id.toB58String()) {
          return callback(new Error('invalid peer'))
        }

        try {
          input.listenAddrs
            .map(multiaddr)
            .forEach((ma) => peerInfo.multiaddrs.add(ma))
        } catch (err) {
          return callback(err)
        }

        let observedAddr

        try {
          observedAddr = getObservedAddrs(input)
        } catch (err) {
          return callback(err)
        }

        // Copy the protocols
        peerInfo.protocols = new Set(input.protocols)

        callback(null, peerInfo, observedAddr)
      })
    })
  )
}

function getObservedAddrs (input) {
  if (!hasObservedAddr(input)) {
    return []
  }

  let addrs = input.observedAddr

  if (!Array.isArray(addrs)) {
    addrs = [addrs]
  }

  return addrs.map((oa) => multiaddr(oa))
}

function hasObservedAddr (input) {
  return input.observedAddr && input.observedAddr.length > 0
}

      };
    };
  }
}, {package:"libp2p-identify",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-identify\\src\\dialer.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-identify\\src\\listener.js", {"./message":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-identify\\src\\message.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","pull-length-prefixed":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-length-prefixed\\src\\index.js","pull-stream/pull":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\pull.js","pull-stream/sources/values":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\sources\\values.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-identify\src\listener.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const pull = require('pull-stream/pull')
const values = require('pull-stream/sources/values')
const lp = require('pull-length-prefixed')

const msg = require('./message')

module.exports = (conn, pInfoSelf) => {
  // send what I see from the other + my Info
  conn.getObservedAddrs((err, observedAddrs) => {
    if (err) { return }
    observedAddrs = observedAddrs[0]

    let publicKey = Buffer.alloc(0)
    if (pInfoSelf.id.pubKey) {
      publicKey = pInfoSelf.id.pubKey.bytes
    }

    const msgSend = msg.encode({
      protocolVersion: 'ipfs/0.1.0',
      agentVersion: 'na',
      publicKey: publicKey,
      listenAddrs: pInfoSelf.multiaddrs.toArray().map((ma) => ma.buffer),
      observedAddr: observedAddrs ? observedAddrs.buffer : Buffer.from(''),
      protocols: Array.from(pInfoSelf.protocols)
    })

    pull(
      values([msgSend]),
      lp.encode(),
      conn
    )
  })
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"libp2p-identify",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-identify\\src\\listener.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\limit-dialer\\queue.js", {"async/queue":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\queue.js","async/timeout":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\timeout.js","debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debug\\src\\browser.js","interface-connection":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\interface-connection\\src\\index.js","once":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\once\\once.js","pull-stream/pull":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\pull.js","pull-stream/sources/empty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\sources\\empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-switch\src\limit-dialer\queue.js
      return function (require, module, exports) {
'use strict'

const Connection = require('interface-connection').Connection
const pull = require('pull-stream/pull')
const empty = require('pull-stream/sources/empty')
const timeout = require('async/timeout')
const queue = require('async/queue')
const debug = require('debug')
const once = require('once')

const log = debug('libp2p:switch:dialer:queue')
log.error = debug('libp2p:switch:dialer:queue:error')

/**
 * Queue up the amount of dials to a given peer.
 */
class DialQueue {
  /**
   * Create a new dial queue.
   *
   * @param {number} limit
   * @param {number} dialTimeout
   */
  constructor (limit, dialTimeout) {
    this.dialTimeout = dialTimeout

    this.queue = queue((task, cb) => {
      this._doWork(task.transport, task.addr, task.token, cb)
    }, limit)
  }

  /**
   * The actual work done by the queue.
   *
   * @param {SwarmTransport} transport
   * @param {Multiaddr} addr
   * @param {CancelToken} token
   * @param {function(Error, Connection)} callback
   * @returns {void}
   * @private
   */
  _doWork (transport, addr, token, callback) {
    callback = once(callback)
    log('work:start')
    this._dialWithTimeout(transport, addr, (err, conn) => {
      if (err) {
        log.error(`${transport.constructor.name}:work`, err)
        return callback(err)
      }

      if (token.cancel) {
        log('work:cancel')
        // clean up already done dials
        pull(empty(), conn)
        // If we can close the connection, do it
        if (typeof conn.close === 'function') {
          return conn.close((_) => callback(null))
        }
        return callback(null)
      }

      // one is enough
      token.cancel = true

      log('work:success')

      const proxyConn = new Connection()
      proxyConn.setInnerConn(conn)
      callback(null, { multiaddr: addr, conn: conn })
    })
  }

  /**
   * Dial the given transport, timing out with the set timeout.
   *
   * @param {SwarmTransport} transport
   * @param {Multiaddr} addr
   * @param {function(Error, Connection)} callback
   * @returns {void}
   *
   * @private
   */
  _dialWithTimeout (transport, addr, callback) {
    timeout((cb) => {
      const conn = transport.dial(addr, (err) => {
        if (err) {
          return cb(err)
        }

        cb(null, conn)
      })
    }, this.dialTimeout)(callback)
  }

  /**
   * Add new work to the queue.
   *
   * @param {SwarmTransport} transport
   * @param {Multiaddr} addr
   * @param {CancelToken} token
   * @param {function(Error, Connection)} callback
   * @returns {void}
   */
  push (transport, addr, token, callback) {
    this.queue.push({ transport, addr, token }, callback)
  }
}

module.exports = DialQueue

      };
    };
  }
}, {package:"libp2p-switch",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-switch\\src\\limit-dialer\\queue.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\circuit\\utils.js", {"../protocol":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\protocol\\index.js","multiaddr":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multiaddr\\src\\index.js","peer-id":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-id\\src\\index.js","peer-info":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-info\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-circuit\src\circuit\utils.js
      return function (require, module, exports) {
'use strict'

const multiaddr = require('multiaddr')
const PeerInfo = require('peer-info')
const PeerId = require('peer-id')
const proto = require('../protocol')

module.exports = function (swarm) {
  /**
   * Get b58 string from multiaddr or peerinfo
   *
   * @param {Multiaddr|PeerInfo} peer
   * @return {*}
   */
  function getB58String (peer) {
    let b58Id = null
    if (multiaddr.isMultiaddr(peer)) {
      const relayMa = multiaddr(peer)
      b58Id = relayMa.getPeerId()
    } else if (PeerInfo.isPeerInfo(peer)) {
      b58Id = peer.id.toB58String()
    }

    return b58Id
  }

  /**
   * Helper to make a peer info from a multiaddrs
   *
   * @param {Multiaddr|PeerInfo|PeerId} ma
   * @param {Swarm} swarm
   * @return {PeerInfo}
   * @private
   */
  // TODO: this is ripped off of libp2p, should probably be a generally available util function
  function peerInfoFromMa (peer) {
    let p
    // PeerInfo
    if (PeerInfo.isPeerInfo(peer)) {
      p = peer
      // Multiaddr instance (not string)
    } else if (multiaddr.isMultiaddr(peer)) {
      const peerIdB58Str = peer.getPeerId()
      try {
        p = swarm._peerBook.get(peerIdB58Str)
      } catch (err) {
        p = new PeerInfo(PeerId.createFromB58String(peerIdB58Str))
      }
      p.multiaddrs.add(peer)
      // PeerId
    } else if (PeerId.isPeerId(peer)) {
      const peerIdB58Str = peer.toB58String()
      p = swarm._peerBook.has(peerIdB58Str) ? swarm._peerBook.get(peerIdB58Str) : peer
    }

    return p
  }

  /**
   * Checks if peer has an existing connection
   *
   * @param {String} peerId
   * @param {Swarm} swarm
   * @return {Boolean}
   */
  function isPeerConnected (peerId) {
    return swarm.muxedConns[peerId] || swarm.conns[peerId]
  }

  /**
   * Write a response
   *
   * @param {StreamHandler} streamHandler
   * @param {CircuitRelay.Status} status
   * @param {Function} cb
   * @returns {*}
   */
  function writeResponse (streamHandler, status, cb) {
    cb = cb || (() => {})
    streamHandler.write(proto.CircuitRelay.encode({
      type: proto.CircuitRelay.Type.STATUS,
      code: status
    }))
    return cb()
  }

  /**
   * Validate incomming HOP/STOP message
   *
   * @param {CircuitRelay} msg
   * @param {StreamHandler} streamHandler
   * @param {CircuitRelay.Type} type
   * @returns {*}
   * @param {Function} cb
   */
  function validateAddrs (msg, streamHandler, type, cb) {
    try {
      msg.dstPeer.addrs.forEach((addr) => {
        return multiaddr(addr)
      })
    } catch (err) {
      writeResponse(streamHandler, type === proto.CircuitRelay.Type.HOP
        ? proto.CircuitRelay.Status.HOP_DST_MULTIADDR_INVALID
        : proto.CircuitRelay.Status.STOP_DST_MULTIADDR_INVALID)
      return cb(err)
    }

    try {
      msg.srcPeer.addrs.forEach((addr) => {
        return multiaddr(addr)
      })
    } catch (err) {
      writeResponse(streamHandler, type === proto.CircuitRelay.Type.HOP
        ? proto.CircuitRelay.Status.HOP_SRC_MULTIADDR_INVALID
        : proto.CircuitRelay.Status.STOP_SRC_MULTIADDR_INVALID)
      return cb(err)
    }

    return cb(null)
  }

  function peerIdFromId (id) {
    if (typeof id === 'string') {
      return PeerId.createFromB58String(id)
    }

    return PeerId.createFromBytes(id)
  }

  return {
    getB58String,
    peerInfoFromMa,
    isPeerConnected,
    validateAddrs,
    writeResponse,
    peerIdFromId
  }
}

      };
    };
  }
}, {package:"libp2p-circuit",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\circuit\\utils.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\circuit\\dialer.js", {"../multicodec":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\multicodec.js","../protocol":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\protocol\\index.js","./stream-handler":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\circuit\\stream-handler.js","./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\circuit\\utils.js","async/setImmediate":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\setImmediate.js","async/waterfall":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\waterfall.js","debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debug\\src\\browser.js","interface-connection":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\interface-connection\\src\\index.js","multiaddr":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multiaddr\\src\\index.js","once":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\once\\once.js","peer-id":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-id\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-circuit\src\circuit\dialer.js
      return function (require, module, exports) {
'use strict'

const once = require('once')
const PeerId = require('peer-id')
const waterfall = require('async/waterfall')
const setImmediate = require('async/setImmediate')
const multiaddr = require('multiaddr')

const Connection = require('interface-connection').Connection

const utilsFactory = require('./utils')
const StreamHandler = require('./stream-handler')

const debug = require('debug')
const log = debug('libp2p:circuit:dialer')
log.err = debug('libp2p:circuit:error:dialer')

const multicodec = require('../multicodec')
const proto = require('../protocol')

class Dialer {
  /**
   * Creates an instance of Dialer.
   * @param {Swarm} swarm - the swarm
   * @param {any} options - config options
   *
   * @memberOf Dialer
   */
  constructor (swarm, options) {
    this.swarm = swarm
    this.relayPeers = new Map()
    this.relayConns = new Map()
    this.options = options
    this.utils = utilsFactory(swarm)
  }

  /**
   * Helper that returns a relay connection
   *
   * @param {*} relay
   * @param {*} callback
   * @returns {Function} - callback
   */
  _dialRelayHelper (relay, callback) {
    if (this.relayConns.has(relay.id.toB58String())) {
      return callback(null, this.relayConns.get(relay.id.toB58String()))
    }

    return this._dialRelay(relay, callback)
  }

  /**
   * Dial a peer over a relay
   *
   * @param {multiaddr} ma - the multiaddr of the peer to dial
   * @param {Function} cb - a callback called once dialed
   * @returns {Connection} - the connection
   *
   */
  dial (ma, cb) {
    cb = cb || (() => { })
    const strMa = ma.toString()
    if (!strMa.includes('/p2p-circuit')) {
      log.err('invalid circuit address')
      return cb(new Error('invalid circuit address'))
    }

    const addr = strMa.split('p2p-circuit') // extract relay address if any
    const relay = addr[0] === '/' ? null : multiaddr(addr[0])
    const peer = multiaddr(addr[1] || addr[0])

    const dstConn = new Connection()
    setImmediate(
      this._dialPeer.bind(this),
      peer,
      relay,
      (err, conn) => {
        if (err) {
          log.err(err)
          return cb(err)
        }

        dstConn.setInnerConn(conn)
        cb(null, dstConn)
      })

    return dstConn
  }

  /**
   * Does the peer support the HOP protocol
   *
   * @param {PeerInfo} peer
   * @param {Function} callback
   * @returns {void}
   */
  canHop (peer, callback) {
    callback = once(callback || (() => { }))

    this._dialRelayHelper(peer, (err, conn) => {
      if (err) {
        return callback(err)
      }

      const sh = new StreamHandler(conn)
      waterfall([
        (cb) => sh.write(proto.CircuitRelay.encode({
          type: proto.CircuitRelay.Type.CAN_HOP
        }), cb),
        (cb) => sh.read(cb)
      ], (err, msg) => {
        if (err) {
          return callback(err)
        }
        const response = proto.CircuitRelay.decode(msg)

        if (response.code !== proto.CircuitRelay.Status.SUCCESS) {
          const err = new Error(`HOP not supported, skipping - ${this.utils.getB58String(peer)}`)
          log(err)
          return callback(err)
        }

        log('HOP supported adding as relay - %s', this.utils.getB58String(peer))
        this.relayPeers.set(this.utils.getB58String(peer), peer)
        sh.close()
        callback()
      })
    })
  }

  /**
   * Dial the destination peer over a relay
   *
   * @param {multiaddr} dstMa
   * @param {Connection|PeerInfo} relay
   * @param {Function} cb
   * @return {Function|void}
   * @private
   */
  _dialPeer (dstMa, relay, cb) {
    if (typeof relay === 'function') {
      cb = relay
      relay = null
    }

    if (!cb) {
      cb = () => {}
    }

    dstMa = multiaddr(dstMa)
    // if no relay provided, dial on all available relays until one succeeds
    if (!relay) {
      const relays = Array.from(this.relayPeers.values())
      let next = (nextRelay) => {
        if (!nextRelay) {
          let err = `no relay peers were found or all relays failed to dial`
          log.err(err)
          return cb(err)
        }

        return this._negotiateRelay(
          nextRelay,
          dstMa,
          (err, conn) => {
            if (err) {
              log.err(err)
              return next(relays.shift())
            }
            cb(null, conn)
          })
      }
      next(relays.shift())
    } else {
      return this._negotiateRelay(
        relay,
        dstMa,
        (err, conn) => {
          if (err) {
            log.err('An error has occurred negotiating the relay connection', err)
            return cb(err)
          }

          return cb(null, conn)
        })
    }
  }

  /**
   * Negotiate the relay connection
   *
   * @param {Multiaddr|PeerInfo|Connection} relay - the Connection or PeerInfo of the relay
   * @param {multiaddr} dstMa - the multiaddr of the peer to relay the connection for
   * @param {Function} callback - a callback which gets the negotiated relay connection
   * @returns {void}
   * @private
   *
   * @memberOf Dialer
   */
  _negotiateRelay (relay, dstMa, callback) {
    dstMa = multiaddr(dstMa)
    relay = this.utils.peerInfoFromMa(relay)
    const srcMas = this.swarm._peerInfo.multiaddrs.toArray()
    this._dialRelayHelper(relay, (err, conn) => {
      if (err) {
        log.err(err)
        return callback(err)
      }
      let sh = new StreamHandler(conn)
      waterfall([
        (cb) => {
          log('negotiating relay for peer %s', dstMa.getPeerId())
          let dstPeerId
          try {
            dstPeerId = PeerId.createFromB58String(dstMa.getPeerId()).id
          } catch (err) {
            return cb(err)
          }
          sh.write(
            proto.CircuitRelay.encode({
              type: proto.CircuitRelay.Type.HOP,
              srcPeer: {
                id: this.swarm._peerInfo.id.id,
                addrs: srcMas.map((addr) => addr.buffer)
              },
              dstPeer: {
                id: dstPeerId,
                addrs: [dstMa.buffer]
              }
            }), cb)
        },
        (cb) => sh.read(cb)
      ], (err, msg) => {
        if (err) {
          return callback(err)
        }
        const message = proto.CircuitRelay.decode(msg)
        if (message.type !== proto.CircuitRelay.Type.STATUS) {
          return callback(new Error(`Got invalid message type - ` +
            `expected ${proto.CircuitRelay.Type.STATUS} got ${message.type}`))
        }

        if (message.code !== proto.CircuitRelay.Status.SUCCESS) {
          return callback(new Error(`Got ${message.code} error code trying to dial over relay`))
        }

        callback(null, new Connection(sh.rest()))
      })
    })
  }

  /**
   * Dial a relay peer by its PeerInfo
   *
   * @param {PeerInfo} peer - the PeerInfo of the relay peer
   * @param {Function} cb - a callback with the connection to the relay peer
   * @returns {void}
   * @private
   */
  _dialRelay (peer, cb) {
    cb = once(cb || (() => { }))

    this.swarm.dial(
      peer,
      multicodec.relay,
      once((err, conn) => {
        if (err) {
          log.err(err)
          return cb(err)
        }
        cb(null, conn)
      }))
  }
}

module.exports = Dialer

      };
    };
  }
}, {package:"libp2p-circuit",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\circuit\\dialer.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\listener.js", {"./circuit/hop":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\circuit\\hop.js","./circuit/stop":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\circuit\\stop.js","./circuit/stream-handler":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\circuit\\stream-handler.js","./circuit/utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\circuit\\utils.js","./multicodec":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\multicodec.js","./protocol":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\protocol\\index.js","async/setImmediate":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\setImmediate.js","debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debug\\src\\browser.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","mafmt":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\mafmt\\src\\index.js","multiaddr":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multiaddr\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-circuit\src\listener.js
      return function (require, module, exports) {
'use strict'

const setImmediate = require('async/setImmediate')

const multicodec = require('./multicodec')
const EE = require('events').EventEmitter
const multiaddr = require('multiaddr')
const mafmt = require('mafmt')
const Stop = require('./circuit/stop')
const Hop = require('./circuit/hop')
const proto = require('./protocol')
const utilsFactory = require('./circuit/utils')

const StreamHandler = require('./circuit/stream-handler')

const debug = require('debug')

const log = debug('libp2p:circuit:listener')
log.err = debug('libp2p:circuit:error:listener')

module.exports = (swarm, options, connHandler) => {
  const listener = new EE()
  const utils = utilsFactory(swarm)

  listener.stopHandler = new Stop(swarm)
  listener.stopHandler.on('connection', (conn) => listener.emit('connection', conn))
  listener.hopHandler = new Hop(swarm, options.hop)

  /**
   * Add swarm handler and listen for incoming connections
   *
   * @param {Multiaddr} ma
   * @param {Function} callback
   * @return {void}
   */
  listener.listen = (ma, callback) => {
    callback = callback || (() => {})

    swarm.handle(multicodec.relay, (_, conn) => {
      const sh = new StreamHandler(conn)

      sh.read((err, msg) => {
        if (err) {
          log.err(err)
          return
        }

        let request = null
        try {
          request = proto.CircuitRelay.decode(msg)
        } catch (err) {
          return utils.writeResponse(
            sh,
            proto.CircuitRelay.Status.MALFORMED_MESSAGE)
        }

        switch (request.type) {
          case proto.CircuitRelay.Type.CAN_HOP:
          case proto.CircuitRelay.Type.HOP: {
            return listener.hopHandler.handle(request, sh)
          }

          case proto.CircuitRelay.Type.STOP: {
            return listener.stopHandler.handle(request, sh, connHandler)
          }

          default: {
            utils.writeResponse(
              sh,
              proto.CircuitRelay.Status.INVALID_MSG_TYPE)
            return sh.close()
          }
        }
      })
    })

    setImmediate(() => listener.emit('listen'))
    callback()
  }

  /**
   * Remove swarm listener
   *
   * @param {Function} cb
   * @return {void}
   */
  listener.close = (cb) => {
    swarm.unhandle(multicodec.relay)
    setImmediate(() => listener.emit('close'))
    cb()
  }

  /**
   * Get fixed up multiaddrs
   *
   * NOTE: This method will grab the peers multiaddrs and expand them such that:
   *
   * a) If it's an existing /p2p-circuit address for a specific relay i.e.
   *    `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit` this method will expand the
   *    address to `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit/ipfs/QmPeer` where
   *    `QmPeer` is this peers id
   * b) If it's not a /p2p-circuit address, it will encapsulate the address as a /p2p-circuit
   *    addr, such when dialing over a relay with this address, it will create the circuit using
   *    the encapsulated transport address. This is useful when for example, a peer should only
   *    be dialed over TCP rather than any other transport
   *
   * @param {Function} callback
   * @return {void}
   */
  listener.getAddrs = (callback) => {
    let addrs = swarm._peerInfo.multiaddrs.toArray()

    // get all the explicit relay addrs excluding self
    let p2pAddrs = addrs.filter((addr) => {
      return mafmt.Circuit.matches(addr) &&
        !addr.toString().includes(swarm._peerInfo.id.toB58String())
    })

    // use the explicit relays instead of any relay
    if (p2pAddrs.length) {
      addrs = p2pAddrs
    }

    let listenAddrs = []
    addrs.forEach((addr) => {
      const peerMa = `/p2p-circuit/ipfs/${swarm._peerInfo.id.toB58String()}`
      if (addr.toString() === peerMa) {
        listenAddrs.push(multiaddr(peerMa))
        return
      }

      if (!mafmt.Circuit.matches(addr)) {
        if (addr.getPeerId()) {
          // by default we're reachable over any relay
          listenAddrs.push(multiaddr(`/p2p-circuit`).encapsulate(addr))
        } else {
          const ma = `${addr}/ipfs/${swarm._peerInfo.id.toB58String()}`
          listenAddrs.push(multiaddr(`/p2p-circuit`).encapsulate(ma))
        }
      } else {
        listenAddrs.push(addr.encapsulate(`/ipfs/${swarm._peerInfo.id.toB58String()}`))
      }
    })

    callback(null, listenAddrs)
  }

  return listener
}

      };
    };
  }
}, {package:"libp2p-circuit",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\listener.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\hamt-sharding\\src\\bucket.js", {"./consumable-hash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\hamt-sharding\\src\\consumable-hash.js","sparse-array":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\sparse-array\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\hamt-sharding\src\bucket.js
      return function (require, module, exports) {
'use strict'

const SparseArray = require('sparse-array')
const wrapHash = require('./consumable-hash')

const defaultOptions = {
  bits: 8
}

class Bucket {
  constructor (options, parent, posAtParent) {
    this._options = Object.assign({}, defaultOptions, options)
    this._popCount = 0
    this._parent = parent
    this._posAtParent = posAtParent

    if (!this._options.hashFn) {
      throw new Error('please define an options.hashFn')
    }

    // make sure we only wrap options.hashFn once in the whole tree
    if (!this._options.hash) {
      this._options.hash = wrapHash(this._options.hashFn)
    }
    this._children = new SparseArray()
  }

  static isBucket (o) {
    return o instanceof Bucket
  }

  async put (key, value) {
    const place = await this._findNewBucketAndPos(key)

    await place.bucket._putAt(place, key, value)
  }

  async get (key) {
    const child = await this._findChild(key)

    if (child) {
      return child.value
    }
  }

  async del (key) {
    const place = await this._findPlace(key)
    const child = place.bucket._at(place.pos)

    if (child && child.key === key) {
      place.bucket._delAt(place.pos)
    }
  }

  leafCount () {
    return this._children.compactArray().reduce((acc, child) => {
      if (child instanceof Bucket) {
        return acc + child.leafCount()
      }

      return acc + 1
    }, 0)
  }

  childrenCount () {
    return this._children.length
  }

  onlyChild () {
    return this._children.get(0)
  }

  * eachLeafSeries () {
    const children = this._children.compactArray()

    for (const child of children) {
      if (child instanceof Bucket) {
        for (const c2 of child.eachLeafSeries()) {
          yield c2
        }
      } else {
        yield child
      }
    }
  }

  serialize (map, reduce) {
    // serialize to a custom non-sparse representation
    return reduce(this._children.reduce((acc, child, index) => {
      if (child) {
        if (child instanceof Bucket) {
          acc.push(child.serialize(map, reduce))
        } else {
          acc.push(map(child, index))
        }
      }
      return acc
    }, []))
  }

  async asyncTransform (asyncMap, asyncReduce) {
    return asyncTransformBucket(this, asyncMap, asyncReduce)
  }

  toJSON () {
    return this.serialize(mapNode, reduceNodes)
  }

  prettyPrint () {
    return JSON.stringify(this.toJSON(), null, '  ')
  }

  tableSize () {
    return Math.pow(2, this._options.bits)
  }

  async _findChild (key) {
    const result = await this._findPlace(key)
    const child = result.bucket._at(result.pos)

    if (child && child.key === key) {
      return child
    }
  }

  async _findPlace (key) {
    const hashValue = this._options.hash(key)
    const index = await hashValue.take(this._options.bits)

    const child = this._children.get(index)

    if (child instanceof Bucket) {
      return child._findPlace(hashValue)
    }

    return {
      bucket: this,
      pos: index,
      hash: hashValue
    }
  }

  async _findNewBucketAndPos (key) {
    const place = await this._findPlace(key)
    const child = place.bucket._at(place.pos)

    if (child && child.key !== key) {
      // conflict

      const bucket = new Bucket(this._options, place.bucket, place.pos)
      place.bucket._putObjectAt(place.pos, bucket)

      // put the previous value
      const newPlace = await bucket._findPlace(child.hash)
      newPlace.bucket._putAt(newPlace, child.key, child.value)

      return bucket._findNewBucketAndPos(place.hash)
    }

    // no conflict, we found the place
    return place
  }

  _putAt (place, key, value) {
    this._putObjectAt(place.pos, {
      key: key,
      value: value,
      hash: place.hash
    })
  }

  _putObjectAt (pos, object) {
    if (!this._children.get(pos)) {
      this._popCount++
    }
    this._children.set(pos, object)
  }

  _delAt (pos) {
    if (this._children.get(pos)) {
      this._popCount--
    }
    this._children.unset(pos)
    this._level()
  }

  _level () {
    if (this._parent && this._popCount <= 1) {
      if (this._popCount === 1) {
        // remove myself from parent, replacing me with my only child
        const onlyChild = this._children.find(exists)

        if (!(onlyChild instanceof Bucket)) {
          const hash = onlyChild.hash
          hash.untake(this._options.bits)
          const place = {
            pos: this._posAtParent,
            hash: hash
          }
          this._parent._putAt(place, onlyChild.key, onlyChild.value)
        }
      } else {
        this._parent._delAt(this._posAtParent)
      }
    }
  }

  _at (index) {
    return this._children.get(index)
  }
}

function exists (o) {
  return Boolean(o)
}

function mapNode (node, index) {
  return node.key
}

function reduceNodes (nodes) {
  return nodes
}

async function asyncTransformBucket (bucket, asyncMap, asyncReduce) {
  const output = []

  for (const child of bucket._children.compactArray()) {
    if (child instanceof Bucket) {
      await asyncTransformBucket(child, asyncMap, asyncReduce)
    } else {
      const mappedChildren = await asyncMap(child)

      output.push({
        bitField: bucket._children.bitField(),
        children: mappedChildren
      })
    }

    return asyncReduce(output)
  }
}

module.exports = Bucket

      };
    };
  }
}, {package:"hamt-sharding",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\hamt-sharding\\src\\bucket.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\deep-extend\\lib\\deep-extend.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\deep-extend\lib\deep-extend.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/*!
 * @description Recursive object extending
 * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
 * @license MIT
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Viacheslav Lotsmanov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

'use strict';

function isSpecificValue(val) {
	return (
		val instanceof Buffer
		|| val instanceof Date
		|| val instanceof RegExp
	) ? true : false;
}

function cloneSpecificValue(val) {
	if (val instanceof Buffer) {
		var x = Buffer.alloc
			? Buffer.alloc(val.length)
			: new Buffer(val.length);
		val.copy(x);
		return x;
	} else if (val instanceof Date) {
		return new Date(val.getTime());
	} else if (val instanceof RegExp) {
		return new RegExp(val);
	} else {
		throw new Error('Unexpected situation');
	}
}

/**
 * Recursive cloning array.
 */
function deepCloneArray(arr) {
	var clone = [];
	arr.forEach(function (item, index) {
		if (typeof item === 'object' && item !== null) {
			if (Array.isArray(item)) {
				clone[index] = deepCloneArray(item);
			} else if (isSpecificValue(item)) {
				clone[index] = cloneSpecificValue(item);
			} else {
				clone[index] = deepExtend({}, item);
			}
		} else {
			clone[index] = item;
		}
	});
	return clone;
}

function safeGetProperty(object, property) {
	return property === '__proto__' ? undefined : object[property];
}

/**
 * Extening object that entered in first argument.
 *
 * Returns extended object or false if have no target object or incorrect type.
 *
 * If you wish to clone source object (without modify it), just use empty new
 * object as first argument, like this:
 *   deepExtend({}, yourObj_1, [yourObj_N]);
 */
var deepExtend = module.exports = function (/*obj_1, [obj_2], [obj_N]*/) {
	if (arguments.length < 1 || typeof arguments[0] !== 'object') {
		return false;
	}

	if (arguments.length < 2) {
		return arguments[0];
	}

	var target = arguments[0];

	// convert arguments to array and cut off target object
	var args = Array.prototype.slice.call(arguments, 1);

	var val, src, clone;

	args.forEach(function (obj) {
		// skip argument if isn't an object, is null, or is an array
		if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {
			return;
		}

		Object.keys(obj).forEach(function (key) {
			src = safeGetProperty(target, key); // source value
			val = safeGetProperty(obj, key); // new value

			// recursion prevention
			if (val === target) {
				return;

			/**
			 * if new value isn't object then just overwrite by new value
			 * instead of extending.
			 */
			} else if (typeof val !== 'object' || val === null) {
				target[key] = val;
				return;

			// just clone arrays (and recursive clone objects inside)
			} else if (Array.isArray(val)) {
				target[key] = deepCloneArray(val);
				return;

			// custom cloning and overwrite for specific objects
			} else if (isSpecificValue(val)) {
				target[key] = cloneSpecificValue(val);
				return;

			// overwrite by new value if source isn't object or array
			} else if (typeof src !== 'object' || src === null || Array.isArray(src)) {
				target[key] = deepExtend({}, val);
				return;

			// source value and new value is objects both, extending...
			} else {
				target[key] = deepExtend(src, val);
				return;
			}
		});
	});

	return target;
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"deep-extend",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\deep-extend\\lib\\deep-extend.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\hamt-sharding\\src\\index.js", {"./bucket":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\hamt-sharding\\src\\bucket.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\hamt-sharding\src\index.js
      return function (require, module, exports) {
'use strict'

const Bucket = require('./bucket')

module.exports = function createHAMT (options) {
  return new Bucket(options)
}

module.exports.isBucket = Bucket.isBucket

      };
    };
  }
}, {package:"hamt-sharding",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\hamt-sharding\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async-iterator-batch\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\async-iterator-batch\index.js
      return function (require, module, exports) {
'use strict'

async function * batch (source, size) {
  let things = []

  for await (const set of source) {
    things = things.concat(set)

    while (things.length >= size) {
      yield things.slice(0, size)

      things = things.slice(size)
    }
  }

  while (things.length) {
    yield things.slice(0, size)

    things = things.slice(size)
  }
}

module.exports = batch

      };
    };
  }
}, {package:"async-iterator-batch",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async-iterator-batch\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\bl.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","readable-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\readable-browser.js","util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\util\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\bl\bl.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'
var DuplexStream = require('readable-stream').Duplex
  , util         = require('util')

function BufferList (callback) {
  if (!(this instanceof BufferList))
    return new BufferList(callback)

  this._bufs  = []
  this.length = 0

  if (typeof callback == 'function') {
    this._callback = callback

    var piper = function piper (err) {
      if (this._callback) {
        this._callback(err)
        this._callback = null
      }
    }.bind(this)

    this.on('pipe', function onPipe (src) {
      src.on('error', piper)
    })
    this.on('unpipe', function onUnpipe (src) {
      src.removeListener('error', piper)
    })
  } else {
    this.append(callback)
  }

  DuplexStream.call(this)
}


util.inherits(BufferList, DuplexStream)


BufferList.prototype._offset = function _offset (offset) {
  var tot = 0, i = 0, _t
  if (offset === 0) return [ 0, 0 ]
  for (; i < this._bufs.length; i++) {
    _t = tot + this._bufs[i].length
    if (offset < _t || i == this._bufs.length - 1) {
      return [ i, offset - tot ]
    }
    tot = _t
  }
}

BufferList.prototype._reverseOffset = function (blOffset) {
  var bufferId = blOffset[0]
  var offset = blOffset[1]
  for (var i = 0; i < bufferId; i++) {
    offset += this._bufs[i].length
  }
  return offset
}

BufferList.prototype.append = function append (buf) {
  var i = 0

  if (Buffer.isBuffer(buf)) {
    this._appendBuffer(buf)
  } else if (Array.isArray(buf)) {
    for (; i < buf.length; i++)
      this.append(buf[i])
  } else if (buf instanceof BufferList) {
    // unwrap argument into individual BufferLists
    for (; i < buf._bufs.length; i++)
      this.append(buf._bufs[i])
  } else if (buf != null) {
    // coerce number arguments to strings, since Buffer(number) does
    // uninitialized memory allocation
    if (typeof buf == 'number')
      buf = buf.toString()

    this._appendBuffer(Buffer.from(buf))
  }

  return this
}


BufferList.prototype._appendBuffer = function appendBuffer (buf) {
  this._bufs.push(buf)
  this.length += buf.length
}


BufferList.prototype._write = function _write (buf, encoding, callback) {
  this._appendBuffer(buf)

  if (typeof callback == 'function')
    callback()
}


BufferList.prototype._read = function _read (size) {
  if (!this.length)
    return this.push(null)

  size = Math.min(size, this.length)
  this.push(this.slice(0, size))
  this.consume(size)
}


BufferList.prototype.end = function end (chunk) {
  DuplexStream.prototype.end.call(this, chunk)

  if (this._callback) {
    this._callback(null, this.slice())
    this._callback = null
  }
}


BufferList.prototype.get = function get (index) {
  if (index > this.length || index < 0) {
    return undefined
  }
  var offset = this._offset(index)
  return this._bufs[offset[0]][offset[1]]
}


BufferList.prototype.slice = function slice (start, end) {
  if (typeof start == 'number' && start < 0)
    start += this.length
  if (typeof end == 'number' && end < 0)
    end += this.length
  return this.copy(null, 0, start, end)
}


BufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {
  if (typeof srcStart != 'number' || srcStart < 0)
    srcStart = 0
  if (typeof srcEnd != 'number' || srcEnd > this.length)
    srcEnd = this.length
  if (srcStart >= this.length)
    return dst || Buffer.alloc(0)
  if (srcEnd <= 0)
    return dst || Buffer.alloc(0)

  var copy   = !!dst
    , off    = this._offset(srcStart)
    , len    = srcEnd - srcStart
    , bytes  = len
    , bufoff = (copy && dstStart) || 0
    , start  = off[1]
    , l
    , i

  // copy/slice everything
  if (srcStart === 0 && srcEnd == this.length) {
    if (!copy) { // slice, but full concat if multiple buffers
      return this._bufs.length === 1
        ? this._bufs[0]
        : Buffer.concat(this._bufs, this.length)
    }

    // copy, need to copy individual buffers
    for (i = 0; i < this._bufs.length; i++) {
      this._bufs[i].copy(dst, bufoff)
      bufoff += this._bufs[i].length
    }

    return dst
  }

  // easy, cheap case where it's a subset of one of the buffers
  if (bytes <= this._bufs[off[0]].length - start) {
    return copy
      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
      : this._bufs[off[0]].slice(start, start + bytes)
  }

  if (!copy) // a slice, we need something to copy in to
    dst = Buffer.allocUnsafe(len)

  for (i = off[0]; i < this._bufs.length; i++) {
    l = this._bufs[i].length - start

    if (bytes > l) {
      this._bufs[i].copy(dst, bufoff, start)
      bufoff += l
    } else {
      this._bufs[i].copy(dst, bufoff, start, start + bytes)
      bufoff += l
      break
    }

    bytes -= l

    if (start)
      start = 0
  }

  // safeguard so that we don't return uninitialized memory
  if (dst.length > bufoff) return dst.slice(0, bufoff)

  return dst
}

BufferList.prototype.shallowSlice = function shallowSlice (start, end) {
  start = start || 0
  end = typeof end !== 'number' ? this.length : end

  if (start < 0)
    start += this.length
  if (end < 0)
    end += this.length

  if (start === end) {
    return new BufferList()
  }
  var startOffset = this._offset(start)
    , endOffset = this._offset(end)
    , buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1)

  if (endOffset[1] == 0)
    buffers.pop()
  else
    buffers[buffers.length-1] = buffers[buffers.length-1].slice(0, endOffset[1])

  if (startOffset[1] != 0)
    buffers[0] = buffers[0].slice(startOffset[1])

  return new BufferList(buffers)
}

BufferList.prototype.toString = function toString (encoding, start, end) {
  return this.slice(start, end).toString(encoding)
}

BufferList.prototype.consume = function consume (bytes) {
  // first, normalize the argument, in accordance with how Buffer does it
  bytes = Math.trunc(bytes)
  // do nothing if not a positive number
  if (Number.isNaN(bytes) || bytes <= 0) return this

  while (this._bufs.length) {
    if (bytes >= this._bufs[0].length) {
      bytes -= this._bufs[0].length
      this.length -= this._bufs[0].length
      this._bufs.shift()
    } else {
      this._bufs[0] = this._bufs[0].slice(bytes)
      this.length -= bytes
      break
    }
  }
  return this
}


BufferList.prototype.duplicate = function duplicate () {
  var i = 0
    , copy = new BufferList()

  for (; i < this._bufs.length; i++)
    copy.append(this._bufs[i])

  return copy
}


BufferList.prototype._destroy = function _destroy (err, cb) {
  this._bufs.length = 0
  this.length = 0
  cb(err)
}


BufferList.prototype.indexOf = function (search, offset, encoding) {
  if (encoding === undefined && typeof offset === 'string') {
    encoding = offset
    offset = undefined
  }
  if (typeof search === 'function' || Array.isArray(search)) {
    throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.')
  } else if (typeof search === 'number') {
      search = Buffer.from([search])
  } else if (typeof search === 'string') {
    search = Buffer.from(search, encoding)
  } else if (search instanceof BufferList) {
    search = search.slice()
  } else if (!Buffer.isBuffer(search)) {
    search = Buffer.from(search)
  }

  offset = Number(offset || 0)
  if (isNaN(offset)) {
    offset = 0
  }

  if (offset < 0) {
    offset = this.length + offset
  }

  if (offset < 0) {
    offset = 0
  }

  if (search.length === 0) {
    return offset > this.length ? this.length : offset
  }

  var blOffset = this._offset(offset)
  var blIndex = blOffset[0] // index of which internal buffer we're working on
  var buffOffset = blOffset[1] // offset of the internal buffer we're working on

  // scan over each buffer
  for (blIndex; blIndex < this._bufs.length; blIndex++) {
    var buff = this._bufs[blIndex]
    while(buffOffset < buff.length) {
      var availableWindow = buff.length - buffOffset
      if (availableWindow >= search.length) {
        var nativeSearchResult = buff.indexOf(search, buffOffset)
        if (nativeSearchResult !== -1) {
          return this._reverseOffset([blIndex, nativeSearchResult])
        }
        buffOffset = buff.length - search.length + 1 // end of native search window
      } else {
        var revOffset = this._reverseOffset([blIndex, buffOffset])
        if (this._match(revOffset, search)) {
          return revOffset
        }
        buffOffset++
      }
    }
    buffOffset = 0
  }
  return -1
}

BufferList.prototype._match = function(offset, search) {
  if (this.length - offset < search.length) {
    return false
  }
  for (var searchOffset = 0; searchOffset < search.length ; searchOffset++) {
    if(this.get(offset + searchOffset) !== search[searchOffset]){
      return false
    }
  }
  return true
}


;(function () {
  var methods = {
      'readDoubleBE' : 8
    , 'readDoubleLE' : 8
    , 'readFloatBE'  : 4
    , 'readFloatLE'  : 4
    , 'readInt32BE'  : 4
    , 'readInt32LE'  : 4
    , 'readUInt32BE' : 4
    , 'readUInt32LE' : 4
    , 'readInt16BE'  : 2
    , 'readInt16LE'  : 2
    , 'readUInt16BE' : 2
    , 'readUInt16LE' : 2
    , 'readInt8'     : 1
    , 'readUInt8'    : 1
    , 'readIntBE'    : null
    , 'readIntLE'    : null
    , 'readUIntBE'   : null
    , 'readUIntLE'   : null
  }

  for (var m in methods) {
    (function (m) {
      if (methods[m] === null) {
        BufferList.prototype[m] = function (offset, byteLength) {
          return this.slice(offset, offset + byteLength)[m](0, byteLength)
        }
      }
      else {
        BufferList.prototype[m] = function (offset) {
          return this.slice(offset, offset + methods[m])[m](0)
        }
      }
    }(m))
  }
}())


module.exports = BufferList

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"bl",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\bl.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\rabin-wasm\\src\\index.js", {"../dist/rabin-wasm.node.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\rabin-wasm\\dist\\rabin-wasm.js","./rabin":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\rabin-wasm\\src\\rabin.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\rabin-wasm\src\index.js
      return function (require, module, exports) {
const Rabin = require('./rabin')
const getRabin = require('../dist/rabin-wasm.node.js')

const create = async (bits, min, max, windowSize) => {
    const compiled = await getRabin()

    return new Rabin(bits, min, max, windowSize, compiled)
}

module.exports = {
    Rabin,
    create
}

      };
    };
  }
}, {package:"rabin-wasm",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\rabin-wasm\\src\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\mortice\\lib\\constants.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\mortice\lib\constants.js
      return function (require, module, exports) {

module.exports = {
  WORKER_REQUEST_READ_LOCK: 'lock:worker:request-read',
  WORKER_RELEASE_READ_LOCK: 'lock:worker:release-read',
  MASTER_GRANT_READ_LOCK: 'lock:master:grant-read',

  WORKER_REQUEST_WRITE_LOCK: 'lock:worker:request-write',
  WORKER_RELEASE_WRITE_LOCK: 'lock:worker:release-write',
  MASTER_GRANT_WRITE_LOCK: 'lock:master:grant-write'
}

      };
    };
  }
}, {package:"mortice",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\mortice\\lib\\constants.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\index.js", {"./lib/index":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\shortid\index.js
      return function (require, module, exports) {
'use strict';
module.exports = require('./lib/index');

      };
    };
  }
}, {package:"shortid",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\_wordlists.js", {"./wordlists/chinese_simplified.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\chinese_simplified.json","./wordlists/chinese_traditional.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\chinese_traditional.json","./wordlists/czech.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\czech.json","./wordlists/english.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\english.json","./wordlists/french.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\french.json","./wordlists/italian.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\italian.json","./wordlists/japanese.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\japanese.json","./wordlists/korean.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\korean.json","./wordlists/portuguese.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\portuguese.json","./wordlists/spanish.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\spanish.json"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\key-tree\node_modules\bip39\src\_wordlists.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// browserify by default only pulls in files that are hard coded in requires
// In order of last to first in this file, the default wordlist will be chosen
// based on what is present. (Bundles may remove wordlists they don't need)
const wordlists = {};
exports.wordlists = wordlists;
let _default;
exports._default = _default;
try {
    exports._default = _default = require('./wordlists/czech.json');
    wordlists.czech = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/chinese_simplified.json');
    wordlists.chinese_simplified = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/chinese_traditional.json');
    wordlists.chinese_traditional = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/korean.json');
    wordlists.korean = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/french.json');
    wordlists.french = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/italian.json');
    wordlists.italian = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/spanish.json');
    wordlists.spanish = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/japanese.json');
    wordlists.japanese = _default;
    wordlists.JA = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/portuguese.json');
    wordlists.portuguese = _default;
}
catch (err) { }
try {
    exports._default = _default = require('./wordlists/english.json');
    wordlists.english = _default;
    wordlists.EN = _default;
}
catch (err) { }

      };
    };
  }
}, {package:"bip39",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\_wordlists.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\xtend\\mutable.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\xtend\mutable.js
      return function (require, module, exports) {
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

      };
    };
  }
}, {package:"xtend",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\xtend\\mutable.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\mgf1.js", {"./forge":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\forge.js","./util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\node-forge\lib\mgf1.js
      return function (require, module, exports) {
/**
 * Javascript implementation of mask generation function MGF1.
 *
 * @author Stefan Siegl
 * @author Dave Longley
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 * Copyright (c) 2014 Digital Bazaar, Inc.
 */
var forge = require('./forge');
require('./util');

forge.mgf = forge.mgf || {};
var mgf1 = module.exports = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {};

/**
 * Creates a MGF1 mask generation function object.
 *
 * @param md the message digest API to use (eg: forge.md.sha1.create()).
 *
 * @return a mask generation function object.
 */
mgf1.create = function(md) {
  var mgf = {
    /**
     * Generate mask of specified length.
     *
     * @param {String} seed The seed for mask generation.
     * @param maskLen Number of bytes to generate.
     * @return {String} The generated mask.
     */
    generate: function(seed, maskLen) {
      /* 2. Let T be the empty octet string. */
      var t = new forge.util.ByteBuffer();

      /* 3. For counter from 0 to ceil(maskLen / hLen), do the following: */
      var len = Math.ceil(maskLen / md.digestLength);
      for(var i = 0; i < len; i++) {
        /* a. Convert counter to an octet string C of length 4 octets */
        var c = new forge.util.ByteBuffer();
        c.putInt32(i);

        /* b. Concatenate the hash of the seed mgfSeed and C to the octet
         * string T: */
        md.start();
        md.update(seed + c.getBytes());
        t.putBuffer(md.digest());
      }

      /* Output the leading maskLen octets of T as the octet string mask. */
      t.truncate(t.length() - maskLen);
      return t.getBytes();
    }
  };

  return mgf;
};

      };
    };
  }
}, {package:"node-forge",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\node-forge\\lib\\mgf1.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-record\\node_modules\\multihashing-async\\src\\crypto.js", {"./blake":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-record\\node_modules\\multihashing-async\\src\\blake.js","./crypto-sha1-2":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-record\\node_modules\\multihashing-async\\src\\crypto-sha1-2-browser.js","./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-record\\node_modules\\multihashing-async\\src\\utils.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","js-sha3":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\js-sha3\\src\\sha3.js","murmurhash3js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\murmurhash3js\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-record\node_modules\multihashing-async\src\crypto.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const sha3 = require('js-sha3')
const murmur3 = require('murmurhash3js')

const utils = require('./utils')
const sha = require('./crypto-sha1-2')

const toCallback = utils.toCallback
const toBuf = utils.toBuf
const fromString = utils.fromString
const fromNumberTo32BitBuf = utils.fromNumberTo32BitBuf

const dblSha2256 = (buf, cb) => {
  sha.sha2256(buf, (err, firstHash) => {
    if (err) {
      cb(err)
    }
    sha.sha2256((Buffer.from(firstHash)), cb)
  })
}

module.exports = {
  sha1: sha.sha1,
  sha2256: sha.sha2256,
  sha2512: sha.sha2512,
  sha3512: toCallback(toBuf(sha3.sha3_512)),
  sha3384: toCallback(toBuf(sha3.sha3_384)),
  sha3256: toCallback(toBuf(sha3.sha3_256)),
  sha3224: toCallback(toBuf(sha3.sha3_224)),
  shake128: toCallback(toBuf(sha3.shake_128, 128)),
  shake256: toCallback(toBuf(sha3.shake_256, 256)),
  keccak224: toCallback(toBuf(sha3.keccak_224)),
  keccak256: toCallback(toBuf(sha3.keccak_256)),
  keccak384: toCallback(toBuf(sha3.keccak_384)),
  keccak512: toCallback(toBuf(sha3.keccak_512)),
  murmur3128: toCallback(toBuf(fromString(murmur3.x64.hash128))),
  murmur332: toCallback(fromNumberTo32BitBuf(fromString(murmur3.x86.hash32))),
  addBlake: require('./blake'),
  dblSha2256: dblSha2256
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-record\\node_modules\\multihashing-async\\src\\crypto.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\heap\\index.js", {"./lib/heap":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\heap\\lib\\heap.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\heap\index.js
      return function (require, module, exports) {
module.exports = require('./lib/heap');

      };
    };
  }
}, {package:"heap",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\heap\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-pull-stream\\node_modules\\uuid\\v4.js", {"./lib/bytesToUuid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-pull-stream\\node_modules\\uuid\\lib\\bytesToUuid.js","./lib/rng":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-pull-stream\\node_modules\\uuid\\lib\\rng-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\socket.io-pull-stream\node_modules\uuid\v4.js
      return function (require, module, exports) {
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;

      };
    };
  }
}, {package:"uuid",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-pull-stream\\node_modules\\uuid\\v4.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-pull-stream\\node_modules\\uuid\\v1.js", {"./lib/bytesToUuid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-pull-stream\\node_modules\\uuid\\lib\\bytesToUuid.js","./lib/rng":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-pull-stream\\node_modules\\uuid\\lib\\rng-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\socket.io-pull-stream\node_modules\uuid\v1.js
      return function (require, module, exports) {
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;

      };
    };
  }
}, {package:"uuid",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-pull-stream\\node_modules\\uuid\\v1.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-pull-stream\\node_modules\\debug\\src\\common.js", {"ms":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ms\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\socket.io-pull-stream\node_modules\debug\src\common.js
      return function (require, module, exports) {
"use strict";

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = require('ms');
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * Active `debug` instances.
  */

  createDebug.instances = [];
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;

    function debug() {
      // Disabled?
      if (!debug.enabled) {
        return;
      }

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return match;
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = createDebug.enabled(namespace);
    debug.useColors = createDebug.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy;
    debug.extend = extend; // Debug.formatArgs = formatArgs;
    // debug.rawLog = rawLog;
    // env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    createDebug.instances.push(debug);
    return debug;
  }

  function destroy() {
    var index = createDebug.instances.indexOf(this);

    if (index !== -1) {
      createDebug.instances.splice(index, 1);
      return true;
    }

    return false;
  }

  function extend(namespace, delimiter) {
    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < createDebug.instances.length; i++) {
      var instance = createDebug.instances[i];
      instance.enabled = createDebug.enabled(instance.namespace);
    }
  }
  /**
  * Disable debug output.
  *
  * @api public
  */


  function disable() {
    createDebug.enable('');
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;


      };
    };
  }
}, {package:"debug",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-pull-stream\\node_modules\\debug\\src\\common.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-secio\\node_modules\\multihashing-async\\src\\crypto.js", {"./blake":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-secio\\node_modules\\multihashing-async\\src\\blake.js","./crypto-sha1-2":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-secio\\node_modules\\multihashing-async\\src\\crypto-sha1-2-browser.js","./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-secio\\node_modules\\multihashing-async\\src\\utils.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","js-sha3":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\js-sha3\\src\\sha3.js","murmurhash3js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\murmurhash3js\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-secio\node_modules\multihashing-async\src\crypto.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const sha3 = require('js-sha3')
const murmur3 = require('murmurhash3js')

const utils = require('./utils')
const sha = require('./crypto-sha1-2')

const toCallback = utils.toCallback
const toBuf = utils.toBuf
const fromString = utils.fromString
const fromNumberTo32BitBuf = utils.fromNumberTo32BitBuf

const dblSha2256 = (buf, cb) => {
  sha.sha2256(buf, (err, firstHash) => {
    if (err) {
      cb(err)
    }
    sha.sha2256((Buffer.from(firstHash)), cb)
  })
}

module.exports = {
  sha1: sha.sha1,
  sha2256: sha.sha2256,
  sha2512: sha.sha2512,
  sha3512: toCallback(toBuf(sha3.sha3_512)),
  sha3384: toCallback(toBuf(sha3.sha3_384)),
  sha3256: toCallback(toBuf(sha3.sha3_256)),
  sha3224: toCallback(toBuf(sha3.sha3_224)),
  shake128: toCallback(toBuf(sha3.shake_128, 128)),
  shake256: toCallback(toBuf(sha3.shake_256, 256)),
  keccak224: toCallback(toBuf(sha3.keccak_224)),
  keccak256: toCallback(toBuf(sha3.keccak_256)),
  keccak384: toCallback(toBuf(sha3.keccak_384)),
  keccak512: toCallback(toBuf(sha3.keccak_512)),
  murmur3128: toCallback(toBuf(fromString(murmur3.x64.hash128))),
  murmur332: toCallback(fromNumberTo32BitBuf(fromString(murmur3.x86.hash32))),
  addBlake: require('./blake'),
  dblSha2256: dblSha2256
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-secio\\node_modules\\multihashing-async\\src\\crypto.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-parser\\node_modules\\ms\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\socket.io-parser\node_modules\ms\index.js
      return function (require, module, exports) {
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

      };
    };
  }
}, {package:"ms",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-parser\\node_modules\\ms\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-parser\\lib\\keys.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\engine.io-parser\lib\keys.js
      return function (require, module, exports) {

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

      };
    };
  }
}, {package:"engine.io-parser",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-parser\\lib\\keys.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-parser\\lib\\utf8.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\engine.io-parser\lib\utf8.js
      return function (require, module, exports) {
/*! https://mths.be/utf8js v2.1.2 by @mathias */

var stringFromCharCode = String.fromCharCode;

// Taken from https://mths.be/punycode
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	var value;
	var extra;
	while (counter < length) {
		value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// high surrogate, and there is a next character
			extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) { // low surrogate
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// unmatched surrogate; only append this code unit, in case the next
				// code unit is the high surrogate of a surrogate pair
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

// Taken from https://mths.be/punycode
function ucs2encode(array) {
	var length = array.length;
	var index = -1;
	var value;
	var output = '';
	while (++index < length) {
		value = array[index];
		if (value > 0xFFFF) {
			value -= 0x10000;
			output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
			value = 0xDC00 | value & 0x3FF;
		}
		output += stringFromCharCode(value);
	}
	return output;
}

function checkScalarValue(codePoint, strict) {
	if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
		if (strict) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
		return false;
	}
	return true;
}
/*--------------------------------------------------------------------------*/

function createByte(codePoint, shift) {
	return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
}

function encodeCodePoint(codePoint, strict) {
	if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
		return stringFromCharCode(codePoint);
	}
	var symbol = '';
	if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
		symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
	}
	else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
		if (!checkScalarValue(codePoint, strict)) {
			codePoint = 0xFFFD;
		}
		symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
		symbol += createByte(codePoint, 6);
	}
	else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
		symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
		symbol += createByte(codePoint, 12);
		symbol += createByte(codePoint, 6);
	}
	symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
	return symbol;
}

function utf8encode(string, opts) {
	opts = opts || {};
	var strict = false !== opts.strict;

	var codePoints = ucs2decode(string);
	var length = codePoints.length;
	var index = -1;
	var codePoint;
	var byteString = '';
	while (++index < length) {
		codePoint = codePoints[index];
		byteString += encodeCodePoint(codePoint, strict);
	}
	return byteString;
}

/*--------------------------------------------------------------------------*/

function readContinuationByte() {
	if (byteIndex >= byteCount) {
		throw Error('Invalid byte index');
	}

	var continuationByte = byteArray[byteIndex] & 0xFF;
	byteIndex++;

	if ((continuationByte & 0xC0) == 0x80) {
		return continuationByte & 0x3F;
	}

	// If we end up here, it’s not a continuation byte
	throw Error('Invalid continuation byte');
}

function decodeSymbol(strict) {
	var byte1;
	var byte2;
	var byte3;
	var byte4;
	var codePoint;

	if (byteIndex > byteCount) {
		throw Error('Invalid byte index');
	}

	if (byteIndex == byteCount) {
		return false;
	}

	// Read first byte
	byte1 = byteArray[byteIndex] & 0xFF;
	byteIndex++;

	// 1-byte sequence (no continuation bytes)
	if ((byte1 & 0x80) == 0) {
		return byte1;
	}

	// 2-byte sequence
	if ((byte1 & 0xE0) == 0xC0) {
		byte2 = readContinuationByte();
		codePoint = ((byte1 & 0x1F) << 6) | byte2;
		if (codePoint >= 0x80) {
			return codePoint;
		} else {
			throw Error('Invalid continuation byte');
		}
	}

	// 3-byte sequence (may include unpaired surrogates)
	if ((byte1 & 0xF0) == 0xE0) {
		byte2 = readContinuationByte();
		byte3 = readContinuationByte();
		codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
		if (codePoint >= 0x0800) {
			return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
		} else {
			throw Error('Invalid continuation byte');
		}
	}

	// 4-byte sequence
	if ((byte1 & 0xF8) == 0xF0) {
		byte2 = readContinuationByte();
		byte3 = readContinuationByte();
		byte4 = readContinuationByte();
		codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
			(byte3 << 0x06) | byte4;
		if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
			return codePoint;
		}
	}

	throw Error('Invalid UTF-8 detected');
}

var byteArray;
var byteCount;
var byteIndex;
function utf8decode(byteString, opts) {
	opts = opts || {};
	var strict = false !== opts.strict;

	byteArray = ucs2decode(byteString);
	byteCount = byteArray.length;
	byteIndex = 0;
	var codePoints = [];
	var tmp;
	while ((tmp = decodeSymbol(strict)) !== false) {
		codePoints.push(tmp);
	}
	return ucs2encode(codePoints);
}

module.exports = {
	version: '2.1.2',
	encode: utf8encode,
	decode: utf8decode
};

      };
    };
  }
}, {package:"engine.io-parser",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-parser\\lib\\utf8.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\after\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\after\index.js
      return function (require, module, exports) {
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

      };
    };
  }
}, {package:"after",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\after\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\blob\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\blob\index.js
      return function (require, module, exports) {
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :
  typeof WebKitBlobBuilder !== 'undefined' ? WebKitBlobBuilder :
  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :
  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : 
  false;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  return ary.map(function(chunk) {
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      return buf;
    }

    return chunk;
  });
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary).forEach(function(part) {
    bb.append(part);
  });

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  return new Blob(mapArrayBufferViews(ary), options || {});
};

if (typeof Blob !== 'undefined') {
  BlobBuilderConstructor.prototype = Blob.prototype;
  BlobConstructor.prototype = Blob.prototype;
}

module.exports = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

      };
    };
  }
}, {package:"blob",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\blob\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\arraybuffer.slice\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\arraybuffer.slice\index.js
      return function (require, module, exports) {
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

      };
    };
  }
}, {package:"arraybuffer.slice",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\arraybuffer.slice\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\base64-arraybuffer\\lib\\base64-arraybuffer.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\base64-arraybuffer\lib\base64-arraybuffer.js
      return function (require, module, exports) {
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(chars){
  "use strict";

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i+1]);
      encoded3 = chars.indexOf(base64[i+2]);
      encoded4 = chars.indexOf(base64[i+3]);

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

      };
    };
  }
}, {package:"base64-arraybuffer",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\base64-arraybuffer\\lib\\base64-arraybuffer.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\transport.js", {"component-emitter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\component-emitter\\index.js","engine.io-parser":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-parser\\lib\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\engine.io-client\lib\transport.js
      return function (require, module, exports) {
/**
 * Module dependencies.
 */

var parser = require('engine.io-parser');
var Emitter = require('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;
  this.withCredentials = opts.withCredentials;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
  this.forceNode = opts.forceNode;

  // results of ReactNative environment detection
  this.isReactNative = opts.isReactNative;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;
  this.localAddress = opts.localAddress;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' === this.readyState || '' === this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function (packets) {
  if ('open' === this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function (data) {
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

      };
    };
  }
}, {package:"engine.io-client",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\transport.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\node_modules\\debug\\src\\browser.js", {"./debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\node_modules\\debug\\src\\debug.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\engine.io-client\node_modules\debug\src\browser.js
      return function (require, module, exports) {
(function (process){(function (){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"debug",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\node_modules\\debug\\src\\browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\transports\\index.js", {"./polling-jsonp":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\transports\\polling-jsonp.js","./polling-xhr":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\transports\\polling-xhr.js","./websocket":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\transports\\websocket.js","xmlhttprequest-ssl":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\xmlhttprequest.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\engine.io-client\lib\transports\index.js
      return function (require, module, exports) {
/**
 * Module dependencies
 */

var XMLHttpRequest = require('xmlhttprequest-ssl');
var XHR = require('./polling-xhr');
var JSONP = require('./polling-jsonp');
var websocket = require('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling (opts) {
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (typeof location !== 'undefined') {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname !== location.hostname || port !== opts.port;
    xs = opts.secure !== isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

      };
    };
  }
}, {package:"engine.io-client",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\transports\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-pubsub\\src\\message\\rpc.proto.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-pubsub\src\message\rpc.proto.js
      return function (require, module, exports) {
'use strict'
module.exports = `
message RPC {
  repeated SubOpts subscriptions = 1;
  repeated Message msgs = 2;

  message SubOpts {
    optional bool subscribe = 1; // subscribe or unsubcribe
    optional string topicID = 2;
  }

  message Message {
    optional bytes from = 1;
    optional bytes data = 2;
    optional bytes seqno = 3;
    repeated string topicIDs = 4;
    optional bytes signature = 5;
    optional bytes key = 6;
  }
}`

      };
    };
  }
}, {package:"libp2p-pubsub",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-pubsub\\src\\message\\rpc.proto.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-pubsub\\src\\message\\topic-descriptor.proto.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-pubsub\src\message\topic-descriptor.proto.js
      return function (require, module, exports) {
'use strict'
module.exports = `
// topicCID = cid(merkledag_protobuf(topicDescriptor)); (not the topic.name)
message TopicDescriptor {
  optional string name = 1;
  optional AuthOpts auth = 2;
  optional EncOpts enc = 2;

  message AuthOpts {
    optional AuthMode mode = 1;
    repeated bytes keys = 2; // root keys to trust

    enum AuthMode {
      NONE = 0; // no authentication, anyone can publish
      KEY = 1; // only messages signed by keys in the topic descriptor are accepted
      WOT = 2; // web of trust, certificates can allow publisher set to grow
    }
  }

  message EncOpts {
    optional EncMode mode = 1;
    repeated bytes keyHashes = 2; // the hashes of the shared keys used (salted)

    enum EncMode {
      NONE = 0; // no encryption, anyone can read
      SHAREDKEY = 1; // messages are encrypted with shared key
      WOT = 2; // web of trust, certificates can allow publisher set to grow
    }
  }
}`

      };
    };
  }
}, {package:"libp2p-pubsub",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-pubsub\\src\\message\\topic-descriptor.proto.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash.throttle\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\lodash.throttle\index.js
      return function (require, module, exports) {
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = throttle;

      };
    };
  }
}, {package:"lodash.throttle",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash.throttle\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\latency-monitor\\node_modules\\debug\\src\\debug.js", {"ms":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\latency-monitor\\node_modules\\ms\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\latency-monitor\node_modules\debug\src\debug.js
      return function (require, module, exports) {

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

      };
    };
  }
}, {package:"debug",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\latency-monitor\\node_modules\\debug\\src\\debug.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\retimer\\time-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\retimer\time-browser.js
      return function (require, module, exports) {
'use strict'

module.exports = function getTime () {
  return Date.now()
}

      };
    };
  }
}, {package:"retimer",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\retimer\\time-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\node_modules\\semver\\semver.js", {"_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\multistream-select\node_modules\semver\semver.js
      return function (require, module, exports) {
(function (process){(function (){
exports = module.exports = SemVer

var debug
/* istanbul ignore next */
if (typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.unshift('SEMVER')
    console.log.apply(console, args)
  }
} else {
  debug = function () {}
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0'

var MAX_LENGTH = 256
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16

// The actual regexps go on exports.re
var re = exports.re = []
var src = exports.src = []
var t = exports.tokens = {}
var R = 0

function tok (n) {
  t[n] = R++
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

tok('NUMERICIDENTIFIER')
src[t.NUMERICIDENTIFIER] = '0|[1-9]\\d*'
tok('NUMERICIDENTIFIERLOOSE')
src[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+'

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

tok('NONNUMERICIDENTIFIER')
src[t.NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'

// ## Main Version
// Three dot-separated numeric identifiers.

tok('MAINVERSION')
src[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[t.NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[t.NUMERICIDENTIFIER] + ')'

tok('MAINVERSIONLOOSE')
src[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')'

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

tok('PRERELEASEIDENTIFIER')
src[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] +
                            '|' + src[t.NONNUMERICIDENTIFIER] + ')'

tok('PRERELEASEIDENTIFIERLOOSE')
src[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[t.NONNUMERICIDENTIFIER] + ')'

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

tok('PRERELEASE')
src[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))'

tok('PRERELEASELOOSE')
src[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))'

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

tok('BUILDIDENTIFIER')
src[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+'

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

tok('BUILD')
src[t.BUILD] = '(?:\\+(' + src[t.BUILDIDENTIFIER] +
             '(?:\\.' + src[t.BUILDIDENTIFIER] + ')*))'

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

tok('FULL')
tok('FULLPLAIN')
src[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] +
                  src[t.PRERELEASE] + '?' +
                  src[t.BUILD] + '?'

src[t.FULL] = '^' + src[t.FULLPLAIN] + '$'

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
tok('LOOSEPLAIN')
src[t.LOOSEPLAIN] = '[v=\\s]*' + src[t.MAINVERSIONLOOSE] +
                  src[t.PRERELEASELOOSE] + '?' +
                  src[t.BUILD] + '?'

tok('LOOSE')
src[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$'

tok('GTLT')
src[t.GTLT] = '((?:<|>)?=?)'

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
tok('XRANGEIDENTIFIERLOOSE')
src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
tok('XRANGEIDENTIFIER')
src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\*'

tok('XRANGEPLAIN')
src[t.XRANGEPLAIN] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[t.PRERELEASE] + ')?' +
                   src[t.BUILD] + '?' +
                   ')?)?'

tok('XRANGEPLAINLOOSE')
src[t.XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[t.PRERELEASELOOSE] + ')?' +
                        src[t.BUILD] + '?' +
                        ')?)?'

tok('XRANGE')
src[t.XRANGE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAIN] + '$'
tok('XRANGELOOSE')
src[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAINLOOSE] + '$'

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
tok('COERCE')
src[t.COERCE] = '(^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])'
tok('COERCERTL')
re[t.COERCERTL] = new RegExp(src[t.COERCE], 'g')

// Tilde ranges.
// Meaning is "reasonably at or greater than"
tok('LONETILDE')
src[t.LONETILDE] = '(?:~>?)'

tok('TILDETRIM')
src[t.TILDETRIM] = '(\\s*)' + src[t.LONETILDE] + '\\s+'
re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g')
var tildeTrimReplace = '$1~'

tok('TILDE')
src[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$'
tok('TILDELOOSE')
src[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$'

// Caret ranges.
// Meaning is "at least and backwards compatible with"
tok('LONECARET')
src[t.LONECARET] = '(?:\\^)'

tok('CARETTRIM')
src[t.CARETTRIM] = '(\\s*)' + src[t.LONECARET] + '\\s+'
re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g')
var caretTrimReplace = '$1^'

tok('CARET')
src[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$'
tok('CARETLOOSE')
src[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$'

// A simple gt/lt/eq thing, or just "" to indicate "any version"
tok('COMPARATORLOOSE')
src[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + ')$|^$'
tok('COMPARATOR')
src[t.COMPARATOR] = '^' + src[t.GTLT] + '\\s*(' + src[t.FULLPLAIN] + ')$|^$'

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
tok('COMPARATORTRIM')
src[t.COMPARATORTRIM] = '(\\s*)' + src[t.GTLT] +
                      '\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')'

// this one has to use the /g flag
re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g')
var comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
tok('HYPHENRANGE')
src[t.HYPHENRANGE] = '^\\s*(' + src[t.XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[t.XRANGEPLAIN] + ')' +
                   '\\s*$'

tok('HYPHENRANGELOOSE')
src[t.HYPHENRANGELOOSE] = '^\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[t.XRANGEPLAINLOOSE] + ')' +
                        '\\s*$'

// Star ranges basically just allow anything at all.
tok('STAR')
src[t.STAR] = '(<|>)?=?\\s*\\*'

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i])
  if (!re[i]) {
    re[i] = new RegExp(src[i])
  }
}

exports.parse = parse
function parse (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  var r = options.loose ? re[t.LOOSE] : re[t.FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

exports.valid = valid
function valid (version, options) {
  var v = parse(version, options)
  return v ? v.version : null
}

exports.clean = clean
function clean (version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}

exports.SemVer = SemVer

function SemVer (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }
  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version
    } else {
      version = version.version
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version)
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options)
  }

  debug('SemVer', version, options)
  this.options = options
  this.loose = !!options.loose

  var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

  if (!m) {
    throw new TypeError('Invalid Version: ' + version)
  }

  this.raw = version

  // these are actually numbers
  this.major = +m[1]
  this.minor = +m[2]
  this.patch = +m[3]

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version')
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version')
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version')
  }

  // numberify any prerelease numeric ids
  if (!m[4]) {
    this.prerelease = []
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num
        }
      }
      return id
    })
  }

  this.build = m[5] ? m[5].split('.') : []
  this.format()
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch
  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.')
  }
  return this.version
}

SemVer.prototype.toString = function () {
  return this.version
}

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other)
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return this.compareMain(other) || this.comparePre(other)
}

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch)
}

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) {
    return -1
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0
  }

  var i = 0
  do {
    var a = this.prerelease[i]
    var b = other.prerelease[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

SemVer.prototype.compareBuild = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  var i = 0
  do {
    var a = this.build[i]
    var b = other.build[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor = 0
      this.major++
      this.inc('pre', identifier)
      break
    case 'preminor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor++
      this.inc('pre', identifier)
      break
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0
      this.inc('patch', identifier)
      this.inc('pre', identifier)
      break
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier)
      }
      this.inc('pre', identifier)
      break

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) {
        this.major++
      }
      this.minor = 0
      this.patch = 0
      this.prerelease = []
      break
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++
      }
      this.patch = 0
      this.prerelease = []
      break
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++
      }
      this.prerelease = []
      break
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0]
      } else {
        var i = this.prerelease.length
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++
            i = -2
          }
        }
        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0)
        }
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0]
          }
        } else {
          this.prerelease = [identifier, 0]
        }
      }
      break

    default:
      throw new Error('invalid increment argument: ' + release)
  }
  this.format()
  this.raw = this.version
  return this
}

exports.inc = inc
function inc (version, release, loose, identifier) {
  if (typeof (loose) === 'string') {
    identifier = loose
    loose = undefined
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version
  } catch (er) {
    return null
  }
}

exports.diff = diff
function diff (version1, version2) {
  if (eq(version1, version2)) {
    return null
  } else {
    var v1 = parse(version1)
    var v2 = parse(version2)
    var prefix = ''
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre'
      var defaultResult = 'prerelease'
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers

var numeric = /^[0-9]+$/
function compareIdentifiers (a, b) {
  var anum = numeric.test(a)
  var bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

exports.rcompareIdentifiers = rcompareIdentifiers
function rcompareIdentifiers (a, b) {
  return compareIdentifiers(b, a)
}

exports.major = major
function major (a, loose) {
  return new SemVer(a, loose).major
}

exports.minor = minor
function minor (a, loose) {
  return new SemVer(a, loose).minor
}

exports.patch = patch
function patch (a, loose) {
  return new SemVer(a, loose).patch
}

exports.compare = compare
function compare (a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose))
}

exports.compareLoose = compareLoose
function compareLoose (a, b) {
  return compare(a, b, true)
}

exports.compareBuild = compareBuild
function compareBuild (a, b, loose) {
  var versionA = new SemVer(a, loose)
  var versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}

exports.rcompare = rcompare
function rcompare (a, b, loose) {
  return compare(b, a, loose)
}

exports.sort = sort
function sort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compareBuild(a, b, loose)
  })
}

exports.rsort = rsort
function rsort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compareBuild(b, a, loose)
  })
}

exports.gt = gt
function gt (a, b, loose) {
  return compare(a, b, loose) > 0
}

exports.lt = lt
function lt (a, b, loose) {
  return compare(a, b, loose) < 0
}

exports.eq = eq
function eq (a, b, loose) {
  return compare(a, b, loose) === 0
}

exports.neq = neq
function neq (a, b, loose) {
  return compare(a, b, loose) !== 0
}

exports.gte = gte
function gte (a, b, loose) {
  return compare(a, b, loose) >= 0
}

exports.lte = lte
function lte (a, b, loose) {
  return compare(a, b, loose) <= 0
}

exports.cmp = cmp
function cmp (a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError('Invalid operator: ' + op)
  }
}

exports.Comparator = Comparator
function Comparator (comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp
    } else {
      comp = comp.value
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options)
  }

  debug('comparator', comp, options)
  this.options = options
  this.loose = !!options.loose
  this.parse(comp)

  if (this.semver === ANY) {
    this.value = ''
  } else {
    this.value = this.operator + this.semver.version
  }

  debug('comp', this)
}

var ANY = {}
Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
  var m = comp.match(r)

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp)
  }

  this.operator = m[1] !== undefined ? m[1] : ''
  if (this.operator === '=') {
    this.operator = ''
  }

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) {
    this.semver = ANY
  } else {
    this.semver = new SemVer(m[2], this.options.loose)
  }
}

Comparator.prototype.toString = function () {
  return this.value
}

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose)

  if (this.semver === ANY || version === ANY) {
    return true
  }

  if (typeof version === 'string') {
    try {
      version = new SemVer(version, this.options)
    } catch (er) {
      return false
    }
  }

  return cmp(version, this.operator, this.semver, this.options)
}

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required')
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  var rangeTmp

  if (this.operator === '') {
    if (this.value === '') {
      return true
    }
    rangeTmp = new Range(comp.value, options)
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === '') {
    if (comp.value === '') {
      return true
    }
    rangeTmp = new Range(this.value, options)
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>')
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<')
  var sameSemVer = this.semver.version === comp.semver.version
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=')
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'))
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'))

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
}

exports.Range = Range
function Range (range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options
  this.loose = !!options.loose
  this.includePrerelease = !!options.includePrerelease

  // First, split based on boolean or ||
  this.raw = range
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  })

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range)
  }

  this.format()
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim()
  }).join('||').trim()
  return this.range
}

Range.prototype.toString = function () {
  return this.range
}

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose
  range = range.trim()
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
  range = range.replace(hr, hyphenReplace)
  debug('hyphen replace', range)
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
  debug('comparator trim', range, re[t.COMPARATORTRIM])

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[t.TILDETRIM], tildeTrimReplace)

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[t.CARETTRIM], caretTrimReplace)

  // normalize spaces
  range = range.split(/\s+/).join(' ')

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(' ').split(/\s+/)
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    })
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this)

  return set
}

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required')
  }

  return this.set.some(function (thisComparators) {
    return (
      isSatisfiable(thisComparators, options) &&
      range.set.some(function (rangeComparators) {
        return (
          isSatisfiable(rangeComparators, options) &&
          thisComparators.every(function (thisComparator) {
            return rangeComparators.every(function (rangeComparator) {
              return thisComparator.intersects(rangeComparator, options)
            })
          })
        )
      })
    )
  })
}

// take a set of comparators and determine whether there
// exists a version which can satisfy it
function isSatisfiable (comparators, options) {
  var result = true
  var remainingComparators = comparators.slice()
  var testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every(function (otherComparator) {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(' ').trim().split(' ')
  })
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === 'x' || id === '*'
}

// ~, ~> -- > * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x -- > >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x -- > >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x -- > >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 -- > >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 -- > >=1.2.0 <1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(' ')
}

function replaceTilde (comp, options) {
  var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
            ' <' + M + '.' + (+m + 1) + '.0'
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0'
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ -- > * (any, kinda silly)
// ^2, ^2.x, ^2.x.x -- > >=2.0.0 <3.0.0
// ^2.0, ^2.0.x -- > >=2.0.0 <3.0.0
// ^1.2, ^1.2.x -- > >=1.2.0 <2.0.0
// ^1.2.3 -- > >=1.2.3 <2.0.0
// ^1.2.0 -- > >=1.2.0 <2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(' ')
}

function replaceCaret (comp, options) {
  debug('caret', comp, options)
  var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + (+M + 1) + '.0.0'
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0'
      }
    }

    debug('caret return', ret)
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(' ')
}

function replaceXRange (comp, options) {
  comp = comp.trim()
  var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    var xM = isX(M)
    var xm = xM || isX(m)
    var xp = xm || isX(p)
    var anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      ret = gtlt + M + '.' + m + '.' + p + pr
    } else if (xm) {
      ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0' + pr +
        ' <' + M + '.' + (+m + 1) + '.0' + pr
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars (comp, options) {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[t.STAR], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0'
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0'
  } else {
    from = '>=' + from
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0'
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0'
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
  } else {
    to = '<=' + to
  }

  return (from + ' ' + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === 'string') {
    try {
      version = new SemVer(version, this.options)
    } catch (er) {
      return false
    }
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
}

function testSet (set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies
function satisfies (version, range, options) {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying
function maxSatisfying (versions, range, options) {
  var max = null
  var maxSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}

exports.minSatisfying = minSatisfying
function minSatisfying (versions, range, options) {
  var min = null
  var minSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}

exports.minVersion = minVersion
function minVersion (range, loose) {
  range = new Range(range, loose)

  var minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error('Unexpected operation: ' + comparator.operator)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange
function validRange (range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr
function ltr (version, range, options) {
  return outside(version, range, '<', options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr
function gtr (version, range, options) {
  return outside(version, range, '>', options)
}

exports.outside = outside
function outside (version, range, hilo, options) {
  version = new SemVer(version, options)
  range = new Range(range, options)

  var gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    var high = null
    var low = null

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease
function prerelease (version, options) {
  var parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects
function intersects (r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce
function coerce (version, options) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  var match = null
  if (!options.rtl) {
    match = version.match(re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    var next
    while ((next = re[t.COERCERTL].exec(version)) &&
      (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
          next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    re[t.COERCERTL].lastIndex = -1
  }

  if (match === null) {
    return null
  }

  return parse(match[2] +
    '.' + (match[3] || '0') +
    '.' + (match[4] || '0'), options)
}

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"semver",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\node_modules\\semver\\semver.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\util.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debug\\src\\browser.js","pull-length-prefixed":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-length-prefixed\\src\\index.js","pull-stream/pull":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\pull.js","pull-stream/sinks/collect":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\sinks\\collect.js","pull-stream/sources/values":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\sources\\values.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\multistream-select\src\util.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const pull = require('pull-stream/pull')
const values = require('pull-stream/sources/values')
const collect = require('pull-stream/sinks/collect')
const pullLP = require('pull-length-prefixed')
const debug = require('debug')

exports = module.exports

function randomId () {
  return ((~~(Math.random() * 1e9)).toString(36))
}

// prefixes a message with a varint
// TODO this is a pull-stream 'creep' (pull stream to add a byte?')
function encode (msg, callback) {
  pull(
    values(Buffer.isBuffer(msg) ? [msg] : [Buffer.from(msg)]),
    pullLP.encode(),
    collect((err, encoded) => {
      if (err) {
        return callback(err)
      }
      callback(null, encoded[0])
    })
  )
}

exports.writeEncoded = (writer, msg, callback) => {
  encode(msg, (err, msg) => {
    if (err) {
      return callback(err)
    }
    writer.write(msg)
  })
}

function createLogger (type) {
  const rId = randomId()

  function printer (logger) {
    return (msg) => {
      if (Array.isArray(msg)) {
        msg = msg.join(' ')
      }
      logger('(%s) %s', rId, msg)
    }
  }

  const log = printer(debug('mss:' + type))
  log.error = printer(debug('mss:' + type + ':error'))

  return log
}

exports.log = {}

exports.log.dialer = () => {
  return createLogger('dialer\t')
}
exports.log.listener = () => {
  return createLogger('listener\t')
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multistream-select",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\util.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\select.js", {"./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\constants.js","./util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\util.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","err-code":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\err-code\\index.js","pull-handshake":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-handshake\\index.js","pull-length-prefixed":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-length-prefixed\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\multistream-select\src\select.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const handshake = require('pull-handshake')
const pullLP = require('pull-length-prefixed')
const util = require('./util')
const writeEncoded = util.writeEncoded

const errCode = require('err-code')
const { errors } = require('./constants')

function select (multicodec, callback, log) {
  const stream = handshake({
    timeout: 60 * 1000
  }, callback)

  const shake = stream.handshake

  log('writing multicodec: ' + multicodec)
  writeEncoded(shake, Buffer.from(multicodec + '\n'), callback)

  pullLP.decodeFromReader(shake, (err, data) => {
    if (err) {
      return callback(err)
    }
    const protocol = data.toString().slice(0, -1)

    if (protocol !== multicodec) {
      const err = errCode(new Error(`"${multicodec}" not supported`), errors.MULTICODEC_NOT_SUPPORTED)

      return callback(err, shake.rest())
    }

    log('received ack: ' + protocol)
    callback(null, shake.rest())
  })

  return stream
}

module.exports = select

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multistream-select",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\select.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\listener\\ls-handler.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","pull-length-prefixed":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-length-prefixed\\src\\index.js","pull-stream/pull":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\pull.js","pull-stream/sources/values":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\sources\\values.js","varint":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\varint\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\multistream-select\src\listener\ls-handler.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const pull = require('pull-stream/pull')
const values = require('pull-stream/sources/values')
const pullLP = require('pull-length-prefixed')
const varint = require('varint')

function lsHandler (self, conn) {
  const protos = Object.keys(self.handlers).filter((key) => key !== 'ls')

  const nProtos = protos.length
  // total size of the list of protocols, including varint and newline
  const size = protos.reduce((size, proto) => {
    const p = Buffer.from(proto + '\n')
    const el = varint.encodingLength(p.length)
    return size + el
  }, 0)

  const buf = Buffer.concat([
    Buffer.from(varint.encode(nProtos)),
    Buffer.from(varint.encode(size)),
    Buffer.from('\n')
  ])

  const encodedProtos = protos.map((proto) => {
    return Buffer.from(proto + '\n')
  })

  pull(
    values([buf].concat(encodedProtos)),
    pullLP.encode(),
    conn
  )
}

module.exports = lsHandler

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multistream-select",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\listener\\ls-handler.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\listener\\select-handler.js", {"../util.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\util.js","async/some":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\some.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","interface-connection":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\interface-connection\\src\\index.js","pull-handshake":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-handshake\\index.js","pull-length-prefixed":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-length-prefixed\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\multistream-select\src\listener\select-handler.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const handshake = require('pull-handshake')
const lp = require('pull-length-prefixed')
const Connection = require('interface-connection').Connection
const writeEncoded = require('../util.js').writeEncoded
const some = require('async/some')

function selectHandler (rawConn, handlersMap, log) {
  const cb = (err) => {
    // incoming errors are irrelevant for the app
    log.error(err)
  }

  const stream = handshake({ timeout: 60 * 1000 }, cb)
  const shake = stream.handshake

  next()
  return stream

  function next () {
    lp.decodeFromReader(shake, (err, data) => {
      if (err) {
        return cb(err)
      }
      log('received:', data.toString())
      const protocol = data.toString().slice(0, -1)

      matcher(protocol, handlersMap, (err, result) => {
        if (err) {
          return cb(err)
        }
        const key = result

        if (key) {
          log('send ack back of: ' + protocol)
          writeEncoded(shake, data, cb)

          const conn = new Connection(shake.rest(), rawConn)
          handlersMap[key].handlerFunc(protocol, conn)
        } else {
          log('not supported protocol: ' + protocol)
          writeEncoded(shake, Buffer.from('na\n'))
          next()
        }
      })
    })
  }
}

function matcher (protocol, handlers, callback) {
  const supportedProtocols = Object.keys(handlers)
  let supportedProtocol = false

  some(supportedProtocols,
    (sp, cb) => {
      handlers[sp].matchFunc(sp, protocol, (err, result) => {
        if (err) {
          return cb(err)
        }
        if (result) {
          supportedProtocol = sp
        }
        cb()
      })
    },
    (err) => {
      if (err) {
        return callback(err)
      }
      callback(null, supportedProtocol)
    }
  )
}

module.exports = selectHandler

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multistream-select",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multistream-select\\src\\listener\\select-handler.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\protocol\\index.js", {"protons":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\protons\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-circuit\src\protocol\index.js
      return function (require, module, exports) {
'use strict'
const protobuf = require('protons')
module.exports = protobuf(`
message CircuitRelay {

  enum Status {
    SUCCESS                    = 100;
    HOP_SRC_ADDR_TOO_LONG      = 220;
    HOP_DST_ADDR_TOO_LONG      = 221;
    HOP_SRC_MULTIADDR_INVALID  = 250;
    HOP_DST_MULTIADDR_INVALID  = 251;
    HOP_NO_CONN_TO_DST         = 260;
    HOP_CANT_DIAL_DST          = 261;
    HOP_CANT_OPEN_DST_STREAM   = 262;
    HOP_CANT_SPEAK_RELAY       = 270;
    HOP_CANT_RELAY_TO_SELF     = 280;
    STOP_SRC_ADDR_TOO_LONG     = 320;
    STOP_DST_ADDR_TOO_LONG     = 321;
    STOP_SRC_MULTIADDR_INVALID = 350;
    STOP_DST_MULTIADDR_INVALID = 351;
    STOP_RELAY_REFUSED         = 390;
    MALFORMED_MESSAGE          = 400;
  }

  enum Type { // RPC identifier, either HOP, STOP or STATUS
    HOP = 1;
    STOP = 2;
    STATUS = 3;
    CAN_HOP = 4;
  }

  message Peer {
    required bytes id = 1;    // peer id
    repeated bytes addrs = 2; // peer's known addresses
  }

  optional Type type = 1;     // Type of the message

  optional Peer srcPeer = 2;  // srcPeer and dstPeer are used when Type is HOP or STATUS
  optional Peer dstPeer = 3;

  optional Status code = 4;   // Status code, used when Type is STATUS
}
`)

      };
    };
  }
}, {package:"libp2p-circuit",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\protocol\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\multicodec.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-circuit\src\multicodec.js
      return function (require, module, exports) {
'use strict'

module.exports = {
  relay: '/libp2p/circuit/relay/0.1.0'
}

      };
    };
  }
}, {package:"libp2p-circuit",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\multicodec.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\circuit\\stream-handler.js", {"debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debug\\src\\browser.js","pull-handshake":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-handshake\\index.js","pull-length-prefixed":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-length-prefixed\\src\\index.js","pull-stream/pull":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\pull.js","pull-stream/sinks/collect":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\sinks\\collect.js","pull-stream/sources/empty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\sources\\empty.js","pull-stream/sources/values":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\sources\\values.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-circuit\src\circuit\stream-handler.js
      return function (require, module, exports) {
'use strict'

const values = require('pull-stream/sources/values')
const collect = require('pull-stream/sinks/collect')
const empty = require('pull-stream/sources/empty')
const pull = require('pull-stream/pull')
const lp = require('pull-length-prefixed')
const handshake = require('pull-handshake')

const debug = require('debug')
const log = debug('libp2p:circuit:stream-handler')
log.err = debug('libp2p:circuit:error:stream-handler')

class StreamHandler {
  /**
   * Create a stream handler for connection
   *
   * @param {Connection} conn - connection to read/write
   * @param {Function|undefined} cb - handshake callback called on error
   * @param {Number} timeout - handshake timeout
   * @param {Number} maxLength - max bytes length of message
   */
  constructor (conn, cb, timeout, maxLength) {
    this.conn = conn
    this.stream = null
    this.shake = null
    this.timeout = cb || 1000 * 60
    this.maxLength = maxLength || 4096

    if (typeof cb === 'function') {
      this.timeout = timeout || 1000 * 60
    }

    this.stream = handshake({ timeout: this.timeout }, cb)
    this.shake = this.stream.handshake

    pull(this.stream, conn, this.stream)
  }

  isValid () {
    return this.conn && this.shake && this.stream
  }

  /**
   * Read and decode message
   *
   * @param {Function} cb
   * @returns {void|Function}
   */
  read (cb) {
    if (!this.isValid()) {
      return cb(new Error(`handler is not in a valid state`))
    }

    lp.decodeFromReader(
      this.shake,
      { maxLength: this.maxLength },
      (err, msg) => {
        if (err) {
          log.err(err)
          // this.shake.abort(err)
          return cb(err)
        }

        return cb(null, msg)
      })
  }

  /**
   * Encode and write array of buffers
   *
   * @param {Buffer[]} msg
   * @param {Function} [cb]
   * @returns {Function}
   */
  write (msg, cb) {
    cb = cb || (() => {})

    if (!this.isValid()) {
      return cb(new Error(`handler is not in a valid state`))
    }

    pull(
      values([msg]),
      lp.encode(),
      collect((err, encoded) => {
        if (err) {
          log.err(err)
          this.shake.abort(err)
          return cb(err)
        }

        encoded.forEach((e) => this.shake.write(e))
        cb()
      })
    )
  }

  /**
   * Get the raw Connection
   *
   * @returns {null|Connection|*}
   */
  getRawConn () {
    return this.conn
  }

  /**
   * Return the handshake rest stream and invalidate handler
   *
   * @return {*|{source, sink}}
   */
  rest () {
    const rest = this.shake.rest()

    this.conn = null
    this.stream = null
    this.shake = null
    return rest
  }

  /**
   * Close the stream
   *
   * @returns {undefined}
   */
  close () {
    if (!this.isValid()) {
      return
    }

    // close stream
    pull(
      empty(),
      this.rest()
    )
  }
}

module.exports = StreamHandler

      };
    };
  }
}, {package:"libp2p-circuit",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\circuit\\stream-handler.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\circuit\\stop.js", {"../protocol":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\protocol\\index.js","./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\circuit\\utils.js","async/series":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\series.js","async/setImmediate":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\setImmediate.js","debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debug\\src\\browser.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","interface-connection":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\interface-connection\\src\\index.js","peer-info":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-info\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-circuit\src\circuit\stop.js
      return function (require, module, exports) {
'use strict'

const setImmediate = require('async/setImmediate')

const EE = require('events').EventEmitter
const Connection = require('interface-connection').Connection
const utilsFactory = require('./utils')
const PeerInfo = require('peer-info')
const proto = require('../protocol').CircuitRelay
const series = require('async/series')

const debug = require('debug')

const log = debug('libp2p:circuit:stop')
log.err = debug('libp2p:circuit:error:stop')

class Stop extends EE {
  constructor (swarm) {
    super()
    this.swarm = swarm
    this.utils = utilsFactory(swarm)
  }

  /**
   * Handle the incoming STOP message
   *
   * @param {{}} msg  - the parsed protobuf message
   * @param {StreamHandler} sh  - the stream handler wrapped connection
   * @param {Function} callback  - callback
   * @returns {undefined}
   */
  handle (msg, sh, callback) {
    callback = callback || (() => {})

    series([
      (cb) => this.utils.validateAddrs(msg, sh, proto.Type.STOP, cb),
      (cb) => this.utils.writeResponse(sh, proto.Status.Success, cb)
    ], (err) => {
      if (err) {
        // we don't return the error here,
        // since multistream select don't expect one
        callback()
        return log(err)
      }

      const peerInfo = new PeerInfo(this.utils.peerIdFromId(msg.srcPeer.id))
      msg.srcPeer.addrs.forEach((addr) => peerInfo.multiaddrs.add(addr))
      const newConn = new Connection(sh.rest())
      newConn.setPeerInfo(peerInfo)
      setImmediate(() => this.emit('connection', newConn))
      callback(newConn)
    })
  }
}

module.exports = Stop

      };
    };
  }
}, {package:"libp2p-circuit",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\circuit\\stop.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\circuit\\hop.js", {"../protocol":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\protocol\\index.js","./../multicodec":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\multicodec.js","./stream-handler":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\circuit\\stream-handler.js","./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\circuit\\utils.js","async/series":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\series.js","async/setImmediate":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\setImmediate.js","async/waterfall":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\waterfall.js","debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debug\\src\\browser.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","multiaddr":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multiaddr\\src\\index.js","once":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\once\\once.js","peer-id":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-id\\src\\index.js","peer-info":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\peer-info\\src\\index.js","pull-stream/pull":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pull-stream\\pull.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-circuit\src\circuit\hop.js
      return function (require, module, exports) {
'use strict'

const pull = require('pull-stream/pull')
const debug = require('debug')
const PeerInfo = require('peer-info')
const PeerId = require('peer-id')
const EE = require('events').EventEmitter
const once = require('once')
const utilsFactory = require('./utils')
const StreamHandler = require('./stream-handler')
const proto = require('../protocol').CircuitRelay
const multiaddr = require('multiaddr')
const series = require('async/series')
const waterfall = require('async/waterfall')
const setImmediate = require('async/setImmediate')

const multicodec = require('./../multicodec')

const log = debug('libp2p:circuit:relay')
log.err = debug('libp2p:circuit:error:relay')

class Hop extends EE {
  /**
   * Construct a Circuit object
   *
   * This class will handle incoming circuit connections and
   * either start a relay or hand the relayed connection to
   * the swarm
   *
   * @param {Swarm} swarm
   * @param {Object} options
   */
  constructor (swarm, options) {
    super()
    this.swarm = swarm
    this.peerInfo = this.swarm._peerInfo
    this.utils = utilsFactory(swarm)
    this.config = options || { active: false, enabled: false }
    this.active = this.config.active
  }

  /**
   * Handle the relay message
   *
   * @param {CircuitRelay} message
   * @param {StreamHandler} sh
   * @returns {*}
   */
  handle (message, sh) {
    if (!this.config.enabled) {
      this.utils.writeResponse(
        sh,
        proto.Status.HOP_CANT_SPEAK_RELAY)
      return sh.close()
    }

    // check if message is `CAN_HOP`
    if (message.type === proto.Type.CAN_HOP) {
      this.utils.writeResponse(
        sh,
        proto.Status.SUCCESS)
      return sh.close()
    }

    // This is a relay request - validate and create a circuit
    let srcPeerId = null
    let dstPeerId = null
    try {
      srcPeerId = PeerId.createFromBytes(message.srcPeer.id).toB58String()
      dstPeerId = PeerId.createFromBytes(message.dstPeer.id).toB58String()
    } catch (err) {
      log.err(err)

      if (!srcPeerId) {
        this.utils.writeResponse(
          sh,
          proto.Status.HOP_SRC_MULTIADDR_INVALID)
        return sh.close()
      }

      if (!dstPeerId) {
        this.utils.writeResponse(
          sh,
          proto.Status.HOP_DST_MULTIADDR_INVALID)
        return sh.close()
      }
    }

    if (srcPeerId === dstPeerId) {
      this.utils.writeResponse(
        sh,
        proto.Status.HOP_CANT_RELAY_TO_SELF)
      return sh.close()
    }

    if (!message.dstPeer.addrs.length) {
      // TODO: use encapsulate here
      const addr = multiaddr(`/p2p-circuit/ipfs/${dstPeerId}`).buffer
      message.dstPeer.addrs.push(addr)
    }

    log('trying to establish a circuit: %s <-> %s', srcPeerId, dstPeerId)
    const noPeer = () => {
      // log.err(err)
      this.utils.writeResponse(
        sh,
        proto.Status.HOP_NO_CONN_TO_DST)
      return sh.close()
    }

    const isConnected = (cb) => {
      let dstPeer
      try {
        dstPeer = this.swarm._peerBook.get(dstPeerId)
        if (!dstPeer.isConnected() && !this.active) {
          const err = new Error(`No Connection to peer ${dstPeerId}`)
          noPeer(err)
          return cb(err)
        }
      } catch (err) {
        if (!this.active) {
          noPeer(err)
          return cb(err)
        }
      }
      cb()
    }

    series([
      (cb) => this.utils.validateAddrs(message, sh, proto.Type.HOP, cb),
      (cb) => isConnected(cb),
      (cb) => this._circuit(sh, message, cb)
    ], (err) => {
      if (err) {
        log.err(err)
        sh.close()
        return setImmediate(() => this.emit('circuit:error', err))
      }
      setImmediate(() => this.emit('circuit:success'))
    })
  }

  /**
   * Connect to STOP
   *
   * @param {PeerInfo} peer
   * @param {StreamHandler} srcSh
   * @param {function} callback
   * @returns {void}
   */
  _connectToStop (peer, srcSh, callback) {
    this._dialPeer(peer, (err, dstConn) => {
      if (err) {
        this.utils.writeResponse(
          srcSh,
          proto.Status.HOP_CANT_DIAL_DST)
        log.err(err)
        return callback(err)
      }

      return this.utils.writeResponse(
        srcSh,
        proto.Status.SUCCESS,
        (err) => {
          if (err) {
            log.err(err)
            return callback(err)
          }
          return callback(null, dstConn)
        })
    })
  }

  /**
   * Negotiate STOP
   *
   * @param {StreamHandler} dstSh
   * @param {StreamHandler} srcSh
   * @param {CircuitRelay} message
   * @param {function} callback
   * @returns {void}
   */
  _negotiateStop (dstSh, srcSh, message, callback) {
    const stopMsg = Object.assign({}, message, {
      type: proto.Type.STOP // change the message type
    })
    dstSh.write(proto.encode(stopMsg),
      (err) => {
        if (err) {
          this.utils.writeResponse(
            srcSh,
            proto.Status.HOP_CANT_OPEN_DST_STREAM)
          log.err(err)
          return callback(err)
        }

        // read response from STOP
        dstSh.read((err, msg) => {
          if (err) {
            log.err(err)
            return callback(err)
          }

          const message = proto.decode(msg)
          if (message.code !== proto.Status.SUCCESS) {
            return callback(new Error(`Unable to create circuit!`))
          }

          return callback(null, msg)
        })
      })
  }

  /**
   * Attempt to make a circuit from A <-> R <-> B where R is this relay
   *
   * @param {StreamHandler} srcSh - the source stream handler
   * @param {CircuitRelay} message - the message with the src and dst entries
   * @param {Function} callback - callback to signal success or failure
   * @returns {void}
   * @private
   */
  _circuit (srcSh, message, callback) {
    let dstSh = null
    waterfall([
      (cb) => this._connectToStop(message.dstPeer, srcSh, cb),
      (_dstConn, cb) => {
        dstSh = new StreamHandler(_dstConn)
        this._negotiateStop(dstSh, srcSh, message, cb)
      }
    ], (err) => {
      if (err) {
        // close/end the source stream if there was an error
        if (srcSh) {
          srcSh.close()
        }

        if (dstSh) {
          dstSh.close()
        }
        return callback(err)
      }

      const src = srcSh.rest()
      const dst = dstSh.rest()

      const srcIdStr = PeerId.createFromBytes(message.srcPeer.id).toB58String()
      const dstIdStr = PeerId.createFromBytes(message.dstPeer.id).toB58String()

      // circuit the src and dst streams
      pull(
        src,
        dst,
        src
      )
      log('circuit %s <-> %s established', srcIdStr, dstIdStr)
      callback()
    })
  }

  /**
   * Dial the dest peer and create a circuit
   *
   * @param {Multiaddr} dstPeer
   * @param {Function} callback
   * @returns {void}
   * @private
   */
  _dialPeer (dstPeer, callback) {
    const peerInfo = new PeerInfo(PeerId.createFromBytes(dstPeer.id))
    dstPeer.addrs.forEach((a) => peerInfo.multiaddrs.add(a))
    this.swarm.dial(peerInfo, multicodec.relay, once((err, conn) => {
      if (err) {
        log.err(err)
        return callback(err)
      }

      callback(null, conn)
    }))
  }
}

module.exports = Hop

      };
    };
  }
}, {package:"libp2p-circuit",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-circuit\\src\\circuit\\hop.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\sparse-array\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\sparse-array\index.js
      return function (require, module, exports) {
'use strict'

// JS treats subjects of bitwise operators as SIGNED 32 bit numbers,
// which means the maximum amount of bits we can store inside each byte
// is 7..
const BITS_PER_BYTE = 7

module.exports = class SparseArray {
  constructor () {
    this._bitArrays = []
    this._data = []
    this._length = 0
    this._changedLength = false
    this._changedData = false
  }

  set (index, value) {
    let pos = this._internalPositionFor(index, false)
    if (value === undefined) {
      // unsetting
      if (pos !== -1) {
        // remove item from bit array and array itself
        this._unsetInternalPos(pos)
        this._unsetBit(index)
        this._changedLength = true
        this._changedData = true
      }
    } else {
      let needsSort = false
      if (pos === -1) {
        pos = this._data.length
        this._setBit(index)
        this._changedData = true
      } else {
        needsSort = true
      }
      this._setInternalPos(pos, index, value, needsSort)
      this._changedLength = true
    }
  }

  unset (index) {
    this.set(index, undefined)
  }

  get (index) {
    this._sortData()
    const pos = this._internalPositionFor(index, true)
    if (pos === -1) {
      return undefined
    }
    return this._data[pos][1]
  }

  push (value) {
    this.set(this.length, value)
    return this.length
  }

  get length () {
    this._sortData()
    if (this._changedLength) {
      const last = this._data[this._data.length - 1]
      this._length = last ? last[0] + 1 : 0
      this._changedLength = false
    }
    return this._length
  }

  forEach (iterator) {
    let i = 0
    while(i < this.length) {
      iterator(this.get(i), i, this)
      i++
    }
  }

  map (iterator) {
    let i = 0
    let mapped = new Array(this.length)
    while(i < this.length) {
      mapped[i] = iterator(this.get(i), i, this)
      i++
    }
    return mapped
  }

  reduce (reducer, initialValue) {
    let i = 0
    let acc = initialValue
    while(i < this.length) {
      const value = this.get(i)
      acc = reducer(acc, value, i)
      i++
    }
    return acc
  }

  find (finder) {
    let i = 0, found, last
    while ((i < this.length) && !found) {
      last = this.get(i)
      found = finder(last)
      i++
    }
    return found ? last : undefined
  }

  _internalPositionFor (index, noCreate) {
    const bytePos = this._bytePosFor(index, noCreate)
    if (bytePos >= this._bitArrays.length) {
      return -1
    }
    const byte = this._bitArrays[bytePos]
    const bitPos = index - bytePos * BITS_PER_BYTE
    const exists = (byte & (1 << bitPos)) > 0
    if (!exists) {
      return -1
    }
    const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0)

    const mask = ~(0xffffffff << (bitPos + 1))
    const bytePopCount = popCount(byte & mask)
    const arrayPos = previousPopCount + bytePopCount - 1
    return arrayPos
  }

  _bytePosFor (index, noCreate) {
    const bytePos = Math.floor(index / BITS_PER_BYTE)
    const targetLength = bytePos + 1
    while (!noCreate && this._bitArrays.length < targetLength) {
      this._bitArrays.push(0)
    }
    return bytePos
  }

  _setBit (index) {
    const bytePos = this._bytePosFor(index, false)
    this._bitArrays[bytePos] |= (1 << (index - (bytePos * BITS_PER_BYTE)))
  }

  _unsetBit(index) {
    const bytePos = this._bytePosFor(index, false)
    this._bitArrays[bytePos] &= ~(1 << (index - (bytePos * BITS_PER_BYTE)))
  }

  _setInternalPos(pos, index, value, needsSort) {
    const data =this._data
    const elem = [index, value]
    if (needsSort) {
      this._sortData()
      data[pos] = elem
    } else {
      // new element. just shove it into the array
      // but be nice about where we shove it
      // in order to make sorting it later easier
      if (data.length) {
        if (data[data.length - 1][0] >= index) {
          data.push(elem)
        } else if (data[0][0] <= index) {
          data.unshift(elem)
        } else {
          const randomIndex = Math.round(data.length / 2)
          this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex))
        }
      } else {
        this._data.push(elem)
      }
      this._changedData = true
      this._changedLength = true
    }
  }

  _unsetInternalPos (pos) {
    this._data.splice(pos, 1)
  }

  _sortData () {
    if (this._changedData) {
      this._data.sort(sortInternal)
    }

    this._changedData = false
  }

  bitField () {
    const bytes = []
    let pendingBitsForResultingByte = 8
    let pendingBitsForNewByte = 0
    let resultingByte = 0
    let newByte
    const pending = this._bitArrays.slice()
    while (pending.length || pendingBitsForNewByte) {
      if (pendingBitsForNewByte === 0) {
        newByte = pending.shift()
        pendingBitsForNewByte = 7
      }

      const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte)
      const mask = ~(0b11111111 << usingBits)
      const masked = newByte & mask
      resultingByte |= masked << (8 - pendingBitsForResultingByte)
      newByte = newByte >>> usingBits
      pendingBitsForNewByte -= usingBits
      pendingBitsForResultingByte -= usingBits

      if (!pendingBitsForResultingByte || (!pendingBitsForNewByte && !pending.length)) {
        bytes.push(resultingByte)
        resultingByte = 0
        pendingBitsForResultingByte = 8
      }
    }

    // remove trailing zeroes
    for(var i = bytes.length - 1; i > 0; i--) {
      const value = bytes[i]
      if (value === 0) {
        bytes.pop()
      } else {
        break
      }
    }

    return bytes
  }

  compactArray () {
    this._sortData()
    return this._data.map(valueOnly)
  }
}

function popCountReduce (count, byte) {
  return count + popCount(byte)
}

function popCount(_v) {
  let v = _v
  v = v - ((v >> 1) & 0x55555555)                    // reuse input as temporary
  v = (v & 0x33333333) + ((v >> 2) & 0x33333333)     // temp
  return ((v + (v >> 4) & 0xF0F0F0F) * 0x1010101) >> 24
}

function sortInternal (a, b) {
  return a[0] - b[0]
}

function valueOnly (elem) {
  return elem[1]
}
      };
    };
  }
}, {package:"sparse-array",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\sparse-array\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\hamt-sharding\\src\\consumable-hash.js", {"../../is-buffer/index.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-buffer\\index.js","./consumable-buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\hamt-sharding\\src\\consumable-buffer.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\hamt-sharding\src\consumable-hash.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const ConsumableBuffer = require('./consumable-buffer')

module.exports = function wrapHash (hashFn) {
  return function hashing (value) {
    if (value instanceof InfiniteHash) {
      // already a hash. return it
      return value
    } else {
      return new InfiniteHash(value, hashFn)
    }
  }
}

class InfiniteHash {
  constructor (value, hashFn) {
    if ((typeof value) !== 'string' && !Buffer.isBuffer(value)) {
      throw new Error('can only hash strings or buffers')
    }
    this._value = value
    this._hashFn = hashFn
    this._depth = -1
    this._availableBits = 0
    this._currentBufferIndex = 0
    this._buffers = []
  }

  async take (bits) {
    let pendingBits = bits

    while (this._availableBits < pendingBits) {
      await this._produceMoreBits()
    }

    let result = 0

    while (pendingBits > 0) {
      const hash = this._buffers[this._currentBufferIndex]
      const available = Math.min(hash.availableBits(), pendingBits)
      const took = hash.take(available)
      result = (result << available) + took
      pendingBits -= available
      this._availableBits -= available

      if (hash.availableBits() === 0) {
        this._currentBufferIndex++
      }
    }

    return result
  }

  untake (bits) {
    let pendingBits = bits

    while (pendingBits > 0) {
      const hash = this._buffers[this._currentBufferIndex]
      const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits)
      hash.untake(availableForUntake)
      pendingBits -= availableForUntake
      this._availableBits += availableForUntake

      if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {
        this._depth--
        this._currentBufferIndex--
      }
    }
  }

  async _produceMoreBits () {
    this._depth++

    const value = this._depth ? this._value + this._depth : this._value
    const hashValue = await this._hashFn(value)
    const buffer = new ConsumableBuffer(hashValue)

    this._buffers.push(buffer)
    this._availableBits += buffer.availableBits()
  }
}

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

      };
    };
  }
}, {package:"hamt-sharding",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\hamt-sharding\\src\\consumable-hash.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\readable-browser.js", {"./lib/_stream_duplex.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\_stream_duplex.js","./lib/_stream_passthrough.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\_stream_passthrough.js","./lib/_stream_readable.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\_stream_readable.js","./lib/_stream_transform.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\_stream_transform.js","./lib/_stream_writable.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\_stream_writable.js","./lib/internal/streams/end-of-stream.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\end-of-stream.js","./lib/internal/streams/pipeline.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\pipeline.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\bl\node_modules\readable-stream\readable-browser.js
      return function (require, module, exports) {
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\readable-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\rabin-wasm\\src\\rabin.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\rabin-wasm\src\rabin.js
      return function (require, module, exports) {
/**
 * Rabin fingerprinting
 *
 * @class Rabin
 */
class Rabin {
    /**
     * Creates an instance of Rabin.
     * @param {number} [bits=12]
     * @param {number} [min=8 * 1024]
     * @param {number} [max=32 * 1024]
     * @param { __import__("./../dist/rabin").default } asModule
     * @memberof Rabin
     */
    constructor(bits = 12, min = 8 * 1024, max = 32 * 1024, windowSize = 64, asModule) {
        this.bits = bits
        this.min = min
        this.max = max
        this.asModule = asModule
        this.rabin = new asModule.Rabin(bits, min, max, windowSize)
    }

    /**
     * Fingerprints the buffer
     *
     * @param {Uint8Array} buf
     * @returns {Array<number>}
     * @memberof Rabin
     */
    fingerprint(buf) {
        const lengths = new Int32Array(Math.ceil(buf.length/this.min))
        const lengthsPtr = this.asModule.newArray(lengths)
        const pointer = this.asModule.newArray(buf)

        // run finderprint
        this.rabin.fingerprint(pointer, lengthsPtr)

        const processed = this.asModule.getArray(Int32Array, lengthsPtr)

        //free memory
        this.asModule.freeArray(lengthsPtr)
        this.asModule.freeArray(pointer)

        // TODO: remove this. @see https://github.com/ipfs/js-ipfs/issues/2118#issuecomment-497722625
        // clean extra 0s in the array
        const cleanArr = []
        for (let i = 0; i < processed.length; i++) {
            if(processed[i] === 0) break
            cleanArr[i] = processed[i];
        }

        return cleanArr
    }
}

module.exports = Rabin
      };
    };
  }
}, {package:"rabin-wasm",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\rabin-wasm\\src\\rabin.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\rabin-wasm\\dist\\rabin-wasm.js", {"assemblyscript/lib/loader":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assemblyscript\\lib\\loader\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\rabin-wasm\dist\rabin-wasm.js
      return function (require, module, exports) {

const { instantiateStreaming } = require("assemblyscript/lib/loader");

loadWebAssembly.supported = typeof WebAssembly !== 'undefined'

function loadWebAssembly (imp = {}) {
  if (!loadWebAssembly.supported) return null
  
  var wasm = new Uint8Array([0,97,115,109,1,0,0,0,1,90,16,96,0,0,96,2,127,127,1,127,96,4,127,127,127,127,0,96,1,127,1,127,96,3,127,127,127,0,96,1,126,1,127,96,2,126,126,1,126,96,5,127,127,127,127,127,1,127,96,3,127,127,126,0,96,2,127,127,1,126,96,3,127,127,127,1,127,96,1,127,0,96,2,127,127,0,96,1,127,1,126,96,2,127,126,0,96,0,1,127,2,13,1,3,101,110,118,5,97,98,111,114,116,0,2,3,57,56,3,3,12,3,3,15,5,6,1,8,4,1,9,11,7,4,10,10,11,0,0,0,3,12,3,12,3,12,13,14,13,14,13,14,13,14,13,14,13,14,13,14,13,14,13,14,13,14,13,14,13,14,13,14,13,14,4,4,1,112,0,1,5,3,1,0,1,6,26,5,127,1,65,0,11,127,1,65,0,11,127,1,65,0,11,127,1,65,0,11,127,1,65,0,11,7,253,6,44,6,109,101,109,111,114,121,2,0,5,116,97,98,108,101,1,0,6,100,101,103,114,101,101,0,7,3,109,111,100,0,8,16,82,97,98,105,110,35,103,101,116,58,119,105,110,100,111,119,0,23,16,82,97,98,105,110,35,115,101,116,58,119,105,110,100,111,119,0,24,21,82,97,98,105,110,35,103,101,116,58,119,105,110,100,111,119,95,115,105,122,101,0,25,21,82,97,98,105,110,35,115,101,116,58,119,105,110,100,111,119,95,115,105,122,101,0,26,14,82,97,98,105,110,35,103,101,116,58,119,112,111,115,0,27,14,82,97,98,105,110,35,115,101,116,58,119,112,111,115,0,28,15,82,97,98,105,110,35,103,101,116,58,99,111,117,110,116,0,29,15,82,97,98,105,110,35,115,101,116,58,99,111,117,110,116,0,30,13,82,97,98,105,110,35,103,101,116,58,112,111,115,0,31,13,82,97,98,105,110,35,115,101,116,58,112,111,115,0,32,15,82,97,98,105,110,35,103,101,116,58,115,116,97,114,116,0,33,15,82,97,98,105,110,35,115,101,116,58,115,116,97,114,116,0,34,16,82,97,98,105,110,35,103,101,116,58,100,105,103,101,115,116,0,35,16,82,97,98,105,110,35,115,101,116,58,100,105,103,101,115,116,0,36,21,82,97,98,105,110,35,103,101,116,58,99,104,117,110,107,95,115,116,97,114,116,0,37,21,82,97,98,105,110,35,115,101,116,58,99,104,117,110,107,95,115,116,97,114,116,0,38,22,82,97,98,105,110,35,103,101,116,58,99,104,117,110,107,95,108,101,110,103,116,104,0,39,22,82,97,98,105,110,35,115,101,116,58,99,104,117,110,107,95,108,101,110,103,116,104,0,40,31,82,97,98,105,110,35,103,101,116,58,99,104,117,110,107,95,99,117,116,95,102,105,110,103,101,114,112,114,105,110,116,0,41,31,82,97,98,105,110,35,115,101,116,58,99,104,117,110,107,95,99,117,116,95,102,105,110,103,101,114,112,114,105,110,116,0,42,20,82,97,98,105,110,35,103,101,116,58,112,111,108,121,110,111,109,105,97,108,0,43,20,82,97,98,105,110,35,115,101,116,58,112,111,108,121,110,111,109,105,97,108,0,44,27,82,97,98,105,110,35,103,101,116,58,112,111,108,121,110,111,109,105,97,108,95,100,101,103,114,101,101,0,45,27,82,97,98,105,110,35,115,101,116,58,112,111,108,121,110,111,109,105,97,108,95,100,101,103,114,101,101,0,46,26,82,97,98,105,110,35,103,101,116,58,112,111,108,121,110,111,109,105,97,108,95,115,104,105,102,116,0,47,26,82,97,98,105,110,35,115,101,116,58,112,111,108,121,110,111,109,105,97,108,95,115,104,105,102,116,0,48,22,82,97,98,105,110,35,103,101,116,58,97,118,101,114,97,103,101,95,98,105,116,115,0,49,22,82,97,98,105,110,35,115,101,116,58,97,118,101,114,97,103,101,95,98,105,116,115,0,50,17,82,97,98,105,110,35,103,101,116,58,109,105,110,115,105,122,101,0,51,17,82,97,98,105,110,35,115,101,116,58,109,105,110,115,105,122,101,0,52,17,82,97,98,105,110,35,103,101,116,58,109,97,120,115,105,122,101,0,53,17,82,97,98,105,110,35,115,101,116,58,109,97,120,115,105,122,101,0,54,14,82,97,98,105,110,35,103,101,116,58,109,97,115,107,0,55,14,82,97,98,105,110,35,115,101,116,58,109,97,115,107,0,56,17,82,97,98,105,110,35,99,111,110,115,116,114,117,99,116,111,114,0,15,17,82,97,98,105,110,35,102,105,110,103,101,114,112,114,105,110,116,0,16,14,109,101,109,111,114,121,46,99,111,109,112,97,114,101,0,18,15,109,101,109,111,114,121,46,97,108,108,111,99,97,116,101,0,4,11,109,101,109,111,114,121,46,102,114,101,101,0,19,12,109,101,109,111,114,121,46,114,101,115,101,116,0,20,8,1,21,9,7,1,0,65,0,11,1,22,10,188,30,56,104,1,3,127,32,0,65,128,128,128,128,4,75,4,64,0,11,35,1,34,1,32,0,65,1,32,0,65,1,75,27,106,65,7,106,65,120,113,34,0,63,0,34,2,65,16,116,75,4,64,32,2,32,0,32,1,107,65,255,255,3,106,65,128,128,124,113,65,16,118,34,3,32,2,32,3,74,27,64,0,65,0,72,4,64,32,3,64,0,65,0,72,4,64,0,11,11,11,32,0,36,1,32,1,11,51,1,1,127,32,0,65,248,255,255,255,3,75,4,64,65,0,65,200,0,65,26,65,2,16,0,0,11,65,1,65,32,32,0,65,7,106,103,107,116,16,1,34,1,32,0,54,2,0,32,1,11,145,3,1,1,127,32,1,69,4,64,15,11,32,0,65,0,58,0,0,32,0,32,1,106,65,1,107,65,0,58,0,0,32,1,65,2,77,4,64,15,11,32,0,65,1,106,65,0,58,0,0,32,0,65,2,106,65,0,58,0,0,32,0,32,1,106,34,2,65,2,107,65,0,58,0,0,32,2,65,3,107,65,0,58,0,0,32,1,65,6,77,4,64,15,11,32,0,65,3,106,65,0,58,0,0,32,0,32,1,106,65,4,107,65,0,58,0,0,32,1,65,8,77,4,64,15,11,65,0,32,0,107,65,3,113,34,2,32,0,106,34,0,65,0,54,2,0,32,1,32,2,107,65,124,113,34,1,32,0,106,65,4,107,65,0,54,2,0,32,1,65,8,77,4,64,15,11,32,0,65,4,106,65,0,54,2,0,32,0,65,8,106,65,0,54,2,0,32,0,32,1,106,34,2,65,12,107,65,0,54,2,0,32,2,65,8,107,65,0,54,2,0,32,1,65,24,77,4,64,15,11,32,0,65,12,106,65,0,54,2,0,32,0,65,16,106,65,0,54,2,0,32,0,65,20,106,65,0,54,2,0,32,0,65,24,106,65,0,54,2,0,32,0,32,1,106,34,2,65,28,107,65,0,54,2,0,32,2,65,24,107,65,0,54,2,0,32,2,65,20,107,65,0,54,2,0,32,2,65,16,107,65,0,54,2,0,32,0,65,4,113,65,24,106,34,2,32,0,106,33,0,32,1,32,2,107,33,1,3,64,32,1,65,32,79,4,64,32,0,66,0,55,3,0,32,0,65,8,106,66,0,55,3,0,32,0,65,16,106,66,0,55,3,0,32,0,65,24,106,66,0,55,3,0,32,1,65,32,107,33,1,32,0,65,32,106,33,0,12,1,11,11,11,6,0,32,0,16,1,11,76,1,1,127,65,128,16,16,2,34,1,65,8,106,65,128,16,16,3,32,0,69,4,64,65,12,16,1,33,0,11,32,0,65,0,54,2,0,32,0,65,0,54,2,4,32,0,65,0,54,2,8,32,0,32,1,54,2,0,32,0,65,0,54,2,4,32,0,65,128,16,54,2,8,32,0,11,8,0,65,12,16,1,16,5,11,70,2,1,127,1,126,66,128,128,128,128,128,128,128,128,128,127,33,2,3,64,2,64,32,1,65,192,0,78,13,0,32,0,32,2,131,66,0,86,4,64,65,63,32,1,107,15,5,32,2,66,1,136,33,2,32,1,65,1,106,33,1,12,2,11,0,11,11,65,127,11,175,2,2,1,127,2,126,3,64,2,127,66,128,128,128,128,128,128,128,128,128,127,33,3,65,0,33,2,3,64,2,64,32,2,65,192,0,78,13,0,65,63,32,2,107,32,0,32,3,131,66,0,86,13,2,26,32,3,66,1,136,33,3,32,2,65,1,106,33,2,12,1,11,11,65,127,11,2,127,32,1,33,4,66,128,128,128,128,128,128,128,128,128,127,33,3,65,0,33,2,3,64,2,64,32,2,65,192,0,78,13,0,65,63,32,2,107,32,3,32,4,131,66,0,86,13,2,26,32,3,66,1,136,33,3,32,2,65,1,106,33,2,12,1,11,11,65,127,11,78,4,64,32,1,2,127,66,128,128,128,128,128,128,128,128,128,127,33,3,65,0,33,2,3,64,2,64,32,2,65,192,0,78,13,0,65,63,32,2,107,32,0,32,3,131,66,0,86,13,2,26,32,3,66,1,136,33,3,32,2,65,1,106,33,2,12,1,11,11,65,127,11,2,127,66,128,128,128,128,128,128,128,128,128,127,33,3,65,0,33,2,3,64,2,64,32,2,65,192,0,78,13,0,65,63,32,2,107,32,1,32,3,131,66,0,86,13,2,26,32,3,66,1,136,33,3,32,2,65,1,106,33,2,12,1,11,11,65,127,11,107,172,134,32,0,133,33,0,12,1,11,11,32,0,11,96,1,1,127,32,1,65,248,255,255,255,3,75,4,64,65,0,65,8,65,23,65,34,16,0,0,11,32,1,16,2,34,2,65,8,106,32,1,16,3,32,0,69,4,64,65,12,16,1,33,0,11,32,0,65,0,54,2,0,32,0,65,0,54,2,4,32,0,65,0,54,2,8,32,0,32,2,54,2,0,32,0,65,0,54,2,4,32,0,32,1,54,2,8,32,0,11,49,0,32,1,32,0,40,2,8,65,3,118,79,4,64,65,0,65,8,65,50,65,63,16,0,0,11,32,0,40,2,4,32,0,40,2,0,32,1,65,3,116,106,106,32,2,55,3,8,11,43,0,32,1,32,0,40,2,8,79,4,64,65,0,65,8,65,50,65,63,16,0,0,11,32,0,40,2,4,32,1,32,0,40,2,0,106,106,32,2,58,0,8,11,41,0,32,1,32,0,40,2,8,79,4,64,65,0,65,8,65,39,65,63,16,0,0,11,32,0,40,2,4,32,1,32,0,40,2,0,106,106,45,0,8,11,47,0,32,1,32,0,40,2,8,65,3,118,79,4,64,65,0,65,8,65,39,65,63,16,0,0,11,32,0,40,2,4,32,0,40,2,0,32,1,65,3,116,106,106,41,3,8,11,166,10,2,3,127,5,126,35,2,69,4,64,3,64,32,2,65,128,2,72,4,64,32,2,65,255,1,113,173,33,4,32,0,41,3,72,33,6,3,64,2,127,32,4,33,5,66,128,128,128,128,128,128,128,128,128,127,33,4,65,0,33,1,3,64,32,1,65,192,0,72,4,64,65,63,32,1,107,32,4,32,5,131,66,0,86,13,2,26,32,4,66,1,136,33,4,32,1,65,1,106,33,1,12,1,11,11,65,127,11,2,127,32,6,33,7,66,128,128,128,128,128,128,128,128,128,127,33,4,65,0,33,1,3,64,32,1,65,192,0,72,4,64,65,63,32,1,107,32,4,32,7,131,66,0,86,13,2,26,32,4,66,1,136,33,4,32,1,65,1,106,33,1,12,1,11,11,65,127,11,78,4,64,32,6,2,127,66,128,128,128,128,128,128,128,128,128,127,33,4,65,0,33,1,3,64,32,1,65,192,0,72,4,64,65,63,32,1,107,32,4,32,5,131,66,0,86,13,2,26,32,4,66,1,136,33,4,32,1,65,1,106,33,1,12,1,11,11,65,127,11,2,127,66,128,128,128,128,128,128,128,128,128,127,33,4,65,0,33,1,3,64,32,1,65,192,0,72,4,64,65,63,32,1,107,32,4,32,6,131,66,0,86,13,2,26,32,4,66,1,136,33,4,32,1,65,1,106,33,1,12,1,11,11,65,127,11,107,172,134,32,5,133,33,4,12,1,11,11,65,0,33,1,3,64,32,1,32,0,40,2,4,65,1,107,72,4,64,32,5,66,8,134,33,4,32,0,41,3,72,33,6,3,64,2,127,32,4,33,5,66,128,128,128,128,128,128,128,128,128,127,33,4,65,0,33,3,3,64,32,3,65,192,0,72,4,64,65,63,32,3,107,32,4,32,5,131,66,0,86,13,2,26,32,4,66,1,136,33,4,32,3,65,1,106,33,3,12,1,11,11,65,127,11,2,127,32,6,33,7,66,128,128,128,128,128,128,128,128,128,127,33,4,65,0,33,3,3,64,32,3,65,192,0,72,4,64,65,63,32,3,107,32,4,32,7,131,66,0,86,13,2,26,32,4,66,1,136,33,4,32,3,65,1,106,33,3,12,1,11,11,65,127,11,78,4,64,32,6,2,127,66,128,128,128,128,128,128,128,128,128,127,33,4,65,0,33,3,3,64,32,3,65,192,0,72,4,64,65,63,32,3,107,32,4,32,5,131,66,0,86,13,2,26,32,4,66,1,136,33,4,32,3,65,1,106,33,3,12,1,11,11,65,127,11,2,127,66,128,128,128,128,128,128,128,128,128,127,33,4,65,0,33,3,3,64,32,3,65,192,0,72,4,64,65,63,32,3,107,32,4,32,6,131,66,0,86,13,2,26,32,4,66,1,136,33,4,32,3,65,1,106,33,3,12,1,11,11,65,127,11,107,172,134,32,5,133,33,4,12,1,11,11,32,1,65,1,106,33,1,12,1,11,11,35,4,32,2,32,5,16,10,32,2,65,1,106,33,2,12,1,11,11,2,127,32,0,41,3,72,33,4,66,128,128,128,128,128,128,128,128,128,127,33,5,65,0,33,2,3,64,32,2,65,192,0,72,4,64,65,63,32,2,107,32,4,32,5,131,66,0,86,13,2,26,32,5,66,1,136,33,5,32,2,65,1,106,33,2,12,1,11,11,65,127,11,172,33,8,65,0,33,2,3,64,32,2,65,128,2,72,4,64,35,3,33,3,32,2,172,32,8,134,33,5,32,0,41,3,72,33,6,3,64,2,127,66,128,128,128,128,128,128,128,128,128,127,33,4,65,0,33,1,3,64,32,1,65,192,0,72,4,64,65,63,32,1,107,32,4,32,5,131,66,0,86,13,2,26,32,4,66,1,136,33,4,32,1,65,1,106,33,1,12,1,11,11,65,127,11,2,127,32,6,33,7,66,128,128,128,128,128,128,128,128,128,127,33,4,65,0,33,1,3,64,32,1,65,192,0,72,4,64,65,63,32,1,107,32,4,32,7,131,66,0,86,13,2,26,32,4,66,1,136,33,4,32,1,65,1,106,33,1,12,1,11,11,65,127,11,78,4,64,32,6,2,127,66,128,128,128,128,128,128,128,128,128,127,33,4,65,0,33,1,3,64,32,1,65,192,0,72,4,64,65,63,32,1,107,32,4,32,5,131,66,0,86,13,2,26,32,4,66,1,136,33,4,32,1,65,1,106,33,1,12,1,11,11,65,127,11,2,127,66,128,128,128,128,128,128,128,128,128,127,33,4,65,0,33,1,3,64,32,1,65,192,0,72,4,64,65,63,32,1,107,32,4,32,6,131,66,0,86,13,2,26,32,4,66,1,136,33,4,32,1,65,1,106,33,1,12,1,11,11,65,127,11,107,172,134,32,5,133,33,5,12,1,11,11,32,3,32,2,32,2,172,32,8,134,32,5,132,16,10,32,2,65,1,106,33,2,12,1,11,11,65,1,36,2,11,32,0,66,0,55,3,24,32,0,66,0,55,3,32,65,0,33,2,3,64,32,2,32,0,40,2,4,72,4,64,32,0,40,2,0,32,2,65,0,16,11,32,2,65,1,106,33,2,12,1,11,11,32,0,66,0,55,3,40,32,0,65,0,54,2,8,32,0,66,0,55,3,16,32,0,66,0,55,3,40,32,0,40,2,0,32,0,40,2,8,16,12,33,1,32,0,40,2,0,32,0,40,2,8,65,1,16,11,32,0,32,0,41,3,40,35,4,32,1,65,255,1,113,16,13,133,55,3,40,32,0,32,0,40,2,8,65,1,106,32,0,40,2,4,111,54,2,8,32,0,41,3,40,32,0,41,3,88,136,167,33,1,32,0,32,0,41,3,40,66,8,134,55,3,40,32,0,32,0,41,3,40,66,1,132,55,3,40,32,0,32,0,41,3,40,35,3,32,1,65,255,1,113,16,13,133,55,3,40,11,234,1,0,32,0,69,4,64,65,128,1,16,1,33,0,11,32,0,65,0,54,2,0,32,0,65,0,54,2,4,32,0,65,0,54,2,8,32,0,66,0,55,3,16,32,0,66,0,55,3,24,32,0,66,0,55,3,32,32,0,66,0,55,3,40,32,0,66,0,55,3,48,32,0,66,0,55,3,56,32,0,66,0,55,3,64,32,0,66,0,55,3,72,32,0,66,0,55,3,80,32,0,66,0,55,3,88,32,0,66,0,55,3,96,32,0,66,0,55,3,104,32,0,66,0,55,3,112,32,0,66,0,55,3,120,32,0,32,1,173,55,3,96,32,0,32,2,173,55,3,104,32,0,32,3,173,55,3,112,32,0,65,12,16,1,32,4,16,9,54,2,0,32,0,32,4,54,2,4,32,0,66,1,32,0,41,3,96,134,66,1,125,55,3,120,32,0,66,243,130,183,218,216,230,232,30,55,3,72,32,0,66,53,55,3,80,32,0,32,0,41,3,80,66,8,125,55,3,88,32,0,16,14,32,0,11,206,4,1,5,127,32,1,40,2,8,33,4,32,1,40,2,0,65,8,106,33,5,3,64,2,127,65,0,33,3,3,64,32,3,32,4,72,4,64,32,3,32,5,106,45,0,0,33,1,32,0,40,2,0,32,0,40,2,8,16,12,33,6,32,0,40,2,0,32,0,40,2,8,32,1,16,11,32,0,32,0,41,3,40,35,4,32,6,65,255,1,113,16,13,133,55,3,40,32,0,32,0,40,2,8,65,1,106,32,0,40,2,4,111,54,2,8,32,0,41,3,40,32,0,41,3,88,136,167,33,6,32,0,32,0,41,3,40,66,8,134,55,3,40,32,0,32,0,41,3,40,32,1,173,132,55,3,40,32,0,32,0,41,3,40,35,3,32,6,65,255,1,113,16,13,133,55,3,40,32,0,32,0,41,3,16,66,1,124,55,3,16,32,0,32,0,41,3,24,66,1,124,55,3,24,2,127,32,0,41,3,16,32,0,41,3,104,90,34,1,4,64,32,0,41,3,40,32,0,41,3,120,131,66,0,81,33,1,11,32,1,69,11,4,127,32,0,41,3,16,32,0,41,3,112,90,5,32,1,11,4,64,32,0,32,0,41,3,32,55,3,48,32,0,32,0,41,3,16,55,3,56,32,0,32,0,41,3,40,55,3,64,65,0,33,1,3,64,32,1,32,0,40,2,4,72,4,64,32,0,40,2,0,32,1,65,0,16,11,32,1,65,1,106,33,1,12,1,11,11,32,0,66,0,55,3,40,32,0,65,0,54,2,8,32,0,66,0,55,3,16,32,0,66,0,55,3,40,32,0,40,2,0,32,0,40,2,8,16,12,33,1,32,0,40,2,0,32,0,40,2,8,65,1,16,11,32,0,32,0,41,3,40,35,4,32,1,65,255,1,113,16,13,133,55,3,40,32,0,32,0,40,2,8,65,1,106,32,0,40,2,4,111,54,2,8,32,0,41,3,40,32,0,41,3,88,136,167,33,1,32,0,32,0,41,3,40,66,8,134,55,3,40,32,0,32,0,41,3,40,66,1,132,55,3,40,32,0,32,0,41,3,40,35,3,32,1,65,255,1,113,16,13,133,55,3,40,32,3,65,1,106,12,3,5,32,3,65,1,106,33,3,12,2,11,0,11,11,65,127,11,34,1,65,0,78,4,64,32,4,32,1,107,33,4,32,1,32,5,106,33,5,32,7,34,1,65,1,106,33,7,32,2,40,2,4,32,2,40,2,0,32,1,65,2,116,106,106,32,0,41,3,56,62,2,8,32,2,40,2,4,32,2,40,2,0,32,1,65,2,116,106,106,40,2,8,26,12,1,11,11,11,88,1,1,127,32,0,32,1,70,4,64,65,0,15,11,3,64,32,2,65,0,71,34,3,4,64,32,0,45,0,0,32,1,45,0,0,70,33,3,11,32,3,4,64,32,2,65,1,107,33,2,32,0,65,1,106,33,0,32,1,65,1,106,33,1,12,1,11,11,32,2,4,127,32,0,45,0,0,32,1,45,0,0,107,5,65,0,11,11,10,0,32,0,32,1,32,2,16,17,11,3,0,1,11,6,0,35,0,36,1,11,19,0,65,136,1,36,0,35,0,36,1,16,6,36,3,16,6,36,4,11,3,0,1,11,7,0,32,0,40,2,0,11,9,0,32,0,32,1,54,2,0,11,7,0,32,0,40,2,4,11,9,0,32,0,32,1,54,2,4,11,7,0,32,0,40,2,8,11,9,0,32,0,32,1,54,2,8,11,7,0,32,0,41,3,16,11,9,0,32,0,32,1,55,3,16,11,7,0,32,0,41,3,24,11,9,0,32,0,32,1,55,3,24,11,7,0,32,0,41,3,32,11,9,0,32,0,32,1,55,3,32,11,7,0,32,0,41,3,40,11,9,0,32,0,32,1,55,3,40,11,7,0,32,0,41,3,48,11,9,0,32,0,32,1,55,3,48,11,7,0,32,0,41,3,56,11,9,0,32,0,32,1,55,3,56,11,7,0,32,0,41,3,64,11,9,0,32,0,32,1,55,3,64,11,7,0,32,0,41,3,72,11,9,0,32,0,32,1,55,3,72,11,7,0,32,0,41,3,80,11,9,0,32,0,32,1,55,3,80,11,7,0,32,0,41,3,88,11,9,0,32,0,32,1,55,3,88,11,7,0,32,0,41,3,96,11,9,0,32,0,32,1,55,3,96,11,7,0,32,0,41,3,104,11,9,0,32,0,32,1,55,3,104,11,7,0,32,0,41,3,112,11,9,0,32,0,32,1,55,3,112,11,7,0,32,0,41,3,120,11,9,0,32,0,32,1,55,3,120,11,11,128,1,2,0,65,8,11,57,27,0,0,0,126,0,108,0,105,0,98,0,47,0,105,0,110,0,116,0,101,0,114,0,110,0,97,0,108,0,47,0,116,0,121,0,112,0,101,0,100,0,97,0,114,0,114,0,97,0,121,0,46,0,116,0,115,0,65,200,0,11,59,28,0,0,0,126,0,108,0,105,0,98,0,47,0,105,0,110,0,116,0,101,0,114,0,110,0,97,0,108,0,47,0,97,0,114,0,114,0,97,0,121,0,98,0,117,0,102,0,102,0,101,0,114,0,46,0,116,0,115,0,32,16,115,111,117,114,99,101,77,97,112,112,105,110,103,85,82,76,14,114,97,98,105,110,46,119,97,115,109,46,109,97,112])
  // make it work async because browsers throw when a wasm module is bigger than 4kb and load sync
  return instantiateStreaming(new Response(new Blob([wasm], {type: 'application/wasm'})), imp)
}
module.exports = loadWebAssembly

      };
    };
  }
}, {package:"rabin-wasm",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\rabin-wasm\\dist\\rabin-wasm.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\index.js", {"./alphabet":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\alphabet.js","./build":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\build.js","./is-valid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\is-valid.js","./util/cluster-worker-id":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\util\\cluster-worker-id-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\shortid\lib\index.js
      return function (require, module, exports) {
'use strict';

var alphabet = require('./alphabet');
var build = require('./build');
var isValid = require('./is-valid');

// if you are using cluster or multiple servers use this to make each instance
// has a unique value for worker
// Note: I don't know if this is automatically set when using third
// party cluster solutions such as pm2.
var clusterWorkerId = require('./util/cluster-worker-id') || 0;

/**
 * Set the seed.
 * Highly recommended if you don't want people to try to figure out your id schema.
 * exposed as shortid.seed(int)
 * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.
 */
function seed(seedValue) {
    alphabet.seed(seedValue);
    return module.exports;
}

/**
 * Set the cluster worker or machine id
 * exposed as shortid.worker(int)
 * @param workerId worker must be positive integer.  Number less than 16 is recommended.
 * returns shortid module so it can be chained.
 */
function worker(workerId) {
    clusterWorkerId = workerId;
    return module.exports;
}

/**
 *
 * sets new characters to use in the alphabet
 * returns the shuffled alphabet
 */
function characters(newCharacters) {
    if (newCharacters !== undefined) {
        alphabet.characters(newCharacters);
    }

    return alphabet.shuffled();
}

/**
 * Generate unique id
 * Returns string id
 */
function generate() {
  return build(clusterWorkerId);
}

// Export all other functions as properties of the generate function
module.exports = generate;
module.exports.generate = generate;
module.exports.seed = seed;
module.exports.worker = worker;
module.exports.characters = characters;
module.exports.isValid = isValid;

      };
    };
  }
}, {package:"shortid",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\chinese_simplified.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\key-tree\node_modules\bip39\src\wordlists\chinese_simplified.json
      return function (require, module, exports) {
module.exports=[
    "的",
    "一",
    "是",
    "在",
    "不",
    "了",
    "有",
    "和",
    "人",
    "这",
    "中",
    "大",
    "为",
    "上",
    "个",
    "国",
    "我",
    "以",
    "要",
    "他",
    "时",
    "来",
    "用",
    "们",
    "生",
    "到",
    "作",
    "地",
    "于",
    "出",
    "就",
    "分",
    "对",
    "成",
    "会",
    "可",
    "主",
    "发",
    "年",
    "动",
    "同",
    "工",
    "也",
    "能",
    "下",
    "过",
    "子",
    "说",
    "产",
    "种",
    "面",
    "而",
    "方",
    "后",
    "多",
    "定",
    "行",
    "学",
    "法",
    "所",
    "民",
    "得",
    "经",
    "十",
    "三",
    "之",
    "进",
    "着",
    "等",
    "部",
    "度",
    "家",
    "电",
    "力",
    "里",
    "如",
    "水",
    "化",
    "高",
    "自",
    "二",
    "理",
    "起",
    "小",
    "物",
    "现",
    "实",
    "加",
    "量",
    "都",
    "两",
    "体",
    "制",
    "机",
    "当",
    "使",
    "点",
    "从",
    "业",
    "本",
    "去",
    "把",
    "性",
    "好",
    "应",
    "开",
    "它",
    "合",
    "还",
    "因",
    "由",
    "其",
    "些",
    "然",
    "前",
    "外",
    "天",
    "政",
    "四",
    "日",
    "那",
    "社",
    "义",
    "事",
    "平",
    "形",
    "相",
    "全",
    "表",
    "间",
    "样",
    "与",
    "关",
    "各",
    "重",
    "新",
    "线",
    "内",
    "数",
    "正",
    "心",
    "反",
    "你",
    "明",
    "看",
    "原",
    "又",
    "么",
    "利",
    "比",
    "或",
    "但",
    "质",
    "气",
    "第",
    "向",
    "道",
    "命",
    "此",
    "变",
    "条",
    "只",
    "没",
    "结",
    "解",
    "问",
    "意",
    "建",
    "月",
    "公",
    "无",
    "系",
    "军",
    "很",
    "情",
    "者",
    "最",
    "立",
    "代",
    "想",
    "已",
    "通",
    "并",
    "提",
    "直",
    "题",
    "党",
    "程",
    "展",
    "五",
    "果",
    "料",
    "象",
    "员",
    "革",
    "位",
    "入",
    "常",
    "文",
    "总",
    "次",
    "品",
    "式",
    "活",
    "设",
    "及",
    "管",
    "特",
    "件",
    "长",
    "求",
    "老",
    "头",
    "基",
    "资",
    "边",
    "流",
    "路",
    "级",
    "少",
    "图",
    "山",
    "统",
    "接",
    "知",
    "较",
    "将",
    "组",
    "见",
    "计",
    "别",
    "她",
    "手",
    "角",
    "期",
    "根",
    "论",
    "运",
    "农",
    "指",
    "几",
    "九",
    "区",
    "强",
    "放",
    "决",
    "西",
    "被",
    "干",
    "做",
    "必",
    "战",
    "先",
    "回",
    "则",
    "任",
    "取",
    "据",
    "处",
    "队",
    "南",
    "给",
    "色",
    "光",
    "门",
    "即",
    "保",
    "治",
    "北",
    "造",
    "百",
    "规",
    "热",
    "领",
    "七",
    "海",
    "口",
    "东",
    "导",
    "器",
    "压",
    "志",
    "世",
    "金",
    "增",
    "争",
    "济",
    "阶",
    "油",
    "思",
    "术",
    "极",
    "交",
    "受",
    "联",
    "什",
    "认",
    "六",
    "共",
    "权",
    "收",
    "证",
    "改",
    "清",
    "美",
    "再",
    "采",
    "转",
    "更",
    "单",
    "风",
    "切",
    "打",
    "白",
    "教",
    "速",
    "花",
    "带",
    "安",
    "场",
    "身",
    "车",
    "例",
    "真",
    "务",
    "具",
    "万",
    "每",
    "目",
    "至",
    "达",
    "走",
    "积",
    "示",
    "议",
    "声",
    "报",
    "斗",
    "完",
    "类",
    "八",
    "离",
    "华",
    "名",
    "确",
    "才",
    "科",
    "张",
    "信",
    "马",
    "节",
    "话",
    "米",
    "整",
    "空",
    "元",
    "况",
    "今",
    "集",
    "温",
    "传",
    "土",
    "许",
    "步",
    "群",
    "广",
    "石",
    "记",
    "需",
    "段",
    "研",
    "界",
    "拉",
    "林",
    "律",
    "叫",
    "且",
    "究",
    "观",
    "越",
    "织",
    "装",
    "影",
    "算",
    "低",
    "持",
    "音",
    "众",
    "书",
    "布",
    "复",
    "容",
    "儿",
    "须",
    "际",
    "商",
    "非",
    "验",
    "连",
    "断",
    "深",
    "难",
    "近",
    "矿",
    "千",
    "周",
    "委",
    "素",
    "技",
    "备",
    "半",
    "办",
    "青",
    "省",
    "列",
    "习",
    "响",
    "约",
    "支",
    "般",
    "史",
    "感",
    "劳",
    "便",
    "团",
    "往",
    "酸",
    "历",
    "市",
    "克",
    "何",
    "除",
    "消",
    "构",
    "府",
    "称",
    "太",
    "准",
    "精",
    "值",
    "号",
    "率",
    "族",
    "维",
    "划",
    "选",
    "标",
    "写",
    "存",
    "候",
    "毛",
    "亲",
    "快",
    "效",
    "斯",
    "院",
    "查",
    "江",
    "型",
    "眼",
    "王",
    "按",
    "格",
    "养",
    "易",
    "置",
    "派",
    "层",
    "片",
    "始",
    "却",
    "专",
    "状",
    "育",
    "厂",
    "京",
    "识",
    "适",
    "属",
    "圆",
    "包",
    "火",
    "住",
    "调",
    "满",
    "县",
    "局",
    "照",
    "参",
    "红",
    "细",
    "引",
    "听",
    "该",
    "铁",
    "价",
    "严",
    "首",
    "底",
    "液",
    "官",
    "德",
    "随",
    "病",
    "苏",
    "失",
    "尔",
    "死",
    "讲",
    "配",
    "女",
    "黄",
    "推",
    "显",
    "谈",
    "罪",
    "神",
    "艺",
    "呢",
    "席",
    "含",
    "企",
    "望",
    "密",
    "批",
    "营",
    "项",
    "防",
    "举",
    "球",
    "英",
    "氧",
    "势",
    "告",
    "李",
    "台",
    "落",
    "木",
    "帮",
    "轮",
    "破",
    "亚",
    "师",
    "围",
    "注",
    "远",
    "字",
    "材",
    "排",
    "供",
    "河",
    "态",
    "封",
    "另",
    "施",
    "减",
    "树",
    "溶",
    "怎",
    "止",
    "案",
    "言",
    "士",
    "均",
    "武",
    "固",
    "叶",
    "鱼",
    "波",
    "视",
    "仅",
    "费",
    "紧",
    "爱",
    "左",
    "章",
    "早",
    "朝",
    "害",
    "续",
    "轻",
    "服",
    "试",
    "食",
    "充",
    "兵",
    "源",
    "判",
    "护",
    "司",
    "足",
    "某",
    "练",
    "差",
    "致",
    "板",
    "田",
    "降",
    "黑",
    "犯",
    "负",
    "击",
    "范",
    "继",
    "兴",
    "似",
    "余",
    "坚",
    "曲",
    "输",
    "修",
    "故",
    "城",
    "夫",
    "够",
    "送",
    "笔",
    "船",
    "占",
    "右",
    "财",
    "吃",
    "富",
    "春",
    "职",
    "觉",
    "汉",
    "画",
    "功",
    "巴",
    "跟",
    "虽",
    "杂",
    "飞",
    "检",
    "吸",
    "助",
    "升",
    "阳",
    "互",
    "初",
    "创",
    "抗",
    "考",
    "投",
    "坏",
    "策",
    "古",
    "径",
    "换",
    "未",
    "跑",
    "留",
    "钢",
    "曾",
    "端",
    "责",
    "站",
    "简",
    "述",
    "钱",
    "副",
    "尽",
    "帝",
    "射",
    "草",
    "冲",
    "承",
    "独",
    "令",
    "限",
    "阿",
    "宣",
    "环",
    "双",
    "请",
    "超",
    "微",
    "让",
    "控",
    "州",
    "良",
    "轴",
    "找",
    "否",
    "纪",
    "益",
    "依",
    "优",
    "顶",
    "础",
    "载",
    "倒",
    "房",
    "突",
    "坐",
    "粉",
    "敌",
    "略",
    "客",
    "袁",
    "冷",
    "胜",
    "绝",
    "析",
    "块",
    "剂",
    "测",
    "丝",
    "协",
    "诉",
    "念",
    "陈",
    "仍",
    "罗",
    "盐",
    "友",
    "洋",
    "错",
    "苦",
    "夜",
    "刑",
    "移",
    "频",
    "逐",
    "靠",
    "混",
    "母",
    "短",
    "皮",
    "终",
    "聚",
    "汽",
    "村",
    "云",
    "哪",
    "既",
    "距",
    "卫",
    "停",
    "烈",
    "央",
    "察",
    "烧",
    "迅",
    "境",
    "若",
    "印",
    "洲",
    "刻",
    "括",
    "激",
    "孔",
    "搞",
    "甚",
    "室",
    "待",
    "核",
    "校",
    "散",
    "侵",
    "吧",
    "甲",
    "游",
    "久",
    "菜",
    "味",
    "旧",
    "模",
    "湖",
    "货",
    "损",
    "预",
    "阻",
    "毫",
    "普",
    "稳",
    "乙",
    "妈",
    "植",
    "息",
    "扩",
    "银",
    "语",
    "挥",
    "酒",
    "守",
    "拿",
    "序",
    "纸",
    "医",
    "缺",
    "雨",
    "吗",
    "针",
    "刘",
    "啊",
    "急",
    "唱",
    "误",
    "训",
    "愿",
    "审",
    "附",
    "获",
    "茶",
    "鲜",
    "粮",
    "斤",
    "孩",
    "脱",
    "硫",
    "肥",
    "善",
    "龙",
    "演",
    "父",
    "渐",
    "血",
    "欢",
    "械",
    "掌",
    "歌",
    "沙",
    "刚",
    "攻",
    "谓",
    "盾",
    "讨",
    "晚",
    "粒",
    "乱",
    "燃",
    "矛",
    "乎",
    "杀",
    "药",
    "宁",
    "鲁",
    "贵",
    "钟",
    "煤",
    "读",
    "班",
    "伯",
    "香",
    "介",
    "迫",
    "句",
    "丰",
    "培",
    "握",
    "兰",
    "担",
    "弦",
    "蛋",
    "沉",
    "假",
    "穿",
    "执",
    "答",
    "乐",
    "谁",
    "顺",
    "烟",
    "缩",
    "征",
    "脸",
    "喜",
    "松",
    "脚",
    "困",
    "异",
    "免",
    "背",
    "星",
    "福",
    "买",
    "染",
    "井",
    "概",
    "慢",
    "怕",
    "磁",
    "倍",
    "祖",
    "皇",
    "促",
    "静",
    "补",
    "评",
    "翻",
    "肉",
    "践",
    "尼",
    "衣",
    "宽",
    "扬",
    "棉",
    "希",
    "伤",
    "操",
    "垂",
    "秋",
    "宜",
    "氢",
    "套",
    "督",
    "振",
    "架",
    "亮",
    "末",
    "宪",
    "庆",
    "编",
    "牛",
    "触",
    "映",
    "雷",
    "销",
    "诗",
    "座",
    "居",
    "抓",
    "裂",
    "胞",
    "呼",
    "娘",
    "景",
    "威",
    "绿",
    "晶",
    "厚",
    "盟",
    "衡",
    "鸡",
    "孙",
    "延",
    "危",
    "胶",
    "屋",
    "乡",
    "临",
    "陆",
    "顾",
    "掉",
    "呀",
    "灯",
    "岁",
    "措",
    "束",
    "耐",
    "剧",
    "玉",
    "赵",
    "跳",
    "哥",
    "季",
    "课",
    "凯",
    "胡",
    "额",
    "款",
    "绍",
    "卷",
    "齐",
    "伟",
    "蒸",
    "殖",
    "永",
    "宗",
    "苗",
    "川",
    "炉",
    "岩",
    "弱",
    "零",
    "杨",
    "奏",
    "沿",
    "露",
    "杆",
    "探",
    "滑",
    "镇",
    "饭",
    "浓",
    "航",
    "怀",
    "赶",
    "库",
    "夺",
    "伊",
    "灵",
    "税",
    "途",
    "灭",
    "赛",
    "归",
    "召",
    "鼓",
    "播",
    "盘",
    "裁",
    "险",
    "康",
    "唯",
    "录",
    "菌",
    "纯",
    "借",
    "糖",
    "盖",
    "横",
    "符",
    "私",
    "努",
    "堂",
    "域",
    "枪",
    "润",
    "幅",
    "哈",
    "竟",
    "熟",
    "虫",
    "泽",
    "脑",
    "壤",
    "碳",
    "欧",
    "遍",
    "侧",
    "寨",
    "敢",
    "彻",
    "虑",
    "斜",
    "薄",
    "庭",
    "纳",
    "弹",
    "饲",
    "伸",
    "折",
    "麦",
    "湿",
    "暗",
    "荷",
    "瓦",
    "塞",
    "床",
    "筑",
    "恶",
    "户",
    "访",
    "塔",
    "奇",
    "透",
    "梁",
    "刀",
    "旋",
    "迹",
    "卡",
    "氯",
    "遇",
    "份",
    "毒",
    "泥",
    "退",
    "洗",
    "摆",
    "灰",
    "彩",
    "卖",
    "耗",
    "夏",
    "择",
    "忙",
    "铜",
    "献",
    "硬",
    "予",
    "繁",
    "圈",
    "雪",
    "函",
    "亦",
    "抽",
    "篇",
    "阵",
    "阴",
    "丁",
    "尺",
    "追",
    "堆",
    "雄",
    "迎",
    "泛",
    "爸",
    "楼",
    "避",
    "谋",
    "吨",
    "野",
    "猪",
    "旗",
    "累",
    "偏",
    "典",
    "馆",
    "索",
    "秦",
    "脂",
    "潮",
    "爷",
    "豆",
    "忽",
    "托",
    "惊",
    "塑",
    "遗",
    "愈",
    "朱",
    "替",
    "纤",
    "粗",
    "倾",
    "尚",
    "痛",
    "楚",
    "谢",
    "奋",
    "购",
    "磨",
    "君",
    "池",
    "旁",
    "碎",
    "骨",
    "监",
    "捕",
    "弟",
    "暴",
    "割",
    "贯",
    "殊",
    "释",
    "词",
    "亡",
    "壁",
    "顿",
    "宝",
    "午",
    "尘",
    "闻",
    "揭",
    "炮",
    "残",
    "冬",
    "桥",
    "妇",
    "警",
    "综",
    "招",
    "吴",
    "付",
    "浮",
    "遭",
    "徐",
    "您",
    "摇",
    "谷",
    "赞",
    "箱",
    "隔",
    "订",
    "男",
    "吹",
    "园",
    "纷",
    "唐",
    "败",
    "宋",
    "玻",
    "巨",
    "耕",
    "坦",
    "荣",
    "闭",
    "湾",
    "键",
    "凡",
    "驻",
    "锅",
    "救",
    "恩",
    "剥",
    "凝",
    "碱",
    "齿",
    "截",
    "炼",
    "麻",
    "纺",
    "禁",
    "废",
    "盛",
    "版",
    "缓",
    "净",
    "睛",
    "昌",
    "婚",
    "涉",
    "筒",
    "嘴",
    "插",
    "岸",
    "朗",
    "庄",
    "街",
    "藏",
    "姑",
    "贸",
    "腐",
    "奴",
    "啦",
    "惯",
    "乘",
    "伙",
    "恢",
    "匀",
    "纱",
    "扎",
    "辩",
    "耳",
    "彪",
    "臣",
    "亿",
    "璃",
    "抵",
    "脉",
    "秀",
    "萨",
    "俄",
    "网",
    "舞",
    "店",
    "喷",
    "纵",
    "寸",
    "汗",
    "挂",
    "洪",
    "贺",
    "闪",
    "柬",
    "爆",
    "烯",
    "津",
    "稻",
    "墙",
    "软",
    "勇",
    "像",
    "滚",
    "厘",
    "蒙",
    "芳",
    "肯",
    "坡",
    "柱",
    "荡",
    "腿",
    "仪",
    "旅",
    "尾",
    "轧",
    "冰",
    "贡",
    "登",
    "黎",
    "削",
    "钻",
    "勒",
    "逃",
    "障",
    "氨",
    "郭",
    "峰",
    "币",
    "港",
    "伏",
    "轨",
    "亩",
    "毕",
    "擦",
    "莫",
    "刺",
    "浪",
    "秘",
    "援",
    "株",
    "健",
    "售",
    "股",
    "岛",
    "甘",
    "泡",
    "睡",
    "童",
    "铸",
    "汤",
    "阀",
    "休",
    "汇",
    "舍",
    "牧",
    "绕",
    "炸",
    "哲",
    "磷",
    "绩",
    "朋",
    "淡",
    "尖",
    "启",
    "陷",
    "柴",
    "呈",
    "徒",
    "颜",
    "泪",
    "稍",
    "忘",
    "泵",
    "蓝",
    "拖",
    "洞",
    "授",
    "镜",
    "辛",
    "壮",
    "锋",
    "贫",
    "虚",
    "弯",
    "摩",
    "泰",
    "幼",
    "廷",
    "尊",
    "窗",
    "纲",
    "弄",
    "隶",
    "疑",
    "氏",
    "宫",
    "姐",
    "震",
    "瑞",
    "怪",
    "尤",
    "琴",
    "循",
    "描",
    "膜",
    "违",
    "夹",
    "腰",
    "缘",
    "珠",
    "穷",
    "森",
    "枝",
    "竹",
    "沟",
    "催",
    "绳",
    "忆",
    "邦",
    "剩",
    "幸",
    "浆",
    "栏",
    "拥",
    "牙",
    "贮",
    "礼",
    "滤",
    "钠",
    "纹",
    "罢",
    "拍",
    "咱",
    "喊",
    "袖",
    "埃",
    "勤",
    "罚",
    "焦",
    "潜",
    "伍",
    "墨",
    "欲",
    "缝",
    "姓",
    "刊",
    "饱",
    "仿",
    "奖",
    "铝",
    "鬼",
    "丽",
    "跨",
    "默",
    "挖",
    "链",
    "扫",
    "喝",
    "袋",
    "炭",
    "污",
    "幕",
    "诸",
    "弧",
    "励",
    "梅",
    "奶",
    "洁",
    "灾",
    "舟",
    "鉴",
    "苯",
    "讼",
    "抱",
    "毁",
    "懂",
    "寒",
    "智",
    "埔",
    "寄",
    "届",
    "跃",
    "渡",
    "挑",
    "丹",
    "艰",
    "贝",
    "碰",
    "拔",
    "爹",
    "戴",
    "码",
    "梦",
    "芽",
    "熔",
    "赤",
    "渔",
    "哭",
    "敬",
    "颗",
    "奔",
    "铅",
    "仲",
    "虎",
    "稀",
    "妹",
    "乏",
    "珍",
    "申",
    "桌",
    "遵",
    "允",
    "隆",
    "螺",
    "仓",
    "魏",
    "锐",
    "晓",
    "氮",
    "兼",
    "隐",
    "碍",
    "赫",
    "拨",
    "忠",
    "肃",
    "缸",
    "牵",
    "抢",
    "博",
    "巧",
    "壳",
    "兄",
    "杜",
    "讯",
    "诚",
    "碧",
    "祥",
    "柯",
    "页",
    "巡",
    "矩",
    "悲",
    "灌",
    "龄",
    "伦",
    "票",
    "寻",
    "桂",
    "铺",
    "圣",
    "恐",
    "恰",
    "郑",
    "趣",
    "抬",
    "荒",
    "腾",
    "贴",
    "柔",
    "滴",
    "猛",
    "阔",
    "辆",
    "妻",
    "填",
    "撤",
    "储",
    "签",
    "闹",
    "扰",
    "紫",
    "砂",
    "递",
    "戏",
    "吊",
    "陶",
    "伐",
    "喂",
    "疗",
    "瓶",
    "婆",
    "抚",
    "臂",
    "摸",
    "忍",
    "虾",
    "蜡",
    "邻",
    "胸",
    "巩",
    "挤",
    "偶",
    "弃",
    "槽",
    "劲",
    "乳",
    "邓",
    "吉",
    "仁",
    "烂",
    "砖",
    "租",
    "乌",
    "舰",
    "伴",
    "瓜",
    "浅",
    "丙",
    "暂",
    "燥",
    "橡",
    "柳",
    "迷",
    "暖",
    "牌",
    "秧",
    "胆",
    "详",
    "簧",
    "踏",
    "瓷",
    "谱",
    "呆",
    "宾",
    "糊",
    "洛",
    "辉",
    "愤",
    "竞",
    "隙",
    "怒",
    "粘",
    "乃",
    "绪",
    "肩",
    "籍",
    "敏",
    "涂",
    "熙",
    "皆",
    "侦",
    "悬",
    "掘",
    "享",
    "纠",
    "醒",
    "狂",
    "锁",
    "淀",
    "恨",
    "牲",
    "霸",
    "爬",
    "赏",
    "逆",
    "玩",
    "陵",
    "祝",
    "秒",
    "浙",
    "貌",
    "役",
    "彼",
    "悉",
    "鸭",
    "趋",
    "凤",
    "晨",
    "畜",
    "辈",
    "秩",
    "卵",
    "署",
    "梯",
    "炎",
    "滩",
    "棋",
    "驱",
    "筛",
    "峡",
    "冒",
    "啥",
    "寿",
    "译",
    "浸",
    "泉",
    "帽",
    "迟",
    "硅",
    "疆",
    "贷",
    "漏",
    "稿",
    "冠",
    "嫩",
    "胁",
    "芯",
    "牢",
    "叛",
    "蚀",
    "奥",
    "鸣",
    "岭",
    "羊",
    "凭",
    "串",
    "塘",
    "绘",
    "酵",
    "融",
    "盆",
    "锡",
    "庙",
    "筹",
    "冻",
    "辅",
    "摄",
    "袭",
    "筋",
    "拒",
    "僚",
    "旱",
    "钾",
    "鸟",
    "漆",
    "沈",
    "眉",
    "疏",
    "添",
    "棒",
    "穗",
    "硝",
    "韩",
    "逼",
    "扭",
    "侨",
    "凉",
    "挺",
    "碗",
    "栽",
    "炒",
    "杯",
    "患",
    "馏",
    "劝",
    "豪",
    "辽",
    "勃",
    "鸿",
    "旦",
    "吏",
    "拜",
    "狗",
    "埋",
    "辊",
    "掩",
    "饮",
    "搬",
    "骂",
    "辞",
    "勾",
    "扣",
    "估",
    "蒋",
    "绒",
    "雾",
    "丈",
    "朵",
    "姆",
    "拟",
    "宇",
    "辑",
    "陕",
    "雕",
    "偿",
    "蓄",
    "崇",
    "剪",
    "倡",
    "厅",
    "咬",
    "驶",
    "薯",
    "刷",
    "斥",
    "番",
    "赋",
    "奉",
    "佛",
    "浇",
    "漫",
    "曼",
    "扇",
    "钙",
    "桃",
    "扶",
    "仔",
    "返",
    "俗",
    "亏",
    "腔",
    "鞋",
    "棱",
    "覆",
    "框",
    "悄",
    "叔",
    "撞",
    "骗",
    "勘",
    "旺",
    "沸",
    "孤",
    "吐",
    "孟",
    "渠",
    "屈",
    "疾",
    "妙",
    "惜",
    "仰",
    "狠",
    "胀",
    "谐",
    "抛",
    "霉",
    "桑",
    "岗",
    "嘛",
    "衰",
    "盗",
    "渗",
    "脏",
    "赖",
    "涌",
    "甜",
    "曹",
    "阅",
    "肌",
    "哩",
    "厉",
    "烃",
    "纬",
    "毅",
    "昨",
    "伪",
    "症",
    "煮",
    "叹",
    "钉",
    "搭",
    "茎",
    "笼",
    "酷",
    "偷",
    "弓",
    "锥",
    "恒",
    "杰",
    "坑",
    "鼻",
    "翼",
    "纶",
    "叙",
    "狱",
    "逮",
    "罐",
    "络",
    "棚",
    "抑",
    "膨",
    "蔬",
    "寺",
    "骤",
    "穆",
    "冶",
    "枯",
    "册",
    "尸",
    "凸",
    "绅",
    "坯",
    "牺",
    "焰",
    "轰",
    "欣",
    "晋",
    "瘦",
    "御",
    "锭",
    "锦",
    "丧",
    "旬",
    "锻",
    "垄",
    "搜",
    "扑",
    "邀",
    "亭",
    "酯",
    "迈",
    "舒",
    "脆",
    "酶",
    "闲",
    "忧",
    "酚",
    "顽",
    "羽",
    "涨",
    "卸",
    "仗",
    "陪",
    "辟",
    "惩",
    "杭",
    "姚",
    "肚",
    "捉",
    "飘",
    "漂",
    "昆",
    "欺",
    "吾",
    "郎",
    "烷",
    "汁",
    "呵",
    "饰",
    "萧",
    "雅",
    "邮",
    "迁",
    "燕",
    "撒",
    "姻",
    "赴",
    "宴",
    "烦",
    "债",
    "帐",
    "斑",
    "铃",
    "旨",
    "醇",
    "董",
    "饼",
    "雏",
    "姿",
    "拌",
    "傅",
    "腹",
    "妥",
    "揉",
    "贤",
    "拆",
    "歪",
    "葡",
    "胺",
    "丢",
    "浩",
    "徽",
    "昂",
    "垫",
    "挡",
    "览",
    "贪",
    "慰",
    "缴",
    "汪",
    "慌",
    "冯",
    "诺",
    "姜",
    "谊",
    "凶",
    "劣",
    "诬",
    "耀",
    "昏",
    "躺",
    "盈",
    "骑",
    "乔",
    "溪",
    "丛",
    "卢",
    "抹",
    "闷",
    "咨",
    "刮",
    "驾",
    "缆",
    "悟",
    "摘",
    "铒",
    "掷",
    "颇",
    "幻",
    "柄",
    "惠",
    "惨",
    "佳",
    "仇",
    "腊",
    "窝",
    "涤",
    "剑",
    "瞧",
    "堡",
    "泼",
    "葱",
    "罩",
    "霍",
    "捞",
    "胎",
    "苍",
    "滨",
    "俩",
    "捅",
    "湘",
    "砍",
    "霞",
    "邵",
    "萄",
    "疯",
    "淮",
    "遂",
    "熊",
    "粪",
    "烘",
    "宿",
    "档",
    "戈",
    "驳",
    "嫂",
    "裕",
    "徙",
    "箭",
    "捐",
    "肠",
    "撑",
    "晒",
    "辨",
    "殿",
    "莲",
    "摊",
    "搅",
    "酱",
    "屏",
    "疫",
    "哀",
    "蔡",
    "堵",
    "沫",
    "皱",
    "畅",
    "叠",
    "阁",
    "莱",
    "敲",
    "辖",
    "钩",
    "痕",
    "坝",
    "巷",
    "饿",
    "祸",
    "丘",
    "玄",
    "溜",
    "曰",
    "逻",
    "彭",
    "尝",
    "卿",
    "妨",
    "艇",
    "吞",
    "韦",
    "怨",
    "矮",
    "歇"
]

      };
    };
  }
}, {package:"bip39",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\chinese_simplified.json",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\czech.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\key-tree\node_modules\bip39\src\wordlists\czech.json
      return function (require, module, exports) {
module.exports=[
    "abdikace",
    "abeceda",
    "adresa",
    "agrese",
    "akce",
    "aktovka",
    "alej",
    "alkohol",
    "amputace",
    "ananas",
    "andulka",
    "anekdota",
    "anketa",
    "antika",
    "anulovat",
    "archa",
    "arogance",
    "asfalt",
    "asistent",
    "aspirace",
    "astma",
    "astronom",
    "atlas",
    "atletika",
    "atol",
    "autobus",
    "azyl",
    "babka",
    "bachor",
    "bacil",
    "baculka",
    "badatel",
    "bageta",
    "bagr",
    "bahno",
    "bakterie",
    "balada",
    "baletka",
    "balkon",
    "balonek",
    "balvan",
    "balza",
    "bambus",
    "bankomat",
    "barbar",
    "baret",
    "barman",
    "baroko",
    "barva",
    "baterka",
    "batoh",
    "bavlna",
    "bazalka",
    "bazilika",
    "bazuka",
    "bedna",
    "beran",
    "beseda",
    "bestie",
    "beton",
    "bezinka",
    "bezmoc",
    "beztak",
    "bicykl",
    "bidlo",
    "biftek",
    "bikiny",
    "bilance",
    "biograf",
    "biolog",
    "bitva",
    "bizon",
    "blahobyt",
    "blatouch",
    "blecha",
    "bledule",
    "blesk",
    "blikat",
    "blizna",
    "blokovat",
    "bloudit",
    "blud",
    "bobek",
    "bobr",
    "bodlina",
    "bodnout",
    "bohatost",
    "bojkot",
    "bojovat",
    "bokorys",
    "bolest",
    "borec",
    "borovice",
    "bota",
    "boubel",
    "bouchat",
    "bouda",
    "boule",
    "bourat",
    "boxer",
    "bradavka",
    "brambora",
    "branka",
    "bratr",
    "brepta",
    "briketa",
    "brko",
    "brloh",
    "bronz",
    "broskev",
    "brunetka",
    "brusinka",
    "brzda",
    "brzy",
    "bublina",
    "bubnovat",
    "buchta",
    "buditel",
    "budka",
    "budova",
    "bufet",
    "bujarost",
    "bukvice",
    "buldok",
    "bulva",
    "bunda",
    "bunkr",
    "burza",
    "butik",
    "buvol",
    "buzola",
    "bydlet",
    "bylina",
    "bytovka",
    "bzukot",
    "capart",
    "carevna",
    "cedr",
    "cedule",
    "cejch",
    "cejn",
    "cela",
    "celer",
    "celkem",
    "celnice",
    "cenina",
    "cennost",
    "cenovka",
    "centrum",
    "cenzor",
    "cestopis",
    "cetka",
    "chalupa",
    "chapadlo",
    "charita",
    "chata",
    "chechtat",
    "chemie",
    "chichot",
    "chirurg",
    "chlad",
    "chleba",
    "chlubit",
    "chmel",
    "chmura",
    "chobot",
    "chochol",
    "chodba",
    "cholera",
    "chomout",
    "chopit",
    "choroba",
    "chov",
    "chrapot",
    "chrlit",
    "chrt",
    "chrup",
    "chtivost",
    "chudina",
    "chutnat",
    "chvat",
    "chvilka",
    "chvost",
    "chyba",
    "chystat",
    "chytit",
    "cibule",
    "cigareta",
    "cihelna",
    "cihla",
    "cinkot",
    "cirkus",
    "cisterna",
    "citace",
    "citrus",
    "cizinec",
    "cizost",
    "clona",
    "cokoliv",
    "couvat",
    "ctitel",
    "ctnost",
    "cudnost",
    "cuketa",
    "cukr",
    "cupot",
    "cvaknout",
    "cval",
    "cvik",
    "cvrkot",
    "cyklista",
    "daleko",
    "dareba",
    "datel",
    "datum",
    "dcera",
    "debata",
    "dechovka",
    "decibel",
    "deficit",
    "deflace",
    "dekl",
    "dekret",
    "demokrat",
    "deprese",
    "derby",
    "deska",
    "detektiv",
    "dikobraz",
    "diktovat",
    "dioda",
    "diplom",
    "disk",
    "displej",
    "divadlo",
    "divoch",
    "dlaha",
    "dlouho",
    "dluhopis",
    "dnes",
    "dobro",
    "dobytek",
    "docent",
    "dochutit",
    "dodnes",
    "dohled",
    "dohoda",
    "dohra",
    "dojem",
    "dojnice",
    "doklad",
    "dokola",
    "doktor",
    "dokument",
    "dolar",
    "doleva",
    "dolina",
    "doma",
    "dominant",
    "domluvit",
    "domov",
    "donutit",
    "dopad",
    "dopis",
    "doplnit",
    "doposud",
    "doprovod",
    "dopustit",
    "dorazit",
    "dorost",
    "dort",
    "dosah",
    "doslov",
    "dostatek",
    "dosud",
    "dosyta",
    "dotaz",
    "dotek",
    "dotknout",
    "doufat",
    "doutnat",
    "dovozce",
    "dozadu",
    "doznat",
    "dozorce",
    "drahota",
    "drak",
    "dramatik",
    "dravec",
    "draze",
    "drdol",
    "drobnost",
    "drogerie",
    "drozd",
    "drsnost",
    "drtit",
    "drzost",
    "duben",
    "duchovno",
    "dudek",
    "duha",
    "duhovka",
    "dusit",
    "dusno",
    "dutost",
    "dvojice",
    "dvorec",
    "dynamit",
    "ekolog",
    "ekonomie",
    "elektron",
    "elipsa",
    "email",
    "emise",
    "emoce",
    "empatie",
    "epizoda",
    "epocha",
    "epopej",
    "epos",
    "esej",
    "esence",
    "eskorta",
    "eskymo",
    "etiketa",
    "euforie",
    "evoluce",
    "exekuce",
    "exkurze",
    "expedice",
    "exploze",
    "export",
    "extrakt",
    "facka",
    "fajfka",
    "fakulta",
    "fanatik",
    "fantazie",
    "farmacie",
    "favorit",
    "fazole",
    "federace",
    "fejeton",
    "fenka",
    "fialka",
    "figurant",
    "filozof",
    "filtr",
    "finance",
    "finta",
    "fixace",
    "fjord",
    "flanel",
    "flirt",
    "flotila",
    "fond",
    "fosfor",
    "fotbal",
    "fotka",
    "foton",
    "frakce",
    "freska",
    "fronta",
    "fukar",
    "funkce",
    "fyzika",
    "galeje",
    "garant",
    "genetika",
    "geolog",
    "gilotina",
    "glazura",
    "glejt",
    "golem",
    "golfista",
    "gotika",
    "graf",
    "gramofon",
    "granule",
    "grep",
    "gril",
    "grog",
    "groteska",
    "guma",
    "hadice",
    "hadr",
    "hala",
    "halenka",
    "hanba",
    "hanopis",
    "harfa",
    "harpuna",
    "havran",
    "hebkost",
    "hejkal",
    "hejno",
    "hejtman",
    "hektar",
    "helma",
    "hematom",
    "herec",
    "herna",
    "heslo",
    "hezky",
    "historik",
    "hladovka",
    "hlasivky",
    "hlava",
    "hledat",
    "hlen",
    "hlodavec",
    "hloh",
    "hloupost",
    "hltat",
    "hlubina",
    "hluchota",
    "hmat",
    "hmota",
    "hmyz",
    "hnis",
    "hnojivo",
    "hnout",
    "hoblina",
    "hoboj",
    "hoch",
    "hodiny",
    "hodlat",
    "hodnota",
    "hodovat",
    "hojnost",
    "hokej",
    "holinka",
    "holka",
    "holub",
    "homole",
    "honitba",
    "honorace",
    "horal",
    "horda",
    "horizont",
    "horko",
    "horlivec",
    "hormon",
    "hornina",
    "horoskop",
    "horstvo",
    "hospoda",
    "hostina",
    "hotovost",
    "houba",
    "houf",
    "houpat",
    "houska",
    "hovor",
    "hradba",
    "hranice",
    "hravost",
    "hrazda",
    "hrbolek",
    "hrdina",
    "hrdlo",
    "hrdost",
    "hrnek",
    "hrobka",
    "hromada",
    "hrot",
    "hrouda",
    "hrozen",
    "hrstka",
    "hrubost",
    "hryzat",
    "hubenost",
    "hubnout",
    "hudba",
    "hukot",
    "humr",
    "husita",
    "hustota",
    "hvozd",
    "hybnost",
    "hydrant",
    "hygiena",
    "hymna",
    "hysterik",
    "idylka",
    "ihned",
    "ikona",
    "iluze",
    "imunita",
    "infekce",
    "inflace",
    "inkaso",
    "inovace",
    "inspekce",
    "internet",
    "invalida",
    "investor",
    "inzerce",
    "ironie",
    "jablko",
    "jachta",
    "jahoda",
    "jakmile",
    "jakost",
    "jalovec",
    "jantar",
    "jarmark",
    "jaro",
    "jasan",
    "jasno",
    "jatka",
    "javor",
    "jazyk",
    "jedinec",
    "jedle",
    "jednatel",
    "jehlan",
    "jekot",
    "jelen",
    "jelito",
    "jemnost",
    "jenom",
    "jepice",
    "jeseter",
    "jevit",
    "jezdec",
    "jezero",
    "jinak",
    "jindy",
    "jinoch",
    "jiskra",
    "jistota",
    "jitrnice",
    "jizva",
    "jmenovat",
    "jogurt",
    "jurta",
    "kabaret",
    "kabel",
    "kabinet",
    "kachna",
    "kadet",
    "kadidlo",
    "kahan",
    "kajak",
    "kajuta",
    "kakao",
    "kaktus",
    "kalamita",
    "kalhoty",
    "kalibr",
    "kalnost",
    "kamera",
    "kamkoliv",
    "kamna",
    "kanibal",
    "kanoe",
    "kantor",
    "kapalina",
    "kapela",
    "kapitola",
    "kapka",
    "kaple",
    "kapota",
    "kapr",
    "kapusta",
    "kapybara",
    "karamel",
    "karotka",
    "karton",
    "kasa",
    "katalog",
    "katedra",
    "kauce",
    "kauza",
    "kavalec",
    "kazajka",
    "kazeta",
    "kazivost",
    "kdekoliv",
    "kdesi",
    "kedluben",
    "kemp",
    "keramika",
    "kino",
    "klacek",
    "kladivo",
    "klam",
    "klapot",
    "klasika",
    "klaun",
    "klec",
    "klenba",
    "klepat",
    "klesnout",
    "klid",
    "klima",
    "klisna",
    "klobouk",
    "klokan",
    "klopa",
    "kloub",
    "klubovna",
    "klusat",
    "kluzkost",
    "kmen",
    "kmitat",
    "kmotr",
    "kniha",
    "knot",
    "koalice",
    "koberec",
    "kobka",
    "kobliha",
    "kobyla",
    "kocour",
    "kohout",
    "kojenec",
    "kokos",
    "koktejl",
    "kolaps",
    "koleda",
    "kolize",
    "kolo",
    "komando",
    "kometa",
    "komik",
    "komnata",
    "komora",
    "kompas",
    "komunita",
    "konat",
    "koncept",
    "kondice",
    "konec",
    "konfese",
    "kongres",
    "konina",
    "konkurs",
    "kontakt",
    "konzerva",
    "kopanec",
    "kopie",
    "kopnout",
    "koprovka",
    "korbel",
    "korektor",
    "kormidlo",
    "koroptev",
    "korpus",
    "koruna",
    "koryto",
    "korzet",
    "kosatec",
    "kostka",
    "kotel",
    "kotleta",
    "kotoul",
    "koukat",
    "koupelna",
    "kousek",
    "kouzlo",
    "kovboj",
    "koza",
    "kozoroh",
    "krabice",
    "krach",
    "krajina",
    "kralovat",
    "krasopis",
    "kravata",
    "kredit",
    "krejcar",
    "kresba",
    "kreveta",
    "kriket",
    "kritik",
    "krize",
    "krkavec",
    "krmelec",
    "krmivo",
    "krocan",
    "krok",
    "kronika",
    "kropit",
    "kroupa",
    "krovka",
    "krtek",
    "kruhadlo",
    "krupice",
    "krutost",
    "krvinka",
    "krychle",
    "krypta",
    "krystal",
    "kryt",
    "kudlanka",
    "kufr",
    "kujnost",
    "kukla",
    "kulajda",
    "kulich",
    "kulka",
    "kulomet",
    "kultura",
    "kuna",
    "kupodivu",
    "kurt",
    "kurzor",
    "kutil",
    "kvalita",
    "kvasinka",
    "kvestor",
    "kynolog",
    "kyselina",
    "kytara",
    "kytice",
    "kytka",
    "kytovec",
    "kyvadlo",
    "labrador",
    "lachtan",
    "ladnost",
    "laik",
    "lakomec",
    "lamela",
    "lampa",
    "lanovka",
    "lasice",
    "laso",
    "lastura",
    "latinka",
    "lavina",
    "lebka",
    "leckdy",
    "leden",
    "lednice",
    "ledovka",
    "ledvina",
    "legenda",
    "legie",
    "legrace",
    "lehce",
    "lehkost",
    "lehnout",
    "lektvar",
    "lenochod",
    "lentilka",
    "lepenka",
    "lepidlo",
    "letadlo",
    "letec",
    "letmo",
    "letokruh",
    "levhart",
    "levitace",
    "levobok",
    "libra",
    "lichotka",
    "lidojed",
    "lidskost",
    "lihovina",
    "lijavec",
    "lilek",
    "limetka",
    "linie",
    "linka",
    "linoleum",
    "listopad",
    "litina",
    "litovat",
    "lobista",
    "lodivod",
    "logika",
    "logoped",
    "lokalita",
    "loket",
    "lomcovat",
    "lopata",
    "lopuch",
    "lord",
    "losos",
    "lotr",
    "loudal",
    "louh",
    "louka",
    "louskat",
    "lovec",
    "lstivost",
    "lucerna",
    "lucifer",
    "lump",
    "lusk",
    "lustrace",
    "lvice",
    "lyra",
    "lyrika",
    "lysina",
    "madam",
    "madlo",
    "magistr",
    "mahagon",
    "majetek",
    "majitel",
    "majorita",
    "makak",
    "makovice",
    "makrela",
    "malba",
    "malina",
    "malovat",
    "malvice",
    "maminka",
    "mandle",
    "manko",
    "marnost",
    "masakr",
    "maskot",
    "masopust",
    "matice",
    "matrika",
    "maturita",
    "mazanec",
    "mazivo",
    "mazlit",
    "mazurka",
    "mdloba",
    "mechanik",
    "meditace",
    "medovina",
    "melasa",
    "meloun",
    "mentolka",
    "metla",
    "metoda",
    "metr",
    "mezera",
    "migrace",
    "mihnout",
    "mihule",
    "mikina",
    "mikrofon",
    "milenec",
    "milimetr",
    "milost",
    "mimika",
    "mincovna",
    "minibar",
    "minomet",
    "minulost",
    "miska",
    "mistr",
    "mixovat",
    "mladost",
    "mlha",
    "mlhovina",
    "mlok",
    "mlsat",
    "mluvit",
    "mnich",
    "mnohem",
    "mobil",
    "mocnost",
    "modelka",
    "modlitba",
    "mohyla",
    "mokro",
    "molekula",
    "momentka",
    "monarcha",
    "monokl",
    "monstrum",
    "montovat",
    "monzun",
    "mosaz",
    "moskyt",
    "most",
    "motivace",
    "motorka",
    "motyka",
    "moucha",
    "moudrost",
    "mozaika",
    "mozek",
    "mozol",
    "mramor",
    "mravenec",
    "mrkev",
    "mrtvola",
    "mrzet",
    "mrzutost",
    "mstitel",
    "mudrc",
    "muflon",
    "mulat",
    "mumie",
    "munice",
    "muset",
    "mutace",
    "muzeum",
    "muzikant",
    "myslivec",
    "mzda",
    "nabourat",
    "nachytat",
    "nadace",
    "nadbytek",
    "nadhoz",
    "nadobro",
    "nadpis",
    "nahlas",
    "nahnat",
    "nahodile",
    "nahradit",
    "naivita",
    "najednou",
    "najisto",
    "najmout",
    "naklonit",
    "nakonec",
    "nakrmit",
    "nalevo",
    "namazat",
    "namluvit",
    "nanometr",
    "naoko",
    "naopak",
    "naostro",
    "napadat",
    "napevno",
    "naplnit",
    "napnout",
    "naposled",
    "naprosto",
    "narodit",
    "naruby",
    "narychlo",
    "nasadit",
    "nasekat",
    "naslepo",
    "nastat",
    "natolik",
    "navenek",
    "navrch",
    "navzdory",
    "nazvat",
    "nebe",
    "nechat",
    "necky",
    "nedaleko",
    "nedbat",
    "neduh",
    "negace",
    "nehet",
    "nehoda",
    "nejen",
    "nejprve",
    "neklid",
    "nelibost",
    "nemilost",
    "nemoc",
    "neochota",
    "neonka",
    "nepokoj",
    "nerost",
    "nerv",
    "nesmysl",
    "nesoulad",
    "netvor",
    "neuron",
    "nevina",
    "nezvykle",
    "nicota",
    "nijak",
    "nikam",
    "nikdy",
    "nikl",
    "nikterak",
    "nitro",
    "nocleh",
    "nohavice",
    "nominace",
    "nora",
    "norek",
    "nositel",
    "nosnost",
    "nouze",
    "noviny",
    "novota",
    "nozdra",
    "nuda",
    "nudle",
    "nuget",
    "nutit",
    "nutnost",
    "nutrie",
    "nymfa",
    "obal",
    "obarvit",
    "obava",
    "obdiv",
    "obec",
    "obehnat",
    "obejmout",
    "obezita",
    "obhajoba",
    "obilnice",
    "objasnit",
    "objekt",
    "obklopit",
    "oblast",
    "oblek",
    "obliba",
    "obloha",
    "obluda",
    "obnos",
    "obohatit",
    "obojek",
    "obout",
    "obrazec",
    "obrna",
    "obruba",
    "obrys",
    "obsah",
    "obsluha",
    "obstarat",
    "obuv",
    "obvaz",
    "obvinit",
    "obvod",
    "obvykle",
    "obyvatel",
    "obzor",
    "ocas",
    "ocel",
    "ocenit",
    "ochladit",
    "ochota",
    "ochrana",
    "ocitnout",
    "odboj",
    "odbyt",
    "odchod",
    "odcizit",
    "odebrat",
    "odeslat",
    "odevzdat",
    "odezva",
    "odhadce",
    "odhodit",
    "odjet",
    "odjinud",
    "odkaz",
    "odkoupit",
    "odliv",
    "odluka",
    "odmlka",
    "odolnost",
    "odpad",
    "odpis",
    "odplout",
    "odpor",
    "odpustit",
    "odpykat",
    "odrazka",
    "odsoudit",
    "odstup",
    "odsun",
    "odtok",
    "odtud",
    "odvaha",
    "odveta",
    "odvolat",
    "odvracet",
    "odznak",
    "ofina",
    "ofsajd",
    "ohlas",
    "ohnisko",
    "ohrada",
    "ohrozit",
    "ohryzek",
    "okap",
    "okenice",
    "oklika",
    "okno",
    "okouzlit",
    "okovy",
    "okrasa",
    "okres",
    "okrsek",
    "okruh",
    "okupant",
    "okurka",
    "okusit",
    "olejnina",
    "olizovat",
    "omak",
    "omeleta",
    "omezit",
    "omladina",
    "omlouvat",
    "omluva",
    "omyl",
    "onehdy",
    "opakovat",
    "opasek",
    "operace",
    "opice",
    "opilost",
    "opisovat",
    "opora",
    "opozice",
    "opravdu",
    "oproti",
    "orbital",
    "orchestr",
    "orgie",
    "orlice",
    "orloj",
    "ortel",
    "osada",
    "oschnout",
    "osika",
    "osivo",
    "oslava",
    "oslepit",
    "oslnit",
    "oslovit",
    "osnova",
    "osoba",
    "osolit",
    "ospalec",
    "osten",
    "ostraha",
    "ostuda",
    "ostych",
    "osvojit",
    "oteplit",
    "otisk",
    "otop",
    "otrhat",
    "otrlost",
    "otrok",
    "otruby",
    "otvor",
    "ovanout",
    "ovar",
    "oves",
    "ovlivnit",
    "ovoce",
    "oxid",
    "ozdoba",
    "pachatel",
    "pacient",
    "padouch",
    "pahorek",
    "pakt",
    "palanda",
    "palec",
    "palivo",
    "paluba",
    "pamflet",
    "pamlsek",
    "panenka",
    "panika",
    "panna",
    "panovat",
    "panstvo",
    "pantofle",
    "paprika",
    "parketa",
    "parodie",
    "parta",
    "paruka",
    "paryba",
    "paseka",
    "pasivita",
    "pastelka",
    "patent",
    "patrona",
    "pavouk",
    "pazneht",
    "pazourek",
    "pecka",
    "pedagog",
    "pejsek",
    "peklo",
    "peloton",
    "penalta",
    "pendrek",
    "penze",
    "periskop",
    "pero",
    "pestrost",
    "petarda",
    "petice",
    "petrolej",
    "pevnina",
    "pexeso",
    "pianista",
    "piha",
    "pijavice",
    "pikle",
    "piknik",
    "pilina",
    "pilnost",
    "pilulka",
    "pinzeta",
    "pipeta",
    "pisatel",
    "pistole",
    "pitevna",
    "pivnice",
    "pivovar",
    "placenta",
    "plakat",
    "plamen",
    "planeta",
    "plastika",
    "platit",
    "plavidlo",
    "plaz",
    "plech",
    "plemeno",
    "plenta",
    "ples",
    "pletivo",
    "plevel",
    "plivat",
    "plnit",
    "plno",
    "plocha",
    "plodina",
    "plomba",
    "plout",
    "pluk",
    "plyn",
    "pobavit",
    "pobyt",
    "pochod",
    "pocit",
    "poctivec",
    "podat",
    "podcenit",
    "podepsat",
    "podhled",
    "podivit",
    "podklad",
    "podmanit",
    "podnik",
    "podoba",
    "podpora",
    "podraz",
    "podstata",
    "podvod",
    "podzim",
    "poezie",
    "pohanka",
    "pohnutka",
    "pohovor",
    "pohroma",
    "pohyb",
    "pointa",
    "pojistka",
    "pojmout",
    "pokazit",
    "pokles",
    "pokoj",
    "pokrok",
    "pokuta",
    "pokyn",
    "poledne",
    "polibek",
    "polknout",
    "poloha",
    "polynom",
    "pomalu",
    "pominout",
    "pomlka",
    "pomoc",
    "pomsta",
    "pomyslet",
    "ponechat",
    "ponorka",
    "ponurost",
    "popadat",
    "popel",
    "popisek",
    "poplach",
    "poprosit",
    "popsat",
    "popud",
    "poradce",
    "porce",
    "porod",
    "porucha",
    "poryv",
    "posadit",
    "posed",
    "posila",
    "poskok",
    "poslanec",
    "posoudit",
    "pospolu",
    "postava",
    "posudek",
    "posyp",
    "potah",
    "potkan",
    "potlesk",
    "potomek",
    "potrava",
    "potupa",
    "potvora",
    "poukaz",
    "pouto",
    "pouzdro",
    "povaha",
    "povidla",
    "povlak",
    "povoz",
    "povrch",
    "povstat",
    "povyk",
    "povzdech",
    "pozdrav",
    "pozemek",
    "poznatek",
    "pozor",
    "pozvat",
    "pracovat",
    "prahory",
    "praktika",
    "prales",
    "praotec",
    "praporek",
    "prase",
    "pravda",
    "princip",
    "prkno",
    "probudit",
    "procento",
    "prodej",
    "profese",
    "prohra",
    "projekt",
    "prolomit",
    "promile",
    "pronikat",
    "propad",
    "prorok",
    "prosba",
    "proton",
    "proutek",
    "provaz",
    "prskavka",
    "prsten",
    "prudkost",
    "prut",
    "prvek",
    "prvohory",
    "psanec",
    "psovod",
    "pstruh",
    "ptactvo",
    "puberta",
    "puch",
    "pudl",
    "pukavec",
    "puklina",
    "pukrle",
    "pult",
    "pumpa",
    "punc",
    "pupen",
    "pusa",
    "pusinka",
    "pustina",
    "putovat",
    "putyka",
    "pyramida",
    "pysk",
    "pytel",
    "racek",
    "rachot",
    "radiace",
    "radnice",
    "radon",
    "raft",
    "ragby",
    "raketa",
    "rakovina",
    "rameno",
    "rampouch",
    "rande",
    "rarach",
    "rarita",
    "rasovna",
    "rastr",
    "ratolest",
    "razance",
    "razidlo",
    "reagovat",
    "reakce",
    "recept",
    "redaktor",
    "referent",
    "reflex",
    "rejnok",
    "reklama",
    "rekord",
    "rekrut",
    "rektor",
    "reputace",
    "revize",
    "revma",
    "revolver",
    "rezerva",
    "riskovat",
    "riziko",
    "robotika",
    "rodokmen",
    "rohovka",
    "rokle",
    "rokoko",
    "romaneto",
    "ropovod",
    "ropucha",
    "rorejs",
    "rosol",
    "rostlina",
    "rotmistr",
    "rotoped",
    "rotunda",
    "roubenka",
    "roucho",
    "roup",
    "roura",
    "rovina",
    "rovnice",
    "rozbor",
    "rozchod",
    "rozdat",
    "rozeznat",
    "rozhodce",
    "rozinka",
    "rozjezd",
    "rozkaz",
    "rozloha",
    "rozmar",
    "rozpad",
    "rozruch",
    "rozsah",
    "roztok",
    "rozum",
    "rozvod",
    "rubrika",
    "ruchadlo",
    "rukavice",
    "rukopis",
    "ryba",
    "rybolov",
    "rychlost",
    "rydlo",
    "rypadlo",
    "rytina",
    "ryzost",
    "sadista",
    "sahat",
    "sako",
    "samec",
    "samizdat",
    "samota",
    "sanitka",
    "sardinka",
    "sasanka",
    "satelit",
    "sazba",
    "sazenice",
    "sbor",
    "schovat",
    "sebranka",
    "secese",
    "sedadlo",
    "sediment",
    "sedlo",
    "sehnat",
    "sejmout",
    "sekera",
    "sekta",
    "sekunda",
    "sekvoje",
    "semeno",
    "seno",
    "servis",
    "sesadit",
    "seshora",
    "seskok",
    "seslat",
    "sestra",
    "sesuv",
    "sesypat",
    "setba",
    "setina",
    "setkat",
    "setnout",
    "setrvat",
    "sever",
    "seznam",
    "shoda",
    "shrnout",
    "sifon",
    "silnice",
    "sirka",
    "sirotek",
    "sirup",
    "situace",
    "skafandr",
    "skalisko",
    "skanzen",
    "skaut",
    "skeptik",
    "skica",
    "skladba",
    "sklenice",
    "sklo",
    "skluz",
    "skoba",
    "skokan",
    "skoro",
    "skripta",
    "skrz",
    "skupina",
    "skvost",
    "skvrna",
    "slabika",
    "sladidlo",
    "slanina",
    "slast",
    "slavnost",
    "sledovat",
    "slepec",
    "sleva",
    "slezina",
    "slib",
    "slina",
    "sliznice",
    "slon",
    "sloupek",
    "slovo",
    "sluch",
    "sluha",
    "slunce",
    "slupka",
    "slza",
    "smaragd",
    "smetana",
    "smilstvo",
    "smlouva",
    "smog",
    "smrad",
    "smrk",
    "smrtka",
    "smutek",
    "smysl",
    "snad",
    "snaha",
    "snob",
    "sobota",
    "socha",
    "sodovka",
    "sokol",
    "sopka",
    "sotva",
    "souboj",
    "soucit",
    "soudce",
    "souhlas",
    "soulad",
    "soumrak",
    "souprava",
    "soused",
    "soutok",
    "souviset",
    "spalovna",
    "spasitel",
    "spis",
    "splav",
    "spodek",
    "spojenec",
    "spolu",
    "sponzor",
    "spornost",
    "spousta",
    "sprcha",
    "spustit",
    "sranda",
    "sraz",
    "srdce",
    "srna",
    "srnec",
    "srovnat",
    "srpen",
    "srst",
    "srub",
    "stanice",
    "starosta",
    "statika",
    "stavba",
    "stehno",
    "stezka",
    "stodola",
    "stolek",
    "stopa",
    "storno",
    "stoupat",
    "strach",
    "stres",
    "strhnout",
    "strom",
    "struna",
    "studna",
    "stupnice",
    "stvol",
    "styk",
    "subjekt",
    "subtropy",
    "suchar",
    "sudost",
    "sukno",
    "sundat",
    "sunout",
    "surikata",
    "surovina",
    "svah",
    "svalstvo",
    "svetr",
    "svatba",
    "svazek",
    "svisle",
    "svitek",
    "svoboda",
    "svodidlo",
    "svorka",
    "svrab",
    "sykavka",
    "sykot",
    "synek",
    "synovec",
    "sypat",
    "sypkost",
    "syrovost",
    "sysel",
    "sytost",
    "tabletka",
    "tabule",
    "tahoun",
    "tajemno",
    "tajfun",
    "tajga",
    "tajit",
    "tajnost",
    "taktika",
    "tamhle",
    "tampon",
    "tancovat",
    "tanec",
    "tanker",
    "tapeta",
    "tavenina",
    "tazatel",
    "technika",
    "tehdy",
    "tekutina",
    "telefon",
    "temnota",
    "tendence",
    "tenista",
    "tenor",
    "teplota",
    "tepna",
    "teprve",
    "terapie",
    "termoska",
    "textil",
    "ticho",
    "tiskopis",
    "titulek",
    "tkadlec",
    "tkanina",
    "tlapka",
    "tleskat",
    "tlukot",
    "tlupa",
    "tmel",
    "toaleta",
    "topinka",
    "topol",
    "torzo",
    "touha",
    "toulec",
    "tradice",
    "traktor",
    "tramp",
    "trasa",
    "traverza",
    "trefit",
    "trest",
    "trezor",
    "trhavina",
    "trhlina",
    "trochu",
    "trojice",
    "troska",
    "trouba",
    "trpce",
    "trpitel",
    "trpkost",
    "trubec",
    "truchlit",
    "truhlice",
    "trus",
    "trvat",
    "tudy",
    "tuhnout",
    "tuhost",
    "tundra",
    "turista",
    "turnaj",
    "tuzemsko",
    "tvaroh",
    "tvorba",
    "tvrdost",
    "tvrz",
    "tygr",
    "tykev",
    "ubohost",
    "uboze",
    "ubrat",
    "ubrousek",
    "ubrus",
    "ubytovna",
    "ucho",
    "uctivost",
    "udivit",
    "uhradit",
    "ujednat",
    "ujistit",
    "ujmout",
    "ukazatel",
    "uklidnit",
    "uklonit",
    "ukotvit",
    "ukrojit",
    "ulice",
    "ulita",
    "ulovit",
    "umyvadlo",
    "unavit",
    "uniforma",
    "uniknout",
    "upadnout",
    "uplatnit",
    "uplynout",
    "upoutat",
    "upravit",
    "uran",
    "urazit",
    "usednout",
    "usilovat",
    "usmrtit",
    "usnadnit",
    "usnout",
    "usoudit",
    "ustlat",
    "ustrnout",
    "utahovat",
    "utkat",
    "utlumit",
    "utonout",
    "utopenec",
    "utrousit",
    "uvalit",
    "uvolnit",
    "uvozovka",
    "uzdravit",
    "uzel",
    "uzenina",
    "uzlina",
    "uznat",
    "vagon",
    "valcha",
    "valoun",
    "vana",
    "vandal",
    "vanilka",
    "varan",
    "varhany",
    "varovat",
    "vcelku",
    "vchod",
    "vdova",
    "vedro",
    "vegetace",
    "vejce",
    "velbloud",
    "veletrh",
    "velitel",
    "velmoc",
    "velryba",
    "venkov",
    "veranda",
    "verze",
    "veselka",
    "veskrze",
    "vesnice",
    "vespodu",
    "vesta",
    "veterina",
    "veverka",
    "vibrace",
    "vichr",
    "videohra",
    "vidina",
    "vidle",
    "vila",
    "vinice",
    "viset",
    "vitalita",
    "vize",
    "vizitka",
    "vjezd",
    "vklad",
    "vkus",
    "vlajka",
    "vlak",
    "vlasec",
    "vlevo",
    "vlhkost",
    "vliv",
    "vlnovka",
    "vloupat",
    "vnucovat",
    "vnuk",
    "voda",
    "vodivost",
    "vodoznak",
    "vodstvo",
    "vojensky",
    "vojna",
    "vojsko",
    "volant",
    "volba",
    "volit",
    "volno",
    "voskovka",
    "vozidlo",
    "vozovna",
    "vpravo",
    "vrabec",
    "vracet",
    "vrah",
    "vrata",
    "vrba",
    "vrcholek",
    "vrhat",
    "vrstva",
    "vrtule",
    "vsadit",
    "vstoupit",
    "vstup",
    "vtip",
    "vybavit",
    "vybrat",
    "vychovat",
    "vydat",
    "vydra",
    "vyfotit",
    "vyhledat",
    "vyhnout",
    "vyhodit",
    "vyhradit",
    "vyhubit",
    "vyjasnit",
    "vyjet",
    "vyjmout",
    "vyklopit",
    "vykonat",
    "vylekat",
    "vymazat",
    "vymezit",
    "vymizet",
    "vymyslet",
    "vynechat",
    "vynikat",
    "vynutit",
    "vypadat",
    "vyplatit",
    "vypravit",
    "vypustit",
    "vyrazit",
    "vyrovnat",
    "vyrvat",
    "vyslovit",
    "vysoko",
    "vystavit",
    "vysunout",
    "vysypat",
    "vytasit",
    "vytesat",
    "vytratit",
    "vyvinout",
    "vyvolat",
    "vyvrhel",
    "vyzdobit",
    "vyznat",
    "vzadu",
    "vzbudit",
    "vzchopit",
    "vzdor",
    "vzduch",
    "vzdychat",
    "vzestup",
    "vzhledem",
    "vzkaz",
    "vzlykat",
    "vznik",
    "vzorek",
    "vzpoura",
    "vztah",
    "vztek",
    "xylofon",
    "zabrat",
    "zabydlet",
    "zachovat",
    "zadarmo",
    "zadusit",
    "zafoukat",
    "zahltit",
    "zahodit",
    "zahrada",
    "zahynout",
    "zajatec",
    "zajet",
    "zajistit",
    "zaklepat",
    "zakoupit",
    "zalepit",
    "zamezit",
    "zamotat",
    "zamyslet",
    "zanechat",
    "zanikat",
    "zaplatit",
    "zapojit",
    "zapsat",
    "zarazit",
    "zastavit",
    "zasunout",
    "zatajit",
    "zatemnit",
    "zatknout",
    "zaujmout",
    "zavalit",
    "zavelet",
    "zavinit",
    "zavolat",
    "zavrtat",
    "zazvonit",
    "zbavit",
    "zbrusu",
    "zbudovat",
    "zbytek",
    "zdaleka",
    "zdarma",
    "zdatnost",
    "zdivo",
    "zdobit",
    "zdroj",
    "zdvih",
    "zdymadlo",
    "zelenina",
    "zeman",
    "zemina",
    "zeptat",
    "zezadu",
    "zezdola",
    "zhatit",
    "zhltnout",
    "zhluboka",
    "zhotovit",
    "zhruba",
    "zima",
    "zimnice",
    "zjemnit",
    "zklamat",
    "zkoumat",
    "zkratka",
    "zkumavka",
    "zlato",
    "zlehka",
    "zloba",
    "zlom",
    "zlost",
    "zlozvyk",
    "zmapovat",
    "zmar",
    "zmatek",
    "zmije",
    "zmizet",
    "zmocnit",
    "zmodrat",
    "zmrzlina",
    "zmutovat",
    "znak",
    "znalost",
    "znamenat",
    "znovu",
    "zobrazit",
    "zotavit",
    "zoubek",
    "zoufale",
    "zplodit",
    "zpomalit",
    "zprava",
    "zprostit",
    "zprudka",
    "zprvu",
    "zrada",
    "zranit",
    "zrcadlo",
    "zrnitost",
    "zrno",
    "zrovna",
    "zrychlit",
    "zrzavost",
    "zticha",
    "ztratit",
    "zubovina",
    "zubr",
    "zvednout",
    "zvenku",
    "zvesela",
    "zvon",
    "zvrat",
    "zvukovod",
    "zvyk"
]

      };
    };
  }
}, {package:"bip39",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\czech.json",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\italian.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\key-tree\node_modules\bip39\src\wordlists\italian.json
      return function (require, module, exports) {
module.exports=[
    "abaco",
    "abbaglio",
    "abbinato",
    "abete",
    "abisso",
    "abolire",
    "abrasivo",
    "abrogato",
    "accadere",
    "accenno",
    "accusato",
    "acetone",
    "achille",
    "acido",
    "acqua",
    "acre",
    "acrilico",
    "acrobata",
    "acuto",
    "adagio",
    "addebito",
    "addome",
    "adeguato",
    "aderire",
    "adipe",
    "adottare",
    "adulare",
    "affabile",
    "affetto",
    "affisso",
    "affranto",
    "aforisma",
    "afoso",
    "africano",
    "agave",
    "agente",
    "agevole",
    "aggancio",
    "agire",
    "agitare",
    "agonismo",
    "agricolo",
    "agrumeto",
    "aguzzo",
    "alabarda",
    "alato",
    "albatro",
    "alberato",
    "albo",
    "albume",
    "alce",
    "alcolico",
    "alettone",
    "alfa",
    "algebra",
    "aliante",
    "alibi",
    "alimento",
    "allagato",
    "allegro",
    "allievo",
    "allodola",
    "allusivo",
    "almeno",
    "alogeno",
    "alpaca",
    "alpestre",
    "altalena",
    "alterno",
    "alticcio",
    "altrove",
    "alunno",
    "alveolo",
    "alzare",
    "amalgama",
    "amanita",
    "amarena",
    "ambito",
    "ambrato",
    "ameba",
    "america",
    "ametista",
    "amico",
    "ammasso",
    "ammenda",
    "ammirare",
    "ammonito",
    "amore",
    "ampio",
    "ampliare",
    "amuleto",
    "anacardo",
    "anagrafe",
    "analista",
    "anarchia",
    "anatra",
    "anca",
    "ancella",
    "ancora",
    "andare",
    "andrea",
    "anello",
    "angelo",
    "angolare",
    "angusto",
    "anima",
    "annegare",
    "annidato",
    "anno",
    "annuncio",
    "anonimo",
    "anticipo",
    "anzi",
    "apatico",
    "apertura",
    "apode",
    "apparire",
    "appetito",
    "appoggio",
    "approdo",
    "appunto",
    "aprile",
    "arabica",
    "arachide",
    "aragosta",
    "araldica",
    "arancio",
    "aratura",
    "arazzo",
    "arbitro",
    "archivio",
    "ardito",
    "arenile",
    "argento",
    "argine",
    "arguto",
    "aria",
    "armonia",
    "arnese",
    "arredato",
    "arringa",
    "arrosto",
    "arsenico",
    "arso",
    "artefice",
    "arzillo",
    "asciutto",
    "ascolto",
    "asepsi",
    "asettico",
    "asfalto",
    "asino",
    "asola",
    "aspirato",
    "aspro",
    "assaggio",
    "asse",
    "assoluto",
    "assurdo",
    "asta",
    "astenuto",
    "astice",
    "astratto",
    "atavico",
    "ateismo",
    "atomico",
    "atono",
    "attesa",
    "attivare",
    "attorno",
    "attrito",
    "attuale",
    "ausilio",
    "austria",
    "autista",
    "autonomo",
    "autunno",
    "avanzato",
    "avere",
    "avvenire",
    "avviso",
    "avvolgere",
    "azione",
    "azoto",
    "azzimo",
    "azzurro",
    "babele",
    "baccano",
    "bacino",
    "baco",
    "badessa",
    "badilata",
    "bagnato",
    "baita",
    "balcone",
    "baldo",
    "balena",
    "ballata",
    "balzano",
    "bambino",
    "bandire",
    "baraonda",
    "barbaro",
    "barca",
    "baritono",
    "barlume",
    "barocco",
    "basilico",
    "basso",
    "batosta",
    "battuto",
    "baule",
    "bava",
    "bavosa",
    "becco",
    "beffa",
    "belgio",
    "belva",
    "benda",
    "benevole",
    "benigno",
    "benzina",
    "bere",
    "berlina",
    "beta",
    "bibita",
    "bici",
    "bidone",
    "bifido",
    "biga",
    "bilancia",
    "bimbo",
    "binocolo",
    "biologo",
    "bipede",
    "bipolare",
    "birbante",
    "birra",
    "biscotto",
    "bisesto",
    "bisnonno",
    "bisonte",
    "bisturi",
    "bizzarro",
    "blando",
    "blatta",
    "bollito",
    "bonifico",
    "bordo",
    "bosco",
    "botanico",
    "bottino",
    "bozzolo",
    "braccio",
    "bradipo",
    "brama",
    "branca",
    "bravura",
    "bretella",
    "brevetto",
    "brezza",
    "briglia",
    "brillante",
    "brindare",
    "broccolo",
    "brodo",
    "bronzina",
    "brullo",
    "bruno",
    "bubbone",
    "buca",
    "budino",
    "buffone",
    "buio",
    "bulbo",
    "buono",
    "burlone",
    "burrasca",
    "bussola",
    "busta",
    "cadetto",
    "caduco",
    "calamaro",
    "calcolo",
    "calesse",
    "calibro",
    "calmo",
    "caloria",
    "cambusa",
    "camerata",
    "camicia",
    "cammino",
    "camola",
    "campale",
    "canapa",
    "candela",
    "cane",
    "canino",
    "canotto",
    "cantina",
    "capace",
    "capello",
    "capitolo",
    "capogiro",
    "cappero",
    "capra",
    "capsula",
    "carapace",
    "carcassa",
    "cardo",
    "carisma",
    "carovana",
    "carretto",
    "cartolina",
    "casaccio",
    "cascata",
    "caserma",
    "caso",
    "cassone",
    "castello",
    "casuale",
    "catasta",
    "catena",
    "catrame",
    "cauto",
    "cavillo",
    "cedibile",
    "cedrata",
    "cefalo",
    "celebre",
    "cellulare",
    "cena",
    "cenone",
    "centesimo",
    "ceramica",
    "cercare",
    "certo",
    "cerume",
    "cervello",
    "cesoia",
    "cespo",
    "ceto",
    "chela",
    "chiaro",
    "chicca",
    "chiedere",
    "chimera",
    "china",
    "chirurgo",
    "chitarra",
    "ciao",
    "ciclismo",
    "cifrare",
    "cigno",
    "cilindro",
    "ciottolo",
    "circa",
    "cirrosi",
    "citrico",
    "cittadino",
    "ciuffo",
    "civetta",
    "civile",
    "classico",
    "clinica",
    "cloro",
    "cocco",
    "codardo",
    "codice",
    "coerente",
    "cognome",
    "collare",
    "colmato",
    "colore",
    "colposo",
    "coltivato",
    "colza",
    "coma",
    "cometa",
    "commando",
    "comodo",
    "computer",
    "comune",
    "conciso",
    "condurre",
    "conferma",
    "congelare",
    "coniuge",
    "connesso",
    "conoscere",
    "consumo",
    "continuo",
    "convegno",
    "coperto",
    "copione",
    "coppia",
    "copricapo",
    "corazza",
    "cordata",
    "coricato",
    "cornice",
    "corolla",
    "corpo",
    "corredo",
    "corsia",
    "cortese",
    "cosmico",
    "costante",
    "cottura",
    "covato",
    "cratere",
    "cravatta",
    "creato",
    "credere",
    "cremoso",
    "crescita",
    "creta",
    "criceto",
    "crinale",
    "crisi",
    "critico",
    "croce",
    "cronaca",
    "crostata",
    "cruciale",
    "crusca",
    "cucire",
    "cuculo",
    "cugino",
    "cullato",
    "cupola",
    "curatore",
    "cursore",
    "curvo",
    "cuscino",
    "custode",
    "dado",
    "daino",
    "dalmata",
    "damerino",
    "daniela",
    "dannoso",
    "danzare",
    "datato",
    "davanti",
    "davvero",
    "debutto",
    "decennio",
    "deciso",
    "declino",
    "decollo",
    "decreto",
    "dedicato",
    "definito",
    "deforme",
    "degno",
    "delegare",
    "delfino",
    "delirio",
    "delta",
    "demenza",
    "denotato",
    "dentro",
    "deposito",
    "derapata",
    "derivare",
    "deroga",
    "descritto",
    "deserto",
    "desiderio",
    "desumere",
    "detersivo",
    "devoto",
    "diametro",
    "dicembre",
    "diedro",
    "difeso",
    "diffuso",
    "digerire",
    "digitale",
    "diluvio",
    "dinamico",
    "dinnanzi",
    "dipinto",
    "diploma",
    "dipolo",
    "diradare",
    "dire",
    "dirotto",
    "dirupo",
    "disagio",
    "discreto",
    "disfare",
    "disgelo",
    "disposto",
    "distanza",
    "disumano",
    "dito",
    "divano",
    "divelto",
    "dividere",
    "divorato",
    "doblone",
    "docente",
    "doganale",
    "dogma",
    "dolce",
    "domato",
    "domenica",
    "dominare",
    "dondolo",
    "dono",
    "dormire",
    "dote",
    "dottore",
    "dovuto",
    "dozzina",
    "drago",
    "druido",
    "dubbio",
    "dubitare",
    "ducale",
    "duna",
    "duomo",
    "duplice",
    "duraturo",
    "ebano",
    "eccesso",
    "ecco",
    "eclissi",
    "economia",
    "edera",
    "edicola",
    "edile",
    "editoria",
    "educare",
    "egemonia",
    "egli",
    "egoismo",
    "egregio",
    "elaborato",
    "elargire",
    "elegante",
    "elencato",
    "eletto",
    "elevare",
    "elfico",
    "elica",
    "elmo",
    "elsa",
    "eluso",
    "emanato",
    "emblema",
    "emesso",
    "emiro",
    "emotivo",
    "emozione",
    "empirico",
    "emulo",
    "endemico",
    "enduro",
    "energia",
    "enfasi",
    "enoteca",
    "entrare",
    "enzima",
    "epatite",
    "epilogo",
    "episodio",
    "epocale",
    "eppure",
    "equatore",
    "erario",
    "erba",
    "erboso",
    "erede",
    "eremita",
    "erigere",
    "ermetico",
    "eroe",
    "erosivo",
    "errante",
    "esagono",
    "esame",
    "esanime",
    "esaudire",
    "esca",
    "esempio",
    "esercito",
    "esibito",
    "esigente",
    "esistere",
    "esito",
    "esofago",
    "esortato",
    "esoso",
    "espanso",
    "espresso",
    "essenza",
    "esso",
    "esteso",
    "estimare",
    "estonia",
    "estroso",
    "esultare",
    "etilico",
    "etnico",
    "etrusco",
    "etto",
    "euclideo",
    "europa",
    "evaso",
    "evidenza",
    "evitato",
    "evoluto",
    "evviva",
    "fabbrica",
    "faccenda",
    "fachiro",
    "falco",
    "famiglia",
    "fanale",
    "fanfara",
    "fango",
    "fantasma",
    "fare",
    "farfalla",
    "farinoso",
    "farmaco",
    "fascia",
    "fastoso",
    "fasullo",
    "faticare",
    "fato",
    "favoloso",
    "febbre",
    "fecola",
    "fede",
    "fegato",
    "felpa",
    "feltro",
    "femmina",
    "fendere",
    "fenomeno",
    "fermento",
    "ferro",
    "fertile",
    "fessura",
    "festivo",
    "fetta",
    "feudo",
    "fiaba",
    "fiducia",
    "fifa",
    "figurato",
    "filo",
    "finanza",
    "finestra",
    "finire",
    "fiore",
    "fiscale",
    "fisico",
    "fiume",
    "flacone",
    "flamenco",
    "flebo",
    "flemma",
    "florido",
    "fluente",
    "fluoro",
    "fobico",
    "focaccia",
    "focoso",
    "foderato",
    "foglio",
    "folata",
    "folclore",
    "folgore",
    "fondente",
    "fonetico",
    "fonia",
    "fontana",
    "forbito",
    "forchetta",
    "foresta",
    "formica",
    "fornaio",
    "foro",
    "fortezza",
    "forzare",
    "fosfato",
    "fosso",
    "fracasso",
    "frana",
    "frassino",
    "fratello",
    "freccetta",
    "frenata",
    "fresco",
    "frigo",
    "frollino",
    "fronde",
    "frugale",
    "frutta",
    "fucilata",
    "fucsia",
    "fuggente",
    "fulmine",
    "fulvo",
    "fumante",
    "fumetto",
    "fumoso",
    "fune",
    "funzione",
    "fuoco",
    "furbo",
    "furgone",
    "furore",
    "fuso",
    "futile",
    "gabbiano",
    "gaffe",
    "galateo",
    "gallina",
    "galoppo",
    "gambero",
    "gamma",
    "garanzia",
    "garbo",
    "garofano",
    "garzone",
    "gasdotto",
    "gasolio",
    "gastrico",
    "gatto",
    "gaudio",
    "gazebo",
    "gazzella",
    "geco",
    "gelatina",
    "gelso",
    "gemello",
    "gemmato",
    "gene",
    "genitore",
    "gennaio",
    "genotipo",
    "gergo",
    "ghepardo",
    "ghiaccio",
    "ghisa",
    "giallo",
    "gilda",
    "ginepro",
    "giocare",
    "gioiello",
    "giorno",
    "giove",
    "girato",
    "girone",
    "gittata",
    "giudizio",
    "giurato",
    "giusto",
    "globulo",
    "glutine",
    "gnomo",
    "gobba",
    "golf",
    "gomito",
    "gommone",
    "gonfio",
    "gonna",
    "governo",
    "gracile",
    "grado",
    "grafico",
    "grammo",
    "grande",
    "grattare",
    "gravoso",
    "grazia",
    "greca",
    "gregge",
    "grifone",
    "grigio",
    "grinza",
    "grotta",
    "gruppo",
    "guadagno",
    "guaio",
    "guanto",
    "guardare",
    "gufo",
    "guidare",
    "ibernato",
    "icona",
    "identico",
    "idillio",
    "idolo",
    "idra",
    "idrico",
    "idrogeno",
    "igiene",
    "ignaro",
    "ignorato",
    "ilare",
    "illeso",
    "illogico",
    "illudere",
    "imballo",
    "imbevuto",
    "imbocco",
    "imbuto",
    "immane",
    "immerso",
    "immolato",
    "impacco",
    "impeto",
    "impiego",
    "importo",
    "impronta",
    "inalare",
    "inarcare",
    "inattivo",
    "incanto",
    "incendio",
    "inchino",
    "incisivo",
    "incluso",
    "incontro",
    "incrocio",
    "incubo",
    "indagine",
    "india",
    "indole",
    "inedito",
    "infatti",
    "infilare",
    "inflitto",
    "ingaggio",
    "ingegno",
    "inglese",
    "ingordo",
    "ingrosso",
    "innesco",
    "inodore",
    "inoltrare",
    "inondato",
    "insano",
    "insetto",
    "insieme",
    "insonnia",
    "insulina",
    "intasato",
    "intero",
    "intonaco",
    "intuito",
    "inumidire",
    "invalido",
    "invece",
    "invito",
    "iperbole",
    "ipnotico",
    "ipotesi",
    "ippica",
    "iride",
    "irlanda",
    "ironico",
    "irrigato",
    "irrorare",
    "isolato",
    "isotopo",
    "isterico",
    "istituto",
    "istrice",
    "italia",
    "iterare",
    "labbro",
    "labirinto",
    "lacca",
    "lacerato",
    "lacrima",
    "lacuna",
    "laddove",
    "lago",
    "lampo",
    "lancetta",
    "lanterna",
    "lardoso",
    "larga",
    "laringe",
    "lastra",
    "latenza",
    "latino",
    "lattuga",
    "lavagna",
    "lavoro",
    "legale",
    "leggero",
    "lembo",
    "lentezza",
    "lenza",
    "leone",
    "lepre",
    "lesivo",
    "lessato",
    "lesto",
    "letterale",
    "leva",
    "levigato",
    "libero",
    "lido",
    "lievito",
    "lilla",
    "limatura",
    "limitare",
    "limpido",
    "lineare",
    "lingua",
    "liquido",
    "lira",
    "lirica",
    "lisca",
    "lite",
    "litigio",
    "livrea",
    "locanda",
    "lode",
    "logica",
    "lombare",
    "londra",
    "longevo",
    "loquace",
    "lorenzo",
    "loto",
    "lotteria",
    "luce",
    "lucidato",
    "lumaca",
    "luminoso",
    "lungo",
    "lupo",
    "luppolo",
    "lusinga",
    "lusso",
    "lutto",
    "macabro",
    "macchina",
    "macero",
    "macinato",
    "madama",
    "magico",
    "maglia",
    "magnete",
    "magro",
    "maiolica",
    "malafede",
    "malgrado",
    "malinteso",
    "malsano",
    "malto",
    "malumore",
    "mana",
    "mancia",
    "mandorla",
    "mangiare",
    "manifesto",
    "mannaro",
    "manovra",
    "mansarda",
    "mantide",
    "manubrio",
    "mappa",
    "maratona",
    "marcire",
    "maretta",
    "marmo",
    "marsupio",
    "maschera",
    "massaia",
    "mastino",
    "materasso",
    "matricola",
    "mattone",
    "maturo",
    "mazurca",
    "meandro",
    "meccanico",
    "mecenate",
    "medesimo",
    "meditare",
    "mega",
    "melassa",
    "melis",
    "melodia",
    "meninge",
    "meno",
    "mensola",
    "mercurio",
    "merenda",
    "merlo",
    "meschino",
    "mese",
    "messere",
    "mestolo",
    "metallo",
    "metodo",
    "mettere",
    "miagolare",
    "mica",
    "micelio",
    "michele",
    "microbo",
    "midollo",
    "miele",
    "migliore",
    "milano",
    "milite",
    "mimosa",
    "minerale",
    "mini",
    "minore",
    "mirino",
    "mirtillo",
    "miscela",
    "missiva",
    "misto",
    "misurare",
    "mitezza",
    "mitigare",
    "mitra",
    "mittente",
    "mnemonico",
    "modello",
    "modifica",
    "modulo",
    "mogano",
    "mogio",
    "mole",
    "molosso",
    "monastero",
    "monco",
    "mondina",
    "monetario",
    "monile",
    "monotono",
    "monsone",
    "montato",
    "monviso",
    "mora",
    "mordere",
    "morsicato",
    "mostro",
    "motivato",
    "motosega",
    "motto",
    "movenza",
    "movimento",
    "mozzo",
    "mucca",
    "mucosa",
    "muffa",
    "mughetto",
    "mugnaio",
    "mulatto",
    "mulinello",
    "multiplo",
    "mummia",
    "munto",
    "muovere",
    "murale",
    "musa",
    "muscolo",
    "musica",
    "mutevole",
    "muto",
    "nababbo",
    "nafta",
    "nanometro",
    "narciso",
    "narice",
    "narrato",
    "nascere",
    "nastrare",
    "naturale",
    "nautica",
    "naviglio",
    "nebulosa",
    "necrosi",
    "negativo",
    "negozio",
    "nemmeno",
    "neofita",
    "neretto",
    "nervo",
    "nessuno",
    "nettuno",
    "neutrale",
    "neve",
    "nevrotico",
    "nicchia",
    "ninfa",
    "nitido",
    "nobile",
    "nocivo",
    "nodo",
    "nome",
    "nomina",
    "nordico",
    "normale",
    "norvegese",
    "nostrano",
    "notare",
    "notizia",
    "notturno",
    "novella",
    "nucleo",
    "nulla",
    "numero",
    "nuovo",
    "nutrire",
    "nuvola",
    "nuziale",
    "oasi",
    "obbedire",
    "obbligo",
    "obelisco",
    "oblio",
    "obolo",
    "obsoleto",
    "occasione",
    "occhio",
    "occidente",
    "occorrere",
    "occultare",
    "ocra",
    "oculato",
    "odierno",
    "odorare",
    "offerta",
    "offrire",
    "offuscato",
    "oggetto",
    "oggi",
    "ognuno",
    "olandese",
    "olfatto",
    "oliato",
    "oliva",
    "ologramma",
    "oltre",
    "omaggio",
    "ombelico",
    "ombra",
    "omega",
    "omissione",
    "ondoso",
    "onere",
    "onice",
    "onnivoro",
    "onorevole",
    "onta",
    "operato",
    "opinione",
    "opposto",
    "oracolo",
    "orafo",
    "ordine",
    "orecchino",
    "orefice",
    "orfano",
    "organico",
    "origine",
    "orizzonte",
    "orma",
    "ormeggio",
    "ornativo",
    "orologio",
    "orrendo",
    "orribile",
    "ortensia",
    "ortica",
    "orzata",
    "orzo",
    "osare",
    "oscurare",
    "osmosi",
    "ospedale",
    "ospite",
    "ossa",
    "ossidare",
    "ostacolo",
    "oste",
    "otite",
    "otre",
    "ottagono",
    "ottimo",
    "ottobre",
    "ovale",
    "ovest",
    "ovino",
    "oviparo",
    "ovocito",
    "ovunque",
    "ovviare",
    "ozio",
    "pacchetto",
    "pace",
    "pacifico",
    "padella",
    "padrone",
    "paese",
    "paga",
    "pagina",
    "palazzina",
    "palesare",
    "pallido",
    "palo",
    "palude",
    "pandoro",
    "pannello",
    "paolo",
    "paonazzo",
    "paprica",
    "parabola",
    "parcella",
    "parere",
    "pargolo",
    "pari",
    "parlato",
    "parola",
    "partire",
    "parvenza",
    "parziale",
    "passivo",
    "pasticca",
    "patacca",
    "patologia",
    "pattume",
    "pavone",
    "peccato",
    "pedalare",
    "pedonale",
    "peggio",
    "peloso",
    "penare",
    "pendice",
    "penisola",
    "pennuto",
    "penombra",
    "pensare",
    "pentola",
    "pepe",
    "pepita",
    "perbene",
    "percorso",
    "perdonato",
    "perforare",
    "pergamena",
    "periodo",
    "permesso",
    "perno",
    "perplesso",
    "persuaso",
    "pertugio",
    "pervaso",
    "pesatore",
    "pesista",
    "peso",
    "pestifero",
    "petalo",
    "pettine",
    "petulante",
    "pezzo",
    "piacere",
    "pianta",
    "piattino",
    "piccino",
    "picozza",
    "piega",
    "pietra",
    "piffero",
    "pigiama",
    "pigolio",
    "pigro",
    "pila",
    "pilifero",
    "pillola",
    "pilota",
    "pimpante",
    "pineta",
    "pinna",
    "pinolo",
    "pioggia",
    "piombo",
    "piramide",
    "piretico",
    "pirite",
    "pirolisi",
    "pitone",
    "pizzico",
    "placebo",
    "planare",
    "plasma",
    "platano",
    "plenario",
    "pochezza",
    "poderoso",
    "podismo",
    "poesia",
    "poggiare",
    "polenta",
    "poligono",
    "pollice",
    "polmonite",
    "polpetta",
    "polso",
    "poltrona",
    "polvere",
    "pomice",
    "pomodoro",
    "ponte",
    "popoloso",
    "porfido",
    "poroso",
    "porpora",
    "porre",
    "portata",
    "posa",
    "positivo",
    "possesso",
    "postulato",
    "potassio",
    "potere",
    "pranzo",
    "prassi",
    "pratica",
    "precluso",
    "predica",
    "prefisso",
    "pregiato",
    "prelievo",
    "premere",
    "prenotare",
    "preparato",
    "presenza",
    "pretesto",
    "prevalso",
    "prima",
    "principe",
    "privato",
    "problema",
    "procura",
    "produrre",
    "profumo",
    "progetto",
    "prolunga",
    "promessa",
    "pronome",
    "proposta",
    "proroga",
    "proteso",
    "prova",
    "prudente",
    "prugna",
    "prurito",
    "psiche",
    "pubblico",
    "pudica",
    "pugilato",
    "pugno",
    "pulce",
    "pulito",
    "pulsante",
    "puntare",
    "pupazzo",
    "pupilla",
    "puro",
    "quadro",
    "qualcosa",
    "quasi",
    "querela",
    "quota",
    "raccolto",
    "raddoppio",
    "radicale",
    "radunato",
    "raffica",
    "ragazzo",
    "ragione",
    "ragno",
    "ramarro",
    "ramingo",
    "ramo",
    "randagio",
    "rantolare",
    "rapato",
    "rapina",
    "rappreso",
    "rasatura",
    "raschiato",
    "rasente",
    "rassegna",
    "rastrello",
    "rata",
    "ravveduto",
    "reale",
    "recepire",
    "recinto",
    "recluta",
    "recondito",
    "recupero",
    "reddito",
    "redimere",
    "regalato",
    "registro",
    "regola",
    "regresso",
    "relazione",
    "remare",
    "remoto",
    "renna",
    "replica",
    "reprimere",
    "reputare",
    "resa",
    "residente",
    "responso",
    "restauro",
    "rete",
    "retina",
    "retorica",
    "rettifica",
    "revocato",
    "riassunto",
    "ribadire",
    "ribelle",
    "ribrezzo",
    "ricarica",
    "ricco",
    "ricevere",
    "riciclato",
    "ricordo",
    "ricreduto",
    "ridicolo",
    "ridurre",
    "rifasare",
    "riflesso",
    "riforma",
    "rifugio",
    "rigare",
    "rigettato",
    "righello",
    "rilassato",
    "rilevato",
    "rimanere",
    "rimbalzo",
    "rimedio",
    "rimorchio",
    "rinascita",
    "rincaro",
    "rinforzo",
    "rinnovo",
    "rinomato",
    "rinsavito",
    "rintocco",
    "rinuncia",
    "rinvenire",
    "riparato",
    "ripetuto",
    "ripieno",
    "riportare",
    "ripresa",
    "ripulire",
    "risata",
    "rischio",
    "riserva",
    "risibile",
    "riso",
    "rispetto",
    "ristoro",
    "risultato",
    "risvolto",
    "ritardo",
    "ritegno",
    "ritmico",
    "ritrovo",
    "riunione",
    "riva",
    "riverso",
    "rivincita",
    "rivolto",
    "rizoma",
    "roba",
    "robotico",
    "robusto",
    "roccia",
    "roco",
    "rodaggio",
    "rodere",
    "roditore",
    "rogito",
    "rollio",
    "romantico",
    "rompere",
    "ronzio",
    "rosolare",
    "rospo",
    "rotante",
    "rotondo",
    "rotula",
    "rovescio",
    "rubizzo",
    "rubrica",
    "ruga",
    "rullino",
    "rumine",
    "rumoroso",
    "ruolo",
    "rupe",
    "russare",
    "rustico",
    "sabato",
    "sabbiare",
    "sabotato",
    "sagoma",
    "salasso",
    "saldatura",
    "salgemma",
    "salivare",
    "salmone",
    "salone",
    "saltare",
    "saluto",
    "salvo",
    "sapere",
    "sapido",
    "saporito",
    "saraceno",
    "sarcasmo",
    "sarto",
    "sassoso",
    "satellite",
    "satira",
    "satollo",
    "saturno",
    "savana",
    "savio",
    "saziato",
    "sbadiglio",
    "sbalzo",
    "sbancato",
    "sbarra",
    "sbattere",
    "sbavare",
    "sbendare",
    "sbirciare",
    "sbloccato",
    "sbocciato",
    "sbrinare",
    "sbruffone",
    "sbuffare",
    "scabroso",
    "scadenza",
    "scala",
    "scambiare",
    "scandalo",
    "scapola",
    "scarso",
    "scatenare",
    "scavato",
    "scelto",
    "scenico",
    "scettro",
    "scheda",
    "schiena",
    "sciarpa",
    "scienza",
    "scindere",
    "scippo",
    "sciroppo",
    "scivolo",
    "sclerare",
    "scodella",
    "scolpito",
    "scomparto",
    "sconforto",
    "scoprire",
    "scorta",
    "scossone",
    "scozzese",
    "scriba",
    "scrollare",
    "scrutinio",
    "scuderia",
    "scultore",
    "scuola",
    "scuro",
    "scusare",
    "sdebitare",
    "sdoganare",
    "seccatura",
    "secondo",
    "sedano",
    "seggiola",
    "segnalato",
    "segregato",
    "seguito",
    "selciato",
    "selettivo",
    "sella",
    "selvaggio",
    "semaforo",
    "sembrare",
    "seme",
    "seminato",
    "sempre",
    "senso",
    "sentire",
    "sepolto",
    "sequenza",
    "serata",
    "serbato",
    "sereno",
    "serio",
    "serpente",
    "serraglio",
    "servire",
    "sestina",
    "setola",
    "settimana",
    "sfacelo",
    "sfaldare",
    "sfamato",
    "sfarzoso",
    "sfaticato",
    "sfera",
    "sfida",
    "sfilato",
    "sfinge",
    "sfocato",
    "sfoderare",
    "sfogo",
    "sfoltire",
    "sforzato",
    "sfratto",
    "sfruttato",
    "sfuggito",
    "sfumare",
    "sfuso",
    "sgabello",
    "sgarbato",
    "sgonfiare",
    "sgorbio",
    "sgrassato",
    "sguardo",
    "sibilo",
    "siccome",
    "sierra",
    "sigla",
    "signore",
    "silenzio",
    "sillaba",
    "simbolo",
    "simpatico",
    "simulato",
    "sinfonia",
    "singolo",
    "sinistro",
    "sino",
    "sintesi",
    "sinusoide",
    "sipario",
    "sisma",
    "sistole",
    "situato",
    "slitta",
    "slogatura",
    "sloveno",
    "smarrito",
    "smemorato",
    "smentito",
    "smeraldo",
    "smilzo",
    "smontare",
    "smottato",
    "smussato",
    "snellire",
    "snervato",
    "snodo",
    "sobbalzo",
    "sobrio",
    "soccorso",
    "sociale",
    "sodale",
    "soffitto",
    "sogno",
    "soldato",
    "solenne",
    "solido",
    "sollazzo",
    "solo",
    "solubile",
    "solvente",
    "somatico",
    "somma",
    "sonda",
    "sonetto",
    "sonnifero",
    "sopire",
    "soppeso",
    "sopra",
    "sorgere",
    "sorpasso",
    "sorriso",
    "sorso",
    "sorteggio",
    "sorvolato",
    "sospiro",
    "sosta",
    "sottile",
    "spada",
    "spalla",
    "spargere",
    "spatola",
    "spavento",
    "spazzola",
    "specie",
    "spedire",
    "spegnere",
    "spelatura",
    "speranza",
    "spessore",
    "spettrale",
    "spezzato",
    "spia",
    "spigoloso",
    "spillato",
    "spinoso",
    "spirale",
    "splendido",
    "sportivo",
    "sposo",
    "spranga",
    "sprecare",
    "spronato",
    "spruzzo",
    "spuntino",
    "squillo",
    "sradicare",
    "srotolato",
    "stabile",
    "stacco",
    "staffa",
    "stagnare",
    "stampato",
    "stantio",
    "starnuto",
    "stasera",
    "statuto",
    "stelo",
    "steppa",
    "sterzo",
    "stiletto",
    "stima",
    "stirpe",
    "stivale",
    "stizzoso",
    "stonato",
    "storico",
    "strappo",
    "stregato",
    "stridulo",
    "strozzare",
    "strutto",
    "stuccare",
    "stufo",
    "stupendo",
    "subentro",
    "succoso",
    "sudore",
    "suggerito",
    "sugo",
    "sultano",
    "suonare",
    "superbo",
    "supporto",
    "surgelato",
    "surrogato",
    "sussurro",
    "sutura",
    "svagare",
    "svedese",
    "sveglio",
    "svelare",
    "svenuto",
    "svezia",
    "sviluppo",
    "svista",
    "svizzera",
    "svolta",
    "svuotare",
    "tabacco",
    "tabulato",
    "tacciare",
    "taciturno",
    "tale",
    "talismano",
    "tampone",
    "tannino",
    "tara",
    "tardivo",
    "targato",
    "tariffa",
    "tarpare",
    "tartaruga",
    "tasto",
    "tattico",
    "taverna",
    "tavolata",
    "tazza",
    "teca",
    "tecnico",
    "telefono",
    "temerario",
    "tempo",
    "temuto",
    "tendone",
    "tenero",
    "tensione",
    "tentacolo",
    "teorema",
    "terme",
    "terrazzo",
    "terzetto",
    "tesi",
    "tesserato",
    "testato",
    "tetro",
    "tettoia",
    "tifare",
    "tigella",
    "timbro",
    "tinto",
    "tipico",
    "tipografo",
    "tiraggio",
    "tiro",
    "titanio",
    "titolo",
    "titubante",
    "tizio",
    "tizzone",
    "toccare",
    "tollerare",
    "tolto",
    "tombola",
    "tomo",
    "tonfo",
    "tonsilla",
    "topazio",
    "topologia",
    "toppa",
    "torba",
    "tornare",
    "torrone",
    "tortora",
    "toscano",
    "tossire",
    "tostatura",
    "totano",
    "trabocco",
    "trachea",
    "trafila",
    "tragedia",
    "tralcio",
    "tramonto",
    "transito",
    "trapano",
    "trarre",
    "trasloco",
    "trattato",
    "trave",
    "treccia",
    "tremolio",
    "trespolo",
    "tributo",
    "tricheco",
    "trifoglio",
    "trillo",
    "trincea",
    "trio",
    "tristezza",
    "triturato",
    "trivella",
    "tromba",
    "trono",
    "troppo",
    "trottola",
    "trovare",
    "truccato",
    "tubatura",
    "tuffato",
    "tulipano",
    "tumulto",
    "tunisia",
    "turbare",
    "turchino",
    "tuta",
    "tutela",
    "ubicato",
    "uccello",
    "uccisore",
    "udire",
    "uditivo",
    "uffa",
    "ufficio",
    "uguale",
    "ulisse",
    "ultimato",
    "umano",
    "umile",
    "umorismo",
    "uncinetto",
    "ungere",
    "ungherese",
    "unicorno",
    "unificato",
    "unisono",
    "unitario",
    "unte",
    "uovo",
    "upupa",
    "uragano",
    "urgenza",
    "urlo",
    "usanza",
    "usato",
    "uscito",
    "usignolo",
    "usuraio",
    "utensile",
    "utilizzo",
    "utopia",
    "vacante",
    "vaccinato",
    "vagabondo",
    "vagliato",
    "valanga",
    "valgo",
    "valico",
    "valletta",
    "valoroso",
    "valutare",
    "valvola",
    "vampata",
    "vangare",
    "vanitoso",
    "vano",
    "vantaggio",
    "vanvera",
    "vapore",
    "varano",
    "varcato",
    "variante",
    "vasca",
    "vedetta",
    "vedova",
    "veduto",
    "vegetale",
    "veicolo",
    "velcro",
    "velina",
    "velluto",
    "veloce",
    "venato",
    "vendemmia",
    "vento",
    "verace",
    "verbale",
    "vergogna",
    "verifica",
    "vero",
    "verruca",
    "verticale",
    "vescica",
    "vessillo",
    "vestale",
    "veterano",
    "vetrina",
    "vetusto",
    "viandante",
    "vibrante",
    "vicenda",
    "vichingo",
    "vicinanza",
    "vidimare",
    "vigilia",
    "vigneto",
    "vigore",
    "vile",
    "villano",
    "vimini",
    "vincitore",
    "viola",
    "vipera",
    "virgola",
    "virologo",
    "virulento",
    "viscoso",
    "visione",
    "vispo",
    "vissuto",
    "visura",
    "vita",
    "vitello",
    "vittima",
    "vivanda",
    "vivido",
    "viziare",
    "voce",
    "voga",
    "volatile",
    "volere",
    "volpe",
    "voragine",
    "vulcano",
    "zampogna",
    "zanna",
    "zappato",
    "zattera",
    "zavorra",
    "zefiro",
    "zelante",
    "zelo",
    "zenzero",
    "zerbino",
    "zibetto",
    "zinco",
    "zircone",
    "zitto",
    "zolla",
    "zotico",
    "zucchero",
    "zufolo",
    "zulu",
    "zuppa"
]

      };
    };
  }
}, {package:"bip39",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\italian.json",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\korean.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\key-tree\node_modules\bip39\src\wordlists\korean.json
      return function (require, module, exports) {
module.exports=[
    "가격",
    "가끔",
    "가난",
    "가능",
    "가득",
    "가르침",
    "가뭄",
    "가방",
    "가상",
    "가슴",
    "가운데",
    "가을",
    "가이드",
    "가입",
    "가장",
    "가정",
    "가족",
    "가죽",
    "각오",
    "각자",
    "간격",
    "간부",
    "간섭",
    "간장",
    "간접",
    "간판",
    "갈등",
    "갈비",
    "갈색",
    "갈증",
    "감각",
    "감기",
    "감소",
    "감수성",
    "감자",
    "감정",
    "갑자기",
    "강남",
    "강당",
    "강도",
    "강력히",
    "강변",
    "강북",
    "강사",
    "강수량",
    "강아지",
    "강원도",
    "강의",
    "강제",
    "강조",
    "같이",
    "개구리",
    "개나리",
    "개방",
    "개별",
    "개선",
    "개성",
    "개인",
    "객관적",
    "거실",
    "거액",
    "거울",
    "거짓",
    "거품",
    "걱정",
    "건강",
    "건물",
    "건설",
    "건조",
    "건축",
    "걸음",
    "검사",
    "검토",
    "게시판",
    "게임",
    "겨울",
    "견해",
    "결과",
    "결국",
    "결론",
    "결석",
    "결승",
    "결심",
    "결정",
    "결혼",
    "경계",
    "경고",
    "경기",
    "경력",
    "경복궁",
    "경비",
    "경상도",
    "경영",
    "경우",
    "경쟁",
    "경제",
    "경주",
    "경찰",
    "경치",
    "경향",
    "경험",
    "계곡",
    "계단",
    "계란",
    "계산",
    "계속",
    "계약",
    "계절",
    "계층",
    "계획",
    "고객",
    "고구려",
    "고궁",
    "고급",
    "고등학생",
    "고무신",
    "고민",
    "고양이",
    "고장",
    "고전",
    "고집",
    "고춧가루",
    "고통",
    "고향",
    "곡식",
    "골목",
    "골짜기",
    "골프",
    "공간",
    "공개",
    "공격",
    "공군",
    "공급",
    "공기",
    "공동",
    "공무원",
    "공부",
    "공사",
    "공식",
    "공업",
    "공연",
    "공원",
    "공장",
    "공짜",
    "공책",
    "공통",
    "공포",
    "공항",
    "공휴일",
    "과목",
    "과일",
    "과장",
    "과정",
    "과학",
    "관객",
    "관계",
    "관광",
    "관념",
    "관람",
    "관련",
    "관리",
    "관습",
    "관심",
    "관점",
    "관찰",
    "광경",
    "광고",
    "광장",
    "광주",
    "괴로움",
    "굉장히",
    "교과서",
    "교문",
    "교복",
    "교실",
    "교양",
    "교육",
    "교장",
    "교직",
    "교통",
    "교환",
    "교훈",
    "구경",
    "구름",
    "구멍",
    "구별",
    "구분",
    "구석",
    "구성",
    "구속",
    "구역",
    "구입",
    "구청",
    "구체적",
    "국가",
    "국기",
    "국내",
    "국립",
    "국물",
    "국민",
    "국수",
    "국어",
    "국왕",
    "국적",
    "국제",
    "국회",
    "군대",
    "군사",
    "군인",
    "궁극적",
    "권리",
    "권위",
    "권투",
    "귀국",
    "귀신",
    "규정",
    "규칙",
    "균형",
    "그날",
    "그냥",
    "그늘",
    "그러나",
    "그룹",
    "그릇",
    "그림",
    "그제서야",
    "그토록",
    "극복",
    "극히",
    "근거",
    "근교",
    "근래",
    "근로",
    "근무",
    "근본",
    "근원",
    "근육",
    "근처",
    "글씨",
    "글자",
    "금강산",
    "금고",
    "금년",
    "금메달",
    "금액",
    "금연",
    "금요일",
    "금지",
    "긍정적",
    "기간",
    "기관",
    "기념",
    "기능",
    "기독교",
    "기둥",
    "기록",
    "기름",
    "기법",
    "기본",
    "기분",
    "기쁨",
    "기숙사",
    "기술",
    "기억",
    "기업",
    "기온",
    "기운",
    "기원",
    "기적",
    "기준",
    "기침",
    "기혼",
    "기획",
    "긴급",
    "긴장",
    "길이",
    "김밥",
    "김치",
    "김포공항",
    "깍두기",
    "깜빡",
    "깨달음",
    "깨소금",
    "껍질",
    "꼭대기",
    "꽃잎",
    "나들이",
    "나란히",
    "나머지",
    "나물",
    "나침반",
    "나흘",
    "낙엽",
    "난방",
    "날개",
    "날씨",
    "날짜",
    "남녀",
    "남대문",
    "남매",
    "남산",
    "남자",
    "남편",
    "남학생",
    "낭비",
    "낱말",
    "내년",
    "내용",
    "내일",
    "냄비",
    "냄새",
    "냇물",
    "냉동",
    "냉면",
    "냉방",
    "냉장고",
    "넥타이",
    "넷째",
    "노동",
    "노란색",
    "노력",
    "노인",
    "녹음",
    "녹차",
    "녹화",
    "논리",
    "논문",
    "논쟁",
    "놀이",
    "농구",
    "농담",
    "농민",
    "농부",
    "농업",
    "농장",
    "농촌",
    "높이",
    "눈동자",
    "눈물",
    "눈썹",
    "뉴욕",
    "느낌",
    "늑대",
    "능동적",
    "능력",
    "다방",
    "다양성",
    "다음",
    "다이어트",
    "다행",
    "단계",
    "단골",
    "단독",
    "단맛",
    "단순",
    "단어",
    "단위",
    "단점",
    "단체",
    "단추",
    "단편",
    "단풍",
    "달걀",
    "달러",
    "달력",
    "달리",
    "닭고기",
    "담당",
    "담배",
    "담요",
    "담임",
    "답변",
    "답장",
    "당근",
    "당분간",
    "당연히",
    "당장",
    "대규모",
    "대낮",
    "대단히",
    "대답",
    "대도시",
    "대략",
    "대량",
    "대륙",
    "대문",
    "대부분",
    "대신",
    "대응",
    "대장",
    "대전",
    "대접",
    "대중",
    "대책",
    "대출",
    "대충",
    "대통령",
    "대학",
    "대한민국",
    "대합실",
    "대형",
    "덩어리",
    "데이트",
    "도대체",
    "도덕",
    "도둑",
    "도망",
    "도서관",
    "도심",
    "도움",
    "도입",
    "도자기",
    "도저히",
    "도전",
    "도중",
    "도착",
    "독감",
    "독립",
    "독서",
    "독일",
    "독창적",
    "동화책",
    "뒷모습",
    "뒷산",
    "딸아이",
    "마누라",
    "마늘",
    "마당",
    "마라톤",
    "마련",
    "마무리",
    "마사지",
    "마약",
    "마요네즈",
    "마을",
    "마음",
    "마이크",
    "마중",
    "마지막",
    "마찬가지",
    "마찰",
    "마흔",
    "막걸리",
    "막내",
    "막상",
    "만남",
    "만두",
    "만세",
    "만약",
    "만일",
    "만점",
    "만족",
    "만화",
    "많이",
    "말기",
    "말씀",
    "말투",
    "맘대로",
    "망원경",
    "매년",
    "매달",
    "매력",
    "매번",
    "매스컴",
    "매일",
    "매장",
    "맥주",
    "먹이",
    "먼저",
    "먼지",
    "멀리",
    "메일",
    "며느리",
    "며칠",
    "면담",
    "멸치",
    "명단",
    "명령",
    "명예",
    "명의",
    "명절",
    "명칭",
    "명함",
    "모금",
    "모니터",
    "모델",
    "모든",
    "모범",
    "모습",
    "모양",
    "모임",
    "모조리",
    "모집",
    "모퉁이",
    "목걸이",
    "목록",
    "목사",
    "목소리",
    "목숨",
    "목적",
    "목표",
    "몰래",
    "몸매",
    "몸무게",
    "몸살",
    "몸속",
    "몸짓",
    "몸통",
    "몹시",
    "무관심",
    "무궁화",
    "무더위",
    "무덤",
    "무릎",
    "무슨",
    "무엇",
    "무역",
    "무용",
    "무조건",
    "무지개",
    "무척",
    "문구",
    "문득",
    "문법",
    "문서",
    "문제",
    "문학",
    "문화",
    "물가",
    "물건",
    "물결",
    "물고기",
    "물론",
    "물리학",
    "물음",
    "물질",
    "물체",
    "미국",
    "미디어",
    "미사일",
    "미술",
    "미역",
    "미용실",
    "미움",
    "미인",
    "미팅",
    "미혼",
    "민간",
    "민족",
    "민주",
    "믿음",
    "밀가루",
    "밀리미터",
    "밑바닥",
    "바가지",
    "바구니",
    "바나나",
    "바늘",
    "바닥",
    "바닷가",
    "바람",
    "바이러스",
    "바탕",
    "박물관",
    "박사",
    "박수",
    "반대",
    "반드시",
    "반말",
    "반발",
    "반성",
    "반응",
    "반장",
    "반죽",
    "반지",
    "반찬",
    "받침",
    "발가락",
    "발걸음",
    "발견",
    "발달",
    "발레",
    "발목",
    "발바닥",
    "발생",
    "발음",
    "발자국",
    "발전",
    "발톱",
    "발표",
    "밤하늘",
    "밥그릇",
    "밥맛",
    "밥상",
    "밥솥",
    "방금",
    "방면",
    "방문",
    "방바닥",
    "방법",
    "방송",
    "방식",
    "방안",
    "방울",
    "방지",
    "방학",
    "방해",
    "방향",
    "배경",
    "배꼽",
    "배달",
    "배드민턴",
    "백두산",
    "백색",
    "백성",
    "백인",
    "백제",
    "백화점",
    "버릇",
    "버섯",
    "버튼",
    "번개",
    "번역",
    "번지",
    "번호",
    "벌금",
    "벌레",
    "벌써",
    "범위",
    "범인",
    "범죄",
    "법률",
    "법원",
    "법적",
    "법칙",
    "베이징",
    "벨트",
    "변경",
    "변동",
    "변명",
    "변신",
    "변호사",
    "변화",
    "별도",
    "별명",
    "별일",
    "병실",
    "병아리",
    "병원",
    "보관",
    "보너스",
    "보라색",
    "보람",
    "보름",
    "보상",
    "보안",
    "보자기",
    "보장",
    "보전",
    "보존",
    "보통",
    "보편적",
    "보험",
    "복도",
    "복사",
    "복숭아",
    "복습",
    "볶음",
    "본격적",
    "본래",
    "본부",
    "본사",
    "본성",
    "본인",
    "본질",
    "볼펜",
    "봉사",
    "봉지",
    "봉투",
    "부근",
    "부끄러움",
    "부담",
    "부동산",
    "부문",
    "부분",
    "부산",
    "부상",
    "부엌",
    "부인",
    "부작용",
    "부장",
    "부정",
    "부족",
    "부지런히",
    "부친",
    "부탁",
    "부품",
    "부회장",
    "북부",
    "북한",
    "분노",
    "분량",
    "분리",
    "분명",
    "분석",
    "분야",
    "분위기",
    "분필",
    "분홍색",
    "불고기",
    "불과",
    "불교",
    "불꽃",
    "불만",
    "불법",
    "불빛",
    "불안",
    "불이익",
    "불행",
    "브랜드",
    "비극",
    "비난",
    "비닐",
    "비둘기",
    "비디오",
    "비로소",
    "비만",
    "비명",
    "비밀",
    "비바람",
    "비빔밥",
    "비상",
    "비용",
    "비율",
    "비중",
    "비타민",
    "비판",
    "빌딩",
    "빗물",
    "빗방울",
    "빗줄기",
    "빛깔",
    "빨간색",
    "빨래",
    "빨리",
    "사건",
    "사계절",
    "사나이",
    "사냥",
    "사람",
    "사랑",
    "사립",
    "사모님",
    "사물",
    "사방",
    "사상",
    "사생활",
    "사설",
    "사슴",
    "사실",
    "사업",
    "사용",
    "사월",
    "사장",
    "사전",
    "사진",
    "사촌",
    "사춘기",
    "사탕",
    "사투리",
    "사흘",
    "산길",
    "산부인과",
    "산업",
    "산책",
    "살림",
    "살인",
    "살짝",
    "삼계탕",
    "삼국",
    "삼십",
    "삼월",
    "삼촌",
    "상관",
    "상금",
    "상대",
    "상류",
    "상반기",
    "상상",
    "상식",
    "상업",
    "상인",
    "상자",
    "상점",
    "상처",
    "상추",
    "상태",
    "상표",
    "상품",
    "상황",
    "새벽",
    "색깔",
    "색연필",
    "생각",
    "생명",
    "생물",
    "생방송",
    "생산",
    "생선",
    "생신",
    "생일",
    "생활",
    "서랍",
    "서른",
    "서명",
    "서민",
    "서비스",
    "서양",
    "서울",
    "서적",
    "서점",
    "서쪽",
    "서클",
    "석사",
    "석유",
    "선거",
    "선물",
    "선배",
    "선생",
    "선수",
    "선원",
    "선장",
    "선전",
    "선택",
    "선풍기",
    "설거지",
    "설날",
    "설렁탕",
    "설명",
    "설문",
    "설사",
    "설악산",
    "설치",
    "설탕",
    "섭씨",
    "성공",
    "성당",
    "성명",
    "성별",
    "성인",
    "성장",
    "성적",
    "성질",
    "성함",
    "세금",
    "세미나",
    "세상",
    "세월",
    "세종대왕",
    "세탁",
    "센터",
    "센티미터",
    "셋째",
    "소규모",
    "소극적",
    "소금",
    "소나기",
    "소년",
    "소득",
    "소망",
    "소문",
    "소설",
    "소속",
    "소아과",
    "소용",
    "소원",
    "소음",
    "소중히",
    "소지품",
    "소질",
    "소풍",
    "소형",
    "속담",
    "속도",
    "속옷",
    "손가락",
    "손길",
    "손녀",
    "손님",
    "손등",
    "손목",
    "손뼉",
    "손실",
    "손질",
    "손톱",
    "손해",
    "솔직히",
    "솜씨",
    "송아지",
    "송이",
    "송편",
    "쇠고기",
    "쇼핑",
    "수건",
    "수년",
    "수단",
    "수돗물",
    "수동적",
    "수면",
    "수명",
    "수박",
    "수상",
    "수석",
    "수술",
    "수시로",
    "수업",
    "수염",
    "수영",
    "수입",
    "수준",
    "수집",
    "수출",
    "수컷",
    "수필",
    "수학",
    "수험생",
    "수화기",
    "숙녀",
    "숙소",
    "숙제",
    "순간",
    "순서",
    "순수",
    "순식간",
    "순위",
    "숟가락",
    "술병",
    "술집",
    "숫자",
    "스님",
    "스물",
    "스스로",
    "스승",
    "스웨터",
    "스위치",
    "스케이트",
    "스튜디오",
    "스트레스",
    "스포츠",
    "슬쩍",
    "슬픔",
    "습관",
    "습기",
    "승객",
    "승리",
    "승부",
    "승용차",
    "승진",
    "시각",
    "시간",
    "시골",
    "시금치",
    "시나리오",
    "시댁",
    "시리즈",
    "시멘트",
    "시민",
    "시부모",
    "시선",
    "시설",
    "시스템",
    "시아버지",
    "시어머니",
    "시월",
    "시인",
    "시일",
    "시작",
    "시장",
    "시절",
    "시점",
    "시중",
    "시즌",
    "시집",
    "시청",
    "시합",
    "시험",
    "식구",
    "식기",
    "식당",
    "식량",
    "식료품",
    "식물",
    "식빵",
    "식사",
    "식생활",
    "식초",
    "식탁",
    "식품",
    "신고",
    "신규",
    "신념",
    "신문",
    "신발",
    "신비",
    "신사",
    "신세",
    "신용",
    "신제품",
    "신청",
    "신체",
    "신화",
    "실감",
    "실내",
    "실력",
    "실례",
    "실망",
    "실수",
    "실습",
    "실시",
    "실장",
    "실정",
    "실질적",
    "실천",
    "실체",
    "실컷",
    "실태",
    "실패",
    "실험",
    "실현",
    "심리",
    "심부름",
    "심사",
    "심장",
    "심정",
    "심판",
    "쌍둥이",
    "씨름",
    "씨앗",
    "아가씨",
    "아나운서",
    "아드님",
    "아들",
    "아쉬움",
    "아스팔트",
    "아시아",
    "아울러",
    "아저씨",
    "아줌마",
    "아직",
    "아침",
    "아파트",
    "아프리카",
    "아픔",
    "아홉",
    "아흔",
    "악기",
    "악몽",
    "악수",
    "안개",
    "안경",
    "안과",
    "안내",
    "안녕",
    "안동",
    "안방",
    "안부",
    "안주",
    "알루미늄",
    "알코올",
    "암시",
    "암컷",
    "압력",
    "앞날",
    "앞문",
    "애인",
    "애정",
    "액수",
    "앨범",
    "야간",
    "야단",
    "야옹",
    "약간",
    "약국",
    "약속",
    "약수",
    "약점",
    "약품",
    "약혼녀",
    "양념",
    "양력",
    "양말",
    "양배추",
    "양주",
    "양파",
    "어둠",
    "어려움",
    "어른",
    "어젯밤",
    "어쨌든",
    "어쩌다가",
    "어쩐지",
    "언니",
    "언덕",
    "언론",
    "언어",
    "얼굴",
    "얼른",
    "얼음",
    "얼핏",
    "엄마",
    "업무",
    "업종",
    "업체",
    "엉덩이",
    "엉망",
    "엉터리",
    "엊그제",
    "에너지",
    "에어컨",
    "엔진",
    "여건",
    "여고생",
    "여관",
    "여군",
    "여권",
    "여대생",
    "여덟",
    "여동생",
    "여든",
    "여론",
    "여름",
    "여섯",
    "여성",
    "여왕",
    "여인",
    "여전히",
    "여직원",
    "여학생",
    "여행",
    "역사",
    "역시",
    "역할",
    "연결",
    "연구",
    "연극",
    "연기",
    "연락",
    "연설",
    "연세",
    "연속",
    "연습",
    "연애",
    "연예인",
    "연인",
    "연장",
    "연주",
    "연출",
    "연필",
    "연합",
    "연휴",
    "열기",
    "열매",
    "열쇠",
    "열심히",
    "열정",
    "열차",
    "열흘",
    "염려",
    "엽서",
    "영국",
    "영남",
    "영상",
    "영양",
    "영역",
    "영웅",
    "영원히",
    "영하",
    "영향",
    "영혼",
    "영화",
    "옆구리",
    "옆방",
    "옆집",
    "예감",
    "예금",
    "예방",
    "예산",
    "예상",
    "예선",
    "예술",
    "예습",
    "예식장",
    "예약",
    "예전",
    "예절",
    "예정",
    "예컨대",
    "옛날",
    "오늘",
    "오락",
    "오랫동안",
    "오렌지",
    "오로지",
    "오른발",
    "오븐",
    "오십",
    "오염",
    "오월",
    "오전",
    "오직",
    "오징어",
    "오페라",
    "오피스텔",
    "오히려",
    "옥상",
    "옥수수",
    "온갖",
    "온라인",
    "온몸",
    "온종일",
    "온통",
    "올가을",
    "올림픽",
    "올해",
    "옷차림",
    "와이셔츠",
    "와인",
    "완성",
    "완전",
    "왕비",
    "왕자",
    "왜냐하면",
    "왠지",
    "외갓집",
    "외국",
    "외로움",
    "외삼촌",
    "외출",
    "외침",
    "외할머니",
    "왼발",
    "왼손",
    "왼쪽",
    "요금",
    "요일",
    "요즘",
    "요청",
    "용기",
    "용서",
    "용어",
    "우산",
    "우선",
    "우승",
    "우연히",
    "우정",
    "우체국",
    "우편",
    "운동",
    "운명",
    "운반",
    "운전",
    "운행",
    "울산",
    "울음",
    "움직임",
    "웃어른",
    "웃음",
    "워낙",
    "원고",
    "원래",
    "원서",
    "원숭이",
    "원인",
    "원장",
    "원피스",
    "월급",
    "월드컵",
    "월세",
    "월요일",
    "웨이터",
    "위반",
    "위법",
    "위성",
    "위원",
    "위험",
    "위협",
    "윗사람",
    "유난히",
    "유럽",
    "유명",
    "유물",
    "유산",
    "유적",
    "유치원",
    "유학",
    "유행",
    "유형",
    "육군",
    "육상",
    "육십",
    "육체",
    "은행",
    "음력",
    "음료",
    "음반",
    "음성",
    "음식",
    "음악",
    "음주",
    "의견",
    "의논",
    "의문",
    "의복",
    "의식",
    "의심",
    "의외로",
    "의욕",
    "의원",
    "의학",
    "이것",
    "이곳",
    "이념",
    "이놈",
    "이달",
    "이대로",
    "이동",
    "이렇게",
    "이력서",
    "이론적",
    "이름",
    "이민",
    "이발소",
    "이별",
    "이불",
    "이빨",
    "이상",
    "이성",
    "이슬",
    "이야기",
    "이용",
    "이웃",
    "이월",
    "이윽고",
    "이익",
    "이전",
    "이중",
    "이튿날",
    "이틀",
    "이혼",
    "인간",
    "인격",
    "인공",
    "인구",
    "인근",
    "인기",
    "인도",
    "인류",
    "인물",
    "인생",
    "인쇄",
    "인연",
    "인원",
    "인재",
    "인종",
    "인천",
    "인체",
    "인터넷",
    "인하",
    "인형",
    "일곱",
    "일기",
    "일단",
    "일대",
    "일등",
    "일반",
    "일본",
    "일부",
    "일상",
    "일생",
    "일손",
    "일요일",
    "일월",
    "일정",
    "일종",
    "일주일",
    "일찍",
    "일체",
    "일치",
    "일행",
    "일회용",
    "임금",
    "임무",
    "입대",
    "입력",
    "입맛",
    "입사",
    "입술",
    "입시",
    "입원",
    "입장",
    "입학",
    "자가용",
    "자격",
    "자극",
    "자동",
    "자랑",
    "자부심",
    "자식",
    "자신",
    "자연",
    "자원",
    "자율",
    "자전거",
    "자정",
    "자존심",
    "자판",
    "작가",
    "작년",
    "작성",
    "작업",
    "작용",
    "작은딸",
    "작품",
    "잔디",
    "잔뜩",
    "잔치",
    "잘못",
    "잠깐",
    "잠수함",
    "잠시",
    "잠옷",
    "잠자리",
    "잡지",
    "장관",
    "장군",
    "장기간",
    "장래",
    "장례",
    "장르",
    "장마",
    "장면",
    "장모",
    "장미",
    "장비",
    "장사",
    "장소",
    "장식",
    "장애인",
    "장인",
    "장점",
    "장차",
    "장학금",
    "재능",
    "재빨리",
    "재산",
    "재생",
    "재작년",
    "재정",
    "재채기",
    "재판",
    "재학",
    "재활용",
    "저것",
    "저고리",
    "저곳",
    "저녁",
    "저런",
    "저렇게",
    "저번",
    "저울",
    "저절로",
    "저축",
    "적극",
    "적당히",
    "적성",
    "적용",
    "적응",
    "전개",
    "전공",
    "전기",
    "전달",
    "전라도",
    "전망",
    "전문",
    "전반",
    "전부",
    "전세",
    "전시",
    "전용",
    "전자",
    "전쟁",
    "전주",
    "전철",
    "전체",
    "전통",
    "전혀",
    "전후",
    "절대",
    "절망",
    "절반",
    "절약",
    "절차",
    "점검",
    "점수",
    "점심",
    "점원",
    "점점",
    "점차",
    "접근",
    "접시",
    "접촉",
    "젓가락",
    "정거장",
    "정도",
    "정류장",
    "정리",
    "정말",
    "정면",
    "정문",
    "정반대",
    "정보",
    "정부",
    "정비",
    "정상",
    "정성",
    "정오",
    "정원",
    "정장",
    "정지",
    "정치",
    "정확히",
    "제공",
    "제과점",
    "제대로",
    "제목",
    "제발",
    "제법",
    "제삿날",
    "제안",
    "제일",
    "제작",
    "제주도",
    "제출",
    "제품",
    "제한",
    "조각",
    "조건",
    "조금",
    "조깅",
    "조명",
    "조미료",
    "조상",
    "조선",
    "조용히",
    "조절",
    "조정",
    "조직",
    "존댓말",
    "존재",
    "졸업",
    "졸음",
    "종교",
    "종로",
    "종류",
    "종소리",
    "종업원",
    "종종",
    "종합",
    "좌석",
    "죄인",
    "주관적",
    "주름",
    "주말",
    "주머니",
    "주먹",
    "주문",
    "주민",
    "주방",
    "주변",
    "주식",
    "주인",
    "주일",
    "주장",
    "주전자",
    "주택",
    "준비",
    "줄거리",
    "줄기",
    "줄무늬",
    "중간",
    "중계방송",
    "중국",
    "중년",
    "중단",
    "중독",
    "중반",
    "중부",
    "중세",
    "중소기업",
    "중순",
    "중앙",
    "중요",
    "중학교",
    "즉석",
    "즉시",
    "즐거움",
    "증가",
    "증거",
    "증권",
    "증상",
    "증세",
    "지각",
    "지갑",
    "지경",
    "지극히",
    "지금",
    "지급",
    "지능",
    "지름길",
    "지리산",
    "지방",
    "지붕",
    "지식",
    "지역",
    "지우개",
    "지원",
    "지적",
    "지점",
    "지진",
    "지출",
    "직선",
    "직업",
    "직원",
    "직장",
    "진급",
    "진동",
    "진로",
    "진료",
    "진리",
    "진짜",
    "진찰",
    "진출",
    "진통",
    "진행",
    "질문",
    "질병",
    "질서",
    "짐작",
    "집단",
    "집안",
    "집중",
    "짜증",
    "찌꺼기",
    "차남",
    "차라리",
    "차량",
    "차림",
    "차별",
    "차선",
    "차츰",
    "착각",
    "찬물",
    "찬성",
    "참가",
    "참기름",
    "참새",
    "참석",
    "참여",
    "참외",
    "참조",
    "찻잔",
    "창가",
    "창고",
    "창구",
    "창문",
    "창밖",
    "창작",
    "창조",
    "채널",
    "채점",
    "책가방",
    "책방",
    "책상",
    "책임",
    "챔피언",
    "처벌",
    "처음",
    "천국",
    "천둥",
    "천장",
    "천재",
    "천천히",
    "철도",
    "철저히",
    "철학",
    "첫날",
    "첫째",
    "청년",
    "청바지",
    "청소",
    "청춘",
    "체계",
    "체력",
    "체온",
    "체육",
    "체중",
    "체험",
    "초등학생",
    "초반",
    "초밥",
    "초상화",
    "초순",
    "초여름",
    "초원",
    "초저녁",
    "초점",
    "초청",
    "초콜릿",
    "촛불",
    "총각",
    "총리",
    "총장",
    "촬영",
    "최근",
    "최상",
    "최선",
    "최신",
    "최악",
    "최종",
    "추석",
    "추억",
    "추진",
    "추천",
    "추측",
    "축구",
    "축소",
    "축제",
    "축하",
    "출근",
    "출발",
    "출산",
    "출신",
    "출연",
    "출입",
    "출장",
    "출판",
    "충격",
    "충고",
    "충돌",
    "충분히",
    "충청도",
    "취업",
    "취직",
    "취향",
    "치약",
    "친구",
    "친척",
    "칠십",
    "칠월",
    "칠판",
    "침대",
    "침묵",
    "침실",
    "칫솔",
    "칭찬",
    "카메라",
    "카운터",
    "칼국수",
    "캐릭터",
    "캠퍼스",
    "캠페인",
    "커튼",
    "컨디션",
    "컬러",
    "컴퓨터",
    "코끼리",
    "코미디",
    "콘서트",
    "콜라",
    "콤플렉스",
    "콩나물",
    "쾌감",
    "쿠데타",
    "크림",
    "큰길",
    "큰딸",
    "큰소리",
    "큰아들",
    "큰어머니",
    "큰일",
    "큰절",
    "클래식",
    "클럽",
    "킬로",
    "타입",
    "타자기",
    "탁구",
    "탁자",
    "탄생",
    "태권도",
    "태양",
    "태풍",
    "택시",
    "탤런트",
    "터널",
    "터미널",
    "테니스",
    "테스트",
    "테이블",
    "텔레비전",
    "토론",
    "토마토",
    "토요일",
    "통계",
    "통과",
    "통로",
    "통신",
    "통역",
    "통일",
    "통장",
    "통제",
    "통증",
    "통합",
    "통화",
    "퇴근",
    "퇴원",
    "퇴직금",
    "튀김",
    "트럭",
    "특급",
    "특별",
    "특성",
    "특수",
    "특징",
    "특히",
    "튼튼히",
    "티셔츠",
    "파란색",
    "파일",
    "파출소",
    "판결",
    "판단",
    "판매",
    "판사",
    "팔십",
    "팔월",
    "팝송",
    "패션",
    "팩스",
    "팩시밀리",
    "팬티",
    "퍼센트",
    "페인트",
    "편견",
    "편의",
    "편지",
    "편히",
    "평가",
    "평균",
    "평생",
    "평소",
    "평양",
    "평일",
    "평화",
    "포스터",
    "포인트",
    "포장",
    "포함",
    "표면",
    "표정",
    "표준",
    "표현",
    "품목",
    "품질",
    "풍경",
    "풍속",
    "풍습",
    "프랑스",
    "프린터",
    "플라스틱",
    "피곤",
    "피망",
    "피아노",
    "필름",
    "필수",
    "필요",
    "필자",
    "필통",
    "핑계",
    "하느님",
    "하늘",
    "하드웨어",
    "하룻밤",
    "하반기",
    "하숙집",
    "하순",
    "하여튼",
    "하지만",
    "하천",
    "하품",
    "하필",
    "학과",
    "학교",
    "학급",
    "학기",
    "학년",
    "학력",
    "학번",
    "학부모",
    "학비",
    "학생",
    "학술",
    "학습",
    "학용품",
    "학원",
    "학위",
    "학자",
    "학점",
    "한계",
    "한글",
    "한꺼번에",
    "한낮",
    "한눈",
    "한동안",
    "한때",
    "한라산",
    "한마디",
    "한문",
    "한번",
    "한복",
    "한식",
    "한여름",
    "한쪽",
    "할머니",
    "할아버지",
    "할인",
    "함께",
    "함부로",
    "합격",
    "합리적",
    "항공",
    "항구",
    "항상",
    "항의",
    "해결",
    "해군",
    "해답",
    "해당",
    "해물",
    "해석",
    "해설",
    "해수욕장",
    "해안",
    "핵심",
    "핸드백",
    "햄버거",
    "햇볕",
    "햇살",
    "행동",
    "행복",
    "행사",
    "행운",
    "행위",
    "향기",
    "향상",
    "향수",
    "허락",
    "허용",
    "헬기",
    "현관",
    "현금",
    "현대",
    "현상",
    "현실",
    "현장",
    "현재",
    "현지",
    "혈액",
    "협력",
    "형부",
    "형사",
    "형수",
    "형식",
    "형제",
    "형태",
    "형편",
    "혜택",
    "호기심",
    "호남",
    "호랑이",
    "호박",
    "호텔",
    "호흡",
    "혹시",
    "홀로",
    "홈페이지",
    "홍보",
    "홍수",
    "홍차",
    "화면",
    "화분",
    "화살",
    "화요일",
    "화장",
    "화학",
    "확보",
    "확인",
    "확장",
    "확정",
    "환갑",
    "환경",
    "환영",
    "환율",
    "환자",
    "활기",
    "활동",
    "활발히",
    "활용",
    "활짝",
    "회견",
    "회관",
    "회복",
    "회색",
    "회원",
    "회장",
    "회전",
    "횟수",
    "횡단보도",
    "효율적",
    "후반",
    "후춧가루",
    "훈련",
    "훨씬",
    "휴식",
    "휴일",
    "흉내",
    "흐름",
    "흑백",
    "흑인",
    "흔적",
    "흔히",
    "흥미",
    "흥분",
    "희곡",
    "희망",
    "희생",
    "흰색",
    "힘껏"
]

      };
    };
  }
}, {package:"bip39",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\korean.json",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\japanese.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\key-tree\node_modules\bip39\src\wordlists\japanese.json
      return function (require, module, exports) {
module.exports=[
    "あいこくしん",
    "あいさつ",
    "あいだ",
    "あおぞら",
    "あかちゃん",
    "あきる",
    "あけがた",
    "あける",
    "あこがれる",
    "あさい",
    "あさひ",
    "あしあと",
    "あじわう",
    "あずかる",
    "あずき",
    "あそぶ",
    "あたえる",
    "あたためる",
    "あたりまえ",
    "あたる",
    "あつい",
    "あつかう",
    "あっしゅく",
    "あつまり",
    "あつめる",
    "あてな",
    "あてはまる",
    "あひる",
    "あぶら",
    "あぶる",
    "あふれる",
    "あまい",
    "あまど",
    "あまやかす",
    "あまり",
    "あみもの",
    "あめりか",
    "あやまる",
    "あゆむ",
    "あらいぐま",
    "あらし",
    "あらすじ",
    "あらためる",
    "あらゆる",
    "あらわす",
    "ありがとう",
    "あわせる",
    "あわてる",
    "あんい",
    "あんがい",
    "あんこ",
    "あんぜん",
    "あんてい",
    "あんない",
    "あんまり",
    "いいだす",
    "いおん",
    "いがい",
    "いがく",
    "いきおい",
    "いきなり",
    "いきもの",
    "いきる",
    "いくじ",
    "いくぶん",
    "いけばな",
    "いけん",
    "いこう",
    "いこく",
    "いこつ",
    "いさましい",
    "いさん",
    "いしき",
    "いじゅう",
    "いじょう",
    "いじわる",
    "いずみ",
    "いずれ",
    "いせい",
    "いせえび",
    "いせかい",
    "いせき",
    "いぜん",
    "いそうろう",
    "いそがしい",
    "いだい",
    "いだく",
    "いたずら",
    "いたみ",
    "いたりあ",
    "いちおう",
    "いちじ",
    "いちど",
    "いちば",
    "いちぶ",
    "いちりゅう",
    "いつか",
    "いっしゅん",
    "いっせい",
    "いっそう",
    "いったん",
    "いっち",
    "いってい",
    "いっぽう",
    "いてざ",
    "いてん",
    "いどう",
    "いとこ",
    "いない",
    "いなか",
    "いねむり",
    "いのち",
    "いのる",
    "いはつ",
    "いばる",
    "いはん",
    "いびき",
    "いひん",
    "いふく",
    "いへん",
    "いほう",
    "いみん",
    "いもうと",
    "いもたれ",
    "いもり",
    "いやがる",
    "いやす",
    "いよかん",
    "いよく",
    "いらい",
    "いらすと",
    "いりぐち",
    "いりょう",
    "いれい",
    "いれもの",
    "いれる",
    "いろえんぴつ",
    "いわい",
    "いわう",
    "いわかん",
    "いわば",
    "いわゆる",
    "いんげんまめ",
    "いんさつ",
    "いんしょう",
    "いんよう",
    "うえき",
    "うえる",
    "うおざ",
    "うがい",
    "うかぶ",
    "うかべる",
    "うきわ",
    "うくらいな",
    "うくれれ",
    "うけたまわる",
    "うけつけ",
    "うけとる",
    "うけもつ",
    "うける",
    "うごかす",
    "うごく",
    "うこん",
    "うさぎ",
    "うしなう",
    "うしろがみ",
    "うすい",
    "うすぎ",
    "うすぐらい",
    "うすめる",
    "うせつ",
    "うちあわせ",
    "うちがわ",
    "うちき",
    "うちゅう",
    "うっかり",
    "うつくしい",
    "うったえる",
    "うつる",
    "うどん",
    "うなぎ",
    "うなじ",
    "うなずく",
    "うなる",
    "うねる",
    "うのう",
    "うぶげ",
    "うぶごえ",
    "うまれる",
    "うめる",
    "うもう",
    "うやまう",
    "うよく",
    "うらがえす",
    "うらぐち",
    "うらない",
    "うりあげ",
    "うりきれ",
    "うるさい",
    "うれしい",
    "うれゆき",
    "うれる",
    "うろこ",
    "うわき",
    "うわさ",
    "うんこう",
    "うんちん",
    "うんてん",
    "うんどう",
    "えいえん",
    "えいが",
    "えいきょう",
    "えいご",
    "えいせい",
    "えいぶん",
    "えいよう",
    "えいわ",
    "えおり",
    "えがお",
    "えがく",
    "えきたい",
    "えくせる",
    "えしゃく",
    "えすて",
    "えつらん",
    "えのぐ",
    "えほうまき",
    "えほん",
    "えまき",
    "えもじ",
    "えもの",
    "えらい",
    "えらぶ",
    "えりあ",
    "えんえん",
    "えんかい",
    "えんぎ",
    "えんげき",
    "えんしゅう",
    "えんぜつ",
    "えんそく",
    "えんちょう",
    "えんとつ",
    "おいかける",
    "おいこす",
    "おいしい",
    "おいつく",
    "おうえん",
    "おうさま",
    "おうじ",
    "おうせつ",
    "おうたい",
    "おうふく",
    "おうべい",
    "おうよう",
    "おえる",
    "おおい",
    "おおう",
    "おおどおり",
    "おおや",
    "おおよそ",
    "おかえり",
    "おかず",
    "おがむ",
    "おかわり",
    "おぎなう",
    "おきる",
    "おくさま",
    "おくじょう",
    "おくりがな",
    "おくる",
    "おくれる",
    "おこす",
    "おこなう",
    "おこる",
    "おさえる",
    "おさない",
    "おさめる",
    "おしいれ",
    "おしえる",
    "おじぎ",
    "おじさん",
    "おしゃれ",
    "おそらく",
    "おそわる",
    "おたがい",
    "おたく",
    "おだやか",
    "おちつく",
    "おっと",
    "おつり",
    "おでかけ",
    "おとしもの",
    "おとなしい",
    "おどり",
    "おどろかす",
    "おばさん",
    "おまいり",
    "おめでとう",
    "おもいで",
    "おもう",
    "おもたい",
    "おもちゃ",
    "おやつ",
    "おやゆび",
    "およぼす",
    "おらんだ",
    "おろす",
    "おんがく",
    "おんけい",
    "おんしゃ",
    "おんせん",
    "おんだん",
    "おんちゅう",
    "おんどけい",
    "かあつ",
    "かいが",
    "がいき",
    "がいけん",
    "がいこう",
    "かいさつ",
    "かいしゃ",
    "かいすいよく",
    "かいぜん",
    "かいぞうど",
    "かいつう",
    "かいてん",
    "かいとう",
    "かいふく",
    "がいへき",
    "かいほう",
    "かいよう",
    "がいらい",
    "かいわ",
    "かえる",
    "かおり",
    "かかえる",
    "かがく",
    "かがし",
    "かがみ",
    "かくご",
    "かくとく",
    "かざる",
    "がぞう",
    "かたい",
    "かたち",
    "がちょう",
    "がっきゅう",
    "がっこう",
    "がっさん",
    "がっしょう",
    "かなざわし",
    "かのう",
    "がはく",
    "かぶか",
    "かほう",
    "かほご",
    "かまう",
    "かまぼこ",
    "かめれおん",
    "かゆい",
    "かようび",
    "からい",
    "かるい",
    "かろう",
    "かわく",
    "かわら",
    "がんか",
    "かんけい",
    "かんこう",
    "かんしゃ",
    "かんそう",
    "かんたん",
    "かんち",
    "がんばる",
    "きあい",
    "きあつ",
    "きいろ",
    "ぎいん",
    "きうい",
    "きうん",
    "きえる",
    "きおう",
    "きおく",
    "きおち",
    "きおん",
    "きかい",
    "きかく",
    "きかんしゃ",
    "ききて",
    "きくばり",
    "きくらげ",
    "きけんせい",
    "きこう",
    "きこえる",
    "きこく",
    "きさい",
    "きさく",
    "きさま",
    "きさらぎ",
    "ぎじかがく",
    "ぎしき",
    "ぎじたいけん",
    "ぎじにってい",
    "ぎじゅつしゃ",
    "きすう",
    "きせい",
    "きせき",
    "きせつ",
    "きそう",
    "きぞく",
    "きぞん",
    "きたえる",
    "きちょう",
    "きつえん",
    "ぎっちり",
    "きつつき",
    "きつね",
    "きてい",
    "きどう",
    "きどく",
    "きない",
    "きなが",
    "きなこ",
    "きぬごし",
    "きねん",
    "きのう",
    "きのした",
    "きはく",
    "きびしい",
    "きひん",
    "きふく",
    "きぶん",
    "きぼう",
    "きほん",
    "きまる",
    "きみつ",
    "きむずかしい",
    "きめる",
    "きもだめし",
    "きもち",
    "きもの",
    "きゃく",
    "きやく",
    "ぎゅうにく",
    "きよう",
    "きょうりゅう",
    "きらい",
    "きらく",
    "きりん",
    "きれい",
    "きれつ",
    "きろく",
    "ぎろん",
    "きわめる",
    "ぎんいろ",
    "きんかくじ",
    "きんじょ",
    "きんようび",
    "ぐあい",
    "くいず",
    "くうかん",
    "くうき",
    "くうぐん",
    "くうこう",
    "ぐうせい",
    "くうそう",
    "ぐうたら",
    "くうふく",
    "くうぼ",
    "くかん",
    "くきょう",
    "くげん",
    "ぐこう",
    "くさい",
    "くさき",
    "くさばな",
    "くさる",
    "くしゃみ",
    "くしょう",
    "くすのき",
    "くすりゆび",
    "くせげ",
    "くせん",
    "ぐたいてき",
    "くださる",
    "くたびれる",
    "くちこみ",
    "くちさき",
    "くつした",
    "ぐっすり",
    "くつろぐ",
    "くとうてん",
    "くどく",
    "くなん",
    "くねくね",
    "くのう",
    "くふう",
    "くみあわせ",
    "くみたてる",
    "くめる",
    "くやくしょ",
    "くらす",
    "くらべる",
    "くるま",
    "くれる",
    "くろう",
    "くわしい",
    "ぐんかん",
    "ぐんしょく",
    "ぐんたい",
    "ぐんて",
    "けあな",
    "けいかく",
    "けいけん",
    "けいこ",
    "けいさつ",
    "げいじゅつ",
    "けいたい",
    "げいのうじん",
    "けいれき",
    "けいろ",
    "けおとす",
    "けおりもの",
    "げきか",
    "げきげん",
    "げきだん",
    "げきちん",
    "げきとつ",
    "げきは",
    "げきやく",
    "げこう",
    "げこくじょう",
    "げざい",
    "けさき",
    "げざん",
    "けしき",
    "けしごむ",
    "けしょう",
    "げすと",
    "けたば",
    "けちゃっぷ",
    "けちらす",
    "けつあつ",
    "けつい",
    "けつえき",
    "けっこん",
    "けつじょ",
    "けっせき",
    "けってい",
    "けつまつ",
    "げつようび",
    "げつれい",
    "けつろん",
    "げどく",
    "けとばす",
    "けとる",
    "けなげ",
    "けなす",
    "けなみ",
    "けぬき",
    "げねつ",
    "けねん",
    "けはい",
    "げひん",
    "けぶかい",
    "げぼく",
    "けまり",
    "けみかる",
    "けむし",
    "けむり",
    "けもの",
    "けらい",
    "けろけろ",
    "けわしい",
    "けんい",
    "けんえつ",
    "けんお",
    "けんか",
    "げんき",
    "けんげん",
    "けんこう",
    "けんさく",
    "けんしゅう",
    "けんすう",
    "げんそう",
    "けんちく",
    "けんてい",
    "けんとう",
    "けんない",
    "けんにん",
    "げんぶつ",
    "けんま",
    "けんみん",
    "けんめい",
    "けんらん",
    "けんり",
    "こあくま",
    "こいぬ",
    "こいびと",
    "ごうい",
    "こうえん",
    "こうおん",
    "こうかん",
    "ごうきゅう",
    "ごうけい",
    "こうこう",
    "こうさい",
    "こうじ",
    "こうすい",
    "ごうせい",
    "こうそく",
    "こうたい",
    "こうちゃ",
    "こうつう",
    "こうてい",
    "こうどう",
    "こうない",
    "こうはい",
    "ごうほう",
    "ごうまん",
    "こうもく",
    "こうりつ",
    "こえる",
    "こおり",
    "ごかい",
    "ごがつ",
    "ごかん",
    "こくご",
    "こくさい",
    "こくとう",
    "こくない",
    "こくはく",
    "こぐま",
    "こけい",
    "こける",
    "ここのか",
    "こころ",
    "こさめ",
    "こしつ",
    "こすう",
    "こせい",
    "こせき",
    "こぜん",
    "こそだて",
    "こたい",
    "こたえる",
    "こたつ",
    "こちょう",
    "こっか",
    "こつこつ",
    "こつばん",
    "こつぶ",
    "こてい",
    "こてん",
    "ことがら",
    "ことし",
    "ことば",
    "ことり",
    "こなごな",
    "こねこね",
    "このまま",
    "このみ",
    "このよ",
    "ごはん",
    "こひつじ",
    "こふう",
    "こふん",
    "こぼれる",
    "ごまあぶら",
    "こまかい",
    "ごますり",
    "こまつな",
    "こまる",
    "こむぎこ",
    "こもじ",
    "こもち",
    "こもの",
    "こもん",
    "こやく",
    "こやま",
    "こゆう",
    "こゆび",
    "こよい",
    "こよう",
    "こりる",
    "これくしょん",
    "ころっけ",
    "こわもて",
    "こわれる",
    "こんいん",
    "こんかい",
    "こんき",
    "こんしゅう",
    "こんすい",
    "こんだて",
    "こんとん",
    "こんなん",
    "こんびに",
    "こんぽん",
    "こんまけ",
    "こんや",
    "こんれい",
    "こんわく",
    "ざいえき",
    "さいかい",
    "さいきん",
    "ざいげん",
    "ざいこ",
    "さいしょ",
    "さいせい",
    "ざいたく",
    "ざいちゅう",
    "さいてき",
    "ざいりょう",
    "さうな",
    "さかいし",
    "さがす",
    "さかな",
    "さかみち",
    "さがる",
    "さぎょう",
    "さくし",
    "さくひん",
    "さくら",
    "さこく",
    "さこつ",
    "さずかる",
    "ざせき",
    "さたん",
    "さつえい",
    "ざつおん",
    "ざっか",
    "ざつがく",
    "さっきょく",
    "ざっし",
    "さつじん",
    "ざっそう",
    "さつたば",
    "さつまいも",
    "さてい",
    "さといも",
    "さとう",
    "さとおや",
    "さとし",
    "さとる",
    "さのう",
    "さばく",
    "さびしい",
    "さべつ",
    "さほう",
    "さほど",
    "さます",
    "さみしい",
    "さみだれ",
    "さむけ",
    "さめる",
    "さやえんどう",
    "さゆう",
    "さよう",
    "さよく",
    "さらだ",
    "ざるそば",
    "さわやか",
    "さわる",
    "さんいん",
    "さんか",
    "さんきゃく",
    "さんこう",
    "さんさい",
    "ざんしょ",
    "さんすう",
    "さんせい",
    "さんそ",
    "さんち",
    "さんま",
    "さんみ",
    "さんらん",
    "しあい",
    "しあげ",
    "しあさって",
    "しあわせ",
    "しいく",
    "しいん",
    "しうち",
    "しえい",
    "しおけ",
    "しかい",
    "しかく",
    "じかん",
    "しごと",
    "しすう",
    "じだい",
    "したうけ",
    "したぎ",
    "したて",
    "したみ",
    "しちょう",
    "しちりん",
    "しっかり",
    "しつじ",
    "しつもん",
    "してい",
    "してき",
    "してつ",
    "じてん",
    "じどう",
    "しなぎれ",
    "しなもの",
    "しなん",
    "しねま",
    "しねん",
    "しのぐ",
    "しのぶ",
    "しはい",
    "しばかり",
    "しはつ",
    "しはらい",
    "しはん",
    "しひょう",
    "しふく",
    "じぶん",
    "しへい",
    "しほう",
    "しほん",
    "しまう",
    "しまる",
    "しみん",
    "しむける",
    "じむしょ",
    "しめい",
    "しめる",
    "しもん",
    "しゃいん",
    "しゃうん",
    "しゃおん",
    "じゃがいも",
    "しやくしょ",
    "しゃくほう",
    "しゃけん",
    "しゃこ",
    "しゃざい",
    "しゃしん",
    "しゃせん",
    "しゃそう",
    "しゃたい",
    "しゃちょう",
    "しゃっきん",
    "じゃま",
    "しゃりん",
    "しゃれい",
    "じゆう",
    "じゅうしょ",
    "しゅくはく",
    "じゅしん",
    "しゅっせき",
    "しゅみ",
    "しゅらば",
    "じゅんばん",
    "しょうかい",
    "しょくたく",
    "しょっけん",
    "しょどう",
    "しょもつ",
    "しらせる",
    "しらべる",
    "しんか",
    "しんこう",
    "じんじゃ",
    "しんせいじ",
    "しんちく",
    "しんりん",
    "すあげ",
    "すあし",
    "すあな",
    "ずあん",
    "すいえい",
    "すいか",
    "すいとう",
    "ずいぶん",
    "すいようび",
    "すうがく",
    "すうじつ",
    "すうせん",
    "すおどり",
    "すきま",
    "すくう",
    "すくない",
    "すける",
    "すごい",
    "すこし",
    "ずさん",
    "すずしい",
    "すすむ",
    "すすめる",
    "すっかり",
    "ずっしり",
    "ずっと",
    "すてき",
    "すてる",
    "すねる",
    "すのこ",
    "すはだ",
    "すばらしい",
    "ずひょう",
    "ずぶぬれ",
    "すぶり",
    "すふれ",
    "すべて",
    "すべる",
    "ずほう",
    "すぼん",
    "すまい",
    "すめし",
    "すもう",
    "すやき",
    "すらすら",
    "するめ",
    "すれちがう",
    "すろっと",
    "すわる",
    "すんぜん",
    "すんぽう",
    "せあぶら",
    "せいかつ",
    "せいげん",
    "せいじ",
    "せいよう",
    "せおう",
    "せかいかん",
    "せきにん",
    "せきむ",
    "せきゆ",
    "せきらんうん",
    "せけん",
    "せこう",
    "せすじ",
    "せたい",
    "せたけ",
    "せっかく",
    "せっきゃく",
    "ぜっく",
    "せっけん",
    "せっこつ",
    "せっさたくま",
    "せつぞく",
    "せつだん",
    "せつでん",
    "せっぱん",
    "せつび",
    "せつぶん",
    "せつめい",
    "せつりつ",
    "せなか",
    "せのび",
    "せはば",
    "せびろ",
    "せぼね",
    "せまい",
    "せまる",
    "せめる",
    "せもたれ",
    "せりふ",
    "ぜんあく",
    "せんい",
    "せんえい",
    "せんか",
    "せんきょ",
    "せんく",
    "せんげん",
    "ぜんご",
    "せんさい",
    "せんしゅ",
    "せんすい",
    "せんせい",
    "せんぞ",
    "せんたく",
    "せんちょう",
    "せんてい",
    "せんとう",
    "せんぬき",
    "せんねん",
    "せんぱい",
    "ぜんぶ",
    "ぜんぽう",
    "せんむ",
    "せんめんじょ",
    "せんもん",
    "せんやく",
    "せんゆう",
    "せんよう",
    "ぜんら",
    "ぜんりゃく",
    "せんれい",
    "せんろ",
    "そあく",
    "そいとげる",
    "そいね",
    "そうがんきょう",
    "そうき",
    "そうご",
    "そうしん",
    "そうだん",
    "そうなん",
    "そうび",
    "そうめん",
    "そうり",
    "そえもの",
    "そえん",
    "そがい",
    "そげき",
    "そこう",
    "そこそこ",
    "そざい",
    "そしな",
    "そせい",
    "そせん",
    "そそぐ",
    "そだてる",
    "そつう",
    "そつえん",
    "そっかん",
    "そつぎょう",
    "そっけつ",
    "そっこう",
    "そっせん",
    "そっと",
    "そとがわ",
    "そとづら",
    "そなえる",
    "そなた",
    "そふぼ",
    "そぼく",
    "そぼろ",
    "そまつ",
    "そまる",
    "そむく",
    "そむりえ",
    "そめる",
    "そもそも",
    "そよかぜ",
    "そらまめ",
    "そろう",
    "そんかい",
    "そんけい",
    "そんざい",
    "そんしつ",
    "そんぞく",
    "そんちょう",
    "ぞんび",
    "ぞんぶん",
    "そんみん",
    "たあい",
    "たいいん",
    "たいうん",
    "たいえき",
    "たいおう",
    "だいがく",
    "たいき",
    "たいぐう",
    "たいけん",
    "たいこ",
    "たいざい",
    "だいじょうぶ",
    "だいすき",
    "たいせつ",
    "たいそう",
    "だいたい",
    "たいちょう",
    "たいてい",
    "だいどころ",
    "たいない",
    "たいねつ",
    "たいのう",
    "たいはん",
    "だいひょう",
    "たいふう",
    "たいへん",
    "たいほ",
    "たいまつばな",
    "たいみんぐ",
    "たいむ",
    "たいめん",
    "たいやき",
    "たいよう",
    "たいら",
    "たいりょく",
    "たいる",
    "たいわん",
    "たうえ",
    "たえる",
    "たおす",
    "たおる",
    "たおれる",
    "たかい",
    "たかね",
    "たきび",
    "たくさん",
    "たこく",
    "たこやき",
    "たさい",
    "たしざん",
    "だじゃれ",
    "たすける",
    "たずさわる",
    "たそがれ",
    "たたかう",
    "たたく",
    "ただしい",
    "たたみ",
    "たちばな",
    "だっかい",
    "だっきゃく",
    "だっこ",
    "だっしゅつ",
    "だったい",
    "たてる",
    "たとえる",
    "たなばた",
    "たにん",
    "たぬき",
    "たのしみ",
    "たはつ",
    "たぶん",
    "たべる",
    "たぼう",
    "たまご",
    "たまる",
    "だむる",
    "ためいき",
    "ためす",
    "ためる",
    "たもつ",
    "たやすい",
    "たよる",
    "たらす",
    "たりきほんがん",
    "たりょう",
    "たりる",
    "たると",
    "たれる",
    "たれんと",
    "たろっと",
    "たわむれる",
    "だんあつ",
    "たんい",
    "たんおん",
    "たんか",
    "たんき",
    "たんけん",
    "たんご",
    "たんさん",
    "たんじょうび",
    "だんせい",
    "たんそく",
    "たんたい",
    "だんち",
    "たんてい",
    "たんとう",
    "だんな",
    "たんにん",
    "だんねつ",
    "たんのう",
    "たんぴん",
    "だんぼう",
    "たんまつ",
    "たんめい",
    "だんれつ",
    "だんろ",
    "だんわ",
    "ちあい",
    "ちあん",
    "ちいき",
    "ちいさい",
    "ちえん",
    "ちかい",
    "ちから",
    "ちきゅう",
    "ちきん",
    "ちけいず",
    "ちけん",
    "ちこく",
    "ちさい",
    "ちしき",
    "ちしりょう",
    "ちせい",
    "ちそう",
    "ちたい",
    "ちたん",
    "ちちおや",
    "ちつじょ",
    "ちてき",
    "ちてん",
    "ちぬき",
    "ちぬり",
    "ちのう",
    "ちひょう",
    "ちへいせん",
    "ちほう",
    "ちまた",
    "ちみつ",
    "ちみどろ",
    "ちめいど",
    "ちゃんこなべ",
    "ちゅうい",
    "ちゆりょく",
    "ちょうし",
    "ちょさくけん",
    "ちらし",
    "ちらみ",
    "ちりがみ",
    "ちりょう",
    "ちるど",
    "ちわわ",
    "ちんたい",
    "ちんもく",
    "ついか",
    "ついたち",
    "つうか",
    "つうじょう",
    "つうはん",
    "つうわ",
    "つかう",
    "つかれる",
    "つくね",
    "つくる",
    "つけね",
    "つける",
    "つごう",
    "つたえる",
    "つづく",
    "つつじ",
    "つつむ",
    "つとめる",
    "つながる",
    "つなみ",
    "つねづね",
    "つのる",
    "つぶす",
    "つまらない",
    "つまる",
    "つみき",
    "つめたい",
    "つもり",
    "つもる",
    "つよい",
    "つるぼ",
    "つるみく",
    "つわもの",
    "つわり",
    "てあし",
    "てあて",
    "てあみ",
    "ていおん",
    "ていか",
    "ていき",
    "ていけい",
    "ていこく",
    "ていさつ",
    "ていし",
    "ていせい",
    "ていたい",
    "ていど",
    "ていねい",
    "ていひょう",
    "ていへん",
    "ていぼう",
    "てうち",
    "ておくれ",
    "てきとう",
    "てくび",
    "でこぼこ",
    "てさぎょう",
    "てさげ",
    "てすり",
    "てそう",
    "てちがい",
    "てちょう",
    "てつがく",
    "てつづき",
    "でっぱ",
    "てつぼう",
    "てつや",
    "でぬかえ",
    "てぬき",
    "てぬぐい",
    "てのひら",
    "てはい",
    "てぶくろ",
    "てふだ",
    "てほどき",
    "てほん",
    "てまえ",
    "てまきずし",
    "てみじか",
    "てみやげ",
    "てらす",
    "てれび",
    "てわけ",
    "てわたし",
    "でんあつ",
    "てんいん",
    "てんかい",
    "てんき",
    "てんぐ",
    "てんけん",
    "てんごく",
    "てんさい",
    "てんし",
    "てんすう",
    "でんち",
    "てんてき",
    "てんとう",
    "てんない",
    "てんぷら",
    "てんぼうだい",
    "てんめつ",
    "てんらんかい",
    "でんりょく",
    "でんわ",
    "どあい",
    "といれ",
    "どうかん",
    "とうきゅう",
    "どうぐ",
    "とうし",
    "とうむぎ",
    "とおい",
    "とおか",
    "とおく",
    "とおす",
    "とおる",
    "とかい",
    "とかす",
    "ときおり",
    "ときどき",
    "とくい",
    "とくしゅう",
    "とくてん",
    "とくに",
    "とくべつ",
    "とけい",
    "とける",
    "とこや",
    "とさか",
    "としょかん",
    "とそう",
    "とたん",
    "とちゅう",
    "とっきゅう",
    "とっくん",
    "とつぜん",
    "とつにゅう",
    "とどける",
    "ととのえる",
    "とない",
    "となえる",
    "となり",
    "とのさま",
    "とばす",
    "どぶがわ",
    "とほう",
    "とまる",
    "とめる",
    "ともだち",
    "ともる",
    "どようび",
    "とらえる",
    "とんかつ",
    "どんぶり",
    "ないかく",
    "ないこう",
    "ないしょ",
    "ないす",
    "ないせん",
    "ないそう",
    "なおす",
    "ながい",
    "なくす",
    "なげる",
    "なこうど",
    "なさけ",
    "なたでここ",
    "なっとう",
    "なつやすみ",
    "ななおし",
    "なにごと",
    "なにもの",
    "なにわ",
    "なのか",
    "なふだ",
    "なまいき",
    "なまえ",
    "なまみ",
    "なみだ",
    "なめらか",
    "なめる",
    "なやむ",
    "ならう",
    "ならび",
    "ならぶ",
    "なれる",
    "なわとび",
    "なわばり",
    "にあう",
    "にいがた",
    "にうけ",
    "におい",
    "にかい",
    "にがて",
    "にきび",
    "にくしみ",
    "にくまん",
    "にげる",
    "にさんかたんそ",
    "にしき",
    "にせもの",
    "にちじょう",
    "にちようび",
    "にっか",
    "にっき",
    "にっけい",
    "にっこう",
    "にっさん",
    "にっしょく",
    "にっすう",
    "にっせき",
    "にってい",
    "になう",
    "にほん",
    "にまめ",
    "にもつ",
    "にやり",
    "にゅういん",
    "にりんしゃ",
    "にわとり",
    "にんい",
    "にんか",
    "にんき",
    "にんげん",
    "にんしき",
    "にんずう",
    "にんそう",
    "にんたい",
    "にんち",
    "にんてい",
    "にんにく",
    "にんぷ",
    "にんまり",
    "にんむ",
    "にんめい",
    "にんよう",
    "ぬいくぎ",
    "ぬかす",
    "ぬぐいとる",
    "ぬぐう",
    "ぬくもり",
    "ぬすむ",
    "ぬまえび",
    "ぬめり",
    "ぬらす",
    "ぬんちゃく",
    "ねあげ",
    "ねいき",
    "ねいる",
    "ねいろ",
    "ねぐせ",
    "ねくたい",
    "ねくら",
    "ねこぜ",
    "ねこむ",
    "ねさげ",
    "ねすごす",
    "ねそべる",
    "ねだん",
    "ねつい",
    "ねっしん",
    "ねつぞう",
    "ねったいぎょ",
    "ねぶそく",
    "ねふだ",
    "ねぼう",
    "ねほりはほり",
    "ねまき",
    "ねまわし",
    "ねみみ",
    "ねむい",
    "ねむたい",
    "ねもと",
    "ねらう",
    "ねわざ",
    "ねんいり",
    "ねんおし",
    "ねんかん",
    "ねんきん",
    "ねんぐ",
    "ねんざ",
    "ねんし",
    "ねんちゃく",
    "ねんど",
    "ねんぴ",
    "ねんぶつ",
    "ねんまつ",
    "ねんりょう",
    "ねんれい",
    "のいず",
    "のおづま",
    "のがす",
    "のきなみ",
    "のこぎり",
    "のこす",
    "のこる",
    "のせる",
    "のぞく",
    "のぞむ",
    "のたまう",
    "のちほど",
    "のっく",
    "のばす",
    "のはら",
    "のべる",
    "のぼる",
    "のみもの",
    "のやま",
    "のらいぬ",
    "のらねこ",
    "のりもの",
    "のりゆき",
    "のれん",
    "のんき",
    "ばあい",
    "はあく",
    "ばあさん",
    "ばいか",
    "ばいく",
    "はいけん",
    "はいご",
    "はいしん",
    "はいすい",
    "はいせん",
    "はいそう",
    "はいち",
    "ばいばい",
    "はいれつ",
    "はえる",
    "はおる",
    "はかい",
    "ばかり",
    "はかる",
    "はくしゅ",
    "はけん",
    "はこぶ",
    "はさみ",
    "はさん",
    "はしご",
    "ばしょ",
    "はしる",
    "はせる",
    "ぱそこん",
    "はそん",
    "はたん",
    "はちみつ",
    "はつおん",
    "はっかく",
    "はづき",
    "はっきり",
    "はっくつ",
    "はっけん",
    "はっこう",
    "はっさん",
    "はっしん",
    "はったつ",
    "はっちゅう",
    "はってん",
    "はっぴょう",
    "はっぽう",
    "はなす",
    "はなび",
    "はにかむ",
    "はぶらし",
    "はみがき",
    "はむかう",
    "はめつ",
    "はやい",
    "はやし",
    "はらう",
    "はろうぃん",
    "はわい",
    "はんい",
    "はんえい",
    "はんおん",
    "はんかく",
    "はんきょう",
    "ばんぐみ",
    "はんこ",
    "はんしゃ",
    "はんすう",
    "はんだん",
    "ぱんち",
    "ぱんつ",
    "はんてい",
    "はんとし",
    "はんのう",
    "はんぱ",
    "はんぶん",
    "はんぺん",
    "はんぼうき",
    "はんめい",
    "はんらん",
    "はんろん",
    "ひいき",
    "ひうん",
    "ひえる",
    "ひかく",
    "ひかり",
    "ひかる",
    "ひかん",
    "ひくい",
    "ひけつ",
    "ひこうき",
    "ひこく",
    "ひさい",
    "ひさしぶり",
    "ひさん",
    "びじゅつかん",
    "ひしょ",
    "ひそか",
    "ひそむ",
    "ひたむき",
    "ひだり",
    "ひたる",
    "ひつぎ",
    "ひっこし",
    "ひっし",
    "ひつじゅひん",
    "ひっす",
    "ひつぜん",
    "ぴったり",
    "ぴっちり",
    "ひつよう",
    "ひてい",
    "ひとごみ",
    "ひなまつり",
    "ひなん",
    "ひねる",
    "ひはん",
    "ひびく",
    "ひひょう",
    "ひほう",
    "ひまわり",
    "ひまん",
    "ひみつ",
    "ひめい",
    "ひめじし",
    "ひやけ",
    "ひやす",
    "ひよう",
    "びょうき",
    "ひらがな",
    "ひらく",
    "ひりつ",
    "ひりょう",
    "ひるま",
    "ひるやすみ",
    "ひれい",
    "ひろい",
    "ひろう",
    "ひろき",
    "ひろゆき",
    "ひんかく",
    "ひんけつ",
    "ひんこん",
    "ひんしゅ",
    "ひんそう",
    "ぴんち",
    "ひんぱん",
    "びんぼう",
    "ふあん",
    "ふいうち",
    "ふうけい",
    "ふうせん",
    "ぷうたろう",
    "ふうとう",
    "ふうふ",
    "ふえる",
    "ふおん",
    "ふかい",
    "ふきん",
    "ふくざつ",
    "ふくぶくろ",
    "ふこう",
    "ふさい",
    "ふしぎ",
    "ふじみ",
    "ふすま",
    "ふせい",
    "ふせぐ",
    "ふそく",
    "ぶたにく",
    "ふたん",
    "ふちょう",
    "ふつう",
    "ふつか",
    "ふっかつ",
    "ふっき",
    "ふっこく",
    "ぶどう",
    "ふとる",
    "ふとん",
    "ふのう",
    "ふはい",
    "ふひょう",
    "ふへん",
    "ふまん",
    "ふみん",
    "ふめつ",
    "ふめん",
    "ふよう",
    "ふりこ",
    "ふりる",
    "ふるい",
    "ふんいき",
    "ぶんがく",
    "ぶんぐ",
    "ふんしつ",
    "ぶんせき",
    "ふんそう",
    "ぶんぽう",
    "へいあん",
    "へいおん",
    "へいがい",
    "へいき",
    "へいげん",
    "へいこう",
    "へいさ",
    "へいしゃ",
    "へいせつ",
    "へいそ",
    "へいたく",
    "へいてん",
    "へいねつ",
    "へいわ",
    "へきが",
    "へこむ",
    "べにいろ",
    "べにしょうが",
    "へらす",
    "へんかん",
    "べんきょう",
    "べんごし",
    "へんさい",
    "へんたい",
    "べんり",
    "ほあん",
    "ほいく",
    "ぼうぎょ",
    "ほうこく",
    "ほうそう",
    "ほうほう",
    "ほうもん",
    "ほうりつ",
    "ほえる",
    "ほおん",
    "ほかん",
    "ほきょう",
    "ぼきん",
    "ほくろ",
    "ほけつ",
    "ほけん",
    "ほこう",
    "ほこる",
    "ほしい",
    "ほしつ",
    "ほしゅ",
    "ほしょう",
    "ほせい",
    "ほそい",
    "ほそく",
    "ほたて",
    "ほたる",
    "ぽちぶくろ",
    "ほっきょく",
    "ほっさ",
    "ほったん",
    "ほとんど",
    "ほめる",
    "ほんい",
    "ほんき",
    "ほんけ",
    "ほんしつ",
    "ほんやく",
    "まいにち",
    "まかい",
    "まかせる",
    "まがる",
    "まける",
    "まこと",
    "まさつ",
    "まじめ",
    "ますく",
    "まぜる",
    "まつり",
    "まとめ",
    "まなぶ",
    "まぬけ",
    "まねく",
    "まほう",
    "まもる",
    "まゆげ",
    "まよう",
    "まろやか",
    "まわす",
    "まわり",
    "まわる",
    "まんが",
    "まんきつ",
    "まんぞく",
    "まんなか",
    "みいら",
    "みうち",
    "みえる",
    "みがく",
    "みかた",
    "みかん",
    "みけん",
    "みこん",
    "みじかい",
    "みすい",
    "みすえる",
    "みせる",
    "みっか",
    "みつかる",
    "みつける",
    "みてい",
    "みとめる",
    "みなと",
    "みなみかさい",
    "みねらる",
    "みのう",
    "みのがす",
    "みほん",
    "みもと",
    "みやげ",
    "みらい",
    "みりょく",
    "みわく",
    "みんか",
    "みんぞく",
    "むいか",
    "むえき",
    "むえん",
    "むかい",
    "むかう",
    "むかえ",
    "むかし",
    "むぎちゃ",
    "むける",
    "むげん",
    "むさぼる",
    "むしあつい",
    "むしば",
    "むじゅん",
    "むしろ",
    "むすう",
    "むすこ",
    "むすぶ",
    "むすめ",
    "むせる",
    "むせん",
    "むちゅう",
    "むなしい",
    "むのう",
    "むやみ",
    "むよう",
    "むらさき",
    "むりょう",
    "むろん",
    "めいあん",
    "めいうん",
    "めいえん",
    "めいかく",
    "めいきょく",
    "めいさい",
    "めいし",
    "めいそう",
    "めいぶつ",
    "めいれい",
    "めいわく",
    "めぐまれる",
    "めざす",
    "めした",
    "めずらしい",
    "めだつ",
    "めまい",
    "めやす",
    "めんきょ",
    "めんせき",
    "めんどう",
    "もうしあげる",
    "もうどうけん",
    "もえる",
    "もくし",
    "もくてき",
    "もくようび",
    "もちろん",
    "もどる",
    "もらう",
    "もんく",
    "もんだい",
    "やおや",
    "やける",
    "やさい",
    "やさしい",
    "やすい",
    "やすたろう",
    "やすみ",
    "やせる",
    "やそう",
    "やたい",
    "やちん",
    "やっと",
    "やっぱり",
    "やぶる",
    "やめる",
    "ややこしい",
    "やよい",
    "やわらかい",
    "ゆうき",
    "ゆうびんきょく",
    "ゆうべ",
    "ゆうめい",
    "ゆけつ",
    "ゆしゅつ",
    "ゆせん",
    "ゆそう",
    "ゆたか",
    "ゆちゃく",
    "ゆでる",
    "ゆにゅう",
    "ゆびわ",
    "ゆらい",
    "ゆれる",
    "ようい",
    "ようか",
    "ようきゅう",
    "ようじ",
    "ようす",
    "ようちえん",
    "よかぜ",
    "よかん",
    "よきん",
    "よくせい",
    "よくぼう",
    "よけい",
    "よごれる",
    "よさん",
    "よしゅう",
    "よそう",
    "よそく",
    "よっか",
    "よてい",
    "よどがわく",
    "よねつ",
    "よやく",
    "よゆう",
    "よろこぶ",
    "よろしい",
    "らいう",
    "らくがき",
    "らくご",
    "らくさつ",
    "らくだ",
    "らしんばん",
    "らせん",
    "らぞく",
    "らたい",
    "らっか",
    "られつ",
    "りえき",
    "りかい",
    "りきさく",
    "りきせつ",
    "りくぐん",
    "りくつ",
    "りけん",
    "りこう",
    "りせい",
    "りそう",
    "りそく",
    "りてん",
    "りねん",
    "りゆう",
    "りゅうがく",
    "りよう",
    "りょうり",
    "りょかん",
    "りょくちゃ",
    "りょこう",
    "りりく",
    "りれき",
    "りろん",
    "りんご",
    "るいけい",
    "るいさい",
    "るいじ",
    "るいせき",
    "るすばん",
    "るりがわら",
    "れいかん",
    "れいぎ",
    "れいせい",
    "れいぞうこ",
    "れいとう",
    "れいぼう",
    "れきし",
    "れきだい",
    "れんあい",
    "れんけい",
    "れんこん",
    "れんさい",
    "れんしゅう",
    "れんぞく",
    "れんらく",
    "ろうか",
    "ろうご",
    "ろうじん",
    "ろうそく",
    "ろくが",
    "ろこつ",
    "ろじうら",
    "ろしゅつ",
    "ろせん",
    "ろてん",
    "ろめん",
    "ろれつ",
    "ろんぎ",
    "ろんぱ",
    "ろんぶん",
    "ろんり",
    "わかす",
    "わかめ",
    "わかやま",
    "わかれる",
    "わしつ",
    "わじまし",
    "わすれもの",
    "わらう",
    "われる"
]

      };
    };
  }
}, {package:"bip39",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\japanese.json",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\chinese_traditional.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\key-tree\node_modules\bip39\src\wordlists\chinese_traditional.json
      return function (require, module, exports) {
module.exports=[
    "的",
    "一",
    "是",
    "在",
    "不",
    "了",
    "有",
    "和",
    "人",
    "這",
    "中",
    "大",
    "為",
    "上",
    "個",
    "國",
    "我",
    "以",
    "要",
    "他",
    "時",
    "來",
    "用",
    "們",
    "生",
    "到",
    "作",
    "地",
    "於",
    "出",
    "就",
    "分",
    "對",
    "成",
    "會",
    "可",
    "主",
    "發",
    "年",
    "動",
    "同",
    "工",
    "也",
    "能",
    "下",
    "過",
    "子",
    "說",
    "產",
    "種",
    "面",
    "而",
    "方",
    "後",
    "多",
    "定",
    "行",
    "學",
    "法",
    "所",
    "民",
    "得",
    "經",
    "十",
    "三",
    "之",
    "進",
    "著",
    "等",
    "部",
    "度",
    "家",
    "電",
    "力",
    "裡",
    "如",
    "水",
    "化",
    "高",
    "自",
    "二",
    "理",
    "起",
    "小",
    "物",
    "現",
    "實",
    "加",
    "量",
    "都",
    "兩",
    "體",
    "制",
    "機",
    "當",
    "使",
    "點",
    "從",
    "業",
    "本",
    "去",
    "把",
    "性",
    "好",
    "應",
    "開",
    "它",
    "合",
    "還",
    "因",
    "由",
    "其",
    "些",
    "然",
    "前",
    "外",
    "天",
    "政",
    "四",
    "日",
    "那",
    "社",
    "義",
    "事",
    "平",
    "形",
    "相",
    "全",
    "表",
    "間",
    "樣",
    "與",
    "關",
    "各",
    "重",
    "新",
    "線",
    "內",
    "數",
    "正",
    "心",
    "反",
    "你",
    "明",
    "看",
    "原",
    "又",
    "麼",
    "利",
    "比",
    "或",
    "但",
    "質",
    "氣",
    "第",
    "向",
    "道",
    "命",
    "此",
    "變",
    "條",
    "只",
    "沒",
    "結",
    "解",
    "問",
    "意",
    "建",
    "月",
    "公",
    "無",
    "系",
    "軍",
    "很",
    "情",
    "者",
    "最",
    "立",
    "代",
    "想",
    "已",
    "通",
    "並",
    "提",
    "直",
    "題",
    "黨",
    "程",
    "展",
    "五",
    "果",
    "料",
    "象",
    "員",
    "革",
    "位",
    "入",
    "常",
    "文",
    "總",
    "次",
    "品",
    "式",
    "活",
    "設",
    "及",
    "管",
    "特",
    "件",
    "長",
    "求",
    "老",
    "頭",
    "基",
    "資",
    "邊",
    "流",
    "路",
    "級",
    "少",
    "圖",
    "山",
    "統",
    "接",
    "知",
    "較",
    "將",
    "組",
    "見",
    "計",
    "別",
    "她",
    "手",
    "角",
    "期",
    "根",
    "論",
    "運",
    "農",
    "指",
    "幾",
    "九",
    "區",
    "強",
    "放",
    "決",
    "西",
    "被",
    "幹",
    "做",
    "必",
    "戰",
    "先",
    "回",
    "則",
    "任",
    "取",
    "據",
    "處",
    "隊",
    "南",
    "給",
    "色",
    "光",
    "門",
    "即",
    "保",
    "治",
    "北",
    "造",
    "百",
    "規",
    "熱",
    "領",
    "七",
    "海",
    "口",
    "東",
    "導",
    "器",
    "壓",
    "志",
    "世",
    "金",
    "增",
    "爭",
    "濟",
    "階",
    "油",
    "思",
    "術",
    "極",
    "交",
    "受",
    "聯",
    "什",
    "認",
    "六",
    "共",
    "權",
    "收",
    "證",
    "改",
    "清",
    "美",
    "再",
    "採",
    "轉",
    "更",
    "單",
    "風",
    "切",
    "打",
    "白",
    "教",
    "速",
    "花",
    "帶",
    "安",
    "場",
    "身",
    "車",
    "例",
    "真",
    "務",
    "具",
    "萬",
    "每",
    "目",
    "至",
    "達",
    "走",
    "積",
    "示",
    "議",
    "聲",
    "報",
    "鬥",
    "完",
    "類",
    "八",
    "離",
    "華",
    "名",
    "確",
    "才",
    "科",
    "張",
    "信",
    "馬",
    "節",
    "話",
    "米",
    "整",
    "空",
    "元",
    "況",
    "今",
    "集",
    "溫",
    "傳",
    "土",
    "許",
    "步",
    "群",
    "廣",
    "石",
    "記",
    "需",
    "段",
    "研",
    "界",
    "拉",
    "林",
    "律",
    "叫",
    "且",
    "究",
    "觀",
    "越",
    "織",
    "裝",
    "影",
    "算",
    "低",
    "持",
    "音",
    "眾",
    "書",
    "布",
    "复",
    "容",
    "兒",
    "須",
    "際",
    "商",
    "非",
    "驗",
    "連",
    "斷",
    "深",
    "難",
    "近",
    "礦",
    "千",
    "週",
    "委",
    "素",
    "技",
    "備",
    "半",
    "辦",
    "青",
    "省",
    "列",
    "習",
    "響",
    "約",
    "支",
    "般",
    "史",
    "感",
    "勞",
    "便",
    "團",
    "往",
    "酸",
    "歷",
    "市",
    "克",
    "何",
    "除",
    "消",
    "構",
    "府",
    "稱",
    "太",
    "準",
    "精",
    "值",
    "號",
    "率",
    "族",
    "維",
    "劃",
    "選",
    "標",
    "寫",
    "存",
    "候",
    "毛",
    "親",
    "快",
    "效",
    "斯",
    "院",
    "查",
    "江",
    "型",
    "眼",
    "王",
    "按",
    "格",
    "養",
    "易",
    "置",
    "派",
    "層",
    "片",
    "始",
    "卻",
    "專",
    "狀",
    "育",
    "廠",
    "京",
    "識",
    "適",
    "屬",
    "圓",
    "包",
    "火",
    "住",
    "調",
    "滿",
    "縣",
    "局",
    "照",
    "參",
    "紅",
    "細",
    "引",
    "聽",
    "該",
    "鐵",
    "價",
    "嚴",
    "首",
    "底",
    "液",
    "官",
    "德",
    "隨",
    "病",
    "蘇",
    "失",
    "爾",
    "死",
    "講",
    "配",
    "女",
    "黃",
    "推",
    "顯",
    "談",
    "罪",
    "神",
    "藝",
    "呢",
    "席",
    "含",
    "企",
    "望",
    "密",
    "批",
    "營",
    "項",
    "防",
    "舉",
    "球",
    "英",
    "氧",
    "勢",
    "告",
    "李",
    "台",
    "落",
    "木",
    "幫",
    "輪",
    "破",
    "亞",
    "師",
    "圍",
    "注",
    "遠",
    "字",
    "材",
    "排",
    "供",
    "河",
    "態",
    "封",
    "另",
    "施",
    "減",
    "樹",
    "溶",
    "怎",
    "止",
    "案",
    "言",
    "士",
    "均",
    "武",
    "固",
    "葉",
    "魚",
    "波",
    "視",
    "僅",
    "費",
    "緊",
    "愛",
    "左",
    "章",
    "早",
    "朝",
    "害",
    "續",
    "輕",
    "服",
    "試",
    "食",
    "充",
    "兵",
    "源",
    "判",
    "護",
    "司",
    "足",
    "某",
    "練",
    "差",
    "致",
    "板",
    "田",
    "降",
    "黑",
    "犯",
    "負",
    "擊",
    "范",
    "繼",
    "興",
    "似",
    "餘",
    "堅",
    "曲",
    "輸",
    "修",
    "故",
    "城",
    "夫",
    "夠",
    "送",
    "筆",
    "船",
    "佔",
    "右",
    "財",
    "吃",
    "富",
    "春",
    "職",
    "覺",
    "漢",
    "畫",
    "功",
    "巴",
    "跟",
    "雖",
    "雜",
    "飛",
    "檢",
    "吸",
    "助",
    "昇",
    "陽",
    "互",
    "初",
    "創",
    "抗",
    "考",
    "投",
    "壞",
    "策",
    "古",
    "徑",
    "換",
    "未",
    "跑",
    "留",
    "鋼",
    "曾",
    "端",
    "責",
    "站",
    "簡",
    "述",
    "錢",
    "副",
    "盡",
    "帝",
    "射",
    "草",
    "衝",
    "承",
    "獨",
    "令",
    "限",
    "阿",
    "宣",
    "環",
    "雙",
    "請",
    "超",
    "微",
    "讓",
    "控",
    "州",
    "良",
    "軸",
    "找",
    "否",
    "紀",
    "益",
    "依",
    "優",
    "頂",
    "礎",
    "載",
    "倒",
    "房",
    "突",
    "坐",
    "粉",
    "敵",
    "略",
    "客",
    "袁",
    "冷",
    "勝",
    "絕",
    "析",
    "塊",
    "劑",
    "測",
    "絲",
    "協",
    "訴",
    "念",
    "陳",
    "仍",
    "羅",
    "鹽",
    "友",
    "洋",
    "錯",
    "苦",
    "夜",
    "刑",
    "移",
    "頻",
    "逐",
    "靠",
    "混",
    "母",
    "短",
    "皮",
    "終",
    "聚",
    "汽",
    "村",
    "雲",
    "哪",
    "既",
    "距",
    "衛",
    "停",
    "烈",
    "央",
    "察",
    "燒",
    "迅",
    "境",
    "若",
    "印",
    "洲",
    "刻",
    "括",
    "激",
    "孔",
    "搞",
    "甚",
    "室",
    "待",
    "核",
    "校",
    "散",
    "侵",
    "吧",
    "甲",
    "遊",
    "久",
    "菜",
    "味",
    "舊",
    "模",
    "湖",
    "貨",
    "損",
    "預",
    "阻",
    "毫",
    "普",
    "穩",
    "乙",
    "媽",
    "植",
    "息",
    "擴",
    "銀",
    "語",
    "揮",
    "酒",
    "守",
    "拿",
    "序",
    "紙",
    "醫",
    "缺",
    "雨",
    "嗎",
    "針",
    "劉",
    "啊",
    "急",
    "唱",
    "誤",
    "訓",
    "願",
    "審",
    "附",
    "獲",
    "茶",
    "鮮",
    "糧",
    "斤",
    "孩",
    "脫",
    "硫",
    "肥",
    "善",
    "龍",
    "演",
    "父",
    "漸",
    "血",
    "歡",
    "械",
    "掌",
    "歌",
    "沙",
    "剛",
    "攻",
    "謂",
    "盾",
    "討",
    "晚",
    "粒",
    "亂",
    "燃",
    "矛",
    "乎",
    "殺",
    "藥",
    "寧",
    "魯",
    "貴",
    "鐘",
    "煤",
    "讀",
    "班",
    "伯",
    "香",
    "介",
    "迫",
    "句",
    "豐",
    "培",
    "握",
    "蘭",
    "擔",
    "弦",
    "蛋",
    "沉",
    "假",
    "穿",
    "執",
    "答",
    "樂",
    "誰",
    "順",
    "煙",
    "縮",
    "徵",
    "臉",
    "喜",
    "松",
    "腳",
    "困",
    "異",
    "免",
    "背",
    "星",
    "福",
    "買",
    "染",
    "井",
    "概",
    "慢",
    "怕",
    "磁",
    "倍",
    "祖",
    "皇",
    "促",
    "靜",
    "補",
    "評",
    "翻",
    "肉",
    "踐",
    "尼",
    "衣",
    "寬",
    "揚",
    "棉",
    "希",
    "傷",
    "操",
    "垂",
    "秋",
    "宜",
    "氫",
    "套",
    "督",
    "振",
    "架",
    "亮",
    "末",
    "憲",
    "慶",
    "編",
    "牛",
    "觸",
    "映",
    "雷",
    "銷",
    "詩",
    "座",
    "居",
    "抓",
    "裂",
    "胞",
    "呼",
    "娘",
    "景",
    "威",
    "綠",
    "晶",
    "厚",
    "盟",
    "衡",
    "雞",
    "孫",
    "延",
    "危",
    "膠",
    "屋",
    "鄉",
    "臨",
    "陸",
    "顧",
    "掉",
    "呀",
    "燈",
    "歲",
    "措",
    "束",
    "耐",
    "劇",
    "玉",
    "趙",
    "跳",
    "哥",
    "季",
    "課",
    "凱",
    "胡",
    "額",
    "款",
    "紹",
    "卷",
    "齊",
    "偉",
    "蒸",
    "殖",
    "永",
    "宗",
    "苗",
    "川",
    "爐",
    "岩",
    "弱",
    "零",
    "楊",
    "奏",
    "沿",
    "露",
    "桿",
    "探",
    "滑",
    "鎮",
    "飯",
    "濃",
    "航",
    "懷",
    "趕",
    "庫",
    "奪",
    "伊",
    "靈",
    "稅",
    "途",
    "滅",
    "賽",
    "歸",
    "召",
    "鼓",
    "播",
    "盤",
    "裁",
    "險",
    "康",
    "唯",
    "錄",
    "菌",
    "純",
    "借",
    "糖",
    "蓋",
    "橫",
    "符",
    "私",
    "努",
    "堂",
    "域",
    "槍",
    "潤",
    "幅",
    "哈",
    "竟",
    "熟",
    "蟲",
    "澤",
    "腦",
    "壤",
    "碳",
    "歐",
    "遍",
    "側",
    "寨",
    "敢",
    "徹",
    "慮",
    "斜",
    "薄",
    "庭",
    "納",
    "彈",
    "飼",
    "伸",
    "折",
    "麥",
    "濕",
    "暗",
    "荷",
    "瓦",
    "塞",
    "床",
    "築",
    "惡",
    "戶",
    "訪",
    "塔",
    "奇",
    "透",
    "梁",
    "刀",
    "旋",
    "跡",
    "卡",
    "氯",
    "遇",
    "份",
    "毒",
    "泥",
    "退",
    "洗",
    "擺",
    "灰",
    "彩",
    "賣",
    "耗",
    "夏",
    "擇",
    "忙",
    "銅",
    "獻",
    "硬",
    "予",
    "繁",
    "圈",
    "雪",
    "函",
    "亦",
    "抽",
    "篇",
    "陣",
    "陰",
    "丁",
    "尺",
    "追",
    "堆",
    "雄",
    "迎",
    "泛",
    "爸",
    "樓",
    "避",
    "謀",
    "噸",
    "野",
    "豬",
    "旗",
    "累",
    "偏",
    "典",
    "館",
    "索",
    "秦",
    "脂",
    "潮",
    "爺",
    "豆",
    "忽",
    "托",
    "驚",
    "塑",
    "遺",
    "愈",
    "朱",
    "替",
    "纖",
    "粗",
    "傾",
    "尚",
    "痛",
    "楚",
    "謝",
    "奮",
    "購",
    "磨",
    "君",
    "池",
    "旁",
    "碎",
    "骨",
    "監",
    "捕",
    "弟",
    "暴",
    "割",
    "貫",
    "殊",
    "釋",
    "詞",
    "亡",
    "壁",
    "頓",
    "寶",
    "午",
    "塵",
    "聞",
    "揭",
    "炮",
    "殘",
    "冬",
    "橋",
    "婦",
    "警",
    "綜",
    "招",
    "吳",
    "付",
    "浮",
    "遭",
    "徐",
    "您",
    "搖",
    "谷",
    "贊",
    "箱",
    "隔",
    "訂",
    "男",
    "吹",
    "園",
    "紛",
    "唐",
    "敗",
    "宋",
    "玻",
    "巨",
    "耕",
    "坦",
    "榮",
    "閉",
    "灣",
    "鍵",
    "凡",
    "駐",
    "鍋",
    "救",
    "恩",
    "剝",
    "凝",
    "鹼",
    "齒",
    "截",
    "煉",
    "麻",
    "紡",
    "禁",
    "廢",
    "盛",
    "版",
    "緩",
    "淨",
    "睛",
    "昌",
    "婚",
    "涉",
    "筒",
    "嘴",
    "插",
    "岸",
    "朗",
    "莊",
    "街",
    "藏",
    "姑",
    "貿",
    "腐",
    "奴",
    "啦",
    "慣",
    "乘",
    "夥",
    "恢",
    "勻",
    "紗",
    "扎",
    "辯",
    "耳",
    "彪",
    "臣",
    "億",
    "璃",
    "抵",
    "脈",
    "秀",
    "薩",
    "俄",
    "網",
    "舞",
    "店",
    "噴",
    "縱",
    "寸",
    "汗",
    "掛",
    "洪",
    "賀",
    "閃",
    "柬",
    "爆",
    "烯",
    "津",
    "稻",
    "牆",
    "軟",
    "勇",
    "像",
    "滾",
    "厘",
    "蒙",
    "芳",
    "肯",
    "坡",
    "柱",
    "盪",
    "腿",
    "儀",
    "旅",
    "尾",
    "軋",
    "冰",
    "貢",
    "登",
    "黎",
    "削",
    "鑽",
    "勒",
    "逃",
    "障",
    "氨",
    "郭",
    "峰",
    "幣",
    "港",
    "伏",
    "軌",
    "畝",
    "畢",
    "擦",
    "莫",
    "刺",
    "浪",
    "秘",
    "援",
    "株",
    "健",
    "售",
    "股",
    "島",
    "甘",
    "泡",
    "睡",
    "童",
    "鑄",
    "湯",
    "閥",
    "休",
    "匯",
    "舍",
    "牧",
    "繞",
    "炸",
    "哲",
    "磷",
    "績",
    "朋",
    "淡",
    "尖",
    "啟",
    "陷",
    "柴",
    "呈",
    "徒",
    "顏",
    "淚",
    "稍",
    "忘",
    "泵",
    "藍",
    "拖",
    "洞",
    "授",
    "鏡",
    "辛",
    "壯",
    "鋒",
    "貧",
    "虛",
    "彎",
    "摩",
    "泰",
    "幼",
    "廷",
    "尊",
    "窗",
    "綱",
    "弄",
    "隸",
    "疑",
    "氏",
    "宮",
    "姐",
    "震",
    "瑞",
    "怪",
    "尤",
    "琴",
    "循",
    "描",
    "膜",
    "違",
    "夾",
    "腰",
    "緣",
    "珠",
    "窮",
    "森",
    "枝",
    "竹",
    "溝",
    "催",
    "繩",
    "憶",
    "邦",
    "剩",
    "幸",
    "漿",
    "欄",
    "擁",
    "牙",
    "貯",
    "禮",
    "濾",
    "鈉",
    "紋",
    "罷",
    "拍",
    "咱",
    "喊",
    "袖",
    "埃",
    "勤",
    "罰",
    "焦",
    "潛",
    "伍",
    "墨",
    "欲",
    "縫",
    "姓",
    "刊",
    "飽",
    "仿",
    "獎",
    "鋁",
    "鬼",
    "麗",
    "跨",
    "默",
    "挖",
    "鏈",
    "掃",
    "喝",
    "袋",
    "炭",
    "污",
    "幕",
    "諸",
    "弧",
    "勵",
    "梅",
    "奶",
    "潔",
    "災",
    "舟",
    "鑑",
    "苯",
    "訟",
    "抱",
    "毀",
    "懂",
    "寒",
    "智",
    "埔",
    "寄",
    "屆",
    "躍",
    "渡",
    "挑",
    "丹",
    "艱",
    "貝",
    "碰",
    "拔",
    "爹",
    "戴",
    "碼",
    "夢",
    "芽",
    "熔",
    "赤",
    "漁",
    "哭",
    "敬",
    "顆",
    "奔",
    "鉛",
    "仲",
    "虎",
    "稀",
    "妹",
    "乏",
    "珍",
    "申",
    "桌",
    "遵",
    "允",
    "隆",
    "螺",
    "倉",
    "魏",
    "銳",
    "曉",
    "氮",
    "兼",
    "隱",
    "礙",
    "赫",
    "撥",
    "忠",
    "肅",
    "缸",
    "牽",
    "搶",
    "博",
    "巧",
    "殼",
    "兄",
    "杜",
    "訊",
    "誠",
    "碧",
    "祥",
    "柯",
    "頁",
    "巡",
    "矩",
    "悲",
    "灌",
    "齡",
    "倫",
    "票",
    "尋",
    "桂",
    "鋪",
    "聖",
    "恐",
    "恰",
    "鄭",
    "趣",
    "抬",
    "荒",
    "騰",
    "貼",
    "柔",
    "滴",
    "猛",
    "闊",
    "輛",
    "妻",
    "填",
    "撤",
    "儲",
    "簽",
    "鬧",
    "擾",
    "紫",
    "砂",
    "遞",
    "戲",
    "吊",
    "陶",
    "伐",
    "餵",
    "療",
    "瓶",
    "婆",
    "撫",
    "臂",
    "摸",
    "忍",
    "蝦",
    "蠟",
    "鄰",
    "胸",
    "鞏",
    "擠",
    "偶",
    "棄",
    "槽",
    "勁",
    "乳",
    "鄧",
    "吉",
    "仁",
    "爛",
    "磚",
    "租",
    "烏",
    "艦",
    "伴",
    "瓜",
    "淺",
    "丙",
    "暫",
    "燥",
    "橡",
    "柳",
    "迷",
    "暖",
    "牌",
    "秧",
    "膽",
    "詳",
    "簧",
    "踏",
    "瓷",
    "譜",
    "呆",
    "賓",
    "糊",
    "洛",
    "輝",
    "憤",
    "競",
    "隙",
    "怒",
    "粘",
    "乃",
    "緒",
    "肩",
    "籍",
    "敏",
    "塗",
    "熙",
    "皆",
    "偵",
    "懸",
    "掘",
    "享",
    "糾",
    "醒",
    "狂",
    "鎖",
    "淀",
    "恨",
    "牲",
    "霸",
    "爬",
    "賞",
    "逆",
    "玩",
    "陵",
    "祝",
    "秒",
    "浙",
    "貌",
    "役",
    "彼",
    "悉",
    "鴨",
    "趨",
    "鳳",
    "晨",
    "畜",
    "輩",
    "秩",
    "卵",
    "署",
    "梯",
    "炎",
    "灘",
    "棋",
    "驅",
    "篩",
    "峽",
    "冒",
    "啥",
    "壽",
    "譯",
    "浸",
    "泉",
    "帽",
    "遲",
    "矽",
    "疆",
    "貸",
    "漏",
    "稿",
    "冠",
    "嫩",
    "脅",
    "芯",
    "牢",
    "叛",
    "蝕",
    "奧",
    "鳴",
    "嶺",
    "羊",
    "憑",
    "串",
    "塘",
    "繪",
    "酵",
    "融",
    "盆",
    "錫",
    "廟",
    "籌",
    "凍",
    "輔",
    "攝",
    "襲",
    "筋",
    "拒",
    "僚",
    "旱",
    "鉀",
    "鳥",
    "漆",
    "沈",
    "眉",
    "疏",
    "添",
    "棒",
    "穗",
    "硝",
    "韓",
    "逼",
    "扭",
    "僑",
    "涼",
    "挺",
    "碗",
    "栽",
    "炒",
    "杯",
    "患",
    "餾",
    "勸",
    "豪",
    "遼",
    "勃",
    "鴻",
    "旦",
    "吏",
    "拜",
    "狗",
    "埋",
    "輥",
    "掩",
    "飲",
    "搬",
    "罵",
    "辭",
    "勾",
    "扣",
    "估",
    "蔣",
    "絨",
    "霧",
    "丈",
    "朵",
    "姆",
    "擬",
    "宇",
    "輯",
    "陝",
    "雕",
    "償",
    "蓄",
    "崇",
    "剪",
    "倡",
    "廳",
    "咬",
    "駛",
    "薯",
    "刷",
    "斥",
    "番",
    "賦",
    "奉",
    "佛",
    "澆",
    "漫",
    "曼",
    "扇",
    "鈣",
    "桃",
    "扶",
    "仔",
    "返",
    "俗",
    "虧",
    "腔",
    "鞋",
    "棱",
    "覆",
    "框",
    "悄",
    "叔",
    "撞",
    "騙",
    "勘",
    "旺",
    "沸",
    "孤",
    "吐",
    "孟",
    "渠",
    "屈",
    "疾",
    "妙",
    "惜",
    "仰",
    "狠",
    "脹",
    "諧",
    "拋",
    "黴",
    "桑",
    "崗",
    "嘛",
    "衰",
    "盜",
    "滲",
    "臟",
    "賴",
    "湧",
    "甜",
    "曹",
    "閱",
    "肌",
    "哩",
    "厲",
    "烴",
    "緯",
    "毅",
    "昨",
    "偽",
    "症",
    "煮",
    "嘆",
    "釘",
    "搭",
    "莖",
    "籠",
    "酷",
    "偷",
    "弓",
    "錐",
    "恆",
    "傑",
    "坑",
    "鼻",
    "翼",
    "綸",
    "敘",
    "獄",
    "逮",
    "罐",
    "絡",
    "棚",
    "抑",
    "膨",
    "蔬",
    "寺",
    "驟",
    "穆",
    "冶",
    "枯",
    "冊",
    "屍",
    "凸",
    "紳",
    "坯",
    "犧",
    "焰",
    "轟",
    "欣",
    "晉",
    "瘦",
    "禦",
    "錠",
    "錦",
    "喪",
    "旬",
    "鍛",
    "壟",
    "搜",
    "撲",
    "邀",
    "亭",
    "酯",
    "邁",
    "舒",
    "脆",
    "酶",
    "閒",
    "憂",
    "酚",
    "頑",
    "羽",
    "漲",
    "卸",
    "仗",
    "陪",
    "闢",
    "懲",
    "杭",
    "姚",
    "肚",
    "捉",
    "飄",
    "漂",
    "昆",
    "欺",
    "吾",
    "郎",
    "烷",
    "汁",
    "呵",
    "飾",
    "蕭",
    "雅",
    "郵",
    "遷",
    "燕",
    "撒",
    "姻",
    "赴",
    "宴",
    "煩",
    "債",
    "帳",
    "斑",
    "鈴",
    "旨",
    "醇",
    "董",
    "餅",
    "雛",
    "姿",
    "拌",
    "傅",
    "腹",
    "妥",
    "揉",
    "賢",
    "拆",
    "歪",
    "葡",
    "胺",
    "丟",
    "浩",
    "徽",
    "昂",
    "墊",
    "擋",
    "覽",
    "貪",
    "慰",
    "繳",
    "汪",
    "慌",
    "馮",
    "諾",
    "姜",
    "誼",
    "兇",
    "劣",
    "誣",
    "耀",
    "昏",
    "躺",
    "盈",
    "騎",
    "喬",
    "溪",
    "叢",
    "盧",
    "抹",
    "悶",
    "諮",
    "刮",
    "駕",
    "纜",
    "悟",
    "摘",
    "鉺",
    "擲",
    "頗",
    "幻",
    "柄",
    "惠",
    "慘",
    "佳",
    "仇",
    "臘",
    "窩",
    "滌",
    "劍",
    "瞧",
    "堡",
    "潑",
    "蔥",
    "罩",
    "霍",
    "撈",
    "胎",
    "蒼",
    "濱",
    "倆",
    "捅",
    "湘",
    "砍",
    "霞",
    "邵",
    "萄",
    "瘋",
    "淮",
    "遂",
    "熊",
    "糞",
    "烘",
    "宿",
    "檔",
    "戈",
    "駁",
    "嫂",
    "裕",
    "徙",
    "箭",
    "捐",
    "腸",
    "撐",
    "曬",
    "辨",
    "殿",
    "蓮",
    "攤",
    "攪",
    "醬",
    "屏",
    "疫",
    "哀",
    "蔡",
    "堵",
    "沫",
    "皺",
    "暢",
    "疊",
    "閣",
    "萊",
    "敲",
    "轄",
    "鉤",
    "痕",
    "壩",
    "巷",
    "餓",
    "禍",
    "丘",
    "玄",
    "溜",
    "曰",
    "邏",
    "彭",
    "嘗",
    "卿",
    "妨",
    "艇",
    "吞",
    "韋",
    "怨",
    "矮",
    "歇"
]

      };
    };
  }
}, {package:"bip39",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\chinese_traditional.json",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\spanish.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\key-tree\node_modules\bip39\src\wordlists\spanish.json
      return function (require, module, exports) {
module.exports=[
    "ábaco",
    "abdomen",
    "abeja",
    "abierto",
    "abogado",
    "abono",
    "aborto",
    "abrazo",
    "abrir",
    "abuelo",
    "abuso",
    "acabar",
    "academia",
    "acceso",
    "acción",
    "aceite",
    "acelga",
    "acento",
    "aceptar",
    "ácido",
    "aclarar",
    "acné",
    "acoger",
    "acoso",
    "activo",
    "acto",
    "actriz",
    "actuar",
    "acudir",
    "acuerdo",
    "acusar",
    "adicto",
    "admitir",
    "adoptar",
    "adorno",
    "aduana",
    "adulto",
    "aéreo",
    "afectar",
    "afición",
    "afinar",
    "afirmar",
    "ágil",
    "agitar",
    "agonía",
    "agosto",
    "agotar",
    "agregar",
    "agrio",
    "agua",
    "agudo",
    "águila",
    "aguja",
    "ahogo",
    "ahorro",
    "aire",
    "aislar",
    "ajedrez",
    "ajeno",
    "ajuste",
    "alacrán",
    "alambre",
    "alarma",
    "alba",
    "álbum",
    "alcalde",
    "aldea",
    "alegre",
    "alejar",
    "alerta",
    "aleta",
    "alfiler",
    "alga",
    "algodón",
    "aliado",
    "aliento",
    "alivio",
    "alma",
    "almeja",
    "almíbar",
    "altar",
    "alteza",
    "altivo",
    "alto",
    "altura",
    "alumno",
    "alzar",
    "amable",
    "amante",
    "amapola",
    "amargo",
    "amasar",
    "ámbar",
    "ámbito",
    "ameno",
    "amigo",
    "amistad",
    "amor",
    "amparo",
    "amplio",
    "ancho",
    "anciano",
    "ancla",
    "andar",
    "andén",
    "anemia",
    "ángulo",
    "anillo",
    "ánimo",
    "anís",
    "anotar",
    "antena",
    "antiguo",
    "antojo",
    "anual",
    "anular",
    "anuncio",
    "añadir",
    "añejo",
    "año",
    "apagar",
    "aparato",
    "apetito",
    "apio",
    "aplicar",
    "apodo",
    "aporte",
    "apoyo",
    "aprender",
    "aprobar",
    "apuesta",
    "apuro",
    "arado",
    "araña",
    "arar",
    "árbitro",
    "árbol",
    "arbusto",
    "archivo",
    "arco",
    "arder",
    "ardilla",
    "arduo",
    "área",
    "árido",
    "aries",
    "armonía",
    "arnés",
    "aroma",
    "arpa",
    "arpón",
    "arreglo",
    "arroz",
    "arruga",
    "arte",
    "artista",
    "asa",
    "asado",
    "asalto",
    "ascenso",
    "asegurar",
    "aseo",
    "asesor",
    "asiento",
    "asilo",
    "asistir",
    "asno",
    "asombro",
    "áspero",
    "astilla",
    "astro",
    "astuto",
    "asumir",
    "asunto",
    "atajo",
    "ataque",
    "atar",
    "atento",
    "ateo",
    "ático",
    "atleta",
    "átomo",
    "atraer",
    "atroz",
    "atún",
    "audaz",
    "audio",
    "auge",
    "aula",
    "aumento",
    "ausente",
    "autor",
    "aval",
    "avance",
    "avaro",
    "ave",
    "avellana",
    "avena",
    "avestruz",
    "avión",
    "aviso",
    "ayer",
    "ayuda",
    "ayuno",
    "azafrán",
    "azar",
    "azote",
    "azúcar",
    "azufre",
    "azul",
    "baba",
    "babor",
    "bache",
    "bahía",
    "baile",
    "bajar",
    "balanza",
    "balcón",
    "balde",
    "bambú",
    "banco",
    "banda",
    "baño",
    "barba",
    "barco",
    "barniz",
    "barro",
    "báscula",
    "bastón",
    "basura",
    "batalla",
    "batería",
    "batir",
    "batuta",
    "baúl",
    "bazar",
    "bebé",
    "bebida",
    "bello",
    "besar",
    "beso",
    "bestia",
    "bicho",
    "bien",
    "bingo",
    "blanco",
    "bloque",
    "blusa",
    "boa",
    "bobina",
    "bobo",
    "boca",
    "bocina",
    "boda",
    "bodega",
    "boina",
    "bola",
    "bolero",
    "bolsa",
    "bomba",
    "bondad",
    "bonito",
    "bono",
    "bonsái",
    "borde",
    "borrar",
    "bosque",
    "bote",
    "botín",
    "bóveda",
    "bozal",
    "bravo",
    "brazo",
    "brecha",
    "breve",
    "brillo",
    "brinco",
    "brisa",
    "broca",
    "broma",
    "bronce",
    "brote",
    "bruja",
    "brusco",
    "bruto",
    "buceo",
    "bucle",
    "bueno",
    "buey",
    "bufanda",
    "bufón",
    "búho",
    "buitre",
    "bulto",
    "burbuja",
    "burla",
    "burro",
    "buscar",
    "butaca",
    "buzón",
    "caballo",
    "cabeza",
    "cabina",
    "cabra",
    "cacao",
    "cadáver",
    "cadena",
    "caer",
    "café",
    "caída",
    "caimán",
    "caja",
    "cajón",
    "cal",
    "calamar",
    "calcio",
    "caldo",
    "calidad",
    "calle",
    "calma",
    "calor",
    "calvo",
    "cama",
    "cambio",
    "camello",
    "camino",
    "campo",
    "cáncer",
    "candil",
    "canela",
    "canguro",
    "canica",
    "canto",
    "caña",
    "cañón",
    "caoba",
    "caos",
    "capaz",
    "capitán",
    "capote",
    "captar",
    "capucha",
    "cara",
    "carbón",
    "cárcel",
    "careta",
    "carga",
    "cariño",
    "carne",
    "carpeta",
    "carro",
    "carta",
    "casa",
    "casco",
    "casero",
    "caspa",
    "castor",
    "catorce",
    "catre",
    "caudal",
    "causa",
    "cazo",
    "cebolla",
    "ceder",
    "cedro",
    "celda",
    "célebre",
    "celoso",
    "célula",
    "cemento",
    "ceniza",
    "centro",
    "cerca",
    "cerdo",
    "cereza",
    "cero",
    "cerrar",
    "certeza",
    "césped",
    "cetro",
    "chacal",
    "chaleco",
    "champú",
    "chancla",
    "chapa",
    "charla",
    "chico",
    "chiste",
    "chivo",
    "choque",
    "choza",
    "chuleta",
    "chupar",
    "ciclón",
    "ciego",
    "cielo",
    "cien",
    "cierto",
    "cifra",
    "cigarro",
    "cima",
    "cinco",
    "cine",
    "cinta",
    "ciprés",
    "circo",
    "ciruela",
    "cisne",
    "cita",
    "ciudad",
    "clamor",
    "clan",
    "claro",
    "clase",
    "clave",
    "cliente",
    "clima",
    "clínica",
    "cobre",
    "cocción",
    "cochino",
    "cocina",
    "coco",
    "código",
    "codo",
    "cofre",
    "coger",
    "cohete",
    "cojín",
    "cojo",
    "cola",
    "colcha",
    "colegio",
    "colgar",
    "colina",
    "collar",
    "colmo",
    "columna",
    "combate",
    "comer",
    "comida",
    "cómodo",
    "compra",
    "conde",
    "conejo",
    "conga",
    "conocer",
    "consejo",
    "contar",
    "copa",
    "copia",
    "corazón",
    "corbata",
    "corcho",
    "cordón",
    "corona",
    "correr",
    "coser",
    "cosmos",
    "costa",
    "cráneo",
    "cráter",
    "crear",
    "crecer",
    "creído",
    "crema",
    "cría",
    "crimen",
    "cripta",
    "crisis",
    "cromo",
    "crónica",
    "croqueta",
    "crudo",
    "cruz",
    "cuadro",
    "cuarto",
    "cuatro",
    "cubo",
    "cubrir",
    "cuchara",
    "cuello",
    "cuento",
    "cuerda",
    "cuesta",
    "cueva",
    "cuidar",
    "culebra",
    "culpa",
    "culto",
    "cumbre",
    "cumplir",
    "cuna",
    "cuneta",
    "cuota",
    "cupón",
    "cúpula",
    "curar",
    "curioso",
    "curso",
    "curva",
    "cutis",
    "dama",
    "danza",
    "dar",
    "dardo",
    "dátil",
    "deber",
    "débil",
    "década",
    "decir",
    "dedo",
    "defensa",
    "definir",
    "dejar",
    "delfín",
    "delgado",
    "delito",
    "demora",
    "denso",
    "dental",
    "deporte",
    "derecho",
    "derrota",
    "desayuno",
    "deseo",
    "desfile",
    "desnudo",
    "destino",
    "desvío",
    "detalle",
    "detener",
    "deuda",
    "día",
    "diablo",
    "diadema",
    "diamante",
    "diana",
    "diario",
    "dibujo",
    "dictar",
    "diente",
    "dieta",
    "diez",
    "difícil",
    "digno",
    "dilema",
    "diluir",
    "dinero",
    "directo",
    "dirigir",
    "disco",
    "diseño",
    "disfraz",
    "diva",
    "divino",
    "doble",
    "doce",
    "dolor",
    "domingo",
    "don",
    "donar",
    "dorado",
    "dormir",
    "dorso",
    "dos",
    "dosis",
    "dragón",
    "droga",
    "ducha",
    "duda",
    "duelo",
    "dueño",
    "dulce",
    "dúo",
    "duque",
    "durar",
    "dureza",
    "duro",
    "ébano",
    "ebrio",
    "echar",
    "eco",
    "ecuador",
    "edad",
    "edición",
    "edificio",
    "editor",
    "educar",
    "efecto",
    "eficaz",
    "eje",
    "ejemplo",
    "elefante",
    "elegir",
    "elemento",
    "elevar",
    "elipse",
    "élite",
    "elixir",
    "elogio",
    "eludir",
    "embudo",
    "emitir",
    "emoción",
    "empate",
    "empeño",
    "empleo",
    "empresa",
    "enano",
    "encargo",
    "enchufe",
    "encía",
    "enemigo",
    "enero",
    "enfado",
    "enfermo",
    "engaño",
    "enigma",
    "enlace",
    "enorme",
    "enredo",
    "ensayo",
    "enseñar",
    "entero",
    "entrar",
    "envase",
    "envío",
    "época",
    "equipo",
    "erizo",
    "escala",
    "escena",
    "escolar",
    "escribir",
    "escudo",
    "esencia",
    "esfera",
    "esfuerzo",
    "espada",
    "espejo",
    "espía",
    "esposa",
    "espuma",
    "esquí",
    "estar",
    "este",
    "estilo",
    "estufa",
    "etapa",
    "eterno",
    "ética",
    "etnia",
    "evadir",
    "evaluar",
    "evento",
    "evitar",
    "exacto",
    "examen",
    "exceso",
    "excusa",
    "exento",
    "exigir",
    "exilio",
    "existir",
    "éxito",
    "experto",
    "explicar",
    "exponer",
    "extremo",
    "fábrica",
    "fábula",
    "fachada",
    "fácil",
    "factor",
    "faena",
    "faja",
    "falda",
    "fallo",
    "falso",
    "faltar",
    "fama",
    "familia",
    "famoso",
    "faraón",
    "farmacia",
    "farol",
    "farsa",
    "fase",
    "fatiga",
    "fauna",
    "favor",
    "fax",
    "febrero",
    "fecha",
    "feliz",
    "feo",
    "feria",
    "feroz",
    "fértil",
    "fervor",
    "festín",
    "fiable",
    "fianza",
    "fiar",
    "fibra",
    "ficción",
    "ficha",
    "fideo",
    "fiebre",
    "fiel",
    "fiera",
    "fiesta",
    "figura",
    "fijar",
    "fijo",
    "fila",
    "filete",
    "filial",
    "filtro",
    "fin",
    "finca",
    "fingir",
    "finito",
    "firma",
    "flaco",
    "flauta",
    "flecha",
    "flor",
    "flota",
    "fluir",
    "flujo",
    "flúor",
    "fobia",
    "foca",
    "fogata",
    "fogón",
    "folio",
    "folleto",
    "fondo",
    "forma",
    "forro",
    "fortuna",
    "forzar",
    "fosa",
    "foto",
    "fracaso",
    "frágil",
    "franja",
    "frase",
    "fraude",
    "freír",
    "freno",
    "fresa",
    "frío",
    "frito",
    "fruta",
    "fuego",
    "fuente",
    "fuerza",
    "fuga",
    "fumar",
    "función",
    "funda",
    "furgón",
    "furia",
    "fusil",
    "fútbol",
    "futuro",
    "gacela",
    "gafas",
    "gaita",
    "gajo",
    "gala",
    "galería",
    "gallo",
    "gamba",
    "ganar",
    "gancho",
    "ganga",
    "ganso",
    "garaje",
    "garza",
    "gasolina",
    "gastar",
    "gato",
    "gavilán",
    "gemelo",
    "gemir",
    "gen",
    "género",
    "genio",
    "gente",
    "geranio",
    "gerente",
    "germen",
    "gesto",
    "gigante",
    "gimnasio",
    "girar",
    "giro",
    "glaciar",
    "globo",
    "gloria",
    "gol",
    "golfo",
    "goloso",
    "golpe",
    "goma",
    "gordo",
    "gorila",
    "gorra",
    "gota",
    "goteo",
    "gozar",
    "grada",
    "gráfico",
    "grano",
    "grasa",
    "gratis",
    "grave",
    "grieta",
    "grillo",
    "gripe",
    "gris",
    "grito",
    "grosor",
    "grúa",
    "grueso",
    "grumo",
    "grupo",
    "guante",
    "guapo",
    "guardia",
    "guerra",
    "guía",
    "guiño",
    "guion",
    "guiso",
    "guitarra",
    "gusano",
    "gustar",
    "haber",
    "hábil",
    "hablar",
    "hacer",
    "hacha",
    "hada",
    "hallar",
    "hamaca",
    "harina",
    "haz",
    "hazaña",
    "hebilla",
    "hebra",
    "hecho",
    "helado",
    "helio",
    "hembra",
    "herir",
    "hermano",
    "héroe",
    "hervir",
    "hielo",
    "hierro",
    "hígado",
    "higiene",
    "hijo",
    "himno",
    "historia",
    "hocico",
    "hogar",
    "hoguera",
    "hoja",
    "hombre",
    "hongo",
    "honor",
    "honra",
    "hora",
    "hormiga",
    "horno",
    "hostil",
    "hoyo",
    "hueco",
    "huelga",
    "huerta",
    "hueso",
    "huevo",
    "huida",
    "huir",
    "humano",
    "húmedo",
    "humilde",
    "humo",
    "hundir",
    "huracán",
    "hurto",
    "icono",
    "ideal",
    "idioma",
    "ídolo",
    "iglesia",
    "iglú",
    "igual",
    "ilegal",
    "ilusión",
    "imagen",
    "imán",
    "imitar",
    "impar",
    "imperio",
    "imponer",
    "impulso",
    "incapaz",
    "índice",
    "inerte",
    "infiel",
    "informe",
    "ingenio",
    "inicio",
    "inmenso",
    "inmune",
    "innato",
    "insecto",
    "instante",
    "interés",
    "íntimo",
    "intuir",
    "inútil",
    "invierno",
    "ira",
    "iris",
    "ironía",
    "isla",
    "islote",
    "jabalí",
    "jabón",
    "jamón",
    "jarabe",
    "jardín",
    "jarra",
    "jaula",
    "jazmín",
    "jefe",
    "jeringa",
    "jinete",
    "jornada",
    "joroba",
    "joven",
    "joya",
    "juerga",
    "jueves",
    "juez",
    "jugador",
    "jugo",
    "juguete",
    "juicio",
    "junco",
    "jungla",
    "junio",
    "juntar",
    "júpiter",
    "jurar",
    "justo",
    "juvenil",
    "juzgar",
    "kilo",
    "koala",
    "labio",
    "lacio",
    "lacra",
    "lado",
    "ladrón",
    "lagarto",
    "lágrima",
    "laguna",
    "laico",
    "lamer",
    "lámina",
    "lámpara",
    "lana",
    "lancha",
    "langosta",
    "lanza",
    "lápiz",
    "largo",
    "larva",
    "lástima",
    "lata",
    "látex",
    "latir",
    "laurel",
    "lavar",
    "lazo",
    "leal",
    "lección",
    "leche",
    "lector",
    "leer",
    "legión",
    "legumbre",
    "lejano",
    "lengua",
    "lento",
    "leña",
    "león",
    "leopardo",
    "lesión",
    "letal",
    "letra",
    "leve",
    "leyenda",
    "libertad",
    "libro",
    "licor",
    "líder",
    "lidiar",
    "lienzo",
    "liga",
    "ligero",
    "lima",
    "límite",
    "limón",
    "limpio",
    "lince",
    "lindo",
    "línea",
    "lingote",
    "lino",
    "linterna",
    "líquido",
    "liso",
    "lista",
    "litera",
    "litio",
    "litro",
    "llaga",
    "llama",
    "llanto",
    "llave",
    "llegar",
    "llenar",
    "llevar",
    "llorar",
    "llover",
    "lluvia",
    "lobo",
    "loción",
    "loco",
    "locura",
    "lógica",
    "logro",
    "lombriz",
    "lomo",
    "lonja",
    "lote",
    "lucha",
    "lucir",
    "lugar",
    "lujo",
    "luna",
    "lunes",
    "lupa",
    "lustro",
    "luto",
    "luz",
    "maceta",
    "macho",
    "madera",
    "madre",
    "maduro",
    "maestro",
    "mafia",
    "magia",
    "mago",
    "maíz",
    "maldad",
    "maleta",
    "malla",
    "malo",
    "mamá",
    "mambo",
    "mamut",
    "manco",
    "mando",
    "manejar",
    "manga",
    "maniquí",
    "manjar",
    "mano",
    "manso",
    "manta",
    "mañana",
    "mapa",
    "máquina",
    "mar",
    "marco",
    "marea",
    "marfil",
    "margen",
    "marido",
    "mármol",
    "marrón",
    "martes",
    "marzo",
    "masa",
    "máscara",
    "masivo",
    "matar",
    "materia",
    "matiz",
    "matriz",
    "máximo",
    "mayor",
    "mazorca",
    "mecha",
    "medalla",
    "medio",
    "médula",
    "mejilla",
    "mejor",
    "melena",
    "melón",
    "memoria",
    "menor",
    "mensaje",
    "mente",
    "menú",
    "mercado",
    "merengue",
    "mérito",
    "mes",
    "mesón",
    "meta",
    "meter",
    "método",
    "metro",
    "mezcla",
    "miedo",
    "miel",
    "miembro",
    "miga",
    "mil",
    "milagro",
    "militar",
    "millón",
    "mimo",
    "mina",
    "minero",
    "mínimo",
    "minuto",
    "miope",
    "mirar",
    "misa",
    "miseria",
    "misil",
    "mismo",
    "mitad",
    "mito",
    "mochila",
    "moción",
    "moda",
    "modelo",
    "moho",
    "mojar",
    "molde",
    "moler",
    "molino",
    "momento",
    "momia",
    "monarca",
    "moneda",
    "monja",
    "monto",
    "moño",
    "morada",
    "morder",
    "moreno",
    "morir",
    "morro",
    "morsa",
    "mortal",
    "mosca",
    "mostrar",
    "motivo",
    "mover",
    "móvil",
    "mozo",
    "mucho",
    "mudar",
    "mueble",
    "muela",
    "muerte",
    "muestra",
    "mugre",
    "mujer",
    "mula",
    "muleta",
    "multa",
    "mundo",
    "muñeca",
    "mural",
    "muro",
    "músculo",
    "museo",
    "musgo",
    "música",
    "muslo",
    "nácar",
    "nación",
    "nadar",
    "naipe",
    "naranja",
    "nariz",
    "narrar",
    "nasal",
    "natal",
    "nativo",
    "natural",
    "náusea",
    "naval",
    "nave",
    "navidad",
    "necio",
    "néctar",
    "negar",
    "negocio",
    "negro",
    "neón",
    "nervio",
    "neto",
    "neutro",
    "nevar",
    "nevera",
    "nicho",
    "nido",
    "niebla",
    "nieto",
    "niñez",
    "niño",
    "nítido",
    "nivel",
    "nobleza",
    "noche",
    "nómina",
    "noria",
    "norma",
    "norte",
    "nota",
    "noticia",
    "novato",
    "novela",
    "novio",
    "nube",
    "nuca",
    "núcleo",
    "nudillo",
    "nudo",
    "nuera",
    "nueve",
    "nuez",
    "nulo",
    "número",
    "nutria",
    "oasis",
    "obeso",
    "obispo",
    "objeto",
    "obra",
    "obrero",
    "observar",
    "obtener",
    "obvio",
    "oca",
    "ocaso",
    "océano",
    "ochenta",
    "ocho",
    "ocio",
    "ocre",
    "octavo",
    "octubre",
    "oculto",
    "ocupar",
    "ocurrir",
    "odiar",
    "odio",
    "odisea",
    "oeste",
    "ofensa",
    "oferta",
    "oficio",
    "ofrecer",
    "ogro",
    "oído",
    "oír",
    "ojo",
    "ola",
    "oleada",
    "olfato",
    "olivo",
    "olla",
    "olmo",
    "olor",
    "olvido",
    "ombligo",
    "onda",
    "onza",
    "opaco",
    "opción",
    "ópera",
    "opinar",
    "oponer",
    "optar",
    "óptica",
    "opuesto",
    "oración",
    "orador",
    "oral",
    "órbita",
    "orca",
    "orden",
    "oreja",
    "órgano",
    "orgía",
    "orgullo",
    "oriente",
    "origen",
    "orilla",
    "oro",
    "orquesta",
    "oruga",
    "osadía",
    "oscuro",
    "osezno",
    "oso",
    "ostra",
    "otoño",
    "otro",
    "oveja",
    "óvulo",
    "óxido",
    "oxígeno",
    "oyente",
    "ozono",
    "pacto",
    "padre",
    "paella",
    "página",
    "pago",
    "país",
    "pájaro",
    "palabra",
    "palco",
    "paleta",
    "pálido",
    "palma",
    "paloma",
    "palpar",
    "pan",
    "panal",
    "pánico",
    "pantera",
    "pañuelo",
    "papá",
    "papel",
    "papilla",
    "paquete",
    "parar",
    "parcela",
    "pared",
    "parir",
    "paro",
    "párpado",
    "parque",
    "párrafo",
    "parte",
    "pasar",
    "paseo",
    "pasión",
    "paso",
    "pasta",
    "pata",
    "patio",
    "patria",
    "pausa",
    "pauta",
    "pavo",
    "payaso",
    "peatón",
    "pecado",
    "pecera",
    "pecho",
    "pedal",
    "pedir",
    "pegar",
    "peine",
    "pelar",
    "peldaño",
    "pelea",
    "peligro",
    "pellejo",
    "pelo",
    "peluca",
    "pena",
    "pensar",
    "peñón",
    "peón",
    "peor",
    "pepino",
    "pequeño",
    "pera",
    "percha",
    "perder",
    "pereza",
    "perfil",
    "perico",
    "perla",
    "permiso",
    "perro",
    "persona",
    "pesa",
    "pesca",
    "pésimo",
    "pestaña",
    "pétalo",
    "petróleo",
    "pez",
    "pezuña",
    "picar",
    "pichón",
    "pie",
    "piedra",
    "pierna",
    "pieza",
    "pijama",
    "pilar",
    "piloto",
    "pimienta",
    "pino",
    "pintor",
    "pinza",
    "piña",
    "piojo",
    "pipa",
    "pirata",
    "pisar",
    "piscina",
    "piso",
    "pista",
    "pitón",
    "pizca",
    "placa",
    "plan",
    "plata",
    "playa",
    "plaza",
    "pleito",
    "pleno",
    "plomo",
    "pluma",
    "plural",
    "pobre",
    "poco",
    "poder",
    "podio",
    "poema",
    "poesía",
    "poeta",
    "polen",
    "policía",
    "pollo",
    "polvo",
    "pomada",
    "pomelo",
    "pomo",
    "pompa",
    "poner",
    "porción",
    "portal",
    "posada",
    "poseer",
    "posible",
    "poste",
    "potencia",
    "potro",
    "pozo",
    "prado",
    "precoz",
    "pregunta",
    "premio",
    "prensa",
    "preso",
    "previo",
    "primo",
    "príncipe",
    "prisión",
    "privar",
    "proa",
    "probar",
    "proceso",
    "producto",
    "proeza",
    "profesor",
    "programa",
    "prole",
    "promesa",
    "pronto",
    "propio",
    "próximo",
    "prueba",
    "público",
    "puchero",
    "pudor",
    "pueblo",
    "puerta",
    "puesto",
    "pulga",
    "pulir",
    "pulmón",
    "pulpo",
    "pulso",
    "puma",
    "punto",
    "puñal",
    "puño",
    "pupa",
    "pupila",
    "puré",
    "quedar",
    "queja",
    "quemar",
    "querer",
    "queso",
    "quieto",
    "química",
    "quince",
    "quitar",
    "rábano",
    "rabia",
    "rabo",
    "ración",
    "radical",
    "raíz",
    "rama",
    "rampa",
    "rancho",
    "rango",
    "rapaz",
    "rápido",
    "rapto",
    "rasgo",
    "raspa",
    "rato",
    "rayo",
    "raza",
    "razón",
    "reacción",
    "realidad",
    "rebaño",
    "rebote",
    "recaer",
    "receta",
    "rechazo",
    "recoger",
    "recreo",
    "recto",
    "recurso",
    "red",
    "redondo",
    "reducir",
    "reflejo",
    "reforma",
    "refrán",
    "refugio",
    "regalo",
    "regir",
    "regla",
    "regreso",
    "rehén",
    "reino",
    "reír",
    "reja",
    "relato",
    "relevo",
    "relieve",
    "relleno",
    "reloj",
    "remar",
    "remedio",
    "remo",
    "rencor",
    "rendir",
    "renta",
    "reparto",
    "repetir",
    "reposo",
    "reptil",
    "res",
    "rescate",
    "resina",
    "respeto",
    "resto",
    "resumen",
    "retiro",
    "retorno",
    "retrato",
    "reunir",
    "revés",
    "revista",
    "rey",
    "rezar",
    "rico",
    "riego",
    "rienda",
    "riesgo",
    "rifa",
    "rígido",
    "rigor",
    "rincón",
    "riñón",
    "río",
    "riqueza",
    "risa",
    "ritmo",
    "rito",
    "rizo",
    "roble",
    "roce",
    "rociar",
    "rodar",
    "rodeo",
    "rodilla",
    "roer",
    "rojizo",
    "rojo",
    "romero",
    "romper",
    "ron",
    "ronco",
    "ronda",
    "ropa",
    "ropero",
    "rosa",
    "rosca",
    "rostro",
    "rotar",
    "rubí",
    "rubor",
    "rudo",
    "rueda",
    "rugir",
    "ruido",
    "ruina",
    "ruleta",
    "rulo",
    "rumbo",
    "rumor",
    "ruptura",
    "ruta",
    "rutina",
    "sábado",
    "saber",
    "sabio",
    "sable",
    "sacar",
    "sagaz",
    "sagrado",
    "sala",
    "saldo",
    "salero",
    "salir",
    "salmón",
    "salón",
    "salsa",
    "salto",
    "salud",
    "salvar",
    "samba",
    "sanción",
    "sandía",
    "sanear",
    "sangre",
    "sanidad",
    "sano",
    "santo",
    "sapo",
    "saque",
    "sardina",
    "sartén",
    "sastre",
    "satán",
    "sauna",
    "saxofón",
    "sección",
    "seco",
    "secreto",
    "secta",
    "sed",
    "seguir",
    "seis",
    "sello",
    "selva",
    "semana",
    "semilla",
    "senda",
    "sensor",
    "señal",
    "señor",
    "separar",
    "sepia",
    "sequía",
    "ser",
    "serie",
    "sermón",
    "servir",
    "sesenta",
    "sesión",
    "seta",
    "setenta",
    "severo",
    "sexo",
    "sexto",
    "sidra",
    "siesta",
    "siete",
    "siglo",
    "signo",
    "sílaba",
    "silbar",
    "silencio",
    "silla",
    "símbolo",
    "simio",
    "sirena",
    "sistema",
    "sitio",
    "situar",
    "sobre",
    "socio",
    "sodio",
    "sol",
    "solapa",
    "soldado",
    "soledad",
    "sólido",
    "soltar",
    "solución",
    "sombra",
    "sondeo",
    "sonido",
    "sonoro",
    "sonrisa",
    "sopa",
    "soplar",
    "soporte",
    "sordo",
    "sorpresa",
    "sorteo",
    "sostén",
    "sótano",
    "suave",
    "subir",
    "suceso",
    "sudor",
    "suegra",
    "suelo",
    "sueño",
    "suerte",
    "sufrir",
    "sujeto",
    "sultán",
    "sumar",
    "superar",
    "suplir",
    "suponer",
    "supremo",
    "sur",
    "surco",
    "sureño",
    "surgir",
    "susto",
    "sutil",
    "tabaco",
    "tabique",
    "tabla",
    "tabú",
    "taco",
    "tacto",
    "tajo",
    "talar",
    "talco",
    "talento",
    "talla",
    "talón",
    "tamaño",
    "tambor",
    "tango",
    "tanque",
    "tapa",
    "tapete",
    "tapia",
    "tapón",
    "taquilla",
    "tarde",
    "tarea",
    "tarifa",
    "tarjeta",
    "tarot",
    "tarro",
    "tarta",
    "tatuaje",
    "tauro",
    "taza",
    "tazón",
    "teatro",
    "techo",
    "tecla",
    "técnica",
    "tejado",
    "tejer",
    "tejido",
    "tela",
    "teléfono",
    "tema",
    "temor",
    "templo",
    "tenaz",
    "tender",
    "tener",
    "tenis",
    "tenso",
    "teoría",
    "terapia",
    "terco",
    "término",
    "ternura",
    "terror",
    "tesis",
    "tesoro",
    "testigo",
    "tetera",
    "texto",
    "tez",
    "tibio",
    "tiburón",
    "tiempo",
    "tienda",
    "tierra",
    "tieso",
    "tigre",
    "tijera",
    "tilde",
    "timbre",
    "tímido",
    "timo",
    "tinta",
    "tío",
    "típico",
    "tipo",
    "tira",
    "tirón",
    "titán",
    "títere",
    "título",
    "tiza",
    "toalla",
    "tobillo",
    "tocar",
    "tocino",
    "todo",
    "toga",
    "toldo",
    "tomar",
    "tono",
    "tonto",
    "topar",
    "tope",
    "toque",
    "tórax",
    "torero",
    "tormenta",
    "torneo",
    "toro",
    "torpedo",
    "torre",
    "torso",
    "tortuga",
    "tos",
    "tosco",
    "toser",
    "tóxico",
    "trabajo",
    "tractor",
    "traer",
    "tráfico",
    "trago",
    "traje",
    "tramo",
    "trance",
    "trato",
    "trauma",
    "trazar",
    "trébol",
    "tregua",
    "treinta",
    "tren",
    "trepar",
    "tres",
    "tribu",
    "trigo",
    "tripa",
    "triste",
    "triunfo",
    "trofeo",
    "trompa",
    "tronco",
    "tropa",
    "trote",
    "trozo",
    "truco",
    "trueno",
    "trufa",
    "tubería",
    "tubo",
    "tuerto",
    "tumba",
    "tumor",
    "túnel",
    "túnica",
    "turbina",
    "turismo",
    "turno",
    "tutor",
    "ubicar",
    "úlcera",
    "umbral",
    "unidad",
    "unir",
    "universo",
    "uno",
    "untar",
    "uña",
    "urbano",
    "urbe",
    "urgente",
    "urna",
    "usar",
    "usuario",
    "útil",
    "utopía",
    "uva",
    "vaca",
    "vacío",
    "vacuna",
    "vagar",
    "vago",
    "vaina",
    "vajilla",
    "vale",
    "válido",
    "valle",
    "valor",
    "válvula",
    "vampiro",
    "vara",
    "variar",
    "varón",
    "vaso",
    "vecino",
    "vector",
    "vehículo",
    "veinte",
    "vejez",
    "vela",
    "velero",
    "veloz",
    "vena",
    "vencer",
    "venda",
    "veneno",
    "vengar",
    "venir",
    "venta",
    "venus",
    "ver",
    "verano",
    "verbo",
    "verde",
    "vereda",
    "verja",
    "verso",
    "verter",
    "vía",
    "viaje",
    "vibrar",
    "vicio",
    "víctima",
    "vida",
    "vídeo",
    "vidrio",
    "viejo",
    "viernes",
    "vigor",
    "vil",
    "villa",
    "vinagre",
    "vino",
    "viñedo",
    "violín",
    "viral",
    "virgo",
    "virtud",
    "visor",
    "víspera",
    "vista",
    "vitamina",
    "viudo",
    "vivaz",
    "vivero",
    "vivir",
    "vivo",
    "volcán",
    "volumen",
    "volver",
    "voraz",
    "votar",
    "voto",
    "voz",
    "vuelo",
    "vulgar",
    "yacer",
    "yate",
    "yegua",
    "yema",
    "yerno",
    "yeso",
    "yodo",
    "yoga",
    "yogur",
    "zafiro",
    "zanja",
    "zapato",
    "zarza",
    "zona",
    "zorro",
    "zumo",
    "zurdo"
]

      };
    };
  }
}, {package:"bip39",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\spanish.json",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\portuguese.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\key-tree\node_modules\bip39\src\wordlists\portuguese.json
      return function (require, module, exports) {
module.exports=[
    "abacate",
    "abaixo",
    "abalar",
    "abater",
    "abduzir",
    "abelha",
    "aberto",
    "abismo",
    "abotoar",
    "abranger",
    "abreviar",
    "abrigar",
    "abrupto",
    "absinto",
    "absoluto",
    "absurdo",
    "abutre",
    "acabado",
    "acalmar",
    "acampar",
    "acanhar",
    "acaso",
    "aceitar",
    "acelerar",
    "acenar",
    "acervo",
    "acessar",
    "acetona",
    "achatar",
    "acidez",
    "acima",
    "acionado",
    "acirrar",
    "aclamar",
    "aclive",
    "acolhida",
    "acomodar",
    "acoplar",
    "acordar",
    "acumular",
    "acusador",
    "adaptar",
    "adega",
    "adentro",
    "adepto",
    "adequar",
    "aderente",
    "adesivo",
    "adeus",
    "adiante",
    "aditivo",
    "adjetivo",
    "adjunto",
    "admirar",
    "adorar",
    "adquirir",
    "adubo",
    "adverso",
    "advogado",
    "aeronave",
    "afastar",
    "aferir",
    "afetivo",
    "afinador",
    "afivelar",
    "aflito",
    "afluente",
    "afrontar",
    "agachar",
    "agarrar",
    "agasalho",
    "agenciar",
    "agilizar",
    "agiota",
    "agitado",
    "agora",
    "agradar",
    "agreste",
    "agrupar",
    "aguardar",
    "agulha",
    "ajoelhar",
    "ajudar",
    "ajustar",
    "alameda",
    "alarme",
    "alastrar",
    "alavanca",
    "albergue",
    "albino",
    "alcatra",
    "aldeia",
    "alecrim",
    "alegria",
    "alertar",
    "alface",
    "alfinete",
    "algum",
    "alheio",
    "aliar",
    "alicate",
    "alienar",
    "alinhar",
    "aliviar",
    "almofada",
    "alocar",
    "alpiste",
    "alterar",
    "altitude",
    "alucinar",
    "alugar",
    "aluno",
    "alusivo",
    "alvo",
    "amaciar",
    "amador",
    "amarelo",
    "amassar",
    "ambas",
    "ambiente",
    "ameixa",
    "amenizar",
    "amido",
    "amistoso",
    "amizade",
    "amolador",
    "amontoar",
    "amoroso",
    "amostra",
    "amparar",
    "ampliar",
    "ampola",
    "anagrama",
    "analisar",
    "anarquia",
    "anatomia",
    "andaime",
    "anel",
    "anexo",
    "angular",
    "animar",
    "anjo",
    "anomalia",
    "anotado",
    "ansioso",
    "anterior",
    "anuidade",
    "anunciar",
    "anzol",
    "apagador",
    "apalpar",
    "apanhado",
    "apego",
    "apelido",
    "apertada",
    "apesar",
    "apetite",
    "apito",
    "aplauso",
    "aplicada",
    "apoio",
    "apontar",
    "aposta",
    "aprendiz",
    "aprovar",
    "aquecer",
    "arame",
    "aranha",
    "arara",
    "arcada",
    "ardente",
    "areia",
    "arejar",
    "arenito",
    "aresta",
    "argiloso",
    "argola",
    "arma",
    "arquivo",
    "arraial",
    "arrebate",
    "arriscar",
    "arroba",
    "arrumar",
    "arsenal",
    "arterial",
    "artigo",
    "arvoredo",
    "asfaltar",
    "asilado",
    "aspirar",
    "assador",
    "assinar",
    "assoalho",
    "assunto",
    "astral",
    "atacado",
    "atadura",
    "atalho",
    "atarefar",
    "atear",
    "atender",
    "aterro",
    "ateu",
    "atingir",
    "atirador",
    "ativo",
    "atoleiro",
    "atracar",
    "atrevido",
    "atriz",
    "atual",
    "atum",
    "auditor",
    "aumentar",
    "aura",
    "aurora",
    "autismo",
    "autoria",
    "autuar",
    "avaliar",
    "avante",
    "avaria",
    "avental",
    "avesso",
    "aviador",
    "avisar",
    "avulso",
    "axila",
    "azarar",
    "azedo",
    "azeite",
    "azulejo",
    "babar",
    "babosa",
    "bacalhau",
    "bacharel",
    "bacia",
    "bagagem",
    "baiano",
    "bailar",
    "baioneta",
    "bairro",
    "baixista",
    "bajular",
    "baleia",
    "baliza",
    "balsa",
    "banal",
    "bandeira",
    "banho",
    "banir",
    "banquete",
    "barato",
    "barbado",
    "baronesa",
    "barraca",
    "barulho",
    "baseado",
    "bastante",
    "batata",
    "batedor",
    "batida",
    "batom",
    "batucar",
    "baunilha",
    "beber",
    "beijo",
    "beirada",
    "beisebol",
    "beldade",
    "beleza",
    "belga",
    "beliscar",
    "bendito",
    "bengala",
    "benzer",
    "berimbau",
    "berlinda",
    "berro",
    "besouro",
    "bexiga",
    "bezerro",
    "bico",
    "bicudo",
    "bienal",
    "bifocal",
    "bifurcar",
    "bigorna",
    "bilhete",
    "bimestre",
    "bimotor",
    "biologia",
    "biombo",
    "biosfera",
    "bipolar",
    "birrento",
    "biscoito",
    "bisneto",
    "bispo",
    "bissexto",
    "bitola",
    "bizarro",
    "blindado",
    "bloco",
    "bloquear",
    "boato",
    "bobagem",
    "bocado",
    "bocejo",
    "bochecha",
    "boicotar",
    "bolada",
    "boletim",
    "bolha",
    "bolo",
    "bombeiro",
    "bonde",
    "boneco",
    "bonita",
    "borbulha",
    "borda",
    "boreal",
    "borracha",
    "bovino",
    "boxeador",
    "branco",
    "brasa",
    "braveza",
    "breu",
    "briga",
    "brilho",
    "brincar",
    "broa",
    "brochura",
    "bronzear",
    "broto",
    "bruxo",
    "bucha",
    "budismo",
    "bufar",
    "bule",
    "buraco",
    "busca",
    "busto",
    "buzina",
    "cabana",
    "cabelo",
    "cabide",
    "cabo",
    "cabrito",
    "cacau",
    "cacetada",
    "cachorro",
    "cacique",
    "cadastro",
    "cadeado",
    "cafezal",
    "caiaque",
    "caipira",
    "caixote",
    "cajado",
    "caju",
    "calafrio",
    "calcular",
    "caldeira",
    "calibrar",
    "calmante",
    "calota",
    "camada",
    "cambista",
    "camisa",
    "camomila",
    "campanha",
    "camuflar",
    "canavial",
    "cancelar",
    "caneta",
    "canguru",
    "canhoto",
    "canivete",
    "canoa",
    "cansado",
    "cantar",
    "canudo",
    "capacho",
    "capela",
    "capinar",
    "capotar",
    "capricho",
    "captador",
    "capuz",
    "caracol",
    "carbono",
    "cardeal",
    "careca",
    "carimbar",
    "carneiro",
    "carpete",
    "carreira",
    "cartaz",
    "carvalho",
    "casaco",
    "casca",
    "casebre",
    "castelo",
    "casulo",
    "catarata",
    "cativar",
    "caule",
    "causador",
    "cautelar",
    "cavalo",
    "caverna",
    "cebola",
    "cedilha",
    "cegonha",
    "celebrar",
    "celular",
    "cenoura",
    "censo",
    "centeio",
    "cercar",
    "cerrado",
    "certeiro",
    "cerveja",
    "cetim",
    "cevada",
    "chacota",
    "chaleira",
    "chamado",
    "chapada",
    "charme",
    "chatice",
    "chave",
    "chefe",
    "chegada",
    "cheiro",
    "cheque",
    "chicote",
    "chifre",
    "chinelo",
    "chocalho",
    "chover",
    "chumbo",
    "chutar",
    "chuva",
    "cicatriz",
    "ciclone",
    "cidade",
    "cidreira",
    "ciente",
    "cigana",
    "cimento",
    "cinto",
    "cinza",
    "ciranda",
    "circuito",
    "cirurgia",
    "citar",
    "clareza",
    "clero",
    "clicar",
    "clone",
    "clube",
    "coado",
    "coagir",
    "cobaia",
    "cobertor",
    "cobrar",
    "cocada",
    "coelho",
    "coentro",
    "coeso",
    "cogumelo",
    "coibir",
    "coifa",
    "coiote",
    "colar",
    "coleira",
    "colher",
    "colidir",
    "colmeia",
    "colono",
    "coluna",
    "comando",
    "combinar",
    "comentar",
    "comitiva",
    "comover",
    "complexo",
    "comum",
    "concha",
    "condor",
    "conectar",
    "confuso",
    "congelar",
    "conhecer",
    "conjugar",
    "consumir",
    "contrato",
    "convite",
    "cooperar",
    "copeiro",
    "copiador",
    "copo",
    "coquetel",
    "coragem",
    "cordial",
    "corneta",
    "coronha",
    "corporal",
    "correio",
    "cortejo",
    "coruja",
    "corvo",
    "cosseno",
    "costela",
    "cotonete",
    "couro",
    "couve",
    "covil",
    "cozinha",
    "cratera",
    "cravo",
    "creche",
    "credor",
    "creme",
    "crer",
    "crespo",
    "criada",
    "criminal",
    "crioulo",
    "crise",
    "criticar",
    "crosta",
    "crua",
    "cruzeiro",
    "cubano",
    "cueca",
    "cuidado",
    "cujo",
    "culatra",
    "culminar",
    "culpar",
    "cultura",
    "cumprir",
    "cunhado",
    "cupido",
    "curativo",
    "curral",
    "cursar",
    "curto",
    "cuspir",
    "custear",
    "cutelo",
    "damasco",
    "datar",
    "debater",
    "debitar",
    "deboche",
    "debulhar",
    "decalque",
    "decimal",
    "declive",
    "decote",
    "decretar",
    "dedal",
    "dedicado",
    "deduzir",
    "defesa",
    "defumar",
    "degelo",
    "degrau",
    "degustar",
    "deitado",
    "deixar",
    "delator",
    "delegado",
    "delinear",
    "delonga",
    "demanda",
    "demitir",
    "demolido",
    "dentista",
    "depenado",
    "depilar",
    "depois",
    "depressa",
    "depurar",
    "deriva",
    "derramar",
    "desafio",
    "desbotar",
    "descanso",
    "desenho",
    "desfiado",
    "desgaste",
    "desigual",
    "deslize",
    "desmamar",
    "desova",
    "despesa",
    "destaque",
    "desviar",
    "detalhar",
    "detentor",
    "detonar",
    "detrito",
    "deusa",
    "dever",
    "devido",
    "devotado",
    "dezena",
    "diagrama",
    "dialeto",
    "didata",
    "difuso",
    "digitar",
    "dilatado",
    "diluente",
    "diminuir",
    "dinastia",
    "dinheiro",
    "diocese",
    "direto",
    "discreta",
    "disfarce",
    "disparo",
    "disquete",
    "dissipar",
    "distante",
    "ditador",
    "diurno",
    "diverso",
    "divisor",
    "divulgar",
    "dizer",
    "dobrador",
    "dolorido",
    "domador",
    "dominado",
    "donativo",
    "donzela",
    "dormente",
    "dorsal",
    "dosagem",
    "dourado",
    "doutor",
    "drenagem",
    "drible",
    "drogaria",
    "duelar",
    "duende",
    "dueto",
    "duplo",
    "duquesa",
    "durante",
    "duvidoso",
    "eclodir",
    "ecoar",
    "ecologia",
    "edificar",
    "edital",
    "educado",
    "efeito",
    "efetivar",
    "ejetar",
    "elaborar",
    "eleger",
    "eleitor",
    "elenco",
    "elevador",
    "eliminar",
    "elogiar",
    "embargo",
    "embolado",
    "embrulho",
    "embutido",
    "emenda",
    "emergir",
    "emissor",
    "empatia",
    "empenho",
    "empinado",
    "empolgar",
    "emprego",
    "empurrar",
    "emulador",
    "encaixe",
    "encenado",
    "enchente",
    "encontro",
    "endeusar",
    "endossar",
    "enfaixar",
    "enfeite",
    "enfim",
    "engajado",
    "engenho",
    "englobar",
    "engomado",
    "engraxar",
    "enguia",
    "enjoar",
    "enlatar",
    "enquanto",
    "enraizar",
    "enrolado",
    "enrugar",
    "ensaio",
    "enseada",
    "ensino",
    "ensopado",
    "entanto",
    "enteado",
    "entidade",
    "entortar",
    "entrada",
    "entulho",
    "envergar",
    "enviado",
    "envolver",
    "enxame",
    "enxerto",
    "enxofre",
    "enxuto",
    "epiderme",
    "equipar",
    "ereto",
    "erguido",
    "errata",
    "erva",
    "ervilha",
    "esbanjar",
    "esbelto",
    "escama",
    "escola",
    "escrita",
    "escuta",
    "esfinge",
    "esfolar",
    "esfregar",
    "esfumado",
    "esgrima",
    "esmalte",
    "espanto",
    "espelho",
    "espiga",
    "esponja",
    "espreita",
    "espumar",
    "esquerda",
    "estaca",
    "esteira",
    "esticar",
    "estofado",
    "estrela",
    "estudo",
    "esvaziar",
    "etanol",
    "etiqueta",
    "euforia",
    "europeu",
    "evacuar",
    "evaporar",
    "evasivo",
    "eventual",
    "evidente",
    "evoluir",
    "exagero",
    "exalar",
    "examinar",
    "exato",
    "exausto",
    "excesso",
    "excitar",
    "exclamar",
    "executar",
    "exemplo",
    "exibir",
    "exigente",
    "exonerar",
    "expandir",
    "expelir",
    "expirar",
    "explanar",
    "exposto",
    "expresso",
    "expulsar",
    "externo",
    "extinto",
    "extrato",
    "fabricar",
    "fabuloso",
    "faceta",
    "facial",
    "fada",
    "fadiga",
    "faixa",
    "falar",
    "falta",
    "familiar",
    "fandango",
    "fanfarra",
    "fantoche",
    "fardado",
    "farelo",
    "farinha",
    "farofa",
    "farpa",
    "fartura",
    "fatia",
    "fator",
    "favorita",
    "faxina",
    "fazenda",
    "fechado",
    "feijoada",
    "feirante",
    "felino",
    "feminino",
    "fenda",
    "feno",
    "fera",
    "feriado",
    "ferrugem",
    "ferver",
    "festejar",
    "fetal",
    "feudal",
    "fiapo",
    "fibrose",
    "ficar",
    "ficheiro",
    "figurado",
    "fileira",
    "filho",
    "filme",
    "filtrar",
    "firmeza",
    "fisgada",
    "fissura",
    "fita",
    "fivela",
    "fixador",
    "fixo",
    "flacidez",
    "flamingo",
    "flanela",
    "flechada",
    "flora",
    "flutuar",
    "fluxo",
    "focal",
    "focinho",
    "fofocar",
    "fogo",
    "foguete",
    "foice",
    "folgado",
    "folheto",
    "forjar",
    "formiga",
    "forno",
    "forte",
    "fosco",
    "fossa",
    "fragata",
    "fralda",
    "frango",
    "frasco",
    "fraterno",
    "freira",
    "frente",
    "fretar",
    "frieza",
    "friso",
    "fritura",
    "fronha",
    "frustrar",
    "fruteira",
    "fugir",
    "fulano",
    "fuligem",
    "fundar",
    "fungo",
    "funil",
    "furador",
    "furioso",
    "futebol",
    "gabarito",
    "gabinete",
    "gado",
    "gaiato",
    "gaiola",
    "gaivota",
    "galega",
    "galho",
    "galinha",
    "galocha",
    "ganhar",
    "garagem",
    "garfo",
    "gargalo",
    "garimpo",
    "garoupa",
    "garrafa",
    "gasoduto",
    "gasto",
    "gata",
    "gatilho",
    "gaveta",
    "gazela",
    "gelado",
    "geleia",
    "gelo",
    "gemada",
    "gemer",
    "gemido",
    "generoso",
    "gengiva",
    "genial",
    "genoma",
    "genro",
    "geologia",
    "gerador",
    "germinar",
    "gesso",
    "gestor",
    "ginasta",
    "gincana",
    "gingado",
    "girafa",
    "girino",
    "glacial",
    "glicose",
    "global",
    "glorioso",
    "goela",
    "goiaba",
    "golfe",
    "golpear",
    "gordura",
    "gorjeta",
    "gorro",
    "gostoso",
    "goteira",
    "governar",
    "gracejo",
    "gradual",
    "grafite",
    "gralha",
    "grampo",
    "granada",
    "gratuito",
    "graveto",
    "graxa",
    "grego",
    "grelhar",
    "greve",
    "grilo",
    "grisalho",
    "gritaria",
    "grosso",
    "grotesco",
    "grudado",
    "grunhido",
    "gruta",
    "guache",
    "guarani",
    "guaxinim",
    "guerrear",
    "guiar",
    "guincho",
    "guisado",
    "gula",
    "guloso",
    "guru",
    "habitar",
    "harmonia",
    "haste",
    "haver",
    "hectare",
    "herdar",
    "heresia",
    "hesitar",
    "hiato",
    "hibernar",
    "hidratar",
    "hiena",
    "hino",
    "hipismo",
    "hipnose",
    "hipoteca",
    "hoje",
    "holofote",
    "homem",
    "honesto",
    "honrado",
    "hormonal",
    "hospedar",
    "humorado",
    "iate",
    "ideia",
    "idoso",
    "ignorado",
    "igreja",
    "iguana",
    "ileso",
    "ilha",
    "iludido",
    "iluminar",
    "ilustrar",
    "imagem",
    "imediato",
    "imenso",
    "imersivo",
    "iminente",
    "imitador",
    "imortal",
    "impacto",
    "impedir",
    "implante",
    "impor",
    "imprensa",
    "impune",
    "imunizar",
    "inalador",
    "inapto",
    "inativo",
    "incenso",
    "inchar",
    "incidir",
    "incluir",
    "incolor",
    "indeciso",
    "indireto",
    "indutor",
    "ineficaz",
    "inerente",
    "infantil",
    "infestar",
    "infinito",
    "inflamar",
    "informal",
    "infrator",
    "ingerir",
    "inibido",
    "inicial",
    "inimigo",
    "injetar",
    "inocente",
    "inodoro",
    "inovador",
    "inox",
    "inquieto",
    "inscrito",
    "inseto",
    "insistir",
    "inspetor",
    "instalar",
    "insulto",
    "intacto",
    "integral",
    "intimar",
    "intocado",
    "intriga",
    "invasor",
    "inverno",
    "invicto",
    "invocar",
    "iogurte",
    "iraniano",
    "ironizar",
    "irreal",
    "irritado",
    "isca",
    "isento",
    "isolado",
    "isqueiro",
    "italiano",
    "janeiro",
    "jangada",
    "janta",
    "jararaca",
    "jardim",
    "jarro",
    "jasmim",
    "jato",
    "javali",
    "jazida",
    "jejum",
    "joaninha",
    "joelhada",
    "jogador",
    "joia",
    "jornal",
    "jorrar",
    "jovem",
    "juba",
    "judeu",
    "judoca",
    "juiz",
    "julgador",
    "julho",
    "jurado",
    "jurista",
    "juro",
    "justa",
    "labareda",
    "laboral",
    "lacre",
    "lactante",
    "ladrilho",
    "lagarta",
    "lagoa",
    "laje",
    "lamber",
    "lamentar",
    "laminar",
    "lampejo",
    "lanche",
    "lapidar",
    "lapso",
    "laranja",
    "lareira",
    "largura",
    "lasanha",
    "lastro",
    "lateral",
    "latido",
    "lavanda",
    "lavoura",
    "lavrador",
    "laxante",
    "lazer",
    "lealdade",
    "lebre",
    "legado",
    "legendar",
    "legista",
    "leigo",
    "leiloar",
    "leitura",
    "lembrete",
    "leme",
    "lenhador",
    "lentilha",
    "leoa",
    "lesma",
    "leste",
    "letivo",
    "letreiro",
    "levar",
    "leveza",
    "levitar",
    "liberal",
    "libido",
    "liderar",
    "ligar",
    "ligeiro",
    "limitar",
    "limoeiro",
    "limpador",
    "linda",
    "linear",
    "linhagem",
    "liquidez",
    "listagem",
    "lisura",
    "litoral",
    "livro",
    "lixa",
    "lixeira",
    "locador",
    "locutor",
    "lojista",
    "lombo",
    "lona",
    "longe",
    "lontra",
    "lorde",
    "lotado",
    "loteria",
    "loucura",
    "lousa",
    "louvar",
    "luar",
    "lucidez",
    "lucro",
    "luneta",
    "lustre",
    "lutador",
    "luva",
    "macaco",
    "macete",
    "machado",
    "macio",
    "madeira",
    "madrinha",
    "magnata",
    "magreza",
    "maior",
    "mais",
    "malandro",
    "malha",
    "malote",
    "maluco",
    "mamilo",
    "mamoeiro",
    "mamute",
    "manada",
    "mancha",
    "mandato",
    "manequim",
    "manhoso",
    "manivela",
    "manobrar",
    "mansa",
    "manter",
    "manusear",
    "mapeado",
    "maquinar",
    "marcador",
    "maresia",
    "marfim",
    "margem",
    "marinho",
    "marmita",
    "maroto",
    "marquise",
    "marreco",
    "martelo",
    "marujo",
    "mascote",
    "masmorra",
    "massagem",
    "mastigar",
    "matagal",
    "materno",
    "matinal",
    "matutar",
    "maxilar",
    "medalha",
    "medida",
    "medusa",
    "megafone",
    "meiga",
    "melancia",
    "melhor",
    "membro",
    "memorial",
    "menino",
    "menos",
    "mensagem",
    "mental",
    "merecer",
    "mergulho",
    "mesada",
    "mesclar",
    "mesmo",
    "mesquita",
    "mestre",
    "metade",
    "meteoro",
    "metragem",
    "mexer",
    "mexicano",
    "micro",
    "migalha",
    "migrar",
    "milagre",
    "milenar",
    "milhar",
    "mimado",
    "minerar",
    "minhoca",
    "ministro",
    "minoria",
    "miolo",
    "mirante",
    "mirtilo",
    "misturar",
    "mocidade",
    "moderno",
    "modular",
    "moeda",
    "moer",
    "moinho",
    "moita",
    "moldura",
    "moleza",
    "molho",
    "molinete",
    "molusco",
    "montanha",
    "moqueca",
    "morango",
    "morcego",
    "mordomo",
    "morena",
    "mosaico",
    "mosquete",
    "mostarda",
    "motel",
    "motim",
    "moto",
    "motriz",
    "muda",
    "muito",
    "mulata",
    "mulher",
    "multar",
    "mundial",
    "munido",
    "muralha",
    "murcho",
    "muscular",
    "museu",
    "musical",
    "nacional",
    "nadador",
    "naja",
    "namoro",
    "narina",
    "narrado",
    "nascer",
    "nativa",
    "natureza",
    "navalha",
    "navegar",
    "navio",
    "neblina",
    "nebuloso",
    "negativa",
    "negociar",
    "negrito",
    "nervoso",
    "neta",
    "neural",
    "nevasca",
    "nevoeiro",
    "ninar",
    "ninho",
    "nitidez",
    "nivelar",
    "nobreza",
    "noite",
    "noiva",
    "nomear",
    "nominal",
    "nordeste",
    "nortear",
    "notar",
    "noticiar",
    "noturno",
    "novelo",
    "novilho",
    "novo",
    "nublado",
    "nudez",
    "numeral",
    "nupcial",
    "nutrir",
    "nuvem",
    "obcecado",
    "obedecer",
    "objetivo",
    "obrigado",
    "obscuro",
    "obstetra",
    "obter",
    "obturar",
    "ocidente",
    "ocioso",
    "ocorrer",
    "oculista",
    "ocupado",
    "ofegante",
    "ofensiva",
    "oferenda",
    "oficina",
    "ofuscado",
    "ogiva",
    "olaria",
    "oleoso",
    "olhar",
    "oliveira",
    "ombro",
    "omelete",
    "omisso",
    "omitir",
    "ondulado",
    "oneroso",
    "ontem",
    "opcional",
    "operador",
    "oponente",
    "oportuno",
    "oposto",
    "orar",
    "orbitar",
    "ordem",
    "ordinal",
    "orfanato",
    "orgasmo",
    "orgulho",
    "oriental",
    "origem",
    "oriundo",
    "orla",
    "ortodoxo",
    "orvalho",
    "oscilar",
    "ossada",
    "osso",
    "ostentar",
    "otimismo",
    "ousadia",
    "outono",
    "outubro",
    "ouvido",
    "ovelha",
    "ovular",
    "oxidar",
    "oxigenar",
    "pacato",
    "paciente",
    "pacote",
    "pactuar",
    "padaria",
    "padrinho",
    "pagar",
    "pagode",
    "painel",
    "pairar",
    "paisagem",
    "palavra",
    "palestra",
    "palheta",
    "palito",
    "palmada",
    "palpitar",
    "pancada",
    "panela",
    "panfleto",
    "panqueca",
    "pantanal",
    "papagaio",
    "papelada",
    "papiro",
    "parafina",
    "parcial",
    "pardal",
    "parede",
    "partida",
    "pasmo",
    "passado",
    "pastel",
    "patamar",
    "patente",
    "patinar",
    "patrono",
    "paulada",
    "pausar",
    "peculiar",
    "pedalar",
    "pedestre",
    "pediatra",
    "pedra",
    "pegada",
    "peitoral",
    "peixe",
    "pele",
    "pelicano",
    "penca",
    "pendurar",
    "peneira",
    "penhasco",
    "pensador",
    "pente",
    "perceber",
    "perfeito",
    "pergunta",
    "perito",
    "permitir",
    "perna",
    "perplexo",
    "persiana",
    "pertence",
    "peruca",
    "pescado",
    "pesquisa",
    "pessoa",
    "petiscar",
    "piada",
    "picado",
    "piedade",
    "pigmento",
    "pilastra",
    "pilhado",
    "pilotar",
    "pimenta",
    "pincel",
    "pinguim",
    "pinha",
    "pinote",
    "pintar",
    "pioneiro",
    "pipoca",
    "piquete",
    "piranha",
    "pires",
    "pirueta",
    "piscar",
    "pistola",
    "pitanga",
    "pivete",
    "planta",
    "plaqueta",
    "platina",
    "plebeu",
    "plumagem",
    "pluvial",
    "pneu",
    "poda",
    "poeira",
    "poetisa",
    "polegada",
    "policiar",
    "poluente",
    "polvilho",
    "pomar",
    "pomba",
    "ponderar",
    "pontaria",
    "populoso",
    "porta",
    "possuir",
    "postal",
    "pote",
    "poupar",
    "pouso",
    "povoar",
    "praia",
    "prancha",
    "prato",
    "praxe",
    "prece",
    "predador",
    "prefeito",
    "premiar",
    "prensar",
    "preparar",
    "presilha",
    "pretexto",
    "prevenir",
    "prezar",
    "primata",
    "princesa",
    "prisma",
    "privado",
    "processo",
    "produto",
    "profeta",
    "proibido",
    "projeto",
    "prometer",
    "propagar",
    "prosa",
    "protetor",
    "provador",
    "publicar",
    "pudim",
    "pular",
    "pulmonar",
    "pulseira",
    "punhal",
    "punir",
    "pupilo",
    "pureza",
    "puxador",
    "quadra",
    "quantia",
    "quarto",
    "quase",
    "quebrar",
    "queda",
    "queijo",
    "quente",
    "querido",
    "quimono",
    "quina",
    "quiosque",
    "rabanada",
    "rabisco",
    "rachar",
    "racionar",
    "radial",
    "raiar",
    "rainha",
    "raio",
    "raiva",
    "rajada",
    "ralado",
    "ramal",
    "ranger",
    "ranhura",
    "rapadura",
    "rapel",
    "rapidez",
    "raposa",
    "raquete",
    "raridade",
    "rasante",
    "rascunho",
    "rasgar",
    "raspador",
    "rasteira",
    "rasurar",
    "ratazana",
    "ratoeira",
    "realeza",
    "reanimar",
    "reaver",
    "rebaixar",
    "rebelde",
    "rebolar",
    "recado",
    "recente",
    "recheio",
    "recibo",
    "recordar",
    "recrutar",
    "recuar",
    "rede",
    "redimir",
    "redonda",
    "reduzida",
    "reenvio",
    "refinar",
    "refletir",
    "refogar",
    "refresco",
    "refugiar",
    "regalia",
    "regime",
    "regra",
    "reinado",
    "reitor",
    "rejeitar",
    "relativo",
    "remador",
    "remendo",
    "remorso",
    "renovado",
    "reparo",
    "repelir",
    "repleto",
    "repolho",
    "represa",
    "repudiar",
    "requerer",
    "resenha",
    "resfriar",
    "resgatar",
    "residir",
    "resolver",
    "respeito",
    "ressaca",
    "restante",
    "resumir",
    "retalho",
    "reter",
    "retirar",
    "retomada",
    "retratar",
    "revelar",
    "revisor",
    "revolta",
    "riacho",
    "rica",
    "rigidez",
    "rigoroso",
    "rimar",
    "ringue",
    "risada",
    "risco",
    "risonho",
    "robalo",
    "rochedo",
    "rodada",
    "rodeio",
    "rodovia",
    "roedor",
    "roleta",
    "romano",
    "roncar",
    "rosado",
    "roseira",
    "rosto",
    "rota",
    "roteiro",
    "rotina",
    "rotular",
    "rouco",
    "roupa",
    "roxo",
    "rubro",
    "rugido",
    "rugoso",
    "ruivo",
    "rumo",
    "rupestre",
    "russo",
    "sabor",
    "saciar",
    "sacola",
    "sacudir",
    "sadio",
    "safira",
    "saga",
    "sagrada",
    "saibro",
    "salada",
    "saleiro",
    "salgado",
    "saliva",
    "salpicar",
    "salsicha",
    "saltar",
    "salvador",
    "sambar",
    "samurai",
    "sanar",
    "sanfona",
    "sangue",
    "sanidade",
    "sapato",
    "sarda",
    "sargento",
    "sarjeta",
    "saturar",
    "saudade",
    "saxofone",
    "sazonal",
    "secar",
    "secular",
    "seda",
    "sedento",
    "sediado",
    "sedoso",
    "sedutor",
    "segmento",
    "segredo",
    "segundo",
    "seiva",
    "seleto",
    "selvagem",
    "semanal",
    "semente",
    "senador",
    "senhor",
    "sensual",
    "sentado",
    "separado",
    "sereia",
    "seringa",
    "serra",
    "servo",
    "setembro",
    "setor",
    "sigilo",
    "silhueta",
    "silicone",
    "simetria",
    "simpatia",
    "simular",
    "sinal",
    "sincero",
    "singular",
    "sinopse",
    "sintonia",
    "sirene",
    "siri",
    "situado",
    "soberano",
    "sobra",
    "socorro",
    "sogro",
    "soja",
    "solda",
    "soletrar",
    "solteiro",
    "sombrio",
    "sonata",
    "sondar",
    "sonegar",
    "sonhador",
    "sono",
    "soprano",
    "soquete",
    "sorrir",
    "sorteio",
    "sossego",
    "sotaque",
    "soterrar",
    "sovado",
    "sozinho",
    "suavizar",
    "subida",
    "submerso",
    "subsolo",
    "subtrair",
    "sucata",
    "sucesso",
    "suco",
    "sudeste",
    "sufixo",
    "sugador",
    "sugerir",
    "sujeito",
    "sulfato",
    "sumir",
    "suor",
    "superior",
    "suplicar",
    "suposto",
    "suprimir",
    "surdina",
    "surfista",
    "surpresa",
    "surreal",
    "surtir",
    "suspiro",
    "sustento",
    "tabela",
    "tablete",
    "tabuada",
    "tacho",
    "tagarela",
    "talher",
    "talo",
    "talvez",
    "tamanho",
    "tamborim",
    "tampa",
    "tangente",
    "tanto",
    "tapar",
    "tapioca",
    "tardio",
    "tarefa",
    "tarja",
    "tarraxa",
    "tatuagem",
    "taurino",
    "taxativo",
    "taxista",
    "teatral",
    "tecer",
    "tecido",
    "teclado",
    "tedioso",
    "teia",
    "teimar",
    "telefone",
    "telhado",
    "tempero",
    "tenente",
    "tensor",
    "tentar",
    "termal",
    "terno",
    "terreno",
    "tese",
    "tesoura",
    "testado",
    "teto",
    "textura",
    "texugo",
    "tiara",
    "tigela",
    "tijolo",
    "timbrar",
    "timidez",
    "tingido",
    "tinteiro",
    "tiragem",
    "titular",
    "toalha",
    "tocha",
    "tolerar",
    "tolice",
    "tomada",
    "tomilho",
    "tonel",
    "tontura",
    "topete",
    "tora",
    "torcido",
    "torneio",
    "torque",
    "torrada",
    "torto",
    "tostar",
    "touca",
    "toupeira",
    "toxina",
    "trabalho",
    "tracejar",
    "tradutor",
    "trafegar",
    "trajeto",
    "trama",
    "trancar",
    "trapo",
    "traseiro",
    "tratador",
    "travar",
    "treino",
    "tremer",
    "trepidar",
    "trevo",
    "triagem",
    "tribo",
    "triciclo",
    "tridente",
    "trilogia",
    "trindade",
    "triplo",
    "triturar",
    "triunfal",
    "trocar",
    "trombeta",
    "trova",
    "trunfo",
    "truque",
    "tubular",
    "tucano",
    "tudo",
    "tulipa",
    "tupi",
    "turbo",
    "turma",
    "turquesa",
    "tutelar",
    "tutorial",
    "uivar",
    "umbigo",
    "unha",
    "unidade",
    "uniforme",
    "urologia",
    "urso",
    "urtiga",
    "urubu",
    "usado",
    "usina",
    "usufruir",
    "vacina",
    "vadiar",
    "vagaroso",
    "vaidoso",
    "vala",
    "valente",
    "validade",
    "valores",
    "vantagem",
    "vaqueiro",
    "varanda",
    "vareta",
    "varrer",
    "vascular",
    "vasilha",
    "vassoura",
    "vazar",
    "vazio",
    "veado",
    "vedar",
    "vegetar",
    "veicular",
    "veleiro",
    "velhice",
    "veludo",
    "vencedor",
    "vendaval",
    "venerar",
    "ventre",
    "verbal",
    "verdade",
    "vereador",
    "vergonha",
    "vermelho",
    "verniz",
    "versar",
    "vertente",
    "vespa",
    "vestido",
    "vetorial",
    "viaduto",
    "viagem",
    "viajar",
    "viatura",
    "vibrador",
    "videira",
    "vidraria",
    "viela",
    "viga",
    "vigente",
    "vigiar",
    "vigorar",
    "vilarejo",
    "vinco",
    "vinheta",
    "vinil",
    "violeta",
    "virada",
    "virtude",
    "visitar",
    "visto",
    "vitral",
    "viveiro",
    "vizinho",
    "voador",
    "voar",
    "vogal",
    "volante",
    "voleibol",
    "voltagem",
    "volumoso",
    "vontade",
    "vulto",
    "vuvuzela",
    "xadrez",
    "xarope",
    "xeque",
    "xeretar",
    "xerife",
    "xingar",
    "zangado",
    "zarpar",
    "zebu",
    "zelador",
    "zombar",
    "zoologia",
    "zumbido"
]

      };
    };
  }
}, {package:"bip39",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\portuguese.json",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\english.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\key-tree\node_modules\bip39\src\wordlists\english.json
      return function (require, module, exports) {
module.exports=[
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
]

      };
    };
  }
}, {package:"bip39",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\english.json",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\french.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\key-tree\node_modules\bip39\src\wordlists\french.json
      return function (require, module, exports) {
module.exports=[
    "abaisser",
    "abandon",
    "abdiquer",
    "abeille",
    "abolir",
    "aborder",
    "aboutir",
    "aboyer",
    "abrasif",
    "abreuver",
    "abriter",
    "abroger",
    "abrupt",
    "absence",
    "absolu",
    "absurde",
    "abusif",
    "abyssal",
    "académie",
    "acajou",
    "acarien",
    "accabler",
    "accepter",
    "acclamer",
    "accolade",
    "accroche",
    "accuser",
    "acerbe",
    "achat",
    "acheter",
    "aciduler",
    "acier",
    "acompte",
    "acquérir",
    "acronyme",
    "acteur",
    "actif",
    "actuel",
    "adepte",
    "adéquat",
    "adhésif",
    "adjectif",
    "adjuger",
    "admettre",
    "admirer",
    "adopter",
    "adorer",
    "adoucir",
    "adresse",
    "adroit",
    "adulte",
    "adverbe",
    "aérer",
    "aéronef",
    "affaire",
    "affecter",
    "affiche",
    "affreux",
    "affubler",
    "agacer",
    "agencer",
    "agile",
    "agiter",
    "agrafer",
    "agréable",
    "agrume",
    "aider",
    "aiguille",
    "ailier",
    "aimable",
    "aisance",
    "ajouter",
    "ajuster",
    "alarmer",
    "alchimie",
    "alerte",
    "algèbre",
    "algue",
    "aliéner",
    "aliment",
    "alléger",
    "alliage",
    "allouer",
    "allumer",
    "alourdir",
    "alpaga",
    "altesse",
    "alvéole",
    "amateur",
    "ambigu",
    "ambre",
    "aménager",
    "amertume",
    "amidon",
    "amiral",
    "amorcer",
    "amour",
    "amovible",
    "amphibie",
    "ampleur",
    "amusant",
    "analyse",
    "anaphore",
    "anarchie",
    "anatomie",
    "ancien",
    "anéantir",
    "angle",
    "angoisse",
    "anguleux",
    "animal",
    "annexer",
    "annonce",
    "annuel",
    "anodin",
    "anomalie",
    "anonyme",
    "anormal",
    "antenne",
    "antidote",
    "anxieux",
    "apaiser",
    "apéritif",
    "aplanir",
    "apologie",
    "appareil",
    "appeler",
    "apporter",
    "appuyer",
    "aquarium",
    "aqueduc",
    "arbitre",
    "arbuste",
    "ardeur",
    "ardoise",
    "argent",
    "arlequin",
    "armature",
    "armement",
    "armoire",
    "armure",
    "arpenter",
    "arracher",
    "arriver",
    "arroser",
    "arsenic",
    "artériel",
    "article",
    "aspect",
    "asphalte",
    "aspirer",
    "assaut",
    "asservir",
    "assiette",
    "associer",
    "assurer",
    "asticot",
    "astre",
    "astuce",
    "atelier",
    "atome",
    "atrium",
    "atroce",
    "attaque",
    "attentif",
    "attirer",
    "attraper",
    "aubaine",
    "auberge",
    "audace",
    "audible",
    "augurer",
    "aurore",
    "automne",
    "autruche",
    "avaler",
    "avancer",
    "avarice",
    "avenir",
    "averse",
    "aveugle",
    "aviateur",
    "avide",
    "avion",
    "aviser",
    "avoine",
    "avouer",
    "avril",
    "axial",
    "axiome",
    "badge",
    "bafouer",
    "bagage",
    "baguette",
    "baignade",
    "balancer",
    "balcon",
    "baleine",
    "balisage",
    "bambin",
    "bancaire",
    "bandage",
    "banlieue",
    "bannière",
    "banquier",
    "barbier",
    "baril",
    "baron",
    "barque",
    "barrage",
    "bassin",
    "bastion",
    "bataille",
    "bateau",
    "batterie",
    "baudrier",
    "bavarder",
    "belette",
    "bélier",
    "belote",
    "bénéfice",
    "berceau",
    "berger",
    "berline",
    "bermuda",
    "besace",
    "besogne",
    "bétail",
    "beurre",
    "biberon",
    "bicycle",
    "bidule",
    "bijou",
    "bilan",
    "bilingue",
    "billard",
    "binaire",
    "biologie",
    "biopsie",
    "biotype",
    "biscuit",
    "bison",
    "bistouri",
    "bitume",
    "bizarre",
    "blafard",
    "blague",
    "blanchir",
    "blessant",
    "blinder",
    "blond",
    "bloquer",
    "blouson",
    "bobard",
    "bobine",
    "boire",
    "boiser",
    "bolide",
    "bonbon",
    "bondir",
    "bonheur",
    "bonifier",
    "bonus",
    "bordure",
    "borne",
    "botte",
    "boucle",
    "boueux",
    "bougie",
    "boulon",
    "bouquin",
    "bourse",
    "boussole",
    "boutique",
    "boxeur",
    "branche",
    "brasier",
    "brave",
    "brebis",
    "brèche",
    "breuvage",
    "bricoler",
    "brigade",
    "brillant",
    "brioche",
    "brique",
    "brochure",
    "broder",
    "bronzer",
    "brousse",
    "broyeur",
    "brume",
    "brusque",
    "brutal",
    "bruyant",
    "buffle",
    "buisson",
    "bulletin",
    "bureau",
    "burin",
    "bustier",
    "butiner",
    "butoir",
    "buvable",
    "buvette",
    "cabanon",
    "cabine",
    "cachette",
    "cadeau",
    "cadre",
    "caféine",
    "caillou",
    "caisson",
    "calculer",
    "calepin",
    "calibre",
    "calmer",
    "calomnie",
    "calvaire",
    "camarade",
    "caméra",
    "camion",
    "campagne",
    "canal",
    "caneton",
    "canon",
    "cantine",
    "canular",
    "capable",
    "caporal",
    "caprice",
    "capsule",
    "capter",
    "capuche",
    "carabine",
    "carbone",
    "caresser",
    "caribou",
    "carnage",
    "carotte",
    "carreau",
    "carton",
    "cascade",
    "casier",
    "casque",
    "cassure",
    "causer",
    "caution",
    "cavalier",
    "caverne",
    "caviar",
    "cédille",
    "ceinture",
    "céleste",
    "cellule",
    "cendrier",
    "censurer",
    "central",
    "cercle",
    "cérébral",
    "cerise",
    "cerner",
    "cerveau",
    "cesser",
    "chagrin",
    "chaise",
    "chaleur",
    "chambre",
    "chance",
    "chapitre",
    "charbon",
    "chasseur",
    "chaton",
    "chausson",
    "chavirer",
    "chemise",
    "chenille",
    "chéquier",
    "chercher",
    "cheval",
    "chien",
    "chiffre",
    "chignon",
    "chimère",
    "chiot",
    "chlorure",
    "chocolat",
    "choisir",
    "chose",
    "chouette",
    "chrome",
    "chute",
    "cigare",
    "cigogne",
    "cimenter",
    "cinéma",
    "cintrer",
    "circuler",
    "cirer",
    "cirque",
    "citerne",
    "citoyen",
    "citron",
    "civil",
    "clairon",
    "clameur",
    "claquer",
    "classe",
    "clavier",
    "client",
    "cligner",
    "climat",
    "clivage",
    "cloche",
    "clonage",
    "cloporte",
    "cobalt",
    "cobra",
    "cocasse",
    "cocotier",
    "coder",
    "codifier",
    "coffre",
    "cogner",
    "cohésion",
    "coiffer",
    "coincer",
    "colère",
    "colibri",
    "colline",
    "colmater",
    "colonel",
    "combat",
    "comédie",
    "commande",
    "compact",
    "concert",
    "conduire",
    "confier",
    "congeler",
    "connoter",
    "consonne",
    "contact",
    "convexe",
    "copain",
    "copie",
    "corail",
    "corbeau",
    "cordage",
    "corniche",
    "corpus",
    "correct",
    "cortège",
    "cosmique",
    "costume",
    "coton",
    "coude",
    "coupure",
    "courage",
    "couteau",
    "couvrir",
    "coyote",
    "crabe",
    "crainte",
    "cravate",
    "crayon",
    "créature",
    "créditer",
    "crémeux",
    "creuser",
    "crevette",
    "cribler",
    "crier",
    "cristal",
    "critère",
    "croire",
    "croquer",
    "crotale",
    "crucial",
    "cruel",
    "crypter",
    "cubique",
    "cueillir",
    "cuillère",
    "cuisine",
    "cuivre",
    "culminer",
    "cultiver",
    "cumuler",
    "cupide",
    "curatif",
    "curseur",
    "cyanure",
    "cycle",
    "cylindre",
    "cynique",
    "daigner",
    "damier",
    "danger",
    "danseur",
    "dauphin",
    "débattre",
    "débiter",
    "déborder",
    "débrider",
    "débutant",
    "décaler",
    "décembre",
    "déchirer",
    "décider",
    "déclarer",
    "décorer",
    "décrire",
    "décupler",
    "dédale",
    "déductif",
    "déesse",
    "défensif",
    "défiler",
    "défrayer",
    "dégager",
    "dégivrer",
    "déglutir",
    "dégrafer",
    "déjeuner",
    "délice",
    "déloger",
    "demander",
    "demeurer",
    "démolir",
    "dénicher",
    "dénouer",
    "dentelle",
    "dénuder",
    "départ",
    "dépenser",
    "déphaser",
    "déplacer",
    "déposer",
    "déranger",
    "dérober",
    "désastre",
    "descente",
    "désert",
    "désigner",
    "désobéir",
    "dessiner",
    "destrier",
    "détacher",
    "détester",
    "détourer",
    "détresse",
    "devancer",
    "devenir",
    "deviner",
    "devoir",
    "diable",
    "dialogue",
    "diamant",
    "dicter",
    "différer",
    "digérer",
    "digital",
    "digne",
    "diluer",
    "dimanche",
    "diminuer",
    "dioxyde",
    "directif",
    "diriger",
    "discuter",
    "disposer",
    "dissiper",
    "distance",
    "divertir",
    "diviser",
    "docile",
    "docteur",
    "dogme",
    "doigt",
    "domaine",
    "domicile",
    "dompter",
    "donateur",
    "donjon",
    "donner",
    "dopamine",
    "dortoir",
    "dorure",
    "dosage",
    "doseur",
    "dossier",
    "dotation",
    "douanier",
    "double",
    "douceur",
    "douter",
    "doyen",
    "dragon",
    "draper",
    "dresser",
    "dribbler",
    "droiture",
    "duperie",
    "duplexe",
    "durable",
    "durcir",
    "dynastie",
    "éblouir",
    "écarter",
    "écharpe",
    "échelle",
    "éclairer",
    "éclipse",
    "éclore",
    "écluse",
    "école",
    "économie",
    "écorce",
    "écouter",
    "écraser",
    "écrémer",
    "écrivain",
    "écrou",
    "écume",
    "écureuil",
    "édifier",
    "éduquer",
    "effacer",
    "effectif",
    "effigie",
    "effort",
    "effrayer",
    "effusion",
    "égaliser",
    "égarer",
    "éjecter",
    "élaborer",
    "élargir",
    "électron",
    "élégant",
    "éléphant",
    "élève",
    "éligible",
    "élitisme",
    "éloge",
    "élucider",
    "éluder",
    "emballer",
    "embellir",
    "embryon",
    "émeraude",
    "émission",
    "emmener",
    "émotion",
    "émouvoir",
    "empereur",
    "employer",
    "emporter",
    "emprise",
    "émulsion",
    "encadrer",
    "enchère",
    "enclave",
    "encoche",
    "endiguer",
    "endosser",
    "endroit",
    "enduire",
    "énergie",
    "enfance",
    "enfermer",
    "enfouir",
    "engager",
    "engin",
    "englober",
    "énigme",
    "enjamber",
    "enjeu",
    "enlever",
    "ennemi",
    "ennuyeux",
    "enrichir",
    "enrobage",
    "enseigne",
    "entasser",
    "entendre",
    "entier",
    "entourer",
    "entraver",
    "énumérer",
    "envahir",
    "enviable",
    "envoyer",
    "enzyme",
    "éolien",
    "épaissir",
    "épargne",
    "épatant",
    "épaule",
    "épicerie",
    "épidémie",
    "épier",
    "épilogue",
    "épine",
    "épisode",
    "épitaphe",
    "époque",
    "épreuve",
    "éprouver",
    "épuisant",
    "équerre",
    "équipe",
    "ériger",
    "érosion",
    "erreur",
    "éruption",
    "escalier",
    "espadon",
    "espèce",
    "espiègle",
    "espoir",
    "esprit",
    "esquiver",
    "essayer",
    "essence",
    "essieu",
    "essorer",
    "estime",
    "estomac",
    "estrade",
    "étagère",
    "étaler",
    "étanche",
    "étatique",
    "éteindre",
    "étendoir",
    "éternel",
    "éthanol",
    "éthique",
    "ethnie",
    "étirer",
    "étoffer",
    "étoile",
    "étonnant",
    "étourdir",
    "étrange",
    "étroit",
    "étude",
    "euphorie",
    "évaluer",
    "évasion",
    "éventail",
    "évidence",
    "éviter",
    "évolutif",
    "évoquer",
    "exact",
    "exagérer",
    "exaucer",
    "exceller",
    "excitant",
    "exclusif",
    "excuse",
    "exécuter",
    "exemple",
    "exercer",
    "exhaler",
    "exhorter",
    "exigence",
    "exiler",
    "exister",
    "exotique",
    "expédier",
    "explorer",
    "exposer",
    "exprimer",
    "exquis",
    "extensif",
    "extraire",
    "exulter",
    "fable",
    "fabuleux",
    "facette",
    "facile",
    "facture",
    "faiblir",
    "falaise",
    "fameux",
    "famille",
    "farceur",
    "farfelu",
    "farine",
    "farouche",
    "fasciner",
    "fatal",
    "fatigue",
    "faucon",
    "fautif",
    "faveur",
    "favori",
    "fébrile",
    "féconder",
    "fédérer",
    "félin",
    "femme",
    "fémur",
    "fendoir",
    "féodal",
    "fermer",
    "féroce",
    "ferveur",
    "festival",
    "feuille",
    "feutre",
    "février",
    "fiasco",
    "ficeler",
    "fictif",
    "fidèle",
    "figure",
    "filature",
    "filetage",
    "filière",
    "filleul",
    "filmer",
    "filou",
    "filtrer",
    "financer",
    "finir",
    "fiole",
    "firme",
    "fissure",
    "fixer",
    "flairer",
    "flamme",
    "flasque",
    "flatteur",
    "fléau",
    "flèche",
    "fleur",
    "flexion",
    "flocon",
    "flore",
    "fluctuer",
    "fluide",
    "fluvial",
    "folie",
    "fonderie",
    "fongible",
    "fontaine",
    "forcer",
    "forgeron",
    "formuler",
    "fortune",
    "fossile",
    "foudre",
    "fougère",
    "fouiller",
    "foulure",
    "fourmi",
    "fragile",
    "fraise",
    "franchir",
    "frapper",
    "frayeur",
    "frégate",
    "freiner",
    "frelon",
    "frémir",
    "frénésie",
    "frère",
    "friable",
    "friction",
    "frisson",
    "frivole",
    "froid",
    "fromage",
    "frontal",
    "frotter",
    "fruit",
    "fugitif",
    "fuite",
    "fureur",
    "furieux",
    "furtif",
    "fusion",
    "futur",
    "gagner",
    "galaxie",
    "galerie",
    "gambader",
    "garantir",
    "gardien",
    "garnir",
    "garrigue",
    "gazelle",
    "gazon",
    "géant",
    "gélatine",
    "gélule",
    "gendarme",
    "général",
    "génie",
    "genou",
    "gentil",
    "géologie",
    "géomètre",
    "géranium",
    "germe",
    "gestuel",
    "geyser",
    "gibier",
    "gicler",
    "girafe",
    "givre",
    "glace",
    "glaive",
    "glisser",
    "globe",
    "gloire",
    "glorieux",
    "golfeur",
    "gomme",
    "gonfler",
    "gorge",
    "gorille",
    "goudron",
    "gouffre",
    "goulot",
    "goupille",
    "gourmand",
    "goutte",
    "graduel",
    "graffiti",
    "graine",
    "grand",
    "grappin",
    "gratuit",
    "gravir",
    "grenat",
    "griffure",
    "griller",
    "grimper",
    "grogner",
    "gronder",
    "grotte",
    "groupe",
    "gruger",
    "grutier",
    "gruyère",
    "guépard",
    "guerrier",
    "guide",
    "guimauve",
    "guitare",
    "gustatif",
    "gymnaste",
    "gyrostat",
    "habitude",
    "hachoir",
    "halte",
    "hameau",
    "hangar",
    "hanneton",
    "haricot",
    "harmonie",
    "harpon",
    "hasard",
    "hélium",
    "hématome",
    "herbe",
    "hérisson",
    "hermine",
    "héron",
    "hésiter",
    "heureux",
    "hiberner",
    "hibou",
    "hilarant",
    "histoire",
    "hiver",
    "homard",
    "hommage",
    "homogène",
    "honneur",
    "honorer",
    "honteux",
    "horde",
    "horizon",
    "horloge",
    "hormone",
    "horrible",
    "houleux",
    "housse",
    "hublot",
    "huileux",
    "humain",
    "humble",
    "humide",
    "humour",
    "hurler",
    "hydromel",
    "hygiène",
    "hymne",
    "hypnose",
    "idylle",
    "ignorer",
    "iguane",
    "illicite",
    "illusion",
    "image",
    "imbiber",
    "imiter",
    "immense",
    "immobile",
    "immuable",
    "impact",
    "impérial",
    "implorer",
    "imposer",
    "imprimer",
    "imputer",
    "incarner",
    "incendie",
    "incident",
    "incliner",
    "incolore",
    "indexer",
    "indice",
    "inductif",
    "inédit",
    "ineptie",
    "inexact",
    "infini",
    "infliger",
    "informer",
    "infusion",
    "ingérer",
    "inhaler",
    "inhiber",
    "injecter",
    "injure",
    "innocent",
    "inoculer",
    "inonder",
    "inscrire",
    "insecte",
    "insigne",
    "insolite",
    "inspirer",
    "instinct",
    "insulter",
    "intact",
    "intense",
    "intime",
    "intrigue",
    "intuitif",
    "inutile",
    "invasion",
    "inventer",
    "inviter",
    "invoquer",
    "ironique",
    "irradier",
    "irréel",
    "irriter",
    "isoler",
    "ivoire",
    "ivresse",
    "jaguar",
    "jaillir",
    "jambe",
    "janvier",
    "jardin",
    "jauger",
    "jaune",
    "javelot",
    "jetable",
    "jeton",
    "jeudi",
    "jeunesse",
    "joindre",
    "joncher",
    "jongler",
    "joueur",
    "jouissif",
    "journal",
    "jovial",
    "joyau",
    "joyeux",
    "jubiler",
    "jugement",
    "junior",
    "jupon",
    "juriste",
    "justice",
    "juteux",
    "juvénile",
    "kayak",
    "kimono",
    "kiosque",
    "label",
    "labial",
    "labourer",
    "lacérer",
    "lactose",
    "lagune",
    "laine",
    "laisser",
    "laitier",
    "lambeau",
    "lamelle",
    "lampe",
    "lanceur",
    "langage",
    "lanterne",
    "lapin",
    "largeur",
    "larme",
    "laurier",
    "lavabo",
    "lavoir",
    "lecture",
    "légal",
    "léger",
    "légume",
    "lessive",
    "lettre",
    "levier",
    "lexique",
    "lézard",
    "liasse",
    "libérer",
    "libre",
    "licence",
    "licorne",
    "liège",
    "lièvre",
    "ligature",
    "ligoter",
    "ligue",
    "limer",
    "limite",
    "limonade",
    "limpide",
    "linéaire",
    "lingot",
    "lionceau",
    "liquide",
    "lisière",
    "lister",
    "lithium",
    "litige",
    "littoral",
    "livreur",
    "logique",
    "lointain",
    "loisir",
    "lombric",
    "loterie",
    "louer",
    "lourd",
    "loutre",
    "louve",
    "loyal",
    "lubie",
    "lucide",
    "lucratif",
    "lueur",
    "lugubre",
    "luisant",
    "lumière",
    "lunaire",
    "lundi",
    "luron",
    "lutter",
    "luxueux",
    "machine",
    "magasin",
    "magenta",
    "magique",
    "maigre",
    "maillon",
    "maintien",
    "mairie",
    "maison",
    "majorer",
    "malaxer",
    "maléfice",
    "malheur",
    "malice",
    "mallette",
    "mammouth",
    "mandater",
    "maniable",
    "manquant",
    "manteau",
    "manuel",
    "marathon",
    "marbre",
    "marchand",
    "mardi",
    "maritime",
    "marqueur",
    "marron",
    "marteler",
    "mascotte",
    "massif",
    "matériel",
    "matière",
    "matraque",
    "maudire",
    "maussade",
    "mauve",
    "maximal",
    "méchant",
    "méconnu",
    "médaille",
    "médecin",
    "méditer",
    "méduse",
    "meilleur",
    "mélange",
    "mélodie",
    "membre",
    "mémoire",
    "menacer",
    "mener",
    "menhir",
    "mensonge",
    "mentor",
    "mercredi",
    "mérite",
    "merle",
    "messager",
    "mesure",
    "métal",
    "météore",
    "méthode",
    "métier",
    "meuble",
    "miauler",
    "microbe",
    "miette",
    "mignon",
    "migrer",
    "milieu",
    "million",
    "mimique",
    "mince",
    "minéral",
    "minimal",
    "minorer",
    "minute",
    "miracle",
    "miroiter",
    "missile",
    "mixte",
    "mobile",
    "moderne",
    "moelleux",
    "mondial",
    "moniteur",
    "monnaie",
    "monotone",
    "monstre",
    "montagne",
    "monument",
    "moqueur",
    "morceau",
    "morsure",
    "mortier",
    "moteur",
    "motif",
    "mouche",
    "moufle",
    "moulin",
    "mousson",
    "mouton",
    "mouvant",
    "multiple",
    "munition",
    "muraille",
    "murène",
    "murmure",
    "muscle",
    "muséum",
    "musicien",
    "mutation",
    "muter",
    "mutuel",
    "myriade",
    "myrtille",
    "mystère",
    "mythique",
    "nageur",
    "nappe",
    "narquois",
    "narrer",
    "natation",
    "nation",
    "nature",
    "naufrage",
    "nautique",
    "navire",
    "nébuleux",
    "nectar",
    "néfaste",
    "négation",
    "négliger",
    "négocier",
    "neige",
    "nerveux",
    "nettoyer",
    "neurone",
    "neutron",
    "neveu",
    "niche",
    "nickel",
    "nitrate",
    "niveau",
    "noble",
    "nocif",
    "nocturne",
    "noirceur",
    "noisette",
    "nomade",
    "nombreux",
    "nommer",
    "normatif",
    "notable",
    "notifier",
    "notoire",
    "nourrir",
    "nouveau",
    "novateur",
    "novembre",
    "novice",
    "nuage",
    "nuancer",
    "nuire",
    "nuisible",
    "numéro",
    "nuptial",
    "nuque",
    "nutritif",
    "obéir",
    "objectif",
    "obliger",
    "obscur",
    "observer",
    "obstacle",
    "obtenir",
    "obturer",
    "occasion",
    "occuper",
    "océan",
    "octobre",
    "octroyer",
    "octupler",
    "oculaire",
    "odeur",
    "odorant",
    "offenser",
    "officier",
    "offrir",
    "ogive",
    "oiseau",
    "oisillon",
    "olfactif",
    "olivier",
    "ombrage",
    "omettre",
    "onctueux",
    "onduler",
    "onéreux",
    "onirique",
    "opale",
    "opaque",
    "opérer",
    "opinion",
    "opportun",
    "opprimer",
    "opter",
    "optique",
    "orageux",
    "orange",
    "orbite",
    "ordonner",
    "oreille",
    "organe",
    "orgueil",
    "orifice",
    "ornement",
    "orque",
    "ortie",
    "osciller",
    "osmose",
    "ossature",
    "otarie",
    "ouragan",
    "ourson",
    "outil",
    "outrager",
    "ouvrage",
    "ovation",
    "oxyde",
    "oxygène",
    "ozone",
    "paisible",
    "palace",
    "palmarès",
    "palourde",
    "palper",
    "panache",
    "panda",
    "pangolin",
    "paniquer",
    "panneau",
    "panorama",
    "pantalon",
    "papaye",
    "papier",
    "papoter",
    "papyrus",
    "paradoxe",
    "parcelle",
    "paresse",
    "parfumer",
    "parler",
    "parole",
    "parrain",
    "parsemer",
    "partager",
    "parure",
    "parvenir",
    "passion",
    "pastèque",
    "paternel",
    "patience",
    "patron",
    "pavillon",
    "pavoiser",
    "payer",
    "paysage",
    "peigne",
    "peintre",
    "pelage",
    "pélican",
    "pelle",
    "pelouse",
    "peluche",
    "pendule",
    "pénétrer",
    "pénible",
    "pensif",
    "pénurie",
    "pépite",
    "péplum",
    "perdrix",
    "perforer",
    "période",
    "permuter",
    "perplexe",
    "persil",
    "perte",
    "peser",
    "pétale",
    "petit",
    "pétrir",
    "peuple",
    "pharaon",
    "phobie",
    "phoque",
    "photon",
    "phrase",
    "physique",
    "piano",
    "pictural",
    "pièce",
    "pierre",
    "pieuvre",
    "pilote",
    "pinceau",
    "pipette",
    "piquer",
    "pirogue",
    "piscine",
    "piston",
    "pivoter",
    "pixel",
    "pizza",
    "placard",
    "plafond",
    "plaisir",
    "planer",
    "plaque",
    "plastron",
    "plateau",
    "pleurer",
    "plexus",
    "pliage",
    "plomb",
    "plonger",
    "pluie",
    "plumage",
    "pochette",
    "poésie",
    "poète",
    "pointe",
    "poirier",
    "poisson",
    "poivre",
    "polaire",
    "policier",
    "pollen",
    "polygone",
    "pommade",
    "pompier",
    "ponctuel",
    "pondérer",
    "poney",
    "portique",
    "position",
    "posséder",
    "posture",
    "potager",
    "poteau",
    "potion",
    "pouce",
    "poulain",
    "poumon",
    "pourpre",
    "poussin",
    "pouvoir",
    "prairie",
    "pratique",
    "précieux",
    "prédire",
    "préfixe",
    "prélude",
    "prénom",
    "présence",
    "prétexte",
    "prévoir",
    "primitif",
    "prince",
    "prison",
    "priver",
    "problème",
    "procéder",
    "prodige",
    "profond",
    "progrès",
    "proie",
    "projeter",
    "prologue",
    "promener",
    "propre",
    "prospère",
    "protéger",
    "prouesse",
    "proverbe",
    "prudence",
    "pruneau",
    "psychose",
    "public",
    "puceron",
    "puiser",
    "pulpe",
    "pulsar",
    "punaise",
    "punitif",
    "pupitre",
    "purifier",
    "puzzle",
    "pyramide",
    "quasar",
    "querelle",
    "question",
    "quiétude",
    "quitter",
    "quotient",
    "racine",
    "raconter",
    "radieux",
    "ragondin",
    "raideur",
    "raisin",
    "ralentir",
    "rallonge",
    "ramasser",
    "rapide",
    "rasage",
    "ratisser",
    "ravager",
    "ravin",
    "rayonner",
    "réactif",
    "réagir",
    "réaliser",
    "réanimer",
    "recevoir",
    "réciter",
    "réclamer",
    "récolter",
    "recruter",
    "reculer",
    "recycler",
    "rédiger",
    "redouter",
    "refaire",
    "réflexe",
    "réformer",
    "refrain",
    "refuge",
    "régalien",
    "région",
    "réglage",
    "régulier",
    "réitérer",
    "rejeter",
    "rejouer",
    "relatif",
    "relever",
    "relief",
    "remarque",
    "remède",
    "remise",
    "remonter",
    "remplir",
    "remuer",
    "renard",
    "renfort",
    "renifler",
    "renoncer",
    "rentrer",
    "renvoi",
    "replier",
    "reporter",
    "reprise",
    "reptile",
    "requin",
    "réserve",
    "résineux",
    "résoudre",
    "respect",
    "rester",
    "résultat",
    "rétablir",
    "retenir",
    "réticule",
    "retomber",
    "retracer",
    "réunion",
    "réussir",
    "revanche",
    "revivre",
    "révolte",
    "révulsif",
    "richesse",
    "rideau",
    "rieur",
    "rigide",
    "rigoler",
    "rincer",
    "riposter",
    "risible",
    "risque",
    "rituel",
    "rival",
    "rivière",
    "rocheux",
    "romance",
    "rompre",
    "ronce",
    "rondin",
    "roseau",
    "rosier",
    "rotatif",
    "rotor",
    "rotule",
    "rouge",
    "rouille",
    "rouleau",
    "routine",
    "royaume",
    "ruban",
    "rubis",
    "ruche",
    "ruelle",
    "rugueux",
    "ruiner",
    "ruisseau",
    "ruser",
    "rustique",
    "rythme",
    "sabler",
    "saboter",
    "sabre",
    "sacoche",
    "safari",
    "sagesse",
    "saisir",
    "salade",
    "salive",
    "salon",
    "saluer",
    "samedi",
    "sanction",
    "sanglier",
    "sarcasme",
    "sardine",
    "saturer",
    "saugrenu",
    "saumon",
    "sauter",
    "sauvage",
    "savant",
    "savonner",
    "scalpel",
    "scandale",
    "scélérat",
    "scénario",
    "sceptre",
    "schéma",
    "science",
    "scinder",
    "score",
    "scrutin",
    "sculpter",
    "séance",
    "sécable",
    "sécher",
    "secouer",
    "sécréter",
    "sédatif",
    "séduire",
    "seigneur",
    "séjour",
    "sélectif",
    "semaine",
    "sembler",
    "semence",
    "séminal",
    "sénateur",
    "sensible",
    "sentence",
    "séparer",
    "séquence",
    "serein",
    "sergent",
    "sérieux",
    "serrure",
    "sérum",
    "service",
    "sésame",
    "sévir",
    "sevrage",
    "sextuple",
    "sidéral",
    "siècle",
    "siéger",
    "siffler",
    "sigle",
    "signal",
    "silence",
    "silicium",
    "simple",
    "sincère",
    "sinistre",
    "siphon",
    "sirop",
    "sismique",
    "situer",
    "skier",
    "social",
    "socle",
    "sodium",
    "soigneux",
    "soldat",
    "soleil",
    "solitude",
    "soluble",
    "sombre",
    "sommeil",
    "somnoler",
    "sonde",
    "songeur",
    "sonnette",
    "sonore",
    "sorcier",
    "sortir",
    "sosie",
    "sottise",
    "soucieux",
    "soudure",
    "souffle",
    "soulever",
    "soupape",
    "source",
    "soutirer",
    "souvenir",
    "spacieux",
    "spatial",
    "spécial",
    "sphère",
    "spiral",
    "stable",
    "station",
    "sternum",
    "stimulus",
    "stipuler",
    "strict",
    "studieux",
    "stupeur",
    "styliste",
    "sublime",
    "substrat",
    "subtil",
    "subvenir",
    "succès",
    "sucre",
    "suffixe",
    "suggérer",
    "suiveur",
    "sulfate",
    "superbe",
    "supplier",
    "surface",
    "suricate",
    "surmener",
    "surprise",
    "sursaut",
    "survie",
    "suspect",
    "syllabe",
    "symbole",
    "symétrie",
    "synapse",
    "syntaxe",
    "système",
    "tabac",
    "tablier",
    "tactile",
    "tailler",
    "talent",
    "talisman",
    "talonner",
    "tambour",
    "tamiser",
    "tangible",
    "tapis",
    "taquiner",
    "tarder",
    "tarif",
    "tartine",
    "tasse",
    "tatami",
    "tatouage",
    "taupe",
    "taureau",
    "taxer",
    "témoin",
    "temporel",
    "tenaille",
    "tendre",
    "teneur",
    "tenir",
    "tension",
    "terminer",
    "terne",
    "terrible",
    "tétine",
    "texte",
    "thème",
    "théorie",
    "thérapie",
    "thorax",
    "tibia",
    "tiède",
    "timide",
    "tirelire",
    "tiroir",
    "tissu",
    "titane",
    "titre",
    "tituber",
    "toboggan",
    "tolérant",
    "tomate",
    "tonique",
    "tonneau",
    "toponyme",
    "torche",
    "tordre",
    "tornade",
    "torpille",
    "torrent",
    "torse",
    "tortue",
    "totem",
    "toucher",
    "tournage",
    "tousser",
    "toxine",
    "traction",
    "trafic",
    "tragique",
    "trahir",
    "train",
    "trancher",
    "travail",
    "trèfle",
    "tremper",
    "trésor",
    "treuil",
    "triage",
    "tribunal",
    "tricoter",
    "trilogie",
    "triomphe",
    "tripler",
    "triturer",
    "trivial",
    "trombone",
    "tronc",
    "tropical",
    "troupeau",
    "tuile",
    "tulipe",
    "tumulte",
    "tunnel",
    "turbine",
    "tuteur",
    "tutoyer",
    "tuyau",
    "tympan",
    "typhon",
    "typique",
    "tyran",
    "ubuesque",
    "ultime",
    "ultrason",
    "unanime",
    "unifier",
    "union",
    "unique",
    "unitaire",
    "univers",
    "uranium",
    "urbain",
    "urticant",
    "usage",
    "usine",
    "usuel",
    "usure",
    "utile",
    "utopie",
    "vacarme",
    "vaccin",
    "vagabond",
    "vague",
    "vaillant",
    "vaincre",
    "vaisseau",
    "valable",
    "valise",
    "vallon",
    "valve",
    "vampire",
    "vanille",
    "vapeur",
    "varier",
    "vaseux",
    "vassal",
    "vaste",
    "vecteur",
    "vedette",
    "végétal",
    "véhicule",
    "veinard",
    "véloce",
    "vendredi",
    "vénérer",
    "venger",
    "venimeux",
    "ventouse",
    "verdure",
    "vérin",
    "vernir",
    "verrou",
    "verser",
    "vertu",
    "veston",
    "vétéran",
    "vétuste",
    "vexant",
    "vexer",
    "viaduc",
    "viande",
    "victoire",
    "vidange",
    "vidéo",
    "vignette",
    "vigueur",
    "vilain",
    "village",
    "vinaigre",
    "violon",
    "vipère",
    "virement",
    "virtuose",
    "virus",
    "visage",
    "viseur",
    "vision",
    "visqueux",
    "visuel",
    "vital",
    "vitesse",
    "viticole",
    "vitrine",
    "vivace",
    "vivipare",
    "vocation",
    "voguer",
    "voile",
    "voisin",
    "voiture",
    "volaille",
    "volcan",
    "voltiger",
    "volume",
    "vorace",
    "vortex",
    "voter",
    "vouloir",
    "voyage",
    "voyelle",
    "wagon",
    "xénon",
    "yacht",
    "zèbre",
    "zénith",
    "zeste",
    "zoologie"
]

      };
    };
  }
}, {package:"bip39",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\key-tree\\node_modules\\bip39\\src\\wordlists\\french.json",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-record\\node_modules\\multihashing-async\\src\\utils.js", {"_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-record\node_modules\multihashing-async\src\utils.js
      return function (require, module, exports) {
(function (process,Buffer){(function (){
'use strict'

exports.toCallback = (doWork) => {
  return function (input, callback) {
    let res
    try {
      res = doWork(input)
    } catch (err) {
      process.nextTick(callback, err)
      return
    }

    process.nextTick(callback, null, res)
  }
}

exports.toBuf = (doWork, other) => (input) => {
  let result = doWork(input, other)
  return Buffer.from(result, 'hex')
}

exports.fromString = (doWork, other) => (_input) => {
  const input = Buffer.isBuffer(_input) ? _input.toString() : _input
  return doWork(input, other)
}

exports.fromNumberTo32BitBuf = (doWork, other) => (input) => {
  let number = doWork(input, other)
  const bytes = new Array(4)

  for (let i = 0; i < 4; i++) {
    bytes[i] = number & 0xff
    number = number >> 8
  }

  return Buffer.from(bytes)
}

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-record\\node_modules\\multihashing-async\\src\\utils.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-record\\node_modules\\multihashing-async\\src\\blake.js", {"./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-record\\node_modules\\multihashing-async\\src\\utils.js","blakejs":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\blakejs\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-record\node_modules\multihashing-async\src\blake.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const blake = require('blakejs')

const toCallback = require('./utils').toCallback

const minB = 0xb201
const minS = 0xb241

const blake2b = {
  init: blake.blake2bInit,
  update: blake.blake2bUpdate,
  digest: blake.blake2bFinal
}

const blake2s = {
  init: blake.blake2sInit,
  update: blake.blake2sUpdate,
  digest: blake.blake2sFinal
}

const makeB2Hash = (size, hf) => toCallback((buf) => {
  const ctx = hf.init(size, null)
  hf.update(ctx, buf)
  return Buffer.from(hf.digest(ctx))
})

module.exports = (table) => {
  for (let i = 0; i < 64; i++) {
    table[minB + i] = makeB2Hash(i + 1, blake2b)
  }
  for (let i = 0; i < 32; i++) {
    table[minS + i] = makeB2Hash(i + 1, blake2s)
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-record\\node_modules\\multihashing-async\\src\\blake.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-record\\node_modules\\multihashing-async\\src\\crypto-sha1-2-browser.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","nodeify":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\nodeify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-record\node_modules\multihashing-async\src\crypto-sha1-2-browser.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/* global self */

'use strict'

const nodeify = require('nodeify')

const webCrypto = getWebCrypto()

function getWebCrypto () {
  if (self.crypto) {
    return self.crypto.subtle || self.crypto.webkitSubtle
  }

  if (self.msCrypto) {
    return self.msCrypto.subtle
  }
}

function webCryptoHash (type) {
  if (!webCrypto) {
    throw new Error('Please use a browser with webcrypto support and ensure the code has been delivered securely via HTTPS/TLS and run within a Secure Context')
  }

  return (data, callback) => {
    const res = webCrypto.digest({ name: type }, data)

    if (typeof res.then !== 'function') { // IE11
      res.onerror = () => {
        callback(new Error(`hashing data using ${type}`))
      }
      res.oncomplete = (e) => {
        callback(null, e.target.result)
      }
      return
    }

    nodeify(
      res.then((raw) => Buffer.from(new Uint8Array(raw))),
      callback
    )
  }
}

function sha1 (buf, callback) {
  webCryptoHash('SHA-1')(buf, callback)
}

function sha2256 (buf, callback) {
  webCryptoHash('SHA-256')(buf, callback)
}

function sha2512 (buf, callback) {
  webCryptoHash('SHA-512')(buf, callback)
}

module.exports = {
  sha1: sha1,
  sha2256: sha2256,
  sha2512: sha2512
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-record\\node_modules\\multihashing-async\\src\\crypto-sha1-2-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\heap\\lib\\heap.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\heap\lib\heap.js
      return function (require, module, exports) {
// Generated by CoffeeScript 1.8.0
(function() {
  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

  floor = Math.floor, min = Math.min;


  /*
  Default comparison function to be used
   */

  defaultCmp = function(x, y) {
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    return 0;
  };


  /*
  Insert item x in list a, and keep it sorted assuming a is sorted.
  
  If x is already in a, insert it to the right of the rightmost x.
  
  Optional args lo (default 0) and hi (default a.length) bound the slice
  of a to be searched.
   */

  insort = function(a, x, lo, hi, cmp) {
    var mid;
    if (lo == null) {
      lo = 0;
    }
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (lo < 0) {
      throw new Error('lo must be non-negative');
    }
    if (hi == null) {
      hi = a.length;
    }
    while (lo < hi) {
      mid = floor((lo + hi) / 2);
      if (cmp(x, a[mid]) < 0) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
  };


  /*
  Push item onto heap, maintaining the heap invariant.
   */

  heappush = function(array, item, cmp) {
    if (cmp == null) {
      cmp = defaultCmp;
    }
    array.push(item);
    return _siftdown(array, 0, array.length - 1, cmp);
  };


  /*
  Pop the smallest item off the heap, maintaining the heap invariant.
   */

  heappop = function(array, cmp) {
    var lastelt, returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    lastelt = array.pop();
    if (array.length) {
      returnitem = array[0];
      array[0] = lastelt;
      _siftup(array, 0, cmp);
    } else {
      returnitem = lastelt;
    }
    return returnitem;
  };


  /*
  Pop and return the current smallest value, and add the new item.
  
  This is more efficient than heappop() followed by heappush(), and can be
  more appropriate when using a fixed size heap. Note that the value
  returned may be larger than item! That constrains reasonable use of
  this routine unless written as part of a conditional replacement:
      if item > array[0]
        item = heapreplace(array, item)
   */

  heapreplace = function(array, item, cmp) {
    var returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    returnitem = array[0];
    array[0] = item;
    _siftup(array, 0, cmp);
    return returnitem;
  };


  /*
  Fast version of a heappush followed by a heappop.
   */

  heappushpop = function(array, item, cmp) {
    var _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (array.length && cmp(array[0], item) < 0) {
      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
      _siftup(array, 0, cmp);
    }
    return item;
  };


  /*
  Transform list into a heap, in-place, in O(array.length) time.
   */

  heapify = function(array, cmp) {
    var i, _i, _j, _len, _ref, _ref1, _results, _results1;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    _ref1 = (function() {
      _results1 = [];
      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }
      return _results1;
    }).apply(this).reverse();
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      _results.push(_siftup(array, i, cmp));
    }
    return _results;
  };


  /*
  Update the position of the given item in the heap.
  This function should be called every time the item is being modified.
   */

  updateItem = function(array, item, cmp) {
    var pos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    pos = array.indexOf(item);
    if (pos === -1) {
      return;
    }
    _siftdown(array, 0, pos, cmp);
    return _siftup(array, pos, cmp);
  };


  /*
  Find the n largest elements in a dataset.
   */

  nlargest = function(array, n, cmp) {
    var elem, result, _i, _len, _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    result = array.slice(0, n);
    if (!result.length) {
      return result;
    }
    heapify(result, cmp);
    _ref = array.slice(n);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elem = _ref[_i];
      heappushpop(result, elem, cmp);
    }
    return result.sort(cmp).reverse();
  };


  /*
  Find the n smallest elements in a dataset.
   */

  nsmallest = function(array, n, cmp) {
    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (n * 10 <= array.length) {
      result = array.slice(0, n).sort(cmp);
      if (!result.length) {
        return result;
      }
      los = result[result.length - 1];
      _ref = array.slice(n);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        if (cmp(elem, los) < 0) {
          insort(result, elem, 0, null, cmp);
          result.pop();
          los = result[result.length - 1];
        }
      }
      return result;
    }
    heapify(array, cmp);
    _results = [];
    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      _results.push(heappop(array, cmp));
    }
    return _results;
  };

  _siftdown = function(array, startpos, pos, cmp) {
    var newitem, parent, parentpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    newitem = array[pos];
    while (pos > startpos) {
      parentpos = (pos - 1) >> 1;
      parent = array[parentpos];
      if (cmp(newitem, parent) < 0) {
        array[pos] = parent;
        pos = parentpos;
        continue;
      }
      break;
    }
    return array[pos] = newitem;
  };

  _siftup = function(array, pos, cmp) {
    var childpos, endpos, newitem, rightpos, startpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    endpos = array.length;
    startpos = pos;
    newitem = array[pos];
    childpos = 2 * pos + 1;
    while (childpos < endpos) {
      rightpos = childpos + 1;
      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
        childpos = rightpos;
      }
      array[pos] = array[childpos];
      pos = childpos;
      childpos = 2 * pos + 1;
    }
    array[pos] = newitem;
    return _siftdown(array, startpos, pos, cmp);
  };

  Heap = (function() {
    Heap.push = heappush;

    Heap.pop = heappop;

    Heap.replace = heapreplace;

    Heap.pushpop = heappushpop;

    Heap.heapify = heapify;

    Heap.updateItem = updateItem;

    Heap.nlargest = nlargest;

    Heap.nsmallest = nsmallest;

    function Heap(cmp) {
      this.cmp = cmp != null ? cmp : defaultCmp;
      this.nodes = [];
    }

    Heap.prototype.push = function(x) {
      return heappush(this.nodes, x, this.cmp);
    };

    Heap.prototype.pop = function() {
      return heappop(this.nodes, this.cmp);
    };

    Heap.prototype.peek = function() {
      return this.nodes[0];
    };

    Heap.prototype.contains = function(x) {
      return this.nodes.indexOf(x) !== -1;
    };

    Heap.prototype.replace = function(x) {
      return heapreplace(this.nodes, x, this.cmp);
    };

    Heap.prototype.pushpop = function(x) {
      return heappushpop(this.nodes, x, this.cmp);
    };

    Heap.prototype.heapify = function() {
      return heapify(this.nodes, this.cmp);
    };

    Heap.prototype.updateItem = function(x) {
      return updateItem(this.nodes, x, this.cmp);
    };

    Heap.prototype.clear = function() {
      return this.nodes = [];
    };

    Heap.prototype.empty = function() {
      return this.nodes.length === 0;
    };

    Heap.prototype.size = function() {
      return this.nodes.length;
    };

    Heap.prototype.clone = function() {
      var heap;
      heap = new Heap();
      heap.nodes = this.nodes.slice(0);
      return heap;
    };

    Heap.prototype.toArray = function() {
      return this.nodes.slice(0);
    };

    Heap.prototype.insert = Heap.prototype.push;

    Heap.prototype.top = Heap.prototype.peek;

    Heap.prototype.front = Heap.prototype.peek;

    Heap.prototype.has = Heap.prototype.contains;

    Heap.prototype.copy = Heap.prototype.clone;

    return Heap;

  })();

  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      return define([], factory);
    } else if (typeof exports === 'object') {
      return module.exports = factory();
    } else {
      return root.Heap = factory();
    }
  })(this, function() {
    return Heap;
  });

}).call(this);

      };
    };
  }
}, {package:"heap",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\heap\\lib\\heap.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-pull-stream\\node_modules\\uuid\\lib\\bytesToUuid.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\socket.io-pull-stream\node_modules\uuid\lib\bytesToUuid.js
      return function (require, module, exports) {
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

module.exports = bytesToUuid;

      };
    };
  }
}, {package:"uuid",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-pull-stream\\node_modules\\uuid\\lib\\bytesToUuid.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-pull-stream\\node_modules\\uuid\\lib\\rng-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\socket.io-pull-stream\node_modules\uuid\lib\rng-browser.js
      return function (require, module, exports) {
// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

      };
    };
  }
}, {package:"uuid",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\socket.io-pull-stream\\node_modules\\uuid\\lib\\rng-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-secio\\node_modules\\multihashing-async\\src\\utils.js", {"_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-secio\node_modules\multihashing-async\src\utils.js
      return function (require, module, exports) {
(function (process,Buffer){(function (){
'use strict'

exports.toCallback = (doWork) => {
  return function (input, callback) {
    let res
    try {
      res = doWork(input)
    } catch (err) {
      process.nextTick(callback, err)
      return
    }

    process.nextTick(callback, null, res)
  }
}

exports.toBuf = (doWork, other) => (input) => {
  let result = doWork(input, other)
  return Buffer.from(result, 'hex')
}

exports.fromString = (doWork, other) => (_input) => {
  const input = Buffer.isBuffer(_input) ? _input.toString() : _input
  return doWork(input, other)
}

exports.fromNumberTo32BitBuf = (doWork, other) => (input) => {
  let number = doWork(input, other)
  const bytes = new Array(4)

  for (let i = 0; i < 4; i++) {
    bytes[i] = number & 0xff
    number = number >> 8
  }

  return Buffer.from(bytes)
}

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-secio\\node_modules\\multihashing-async\\src\\utils.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-secio\\node_modules\\multihashing-async\\src\\blake.js", {"./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-secio\\node_modules\\multihashing-async\\src\\utils.js","blakejs":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\blakejs\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-secio\node_modules\multihashing-async\src\blake.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const blake = require('blakejs')

const toCallback = require('./utils').toCallback

const minB = 0xb201
const minS = 0xb241

const blake2b = {
  init: blake.blake2bInit,
  update: blake.blake2bUpdate,
  digest: blake.blake2bFinal
}

const blake2s = {
  init: blake.blake2sInit,
  update: blake.blake2sUpdate,
  digest: blake.blake2sFinal
}

const makeB2Hash = (size, hf) => toCallback((buf) => {
  const ctx = hf.init(size, null)
  hf.update(ctx, buf)
  return Buffer.from(hf.digest(ctx))
})

module.exports = (table) => {
  for (let i = 0; i < 64; i++) {
    table[minB + i] = makeB2Hash(i + 1, blake2b)
  }
  for (let i = 0; i < 32; i++) {
    table[minS + i] = makeB2Hash(i + 1, blake2s)
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-secio\\node_modules\\multihashing-async\\src\\blake.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-secio\\node_modules\\multihashing-async\\src\\crypto-sha1-2-browser.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","nodeify":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\nodeify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\libp2p-secio\node_modules\multihashing-async\src\crypto-sha1-2-browser.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/* global self */

'use strict'

const nodeify = require('nodeify')

const webCrypto = getWebCrypto()

function getWebCrypto () {
  if (self.crypto) {
    return self.crypto.subtle || self.crypto.webkitSubtle
  }

  if (self.msCrypto) {
    return self.msCrypto.subtle
  }
}

function webCryptoHash (type) {
  if (!webCrypto) {
    throw new Error('Please use a browser with webcrypto support and ensure the code has been delivered securely via HTTPS/TLS and run within a Secure Context')
  }

  return (data, callback) => {
    const res = webCrypto.digest({ name: type }, data)

    if (typeof res.then !== 'function') { // IE11
      res.onerror = () => {
        callback(new Error(`hashing data using ${type}`))
      }
      res.oncomplete = (e) => {
        callback(null, e.target.result)
      }
      return
    }

    nodeify(
      res.then((raw) => Buffer.from(new Uint8Array(raw))),
      callback
    )
  }
}

function sha1 (buf, callback) {
  webCryptoHash('SHA-1')(buf, callback)
}

function sha2256 (buf, callback) {
  webCryptoHash('SHA-256')(buf, callback)
}

function sha2512 (buf, callback) {
  webCryptoHash('SHA-512')(buf, callback)
}

module.exports = {
  sha1: sha1,
  sha2256: sha2256,
  sha2512: sha2512
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"multihashing-async",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\libp2p-secio\\node_modules\\multihashing-async\\src\\crypto-sha1-2-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\node_modules\\debug\\src\\debug.js", {"ms":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\node_modules\\ms\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\engine.io-client\node_modules\debug\src\debug.js
      return function (require, module, exports) {

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

      };
    };
  }
}, {package:"debug",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\node_modules\\debug\\src\\debug.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\xmlhttprequest.js", {"./globalThis":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\globalThis.browser.js","has-cors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\has-cors\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\engine.io-client\lib\xmlhttprequest.js
      return function (require, module, exports) {
// browser shim for xmlhttprequest module

var hasCORS = require('has-cors');
var globalThis = require('./globalThis');

module.exports = function (opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new globalThis[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
    } catch (e) { }
  }
};

      };
    };
  }
}, {package:"engine.io-client",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\xmlhttprequest.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\transports\\polling-jsonp.js", {"../globalThis":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\globalThis.browser.js","./polling":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\transports\\polling.js","component-inherit":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\component-inherit\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\engine.io-client\lib\transports\polling-jsonp.js
      return function (require, module, exports) {
/**
 * Module requirements.
 */

var Polling = require('./polling');
var inherit = require('component-inherit');
var globalThis = require('../globalThis');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    callbacks = globalThis.___eio = (globalThis.___eio || []);
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (typeof addEventListener === 'function') {
    addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function (e) {
    self.onError('jsonp poll error', e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  } else {
    (document.head || document.body).appendChild(script);
  }
  this.script = script;

  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);

  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch (e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function () {
      if (self.iframe.readyState === 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

      };
    };
  }
}, {package:"engine.io-client",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\transports\\polling-jsonp.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\transports\\websocket.js", {"../transport":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\transport.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","component-inherit":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\component-inherit\\index.js","debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\node_modules\\debug\\src\\browser.js","engine.io-parser":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-parser\\lib\\browser.js","parseqs":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\parseqs\\index.js","ws":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js","yeast":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\yeast\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\engine.io-client\lib\transports\websocket.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parser = require('engine.io-parser');
var parseqs = require('parseqs');
var inherit = require('component-inherit');
var yeast = require('yeast');
var debug = require('debug')('engine.io-client:websocket');

var BrowserWebSocket, NodeWebSocket;

if (typeof WebSocket !== 'undefined') {
  BrowserWebSocket = WebSocket;
} else if (typeof self !== 'undefined') {
  BrowserWebSocket = self.WebSocket || self.MozWebSocket;
}

if (typeof window === 'undefined') {
  try {
    NodeWebSocket = require('ws');
  } catch (e) { }
}

/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */

var WebSocketImpl = BrowserWebSocket || NodeWebSocket;

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  this.perMessageDeflate = opts.perMessageDeflate;
  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
  this.protocols = opts.protocols;
  if (!this.usingBrowserWebSocket) {
    WebSocketImpl = NodeWebSocket;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function () {
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var uri = this.uri();
  var protocols = this.protocols;

  var opts = {};

  if (!this.isReactNative) {
    opts.agent = this.agent;
    opts.perMessageDeflate = this.perMessageDeflate;

    // SSL options for Node.js client
    opts.pfx = this.pfx;
    opts.key = this.key;
    opts.passphrase = this.passphrase;
    opts.cert = this.cert;
    opts.ca = this.ca;
    opts.ciphers = this.ciphers;
    opts.rejectUnauthorized = this.rejectUnauthorized;
  }

  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }
  if (this.localAddress) {
    opts.localAddress = this.localAddress;
  }

  try {
    this.ws =
      this.usingBrowserWebSocket && !this.isReactNative
        ? protocols
          ? new WebSocketImpl(uri, protocols)
          : new WebSocketImpl(uri)
        : new WebSocketImpl(uri, protocols, opts);
  } catch (err) {
    return this.emit('error', err);
  }

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'nodebuffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function () {
  var self = this;

  this.ws.onopen = function () {
    self.onOpen();
  };
  this.ws.onclose = function () {
    self.onClose();
  };
  this.ws.onmessage = function (ev) {
    self.onData(ev.data);
  };
  this.ws.onerror = function (e) {
    self.onError('websocket error', e);
  };
};

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function (packets) {
  var self = this;
  this.writable = false;

  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  var total = packets.length;
  for (var i = 0, l = total; i < l; i++) {
    (function (packet) {
      parser.encodePacket(packet, self.supportsBinary, function (data) {
        if (!self.usingBrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' === typeof data ? Buffer.byteLength(data) : data.length;
            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }

        // Sometimes the websocket has already been closed but the browser didn't
        // have a chance of informing us about it yet, in that case send will
        // throw an error
        try {
          if (self.usingBrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e) {
          debug('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done () {
    self.emit('flush');

    // fake drain
    // defer to next tick to allow Socket to clear writeBuffer
    setTimeout(function () {
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function () {
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function () {
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||
    ('ws' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function () {
  return !!WebSocketImpl && !('__initialize' in WebSocketImpl && this.name === WS.prototype.name);
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"engine.io-client",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\transports\\websocket.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\transports\\polling-xhr.js", {"../globalThis":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\globalThis.browser.js","./polling":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\transports\\polling.js","component-emitter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\component-emitter\\index.js","component-inherit":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\component-inherit\\index.js","debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\node_modules\\debug\\src\\browser.js","xmlhttprequest-ssl":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\xmlhttprequest.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\engine.io-client\lib\transports\polling-xhr.js
      return function (require, module, exports) {
/* global attachEvent */

/**
 * Module requirements.
 */

var XMLHttpRequest = require('xmlhttprequest-ssl');
var Polling = require('./polling');
var Emitter = require('component-emitter');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:polling-xhr');
var globalThis = require('../globalThis');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty () {}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR (opts) {
  Polling.call(this, opts);
  this.requestTimeout = opts.requestTimeout;
  this.extraHeaders = opts.extraHeaders;

  if (typeof location !== 'undefined') {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = (typeof location !== 'undefined' && opts.hostname !== location.hostname) ||
      port !== opts.port;
    this.xs = opts.secure !== isSSL;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function (opts) {
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;
  opts.withCredentials = this.withCredentials;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  opts.requestTimeout = this.requestTimeout;

  // other options for Node.js client
  opts.extraHeaders = this.extraHeaders;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function (data, fn) {
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function (err) {
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function () {
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function (data) {
    self.onData(data);
  });
  req.on('error', function (err) {
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request (opts) {
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined !== opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;
  this.withCredentials = opts.withCredentials;
  this.requestTimeout = opts.requestTimeout;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function () {
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}

    if ('POST' === this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    try {
      xhr.setRequestHeader('Accept', '*/*');
    } catch (e) {}

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = this.withCredentials;
    }

    if (this.requestTimeout) {
      xhr.timeout = this.requestTimeout;
    }

    if (this.hasXDR()) {
      xhr.onload = function () {
        self.onLoad();
      };
      xhr.onerror = function () {
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 2) {
          try {
            var contentType = xhr.getResponseHeader('Content-Type');
            if (self.supportsBinary && contentType === 'application/octet-stream' || contentType === 'application/octet-stream; charset=UTF-8') {
              xhr.responseType = 'arraybuffer';
            }
          } catch (e) {}
        }
        if (4 !== xhr.readyState) return;
        if (200 === xhr.status || 1223 === xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function () {
            self.onError(typeof xhr.status === 'number' ? xhr.status : 0);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function () {
      self.onError(e);
    }, 0);
    return;
  }

  if (typeof document !== 'undefined') {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function () {
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function (data) {
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function (err) {
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function (fromError) {
  if ('undefined' === typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch (e) {}
  }

  if (typeof document !== 'undefined') {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function () {
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type');
    } catch (e) {}
    if (contentType === 'application/octet-stream' || contentType === 'application/octet-stream; charset=UTF-8') {
      data = this.xhr.response || this.xhr.responseText;
    } else {
      data = this.xhr.responseText;
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function () {
  return typeof XDomainRequest !== 'undefined' && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function () {
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

Request.requestsCount = 0;
Request.requests = {};

if (typeof document !== 'undefined') {
  if (typeof attachEvent === 'function') {
    attachEvent('onunload', unloadHandler);
  } else if (typeof addEventListener === 'function') {
    var terminationEvent = 'onpagehide' in globalThis ? 'pagehide' : 'unload';
    addEventListener(terminationEvent, unloadHandler, false);
  }
}

function unloadHandler () {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

      };
    };
  }
}, {package:"engine.io-client",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\transports\\polling-xhr.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\latency-monitor\\node_modules\\ms\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\latency-monitor\node_modules\ms\index.js
      return function (require, module, exports) {
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

      };
    };
  }
}, {package:"ms",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\latency-monitor\\node_modules\\ms\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\some.js", {"./internal/createTester":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\internal\\createTester.js","./internal/doParallel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\internal\\doParallel.js","lodash/identity":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash\\identity.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\async\some.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createTester = require('./internal/createTester');

var _createTester2 = _interopRequireDefault(_createTester);

var _doParallel = require('./internal/doParallel');

var _doParallel2 = _interopRequireDefault(_doParallel);

var _identity = require('lodash/identity');

var _identity2 = _interopRequireDefault(_identity);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Returns `true` if at least one element in the `coll` satisfies an async test.
 * If any iteratee call returns `true`, the main `callback` is immediately
 * called.
 *
 * @name some
 * @static
 * @memberOf module:Collections
 * @method
 * @alias any
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collections in parallel.
 * The iteratee should complete with a boolean `result` value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the iteratee functions have finished.
 * Result will be either `true` or `false` depending on the values of the async
 * tests. Invoked with (err, result).
 * @example
 *
 * async.some(['file1','file2','file3'], function(filePath, callback) {
 *     fs.access(filePath, function(err) {
 *         callback(null, !err)
 *     });
 * }, function(err, result) {
 *     // if result is true then at least one of the files exists
 * });
 */
exports.default = (0, _doParallel2.default)((0, _createTester2.default)(Boolean, _identity2.default));
module.exports = exports['default'];
      };
    };
  }
}, {package:"async",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async\\some.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\hamt-sharding\\src\\consumable-buffer.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\hamt-sharding\src\consumable-buffer.js
      return function (require, module, exports) {
'use strict'

const START_MASKS = [
  0b11111111,
  0b11111110,
  0b11111100,
  0b11111000,
  0b11110000,
  0b11100000,
  0b11000000,
  0b10000000
]

const STOP_MASKS = [
  0b00000001,
  0b00000011,
  0b00000111,
  0b00001111,
  0b00011111,
  0b00111111,
  0b01111111,
  0b11111111
]

module.exports = class ConsumableBuffer {
  constructor (value) {
    this._value = value
    this._currentBytePos = value.length - 1
    this._currentBitPos = 7
  }

  availableBits () {
    return this._currentBitPos + 1 + this._currentBytePos * 8
  }

  totalBits () {
    return this._value.length * 8
  }

  take (bits) {
    let pendingBits = bits
    let result = 0
    while (pendingBits && this._haveBits()) {
      const byte = this._value[this._currentBytePos]
      const availableBits = this._currentBitPos + 1
      const taking = Math.min(availableBits, pendingBits)
      const value = byteBitsToInt(byte, availableBits - taking, taking)
      result = (result << taking) + value

      pendingBits -= taking

      this._currentBitPos -= taking
      if (this._currentBitPos < 0) {
        this._currentBitPos = 7
        this._currentBytePos--
      }
    }

    return result
  }

  untake (bits) {
    this._currentBitPos += bits
    while (this._currentBitPos > 7) {
      this._currentBitPos -= 8
      this._currentBytePos += 1
    }
  }

  _haveBits () {
    return this._currentBytePos >= 0
  }
}

function byteBitsToInt (byte, start, length) {
  const mask = maskFor(start, length)
  return (byte & mask) >>> start
}

function maskFor (start, length) {
  return START_MASKS[start] & STOP_MASKS[Math.min(length + start - 1, 7)]
}

      };
    };
  }
}, {package:"hamt-sharding",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\hamt-sharding\\src\\consumable-buffer.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\end-of-stream.js", {"../../../errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\errors-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\bl\node_modules\readable-stream\lib\internal\streams\end-of-stream.js
      return function (require, module, exports) {
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\end-of-stream.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\pipeline.js", {"../../../errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\errors-browser.js","./end-of-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\end-of-stream.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\bl\node_modules\readable-stream\lib\internal\streams\pipeline.js
      return function (require, module, exports) {
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\pipeline.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\_stream_passthrough.js", {"./_stream_transform":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\_stream_transform.js","inherits":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\inherits\\inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\bl\node_modules\readable-stream\lib\_stream_passthrough.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\_stream_passthrough.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\_stream_duplex.js", {"./_stream_readable":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\_stream_readable.js","./_stream_writable":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\_stream_writable.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","inherits":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\inherits\\inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\bl\node_modules\readable-stream\lib\_stream_duplex.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\_stream_duplex.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\_stream_transform.js", {"../errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\errors-browser.js","./_stream_duplex":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\_stream_duplex.js","inherits":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\inherits\\inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\bl\node_modules\readable-stream\lib\_stream_transform.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\_stream_transform.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\_stream_writable.js", {"../errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\errors-browser.js","./_stream_duplex":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\_stream_duplex.js","./internal/streams/destroy":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\destroy.js","./internal/streams/state":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\state.js","./internal/streams/stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\stream-browser.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","inherits":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\inherits\\inherits_browser.js","util-deprecate":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\util-deprecate\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\bl\node_modules\readable-stream\lib\_stream_writable.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\_stream_writable.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\_stream_readable.js", {"../errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\errors-browser.js","./_stream_duplex":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\_stream_duplex.js","./internal/streams/async_iterator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\async_iterator.js","./internal/streams/buffer_list":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\buffer_list.js","./internal/streams/destroy":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\destroy.js","./internal/streams/from":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\from-browser.js","./internal/streams/state":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\state.js","./internal/streams/stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\stream-browser.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","inherits":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\inherits\\inherits_browser.js","string_decoder/":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\string_decoder\\lib\\string_decoder.js","util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\bl\node_modules\readable-stream\lib\_stream_readable.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\_stream_readable.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assemblyscript\\lib\\loader\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\assemblyscript\lib\loader\index.js
      return function (require, module, exports) {
"use strict";

const hasBigInt64 = typeof BigUint64Array !== "undefined";
const thisPtr = Symbol();

/** Gets a string from an U32 and an U16 view on a memory. */
function getStringImpl(U32, U16, ptr) {
  var dataLength = U32[ptr >>> 2];
  var dataOffset = (ptr + 4) >>> 1;
  var dataRemain = dataLength;
  var parts = [];
  const chunkSize = 1024;
  while (dataRemain > chunkSize) {
    let last = U16[dataOffset + chunkSize - 1];
    let size = last >= 0xD800 && last < 0xDC00 ? chunkSize - 1 : chunkSize;
    let part = U16.subarray(dataOffset, dataOffset += size);
    parts.push(String.fromCharCode.apply(String, part));
    dataRemain -= size;
  }
  return parts.join("") + String.fromCharCode.apply(String, U16.subarray(dataOffset, dataOffset + dataRemain));
}

/** Prepares the base module prior to instantiation. */
function preInstantiate(imports) {
  var baseModule = {};

  function getString(memory, ptr) {
    if (!memory) return "<yet unknown>";
    var buffer = memory.buffer;
    return getStringImpl(new Uint32Array(buffer), new Uint16Array(buffer), ptr);
  }

  // add common imports used by stdlib for convenience
  var env = (imports.env = imports.env || {});
  env.abort = env.abort || function abort(mesg, file, line, colm) {
    var memory = baseModule.memory || env.memory; // prefer exported, otherwise try imported
    throw Error("abort: " + getString(memory, mesg) + " at " + getString(memory, file) + ":" + line + ":" + colm);
  }
  env.trace = env.trace || function trace(mesg, n) {
    var memory = baseModule.memory || env.memory;
    console.log("trace: " + getString(memory, mesg) + (n ? " " : "") + Array.prototype.slice.call(arguments, 2, 2 + n).join(", "));
  }
  imports.Math = imports.Math || Math;
  imports.Date = imports.Date || Date;

  return baseModule;
}

/** Prepares the final module once instantiation is complete. */
function postInstantiate(baseModule, instance) {
  var rawExports = instance.exports;
  var memory = rawExports.memory;
  var memory_allocate = rawExports["memory.allocate"];
  var memory_fill = rawExports["memory.fill"];
  var memory_free = rawExports["memory.free"];
  var table = rawExports.table;
  var setargc = rawExports._setargc || function() {};

  // Provide views for all sorts of basic values
  var buffer, I8, U8, I16, U16, I32, U32, F32, F64, I64, U64;

  /** Updates memory views if memory has grown meanwhile. */
  function checkMem() {
    // see: https://github.com/WebAssembly/design/issues/1210
    if (buffer !== memory.buffer) {
      buffer = memory.buffer;
      I8  = new Int8Array(buffer);
      U8  = new Uint8Array(buffer);
      I16 = new Int16Array(buffer);
      U16 = new Uint16Array(buffer);
      I32 = new Int32Array(buffer);
      U32 = new Uint32Array(buffer);
      if (hasBigInt64) {
        I64 = new BigInt64Array(buffer);
        U64 = new BigUint64Array(buffer);
      }
      F32 = new Float32Array(buffer);
      F64 = new Float64Array(buffer);
    }
  }
  checkMem();

  /** Allocates a new string in the module's memory and returns its pointer. */
  function newString(str) {
    var dataLength = str.length;
    var ptr = memory_allocate(4 + (dataLength << 1));
    var dataOffset = (4 + ptr) >>> 1;
    checkMem();
    U32[ptr >>> 2] = dataLength;
    for (let i = 0; i < dataLength; ++i) U16[dataOffset + i] = str.charCodeAt(i);
    return ptr;
  }

  baseModule.newString = newString;

  /** Gets a string from the module's memory by its pointer. */
  function getString(ptr) {
    checkMem();
    return getStringImpl(U32, U16, ptr);
  }

  baseModule.getString = getString;

  function computeBufferSize(byteLength) {
    const HEADER_SIZE = 8;
    return 1 << (32 - Math.clz32(byteLength + HEADER_SIZE - 1));
  }

  /** Creates a new typed array in the module's memory and returns its pointer. */
  function newArray(view, length, unsafe) {
    var ctor = view.constructor;
    if (ctor === Function) { // TypedArray constructor created in memory
      ctor = view;
      view = null;
    } else { // TypedArray instance copied into memory
      if (length === undefined) length = view.length;
    }
    var elementSize = ctor.BYTES_PER_ELEMENT;
    if (!elementSize) throw Error("not a typed array");
    var byteLength = elementSize * length;
    var ptr = memory_allocate(12); // TypedArray header
    var buf = memory_allocate(computeBufferSize(byteLength)); // ArrayBuffer
    checkMem();
    U32[ ptr      >>> 2] = buf;        // .buffer
    U32[(ptr + 4) >>> 2] = 0;          // .byteOffset
    U32[(ptr + 8) >>> 2] = byteLength; // .byteLength
    U32[ buf      >>> 2] = byteLength; // .byteLength
    U32[(buf + 4) >>> 2] = 0;          // 0
    if (view) {
      new ctor(buffer, buf + 8, length).set(view);
      if (view.length < length && !unsafe) {
        let setLength = elementSize * view.length;
        memory_fill(buf + 8 + setLength, 0, byteLength - setLength);
      }
    } else if (!unsafe) {
      memory_fill(buf + 8, 0, byteLength);
    }
    return ptr;
  }

  baseModule.newArray = newArray;

  /** Gets a view on a typed array in the module's memory by its pointer. */
  function getArray(ctor, ptr) {
    var elementSize = ctor.BYTES_PER_ELEMENT;
    if (!elementSize) throw Error("not a typed array");
    checkMem();
    var buf        = U32[ ptr      >>> 2];
    var byteOffset = U32[(ptr + 4) >>> 2];
    var byteLength = U32[(ptr + 8) >>> 2];
    return new ctor(buffer, buf + 8 + byteOffset, (byteLength - byteOffset) / elementSize);
  }

  baseModule.getArray = getArray;

  /** Frees a typed array in the module's memory. Must not be accessed anymore afterwards. */
  function freeArray(ptr) {
    checkMem();
    var buf = U32[ptr >>> 2];
    memory_free(buf);
    memory_free(ptr);
  }

  baseModule.freeArray = freeArray;

  /**
   * Creates a new function in the module's table and returns its pointer. Note that only actual
   * WebAssembly functions, i.e. as exported by the module, are supported.
   */
  function newFunction(fn) {
    if (typeof fn.original === "function") fn = fn.original;
    var index = table.length;
    table.grow(1);
    table.set(index, fn);
    return index;
  }

  baseModule.newFunction = newFunction;

  /** Gets a function by its pointer. */
  function getFunction(ptr) {
    return wrapFunction(table.get(ptr), setargc);
  }

  baseModule.getFunction = getFunction;

  // Pull basic exports to baseModule so code in preInstantiate can use them
  baseModule.memory = baseModule.memory || memory;
  baseModule.table = baseModule.table || table;

  // Demangle exports and provide the usual utility on the prototype
  return demangle(rawExports, Object.defineProperties(baseModule, {
    I8: { get: function() { checkMem(); return I8; } },
    U8: { get: function() { checkMem(); return U8; } },
    I16: { get: function() { checkMem(); return I16; } },
    U16: { get: function() { checkMem(); return U16; } },
    I32: { get: function() { checkMem(); return I32; } },
    U32: { get: function() { checkMem(); return U32; } },
    I64: { get: function() { checkMem(); return I64; } },
    U64: { get: function() { checkMem(); return U64; } },
    F32: { get: function() { checkMem(); return F32; } },
    F64: { get: function() { checkMem(); return F64; } }
  }));
}

/** Wraps a WebAssembly function while also taking care of variable arguments. */
function wrapFunction(fn, setargc) {
  var wrap = (...args) => {
    setargc(args.length);
    return fn(...args);
  }
  // adding a function to the table with `newFunction` is limited to actual WebAssembly functions,
  // hence we can't use the wrapper and instead need to provide a reference to the original
  wrap.original = fn;
  return wrap;
}

/** Instantiates an AssemblyScript module using the specified imports. */
function instantiate(module, imports) {
  return postInstantiate(
    preInstantiate(imports || (imports = {})),
    new WebAssembly.Instance(module, imports)
  );
}

exports.instantiate = instantiate;

/** Instantiates an AssemblyScript module from a buffer using the specified imports. */
function instantiateBuffer(buffer, imports) {
  return instantiate(new WebAssembly.Module(buffer), imports);
}

exports.instantiateBuffer = instantiateBuffer;

/** Instantiates an AssemblyScript module from a response using the specified imports. */
async function instantiateStreaming(response, imports) {
  return postInstantiate(
    preInstantiate(imports || (imports = {})),
    (await WebAssembly.instantiateStreaming(response, imports)).instance
  );
}

exports.instantiateStreaming = instantiateStreaming;

/** Demangles an AssemblyScript module's exports to a friendly object structure. */
function demangle(exports, baseModule) {
  var module = baseModule ? Object.create(baseModule) : {};
  var setargc = exports._setargc || function() {};
  function hasOwnProperty(elem, prop) {
    return Object.prototype.hasOwnProperty.call(elem, prop);
  }
  for (let internalName in exports) {
    if (!hasOwnProperty(exports, internalName)) continue;
    let elem = exports[internalName];
    let parts = internalName.split(".");
    let curr = module;
    while (parts.length > 1) {
      let part = parts.shift();
      if (!hasOwnProperty(curr, part)) curr[part] = {};
      curr = curr[part];
    }
    let name = parts[0];
    let hash = name.indexOf("#");
    if (hash >= 0) {
      let className = name.substring(0, hash);
      let classElem = curr[className];
      if (typeof classElem === "undefined" || !classElem.prototype) {
        let ctor = function(...args) {
          return ctor.wrap(ctor.prototype.constructor(0, ...args));
        };
        ctor.prototype = {};
        ctor.wrap = function(thisValue) {
          return Object.create(ctor.prototype, { [thisPtr]: { value: thisValue, writable: false } });
        };
        if (classElem) Object.getOwnPropertyNames(classElem).forEach(name =>
          Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name))
        );
        curr[className] = ctor;
      }
      name = name.substring(hash + 1);
      curr = curr[className].prototype;
      if (/^(get|set):/.test(name)) {
        if (!hasOwnProperty(curr, name = name.substring(4))) {
          let getter = exports[internalName.replace("set:", "get:")];
          let setter = exports[internalName.replace("get:", "set:")];
          Object.defineProperty(curr, name, {
            get: function() { return getter(this[thisPtr]); },
            set: function(value) { setter(this[thisPtr], value); },
            enumerable: true
          });
        }
      } else {
        if (name === 'constructor') {
          curr[name] = wrapFunction(elem, setargc);
        } else { // for methods
          Object.defineProperty(curr, name, {
            value: function (...args) {
              setargc(args.length);
              return elem(this[thisPtr], ...args);
            }
          });
        }
      }
    } else {
      if (/^(get|set):/.test(name)) {
        if (!hasOwnProperty(curr, name = name.substring(4))) {
          Object.defineProperty(curr, name, {
            get: exports[internalName.replace("set:", "get:")],
            set: exports[internalName.replace("get:", "set:")],
            enumerable: true
          });
        }
      } else if (typeof elem === "function") {
        curr[name] = wrapFunction(elem, setargc);
      } else {
        curr[name] = elem;
      }
    }
  }

  return module;
}

exports.demangle = demangle;

      };
    };
  }
}, {package:"assemblyscript",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assemblyscript\\lib\\loader\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\util\\cluster-worker-id-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\shortid\lib\util\cluster-worker-id-browser.js
      return function (require, module, exports) {
'use strict';

module.exports = 0;

      };
    };
  }
}, {package:"shortid",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\util\\cluster-worker-id-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\is-valid.js", {"./alphabet":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\alphabet.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\shortid\lib\is-valid.js
      return function (require, module, exports) {
'use strict';
var alphabet = require('./alphabet');

function isShortId(id) {
    if (!id || typeof id !== 'string' || id.length < 6 ) {
        return false;
    }

    var nonAlphabetic = new RegExp('[^' +
      alphabet.get().replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&') +
    ']');
    return !nonAlphabetic.test(id);
}

module.exports = isShortId;

      };
    };
  }
}, {package:"shortid",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\is-valid.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\alphabet.js", {"./random/random-from-seed":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\random\\random-from-seed.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\shortid\lib\alphabet.js
      return function (require, module, exports) {
'use strict';

var randomFromSeed = require('./random/random-from-seed');

var ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';
var alphabet;
var previousSeed;

var shuffled;

function reset() {
    shuffled = false;
}

function setCharacters(_alphabet_) {
    if (!_alphabet_) {
        if (alphabet !== ORIGINAL) {
            alphabet = ORIGINAL;
            reset();
        }
        return;
    }

    if (_alphabet_ === alphabet) {
        return;
    }

    if (_alphabet_.length !== ORIGINAL.length) {
        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);
    }

    var unique = _alphabet_.split('').filter(function(item, ind, arr){
       return ind !== arr.lastIndexOf(item);
    });

    if (unique.length) {
        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));
    }

    alphabet = _alphabet_;
    reset();
}

function characters(_alphabet_) {
    setCharacters(_alphabet_);
    return alphabet;
}

function setSeed(seed) {
    randomFromSeed.seed(seed);
    if (previousSeed !== seed) {
        reset();
        previousSeed = seed;
    }
}

function shuffle() {
    if (!alphabet) {
        setCharacters(ORIGINAL);
    }

    var sourceArray = alphabet.split('');
    var targetArray = [];
    var r = randomFromSeed.nextValue();
    var characterIndex;

    while (sourceArray.length > 0) {
        r = randomFromSeed.nextValue();
        characterIndex = Math.floor(r * sourceArray.length);
        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
    }
    return targetArray.join('');
}

function getShuffled() {
    if (shuffled) {
        return shuffled;
    }
    shuffled = shuffle();
    return shuffled;
}

/**
 * lookup shuffled letter
 * @param index
 * @returns {string}
 */
function lookup(index) {
    var alphabetShuffled = getShuffled();
    return alphabetShuffled[index];
}

function get () {
  return alphabet || ORIGINAL;
}

module.exports = {
    get: get,
    characters: characters,
    seed: setSeed,
    lookup: lookup,
    shuffled: getShuffled
};

      };
    };
  }
}, {package:"shortid",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\alphabet.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\build.js", {"./alphabet":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\alphabet.js","./generate":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\generate.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\shortid\lib\build.js
      return function (require, module, exports) {
'use strict';

var generate = require('./generate');
var alphabet = require('./alphabet');

// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.
// This number should be updated every year or so to keep the generated id short.
// To regenerate `new Date() - 0` and bump the version. Always bump the version!
var REDUCE_TIME = 1459707606518;

// don't change unless we change the algos or REDUCE_TIME
// must be an integer and less than 16
var version = 6;

// Counter is used when shortid is called multiple times in one second.
var counter;

// Remember the last time shortid was called in case counter is needed.
var previousSeconds;

/**
 * Generate unique id
 * Returns string id
 */
function build(clusterWorkerId) {
    var str = '';

    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);

    if (seconds === previousSeconds) {
        counter++;
    } else {
        counter = 0;
        previousSeconds = seconds;
    }

    str = str + generate(version);
    str = str + generate(clusterWorkerId);
    if (counter > 0) {
        str = str + generate(counter);
    }
    str = str + generate(seconds);
    return str;
}

module.exports = build;

      };
    };
  }
}, {package:"shortid",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\build.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\node_modules\\ms\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\engine.io-client\node_modules\ms\index.js
      return function (require, module, exports) {
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

      };
    };
  }
}, {package:"ms",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\node_modules\\ms\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\globalThis.browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\engine.io-client\lib\globalThis.browser.js
      return function (require, module, exports) {
module.exports = (function () {
  if (typeof self !== 'undefined') {
    return self;
  } else if (typeof window !== 'undefined') {
    return window;
  } else {
    return Function('return this')(); // eslint-disable-line no-new-func
  }
})();

      };
    };
  }
}, {package:"engine.io-client",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\globalThis.browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\has-cors\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\has-cors\index.js
      return function (require, module, exports) {

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

      };
    };
  }
}, {package:"has-cors",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\has-cors\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\transports\\polling.js", {"../transport":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\transport.js","component-inherit":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\component-inherit\\index.js","debug":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\node_modules\\debug\\src\\browser.js","engine.io-parser":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-parser\\lib\\browser.js","parseqs":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\parseqs\\index.js","xmlhttprequest-ssl":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\xmlhttprequest.js","yeast":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\yeast\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\engine.io-client\lib\transports\polling.js
      return function (require, module, exports) {
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parseqs = require('parseqs');
var parser = require('engine.io-parser');
var inherit = require('component-inherit');
var yeast = require('yeast');
var debug = require('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function () {
  var XMLHttpRequest = require('xmlhttprequest-ssl');
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function () {
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function (onPause) {
  var self = this;

  this.readyState = 'pausing';

  function pause () {
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function () {
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function () {
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function () {
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function (data) {
  var self = this;
  debug('polling got data %s', data);
  var callback = function (packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' === self.readyState && packet.type === 'open') {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' === packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' !== this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' === this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function () {
  var self = this;

  function close () {
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' === this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function (packets) {
  var self = this;
  this.writable = false;
  var callbackfn = function () {
    self.writable = true;
    self.emit('drain');
  };

  parser.encodePayload(packets, this.supportsBinary, function (data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' === schema && Number(this.port) !== 443) ||
     ('http' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

      };
    };
  }
}, {package:"engine.io-client",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\engine.io-client\\lib\\transports\\polling.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\component-inherit\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\component-inherit\index.js
      return function (require, module, exports) {

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
      };
    };
  }
}, {package:"component-inherit",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\component-inherit\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\yeast\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\yeast\index.js
      return function (require, module, exports) {
'use strict';

var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;

      };
    };
  }
}, {package:"yeast",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\yeast\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\errors-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\bl\node_modules\readable-stream\errors-browser.js
      return function (require, module, exports) {
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\errors-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\destroy.js", {"_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\bl\node_modules\readable-stream\lib\internal\streams\destroy.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\destroy.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\stream-browser.js", {"events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\bl\node_modules\readable-stream\lib\internal\streams\stream-browser.js
      return function (require, module, exports) {
module.exports = require('events').EventEmitter;

      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\stream-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\state.js", {"../../../errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\errors-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\bl\node_modules\readable-stream\lib\internal\streams\state.js
      return function (require, module, exports) {
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};
      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\state.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\from-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\bl\node_modules\readable-stream\lib\internal\streams\from-browser.js
      return function (require, module, exports) {
module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};

      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\from-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\buffer_list.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\bl\node_modules\readable-stream\lib\internal\streams\buffer_list.js
      return function (require, module, exports) {
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();
      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\buffer_list.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\async_iterator.js", {"./end-of-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\end-of-stream.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\bl\node_modules\readable-stream\lib\internal\streams\async_iterator.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bl\\node_modules\\readable-stream\\lib\\internal\\streams\\async_iterator.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\random\\random-from-seed.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\shortid\lib\random\random-from-seed.js
      return function (require, module, exports) {
'use strict';

// Found this seed-based random generator somewhere
// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)

var seed = 1;

/**
 * return a random number based on a seed
 * @param seed
 * @returns {number}
 */
function getNextValue() {
    seed = (seed * 9301 + 49297) % 233280;
    return seed/(233280.0);
}

function setSeed(_seed_) {
    seed = _seed_;
}

module.exports = {
    nextValue: getNextValue,
    seed: setSeed
};

      };
    };
  }
}, {package:"shortid",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\random\\random-from-seed.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\generate.js", {"./alphabet":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\alphabet.js","./random/random-byte":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\random\\random-byte-browser.js","nanoid/format":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\nanoid\\format.browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\shortid\lib\generate.js
      return function (require, module, exports) {
'use strict';

var alphabet = require('./alphabet');
var random = require('./random/random-byte');
var format = require('nanoid/format');

function generate(number) {
    var loopCounter = 0;
    var done;

    var str = '';

    while (!done) {
        str = str + format(random, alphabet.get(), 1);
        done = number < (Math.pow(16, loopCounter + 1 ) );
        loopCounter++;
    }
    return str;
}

module.exports = generate;

      };
    };
  }
}, {package:"shortid",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\generate.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\random\\random-byte-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\shortid\lib\random\random-byte-browser.js
      return function (require, module, exports) {
'use strict';

var crypto = typeof window === 'object' && (window.crypto || window.msCrypto); // IE 11 uses window.msCrypto

var randomByte;

if (!crypto || !crypto.getRandomValues) {
    randomByte = function(size) {
        var bytes = [];
        for (var i = 0; i < size; i++) {
            bytes.push(Math.floor(Math.random() * 256));
        }
        return bytes;
    };
} else {
    randomByte = function(size) {
        return crypto.getRandomValues(new Uint8Array(size));
    };
}

module.exports = randomByte;

      };
    };
  }
}, {package:"shortid",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\shortid\\lib\\random\\random-byte-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\nanoid\\format.browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\nanoid\format.browser.js
      return function (require, module, exports) {
// This file replaces `format.js` in bundlers like webpack or Rollup,
// according to `browser` config in `package.json`.

module.exports = function (random, alphabet, size) {
  // We can’t use bytes bigger than the alphabet. To make bytes values closer
  // to the alphabet, we apply bitmask on them. We look for the closest
  // `2 ** x - 1` number, which will be bigger than alphabet size. If we have
  // 30 symbols in the alphabet, we will take 31 (00011111).
  // We do not use faster Math.clz32, because it is not available in browsers.
  var mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1
  // Bitmask is not a perfect solution (in our example it will pass 31 bytes,
  // which is bigger than the alphabet). As a result, we will need more bytes,
  // than ID size, because we will refuse bytes bigger than the alphabet.

  // Every hardware random generator call is costly,
  // because we need to wait for entropy collection. This is why often it will
  // be faster to ask for few extra bytes in advance, to avoid additional calls.

  // Here we calculate how many random bytes should we call in advance.
  // It depends on ID length, mask / alphabet size and magic number 1.6
  // (which was selected according benchmarks).

  // -~f => Math.ceil(f) if n is float number
  // -~i => i + 1 if n is integer number
  var step = -~(1.6 * mask * size / alphabet.length)
  var id = ''

  while (true) {
    var bytes = random(step)
    // Compact alternative for `for (var i = 0; i < step; i++)`
    var i = step
    while (i--) {
      // If random byte is bigger than alphabet even after bitmask,
      // we refuse it by `|| ''`.
      id += alphabet[bytes[i] & mask] || ''
      // More compact than `id.length + 1 === size`
      if (id.length === +size) return id
    }
  }
}

      };
    };
  }
}, {package:"nanoid",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\nanoid\\format.browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\background.js", {"../../shared/constants/app":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\app.js","../../shared/constants/metametrics":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\metametrics.js","../../shared/constants/time":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\time.js","./first-time-state":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\first-time-state.js","./lib/createStreamSink":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\createStreamSink.js","./lib/ens-ipfs/setup":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\ens-ipfs\\setup.js","./lib/get-first-preferred-lang-code":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\get-first-preferred-lang-code.js","./lib/getObjStructure":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\getObjStructure.js","./lib/local-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\local-store.js","./lib/migrator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\migrator\\index.js","./lib/network-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\network-store.js","./lib/notification-manager":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\notification-manager.js","./metamask-controller":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\metamask-controller.js","./migrations":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\migrations\\index.js","./platforms/extension":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\platforms\\extension.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","@metamask/obs-store":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\obs-store\\dist\\index.js","@sentry/browser":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\browser\\dist\\index.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","debounce-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\debounce-stream\\index.js","end-of-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\end-of-stream\\index.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js","extension-port-stream":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\extension-port-stream\\dist\\index.js","extensionizer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\extensionizer\\index.js","loglevel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\loglevel\\lib\\loglevel.js","pump":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pump\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\app\scripts\background.js
      return function (require, module, exports) {
(function (process){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _endOfStream = _interopRequireDefault(require("end-of-stream"));

var _pump = _interopRequireDefault(require("pump"));

var _debounceStream = _interopRequireDefault(require("debounce-stream"));

var _loglevel = _interopRequireDefault(require("loglevel"));

var _extensionizer = _interopRequireDefault(require("extensionizer"));

var _obsStore = require("@metamask/obs-store");

var _extensionPortStream = _interopRequireDefault(require("extension-port-stream"));

var _browser = require("@sentry/browser");

var _ethRpcErrors = require("eth-rpc-errors");

var _app = require("../../shared/constants/app");

var _time = require("../../shared/constants/time");

var _metametrics = require("../../shared/constants/metametrics");

var _migrations = _interopRequireDefault(require("./migrations"));

var _migrator = _interopRequireDefault(require("./lib/migrator"));

var _extension = _interopRequireDefault(require("./platforms/extension"));

var _localStore = _interopRequireDefault(require("./lib/local-store"));

var _networkStore = _interopRequireDefault(require("./lib/network-store"));

var _createStreamSink = _interopRequireDefault(require("./lib/createStreamSink"));

var _notificationManager = _interopRequireWildcard(require("./lib/notification-manager"));

var _metamaskController = _interopRequireWildcard(require("./metamask-controller"));

var _firstTimeState = _interopRequireDefault(require("./first-time-state"));

var _getFirstPreferredLangCode = _interopRequireDefault(require("./lib/get-first-preferred-lang-code"));

var _getObjStructure = _interopRequireDefault(require("./lib/getObjStructure"));

var _setup = _interopRequireDefault(require("./lib/ens-ipfs/setup"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/* eslint-enable import/first */
const {
  sentry
} = global;

const firstTimeState = _objectSpread({}, _firstTimeState.default);

_loglevel.default.setDefaultLevel(true ? 'debug' : 'info');

const platform = new _extension.default();
const notificationManager = new _notificationManager.default();
global.METAMASK_NOTIFIER = notificationManager;
let popupIsOpen = false;
let notificationIsOpen = false;
let uiIsTriggering = false;
const openMetamaskTabsIDs = {};
const requestAccountTabIds = {}; // state persistence

const inTest = process.env.IN_TEST;
const localStore = inTest ? new _networkStore.default() : new _localStore.default();
let versionedData;

if (inTest || true) {
  global.metamaskGetState = localStore.get.bind(localStore);
} // initialization flow


initialize().catch(_loglevel.default.error);
/**
 * @typedef {__import__('../../shared/constants/transaction').TransactionMeta} TransactionMeta
 */

/**
 * The data emitted from the MetaMaskController.store EventEmitter, also used to initialize the MetaMaskController. Available in UI on React state as state.metamask.
 *
 * @typedef MetaMaskState
 * @property {boolean} isInitialized - Whether the first vault has been created.
 * @property {boolean} isUnlocked - Whether the vault is currently decrypted and accounts are available for selection.
 * @property {boolean} isAccountMenuOpen - Represents whether the main account selection UI is currently displayed.
 * @property {Object} identities - An object matching lower-case hex addresses to Identity objects with "address" and "name" (nickname) keys.
 * @property {Object} unapprovedTxs - An object mapping transaction hashes to unapproved transactions.
 * @property {Array} frequentRpcList - A list of frequently used RPCs, including custom user-provided ones.
 * @property {Array} addressBook - A list of previously sent to addresses.
 * @property {Object} contractExchangeRates - Info about current token prices.
 * @property {Array} tokens - Tokens held by the current user, including their balances.
 * @property {Object} send - TODO: Document
 * @property {boolean} useBlockie - Indicates preferred user identicon format. True for blockie, false for Jazzicon.
 * @property {Object} featureFlags - An object for optional feature flags.
 * @property {boolean} welcomeScreen - True if welcome screen should be shown.
 * @property {string} currentLocale - A locale string matching the user's preferred display language.
 * @property {Object} provider - The current selected network provider.
 * @property {string} provider.rpcUrl - The address for the RPC API, if using an RPC API.
 * @property {string} provider.type - An identifier for the type of network selected, allows MetaMask to use custom provider strategies for known networks.
 * @property {string} network - A stringified number of the current network ID.
 * @property {Object} accounts - An object mapping lower-case hex addresses to objects with "balance" and "address" keys, both storing hex string values.
 * @property {hex} currentBlockGasLimit - The most recently seen block gas limit, in a lower case hex prefixed string.
 * @property {TransactionMeta[]} currentNetworkTxList - An array of transactions associated with the currently selected network.
 * @property {Object} unapprovedMsgs - An object of messages pending approval, mapping a unique ID to the options.
 * @property {number} unapprovedMsgCount - The number of messages in unapprovedMsgs.
 * @property {Object} unapprovedPersonalMsgs - An object of messages pending approval, mapping a unique ID to the options.
 * @property {number} unapprovedPersonalMsgCount - The number of messages in unapprovedPersonalMsgs.
 * @property {Object} unapprovedEncryptionPublicKeyMsgs - An object of messages pending approval, mapping a unique ID to the options.
 * @property {number} unapprovedEncryptionPublicKeyMsgCount - The number of messages in EncryptionPublicKeyMsgs.
 * @property {Object} unapprovedDecryptMsgs - An object of messages pending approval, mapping a unique ID to the options.
 * @property {number} unapprovedDecryptMsgCount - The number of messages in unapprovedDecryptMsgs.
 * @property {Object} unapprovedTypedMsgs - An object of messages pending approval, mapping a unique ID to the options.
 * @property {number} unapprovedTypedMsgCount - The number of messages in unapprovedTypedMsgs.
 * @property {number} pendingApprovalCount - The number of pending request in the approval controller.
 * @property {string[]} keyringTypes - An array of unique keyring identifying strings, representing available strategies for creating accounts.
 * @property {Keyring[]} keyrings - An array of keyring descriptions, summarizing the accounts that are available for use, and what keyrings they belong to.
 * @property {string} selectedAddress - A lower case hex string of the currently selected address.
 * @property {string} currentCurrency - A string identifying the user's preferred display currency, for use in showing conversion rates.
 * @property {number} conversionRate - A number representing the current exchange rate from the user's preferred currency to Ether.
 * @property {number} conversionDate - A unix epoch date (ms) for the time the current conversion rate was last retrieved.
 * @property {boolean} forgottenPassword - Returns true if the user has initiated the password recovery screen, is recovering from seed phrase.
 */

/**
 * @typedef VersionedData
 * @property {MetaMaskState} data - The data emitted from MetaMask controller, or used to initialize it.
 * @property {number} version - The latest migration version that has been run.
 */

/**
 * Initializes the MetaMask controller, and sets up all platform configuration.
 *
 * @returns {Promise} Setup complete.
 */

async function initialize() {
  const initState = await loadStateFromPersistence();
  const initLangCode = await (0, _getFirstPreferredLangCode.default)();
  await setupController(initState, initLangCode);

  _loglevel.default.info('MetaMask initialization complete.');
} //
// State and Persistence
//

/**
 * Loads any stored data, prioritizing the latest storage strategy.
 * Migrates that data schema in case it was last loaded on an older version.
 *
 * @returns {Promise<MetaMaskState>} Last data emitted from previous instance of MetaMask.
 */


async function loadStateFromPersistence() {
  // migrations
  const migrator = new _migrator.default({
    migrations: _migrations.default
  });
  migrator.on('error', console.warn); // read from disk
  // first from preferred, async API:

  versionedData = (await localStore.get()) || migrator.generateInitialState(firstTimeState); // check if somehow state is empty
  // this should never happen but new error reporting suggests that it has
  // for a small number of users
  // https://github.com/metamask/metamask-extension/issues/3919

  if (versionedData && !versionedData.data) {
    // unable to recover, clear state
    versionedData = migrator.generateInitialState(firstTimeState);
    sentry.captureMessage('MetaMask - Empty vault found - unable to recover');
  } // report migration errors to sentry


  migrator.on('error', err => {
    // get vault structure without secrets
    const vaultStructure = (0, _getObjStructure.default)(versionedData);
    sentry.captureException(err, {
      // "extra" key is required by Sentry
      extra: {
        vaultStructure
      }
    });
  }); // migrate data

  versionedData = await migrator.migrateData(versionedData);

  if (!versionedData) {
    throw new Error('MetaMask - migrator returned undefined');
  } // write to disk


  if (localStore.isSupported) {
    localStore.set(versionedData);
  } else {
    // throw in setTimeout so as to not block boot
    setTimeout(() => {
      throw new Error('MetaMask - Localstore not supported');
    });
  } // return just the data


  return versionedData.data;
}
/**
 * Initializes the MetaMask Controller with any initial state and default language.
 * Configures platform-specific error reporting strategy.
 * Streams emitted state updates to platform-specific storage strategy.
 * Creates platform listeners for new Dapps/Contexts, and sets up their data connections to the controller.
 *
 * @param {Object} initState - The initial state to start the controller with, matches the state that is emitted from the controller.
 * @param {string} initLangCode - The region code for the language preferred by the current user.
 * @returns {Promise} After setup is complete.
 */


function setupController(initState, initLangCode) {
  //
  // MetaMask Controller
  //
  const controller = new _metamaskController.default({
    infuraProjectId: process.env.INFURA_PROJECT_ID,
    // User confirmation callbacks:
    showUserConfirmation: triggerUi,
    openPopup,
    // initial state
    initState,
    // initial locale code
    initLangCode,
    // platform specific api
    platform,
    notificationManager,
    extension: _extensionizer.default,
    getRequestAccountTabIds: () => {
      return requestAccountTabIds;
    },
    getOpenMetamaskTabsIds: () => {
      return openMetamaskTabsIDs;
    }
  });
  (0, _setup.default)({
    getCurrentChainId: controller.networkController.getCurrentChainId.bind(controller.networkController),
    getIpfsGateway: controller.preferencesController.getIpfsGateway.bind(controller.preferencesController),
    provider: controller.provider
  }); // setup state persistence

  (0, _pump.default)((0, _obsStore.storeAsStream)(controller.store), (0, _debounceStream.default)(1000), (0, _obsStore.storeTransformStream)(versionifyData), (0, _createStreamSink.default)(persistData), error => {
    _loglevel.default.error('MetaMask - Persistence pipeline failed', error);
  });
  /**
   * Assigns the given state to the versioned object (with metadata), and returns that.
   *
   * @param {Object} state - The state object as emitted by the MetaMaskController.
   * @returns {VersionedData} The state object wrapped in an object that includes a metadata key.
   */

  function versionifyData(state) {
    versionedData.data = state;
    return versionedData;
  }

  let dataPersistenceFailing = false;

  async function persistData(state) {
    if (!state) {
      throw new Error('MetaMask - updated state is missing');
    }

    if (!state.data) {
      throw new Error('MetaMask - updated state does not have data');
    }

    if (localStore.isSupported) {
      try {
        await localStore.set(state);

        if (dataPersistenceFailing) {
          dataPersistenceFailing = false;
        }
      } catch (err) {
        // log error so we dont break the pipeline
        if (!dataPersistenceFailing) {
          dataPersistenceFailing = true;
          (0, _browser.captureException)(err);
        }

        _loglevel.default.error('error setting state in local store:', err);
      }
    }
  } //
  // connect to other contexts
  //


  _extensionizer.default.runtime.onConnect.addListener(connectRemote);

  _extensionizer.default.runtime.onConnectExternal.addListener(connectExternal);

  const metamaskInternalProcessHash = {
    [_app.ENVIRONMENT_TYPE_POPUP]: true,
    [_app.ENVIRONMENT_TYPE_NOTIFICATION]: true,
    [_app.ENVIRONMENT_TYPE_FULLSCREEN]: true
  };
  const metamaskBlockedPorts = ['trezor-connect'];

  const isClientOpenStatus = () => {
    return popupIsOpen || Boolean(Object.keys(openMetamaskTabsIDs).length) || notificationIsOpen;
  };

  const onCloseEnvironmentInstances = (isClientOpen, environmentType) => {
    // if all instances of metamask are closed we call a method on the controller to stop gasFeeController polling
    if (isClientOpen === false) {
      controller.onClientClosed(); // otherwise we want to only remove the polling tokens for the environment type that has closed
    } else {
      // in the case of fullscreen environment a user might have multiple tabs open so we don't want to disconnect all of
      // its corresponding polling tokens unless all tabs are closed.
      if (environmentType === _app.ENVIRONMENT_TYPE_FULLSCREEN && Boolean(Object.keys(openMetamaskTabsIDs).length)) {
        return;
      }

      controller.onEnvironmentTypeClosed(environmentType);
    }
  };
  /**
   * A runtime.Port object, as provided by the browser:
   *
   * @see https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/runtime/Port
   * @typedef Port
   * @type Object
   */

  /**
   * Connects a Port to the MetaMask controller via a multiplexed duplex stream.
   * This method identifies trusted (MetaMask) interfaces, and connects them differently from untrusted (web pages).
   *
   * @param {Port} remotePort - The port provided by a new context.
   */


  function connectRemote(remotePort) {
    const processName = remotePort.name;
    const isMetaMaskInternalProcess = metamaskInternalProcessHash[processName];

    if (metamaskBlockedPorts.includes(remotePort.name)) {
      return;
    }

    if (isMetaMaskInternalProcess) {
      const portStream = new _extensionPortStream.default(remotePort); // communication with popup

      controller.isClientOpen = true;
      controller.setupTrustedCommunication(portStream, remotePort.sender);

      if (processName === _app.ENVIRONMENT_TYPE_POPUP) {
        popupIsOpen = true;
        (0, _endOfStream.default)(portStream, () => {
          popupIsOpen = false;
          const isClientOpen = isClientOpenStatus();
          controller.isClientOpen = isClientOpen;
          onCloseEnvironmentInstances(isClientOpen, _app.ENVIRONMENT_TYPE_POPUP);
        });
      }

      if (processName === _app.ENVIRONMENT_TYPE_NOTIFICATION) {
        notificationIsOpen = true;
        (0, _endOfStream.default)(portStream, () => {
          notificationIsOpen = false;
          const isClientOpen = isClientOpenStatus();
          controller.isClientOpen = isClientOpen;
          onCloseEnvironmentInstances(isClientOpen, _app.ENVIRONMENT_TYPE_NOTIFICATION);
        });
      }

      if (processName === _app.ENVIRONMENT_TYPE_FULLSCREEN) {
        const tabId = remotePort.sender.tab.id;
        openMetamaskTabsIDs[tabId] = true;
        (0, _endOfStream.default)(portStream, () => {
          delete openMetamaskTabsIDs[tabId];
          const isClientOpen = isClientOpenStatus();
          controller.isClientOpen = isClientOpen;
          onCloseEnvironmentInstances(isClientOpen, _app.ENVIRONMENT_TYPE_FULLSCREEN);
        });
      }
    } else {
      if (remotePort.sender && remotePort.sender.tab && remotePort.sender.url) {
        const tabId = remotePort.sender.tab.id;
        const url = new URL(remotePort.sender.url);
        const {
          origin
        } = url;
        remotePort.onMessage.addListener(msg => {
          if (msg.data && msg.data.method === 'eth_requestAccounts') {
            requestAccountTabIds[origin] = tabId;
          }
        });
      }

      connectExternal(remotePort);
    }
  } // communication with page or other extension


  function connectExternal(remotePort) {
    const portStream = new _extensionPortStream.default(remotePort);
    controller.setupUntrustedCommunication({
      connectionStream: portStream,
      sender: remotePort.sender
    });
  } //
  // User Interface setup
  //


  updateBadge();
  controller.txController.on(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE, updateBadge);
  controller.messageManager.on(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE, updateBadge);
  controller.personalMessageManager.on(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE, updateBadge);
  controller.decryptMessageManager.on(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE, updateBadge);
  controller.encryptionPublicKeyManager.on(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE, updateBadge);
  controller.typedMessageManager.on(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE, updateBadge);
  controller.appStateController.on(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE, updateBadge);
  controller.controllerMessenger.subscribe(_metamaskController.METAMASK_CONTROLLER_EVENTS.APPROVAL_STATE_CHANGE, updateBadge);
  /**
   * Updates the Web Extension's "badge" number, on the little fox in the toolbar.
   * The number reflects the current number of pending transactions or message signatures needing user approval.
   */

  function updateBadge() {
    let label = '';
    const count = getUnapprovedTransactionCount();

    if (count) {
      label = String(count);
    }

    _extensionizer.default.browserAction.setBadgeText({
      text: label
    });

    _extensionizer.default.browserAction.setBadgeBackgroundColor({
      color: '#037DD6'
    });
  }

  function getUnapprovedTransactionCount() {
    const unapprovedTxCount = controller.txController.getUnapprovedTxCount();
    const {
      unapprovedMsgCount
    } = controller.messageManager;
    const {
      unapprovedPersonalMsgCount
    } = controller.personalMessageManager;
    const {
      unapprovedDecryptMsgCount
    } = controller.decryptMessageManager;
    const {
      unapprovedEncryptionPublicKeyMsgCount
    } = controller.encryptionPublicKeyManager;
    const {
      unapprovedTypedMessagesCount
    } = controller.typedMessageManager;
    const pendingApprovalCount = controller.approvalController.getTotalApprovalCount();
    const waitingForUnlockCount = controller.appStateController.waitingForUnlock.length;
    return unapprovedTxCount + unapprovedMsgCount + unapprovedPersonalMsgCount + unapprovedDecryptMsgCount + unapprovedEncryptionPublicKeyMsgCount + unapprovedTypedMessagesCount + pendingApprovalCount + waitingForUnlockCount;
  }

  notificationManager.on(_notificationManager.NOTIFICATION_MANAGER_EVENTS.POPUP_CLOSED, ({
    automaticallyClosed
  }) => {
    if (!automaticallyClosed) {
      rejectUnapprovedNotifications();
    } else if (getUnapprovedTransactionCount() > 0) {
      triggerUi();
    }
  });

  function rejectUnapprovedNotifications() {
    Object.keys(controller.txController.txStateManager.getUnapprovedTxList()).forEach(txId => controller.txController.txStateManager.setTxStatusRejected(txId));
    controller.messageManager.messages.filter(msg => msg.status === 'unapproved').forEach(tx => controller.messageManager.rejectMsg(tx.id, _metametrics.REJECT_NOTFICIATION_CLOSE_SIG));
    controller.personalMessageManager.messages.filter(msg => msg.status === 'unapproved').forEach(tx => controller.personalMessageManager.rejectMsg(tx.id, _metametrics.REJECT_NOTFICIATION_CLOSE_SIG));
    controller.typedMessageManager.messages.filter(msg => msg.status === 'unapproved').forEach(tx => controller.typedMessageManager.rejectMsg(tx.id, _metametrics.REJECT_NOTFICIATION_CLOSE_SIG));
    controller.decryptMessageManager.messages.filter(msg => msg.status === 'unapproved').forEach(tx => controller.decryptMessageManager.rejectMsg(tx.id, _metametrics.REJECT_NOTFICIATION_CLOSE));
    controller.encryptionPublicKeyManager.messages.filter(msg => msg.status === 'unapproved').forEach(tx => controller.encryptionPublicKeyManager.rejectMsg(tx.id, _metametrics.REJECT_NOTFICIATION_CLOSE)); // Finally, reject all approvals managed by the ApprovalController

    controller.approvalController.clear(_ethRpcErrors.ethErrors.provider.userRejectedRequest());
    updateBadge();
  }

  return Promise.resolve();
} //
// Etc...
//

/**
 * Opens the browser popup for user confirmation
 */


async function triggerUi() {
  const tabs = await platform.getActiveTabs();
  const currentlyActiveMetamaskTab = Boolean(tabs.find(tab => openMetamaskTabsIDs[tab.id])); // Vivaldi is not closing port connection on popup close, so popupIsOpen does not work correctly
  // To be reviewed in the future if this behaviour is fixed - also the way we determine isVivaldi variable might change at some point

  const isVivaldi = tabs.length > 0 && tabs[0].extData && tabs[0].extData.indexOf('vivaldi_tab') > -1;

  if (!uiIsTriggering && (isVivaldi || !popupIsOpen) && !currentlyActiveMetamaskTab) {
    uiIsTriggering = true;

    try {
      await notificationManager.showPopup();
    } finally {
      uiIsTriggering = false;
    }
  }
}
/**
 * Opens the browser popup for user confirmation of watchAsset
 * then it waits until user interact with the UI
 */


async function openPopup() {
  await triggerUi();
  await new Promise(resolve => {
    const interval = setInterval(() => {
      if (!notificationIsOpen) {
        clearInterval(interval);
        resolve();
      }
    }, _time.SECOND);
  });
} // On first install, open a new tab with MetaMask


_extensionizer.default.runtime.onInstalled.addListener(({
  reason
}) => {
  if (reason === 'install' && !(true || process.env.IN_TEST)) {
    platform.openExtensionInBrowser();
  }
});


}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\background.js",}]],["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\background.js"],{})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi94NTA5LmpzIiwibm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3BrY3M3YXNuMS5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLWJpdHN3YXAvbm9kZV9tb2R1bGVzL211bHRpaGFzaGluZy1hc3luYy9zcmMvY3J5cHRvLmpzIiwibm9kZV9tb2R1bGVzL3B1bGwtcmVhZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1yZWNvcmQvc3JjL3NlbGVjdG9ycy9wdWJsaWMta2V5LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci1pbmRleG9mL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1yZWNvcmQvc3JjL3ZhbGlkYXRvcnMvcHVibGljLWtleS5qcyIsIm5vZGVfbW9kdWxlcy9wdWxsLXdzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlbGF0aXZlLXVybC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wdWxsLXdzL3NpbmsuanMiLCJub2RlX21vZHVsZXMvcHVsbC13cy9zb3VyY2UuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWthZC1kaHQvc3JjL3BlZXItbGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAta2FkLWRodC9ub2RlX21vZHVsZXMvbXVsdGloYXNoaW5nLWFzeW5jL3NyYy9jcnlwdG8uanMiLCJub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAta2FkLWRodC9zcmMvcGVlci1kaXN0YW5jZS1saXN0LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1rYWQtZGh0L3NyYy9xdWVyeS93b3JrZXJRdWV1ZS5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAta2FkLWRodC9zcmMvcXVlcnkvcGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAta2FkLWRodC9zcmMvcnBjL2hhbmRsZXJzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC13ZWJzb2NrZXQtc3Rhci9zcmMvZXJyb3JzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1wdWxsLXN0cmVhbS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHVsbC1wYWlyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1zZWNpby9zcmMvc3VwcG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtc2VjaW8vc3JjL2hhbmRzaGFrZS9jcnlwdG8uanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXNlY2lvL3NyYy9ldG0uanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXBlZXIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1wZWVyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUuanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXBlZXIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXBlZXIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtcGVlci9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtcGVlci9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1wZWVyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvcGFyc2V1cmkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvb24uanMiLCJub2RlX21vZHVsZXMvY29tcG9uZW50LWJpbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGFyc2Vxcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90by1hcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oYXMtYmluYXJ5Mi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvZGVidWcuanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2lzLWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2JpbmFyeS5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9iYWNrbzIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW5kZXhvZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtcGluZy9zcmMvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1waW5nL3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1mbG9vZHN1Yi9zcmMvY29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1wdWJzdWIvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xhdGVuY3ktbW9uaXRvci9kaXN0L0xhdGVuY3lNb25pdG9yLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1zd2l0Y2gvc3JjL29ic2VydmUtY29ubmVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtc3dpdGNoL3NyYy9jb25uZWN0aW9uL2luY29taW5nLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1zd2l0Y2gvc3JjL3N0YXRzL29sZC1wZWVycy5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtc3dpdGNoL3NyYy9zdGF0cy9zdGF0LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1zd2l0Y2gvc3JjL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtc3dpdGNoL3NyYy9kaWFsZXIvcXVldWVNYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1zd2l0Y2gvc3JjL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL211bHRpc3RyZWFtLXNlbGVjdC9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXN3aXRjaC9zcmMvY29ubmVjdGlvbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtaWRlbnRpZnkvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1zd2l0Y2gvc3JjL2xpbWl0LWRpYWxlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtY2lyY3VpdC9zcmMvY2lyY3VpdC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1leHBvcnRlci9zcmMvdXRpbHMvZXh0cmFjdC1kYXRhLWZyb20tYmxvY2suanMiLCJub2RlX21vZHVsZXMvaXBmcy11bml4ZnMtZXhwb3J0ZXIvc3JjL3V0aWxzL3ZhbGlkYXRlLW9mZnNldC1hbmQtbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWV4cG9ydGVyL3NyYy9yZXNvbHZlcnMvdW5peGZzLXYxL2NvbnRlbnQvZGlyZWN0b3J5LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWV4cG9ydGVyL3NyYy9yZXNvbHZlcnMvdW5peGZzLXYxL2NvbnRlbnQvaGFtdC1zaGFyZGVkLWRpcmVjdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1leHBvcnRlci9zcmMvcmVzb2x2ZXJzL3VuaXhmcy12MS9jb250ZW50L2ZpbGUuanMiLCJub2RlX21vZHVsZXMvaXBmcy11bml4ZnMtZXhwb3J0ZXIvc3JjL3V0aWxzL2ZpbmQtY2lkLWluLXNoYXJkLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtdXRpbHMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9lcnJvcnMtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXV0aWxzL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaXBmcy11dGlscy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtdXRpbHMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9mcm9tLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaXBmcy11dGlscy9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0LmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtdXRpbHMvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9hc3luY19pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1pbXBvcnRlci9zcmMvdXRpbHMvcGVyc2lzdC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1pbXBvcnRlci9zcmMvZGlyLXNoYXJkZWQuanMiLCJub2RlX21vZHVsZXMvaXBmcy11bml4ZnMtaW1wb3J0ZXIvc3JjL2RhZy1idWlsZGVyL2ZpbGUvZmxhdC5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLXVuaXhmcy1pbXBvcnRlci9zcmMvZGFnLWJ1aWxkZXIvZmlsZS90cmlja2xlLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWltcG9ydGVyL3NyYy9kYWctYnVpbGRlci9maWxlL2JhbGFuY2VkLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtdW5peGZzLWltcG9ydGVyL3NyYy9jaHVua2VyL2ZpeGVkLXNpemUuanMiLCJub2RlX21vZHVsZXMvaXBmcy11bml4ZnMtaW1wb3J0ZXIvc3JjL2NodW5rZXIvcmFiaW4uanMiLCJub2RlX21vZHVsZXMvaXBmcy1tZnMvc3JjL2NvcmUvdXRpbHMvaGFtdC11dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9taXNlLXRpbWVvdXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JzZXJ2YWJsZS13ZWJ3b3JrZXJzL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb3J0aWNlL2xpYi9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL21vcnRpY2UvbGliL25vZGUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2tleS10cmVlL25vZGVfbW9kdWxlcy9iaXAzOS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZW5jb2RpbmctZG93bi9ub2RlX21vZHVsZXMvYWJzdHJhY3QtbGV2ZWxkb3duL25leHQtdGljay1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2VuY29kaW5nLWRvd24vbm9kZV9tb2R1bGVzL2xldmVsLXN1cHBvcnRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1jcnlwdG8vbm9kZV9tb2R1bGVzL3NlY3AyNTZrMS9saWIvanMvZWNqcG9pbnQuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWNyeXB0by9ub2RlX21vZHVsZXMvc2VjcDI1NmsxL2xpYi9qcy9ibi9vcHRpbWl6ZWQuanMiLCJub2RlX21vZHVsZXMvZHJiZy5qcy9saWIvaGFzaC1pbmZvLmpzb24iLCJub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcHNzLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL21nZi5qcyIsIm5vZGVfbW9kdWxlcy9pcGZzLWJpdHN3YXAvbm9kZV9tb2R1bGVzL211bHRpaGFzaGluZy1hc3luYy9zcmMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvaXBmcy1iaXRzd2FwL25vZGVfbW9kdWxlcy9tdWx0aWhhc2hpbmctYXN5bmMvc3JjL2JsYWtlLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMtYml0c3dhcC9ub2RlX21vZHVsZXMvbXVsdGloYXNoaW5nLWFzeW5jL3NyYy9jcnlwdG8tc2hhMS0yLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHVsbC1yZWFkZXIvc3RhdGUuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXJlY29yZC9ub2RlX21vZHVsZXMvbXVsdGloYXNoaW5nLWFzeW5jL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wdWxsLXdzL3JlYWR5LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1rYWQtZGh0L25vZGVfbW9kdWxlcy9tdWx0aWhhc2hpbmctYXN5bmMvc3JjL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1rYWQtZGh0L25vZGVfbW9kdWxlcy9tdWx0aWhhc2hpbmctYXN5bmMvc3JjL2JsYWtlLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1rYWQtZGh0L25vZGVfbW9kdWxlcy9tdWx0aWhhc2hpbmctYXN5bmMvc3JjL2NyeXB0by1zaGExLTItYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAta2FkLWRodC9zcmMvcGVlci1xdWV1ZS5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAta2FkLWRodC9zcmMvcnBjL2hhbmRsZXJzL3BpbmcuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWthZC1kaHQvc3JjL3JwYy9oYW5kbGVycy9wdXQtdmFsdWUuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWthZC1kaHQvc3JjL3JwYy9oYW5kbGVycy9hZGQtcHJvdmlkZXIuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWthZC1kaHQvc3JjL3JwYy9oYW5kbGVycy9maW5kLW5vZGUuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWthZC1kaHQvc3JjL3JwYy9oYW5kbGVycy9nZXQtcHJvdmlkZXJzLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1rYWQtZGh0L3NyYy9ycGMvaGFuZGxlcnMvZ2V0LXZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2RhdGEtcXVldWUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLXB1bGwtc3RyZWFtL25vZGVfbW9kdWxlcy91dWlkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1wdWxsLXN0cmVhbS9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXNlY2lvL25vZGVfbW9kdWxlcy9tdWx0aWhhc2hpbmctYXN5bmMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1zZWNpby9zcmMvaGFuZHNoYWtlL3NlY2lvLnByb3RvLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1wZWVyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZXJyb3JzLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXBlZXIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1wZWVyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXBlZXIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtcGVlci9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtcGVlci9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0LmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1wZWVyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvaGFzLWJpbmFyeTIvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2RlYnVnLmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbGliL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvc29ja2V0LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1wdWJzdWIvc3JjL21lc3NhZ2Uvc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtcHVic3ViL3NyYy91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtcHVic3ViL3NyYy9wZWVyLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1wdWJzdWIvc3JjL21lc3NhZ2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGltZS1jYWNoZS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbGF0ZW5jeS1tb25pdG9yL2Rpc3QvVmlzaWJpbGl0eUNoYW5nZUVtaXR0ZXIuanMiLCJub2RlX21vZHVsZXMvbGF0ZW5jeS1tb25pdG9yL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtc3dpdGNoL3NyYy9jb25uZWN0aW9uL2Jhc2UuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXN3aXRjaC9ub2RlX21vZHVsZXMvYmlnbnVtYmVyLmpzL2JpZ251bWJlci5qcyIsIm5vZGVfbW9kdWxlcy9yZXRpbWVyL3JldGltZXIuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXN3aXRjaC9zcmMvZGlhbGVyL3F1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL211bHRpc3RyZWFtLXNlbGVjdC9zcmMvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL211bHRpc3RyZWFtLXNlbGVjdC9zcmMvbGlzdGVuZXIvbWF0Y2gtZXhhY3QuanMiLCJub2RlX21vZHVsZXMvbXVsdGlzdHJlYW0tc2VsZWN0L3NyYy9saXN0ZW5lci9tYXRjaC1zZW12ZXIuanMiLCJub2RlX21vZHVsZXMvbXVsdGlzdHJlYW0tc2VsZWN0L3NyYy9kaWFsZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbXVsdGlzdHJlYW0tc2VsZWN0L3NyYy9saXN0ZW5lci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtaWRlbnRpZnkvc3JjL21lc3NhZ2UuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWlkZW50aWZ5L3NyYy9kaWFsZXIuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWlkZW50aWZ5L3NyYy9saXN0ZW5lci5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtc3dpdGNoL3NyYy9saW1pdC1kaWFsZXIvcXVldWUuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWNpcmN1aXQvc3JjL2NpcmN1aXQvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWNpcmN1aXQvc3JjL2NpcmN1aXQvZGlhbGVyLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1jaXJjdWl0L3NyYy9saXN0ZW5lci5qcyIsIm5vZGVfbW9kdWxlcy9oYW10LXNoYXJkaW5nL3NyYy9idWNrZXQuanMiLCJub2RlX21vZHVsZXMvZGVlcC1leHRlbmQvbGliL2RlZXAtZXh0ZW5kLmpzIiwibm9kZV9tb2R1bGVzL2hhbXQtc2hhcmRpbmcvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jLWl0ZXJhdG9yLWJhdGNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JsL2JsLmpzIiwibm9kZV9tb2R1bGVzL3JhYmluLXdhc20vc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vcnRpY2UvbGliL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9zaG9ydGlkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9rZXktdHJlZS9ub2RlX21vZHVsZXMvYmlwMzkvc3JjL193b3JkbGlzdHMuanMiLCJub2RlX21vZHVsZXMveHRlbmQvbXV0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9tZ2YxLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1yZWNvcmQvbm9kZV9tb2R1bGVzL211bHRpaGFzaGluZy1hc3luYy9zcmMvY3J5cHRvLmpzIiwibm9kZV9tb2R1bGVzL2hlYXAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc29ja2V0LmlvLXB1bGwtc3RyZWFtL25vZGVfbW9kdWxlcy91dWlkL3Y0LmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1wdWxsLXN0cmVhbS9ub2RlX21vZHVsZXMvdXVpZC92MS5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcHVsbC1zdHJlYW0vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXNlY2lvL25vZGVfbW9kdWxlcy9tdWx0aWhhc2hpbmctYXN5bmMvc3JjL2NyeXB0by5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbGliL3V0ZjguanMiLCJub2RlX21vZHVsZXMvYWZ0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmxvYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hcnJheWJ1ZmZlci5zbGljZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYXNlNjQtYXJyYXlidWZmZXIvbGliL2Jhc2U2NC1hcnJheWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnQuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtcHVic3ViL3NyYy9tZXNzYWdlL3JwYy5wcm90by5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtcHVic3ViL3NyYy9tZXNzYWdlL3RvcGljLWRlc2NyaXB0b3IucHJvdG8uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLnRocm90dGxlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xhdGVuY3ktbW9uaXRvci9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2RlYnVnLmpzIiwibm9kZV9tb2R1bGVzL3JldGltZXIvdGltZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL211bHRpc3RyZWFtLXNlbGVjdC9ub2RlX21vZHVsZXMvc2VtdmVyL3NlbXZlci5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aXN0cmVhbS1zZWxlY3Qvc3JjL3V0aWwuanMiLCJub2RlX21vZHVsZXMvbXVsdGlzdHJlYW0tc2VsZWN0L3NyYy9zZWxlY3QuanMiLCJub2RlX21vZHVsZXMvbXVsdGlzdHJlYW0tc2VsZWN0L3NyYy9saXN0ZW5lci9scy1oYW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL211bHRpc3RyZWFtLXNlbGVjdC9zcmMvbGlzdGVuZXIvc2VsZWN0LWhhbmRsZXIuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWNpcmN1aXQvc3JjL3Byb3RvY29sL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1jaXJjdWl0L3NyYy9tdWx0aWNvZGVjLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1jaXJjdWl0L3NyYy9jaXJjdWl0L3N0cmVhbS1oYW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1jaXJjdWl0L3NyYy9jaXJjdWl0L3N0b3AuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLWNpcmN1aXQvc3JjL2NpcmN1aXQvaG9wLmpzIiwibm9kZV9tb2R1bGVzL3NwYXJzZS1hcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oYW10LXNoYXJkaW5nL3NyYy9jb25zdW1hYmxlLWhhc2guanMiLCJub2RlX21vZHVsZXMvYmwvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JhYmluLXdhc20vc3JjL3JhYmluLmpzIiwibm9kZV9tb2R1bGVzL3JhYmluLXdhc20vZGlzdC9yYWJpbi13YXNtLmpzIiwibm9kZV9tb2R1bGVzL3Nob3J0aWQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9rZXktdHJlZS9ub2RlX21vZHVsZXMvYmlwMzkvc3JjL3dvcmRsaXN0cy9jaGluZXNlX3NpbXBsaWZpZWQuanNvbiIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2sva2V5LXRyZWUvbm9kZV9tb2R1bGVzL2JpcDM5L3NyYy93b3JkbGlzdHMvY3plY2guanNvbiIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2sva2V5LXRyZWUvbm9kZV9tb2R1bGVzL2JpcDM5L3NyYy93b3JkbGlzdHMvaXRhbGlhbi5qc29uIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9rZXktdHJlZS9ub2RlX21vZHVsZXMvYmlwMzkvc3JjL3dvcmRsaXN0cy9rb3JlYW4uanNvbiIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2sva2V5LXRyZWUvbm9kZV9tb2R1bGVzL2JpcDM5L3NyYy93b3JkbGlzdHMvamFwYW5lc2UuanNvbiIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2sva2V5LXRyZWUvbm9kZV9tb2R1bGVzL2JpcDM5L3NyYy93b3JkbGlzdHMvY2hpbmVzZV90cmFkaXRpb25hbC5qc29uIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9rZXktdHJlZS9ub2RlX21vZHVsZXMvYmlwMzkvc3JjL3dvcmRsaXN0cy9zcGFuaXNoLmpzb24iLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2tleS10cmVlL25vZGVfbW9kdWxlcy9iaXAzOS9zcmMvd29yZGxpc3RzL3BvcnR1Z3Vlc2UuanNvbiIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2sva2V5LXRyZWUvbm9kZV9tb2R1bGVzL2JpcDM5L3NyYy93b3JkbGlzdHMvZW5nbGlzaC5qc29uIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9rZXktdHJlZS9ub2RlX21vZHVsZXMvYmlwMzkvc3JjL3dvcmRsaXN0cy9mcmVuY2guanNvbiIsIm5vZGVfbW9kdWxlcy9saWJwMnAtcmVjb3JkL25vZGVfbW9kdWxlcy9tdWx0aWhhc2hpbmctYXN5bmMvc3JjL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1yZWNvcmQvbm9kZV9tb2R1bGVzL211bHRpaGFzaGluZy1hc3luYy9zcmMvYmxha2UuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXJlY29yZC9ub2RlX21vZHVsZXMvbXVsdGloYXNoaW5nLWFzeW5jL3NyYy9jcnlwdG8tc2hhMS0yLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaGVhcC9saWIvaGVhcC5qcyIsIm5vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcHVsbC1zdHJlYW0vbm9kZV9tb2R1bGVzL3V1aWQvbGliL2J5dGVzVG9VdWlkLmpzIiwibm9kZV9tb2R1bGVzL3NvY2tldC5pby1wdWxsLXN0cmVhbS9ub2RlX21vZHVsZXMvdXVpZC9saWIvcm5nLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvbGlicDJwLXNlY2lvL25vZGVfbW9kdWxlcy9tdWx0aWhhc2hpbmctYXN5bmMvc3JjL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2xpYnAycC1zZWNpby9ub2RlX21vZHVsZXMvbXVsdGloYXNoaW5nLWFzeW5jL3NyYy9ibGFrZS5qcyIsIm5vZGVfbW9kdWxlcy9saWJwMnAtc2VjaW8vbm9kZV9tb2R1bGVzL211bHRpaGFzaGluZy1hc3luYy9zcmMvY3J5cHRvLXNoYTEtMi1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9kZWJ1Zy5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi94bWxodHRwcmVxdWVzdC5qcyIsIm5vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmctanNvbnAuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy93ZWJzb2NrZXQuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLXhoci5qcyIsIm5vZGVfbW9kdWxlcy9sYXRlbmN5LW1vbml0b3Ivbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL3NvbWUuanMiLCJub2RlX21vZHVsZXMvaGFtdC1zaGFyZGluZy9zcmMvY29uc3VtYWJsZS1idWZmZXIuanMiLCJub2RlX21vZHVsZXMvYmwvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL2JsL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUuanMiLCJub2RlX21vZHVsZXMvYmwvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9ibC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9ibC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9ibC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2JsL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvYXNzZW1ibHlzY3JpcHQvbGliL2xvYWRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaG9ydGlkL2xpYi91dGlsL2NsdXN0ZXItd29ya2VyLWlkLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc2hvcnRpZC9saWIvaXMtdmFsaWQuanMiLCJub2RlX21vZHVsZXMvc2hvcnRpZC9saWIvYWxwaGFiZXQuanMiLCJub2RlX21vZHVsZXMvc2hvcnRpZC9saWIvYnVpbGQuanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvZ2xvYmFsVGhpcy5icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2hhcy1jb3JzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy5qcyIsIm5vZGVfbW9kdWxlcy9jb21wb25lbnQtaW5oZXJpdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy95ZWFzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ibC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2Vycm9ycy1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2JsL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIm5vZGVfbW9kdWxlcy9ibC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2JsL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RhdGUuanMiLCJub2RlX21vZHVsZXMvYmwvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9mcm9tLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYmwvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9idWZmZXJfbGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9ibC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL3Nob3J0aWQvbGliL3JhbmRvbS9yYW5kb20tZnJvbS1zZWVkLmpzIiwibm9kZV9tb2R1bGVzL3Nob3J0aWQvbGliL2dlbmVyYXRlLmpzIiwibm9kZV9tb2R1bGVzL3Nob3J0aWQvbGliL3JhbmRvbS9yYW5kb20tYnl0ZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL25hbm9pZC9mb3JtYXQuYnJvd3Nlci5qcyIsImFwcC9zY3JpcHRzL2JhY2tncm91bmQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxcUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDMVpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3hyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25tQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNwV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbGZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4R0E7QUFDQTs7Ozs7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDak5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyTEE7QUFDQTs7Ozs7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDalBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hHQTtBQUNBOzs7Ozs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNqTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM1dUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDLzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNwUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6Q0E7QUFDQTs7Ozs7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN6UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdmJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDNWpEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsZ0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbGdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xnRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsZ0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbGdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xnRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsZ0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbGdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xnRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbGdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzNTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDeHJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbm1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwVUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEdBO0FBQ0E7Ozs7Ozs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQ0EsSUFBQSxlQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLGVBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxRQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLE1BQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxrQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxpQkFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLFlBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsVUFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLGlCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLGVBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxZQUFBLE9BQUEsQ0FBQSxxQkFBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSx1QkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSx1QkFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLFdBQUEsT0FBQSxDQUFBLGlCQUFBLENBQUEsQ0FBQTs7QUFFQSxJQUFBLGdCQUFBLE9BQUEsQ0FBQSxnQkFBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxPQUFBLE9BQUEsQ0FBQSw0QkFBQSxDQUFBLENBQUE7O0FBS0EsSUFBQSxRQUFBLE9BQUEsQ0FBQSw2QkFBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxlQUFBLE9BQUEsQ0FBQSxvQ0FBQSxDQUFBLENBQUE7O0FBSUEsSUFBQSxjQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLGNBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxZQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLGdCQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsYUFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSx1QkFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLGNBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsbUJBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxnQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxxQkFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLG9CQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLHdCQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsdUJBQUEsdUJBQUEsQ0FBQSxPQUFBLENBQUEsNEJBQUEsQ0FBQSxDQUFBLENBQUE7O0FBR0EsSUFBQSxzQkFBQSx1QkFBQSxDQUFBLE9BQUEsQ0FBQSx1QkFBQSxDQUFBLENBQUEsQ0FBQTs7QUFHQSxJQUFBLGtCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLG9CQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsNkJBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEscUNBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxtQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSx1QkFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLFNBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsc0JBQUEsQ0FBQSxDQUFBLENBQUE7Ozs7Ozs7Ozs7O0FBR0EsTUFBTTs7Q0FBQSxHQUFhLE1BQW5CLENBQUE7O0FBQ0EsTUFBTSxpQkFBYyxhQUFBLENBQUEsRUFBQSxFQUFRLGVBQUEsUUFBUixDQUFwQixDQUFBOztBQUVBLFNBQUEsUUFBQSxnQkFBQSxDQUFvQixPQUFPLElBQVAsZUFBQSxHQUE2QixPQUE3QixHQUF1QyxNQUEzRCxDQUFBLENBQUE7O0FBRUEsTUFBTSxXQUFXLElBQUksVUFBQSxRQUFKLEVBQWpCLENBQUE7QUFFQSxNQUFNLHNCQUFzQixJQUFJLG9CQUFBLFFBQUosRUFBNUIsQ0FBQTtBQUNBLE1BQU0sa0JBQU4sR0FBMkIsbUJBQTNCLENBQUE7QUFFQSxJQUFJLGNBQWMsS0FBbEIsQ0FBQTtBQUNBLElBQUkscUJBQXFCLEtBQXpCLENBQUE7QUFDQSxJQUFJLGlCQUFpQixLQUFyQixDQUFBO0FBQ0EsTUFBTSxzQkFBc0IsRUFBNUIsQ0FBQTtBQUNBLE1BQU0sdUJBQXVCLEVBQTdCOztBQUdBLE1BQU0sU0FBUyxPQUFPLElBQVAsUUFBZixDQUFBO0FBQ0EsTUFBTSxhQUFhLE1BQU0sR0FBRyxJQUFJLGFBQUEsUUFBSixFQUFILEdBQWdDLElBQUksV0FBQSxRQUFKLEVBQXpELENBQUE7QUFDQSxJQUFJLGFBQUosQ0FBQTs7QUFFQSxJQUFJLE1BQU0sSUFBSSxPQUFPLElBQVAsZUFBZCxFQUEwQztFQUN4QyxNQUFNLGlCQUFOLEdBQTBCLFVBQVUsSUFBVixLQUFBLENBQW9CLFVBQXBCLENBQTFCLENBQUE7Ozs7QUFJRixVQUFVLEVBQUEsTUFBVixDQUFtQixTQUFBLFFBQUEsTUFBbkIsQ0FBQSxDQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThEQSw0QkFBNEI7RUFDMUIsTUFBTSxZQUFZLE1BQU0sd0JBQXdCLEVBQWhELENBQUE7RUFDQSxNQUFNLGVBQWUsTUFBTSxDQUFBLENBQUEsRUFBQSwwQkFBQSxRQUFBLEdBQTNCLENBQUE7RUFDQSxNQUFNLGVBQWUsQ0FBQyxTQUFELEVBQVksWUFBWixDQUFyQixDQUFBOztFQUNBLFNBQUEsUUFBQSxLQUFBLENBQVMsbUNBQVQsQ0FBQSxDQUFBOzs7Ozs7Ozs7Ozs7O0FBYUYsMENBQTBDOztFQUV4QyxNQUFNLFdBQVcsSUFBSSxTQUFBLFFBQUosQ0FBYTtJQUFFLFlBQUEsV0FBQSxRQUFBO0dBQWYsQ0FBakIsQ0FBQTtFQUNBLFFBQVEsR0FBUixDQUFZLE9BQVosRUFBcUIsT0FBTyxLQUE1QixDQUFBLENBSHdDOzs7RUFPeEMsZ0JBQ0UsQ0FBQyxNQUFNLFVBQVUsSUFBVixFQUFQLEtBQTRCLFFBQVEscUJBQVIsQ0FBOEIsY0FBOUIsQ0FEOUIsQ0FQd0M7Ozs7O0VBY3hDLElBQUksYUFBYSxJQUFJLENBQUMsYUFBYSxLQUFuQyxFQUEwQzs7SUFFeEMsZ0JBQWdCLFFBQVEscUJBQVIsQ0FBOEIsY0FBOUIsQ0FBaEIsQ0FBQTtJQUNBLE1BQU0sZUFBTixDQUFzQixrREFBdEIsQ0FBQSxDQUFBO0dBakJzQzs7O0VBcUJ4QyxRQUFRLEdBQVIsQ0FBWSxPQUFaLEVBQXNCLE9BQVE7O0lBRTVCLE1BQU0saUJBQWlCLENBQUEsQ0FBQSxFQUFBLGdCQUFBLFFBQUEsRUFBZ0IsYUFBaEIsQ0FBdkIsQ0FBQTtJQUNBLE1BQU0saUJBQU4sQ0FBd0IsR0FBeEIsRUFBNkI7O01BRTNCLE9BQU87UUFBRSxjQUFBO09BQUY7S0FGVCxDQUFBLENBQUE7R0FIRixDQUFBLENBckJ3Qzs7RUErQnhDLGdCQUFnQixNQUFNLFFBQVEsWUFBUixDQUFxQixhQUFyQixDQUF0QixDQUFBOztFQUNBLElBQUksQ0FBQyxhQUFMLEVBQW9CO0lBQ2xCLE1BQU0sSUFBSSxLQUFKLENBQVUsd0NBQVYsQ0FBTixDQUFBO0dBakNzQzs7O0VBcUN4QyxJQUFJLFVBQVUsWUFBZCxFQUE0QjtJQUMxQixVQUFVLElBQVYsQ0FBZSxhQUFmLENBQUEsQ0FBQTtHQURGLE1BRU87O0lBRUwsVUFBVSxDQUFDLE1BQU07TUFDZixNQUFNLElBQUksS0FBSixDQUFVLHFDQUFWLENBQU4sQ0FBQTtLQURRLENBQVYsQ0FBQTtHQXpDc0M7OztFQStDeEMsT0FBTyxhQUFhLEtBQXBCLENBQUE7Q0FDRDs7Ozs7Ozs7Ozs7OztBQVlELGtEQUFrRDs7OztFQUtoRCxNQUFNLGFBQWEsSUFBSSxtQkFBQSxRQUFKLENBQXVCO0lBQ3hDLGlCQUFpQixPQUFPLElBQVAsa0JBRHVCOztJQUd4QyxzQkFBc0IsU0FIa0I7SUFJeEMsU0FKd0M7O0lBTXhDLFNBTndDOztJQVF4QyxZQVJ3Qzs7SUFVeEMsUUFWd0M7SUFXeEMsbUJBWHdDO0lBWXhDLFdBQUEsY0FBQSxRQVp3QztJQWF4Qyx5QkFBeUIsTUFBTTtNQUM3QixPQUFPLG9CQUFQLENBQUE7S0Fkc0M7SUFnQnhDLHdCQUF3QixNQUFNO01BQzVCLE9BQU8sbUJBQVAsQ0FBQTtLQUNEO0dBbEJnQixDQUFuQixDQUFBO0VBcUJBLENBQUEsQ0FBQSxFQUFBLE1BQUEsUUFBQSxFQUFxQjtJQUNuQixtQkFBbUIsVUFBVSxrQkFBVixrQkFBQSxLQUFBLENBQ2pCLFVBQVUsa0JBRE8sQ0FEQTtJQUluQixnQkFBZ0IsVUFBVSxzQkFBVixlQUFBLEtBQUEsQ0FDZCxVQUFVLHNCQURJLENBSkc7SUFPbkIsVUFBVSxVQUFVLFNBQUM7R0FQdkIsQ0FBQSxDQTFCZ0Q7O0VBcUNoRCxDQUFBLENBQUEsRUFBQSxLQUFBLFFBQUEsRUFDRSxDQUFBLENBQUEsRUFBQSxTQUFBLGNBQUEsRUFBYyxVQUFVLE1BQXhCLENBREYsRUFFRSxDQUFBLENBQUEsRUFBQSxlQUFBLFFBQUEsRUFBUyxJQUFULENBRkYsRUFHRSxDQUFBLENBQUEsRUFBQSxTQUFBLHFCQUFBLEVBQXFCLGNBQXJCLENBSEYsRUFJRSxDQUFBLENBQUEsRUFBQSxpQkFBQSxRQUFBLEVBQWlCLFdBQWpCLENBSkYsRUFLRyxTQUFVO0lBQ1QsU0FBQSxRQUFBLE1BQUEsQ0FBVSx3Q0FBVixFQUFvRCxLQUFwRCxDQUFBLENBQUE7R0FOSixDQUFBLENBQUE7Ozs7Ozs7O0VBZ0JBLCtCQUErQjtJQUM3QixhQUFhLEtBQWIsR0FBcUIsS0FBckIsQ0FBQTtJQUNBLE9BQU8sYUFBUCxDQUFBO0dBQ0Q7O0VBRUQsSUFBSSx5QkFBeUIsS0FBN0IsQ0FBQTs7RUFFQSxrQ0FBa0M7SUFDaEMsSUFBSSxDQUFDLEtBQUwsRUFBWTtNQUNWLE1BQU0sSUFBSSxLQUFKLENBQVUscUNBQVYsQ0FBTixDQUFBO0tBQ0Q7O0lBQ0QsSUFBSSxDQUFDLEtBQUssS0FBVixFQUFpQjtNQUNmLE1BQU0sSUFBSSxLQUFKLENBQVUsNkNBQVYsQ0FBTixDQUFBO0tBQ0Q7O0lBQ0QsSUFBSSxVQUFVLFlBQWQsRUFBNEI7TUFDMUIsSUFBSTtRQUNGLE1BQU0sVUFBVSxJQUFWLENBQWUsS0FBZixDQUFOLENBQUE7O1FBQ0EsSUFBSSxzQkFBSixFQUE0QjtVQUMxQix5QkFBeUIsS0FBekIsQ0FBQTtTQUNEO09BSkgsQ0FLRSxZQUFZOztRQUVaLElBQUksQ0FBQyxzQkFBTCxFQUE2QjtVQUMzQix5QkFBeUIsSUFBekIsQ0FBQTtVQUNBLENBQUEsQ0FBQSxFQUFBLFFBQUEsaUJBQUEsRUFBaUIsR0FBakIsQ0FBQSxDQUFBO1NBQ0Q7O1FBQ0QsU0FBQSxRQUFBLE1BQUEsQ0FBVSxxQ0FBVixFQUFpRCxHQUFqRCxDQUFBLENBQUE7T0FDRDtLQUNGO0dBakY2Qzs7Ozs7RUF1RmhELGNBQUEsUUFBQSxRQUFBLFVBQUEsWUFBQSxDQUF3QyxhQUF4QyxDQUFBLENBQUE7O0VBQ0EsY0FBQSxRQUFBLFFBQUEsa0JBQUEsWUFBQSxDQUFnRCxlQUFoRCxDQUFBLENBQUE7O0VBRUEsTUFBTSw4QkFBOEI7SUFDbEMsQ0FBQyxJQUFBLHVCQUFELEdBQTBCLElBRFE7SUFFbEMsQ0FBQyxJQUFBLDhCQUFELEdBQWlDLElBRkM7SUFHbEMsQ0FBQyxJQUFBLDRCQUFELEdBQStCLElBQUE7R0FIakMsQ0FBQTtFQU1BLE1BQU0sdUJBQXVCLENBQUMsZ0JBQUQsQ0FBN0IsQ0FBQTs7RUFFQSxNQUFNLHFCQUFxQixNQUFNO0lBQy9CLE9BQ0UsV0FBVyxJQUNYLE9BQU8sQ0FBQyxNQUFNLEtBQU4sQ0FBWSxtQkFBWixDQUFBLE9BQUQsQ0FEUCxJQUVBLGtCQUhGLENBQUE7R0FERixDQUFBOztFQVFBLE1BQU0sOEJBQThCLG1DQUFtQzs7SUFFckUsSUFBSSxZQUFZLEtBQUssS0FBckIsRUFBNEI7TUFDMUIsVUFBVSxlQUFWLEVBQUEsQ0FEMEI7S0FBNUIsTUFHTzs7O01BR0wsSUFDRSxlQUFlLEtBQUssSUFBQSw0QkFBcEIsSUFDQSxPQUFPLENBQUMsTUFBTSxLQUFOLENBQVksbUJBQVosQ0FBQSxPQUFELENBRlQsRUFHRTtRQUNBLE9BQUE7T0FDRDs7TUFDRCxVQUFVLHdCQUFWLENBQW1DLGVBQW5DLENBQUEsQ0FBQTtLQUNEO0dBZkgsQ0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFnQ0EsbUNBQW1DO0lBQ2pDLE1BQU0sY0FBYyxVQUFVLEtBQTlCLENBQUE7SUFDQSxNQUFNLDRCQUE0QiwyQkFBMkIsQ0FBQyxXQUFELENBQTdELENBQUE7O0lBRUEsSUFBSSxvQkFBb0IsU0FBcEIsQ0FBOEIsVUFBVSxLQUF4QyxDQUFKLEVBQW9EO01BQ2xELE9BQUE7S0FDRDs7SUFFRCxJQUFJLHlCQUFKLEVBQStCO01BQzdCLE1BQU0sYUFBYSxJQUFJLG9CQUFBLFFBQUosQ0FBZSxVQUFmLENBQW5CLENBRDZCOztNQUc3QixVQUFVLGFBQVYsR0FBMEIsSUFBMUIsQ0FBQTtNQUNBLFVBQVUsMEJBQVYsQ0FBcUMsVUFBckMsRUFBaUQsVUFBVSxPQUEzRCxDQUFBLENBQUE7O01BRUEsSUFBSSxXQUFXLEtBQUssSUFBQSx1QkFBcEIsRUFBNEM7UUFDMUMsY0FBYyxJQUFkLENBQUE7UUFDQSxDQUFBLENBQUEsRUFBQSxZQUFBLFFBQUEsRUFBWSxVQUFaLEVBQXdCLE1BQU07VUFDNUIsY0FBYyxLQUFkLENBQUE7VUFDQSxNQUFNLGVBQWUsa0JBQWtCLEVBQXZDLENBQUE7VUFDQSxVQUFVLGFBQVYsR0FBMEIsWUFBMUIsQ0FBQTtVQUNBLDJCQUEyQixDQUFDLFlBQUQsRUFBZSxJQUFBLHVCQUFmLENBQTNCLENBQUE7U0FKRixDQUFBLENBQUE7T0FNRDs7TUFFRCxJQUFJLFdBQVcsS0FBSyxJQUFBLDhCQUFwQixFQUFtRDtRQUNqRCxxQkFBcUIsSUFBckIsQ0FBQTtRQUVBLENBQUEsQ0FBQSxFQUFBLFlBQUEsUUFBQSxFQUFZLFVBQVosRUFBd0IsTUFBTTtVQUM1QixxQkFBcUIsS0FBckIsQ0FBQTtVQUNBLE1BQU0sZUFBZSxrQkFBa0IsRUFBdkMsQ0FBQTtVQUNBLFVBQVUsYUFBVixHQUEwQixZQUExQixDQUFBO1VBQ0EsMkJBQTJCLENBQ3pCLFlBRHlCLEVBRXpCLElBQUEsOEJBRnlCLENBQTNCLENBQUE7U0FKRixDQUFBLENBQUE7T0FTRDs7TUFFRCxJQUFJLFdBQVcsS0FBSyxJQUFBLDRCQUFwQixFQUFpRDtRQUMvQyxNQUFNLFFBQVEsVUFBVSxPQUFWLElBQUEsR0FBZCxDQUFBO1FBQ0EsbUJBQW1CLENBQUMsS0FBRCxDQUFuQixHQUE2QixJQUE3QixDQUFBO1FBRUEsQ0FBQSxDQUFBLEVBQUEsWUFBQSxRQUFBLEVBQVksVUFBWixFQUF3QixNQUFNO1VBQzVCLE9BQU8sbUJBQW1CLENBQUMsS0FBRCxDQUExQixDQUFBO1VBQ0EsTUFBTSxlQUFlLGtCQUFrQixFQUF2QyxDQUFBO1VBQ0EsVUFBVSxhQUFWLEdBQTBCLFlBQTFCLENBQUE7VUFDQSwyQkFBMkIsQ0FDekIsWUFEeUIsRUFFekIsSUFBQSw0QkFGeUIsQ0FBM0IsQ0FBQTtTQUpGLENBQUEsQ0FBQTtPQVNEO0tBM0NILE1BNENPO01BQ0wsSUFBSSxVQUFVLE9BQVYsSUFBcUIsVUFBVSxPQUFWLElBQXJCLElBQThDLFVBQVUsT0FBVixJQUFsRCxFQUF5RTtRQUN2RSxNQUFNLFFBQVEsVUFBVSxPQUFWLElBQUEsR0FBZCxDQUFBO1FBQ0EsTUFBTSxNQUFNLElBQUksR0FBSixDQUFRLFVBQVUsT0FBVixJQUFSLENBQVosQ0FBQTtRQUNBLE1BQU07O1NBQUEsR0FBYSxHQUFuQixDQUFBO1FBRUEsVUFBVSxVQUFWLFlBQUEsQ0FBa0MsT0FBUTtVQUN4QyxJQUFJLEdBQUcsS0FBSCxJQUFZLEdBQUcsS0FBSCxPQUFBLEtBQW9CLHFCQUFwQyxFQUEyRDtZQUN6RCxvQkFBb0IsQ0FBQyxNQUFELENBQXBCLEdBQStCLEtBQS9CLENBQUE7V0FDRDtTQUhILENBQUEsQ0FBQTtPQUtEOztNQUNELGVBQWUsQ0FBQyxVQUFELENBQWYsQ0FBQTtLQUNEO0dBM002Qzs7O0VBK01oRCxxQ0FBcUM7SUFDbkMsTUFBTSxhQUFhLElBQUksb0JBQUEsUUFBSixDQUFlLFVBQWYsQ0FBbkIsQ0FBQTtJQUNBLFVBQVUsNEJBQVYsQ0FBdUM7TUFDckMsa0JBQWtCLFVBRG1CO01BRXJDLFFBQVEsVUFBVSxPQUFDO0tBRnJCLENBQUEsQ0FBQTtHQWpOOEM7Ozs7O0VBMk5oRCxXQUFXLEVBQUEsQ0FBQTtFQUNYLFVBQVUsYUFBVixHQUFBLENBQ0UsbUJBQUEsMkJBQUEsYUFERixFQUVFLFdBRkYsQ0FBQSxDQUFBO0VBSUEsVUFBVSxlQUFWLEdBQUEsQ0FDRSxtQkFBQSwyQkFBQSxhQURGLEVBRUUsV0FGRixDQUFBLENBQUE7RUFJQSxVQUFVLHVCQUFWLEdBQUEsQ0FDRSxtQkFBQSwyQkFBQSxhQURGLEVBRUUsV0FGRixDQUFBLENBQUE7RUFJQSxVQUFVLHNCQUFWLEdBQUEsQ0FDRSxtQkFBQSwyQkFBQSxhQURGLEVBRUUsV0FGRixDQUFBLENBQUE7RUFJQSxVQUFVLDJCQUFWLEdBQUEsQ0FDRSxtQkFBQSwyQkFBQSxhQURGLEVBRUUsV0FGRixDQUFBLENBQUE7RUFJQSxVQUFVLG9CQUFWLEdBQUEsQ0FDRSxtQkFBQSwyQkFBQSxhQURGLEVBRUUsV0FGRixDQUFBLENBQUE7RUFJQSxVQUFVLG1CQUFWLEdBQUEsQ0FDRSxtQkFBQSwyQkFBQSxhQURGLEVBRUUsV0FGRixDQUFBLENBQUE7RUFLQSxVQUFVLG9CQUFWLFVBQUEsQ0FDRSxtQkFBQSwyQkFBQSxzQkFERixFQUVFLFdBRkYsQ0FBQSxDQUFBOzs7Ozs7RUFTQSx1QkFBdUI7SUFDckIsSUFBSSxRQUFRLEVBQVosQ0FBQTtJQUNBLE1BQU0sUUFBUSw2QkFBNkIsRUFBM0MsQ0FBQTs7SUFDQSxJQUFJLEtBQUosRUFBVztNQUNULFFBQVEsTUFBTSxDQUFDLEtBQUQsQ0FBZCxDQUFBO0tBQ0Q7O0lBQ0QsY0FBQSxRQUFBLGNBQUEsYUFBQSxDQUFxQztNQUFFLE1BQU0sS0FBQTtLQUE3QyxDQUFBLENBQUE7O0lBQ0EsY0FBQSxRQUFBLGNBQUEsd0JBQUEsQ0FBZ0Q7TUFBRSxPQUFPLFNBQUE7S0FBekQsQ0FBQSxDQUFBO0dBQ0Q7O0VBRUQseUNBQXlDO0lBQ3ZDLE1BQU0sb0JBQW9CLFVBQVUsYUFBVixxQkFBQSxFQUExQixDQUFBO0lBQ0EsTUFBTTs7S0FBQSxHQUF5QixVQUFVLGVBQXpDLENBQUE7SUFDQSxNQUFNOztLQUFBLEdBQWlDLFVBQVUsdUJBQWpELENBQUE7SUFDQSxNQUFNOztLQUFBLEdBQWdDLFVBQVUsc0JBQWhELENBQUE7SUFDQSxNQUFNOztLQUFBLEdBRUYsVUFBVSwyQkFGZCxDQUFBO0lBR0EsTUFBTTs7S0FBQSxHQUFtQyxVQUFVLG9CQUFuRCxDQUFBO0lBQ0EsTUFBTSx1QkFBdUIsVUFBVSxtQkFBVixzQkFBQSxFQUE3QixDQUFBO0lBQ0EsTUFBTSx3QkFDSixVQUFVLG1CQUFWLGlCQUFBLE9BREYsQ0FBQTtJQUVBLE9BQ0UsaUJBQWlCLEdBQ2pCLGtCQURBLEdBRUEsMEJBRkEsR0FHQSx5QkFIQSxHQUlBLHFDQUpBLEdBS0EsNEJBTEEsR0FNQSxvQkFOQSxHQU9BLHFCQVJGLENBQUE7R0FVRDs7RUFFRCxtQkFBbUIsR0FBbkIsQ0FDRSxvQkFBQSw0QkFBQSxhQURGLEVBRUUsQ0FBQzs7R0FBRCxLQUE2QjtJQUMzQixJQUFJLENBQUMsbUJBQUwsRUFBMEI7TUFDeEIsNkJBQTZCLEVBQUEsQ0FBQTtLQUQvQixNQUVPLElBQUksNkJBQTZCLEVBQUEsR0FBSyxDQUF0QyxFQUF5QztNQUM5QyxTQUFTLEVBQUEsQ0FBQTtLQUNWO0dBUEwsQ0FBQSxDQUFBOztFQVdBLHlDQUF5QztJQUN2QyxNQUFNLEtBQU4sQ0FDRSxVQUFVLGFBQVYsZUFBQSxvQkFBQSxFQURGLENBQUEsUUFBQSxDQUVXLFFBQ1QsVUFBVSxhQUFWLGVBQUEsb0JBQUEsQ0FBMkQsSUFBM0QsQ0FIRixDQUFBLENBQUE7SUFLQSxVQUFVLGVBQVYsU0FBQSxPQUFBLENBQ1csT0FBUSxHQUFHLE9BQUgsS0FBZSxZQURsQyxDQUFBLFFBQUEsQ0FFWSxNQUNSLFVBQVUsZUFBVixVQUFBLENBQ0UsRUFBRSxHQURKLEVBRUUsWUFBQSw4QkFGRixDQUhKLENBQUEsQ0FBQTtJQVFBLFVBQVUsdUJBQVYsU0FBQSxPQUFBLENBQ1csT0FBUSxHQUFHLE9BQUgsS0FBZSxZQURsQyxDQUFBLFFBQUEsQ0FFWSxNQUNSLFVBQVUsdUJBQVYsVUFBQSxDQUNFLEVBQUUsR0FESixFQUVFLFlBQUEsOEJBRkYsQ0FISixDQUFBLENBQUE7SUFRQSxVQUFVLG9CQUFWLFNBQUEsT0FBQSxDQUNXLE9BQVEsR0FBRyxPQUFILEtBQWUsWUFEbEMsQ0FBQSxRQUFBLENBRVksTUFDUixVQUFVLG9CQUFWLFVBQUEsQ0FDRSxFQUFFLEdBREosRUFFRSxZQUFBLDhCQUZGLENBSEosQ0FBQSxDQUFBO0lBUUEsVUFBVSxzQkFBVixTQUFBLE9BQUEsQ0FDVyxPQUFRLEdBQUcsT0FBSCxLQUFlLFlBRGxDLENBQUEsUUFBQSxDQUVZLE1BQ1IsVUFBVSxzQkFBVixVQUFBLENBQ0UsRUFBRSxHQURKLEVBRUUsWUFBQSwwQkFGRixDQUhKLENBQUEsQ0FBQTtJQVFBLFVBQVUsMkJBQVYsU0FBQSxPQUFBLENBQ1csT0FBUSxHQUFHLE9BQUgsS0FBZSxZQURsQyxDQUFBLFFBQUEsQ0FFWSxNQUNSLFVBQVUsMkJBQVYsVUFBQSxDQUNFLEVBQUUsR0FESixFQUVFLFlBQUEsMEJBRkYsQ0FISixDQUFBLENBdEN1Qzs7SUFnRHZDLFVBQVUsbUJBQVYsTUFBQSxDQUNFLGFBQUEsVUFBQSxTQUFBLG9CQUFBLEVBREYsQ0FBQSxDQUFBO0lBSUEsV0FBVyxFQUFBLENBQUE7R0FDWjs7RUFFRCxPQUFPLE9BQU8sUUFBUCxFQUFQLENBQUE7Ozs7Ozs7Ozs7QUFVRiwyQkFBMkI7RUFDekIsTUFBTSxPQUFPLE1BQU0sUUFBUSxjQUFSLEVBQW5CLENBQUE7RUFDQSxNQUFNLDZCQUE2QixPQUFPLENBQ3hDLElBQUksS0FBSixDQUFXLE9BQVEsbUJBQW1CLENBQUMsR0FBRyxHQUFKLENBQXRDLENBRHdDLENBQTFDLENBRnlCOzs7RUFPekIsTUFBTSxZQUNKLElBQUksT0FBSixHQUFjLENBQWQsSUFDQSxJQUFJLENBQUMsQ0FBRCxDQUFKLFFBREEsSUFFQSxJQUFJLENBQUMsQ0FBRCxDQUFKLFFBQUEsUUFBQSxDQUF3QixhQUF4QixDQUFBLEdBQXlDLENBQUMsQ0FINUMsQ0FBQTs7RUFJQSxJQUNFLENBQUMsY0FBRCxLQUNDLFNBQVMsSUFBSSxDQUFDLFdBRGYsQ0FBQSxJQUVBLENBQUMsMEJBSEgsRUFJRTtJQUNBLGlCQUFpQixJQUFqQixDQUFBOztJQUNBLElBQUk7TUFDRixNQUFNLG1CQUFtQixVQUFuQixFQUFOLENBQUE7S0FERixTQUVVO01BQ1IsaUJBQWlCLEtBQWpCLENBQUE7S0FDRDtHQUNGO0NBQ0Y7Ozs7Ozs7QUFNRCwyQkFBMkI7RUFDekIsTUFBTSxTQUFTLEVBQWYsQ0FBQTtFQUNBLE1BQU0sSUFBSSxPQUFKLENBQWEsV0FBWTtJQUM3QixNQUFNLFdBQVcsV0FBVyxDQUFDLE1BQU07TUFDakMsSUFBSSxDQUFDLGtCQUFMLEVBQXlCO1FBQ3ZCLGFBQWEsQ0FBQyxRQUFELENBQWIsQ0FBQTtRQUNBLE9BQU8sRUFBQSxDQUFBO09BQ1I7S0FKeUIsRUFLekIsS0FBQSxPQUx5QixDQUE1QixDQUFBO0dBREksQ0FBTixDQUFBOzs7O0FBV0YsY0FBQSxRQUFBLFFBQUEsWUFBQSxZQUFBLENBQTBDLENBQUM7O0NBQUQsS0FBZ0I7RUFDeEQsSUFDRSxNQUFNLEtBQUssU0FBWCxJQUNBLEVBQUUsT0FBTyxJQUFQLGVBQUEsSUFBOEIsT0FBTyxJQUFQLFFBQWhDLENBRkYsRUFHRTtJQUNBLFFBQVEsdUJBQVIsRUFBQSxDQUFBO0dBQ0Q7Q0FOSCxDQUFBLENBQUEiLCJmaWxlIjoiYmFja2dyb3VuZC02LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBKYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIFguNTA5IGFuZCByZWxhdGVkIGNvbXBvbmVudHMgKHN1Y2ggYXNcbiAqIENlcnRpZmljYXRpb24gU2lnbmluZyBSZXF1ZXN0cykgb2YgYSBQdWJsaWMgS2V5IEluZnJhc3RydWN0dXJlLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqXG4gKiBUaGUgQVNOLjEgcmVwcmVzZW50YXRpb24gb2YgYW4gWC41MDl2MyBjZXJ0aWZpY2F0ZSBpcyBhcyBmb2xsb3dzXG4gKiAoc2VlIFJGQyAyNDU5KTpcbiAqXG4gKiBDZXJ0aWZpY2F0ZSA6Oj0gU0VRVUVOQ0Uge1xuICogICB0YnNDZXJ0aWZpY2F0ZSAgICAgICBUQlNDZXJ0aWZpY2F0ZSxcbiAqICAgc2lnbmF0dXJlQWxnb3JpdGhtICAgQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgc2lnbmF0dXJlVmFsdWUgICAgICAgQklUIFNUUklOR1xuICogfVxuICpcbiAqIFRCU0NlcnRpZmljYXRlIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHZlcnNpb24gICAgICAgICBbMF0gIEVYUExJQ0lUIFZlcnNpb24gREVGQVVMVCB2MSxcbiAqICAgc2VyaWFsTnVtYmVyICAgICAgICAgQ2VydGlmaWNhdGVTZXJpYWxOdW1iZXIsXG4gKiAgIHNpZ25hdHVyZSAgICAgICAgICAgIEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIGlzc3VlciAgICAgICAgICAgICAgIE5hbWUsXG4gKiAgIHZhbGlkaXR5ICAgICAgICAgICAgIFZhbGlkaXR5LFxuICogICBzdWJqZWN0ICAgICAgICAgICAgICBOYW1lLFxuICogICBzdWJqZWN0UHVibGljS2V5SW5mbyBTdWJqZWN0UHVibGljS2V5SW5mbyxcbiAqICAgaXNzdWVyVW5pcXVlSUQgIFsxXSAgSU1QTElDSVQgVW5pcXVlSWRlbnRpZmllciBPUFRJT05BTCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgLS0gSWYgcHJlc2VudCwgdmVyc2lvbiBzaGFsbCBiZSB2MiBvciB2M1xuICogICBzdWJqZWN0VW5pcXVlSUQgWzJdICBJTVBMSUNJVCBVbmlxdWVJZGVudGlmaWVyIE9QVElPTkFMLFxuICogICAgICAgICAgICAgICAgICAgICAgICAtLSBJZiBwcmVzZW50LCB2ZXJzaW9uIHNoYWxsIGJlIHYyIG9yIHYzXG4gKiAgIGV4dGVuc2lvbnMgICAgICBbM10gIEVYUExJQ0lUIEV4dGVuc2lvbnMgT1BUSU9OQUxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgLS0gSWYgcHJlc2VudCwgdmVyc2lvbiBzaGFsbCBiZSB2M1xuICogfVxuICpcbiAqIFZlcnNpb24gOjo9IElOVEVHRVIgIHsgdjEoMCksIHYyKDEpLCB2MygyKSB9XG4gKlxuICogQ2VydGlmaWNhdGVTZXJpYWxOdW1iZXIgOjo9IElOVEVHRVJcbiAqXG4gKiBOYW1lIDo6PSBDSE9JQ0Uge1xuICogICAvLyBvbmx5IG9uZSBwb3NzaWJsZSBjaG9pY2UgZm9yIG5vd1xuICogICBSRE5TZXF1ZW5jZVxuICogfVxuICpcbiAqIFJETlNlcXVlbmNlIDo6PSBTRVFVRU5DRSBPRiBSZWxhdGl2ZURpc3Rpbmd1aXNoZWROYW1lXG4gKlxuICogUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZSA6Oj0gU0VUIE9GIEF0dHJpYnV0ZVR5cGVBbmRWYWx1ZVxuICpcbiAqIEF0dHJpYnV0ZVR5cGVBbmRWYWx1ZSA6Oj0gU0VRVUVOQ0Uge1xuICogICB0eXBlICAgICBBdHRyaWJ1dGVUeXBlLFxuICogICB2YWx1ZSAgICBBdHRyaWJ1dGVWYWx1ZVxuICogfVxuICogQXR0cmlidXRlVHlwZSA6Oj0gT0JKRUNUIElERU5USUZJRVJcbiAqIEF0dHJpYnV0ZVZhbHVlIDo6PSBBTlkgREVGSU5FRCBCWSBBdHRyaWJ1dGVUeXBlXG4gKlxuICogVmFsaWRpdHkgOjo9IFNFUVVFTkNFIHtcbiAqICAgbm90QmVmb3JlICAgICAgVGltZSxcbiAqICAgbm90QWZ0ZXIgICAgICAgVGltZVxuICogfVxuICpcbiAqIFRpbWUgOjo9IENIT0lDRSB7XG4gKiAgIHV0Y1RpbWUgICAgICAgIFVUQ1RpbWUsXG4gKiAgIGdlbmVyYWxUaW1lICAgIEdlbmVyYWxpemVkVGltZVxuICogfVxuICpcbiAqIFVuaXF1ZUlkZW50aWZpZXIgOjo9IEJJVCBTVFJJTkdcbiAqXG4gKiBTdWJqZWN0UHVibGljS2V5SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICBhbGdvcml0aG0gICAgICAgICAgICBBbGdvcml0aG1JZGVudGlmaWVyLFxuICogICBzdWJqZWN0UHVibGljS2V5ICAgICBCSVQgU1RSSU5HXG4gKiB9XG4gKlxuICogRXh0ZW5zaW9ucyA6Oj0gU0VRVUVOQ0UgU0laRSAoMS4uTUFYKSBPRiBFeHRlbnNpb25cbiAqXG4gKiBFeHRlbnNpb24gOjo9IFNFUVVFTkNFIHtcbiAqICAgZXh0bklEICAgICAgT0JKRUNUIElERU5USUZJRVIsXG4gKiAgIGNyaXRpY2FsICAgIEJPT0xFQU4gREVGQVVMVCBGQUxTRSxcbiAqICAgZXh0blZhbHVlICAgT0NURVQgU1RSSU5HXG4gKiB9XG4gKlxuICogVGhlIG9ubHkga2V5IGFsZ29yaXRobSBjdXJyZW50bHkgc3VwcG9ydGVkIGZvciBQS0kgaXMgUlNBLlxuICpcbiAqIFJTQVNTQS1QU1Mgc2lnbmF0dXJlcyBhcmUgZGVzY3JpYmVkIGluIFJGQyAzNDQ3IGFuZCBSRkMgNDA1NS5cbiAqXG4gKiBQS0NTIzEwIHYxLjcgZGVzY3JpYmVzIGNlcnRpZmljYXRlIHNpZ25pbmcgcmVxdWVzdHM6XG4gKlxuICogQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvOlxuICpcbiAqIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICB2ZXJzaW9uICAgICAgIElOVEVHRVIgeyB2MSgwKSB9ICh2MSwuLi4pLFxuICogICBzdWJqZWN0ICAgICAgIE5hbWUsXG4gKiAgIHN1YmplY3RQS0luZm8gU3ViamVjdFB1YmxpY0tleUluZm97eyBQS0luZm9BbGdvcml0aG1zIH19LFxuICogICBhdHRyaWJ1dGVzICAgIFswXSBBdHRyaWJ1dGVze3sgQ1JJQXR0cmlidXRlcyB9fVxuICogfVxuICpcbiAqIEF0dHJpYnV0ZXMgeyBBVFRSSUJVVEU6SU9TZXQgfSA6Oj0gU0VUIE9GIEF0dHJpYnV0ZXt7IElPU2V0IH19XG4gKlxuICogQ1JJQXR0cmlidXRlcyAgQVRUUklCVVRFICA6Oj0ge1xuICogICAuLi4gLS0gYWRkIGFueSBsb2NhbGx5IGRlZmluZWQgYXR0cmlidXRlcyBoZXJlIC0tIH1cbiAqXG4gKiBBdHRyaWJ1dGUgeyBBVFRSSUJVVEU6SU9TZXQgfSA6Oj0gU0VRVUVOQ0Uge1xuICogICB0eXBlICAgQVRUUklCVVRFLiZpZCh7SU9TZXR9KSxcbiAqICAgdmFsdWVzIFNFVCBTSVpFKDEuLk1BWCkgT0YgQVRUUklCVVRFLiZUeXBlKHtJT1NldH17QHR5cGV9KVxuICogfVxuICpcbiAqIENlcnRpZmljYXRpb25SZXF1ZXN0IDo6PSBTRVFVRU5DRSB7XG4gKiAgIGNlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8sXG4gKiAgIHNpZ25hdHVyZUFsZ29yaXRobSBBbGdvcml0aG1JZGVudGlmaWVye3sgU2lnbmF0dXJlQWxnb3JpdGhtcyB9fSxcbiAqICAgc2lnbmF0dXJlICAgICAgICAgIEJJVCBTVFJJTkdcbiAqIH1cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9hZXMnKTtcbnJlcXVpcmUoJy4vYXNuMScpO1xucmVxdWlyZSgnLi9kZXMnKTtcbnJlcXVpcmUoJy4vbWQnKTtcbnJlcXVpcmUoJy4vbWdmJyk7XG5yZXF1aXJlKCcuL29pZHMnKTtcbnJlcXVpcmUoJy4vcGVtJyk7XG5yZXF1aXJlKCcuL3BzcycpO1xucmVxdWlyZSgnLi9yc2EnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vLyBzaG9ydGN1dCBmb3IgYXNuLjEgQVBJXG52YXIgYXNuMSA9IGZvcmdlLmFzbjE7XG5cbi8qIFB1YmxpYyBLZXkgSW5mcmFzdHJ1Y3R1cmUgKFBLSSkgaW1wbGVtZW50YXRpb24uICovXG52YXIgcGtpID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wa2kgPSBmb3JnZS5wa2kgfHwge307XG52YXIgb2lkcyA9IHBraS5vaWRzO1xuXG4vLyBzaG9ydCBuYW1lIE9JRCBtYXBwaW5nc1xudmFyIF9zaG9ydE5hbWVzID0ge307XG5fc2hvcnROYW1lc1snQ04nXSA9IG9pZHNbJ2NvbW1vbk5hbWUnXTtcbl9zaG9ydE5hbWVzWydjb21tb25OYW1lJ10gPSAnQ04nO1xuX3Nob3J0TmFtZXNbJ0MnXSA9IG9pZHNbJ2NvdW50cnlOYW1lJ107XG5fc2hvcnROYW1lc1snY291bnRyeU5hbWUnXSA9ICdDJztcbl9zaG9ydE5hbWVzWydMJ10gPSBvaWRzWydsb2NhbGl0eU5hbWUnXTtcbl9zaG9ydE5hbWVzWydsb2NhbGl0eU5hbWUnXSA9ICdMJztcbl9zaG9ydE5hbWVzWydTVCddID0gb2lkc1snc3RhdGVPclByb3ZpbmNlTmFtZSddO1xuX3Nob3J0TmFtZXNbJ3N0YXRlT3JQcm92aW5jZU5hbWUnXSA9ICdTVCc7XG5fc2hvcnROYW1lc1snTyddID0gb2lkc1snb3JnYW5pemF0aW9uTmFtZSddO1xuX3Nob3J0TmFtZXNbJ29yZ2FuaXphdGlvbk5hbWUnXSA9ICdPJztcbl9zaG9ydE5hbWVzWydPVSddID0gb2lkc1snb3JnYW5pemF0aW9uYWxVbml0TmFtZSddO1xuX3Nob3J0TmFtZXNbJ29yZ2FuaXphdGlvbmFsVW5pdE5hbWUnXSA9ICdPVSc7XG5fc2hvcnROYW1lc1snRSddID0gb2lkc1snZW1haWxBZGRyZXNzJ107XG5fc2hvcnROYW1lc1snZW1haWxBZGRyZXNzJ10gPSAnRSc7XG5cbi8vIHZhbGlkYXRvciBmb3IgYW4gU3ViamVjdFB1YmxpY0tleUluZm8gc3RydWN0dXJlXG4vLyBOb3RlOiBDdXJyZW50bHkgb25seSB3b3JrcyB3aXRoIGFuIFJTQSBwdWJsaWMga2V5XG52YXIgcHVibGljS2V5VmFsaWRhdG9yID0gZm9yZ2UucGtpLnJzYS5wdWJsaWNLZXlWYWxpZGF0b3I7XG5cbi8vIHZhbGlkYXRvciBmb3IgYW4gWC41MDl2MyBjZXJ0aWZpY2F0ZVxudmFyIHg1MDlDZXJ0aWZpY2F0ZVZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0NlcnRpZmljYXRlJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgY2FwdHVyZUFzbjE6ICd0YnNDZXJ0aWZpY2F0ZScsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmVyc2lvbicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgICAgdHlwZTogMCxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZlcnNpb24uaW50ZWdlcicsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogJ2NlcnRWZXJzaW9uJ1xuICAgICAgfV1cbiAgICB9LCB7XG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc2VyaWFsTnVtYmVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ2NlcnRTZXJpYWxOdW1iZXInXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNpZ25hdHVyZScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc2lnbmF0dXJlLmFsZ29yaXRobScsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiAnY2VydGluZm9TaWduYXR1cmVPaWQnXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zaWduYXR1cmUucGFyYW1ldGVycycsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIGNhcHR1cmVBc24xOiAnY2VydGluZm9TaWduYXR1cmVQYXJhbXMnXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5pc3N1ZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBjYXB0dXJlQXNuMTogJ2NlcnRJc3N1ZXInXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZhbGlkaXR5JyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgLy8gTm90ZTogVVRDIGFuZCBnZW5lcmFsaXplZCB0aW1lcyBtYXkgYm90aCBhcHBlYXIgc28gdGhlIGNhcHR1cmVcbiAgICAgIC8vIG5hbWVzIGFyZSBiYXNlZCBvbiB0aGVpciBkZXRlY3RlZCBvcmRlciwgdGhlIG5hbWVzIHVzZWQgYmVsb3dcbiAgICAgIC8vIGFyZSBvbmx5IGZvciB0aGUgY29tbW9uIGNhc2UsIHdoaWNoIHZhbGlkaXR5IHRpbWUgcmVhbGx5IG1lYW5zXG4gICAgICAvLyBcIm5vdEJlZm9yZVwiIGFuZCB3aGljaCBtZWFucyBcIm5vdEFmdGVyXCIgd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IG9yZGVyXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgLy8gbm90QmVmb3JlIChUaW1lKSAoVVRDIHRpbWUgY2FzZSlcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZhbGlkaXR5Lm5vdEJlZm9yZSAodXRjKScsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLlVUQ1RJTUUsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIGNhcHR1cmU6ICdjZXJ0VmFsaWRpdHkxVVRDVGltZSdcbiAgICAgIH0sIHtcbiAgICAgICAgLy8gbm90QmVmb3JlIChUaW1lKSAoZ2VuZXJhbGl6ZWQgdGltZSBjYXNlKVxuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmFsaWRpdHkubm90QmVmb3JlIChnZW5lcmFsaXplZCknLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5HRU5FUkFMSVpFRFRJTUUsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIGNhcHR1cmU6ICdjZXJ0VmFsaWRpdHkyR2VuZXJhbGl6ZWRUaW1lJ1xuICAgICAgfSwge1xuICAgICAgICAvLyBub3RBZnRlciAoVGltZSkgKG9ubHkgVVRDIHRpbWUgaXMgc3VwcG9ydGVkKVxuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmFsaWRpdHkubm90QWZ0ZXIgKHV0YyknLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5VVENUSU1FLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICBjYXB0dXJlOiAnY2VydFZhbGlkaXR5M1VUQ1RpbWUnXG4gICAgICB9LCB7XG4gICAgICAgIC8vIG5vdEFmdGVyIChUaW1lKSAob25seSBVVEMgdGltZSBpcyBzdXBwb3J0ZWQpXG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52YWxpZGl0eS5ub3RBZnRlciAoZ2VuZXJhbGl6ZWQpJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuR0VORVJBTElaRURUSU1FLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICBjYXB0dXJlOiAnY2VydFZhbGlkaXR5NEdlbmVyYWxpemVkVGltZSdcbiAgICAgIH1dXG4gICAgfSwge1xuICAgICAgLy8gTmFtZSAoc3ViamVjdCkgKFJETlNlcXVlbmNlKVxuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnN1YmplY3QnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBjYXB0dXJlQXNuMTogJ2NlcnRTdWJqZWN0J1xuICAgIH0sXG4gICAgLy8gU3ViamVjdFB1YmxpY0tleUluZm9cbiAgICBwdWJsaWNLZXlWYWxpZGF0b3IsXG4gICAge1xuICAgICAgLy8gaXNzdWVyVW5pcXVlSUQgKG9wdGlvbmFsKVxuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLmlzc3VlclVuaXF1ZUlEJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICB0eXBlOiAxLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuaXNzdWVyVW5pcXVlSUQuaWQnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5CSVRTVFJJTkcsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBhcmJpdHJhcnkgYml0IGxlbmd0aCBpZHNcbiAgICAgICAgY2FwdHVyZUJpdFN0cmluZ1ZhbHVlOiAnY2VydElzc3VlclVuaXF1ZUlkJ1xuICAgICAgfV1cbiAgICB9LCB7XG4gICAgICAvLyBzdWJqZWN0VW5pcXVlSUQgKG9wdGlvbmFsKVxuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnN1YmplY3RVbmlxdWVJRCcsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgICAgdHlwZTogMixcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnN1YmplY3RVbmlxdWVJRC5pZCcsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgICBjYXB0dXJlQml0U3RyaW5nVmFsdWU6ICdjZXJ0U3ViamVjdFVuaXF1ZUlkJ1xuICAgICAgfV1cbiAgICB9LCB7XG4gICAgICAvLyBFeHRlbnNpb25zIChvcHRpb25hbClcbiAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5leHRlbnNpb25zJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICB0eXBlOiAzLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBjYXB0dXJlQXNuMTogJ2NlcnRFeHRlbnNpb25zJyxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfV1cbiAgfSwge1xuICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgbmFtZTogJ0NlcnRpZmljYXRlLnNpZ25hdHVyZUFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIC8vIGFsZ29yaXRobVxuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLnNpZ25hdHVyZUFsZ29yaXRobS5hbGdvcml0aG0nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdjZXJ0U2lnbmF0dXJlT2lkJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zaWduYXR1cmUucGFyYW1ldGVycycsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnY2VydFNpZ25hdHVyZVBhcmFtcydcbiAgICB9XVxuICB9LCB7XG4gICAgLy8gU2lnbmF0dXJlVmFsdWVcbiAgICBuYW1lOiAnQ2VydGlmaWNhdGUuc2lnbmF0dXJlVmFsdWUnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuQklUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlQml0U3RyaW5nVmFsdWU6ICdjZXJ0U2lnbmF0dXJlJ1xuICB9XVxufTtcblxudmFyIHJzYXNzYVBzc1BhcmFtZXRlclZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ3JzYXBzcycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ3JzYXBzcy5oYXNoQWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDAsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAncnNhcHNzLmhhc2hBbGdvcml0aG0uQWxnb3JpdGhtSWRlbnRpZmllcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLkNsYXNzLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiAncnNhcHNzLmhhc2hBbGdvcml0aG0uQWxnb3JpdGhtSWRlbnRpZmllci5hbGdvcml0aG0nLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogJ2hhc2hPaWQnXG4gICAgICAgIC8qIHBhcmFtZXRlciBibG9jayBvbWl0dGVkLCBmb3IgU0hBMSBOVUxMIGFueWhvdy4gKi9cbiAgICAgIH1dXG4gICAgfV1cbiAgfSwge1xuICAgIG5hbWU6ICdyc2Fwc3MubWFza0dlbkFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICB0eXBlOiAxLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ3JzYXBzcy5tYXNrR2VuQWxnb3JpdGhtLkFsZ29yaXRobUlkZW50aWZpZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5DbGFzcy5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogJ3JzYXBzcy5tYXNrR2VuQWxnb3JpdGhtLkFsZ29yaXRobUlkZW50aWZpZXIuYWxnb3JpdGhtJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6ICdtYXNrR2VuT2lkJ1xuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAncnNhcHNzLm1hc2tHZW5BbGdvcml0aG0uQWxnb3JpdGhtSWRlbnRpZmllci5wYXJhbXMnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgIHZhbHVlOiBbe1xuICAgICAgICAgIG5hbWU6ICdyc2Fwc3MubWFza0dlbkFsZ29yaXRobS5BbGdvcml0aG1JZGVudGlmaWVyLnBhcmFtcy5hbGdvcml0aG0nLFxuICAgICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICBjYXB0dXJlOiAnbWFza0dlbkhhc2hPaWQnXG4gICAgICAgICAgLyogcGFyYW1ldGVyIGJsb2NrIG9taXR0ZWQsIGZvciBTSEExIE5VTEwgYW55aG93LiAqL1xuICAgICAgICB9XVxuICAgICAgfV1cbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ3JzYXBzcy5zYWx0TGVuZ3RoJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDIsXG4gICAgb3B0aW9uYWw6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAncnNhcHNzLnNhbHRMZW5ndGguc2FsdExlbmd0aCcsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLkNsYXNzLklOVEVHRVIsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnc2FsdExlbmd0aCdcbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ3JzYXBzcy50cmFpbGVyRmllbGQnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMyxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdyc2Fwc3MudHJhaWxlci50cmFpbGVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuQ2xhc3MuSU5URUdFUixcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICd0cmFpbGVyJ1xuICAgIH1dXG4gIH1dXG59O1xuXG4vLyB2YWxpZGF0b3IgZm9yIGEgQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIHN0cnVjdHVyZVxudmFyIGNlcnRpZmljYXRpb25SZXF1ZXN0SW5mb1ZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0SW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgY2FwdHVyZUFzbjE6ICdjZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8nLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLmludGVnZXInLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ2NlcnRpZmljYXRpb25SZXF1ZXN0SW5mb1ZlcnNpb24nXG4gIH0sIHtcbiAgICAvLyBOYW1lIChzdWJqZWN0KSAoUkROU2VxdWVuY2UpXG4gICAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0SW5mby5zdWJqZWN0JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAnY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvU3ViamVjdCdcbiAgfSxcbiAgLy8gU3ViamVjdFB1YmxpY0tleUluZm9cbiAgcHVibGljS2V5VmFsaWRhdG9yLFxuICB7XG4gICAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0SW5mby5hdHRyaWJ1dGVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDAsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgb3B0aW9uYWw6IHRydWUsXG4gICAgY2FwdHVyZTogJ2NlcnRpZmljYXRpb25SZXF1ZXN0SW5mb0F0dHJpYnV0ZXMnLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0SW5mby5hdHRyaWJ1dGVzJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8uYXR0cmlidXRlcy50eXBlJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0SW5mby5hdHRyaWJ1dGVzLnZhbHVlJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuU0VULFxuICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZVxuICAgICAgfV1cbiAgICB9XVxuICB9XVxufTtcblxuLy8gdmFsaWRhdG9yIGZvciBhIENlcnRpZmljYXRpb25SZXF1ZXN0IHN0cnVjdHVyZVxudmFyIGNlcnRpZmljYXRpb25SZXF1ZXN0VmFsaWRhdG9yID0ge1xuICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3QnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIGNhcHR1cmVBc24xOiAnY3NyJyxcbiAgdmFsdWU6IFtcbiAgICBjZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9WYWxpZGF0b3IsIHtcbiAgICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3Quc2lnbmF0dXJlQWxnb3JpdGhtJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIC8vIGFsZ29yaXRobVxuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3Quc2lnbmF0dXJlQWxnb3JpdGhtLmFsZ29yaXRobScsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiAnY3NyU2lnbmF0dXJlT2lkJ1xuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3Quc2lnbmF0dXJlQWxnb3JpdGhtLnBhcmFtZXRlcnMnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICBjYXB0dXJlQXNuMTogJ2NzclNpZ25hdHVyZVBhcmFtcydcbiAgICAgIH1dXG4gICAgfSwge1xuICAgICAgLy8gc2lnbmF0dXJlXG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3Quc2lnbmF0dXJlJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5CSVRTVFJJTkcsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlQml0U3RyaW5nVmFsdWU6ICdjc3JTaWduYXR1cmUnXG4gICAgfVxuICBdXG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJETlNlcXVlbmNlIG9mIEFTTi4xIERFUi1lbmNvZGVkIFJlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWVcbiAqIHNldHMgaW50byBhbiBhcnJheSB3aXRoIG9iamVjdHMgdGhhdCBoYXZlIHR5cGUgYW5kIHZhbHVlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHJkbiB0aGUgUkROU2VxdWVuY2UgdG8gY29udmVydC5cbiAqIEBwYXJhbSBtZCBhIG1lc3NhZ2UgZGlnZXN0IHRvIGFwcGVuZCB0eXBlIGFuZCB2YWx1ZSB0byBpZiBwcm92aWRlZC5cbiAqL1xucGtpLlJETkF0dHJpYnV0ZXNBc0FycmF5ID0gZnVuY3Rpb24ocmRuLCBtZCkge1xuICB2YXIgcnZhbCA9IFtdO1xuXG4gIC8vIGVhY2ggdmFsdWUgaW4gJ3JkbicgaW4gaXMgYSBTRVQgb2YgUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZVxuICB2YXIgc2V0LCBhdHRyLCBvYmo7XG4gIGZvcih2YXIgc2kgPSAwOyBzaSA8IHJkbi52YWx1ZS5sZW5ndGg7ICsrc2kpIHtcbiAgICAvLyBnZXQgdGhlIFJlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWUgc2V0XG4gICAgc2V0ID0gcmRuLnZhbHVlW3NpXTtcblxuICAgIC8vIGVhY2ggdmFsdWUgaW4gdGhlIFNFVCBpcyBhbiBBdHRyaWJ1dGVUeXBlQW5kVmFsdWUgc2VxdWVuY2VcbiAgICAvLyBjb250YWluaW5nIGZpcnN0IGEgdHlwZSAoYW4gT0lEKSBhbmQgc2Vjb25kIGEgdmFsdWUgKGRlZmluZWQgYnlcbiAgICAvLyB0aGUgT0lEKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZXQudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgIG9iaiA9IHt9O1xuICAgICAgYXR0ciA9IHNldC52YWx1ZVtpXTtcbiAgICAgIG9iai50eXBlID0gYXNuMS5kZXJUb09pZChhdHRyLnZhbHVlWzBdLnZhbHVlKTtcbiAgICAgIG9iai52YWx1ZSA9IGF0dHIudmFsdWVbMV0udmFsdWU7XG4gICAgICBvYmoudmFsdWVUYWdDbGFzcyA9IGF0dHIudmFsdWVbMV0udHlwZTtcbiAgICAgIC8vIGlmIHRoZSBPSUQgaXMga25vd24sIGdldCBpdHMgbmFtZSBhbmQgc2hvcnQgbmFtZVxuICAgICAgaWYob2JqLnR5cGUgaW4gb2lkcykge1xuICAgICAgICBvYmoubmFtZSA9IG9pZHNbb2JqLnR5cGVdO1xuICAgICAgICBpZihvYmoubmFtZSBpbiBfc2hvcnROYW1lcykge1xuICAgICAgICAgIG9iai5zaG9ydE5hbWUgPSBfc2hvcnROYW1lc1tvYmoubmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKG1kKSB7XG4gICAgICAgIG1kLnVwZGF0ZShvYmoudHlwZSk7XG4gICAgICAgIG1kLnVwZGF0ZShvYmoudmFsdWUpO1xuICAgICAgfVxuICAgICAgcnZhbC5wdXNoKG9iaik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIEFTTi4xIENSSUF0dHJpYnV0ZXMgaW50byBhbiBhcnJheSB3aXRoIG9iamVjdHMgdGhhdCBoYXZlIHR5cGUgYW5kXG4gKiB2YWx1ZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSBhdHRyaWJ1dGVzIHRoZSBDUklBdHRyaWJ1dGVzIHRvIGNvbnZlcnQuXG4gKi9cbnBraS5DUklBdHRyaWJ1dGVzQXNBcnJheSA9IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcbiAgdmFyIHJ2YWwgPSBbXTtcblxuICAvLyBlYWNoIHZhbHVlIGluICdhdHRyaWJ1dGVzJyBpbiBpcyBhIFNFUVVFTkNFIHdpdGggYW4gT0lEIGFuZCBhIFNFVFxuICBmb3IodmFyIHNpID0gMDsgc2kgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgKytzaSkge1xuICAgIC8vIGdldCB0aGUgYXR0cmlidXRlIHNlcXVlbmNlXG4gICAgdmFyIHNlcSA9IGF0dHJpYnV0ZXNbc2ldO1xuXG4gICAgLy8gZWFjaCB2YWx1ZSBpbiB0aGUgU0VRVUVOQ0UgY29udGFpbmluZyBmaXJzdCBhIHR5cGUgKGFuIE9JRCkgYW5kXG4gICAgLy8gc2Vjb25kIGEgc2V0IG9mIHZhbHVlcyAoZGVmaW5lZCBieSB0aGUgT0lEKVxuICAgIHZhciB0eXBlID0gYXNuMS5kZXJUb09pZChzZXEudmFsdWVbMF0udmFsdWUpO1xuICAgIHZhciB2YWx1ZXMgPSBzZXEudmFsdWVbMV0udmFsdWU7XG4gICAgZm9yKHZhciB2aSA9IDA7IHZpIDwgdmFsdWVzLmxlbmd0aDsgKyt2aSkge1xuICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgb2JqLnR5cGUgPSB0eXBlO1xuICAgICAgb2JqLnZhbHVlID0gdmFsdWVzW3ZpXS52YWx1ZTtcbiAgICAgIG9iai52YWx1ZVRhZ0NsYXNzID0gdmFsdWVzW3ZpXS50eXBlO1xuICAgICAgLy8gaWYgdGhlIE9JRCBpcyBrbm93biwgZ2V0IGl0cyBuYW1lIGFuZCBzaG9ydCBuYW1lXG4gICAgICBpZihvYmoudHlwZSBpbiBvaWRzKSB7XG4gICAgICAgIG9iai5uYW1lID0gb2lkc1tvYmoudHlwZV07XG4gICAgICAgIGlmKG9iai5uYW1lIGluIF9zaG9ydE5hbWVzKSB7XG4gICAgICAgICAgb2JqLnNob3J0TmFtZSA9IF9zaG9ydE5hbWVzW29iai5uYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gcGFyc2UgZXh0ZW5zaW9uc1xuICAgICAgaWYob2JqLnR5cGUgPT09IG9pZHMuZXh0ZW5zaW9uUmVxdWVzdCkge1xuICAgICAgICBvYmouZXh0ZW5zaW9ucyA9IFtdO1xuICAgICAgICBmb3IodmFyIGVpID0gMDsgZWkgPCBvYmoudmFsdWUubGVuZ3RoOyArK2VpKSB7XG4gICAgICAgICAgb2JqLmV4dGVuc2lvbnMucHVzaChwa2kuY2VydGlmaWNhdGVFeHRlbnNpb25Gcm9tQXNuMShvYmoudmFsdWVbZWldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJ2YWwucHVzaChvYmopO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGFuIGlzc3VlciBvciBzdWJqZWN0IGF0dHJpYnV0ZSBmcm9tIGl0cyBuYW1lLCB0eXBlLCBvciBzaG9ydCBuYW1lLlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIGlzc3VlciBvciBzdWJqZWN0IG9iamVjdC5cbiAqIEBwYXJhbSBvcHRpb25zIGEgc2hvcnQgbmFtZSBzdHJpbmcgb3IgYW4gb2JqZWN0IHdpdGg6XG4gKiAgICAgICAgICBzaG9ydE5hbWUgdGhlIHNob3J0IG5hbWUgZm9yIHRoZSBhdHRyaWJ1dGUuXG4gKiAgICAgICAgICBuYW1lIHRoZSBuYW1lIGZvciB0aGUgYXR0cmlidXRlLlxuICogICAgICAgICAgdHlwZSB0aGUgdHlwZSBmb3IgdGhlIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhdHRyaWJ1dGUuXG4gKi9cbmZ1bmN0aW9uIF9nZXRBdHRyaWJ1dGUob2JqLCBvcHRpb25zKSB7XG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7c2hvcnROYW1lOiBvcHRpb25zfTtcbiAgfVxuXG4gIHZhciBydmFsID0gbnVsbDtcbiAgdmFyIGF0dHI7XG4gIGZvcih2YXIgaSA9IDA7IHJ2YWwgPT09IG51bGwgJiYgaSA8IG9iai5hdHRyaWJ1dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgYXR0ciA9IG9iai5hdHRyaWJ1dGVzW2ldO1xuICAgIGlmKG9wdGlvbnMudHlwZSAmJiBvcHRpb25zLnR5cGUgPT09IGF0dHIudHlwZSkge1xuICAgICAgcnZhbCA9IGF0dHI7XG4gICAgfSBlbHNlIGlmKG9wdGlvbnMubmFtZSAmJiBvcHRpb25zLm5hbWUgPT09IGF0dHIubmFtZSkge1xuICAgICAgcnZhbCA9IGF0dHI7XG4gICAgfSBlbHNlIGlmKG9wdGlvbnMuc2hvcnROYW1lICYmIG9wdGlvbnMuc2hvcnROYW1lID09PSBhdHRyLnNob3J0TmFtZSkge1xuICAgICAgcnZhbCA9IGF0dHI7XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHNpZ25hdHVyZSBwYXJhbWV0ZXJzIGZyb20gQVNOLjEgc3RydWN0dXJlLlxuICpcbiAqIEN1cnJlbnRseSBvbmx5IFJTQVNTQS1QU1Mgc3VwcG9ydGVkLiAgVGhlIFBLQ1MjMSB2MS41IHNpZ25hdHVyZSBzY2hlbWUgaGFkXG4gKiBubyBwYXJhbWV0ZXJzLlxuICpcbiAqIFJTQVNTQS1QU1MtcGFyYW1zICA6Oj0gIFNFUVVFTkNFICB7XG4gKiAgIGhhc2hBbGdvcml0aG0gICAgICBbMF0gSGFzaEFsZ29yaXRobSBERUZBVUxUXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhMUlkZW50aWZpZXIsXG4gKiAgIG1hc2tHZW5BbGdvcml0aG0gICBbMV0gTWFza0dlbkFsZ29yaXRobSBERUZBVUxUXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWdmMVNIQTFJZGVudGlmaWVyLFxuICogICBzYWx0TGVuZ3RoICAgICAgICAgWzJdIElOVEVHRVIgREVGQVVMVCAyMCxcbiAqICAgdHJhaWxlckZpZWxkICAgICAgIFszXSBJTlRFR0VSIERFRkFVTFQgMVxuICogfVxuICpcbiAqIEhhc2hBbGdvcml0aG0gIDo6PSAgQWxnb3JpdGhtSWRlbnRpZmllclxuICpcbiAqIE1hc2tHZW5BbGdvcml0aG0gIDo6PSAgQWxnb3JpdGhtSWRlbnRpZmllclxuICpcbiAqIEFsZ29yaXRobUlkZW50aWZlciA6Oj0gU0VRVUVOQ0Uge1xuICogICBhbGdvcml0aG0gT0JKRUNUIElERU5USUZJRVIsXG4gKiAgIHBhcmFtZXRlcnMgQU5ZIERFRklORUQgQlkgYWxnb3JpdGhtIE9QVElPTkFMXG4gKiB9XG4gKlxuICogQHBhcmFtIG9pZCBUaGUgT0lEIHNwZWNpZnlpbmcgdGhlIHNpZ25hdHVyZSBhbGdvcml0aG1cbiAqIEBwYXJhbSBvYmogVGhlIEFTTi4xIHN0cnVjdHVyZSBob2xkaW5nIHRoZSBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0gZmlsbERlZmF1bHRzIFdoZXRoZXIgdG8gdXNlIHJldHVybiBkZWZhdWx0IHZhbHVlcyB3aGVyZSBvbWl0dGVkXG4gKiBAcmV0dXJuIHNpZ25hdHVyZSBwYXJhbWV0ZXIgb2JqZWN0XG4gKi9cbnZhciBfcmVhZFNpZ25hdHVyZVBhcmFtZXRlcnMgPSBmdW5jdGlvbihvaWQsIG9iaiwgZmlsbERlZmF1bHRzKSB7XG4gIHZhciBwYXJhbXMgPSB7fTtcblxuICBpZihvaWQgIT09IG9pZHNbJ1JTQVNTQS1QU1MnXSkge1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICBpZihmaWxsRGVmYXVsdHMpIHtcbiAgICBwYXJhbXMgPSB7XG4gICAgICBoYXNoOiB7XG4gICAgICAgIGFsZ29yaXRobU9pZDogb2lkc1snc2hhMSddXG4gICAgICB9LFxuICAgICAgbWdmOiB7XG4gICAgICAgIGFsZ29yaXRobU9pZDogb2lkc1snbWdmMSddLFxuICAgICAgICBoYXNoOiB7XG4gICAgICAgICAgYWxnb3JpdGhtT2lkOiBvaWRzWydzaGExJ11cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNhbHRMZW5ndGg6IDIwXG4gICAgfTtcbiAgfVxuXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCByc2Fzc2FQc3NQYXJhbWV0ZXJWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIFJTQVNTQS1QU1MgcGFyYW1ldGVyIGJsb2NrLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIGlmKGNhcHR1cmUuaGFzaE9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyYW1zLmhhc2ggPSBwYXJhbXMuaGFzaCB8fCB7fTtcbiAgICBwYXJhbXMuaGFzaC5hbGdvcml0aG1PaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuaGFzaE9pZCk7XG4gIH1cblxuICBpZihjYXB0dXJlLm1hc2tHZW5PaWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHBhcmFtcy5tZ2YgPSBwYXJhbXMubWdmIHx8IHt9O1xuICAgIHBhcmFtcy5tZ2YuYWxnb3JpdGhtT2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLm1hc2tHZW5PaWQpO1xuICAgIHBhcmFtcy5tZ2YuaGFzaCA9IHBhcmFtcy5tZ2YuaGFzaCB8fCB7fTtcbiAgICBwYXJhbXMubWdmLmhhc2guYWxnb3JpdGhtT2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLm1hc2tHZW5IYXNoT2lkKTtcbiAgfVxuXG4gIGlmKGNhcHR1cmUuc2FsdExlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyYW1zLnNhbHRMZW5ndGggPSBjYXB0dXJlLnNhbHRMZW5ndGguY2hhckNvZGVBdCgwKTtcbiAgfVxuXG4gIHJldHVybiBwYXJhbXM7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBzaWduYXR1cmUgZGlnZXN0IGZvciBPSUQuXG4gKlxuICogQHBhcmFtIG9wdGlvbnNcbiAqICAgc2lnbmF0dXJlT2lkOiB0aGUgT0lEIHNwZWNpZnlpbmcgdGhlIHNpZ25hdHVyZSBhbGdvcml0aG0uXG4gKiAgIHR5cGU6IGEgaHVtYW4gcmVhZGFibGUgdHlwZSBmb3IgZXJyb3IgbWVzc2FnZXNcbiAqIEByZXR1cm4gYSBjcmVhdGVkIG1kIGluc3RhbmNlLiB0aHJvd3MgaWYgdW5rbm93biBvaWQuXG4gKi9cbnZhciBfY3JlYXRlU2lnbmF0dXJlRGlnZXN0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBzd2l0Y2gob2lkc1tvcHRpb25zLnNpZ25hdHVyZU9pZF0pIHtcbiAgICBjYXNlICdzaGExV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgIC8vIGRlcHJlY2F0ZWQgYWxpYXNcbiAgICBjYXNlICdzaGExV2l0aFJTQVNpZ25hdHVyZSc6XG4gICAgICByZXR1cm4gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgICBjYXNlICdtZDVXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICByZXR1cm4gZm9yZ2UubWQubWQ1LmNyZWF0ZSgpO1xuICAgIGNhc2UgJ3NoYTI1NldpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgIHJldHVybiBmb3JnZS5tZC5zaGEyNTYuY3JlYXRlKCk7XG4gICAgY2FzZSAnc2hhMzg0V2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgcmV0dXJuIGZvcmdlLm1kLnNoYTM4NC5jcmVhdGUoKTtcbiAgICBjYXNlICdzaGE1MTJXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICByZXR1cm4gZm9yZ2UubWQuc2hhNTEyLmNyZWF0ZSgpO1xuICAgIGNhc2UgJ1JTQVNTQS1QU1MnOlxuICAgICAgcmV0dXJuIGZvcmdlLm1kLnNoYTI1Ni5jcmVhdGUoKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnQ291bGQgbm90IGNvbXB1dGUgJyArIG9wdGlvbnMudHlwZSArICcgZGlnZXN0LiAnICtcbiAgICAgICAgJ1Vua25vd24gc2lnbmF0dXJlIE9JRC4nKTtcbiAgICAgIGVycm9yLnNpZ25hdHVyZU9pZCA9IG9wdGlvbnMuc2lnbmF0dXJlT2lkO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8qKlxuICogVmVyaWZ5IHNpZ25hdHVyZSBvbiBjZXJ0aWZpY2F0ZSBvciBDU1IuXG4gKlxuICogQHBhcmFtIG9wdGlvbnM6XG4gKiAgIGNlcnRpZmljYXRlIHRoZSBjZXJ0aWZpY2F0ZSBvciBDU1IgdG8gdmVyaWZ5LlxuICogICBtZCB0aGUgc2lnbmF0dXJlIGRpZ2VzdC5cbiAqICAgc2lnbmF0dXJlIHRoZSBzaWduYXR1cmVcbiAqIEByZXR1cm4gYSBjcmVhdGVkIG1kIGluc3RhbmNlLiB0aHJvd3MgaWYgdW5rbm93biBvaWQuXG4gKi9cbnZhciBfdmVyaWZ5U2lnbmF0dXJlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgY2VydCA9IG9wdGlvbnMuY2VydGlmaWNhdGU7XG4gIHZhciBzY2hlbWU7XG5cbiAgc3dpdGNoKGNlcnQuc2lnbmF0dXJlT2lkKSB7XG4gICAgY2FzZSBvaWRzLnNoYTFXaXRoUlNBRW5jcnlwdGlvbjpcbiAgICAvLyBkZXByZWNhdGVkIGFsaWFzXG4gICAgY2FzZSBvaWRzLnNoYTFXaXRoUlNBU2lnbmF0dXJlOlxuICAgICAgLyogdXNlIFBLQ1MjMSB2MS41IHBhZGRpbmcgc2NoZW1lICovXG4gICAgICBicmVhaztcbiAgICBjYXNlIG9pZHNbJ1JTQVNTQS1QU1MnXTpcbiAgICAgIHZhciBoYXNoLCBtZ2Y7XG5cbiAgICAgIC8qIGluaXRpYWxpemUgbWdmICovXG4gICAgICBoYXNoID0gb2lkc1tjZXJ0LnNpZ25hdHVyZVBhcmFtZXRlcnMubWdmLmhhc2guYWxnb3JpdGhtT2lkXTtcbiAgICAgIGlmKGhhc2ggPT09IHVuZGVmaW5lZCB8fCBmb3JnZS5tZFtoYXNoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgTUdGIGhhc2ggZnVuY3Rpb24uJyk7XG4gICAgICAgIGVycm9yLm9pZCA9IGNlcnQuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuaGFzaC5hbGdvcml0aG1PaWQ7XG4gICAgICAgIGVycm9yLm5hbWUgPSBoYXNoO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgbWdmID0gb2lkc1tjZXJ0LnNpZ25hdHVyZVBhcmFtZXRlcnMubWdmLmFsZ29yaXRobU9pZF07XG4gICAgICBpZihtZ2YgPT09IHVuZGVmaW5lZCB8fCBmb3JnZS5tZ2ZbbWdmXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgTUdGIGZ1bmN0aW9uLicpO1xuICAgICAgICBlcnJvci5vaWQgPSBjZXJ0LnNpZ25hdHVyZVBhcmFtZXRlcnMubWdmLmFsZ29yaXRobU9pZDtcbiAgICAgICAgZXJyb3IubmFtZSA9IG1nZjtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIG1nZiA9IGZvcmdlLm1nZlttZ2ZdLmNyZWF0ZShmb3JnZS5tZFtoYXNoXS5jcmVhdGUoKSk7XG5cbiAgICAgIC8qIGluaXRpYWxpemUgaGFzaCBmdW5jdGlvbiAqL1xuICAgICAgaGFzaCA9IG9pZHNbY2VydC5zaWduYXR1cmVQYXJhbWV0ZXJzLmhhc2guYWxnb3JpdGhtT2lkXTtcbiAgICAgIGlmKGhhc2ggPT09IHVuZGVmaW5lZCB8fCBmb3JnZS5tZFtoYXNoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgUlNBU1NBLVBTUyBoYXNoIGZ1bmN0aW9uLicpO1xuICAgICAgICBlcnJvci5vaWQgPSBjZXJ0LnNpZ25hdHVyZVBhcmFtZXRlcnMuaGFzaC5hbGdvcml0aG1PaWQ7XG4gICAgICAgIGVycm9yLm5hbWUgPSBoYXNoO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgc2NoZW1lID0gZm9yZ2UucHNzLmNyZWF0ZShcbiAgICAgICAgZm9yZ2UubWRbaGFzaF0uY3JlYXRlKCksIG1nZiwgY2VydC5zaWduYXR1cmVQYXJhbWV0ZXJzLnNhbHRMZW5ndGhcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIC8vIHZlcmlmeSBzaWduYXR1cmUgb24gY2VydCB1c2luZyBwdWJsaWMga2V5XG4gIHJldHVybiBjZXJ0LnB1YmxpY0tleS52ZXJpZnkoXG4gICAgb3B0aW9ucy5tZC5kaWdlc3QoKS5nZXRCeXRlcygpLCBvcHRpb25zLnNpZ25hdHVyZSwgc2NoZW1lXG4gICk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFguNTA5IGNlcnRpZmljYXRlIGZyb20gUEVNIGZvcm1hdC5cbiAqXG4gKiBOb3RlOiBJZiB0aGUgY2VydGlmaWNhdGUgaXMgdG8gYmUgdmVyaWZpZWQgdGhlbiBjb21wdXRlIGhhc2ggc2hvdWxkXG4gKiBiZSBzZXQgdG8gdHJ1ZS4gVGhpcyB3aWxsIHNjYW4gdGhlIFRCU0NlcnRpZmljYXRlIHBhcnQgb2YgdGhlIEFTTi4xXG4gKiBvYmplY3Qgd2hpbGUgaXQgaXMgY29udmVydGVkIHNvIGl0IGRvZXNuJ3QgbmVlZCB0byBiZSBjb252ZXJ0ZWQgYmFja1xuICogdG8gQVNOLjEtREVSLWVuY29kaW5nIGxhdGVyLlxuICpcbiAqIEBwYXJhbSBwZW0gdGhlIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGUuXG4gKiBAcGFyYW0gY29tcHV0ZUhhc2ggdHJ1ZSB0byBjb21wdXRlIHRoZSBoYXNoIGZvciB2ZXJpZmljYXRpb24uXG4gKiBAcGFyYW0gc3RyaWN0IHRydWUgdG8gYmUgc3RyaWN0IHdoZW4gY2hlY2tpbmcgQVNOLjEgdmFsdWUgbGVuZ3RocywgZmFsc2UgdG9cbiAqICAgICAgICAgIGFsbG93IHRydW5jYXRlZCB2YWx1ZXMgKGRlZmF1bHQ6IHRydWUpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNlcnRpZmljYXRlLlxuICovXG5wa2kuY2VydGlmaWNhdGVGcm9tUGVtID0gZnVuY3Rpb24ocGVtLCBjb21wdXRlSGFzaCwgc3RyaWN0KSB7XG4gIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG5cbiAgaWYobXNnLnR5cGUgIT09ICdDRVJUSUZJQ0FURScgJiZcbiAgICBtc2cudHlwZSAhPT0gJ1g1MDkgQ0VSVElGSUNBVEUnICYmXG4gICAgbXNnLnR5cGUgIT09ICdUUlVTVEVEIENFUlRJRklDQVRFJykge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICdDb3VsZCBub3QgY29udmVydCBjZXJ0aWZpY2F0ZSBmcm9tIFBFTTsgUEVNIGhlYWRlciB0eXBlICcgK1xuICAgICAgJ2lzIG5vdCBcIkNFUlRJRklDQVRFXCIsIFwiWDUwOSBDRVJUSUZJQ0FURVwiLCBvciBcIlRSVVNURUQgQ0VSVElGSUNBVEVcIi4nKTtcbiAgICBlcnJvci5oZWFkZXJUeXBlID0gbXNnLnR5cGU7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgaWYobXNnLnByb2NUeXBlICYmIG1zZy5wcm9jVHlwZS50eXBlID09PSAnRU5DUllQVEVEJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdDb3VsZCBub3QgY29udmVydCBjZXJ0aWZpY2F0ZSBmcm9tIFBFTTsgUEVNIGlzIGVuY3J5cHRlZC4nKTtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgREVSIHRvIEFTTi4xIG9iamVjdFxuICB2YXIgb2JqID0gYXNuMS5mcm9tRGVyKG1zZy5ib2R5LCBzdHJpY3QpO1xuXG4gIHJldHVybiBwa2kuY2VydGlmaWNhdGVGcm9tQXNuMShvYmosIGNvbXB1dGVIYXNoKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gWC41MDkgY2VydGlmaWNhdGUgdG8gUEVNIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUuXG4gKiBAcGFyYW0gbWF4bGluZSB0aGUgbWF4aW11bSBjaGFyYWN0ZXJzIHBlciBsaW5lLCBkZWZhdWx0cyB0byA2NC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZm9ybWF0dGVkIGNlcnRpZmljYXRlLlxuICovXG5wa2kuY2VydGlmaWNhdGVUb1BlbSA9IGZ1bmN0aW9uKGNlcnQsIG1heGxpbmUpIHtcbiAgLy8gY29udmVydCB0byBBU04uMSwgdGhlbiBERVIsIHRoZW4gUEVNLWVuY29kZVxuICB2YXIgbXNnID0ge1xuICAgIHR5cGU6ICdDRVJUSUZJQ0FURScsXG4gICAgYm9keTogYXNuMS50b0Rlcihwa2kuY2VydGlmaWNhdGVUb0FzbjEoY2VydCkpLmdldEJ5dGVzKClcbiAgfTtcbiAgcmV0dXJuIGZvcmdlLnBlbS5lbmNvZGUobXNnLCB7bWF4bGluZTogbWF4bGluZX0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBSU0EgcHVibGljIGtleSBmcm9tIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHBlbSB0aGUgUEVNLWZvcm1hdHRlZCBwdWJsaWMga2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIHB1YmxpYyBrZXkuXG4gKi9cbnBraS5wdWJsaWNLZXlGcm9tUGVtID0gZnVuY3Rpb24ocGVtKSB7XG4gIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG5cbiAgaWYobXNnLnR5cGUgIT09ICdQVUJMSUMgS0VZJyAmJiBtc2cudHlwZSAhPT0gJ1JTQSBQVUJMSUMgS0VZJykge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgcHVibGljIGtleSBmcm9tIFBFTTsgUEVNIGhlYWRlciAnICtcbiAgICAgICd0eXBlIGlzIG5vdCBcIlBVQkxJQyBLRVlcIiBvciBcIlJTQSBQVUJMSUMgS0VZXCIuJyk7XG4gICAgZXJyb3IuaGVhZGVyVHlwZSA9IG1zZy50eXBlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIGlmKG1zZy5wcm9jVHlwZSAmJiBtc2cucHJvY1R5cGUudHlwZSA9PT0gJ0VOQ1JZUFRFRCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IHB1YmxpYyBrZXkgZnJvbSBQRU07IFBFTSBpcyBlbmNyeXB0ZWQuJyk7XG4gIH1cblxuICAvLyBjb252ZXJ0IERFUiB0byBBU04uMSBvYmplY3RcbiAgdmFyIG9iaiA9IGFzbjEuZnJvbURlcihtc2cuYm9keSk7XG5cbiAgcmV0dXJuIHBraS5wdWJsaWNLZXlGcm9tQXNuMShvYmopO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBSU0EgcHVibGljIGtleSB0byBQRU0gZm9ybWF0ICh1c2luZyBhIFN1YmplY3RQdWJsaWNLZXlJbmZvKS5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBwdWJsaWMga2V5LlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gY2hhcmFjdGVycyBwZXIgbGluZSwgZGVmYXVsdHMgdG8gNjQuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWZvcm1hdHRlZCBwdWJsaWMga2V5LlxuICovXG5wa2kucHVibGljS2V5VG9QZW0gPSBmdW5jdGlvbihrZXksIG1heGxpbmUpIHtcbiAgLy8gY29udmVydCB0byBBU04uMSwgdGhlbiBERVIsIHRoZW4gUEVNLWVuY29kZVxuICB2YXIgbXNnID0ge1xuICAgIHR5cGU6ICdQVUJMSUMgS0VZJyxcbiAgICBib2R5OiBhc24xLnRvRGVyKHBraS5wdWJsaWNLZXlUb0FzbjEoa2V5KSkuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHttYXhsaW5lOiBtYXhsaW5lfSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJTQSBwdWJsaWMga2V5IHRvIFBFTSBmb3JtYXQgKHVzaW5nIGFuIFJTQVB1YmxpY0tleSkuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgcHVibGljIGtleS5cbiAqIEBwYXJhbSBtYXhsaW5lIHRoZSBtYXhpbXVtIGNoYXJhY3RlcnMgcGVyIGxpbmUsIGRlZmF1bHRzIHRvIDY0LlxuICpcbiAqIEByZXR1cm4gdGhlIFBFTS1mb3JtYXR0ZWQgcHVibGljIGtleS5cbiAqL1xucGtpLnB1YmxpY0tleVRvUlNBUHVibGljS2V5UGVtID0gZnVuY3Rpb24oa2V5LCBtYXhsaW5lKSB7XG4gIC8vIGNvbnZlcnQgdG8gQVNOLjEsIHRoZW4gREVSLCB0aGVuIFBFTS1lbmNvZGVcbiAgdmFyIG1zZyA9IHtcbiAgICB0eXBlOiAnUlNBIFBVQkxJQyBLRVknLFxuICAgIGJvZHk6IGFzbjEudG9EZXIocGtpLnB1YmxpY0tleVRvUlNBUHVibGljS2V5KGtleSkpLmdldEJ5dGVzKClcbiAgfTtcbiAgcmV0dXJuIGZvcmdlLnBlbS5lbmNvZGUobXNnLCB7bWF4bGluZTogbWF4bGluZX0pO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgZmluZ2VycHJpbnQgZm9yIHRoZSBnaXZlbiBwdWJsaWMga2V5LlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZS5cbiAqICAgICAgICAgIFttZF0gdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UgKGRlZmF1bHRzIHRvIGZvcmdlLm1kLnNoYTEpLlxuICogICAgICAgICAgW3R5cGVdIHRoZSB0eXBlIG9mIGZpbmdlcnByaW50LCBzdWNoIGFzICdSU0FQdWJsaWNLZXknLFxuICogICAgICAgICAgICAnU3ViamVjdFB1YmxpY0tleUluZm8nIChkZWZhdWx0cyB0byAnUlNBUHVibGljS2V5JykuXG4gKiAgICAgICAgICBbZW5jb2RpbmddIGFuIGFsdGVybmF0aXZlIG91dHB1dCBlbmNvZGluZywgc3VjaCBhcyAnaGV4J1xuICogICAgICAgICAgICAoZGVmYXVsdHMgdG8gbm9uZSwgb3V0cHV0cyBhIGJ5dGUgYnVmZmVyKS5cbiAqICAgICAgICAgIFtkZWxpbWl0ZXJdIHRoZSBkZWxpbWl0ZXIgdG8gdXNlIGJldHdlZW4gYnl0ZXMgZm9yICdoZXgnIGVuY29kZWRcbiAqICAgICAgICAgICAgb3V0cHV0LCBlZzogJzonIChkZWZhdWx0cyB0byBub25lKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBmaW5nZXJwcmludCBhcyBhIGJ5dGUgYnVmZmVyIG9yIG90aGVyIGVuY29kaW5nIGJhc2VkIG9uIG9wdGlvbnMuXG4gKi9cbnBraS5nZXRQdWJsaWNLZXlGaW5nZXJwcmludCA9IGZ1bmN0aW9uKGtleSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIG1kID0gb3B0aW9ucy5tZCB8fCBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICB2YXIgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCAnUlNBUHVibGljS2V5JztcblxuICB2YXIgYnl0ZXM7XG4gIHN3aXRjaCh0eXBlKSB7XG4gICAgY2FzZSAnUlNBUHVibGljS2V5JzpcbiAgICAgIGJ5dGVzID0gYXNuMS50b0Rlcihwa2kucHVibGljS2V5VG9SU0FQdWJsaWNLZXkoa2V5KSkuZ2V0Qnl0ZXMoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1N1YmplY3RQdWJsaWNLZXlJbmZvJzpcbiAgICAgIGJ5dGVzID0gYXNuMS50b0Rlcihwa2kucHVibGljS2V5VG9Bc24xKGtleSkpLmdldEJ5dGVzKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGZpbmdlcnByaW50IHR5cGUgXCInICsgb3B0aW9ucy50eXBlICsgJ1wiLicpO1xuICB9XG5cbiAgLy8gaGFzaCBwdWJsaWMga2V5IGJ5dGVzXG4gIG1kLnN0YXJ0KCk7XG4gIG1kLnVwZGF0ZShieXRlcyk7XG4gIHZhciBkaWdlc3QgPSBtZC5kaWdlc3QoKTtcbiAgaWYob3B0aW9ucy5lbmNvZGluZyA9PT0gJ2hleCcpIHtcbiAgICB2YXIgaGV4ID0gZGlnZXN0LnRvSGV4KCk7XG4gICAgaWYob3B0aW9ucy5kZWxpbWl0ZXIpIHtcbiAgICAgIHJldHVybiBoZXgubWF0Y2goLy57Mn0vZykuam9pbihvcHRpb25zLmRlbGltaXRlcik7XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG4gIH0gZWxzZSBpZihvcHRpb25zLmVuY29kaW5nID09PSAnYmluYXJ5Jykge1xuICAgIHJldHVybiBkaWdlc3QuZ2V0Qnl0ZXMoKTtcbiAgfSBlbHNlIGlmKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcgXCInICsgb3B0aW9ucy5lbmNvZGluZyArICdcIi4nKTtcbiAgfVxuICByZXR1cm4gZGlnZXN0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFBLQ1MjMTAgY2VydGlmaWNhdGlvbiByZXF1ZXN0IChDU1IpIGZyb20gUEVNIGZvcm1hdC5cbiAqXG4gKiBOb3RlOiBJZiB0aGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGlzIHRvIGJlIHZlcmlmaWVkIHRoZW4gY29tcHV0ZSBoYXNoXG4gKiBzaG91bGQgYmUgc2V0IHRvIHRydWUuIFRoaXMgd2lsbCBzY2FuIHRoZSBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gcGFydCBvZlxuICogdGhlIEFTTi4xIG9iamVjdCB3aGlsZSBpdCBpcyBjb252ZXJ0ZWQgc28gaXQgZG9lc24ndCBuZWVkIHRvIGJlIGNvbnZlcnRlZFxuICogYmFjayB0byBBU04uMS1ERVItZW5jb2RpbmcgbGF0ZXIuXG4gKlxuICogQHBhcmFtIHBlbSB0aGUgUEVNLWZvcm1hdHRlZCBjZXJ0aWZpY2F0ZS5cbiAqIEBwYXJhbSBjb21wdXRlSGFzaCB0cnVlIHRvIGNvbXB1dGUgdGhlIGhhc2ggZm9yIHZlcmlmaWNhdGlvbi5cbiAqIEBwYXJhbSBzdHJpY3QgdHJ1ZSB0byBiZSBzdHJpY3Qgd2hlbiBjaGVja2luZyBBU04uMSB2YWx1ZSBsZW5ndGhzLCBmYWxzZSB0b1xuICogICAgICAgICAgYWxsb3cgdHJ1bmNhdGVkIHZhbHVlcyAoZGVmYXVsdDogdHJ1ZSkuXG4gKlxuICogQHJldHVybiB0aGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IChDU1IpLlxuICovXG5wa2kuY2VydGlmaWNhdGlvblJlcXVlc3RGcm9tUGVtID0gZnVuY3Rpb24ocGVtLCBjb21wdXRlSGFzaCwgc3RyaWN0KSB7XG4gIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG5cbiAgaWYobXNnLnR5cGUgIT09ICdDRVJUSUZJQ0FURSBSRVFVRVNUJykge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGZyb20gUEVNOyAnICtcbiAgICAgICdQRU0gaGVhZGVyIHR5cGUgaXMgbm90IFwiQ0VSVElGSUNBVEUgUkVRVUVTVFwiLicpO1xuICAgIGVycm9yLmhlYWRlclR5cGUgPSBtc2cudHlwZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBpZihtc2cucHJvY1R5cGUgJiYgbXNnLnByb2NUeXBlLnR5cGUgPT09ICdFTkNSWVBURUQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgZnJvbSBQRU07ICcgK1xuICAgICAgJ1BFTSBpcyBlbmNyeXB0ZWQuJyk7XG4gIH1cblxuICAvLyBjb252ZXJ0IERFUiB0byBBU04uMSBvYmplY3RcbiAgdmFyIG9iaiA9IGFzbjEuZnJvbURlcihtc2cuYm9keSwgc3RyaWN0KTtcblxuICByZXR1cm4gcGtpLmNlcnRpZmljYXRpb25SZXF1ZXN0RnJvbUFzbjEob2JqLCBjb21wdXRlSGFzaCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUEtDUyMxMCBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgKENTUikgdG8gUEVNIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gY3NyIHRoZSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gKiBAcGFyYW0gbWF4bGluZSB0aGUgbWF4aW11bSBjaGFyYWN0ZXJzIHBlciBsaW5lLCBkZWZhdWx0cyB0byA2NC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZm9ybWF0dGVkIGNlcnRpZmljYXRpb24gcmVxdWVzdC5cbiAqL1xucGtpLmNlcnRpZmljYXRpb25SZXF1ZXN0VG9QZW0gPSBmdW5jdGlvbihjc3IsIG1heGxpbmUpIHtcbiAgLy8gY29udmVydCB0byBBU04uMSwgdGhlbiBERVIsIHRoZW4gUEVNLWVuY29kZVxuICB2YXIgbXNnID0ge1xuICAgIHR5cGU6ICdDRVJUSUZJQ0FURSBSRVFVRVNUJyxcbiAgICBib2R5OiBhc24xLnRvRGVyKHBraS5jZXJ0aWZpY2F0aW9uUmVxdWVzdFRvQXNuMShjc3IpKS5nZXRCeXRlcygpXG4gIH07XG4gIHJldHVybiBmb3JnZS5wZW0uZW5jb2RlKG1zZywge21heGxpbmU6IG1heGxpbmV9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlbXB0eSBYLjUwOXYzIFJTQSBjZXJ0aWZpY2F0ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjZXJ0aWZpY2F0ZS5cbiAqL1xucGtpLmNyZWF0ZUNlcnRpZmljYXRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjZXJ0ID0ge307XG4gIGNlcnQudmVyc2lvbiA9IDB4MDI7XG4gIGNlcnQuc2VyaWFsTnVtYmVyID0gJzAwJztcbiAgY2VydC5zaWduYXR1cmVPaWQgPSBudWxsO1xuICBjZXJ0LnNpZ25hdHVyZSA9IG51bGw7XG4gIGNlcnQuc2lnaW5mbyA9IHt9O1xuICBjZXJ0LnNpZ2luZm8uYWxnb3JpdGhtT2lkID0gbnVsbDtcbiAgY2VydC52YWxpZGl0eSA9IHt9O1xuICBjZXJ0LnZhbGlkaXR5Lm5vdEJlZm9yZSA9IG5ldyBEYXRlKCk7XG4gIGNlcnQudmFsaWRpdHkubm90QWZ0ZXIgPSBuZXcgRGF0ZSgpO1xuXG4gIGNlcnQuaXNzdWVyID0ge307XG4gIGNlcnQuaXNzdWVyLmdldEZpZWxkID0gZnVuY3Rpb24oc24pIHtcbiAgICByZXR1cm4gX2dldEF0dHJpYnV0ZShjZXJ0Lmlzc3Vlciwgc24pO1xuICB9O1xuICBjZXJ0Lmlzc3Vlci5hZGRGaWVsZCA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoW2F0dHJdKTtcbiAgICBjZXJ0Lmlzc3Vlci5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gIH07XG4gIGNlcnQuaXNzdWVyLmF0dHJpYnV0ZXMgPSBbXTtcbiAgY2VydC5pc3N1ZXIuaGFzaCA9IG51bGw7XG5cbiAgY2VydC5zdWJqZWN0ID0ge307XG4gIGNlcnQuc3ViamVjdC5nZXRGaWVsZCA9IGZ1bmN0aW9uKHNuKSB7XG4gICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY2VydC5zdWJqZWN0LCBzbik7XG4gIH07XG4gIGNlcnQuc3ViamVjdC5hZGRGaWVsZCA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoW2F0dHJdKTtcbiAgICBjZXJ0LnN1YmplY3QuYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICB9O1xuICBjZXJ0LnN1YmplY3QuYXR0cmlidXRlcyA9IFtdO1xuICBjZXJ0LnN1YmplY3QuaGFzaCA9IG51bGw7XG5cbiAgY2VydC5leHRlbnNpb25zID0gW107XG4gIGNlcnQucHVibGljS2V5ID0gbnVsbDtcbiAgY2VydC5tZCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHN1YmplY3Qgb2YgdGhpcyBjZXJ0aWZpY2F0ZS5cbiAgICpcbiAgICogQHBhcmFtIGF0dHJzIHRoZSBhcnJheSBvZiBzdWJqZWN0IGF0dHJpYnV0ZXMgdG8gdXNlLlxuICAgKiBAcGFyYW0gdW5pcXVlSWQgYW4gb3B0aW9uYWwgYSB1bmlxdWUgSUQgdG8gdXNlLlxuICAgKi9cbiAgY2VydC5zZXRTdWJqZWN0ID0gZnVuY3Rpb24oYXR0cnMsIHVuaXF1ZUlkKSB7XG4gICAgLy8gc2V0IG5ldyBhdHRyaWJ1dGVzLCBjbGVhciBoYXNoXG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKGF0dHJzKTtcbiAgICBjZXJ0LnN1YmplY3QuYXR0cmlidXRlcyA9IGF0dHJzO1xuICAgIGRlbGV0ZSBjZXJ0LnN1YmplY3QudW5pcXVlSWQ7XG4gICAgaWYodW5pcXVlSWQpIHtcbiAgICAgIC8vIFRPRE86IHN1cHBvcnQgYXJiaXRyYXJ5IGJpdCBsZW5ndGggaWRzXG4gICAgICBjZXJ0LnN1YmplY3QudW5pcXVlSWQgPSB1bmlxdWVJZDtcbiAgICB9XG4gICAgY2VydC5zdWJqZWN0Lmhhc2ggPSBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpc3N1ZXIgb2YgdGhpcyBjZXJ0aWZpY2F0ZS5cbiAgICpcbiAgICogQHBhcmFtIGF0dHJzIHRoZSBhcnJheSBvZiBpc3N1ZXIgYXR0cmlidXRlcyB0byB1c2UuXG4gICAqIEBwYXJhbSB1bmlxdWVJZCBhbiBvcHRpb25hbCBhIHVuaXF1ZSBJRCB0byB1c2UuXG4gICAqL1xuICBjZXJ0LnNldElzc3VlciA9IGZ1bmN0aW9uKGF0dHJzLCB1bmlxdWVJZCkge1xuICAgIC8vIHNldCBuZXcgYXR0cmlidXRlcywgY2xlYXIgaGFzaFxuICAgIF9maWxsTWlzc2luZ0ZpZWxkcyhhdHRycyk7XG4gICAgY2VydC5pc3N1ZXIuYXR0cmlidXRlcyA9IGF0dHJzO1xuICAgIGRlbGV0ZSBjZXJ0Lmlzc3Vlci51bmlxdWVJZDtcbiAgICBpZih1bmlxdWVJZCkge1xuICAgICAgLy8gVE9ETzogc3VwcG9ydCBhcmJpdHJhcnkgYml0IGxlbmd0aCBpZHNcbiAgICAgIGNlcnQuaXNzdWVyLnVuaXF1ZUlkID0gdW5pcXVlSWQ7XG4gICAgfVxuICAgIGNlcnQuaXNzdWVyLmhhc2ggPSBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBleHRlbnNpb25zIG9mIHRoaXMgY2VydGlmaWNhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBleHRzIHRoZSBhcnJheSBvZiBleHRlbnNpb25zIHRvIHVzZS5cbiAgICovXG4gIGNlcnQuc2V0RXh0ZW5zaW9ucyA9IGZ1bmN0aW9uKGV4dHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgZXh0cy5sZW5ndGg7ICsraSkge1xuICAgICAgX2ZpbGxNaXNzaW5nRXh0ZW5zaW9uRmllbGRzKGV4dHNbaV0sIHtjZXJ0OiBjZXJ0fSk7XG4gICAgfVxuICAgIC8vIHNldCBuZXcgZXh0ZW5zaW9uc1xuICAgIGNlcnQuZXh0ZW5zaW9ucyA9IGV4dHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gZXh0ZW5zaW9uIGJ5IGl0cyBuYW1lIG9yIGlkLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgbmFtZSB0byB1c2Ugb3IgYW4gb2JqZWN0IHdpdGg6XG4gICAqICAgICAgICAgIG5hbWUgdGhlIG5hbWUgdG8gdXNlLlxuICAgKiAgICAgICAgICBpZCB0aGUgaWQgdG8gdXNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBleHRlbnNpb24gb3IgbnVsbCBpZiBub3QgZm91bmQuXG4gICAqL1xuICBjZXJ0LmdldEV4dGVuc2lvbiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdGlvbnMgPSB7bmFtZTogb3B0aW9uc307XG4gICAgfVxuXG4gICAgdmFyIHJ2YWwgPSBudWxsO1xuICAgIHZhciBleHQ7XG4gICAgZm9yKHZhciBpID0gMDsgcnZhbCA9PT0gbnVsbCAmJiBpIDwgY2VydC5leHRlbnNpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICBleHQgPSBjZXJ0LmV4dGVuc2lvbnNbaV07XG4gICAgICBpZihvcHRpb25zLmlkICYmIGV4dC5pZCA9PT0gb3B0aW9ucy5pZCkge1xuICAgICAgICBydmFsID0gZXh0O1xuICAgICAgfSBlbHNlIGlmKG9wdGlvbnMubmFtZSAmJiBleHQubmFtZSA9PT0gb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIHJ2YWwgPSBleHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydmFsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaWducyB0aGlzIGNlcnRpZmljYXRlIHVzaW5nIHRoZSBnaXZlbiBwcml2YXRlIGtleS5cbiAgICpcbiAgICogQHBhcmFtIGtleSB0aGUgcHJpdmF0ZSBrZXkgdG8gc2lnbiB3aXRoLlxuICAgKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UgKGRlZmF1bHRzIHRvIGZvcmdlLm1kLnNoYTEpLlxuICAgKi9cbiAgY2VydC5zaWduID0gZnVuY3Rpb24oa2V5LCBtZCkge1xuICAgIC8vIFRPRE86IGdldCBzaWduYXR1cmUgT0lEIGZyb20gcHJpdmF0ZSBrZXlcbiAgICBjZXJ0Lm1kID0gbWQgfHwgZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgICB2YXIgYWxnb3JpdGhtT2lkID0gb2lkc1tjZXJ0Lm1kLmFsZ29yaXRobSArICdXaXRoUlNBRW5jcnlwdGlvbiddO1xuICAgIGlmKCFhbGdvcml0aG1PaWQpIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGNvbXB1dGUgY2VydGlmaWNhdGUgZGlnZXN0LiAnICtcbiAgICAgICAgJ1Vua25vd24gbWVzc2FnZSBkaWdlc3QgYWxnb3JpdGhtIE9JRC4nKTtcbiAgICAgIGVycm9yLmFsZ29yaXRobSA9IGNlcnQubWQuYWxnb3JpdGhtO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNlcnQuc2lnbmF0dXJlT2lkID0gY2VydC5zaWdpbmZvLmFsZ29yaXRobU9pZCA9IGFsZ29yaXRobU9pZDtcblxuICAgIC8vIGdldCBUQlNDZXJ0aWZpY2F0ZSwgY29udmVydCB0byBERVJcbiAgICBjZXJ0LnRic0NlcnRpZmljYXRlID0gcGtpLmdldFRCU0NlcnRpZmljYXRlKGNlcnQpO1xuICAgIHZhciBieXRlcyA9IGFzbjEudG9EZXIoY2VydC50YnNDZXJ0aWZpY2F0ZSk7XG5cbiAgICAvLyBkaWdlc3QgYW5kIHNpZ25cbiAgICBjZXJ0Lm1kLnVwZGF0ZShieXRlcy5nZXRCeXRlcygpKTtcbiAgICBjZXJ0LnNpZ25hdHVyZSA9IGtleS5zaWduKGNlcnQubWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB2ZXJpZnkgdGhlIHNpZ25hdHVyZSBvbiB0aGUgcGFzc2VkIGNlcnRpZmljYXRlIHVzaW5nIHRoaXNcbiAgICogY2VydGlmaWNhdGUncyBwdWJsaWMga2V5LlxuICAgKlxuICAgKiBAcGFyYW0gY2hpbGQgdGhlIGNlcnRpZmljYXRlIHRvIHZlcmlmeS5cbiAgICpcbiAgICogQHJldHVybiB0cnVlIGlmIHZlcmlmaWVkLCBmYWxzZSBpZiBub3QuXG4gICAqL1xuICBjZXJ0LnZlcmlmeSA9IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgdmFyIHJ2YWwgPSBmYWxzZTtcblxuICAgIGlmKCFjZXJ0Lmlzc3VlZChjaGlsZCkpIHtcbiAgICAgIHZhciBpc3N1ZXIgPSBjaGlsZC5pc3N1ZXI7XG4gICAgICB2YXIgc3ViamVjdCA9IGNlcnQuc3ViamVjdDtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoZSBwYXJlbnQgY2VydGlmaWNhdGUgZGlkIG5vdCBpc3N1ZSB0aGUgZ2l2ZW4gY2hpbGQgJyArXG4gICAgICAgICdjZXJ0aWZpY2F0ZTsgdGhlIGNoaWxkIGNlcnRpZmljYXRlXFwncyBpc3N1ZXIgZG9lcyBub3QgbWF0Y2ggdGhlICcgK1xuICAgICAgICAncGFyZW50XFwncyBzdWJqZWN0LicpO1xuICAgICAgZXJyb3IuZXhwZWN0ZWRJc3N1ZXIgPSBzdWJqZWN0LmF0dHJpYnV0ZXM7XG4gICAgICBlcnJvci5hY3R1YWxJc3N1ZXIgPSBpc3N1ZXIuYXR0cmlidXRlcztcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHZhciBtZCA9IGNoaWxkLm1kO1xuICAgIGlmKG1kID09PSBudWxsKSB7XG4gICAgICAvLyBjcmVhdGUgZGlnZXN0IGZvciBPSUQgc2lnbmF0dXJlIHR5cGVzXG4gICAgICBtZCA9IF9jcmVhdGVTaWduYXR1cmVEaWdlc3Qoe1xuICAgICAgICBzaWduYXR1cmVPaWQ6IGNoaWxkLnNpZ25hdHVyZU9pZCxcbiAgICAgICAgdHlwZTogJ2NlcnRpZmljYXRlJ1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHByb2R1Y2UgREVSIGZvcm1hdHRlZCBUQlNDZXJ0aWZpY2F0ZSBhbmQgZGlnZXN0IGl0XG4gICAgICB2YXIgdGJzQ2VydGlmaWNhdGUgPSBjaGlsZC50YnNDZXJ0aWZpY2F0ZSB8fCBwa2kuZ2V0VEJTQ2VydGlmaWNhdGUoY2hpbGQpO1xuICAgICAgdmFyIGJ5dGVzID0gYXNuMS50b0Rlcih0YnNDZXJ0aWZpY2F0ZSk7XG4gICAgICBtZC51cGRhdGUoYnl0ZXMuZ2V0Qnl0ZXMoKSk7XG4gICAgfVxuXG4gICAgaWYobWQgIT09IG51bGwpIHtcbiAgICAgIHJ2YWwgPSBfdmVyaWZ5U2lnbmF0dXJlKHtcbiAgICAgICAgY2VydGlmaWNhdGU6IGNlcnQsIG1kOiBtZCwgc2lnbmF0dXJlOiBjaGlsZC5zaWduYXR1cmVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBydmFsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBjZXJ0aWZpY2F0ZSdzIGlzc3VlciBtYXRjaGVzIHRoZSBwYXNzZWRcbiAgICogY2VydGlmaWNhdGUncyBzdWJqZWN0LiBOb3RlIHRoYXQgbm8gc2lnbmF0dXJlIGNoZWNrIGlzIHBlcmZvcm1lZC5cbiAgICpcbiAgICogQHBhcmFtIHBhcmVudCB0aGUgY2VydGlmaWNhdGUgdG8gY2hlY2suXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiB0aGlzIGNlcnRpZmljYXRlJ3MgaXNzdWVyIG1hdGNoZXMgdGhlIHBhc3NlZCBjZXJ0aWZpY2F0ZSdzXG4gICAqICAgICAgICAgc3ViamVjdC5cbiAgICovXG4gIGNlcnQuaXNJc3N1ZXIgPSBmdW5jdGlvbihwYXJlbnQpIHtcbiAgICB2YXIgcnZhbCA9IGZhbHNlO1xuXG4gICAgdmFyIGkgPSBjZXJ0Lmlzc3VlcjtcbiAgICB2YXIgcyA9IHBhcmVudC5zdWJqZWN0O1xuXG4gICAgLy8gY29tcGFyZSBoYXNoZXMgaWYgcHJlc2VudFxuICAgIGlmKGkuaGFzaCAmJiBzLmhhc2gpIHtcbiAgICAgIHJ2YWwgPSAoaS5oYXNoID09PSBzLmhhc2gpO1xuICAgIH0gZWxzZSBpZihpLmF0dHJpYnV0ZXMubGVuZ3RoID09PSBzLmF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAvLyBhbGwgYXR0cmlidXRlcyBhcmUgdGhlIHNhbWUgc28gaXNzdWVyIG1hdGNoZXMgc3ViamVjdFxuICAgICAgcnZhbCA9IHRydWU7XG4gICAgICB2YXIgaWF0dHIsIHNhdHRyO1xuICAgICAgZm9yKHZhciBuID0gMDsgcnZhbCAmJiBuIDwgaS5hdHRyaWJ1dGVzLmxlbmd0aDsgKytuKSB7XG4gICAgICAgIGlhdHRyID0gaS5hdHRyaWJ1dGVzW25dO1xuICAgICAgICBzYXR0ciA9IHMuYXR0cmlidXRlc1tuXTtcbiAgICAgICAgaWYoaWF0dHIudHlwZSAhPT0gc2F0dHIudHlwZSB8fCBpYXR0ci52YWx1ZSAhPT0gc2F0dHIudmFsdWUpIHtcbiAgICAgICAgICAvLyBhdHRyaWJ1dGUgbWlzbWF0Y2hcbiAgICAgICAgICBydmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgY2VydGlmaWNhdGUncyBzdWJqZWN0IG1hdGNoZXMgdGhlIGlzc3VlciBvZiB0aGVcbiAgICogZ2l2ZW4gY2VydGlmaWNhdGUpLiBOb3RlIHRoYXQgbm90IHNpZ25hdHVyZSBjaGVjayBpcyBwZXJmb3JtZWQuXG4gICAqXG4gICAqIEBwYXJhbSBjaGlsZCB0aGUgY2VydGlmaWNhdGUgdG8gY2hlY2suXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiB0aGlzIGNlcnRpZmljYXRlJ3Mgc3ViamVjdCBtYXRjaGVzIHRoZSBwYXNzZWRcbiAgICogICAgICAgICBjZXJ0aWZpY2F0ZSdzIGlzc3Vlci5cbiAgICovXG4gIGNlcnQuaXNzdWVkID0gZnVuY3Rpb24oY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQuaXNJc3N1ZXIoY2VydCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgc3ViamVjdEtleUlkZW50aWZpZXIgZm9yIHRoaXMgY2VydGlmaWNhdGUgYXMgYnl0ZSBidWZmZXIuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHN1YmplY3RLZXlJZGVudGlmaWVyIGZvciB0aGlzIGNlcnRpZmljYXRlIGFzIGJ5dGUgYnVmZmVyLlxuICAgKi9cbiAgY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyID0gZnVuY3Rpb24oKSB7XG4gICAgLyogU2VlOiA0LjIuMS4yIHNlY3Rpb24gb2YgdGhlIHRoZSBSRkMzMjgwLCBrZXlJZGVudGlmaWVyIGlzIGVpdGhlcjpcblxuICAgICAgKDEpIFRoZSBrZXlJZGVudGlmaWVyIGlzIGNvbXBvc2VkIG9mIHRoZSAxNjAtYml0IFNIQS0xIGhhc2ggb2YgdGhlXG4gICAgICAgIHZhbHVlIG9mIHRoZSBCSVQgU1RSSU5HIHN1YmplY3RQdWJsaWNLZXkgKGV4Y2x1ZGluZyB0aGUgdGFnLFxuICAgICAgICBsZW5ndGgsIGFuZCBudW1iZXIgb2YgdW51c2VkIGJpdHMpLlxuXG4gICAgICAoMikgVGhlIGtleUlkZW50aWZpZXIgaXMgY29tcG9zZWQgb2YgYSBmb3VyIGJpdCB0eXBlIGZpZWxkIHdpdGhcbiAgICAgICAgdGhlIHZhbHVlIDAxMDAgZm9sbG93ZWQgYnkgdGhlIGxlYXN0IHNpZ25pZmljYW50IDYwIGJpdHMgb2YgdGhlXG4gICAgICAgIFNIQS0xIGhhc2ggb2YgdGhlIHZhbHVlIG9mIHRoZSBCSVQgU1RSSU5HIHN1YmplY3RQdWJsaWNLZXlcbiAgICAgICAgKGV4Y2x1ZGluZyB0aGUgdGFnLCBsZW5ndGgsIGFuZCBudW1iZXIgb2YgdW51c2VkIGJpdCBzdHJpbmcgYml0cykuXG4gICAgKi9cblxuICAgIC8vIHNraXBwaW5nIHRoZSB0YWcsIGxlbmd0aCwgYW5kIG51bWJlciBvZiB1bnVzZWQgYml0cyBpcyB0aGUgc2FtZVxuICAgIC8vIGFzIGp1c3QgdXNpbmcgdGhlIFJTQVB1YmxpY0tleSAoZm9yIFJTQSBrZXlzLCB3aGljaCBhcmUgdGhlXG4gICAgLy8gb25seSBvbmVzIHN1cHBvcnRlZClcbiAgICByZXR1cm4gcGtpLmdldFB1YmxpY0tleUZpbmdlcnByaW50KGNlcnQucHVibGljS2V5LCB7dHlwZTogJ1JTQVB1YmxpY0tleSd9KTtcbiAgfTtcblxuICAvKipcbiAgICogVmVyaWZpZXMgdGhlIHN1YmplY3RLZXlJZGVudGlmaWVyIGV4dGVuc2lvbiB2YWx1ZSBmb3IgdGhpcyBjZXJ0aWZpY2F0ZVxuICAgKiBhZ2FpbnN0IGl0cyBwdWJsaWMga2V5LiBJZiBubyBleHRlbnNpb24gaXMgZm91bmQsIGZhbHNlIHdpbGwgYmVcbiAgICogcmV0dXJuZWQuXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiB2ZXJpZmllZCwgZmFsc2UgaWYgbm90LlxuICAgKi9cbiAgY2VydC52ZXJpZnlTdWJqZWN0S2V5SWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvaWQgPSBvaWRzWydzdWJqZWN0S2V5SWRlbnRpZmllciddO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjZXJ0LmV4dGVuc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBleHQgPSBjZXJ0LmV4dGVuc2lvbnNbaV07XG4gICAgICBpZihleHQuaWQgPT09IG9pZCkge1xuICAgICAgICB2YXIgc2tpID0gY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyKCkuZ2V0Qnl0ZXMoKTtcbiAgICAgICAgcmV0dXJuIChmb3JnZS51dGlsLmhleFRvQnl0ZXMoZXh0LnN1YmplY3RLZXlJZGVudGlmaWVyKSA9PT0gc2tpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHJldHVybiBjZXJ0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBYLjUwOXYzIFJTQSBjZXJ0aWZpY2F0ZSBmcm9tIGFuIEFTTi4xIG9iamVjdC5cbiAqXG4gKiBOb3RlOiBJZiB0aGUgY2VydGlmaWNhdGUgaXMgdG8gYmUgdmVyaWZpZWQgdGhlbiBjb21wdXRlIGhhc2ggc2hvdWxkXG4gKiBiZSBzZXQgdG8gdHJ1ZS4gVGhlcmUgaXMgY3VycmVudGx5IG5vIGltcGxlbWVudGF0aW9uIGZvciBjb252ZXJ0aW5nXG4gKiBhIGNlcnRpZmljYXRlIGJhY2sgdG8gQVNOLjEgc28gdGhlIFRCU0NlcnRpZmljYXRlIHBhcnQgb2YgdGhlIEFTTi4xXG4gKiBvYmplY3QgbmVlZHMgdG8gYmUgc2Nhbm5lZCBiZWZvcmUgdGhlIGNlcnQgb2JqZWN0IGlzIGNyZWF0ZWQuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhbiBYLjUwOXYzIFJTQSBjZXJ0aWZpY2F0ZS5cbiAqIEBwYXJhbSBjb21wdXRlSGFzaCB0cnVlIHRvIGNvbXB1dGUgdGhlIGhhc2ggZm9yIHZlcmlmaWNhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjZXJ0aWZpY2F0ZS5cbiAqL1xucGtpLmNlcnRpZmljYXRlRnJvbUFzbjEgPSBmdW5jdGlvbihvYmosIGNvbXB1dGVIYXNoKSB7XG4gIC8vIHZhbGlkYXRlIGNlcnRpZmljYXRlIGFuZCBjYXB0dXJlIGRhdGFcbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShvYmosIHg1MDlDZXJ0aWZpY2F0ZVZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgWC41MDkgY2VydGlmaWNhdGUuICcgK1xuICAgICAgJ0FTTi4xIG9iamVjdCBpcyBub3QgYW4gWDUwOXYzIENlcnRpZmljYXRlLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGdldCBvaWRcbiAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5wdWJsaWNLZXlPaWQpO1xuICBpZihvaWQgIT09IHBraS5vaWRzLnJzYUVuY3J5cHRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHB1YmxpYyBrZXkuIE9JRCBpcyBub3QgUlNBLicpO1xuICB9XG5cbiAgLy8gY3JlYXRlIGNlcnRpZmljYXRlXG4gIHZhciBjZXJ0ID0gcGtpLmNyZWF0ZUNlcnRpZmljYXRlKCk7XG4gIGNlcnQudmVyc2lvbiA9IGNhcHR1cmUuY2VydFZlcnNpb24gP1xuICAgIGNhcHR1cmUuY2VydFZlcnNpb24uY2hhckNvZGVBdCgwKSA6IDA7XG4gIHZhciBzZXJpYWwgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLmNlcnRTZXJpYWxOdW1iZXIpO1xuICBjZXJ0LnNlcmlhbE51bWJlciA9IHNlcmlhbC50b0hleCgpO1xuICBjZXJ0LnNpZ25hdHVyZU9pZCA9IGZvcmdlLmFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jZXJ0U2lnbmF0dXJlT2lkKTtcbiAgY2VydC5zaWduYXR1cmVQYXJhbWV0ZXJzID0gX3JlYWRTaWduYXR1cmVQYXJhbWV0ZXJzKFxuICAgIGNlcnQuc2lnbmF0dXJlT2lkLCBjYXB0dXJlLmNlcnRTaWduYXR1cmVQYXJhbXMsIHRydWUpO1xuICBjZXJ0LnNpZ2luZm8uYWxnb3JpdGhtT2lkID0gZm9yZ2UuYXNuMS5kZXJUb09pZChjYXB0dXJlLmNlcnRpbmZvU2lnbmF0dXJlT2lkKTtcbiAgY2VydC5zaWdpbmZvLnBhcmFtZXRlcnMgPSBfcmVhZFNpZ25hdHVyZVBhcmFtZXRlcnMoY2VydC5zaWdpbmZvLmFsZ29yaXRobU9pZCxcbiAgICBjYXB0dXJlLmNlcnRpbmZvU2lnbmF0dXJlUGFyYW1zLCBmYWxzZSk7XG4gIGNlcnQuc2lnbmF0dXJlID0gY2FwdHVyZS5jZXJ0U2lnbmF0dXJlO1xuXG4gIHZhciB2YWxpZGl0eSA9IFtdO1xuICBpZihjYXB0dXJlLmNlcnRWYWxpZGl0eTFVVENUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWxpZGl0eS5wdXNoKGFzbjEudXRjVGltZVRvRGF0ZShjYXB0dXJlLmNlcnRWYWxpZGl0eTFVVENUaW1lKSk7XG4gIH1cbiAgaWYoY2FwdHVyZS5jZXJ0VmFsaWRpdHkyR2VuZXJhbGl6ZWRUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWxpZGl0eS5wdXNoKGFzbjEuZ2VuZXJhbGl6ZWRUaW1lVG9EYXRlKFxuICAgICAgY2FwdHVyZS5jZXJ0VmFsaWRpdHkyR2VuZXJhbGl6ZWRUaW1lKSk7XG4gIH1cbiAgaWYoY2FwdHVyZS5jZXJ0VmFsaWRpdHkzVVRDVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRpdHkucHVzaChhc24xLnV0Y1RpbWVUb0RhdGUoY2FwdHVyZS5jZXJ0VmFsaWRpdHkzVVRDVGltZSkpO1xuICB9XG4gIGlmKGNhcHR1cmUuY2VydFZhbGlkaXR5NEdlbmVyYWxpemVkVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRpdHkucHVzaChhc24xLmdlbmVyYWxpemVkVGltZVRvRGF0ZShcbiAgICAgIGNhcHR1cmUuY2VydFZhbGlkaXR5NEdlbmVyYWxpemVkVGltZSkpO1xuICB9XG4gIGlmKHZhbGlkaXR5Lmxlbmd0aCA+IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIG5vdEJlZm9yZS9ub3RBZnRlciB2YWxpZGl0eSB0aW1lczsgbW9yZSAnICtcbiAgICAgICd0aGFuIHR3byB0aW1lcyB3ZXJlIHByb3ZpZGVkIGluIHRoZSBjZXJ0aWZpY2F0ZS4nKTtcbiAgfVxuICBpZih2YWxpZGl0eS5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBub3RCZWZvcmUvbm90QWZ0ZXIgdmFsaWRpdHkgdGltZXM7IHRoZXkgJyArXG4gICAgICAnd2VyZSBub3QgcHJvdmlkZWQgYXMgZWl0aGVyIFVUQ1RpbWUgb3IgR2VuZXJhbGl6ZWRUaW1lLicpO1xuICB9XG4gIGNlcnQudmFsaWRpdHkubm90QmVmb3JlID0gdmFsaWRpdHlbMF07XG4gIGNlcnQudmFsaWRpdHkubm90QWZ0ZXIgPSB2YWxpZGl0eVsxXTtcblxuICAvLyBrZWVwIFRCU0NlcnRpZmljYXRlIHRvIHByZXNlcnZlIHNpZ25hdHVyZSB3aGVuIGV4cG9ydGluZ1xuICBjZXJ0LnRic0NlcnRpZmljYXRlID0gY2FwdHVyZS50YnNDZXJ0aWZpY2F0ZTtcblxuICBpZihjb21wdXRlSGFzaCkge1xuICAgIC8vIGNyZWF0ZSBkaWdlc3QgZm9yIE9JRCBzaWduYXR1cmUgdHlwZVxuICAgIGNlcnQubWQgPSBfY3JlYXRlU2lnbmF0dXJlRGlnZXN0KHtcbiAgICAgIHNpZ25hdHVyZU9pZDogY2VydC5zaWduYXR1cmVPaWQsXG4gICAgICB0eXBlOiAnY2VydGlmaWNhdGUnXG4gICAgfSk7XG5cbiAgICAvLyBwcm9kdWNlIERFUiBmb3JtYXR0ZWQgVEJTQ2VydGlmaWNhdGUgYW5kIGRpZ2VzdCBpdFxuICAgIHZhciBieXRlcyA9IGFzbjEudG9EZXIoY2VydC50YnNDZXJ0aWZpY2F0ZSk7XG4gICAgY2VydC5tZC51cGRhdGUoYnl0ZXMuZ2V0Qnl0ZXMoKSk7XG4gIH1cblxuICAvLyBoYW5kbGUgaXNzdWVyLCBidWlsZCBpc3N1ZXIgbWVzc2FnZSBkaWdlc3RcbiAgdmFyIGltZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIHZhciBpYnl0ZXMgPSBhc24xLnRvRGVyKGNhcHR1cmUuY2VydElzc3Vlcik7XG4gIGltZC51cGRhdGUoaWJ5dGVzLmdldEJ5dGVzKCkpO1xuICBjZXJ0Lmlzc3Vlci5nZXRGaWVsZCA9IGZ1bmN0aW9uKHNuKSB7XG4gICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY2VydC5pc3N1ZXIsIHNuKTtcbiAgfTtcbiAgY2VydC5pc3N1ZXIuYWRkRmllbGQgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgY2VydC5pc3N1ZXIuYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICB9O1xuICBjZXJ0Lmlzc3Vlci5hdHRyaWJ1dGVzID0gcGtpLlJETkF0dHJpYnV0ZXNBc0FycmF5KGNhcHR1cmUuY2VydElzc3Vlcik7XG4gIGlmKGNhcHR1cmUuY2VydElzc3VlclVuaXF1ZUlkKSB7XG4gICAgY2VydC5pc3N1ZXIudW5pcXVlSWQgPSBjYXB0dXJlLmNlcnRJc3N1ZXJVbmlxdWVJZDtcbiAgfVxuICBjZXJ0Lmlzc3Vlci5oYXNoID0gaW1kLmRpZ2VzdCgpLnRvSGV4KCk7XG5cbiAgLy8gaGFuZGxlIHN1YmplY3QsIGJ1aWxkIHN1YmplY3QgbWVzc2FnZSBkaWdlc3RcbiAgdmFyIHNtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIHZhciBzYnl0ZXMgPSBhc24xLnRvRGVyKGNhcHR1cmUuY2VydFN1YmplY3QpO1xuICBzbWQudXBkYXRlKHNieXRlcy5nZXRCeXRlcygpKTtcbiAgY2VydC5zdWJqZWN0LmdldEZpZWxkID0gZnVuY3Rpb24oc24pIHtcbiAgICByZXR1cm4gX2dldEF0dHJpYnV0ZShjZXJ0LnN1YmplY3QsIHNuKTtcbiAgfTtcbiAgY2VydC5zdWJqZWN0LmFkZEZpZWxkID0gZnVuY3Rpb24oYXR0cikge1xuICAgIF9maWxsTWlzc2luZ0ZpZWxkcyhbYXR0cl0pO1xuICAgIGNlcnQuc3ViamVjdC5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gIH07XG4gIGNlcnQuc3ViamVjdC5hdHRyaWJ1dGVzID0gcGtpLlJETkF0dHJpYnV0ZXNBc0FycmF5KGNhcHR1cmUuY2VydFN1YmplY3QpO1xuICBpZihjYXB0dXJlLmNlcnRTdWJqZWN0VW5pcXVlSWQpIHtcbiAgICBjZXJ0LnN1YmplY3QudW5pcXVlSWQgPSBjYXB0dXJlLmNlcnRTdWJqZWN0VW5pcXVlSWQ7XG4gIH1cbiAgY2VydC5zdWJqZWN0Lmhhc2ggPSBzbWQuZGlnZXN0KCkudG9IZXgoKTtcblxuICAvLyBoYW5kbGUgZXh0ZW5zaW9uc1xuICBpZihjYXB0dXJlLmNlcnRFeHRlbnNpb25zKSB7XG4gICAgY2VydC5leHRlbnNpb25zID0gcGtpLmNlcnRpZmljYXRlRXh0ZW5zaW9uc0Zyb21Bc24xKGNhcHR1cmUuY2VydEV4dGVuc2lvbnMpO1xuICB9IGVsc2Uge1xuICAgIGNlcnQuZXh0ZW5zaW9ucyA9IFtdO1xuICB9XG5cbiAgLy8gY29udmVydCBSU0EgcHVibGljIGtleSBmcm9tIEFTTi4xXG4gIGNlcnQucHVibGljS2V5ID0gcGtpLnB1YmxpY0tleUZyb21Bc24xKGNhcHR1cmUuc3ViamVjdFB1YmxpY0tleUluZm8pO1xuXG4gIHJldHVybiBjZXJ0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBBU04uMSBleHRlbnNpb25zIG9iamVjdCAod2l0aCBleHRlbnNpb24gc2VxdWVuY2VzIGFzIGl0c1xuICogdmFsdWVzKSBpbnRvIGFuIGFycmF5IG9mIGV4dGVuc2lvbiBvYmplY3RzIHdpdGggdHlwZXMgYW5kIHZhbHVlcy5cbiAqXG4gKiBTdXBwb3J0ZWQgZXh0ZW5zaW9uczpcbiAqXG4gKiBpZC1jZS1rZXlVc2FnZSBPQkpFQ1QgSURFTlRJRklFUiA6Oj0gIHsgaWQtY2UgMTUgfVxuICogS2V5VXNhZ2UgOjo9IEJJVCBTVFJJTkcge1xuICogICBkaWdpdGFsU2lnbmF0dXJlICAgICAgICAoMCksXG4gKiAgIG5vblJlcHVkaWF0aW9uICAgICAgICAgICgxKSxcbiAqICAga2V5RW5jaXBoZXJtZW50ICAgICAgICAgKDIpLFxuICogICBkYXRhRW5jaXBoZXJtZW50ICAgICAgICAoMyksXG4gKiAgIGtleUFncmVlbWVudCAgICAgICAgICAgICg0KSxcbiAqICAga2V5Q2VydFNpZ24gICAgICAgICAgICAgKDUpLFxuICogICBjUkxTaWduICAgICAgICAgICAgICAgICAoNiksXG4gKiAgIGVuY2lwaGVyT25seSAgICAgICAgICAgICg3KSxcbiAqICAgZGVjaXBoZXJPbmx5ICAgICAgICAgICAgKDgpXG4gKiB9XG4gKlxuICogaWQtY2UtYmFzaWNDb25zdHJhaW50cyBPQkpFQ1QgSURFTlRJRklFUiA6Oj0gIHsgaWQtY2UgMTkgfVxuICogQmFzaWNDb25zdHJhaW50cyA6Oj0gU0VRVUVOQ0Uge1xuICogICBjQSAgICAgICAgICAgICAgICAgICAgICBCT09MRUFOIERFRkFVTFQgRkFMU0UsXG4gKiAgIHBhdGhMZW5Db25zdHJhaW50ICAgICAgIElOVEVHRVIgKDAuLk1BWCkgT1BUSU9OQUxcbiAqIH1cbiAqXG4gKiBzdWJqZWN0QWx0TmFtZSBFWFRFTlNJT04gOjo9IHtcbiAqICAgU1lOVEFYIEdlbmVyYWxOYW1lc1xuICogICBJREVOVElGSUVEIEJZIGlkLWNlLXN1YmplY3RBbHROYW1lXG4gKiB9XG4gKlxuICogR2VuZXJhbE5hbWVzIDo6PSBTRVFVRU5DRSBTSVpFICgxLi5NQVgpIE9GIEdlbmVyYWxOYW1lXG4gKlxuICogR2VuZXJhbE5hbWUgOjo9IENIT0lDRSB7XG4gKiAgIG90aGVyTmFtZSAgICAgIFswXSBJTlNUQU5DRSBPRiBPVEhFUi1OQU1FLFxuICogICByZmM4MjJOYW1lICAgICBbMV0gSUE1U3RyaW5nLFxuICogICBkTlNOYW1lICAgICAgICBbMl0gSUE1U3RyaW5nLFxuICogICB4NDAwQWRkcmVzcyAgICBbM10gT1JBZGRyZXNzLFxuICogICBkaXJlY3RvcnlOYW1lICBbNF0gTmFtZSxcbiAqICAgZWRpUGFydHlOYW1lICAgWzVdIEVESVBhcnR5TmFtZSxcbiAqICAgdW5pZm9ybVJlc291cmNlSWRlbnRpZmllciBbNl0gSUE1U3RyaW5nLFxuICogICBJUEFkZHJlc3MgICAgICBbN10gT0NURVQgU1RSSU5HLFxuICogICByZWdpc3RlcmVkSUQgICBbOF0gT0JKRUNUIElERU5USUZJRVJcbiAqIH1cbiAqXG4gKiBPVEhFUi1OQU1FIDo6PSBUWVBFLUlERU5USUZJRVJcbiAqXG4gKiBFRElQYXJ0eU5hbWUgOjo9IFNFUVVFTkNFIHtcbiAqICAgbmFtZUFzc2lnbmVyIFswXSBEaXJlY3RvcnlTdHJpbmcge3ViLW5hbWV9IE9QVElPTkFMLFxuICogICBwYXJ0eU5hbWUgICAgWzFdIERpcmVjdG9yeVN0cmluZyB7dWItbmFtZX1cbiAqIH1cbiAqXG4gKiBAcGFyYW0gZXh0cyB0aGUgZXh0ZW5zaW9ucyBBU04uMSB3aXRoIGV4dGVuc2lvbiBzZXF1ZW5jZXMgdG8gcGFyc2UuXG4gKlxuICogQHJldHVybiB0aGUgYXJyYXkuXG4gKi9cbnBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbnNGcm9tQXNuMSA9IGZ1bmN0aW9uKGV4dHMpIHtcbiAgdmFyIHJ2YWwgPSBbXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGV4dHMudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBnZXQgZXh0ZW5zaW9uIHNlcXVlbmNlXG4gICAgdmFyIGV4dHNlcSA9IGV4dHMudmFsdWVbaV07XG4gICAgZm9yKHZhciBlaSA9IDA7IGVpIDwgZXh0c2VxLnZhbHVlLmxlbmd0aDsgKytlaSkge1xuICAgICAgcnZhbC5wdXNoKHBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbkZyb21Bc24xKGV4dHNlcS52YWx1ZVtlaV0pKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgc2luZ2xlIGNlcnRpZmljYXRlIGV4dGVuc2lvbiBmcm9tIEFTTi4xLlxuICpcbiAqIEBwYXJhbSBleHQgdGhlIGV4dGVuc2lvbiBpbiBBU04uMSBmb3JtYXQuXG4gKlxuICogQHJldHVybiB0aGUgcGFyc2VkIGV4dGVuc2lvbiBhcyBhbiBvYmplY3QuXG4gKi9cbnBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbkZyb21Bc24xID0gZnVuY3Rpb24oZXh0KSB7XG4gIC8vIGFuIGV4dGVuc2lvbiBoYXM6XG4gIC8vIFswXSBleHRuSUQgICAgICBPQkpFQ1QgSURFTlRJRklFUlxuICAvLyBbMV0gY3JpdGljYWwgICAgQk9PTEVBTiBERUZBVUxUIEZBTFNFXG4gIC8vIFsyXSBleHRuVmFsdWUgICBPQ1RFVCBTVFJJTkdcbiAgdmFyIGUgPSB7fTtcbiAgZS5pZCA9IGFzbjEuZGVyVG9PaWQoZXh0LnZhbHVlWzBdLnZhbHVlKTtcbiAgZS5jcml0aWNhbCA9IGZhbHNlO1xuICBpZihleHQudmFsdWVbMV0udHlwZSA9PT0gYXNuMS5UeXBlLkJPT0xFQU4pIHtcbiAgICBlLmNyaXRpY2FsID0gKGV4dC52YWx1ZVsxXS52YWx1ZS5jaGFyQ29kZUF0KDApICE9PSAweDAwKTtcbiAgICBlLnZhbHVlID0gZXh0LnZhbHVlWzJdLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGUudmFsdWUgPSBleHQudmFsdWVbMV0udmFsdWU7XG4gIH1cbiAgLy8gaWYgdGhlIG9pZCBpcyBrbm93biwgZ2V0IGl0cyBuYW1lXG4gIGlmKGUuaWQgaW4gb2lkcykge1xuICAgIGUubmFtZSA9IG9pZHNbZS5pZF07XG5cbiAgICAvLyBoYW5kbGUga2V5IHVzYWdlXG4gICAgaWYoZS5uYW1lID09PSAna2V5VXNhZ2UnKSB7XG4gICAgICAvLyBnZXQgdmFsdWUgYXMgQklUIFNUUklOR1xuICAgICAgdmFyIGV2ID0gYXNuMS5mcm9tRGVyKGUudmFsdWUpO1xuICAgICAgdmFyIGIyID0gMHgwMDtcbiAgICAgIHZhciBiMyA9IDB4MDA7XG4gICAgICBpZihldi52YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIHNraXAgZmlyc3QgYnl0ZSwganVzdCBpbmRpY2F0ZXMgdW51c2VkIGJpdHMgd2hpY2hcbiAgICAgICAgLy8gd2lsbCBiZSBwYWRkZWQgd2l0aCAwcyBhbnl3YXlcbiAgICAgICAgLy8gZ2V0IGJ5dGVzIHdpdGggZmxhZyBiaXRzXG4gICAgICAgIGIyID0gZXYudmFsdWUuY2hhckNvZGVBdCgxKTtcbiAgICAgICAgYjMgPSBldi52YWx1ZS5sZW5ndGggPiAyID8gZXYudmFsdWUuY2hhckNvZGVBdCgyKSA6IDA7XG4gICAgICB9XG4gICAgICAvLyBzZXQgZmxhZ3NcbiAgICAgIGUuZGlnaXRhbFNpZ25hdHVyZSA9IChiMiAmIDB4ODApID09PSAweDgwO1xuICAgICAgZS5ub25SZXB1ZGlhdGlvbiA9IChiMiAmIDB4NDApID09PSAweDQwO1xuICAgICAgZS5rZXlFbmNpcGhlcm1lbnQgPSAoYjIgJiAweDIwKSA9PT0gMHgyMDtcbiAgICAgIGUuZGF0YUVuY2lwaGVybWVudCA9IChiMiAmIDB4MTApID09PSAweDEwO1xuICAgICAgZS5rZXlBZ3JlZW1lbnQgPSAoYjIgJiAweDA4KSA9PT0gMHgwODtcbiAgICAgIGUua2V5Q2VydFNpZ24gPSAoYjIgJiAweDA0KSA9PT0gMHgwNDtcbiAgICAgIGUuY1JMU2lnbiA9IChiMiAmIDB4MDIpID09PSAweDAyO1xuICAgICAgZS5lbmNpcGhlck9ubHkgPSAoYjIgJiAweDAxKSA9PT0gMHgwMTtcbiAgICAgIGUuZGVjaXBoZXJPbmx5ID0gKGIzICYgMHg4MCkgPT09IDB4ODA7XG4gICAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ2Jhc2ljQ29uc3RyYWludHMnKSB7XG4gICAgICAvLyBoYW5kbGUgYmFzaWMgY29uc3RyYWludHNcbiAgICAgIC8vIGdldCB2YWx1ZSBhcyBTRVFVRU5DRVxuICAgICAgdmFyIGV2ID0gYXNuMS5mcm9tRGVyKGUudmFsdWUpO1xuICAgICAgLy8gZ2V0IGNBIEJPT0xFQU4gZmxhZyAoZGVmYXVsdHMgdG8gZmFsc2UpXG4gICAgICBpZihldi52YWx1ZS5sZW5ndGggPiAwICYmIGV2LnZhbHVlWzBdLnR5cGUgPT09IGFzbjEuVHlwZS5CT09MRUFOKSB7XG4gICAgICAgIGUuY0EgPSAoZXYudmFsdWVbMF0udmFsdWUuY2hhckNvZGVBdCgwKSAhPT0gMHgwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlLmNBID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBnZXQgcGF0aCBsZW5ndGggY29uc3RyYWludFxuICAgICAgdmFyIHZhbHVlID0gbnVsbDtcbiAgICAgIGlmKGV2LnZhbHVlLmxlbmd0aCA+IDAgJiYgZXYudmFsdWVbMF0udHlwZSA9PT0gYXNuMS5UeXBlLklOVEVHRVIpIHtcbiAgICAgICAgdmFsdWUgPSBldi52YWx1ZVswXS52YWx1ZTtcbiAgICAgIH0gZWxzZSBpZihldi52YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhbHVlID0gZXYudmFsdWVbMV0udmFsdWU7XG4gICAgICB9XG4gICAgICBpZih2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBlLnBhdGhMZW5Db25zdHJhaW50ID0gYXNuMS5kZXJUb0ludGVnZXIodmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihlLm5hbWUgPT09ICdleHRLZXlVc2FnZScpIHtcbiAgICAgIC8vIGhhbmRsZSBleHRLZXlVc2FnZVxuICAgICAgLy8gdmFsdWUgaXMgYSBTRVFVRU5DRSBvZiBPSURzXG4gICAgICB2YXIgZXYgPSBhc24xLmZyb21EZXIoZS52YWx1ZSk7XG4gICAgICBmb3IodmFyIHZpID0gMDsgdmkgPCBldi52YWx1ZS5sZW5ndGg7ICsrdmkpIHtcbiAgICAgICAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoZXYudmFsdWVbdmldLnZhbHVlKTtcbiAgICAgICAgaWYob2lkIGluIG9pZHMpIHtcbiAgICAgICAgICBlW29pZHNbb2lkXV0gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVbb2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoZS5uYW1lID09PSAnbnNDZXJ0VHlwZScpIHtcbiAgICAgIC8vIGhhbmRsZSBuc0NlcnRUeXBlXG4gICAgICAvLyBnZXQgdmFsdWUgYXMgQklUIFNUUklOR1xuICAgICAgdmFyIGV2ID0gYXNuMS5mcm9tRGVyKGUudmFsdWUpO1xuICAgICAgdmFyIGIyID0gMHgwMDtcbiAgICAgIGlmKGV2LnZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gc2tpcCBmaXJzdCBieXRlLCBqdXN0IGluZGljYXRlcyB1bnVzZWQgYml0cyB3aGljaFxuICAgICAgICAvLyB3aWxsIGJlIHBhZGRlZCB3aXRoIDBzIGFueXdheVxuICAgICAgICAvLyBnZXQgYnl0ZXMgd2l0aCBmbGFnIGJpdHNcbiAgICAgICAgYjIgPSBldi52YWx1ZS5jaGFyQ29kZUF0KDEpO1xuICAgICAgfVxuICAgICAgLy8gc2V0IGZsYWdzXG4gICAgICBlLmNsaWVudCA9IChiMiAmIDB4ODApID09PSAweDgwO1xuICAgICAgZS5zZXJ2ZXIgPSAoYjIgJiAweDQwKSA9PT0gMHg0MDtcbiAgICAgIGUuZW1haWwgPSAoYjIgJiAweDIwKSA9PT0gMHgyMDtcbiAgICAgIGUub2Jqc2lnbiA9IChiMiAmIDB4MTApID09PSAweDEwO1xuICAgICAgZS5yZXNlcnZlZCA9IChiMiAmIDB4MDgpID09PSAweDA4O1xuICAgICAgZS5zc2xDQSA9IChiMiAmIDB4MDQpID09PSAweDA0O1xuICAgICAgZS5lbWFpbENBID0gKGIyICYgMHgwMikgPT09IDB4MDI7XG4gICAgICBlLm9iakNBID0gKGIyICYgMHgwMSkgPT09IDB4MDE7XG4gICAgfSBlbHNlIGlmKFxuICAgICAgZS5uYW1lID09PSAnc3ViamVjdEFsdE5hbWUnIHx8XG4gICAgICBlLm5hbWUgPT09ICdpc3N1ZXJBbHROYW1lJykge1xuICAgICAgLy8gaGFuZGxlIHN1YmplY3RBbHROYW1lL2lzc3VlckFsdE5hbWVcbiAgICAgIGUuYWx0TmFtZXMgPSBbXTtcblxuICAgICAgLy8gZXYgaXMgYSBTWU5UQVggU0VRVUVOQ0VcbiAgICAgIHZhciBnbjtcbiAgICAgIHZhciBldiA9IGFzbjEuZnJvbURlcihlLnZhbHVlKTtcbiAgICAgIGZvcih2YXIgbiA9IDA7IG4gPCBldi52YWx1ZS5sZW5ndGg7ICsrbikge1xuICAgICAgICAvLyBnZXQgR2VuZXJhbE5hbWVcbiAgICAgICAgZ24gPSBldi52YWx1ZVtuXTtcblxuICAgICAgICB2YXIgYWx0TmFtZSA9IHtcbiAgICAgICAgICB0eXBlOiBnbi50eXBlLFxuICAgICAgICAgIHZhbHVlOiBnbi52YWx1ZVxuICAgICAgICB9O1xuICAgICAgICBlLmFsdE5hbWVzLnB1c2goYWx0TmFtZSk7XG5cbiAgICAgICAgLy8gTm90ZTogU3VwcG9ydCBmb3IgdHlwZXMgMSwyLDYsNyw4XG4gICAgICAgIHN3aXRjaChnbi50eXBlKSB7XG4gICAgICAgICAgLy8gcmZjODIyTmFtZVxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAvLyBkTlNOYW1lXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIC8vIHVuaWZvcm1SZXNvdXJjZUlkZW50aWZpZXIgKFVSSSlcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBJUEFkZHJlc3NcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAvLyBjb252ZXJ0IHRvIElQdjQvSVB2NiBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICAgICAgICAgIGFsdE5hbWUuaXAgPSBmb3JnZS51dGlsLmJ5dGVzVG9JUChnbi52YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyByZWdpc3RlcmVkSURcbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBhbHROYW1lLm9pZCA9IGFzbjEuZGVyVG9PaWQoZ24udmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIHVuc3VwcG9ydGVkXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoZS5uYW1lID09PSAnc3ViamVjdEtleUlkZW50aWZpZXInKSB7XG4gICAgICAvLyB2YWx1ZSBpcyBhbiBPQ1RFVFNUUklORyB3L3RoZSBoYXNoIG9mIHRoZSBrZXktdHlwZSBzcGVjaWZpY1xuICAgICAgLy8gcHVibGljIGtleSBzdHJ1Y3R1cmUgKGVnOiBSU0FQdWJsaWNLZXkpXG4gICAgICB2YXIgZXYgPSBhc24xLmZyb21EZXIoZS52YWx1ZSk7XG4gICAgICBlLnN1YmplY3RLZXlJZGVudGlmaWVyID0gZm9yZ2UudXRpbC5ieXRlc1RvSGV4KGV2LnZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUEtDUyMxMCBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgKENTUikgZnJvbSBhbiBBU04uMSBvYmplY3QuXG4gKlxuICogTm90ZTogSWYgdGhlIGNlcnRpZmljYXRpb24gcmVxdWVzdCBpcyB0byBiZSB2ZXJpZmllZCB0aGVuIGNvbXB1dGUgaGFzaFxuICogc2hvdWxkIGJlIHNldCB0byB0cnVlLiBUaGVyZSBpcyBjdXJyZW50bHkgbm8gaW1wbGVtZW50YXRpb24gZm9yIGNvbnZlcnRpbmdcbiAqIGEgY2VydGlmaWNhdGUgYmFjayB0byBBU04uMSBzbyB0aGUgQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIHBhcnQgb2YgdGhlXG4gKiBBU04uMSBvYmplY3QgbmVlZHMgdG8gYmUgc2Nhbm5lZCBiZWZvcmUgdGhlIGNzciBvYmplY3QgaXMgY3JlYXRlZC5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBhc24xIHJlcHJlc2VudGF0aW9uIG9mIGEgUEtDUyMxMCBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgKENTUikuXG4gKiBAcGFyYW0gY29tcHV0ZUhhc2ggdHJ1ZSB0byBjb21wdXRlIHRoZSBoYXNoIGZvciB2ZXJpZmljYXRpb24uXG4gKlxuICogQHJldHVybiB0aGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IChDU1IpLlxuICovXG5wa2kuY2VydGlmaWNhdGlvblJlcXVlc3RGcm9tQXNuMSA9IGZ1bmN0aW9uKG9iaiwgY29tcHV0ZUhhc2gpIHtcbiAgLy8gdmFsaWRhdGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGFuZCBjYXB0dXJlIGRhdGFcbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShvYmosIGNlcnRpZmljYXRpb25SZXF1ZXN0VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBQS0NTIzEwIGNlcnRpZmljYXRlIHJlcXVlc3QuICcgK1xuICAgICAgJ0FTTi4xIG9iamVjdCBpcyBub3QgYSBQS0NTIzEwIENlcnRpZmljYXRpb25SZXF1ZXN0LicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGdldCBvaWRcbiAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5wdWJsaWNLZXlPaWQpO1xuICBpZihvaWQgIT09IHBraS5vaWRzLnJzYUVuY3J5cHRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHB1YmxpYyBrZXkuIE9JRCBpcyBub3QgUlNBLicpO1xuICB9XG5cbiAgLy8gY3JlYXRlIGNlcnRpZmljYXRpb24gcmVxdWVzdFxuICB2YXIgY3NyID0gcGtpLmNyZWF0ZUNlcnRpZmljYXRpb25SZXF1ZXN0KCk7XG4gIGNzci52ZXJzaW9uID0gY2FwdHVyZS5jc3JWZXJzaW9uID8gY2FwdHVyZS5jc3JWZXJzaW9uLmNoYXJDb2RlQXQoMCkgOiAwO1xuICBjc3Iuc2lnbmF0dXJlT2lkID0gZm9yZ2UuYXNuMS5kZXJUb09pZChjYXB0dXJlLmNzclNpZ25hdHVyZU9pZCk7XG4gIGNzci5zaWduYXR1cmVQYXJhbWV0ZXJzID0gX3JlYWRTaWduYXR1cmVQYXJhbWV0ZXJzKFxuICAgIGNzci5zaWduYXR1cmVPaWQsIGNhcHR1cmUuY3NyU2lnbmF0dXJlUGFyYW1zLCB0cnVlKTtcbiAgY3NyLnNpZ2luZm8uYWxnb3JpdGhtT2lkID0gZm9yZ2UuYXNuMS5kZXJUb09pZChjYXB0dXJlLmNzclNpZ25hdHVyZU9pZCk7XG4gIGNzci5zaWdpbmZvLnBhcmFtZXRlcnMgPSBfcmVhZFNpZ25hdHVyZVBhcmFtZXRlcnMoXG4gICAgY3NyLnNpZ2luZm8uYWxnb3JpdGhtT2lkLCBjYXB0dXJlLmNzclNpZ25hdHVyZVBhcmFtcywgZmFsc2UpO1xuICBjc3Iuc2lnbmF0dXJlID0gY2FwdHVyZS5jc3JTaWduYXR1cmU7XG5cbiAgLy8ga2VlcCBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gdG8gcHJlc2VydmUgc2lnbmF0dXJlIHdoZW4gZXhwb3J0aW5nXG4gIGNzci5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gPSBjYXB0dXJlLmNlcnRpZmljYXRpb25SZXF1ZXN0SW5mbztcblxuICBpZihjb21wdXRlSGFzaCkge1xuICAgIC8vIGNyZWF0ZSBkaWdlc3QgZm9yIE9JRCBzaWduYXR1cmUgdHlwZVxuICAgIGNzci5tZCA9IF9jcmVhdGVTaWduYXR1cmVEaWdlc3Qoe1xuICAgICAgc2lnbmF0dXJlT2lkOiBjc3Iuc2lnbmF0dXJlT2lkLFxuICAgICAgdHlwZTogJ2NlcnRpZmljYXRpb24gcmVxdWVzdCdcbiAgICB9KTtcblxuICAgIC8vIHByb2R1Y2UgREVSIGZvcm1hdHRlZCBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gYW5kIGRpZ2VzdCBpdFxuICAgIHZhciBieXRlcyA9IGFzbjEudG9EZXIoY3NyLmNlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyk7XG4gICAgY3NyLm1kLnVwZGF0ZShieXRlcy5nZXRCeXRlcygpKTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBzdWJqZWN0LCBidWlsZCBzdWJqZWN0IG1lc3NhZ2UgZGlnZXN0XG4gIHZhciBzbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICBjc3Iuc3ViamVjdC5nZXRGaWVsZCA9IGZ1bmN0aW9uKHNuKSB7XG4gICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY3NyLnN1YmplY3QsIHNuKTtcbiAgfTtcbiAgY3NyLnN1YmplY3QuYWRkRmllbGQgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgY3NyLnN1YmplY3QuYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICB9O1xuICBjc3Iuc3ViamVjdC5hdHRyaWJ1dGVzID0gcGtpLlJETkF0dHJpYnV0ZXNBc0FycmF5KFxuICAgIGNhcHR1cmUuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvU3ViamVjdCwgc21kKTtcbiAgY3NyLnN1YmplY3QuaGFzaCA9IHNtZC5kaWdlc3QoKS50b0hleCgpO1xuXG4gIC8vIGNvbnZlcnQgUlNBIHB1YmxpYyBrZXkgZnJvbSBBU04uMVxuICBjc3IucHVibGljS2V5ID0gcGtpLnB1YmxpY0tleUZyb21Bc24xKGNhcHR1cmUuc3ViamVjdFB1YmxpY0tleUluZm8pO1xuXG4gIC8vIGNvbnZlcnQgYXR0cmlidXRlcyBmcm9tIEFTTi4xXG4gIGNzci5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbihzbikge1xuICAgIHJldHVybiBfZ2V0QXR0cmlidXRlKGNzciwgc24pO1xuICB9O1xuICBjc3IuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24oYXR0cikge1xuICAgIF9maWxsTWlzc2luZ0ZpZWxkcyhbYXR0cl0pO1xuICAgIGNzci5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gIH07XG4gIGNzci5hdHRyaWJ1dGVzID0gcGtpLkNSSUF0dHJpYnV0ZXNBc0FycmF5KFxuICAgIGNhcHR1cmUuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvQXR0cmlidXRlcyB8fCBbXSk7XG5cbiAgcmV0dXJuIGNzcjtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlbXB0eSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgKGEgQ1NSIG9yIGNlcnRpZmljYXRlIHNpZ25pbmdcbiAqIHJlcXVlc3QpLiBPbmNlIGNyZWF0ZWQsIGl0cyBwdWJsaWMga2V5IGFuZCBhdHRyaWJ1dGVzIGNhbiBiZSBzZXQgYW5kIHRoZW5cbiAqIGl0IGNhbiBiZSBzaWduZWQuXG4gKlxuICogQHJldHVybiB0aGUgZW1wdHkgY2VydGlmaWNhdGlvbiByZXF1ZXN0LlxuICovXG5wa2kuY3JlYXRlQ2VydGlmaWNhdGlvblJlcXVlc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNzciA9IHt9O1xuICBjc3IudmVyc2lvbiA9IDB4MDA7XG4gIGNzci5zaWduYXR1cmVPaWQgPSBudWxsO1xuICBjc3Iuc2lnbmF0dXJlID0gbnVsbDtcbiAgY3NyLnNpZ2luZm8gPSB7fTtcbiAgY3NyLnNpZ2luZm8uYWxnb3JpdGhtT2lkID0gbnVsbDtcblxuICBjc3Iuc3ViamVjdCA9IHt9O1xuICBjc3Iuc3ViamVjdC5nZXRGaWVsZCA9IGZ1bmN0aW9uKHNuKSB7XG4gICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY3NyLnN1YmplY3QsIHNuKTtcbiAgfTtcbiAgY3NyLnN1YmplY3QuYWRkRmllbGQgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgY3NyLnN1YmplY3QuYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICB9O1xuICBjc3Iuc3ViamVjdC5hdHRyaWJ1dGVzID0gW107XG4gIGNzci5zdWJqZWN0Lmhhc2ggPSBudWxsO1xuXG4gIGNzci5wdWJsaWNLZXkgPSBudWxsO1xuICBjc3IuYXR0cmlidXRlcyA9IFtdO1xuICBjc3IuZ2V0QXR0cmlidXRlID0gZnVuY3Rpb24oc24pIHtcbiAgICByZXR1cm4gX2dldEF0dHJpYnV0ZShjc3IsIHNuKTtcbiAgfTtcbiAgY3NyLmFkZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoW2F0dHJdKTtcbiAgICBjc3IuYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICB9O1xuICBjc3IubWQgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdWJqZWN0IG9mIHRoaXMgY2VydGlmaWNhdGlvbiByZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0gYXR0cnMgdGhlIGFycmF5IG9mIHN1YmplY3QgYXR0cmlidXRlcyB0byB1c2UuXG4gICAqL1xuICBjc3Iuc2V0U3ViamVjdCA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgLy8gc2V0IG5ldyBhdHRyaWJ1dGVzXG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKGF0dHJzKTtcbiAgICBjc3Iuc3ViamVjdC5hdHRyaWJ1dGVzID0gYXR0cnM7XG4gICAgY3NyLnN1YmplY3QuaGFzaCA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGF0dHJpYnV0ZXMgb2YgdGhpcyBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyB0aGUgYXJyYXkgb2YgYXR0cmlidXRlcyB0byB1c2UuXG4gICAqL1xuICBjc3Iuc2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgLy8gc2V0IG5ldyBhdHRyaWJ1dGVzXG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKGF0dHJzKTtcbiAgICBjc3IuYXR0cmlidXRlcyA9IGF0dHJzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaWducyB0aGlzIGNlcnRpZmljYXRpb24gcmVxdWVzdCB1c2luZyB0aGUgZ2l2ZW4gcHJpdmF0ZSBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgdGhlIHByaXZhdGUga2V5IHRvIHNpZ24gd2l0aC5cbiAgICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlIChkZWZhdWx0cyB0byBmb3JnZS5tZC5zaGExKS5cbiAgICovXG4gIGNzci5zaWduID0gZnVuY3Rpb24oa2V5LCBtZCkge1xuICAgIC8vIFRPRE86IGdldCBzaWduYXR1cmUgT0lEIGZyb20gcHJpdmF0ZSBrZXlcbiAgICBjc3IubWQgPSBtZCB8fCBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgIHZhciBhbGdvcml0aG1PaWQgPSBvaWRzW2Nzci5tZC5hbGdvcml0aG0gKyAnV2l0aFJTQUVuY3J5cHRpb24nXTtcbiAgICBpZighYWxnb3JpdGhtT2lkKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb21wdXRlIGNlcnRpZmljYXRpb24gcmVxdWVzdCBkaWdlc3QuICcgK1xuICAgICAgICAnVW5rbm93biBtZXNzYWdlIGRpZ2VzdCBhbGdvcml0aG0gT0lELicpO1xuICAgICAgZXJyb3IuYWxnb3JpdGhtID0gY3NyLm1kLmFsZ29yaXRobTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjc3Iuc2lnbmF0dXJlT2lkID0gY3NyLnNpZ2luZm8uYWxnb3JpdGhtT2lkID0gYWxnb3JpdGhtT2lkO1xuXG4gICAgLy8gZ2V0IENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbywgY29udmVydCB0byBERVJcbiAgICBjc3IuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvID0gcGtpLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyhjc3IpO1xuICAgIHZhciBieXRlcyA9IGFzbjEudG9EZXIoY3NyLmNlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyk7XG5cbiAgICAvLyBkaWdlc3QgYW5kIHNpZ25cbiAgICBjc3IubWQudXBkYXRlKGJ5dGVzLmdldEJ5dGVzKCkpO1xuICAgIGNzci5zaWduYXR1cmUgPSBrZXkuc2lnbihjc3IubWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB2ZXJpZnkgdGhlIHNpZ25hdHVyZSBvbiB0aGUgcGFzc2VkIGNlcnRpZmljYXRpb24gcmVxdWVzdCB1c2luZ1xuICAgKiBpdHMgcHVibGljIGtleS5cbiAgICpcbiAgICogQSBDU1IgdGhhdCBoYXMgYmVlbiBleHBvcnRlZCB0byBhIGZpbGUgaW4gUEVNIGZvcm1hdCBjYW4gYmUgdmVyaWZpZWQgdXNpbmdcbiAgICogT3BlblNTTCB1c2luZyB0aGlzIGNvbW1hbmQ6XG4gICAqXG4gICAqIG9wZW5zc2wgcmVxIC1pbiA8dGhlLWNzci1wZW0tZmlsZT4gLXZlcmlmeSAtbm9vdXQgLXRleHRcbiAgICpcbiAgICogQHJldHVybiB0cnVlIGlmIHZlcmlmaWVkLCBmYWxzZSBpZiBub3QuXG4gICAqL1xuICBjc3IudmVyaWZ5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJ2YWwgPSBmYWxzZTtcblxuICAgIHZhciBtZCA9IGNzci5tZDtcbiAgICBpZihtZCA9PT0gbnVsbCkge1xuICAgICAgbWQgPSBfY3JlYXRlU2lnbmF0dXJlRGlnZXN0KHtcbiAgICAgICAgc2lnbmF0dXJlT2lkOiBjc3Iuc2lnbmF0dXJlT2lkLFxuICAgICAgICB0eXBlOiAnY2VydGlmaWNhdGlvbiByZXF1ZXN0J1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHByb2R1Y2UgREVSIGZvcm1hdHRlZCBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gYW5kIGRpZ2VzdCBpdFxuICAgICAgdmFyIGNyaSA9IGNzci5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gfHxcbiAgICAgICAgcGtpLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyhjc3IpO1xuICAgICAgdmFyIGJ5dGVzID0gYXNuMS50b0RlcihjcmkpO1xuICAgICAgbWQudXBkYXRlKGJ5dGVzLmdldEJ5dGVzKCkpO1xuICAgIH1cblxuICAgIGlmKG1kICE9PSBudWxsKSB7XG4gICAgICBydmFsID0gX3ZlcmlmeVNpZ25hdHVyZSh7XG4gICAgICAgIGNlcnRpZmljYXRlOiBjc3IsIG1kOiBtZCwgc2lnbmF0dXJlOiBjc3Iuc2lnbmF0dXJlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICByZXR1cm4gY3NyO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBYLjUwOSBzdWJqZWN0IG9yIGlzc3VlciB0byBhbiBBU04uMSBSRE5TZXF1ZW5jZS5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBzdWJqZWN0IG9yIGlzc3VlciAoZGlzdGluZ3Vpc2hlZCBuYW1lKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBSRE5TZXF1ZW5jZS5cbiAqL1xuZnVuY3Rpb24gX2RuVG9Bc24xKG9iaikge1xuICAvLyBjcmVhdGUgYW4gZW1wdHkgUkROU2VxdWVuY2VcbiAgdmFyIHJ2YWwgPSBhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG5cbiAgLy8gaXRlcmF0ZSBvdmVyIGF0dHJpYnV0ZXNcbiAgdmFyIGF0dHIsIHNldDtcbiAgdmFyIGF0dHJzID0gb2JqLmF0dHJpYnV0ZXM7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7ICsraSkge1xuICAgIGF0dHIgPSBhdHRyc1tpXTtcbiAgICB2YXIgdmFsdWUgPSBhdHRyLnZhbHVlO1xuXG4gICAgLy8gcmV1c2UgdGFnIGNsYXNzIGZvciBhdHRyaWJ1dGUgdmFsdWUgaWYgYXZhaWxhYmxlXG4gICAgdmFyIHZhbHVlVGFnQ2xhc3MgPSBhc24xLlR5cGUuUFJJTlRBQkxFU1RSSU5HO1xuICAgIGlmKCd2YWx1ZVRhZ0NsYXNzJyBpbiBhdHRyKSB7XG4gICAgICB2YWx1ZVRhZ0NsYXNzID0gYXR0ci52YWx1ZVRhZ0NsYXNzO1xuXG4gICAgICBpZih2YWx1ZVRhZ0NsYXNzID09PSBhc24xLlR5cGUuVVRGOCkge1xuICAgICAgICB2YWx1ZSA9IGZvcmdlLnV0aWwuZW5jb2RlVXRmOCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBGSVhNRTogaGFuZGxlIG1vcmUgZW5jb2RpbmdzXG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGEgUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZSBzZXRcbiAgICAvLyBlYWNoIHZhbHVlIGluIHRoZSBzZXQgaXMgYW4gQXR0cmlidXRlVHlwZUFuZFZhbHVlIGZpcnN0XG4gICAgLy8gY29udGFpbmluZyB0aGUgdHlwZSAoYW4gT0lEKSBhbmQgc2Vjb25kIHRoZSB2YWx1ZVxuICAgIHNldCA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLCBbXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIEF0dHJpYnV0ZVR5cGVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgIGFzbjEub2lkVG9EZXIoYXR0ci50eXBlKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gQXR0cmlidXRlVmFsdWVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIHZhbHVlVGFnQ2xhc3MsIGZhbHNlLCB2YWx1ZSlcbiAgICAgIF0pXG4gICAgXSk7XG4gICAgcnZhbC52YWx1ZS5wdXNoKHNldCk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn1cblxuLyoqXG4gKiBHZXRzIGFsbCBwcmludGFibGUgYXR0cmlidXRlcyAodHlwaWNhbGx5IG9mIGFuIGlzc3VlciBvciBzdWJqZWN0KSBpbiBhXG4gKiBzaW1wbGlmaWVkIEpTT04gZm9ybWF0IGZvciBkaXNwbGF5LlxuICpcbiAqIEBwYXJhbSBhdHRycyB0aGUgYXR0cmlidXRlcy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBKU09OIGZvciBkaXNwbGF5LlxuICovXG5mdW5jdGlvbiBfZ2V0QXR0cmlidXRlc0FzSnNvbihhdHRycykge1xuICB2YXIgcnZhbCA9IHt9O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmKGF0dHIuc2hvcnROYW1lICYmIChcbiAgICAgIGF0dHIudmFsdWVUYWdDbGFzcyA9PT0gYXNuMS5UeXBlLlVURjggfHxcbiAgICAgIGF0dHIudmFsdWVUYWdDbGFzcyA9PT0gYXNuMS5UeXBlLlBSSU5UQUJMRVNUUklORyB8fFxuICAgICAgYXR0ci52YWx1ZVRhZ0NsYXNzID09PSBhc24xLlR5cGUuSUE1U1RSSU5HKSkge1xuICAgICAgdmFyIHZhbHVlID0gYXR0ci52YWx1ZTtcbiAgICAgIGlmKGF0dHIudmFsdWVUYWdDbGFzcyA9PT0gYXNuMS5UeXBlLlVURjgpIHtcbiAgICAgICAgdmFsdWUgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgoYXR0ci52YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZighKGF0dHIuc2hvcnROYW1lIGluIHJ2YWwpKSB7XG4gICAgICAgIHJ2YWxbYXR0ci5zaG9ydE5hbWVdID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYoZm9yZ2UudXRpbC5pc0FycmF5KHJ2YWxbYXR0ci5zaG9ydE5hbWVdKSkge1xuICAgICAgICBydmFsW2F0dHIuc2hvcnROYW1lXS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWxbYXR0ci5zaG9ydE5hbWVdID0gW3J2YWxbYXR0ci5zaG9ydE5hbWVdLCB2YWx1ZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufVxuXG4vKipcbiAqIEZpbGxzIGluIG1pc3NpbmcgZmllbGRzIGluIGF0dHJpYnV0ZXMuXG4gKlxuICogQHBhcmFtIGF0dHJzIHRoZSBhdHRyaWJ1dGVzIHRvIGZpbGwgbWlzc2luZyBmaWVsZHMgaW4uXG4gKi9cbmZ1bmN0aW9uIF9maWxsTWlzc2luZ0ZpZWxkcyhhdHRycykge1xuICB2YXIgYXR0cjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgKytpKSB7XG4gICAgYXR0ciA9IGF0dHJzW2ldO1xuXG4gICAgLy8gcG9wdWxhdGUgbWlzc2luZyBuYW1lXG4gICAgaWYodHlwZW9mIGF0dHIubmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmKGF0dHIudHlwZSAmJiBhdHRyLnR5cGUgaW4gcGtpLm9pZHMpIHtcbiAgICAgICAgYXR0ci5uYW1lID0gcGtpLm9pZHNbYXR0ci50eXBlXTtcbiAgICAgIH0gZWxzZSBpZihhdHRyLnNob3J0TmFtZSAmJiBhdHRyLnNob3J0TmFtZSBpbiBfc2hvcnROYW1lcykge1xuICAgICAgICBhdHRyLm5hbWUgPSBwa2kub2lkc1tfc2hvcnROYW1lc1thdHRyLnNob3J0TmFtZV1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBvcHVsYXRlIG1pc3NpbmcgdHlwZSAoT0lEKVxuICAgIGlmKHR5cGVvZiBhdHRyLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZihhdHRyLm5hbWUgJiYgYXR0ci5uYW1lIGluIHBraS5vaWRzKSB7XG4gICAgICAgIGF0dHIudHlwZSA9IHBraS5vaWRzW2F0dHIubmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSB0eXBlIG5vdCBzcGVjaWZpZWQuJyk7XG4gICAgICAgIGVycm9yLmF0dHJpYnV0ZSA9IGF0dHI7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBvcHVsYXRlIG1pc3Npbmcgc2hvcnRuYW1lXG4gICAgaWYodHlwZW9mIGF0dHIuc2hvcnROYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYoYXR0ci5uYW1lICYmIGF0dHIubmFtZSBpbiBfc2hvcnROYW1lcykge1xuICAgICAgICBhdHRyLnNob3J0TmFtZSA9IF9zaG9ydE5hbWVzW2F0dHIubmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBleHRlbnNpb25zIHRvIHZhbHVlXG4gICAgaWYoYXR0ci50eXBlID09PSBvaWRzLmV4dGVuc2lvblJlcXVlc3QpIHtcbiAgICAgIGF0dHIudmFsdWVDb25zdHJ1Y3RlZCA9IHRydWU7XG4gICAgICBhdHRyLnZhbHVlVGFnQ2xhc3MgPSBhc24xLlR5cGUuU0VRVUVOQ0U7XG4gICAgICBpZighYXR0ci52YWx1ZSAmJiBhdHRyLmV4dGVuc2lvbnMpIHtcbiAgICAgICAgYXR0ci52YWx1ZSA9IFtdO1xuICAgICAgICBmb3IodmFyIGVpID0gMDsgZWkgPCBhdHRyLmV4dGVuc2lvbnMubGVuZ3RoOyArK2VpKSB7XG4gICAgICAgICAgYXR0ci52YWx1ZS5wdXNoKHBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvblRvQXNuMShcbiAgICAgICAgICAgIF9maWxsTWlzc2luZ0V4dGVuc2lvbkZpZWxkcyhhdHRyLmV4dGVuc2lvbnNbZWldKSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYodHlwZW9mIGF0dHIudmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSB2YWx1ZSBub3Qgc3BlY2lmaWVkLicpO1xuICAgICAgZXJyb3IuYXR0cmlidXRlID0gYXR0cjtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEZpbGxzIGluIG1pc3NpbmcgZmllbGRzIGluIGNlcnRpZmljYXRlIGV4dGVuc2lvbnMuXG4gKlxuICogQHBhcmFtIGUgdGhlIGV4dGVuc2lvbi5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAgW2NlcnRdIHRoZSBjZXJ0aWZpY2F0ZSB0aGUgZXh0ZW5zaW9ucyBhcmUgZm9yLlxuICpcbiAqIEByZXR1cm4gdGhlIGV4dGVuc2lvbi5cbiAqL1xuZnVuY3Rpb24gX2ZpbGxNaXNzaW5nRXh0ZW5zaW9uRmllbGRzKGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gcG9wdWxhdGUgbWlzc2luZyBuYW1lXG4gIGlmKHR5cGVvZiBlLm5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYoZS5pZCAmJiBlLmlkIGluIHBraS5vaWRzKSB7XG4gICAgICBlLm5hbWUgPSBwa2kub2lkc1tlLmlkXTtcbiAgICB9XG4gIH1cblxuICAvLyBwb3B1bGF0ZSBtaXNzaW5nIGlkXG4gIGlmKHR5cGVvZiBlLmlkID09PSAndW5kZWZpbmVkJykge1xuICAgIGlmKGUubmFtZSAmJiBlLm5hbWUgaW4gcGtpLm9pZHMpIHtcbiAgICAgIGUuaWQgPSBwa2kub2lkc1tlLm5hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0V4dGVuc2lvbiBJRCBub3Qgc3BlY2lmaWVkLicpO1xuICAgICAgZXJyb3IuZXh0ZW5zaW9uID0gZTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGlmKHR5cGVvZiBlLnZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBlO1xuICB9XG5cbiAgLy8gaGFuZGxlIG1pc3NpbmcgdmFsdWU6XG5cbiAgLy8gdmFsdWUgaXMgYSBCSVQgU1RSSU5HXG4gIGlmKGUubmFtZSA9PT0gJ2tleVVzYWdlJykge1xuICAgIC8vIGJ1aWxkIGZsYWdzXG4gICAgdmFyIHVudXNlZCA9IDA7XG4gICAgdmFyIGIyID0gMHgwMDtcbiAgICB2YXIgYjMgPSAweDAwO1xuICAgIGlmKGUuZGlnaXRhbFNpZ25hdHVyZSkge1xuICAgICAgYjIgfD0gMHg4MDtcbiAgICAgIHVudXNlZCA9IDc7XG4gICAgfVxuICAgIGlmKGUubm9uUmVwdWRpYXRpb24pIHtcbiAgICAgIGIyIHw9IDB4NDA7XG4gICAgICB1bnVzZWQgPSA2O1xuICAgIH1cbiAgICBpZihlLmtleUVuY2lwaGVybWVudCkge1xuICAgICAgYjIgfD0gMHgyMDtcbiAgICAgIHVudXNlZCA9IDU7XG4gICAgfVxuICAgIGlmKGUuZGF0YUVuY2lwaGVybWVudCkge1xuICAgICAgYjIgfD0gMHgxMDtcbiAgICAgIHVudXNlZCA9IDQ7XG4gICAgfVxuICAgIGlmKGUua2V5QWdyZWVtZW50KSB7XG4gICAgICBiMiB8PSAweDA4O1xuICAgICAgdW51c2VkID0gMztcbiAgICB9XG4gICAgaWYoZS5rZXlDZXJ0U2lnbikge1xuICAgICAgYjIgfD0gMHgwNDtcbiAgICAgIHVudXNlZCA9IDI7XG4gICAgfVxuICAgIGlmKGUuY1JMU2lnbikge1xuICAgICAgYjIgfD0gMHgwMjtcbiAgICAgIHVudXNlZCA9IDE7XG4gICAgfVxuICAgIGlmKGUuZW5jaXBoZXJPbmx5KSB7XG4gICAgICBiMiB8PSAweDAxO1xuICAgICAgdW51c2VkID0gMDtcbiAgICB9XG4gICAgaWYoZS5kZWNpcGhlck9ubHkpIHtcbiAgICAgIGIzIHw9IDB4ODA7XG4gICAgICB1bnVzZWQgPSA3O1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBiaXQgc3RyaW5nXG4gICAgdmFyIHZhbHVlID0gU3RyaW5nLmZyb21DaGFyQ29kZSh1bnVzZWQpO1xuICAgIGlmKGIzICE9PSAwKSB7XG4gICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGIyKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYjMpO1xuICAgIH0gZWxzZSBpZihiMiAhPT0gMCkge1xuICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiMik7XG4gICAgfVxuICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSwgdmFsdWUpO1xuICB9IGVsc2UgaWYoZS5uYW1lID09PSAnYmFzaWNDb25zdHJhaW50cycpIHtcbiAgICAvLyBiYXNpY0NvbnN0cmFpbnRzIGlzIGEgU0VRVUVOQ0VcbiAgICBlLnZhbHVlID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gICAgLy8gY0EgQk9PTEVBTiBmbGFnIGRlZmF1bHRzIHRvIGZhbHNlXG4gICAgaWYoZS5jQSkge1xuICAgICAgZS52YWx1ZS52YWx1ZS5wdXNoKGFzbjEuY3JlYXRlKFxuICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLkJPT0xFQU4sIGZhbHNlLFxuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkYpKSk7XG4gICAgfVxuICAgIGlmKCdwYXRoTGVuQ29uc3RyYWludCcgaW4gZSkge1xuICAgICAgZS52YWx1ZS52YWx1ZS5wdXNoKGFzbjEuY3JlYXRlKFxuICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgICBhc24xLmludGVnZXJUb0RlcihlLnBhdGhMZW5Db25zdHJhaW50KS5nZXRCeXRlcygpKSk7XG4gICAgfVxuICB9IGVsc2UgaWYoZS5uYW1lID09PSAnZXh0S2V5VXNhZ2UnKSB7XG4gICAgLy8gZXh0S2V5VXNhZ2UgaXMgYSBTRVFVRU5DRSBvZiBPSURzXG4gICAgZS52YWx1ZSA9IGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuICAgIHZhciBzZXEgPSBlLnZhbHVlLnZhbHVlO1xuICAgIGZvcih2YXIga2V5IGluIGUpIHtcbiAgICAgIGlmKGVba2V5XSAhPT0gdHJ1ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIGtleSBpcyBuYW1lIGluIE9JRCBtYXBcbiAgICAgIGlmKGtleSBpbiBvaWRzKSB7XG4gICAgICAgIHNlcS5wdXNoKGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELFxuICAgICAgICAgIGZhbHNlLCBhc24xLm9pZFRvRGVyKG9pZHNba2V5XSkuZ2V0Qnl0ZXMoKSkpO1xuICAgICAgfSBlbHNlIGlmKGtleS5pbmRleE9mKCcuJykgIT09IC0xKSB7XG4gICAgICAgIC8vIGFzc3VtZSBrZXkgaXMgYW4gT0lEXG4gICAgICAgIHNlcS5wdXNoKGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELFxuICAgICAgICAgIGZhbHNlLCBhc24xLm9pZFRvRGVyKGtleSkuZ2V0Qnl0ZXMoKSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ25zQ2VydFR5cGUnKSB7XG4gICAgLy8gbnNDZXJ0VHlwZSBpcyBhIEJJVCBTVFJJTkdcbiAgICAvLyBidWlsZCBmbGFnc1xuICAgIHZhciB1bnVzZWQgPSAwO1xuICAgIHZhciBiMiA9IDB4MDA7XG5cbiAgICBpZihlLmNsaWVudCkge1xuICAgICAgYjIgfD0gMHg4MDtcbiAgICAgIHVudXNlZCA9IDc7XG4gICAgfVxuICAgIGlmKGUuc2VydmVyKSB7XG4gICAgICBiMiB8PSAweDQwO1xuICAgICAgdW51c2VkID0gNjtcbiAgICB9XG4gICAgaWYoZS5lbWFpbCkge1xuICAgICAgYjIgfD0gMHgyMDtcbiAgICAgIHVudXNlZCA9IDU7XG4gICAgfVxuICAgIGlmKGUub2Jqc2lnbikge1xuICAgICAgYjIgfD0gMHgxMDtcbiAgICAgIHVudXNlZCA9IDQ7XG4gICAgfVxuICAgIGlmKGUucmVzZXJ2ZWQpIHtcbiAgICAgIGIyIHw9IDB4MDg7XG4gICAgICB1bnVzZWQgPSAzO1xuICAgIH1cbiAgICBpZihlLnNzbENBKSB7XG4gICAgICBiMiB8PSAweDA0O1xuICAgICAgdW51c2VkID0gMjtcbiAgICB9XG4gICAgaWYoZS5lbWFpbENBKSB7XG4gICAgICBiMiB8PSAweDAyO1xuICAgICAgdW51c2VkID0gMTtcbiAgICB9XG4gICAgaWYoZS5vYmpDQSkge1xuICAgICAgYjIgfD0gMHgwMTtcbiAgICAgIHVudXNlZCA9IDA7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGJpdCBzdHJpbmdcbiAgICB2YXIgdmFsdWUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVudXNlZCk7XG4gICAgaWYoYjIgIT09IDApIHtcbiAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYjIpO1xuICAgIH1cbiAgICBlLnZhbHVlID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLkJJVFNUUklORywgZmFsc2UsIHZhbHVlKTtcbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ3N1YmplY3RBbHROYW1lJyB8fCBlLm5hbWUgPT09ICdpc3N1ZXJBbHROYW1lJykge1xuICAgIC8vIFNZTlRBWCBTRVFVRU5DRVxuICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG5cbiAgICB2YXIgYWx0TmFtZTtcbiAgICBmb3IodmFyIG4gPSAwOyBuIDwgZS5hbHROYW1lcy5sZW5ndGg7ICsrbikge1xuICAgICAgYWx0TmFtZSA9IGUuYWx0TmFtZXNbbl07XG4gICAgICB2YXIgdmFsdWUgPSBhbHROYW1lLnZhbHVlO1xuICAgICAgLy8gaGFuZGxlIElQXG4gICAgICBpZihhbHROYW1lLnR5cGUgPT09IDcgJiYgYWx0TmFtZS5pcCkge1xuICAgICAgICB2YWx1ZSA9IGZvcmdlLnV0aWwuYnl0ZXNGcm9tSVAoYWx0TmFtZS5pcCk7XG4gICAgICAgIGlmKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0V4dGVuc2lvbiBcImlwXCIgdmFsdWUgaXMgbm90IGEgdmFsaWQgSVB2NCBvciBJUHY2IGFkZHJlc3MuJyk7XG4gICAgICAgICAgZXJyb3IuZXh0ZW5zaW9uID0gZTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKGFsdE5hbWUudHlwZSA9PT0gOCkge1xuICAgICAgICAvLyBoYW5kbGUgT0lEXG4gICAgICAgIGlmKGFsdE5hbWUub2lkKSB7XG4gICAgICAgICAgdmFsdWUgPSBhc24xLm9pZFRvRGVyKGFzbjEub2lkVG9EZXIoYWx0TmFtZS5vaWQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkZXByZWNhdGVkIC4uLiBjb252ZXJ0IHZhbHVlIHRvIE9JRFxuICAgICAgICAgIHZhbHVlID0gYXNuMS5vaWRUb0Rlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGUudmFsdWUudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCBhbHROYW1lLnR5cGUsIGZhbHNlLFxuICAgICAgICB2YWx1ZSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ25zQ29tbWVudCcgJiYgb3B0aW9ucy5jZXJ0KSB7XG4gICAgLy8gc2FuaXR5IGNoZWNrIHZhbHVlIGlzIEFTQ0lJIChyZXEnZCkgYW5kIG5vdCB0b28gYmlnXG4gICAgaWYoISgvXltcXHgwMC1cXHg3Rl0qJC8udGVzdChlLmNvbW1lbnQpKSB8fFxuICAgICAgKGUuY29tbWVudC5sZW5ndGggPCAxKSB8fCAoZS5jb21tZW50Lmxlbmd0aCA+IDEyOCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBcIm5zQ29tbWVudFwiIGNvbnRlbnQuJyk7XG4gICAgfVxuICAgIC8vIElBNVNUUklORyBvcGFxdWUgY29tbWVudFxuICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSUE1U1RSSU5HLCBmYWxzZSwgZS5jb21tZW50KTtcbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ3N1YmplY3RLZXlJZGVudGlmaWVyJyAmJiBvcHRpb25zLmNlcnQpIHtcbiAgICB2YXIgc2tpID0gb3B0aW9ucy5jZXJ0LmdlbmVyYXRlU3ViamVjdEtleUlkZW50aWZpZXIoKTtcbiAgICBlLnN1YmplY3RLZXlJZGVudGlmaWVyID0gc2tpLnRvSGV4KCk7XG4gICAgLy8gT0NURVRTVFJJTkcgdy9kaWdlc3RcbiAgICBlLnZhbHVlID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSwgc2tpLmdldEJ5dGVzKCkpO1xuICB9IGVsc2UgaWYoZS5uYW1lID09PSAnYXV0aG9yaXR5S2V5SWRlbnRpZmllcicgJiYgb3B0aW9ucy5jZXJ0KSB7XG4gICAgLy8gU1lOVEFYIFNFUVVFTkNFXG4gICAgZS52YWx1ZSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtdKTtcbiAgICB2YXIgc2VxID0gZS52YWx1ZS52YWx1ZTtcblxuICAgIGlmKGUua2V5SWRlbnRpZmllcikge1xuICAgICAgdmFyIGtleUlkZW50aWZpZXIgPSAoZS5rZXlJZGVudGlmaWVyID09PSB0cnVlID9cbiAgICAgICAgb3B0aW9ucy5jZXJ0LmdlbmVyYXRlU3ViamVjdEtleUlkZW50aWZpZXIoKS5nZXRCeXRlcygpIDpcbiAgICAgICAgZS5rZXlJZGVudGlmaWVyKTtcbiAgICAgIHNlcS5wdXNoKFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIGZhbHNlLCBrZXlJZGVudGlmaWVyKSk7XG4gICAgfVxuXG4gICAgaWYoZS5hdXRob3JpdHlDZXJ0SXNzdWVyKSB7XG4gICAgICB2YXIgYXV0aG9yaXR5Q2VydElzc3VlciA9IFtcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCA0LCB0cnVlLCBbXG4gICAgICAgICAgX2RuVG9Bc24xKGUuYXV0aG9yaXR5Q2VydElzc3VlciA9PT0gdHJ1ZSA/XG4gICAgICAgICAgICBvcHRpb25zLmNlcnQuaXNzdWVyIDogZS5hdXRob3JpdHlDZXJ0SXNzdWVyKVxuICAgICAgICBdKVxuICAgICAgXTtcbiAgICAgIHNlcS5wdXNoKFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDEsIHRydWUsIGF1dGhvcml0eUNlcnRJc3N1ZXIpKTtcbiAgICB9XG5cbiAgICBpZihlLnNlcmlhbE51bWJlcikge1xuICAgICAgdmFyIHNlcmlhbE51bWJlciA9IGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhlLnNlcmlhbE51bWJlciA9PT0gdHJ1ZSA/XG4gICAgICAgIG9wdGlvbnMuY2VydC5zZXJpYWxOdW1iZXIgOiBlLnNlcmlhbE51bWJlcik7XG4gICAgICBzZXEucHVzaChcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAyLCBmYWxzZSwgc2VyaWFsTnVtYmVyKSk7XG4gICAgfVxuICB9IGVsc2UgaWYoZS5uYW1lID09PSAnY1JMRGlzdHJpYnV0aW9uUG9pbnRzJykge1xuICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gICAgdmFyIHNlcSA9IGUudmFsdWUudmFsdWU7XG5cbiAgICAvLyBDcmVhdGUgc3ViIFNFUVVFTkNFIG9mIERpc3RyaWJ1dGlvblBvaW50TmFtZVxuICAgIHZhciBzdWJTZXEgPSBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtdKTtcblxuICAgIC8vIENyZWF0ZSBmdWxsTmFtZSBDSE9JQ0VcbiAgICB2YXIgZnVsbE5hbWVHZW5lcmFsTmFtZXMgPSBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW10pO1xuICAgIHZhciBhbHROYW1lO1xuICAgIGZvcih2YXIgbiA9IDA7IG4gPCBlLmFsdE5hbWVzLmxlbmd0aDsgKytuKSB7XG4gICAgICBhbHROYW1lID0gZS5hbHROYW1lc1tuXTtcbiAgICAgIHZhciB2YWx1ZSA9IGFsdE5hbWUudmFsdWU7XG4gICAgICAvLyBoYW5kbGUgSVBcbiAgICAgIGlmKGFsdE5hbWUudHlwZSA9PT0gNyAmJiBhbHROYW1lLmlwKSB7XG4gICAgICAgIHZhbHVlID0gZm9yZ2UudXRpbC5ieXRlc0Zyb21JUChhbHROYW1lLmlwKTtcbiAgICAgICAgaWYodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnRXh0ZW5zaW9uIFwiaXBcIiB2YWx1ZSBpcyBub3QgYSB2YWxpZCBJUHY0IG9yIElQdjYgYWRkcmVzcy4nKTtcbiAgICAgICAgICBlcnJvci5leHRlbnNpb24gPSBlO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoYWx0TmFtZS50eXBlID09PSA4KSB7XG4gICAgICAgIC8vIGhhbmRsZSBPSURcbiAgICAgICAgaWYoYWx0TmFtZS5vaWQpIHtcbiAgICAgICAgICB2YWx1ZSA9IGFzbjEub2lkVG9EZXIoYXNuMS5vaWRUb0RlcihhbHROYW1lLm9pZCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRlcHJlY2F0ZWQgLi4uIGNvbnZlcnQgdmFsdWUgdG8gT0lEXG4gICAgICAgICAgdmFsdWUgPSBhc24xLm9pZFRvRGVyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVsbE5hbWVHZW5lcmFsTmFtZXMudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCBhbHROYW1lLnR5cGUsIGZhbHNlLFxuICAgICAgICB2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8vIEFkZCB0byB0aGUgcGFyZW50IFNFUVVFTkNFXG4gICAgc3ViU2VxLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtmdWxsTmFtZUdlbmVyYWxOYW1lc10pKTtcbiAgICBzZXEucHVzaChzdWJTZXEpO1xuICB9XG5cbiAgLy8gZW5zdXJlIHZhbHVlIGhhcyBiZWVuIGRlZmluZWQgYnkgbm93XG4gIGlmKHR5cGVvZiBlLnZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignRXh0ZW5zaW9uIHZhbHVlIG5vdCBzcGVjaWZpZWQuJyk7XG4gICAgZXJyb3IuZXh0ZW5zaW9uID0gZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHJldHVybiBlO1xufVxuXG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIHBhcmFtZXRlcnMgb2JqZWN0IHRvIEFTTi4xXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9pZCBTaWduYXR1cmUgYWxnb3JpdGhtIE9JRFxuICogQHBhcmFtIHBhcmFtcyBUaGUgc2lnbmF0dXJlIHBhcmFtZXRycyBvYmplY3RcbiAqIEByZXR1cm4gQVNOLjEgb2JqZWN0IHJlcHJlc2VudGluZyBzaWduYXR1cmUgcGFyYW1ldGVyc1xuICovXG5mdW5jdGlvbiBfc2lnbmF0dXJlUGFyYW1ldGVyc1RvQXNuMShvaWQsIHBhcmFtcykge1xuICBzd2l0Y2gob2lkKSB7XG4gICAgY2FzZSBvaWRzWydSU0FTU0EtUFNTJ106XG4gICAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgICAgaWYocGFyYW1zLmhhc2guYWxnb3JpdGhtT2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFydHMucHVzaChhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtcbiAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgICAgIGFzbjEub2lkVG9EZXIocGFyYW1zLmhhc2guYWxnb3JpdGhtT2lkKS5nZXRCeXRlcygpKSxcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKVxuICAgICAgICAgIF0pXG4gICAgICAgIF0pKTtcbiAgICAgIH1cblxuICAgICAgaWYocGFyYW1zLm1nZi5hbGdvcml0aG1PaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJ0cy5wdXNoKGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMSwgdHJ1ZSwgW1xuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAgICAgYXNuMS5vaWRUb0RlcihwYXJhbXMubWdmLmFsZ29yaXRobU9pZCkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAgICAgICBhc24xLm9pZFRvRGVyKHBhcmFtcy5tZ2YuaGFzaC5hbGdvcml0aG1PaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk5VTEwsIGZhbHNlLCAnJylcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgXSlcbiAgICAgICAgXSkpO1xuICAgICAgfVxuXG4gICAgICBpZihwYXJhbXMuc2FsdExlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAyLCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEuaW50ZWdlclRvRGVyKHBhcmFtcy5zYWx0TGVuZ3RoKS5nZXRCeXRlcygpKVxuICAgICAgICBdKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBwYXJ0cyk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgY2VydGlmaWNhdGlvbiByZXF1ZXN0J3MgYXR0cmlidXRlcyB0byBhbiBBU04uMSBzZXQgb2ZcbiAqIENSSUF0dHJpYnV0ZXMuXG4gKlxuICogQHBhcmFtIGNzciBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gKlxuICogQHJldHVybiB0aGUgQVNOLjEgc2V0IG9mIENSSUF0dHJpYnV0ZXMuXG4gKi9cbmZ1bmN0aW9uIF9DUklBdHRyaWJ1dGVzVG9Bc24xKGNzcikge1xuICAvLyBjcmVhdGUgYW4gZW1wdHkgY29udGV4dC1zcGVjaWZpYyBjb250YWluZXJcbiAgdmFyIHJ2YWwgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtdKTtcblxuICAvLyBubyBhdHRyaWJ1dGVzLCByZXR1cm4gZW1wdHkgY29udGFpbmVyXG4gIGlmKGNzci5hdHRyaWJ1dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBydmFsO1xuICB9XG5cbiAgLy8gZWFjaCBhdHRyaWJ1dGUgaGFzIGEgc2VxdWVuY2Ugd2l0aCBhIHR5cGUgYW5kIGEgc2V0IG9mIHZhbHVlc1xuICB2YXIgYXR0cnMgPSBjc3IuYXR0cmlidXRlcztcbiAgZm9yKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICB2YXIgdmFsdWUgPSBhdHRyLnZhbHVlO1xuXG4gICAgLy8gcmV1c2UgdGFnIGNsYXNzIGZvciBhdHRyaWJ1dGUgdmFsdWUgaWYgYXZhaWxhYmxlXG4gICAgdmFyIHZhbHVlVGFnQ2xhc3MgPSBhc24xLlR5cGUuVVRGODtcbiAgICBpZigndmFsdWVUYWdDbGFzcycgaW4gYXR0cikge1xuICAgICAgdmFsdWVUYWdDbGFzcyA9IGF0dHIudmFsdWVUYWdDbGFzcztcbiAgICB9XG4gICAgaWYodmFsdWVUYWdDbGFzcyA9PT0gYXNuMS5UeXBlLlVURjgpIHtcbiAgICAgIHZhbHVlID0gZm9yZ2UudXRpbC5lbmNvZGVVdGY4KHZhbHVlKTtcbiAgICB9XG4gICAgdmFyIHZhbHVlQ29uc3RydWN0ZWQgPSBmYWxzZTtcbiAgICBpZigndmFsdWVDb25zdHJ1Y3RlZCcgaW4gYXR0cikge1xuICAgICAgdmFsdWVDb25zdHJ1Y3RlZCA9IGF0dHIudmFsdWVDb25zdHJ1Y3RlZDtcbiAgICB9XG4gICAgLy8gRklYTUU6IGhhbmRsZSBtb3JlIGVuY29kaW5nc1xuXG4gICAgLy8gY3JlYXRlIGEgUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZSBzZXRcbiAgICAvLyBlYWNoIHZhbHVlIGluIHRoZSBzZXQgaXMgYW4gQXR0cmlidXRlVHlwZUFuZFZhbHVlIGZpcnN0XG4gICAgLy8gY29udGFpbmluZyB0aGUgdHlwZSAoYW4gT0lEKSBhbmQgc2Vjb25kIHRoZSB2YWx1ZVxuICAgIHZhciBzZXEgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAvLyBBdHRyaWJ1dGVUeXBlXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIoYXR0ci50eXBlKS5nZXRCeXRlcygpKSxcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLCBbXG4gICAgICAgIC8vIEF0dHJpYnV0ZVZhbHVlXG4gICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCB2YWx1ZVRhZ0NsYXNzLCB2YWx1ZUNvbnN0cnVjdGVkLCB2YWx1ZSlcbiAgICAgIF0pXG4gICAgXSk7XG4gICAgcnZhbC52YWx1ZS5wdXNoKHNlcSk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn1cblxudmFyIGphbl8xXzE5NTAgPSBuZXcgRGF0ZSgnMTk1MC0wMS0wMVQwMDowMDowMFonKTtcbnZhciBqYW5fMV8yMDUwID0gbmV3IERhdGUoJzIwNTAtMDEtMDFUMDA6MDA6MDBaJyk7XG5cbi8qKlxuICogQ29udmVydHMgYSBEYXRlIG9iamVjdCB0byBBU04uMVxuICogSGFuZGxlcyB0aGUgZGlmZmVyZW50IGZvcm1hdCBiZWZvcmUgYW5kIGFmdGVyIDFzdCBKYW51YXJ5IDIwNTBcbiAqXG4gKiBAcGFyYW0gZGF0ZSBkYXRlIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBkYXRlLlxuICovXG5mdW5jdGlvbiBfZGF0ZVRvQXNuMShkYXRlKSB7XG4gIGlmKGRhdGUgPj0gamFuXzFfMTk1MCAmJiBkYXRlIDwgamFuXzFfMjA1MCkge1xuICAgIHJldHVybiBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuVVRDVElNRSwgZmFsc2UsXG4gICAgICBhc24xLmRhdGVUb1V0Y1RpbWUoZGF0ZSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuR0VORVJBTElaRURUSU1FLCBmYWxzZSxcbiAgICAgIGFzbjEuZGF0ZVRvR2VuZXJhbGl6ZWRUaW1lKGRhdGUpKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIEFTTi4xIFRCU0NlcnRpZmljYXRlIHBhcnQgb2YgYW4gWC41MDl2MyBjZXJ0aWZpY2F0ZS5cbiAqXG4gKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSBUQlNDZXJ0aWZpY2F0ZS5cbiAqL1xucGtpLmdldFRCU0NlcnRpZmljYXRlID0gZnVuY3Rpb24oY2VydCkge1xuICAvLyBUQlNDZXJ0aWZpY2F0ZVxuICB2YXIgbm90QmVmb3JlID0gX2RhdGVUb0FzbjEoY2VydC52YWxpZGl0eS5ub3RCZWZvcmUpO1xuICB2YXIgbm90QWZ0ZXIgPSBfZGF0ZVRvQXNuMShjZXJ0LnZhbGlkaXR5Lm5vdEFmdGVyKTtcbiAgdmFyIHRicyA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyB2ZXJzaW9uXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAvLyBpbnRlZ2VyXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgICBhc24xLmludGVnZXJUb0RlcihjZXJ0LnZlcnNpb24pLmdldEJ5dGVzKCkpXG4gICAgXSksXG4gICAgLy8gc2VyaWFsTnVtYmVyXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhjZXJ0LnNlcmlhbE51bWJlcikpLFxuICAgIC8vIHNpZ25hdHVyZVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgIC8vIGFsZ29yaXRobVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICBhc24xLm9pZFRvRGVyKGNlcnQuc2lnaW5mby5hbGdvcml0aG1PaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgLy8gcGFyYW1ldGVyc1xuICAgICAgX3NpZ25hdHVyZVBhcmFtZXRlcnNUb0FzbjEoXG4gICAgICAgIGNlcnQuc2lnaW5mby5hbGdvcml0aG1PaWQsIGNlcnQuc2lnaW5mby5wYXJhbWV0ZXJzKVxuICAgIF0pLFxuICAgIC8vIGlzc3VlclxuICAgIF9kblRvQXNuMShjZXJ0Lmlzc3VlciksXG4gICAgLy8gdmFsaWRpdHlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICBub3RCZWZvcmUsXG4gICAgICBub3RBZnRlclxuICAgIF0pLFxuICAgIC8vIHN1YmplY3RcbiAgICBfZG5Ub0FzbjEoY2VydC5zdWJqZWN0KSxcbiAgICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICAgIHBraS5wdWJsaWNLZXlUb0FzbjEoY2VydC5wdWJsaWNLZXkpXG4gIF0pO1xuXG4gIGlmKGNlcnQuaXNzdWVyLnVuaXF1ZUlkKSB7XG4gICAgLy8gaXNzdWVyVW5pcXVlSUQgKG9wdGlvbmFsKVxuICAgIHRicy52YWx1ZS5wdXNoKFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAxLCB0cnVlLCBbXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCkgK1xuICAgICAgICAgIGNlcnQuaXNzdWVyLnVuaXF1ZUlkXG4gICAgICAgIClcbiAgICAgIF0pXG4gICAgKTtcbiAgfVxuICBpZihjZXJ0LnN1YmplY3QudW5pcXVlSWQpIHtcbiAgICAvLyBzdWJqZWN0VW5pcXVlSUQgKG9wdGlvbmFsKVxuICAgIHRicy52YWx1ZS5wdXNoKFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAyLCB0cnVlLCBbXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCkgK1xuICAgICAgICAgIGNlcnQuc3ViamVjdC51bmlxdWVJZFxuICAgICAgICApXG4gICAgICBdKVxuICAgICk7XG4gIH1cblxuICBpZihjZXJ0LmV4dGVuc2lvbnMubGVuZ3RoID4gMCkge1xuICAgIC8vIGV4dGVuc2lvbnMgKG9wdGlvbmFsKVxuICAgIHRicy52YWx1ZS5wdXNoKHBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbnNUb0FzbjEoY2VydC5leHRlbnNpb25zKSk7XG4gIH1cblxuICByZXR1cm4gdGJzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBBU04uMSBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gcGFydCBvZiBhXG4gKiBQS0NTIzEwIENlcnRpZmljYXRpb25SZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSBjc3IgdGhlIGNlcnRpZmljYXRpb24gcmVxdWVzdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhc24xIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mby5cbiAqL1xucGtpLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyA9IGZ1bmN0aW9uKGNzcikge1xuICAvLyBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9cbiAgdmFyIGNyaSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyB2ZXJzaW9uXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIGFzbjEuaW50ZWdlclRvRGVyKGNzci52ZXJzaW9uKS5nZXRCeXRlcygpKSxcbiAgICAvLyBzdWJqZWN0XG4gICAgX2RuVG9Bc24xKGNzci5zdWJqZWN0KSxcbiAgICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICAgIHBraS5wdWJsaWNLZXlUb0FzbjEoY3NyLnB1YmxpY0tleSksXG4gICAgLy8gYXR0cmlidXRlc1xuICAgIF9DUklBdHRyaWJ1dGVzVG9Bc24xKGNzcilcbiAgXSk7XG5cbiAgcmV0dXJuIGNyaTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBEaXN0aW5ndWlzaGVkTmFtZSAoc3ViamVjdCBvciBpc3N1ZXIpIHRvIGFuIEFTTi4xIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gZG4gdGhlIERpc3Rpbmd1aXNoZWROYW1lLlxuICpcbiAqIEByZXR1cm4gdGhlIGFzbjEgcmVwcmVzZW50YXRpb24gb2YgYSBEaXN0aW5ndWlzaGVkTmFtZS5cbiAqL1xucGtpLmRpc3Rpbmd1aXNoZWROYW1lVG9Bc24xID0gZnVuY3Rpb24oZG4pIHtcbiAgcmV0dXJuIF9kblRvQXNuMShkbik7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFguNTA5djMgUlNBIGNlcnRpZmljYXRlIHRvIGFuIEFTTi4xIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhbiBYLjUwOXYzIFJTQSBjZXJ0aWZpY2F0ZS5cbiAqL1xucGtpLmNlcnRpZmljYXRlVG9Bc24xID0gZnVuY3Rpb24oY2VydCkge1xuICAvLyBwcmVmZXIgY2FjaGVkIFRCU0NlcnRpZmljYXRlIG92ZXIgZ2VuZXJhdGluZyBvbmVcbiAgdmFyIHRic0NlcnRpZmljYXRlID0gY2VydC50YnNDZXJ0aWZpY2F0ZSB8fCBwa2kuZ2V0VEJTQ2VydGlmaWNhdGUoY2VydCk7XG5cbiAgLy8gQ2VydGlmaWNhdGVcbiAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBUQlNDZXJ0aWZpY2F0ZVxuICAgIHRic0NlcnRpZmljYXRlLFxuICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIoY2VydC5zaWduYXR1cmVPaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgLy8gcGFyYW1ldGVyc1xuICAgICAgX3NpZ25hdHVyZVBhcmFtZXRlcnNUb0FzbjEoY2VydC5zaWduYXR1cmVPaWQsIGNlcnQuc2lnbmF0dXJlUGFyYW1ldGVycylcbiAgICBdKSxcbiAgICAvLyBTaWduYXR1cmVWYWx1ZVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSxcbiAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCkgKyBjZXJ0LnNpZ25hdHVyZSlcbiAgXSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIFguNTA5djMgY2VydGlmaWNhdGUgZXh0ZW5zaW9ucyB0byBBU04uMS5cbiAqXG4gKiBAcGFyYW0gZXh0cyB0aGUgZXh0ZW5zaW9ucyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIGV4dGVuc2lvbnMgaW4gQVNOLjEgZm9ybWF0LlxuICovXG5wa2kuY2VydGlmaWNhdGVFeHRlbnNpb25zVG9Bc24xID0gZnVuY3Rpb24oZXh0cykge1xuICAvLyBjcmVhdGUgdG9wLWxldmVsIGV4dGVuc2lvbiBjb250YWluZXJcbiAgdmFyIHJ2YWwgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDMsIHRydWUsIFtdKTtcblxuICAvLyBjcmVhdGUgZXh0ZW5zaW9uIHNlcXVlbmNlIChzdG9yZXMgYSBzZXF1ZW5jZSBmb3IgZWFjaCBleHRlbnNpb24pXG4gIHZhciBzZXEgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gIHJ2YWwudmFsdWUucHVzaChzZXEpO1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBleHRzLmxlbmd0aDsgKytpKSB7XG4gICAgc2VxLnZhbHVlLnB1c2gocGtpLmNlcnRpZmljYXRlRXh0ZW5zaW9uVG9Bc24xKGV4dHNbaV0pKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNpbmdsZSBjZXJ0aWZpY2F0ZSBleHRlbnNpb24gdG8gQVNOLjEuXG4gKlxuICogQHBhcmFtIGV4dCB0aGUgZXh0ZW5zaW9uIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgZXh0ZW5zaW9uIGluIEFTTi4xIGZvcm1hdC5cbiAqL1xucGtpLmNlcnRpZmljYXRlRXh0ZW5zaW9uVG9Bc24xID0gZnVuY3Rpb24oZXh0KSB7XG4gIC8vIGNyZWF0ZSBhIHNlcXVlbmNlIGZvciBlYWNoIGV4dGVuc2lvblxuICB2YXIgZXh0c2VxID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuXG4gIC8vIGV4dG5JRCAoT0lEKVxuICBleHRzZXEudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgYXNuMS5vaWRUb0RlcihleHQuaWQpLmdldEJ5dGVzKCkpKTtcblxuICAvLyBjcml0aWNhbCBkZWZhdWx0cyB0byBmYWxzZVxuICBpZihleHQuY3JpdGljYWwpIHtcbiAgICAvLyBjcml0aWNhbCBCT09MRUFOIERFRkFVTFQgRkFMU0VcbiAgICBleHRzZXEudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQk9PTEVBTiwgZmFsc2UsXG4gICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkYpKSk7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBleHQudmFsdWU7XG4gIGlmKHR5cGVvZiBleHQudmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gdmFsdWUgaXMgYXNuLjFcbiAgICB2YWx1ZSA9IGFzbjEudG9EZXIodmFsdWUpLmdldEJ5dGVzKCk7XG4gIH1cblxuICAvLyBleHRuVmFsdWUgKE9DVEVUIFNUUklORylcbiAgZXh0c2VxLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIHZhbHVlKSk7XG5cbiAgcmV0dXJuIGV4dHNlcTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQS0NTIzEwIGNlcnRpZmljYXRpb24gcmVxdWVzdCB0byBhbiBBU04uMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGNzciB0aGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0LlxuICpcbiAqIEByZXR1cm4gdGhlIGFzbjEgcmVwcmVzZW50YXRpb24gb2YgYSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gKi9cbnBraS5jZXJ0aWZpY2F0aW9uUmVxdWVzdFRvQXNuMSA9IGZ1bmN0aW9uKGNzcikge1xuICAvLyBwcmVmZXIgY2FjaGVkIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyBvdmVyIGdlbmVyYXRpbmcgb25lXG4gIHZhciBjcmkgPSBjc3IuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIHx8XG4gICAgcGtpLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyhjc3IpO1xuXG4gIC8vIENlcnRpZmljYXRlXG4gIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvXG4gICAgY3JpLFxuICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIoY3NyLnNpZ25hdHVyZU9pZCkuZ2V0Qnl0ZXMoKSksXG4gICAgICAvLyBwYXJhbWV0ZXJzXG4gICAgICBfc2lnbmF0dXJlUGFyYW1ldGVyc1RvQXNuMShjc3Iuc2lnbmF0dXJlT2lkLCBjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycylcbiAgICBdKSxcbiAgICAvLyBzaWduYXR1cmVcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLkJJVFNUUklORywgZmFsc2UsXG4gICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MDApICsgY3NyLnNpZ25hdHVyZSlcbiAgXSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBDQSBzdG9yZS5cbiAqXG4gKiBAcGFyYW0gY2VydHMgYW4gb3B0aW9uYWwgYXJyYXkgb2YgY2VydGlmaWNhdGUgb2JqZWN0cyBvciBQRU0tZm9ybWF0dGVkXG4gKiAgICAgICAgICBjZXJ0aWZpY2F0ZSBzdHJpbmdzIHRvIGFkZCB0byB0aGUgQ0Egc3RvcmUuXG4gKlxuICogQHJldHVybiB0aGUgQ0Egc3RvcmUuXG4gKi9cbnBraS5jcmVhdGVDYVN0b3JlID0gZnVuY3Rpb24oY2VydHMpIHtcbiAgLy8gY3JlYXRlIENBIHN0b3JlXG4gIHZhciBjYVN0b3JlID0ge1xuICAgIC8vIHN0b3JlZCBjZXJ0aWZpY2F0ZXNcbiAgICBjZXJ0czoge31cbiAgfTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgY2VydGlmaWNhdGUgdGhhdCBpc3N1ZWQgdGhlIHBhc3NlZCBjZXJ0aWZpY2F0ZSBvciBpdHNcbiAgICogJ3BhcmVudCcuXG4gICAqXG4gICAqIEBwYXJhbSBjZXJ0IHRoZSBjZXJ0aWZpY2F0ZSB0byBnZXQgdGhlIHBhcmVudCBmb3IuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHBhcmVudCBjZXJ0aWZpY2F0ZSBvciBudWxsIGlmIG5vbmUgd2FzIGZvdW5kLlxuICAgKi9cbiAgY2FTdG9yZS5nZXRJc3N1ZXIgPSBmdW5jdGlvbihjZXJ0KSB7XG4gICAgdmFyIHJ2YWwgPSBnZXRCeVN1YmplY3QoY2VydC5pc3N1ZXIpO1xuXG4gICAgLy8gc2VlIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBtYXRjaGVzXG4gICAgLyppZihmb3JnZS51dGlsLmlzQXJyYXkocnZhbCkpIHtcbiAgICAgIC8vIFRPRE86IHJlc29sdmUgbXVsdGlwbGUgbWF0Y2hlcyBieSBjaGVja2luZ1xuICAgICAgLy8gYXV0aG9yaXR5S2V5L3N1YmplY3RLZXkvaXNzdWVyVW5pcXVlSUQvb3RoZXIgaWRlbnRpZmllcnMsIGV0Yy5cbiAgICAgIC8vIEZJWE1FOiBvciBhbHRlcm5hdGl2ZWx5IGRvIGF1dGhvcml0eSBrZXkgbWFwcGluZ1xuICAgICAgLy8gaWYgcG9zc2libGUgKFguNTA5djEgY2VydHMgY2FuJ3Qgd29yaz8pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc29sdmluZyBtdWx0aXBsZSBpc3N1ZXIgbWF0Y2hlcyBub3QgaW1wbGVtZW50ZWQgeWV0LicpO1xuICAgIH0qL1xuXG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgYSB0cnVzdGVkIGNlcnRpZmljYXRlIHRvIHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIGNlcnQgdGhlIGNlcnRpZmljYXRlIHRvIGFkZCBhcyBhIHRydXN0ZWQgY2VydGlmaWNhdGUgKGVpdGhlciBhXG4gICAqICAgICAgICAgIHBraS5jZXJ0aWZpY2F0ZSBvYmplY3Qgb3IgYSBQRU0tZm9ybWF0dGVkIGNlcnRpZmljYXRlKS5cbiAgICovXG4gIGNhU3RvcmUuYWRkQ2VydGlmaWNhdGUgPSBmdW5jdGlvbihjZXJ0KSB7XG4gICAgLy8gY29udmVydCBmcm9tIHBlbSBpZiBuZWNlc3NhcnlcbiAgICBpZih0eXBlb2YgY2VydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNlcnQgPSBmb3JnZS5wa2kuY2VydGlmaWNhdGVGcm9tUGVtKGNlcnQpO1xuICAgIH1cblxuICAgIGVuc3VyZVN1YmplY3RIYXNIYXNoKGNlcnQuc3ViamVjdCk7XG5cbiAgICBpZighY2FTdG9yZS5oYXNDZXJ0aWZpY2F0ZShjZXJ0KSkgeyAvLyBhdm9pZCBkdXBsaWNhdGUgY2VydGlmaWNhdGVzIGluIHN0b3JlXG4gICAgICBpZihjZXJ0LnN1YmplY3QuaGFzaCBpbiBjYVN0b3JlLmNlcnRzKSB7XG4gICAgICAgIC8vIHN1YmplY3QgaGFzaCBhbHJlYWR5IGV4aXN0cywgYXBwZW5kIHRvIGFycmF5XG4gICAgICAgIHZhciB0bXAgPSBjYVN0b3JlLmNlcnRzW2NlcnQuc3ViamVjdC5oYXNoXTtcbiAgICAgICAgaWYoIWZvcmdlLnV0aWwuaXNBcnJheSh0bXApKSB7XG4gICAgICAgICAgdG1wID0gW3RtcF07XG4gICAgICAgIH1cbiAgICAgICAgdG1wLnB1c2goY2VydCk7XG4gICAgICAgIGNhU3RvcmUuY2VydHNbY2VydC5zdWJqZWN0Lmhhc2hdID0gdG1wO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FTdG9yZS5jZXJ0c1tjZXJ0LnN1YmplY3QuaGFzaF0gPSBjZXJ0O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgZ2l2ZW4gY2VydGlmaWNhdGUgaXMgaW4gdGhlIHN0b3JlLlxuICAgKlxuICAgKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUgdG8gY2hlY2sgKGVpdGhlciBhIHBraS5jZXJ0aWZpY2F0ZSBvciBhXG4gICAqICAgICAgICAgIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGUpLlxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgdGhlIGNlcnRpZmljYXRlIGlzIGluIHRoZSBzdG9yZSwgZmFsc2UgaWYgbm90LlxuICAgKi9cbiAgY2FTdG9yZS5oYXNDZXJ0aWZpY2F0ZSA9IGZ1bmN0aW9uKGNlcnQpIHtcbiAgICAvLyBjb252ZXJ0IGZyb20gcGVtIGlmIG5lY2Vzc2FyeVxuICAgIGlmKHR5cGVvZiBjZXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgY2VydCA9IGZvcmdlLnBraS5jZXJ0aWZpY2F0ZUZyb21QZW0oY2VydCk7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoID0gZ2V0QnlTdWJqZWN0KGNlcnQuc3ViamVjdCk7XG4gICAgaWYoIW1hdGNoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkobWF0Y2gpKSB7XG4gICAgICBtYXRjaCA9IFttYXRjaF07XG4gICAgfVxuICAgIC8vIGNvbXBhcmUgREVSLWVuY29kaW5nIG9mIGNlcnRpZmljYXRlc1xuICAgIHZhciBkZXIxID0gYXNuMS50b0Rlcihwa2kuY2VydGlmaWNhdGVUb0FzbjEoY2VydCkpLmdldEJ5dGVzKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG1hdGNoLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZGVyMiA9IGFzbjEudG9EZXIocGtpLmNlcnRpZmljYXRlVG9Bc24xKG1hdGNoW2ldKSkuZ2V0Qnl0ZXMoKTtcbiAgICAgIGlmKGRlcjEgPT09IGRlcjIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogTGlzdHMgYWxsIG9mIHRoZSBjZXJ0aWZpY2F0ZXMga2VwdCBpbiB0aGUgc3RvcmUuXG4gICAqXG4gICAqIEByZXR1cm4gYW4gYXJyYXkgb2YgYWxsIG9mIHRoZSBwa2kuY2VydGlmaWNhdGUgb2JqZWN0cyBpbiB0aGUgc3RvcmUuXG4gICAqL1xuICBjYVN0b3JlLmxpc3RBbGxDZXJ0aWZpY2F0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2VydExpc3QgPSBbXTtcblxuICAgIGZvcih2YXIgaGFzaCBpbiBjYVN0b3JlLmNlcnRzKSB7XG4gICAgICBpZihjYVN0b3JlLmNlcnRzLmhhc093blByb3BlcnR5KGhhc2gpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGNhU3RvcmUuY2VydHNbaGFzaF07XG4gICAgICAgIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgY2VydExpc3QucHVzaCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjZXJ0TGlzdC5wdXNoKHZhbHVlW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2VydExpc3Q7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjZXJ0aWZpY2F0ZSBmcm9tIHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIGNlcnQgdGhlIGNlcnRpZmljYXRlIHRvIHJlbW92ZSAoZWl0aGVyIGEgcGtpLmNlcnRpZmljYXRlIG9yIGFcbiAgICogICAgICAgICAgUEVNLWZvcm1hdHRlZCBjZXJ0aWZpY2F0ZSkuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIGNlcnRpZmljYXRlIHRoYXQgd2FzIHJlbW92ZWQgb3IgbnVsbCBpZiB0aGUgY2VydGlmaWNhdGVcbiAgICogICAgICAgICAgIHdhc24ndCBpbiBzdG9yZS5cbiAgICovXG4gIGNhU3RvcmUucmVtb3ZlQ2VydGlmaWNhdGUgPSBmdW5jdGlvbihjZXJ0KSB7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIC8vIGNvbnZlcnQgZnJvbSBwZW0gaWYgbmVjZXNzYXJ5XG4gICAgaWYodHlwZW9mIGNlcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjZXJ0ID0gZm9yZ2UucGtpLmNlcnRpZmljYXRlRnJvbVBlbShjZXJ0KTtcbiAgICB9XG4gICAgZW5zdXJlU3ViamVjdEhhc0hhc2goY2VydC5zdWJqZWN0KTtcbiAgICBpZighY2FTdG9yZS5oYXNDZXJ0aWZpY2F0ZShjZXJ0KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoID0gZ2V0QnlTdWJqZWN0KGNlcnQuc3ViamVjdCk7XG5cbiAgICBpZighZm9yZ2UudXRpbC5pc0FycmF5KG1hdGNoKSkge1xuICAgICAgcmVzdWx0ID0gY2FTdG9yZS5jZXJ0c1tjZXJ0LnN1YmplY3QuaGFzaF07XG4gICAgICBkZWxldGUgY2FTdG9yZS5jZXJ0c1tjZXJ0LnN1YmplY3QuaGFzaF07XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIGNvbXBhcmUgREVSLWVuY29kaW5nIG9mIGNlcnRpZmljYXRlc1xuICAgIHZhciBkZXIxID0gYXNuMS50b0Rlcihwa2kuY2VydGlmaWNhdGVUb0FzbjEoY2VydCkpLmdldEJ5dGVzKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG1hdGNoLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZGVyMiA9IGFzbjEudG9EZXIocGtpLmNlcnRpZmljYXRlVG9Bc24xKG1hdGNoW2ldKSkuZ2V0Qnl0ZXMoKTtcbiAgICAgIGlmKGRlcjEgPT09IGRlcjIpIHtcbiAgICAgICAgcmVzdWx0ID0gbWF0Y2hbaV07XG4gICAgICAgIG1hdGNoLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYobWF0Y2gubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWxldGUgY2FTdG9yZS5jZXJ0c1tjZXJ0LnN1YmplY3QuaGFzaF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRCeVN1YmplY3Qoc3ViamVjdCkge1xuICAgIGVuc3VyZVN1YmplY3RIYXNIYXNoKHN1YmplY3QpO1xuICAgIHJldHVybiBjYVN0b3JlLmNlcnRzW3N1YmplY3QuaGFzaF0gfHwgbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuc3VyZVN1YmplY3RIYXNIYXNoKHN1YmplY3QpIHtcbiAgICAvLyBwcm9kdWNlIHN1YmplY3QgaGFzaCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgaWYoIXN1YmplY3QuaGFzaCkge1xuICAgICAgdmFyIG1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgICAgIHN1YmplY3QuYXR0cmlidXRlcyA9IHBraS5SRE5BdHRyaWJ1dGVzQXNBcnJheShfZG5Ub0FzbjEoc3ViamVjdCksIG1kKTtcbiAgICAgIHN1YmplY3QuaGFzaCA9IG1kLmRpZ2VzdCgpLnRvSGV4KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gYXV0by1hZGQgcGFzc2VkIGluIGNlcnRzXG4gIGlmKGNlcnRzKSB7XG4gICAgLy8gcGFyc2UgUEVNLWZvcm1hdHRlZCBjZXJ0aWZpY2F0ZXMgYXMgbmVjZXNzYXJ5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGNlcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgY2VydCA9IGNlcnRzW2ldO1xuICAgICAgY2FTdG9yZS5hZGRDZXJ0aWZpY2F0ZShjZXJ0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2FTdG9yZTtcbn07XG5cbi8qKlxuICogQ2VydGlmaWNhdGUgdmVyaWZpY2F0aW9uIGVycm9ycywgYmFzZWQgb24gVExTLlxuICovXG5wa2kuY2VydGlmaWNhdGVFcnJvciA9IHtcbiAgYmFkX2NlcnRpZmljYXRlOiAnZm9yZ2UucGtpLkJhZENlcnRpZmljYXRlJyxcbiAgdW5zdXBwb3J0ZWRfY2VydGlmaWNhdGU6ICdmb3JnZS5wa2kuVW5zdXBwb3J0ZWRDZXJ0aWZpY2F0ZScsXG4gIGNlcnRpZmljYXRlX3Jldm9rZWQ6ICdmb3JnZS5wa2kuQ2VydGlmaWNhdGVSZXZva2VkJyxcbiAgY2VydGlmaWNhdGVfZXhwaXJlZDogJ2ZvcmdlLnBraS5DZXJ0aWZpY2F0ZUV4cGlyZWQnLFxuICBjZXJ0aWZpY2F0ZV91bmtub3duOiAnZm9yZ2UucGtpLkNlcnRpZmljYXRlVW5rbm93bicsXG4gIHVua25vd25fY2E6ICdmb3JnZS5wa2kuVW5rbm93bkNlcnRpZmljYXRlQXV0aG9yaXR5J1xufTtcblxuLyoqXG4gKiBWZXJpZmllcyBhIGNlcnRpZmljYXRlIGNoYWluIGFnYWluc3QgdGhlIGdpdmVuIENlcnRpZmljYXRlIEF1dGhvcml0eSBzdG9yZVxuICogd2l0aCBhbiBvcHRpb25hbCBjdXN0b20gdmVyaWZ5IGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSBjYVN0b3JlIGEgY2VydGlmaWNhdGUgc3RvcmUgdG8gdmVyaWZ5IGFnYWluc3QuXG4gKiBAcGFyYW0gY2hhaW4gdGhlIGNlcnRpZmljYXRlIGNoYWluIHRvIHZlcmlmeSwgd2l0aCB0aGUgcm9vdCBvciBoaWdoZXN0XG4gKiAgICAgICAgICBhdXRob3JpdHkgYXQgdGhlIGVuZCAoYW4gYXJyYXkgb2YgY2VydGlmaWNhdGVzKS5cbiAqIEBwYXJhbSBvcHRpb25zIGEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGZvciBldmVyeSBjZXJ0aWZpY2F0ZSBpbiB0aGUgY2hhaW4gb3JcbiAqICAgICAgICAgICAgICAgICAgYW4gb2JqZWN0IHdpdGg6XG4gKiAgICAgICAgICAgICAgICAgIHZlcmlmeSBhIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBmb3IgZXZlcnkgY2VydGlmaWNhdGUgaW4gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgY2hhaW5cbiAqICAgICAgICAgICAgICAgICAgdmFsaWRpdHlDaGVja0RhdGUgdGhlIGRhdGUgYWdhaW5zdCB3aGljaCB0aGUgY2VydGlmaWNhdGVcbiAqICAgICAgICAgICAgICAgICAgICB2YWxpZGl0eSBwZXJpb2Qgc2hvdWxkIGJlIGNoZWNrZWQuIFBhc3MgbnVsbCB0byBub3QgY2hlY2tcbiAqICAgICAgICAgICAgICAgICAgICB0aGUgdmFsaWRpdHkgcGVyaW9kLiBCeSBkZWZhdWx0LCB0aGUgY3VycmVudCBkYXRlIGlzIHVzZWQuXG4gKlxuICogVGhlIHZlcmlmeSBjYWxsYmFjayBoYXMgdGhlIGZvbGxvd2luZyBzaWduYXR1cmU6XG4gKlxuICogdmVyaWZpZWQgLSBTZXQgdG8gdHJ1ZSBpZiBjZXJ0aWZpY2F0ZSB3YXMgdmVyaWZpZWQsIG90aGVyd2lzZSB0aGVcbiAqICAgcGtpLmNlcnRpZmljYXRlRXJyb3IgZm9yIHdoeSB0aGUgY2VydGlmaWNhdGUgZmFpbGVkLlxuICogZGVwdGggLSBUaGUgY3VycmVudCBpbmRleCBpbiB0aGUgY2hhaW4sIHdoZXJlIDAgaXMgdGhlIGVuZCBwb2ludCdzIGNlcnQuXG4gKiBjZXJ0cyAtIFRoZSBjZXJ0aWZpY2F0ZSBjaGFpbiwgKk5PVEUqIGFuIGVtcHR5IGNoYWluIGluZGljYXRlcyBhbiBhbm9ueW1vdXNcbiAqICAgZW5kIHBvaW50LlxuICpcbiAqIFRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUgb24gc3VjY2VzcyBhbmQgb24gZmFpbHVyZSBlaXRoZXIgdGhlIGFwcHJvcHJpYXRlXG4gKiBwa2kuY2VydGlmaWNhdGVFcnJvciBvciBhbiBvYmplY3Qgd2l0aCAnZXJyb3InIHNldCB0byB0aGUgYXBwcm9wcmlhdGVcbiAqIHBraS5jZXJ0aWZpY2F0ZUVycm9yIGFuZCAnbWVzc2FnZScgc2V0IHRvIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2UuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIHRocm93biBpZiBub3QuXG4gKi9cbnBraS52ZXJpZnlDZXJ0aWZpY2F0ZUNoYWluID0gZnVuY3Rpb24oY2FTdG9yZSwgY2hhaW4sIG9wdGlvbnMpIHtcbiAgLyogRnJvbTogUkZDMzI4MCAtIEludGVybmV0IFguNTA5IFB1YmxpYyBLZXkgSW5mcmFzdHJ1Y3R1cmUgQ2VydGlmaWNhdGVcbiAgICBTZWN0aW9uIDY6IENlcnRpZmljYXRpb24gUGF0aCBWYWxpZGF0aW9uXG4gICAgU2VlIGlubGluZSBwYXJlbnRoZXRpY2FscyByZWxhdGVkIHRvIHRoaXMgcGFydGljdWxhciBpbXBsZW1lbnRhdGlvbi5cblxuICAgIFRoZSBwcmltYXJ5IGdvYWwgb2YgcGF0aCB2YWxpZGF0aW9uIGlzIHRvIHZlcmlmeSB0aGUgYmluZGluZyBiZXR3ZWVuXG4gICAgYSBzdWJqZWN0IGRpc3Rpbmd1aXNoZWQgbmFtZSBvciBhIHN1YmplY3QgYWx0ZXJuYXRpdmUgbmFtZSBhbmQgc3ViamVjdFxuICAgIHB1YmxpYyBrZXksIGFzIHJlcHJlc2VudGVkIGluIHRoZSBlbmQgZW50aXR5IGNlcnRpZmljYXRlLCBiYXNlZCBvbiB0aGVcbiAgICBwdWJsaWMga2V5IG9mIHRoZSB0cnVzdCBhbmNob3IuIFRoaXMgcmVxdWlyZXMgb2J0YWluaW5nIGEgc2VxdWVuY2Ugb2ZcbiAgICBjZXJ0aWZpY2F0ZXMgdGhhdCBzdXBwb3J0IHRoYXQgYmluZGluZy4gVGhhdCBzZXF1ZW5jZSBzaG91bGQgYmUgcHJvdmlkZWRcbiAgICBpbiB0aGUgcGFzc2VkICdjaGFpbicuIFRoZSB0cnVzdCBhbmNob3Igc2hvdWxkIGJlIGluIHRoZSBnaXZlbiBDQVxuICAgIHN0b3JlLiBUaGUgJ2VuZCBlbnRpdHknIGNlcnRpZmljYXRlIGlzIHRoZSBjZXJ0aWZpY2F0ZSBwcm92aWRlZCBieSB0aGVcbiAgICBlbmQgcG9pbnQgKHR5cGljYWxseSBhIHNlcnZlcikgYW5kIGlzIHRoZSBmaXJzdCBpbiB0aGUgY2hhaW4uXG5cbiAgICBUbyBtZWV0IHRoaXMgZ29hbCwgdGhlIHBhdGggdmFsaWRhdGlvbiBwcm9jZXNzIHZlcmlmaWVzLCBhbW9uZyBvdGhlclxuICAgIHRoaW5ncywgdGhhdCBhIHByb3NwZWN0aXZlIGNlcnRpZmljYXRpb24gcGF0aCAoYSBzZXF1ZW5jZSBvZiBuXG4gICAgY2VydGlmaWNhdGVzIG9yIGEgJ2NoYWluJykgc2F0aXNmaWVzIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICAgIChhKSBmb3IgYWxsIHggaW4gezEsIC4uLiwgbi0xfSwgdGhlIHN1YmplY3Qgb2YgY2VydGlmaWNhdGUgeCBpc1xuICAgICAgICAgIHRoZSBpc3N1ZXIgb2YgY2VydGlmaWNhdGUgeCsxO1xuXG4gICAgKGIpIGNlcnRpZmljYXRlIDEgaXMgaXNzdWVkIGJ5IHRoZSB0cnVzdCBhbmNob3I7XG5cbiAgICAoYykgY2VydGlmaWNhdGUgbiBpcyB0aGUgY2VydGlmaWNhdGUgdG8gYmUgdmFsaWRhdGVkOyBhbmRcblxuICAgIChkKSBmb3IgYWxsIHggaW4gezEsIC4uLiwgbn0sIHRoZSBjZXJ0aWZpY2F0ZSB3YXMgdmFsaWQgYXQgdGhlXG4gICAgICAgICAgdGltZSBpbiBxdWVzdGlvbi5cblxuICAgIE5vdGUgdGhhdCBoZXJlICduJyBpcyBpbmRleCAwIGluIHRoZSBjaGFpbiBhbmQgMSBpcyB0aGUgbGFzdCBjZXJ0aWZpY2F0ZVxuICAgIGluIHRoZSBjaGFpbiBhbmQgaXQgbXVzdCBiZSBzaWduZWQgYnkgYSBjZXJ0aWZpY2F0ZSBpbiB0aGUgY29ubmVjdGlvbidzXG4gICAgQ0Egc3RvcmUuXG5cbiAgICBUaGUgcGF0aCB2YWxpZGF0aW9uIHByb2Nlc3MgYWxzbyBkZXRlcm1pbmVzIHRoZSBzZXQgb2YgY2VydGlmaWNhdGVcbiAgICBwb2xpY2llcyB0aGF0IGFyZSB2YWxpZCBmb3IgdGhpcyBwYXRoLCBiYXNlZCBvbiB0aGUgY2VydGlmaWNhdGUgcG9saWNpZXNcbiAgICBleHRlbnNpb24sIHBvbGljeSBtYXBwaW5nIGV4dGVuc2lvbiwgcG9saWN5IGNvbnN0cmFpbnRzIGV4dGVuc2lvbiwgYW5kXG4gICAgaW5oaWJpdCBhbnktcG9saWN5IGV4dGVuc2lvbi5cblxuICAgIE5vdGU6IFBvbGljeSBtYXBwaW5nIGV4dGVuc2lvbiBub3Qgc3VwcG9ydGVkIChOb3QgUmVxdWlyZWQpLlxuXG4gICAgTm90ZTogSWYgdGhlIGNlcnRpZmljYXRlIGhhcyBhbiB1bnN1cHBvcnRlZCBjcml0aWNhbCBleHRlbnNpb24sIHRoZW4gaXRcbiAgICBtdXN0IGJlIHJlamVjdGVkLlxuXG4gICAgTm90ZTogQSBjZXJ0aWZpY2F0ZSBpcyBzZWxmLWlzc3VlZCBpZiB0aGUgRE5zIHRoYXQgYXBwZWFyIGluIHRoZSBzdWJqZWN0XG4gICAgYW5kIGlzc3VlciBmaWVsZHMgYXJlIGlkZW50aWNhbCBhbmQgYXJlIG5vdCBlbXB0eS5cblxuICAgIFRoZSBwYXRoIHZhbGlkYXRpb24gYWxnb3JpdGhtIGFzc3VtZXMgdGhlIGZvbGxvd2luZyBzZXZlbiBpbnB1dHMgYXJlXG4gICAgcHJvdmlkZWQgdG8gdGhlIHBhdGggcHJvY2Vzc2luZyBsb2dpYy4gV2hhdCB0aGlzIHNwZWNpZmljIGltcGxlbWVudGF0aW9uXG4gICAgd2lsbCB1c2UgaXMgcHJvdmlkZWQgcGFyZW50aGV0aWNhbGx5OlxuXG4gICAgKGEpIGEgcHJvc3BlY3RpdmUgY2VydGlmaWNhdGlvbiBwYXRoIG9mIGxlbmd0aCBuICh0aGUgJ2NoYWluJylcbiAgICAoYikgdGhlIGN1cnJlbnQgZGF0ZS90aW1lOiAoJ25vdycpLlxuICAgIChjKSB1c2VyLWluaXRpYWwtcG9saWN5LXNldDogQSBzZXQgb2YgY2VydGlmaWNhdGUgcG9saWN5IGlkZW50aWZpZXJzXG4gICAgICAgICAgbmFtaW5nIHRoZSBwb2xpY2llcyB0aGF0IGFyZSBhY2NlcHRhYmxlIHRvIHRoZSBjZXJ0aWZpY2F0ZSB1c2VyLlxuICAgICAgICAgIFRoZSB1c2VyLWluaXRpYWwtcG9saWN5LXNldCBjb250YWlucyB0aGUgc3BlY2lhbCB2YWx1ZSBhbnktcG9saWN5XG4gICAgICAgICAgaWYgdGhlIHVzZXIgaXMgbm90IGNvbmNlcm5lZCBhYm91dCBjZXJ0aWZpY2F0ZSBwb2xpY3lcbiAgICAgICAgICAoTm90IGltcGxlbWVudGVkLiBBbnkgcG9saWN5IGlzIGFjY2VwdGVkKS5cbiAgICAoZCkgdHJ1c3QgYW5jaG9yIGluZm9ybWF0aW9uLCBkZXNjcmliaW5nIGEgQ0EgdGhhdCBzZXJ2ZXMgYXMgYSB0cnVzdFxuICAgICAgICAgIGFuY2hvciBmb3IgdGhlIGNlcnRpZmljYXRpb24gcGF0aC4gVGhlIHRydXN0IGFuY2hvciBpbmZvcm1hdGlvblxuICAgICAgICAgIGluY2x1ZGVzOlxuXG4gICAgICAoMSkgIHRoZSB0cnVzdGVkIGlzc3VlciBuYW1lLFxuICAgICAgKDIpICB0aGUgdHJ1c3RlZCBwdWJsaWMga2V5IGFsZ29yaXRobSxcbiAgICAgICgzKSAgdGhlIHRydXN0ZWQgcHVibGljIGtleSwgYW5kXG4gICAgICAoNCkgIG9wdGlvbmFsbHksIHRoZSB0cnVzdGVkIHB1YmxpYyBrZXkgcGFyYW1ldGVycyBhc3NvY2lhdGVkXG4gICAgICAgICAgICAgd2l0aCB0aGUgcHVibGljIGtleS5cblxuICAgICAgKFRydXN0IGFuY2hvcnMgYXJlIHByb3ZpZGVkIHZpYSBjZXJ0aWZpY2F0ZXMgaW4gdGhlIENBIHN0b3JlKS5cblxuICAgICAgVGhlIHRydXN0IGFuY2hvciBpbmZvcm1hdGlvbiBtYXkgYmUgcHJvdmlkZWQgdG8gdGhlIHBhdGggcHJvY2Vzc2luZ1xuICAgICAgcHJvY2VkdXJlIGluIHRoZSBmb3JtIG9mIGEgc2VsZi1zaWduZWQgY2VydGlmaWNhdGUuIFRoZSB0cnVzdGVkIGFuY2hvclxuICAgICAgaW5mb3JtYXRpb24gaXMgdHJ1c3RlZCBiZWNhdXNlIGl0IHdhcyBkZWxpdmVyZWQgdG8gdGhlIHBhdGggcHJvY2Vzc2luZ1xuICAgICAgcHJvY2VkdXJlIGJ5IHNvbWUgdHJ1c3R3b3J0aHkgb3V0LW9mLWJhbmQgcHJvY2VkdXJlLiBJZiB0aGUgdHJ1c3RlZFxuICAgICAgcHVibGljIGtleSBhbGdvcml0aG0gcmVxdWlyZXMgcGFyYW1ldGVycywgdGhlbiB0aGUgcGFyYW1ldGVycyBhcmVcbiAgICAgIHByb3ZpZGVkIGFsb25nIHdpdGggdGhlIHRydXN0ZWQgcHVibGljIGtleSAoTm8gcGFyYW1ldGVycyB1c2VkIGluIHRoaXNcbiAgICAgIGltcGxlbWVudGF0aW9uKS5cblxuICAgIChlKSBpbml0aWFsLXBvbGljeS1tYXBwaW5nLWluaGliaXQsIHdoaWNoIGluZGljYXRlcyBpZiBwb2xpY3kgbWFwcGluZyBpc1xuICAgICAgICAgIGFsbG93ZWQgaW4gdGhlIGNlcnRpZmljYXRpb24gcGF0aC5cbiAgICAgICAgICAoTm90IGltcGxlbWVudGVkLCBubyBwb2xpY3kgY2hlY2tpbmcpXG5cbiAgICAoZikgaW5pdGlhbC1leHBsaWNpdC1wb2xpY3ksIHdoaWNoIGluZGljYXRlcyBpZiB0aGUgcGF0aCBtdXN0IGJlIHZhbGlkXG4gICAgICAgICAgZm9yIGF0IGxlYXN0IG9uZSBvZiB0aGUgY2VydGlmaWNhdGUgcG9saWNpZXMgaW4gdGhlIHVzZXItaW5pdGlhbC1cbiAgICAgICAgICBwb2xpY3ktc2V0LlxuICAgICAgICAgIChOb3QgaW1wbGVtZW50ZWQsIG5vIHBvbGljeSBjaGVja2luZylcblxuICAgIChnKSBpbml0aWFsLWFueS1wb2xpY3ktaW5oaWJpdCwgd2hpY2ggaW5kaWNhdGVzIHdoZXRoZXIgdGhlXG4gICAgICAgICAgYW55UG9saWN5IE9JRCBzaG91bGQgYmUgcHJvY2Vzc2VkIGlmIGl0IGlzIGluY2x1ZGVkIGluIGFcbiAgICAgICAgICBjZXJ0aWZpY2F0ZS5cbiAgICAgICAgICAoTm90IGltcGxlbWVudGVkLCBzbyBhbnkgcG9saWN5IGlzIHZhbGlkIHByb3ZpZGVkIHRoYXQgaXQgaXNcbiAgICAgICAgICBub3QgbWFya2VkIGFzIGNyaXRpY2FsKSAqL1xuXG4gIC8qIEJhc2ljIFBhdGggUHJvY2Vzc2luZzpcblxuICAgIEZvciBlYWNoIGNlcnRpZmljYXRlIGluIHRoZSAnY2hhaW4nLCB0aGUgZm9sbG93aW5nIGlzIGNoZWNrZWQ6XG5cbiAgICAxLiBUaGUgY2VydGlmaWNhdGUgdmFsaWRpdHkgcGVyaW9kIGluY2x1ZGVzIHRoZSBjdXJyZW50IHRpbWUuXG4gICAgMi4gVGhlIGNlcnRpZmljYXRlIHdhcyBzaWduZWQgYnkgaXRzIHBhcmVudCAod2hlcmUgdGhlIHBhcmVudCBpcyBlaXRoZXJcbiAgICAgICB0aGUgbmV4dCBpbiB0aGUgY2hhaW4gb3IgZnJvbSB0aGUgQ0Egc3RvcmUpLiBBbGxvdyBwcm9jZXNzaW5nIHRvXG4gICAgICAgY29udGludWUgdG8gdGhlIG5leHQgc3RlcCBpZiBubyBwYXJlbnQgaXMgZm91bmQgYnV0IHRoZSBjZXJ0aWZpY2F0ZSBpc1xuICAgICAgIGluIHRoZSBDQSBzdG9yZS5cbiAgICAzLiBUT0RPOiBUaGUgY2VydGlmaWNhdGUgaGFzIG5vdCBiZWVuIHJldm9rZWQuXG4gICAgNC4gVGhlIGNlcnRpZmljYXRlIGlzc3VlciBuYW1lIG1hdGNoZXMgdGhlIHBhcmVudCdzIHN1YmplY3QgbmFtZS5cbiAgICA1LiBUT0RPOiBJZiB0aGUgY2VydGlmaWNhdGUgaXMgc2VsZi1pc3N1ZWQgYW5kIG5vdCB0aGUgZmluYWwgY2VydGlmaWNhdGVcbiAgICAgICBpbiB0aGUgY2hhaW4sIHNraXAgdGhpcyBzdGVwLCBvdGhlcndpc2UgdmVyaWZ5IHRoYXQgdGhlIHN1YmplY3QgbmFtZVxuICAgICAgIGlzIHdpdGhpbiBvbmUgb2YgdGhlIHBlcm1pdHRlZCBzdWJ0cmVlcyBvZiBYLjUwMCBkaXN0aW5ndWlzaGVkIG5hbWVzXG4gICAgICAgYW5kIHRoYXQgZWFjaCBvZiB0aGUgYWx0ZXJuYXRpdmUgbmFtZXMgaW4gdGhlIHN1YmplY3RBbHROYW1lIGV4dGVuc2lvblxuICAgICAgIChjcml0aWNhbCBvciBub24tY3JpdGljYWwpIGlzIHdpdGhpbiBvbmUgb2YgdGhlIHBlcm1pdHRlZCBzdWJ0cmVlcyBmb3JcbiAgICAgICB0aGF0IG5hbWUgdHlwZS5cbiAgICA2LiBUT0RPOiBJZiB0aGUgY2VydGlmaWNhdGUgaXMgc2VsZi1pc3N1ZWQgYW5kIG5vdCB0aGUgZmluYWwgY2VydGlmaWNhdGVcbiAgICAgICBpbiB0aGUgY2hhaW4sIHNraXAgdGhpcyBzdGVwLCBvdGhlcndpc2UgdmVyaWZ5IHRoYXQgdGhlIHN1YmplY3QgbmFtZVxuICAgICAgIGlzIG5vdCB3aXRoaW4gb25lIG9mIHRoZSBleGNsdWRlZCBzdWJ0cmVlcyBmb3IgWC41MDAgZGlzdGluZ3Vpc2hlZFxuICAgICAgIG5hbWVzIGFuZCBub25lIG9mIHRoZSBzdWJqZWN0QWx0TmFtZSBleHRlbnNpb24gbmFtZXMgYXJlIGV4Y2x1ZGVkIGZvclxuICAgICAgIHRoYXQgbmFtZSB0eXBlLlxuICAgIDcuIFRoZSBvdGhlciBzdGVwcyBpbiB0aGUgYWxnb3JpdGhtIGZvciBiYXNpYyBwYXRoIHByb2Nlc3NpbmcgaW52b2x2ZVxuICAgICAgIGhhbmRsaW5nIHRoZSBwb2xpY3kgZXh0ZW5zaW9uIHdoaWNoIGlzIG5vdCBwcmVzZW50bHkgc3VwcG9ydGVkIGluIHRoaXNcbiAgICAgICBpbXBsZW1lbnRhdGlvbi4gSW5zdGVhZCwgaWYgYSBjcml0aWNhbCBwb2xpY3kgZXh0ZW5zaW9uIGlzIGZvdW5kLCB0aGVcbiAgICAgICBjZXJ0aWZpY2F0ZSBpcyByZWplY3RlZCBhcyBub3Qgc3VwcG9ydGVkLlxuICAgIDguIElmIHRoZSBjZXJ0aWZpY2F0ZSBpcyBub3QgdGhlIGZpcnN0IG9yIGlmIGl0cyB0aGUgb25seSBjZXJ0aWZpY2F0ZSBpblxuICAgICAgIHRoZSBjaGFpbiAoaGF2aW5nIG5vIHBhcmVudCBmcm9tIHRoZSBDQSBzdG9yZSBvciBpcyBzZWxmLXNpZ25lZCkgYW5kIGl0XG4gICAgICAgaGFzIGEgY3JpdGljYWwga2V5IHVzYWdlIGV4dGVuc2lvbiwgdmVyaWZ5IHRoYXQgdGhlIGtleUNlcnRTaWduIGJpdCBpc1xuICAgICAgIHNldC4gSWYgdGhlIGtleSB1c2FnZSBleHRlbnNpb24gZXhpc3RzLCB2ZXJpZnkgdGhhdCB0aGUgYmFzaWNcbiAgICAgICBjb25zdHJhaW50cyBleHRlbnNpb24gZXhpc3RzLiBJZiB0aGUgYmFzaWMgY29uc3RyYWludHMgZXh0ZW5zaW9uIGV4aXN0cyxcbiAgICAgICB2ZXJpZnkgdGhhdCB0aGUgY0EgZmxhZyBpcyBzZXQuIElmIHBhdGhMZW5Db25zdHJhaW50IGlzIHNldCwgZW5zdXJlIHRoYXRcbiAgICAgICB0aGUgbnVtYmVyIG9mIGNlcnRpZmljYXRlcyB0aGF0IHByZWNlZGUgaW4gdGhlIGNoYWluIChjb21lIGVhcmxpZXJcbiAgICAgICBpbiB0aGUgY2hhaW4gYXMgaW1wbGVtZW50ZWQgYmVsb3cpLCBleGNsdWRpbmcgdGhlIHZlcnkgZmlyc3QgaW4gdGhlXG4gICAgICAgY2hhaW4gKHR5cGljYWxseSB0aGUgZW5kLWVudGl0eSBvbmUpLCBpc24ndCBncmVhdGVyIHRoYW4gdGhlXG4gICAgICAgcGF0aExlbkNvbnN0cmFpbnQuIFRoaXMgY29uc3RyYWludCBsaW1pdHMgdGhlIG51bWJlciBvZiBpbnRlcm1lZGlhdGVcbiAgICAgICBDQXMgdGhhdCBtYXkgYXBwZWFyIGJlbG93IGEgQ0EgYmVmb3JlIG9ubHkgZW5kLWVudGl0eSBjZXJ0aWZpY2F0ZXNcbiAgICAgICBtYXkgYmUgaXNzdWVkLiAqL1xuXG4gIC8vIGlmIGEgdmVyaWZ5IGNhbGxiYWNrIGlzIHBhc3NlZCBhcyB0aGUgdGhpcmQgcGFyYW1ldGVyLCBwYWNrYWdlIGl0IHdpdGhpblxuICAvLyB0aGUgb3B0aW9ucyBvYmplY3QuIFRoaXMgaXMgdG8gc3VwcG9ydCBhIGxlZ2FjeSBmdW5jdGlvbiBzaWduYXR1cmUgdGhhdFxuICAvLyBleHBlY3RlZCB0aGUgdmVyaWZ5IGNhbGxiYWNrIGFzIHRoZSB0aGlyZCBwYXJhbWV0ZXIuXG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0aW9ucyA9IHt2ZXJpZnk6IG9wdGlvbnN9O1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIGNvcHkgY2VydCBjaGFpbiByZWZlcmVuY2VzIHRvIGFub3RoZXIgYXJyYXkgdG8gcHJvdGVjdCBhZ2FpbnN0IGNoYW5nZXNcbiAgLy8gaW4gdmVyaWZ5IGNhbGxiYWNrXG4gIGNoYWluID0gY2hhaW4uc2xpY2UoMCk7XG4gIHZhciBjZXJ0cyA9IGNoYWluLnNsaWNlKDApO1xuXG4gIHZhciB2YWxpZGl0eUNoZWNrRGF0ZSA9IG9wdGlvbnMudmFsaWRpdHlDaGVja0RhdGU7XG4gIC8vIGlmIG5vIHZhbGlkaXR5Q2hlY2tEYXRlIGlzIHNwZWNpZmllZCwgZGVmYXVsdCB0byB0aGUgY3VycmVudCBkYXRlLiBNYWtlXG4gIC8vIHN1cmUgdG8gbWFpbnRhaW4gdGhlIHZhbHVlIG51bGwgYmVjYXVzZSBpdCBpbmRpY2F0ZXMgdGhhdCB0aGUgdmFsaWRpdHlcbiAgLy8gcGVyaW9kIHNob3VsZCBub3QgYmUgY2hlY2tlZC5cbiAgaWYodHlwZW9mIHZhbGlkaXR5Q2hlY2tEYXRlID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhbGlkaXR5Q2hlY2tEYXRlID0gbmV3IERhdGUoKTtcbiAgfVxuXG4gIC8vIHZlcmlmeSBlYWNoIGNlcnQgaW4gdGhlIGNoYWluIHVzaW5nIGl0cyBwYXJlbnQsIHdoZXJlIHRoZSBwYXJlbnRcbiAgLy8gaXMgZWl0aGVyIHRoZSBuZXh0IGluIHRoZSBjaGFpbiBvciBmcm9tIHRoZSBDQSBzdG9yZVxuICB2YXIgZmlyc3QgPSB0cnVlO1xuICB2YXIgZXJyb3IgPSBudWxsO1xuICB2YXIgZGVwdGggPSAwO1xuICBkbyB7XG4gICAgdmFyIGNlcnQgPSBjaGFpbi5zaGlmdCgpO1xuICAgIHZhciBwYXJlbnQgPSBudWxsO1xuICAgIHZhciBzZWxmU2lnbmVkID0gZmFsc2U7XG5cbiAgICBpZih2YWxpZGl0eUNoZWNrRGF0ZSkge1xuICAgICAgLy8gMS4gY2hlY2sgdmFsaWQgdGltZVxuICAgICAgaWYodmFsaWRpdHlDaGVja0RhdGUgPCBjZXJ0LnZhbGlkaXR5Lm5vdEJlZm9yZSB8fFxuICAgICAgICAgdmFsaWRpdHlDaGVja0RhdGUgPiBjZXJ0LnZhbGlkaXR5Lm5vdEFmdGVyKSB7XG4gICAgICAgIGVycm9yID0ge1xuICAgICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBpcyBub3QgdmFsaWQgeWV0IG9yIGhhcyBleHBpcmVkLicsXG4gICAgICAgICAgZXJyb3I6IHBraS5jZXJ0aWZpY2F0ZUVycm9yLmNlcnRpZmljYXRlX2V4cGlyZWQsXG4gICAgICAgICAgbm90QmVmb3JlOiBjZXJ0LnZhbGlkaXR5Lm5vdEJlZm9yZSxcbiAgICAgICAgICBub3RBZnRlcjogY2VydC52YWxpZGl0eS5ub3RBZnRlcixcbiAgICAgICAgICAvLyBUT0RPOiB3ZSBtaWdodCB3YW50IHRvIHJlY29uc2lkZXIgcmVuYW1pbmcgJ25vdycgdG9cbiAgICAgICAgICAvLyAndmFsaWRpdHlDaGVja0RhdGUnIHNob3VsZCB0aGlzIEFQSSBiZSBjaGFuZ2VkIGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAgbm93OiB2YWxpZGl0eUNoZWNrRGF0ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDIuIHZlcmlmeSB3aXRoIHBhcmVudCBmcm9tIGNoYWluIG9yIENBIHN0b3JlXG4gICAgaWYoZXJyb3IgPT09IG51bGwpIHtcbiAgICAgIHBhcmVudCA9IGNoYWluWzBdIHx8IGNhU3RvcmUuZ2V0SXNzdWVyKGNlcnQpO1xuICAgICAgaWYocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBzZWxmLXNpZ25lZCBjZXJ0XG4gICAgICAgIGlmKGNlcnQuaXNJc3N1ZXIoY2VydCkpIHtcbiAgICAgICAgICBzZWxmU2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICBwYXJlbnQgPSBjZXJ0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKHBhcmVudCkge1xuICAgICAgICAvLyBGSVhNRTogY3VycmVudCBDQSBzdG9yZSBpbXBsZW1lbnRhdGlvbiBtaWdodCBoYXZlIG11bHRpcGxlXG4gICAgICAgIC8vIGNlcnRpZmljYXRlcyB3aGVyZSB0aGUgaXNzdWVyIGNhbid0IGJlIGRldGVybWluZWQgZnJvbSB0aGVcbiAgICAgICAgLy8gY2VydGlmaWNhdGUgKGhhcHBlbnMgcmFyZWx5IHdpdGgsIGVnOiBvbGQgY2VydGlmaWNhdGVzKSBzbyBub3JtYWxpemVcbiAgICAgICAgLy8gYnkgYWx3YXlzIHB1dHRpbmcgcGFyZW50cyBpbnRvIGFuIGFycmF5XG4gICAgICAgIC8vIFRPRE86IHRoZXJlJ3MgbWF5IGJlIGFuIGV4dHJlbWUgZGVnZW5lcmF0ZSBjYXNlIGN1cnJlbnRseSB1bmNvdmVyZWRcbiAgICAgICAgLy8gd2hlcmUgYW4gb2xkIGludGVybWVkaWF0ZSBjZXJ0aWZpY2F0ZSBzZWVtcyB0byBoYXZlIGEgbWF0Y2hpbmcgcGFyZW50XG4gICAgICAgIC8vIGJ1dCBub25lIG9mIHRoZSBwYXJlbnRzIGFjdHVhbGx5IHZlcmlmeSAuLi4gYnV0IHRoZSBpbnRlcm1lZGlhdGVcbiAgICAgICAgLy8gaXMgaW4gdGhlIENBIGFuZCBpdCBzaG91bGQgcGFzcyB0aGlzIGNoZWNrOyBuZWVkcyBpbnZlc3RpZ2F0aW9uXG4gICAgICAgIHZhciBwYXJlbnRzID0gcGFyZW50O1xuICAgICAgICBpZighZm9yZ2UudXRpbC5pc0FycmF5KHBhcmVudHMpKSB7XG4gICAgICAgICAgcGFyZW50cyA9IFtwYXJlbnRzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyeSB0byB2ZXJpZnkgd2l0aCBlYWNoIHBvc3NpYmxlIHBhcmVudCAodHlwaWNhbGx5IG9ubHkgb25lKVxuICAgICAgICB2YXIgdmVyaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUoIXZlcmlmaWVkICYmIHBhcmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHBhcmVudCA9IHBhcmVudHMuc2hpZnQoKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmVyaWZpZWQgPSBwYXJlbnQudmVyaWZ5KGNlcnQpO1xuICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgIC8vIGZhaWx1cmUgdG8gdmVyaWZ5LCBkb24ndCBjYXJlIHdoeSwgdHJ5IG5leHQgb25lXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIXZlcmlmaWVkKSB7XG4gICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICBtZXNzYWdlOiAnQ2VydGlmaWNhdGUgc2lnbmF0dXJlIGlzIGludmFsaWQuJyxcbiAgICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKGVycm9yID09PSBudWxsICYmICghcGFyZW50IHx8IHNlbGZTaWduZWQpICYmXG4gICAgICAgICFjYVN0b3JlLmhhc0NlcnRpZmljYXRlKGNlcnQpKSB7XG4gICAgICAgIC8vIG5vIHBhcmVudCBpc3N1ZXIgYW5kIGNlcnRpZmljYXRlIGl0c2VsZiBpcyBub3QgdHJ1c3RlZFxuICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICBtZXNzYWdlOiAnQ2VydGlmaWNhdGUgaXMgbm90IHRydXN0ZWQuJyxcbiAgICAgICAgICBlcnJvcjogcGtpLmNlcnRpZmljYXRlRXJyb3IudW5rbm93bl9jYVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IDMuIGNoZWNrIHJldm9rZWRcblxuICAgIC8vIDQuIGNoZWNrIGZvciBtYXRjaGluZyBpc3N1ZXIvc3ViamVjdFxuICAgIGlmKGVycm9yID09PSBudWxsICYmIHBhcmVudCAmJiAhY2VydC5pc0lzc3VlcihwYXJlbnQpKSB7XG4gICAgICAvLyBwYXJlbnQgaXMgbm90IGlzc3VlclxuICAgICAgZXJyb3IgPSB7XG4gICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBpc3N1ZXIgaXMgaW52YWxpZC4nLFxuICAgICAgICBlcnJvcjogcGtpLmNlcnRpZmljYXRlRXJyb3IuYmFkX2NlcnRpZmljYXRlXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIDUuIFRPRE86IGNoZWNrIG5hbWVzIHdpdGggcGVybWl0dGVkIG5hbWVzIHRyZWVcblxuICAgIC8vIDYuIFRPRE86IGNoZWNrIG5hbWVzIGFnYWluc3QgZXhjbHVkZWQgbmFtZXMgdHJlZVxuXG4gICAgLy8gNy4gY2hlY2sgZm9yIHVuc3VwcG9ydGVkIGNyaXRpY2FsIGV4dGVuc2lvbnNcbiAgICBpZihlcnJvciA9PT0gbnVsbCkge1xuICAgICAgLy8gc3VwcG9ydGVkIGV4dGVuc2lvbnNcbiAgICAgIHZhciBzZSA9IHtcbiAgICAgICAga2V5VXNhZ2U6IHRydWUsXG4gICAgICAgIGJhc2ljQ29uc3RyYWludHM6IHRydWVcbiAgICAgIH07XG4gICAgICBmb3IodmFyIGkgPSAwOyBlcnJvciA9PT0gbnVsbCAmJiBpIDwgY2VydC5leHRlbnNpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBleHQgPSBjZXJ0LmV4dGVuc2lvbnNbaV07XG4gICAgICAgIGlmKGV4dC5jcml0aWNhbCAmJiAhKGV4dC5uYW1lIGluIHNlKSkge1xuICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgJ0NlcnRpZmljYXRlIGhhcyBhbiB1bnN1cHBvcnRlZCBjcml0aWNhbCBleHRlbnNpb24uJyxcbiAgICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci51bnN1cHBvcnRlZF9jZXJ0aWZpY2F0ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA4LiBjaGVjayBmb3IgQ0EgaWYgY2VydCBpcyBub3QgZmlyc3Qgb3IgaXMgdGhlIG9ubHkgY2VydGlmaWNhdGVcbiAgICAvLyByZW1haW5pbmcgaW4gY2hhaW4gd2l0aCBubyBwYXJlbnQgb3IgaXMgc2VsZi1zaWduZWRcbiAgICBpZihlcnJvciA9PT0gbnVsbCAmJlxuICAgICAgKCFmaXJzdCB8fCAoY2hhaW4ubGVuZ3RoID09PSAwICYmICghcGFyZW50IHx8IHNlbGZTaWduZWQpKSkpIHtcbiAgICAgIC8vIGZpcnN0IGNoZWNrIGtleVVzYWdlIGV4dGVuc2lvbiBhbmQgdGhlbiBiYXNpYyBjb25zdHJhaW50c1xuICAgICAgdmFyIGJjRXh0ID0gY2VydC5nZXRFeHRlbnNpb24oJ2Jhc2ljQ29uc3RyYWludHMnKTtcbiAgICAgIHZhciBrZXlVc2FnZUV4dCA9IGNlcnQuZ2V0RXh0ZW5zaW9uKCdrZXlVc2FnZScpO1xuICAgICAgaWYoa2V5VXNhZ2VFeHQgIT09IG51bGwpIHtcbiAgICAgICAgLy8ga2V5Q2VydFNpZ24gbXVzdCBiZSB0cnVlIGFuZCB0aGVyZSBtdXN0IGJlIGEgYmFzaWNcbiAgICAgICAgLy8gY29uc3RyYWludHMgZXh0ZW5zaW9uXG4gICAgICAgIGlmKCFrZXlVc2FnZUV4dC5rZXlDZXJ0U2lnbiB8fCBiY0V4dCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIGJhZCBjZXJ0aWZpY2F0ZVxuICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgJ0NlcnRpZmljYXRlIGtleVVzYWdlIG9yIGJhc2ljQ29uc3RyYWludHMgY29uZmxpY3QgJyArXG4gICAgICAgICAgICAgICdvciBpbmRpY2F0ZSB0aGF0IHRoZSBjZXJ0aWZpY2F0ZSBpcyBub3QgYSBDQS4gJyArXG4gICAgICAgICAgICAgICdJZiB0aGUgY2VydGlmaWNhdGUgaXMgdGhlIG9ubHkgb25lIGluIHRoZSBjaGFpbiBvciAnICtcbiAgICAgICAgICAgICAgJ2lzblxcJ3QgdGhlIGZpcnN0IHRoZW4gdGhlIGNlcnRpZmljYXRlIG11c3QgYmUgYSAnICtcbiAgICAgICAgICAgICAgJ3ZhbGlkIENBLicsXG4gICAgICAgICAgICBlcnJvcjogcGtpLmNlcnRpZmljYXRlRXJyb3IuYmFkX2NlcnRpZmljYXRlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gYmFzaWMgY29uc3RyYWludHMgY0EgZmxhZyBtdXN0IGJlIHNldFxuICAgICAgaWYoZXJyb3IgPT09IG51bGwgJiYgYmNFeHQgIT09IG51bGwgJiYgIWJjRXh0LmNBKSB7XG4gICAgICAgIC8vIGJhZCBjZXJ0aWZpY2F0ZVxuICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgJ0NlcnRpZmljYXRlIGJhc2ljQ29uc3RyYWludHMgaW5kaWNhdGVzIHRoZSBjZXJ0aWZpY2F0ZSAnICtcbiAgICAgICAgICAgICdpcyBub3QgYSBDQS4nLFxuICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIGVycm9yIGlzIG5vdCBudWxsIGFuZCBrZXlVc2FnZSBpcyBhdmFpbGFibGUsIHRoZW4gd2Uga25vdyBpdFxuICAgICAgLy8gaGFzIGtleUNlcnRTaWduIGFuZCB0aGVyZSBpcyBhIGJhc2ljIGNvbnN0cmFpbnRzIGV4dGVuc2lvbiB0b28sXG4gICAgICAvLyB3aGljaCBtZWFucyB3ZSBjYW4gY2hlY2sgcGF0aExlbkNvbnN0cmFpbnQgKGlmIGl0IGV4aXN0cylcbiAgICAgIGlmKGVycm9yID09PSBudWxsICYmIGtleVVzYWdlRXh0ICE9PSBudWxsICYmXG4gICAgICAgICdwYXRoTGVuQ29uc3RyYWludCcgaW4gYmNFeHQpIHtcbiAgICAgICAgLy8gcGF0aExlbiBpcyB0aGUgbWF4aW11bSAjIG9mIGludGVybWVkaWF0ZSBDQSBjZXJ0cyB0aGF0IGNhbiBiZVxuICAgICAgICAvLyBmb3VuZCBiZXR3ZWVuIHRoZSBjdXJyZW50IGNlcnRpZmljYXRlIGFuZCB0aGUgZW5kLWVudGl0eSAoZGVwdGggMClcbiAgICAgICAgLy8gY2VydGlmaWNhdGU7IHRoaXMgbnVtYmVyIGRvZXMgbm90IGluY2x1ZGUgdGhlIGVuZC1lbnRpdHkgKGRlcHRoIDAsXG4gICAgICAgIC8vIGxhc3QgaW4gdGhlIGNoYWluKSBldmVuIGlmIGl0IGhhcHBlbnMgdG8gYmUgYSBDQSBjZXJ0aWZpY2F0ZSBpdHNlbGZcbiAgICAgICAgdmFyIHBhdGhMZW4gPSBkZXB0aCAtIDE7XG4gICAgICAgIGlmKHBhdGhMZW4gPiBiY0V4dC5wYXRoTGVuQ29uc3RyYWludCkge1xuICAgICAgICAgIC8vIHBhdGhMZW5Db25zdHJhaW50IHZpb2xhdGVkLCBiYWQgY2VydGlmaWNhdGVcbiAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAgICdDZXJ0aWZpY2F0ZSBiYXNpY0NvbnN0cmFpbnRzIHBhdGhMZW5Db25zdHJhaW50IHZpb2xhdGVkLicsXG4gICAgICAgICAgICBlcnJvcjogcGtpLmNlcnRpZmljYXRlRXJyb3IuYmFkX2NlcnRpZmljYXRlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNhbGwgYXBwbGljYXRpb24gY2FsbGJhY2tcbiAgICB2YXIgdmZkID0gKGVycm9yID09PSBudWxsKSA/IHRydWUgOiBlcnJvci5lcnJvcjtcbiAgICB2YXIgcmV0ID0gb3B0aW9ucy52ZXJpZnkgPyBvcHRpb25zLnZlcmlmeSh2ZmQsIGRlcHRoLCBjZXJ0cykgOiB2ZmQ7XG4gICAgaWYocmV0ID09PSB0cnVlKSB7XG4gICAgICAvLyBjbGVhciBhbnkgc2V0IGVycm9yXG4gICAgICBlcnJvciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIHBhc3NlZCBiYXNpYyB0ZXN0cywgc2V0IGRlZmF1bHQgbWVzc2FnZSBhbmQgYWxlcnRcbiAgICAgIGlmKHZmZCA9PT0gdHJ1ZSkge1xuICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICBtZXNzYWdlOiAnVGhlIGFwcGxpY2F0aW9uIHJlamVjdGVkIHRoZSBjZXJ0aWZpY2F0ZS4nLFxuICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgZm9yIGN1c3RvbSBlcnJvciBpbmZvXG4gICAgICBpZihyZXQgfHwgcmV0ID09PSAwKSB7XG4gICAgICAgIC8vIHNldCBjdXN0b20gbWVzc2FnZSBhbmQgZXJyb3JcbiAgICAgICAgaWYodHlwZW9mIHJldCA9PT0gJ29iamVjdCcgJiYgIWZvcmdlLnV0aWwuaXNBcnJheShyZXQpKSB7XG4gICAgICAgICAgaWYocmV0Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSByZXQubWVzc2FnZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYocmV0LmVycm9yKSB7XG4gICAgICAgICAgICBlcnJvci5lcnJvciA9IHJldC5lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZih0eXBlb2YgcmV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIHNldCBjdXN0b20gZXJyb3JcbiAgICAgICAgICBlcnJvci5lcnJvciA9IHJldDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0aHJvdyBlcnJvclxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gbm8gbG9uZ2VyIGZpcnN0IGNlcnQgaW4gY2hhaW5cbiAgICBmaXJzdCA9IGZhbHNlO1xuICAgICsrZGVwdGg7XG4gIH0gd2hpbGUoY2hhaW4ubGVuZ3RoID4gMCk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLyoqXG4gKiBKYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIEFTTi4xIHZhbGlkYXRvcnMgZm9yIFBLQ1MjNyB2MS41LlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDE1IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqXG4gKiBUaGUgQVNOLjEgcmVwcmVzZW50YXRpb24gb2YgUEtDUyM3IGlzIGFzIGZvbGxvd3NcbiAqIChzZWUgUkZDICMyMzE1IGZvciBkZXRhaWxzLCBodHRwOi8vd3d3LmlldGYub3JnL3JmYy9yZmMyMzE1LnR4dCk6XG4gKlxuICogQSBQS0NTIzcgbWVzc2FnZSBjb25zaXN0cyBvZiBhIENvbnRlbnRJbmZvIG9uIHJvb3QgbGV2ZWwsIHdoaWNoIG1heVxuICogY29udGFpbiBhbnkgbnVtYmVyIG9mIGZ1cnRoZXIgQ29udGVudEluZm8gbmVzdGVkIGludG8gaXQuXG4gKlxuICogQ29udGVudEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgY29udGVudFR5cGUgICAgICAgICAgICAgICAgQ29udGVudFR5cGUsXG4gKiAgIGNvbnRlbnQgICAgICAgICAgICAgICBbMF0gIEVYUExJQ0lUIEFOWSBERUZJTkVEIEJZIGNvbnRlbnRUeXBlIE9QVElPTkFMXG4gKiB9XG4gKlxuICogQ29udGVudFR5cGUgOjo9IE9CSkVDVCBJREVOVElGSUVSXG4gKlxuICogRW52ZWxvcGVkRGF0YSA6Oj0gU0VRVUVOQ0Uge1xuICogICB2ZXJzaW9uICAgICAgICAgICAgICAgICAgICBWZXJzaW9uLFxuICogICByZWNpcGllbnRJbmZvcyAgICAgICAgICAgICBSZWNpcGllbnRJbmZvcyxcbiAqICAgZW5jcnlwdGVkQ29udGVudEluZm8gICAgICAgRW5jcnlwdGVkQ29udGVudEluZm9cbiAqIH1cbiAqXG4gKiBFbmNyeXB0ZWREYXRhIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHZlcnNpb24gICAgICAgICAgICAgICAgICAgIFZlcnNpb24sXG4gKiAgIGVuY3J5cHRlZENvbnRlbnRJbmZvICAgICAgIEVuY3J5cHRlZENvbnRlbnRJbmZvXG4gKiB9XG4gKlxuICogaWQtc2lnbmVkRGF0YSBPQkpFQ1QgSURFTlRJRklFUiA6Oj0geyBpc28oMSkgbWVtYmVyLWJvZHkoMilcbiAqICAgdXMoODQwKSByc2Fkc2koMTEzNTQ5KSBwa2NzKDEpIHBrY3M3KDcpIDIgfVxuICpcbiAqIFNpZ25lZERhdGEgOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgICAgICAgICAgSU5URUdFUixcbiAqICAgZGlnZXN0QWxnb3JpdGhtcyAgRGlnZXN0QWxnb3JpdGhtSWRlbnRpZmllcnMsXG4gKiAgIGNvbnRlbnRJbmZvICAgICAgIENvbnRlbnRJbmZvLFxuICogICBjZXJ0aWZpY2F0ZXMgICAgICBbMF0gSU1QTElDSVQgQ2VydGlmaWNhdGVzIE9QVElPTkFMLFxuICogICBjcmxzICAgICAgICAgICAgICBbMV0gSU1QTElDSVQgQ2VydGlmaWNhdGVSZXZvY2F0aW9uTGlzdHMgT1BUSU9OQUwsXG4gKiAgIHNpZ25lckluZm9zICAgICAgIFNpZ25lckluZm9zXG4gKiB9XG4gKlxuICogU2lnbmVySW5mb3MgOjo9IFNFVCBPRiBTaWduZXJJbmZvXG4gKlxuICogU2lnbmVySW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICB2ZXJzaW9uICAgICAgICAgICAgICAgICAgICBWZXJzaW9uLFxuICogICBpc3N1ZXJBbmRTZXJpYWxOdW1iZXIgICAgICBJc3N1ZXJBbmRTZXJpYWxOdW1iZXIsXG4gKiAgIGRpZ2VzdEFsZ29yaXRobSAgICAgICAgICAgIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIGF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzICAgIFswXSBJTVBMSUNJVCBBdHRyaWJ1dGVzIE9QVElPTkFMLFxuICogICBkaWdlc3RFbmNyeXB0aW9uQWxnb3JpdGhtICBEaWdlc3RFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZW5jcnlwdGVkRGlnZXN0ICAgICAgICAgICAgRW5jcnlwdGVkRGlnZXN0LFxuICogICB1bmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzICBbMV0gSU1QTElDSVQgQXR0cmlidXRlcyBPUFRJT05BTFxuICogfVxuICpcbiAqIEVuY3J5cHRlZERpZ2VzdCA6Oj0gT0NURVQgU1RSSU5HXG4gKlxuICogQXR0cmlidXRlcyA6Oj0gU0VUIE9GIEF0dHJpYnV0ZVxuICpcbiAqIEF0dHJpYnV0ZSA6Oj0gU0VRVUVOQ0Uge1xuICogICBhdHRyVHlwZSAgICBPQkpFQ1QgSURFTlRJRklFUixcbiAqICAgYXR0clZhbHVlcyAgU0VUIE9GIEF0dHJpYnV0ZVZhbHVlXG4gKiB9XG4gKlxuICogQXR0cmlidXRlVmFsdWUgOjo9IEFOWVxuICpcbiAqIFZlcnNpb24gOjo9IElOVEVHRVJcbiAqXG4gKiBSZWNpcGllbnRJbmZvcyA6Oj0gU0VUIE9GIFJlY2lwaWVudEluZm9cbiAqXG4gKiBFbmNyeXB0ZWRDb250ZW50SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICBjb250ZW50VHlwZSAgICAgICAgICAgICAgICAgQ29udGVudFR5cGUsXG4gKiAgIGNvbnRlbnRFbmNyeXB0aW9uQWxnb3JpdGhtICBDb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIGVuY3J5cHRlZENvbnRlbnQgICAgICAgWzBdICBJTVBMSUNJVCBFbmNyeXB0ZWRDb250ZW50IE9QVElPTkFMXG4gKiB9XG4gKlxuICogQ29udGVudEVuY3J5cHRpb25BbGdvcml0aG1JZGVudGlmaWVyIDo6PSBBbGdvcml0aG1JZGVudGlmaWVyXG4gKlxuICogVGhlIEFsZ29yaXRobUlkZW50aWZpZXIgY29udGFpbnMgYW4gT2JqZWN0IElkZW50aWZpZXIgKE9JRCkgYW5kIHBhcmFtZXRlcnNcbiAqIGZvciB0aGUgYWxnb3JpdGhtLCBpZiBhbnkuIEluIHRoZSBjYXNlIG9mIEFFUyBhbmQgREVTMywgdGhlcmUgaXMgb25seSBvbmUsXG4gKiB0aGUgSVYuXG4gKlxuICogQWxnb3JpdGhtSWRlbnRpZmVyIDo6PSBTRVFVRU5DRSB7XG4gKiAgICBhbGdvcml0aG0gT0JKRUNUIElERU5USUZJRVIsXG4gKiAgICBwYXJhbWV0ZXJzIEFOWSBERUZJTkVEIEJZIGFsZ29yaXRobSBPUFRJT05BTFxuICogfVxuICpcbiAqIEVuY3J5cHRlZENvbnRlbnQgOjo9IE9DVEVUIFNUUklOR1xuICpcbiAqIFJlY2lwaWVudEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgICAgICAgICAgICAgICAgICAgIFZlcnNpb24sXG4gKiAgIGlzc3VlckFuZFNlcmlhbE51bWJlciAgICAgICBJc3N1ZXJBbmRTZXJpYWxOdW1iZXIsXG4gKiAgIGtleUVuY3J5cHRpb25BbGdvcml0aG0gICAgICBLZXlFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZW5jcnlwdGVkS2V5ICAgICAgICAgICAgICAgIEVuY3J5cHRlZEtleVxuICogfVxuICpcbiAqIElzc3VlckFuZFNlcmlhbE51bWJlciA6Oj0gU0VRVUVOQ0Uge1xuICogICBpc3N1ZXIgICAgICAgICAgICAgICAgICAgICAgTmFtZSxcbiAqICAgc2VyaWFsTnVtYmVyICAgICAgICAgICAgICAgIENlcnRpZmljYXRlU2VyaWFsTnVtYmVyXG4gKiB9XG4gKlxuICogQ2VydGlmaWNhdGVTZXJpYWxOdW1iZXIgOjo9IElOVEVHRVJcbiAqXG4gKiBLZXlFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllciA6Oj0gQWxnb3JpdGhtSWRlbnRpZmllclxuICpcbiAqIEVuY3J5cHRlZEtleSA6Oj0gT0NURVQgU1RSSU5HXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vYXNuMScpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbi8vIHNob3J0Y3V0IGZvciBBU04uMSBBUElcbnZhciBhc24xID0gZm9yZ2UuYXNuMTtcblxuLy8gc2hvcnRjdXQgZm9yIFBLQ1MjNyBBUElcbnZhciBwN3YgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnBrY3M3YXNuMSA9IGZvcmdlLnBrY3M3YXNuMSB8fCB7fTtcbmZvcmdlLnBrY3M3ID0gZm9yZ2UucGtjczcgfHwge307XG5mb3JnZS5wa2NzNy5hc24xID0gcDd2O1xuXG52YXIgY29udGVudEluZm9WYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdDb250ZW50SW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ0NvbnRlbnRJbmZvLkNvbnRlbnRUeXBlJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ2NvbnRlbnRUeXBlJ1xuICB9LCB7XG4gICAgbmFtZTogJ0NvbnRlbnRJbmZvLmNvbnRlbnQnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBjYXB0dXJlQXNuMTogJ2NvbnRlbnQnXG4gIH1dXG59O1xucDd2LmNvbnRlbnRJbmZvVmFsaWRhdG9yID0gY29udGVudEluZm9WYWxpZGF0b3I7XG5cbnZhciBlbmNyeXB0ZWRDb250ZW50SW5mb1ZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0VuY3J5cHRlZENvbnRlbnRJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnRW5jcnlwdGVkQ29udGVudEluZm8uY29udGVudFR5cGUnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnY29udGVudFR5cGUnXG4gIH0sIHtcbiAgICBuYW1lOiAnRW5jcnlwdGVkQ29udGVudEluZm8uY29udGVudEVuY3J5cHRpb25BbGdvcml0aG0nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnRW5jcnlwdGVkQ29udGVudEluZm8uY29udGVudEVuY3J5cHRpb25BbGdvcml0aG0uYWxnb3JpdGhtJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnZW5jQWxnb3JpdGhtJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdFbmNyeXB0ZWRDb250ZW50SW5mby5jb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobS5wYXJhbWV0ZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgY2FwdHVyZUFzbjE6ICdlbmNQYXJhbWV0ZXInXG4gICAgfV1cbiAgfSwge1xuICAgIG5hbWU6ICdFbmNyeXB0ZWRDb250ZW50SW5mby5lbmNyeXB0ZWRDb250ZW50JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDAsXG4gICAgLyogVGhlIFBLQ1MjNyBzdHJ1Y3R1cmUgb3V0cHV0IGJ5IE9wZW5TU0wgc29tZXdoYXQgZGlmZmVycyBmcm9tIHdoYXRcbiAgICAgKiBvdGhlciBpbXBsZW1lbnRhdGlvbnMgZG8gZ2VuZXJhdGUuXG4gICAgICpcbiAgICAgKiBPcGVuU1NMIGdlbmVyYXRlcyBhIHN0cnVjdHVyZSBsaWtlIHRoaXM6XG4gICAgICogU0VRVUVOQ0Uge1xuICAgICAqICAgIC4uLlxuICAgICAqICAgIFswXVxuICAgICAqICAgICAgIDI2IERBIDY3IEQyIDE3IDlDIDQ1IDNDIEIxIDJBIEE4IDU5IDJGIDI5IDMzIDM4XG4gICAgICogICAgICAgQzMgQzMgREYgODYgNzEgNzQgN0EgMTkgOUYgNDAgRDAgMjkgQkUgODUgOTAgNDVcbiAgICAgKiAgICAgICAuLi5cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBXaGVyZWFzIG90aGVyIGltcGxlbWVudGF0aW9ucyAoYW5kIHRoaXMgUEtDUyM3IG1vZHVsZSkgZ2VuZXJhdGU6XG4gICAgICogU0VRVUVOQ0Uge1xuICAgICAqICAgIC4uLlxuICAgICAqICAgIFswXSB7XG4gICAgICogICAgICAgT0NURVQgU1RSSU5HXG4gICAgICogICAgICAgICAgMjYgREEgNjcgRDIgMTcgOUMgNDUgM0MgQjEgMkEgQTggNTkgMkYgMjkgMzMgMzhcbiAgICAgKiAgICAgICAgICBDMyBDMyBERiA4NiA3MSA3NCA3QSAxOSA5RiA0MCBEMCAyOSBCRSA4NSA5MCA0NVxuICAgICAqICAgICAgICAgIC4uLlxuICAgICAqICAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBJbiBvcmRlciB0byBzdXBwb3J0IGJvdGgsIHdlIGp1c3QgY2FwdHVyZSB0aGUgY29udGV4dCBzcGVjaWZpY1xuICAgICAqIGZpZWxkIGhlcmUuICBUaGUgT0NURVQgU1RSSU5HIGJpdCBpcyByZW1vdmVkIGJlbG93LlxuICAgICAqL1xuICAgIGNhcHR1cmU6ICdlbmNyeXB0ZWRDb250ZW50JyxcbiAgICBjYXB0dXJlQXNuMTogJ2VuY3J5cHRlZENvbnRlbnRBc24xJ1xuICB9XVxufTtcblxucDd2LmVudmVsb3BlZERhdGFWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdFbnZlbG9wZWREYXRhJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnRW52ZWxvcGVkRGF0YS5WZXJzaW9uJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICd2ZXJzaW9uJ1xuICB9LCB7XG4gICAgbmFtZTogJ0VudmVsb3BlZERhdGEuUmVjaXBpZW50SW5mb3MnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VULFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAncmVjaXBpZW50SW5mb3MnXG4gIH1dLmNvbmNhdChlbmNyeXB0ZWRDb250ZW50SW5mb1ZhbGlkYXRvcilcbn07XG5cbnA3di5lbmNyeXB0ZWREYXRhVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnRW5jcnlwdGVkRGF0YScsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ0VuY3J5cHRlZERhdGEuVmVyc2lvbicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAndmVyc2lvbidcbiAgfV0uY29uY2F0KGVuY3J5cHRlZENvbnRlbnRJbmZvVmFsaWRhdG9yKVxufTtcblxudmFyIHNpZ25lclZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ1NpZ25lckluZm8nLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdTaWduZXJJbmZvLnZlcnNpb24nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2VcbiAgfSwge1xuICAgIG5hbWU6ICdTaWduZXJJbmZvLmlzc3VlckFuZFNlcmlhbE51bWJlcicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdTaWduZXJJbmZvLmlzc3VlckFuZFNlcmlhbE51bWJlci5pc3N1ZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBjYXB0dXJlQXNuMTogJ2lzc3VlcidcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnU2lnbmVySW5mby5pc3N1ZXJBbmRTZXJpYWxOdW1iZXIuc2VyaWFsTnVtYmVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ3NlcmlhbCdcbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lckluZm8uZGlnZXN0QWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ1NpZ25lckluZm8uZGlnZXN0QWxnb3JpdGhtLmFsZ29yaXRobScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ2RpZ2VzdEFsZ29yaXRobSdcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnU2lnbmVySW5mby5kaWdlc3RBbGdvcml0aG0ucGFyYW1ldGVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnZGlnZXN0UGFyYW1ldGVyJyxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfV1cbiAgfSwge1xuICAgIG5hbWU6ICdTaWduZXJJbmZvLmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDAsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgb3B0aW9uYWw6IHRydWUsXG4gICAgY2FwdHVyZTogJ2F1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzJ1xuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lckluZm8uZGlnZXN0RW5jcnlwdGlvbkFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBjYXB0dXJlOiAnc2lnbmF0dXJlQWxnb3JpdGhtJ1xuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lckluZm8uZW5jcnlwdGVkRGlnZXN0JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnc2lnbmF0dXJlJ1xuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lckluZm8udW5hdXRoZW50aWNhdGVkQXR0cmlidXRlcycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICB0eXBlOiAxLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIGNhcHR1cmU6ICd1bmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzJ1xuICB9XVxufTtcblxucDd2LnNpZ25lZERhdGFWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdTaWduZWREYXRhJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnU2lnbmVkRGF0YS5WZXJzaW9uJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICd2ZXJzaW9uJ1xuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lZERhdGEuRGlnZXN0QWxnb3JpdGhtcycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgY2FwdHVyZUFzbjE6ICdkaWdlc3RBbGdvcml0aG1zJ1xuICB9LFxuICBjb250ZW50SW5mb1ZhbGlkYXRvcixcbiAge1xuICAgIG5hbWU6ICdTaWduZWREYXRhLkNlcnRpZmljYXRlcycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICB0eXBlOiAwLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAnY2VydGlmaWNhdGVzJ1xuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lZERhdGEuQ2VydGlmaWNhdGVSZXZvY2F0aW9uTGlzdHMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMSxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBjYXB0dXJlQXNuMTogJ2NybHMnXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVkRGF0YS5TaWduZXJJbmZvcycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgY2FwdHVyZTogJ3NpZ25lckluZm9zJyxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICB2YWx1ZTogW3NpZ25lclZhbGlkYXRvcl1cbiAgfV1cbn07XG5cbnA3di5yZWNpcGllbnRJbmZvVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnUmVjaXBpZW50SW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ1JlY2lwaWVudEluZm8udmVyc2lvbicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAndmVyc2lvbidcbiAgfSwge1xuICAgIG5hbWU6ICdSZWNpcGllbnRJbmZvLmlzc3VlckFuZFNlcmlhbCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdSZWNpcGllbnRJbmZvLmlzc3VlckFuZFNlcmlhbC5pc3N1ZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBjYXB0dXJlQXNuMTogJ2lzc3VlcidcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnUmVjaXBpZW50SW5mby5pc3N1ZXJBbmRTZXJpYWwuc2VyaWFsTnVtYmVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ3NlcmlhbCdcbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ1JlY2lwaWVudEluZm8ua2V5RW5jcnlwdGlvbkFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdSZWNpcGllbnRJbmZvLmtleUVuY3J5cHRpb25BbGdvcml0aG0uYWxnb3JpdGhtJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnZW5jQWxnb3JpdGhtJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdSZWNpcGllbnRJbmZvLmtleUVuY3J5cHRpb25BbGdvcml0aG0ucGFyYW1ldGVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnZW5jUGFyYW1ldGVyJyxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfV1cbiAgfSwge1xuICAgIG5hbWU6ICdSZWNpcGllbnRJbmZvLmVuY3J5cHRlZEtleScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ2VuY0tleSdcbiAgfV1cbn07XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3Qgc2hhMyA9IHJlcXVpcmUoJ2pzLXNoYTMnKVxuY29uc3QgbXVybXVyMyA9IHJlcXVpcmUoJ211cm11cmhhc2gzanMnKVxuXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3Qgc2hhID0gcmVxdWlyZSgnLi9jcnlwdG8tc2hhMS0yJylcblxuY29uc3QgdG9DYWxsYmFjayA9IHV0aWxzLnRvQ2FsbGJhY2tcbmNvbnN0IHRvQnVmID0gdXRpbHMudG9CdWZcbmNvbnN0IGZyb21TdHJpbmcgPSB1dGlscy5mcm9tU3RyaW5nXG5jb25zdCBmcm9tTnVtYmVyVG8zMkJpdEJ1ZiA9IHV0aWxzLmZyb21OdW1iZXJUbzMyQml0QnVmXG5cbmNvbnN0IGRibFNoYTIyNTYgPSAoYnVmLCBjYikgPT4ge1xuICBzaGEuc2hhMjI1NihidWYsIChlcnIsIGZpcnN0SGFzaCkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNiKGVycilcbiAgICB9XG4gICAgc2hhLnNoYTIyNTYoKEJ1ZmZlci5mcm9tKGZpcnN0SGFzaCkpLCBjYilcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNoYTE6IHNoYS5zaGExLFxuICBzaGEyMjU2OiBzaGEuc2hhMjI1NixcbiAgc2hhMjUxMjogc2hhLnNoYTI1MTIsXG4gIHNoYTM1MTI6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5zaGEzXzUxMikpLFxuICBzaGEzMzg0OiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMuc2hhM18zODQpKSxcbiAgc2hhMzI1NjogdG9DYWxsYmFjayh0b0J1ZihzaGEzLnNoYTNfMjU2KSksXG4gIHNoYTMyMjQ6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5zaGEzXzIyNCkpLFxuICBzaGFrZTEyODogdG9DYWxsYmFjayh0b0J1ZihzaGEzLnNoYWtlXzEyOCwgMTI4KSksXG4gIHNoYWtlMjU2OiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMuc2hha2VfMjU2LCAyNTYpKSxcbiAga2VjY2FrMjI0OiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMua2VjY2FrXzIyNCkpLFxuICBrZWNjYWsyNTY6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5rZWNjYWtfMjU2KSksXG4gIGtlY2NhazM4NDogdG9DYWxsYmFjayh0b0J1ZihzaGEzLmtlY2Nha18zODQpKSxcbiAga2VjY2FrNTEyOiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMua2VjY2FrXzUxMikpLFxuICBtdXJtdXIzMTI4OiB0b0NhbGxiYWNrKHRvQnVmKGZyb21TdHJpbmcobXVybXVyMy54NjQuaGFzaDEyOCkpKSxcbiAgbXVybXVyMzMyOiB0b0NhbGxiYWNrKGZyb21OdW1iZXJUbzMyQml0QnVmKGZyb21TdHJpbmcobXVybXVyMy54ODYuaGFzaDMyKSkpLFxuICBhZGRCbGFrZTogcmVxdWlyZSgnLi9ibGFrZScpLFxuICBkYmxTaGEyMjU2OiBkYmxTaGEyMjU2XG59XG4iLCIndXNlIHN0cmljdCdcbnZhciBTdGF0ZSA9IHJlcXVpcmUoJy4vc3RhdGUnKVxuXG5mdW5jdGlvbiBpc0ludGVnZXIgKGkpIHtcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShpKVxufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uIChmKSB7XG4gIHJldHVybiAnZnVuY3Rpb24nID09PSB0eXBlb2YgZlxufVxuXG5mdW5jdGlvbiBtYXhEZWxheShmbiwgZGVsYXkpIHtcbiAgaWYoIWRlbGF5KSByZXR1cm4gZm5cbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBjYikge1xuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZm4obmV3IEVycm9yKCdwdWxsLXJlYWRlcjogcmVhZCBleGNlZWRlZCB0aW1lb3V0JyksIGNiKVxuICAgIH0sIGRlbGF5KVxuICAgIGZuKGEsIGZ1bmN0aW9uIChlcnIsIHZhbHVlKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpXG4gICAgICBjYihlcnIsIHZhbHVlKVxuICAgIH0pXG5cbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcblxuICB2YXIgcXVldWUgPSBbXSwgcmVhZCwgcmVhZFRpbWVkLCByZWFkaW5nID0gZmFsc2VcbiAgdmFyIHN0YXRlID0gU3RhdGUoKSwgZW5kZWQsIHN0cmVhbWluZywgYWJvcnRcblxuICBmdW5jdGlvbiBkcmFpbiAoKSB7XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgaWYobnVsbCA9PSBxdWV1ZVswXS5sZW5ndGggJiYgc3RhdGUuaGFzKDEpKSB7XG4gICAgICAgIHF1ZXVlLnNoaWZ0KCkuY2IobnVsbCwgc3RhdGUuZ2V0KCkpXG4gICAgICB9XG4gICAgICBlbHNlIGlmKHN0YXRlLmhhcyhxdWV1ZVswXS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBuZXh0ID0gcXVldWUuc2hpZnQoKVxuICAgICAgICBuZXh0LmNiKG51bGwsIHN0YXRlLmdldChuZXh0Lmxlbmd0aCkpXG4gICAgICB9XG4gICAgICBlbHNlIGlmKGVuZGVkID09IHRydWUgJiYgcXVldWVbMF0ubGVuZ3RoICYmIHN0YXRlLmxlbmd0aCA8IHF1ZXVlWzBdLmxlbmd0aCkge1xuICAgICAgICB2YXIgbXNnID0gJ3N0cmVhbSBlbmRlZCB3aXRoOicrc3RhdGUubGVuZ3RoKycgYnV0IHdhbnRlZDonK3F1ZXVlWzBdLmxlbmd0aFxuICAgICAgICBxdWV1ZS5zaGlmdCgpLmNiKG5ldyBFcnJvcihtc2cpKVxuICAgICAgfVxuICAgICAgZWxzZSBpZihlbmRlZClcbiAgICAgICAgcXVldWUuc2hpZnQoKS5jYihlbmRlZClcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuICEhcXVldWUubGVuZ3RoXG4gICAgfVxuICAgIC8vYWx3YXlzIHJlYWQgYSBsaXR0bGUgZGF0YVxuICAgIHJldHVybiBxdWV1ZS5sZW5ndGggfHwgIXN0YXRlLmhhcygxKSB8fCBhYm9ydFxuICB9XG5cbiAgZnVuY3Rpb24gbW9yZSAoKSB7XG4gICAgdmFyIGQgPSBkcmFpbigpXG4gICAgaWYoZCAmJiAhcmVhZGluZylcbiAgICBpZihyZWFkICYmICFyZWFkaW5nICYmICFzdHJlYW1pbmcpIHtcbiAgICAgIHJlYWRpbmcgPSB0cnVlXG4gICAgICByZWFkVGltZWQgKG51bGwsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgICAgcmVhZGluZyA9IGZhbHNlXG4gICAgICAgIGlmKGVycikge1xuICAgICAgICAgIGVuZGVkID0gZXJyXG4gICAgICAgICAgcmV0dXJuIGRyYWluKClcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5hZGQoZGF0YSlcbiAgICAgICAgbW9yZSgpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRlciAoX3JlYWQpIHtcbiAgICBpZihhYm9ydCkge1xuICAgICAgd2hpbGUocXVldWUubGVuZ3RoKSBxdWV1ZS5zaGlmdCgpLmNiKGFib3J0KVxuICAgICAgcmV0dXJuIGNiICYmIGNiKGFib3J0KVxuICAgIH1cbiAgICByZWFkVGltZWQgPSBtYXhEZWxheShfcmVhZCwgdGltZW91dClcbiAgICByZWFkID0gX3JlYWRcbiAgICBtb3JlKClcbiAgfVxuXG4gIHJlYWRlci5hYm9ydCA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gICAgYWJvcnQgPSBlcnIgfHwgdHJ1ZVxuICAgIGlmKHJlYWQpIHtcbiAgICAgIHJlYWRpbmcgPSB0cnVlXG4gICAgICByZWFkKGFib3J0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlKHF1ZXVlLmxlbmd0aCkgcXVldWUuc2hpZnQoKS5jYihhYm9ydClcbiAgICAgICAgY2IgJiYgY2IoYWJvcnQpXG4gICAgICB9KVxuICAgIH1cbiAgICBlbHNlXG4gICAgICBjYigpXG4gIH1cblxuICByZWFkZXIucmVhZCA9IGZ1bmN0aW9uIChsZW4sIF90aW1lb3V0LCBjYikge1xuICAgIGlmKGlzRnVuY3Rpb24oX3RpbWVvdXQpKVxuICAgICAgY2IgPSBfdGltZW91dCwgX3RpbWVvdXQgPSB0aW1lb3V0XG4gICAgaWYoaXNGdW5jdGlvbihjYikpIHtcbiAgICAgIHF1ZXVlLnB1c2goe2xlbmd0aDogaXNJbnRlZ2VyKGxlbikgPyBsZW4gOiBudWxsLCBjYjogY2J9KVxuICAgICAgbW9yZSgpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy9zd2l0Y2ggaW50byBzdHJlYW1pbmcgbW9kZSBmb3IgdGhlIHJlc3Qgb2YgdGhlIHN0cmVhbS5cbiAgICAgIHN0cmVhbWluZyA9IHRydWVcbiAgICAgIC8vd2FpdCBmb3IgdGhlIGN1cnJlbnQgcmVhZCB0byBjb21wbGV0ZVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhYm9ydCwgY2IpIHtcbiAgICAgICAgLy9pZiB0aGVyZSBpcyBhbnl0aGluZyBzdGlsbCBpbiB0aGUgcXVldWUsXG4gICAgICAgIGlmKHJlYWRpbmcgfHwgc3RhdGUuaGFzKDEpKSB7XG4gICAgICAgICAgaWYoYWJvcnQpIHJldHVybiByZWFkKGFib3J0LCBjYilcbiAgICAgICAgICBxdWV1ZS5wdXNoKHtsZW5ndGg6IG51bGwsIGNiOiBjYn0pXG4gICAgICAgICAgbW9yZSgpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIG1heERlbGF5KHJlYWQsIF90aW1lb3V0KShhYm9ydCwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgY2IoZXJyLCBkYXRhKVxuICAgICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRlclxufVxuXG5cblxuXG5cblxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogQmVzdCByZWNvcmQgc2VsZWN0b3IsIGZvciBwdWJsaWMga2V5IHJlY29yZHMuXG4gKiBTaW1wbHkgcmV0dXJucyB0aGUgZmlyc3QgcmVjb3JkLCBhcyBhbGwgdmFsaWQgcHVibGljIGtleVxuICogcmVjb3JkcyBhcmUgZXF1YWwuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGtcbiAqIEBwYXJhbSB7QXJyYXk8QnVmZmVyPn0gcmVjb3Jkc1xuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuY29uc3QgcHVibGljS2V5U2VsZWN0b3IgPSAoaywgcmVjb3JkcykgPT4ge1xuICByZXR1cm4gMFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHB1YmxpY0tleVNlbGVjdG9yXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1ZmZlckluZGV4T2YoYnVmLHNlYXJjaCxvZmZzZXQpe1xuICBvZmZzZXQgPSBvZmZzZXR8fDBcbiAgXG4gIHZhciBtID0gMDtcbiAgdmFyIHMgPSAtMTtcbiAgZm9yKHZhciBpPW9mZnNldDtpPGJ1Zi5sZW5ndGg7KytpKXtcbiAgICBpZihidWZbaV0gPT0gc2VhcmNoW21dKSB7XG4gICAgICBpZihzID09IC0xKSBzID0gaTtcbiAgICAgICsrbTtcbiAgICAgIGlmKG0gPT0gc2VhcmNoLmxlbmd0aCkgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgPSAtMTtcbiAgICAgIG0gPSAwO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzID4gLTEgJiYgYnVmLmxlbmd0aCAtIHMgPCBzZWFyY2gubGVuZ3RoKSByZXR1cm4gLTE7XG4gIHJldHVybiBzO1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHNldEltbWVkaWF0ZSA9IHJlcXVpcmUoJ2FzeW5jL3NldEltbWVkaWF0ZScpXG5jb25zdCBtdWx0aWhhc2hpbmcgPSByZXF1aXJlKCdtdWx0aWhhc2hpbmctYXN5bmMnKVxuXG4vKipcbiAqIFZhbGlkYXRvciBmb3IgcHVibGljayBrZXkgcmVjb3Jkcy5cbiAqIFZlcmlmaWVzIHRoYXQgdGhlIHBhc3NlZCBpbiByZWNvcmQgdmFsdWUgaXMgdGhlIFB1YmxpY0tleVxuICogdGhhdCBtYXRjaGVzIHRoZSBwYXNzZWQgaW4ga2V5LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBrZXkgLSBBIHZhbGlkIGtleSBpcyBvZiB0aGUgZm9ybSBgJy9way88a2V5bXVsdGloYXNoPidgXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5IC0gVGhlIHB1YmxpYyBrZXkgdG8gdmFsaWRhdGUgYWdhaW5zdCAocHJvdG9idWYgZW5jb2RlZCkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmNvbnN0IHZhbGlkYXRlUHVibGljS2V5UmVjb3JkID0gKGtleSwgcHVibGljS2V5LCBjYWxsYmFjaykgPT4ge1xuICBjb25zdCBkb25lID0gKGVycikgPT4gc2V0SW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKGVycikpXG5cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoa2V5KSkge1xuICAgIHJldHVybiBkb25lKG5ldyBFcnJvcignXCJrZXlcIiBtdXN0IGJlIGEgQnVmZmVyJykpXG4gIH1cblxuICBpZiAoa2V5Lmxlbmd0aCA8IDMpIHtcbiAgICByZXR1cm4gZG9uZShuZXcgRXJyb3IoJ2ludmFsaWQgcHVibGljIGtleSByZWNvcmQnKSlcbiAgfVxuXG4gIGNvbnN0IHByZWZpeCA9IGtleS5zbGljZSgwLCA0KS50b1N0cmluZygpXG5cbiAgaWYgKHByZWZpeCAhPT0gJy9way8nKSB7XG4gICAgcmV0dXJuIGRvbmUobmV3IEVycm9yKCdrZXkgd2FzIG5vdCBwcmVmaXhlZCB3aXRoIC9way8nKSlcbiAgfVxuXG4gIGNvbnN0IGtleWhhc2ggPSBrZXkuc2xpY2UoNClcblxuICBtdWx0aWhhc2hpbmcocHVibGljS2V5LCAnc2hhMi0yNTYnLCAoZXJyLCBwdWJsaWNLZXlIYXNoKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGRvbmUoZXJyKVxuICAgIH1cblxuICAgIGlmICgha2V5aGFzaC5lcXVhbHMocHVibGljS2V5SGFzaCkpIHtcbiAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcigncHVibGljIGtleSBkb2VzIG5vdCBtYXRjaCBwYXNzZWQgaW4ga2V5JykpXG4gICAgfVxuXG4gICAgZG9uZSgpXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBmdW5jOiB2YWxpZGF0ZVB1YmxpY0tleVJlY29yZCxcbiAgc2lnbjogZmFsc2Vcbn1cbiIsInZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2R1cGxleCcpXG5cbmV4cG9ydHMuc291cmNlID0gcmVxdWlyZSgnLi9zb3VyY2UnKTtcbmV4cG9ydHMuc2luayA9IHJlcXVpcmUoJy4vc2luaycpO1xuZXhwb3J0cy5jcmVhdGVTZXJ2ZXIgPSByZXF1aXJlKCcuL3NlcnZlcicpXG5leHBvcnRzLmNvbm5lY3QgPSByZXF1aXJlKCcuL2NsaWVudCcpXG4iLCJcbi8vbm9ybWFsaXplIGEgd3MgdXJsLlxudmFyIFVSTCA9IHJlcXVpcmUoJ3VybCcpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1cmwsIGxvY2F0aW9uLCBwcm90b2NvbE1hcCwgZGVmYXVsdFByb3RvY29sKSB7XG4gIHByb3RvY29sTWFwID0gcHJvdG9jb2xNYXAgfHx7fVxuICAvKlxuXG4gIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC12Ni54L2RvY3MvYXBpL3VybC5odG1sI3VybF91cmxfcGFyc2VfdXJsc3RyX3BhcnNlcXVlcnlzdHJpbmdfc2xhc2hlc2Rlbm90ZWhvc3RcblxuICBJIGRpZG4ndCBrbm93IHRoaXMsIGJ1dCB1cmwucGFyc2UgdGFrZXMgYSAzcmRcbiAgYXJndW1lbnQgd2hpY2ggaW50ZXJwcmV0cyBcIi8vZm9vLmNvbVwiIGFzIHRoZSBob3N0bmFtZSxcbiAgYnV0IHdpdGhvdXQgdGhlIHByb3RvY29sLiBieSBkZWZhdWx0LCAvLyBpcyBpbnRlcnByZXRlZFxuICBhcyB0aGUgcGF0aC5cblxuICB0aGF0IGxldHMgdXMgZG8gd2hhdCB0aGUgd3N1cmwgbW9kdWxlIGRvZXMuXG4gIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3dzdXJsXG5cbiAgYnV0IG1vc3Qgb2YgdGhlIHRpbWUsIEkgd2FudCB0byB3cml0ZSBqc1xuICB0aGF0IHdpbGwgd29yayBvbiBsb2NhbGhvc3QsIGFuZCB3aWxsIHdvcmtcbiAgb24gYSBzZXJ2ZXIuLi5cblxuICBzbyBJIHdhbnQgdG8ganVzdCBkbyBjcmVhdGVXZWJTb2NrZXQoJy8nKVxuICBhbmQgZ2V0IFwid3M6Ly9teWRvbWFpbi5jb20vXCJcblxuICAqL1xuXG4gIHZhciB1cmwgPSBVUkwucGFyc2UodXJsLCBmYWxzZSwgdHJ1ZSlcblxuICB2YXIgcHJvdG9cbiAgaWYodXJsLnByb3RvY29sKSBwcm90byA9IHVybC5wcm90b2NvbFxuICBlbHNlIHtcbiAgICBwcm90byA9IGxvY2F0aW9uLnByb3RvY29sID8gbG9jYXRpb24ucHJvdG9jb2wucmVwbGFjZSgvOiQvLCcnKSA6ICdodHRwJ1xuICAgIHByb3RvID0gKChwcm90b2NvbE1hcClbcHJvdG9dIHx8IGRlZmF1bHRQcm90b2NvbCB8fCBwcm90bykgKyAnOidcbiAgfVxuXG4gIC8vaGFuZGxlIHF1aXJrIGluIHVybCBwYWNrYWdlXG4gIGlmKHVybC5ob3N0ICYmIHVybC5ob3N0WzBdID09PSAnOicpXG4gICAgdXJsLmhvc3QgPSBudWxsXG5cbiAgLy91c2VmdWwgZm9yIHdlYnNvY2tldHNcbiAgaWYodXJsLmhvc3RuYW1lKSB7XG4gICAgcmV0dXJuIFVSTC5mb3JtYXQoe1xuICAgICAgcHJvdG9jb2w6IHByb3RvLFxuICAgICAgc2xhc2hlczogdHJ1ZSxcbiAgICAgIGhvc3RuYW1lOiB1cmwuaG9zdG5hbWUsXG4gICAgICBwb3J0OiB1cmwucG9ydCxcbiAgICAgIHBhdGhuYW1lOiB1cmwucGF0aG5hbWUsXG4gICAgICBzZWFyY2g6IHVybC5zZWFyY2hcbiAgICB9KVxuICB9XG4gIGVsc2UgdXJsLmhvc3QgPSBsb2NhdGlvbi5ob3N0XG5cbiAgLy9pbmNsdWRlZCBmb3IgY29tcGxldGVuZXNzLiB3b3VsZCB5b3Ugd2FudCB0byBkbyB0aGlzP1xuICBpZih1cmwucG9ydCkge1xuICAgIHJldHVybiBVUkwuZm9ybWF0KHtcbiAgICAgIHByb3RvY29sOiBwcm90byxcbiAgICAgIHNsYXNoZXM6IHRydWUsXG4gICAgICBob3N0OiBsb2NhdGlvbi5ob3N0bmFtZSArICc6JyArIHVybC5wb3J0LFxuICAgICAgcG9ydDogdXJsLnBvcnQsXG4gICAgICBwYXRobmFtZTogdXJsLnBhdGhuYW1lLFxuICAgICAgc2VhcmNoOiB1cmwuc2VhcmNoXG4gICAgfSlcbiAgfVxuXG4gIC8vZGVmaW5hdGVseSB1c2VmdWwgZm9yIHdlYnNvY2tldHNcbiAgaWYodXJsLnBhdGhuYW1lKSB7XG4gICAgcmV0dXJuIFVSTC5mb3JtYXQoe1xuICAgICAgcHJvdG9jb2w6IHByb3RvLFxuICAgICAgc2xhc2hlczogdHJ1ZSxcbiAgICAgIGhvc3Q6IHVybC5ob3N0LFxuICAgICAgcGF0aG5hbWU6IHVybC5wYXRobmFtZSxcbiAgICAgIHNlYXJjaDogdXJsLnNlYXJjaFxuICAgIH0pXG4gIH1cbiAgZWxzZVxuICAgIHVybC5wYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lXG5cbiAgLy9pbmNsdWRlZCBmb3IgY29tcGxldGVuZXNzLiB3b3VsZCB5b3Ugd2FudCB0byBkbyB0aGlzP1xuICBpZih1cmwuc2VhcmNoKSB7XG4gICAgcmV0dXJuIFVSTC5mb3JtYXQoe1xuICAgICAgcHJvdG9jb2w6IHByb3RvLFxuICAgICAgc2xhc2hlczogdHJ1ZSxcbiAgICAgIGhvc3Q6IHVybC5ob3N0LFxuICAgICAgcGF0aG5hbWU6IHVybC5wYXRobmFtZSxcbiAgICAgIHNlYXJjaDogdXJsLnNlYXJjaFxuICAgIH0pXG4gIH1cbiAgZWxzZSB1cmwuc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoXG5cbiAgcmV0dXJuIHVybC5mb3JtYXQodXJsKVxufVxuXG5cblxuXG5cbiIsInZhciByZWFkeSA9IHJlcXVpcmUoJy4vcmVhZHknKTtcblxuLyoqXG4gICMjIyBgc2luayhzb2NrZXQsIG9wdHM/KWBcblxuICBDcmVhdGUgYSBwdWxsLXN0cmVhbSBgU2lua2AgdGhhdCB3aWxsIHdyaXRlIGRhdGEgdG8gdGhlIGBzb2NrZXRgLlxuXG4gIDw8PCBleGFtcGxlcy93cml0ZS5qc1xuXG4qKi9cblxudmFyIG5leHRUaWNrID0gdHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgPyBzZXRJbW1lZGlhdGUgOiBwcm9jZXNzLm5leHRUaWNrXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc29ja2V0LCBvcHRzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocmVhZCkge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9XG4gICAgdmFyIGNsb3NlT25FbmQgPSBvcHRzLmNsb3NlT25FbmQgIT09IGZhbHNlO1xuICAgIHZhciBvbkNsb3NlID0gJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIG9wdHMgPyBvcHRzIDogb3B0cy5vbkNsb3NlO1xuXG4gICAgZnVuY3Rpb24gbmV4dChlbmQsIGRhdGEpIHtcbiAgICAgIC8vIGlmIHRoZSBzdHJlYW0gaGFzIGVuZGVkLCBzaW1wbHkgcmV0dXJuXG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIGlmIChjbG9zZU9uRW5kICYmIHNvY2tldC5yZWFkeVN0YXRlIDw9IDEpIHtcbiAgICAgICAgICBpZihvbkNsb3NlKVxuICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgIGlmKGV2Lndhc0NsZWFuIHx8IGV2LmNvZGUgPT09IDEwMDYpIG9uQ2xvc2UoKVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCd3cyBlcnJvcicpXG4gICAgICAgICAgICAgICAgZXJyLmV2ZW50ID0gZXZcbiAgICAgICAgICAgICAgICBvbkNsb3NlKGVycilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBzb2NrZXQuY2xvc2UoKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBzb2NrZXQgcmVhZHk/XG4gICAgICByZWFkeShzb2NrZXQsIGZ1bmN0aW9uKGVuZCkge1xuICAgICAgICBpZiAoZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIHJlYWQoZW5kLCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgICAgIG5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlYWQobnVsbCwgbmV4dCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVhZChudWxsLCBuZXh0KTtcbiAgfVxufVxuIiwiLyoqXG4gICMjIyBgc291cmNlKHNvY2tldClgXG5cbiAgQ3JlYXRlIGEgcHVsbC1zdHJlYW0gYFNvdXJjZWAgdGhhdCB3aWxsIHJlYWQgZGF0YSBmcm9tIHRoZSBgc29ja2V0YC5cblxuICA8PDwgZXhhbXBsZXMvcmVhZC5qc1xuXG4qKi9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcblxuLy8gY29waWVkIGZyb20gZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyXG4vLyBTb21lIEFycmF5QnVmZmVycyBhcmUgbm90IHBhc3NpbmcgdGhlIGluc3RhbmNlb2YgY2hlY2ssIHNvIHdlIG5lZWQgdG8gZG8gYSBiaXQgbW9yZSB3b3JrIDooXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXJyYXlCdWZmZXInICYmXG4gICAgICB0eXBlb2Ygb2JqLmJ5dGVMZW5ndGggPT09ICdudW1iZXInKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNvY2tldCwgY2IpIHtcbiAgdmFyIGJ1ZmZlciA9IFtdO1xuICB2YXIgcmVjZWl2ZXI7XG4gIHZhciBlbmRlZDtcbiAgdmFyIHN0YXJ0ZWQgPSBmYWxzZTtcbiAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbihldnQpIHtcbiAgICB2YXIgZGF0YSA9IGV2dC5kYXRhO1xuICAgIGlmIChpc0FycmF5QnVmZmVyKGRhdGEpKSB7XG4gICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgfVxuXG4gICAgaWYgKHJlY2VpdmVyKSB7XG4gICAgICByZXR1cm4gcmVjZWl2ZXIobnVsbCwgZGF0YSk7XG4gICAgfVxuXG4gICAgYnVmZmVyLnB1c2goZGF0YSk7XG4gIH0pO1xuXG4gIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGZ1bmN0aW9uKGV2dCkge1xuICAgIGlmIChlbmRlZCkgcmV0dXJuXG4gICAgaWYgKHJlY2VpdmVyKSB7XG4gICAgICByZWNlaXZlcihlbmRlZCA9IHRydWUpXG4gICAgfVxuICB9KTtcblxuICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgaWYgKGVuZGVkKSByZXR1cm47XG4gICAgZW5kZWQgPSBldnQ7XG4gICAgaWYoIXN0YXJ0ZWQpIHtcbiAgICAgIHN0YXJ0ZWQgPSB0cnVlXG4gICAgICBjYiAmJiBjYihldnQpXG4gICAgfVxuICAgIGlmIChyZWNlaXZlcikge1xuICAgICAgcmVjZWl2ZXIoZW5kZWQpXG4gICAgfVxuICB9KTtcblxuICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIGZ1bmN0aW9uIChldnQpIHtcbiAgICBpZihzdGFydGVkIHx8IGVuZGVkKSByZXR1cm5cbiAgICBzdGFydGVkID0gdHJ1ZVxuICB9KVxuXG4gIGZ1bmN0aW9uIHJlYWQoYWJvcnQsIGNiKSB7XG4gICAgcmVjZWl2ZXIgPSBudWxsO1xuXG4gICAgLy9pZiBzdHJlYW0gaGFzIGFscmVhZHkgZW5kZWQuXG4gICAgaWYgKGVuZGVkKVxuICAgICAgcmV0dXJuIGNiKGVuZGVkKTtcblxuICAgIC8vIGlmIGVuZGVkLCBhYm9ydFxuICAgIGVsc2UgaWYgKGFib3J0KSB7XG4gICAgICAvL3RoaXMgd2lsbCBjYWxsYmFjayB3aGVuIHNvY2tldCBjbG9zZXNcbiAgICAgIHJlY2VpdmVyID0gY2JcbiAgICAgIHNvY2tldC5jbG9zZSgpXG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIGRhdGEsIGlmIGFueVxuICAgIGVsc2UgaWYoYnVmZmVyLmxlbmd0aCA+IDApXG4gICAgICBjYihudWxsLCBidWZmZXIuc2hpZnQoKSk7XG5cbiAgICAvLyB3YWl0IGZvciBtb3JlIGRhdGEgKG9yIGVuZClcbiAgICBlbHNlXG4gICAgICByZWNlaXZlciA9IGNiO1xuXG4gIH07XG5cbiAgcmV0dXJuIHJlYWQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogQSBsaXN0IG9mIHVuaXF1ZSBwZWVyIGluZm9zLlxuICovXG5jbGFzcyBQZWVyTGlzdCB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLmxpc3QgPSBbXVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBpbmZvLiBSZXR1cm5zIGB0cnVlYCBpZiBpdCB3YXMgYSBuZXcgb25lXG4gICAqXG4gICAqIEBwYXJhbSB7UGVlckluZm99IGluZm9cbiAgICogQHJldHVybnMge2Jvb2x9XG4gICAqL1xuICBwdXNoIChpbmZvKSB7XG4gICAgaWYgKCF0aGlzLmhhcyhpbmZvKSkge1xuICAgICAgdGhpcy5saXN0LnB1c2goaW5mbylcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoaXMgUGVlckluZm8gaXMgYWxyZWFkeSBpbiBoZXJlLlxuICAgKlxuICAgKiBAcGFyYW0ge1BlZXJJbmZvfSBpbmZvXG4gICAqIEByZXR1cm5zIHtib29sfVxuICAgKi9cbiAgaGFzIChpbmZvKSB7XG4gICAgY29uc3QgbWF0Y2ggPSB0aGlzLmxpc3QuZmluZCgoaSkgPT4gaS5pZC5pc0VxdWFsKGluZm8uaWQpKVxuICAgIHJldHVybiBCb29sZWFuKG1hdGNoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGlzdCBhcyBhbiBhcnJheS5cbiAgICpcbiAgICogQHJldHVybnMge0FycmF5PFBlZXJJbmZvPn1cbiAgICovXG4gIHRvQXJyYXkgKCkge1xuICAgIHJldHVybiB0aGlzLmxpc3Quc2xpY2UoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgbGFzdCBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm5zIHtQZWVySW5mb31cbiAgICovXG4gIHBvcCAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGlzdC5wb3AoKVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBsZW5ndGggb2YgdGhlIGxpc3RcbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBsZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLmxpc3QubGVuZ3RoXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQZWVyTGlzdFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHNoYTMgPSByZXF1aXJlKCdqcy1zaGEzJylcbmNvbnN0IG11cm11cjMgPSByZXF1aXJlKCdtdXJtdXJoYXNoM2pzJylcblxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IHNoYSA9IHJlcXVpcmUoJy4vY3J5cHRvLXNoYTEtMicpXG5cbmNvbnN0IHRvQ2FsbGJhY2sgPSB1dGlscy50b0NhbGxiYWNrXG5jb25zdCB0b0J1ZiA9IHV0aWxzLnRvQnVmXG5jb25zdCBmcm9tU3RyaW5nID0gdXRpbHMuZnJvbVN0cmluZ1xuY29uc3QgZnJvbU51bWJlclRvMzJCaXRCdWYgPSB1dGlscy5mcm9tTnVtYmVyVG8zMkJpdEJ1ZlxuXG5jb25zdCBkYmxTaGEyMjU2ID0gKGJ1ZiwgY2IpID0+IHtcbiAgc2hhLnNoYTIyNTYoYnVmLCAoZXJyLCBmaXJzdEhhc2gpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBjYihlcnIpXG4gICAgfVxuICAgIHNoYS5zaGEyMjU2KChCdWZmZXIuZnJvbShmaXJzdEhhc2gpKSwgY2IpXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzaGExOiBzaGEuc2hhMSxcbiAgc2hhMjI1Njogc2hhLnNoYTIyNTYsXG4gIHNoYTI1MTI6IHNoYS5zaGEyNTEyLFxuICBzaGEzNTEyOiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMuc2hhM181MTIpKSxcbiAgc2hhMzM4NDogdG9DYWxsYmFjayh0b0J1ZihzaGEzLnNoYTNfMzg0KSksXG4gIHNoYTMyNTY6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5zaGEzXzI1NikpLFxuICBzaGEzMjI0OiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMuc2hhM18yMjQpKSxcbiAgc2hha2UxMjg6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5zaGFrZV8xMjgsIDEyOCkpLFxuICBzaGFrZTI1NjogdG9DYWxsYmFjayh0b0J1ZihzaGEzLnNoYWtlXzI1NiwgMjU2KSksXG4gIGtlY2NhazIyNDogdG9DYWxsYmFjayh0b0J1ZihzaGEzLmtlY2Nha18yMjQpKSxcbiAga2VjY2FrMjU2OiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMua2VjY2FrXzI1NikpLFxuICBrZWNjYWszODQ6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5rZWNjYWtfMzg0KSksXG4gIGtlY2NhazUxMjogdG9DYWxsYmFjayh0b0J1ZihzaGEzLmtlY2Nha181MTIpKSxcbiAgbXVybXVyMzEyODogdG9DYWxsYmFjayh0b0J1Zihmcm9tU3RyaW5nKG11cm11cjMueDY0Lmhhc2gxMjgpKSksXG4gIG11cm11cjMzMjogdG9DYWxsYmFjayhmcm9tTnVtYmVyVG8zMkJpdEJ1Zihmcm9tU3RyaW5nKG11cm11cjMueDg2Lmhhc2gzMikpKSxcbiAgYWRkQmxha2U6IHJlcXVpcmUoJy4vYmxha2UnKSxcbiAgZGJsU2hhMjI1NjogZGJsU2hhMjI1NlxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHByZWZpeCA9ICd+JztcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFdmVudHMoKSB7fVxuXG4vL1xuLy8gV2UgdHJ5IHRvIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLiBJbiBzb21lIGVuZ2luZXMgY3JlYXRpbmcgYW5cbi8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGNoYXJhY3RlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdFxuLy8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vL1xuaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy9cbiAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cbiAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgLy9cbiAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKSBwcmVmaXggPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XSkgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgZW1pdHRlci5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiBlbWl0dGVyO1xufVxuXG4vKipcbiAqIENsZWFyIGV2ZW50IGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldnQgVGhlIEV2ZW50IG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhckV2ZW50KGVtaXR0ZXIsIGV2dCkge1xuICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHZhciBuYW1lcyA9IFtdXG4gICAgLCBldmVudHNcbiAgICAsIG5hbWU7XG5cbiAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cbiAgZm9yIChuYW1lIGluIChldmVudHMgPSB0aGlzLl9ldmVudHMpKSB7XG4gICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghaGFuZGxlcnMpIHJldHVybiBbXTtcbiAgaWYgKGhhbmRsZXJzLmZuKSByZXR1cm4gW2hhbmRsZXJzLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcbiAgaWYgKGxpc3RlbmVycy5mbikgcmV0dXJuIDE7XG4gIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuICBpZiAoIWZuKSB7XG4gICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAoXG4gICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG4gICAgICAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmXG4gICAgICAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG4gICAgKSB7XG4gICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMgPSBbXSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcbiAgICAgICAgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKSB8fFxuICAgICAgICAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAgIC8vXG4gICAgaWYgKGV2ZW50cy5sZW5ndGgpIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgICBlbHNlIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dDtcblxuICBpZiAoZXZlbnQpIHtcbiAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG4vL1xuLy8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cbi8vXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGRpc3RhbmNlID0gcmVxdWlyZSgneG9yLWRpc3RhbmNlJylcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBtYXAgPSByZXF1aXJlKCdhc3luYy9tYXAnKVxuXG4vKipcbiAqIE1haW50YWlucyBhIGxpc3Qgb2YgcGVlcklkcyBzb3J0ZWQgYnkgZGlzdGFuY2UgZnJvbSBhIERIVCBrZXkuXG4gKi9cbmNsYXNzIFBlZXJEaXN0YW5jZUxpc3Qge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBQZWVyRGlzdGFuY2VMaXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gb3JpZ2luRGh0S2V5IC0gdGhlIERIVCBrZXkgZnJvbSB3aGljaCBkaXN0YW5jZSBpcyBjYWxjdWxhdGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjYXBhY2l0eSAtIHRoZSBtYXhpbXVtIHNpemUgb2YgdGhlIGxpc3RcbiAgICovXG4gIGNvbnN0cnVjdG9yIChvcmlnaW5EaHRLZXksIGNhcGFjaXR5KSB7XG4gICAgdGhpcy5vcmlnaW5EaHRLZXkgPSBvcmlnaW5EaHRLZXlcbiAgICB0aGlzLmNhcGFjaXR5ID0gY2FwYWNpdHlcbiAgICB0aGlzLnBlZXJEaXN0YW5jZXMgPSBbXVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBsZW5ndGggb2YgdGhlIGxpc3RcbiAgICovXG4gIGdldCBsZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLnBlZXJEaXN0YW5jZXMubGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogVGhlIHBlZXJJZHMgaW4gdGhlIGxpc3QsIGluIG9yZGVyIG9mIGRpc3RhbmNlIGZyb20gdGhlIG9yaWdpbiBrZXlcbiAgICovXG4gIGdldCBwZWVycyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucGVlckRpc3RhbmNlcy5tYXAocGQgPT4gcGQucGVlcklkKVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHBlZXJJZCB0byB0aGUgbGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHtQZWVySWR9IHBlZXJJZFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBhZGQgKHBlZXJJZCwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5wZWVyRGlzdGFuY2VzLmZpbmQocGQgPT4gcGQucGVlcklkLmlkLmVxdWFscyhwZWVySWQuaWQpKSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKClcbiAgICB9XG5cbiAgICB1dGlscy5jb252ZXJ0UGVlcklkKHBlZXJJZCwgKGVyciwgZGh0S2V5KSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVsID0ge1xuICAgICAgICBwZWVySWQsXG4gICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSh0aGlzLm9yaWdpbkRodEtleSwgZGh0S2V5KVxuICAgICAgfVxuXG4gICAgICB0aGlzLnBlZXJEaXN0YW5jZXMucHVzaChlbClcbiAgICAgIHRoaXMucGVlckRpc3RhbmNlcy5zb3J0KChhLCBiKSA9PiBkaXN0YW5jZS5jb21wYXJlKGEuZGlzdGFuY2UsIGIuZGlzdGFuY2UpKVxuICAgICAgdGhpcy5wZWVyRGlzdGFuY2VzID0gdGhpcy5wZWVyRGlzdGFuY2VzLnNsaWNlKDAsIHRoaXMuY2FwYWNpdHkpXG5cbiAgICAgIGNhbGxiYWNrKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIGFueSBvZiB0aGUgcGVlcklkcyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIgYXJlIGNsb3NlclxuICAgKiB0byB0aGUgb3JpZ2luIGtleSB0aGFuIHRoZSBmdXJ0aGVzdCBwZWVySWQgaW4gdGhlIFBlZXJEaXN0YW5jZUxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8UGVlcklkPn0gcGVlcklkc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBCb29sZWFuKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBhbnlDbG9zZXIgKHBlZXJJZHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFwZWVySWRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGZhbHNlKVxuICAgIH1cblxuICAgIGlmICghdGhpcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB0cnVlKVxuICAgIH1cblxuICAgIG1hcChwZWVySWRzLCAocGVlcklkLCBjYikgPT4gdXRpbHMuY29udmVydFBlZXJJZChwZWVySWQsIGNiKSwgKGVyciwgZGh0S2V5cykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBmdXJ0aGVzdERpc3RhbmNlID0gdGhpcy5wZWVyRGlzdGFuY2VzW3RoaXMucGVlckRpc3RhbmNlcy5sZW5ndGggLSAxXS5kaXN0YW5jZVxuICAgICAgZm9yIChjb25zdCBkaHRLZXkgb2YgZGh0S2V5cykge1xuICAgICAgICBjb25zdCBrZXlEaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMub3JpZ2luRGh0S2V5LCBkaHRLZXkpXG4gICAgICAgIGlmIChkaXN0YW5jZS5jb21wYXJlKGtleURpc3RhbmNlLCBmdXJ0aGVzdERpc3RhbmNlKSA8IDApIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdHJ1ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGZhbHNlKVxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQZWVyRGlzdGFuY2VMaXN0XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcXVldWUgPSByZXF1aXJlKCdhc3luYy9xdWV1ZScpXG5jb25zdCBwcm9taXNpZnkgPSByZXF1aXJlKCdwcm9taXNpZnktZXM2JylcbmNvbnN0IHByb21pc2VUb0NhbGxiYWNrID0gcmVxdWlyZSgncHJvbWlzZS10by1jYWxsYmFjaycpXG5cbmNsYXNzIFdvcmtlclF1ZXVlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgV29ya2VyUXVldWUuXG4gICAqXG4gICAqIEBwYXJhbSB7REhUfSBkaHRcbiAgICogQHBhcmFtIHtSdW59IHJ1blxuICAgKiBAcGFyYW0ge09iamVjdH0gcGF0aFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsb2dcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkaHQsIHJ1biwgcGF0aCwgbG9nKSB7XG4gICAgdGhpcy5kaHQgPSBkaHRcbiAgICB0aGlzLnJ1biA9IHJ1blxuICAgIHRoaXMucGF0aCA9IHBhdGhcbiAgICB0aGlzLmxvZyA9IGxvZ1xuXG4gICAgdGhpcy5jb25jdXJyZW5jeSA9IHRoaXMuZGh0LmNvbmN1cnJlbmN5XG4gICAgdGhpcy5xdWV1ZSA9IHRoaXMuc2V0dXBRdWV1ZSgpXG4gICAgLy8gYSBjb250YWluZXIgZm9yIHJlc29sdmUvcmVqZWN0IGZ1bmN0aW9ucyB0aGF0IHdpbGwgYmUgcG9wdWxhdGVkXG4gICAgLy8gd2hlbiBleGVjdXRlKCkgaXMgY2FsbGVkXG4gICAgdGhpcy5leGVjdXRpb24gPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSB1bmRlcmx5aW5nIGFzeW5jIHF1ZXVlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgc2V0dXBRdWV1ZSAoKSB7XG4gICAgY29uc3QgcSA9IHF1ZXVlKChwZWVyLCBjYikgPT4ge1xuICAgICAgcHJvbWlzZVRvQ2FsbGJhY2sodGhpcy5wcm9jZXNzTmV4dChwZWVyKSkoY2IpXG4gICAgfSwgdGhpcy5jb25jdXJyZW5jeSlcblxuICAgIC8vIElmIHRoZXJlJ3MgYW4gZXJyb3IsIHN0b3AgdGhlIHdvcmtlclxuICAgIHEuZXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICB0aGlzLmxvZy5lcnJvcigncXVldWUnLCBlcnIpXG4gICAgICB0aGlzLnN0b3AoZXJyKVxuICAgIH1cblxuICAgIC8vIFdoZW4gYWxsIHBlZXJzIGluIHRoZSBxdWV1ZSBoYXZlIGJlZW4gcHJvY2Vzc2VkLCBzdG9wIHRoZSB3b3JrZXJcbiAgICBxLmRyYWluID0gKCkgPT4ge1xuICAgICAgdGhpcy5sb2coJ3F1ZXVlOmRyYWluJylcbiAgICAgIHRoaXMuc3RvcCgpXG4gICAgfVxuXG4gICAgLy8gV2hlbiBhIHNwYWNlIG9wZW5zIHVwIGluIHRoZSBxdWV1ZSwgYWRkIHNvbWUgbW9yZSBwZWVyc1xuICAgIHEudW5zYXR1cmF0ZWQgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5ydW5uaW5nKSB7XG4gICAgICAgIHRoaXMuZmlsbCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcS5idWZmZXIgPSAwXG5cbiAgICByZXR1cm4gcVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgdGhlIHdvcmtlciwgb3B0aW9uYWxseSBwcm92aWRpbmcgYW4gZXJyb3IgdG8gcGFzcyB0byB0aGUgd29ya2VyJ3NcbiAgICogY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICAgKi9cbiAgc3RvcCAoZXJyKSB7XG4gICAgaWYgKCF0aGlzLnJ1bm5pbmcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMucnVubmluZyA9IGZhbHNlXG4gICAgdGhpcy5xdWV1ZS5raWxsKClcbiAgICB0aGlzLmxvZygnd29ya2VyOnN0b3AsICVkIHdvcmtlcnMgc3RpbGwgcnVubmluZycsIHRoaXMucnVuLndvcmtlcnMuZmlsdGVyKHcgPT4gdy5ydW5uaW5nKS5sZW5ndGgpXG4gICAgaWYgKGVycikge1xuICAgICAgdGhpcy5leGVjdXRpb24ucmVqZWN0KGVycilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5leGVjdXRpb24ucmVzb2x2ZSgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGUgcXVldWUgZnJvbSBhc3luYyB0byBrZWVwIGBjb25jdXJyZW5jeWAgYW1vdW50IGl0ZW1zIHJ1bm5pbmdcbiAgICogcGVyIHBhdGguXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBleGVjdXRlICgpIHtcbiAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlXG4gICAgLy8gc3RvcmUgdGhlIHByb21pc2UgcmVzb2x1dGlvbiBmdW5jdGlvbnMgdG8gYmUgcmVzb2x2ZWQgYXQgZW5kIG9mIHF1ZXVlXG4gICAgdGhpcy5leGVjdXRpb24gPSB7fVxuICAgIGNvbnN0IGV4ZWNQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gT2JqZWN0LmFzc2lnbih0aGlzLmV4ZWN1dGlvbiwgeyByZXNvbHZlLCByZWplY3QgfSkpXG4gICAgLy8gc3RhcnQgcXVldWVcbiAgICB0aGlzLmZpbGwoKVxuICAgIC8vIGF3YWl0IGNvbXBsZXRpb25cbiAgICBhd2FpdCBleGVjUHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBwZWVycyB0byB0aGUgd29ya2VyIHF1ZXVlIHVudGlsIHRoZXJlIGFyZSBlbm91Z2ggdG8gc2F0aXNmeSB0aGVcbiAgICogd29ya2VyIHF1ZXVlIGNvbmN1cnJlbmN5LlxuICAgKiBOb3RlIHRoYXQgd2UgZG9uJ3Qgd2FudCB0byB0YWtlIGFueSBtb3JlIHRoYW4gdGhvc2UgcmVxdWlyZWQgdG8gc2F0aXNmeVxuICAgKiBjb25jdXJyZW5jeSBmcm9tIHRoZSBwZWVycy10by1xdWVyeSBxdWV1ZSwgYmVjYXVzZSB3ZSBhbHdheXMgd2FudCB0b1xuICAgKiBxdWVyeSB0aGUgY2xvc2VzdCBwZWVycyB0byB0aGUga2V5IGZpcnN0LCBhbmQgbmV3IHBlZXJzIGFyZSBjb250aW5vdXNseVxuICAgKiBiZWluZyBhZGRlZCB0byB0aGUgcGVlcnMtdG8tcXVlcnkgcXVldWUuXG4gICAqL1xuICBmaWxsICgpIHtcbiAgICAvLyBOb3RlOlxuICAgIC8vIC0gcXVldWUucnVubmluZygpOiBudW1iZXIgb2YgaXRlbXMgdGhhdCBhcmUgY3VycmVudGx5IHJ1bm5pbmdcbiAgICAvLyAtIHF1ZXVlLmxlbmd0aCgpOiB0aGUgbnVtYmVyIG9mIGl0ZW1zIHRoYXQgYXJlIHdhaXRpbmcgdG8gYmUgcnVuXG4gICAgd2hpbGUgKHRoaXMucXVldWUucnVubmluZygpICsgdGhpcy5xdWV1ZS5sZW5ndGgoKSA8IHRoaXMuY29uY3VycmVuY3kgJiZcbiAgICAgICAgICAgdGhpcy5wYXRoLnBlZXJzVG9RdWVyeS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnF1ZXVlLnB1c2godGhpcy5wYXRoLnBlZXJzVG9RdWVyeS5kZXF1ZXVlKCkpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgdGhlIG5leHQgcGVlciBpbiB0aGUgcXVldWVcbiAgICpcbiAgICogQHBhcmFtIHtQZWVySWR9IHBlZXJcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBwcm9jZXNzTmV4dCAocGVlcikge1xuICAgIGlmICghdGhpcy5ydW5uaW5nKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBUaGUgcGF0aHMgbXVzdCBiZSBkaXNqb2ludCwgbWVhbmluZyB0aGF0IG5vIHR3byBwYXRocyBpbiB0aGUgUXVlcnkgbWF5XG4gICAgLy8gdHJhdmVyc2UgdGhlIHNhbWUgcGVlclxuICAgIGlmICh0aGlzLnJ1bi5wZWVyc1NlZW4uaGFzKHBlZXIpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB3ZSd2ZSBxdWVyaWVkIGVub3VnaCBwZWVycyBhbHJlYWR5XG4gICAgbGV0IGNvbnRpbnVlUXVlcnlpbmcsIGNvbnRpbnVlUXVlcnlpbmdFcnJvclxuICAgIHRyeSB7XG4gICAgICBjb250aW51ZVF1ZXJ5aW5nID0gYXdhaXQgdGhpcy5ydW4uY29udGludWVRdWVyeWluZyh0aGlzKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29udGludWVRdWVyeWluZ0Vycm9yID0gZXJyXG4gICAgfVxuXG4gICAgLy8gQWJvcnQgYW5kIGlnbm9yZSBhbnkgZXJyb3IgaWYgd2UncmUgbm8gbG9uZ2VyIHJ1bm5pbmdcbiAgICBpZiAoIXRoaXMucnVubmluZykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGNvbnRpbnVlUXVlcnlpbmdFcnJvcikge1xuICAgICAgdGhyb3cgY29udGludWVRdWVyeWluZ0Vycm9yXG4gICAgfVxuXG4gICAgLy8gTm8gcGVlciB3ZSdyZSBxdWVyeWluZyBpcyBjbG9zZXIsIHN0b3AgdGhlIHF1ZXVlXG4gICAgLy8gVGhpcyB3aWxsIGNhdXNlIHF1ZXJpZXMgdGhhdCBtYXkgcG90ZW50aWFsbHkgcmVzdWx0IGluXG4gICAgLy8gY2xvc2VyIG5vZGVzIHRvIGJlIGVuZGVkLCBidXQgaXQgcmVkdWNlcyBvdmVyYWxsIHF1ZXJ5IHRpbWVcbiAgICBpZiAoIWNvbnRpbnVlUXVlcnlpbmcpIHtcbiAgICAgIHRoaXMuc3RvcCgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBhbm90aGVyIHBhdGggaGFzIHF1ZXJpZWQgdGhpcyBwZWVyIGluIHRoZSBtZWFuIHRpbWVcbiAgICBpZiAodGhpcy5ydW4ucGVlcnNTZWVuLmhhcyhwZWVyKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMucnVuLnBlZXJzU2Vlbi5hZGQocGVlcilcblxuICAgIC8vIEV4ZWN1dGUgdGhlIHF1ZXJ5IG9uIHRoZSBuZXh0IHBlZXJcbiAgICB0aGlzLmxvZygncXVldWU6d29yaycpXG4gICAgbGV0IHN0YXRlLCBleGVjRXJyb3JcbiAgICB0cnkge1xuICAgICAgc3RhdGUgPSBhd2FpdCB0aGlzLmV4ZWNRdWVyeShwZWVyKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXhlY0Vycm9yID0gZXJyXG4gICAgfVxuXG4gICAgLy8gQWJvcnQgYW5kIGlnbm9yZSBhbnkgZXJyb3IgaWYgd2UncmUgbm8gbG9uZ2VyIHJ1bm5pbmdcbiAgICBpZiAoIXRoaXMucnVubmluZykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5sb2coJ3F1ZXVlOndvcms6ZG9uZScsIGV4ZWNFcnJvciwgc3RhdGUpXG5cbiAgICBpZiAoZXhlY0Vycm9yKSB7XG4gICAgICB0aHJvdyBleGVjRXJyb3JcbiAgICB9XG5cbiAgICAvLyBJZiBxdWVyeSBpcyBjb21wbGV0ZSwgc3RvcCBhbGwgd29ya2Vycy5cbiAgICAvLyBOb3RlOiBydW4uc3RvcCgpIGNhbGxzIHN0b3AoKSBvbiBhbGwgdGhlIHdvcmtlcnMsIHdoaWNoIGtpbGxzIHRoZVxuICAgIC8vIHF1ZXVlIGFuZCByZXNvbHZlcyBleGVjdXRpb25cbiAgICBpZiAoc3RhdGUgJiYgc3RhdGUucXVlcnlDb21wbGV0ZSkge1xuICAgICAgdGhpcy5sb2coJ3F1ZXJ5OmNvbXBsZXRlJylcbiAgICAgIHRoaXMucnVuLnN0b3AoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgcGF0aCBpcyBjb21wbGV0ZSwganVzdCBzdG9wIHRoaXMgd29ya2VyLlxuICAgIC8vIE5vdGU6IHRoaXMuc3RvcCgpIGtpbGxzIHRoZSBxdWV1ZSBhbmQgcmVzb2x2ZXMgZXhlY3V0aW9uXG4gICAgaWYgKHN0YXRlICYmIHN0YXRlLnBhdGhDb21wbGV0ZSkge1xuICAgICAgdGhpcy5zdG9wKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBhIHF1ZXJ5IG9uIHRoZSBuZXh0IHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7UGVlcklkfSBwZWVyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgZXhlY1F1ZXJ5IChwZWVyKSB7XG4gICAgbGV0IHJlcywgcXVlcnlFcnJvclxuICAgIHRyeSB7XG4gICAgICByZXMgPSBhd2FpdCB0aGlzLnBhdGgucXVlcnlGdW5jKHBlZXIpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBxdWVyeUVycm9yID0gZXJyXG4gICAgfVxuXG4gICAgLy8gQWJvcnQgYW5kIGlnbm9yZSBhbnkgZXJyb3IgaWYgd2UncmUgbm8gbG9uZ2VyIHJ1bm5pbmdcbiAgICBpZiAoIXRoaXMucnVubmluZykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHF1ZXJ5RXJyb3IpIHtcbiAgICAgIHRoaXMucnVuLmVycm9ycy5wdXNoKHF1ZXJ5RXJyb3IpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIHBlZXIgdG8gdGhlIGNsb3Nlc3QgcGVlcnMgd2UgaGF2ZSBzdWNjZXNzZnVsbHkgcXVlcmllZFxuICAgIGF3YWl0IHByb21pc2lmeShjYiA9PiB0aGlzLnJ1bi5wZWVyc1F1ZXJpZWQuYWRkKHBlZXIsIGNiKSkoKVxuXG4gICAgLy8gSWYgdGhlIHF1ZXJ5IGluZGljYXRlcyB0aGF0IHRoaXMgcGF0aCBvciB0aGUgd2hvbGUgcXVlcnkgaXMgY29tcGxldGVcbiAgICAvLyBzZXQgdGhlIHBhdGggcmVzdWx0IGFuZCBiYWlsIG91dFxuICAgIGlmIChyZXMucGF0aENvbXBsZXRlIHx8IHJlcy5xdWVyeUNvbXBsZXRlKSB7XG4gICAgICB0aGlzLnBhdGgucmVzID0gcmVzXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoQ29tcGxldGU6IHJlcy5wYXRoQ29tcGxldGUsXG4gICAgICAgIHF1ZXJ5Q29tcGxldGU6IHJlcy5xdWVyeUNvbXBsZXRlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgYXJlIGNsb3NlciBwZWVycyB0byBxdWVyeSwgYWRkIHRoZW0gdG8gdGhlIHF1ZXVlXG4gICAgaWYgKHJlcy5jbG9zZXJQZWVycyAmJiByZXMuY2xvc2VyUGVlcnMubGVuZ3RoID4gMCkge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocmVzLmNsb3NlclBlZXJzLm1hcChhc3luYyAoY2xvc2VyKSA9PiB7XG4gICAgICAgIC8vIGRvbid0IGFkZCBvdXJzZWx2ZXNcbiAgICAgICAgaWYgKHRoaXMuZGh0Ll9pc1NlbGYoY2xvc2VyLmlkKSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGNsb3NlciA9IHRoaXMuZGh0LnBlZXJCb29rLnB1dChjbG9zZXIpXG4gICAgICAgIHRoaXMuZGh0Ll9wZWVyRGlzY292ZXJlZChjbG9zZXIpXG4gICAgICAgIGF3YWl0IHRoaXMucGF0aC5hZGRQZWVyVG9RdWVyeShjbG9zZXIuaWQpXG4gICAgICB9KSlcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBXb3JrZXJRdWV1ZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFBlZXJRdWV1ZSA9IHJlcXVpcmUoJy4uL3BlZXItcXVldWUnKVxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpXG5cbi8vIFRPRE86IFRlbXBvcmFyeSB1bnRpbCBwYXJhbGxlbCBkaWFsIGluIFN3aXRjaCBoYXZlIGEgcHJvcGVyXG4vLyB0aW1lb3V0LiBSZXF1aXJlcyBhc3luYy9hd2FpdCByZWZhY3RvciBvZiB0cmFuc3BvcnRzIGFuZFxuLy8gZGlhbCBhYm9ydCBsb2dpYy4gVGhpcyBnaXZlcyB1cyAzMHMgdG8gY29tcGxldGUgdGhlIGBxdWVyeUZ1bmNgLlxuLy8gVGhpcyBzaG91bGQgaGVscCByZWR1Y2UgdGhlIGhpZ2ggZW5kIGNhbGwgdGltZXMgb2YgcXVlcmllc1xuY29uc3QgUVVFUllfRlVOQ19USU1FT1VUID0gMzBlM1xuXG4vKipcbiAqIE1hbmFnZXMgYSBzaW5nbGUgUGF0aCB0aHJvdWdoIHRoZSBESFQuXG4gKi9cbmNsYXNzIFBhdGgge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFBhdGguXG4gICAqXG4gICAqIEBwYXJhbSB7UnVufSBydW5cbiAgICogQHBhcmFtIHtxdWVyeUZ1bmN9IHF1ZXJ5RnVuY1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHJ1biwgcXVlcnlGdW5jKSB7XG4gICAgdGhpcy5ydW4gPSBydW5cbiAgICB0aGlzLnF1ZXJ5RnVuYyA9IHV0aWxzLndpdGhUaW1lb3V0KHF1ZXJ5RnVuYywgUVVFUllfRlVOQ19USU1FT1VUKVxuICAgIGlmICghdGhpcy5xdWVyeUZ1bmMpIHRocm93IG5ldyBFcnJvcignUGF0aCByZXF1aXJlcyBhIGBxdWVyeUZuYCB0byBiZSBzcGVjaWZpZWQnKVxuICAgIGlmICh0eXBlb2YgdGhpcy5xdWVyeUZ1bmMgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignUGF0aCBleHBlY3RlZCBgcXVlcnlGbmAgdG8gYmUgYSBmdW5jdGlvbi4gR290ICcgKyB0eXBlb2YgdGhpcy5xdWVyeUZ1bmMpXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8UGVlcklkPn1cbiAgICAgKi9cbiAgICB0aGlzLmluaXRpYWxQZWVycyA9IFtdXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UGVlclF1ZXVlfVxuICAgICAqL1xuICAgIHRoaXMucGVlcnNUb1F1ZXJ5ID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHBlZXIgdG8gdGhlIHNldCBvZiBwZWVycyB0aGF0IGFyZSB1c2VkIHRvIGludGlhbGl6ZSB0aGUgcGF0aC5cbiAgICpcbiAgICogQHBhcmFtIHtQZWVySWR9IHBlZXJcbiAgICovXG4gIGFkZEluaXRpYWxQZWVyIChwZWVyKSB7XG4gICAgdGhpcy5pbml0aWFsUGVlcnMucHVzaChwZWVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgdGhlIHBhdGguXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKlxuICAgKi9cbiAgYXN5bmMgZXhlY3V0ZSAoKSB7XG4gICAgLy8gQ3JlYXRlIGEgcXVldWUgb2YgcGVlcnMgb3JkZXJlZCBieSBkaXN0YW5jZSBmcm9tIHRoZSBrZXlcbiAgICBjb25zdCBxdWV1ZSA9IGF3YWl0IFBlZXJRdWV1ZS5mcm9tS2V5KHRoaXMucnVuLnF1ZXJ5LmtleSlcbiAgICAvLyBBZGQgaW5pdGlhbCBwZWVycyB0byB0aGUgcXVldWVcbiAgICB0aGlzLnBlZXJzVG9RdWVyeSA9IHF1ZXVlXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5pbml0aWFsUGVlcnMubWFwKHBlZXIgPT4gdGhpcy5hZGRQZWVyVG9RdWVyeShwZWVyKSkpXG4gICAgYXdhaXQgdGhpcy5ydW4ud29ya2VyUXVldWUodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBwZWVyIHRvIHRoZSBwZWVycyB0byBiZSBxdWVyaWVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1BlZXJJZH0gcGVlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jIGFkZFBlZXJUb1F1ZXJ5IChwZWVyKSB7XG4gICAgLy8gRG9uJ3QgYWRkIHNlbGZcbiAgICBpZiAodGhpcy5ydW4ucXVlcnkuZGh0Ll9pc1NlbGYocGVlcikpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFRoZSBwYXRocyBtdXN0IGJlIGRpc2pvaW50LCBtZWFuaW5nIHRoYXQgbm8gdHdvIHBhdGhzIGluIHRoZSBRdWVyeSBtYXlcbiAgICAvLyB0cmF2ZXJzZSB0aGUgc2FtZSBwZWVyXG4gICAgaWYgKHRoaXMucnVuLnBlZXJzU2Vlbi5oYXMocGVlcikpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGF3YWl0IHRoaXMucGVlcnNUb1F1ZXJ5LmVucXVldWUocGVlcilcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhdGhcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBUID0gcmVxdWlyZSgnLi4vLi4vbWVzc2FnZScpLlRZUEVTXG5cbm1vZHVsZS5leHBvcnRzID0gKGRodCkgPT4ge1xuICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICBbVC5HRVRfVkFMVUVdOiByZXF1aXJlKCcuL2dldC12YWx1ZScpKGRodCksXG4gICAgW1QuUFVUX1ZBTFVFXTogcmVxdWlyZSgnLi9wdXQtdmFsdWUnKShkaHQpLFxuICAgIFtULkZJTkRfTk9ERV06IHJlcXVpcmUoJy4vZmluZC1ub2RlJykoZGh0KSxcbiAgICBbVC5BRERfUFJPVklERVJdOiByZXF1aXJlKCcuL2FkZC1wcm92aWRlcicpKGRodCksXG4gICAgW1QuR0VUX1BST1ZJREVSU106IHJlcXVpcmUoJy4vZ2V0LXByb3ZpZGVycycpKGRodCksXG4gICAgW1QuUElOR106IHJlcXVpcmUoJy4vcGluZycpKGRodClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1lc3NhZ2UgaGFuZGxlciBtYXRjaGluZyB0aGUgcGFzc2VkIGluIHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlXG4gICAqXG4gICAqIEByZXR1cm5zIHtmdW5jdGlvbihQZWVySW5mbywgTWVzc2FnZSwgZnVuY3Rpb24oRXJyb3IsIE1lc3NhZ2UpKX1cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiBnZXRNZXNzYWdlSGFuZGxlciAodHlwZSkge1xuICAgIHJldHVybiBoYW5kbGVyc1t0eXBlXVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5FUlJfV1NfU1RBUl9XRUJTT0NLRVRfQ09OTkVDVElPTiA9ICdFUlJfV1NfU1RBUl9XRUJTT0NLRVRfQ09OTkVDVElPTidcbiIsIid1c2Ugc3RyaWN0J1xuXG4vLyBzb2NrZXQuaW8tcHVsbC1zdHJlYW1cbmNvbnN0IFF1ZXVlID0gcmVxdWlyZSgnZGF0YS1xdWV1ZScpXG5jb25zdCB1dWlkID0gcmVxdWlyZSgndXVpZCcpXG5jb25zdCBwdWxsID0gcmVxdWlyZSgncHVsbC1zdHJlYW0nKVxuY29uc3Qgc2lvbmFtZSA9ICh0eXBlLCBuYW1lKSA9PiAnc29ja2V0LmlvLXB1bGwtc3RyZWFtLicgKyB0eXBlICsgKG5hbWUgPyAnLicgKyBuYW1lIDogJycpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJylcbmNvbnN0IF9sb2cgPSBkZWJ1Zygnc29ja2V0LmlvLXB1bGwtc3RyZWFtJylcblxuZnVuY3Rpb24gZG9Db2RlYyAoY29kZWMsIGRhdGEpIHtcbiAgaWYgKGRhdGEgPT0gbnVsbCkgcmV0dXJuIGRhdGFcbiAgdHJ5IHtcbiAgICByZXR1cm4gY29kZWMoZGF0YSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0NvZGVjIEVycm9yJylcbiAgICBjb25zb2xlLmVycm9yKGUpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuY29uc3QgY29kZWNzID0ge1xuICBoZXg6IHtcbiAgICBlbmNvZGU6IHYgPT4gdi50b1N0cmluZygnaGV4JyksXG4gICAgZGVjb2RlOiB2ID0+IEJ1ZmZlci5mcm9tKHYsICdoZXgnKVxuICB9LFxuICBwbGFpbjoge1xuICAgIGVuY29kZTogdiA9PiB2LFxuICAgIGRlY29kZTogdiA9PiB2XG4gIH0sXG4gIGJ1ZmZlcjogeyAvLyBhbHdheXMgZG8gQnVmZmVyLmZyb20gYmVjYXVzZSBicm93c2Vyc1xuICAgIGVuY29kZTogdiA9PiBCdWZmZXIuZnJvbSh2KSxcbiAgICBkZWNvZGU6IHYgPT4gQnVmZmVyLmZyb20odilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDb2RlYyAoYykge1xuICBpZiAoIWMpIGMgPSAncGxhaW4nXG4gIGlmICh0eXBlb2YgYyA9PT0gJ29iamVjdCcpIHJldHVybiBjXG4gIGNvbnN0IGNvID0gY29kZWNzW2NdXG4gIGlmICghY28pIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlYyAnICsgYylcbiAgcmV0dXJuIGNvXG59XG5cbmZ1bmN0aW9uIFNJT1NvdXJjZSAoc2lvLCBpZCwgb3B0KSB7XG4gIGNvbnN0IHEgPSBRdWV1ZSgpXG4gIGNvbnN0IGxvZyA9IHNpby5zaW9wbG9nLmJpbmQoc2lvLnNpb3Bsb2csICdzb3VyY2UoJyArIGlkICsgJyknKVxuICBjb25zdCBjb2RlYyA9IGdldENvZGVjKG9wdC5jb2RlYykuZGVjb2RlXG4gIGxvZygnY3JlYXRlIHNvdXJjZScpXG4gIHNpby5lbWl0KHNpb25hbWUoJ2FjY2VwdCcsIGlkKSlcblxuICBmdW5jdGlvbiB1bmxpc3RlbiAoKSB7XG4gICAgc2lvLnJlbW92ZUFsbExpc3RlbmVycyhzaW9uYW1lKCdlcnJvcicsIGlkKSlcbiAgICBzaW8ucmVtb3ZlQWxsTGlzdGVuZXJzKHNpb25hbWUoJ3F1ZXVlJywgaWQpKVxuICB9XG5cbiAgc2lvLm9uKHNpb25hbWUoJ2Vycm9yJywgaWQpLCBlcnIgPT4ge1xuICAgIGlmIChlcnIgPT09IHRydWUpIGxvZygnZmluaXNoJylcbiAgICBlbHNlIGxvZygnZXJyb3InKVxuICAgIHVubGlzdGVuKClcbiAgICBxLmFwcGVuZCh7ZW5kOiBlcnJ9KVxuICB9KVxuICBzaW8ub24oc2lvbmFtZSgncXVldWUnLCBpZCksIGRhdGEgPT4ge1xuICAgIGxvZygncXVldWUgZGF0YScpXG4gICAgcS5hcHBlbmQoe2RhdGE6IGRvQ29kZWMoY29kZWMsIGRhdGEpfSlcbiAgfSlcbiAgc2lvLm9uY2UoJ2Rpc2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgdW5saXN0ZW4oKVxuICAgIHEuYXBwZW5kKHtlbmQ6IHRydWV9KVxuICB9KVxuICByZXR1cm4gZnVuY3Rpb24gKGVuZCwgY2IpIHtcbiAgICBsb2coJ3JlYWRpbmcnKVxuICAgIGlmIChlbmQpIHJldHVybiBjYihlbmQpXG4gICAgcS5nZXQoKGVyciwgZGF0YSkgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIGlmIChkYXRhLmVuZCkge1xuICAgICAgICBxLmVycm9yKGRhdGEuZW5kKVxuICAgICAgICByZXR1cm4gY2IoZGF0YS5lbmQpXG4gICAgICB9XG4gICAgICByZXR1cm4gY2IobnVsbCwgZGF0YS5kYXRhKVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gU0lPU2luayAoc2lvLCBpZCwgb3B0KSB7XG4gIGNvbnN0IHEgPSBRdWV1ZSgpXG4gIGNvbnN0IGxvZyA9IHNpby5zaW9wbG9nLmJpbmQoc2lvLnNpb3Bsb2csICcgIHNpbmsoJyArIGlkICsgJyknKVxuICBjb25zdCBjb2RlYyA9IGdldENvZGVjKG9wdC5jb2RlYykuZW5jb2RlXG4gIGxldCBlbmRlZFxuICBsb2coJ2NyZWF0ZSBzaW5rJylcbiAgc2lvLm9uY2Uoc2lvbmFtZSgnYWNjZXB0JywgaWQpLCAoKSA9PiB7XG4gICAgbG9nKCdzdGFydCB0cmFuc21pc3Npb24nKVxuXG4gICAgZnVuY3Rpb24gbG9vcCAoKSB7XG4gICAgICBxLmdldCgoXywgdmFsKSA9PiB7XG4gICAgICAgIGxldCB7ZGF0YSwgZXJyfSA9IHZhbCB8fCB7fVxuICAgICAgICBpZiAoXykgZXJyID0gX1xuICAgICAgICBsb2coJ3NlbmQnLCBlcnIgJiYgZXJyID09PSB0cnVlID8gJ2ZpbmlzaCcgOiBlcnIgPyAnZXJyb3InIDogZGF0YSA/ICdkYXRhJyA6ICc8aW52YWxpZD4nKVxuICAgICAgICBpZiAoZXJyICYmICFfKSBxLmVycm9yKGVycilcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHNpby5lbWl0KHNpb25hbWUoJ2Vycm9yJywgaWQpLCBlcnIpXG4gICAgICAgIGlmIChkYXRhKSBzaW8uZW1pdChzaW9uYW1lKCdxdWV1ZScsIGlkKSwgZG9Db2RlYyhjb2RlYywgZGF0YSkpXG4gICAgICAgIGxvb3AoKVxuICAgICAgfSlcbiAgICB9XG4gICAgbG9vcCgpXG4gIH0pXG5cbiAgZnVuY3Rpb24gZG9FcnIgKGVuZCkge1xuICAgIHEuYXBwZW5kKHtlcnI6IGVuZH0pXG4gICAgZW5kZWQgPSBlbmRcbiAgfVxuXG4gIHNpby5vbmNlKCdkaXNjb25uZWN0JywgKCkgPT4gZG9FcnIodHJ1ZSkpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChyZWFkKSB7XG4gICAgcmVhZChudWxsLCBmdW5jdGlvbiBuZXh0IChlbmQsIGRhdGEpIHtcbiAgICAgIGlmIChlbmQpIHJldHVybiBkb0VycihlbmQpXG4gICAgICBpZiAoZW5kZWQpIHJldHVybiByZWFkKGVuZGVkLCBuZXh0KVxuICAgICAgcS5hcHBlbmQoe2RhdGF9KVxuICAgICAgcmVhZChudWxsLCBuZXh0KVxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBTSU9QdWxsU3RyZWFtIChzaW8sIG9wdCkge1xuICBpZiAoc2lvLmNyZWF0ZVNpbmspIHJldHVyblxuICBzaW8uc2lvcGxvZyA9IHNpby5pZCA/IF9sb2cuYmluZChfbG9nLCAnWycgKyBzaW8uaWQgKyAnXScpIDogX2xvZ1xuICBzaW8uY3JlYXRlU2luayA9IChpZCwgXykgPT4ge1xuICAgIGlmICghaWQpIGlkID0gdXVpZCgpXG4gICAgY29uc3Qgc2luayA9IFNJT1Npbmsoc2lvLCBpZCwgb3B0IHx8IF8pXG4gICAgc2luay5pZCA9IGlkXG4gICAgcmV0dXJuIHNpbmtcbiAgfVxuICBzaW8uY3JlYXRlU291cmNlID0gKGlkLCBfKSA9PiB7XG4gICAgY29uc3Qgc291cmNlID0gU0lPU291cmNlKHNpbywgaWQsIG9wdCB8fCBfKVxuICAgIHNvdXJjZS5pZCA9IGlkXG4gICAgcmV0dXJuIHNvdXJjZVxuICB9XG4gIHNpby5jcmVhdGVQcm94eSA9IChpZCwgdHNpbywgXykgPT4ge1xuICAgIHB1bGwoXG4gICAgICBzaW8uY3JlYXRlU291cmNlKGlkLCBfKSxcbiAgICAgIHRzaW8uY3JlYXRlU2luayhpZCwgXylcbiAgICApXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vL2EgcGFpciBvZiBwdWxsIHN0cmVhbXMgd2hlcmUgb25lIGRyYWlucyBmcm9tIHRoZSBvdGhlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVhZCwgd2FpdGluZ1xuICBmdW5jdGlvbiBzaW5rIChyZWFkKSB7XG4gICAgaWYoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHJlYWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlYWQgbXVzdCBiZSBmdW5jdGlvbicpXG5cbiAgICBpZihfcmVhZClcbiAgICAgIHRocm93IG5ldyBFcnJvcignYWxyZWFkeSBwaXBlZCcpXG4gICAgX3JlYWQgPSByZWFkXG4gICAgaWYod2FpdGluZykge1xuICAgICAgdmFyIF93YWl0aW5nID0gd2FpdGluZ1xuICAgICAgd2FpdGluZyA9IG51bGxcbiAgICAgIF9yZWFkLmFwcGx5KG51bGwsIF93YWl0aW5nKVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzb3VyY2UgKGFib3J0LCBjYikge1xuICAgIGlmKF9yZWFkKVxuICAgICAgX3JlYWQoYWJvcnQsIGNiKVxuICAgIGVsc2VcbiAgICAgIHdhaXRpbmcgPSBbYWJvcnQsIGNiXVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzb3VyY2U6IHNvdXJjZSwgc2luazogc2lua1xuICB9XG59XG5cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBtaCA9IHJlcXVpcmUoJ211bHRpaGFzaGluZy1hc3luYycpXG5jb25zdCBscCA9IHJlcXVpcmUoJ3B1bGwtbGVuZ3RoLXByZWZpeGVkJylcbmNvbnN0IHB1bGwgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS9wdWxsJylcbmNvbnN0IHZhbHVlcyA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtL3NvdXJjZXMvdmFsdWVzJylcbmNvbnN0IGNvbGxlY3QgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS9zaW5rcy9jb2xsZWN0JylcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2xpYnAycC1jcnlwdG8nKVxuY29uc3QgcGFyYWxsZWwgPSByZXF1aXJlKCdhc3luYy9wYXJhbGxlbCcpXG5cbmV4cG9ydHMuZXhjaGFuZ2VzID0gW1xuICAnUC0yNTYnLFxuICAnUC0zODQnLFxuICAnUC01MjEnXG5dXG5cbmV4cG9ydHMuY2lwaGVycyA9IFtcbiAgJ0FFUy0yNTYnLFxuICAnQUVTLTEyOCdcbl1cblxuZXhwb3J0cy5oYXNoZXMgPSBbXG4gICdTSEEyNTYnLFxuICAnU0hBNTEyJ1xuXVxuXG4vLyBEZXRlcm1pbmVzIHdoaWNoIGFsZ29yaXRobSB0byB1c2UuICBOb3RlOiAgZihhLCBiKSA9IGYoYiwgYSlcbmV4cG9ydHMudGhlQmVzdCA9IChvcmRlciwgcDEsIHAyKSA9PiB7XG4gIGxldCBmaXJzdFxuICBsZXQgc2Vjb25kXG5cbiAgaWYgKG9yZGVyIDwgMCkge1xuICAgIGZpcnN0ID0gcDJcbiAgICBzZWNvbmQgPSBwMVxuICB9IGVsc2UgaWYgKG9yZGVyID4gMCkge1xuICAgIGZpcnN0ID0gcDFcbiAgICBzZWNvbmQgPSBwMlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBwMVswXVxuICB9XG5cbiAgZm9yIChsZXQgZmlyc3RDYW5kaWRhdGUgb2YgZmlyc3QpIHtcbiAgICBmb3IgKGxldCBzZWNvbmRDYW5kaWRhdGUgb2Ygc2Vjb25kKSB7XG4gICAgICBpZiAoZmlyc3RDYW5kaWRhdGUgPT09IHNlY29uZENhbmRpZGF0ZSkge1xuICAgICAgICByZXR1cm4gZmlyc3RDYW5kaWRhdGVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFsZ29yaXRobXMgaW4gY29tbW9uIScpXG59XG5cbmV4cG9ydHMubWFrZU1hY0FuZENpcGhlciA9ICh0YXJnZXQsIGNhbGxiYWNrKSA9PiB7XG4gIHBhcmFsbGVsKFtcbiAgICAoY2IpID0+IG1ha2VNYWModGFyZ2V0Lmhhc2hULCB0YXJnZXQua2V5cy5tYWNLZXksIGNiKSxcbiAgICAoY2IpID0+IG1ha2VDaXBoZXIodGFyZ2V0LmNpcGhlclQsIHRhcmdldC5rZXlzLml2LCB0YXJnZXQua2V5cy5jaXBoZXJLZXksIGNiKVxuICBdLCAoZXJyLCBtYWNBbmRDaXBoZXIpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIH1cblxuICAgIHRhcmdldC5tYWMgPSBtYWNBbmRDaXBoZXJbMF1cbiAgICB0YXJnZXQuY2lwaGVyID0gbWFjQW5kQ2lwaGVyWzFdXG4gICAgY2FsbGJhY2soKVxuICB9KVxufVxuXG5mdW5jdGlvbiBtYWtlTWFjIChoYXNoLCBrZXksIGNhbGxiYWNrKSB7XG4gIGNyeXB0by5obWFjLmNyZWF0ZShoYXNoLCBrZXksIGNhbGxiYWNrKVxufVxuXG5mdW5jdGlvbiBtYWtlQ2lwaGVyIChjaXBoZXJUeXBlLCBpdiwga2V5LCBjYWxsYmFjaykge1xuICBpZiAoY2lwaGVyVHlwZSA9PT0gJ0FFUy0xMjgnIHx8IGNpcGhlclR5cGUgPT09ICdBRVMtMjU2Jykge1xuICAgIHJldHVybiBjcnlwdG8uYWVzLmNyZWF0ZShrZXksIGl2LCBjYWxsYmFjaylcbiAgfVxuXG4gIC8vIFRPRE86IGZpZ3VyZSBvdXQgaWYgQmxvd2Zpc2ggaXMgbmVlZGVkIGFuZCBpZiBzbyBmaW5kIGEgbGlicmFyeSBmb3IgaXQuXG4gIGNhbGxiYWNrKG5ldyBFcnJvcihgdW5yZWNvZ25pemVkIGNpcGhlciB0eXBlOiAke2NpcGhlclR5cGV9YCkpXG59XG5cbmV4cG9ydHMuc2VsZWN0QmVzdCA9IChsb2NhbCwgcmVtb3RlLCBjYikgPT4ge1xuICBleHBvcnRzLmRpZ2VzdChCdWZmZXIuY29uY2F0KFtcbiAgICByZW1vdGUucHViS2V5Qnl0ZXMsXG4gICAgbG9jYWwubm9uY2VcbiAgXSksIChlcnIsIG9oMSkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYihlcnIpXG4gICAgfVxuXG4gICAgZXhwb3J0cy5kaWdlc3QoQnVmZmVyLmNvbmNhdChbXG4gICAgICBsb2NhbC5wdWJLZXlCeXRlcyxcbiAgICAgIHJlbW90ZS5ub25jZVxuICAgIF0pLCAoZXJyLCBvaDIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3JkZXIgPSBCdWZmZXIuY29tcGFyZShvaDEsIG9oMilcblxuICAgICAgaWYgKG9yZGVyID09PSAwKSB7XG4gICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ3lvdSBhcmUgdHJ5aW5nIHRvIHRhbGsgdG8geW91cnNlbGYnKSlcbiAgICAgIH1cblxuICAgICAgY2IobnVsbCwge1xuICAgICAgICBjdXJ2ZVQ6IGV4cG9ydHMudGhlQmVzdChvcmRlciwgbG9jYWwuZXhjaGFuZ2VzLCByZW1vdGUuZXhjaGFuZ2VzKSxcbiAgICAgICAgY2lwaGVyVDogZXhwb3J0cy50aGVCZXN0KG9yZGVyLCBsb2NhbC5jaXBoZXJzLCByZW1vdGUuY2lwaGVycyksXG4gICAgICAgIGhhc2hUOiBleHBvcnRzLnRoZUJlc3Qob3JkZXIsIGxvY2FsLmhhc2hlcywgcmVtb3RlLmhhc2hlcyksXG4gICAgICAgIG9yZGVyXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbmV4cG9ydHMuZGlnZXN0ID0gKGJ1ZiwgY2IpID0+IHtcbiAgbWguZGlnZXN0KGJ1ZiwgJ3NoYTItMjU2JywgYnVmLmxlbmd0aCwgY2IpXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RhdGUsIG1zZywgY2IpIHtcbiAgY2IgPSBjYiB8fCAoKCkgPT4ge30pXG4gIHB1bGwoXG4gICAgdmFsdWVzKFttc2ddKSxcbiAgICBscC5lbmNvZGUoeyBmaXhlZDogdHJ1ZSwgYnl0ZXM6IDQgfSksXG4gICAgY29sbGVjdCgoZXJyLCByZXMpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgIH1cbiAgICAgIHN0YXRlLnNoYWtlLndyaXRlKHJlc1swXSlcbiAgICAgIGNiKClcbiAgICB9KVxuICApXG59XG5cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIHJlYWQgKHJlYWRlciwgY2IpIHtcbiAgbHAuZGVjb2RlRnJvbVJlYWRlcihyZWFkZXIsIHsgZml4ZWQ6IHRydWUsIGJ5dGVzOiA0IH0sIGNiKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHByb3RvbnMgPSByZXF1aXJlKCdwcm90b25zJylcbmNvbnN0IFBlZXJJZCA9IHJlcXVpcmUoJ3BlZXItaWQnKVxuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnbGlicDJwLWNyeXB0bycpXG5jb25zdCBwYXJhbGxlbCA9IHJlcXVpcmUoJ2FzeW5jL3BhcmFsbGVsJylcbmNvbnN0IHdhdGVyZmFsbCA9IHJlcXVpcmUoJ2FzeW5jL3dhdGVyZmFsbCcpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJylcbmNvbnN0IGxvZyA9IGRlYnVnKCdsaWJwMnA6c2VjaW8nKVxubG9nLmVycm9yID0gZGVidWcoJ2xpYnAycDpzZWNpbzplcnJvcicpXG5cbmNvbnN0IHBibSA9IHByb3RvbnMocmVxdWlyZSgnLi9zZWNpby5wcm90bycpKVxuXG5jb25zdCBzdXBwb3J0ID0gcmVxdWlyZSgnLi4vc3VwcG9ydCcpXG5cbi8vIG5vbmNlU2l6ZSBpcyB0aGUgc2l6ZSBvZiBvdXIgbm9uY2VzIChpbiBieXRlcylcbmNvbnN0IG5vbmNlU2l6ZSA9IDE2XG5cbmV4cG9ydHMuY3JlYXRlUHJvcG9zYWwgPSAoc3RhdGUpID0+IHtcbiAgc3RhdGUucHJvcG9zYWwub3V0ID0ge1xuICAgIHJhbmQ6IGNyeXB0by5yYW5kb21CeXRlcyhub25jZVNpemUpLFxuICAgIHB1YmtleTogc3RhdGUua2V5LmxvY2FsLnB1YmxpYy5ieXRlcyxcbiAgICBleGNoYW5nZXM6IHN1cHBvcnQuZXhjaGFuZ2VzLmpvaW4oJywnKSxcbiAgICBjaXBoZXJzOiBzdXBwb3J0LmNpcGhlcnMuam9pbignLCcpLFxuICAgIGhhc2hlczogc3VwcG9ydC5oYXNoZXMuam9pbignLCcpXG4gIH1cblxuICBzdGF0ZS5wcm9wb3NhbEVuY29kZWQub3V0ID0gcGJtLlByb3Bvc2UuZW5jb2RlKHN0YXRlLnByb3Bvc2FsLm91dClcbiAgcmV0dXJuIHN0YXRlLnByb3Bvc2FsRW5jb2RlZC5vdXRcbn1cblxuZXhwb3J0cy5jcmVhdGVFeGNoYW5nZSA9IChzdGF0ZSwgY2FsbGJhY2spID0+IHtcbiAgY3J5cHRvLmtleXMuZ2VuZXJhdGVFcGhlbWVyYWxLZXlQYWlyKHN0YXRlLnByb3RvY29scy5sb2NhbC5jdXJ2ZVQsIChlcnIsIHJlcykgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgfVxuXG4gICAgc3RhdGUuZXBoZW1lcmFsS2V5LmxvY2FsID0gcmVzLmtleVxuICAgIHN0YXRlLnNoYXJlZC5nZW5lcmF0ZSA9IHJlcy5nZW5TaGFyZWRLZXlcblxuICAgIC8vIEdhdGhlciBjb3JwdXMgdG8gc2lnbi5cbiAgICBjb25zdCBzZWxlY3Rpb25PdXQgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgIHN0YXRlLnByb3Bvc2FsRW5jb2RlZC5vdXQsXG4gICAgICBzdGF0ZS5wcm9wb3NhbEVuY29kZWQuaW4sXG4gICAgICBzdGF0ZS5lcGhlbWVyYWxLZXkubG9jYWxcbiAgICBdKVxuXG4gICAgc3RhdGUua2V5LmxvY2FsLnNpZ24oc2VsZWN0aW9uT3V0LCAoZXJyLCBzaWcpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cblxuICAgICAgc3RhdGUuZXhjaGFuZ2Uub3V0ID0ge1xuICAgICAgICBlcHVia2V5OiBzdGF0ZS5lcGhlbWVyYWxLZXkubG9jYWwsXG4gICAgICAgIHNpZ25hdHVyZTogc2lnXG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIHBibS5FeGNoYW5nZS5lbmNvZGUoc3RhdGUuZXhjaGFuZ2Uub3V0KSlcbiAgICB9KVxuICB9KVxufVxuXG5leHBvcnRzLmlkZW50aWZ5ID0gKHN0YXRlLCBtc2csIGNhbGxiYWNrKSA9PiB7XG4gIGxvZygnMS4xIGlkZW50aWZ5JylcblxuICBzdGF0ZS5wcm9wb3NhbEVuY29kZWQuaW4gPSBtc2dcbiAgc3RhdGUucHJvcG9zYWwuaW4gPSBwYm0uUHJvcG9zZS5kZWNvZGUobXNnKVxuICBjb25zdCBwdWJrZXkgPSBzdGF0ZS5wcm9wb3NhbC5pbi5wdWJrZXlcblxuICBzdGF0ZS5rZXkucmVtb3RlID0gY3J5cHRvLmtleXMudW5tYXJzaGFsUHVibGljS2V5KHB1YmtleSlcblxuICBQZWVySWQuY3JlYXRlRnJvbVB1YktleShwdWJrZXkudG9TdHJpbmcoJ2Jhc2U2NCcpLCAoZXJyLCByZW1vdGVJZCkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgfVxuXG4gICAgLy8gSWYgd2Uga25vdyB3aG8gd2UgYXJlIGRpYWxpbmcgdG8sIGRvdWJsZSBjaGVja1xuICAgIGlmIChzdGF0ZS5pZC5yZW1vdGUpIHtcbiAgICAgIGlmIChzdGF0ZS5pZC5yZW1vdGUudG9CNThTdHJpbmcoKSAhPT0gcmVtb3RlSWQudG9CNThTdHJpbmcoKSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdkaWFsZWQgdG8gdGhlIHdyb25nIHBlZXIsIElkcyBkbyBub3QgbWF0Y2gnKSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuaWQucmVtb3RlID0gcmVtb3RlSWRcbiAgICB9XG5cbiAgICBsb2coJzEuMSBpZGVudGlmeSAtICVzIC0gaWRlbnRpZmllZCByZW1vdGUgcGVlciBhcyAlcycsIHN0YXRlLmlkLmxvY2FsLnRvQjU4U3RyaW5nKCksIHN0YXRlLmlkLnJlbW90ZS50b0I1OFN0cmluZygpKVxuICAgIGNhbGxiYWNrKClcbiAgfSlcbn1cblxuZXhwb3J0cy5zZWxlY3RQcm90b2NvbHMgPSAoc3RhdGUsIGNhbGxiYWNrKSA9PiB7XG4gIGxvZygnMS4yIHNlbGVjdGlvbicpXG5cbiAgY29uc3QgbG9jYWwgPSB7XG4gICAgcHViS2V5Qnl0ZXM6IHN0YXRlLmtleS5sb2NhbC5wdWJsaWMuYnl0ZXMsXG4gICAgZXhjaGFuZ2VzOiBzdXBwb3J0LmV4Y2hhbmdlcyxcbiAgICBoYXNoZXM6IHN1cHBvcnQuaGFzaGVzLFxuICAgIGNpcGhlcnM6IHN1cHBvcnQuY2lwaGVycyxcbiAgICBub25jZTogc3RhdGUucHJvcG9zYWwub3V0LnJhbmRcbiAgfVxuXG4gIGNvbnN0IHJlbW90ZSA9IHtcbiAgICBwdWJLZXlCeXRlczogc3RhdGUucHJvcG9zYWwuaW4ucHVia2V5LFxuICAgIGV4Y2hhbmdlczogc3RhdGUucHJvcG9zYWwuaW4uZXhjaGFuZ2VzLnNwbGl0KCcsJyksXG4gICAgaGFzaGVzOiBzdGF0ZS5wcm9wb3NhbC5pbi5oYXNoZXMuc3BsaXQoJywnKSxcbiAgICBjaXBoZXJzOiBzdGF0ZS5wcm9wb3NhbC5pbi5jaXBoZXJzLnNwbGl0KCcsJyksXG4gICAgbm9uY2U6IHN0YXRlLnByb3Bvc2FsLmluLnJhbmRcbiAgfVxuXG4gIHN1cHBvcnQuc2VsZWN0QmVzdChsb2NhbCwgcmVtb3RlLCAoZXJyLCBzZWxlY3RlZCkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgfVxuICAgIC8vIHdlIHVzZSB0aGUgc2FtZSBwYXJhbXMgZm9yIGJvdGggZGlyZWN0aW9ucyAobXVzdCBjaG9vc2Ugc2FtZSBjdXJ2ZSlcbiAgICAvLyBXQVJOSU5HOiBpZiB0aGV5IGRvbnQgU2VsZWN0QmVzdCB0aGUgc2FtZSB3YXksIHRoaXMgd29uJ3Qgd29yay4uLlxuICAgIHN0YXRlLnByb3RvY29scy5yZW1vdGUgPSB7XG4gICAgICBvcmRlcjogc2VsZWN0ZWQub3JkZXIsXG4gICAgICBjdXJ2ZVQ6IHNlbGVjdGVkLmN1cnZlVCxcbiAgICAgIGNpcGhlclQ6IHNlbGVjdGVkLmNpcGhlclQsXG4gICAgICBoYXNoVDogc2VsZWN0ZWQuaGFzaFRcbiAgICB9XG5cbiAgICBzdGF0ZS5wcm90b2NvbHMubG9jYWwgPSB7XG4gICAgICBvcmRlcjogc2VsZWN0ZWQub3JkZXIsXG4gICAgICBjdXJ2ZVQ6IHNlbGVjdGVkLmN1cnZlVCxcbiAgICAgIGNpcGhlclQ6IHNlbGVjdGVkLmNpcGhlclQsXG4gICAgICBoYXNoVDogc2VsZWN0ZWQuaGFzaFRcbiAgICB9XG4gICAgY2FsbGJhY2soKVxuICB9KVxufVxuXG5leHBvcnRzLnZlcmlmeSA9IChzdGF0ZSwgbXNnLCBjYWxsYmFjaykgPT4ge1xuICBsb2coJzIuMS4gdmVyaWZ5JylcblxuICBzdGF0ZS5leGNoYW5nZS5pbiA9IHBibS5FeGNoYW5nZS5kZWNvZGUobXNnKVxuICBzdGF0ZS5lcGhlbWVyYWxLZXkucmVtb3RlID0gc3RhdGUuZXhjaGFuZ2UuaW4uZXB1YmtleVxuXG4gIGNvbnN0IHNlbGVjdGlvbkluID0gQnVmZmVyLmNvbmNhdChbXG4gICAgc3RhdGUucHJvcG9zYWxFbmNvZGVkLmluLFxuICAgIHN0YXRlLnByb3Bvc2FsRW5jb2RlZC5vdXQsXG4gICAgc3RhdGUuZXBoZW1lcmFsS2V5LnJlbW90ZVxuICBdKVxuXG4gIHN0YXRlLmtleS5yZW1vdGUudmVyaWZ5KHNlbGVjdGlvbkluLCBzdGF0ZS5leGNoYW5nZS5pbi5zaWduYXR1cmUsIChlcnIsIHNpZ09rKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICB9XG5cbiAgICBpZiAoIXNpZ09rKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdCYWQgc2lnbmF0dXJlJykpXG4gICAgfVxuXG4gICAgbG9nKCcyLjEuIHZlcmlmeSAtIHNpZ25hdHVyZSB2ZXJpZmllZCcpXG4gICAgY2FsbGJhY2soKVxuICB9KVxufVxuXG5leHBvcnRzLmdlbmVyYXRlS2V5cyA9IChzdGF0ZSwgY2FsbGJhY2spID0+IHtcbiAgbG9nKCcyLjIuIGtleXMnKVxuXG4gIHdhdGVyZmFsbChbXG4gICAgKGNiKSA9PiBzdGF0ZS5zaGFyZWQuZ2VuZXJhdGUoc3RhdGUuZXhjaGFuZ2UuaW4uZXB1YmtleSwgY2IpLFxuICAgIChzZWNyZXQsIGNiKSA9PiB7XG4gICAgICBzdGF0ZS5zaGFyZWQuc2VjcmV0ID0gc2VjcmV0XG5cbiAgICAgIGNyeXB0by5rZXlzLmtleVN0cmV0Y2hlcihcbiAgICAgICAgc3RhdGUucHJvdG9jb2xzLmxvY2FsLmNpcGhlclQsXG4gICAgICAgIHN0YXRlLnByb3RvY29scy5sb2NhbC5oYXNoVCxcbiAgICAgICAgc3RhdGUuc2hhcmVkLnNlY3JldCxcbiAgICAgICAgY2JcbiAgICAgIClcbiAgICB9LFxuICAgIChrZXlzLCBjYikgPT4ge1xuICAgICAgLy8gdXNlIHJhbmRvbSBub25jZXMgdG8gZGVjaWRlIG9yZGVyLlxuICAgICAgaWYgKHN0YXRlLnByb3RvY29scy5sb2NhbC5vcmRlciA+IDApIHtcbiAgICAgICAgc3RhdGUucHJvdG9jb2xzLmxvY2FsLmtleXMgPSBrZXlzLmsxXG4gICAgICAgIHN0YXRlLnByb3RvY29scy5yZW1vdGUua2V5cyA9IGtleXMuazJcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUucHJvdG9jb2xzLmxvY2FsLm9yZGVyIDwgMCkge1xuICAgICAgICAvLyBzd2FwXG4gICAgICAgIHN0YXRlLnByb3RvY29scy5sb2NhbC5rZXlzID0ga2V5cy5rMlxuICAgICAgICBzdGF0ZS5wcm90b2NvbHMucmVtb3RlLmtleXMgPSBrZXlzLmsxXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3ZSBzaG91bGQndmUgYmFpbGVkIGJlZm9yZSBzdGF0ZS4gYnV0IGlmIG5vdCwgYmFpbCBoZXJlLlxuICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCd5b3UgYXJlIHRyeWluZyB0byB0YWxrIHRvIHlvdXJzZWxmJykpXG4gICAgICB9XG5cbiAgICAgIGxvZygnMi4zLiBtYWMgKyBjaXBoZXInKVxuXG4gICAgICBwYXJhbGxlbChbXG4gICAgICAgIChfY2IpID0+IHN1cHBvcnQubWFrZU1hY0FuZENpcGhlcihzdGF0ZS5wcm90b2NvbHMubG9jYWwsIF9jYiksXG4gICAgICAgIChfY2IpID0+IHN1cHBvcnQubWFrZU1hY0FuZENpcGhlcihzdGF0ZS5wcm90b2NvbHMucmVtb3RlLCBfY2IpXG4gICAgICBdLCBjYilcbiAgICB9XG4gIF0sIGNhbGxiYWNrKVxufVxuXG5leHBvcnRzLnZlcmlmeU5vbmNlID0gKHN0YXRlLCBuMikgPT4ge1xuICBjb25zdCBuMSA9IHN0YXRlLnByb3Bvc2FsLm91dC5yYW5kXG5cbiAgaWYgKG4xLmVxdWFscyhuMikpIHJldHVyblxuXG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBgRmFpbGVkIHRvIHJlYWQgb3VyIGVuY3J5cHRlZCBub25jZTogJHtuMS50b1N0cmluZygnaGV4Jyl9ICE9ICR7bjIudG9TdHJpbmcoJ2hleCcpfWBcbiAgKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHB1bGwgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS9wdWxsJylcbmNvbnN0IG1hcCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtL3Rocm91Z2hzL21hcCcpXG5jb25zdCBhc3luY01hcCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtL3Rocm91Z2hzL2FzeW5jLW1hcCcpXG5jb25zdCBscCA9IHJlcXVpcmUoJ3B1bGwtbGVuZ3RoLXByZWZpeGVkJylcblxuY29uc3QgbHBPcHRzID0ge1xuICBmaXhlZDogdHJ1ZSxcbiAgYnl0ZXM6IDRcbn1cblxuZXhwb3J0cy5jcmVhdGVCb3hTdHJlYW0gPSAoY2lwaGVyLCBtYWMpID0+IHtcbiAgcmV0dXJuIHB1bGwoXG4gICAgZW5zdXJlQnVmZmVyKCksXG4gICAgYXN5bmNNYXAoKGNodW5rLCBjYikgPT4ge1xuICAgICAgY2lwaGVyLmVuY3J5cHQoY2h1bmssIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgIH1cblxuICAgICAgICBtYWMuZGlnZXN0KGRhdGEsIChlcnIsIGRpZ2VzdCkgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2IobnVsbCwgQnVmZmVyLmNvbmNhdChbZGF0YSwgZGlnZXN0XSkpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pLFxuICAgIGxwLmVuY29kZShscE9wdHMpXG4gIClcbn1cblxuZXhwb3J0cy5jcmVhdGVVbmJveFN0cmVhbSA9IChkZWNpcGhlciwgbWFjKSA9PiB7XG4gIHJldHVybiBwdWxsKFxuICAgIGVuc3VyZUJ1ZmZlcigpLFxuICAgIGxwLmRlY29kZShscE9wdHMpLFxuICAgIGFzeW5jTWFwKChjaHVuaywgY2IpID0+IHtcbiAgICAgIGNvbnN0IGwgPSBjaHVuay5sZW5ndGhcbiAgICAgIGNvbnN0IG1hY1NpemUgPSBtYWMubGVuZ3RoXG5cbiAgICAgIGlmIChsIDwgbWFjU2l6ZSkge1xuICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKGBidWZmZXIgKCR7bH0pIHNob3J0ZXIgdGhhbiBNQUMgc2l6ZSAoJHttYWNTaXplfSlgKSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWFyayA9IGwgLSBtYWNTaXplXG4gICAgICBjb25zdCBkYXRhID0gY2h1bmsuc2xpY2UoMCwgbWFyaylcbiAgICAgIGNvbnN0IG1hY2QgPSBjaHVuay5zbGljZShtYXJrKVxuXG4gICAgICBtYWMuZGlnZXN0KGRhdGEsIChlcnIsIGV4cGVjdGVkKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtYWNkLmVxdWFscyhleHBlY3RlZCkpIHtcbiAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKGBNQUMgSW52YWxpZDogJHttYWNkLnRvU3RyaW5nKCdoZXgnKX0gIT0gJHtleHBlY3RlZC50b1N0cmluZygnaGV4Jyl9YCkpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBhbGwgZ29vZCwgZGVjcnlwdFxuICAgICAgICBkZWNpcGhlci5kZWNyeXB0KGRhdGEsIChlcnIsIGRlY3J5cHRlZCkgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2IobnVsbCwgZGVjcnlwdGVkKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICApXG59XG5cbmZ1bmN0aW9uIGVuc3VyZUJ1ZmZlciAoKSB7XG4gIHJldHVybiBtYXAoKGMpID0+IHtcbiAgICBpZiAodHlwZW9mIGMgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oYywgJ3V0Zi04JylcbiAgICB9XG5cbiAgICByZXR1cm4gY1xuICB9KVxufVxuIiwiLy8gUG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9lbmQtb2Ytc3RyZWFtIHdpdGhcbi8vIHBlcm1pc3Npb24gZnJvbSB0aGUgYXV0aG9yLCBNYXRoaWFzIEJ1dXMgKEBtYWZpbnRvc2gpLlxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2Rlcy5FUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRTtcblxuZnVuY3Rpb24gb25jZShjYWxsYmFjaykge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuICAgIGNhbGxlZCA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBpc1JlcXVlc3Qoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGVvcyhzdHJlYW0sIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVvcyhzdHJlYW0sIG51bGwsIG9wdHMpO1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICB2YXIgcmVhZGFibGUgPSBvcHRzLnJlYWRhYmxlIHx8IG9wdHMucmVhZGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS5yZWFkYWJsZTtcbiAgdmFyIHdyaXRhYmxlID0gb3B0cy53cml0YWJsZSB8fCBvcHRzLndyaXRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ud3JpdGFibGU7XG5cbiAgdmFyIG9ubGVnYWN5ZmluaXNoID0gZnVuY3Rpb24gb25sZWdhY3lmaW5pc2goKSB7XG4gICAgaWYgKCFzdHJlYW0ud3JpdGFibGUpIG9uZmluaXNoKCk7XG4gIH07XG5cbiAgdmFyIHdyaXRhYmxlRW5kZWQgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGUgJiYgc3RyZWFtLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkO1xuXG4gIHZhciBvbmZpbmlzaCA9IGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIHdyaXRhYmxlID0gZmFsc2U7XG4gICAgd3JpdGFibGVFbmRlZCA9IHRydWU7XG4gICAgaWYgKCFyZWFkYWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuICB9O1xuXG4gIHZhciByZWFkYWJsZUVuZGVkID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlICYmIHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkO1xuXG4gIHZhciBvbmVuZCA9IGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIHJlYWRhYmxlID0gZmFsc2U7XG4gICAgcmVhZGFibGVFbmRlZCA9IHRydWU7XG4gICAgaWYgKCF3cml0YWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuICB9O1xuXG4gIHZhciBvbmVycm9yID0gZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgfTtcblxuICB2YXIgb25jbG9zZSA9IGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgdmFyIGVycjtcblxuICAgIGlmIChyZWFkYWJsZSAmJiAhcmVhZGFibGVFbmRlZCkge1xuICAgICAgaWYgKCFzdHJlYW0uX3JlYWRhYmxlU3RhdGUgfHwgIXN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRlZCkgZXJyID0gbmV3IEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gICAgfVxuXG4gICAgaWYgKHdyaXRhYmxlICYmICF3cml0YWJsZUVuZGVkKSB7XG4gICAgICBpZiAoIXN0cmVhbS5fd3JpdGFibGVTdGF0ZSB8fCAhc3RyZWFtLl93cml0YWJsZVN0YXRlLmVuZGVkKSBlcnIgPSBuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIG9ucmVxdWVzdCA9IGZ1bmN0aW9uIG9ucmVxdWVzdCgpIHtcbiAgICBzdHJlYW0ucmVxLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gIH07XG5cbiAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSB7XG4gICAgc3RyZWFtLm9uKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ub24oJ2Fib3J0Jywgb25jbG9zZSk7XG4gICAgaWYgKHN0cmVhbS5yZXEpIG9ucmVxdWVzdCgpO2Vsc2Ugc3RyZWFtLm9uKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcbiAgfSBlbHNlIGlmICh3cml0YWJsZSAmJiAhc3RyZWFtLl93cml0YWJsZVN0YXRlKSB7XG4gICAgLy8gbGVnYWN5IHN0cmVhbXNcbiAgICBzdHJlYW0ub24oJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ub24oJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuICB9XG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBvbmVuZCk7XG4gIHN0cmVhbS5vbignZmluaXNoJywgb25maW5pc2gpO1xuICBpZiAob3B0cy5lcnJvciAhPT0gZmFsc2UpIHN0cmVhbS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgc3RyZWFtLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY29tcGxldGUnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdhYm9ydCcsIG9uY2xvc2UpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcigncmVxdWVzdCcsIG9ucmVxdWVzdCk7XG4gICAgaWYgKHN0cmVhbS5yZXEpIHN0cmVhbS5yZXEucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW9zOyIsIi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvcHVtcCB3aXRoXG4vLyBwZXJtaXNzaW9uIGZyb20gdGhlIGF1dGhvciwgTWF0aGlhcyBCdXVzIChAbWFmaW50b3NoKS5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVvcztcblxuZnVuY3Rpb24gb25jZShjYWxsYmFjaykge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgY2FsbGJhY2suYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfTUlTU0lOR19BUkdTID0gX3JlcXVpcmUkY29kZXMuRVJSX01JU1NJTkdfQVJHUyxcbiAgICBFUlJfU1RSRUFNX0RFU1RST1lFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fREVTVFJPWUVEO1xuXG5mdW5jdGlvbiBub29wKGVycikge1xuICAvLyBSZXRocm93IHRoZSBlcnJvciBpZiBpdCBleGlzdHMgdG8gYXZvaWQgc3dhbGxvd2luZyBpdFxuICBpZiAoZXJyKSB0aHJvdyBlcnI7XG59XG5cbmZ1bmN0aW9uIGlzUmVxdWVzdChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrKTtcbiAgdmFyIGNsb3NlZCA9IGZhbHNlO1xuICBzdHJlYW0ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGNsb3NlZCA9IHRydWU7XG4gIH0pO1xuICBpZiAoZW9zID09PSB1bmRlZmluZWQpIGVvcyA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpO1xuICBlb3Moc3RyZWFtLCB7XG4gICAgcmVhZGFibGU6IHJlYWRpbmcsXG4gICAgd3JpdGFibGU6IHdyaXRpbmdcbiAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgIGNsb3NlZCA9IHRydWU7XG4gICAgY2FsbGJhY2soKTtcbiAgfSk7XG4gIHZhciBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoY2xvc2VkKSByZXR1cm47XG4gICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgIGRlc3Ryb3llZCA9IHRydWU7IC8vIHJlcXVlc3QuZGVzdHJveSBqdXN0IGRvIC5lbmQgLSAuYWJvcnQgaXMgd2hhdCB3ZSB3YW50XG5cbiAgICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHJldHVybiBzdHJlYW0uYWJvcnQoKTtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSByZXR1cm4gc3RyZWFtLmRlc3Ryb3koKTtcbiAgICBjYWxsYmFjayhlcnIgfHwgbmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCdwaXBlJykpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjYWxsKGZuKSB7XG4gIGZuKCk7XG59XG5cbmZ1bmN0aW9uIHBpcGUoZnJvbSwgdG8pIHtcbiAgcmV0dXJuIGZyb20ucGlwZSh0byk7XG59XG5cbmZ1bmN0aW9uIHBvcENhbGxiYWNrKHN0cmVhbXMpIHtcbiAgaWYgKCFzdHJlYW1zLmxlbmd0aCkgcmV0dXJuIG5vb3A7XG4gIGlmICh0eXBlb2Ygc3RyZWFtc1tzdHJlYW1zLmxlbmd0aCAtIDFdICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gbm9vcDtcbiAgcmV0dXJuIHN0cmVhbXMucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHBpcGVsaW5lKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3RyZWFtcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzdHJlYW1zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIGNhbGxiYWNrID0gcG9wQ2FsbGJhY2soc3RyZWFtcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHN0cmVhbXNbMF0pKSBzdHJlYW1zID0gc3RyZWFtc1swXTtcblxuICBpZiAoc3RyZWFtcy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ3N0cmVhbXMnKTtcbiAgfVxuXG4gIHZhciBlcnJvcjtcbiAgdmFyIGRlc3Ryb3lzID0gc3RyZWFtcy5tYXAoZnVuY3Rpb24gKHN0cmVhbSwgaSkge1xuICAgIHZhciByZWFkaW5nID0gaSA8IHN0cmVhbXMubGVuZ3RoIC0gMTtcbiAgICB2YXIgd3JpdGluZyA9IGkgPiAwO1xuICAgIHJldHVybiBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoIWVycm9yKSBlcnJvciA9IGVycjtcbiAgICAgIGlmIChlcnIpIGRlc3Ryb3lzLmZvckVhY2goY2FsbCk7XG4gICAgICBpZiAocmVhZGluZykgcmV0dXJuO1xuICAgICAgZGVzdHJveXMuZm9yRWFjaChjYWxsKTtcbiAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBzdHJlYW1zLnJlZHVjZShwaXBlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwaXBlbGluZTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX01VTFRJUExFX0NBTExCQUNLID0gX3JlcXVpcmUkY29kZXMuRVJSX01VTFRJUExFX0NBTExCQUNLLFxuICAgIEVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HLFxuICAgIEVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMDtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoY2IgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcbiAgY2IoZXIpO1xuICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07IC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH0gLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuXG5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicgJiYgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkKSB7XG4gICAgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59OyAvLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuXG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3RyYW5zZm9ybSgpJykpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcblxuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07IC8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG5cbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2IoZXJyMik7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7IC8vIFRPRE8oQnJpZGdlQVIpOiBXcml0ZSBhIHRlc3QgZm9yIHRoZXNlIHR3byBlcnJvciBjYXNlc1xuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuXG4gIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wKCk7XG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcoKTtcbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG4ndXNlIHN0cmljdCc7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG5cbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIEFsbG93IHRoZSBrZXlzIGFycmF5IHRvIGJlIEdDJ2VkLlxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcblxuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG4gICAgICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbiAgICB9XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pOyAvLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5cbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBJZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCwgdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjsgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cblxuICBwcm9jZXNzLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pOyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuLyogPHJlcGxhY2VtZW50PiAqL1xuXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59IC8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5cblxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuXG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5cbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cblxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpLFxuICAgIGdldEhpZ2hXYXRlck1hcmsgPSBfcmVxdWlyZS5nZXRIaWdoV2F0ZXJNYXJrO1xuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX01VTFRJUExFX0NBTExCQUNLID0gX3JlcXVpcmUkY29kZXMuRVJSX01VTFRJUExFX0NBTExCQUNLLFxuICAgIEVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0NBTk5PVF9QSVBFLFxuICAgIEVSUl9TVFJFQU1fREVTVFJPWUVEID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9ERVNUUk9ZRUQsXG4gICAgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fTlVMTF9WQUxVRVMsXG4gICAgRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCxcbiAgICBFUlJfVU5LTk9XTl9FTkNPRElORyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9VTktOT1dOX0VOQ09ESU5HO1xuXG52YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbSxcbiAgLy8gZS5nLiBvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZSB2cy4gb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGUsIGV0Yy5cblxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4OyAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlOyAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcblxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCBpc0R1cGxleCk7IC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcblxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7IC8vIGRyYWluIGV2ZW50IGZsYWcuXG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTsgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcblxuICB0aGlzLmVuZGluZyA9IGZhbHNlOyAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG5cbiAgdGhpcy5lbmRlZCA9IGZhbHNlOyAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcblxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7IC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7IC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cblxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7IC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7IC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG5cbiAgdGhpcy5sZW5ndGggPSAwOyAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlOyAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG5cbiAgdGhpcy5jb3JrZWQgPSAwOyAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cblxuICB0aGlzLnN5bmMgPSB0cnVlOyAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlOyAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG5cbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTsgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG5cblxuICB0aGlzLndyaXRlY2IgPSBudWxsOyAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDsgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG5cbiAgdGhpcy5wZW5kaW5nY2IgPSAwOyAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG5cbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlOyAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7IC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG5cbiAgdGhpcy5lbWl0Q2xvc2UgPSBvcHRpb25zLmVtaXRDbG9zZSAhPT0gZmFsc2U7IC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZmluaXNoJyAoYW5kIHBvdGVudGlhbGx5ICdlbmQnKVxuXG4gIHRoaXMuYXV0b0Rlc3Ryb3kgPSAhIW9wdGlvbnMuYXV0b0Rlc3Ryb3k7IC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7IC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuXG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiB3cml0YWJsZVN0YXRlQnVmZmVyR2V0dGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTsgLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG5cblxudmFyIHJlYWxIYXNJbnN0YW5jZTtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gcmVhbEhhc0luc3RhbmNlKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7IC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgV3JpdGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjVcblxuICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuICBpZiAoIWlzRHVwbGV4ICYmICFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykpIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzLCBpc0R1cGxleCk7IC8vIGxlZ2FjeS5cblxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59IC8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cblxuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUoKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EKCk7IC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG5cbiAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTtcbn0gLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuXG5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciBlcjtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBFUlJfU1RSRUFNX05VTExfVkFMVUVTKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdjaHVuaycsIFsnc3RyaW5nJywgJ0J1ZmZlciddLCBjaHVuayk7XG4gIH1cblxuICBpZiAoZXIpIHtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcblxuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuICBpZiAoc3RhdGUuZW5kaW5nKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgRVJSX1VOS05PV05fRU5DT0RJTkcoZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cblxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pOyAvLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcblxuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7IC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG5cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHN0YXRlLmRlc3Ryb3llZCkgc3RhdGUub253cml0ZShuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoJ3dyaXRlJykpO2Vsc2UgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7IC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgZXJyb3JcblxuICAgIHByb2Nlc3MubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpOyAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKTtcbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpIHx8IHN0cmVhbS5kZXN0cm95ZWQ7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufSAvLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cblxuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59IC8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5cblxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cblxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7IC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG5cbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07IC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfd3JpdGUoKScpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7IC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfSAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG5cblxuICBpZiAoIXN0YXRlLmVuZGluZykgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cblxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycik7XG4gICAgfVxuXG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nICYmICFzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcblxuICAgICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAgIC8vIEluIGNhc2Ugb2YgZHVwbGV4IHN0cmVhbXMgd2UgbmVlZCBhIHdheSB0byBkZXRlY3RcbiAgICAgICAgLy8gaWYgdGhlIHJlYWRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGxcbiAgICAgICAgdmFyIHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAgICAgICBpZiAoIXJTdGF0ZSB8fCByU3RhdGUuYXV0b0Rlc3Ryb3kgJiYgclN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuXG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcHJvY2Vzcy5uZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG5cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcblxuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfSAvLyByZXVzZSB0aGUgZnJlZSBjb3JrUmVxLlxuXG5cbiAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblxuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gRUVsaXN0ZW5lckNvdW50KGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuXG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIGRlYnVnO1xuXG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uIGRlYnVnKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9idWZmZXJfbGlzdCcpO1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RhdGUnKSxcbiAgICBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyaztcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRixcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICAgIEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UOyAvLyBMYXp5IGxvYWRlZCB0byBpbXByb3ZlIHRoZSBzdGFydHVwIHBlcmZvcm1hbmNlLlxuXG5cbnZhciBTdHJpbmdEZWNvZGVyO1xudmFyIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjtcbnZhciBmcm9tO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTtcbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pOyAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKEFycmF5LmlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDsgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcblxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTsgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KTsgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7IC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cblxuICB0aGlzLnN5bmMgPSB0cnVlOyAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cblxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHRoaXMucGF1c2VkID0gdHJ1ZTsgLy8gU2hvdWxkIGNsb3NlIGJlIGVtaXR0ZWQgb24gZGVzdHJveS4gRGVmYXVsdHMgdG8gdHJ1ZS5cblxuICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTsgLy8gU2hvdWxkIC5kZXN0cm95KCkgYmUgY2FsbGVkIGFmdGVyICdlbmQnIChhbmQgcG90ZW50aWFsbHkgJ2ZpbmlzaCcpXG5cbiAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTsgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cblxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JzsgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcblxuICB0aGlzLmF3YWl0RHJhaW4gPSAwOyAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG5cbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcblxuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpOyAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBSZWFkYWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxuXG4gIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzLCBpc0R1cGxleCk7IC8vIGxlZ2FjeVxuXG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5cblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIGNiKGVycik7XG59OyAvLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuXG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07IC8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIGRlYnVnKCdyZWFkYWJsZUFkZENodW5rJywgY2h1bmspO1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG5cbiAgICBpZiAoZXIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UKCkpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GKCkpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gLy8gV2UgY2FuIHB1c2ggbW9yZSBkYXRhIGlmIHdlIGFyZSBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyay5cbiAgLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWUgbW9yZSBieXRlcy5cbiAgLy8gVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCwgc3VjaCBhcyB0aGUgcmVwbC5cblxuXG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuXG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuXG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJywgJ1VpbnQ4QXJyYXknXSwgY2h1bmspO1xuICB9XG5cbiAgcmV0dXJuIGVyO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB2YXIgZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IGRlY29kZXI7IC8vIElmIHNldEVuY29kaW5nKG51bGwpLCBkZWNvZGVyLmVuY29kaW5nIGVxdWFscyB1dGY4XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2Rlci5lbmNvZGluZzsgLy8gSXRlcmF0ZSBvdmVyIGN1cnJlbnQgYnVmZmVyIHRvIGNvbnZlcnQgYWxyZWFkeSBzdG9yZWQgQnVmZmVyczpcblxuICB2YXIgcCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmhlYWQ7XG4gIHZhciBjb250ZW50ID0gJyc7XG5cbiAgd2hpbGUgKHAgIT09IG51bGwpIHtcbiAgICBjb250ZW50ICs9IGRlY29kZXIud3JpdGUocC5kYXRhKTtcbiAgICBwID0gcC5uZXh0O1xuICB9XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuY2xlYXIoKTtcblxuICBpZiAoY29udGVudCAhPT0gJycpIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLnB1c2goY29udGVudCk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoID0gY29udGVudC5sZW5ndGg7XG4gIHJldHVybiB0aGlzO1xufTsgLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDFHQlxuXG5cbnZhciBNQVhfSFdNID0gMHg0MDAwMDAwMDtcblxuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgLy8gVE9ETyhyb25hZyk6IFRocm93IEVSUl9WQUxVRV9PVVRfT0ZfUkFOR0UuXG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuXG4gIHJldHVybiBuO1xufSAvLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cblxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuXG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9IC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuXG5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47IC8vIERvbid0IGhhdmUgZW5vdWdoXG5cbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufSAvLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlOyAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmICgoc3RhdGUuaGlnaFdhdGVyTWFyayAhPT0gMCA/IHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIDogc3RhdGUubGVuZ3RoID4gMCkgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpOyAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG5cblxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7IC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH0gLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuXG5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTsgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cblxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcblxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG5cbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7IC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ29uRW9mQ2h1bmsnKTtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuXG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUuc3luYykge1xuICAgIC8vIGlmIHdlIGFyZSBzeW5jLCB3YWl0IHVudGlsIG5leHQgdGljayB0byBlbWl0IHRoZSBkYXRhLlxuICAgIC8vIE90aGVyd2lzZSB3ZSByaXNrIGVtaXR0aW5nIGRhdGEgaW4gdGhlIGZsb3coKVxuICAgIC8vIHRoZSByZWFkYWJsZSBjb2RlIHRyaWdnZXJzIGR1cmluZyBhIHJlYWQoKSBjYWxsXG4gICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICB9XG4gIH1cbn0gLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cblxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLm5lZWRSZWFkYWJsZSwgc3RhdGUuZW1pdHRlZFJlYWRhYmxlKTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW1pdFJlYWRhYmxlXycsIHN0YXRlLmRlc3Ryb3llZCwgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG5cbiAgaWYgKCFzdGF0ZS5kZXN0cm95ZWQgJiYgKHN0YXRlLmxlbmd0aCB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgfSAvLyBUaGUgc3RyZWFtIG5lZWRzIGFub3RoZXIgcmVhZGFibGUgZXZlbnQgaWZcbiAgLy8gMS4gSXQgaXMgbm90IGZsb3dpbmcsIGFzIHRoZSBmbG93IG1lY2hhbmlzbSB3aWxsIHRha2VcbiAgLy8gICAgY2FyZSBvZiBpdC5cbiAgLy8gMi4gSXQgaXMgbm90IGVuZGVkLlxuICAvLyAzLiBJdCBpcyBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyaywgc28gd2UgY2FuIHNjaGVkdWxlXG4gIC8vICAgIGFub3RoZXIgcmVhZGFibGUgbGF0ZXIuXG5cblxuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIGZsb3coc3RyZWFtKTtcbn0gLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICAvLyBBdHRlbXB0IHRvIHJlYWQgbW9yZSBkYXRhIGlmIHdlIHNob3VsZC5cbiAgLy9cbiAgLy8gVGhlIGNvbmRpdGlvbnMgZm9yIHJlYWRpbmcgbW9yZSBkYXRhIGFyZSAob25lIG9mKTpcbiAgLy8gLSBOb3QgZW5vdWdoIGRhdGEgYnVmZmVyZWQgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspLiBUaGUgbG9vcFxuICAvLyAgIGlzIHJlc3BvbnNpYmxlIGZvciBmaWxsaW5nIHRoZSBidWZmZXIgd2l0aCBlbm91Z2ggZGF0YSBpZiBzdWNoIGRhdGFcbiAgLy8gICBpcyBhdmFpbGFibGUuIElmIGhpZ2hXYXRlck1hcmsgaXMgMCBhbmQgd2UgYXJlIG5vdCBpbiB0aGUgZmxvd2luZyBtb2RlXG4gIC8vICAgd2Ugc2hvdWxkIF9ub3RfIGF0dGVtcHQgdG8gYnVmZmVyIGFueSBleHRyYSBkYXRhLiBXZSdsbCBnZXQgbW9yZSBkYXRhXG4gIC8vICAgd2hlbiB0aGUgc3RyZWFtIGNvbnN1bWVyIGNhbGxzIHJlYWQoKSBpbnN0ZWFkLlxuICAvLyAtIE5vIGRhdGEgaW4gdGhlIGJ1ZmZlciwgYW5kIHRoZSBzdHJlYW0gaXMgaW4gZmxvd2luZyBtb2RlLiBJbiB0aGlzIG1vZGVcbiAgLy8gICB0aGUgbG9vcCBiZWxvdyBpcyByZXNwb25zaWJsZSBmb3IgZW5zdXJpbmcgcmVhZCgpIGlzIGNhbGxlZC4gRmFpbGluZyB0b1xuICAvLyAgIGNhbGwgcmVhZCBoZXJlIHdvdWxkIGFib3J0IHRoZSBmbG93IGFuZCB0aGVyZSdzIG5vIG90aGVyIG1lY2hhbmlzbSBmb3JcbiAgLy8gICBjb250aW51aW5nIHRoZSBmbG93IGlmIHRoZSBzdHJlYW0gY29uc3VtZXIgaGFzIGp1c3Qgc3Vic2NyaWJlZCB0byB0aGVcbiAgLy8gICAnZGF0YScgZXZlbnQuXG4gIC8vXG4gIC8vIEluIGFkZGl0aW9uIHRvIHRoZSBhYm92ZSBjb25kaXRpb25zIHRvIGtlZXAgcmVhZGluZyBkYXRhLCB0aGUgZm9sbG93aW5nXG4gIC8vIGNvbmRpdGlvbnMgcHJldmVudCB0aGUgZGF0YSBmcm9tIGJlaW5nIHJlYWQ6XG4gIC8vIC0gVGhlIHN0cmVhbSBoYXMgZW5kZWQgKHN0YXRlLmVuZGVkKS5cbiAgLy8gLSBUaGVyZSBpcyBhbHJlYWR5IGEgcGVuZGluZyAncmVhZCcgb3BlcmF0aW9uIChzdGF0ZS5yZWFkaW5nKS4gVGhpcyBpcyBhXG4gIC8vICAgY2FzZSB3aGVyZSB0aGUgdGhlIHN0cmVhbSBoYXMgY2FsbGVkIHRoZSBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIF9yZWFkKClcbiAgLy8gICBtZXRob2QsIGJ1dCB0aGV5IGFyZSBwcm9jZXNzaW5nIHRoZSBjYWxsIGFzeW5jaHJvbm91c2x5IGFuZCBoYXZlIF9ub3RfXG4gIC8vICAgY2FsbGVkIHB1c2goKSB3aXRoIG5ldyBkYXRhLiBJbiB0aGlzIGNhc2Ugd2Ugc2tpcCBwZXJmb3JtaW5nIG1vcmVcbiAgLy8gICByZWFkKClzLiBUaGUgZXhlY3V0aW9uIGVuZHMgaW4gdGhpcyBtZXRob2QgYWdhaW4gYWZ0ZXIgdGhlIF9yZWFkKCkgZW5kc1xuICAvLyAgIHVwIGNhbGxpbmcgcHVzaCgpIHdpdGggbW9yZSBkYXRhLlxuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwKSkge1xuICAgIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKSAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gIH1cblxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufSAvLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ19yZWFkKCknKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuXG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG5cbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfSAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cblxuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTsgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBjbGVhbmVkVXAgPSB0cnVlOyAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGRlYnVnKCdkZXN0LndyaXRlJywgcmV0KTtcblxuICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgfVxuXG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH0gLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cblxuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGVycm9yT3JEZXN0cm95KGRlc3QsIGVyKTtcbiAgfSAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG5cblxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7IC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cblxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuXG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfSAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuXG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTsgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwaXBlT25EcmFpbkZ1bmN0aW9uUmVzdWx0KCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7XG4gICAgaGFzVW5waXBlZDogZmFsc2VcbiAgfTsgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpczsgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzOyAvLyBnb3QgYSBtYXRjaC5cblxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHtcbiAgICAgICAgaGFzVW5waXBlZDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG5cblxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gIHJldHVybiB0aGlzO1xufTsgLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblxuXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIHVwZGF0ZSByZWFkYWJsZUxpc3RlbmluZyBzbyB0aGF0IHJlc3VtZSgpIG1heSBiZSBhIG5vLW9wXG4gICAgLy8gYSBmZXcgbGluZXMgZG93bi4gVGhpcyBpcyBuZWVkZWQgdG8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScpLlxuICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdGhpcy5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMDsgLy8gVHJ5IHN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBkZWJ1Zygnb24gcmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLnJlYWRpbmcpO1xuXG4gICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIHNvbWVvbmUgc3RpbGwgbGlzdGVuaW5nIHRvXG4gICAgLy8gcmVhZGFibGUgYW5kIHJlc2V0IHRoZSBzdGF0ZS4gSG93ZXZlciB0aGlzIG5lZWRzIHRvIGhhcHBlblxuICAgIC8vIGFmdGVyIHJlYWRhYmxlIGhhcyBiZWVuIGVtaXR0ZWQgYnV0IGJlZm9yZSBJL08gKG5leHRUaWNrKSB0b1xuICAgIC8vIHN1cHBvcnQgb25jZSgncmVhZGFibGUnLCBmbikgY3ljbGVzLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZ1xuICAgIC8vIHJlc3VtZSB3aXRoaW4gdGhlIHNhbWUgdGljayB3aWxsIGhhdmUgbm9cbiAgICAvLyBlZmZlY3QuXG4gICAgcHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIChldikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScgfHwgZXYgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgc29tZW9uZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZWFkYWJsZSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBIb3dldmVyIHRoaXMgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgcmVhZGFibGUgaGFzIGJlZW4gZW1pdHRlZCBidXQgYmVmb3JlIEkvTyAobmV4dFRpY2spIHRvXG4gICAgLy8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScsIGZuKSBjeWNsZXMuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nXG4gICAgLy8gcmVzdW1lIHdpdGhpbiB0aGUgc2FtZSB0aWNrIHdpbGwgaGF2ZSBub1xuICAgIC8vIGVmZmVjdC5cbiAgICBwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVSZWFkYWJsZUxpc3RlbmluZyhzZWxmKSB7XG4gIHZhciBzdGF0ZSA9IHNlbGYuX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc2VsZi5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMDtcblxuICBpZiAoc3RhdGUucmVzdW1lU2NoZWR1bGVkICYmICFzdGF0ZS5wYXVzZWQpIHtcbiAgICAvLyBmbG93aW5nIG5lZWRzIHRvIGJlIHNldCB0byB0cnVlIG5vdywgb3RoZXJ3aXNlXG4gICAgLy8gdGhlIHVwY29taW5nIHJlc3VtZSB3aWxsIG5vdCBmbG93LlxuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlOyAvLyBjcnVkZSB3YXkgdG8gY2hlY2sgaWYgd2Ugc2hvdWxkIHJlc3VtZVxuICB9IGVsc2UgaWYgKHNlbGYubGlzdGVuZXJDb3VudCgnZGF0YScpID4gMCkge1xuICAgIHNlbGYucmVzdW1lKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufSAvLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7IC8vIHdlIGZsb3cgb25seSBpZiB0aGVyZSBpcyBubyBvbmUgbGlzdGVuaW5nXG4gICAgLy8gZm9yIHJlYWRhYmxlLCBidXQgd2Ugc3RpbGwgaGF2ZSB0byBjYWxsXG4gICAgLy8gcmVzdW1lKClcblxuICAgIHN0YXRlLmZsb3dpbmcgPSAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmc7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuXG4gIHN0YXRlLnBhdXNlZCA9IGZhbHNlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBkZWJ1ZygncmVzdW1lJywgc3RhdGUucmVhZGluZyk7XG5cbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUucGF1c2VkID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG5cbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge1xuICAgIDtcbiAgfVxufSAvLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcblxuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7IC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pOyAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gbWV0aG9kV3JhcChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1ldGhvZFdyYXBSZXR1cm5GdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH0gLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuXG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfSAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuXG5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcblxuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3InKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHRoaXMpO1xuICB9O1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlRmxvd2luZycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gc3RhdGU7XG4gICAgfVxuICB9XG59KTsgLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTsgLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5maXJzdCgpO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbnN1bWUobiwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VuZFJlYWRhYmxlJywgc3RhdGUuZW5kRW1pdHRlZCk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIGRlYnVnKCdlbmRSZWFkYWJsZU5UJywgc3RhdGUuZW5kRW1pdHRlZCwgc3RhdGUubGVuZ3RoKTsgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcblxuICAgIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgICAgLy8gaWYgdGhlIHdyaXRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGxcbiAgICAgIHZhciB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG5cbiAgICAgIGlmICghd1N0YXRlIHx8IHdTdGF0ZS5hdXRvRGVzdHJveSAmJiB3U3RhdGUuZmluaXNoZWQpIHtcbiAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVhZGFibGUuZnJvbSA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgb3B0cykge1xuICAgIGlmIChmcm9tID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZyb20gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZnJvbScpO1xuICAgIH1cblxuICAgIHJldHVybiBmcm9tKFJlYWRhYmxlLCBpdGVyYWJsZSwgb3B0cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufSIsIi8qKlxuICogUGFyc2VzIGFuIFVSSVxuICpcbiAqIEBhdXRob3IgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+IChNSVQgbGljZW5zZSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciByZSA9IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKGh0dHB8aHR0cHN8d3N8d3NzKTpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO1xuXG52YXIgcGFydHMgPSBbXG4gICAgJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNldXJpKHN0cikge1xuICAgIHZhciBzcmMgPSBzdHIsXG4gICAgICAgIGIgPSBzdHIuaW5kZXhPZignWycpLFxuICAgICAgICBlID0gc3RyLmluZGV4T2YoJ10nKTtcblxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBiKSArIHN0ci5zdWJzdHJpbmcoYiwgZSkucmVwbGFjZSgvOi9nLCAnOycpICsgc3RyLnN1YnN0cmluZyhlLCBzdHIubGVuZ3RoKTtcbiAgICB9XG5cbiAgICB2YXIgbSA9IHJlLmV4ZWMoc3RyIHx8ICcnKSxcbiAgICAgICAgdXJpID0ge30sXG4gICAgICAgIGkgPSAxNDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdXJpW3BhcnRzW2ldXSA9IG1baV0gfHwgJyc7XG4gICAgfVxuXG4gICAgaWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xuICAgICAgICB1cmkuc291cmNlID0gc3JjO1xuICAgICAgICB1cmkuaG9zdCA9IHVyaS5ob3N0LnN1YnN0cmluZygxLCB1cmkuaG9zdC5sZW5ndGggLSAxKS5yZXBsYWNlKC87L2csICc6Jyk7XG4gICAgICAgIHVyaS5hdXRob3JpdHkgPSB1cmkuYXV0aG9yaXR5LnJlcGxhY2UoJ1snLCAnJykucmVwbGFjZSgnXScsICcnKS5yZXBsYWNlKC87L2csICc6Jyk7XG4gICAgICAgIHVyaS5pcHY2dXJpID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB1cmkucGF0aE5hbWVzID0gcGF0aE5hbWVzKHVyaSwgdXJpWydwYXRoJ10pO1xuICAgIHVyaS5xdWVyeUtleSA9IHF1ZXJ5S2V5KHVyaSwgdXJpWydxdWVyeSddKTtcblxuICAgIHJldHVybiB1cmk7XG59O1xuXG5mdW5jdGlvbiBwYXRoTmFtZXMob2JqLCBwYXRoKSB7XG4gICAgdmFyIHJlZ3ggPSAvXFwvezIsOX0vZyxcbiAgICAgICAgbmFtZXMgPSBwYXRoLnJlcGxhY2UocmVneCwgXCIvXCIpLnNwbGl0KFwiL1wiKTtcblxuICAgIGlmIChwYXRoLnN1YnN0cigwLCAxKSA9PSAnLycgfHwgcGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbmFtZXMuc3BsaWNlKDAsIDEpO1xuICAgIH1cbiAgICBpZiAocGF0aC5zdWJzdHIocGF0aC5sZW5ndGggLSAxLCAxKSA9PSAnLycpIHtcbiAgICAgICAgbmFtZXMuc3BsaWNlKG5hbWVzLmxlbmd0aCAtIDEsIDEpO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lcztcbn1cblxuZnVuY3Rpb24gcXVlcnlLZXkodXJpLCBxdWVyeSkge1xuICAgIHZhciBkYXRhID0ge307XG5cbiAgICBxdWVyeS5yZXBsYWNlKC8oPzpefCYpKFteJj1dKik9PyhbXiZdKikvZywgZnVuY3Rpb24gKCQwLCAkMSwgJDIpIHtcbiAgICAgICAgaWYgKCQxKSB7XG4gICAgICAgICAgICBkYXRhWyQxXSA9ICQyO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZGF0YTtcbn1cbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9uO1xuXG4vKipcbiAqIEhlbHBlciBmb3Igc3Vic2NyaXB0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxFdmVudEVtaXR0ZXJ9IG9iaiB3aXRoIGBFbWl0dGVyYCBtaXhpbiBvciBgRXZlbnRFbWl0dGVyYFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIG9uIChvYmosIGV2LCBmbikge1xuICBvYmoub24oZXYsIGZuKTtcbiAgcmV0dXJuIHtcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICBvYmoucmVtb3ZlTGlzdGVuZXIoZXYsIGZuKTtcbiAgICB9XG4gIH07XG59XG4iLCIvKipcbiAqIFNsaWNlIHJlZmVyZW5jZS5cbiAqL1xuXG52YXIgc2xpY2UgPSBbXS5zbGljZTtcblxuLyoqXG4gKiBCaW5kIGBvYmpgIHRvIGBmbmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGZuIG9yIHN0cmluZ1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBmbil7XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZm4pIGZuID0gb2JqW2ZuXTtcbiAgaWYgKCdmdW5jdGlvbicgIT0gdHlwZW9mIGZuKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmQoKSByZXF1aXJlcyBhIGZ1bmN0aW9uJyk7XG4gIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgfVxufTtcbiIsIi8qKlxuICogQ29tcGlsZXMgYSBxdWVyeXN0cmluZ1xuICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBzdHIgPSAnJztcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIGlmIChzdHIubGVuZ3RoKSBzdHIgKz0gJyYnO1xuICAgICAgc3RyICs9IGVuY29kZVVSSUNvbXBvbmVudChpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIHNpbXBsZSBxdWVyeXN0cmluZyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihxcyl7XG4gIHZhciBxcnkgPSB7fTtcbiAgdmFyIHBhaXJzID0gcXMuc3BsaXQoJyYnKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYWlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgcGFpciA9IHBhaXJzW2ldLnNwbGl0KCc9Jyk7XG4gICAgcXJ5W2RlY29kZVVSSUNvbXBvbmVudChwYWlyWzBdKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSk7XG4gIH1cbiAgcmV0dXJuIHFyeTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXlcblxuZnVuY3Rpb24gdG9BcnJheShsaXN0LCBpbmRleCkge1xuICAgIHZhciBhcnJheSA9IFtdXG5cbiAgICBpbmRleCA9IGluZGV4IHx8IDBcblxuICAgIGZvciAodmFyIGkgPSBpbmRleCB8fCAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVtpIC0gaW5kZXhdID0gbGlzdFtpXVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheVxufVxuIiwiLyogZ2xvYmFsIEJsb2IgRmlsZSAqL1xuXG4vKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciB3aXRoTmF0aXZlQmxvYiA9IHR5cGVvZiBCbG9iID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgdG9TdHJpbmcuY2FsbChCbG9iKSA9PT0gJ1tvYmplY3QgQmxvYkNvbnN0cnVjdG9yXSc7XG52YXIgd2l0aE5hdGl2ZUZpbGUgPSB0eXBlb2YgRmlsZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIEZpbGUgIT09ICd1bmRlZmluZWQnICYmIHRvU3RyaW5nLmNhbGwoRmlsZSkgPT09ICdbb2JqZWN0IEZpbGVDb25zdHJ1Y3Rvcl0nO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaGFzQmluYXJ5O1xuXG4vKipcbiAqIENoZWNrcyBmb3IgYmluYXJ5IGRhdGEuXG4gKlxuICogU3VwcG9ydHMgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQmxvYiBhbmQgRmlsZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYW55dGhpbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gaGFzQmluYXJ5IChvYmopIHtcbiAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoaGFzQmluYXJ5KG9ialtpXSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICgodHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBCdWZmZXIuaXNCdWZmZXIgJiYgQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgKHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHxcbiAgICAod2l0aE5hdGl2ZUJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAod2l0aE5hdGl2ZUZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSlcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2hhcy1iaW5hcnkvcHVsbC80XG4gIGlmIChvYmoudG9KU09OICYmIHR5cGVvZiBvYmoudG9KU09OID09PSAnZnVuY3Rpb24nICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gaGFzQmluYXJ5KG9iai50b0pTT04oKSwgdHJ1ZSk7XG4gIH1cblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgaGFzQmluYXJ5KG9ialtrZXldKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICovXG5leHBvcnRzLmluc3RhbmNlcyA9IFtdO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gIHZhciBoYXNoID0gMCwgaTtcblxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICB2YXIgcHJldlRpbWU7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG4gIGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG4gIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XG4gICAgZXhwb3J0cy5pbml0KGRlYnVnKTtcbiAgfVxuXG4gIGV4cG9ydHMuaW5zdGFuY2VzLnB1c2goZGVidWcpO1xuXG4gIHJldHVybiBkZWJ1Zztcbn1cblxuZnVuY3Rpb24gZGVzdHJveSAoKSB7XG4gIHZhciBpbmRleCA9IGV4cG9ydHMuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBleHBvcnRzLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBpO1xuICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwb3J0cy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBleHBvcnRzLmluc3RhbmNlc1tpXTtcbiAgICBpbnN0YW5jZS5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gaXNCdWY7XG5cbnZhciB3aXRoTmF0aXZlQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgQnVmZmVyLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nO1xudmFyIHdpdGhOYXRpdmVBcnJheUJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIGlzVmlldyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgPyBBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKSA6IChvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqIGlzIGEgYnVmZmVyIG9yIGFuIGFycmF5YnVmZmVyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzQnVmKG9iaikge1xuICByZXR1cm4gKHdpdGhOYXRpdmVCdWZmZXIgJiYgQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICAgICAgKHdpdGhOYXRpdmVBcnJheUJ1ZmZlciAmJiAob2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgaXNWaWV3KG9iaikpKTtcbn1cbiIsIi8qZ2xvYmFsIEJsb2IsRmlsZSovXG5cbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50c1xuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgd2l0aE5hdGl2ZUJsb2IgPSB0eXBlb2YgQmxvYiA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIHRvU3RyaW5nLmNhbGwoQmxvYikgPT09ICdbb2JqZWN0IEJsb2JDb25zdHJ1Y3Rvcl0nKTtcbnZhciB3aXRoTmF0aXZlRmlsZSA9IHR5cGVvZiBGaWxlID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdG9TdHJpbmcuY2FsbChGaWxlKSA9PT0gJ1tvYmplY3QgRmlsZUNvbnN0cnVjdG9yXScpO1xuXG4vKipcbiAqIFJlcGxhY2VzIGV2ZXJ5IEJ1ZmZlciB8IEFycmF5QnVmZmVyIGluIHBhY2tldCB3aXRoIGEgbnVtYmVyZWQgcGxhY2Vob2xkZXIuXG4gKiBBbnl0aGluZyB3aXRoIGJsb2JzIG9yIGZpbGVzIHNob3VsZCBiZSBmZWQgdGhyb3VnaCByZW1vdmVCbG9icyBiZWZvcmUgY29taW5nXG4gKiBoZXJlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBzb2NrZXQuaW8gZXZlbnQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggZGVjb25zdHJ1Y3RlZCBwYWNrZXQgYW5kIGxpc3Qgb2YgYnVmZmVyc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHZhciBidWZmZXJzID0gW107XG4gIHZhciBwYWNrZXREYXRhID0gcGFja2V0LmRhdGE7XG4gIHZhciBwYWNrID0gcGFja2V0O1xuICBwYWNrLmRhdGEgPSBfZGVjb25zdHJ1Y3RQYWNrZXQocGFja2V0RGF0YSwgYnVmZmVycyk7XG4gIHBhY2suYXR0YWNobWVudHMgPSBidWZmZXJzLmxlbmd0aDsgLy8gbnVtYmVyIG9mIGJpbmFyeSAnYXR0YWNobWVudHMnXG4gIHJldHVybiB7cGFja2V0OiBwYWNrLCBidWZmZXJzOiBidWZmZXJzfTtcbn07XG5cbmZ1bmN0aW9uIF9kZWNvbnN0cnVjdFBhY2tldChkYXRhLCBidWZmZXJzKSB7XG4gIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XG5cbiAgaWYgKGlzQnVmKGRhdGEpKSB7XG4gICAgdmFyIHBsYWNlaG9sZGVyID0geyBfcGxhY2Vob2xkZXI6IHRydWUsIG51bTogYnVmZmVycy5sZW5ndGggfTtcbiAgICBidWZmZXJzLnB1c2goZGF0YSk7XG4gICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICB2YXIgbmV3RGF0YSA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuZXdEYXRhW2ldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFbaV0sIGJ1ZmZlcnMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RGF0YTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgIShkYXRhIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICB2YXIgbmV3RGF0YSA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICBuZXdEYXRhW2tleV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldLCBidWZmZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0RhdGE7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogUmVjb25zdHJ1Y3RzIGEgYmluYXJ5IHBhY2tldCBmcm9tIGl0cyBwbGFjZWhvbGRlciBwYWNrZXQgYW5kIGJ1ZmZlcnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gZXZlbnQgcGFja2V0IHdpdGggcGxhY2Vob2xkZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBidWZmZXJzIC0gYmluYXJ5IGJ1ZmZlcnMgdG8gcHV0IGluIHBsYWNlaG9sZGVyIHBvc2l0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSByZWNvbnN0cnVjdGVkIHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnJlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBidWZmZXJzKSB7XG4gIHBhY2tldC5kYXRhID0gX3JlY29uc3RydWN0UGFja2V0KHBhY2tldC5kYXRhLCBidWZmZXJzKTtcbiAgcGFja2V0LmF0dGFjaG1lbnRzID0gdW5kZWZpbmVkOyAvLyBubyBsb25nZXIgdXNlZnVsXG4gIHJldHVybiBwYWNrZXQ7XG59O1xuXG5mdW5jdGlvbiBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YSwgYnVmZmVycykge1xuICBpZiAoIWRhdGEpIHJldHVybiBkYXRhO1xuXG4gIGlmIChkYXRhICYmIGRhdGEuX3BsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuIGJ1ZmZlcnNbZGF0YS5udW1dOyAvLyBhcHByb3ByaWF0ZSBidWZmZXIgKHNob3VsZCBiZSBuYXR1cmFsIG9yZGVyIGFueXdheSlcbiAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhW2ldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFbaV0sIGJ1ZmZlcnMpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgZGF0YVtrZXldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSwgYnVmZmVycyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgcmVtb3ZlcyBCbG9icyBvciBGaWxlcyBmcm9tIGRhdGEgdmlhXG4gKiBGaWxlUmVhZGVyJ3MgcmVhZEFzQXJyYXlCdWZmZXIgbWV0aG9kLiBVc2VkIGJlZm9yZSBlbmNvZGluZ1xuICogZGF0YSBhcyBtc2dwYWNrLiBDYWxscyBjYWxsYmFjayB3aXRoIHRoZSBibG9ibGVzcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5yZW1vdmVCbG9icyA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIF9yZW1vdmVCbG9icyhvYmosIGN1cktleSwgY29udGFpbmluZ09iamVjdCkge1xuICAgIGlmICghb2JqKSByZXR1cm4gb2JqO1xuXG4gICAgLy8gY29udmVydCBhbnkgYmxvYlxuICAgIGlmICgod2l0aE5hdGl2ZUJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgKHdpdGhOYXRpdmVGaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpKSB7XG4gICAgICBwZW5kaW5nQmxvYnMrKztcblxuICAgICAgLy8gYXN5bmMgZmlsZXJlYWRlclxuICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHsgLy8gdGhpcy5yZXN1bHQgPT0gYXJyYXlidWZmZXJcbiAgICAgICAgaWYgKGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICAgICAgICBjb250YWluaW5nT2JqZWN0W2N1cktleV0gPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBibG9ibGVzc0RhdGEgPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vdGhpbmcgcGVuZGluZyBpdHMgY2FsbGJhY2sgdGltZVxuICAgICAgICBpZighIC0tcGVuZGluZ0Jsb2JzKSB7XG4gICAgICAgICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihvYmopOyAvLyBibG9iIC0+IGFycmF5YnVmZmVyXG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9iaikpIHsgLy8gaGFuZGxlIGFycmF5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2ldLCBpLCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgIWlzQnVmKG9iaikpIHsgLy8gYW5kIG9iamVjdFxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcGVuZGluZ0Jsb2JzID0gMDtcbiAgdmFyIGJsb2JsZXNzRGF0YSA9IGRhdGE7XG4gIF9yZW1vdmVCbG9icyhibG9ibGVzc0RhdGEpO1xuICBpZiAoIXBlbmRpbmdCbG9icykge1xuICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gIH1cbn07XG4iLCIvKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICcjMDAwMENDJywgJyMwMDAwRkYnLCAnIzAwMzNDQycsICcjMDAzM0ZGJywgJyMwMDY2Q0MnLCAnIzAwNjZGRicsICcjMDA5OUNDJyxcbiAgJyMwMDk5RkYnLCAnIzAwQ0MwMCcsICcjMDBDQzMzJywgJyMwMENDNjYnLCAnIzAwQ0M5OScsICcjMDBDQ0NDJywgJyMwMENDRkYnLFxuICAnIzMzMDBDQycsICcjMzMwMEZGJywgJyMzMzMzQ0MnLCAnIzMzMzNGRicsICcjMzM2NkNDJywgJyMzMzY2RkYnLCAnIzMzOTlDQycsXG4gICcjMzM5OUZGJywgJyMzM0NDMDAnLCAnIzMzQ0MzMycsICcjMzNDQzY2JywgJyMzM0NDOTknLCAnIzMzQ0NDQycsICcjMzNDQ0ZGJyxcbiAgJyM2NjAwQ0MnLCAnIzY2MDBGRicsICcjNjYzM0NDJywgJyM2NjMzRkYnLCAnIzY2Q0MwMCcsICcjNjZDQzMzJywgJyM5OTAwQ0MnLFxuICAnIzk5MDBGRicsICcjOTkzM0NDJywgJyM5OTMzRkYnLCAnIzk5Q0MwMCcsICcjOTlDQzMzJywgJyNDQzAwMDAnLCAnI0NDMDAzMycsXG4gICcjQ0MwMDY2JywgJyNDQzAwOTknLCAnI0NDMDBDQycsICcjQ0MwMEZGJywgJyNDQzMzMDAnLCAnI0NDMzMzMycsICcjQ0MzMzY2JyxcbiAgJyNDQzMzOTknLCAnI0NDMzNDQycsICcjQ0MzM0ZGJywgJyNDQzY2MDAnLCAnI0NDNjYzMycsICcjQ0M5OTAwJywgJyNDQzk5MzMnLFxuICAnI0NDQ0MwMCcsICcjQ0NDQzMzJywgJyNGRjAwMDAnLCAnI0ZGMDAzMycsICcjRkYwMDY2JywgJyNGRjAwOTknLCAnI0ZGMDBDQycsXG4gICcjRkYwMEZGJywgJyNGRjMzMDAnLCAnI0ZGMzMzMycsICcjRkYzMzY2JywgJyNGRjMzOTknLCAnI0ZGMzNDQycsICcjRkYzM0ZGJyxcbiAgJyNGRjY2MDAnLCAnI0ZGNjYzMycsICcjRkY5OTAwJywgJyNGRjk5MzMnLCAnI0ZGQ0MwMCcsICcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuICByZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcbiAgICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0JylcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuIiwiXG4vKipcbiAqIEV4cG9zZSBgQmFja29mZmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrb2ZmO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYmFja29mZiB0aW1lciB3aXRoIGBvcHRzYC5cbiAqXG4gKiAtIGBtaW5gIGluaXRpYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgWzEwMF1cbiAqIC0gYG1heGAgbWF4IHRpbWVvdXQgWzEwMDAwXVxuICogLSBgaml0dGVyYCBbMF1cbiAqIC0gYGZhY3RvcmAgWzJdXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gQmFja29mZihvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB0aGlzLm1zID0gb3B0cy5taW4gfHwgMTAwO1xuICB0aGlzLm1heCA9IG9wdHMubWF4IHx8IDEwMDAwO1xuICB0aGlzLmZhY3RvciA9IG9wdHMuZmFjdG9yIHx8IDI7XG4gIHRoaXMuaml0dGVyID0gb3B0cy5qaXR0ZXIgPiAwICYmIG9wdHMuaml0dGVyIDw9IDEgPyBvcHRzLmppdHRlciA6IDA7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgYmFja29mZiBkdXJhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24oKXtcbiAgdmFyIG1zID0gdGhpcy5tcyAqIE1hdGgucG93KHRoaXMuZmFjdG9yLCB0aGlzLmF0dGVtcHRzKyspO1xuICBpZiAodGhpcy5qaXR0ZXIpIHtcbiAgICB2YXIgcmFuZCA9ICBNYXRoLnJhbmRvbSgpO1xuICAgIHZhciBkZXZpYXRpb24gPSBNYXRoLmZsb29yKHJhbmQgKiB0aGlzLmppdHRlciAqIG1zKTtcbiAgICBtcyA9IChNYXRoLmZsb29yKHJhbmQgKiAxMCkgJiAxKSA9PSAwICA/IG1zIC0gZGV2aWF0aW9uIDogbXMgKyBkZXZpYXRpb247XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluKG1zLCB0aGlzLm1heCkgfCAwO1xufTtcblxuLyoqXG4gKiBSZXNldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtaW5pbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNaW4gPSBmdW5jdGlvbihtaW4pe1xuICB0aGlzLm1zID0gbWluO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heGltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1heCA9IGZ1bmN0aW9uKG1heCl7XG4gIHRoaXMubWF4ID0gbWF4O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGppdHRlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0Sml0dGVyID0gZnVuY3Rpb24oaml0dGVyKXtcbiAgdGhpcy5qaXR0ZXIgPSBqaXR0ZXI7XG59O1xuXG4iLCJcbnZhciBpbmRleE9mID0gW10uaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChpbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn07IiwiXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG5cbi8qKlxuICogRXhwb3J0cyBwYXJzZXJcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMucGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBQUk9UT0NPTDogJy9pcGZzL3BpbmcvMS4wLjAnLFxuICBQSU5HX0xFTkdUSDogMzJcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdsaWJwMnAtY3J5cHRvJylcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzXG5cbmV4cG9ydHMucm5kID0gKGxlbmd0aCkgPT4ge1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IGNvbnN0YW50cy5QSU5HX0xFTkdUSFxuICB9XG4gIHJldHVybiBjcnlwdG8ucmFuZG9tQnl0ZXMobGVuZ3RoKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuXG5jb25zdCBsb2cgPSBkZWJ1ZygnbGlicDJwOmZsb29kc3ViJylcbmxvZy5lcnIgPSBkZWJ1ZygnbGlicDJwOmZsb29kc3ViOmVycm9yJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxvZzogbG9nLFxuICBtdWx0aWNvZGVjOiAnL2Zsb29kc3ViLzEuMC4wJ1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpXG5jb25zdCBwdWxsID0gcmVxdWlyZSgncHVsbC1zdHJlYW0vcHVsbCcpXG5jb25zdCBlbXB0eSA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtL3NvdXJjZXMvZW1wdHknKVxuY29uc3QgYXN5bmNFYWNoID0gcmVxdWlyZSgnYXN5bmMvZWFjaCcpXG5jb25zdCBUaW1lQ2FjaGUgPSByZXF1aXJlKCd0aW1lLWNhY2hlJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuY29uc3QgZXJyY29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcblxuY29uc3QgUGVlciA9IHJlcXVpcmUoJy4vcGVlcicpXG5jb25zdCBtZXNzYWdlID0gcmVxdWlyZSgnLi9tZXNzYWdlJylcbmNvbnN0IHsgc2lnbk1lc3NhZ2UgfSA9IHJlcXVpcmUoJy4vbWVzc2FnZS9zaWduJylcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpXG5cbmNvbnN0IG5leHRUaWNrID0gcmVxdWlyZSgnYXN5bmMvbmV4dFRpY2snKVxuXG4vKipcbiAqIFB1YnN1YkJhc2VQcm90b2NvbCBoYW5kbGVzIHRoZSBwZWVycyBhbmQgY29ubmVjdGlvbnMgbG9naWMgZm9yIHB1YnN1YiByb3V0ZXJzXG4gKi9cbmNsYXNzIFB1YnN1YkJhc2VQcm90b2NvbCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGVidWdOYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtdWx0aWNvZGVjXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsaWJwMnAgbGlicDJwIGltcGxlbWVudGF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zaWduTWVzc2FnZXMgaWYgbWVzc2FnZXMgc2hvdWxkIGJlIHNpZ25lZCwgZGVmYXVsdHMgdG8gdHJ1ZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkZWJ1Z05hbWUsIG11bHRpY29kZWMsIGxpYnAycCwgb3B0aW9ucykge1xuICAgIHN1cGVyKClcblxuICAgIG9wdGlvbnMgPSB7XG4gICAgICBzaWduTWVzc2FnZXM6IHRydWUsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfVxuXG4gICAgdGhpcy5sb2cgPSBkZWJ1ZyhkZWJ1Z05hbWUpXG4gICAgdGhpcy5sb2cuZXJyID0gZGVidWcoYCR7ZGVidWdOYW1lfTplcnJvcmApXG4gICAgdGhpcy5tdWx0aWNvZGVjID0gbXVsdGljb2RlY1xuICAgIHRoaXMubGlicDJwID0gbGlicDJwXG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2VcblxuICAgIGlmIChvcHRpb25zLnNpZ25NZXNzYWdlcykge1xuICAgICAgdGhpcy5wZWVySWQgPSB0aGlzLmxpYnAycC5wZWVySW5mby5pZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcCBvZiB0b3BpY3MgdG8gd2hpY2ggcGVlcnMgYXJlIHN1YnNjcmliZWQgdG9cbiAgICAgKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLCBQZWVyPn1cbiAgICAgKi9cbiAgICB0aGlzLnRvcGljcyA9IG5ldyBNYXAoKVxuXG4gICAgLyoqXG4gICAgICogQ2FjaGUgb2Ygc2VlbiBtZXNzYWdlc1xuICAgICAqXG4gICAgICogQHR5cGUge1RpbWVDYWNoZX1cbiAgICAgKi9cbiAgICB0aGlzLnNlZW5DYWNoZSA9IG5ldyBUaW1lQ2FjaGUoKVxuXG4gICAgLyoqXG4gICAgICogTWFwIG9mIHBlZXJzLlxuICAgICAqXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsIFBlZXI+fVxuICAgICAqL1xuICAgIHRoaXMucGVlcnMgPSBuZXcgTWFwKClcblxuICAgIC8vIERpYWxzIHRoYXQgYXJlIGN1cnJlbnRseSBpbiBwcm9ncmVzc1xuICAgIHRoaXMuX2RpYWxzID0gbmV3IFNldCgpXG5cbiAgICB0aGlzLl9vbkNvbm5lY3Rpb24gPSB0aGlzLl9vbkNvbm5lY3Rpb24uYmluZCh0aGlzKVxuICAgIHRoaXMuX2RpYWxQZWVyID0gdGhpcy5fZGlhbFBlZXIuYmluZCh0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBjb25uZWN0ZWQgcGVlciB0byB0aGUgcGVlcnMgbWFwLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1BlZXJJbmZvfSBwZWVyIHBlZXIgaW5mb1xuICAgKiBAcmV0dXJucyB7UGVlckluZm99XG4gICAqL1xuICBfYWRkUGVlciAocGVlcikge1xuICAgIGNvbnN0IGlkID0gcGVlci5pbmZvLmlkLnRvQjU4U3RyaW5nKClcblxuICAgIC8qXG4gICAgICBBbHdheXMgdXNlIGFuIGV4aXN0aW5nIHBlZXIuXG5cbiAgICAgIFdoYXQgaXMgaGFwcGVuaW5nIGhlcmUgaXM6IFwiSWYgdGhlIG90aGVyIHBlZXIgaGFzIGFscmVhZHkgZGlhbGVkIHRvIG1lLCB3ZSBhbHJlYWR5IGhhdmVcbiAgICAgIGFuIGVzdGFibGlzaCBsaW5rIGJldHdlZW4gdGhlIHR3bywgd2hhdCBtaWdodCBiZSBtaXNzaW5nIGlzIGFcbiAgICAgIENvbm5lY3Rpb24gc3BlY2lmaWNhbGx5IGJldHdlZW4gbWUgYW5kIHRoYXQgUGVlclwiXG4gICAgICovXG4gICAgbGV0IGV4aXN0aW5nID0gdGhpcy5wZWVycy5nZXQoaWQpXG4gICAgaWYgKCFleGlzdGluZykge1xuICAgICAgdGhpcy5sb2coJ25ldyBwZWVyJywgaWQpXG4gICAgICB0aGlzLnBlZXJzLnNldChpZCwgcGVlcilcbiAgICAgIGV4aXN0aW5nID0gcGVlclxuXG4gICAgICBwZWVyLm9uY2UoJ2Nsb3NlJywgKCkgPT4gdGhpcy5fcmVtb3ZlUGVlcihwZWVyKSlcbiAgICB9XG4gICAgKytleGlzdGluZy5fcmVmZXJlbmNlc1xuXG4gICAgcmV0dXJuIGV4aXN0aW5nXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgcGVlciBmcm9tIHRoZSBwZWVycyBtYXAgaWYgaXQgaGFzIG5vIHJlZmVyZW5jZXMuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UGVlcn0gcGVlciBwZWVyIHN0YXRlXG4gICAqIEByZXR1cm5zIHtQZWVySW5mb31cbiAgICovXG4gIF9yZW1vdmVQZWVyIChwZWVyKSB7XG4gICAgY29uc3QgaWQgPSBwZWVyLmluZm8uaWQudG9CNThTdHJpbmcoKVxuXG4gICAgdGhpcy5sb2coJ3JlbW92ZScsIGlkLCBwZWVyLl9yZWZlcmVuY2VzKVxuICAgIC8vIE9ubHkgZGVsZXRlIHdoZW4gbm8gb25lIGVsc2UgaXMgcmVmZXJlbmNpbmcgdGhpcyBwZWVyLlxuICAgIGlmICgtLXBlZXIuX3JlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgIHRoaXMubG9nKCdkZWxldGUgcGVlcicsIGlkKVxuICAgICAgdGhpcy5wZWVycy5kZWxldGUoaWQpXG4gICAgfVxuXG4gICAgcmV0dXJuIHBlZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBEaWFsIGEgcmVjZWl2ZWQgcGVlci5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtQZWVySW5mb30gcGVlckluZm8gcGVlciBpbmZvXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgX2RpYWxQZWVyIChwZWVySW5mbywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uIG5vb3AgKCkgeyB9XG4gICAgY29uc3QgaWRCNThTdHIgPSBwZWVySW5mby5pZC50b0I1OFN0cmluZygpXG5cbiAgICAvLyBJZiBhbHJlYWR5IGhhdmUgYSBQdWJTdWIgY29ubiwgaWdub3JlXG4gICAgY29uc3QgcGVlciA9IHRoaXMucGVlcnMuZ2V0KGlkQjU4U3RyKVxuICAgIGlmIChwZWVyICYmIHBlZXIuaXNDb25uZWN0ZWQpIHtcbiAgICAgIHJldHVybiBuZXh0VGljaygoKSA9PiBjYWxsYmFjaygpKVxuICAgIH1cblxuICAgIC8vIElmIGFscmVhZHkgZGlhbGluZyB0aGlzIHBlZXIsIGlnbm9yZVxuICAgIGlmICh0aGlzLl9kaWFscy5oYXMoaWRCNThTdHIpKSB7XG4gICAgICB0aGlzLmxvZygnYWxyZWFkeSBkaWFsaW5nICVzLCBpZ25vcmluZyBkaWFsIGF0dGVtcHQnLCBpZEI1OFN0cilcbiAgICAgIHJldHVybiBuZXh0VGljaygoKSA9PiBjYWxsYmFjaygpKVxuICAgIH1cbiAgICB0aGlzLl9kaWFscy5hZGQoaWRCNThTdHIpXG5cbiAgICB0aGlzLmxvZygnZGlhbGluZyAlcycsIGlkQjU4U3RyKVxuICAgIHRoaXMubGlicDJwLmRpYWxQcm90b2NvbChwZWVySW5mbywgdGhpcy5tdWx0aWNvZGVjLCAoZXJyLCBjb25uKSA9PiB7XG4gICAgICB0aGlzLmxvZygnZGlhbCB0byAlcyBjb21wbGV0ZScsIGlkQjU4U3RyKVxuXG4gICAgICAvLyBJZiB0aGUgZGlhbCBpcyBub3QgaW4gdGhlIHNldCwgaXQgbWVhbnMgdGhhdCBwdWJzdWIgaGFzIGJlZW5cbiAgICAgIC8vIHN0b3BwZWRcbiAgICAgIGNvbnN0IHB1YnN1YlN0b3BwZWQgPSAhdGhpcy5fZGlhbHMuaGFzKGlkQjU4U3RyKVxuICAgICAgdGhpcy5fZGlhbHMuZGVsZXRlKGlkQjU4U3RyKVxuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoaXMubG9nLmVycihlcnIpXG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpXG4gICAgICB9XG5cbiAgICAgIC8vIHB1YnN1YiBoYXMgYmVlbiBzdG9wcGVkLCBzbyB3ZSBzaG91bGQganVzdCBiYWlsIG91dFxuICAgICAgaWYgKHB1YnN1YlN0b3BwZWQpIHtcbiAgICAgICAgdGhpcy5sb2coJ3B1YnN1YiB3YXMgc3RvcHBlZCwgbm90IHByb2Nlc3NpbmcgZGlhbCB0byAlcycsIGlkQjU4U3RyKVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9vbkRpYWwocGVlckluZm8sIGNvbm4sIGNhbGxiYWNrKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRGlhbCBhIHJlY2VpdmVkIHBlZXIuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UGVlckluZm99IHBlZXJJbmZvIHBlZXIgaW5mb1xuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm4gY29ubmVjdGlvbiB0byB0aGUgcGVlclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgX29uRGlhbCAocGVlckluZm8sIGNvbm4sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgaWRCNThTdHIgPSBwZWVySW5mby5pZC50b0I1OFN0cmluZygpXG4gICAgdGhpcy5sb2coJ2Nvbm5lY3RlZCcsIGlkQjU4U3RyKVxuXG4gICAgY29uc3QgcGVlciA9IHRoaXMuX2FkZFBlZXIobmV3IFBlZXIocGVlckluZm8pKVxuICAgIHBlZXIuYXR0YWNoQ29ubmVjdGlvbihjb25uKVxuXG4gICAgbmV4dFRpY2soKCkgPT4gY2FsbGJhY2soKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBzdWNjZXNzZnVsIGNvbm5lY3Rpb24gZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbCBjb25uZWN0aW9uIHByb3RvY29sXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubiBjb25uZWN0aW9uIHRvIHRoZSBwZWVyXG4gICAqL1xuICBfb25Db25uZWN0aW9uIChwcm90b2NvbCwgY29ubikge1xuICAgIGNvbm4uZ2V0UGVlckluZm8oKGVyciwgcGVlckluZm8pID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5sb2cuZXJyKCdGYWlsZWQgdG8gaWRlbnRpZnkgaW5jb21taW5nIGNvbm4nLCBlcnIpXG4gICAgICAgIHJldHVybiBwdWxsKGVtcHR5KCksIGNvbm4pXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlkQjU4U3RyID0gcGVlckluZm8uaWQudG9CNThTdHJpbmcoKVxuICAgICAgY29uc3QgcGVlciA9IHRoaXMuX2FkZFBlZXIobmV3IFBlZXIocGVlckluZm8pKVxuXG4gICAgICB0aGlzLl9wcm9jZXNzQ29ubmVjdGlvbihpZEI1OFN0ciwgY29ubiwgcGVlcilcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRpbmcgdGhlIGltcGxlbWVudGF0aW9uIG9mIF9wcm9jZXNzQ29ubmVjdGlvbiBzaG91bGQga2VlcCB0aGUgY29ubmVjdGlvbiBhbmQgaXNcbiAgICogcmVzcG9uc2libGUgZm9yIHByb2Nlc3NpbmcgZWFjaCBSUEMgbWVzc2FnZSByZWNlaXZlZCBieSBvdGhlciBwZWVycy5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZEI1OFN0ciBwZWVyIGlkIHN0cmluZyBpbiBiYXNlNThcbiAgICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uIGNvbm5lY3Rpb25cbiAgICogQHBhcmFtIHtQZWVySW5mb30gcGVlciBwZWVyIGluZm9cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICpcbiAgICovXG4gIF9wcm9jZXNzQ29ubmVjdGlvbiAoaWRCNThTdHIsIGNvbm4sIHBlZXIpIHtcbiAgICB0aHJvdyBlcnJjb2RlKCdfcHJvY2Vzc0Nvbm5lY3Rpb24gbXVzdCBiZSBpbXBsZW1lbnRlZCBieSB0aGUgc3ViY2xhc3MnLCAnRVJSX05PVF9JTVBMRU1FTlRFRCcpXG4gIH1cblxuICAvKipcbiAgICogT24gY29ubmVjdGlvbiBlbmQgZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZEI1OFN0ciBwZWVyIGlkIHN0cmluZyBpbiBiYXNlNThcbiAgICogQHBhcmFtIHtQZWVySW5mb30gcGVlciBwZWVyIGluZm9cbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyIGVycm9yIGZvciBjb25uZWN0aW9uIGVuZFxuICAgKi9cbiAgX29uQ29ubmVjdGlvbkVuZCAoaWRCNThTdHIsIHBlZXIsIGVycikge1xuICAgIC8vIHNvY2tldCBoYW5nIHVwLCBtZWFucyB0aGUgb25lIHNpZGUgY2FuY2VsZWRcbiAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlICE9PSAnc29ja2V0IGhhbmcgdXAnKSB7XG4gICAgICB0aGlzLmxvZy5lcnIoZXJyKVxuICAgIH1cblxuICAgIHRoaXMubG9nKCdjb25uZWN0aW9uIGVuZGVkJywgaWRCNThTdHIsIGVyciA/IGVyci5tZXNzYWdlIDogJycpXG4gICAgdGhpcy5fcmVtb3ZlUGVlcihwZWVyKVxuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgdGhlIG1lc3NhZ2UgYW5kIHNpZ25zIGl0LCBpZiBzaWduaW5nIGlzIGVuYWJsZWRcbiAgICpcbiAgICogQHBhcmFtIHtNZXNzYWdlfSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIE1lc3NhZ2UpfSBjYWxsYmFja1xuICAgKi9cbiAgX2J1aWxkTWVzc2FnZSAobWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBtc2cgPSB1dGlscy5ub3JtYWxpemVPdXRScGNNZXNzYWdlKG1lc3NhZ2UpXG4gICAgaWYgKHRoaXMucGVlcklkKSB7XG4gICAgICBzaWduTWVzc2FnZSh0aGlzLnBlZXJJZCwgbXNnLCBjYWxsYmFjaylcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFRpY2soY2FsbGJhY2ssIG51bGwsIG1zZylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGluZyB0aGUgaW1wbGVtZW50YXRpb24gb2YgcHVibGlzaCBzaG91bGQgaGFuZGxlIHRoZSBhcHByb3ByaWF0ZSBhbGdvcml0aG1zIGZvciB0aGUgcHVibGlzaC9zdWJzY3JpYmVyIGltcGxlbWVudGF0aW9uLlxuICAgKiBGb3IgZXhhbXBsZSwgYSBGbG9vZHN1YiBpbXBsZW1lbnRhdGlvbiBtaWdodCBzaW1wbHkgcHVibGlzaCBlYWNoIG1lc3NhZ2UgdG8gZWFjaCB0b3BpYyBmb3IgZXZlcnkgcGVlclxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fHN0cmluZ30gdG9waWNzXG4gICAqIEBwYXJhbSB7QXJyYXk8YW55Pnxhbnl9IG1lc3NhZ2VzXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKlxuICAgKi9cbiAgcHVibGlzaCAodG9waWNzLCBtZXNzYWdlcywgY2FsbGJhY2spIHtcbiAgICB0aHJvdyBlcnJjb2RlKCdwdWJsaXNoIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgdGhlIHN1YmNsYXNzJywgJ0VSUl9OT1RfSU1QTEVNRU5URUQnKVxuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRpbmcgdGhlIGltcGxlbWVudGF0aW9uIG9mIHN1YnNjcmliZSBzaG91bGQgaGFuZGxlIHRoZSBhcHByb3ByaWF0ZSBhbGdvcml0aG1zIGZvciB0aGUgcHVibGlzaC9zdWJzY3JpYmVyIGltcGxlbWVudGF0aW9uLlxuICAgKiBGb3IgZXhhbXBsZSwgYSBGbG9vZHN1YiBpbXBsZW1lbnRhdGlvbiBtaWdodCBzaW1wbHkgc2VuZCBhIG1lc3NhZ2UgZm9yIGV2ZXJ5IHBlZXIgc2hvd2luZyBpbnRlcmVzdCBpbiB0aGUgdG9waWNzXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz58c3RyaW5nfSB0b3BpY3NcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIHN1YnNjcmliZSAodG9waWNzKSB7XG4gICAgdGhyb3cgZXJyY29kZSgnc3Vic2NyaWJlIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgdGhlIHN1YmNsYXNzJywgJ0VSUl9OT1RfSU1QTEVNRU5URUQnKVxuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRpbmcgdGhlIGltcGxlbWVudGF0aW9uIG9mIHVuc3Vic2NyaWJlIHNob3VsZCBoYW5kbGUgdGhlIGFwcHJvcHJpYXRlIGFsZ29yaXRobXMgZm9yIHRoZSBwdWJsaXNoL3N1YnNjcmliZXIgaW1wbGVtZW50YXRpb24uXG4gICAqIEZvciBleGFtcGxlLCBhIEZsb29kc3ViIGltcGxlbWVudGF0aW9uIG1pZ2h0IHNpbXBseSBzZW5kIGEgbWVzc2FnZSBmb3IgZXZlcnkgcGVlciByZXZva2luZyBpbnRlcmVzdCBpbiB0aGUgdG9waWNzXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz58c3RyaW5nfSB0b3BpY3NcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIHVuc3Vic2NyaWJlICh0b3BpY3MpIHtcbiAgICB0aHJvdyBlcnJjb2RlKCd1bnN1YnNjcmliZSBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IHRoZSBzdWJjbGFzcycsICdFUlJfTk9UX0lNUExFTUVOVEVEJylcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3VudHMgdGhlIHB1YnN1YiBwcm90b2NvbCBvbnRvIHRoZSBsaWJwMnAgbm9kZSBhbmQgc2VuZHMgb3VyXG4gICAqIHN1YnNjcmlwdGlvbnMgdG8gZXZlcnkgcGVlciBjb25uZWNldGVkXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqXG4gICAqL1xuICBzdGFydCAoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICByZXR1cm4gbmV4dFRpY2soKCkgPT4gY2FsbGJhY2sobmV3IEVycm9yKCdhbHJlYWR5IHN0YXJ0ZWQnKSkpXG4gICAgfVxuICAgIHRoaXMubG9nKCdzdGFydGluZycpXG5cbiAgICB0aGlzLmxpYnAycC5oYW5kbGUodGhpcy5tdWx0aWNvZGVjLCB0aGlzLl9vbkNvbm5lY3Rpb24pXG5cbiAgICAvLyBTcGVlZCB1cCBhbnkgbmV3IHBlZXIgdGhhdCBjb21lcyBpbiBteSB3YXlcbiAgICB0aGlzLmxpYnAycC5vbigncGVlcjpjb25uZWN0JywgdGhpcy5fZGlhbFBlZXIpXG5cbiAgICAvLyBEaWFsIGFscmVhZHkgY29ubmVjdGVkIHBlZXJzXG4gICAgY29uc3QgcGVlckluZm9zID0gT2JqZWN0LnZhbHVlcyh0aGlzLmxpYnAycC5wZWVyQm9vay5nZXRBbGwoKSlcblxuICAgIGFzeW5jRWFjaChwZWVySW5mb3MsIChwZWVyLCBjYikgPT4gdGhpcy5fZGlhbFBlZXIocGVlciwgY2IpLCAoZXJyKSA9PiB7XG4gICAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMubG9nKCdzdGFydGVkJylcbiAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZVxuICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogVW5tb3VudHMgdGhlIHB1YnN1YiBwcm90b2NvbCBhbmQgc2h1dHMgZG93biBldmVyeSBjb25uZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqXG4gICAqL1xuICBzdG9wIChjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICByZXR1cm4gbmV4dFRpY2soKCkgPT4gY2FsbGJhY2sobmV3IEVycm9yKCdub3Qgc3RhcnRlZCB5ZXQnKSkpXG4gICAgfVxuXG4gICAgdGhpcy5saWJwMnAudW5oYW5kbGUodGhpcy5tdWx0aWNvZGVjKVxuICAgIHRoaXMubGlicDJwLnJlbW92ZUxpc3RlbmVyKCdwZWVyOmNvbm5lY3QnLCB0aGlzLl9kaWFsUGVlcilcblxuICAgIC8vIFByZXZlbnQgYW55IGRpYWxzIHRoYXQgYXJlIGluIGZsaWdodCBmcm9tIGJlaW5nIHByb2Nlc3NlZFxuICAgIHRoaXMuX2RpYWxzID0gbmV3IFNldCgpXG5cbiAgICB0aGlzLmxvZygnc3RvcHBpbmcnKVxuICAgIGFzeW5jRWFjaCh0aGlzLnBlZXJzLnZhbHVlcygpLCAocGVlciwgY2IpID0+IHBlZXIuY2xvc2UoY2IpLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9nKCdzdG9wcGVkJylcbiAgICAgIHRoaXMucGVlcnMgPSBuZXcgTWFwKClcbiAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlXG4gICAgICBjYWxsYmFjaygpXG4gICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFB1YnN1YkJhc2VQcm90b2NvbFxubW9kdWxlLmV4cG9ydHMubWVzc2FnZSA9IG1lc3NhZ2Vcbm1vZHVsZS5leHBvcnRzLnV0aWxzID0gdXRpbHNcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2V2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuXG52YXIgX2V2ZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudHMpO1xuXG52YXIgX2dldCA9IHJlcXVpcmUoJ2xvZGFzaC9nZXQnKTtcblxudmFyIF9nZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0KTtcblxudmFyIF9pc0Z1bmN0aW9uID0gcmVxdWlyZSgnbG9kYXNoL2lzRnVuY3Rpb24nKTtcblxudmFyIF9pc0Z1bmN0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzRnVuY3Rpb24pO1xuXG52YXIgX1Zpc2liaWxpdHlDaGFuZ2VFbWl0dGVyID0gcmVxdWlyZSgnLi9WaXNpYmlsaXR5Q2hhbmdlRW1pdHRlcicpO1xuXG52YXIgX1Zpc2liaWxpdHlDaGFuZ2VFbWl0dGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Zpc2liaWxpdHlDaGFuZ2VFbWl0dGVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvKiBnbG9iYWwgd2luZG93ICovXG5cblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbGF0ZW5jeS1tb25pdG9yOkxhdGVuY3lNb25pdG9yJyk7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU3VtbWFyeU9iamVjdFxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGV2ZW50cyBIb3cgbWFueSBldmVudHMgd2VyZSBjYWxsZWRcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtaW5NUyBXaGF0IHdhcyB0aGUgbWluIHRpbWUgZm9yIGEgY2IgdG8gYmUgY2FsbGVkXG4gKiBAcHJvcGVydHkge051bWJlcn0gbWF4TVMgV2hhdCB3YXMgdGhlIG1heCB0aW1lIGZvciBhIGNiIHRvIGJlIGNhbGxlZFxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGF2Z01zIFdoYXQgd2FzIHRoZSBhdmVyYWdlIHRpbWUgZm9yIGEgY2IgdG8gYmUgY2FsbGVkXG4gKiBAcHJvcGVydHkge051bWJlcn0gbGVuZ3RoTXMgSG93IGxvbmcgdGhpcyBpbnRlcnZhbCB3YXMgaW4gbXNcbiAqL1xuXG4vKipcbiAqIEEgY2xhc3MgdG8gbW9uaXRvciBsYXRlbmN5IG9mIGFueSBhc3luYyBmdW5jdGlvbiB3aGljaCB3b3JrcyBpbiBhIGJyb3dzZXIgb3Igbm9kZS4gVGhpcyB3b3JrcyBieSBwZXJpb2RpY2FsbHkgY2FsbGluZ1xuICogdGhlIGFzeW5jVGVzdEZuIGFuZCB0aW1pbmcgaG93IGxvbmcgaXQgdGFrZXMgdGhlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZC4gSXQgY2FuIGFsc28gcGVyaW9kaWNhbGx5IGVtaXQgc3RhdHMgYWJvdXQgdGhpcy5cbiAqIFRoaXMgY2FuIGJlIGRpc2FibGVkIGFuZCBzdGF0cyBjYW4gYmUgcHVsbGVkIHZpYSBzZXR0aW5nIGRhdGFFbWl0SW50ZXJ2YWxNcyA9IDAuXG4gKlxuICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaXMgYW4gZXZlbnQgbG9vcCBsYXRlbmN5IG1vbml0b3IuIFRoaXMgd29ya3MgYnkgZmlyaW5nIHBlcmlvZGljIGV2ZW50cyBpbnRvIHRoZSBldmVudCBsb29wXG4gKiBhbmQgdGltaW5nIGhvdyBsb25nIGl0IHRha2VzIHRvIGdldCBiYWNrLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBtb25pdG9yID0gbmV3IExhdGVuY3lNb25pdG9yKCk7XG4gKiBtb25pdG9yLm9uKCdkYXRhJywgKHN1bW1hcnkpID0+IGNvbnNvbGUubG9nKCdFdmVudCBMb29wIExhdGVuY3k6ICVPJywgc3VtbWFyeSkpO1xuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBtb25pdG9yID0gbmV3IExhdGVuY3lNb25pdG9yKHtsYXRlbmN5Q2hlY2tJbnRlcnZhbE1zOiAxMDAwLCBkYXRhRW1pdEludGVydmFsTXM6IDYwMDAwLCBhc3luY1Rlc3RGbjpwaW5nfSk7XG4gKiBtb25pdG9yLm9uKCdkYXRhJywgKHN1bW1hcnkpID0+IGNvbnNvbGUubG9nKCdQaW5nIFBvbmcgTGF0ZW5jeTogJU8nLCBzdW1tYXJ5KSk7XG4gKi9cblxudmFyIExhdGVuY3lNb25pdG9yID0gZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgICBfaW5oZXJpdHMoTGF0ZW5jeU1vbml0b3IsIF9FdmVudEVtaXR0ZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtsYXRlbmN5Q2hlY2tJbnRlcnZhbE1zPTUwMF0gSG93IG9mdGVuIHRvIGFkZCBhIGxhdGVuY3kgY2hlY2sgZXZlbnQgKG1zKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZGF0YUVtaXRJbnRlcnZhbE1zPTUwMDBdIEhvdyBvZnRlbiB0byBzdW1tYXJpemUgbGF0ZW5jeSBjaGVjayBldmVudHMuIG51bGwgb3IgMCBkaXNhYmxlcyBldmVudCBmaXJpbmdcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbYXN5bmNUZXN0Rm5dIFdoYXQgY2Itc3R5bGUgYXN5bmMgZnVuY3Rpb24gdG8gdXNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtsYXRlbmN5UmFuZG9tUGVyY2VudGFnZT01XSBXaGF0IHBlcmNlbnQgKCsvLSkgb2YgbGF0ZW5jeUNoZWNrSW50ZXJ2YWxNcyBzaG91bGQgd2UgcmFuZG9tbHkgdXNlPyBUaGlzIGhlbHBzIGF2b2lkIGFsaWdubWVudCB0byBvdGhlciBldmVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGF0ZW5jeU1vbml0b3IoKSB7XG4gICAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICAgIGxhdGVuY3lDaGVja0ludGVydmFsTXMgPSBfcmVmLmxhdGVuY3lDaGVja0ludGVydmFsTXMsXG4gICAgICAgICAgICBkYXRhRW1pdEludGVydmFsTXMgPSBfcmVmLmRhdGFFbWl0SW50ZXJ2YWxNcyxcbiAgICAgICAgICAgIGFzeW5jVGVzdEZuID0gX3JlZi5hc3luY1Rlc3RGbixcbiAgICAgICAgICAgIGxhdGVuY3lSYW5kb21QZXJjZW50YWdlID0gX3JlZi5sYXRlbmN5UmFuZG9tUGVyY2VudGFnZTtcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGF0ZW5jeU1vbml0b3IpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChMYXRlbmN5TW9uaXRvci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKExhdGVuY3lNb25pdG9yKSkuY2FsbCh0aGlzKSk7XG5cbiAgICAgICAgdmFyIHRoYXQgPSBfdGhpcztcblxuICAgICAgICAvLyAwIGlzbid0IHZhbGlkIGhlcmUsIHNvIGl0cyBvayB0byB1c2UgfHxcbiAgICAgICAgdGhhdC5sYXRlbmN5Q2hlY2tJbnRlcnZhbE1zID0gbGF0ZW5jeUNoZWNrSW50ZXJ2YWxNcyB8fCA1MDA7IC8vIDAuNXNcbiAgICAgICAgdGhhdC5sYXRlbmN5UmFuZG9tUGVyY2VudGFnZSA9IGxhdGVuY3lSYW5kb21QZXJjZW50YWdlIHx8IDEwO1xuICAgICAgICB0aGF0Ll9sYXRlY3lDaGVja011bHRpcGx5ID0gMiAqICh0aGF0LmxhdGVuY3lSYW5kb21QZXJjZW50YWdlIC8gMTAwLjApICogdGhhdC5sYXRlbmN5Q2hlY2tJbnRlcnZhbE1zO1xuICAgICAgICB0aGF0Ll9sYXRlY3lDaGVja1N1YnRyYWN0ID0gdGhhdC5fbGF0ZWN5Q2hlY2tNdWx0aXBseSAvIDI7XG5cbiAgICAgICAgdGhhdC5kYXRhRW1pdEludGVydmFsTXMgPSBkYXRhRW1pdEludGVydmFsTXMgPT09IG51bGwgfHwgZGF0YUVtaXRJbnRlcnZhbE1zID09PSAwID8gdW5kZWZpbmVkIDogZGF0YUVtaXRJbnRlcnZhbE1zIHx8IDUgKiAxMDAwOyAvLyA1c1xuICAgICAgICBkZWJ1ZygnbGF0ZW5jeUNoZWNrSW50ZXJ2YWxNczogJXMgZGF0YUVtaXRJbnRlcnZhbE1zOiAlcycsIHRoYXQubGF0ZW5jeUNoZWNrSW50ZXJ2YWxNcywgdGhhdC5kYXRhRW1pdEludGVydmFsTXMpO1xuICAgICAgICBpZiAodGhhdC5kYXRhRW1pdEludGVydmFsTXMpIHtcbiAgICAgICAgICAgIGRlYnVnKCdFeHBlY3RpbmcgfiVzIGV2ZW50cyBwZXIgc3VtbWFyeScsIHRoYXQubGF0ZW5jeUNoZWNrSW50ZXJ2YWxNcyAvIHRoYXQuZGF0YUVtaXRJbnRlcnZhbE1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKCdOb3QgZW1pdHRpbmcgc3VtbWFyaWVzJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0LmFzeW5jVGVzdEZuID0gYXN5bmNUZXN0Rm47IC8vIElmIHRoZXJlIGlzIG5vIGFzeW5jRm4sIHdlIG1lYXN1cmUgbGF0ZW5jeVxuXG4gICAgICAgIC8vIElmIHByb2Nlc3M6IHVzZSBoaWdoIHJlc29sdXRpb24gdGltZXJcbiAgICAgICAgaWYgKHByb2Nlc3MgJiYgcHJvY2Vzcy5ocnRpbWUpIHtcbiAgICAgICAgICAgIGRlYnVnKCdVc2luZyBwcm9jZXNzLmhydGltZSBmb3IgdGltaW5nJyk7XG4gICAgICAgICAgICB0aGF0Lm5vdyA9IHByb2Nlc3MuaHJ0aW1lO1xuICAgICAgICAgICAgdGhhdC5nZXREZWx0YU1TID0gZnVuY3Rpb24gKHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgIHZhciBocnRpbWUgPSB0aGF0Lm5vdyhzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBocnRpbWVbMF0gKiAxMDAwICsgaHJ0aW1lWzFdIC8gMTAwMDAwMDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBMZXQncyB0cnkgZm9yIGEgdGltZXIgdGhhdCBvbmx5IG1vbm90b25pY2FsbHkgaW5jcmVhc2VzXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKDAsIF9nZXQyLmRlZmF1bHQpKHdpbmRvdywgJ3BlcmZvcm1hbmNlLm5vdycpKSB7XG4gICAgICAgICAgICBkZWJ1ZygnVXNpbmcgcGVyZm9ybWFuY2Uubm93IGZvciB0aW1pbmcnKTtcbiAgICAgICAgICAgIHRoYXQubm93ID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdy5iaW5kKHdpbmRvdy5wZXJmb3JtYW5jZSk7XG4gICAgICAgICAgICB0aGF0LmdldERlbHRhTVMgPSBmdW5jdGlvbiAoc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodGhhdC5ub3coKSAtIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoJ1VzaW5nIERhdGUubm93IGZvciB0aW1pbmcnKTtcbiAgICAgICAgICAgIHRoYXQubm93ID0gRGF0ZS5ub3c7XG4gICAgICAgICAgICB0aGF0LmdldERlbHRhTVMgPSBmdW5jdGlvbiAoc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdC5fbGF0ZW5jeURhdGEgPSB0aGF0Ll9pbml0TGF0ZW5jeURhdGEoKTtcblxuICAgICAgICAvLyBXZSBjaGVjayBmb3IgaXNCcm93c2VyIGJlY2F1c2Ugb2YgYnJvd3NlcnMgc2V0IG1heCByYXRlcyBvZiB0aW1lb3V0cyB3aGVuIGEgcGFnZSBpcyBoaWRkZW4sXG4gICAgICAgIC8vIHNvIHdlIGZhbGwgYmFjayB0byBhbm90aGVyIGxpYnJhcnlcbiAgICAgICAgLy8gU2VlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzYwMzI0MjkvY2hyb21lLXRpbWVvdXRzLWludGVydmFsLXN1c3BlbmRlZC1pbi1iYWNrZ3JvdW5kLXRhYnNcbiAgICAgICAgaWYgKGlzQnJvd3NlcigpKSB7XG4gICAgICAgICAgICB0aGF0Ll92aXNpYmlsaXR5Q2hhbmdlRW1pdHRlciA9IG5ldyBfVmlzaWJpbGl0eUNoYW5nZUVtaXR0ZXIyLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoYXQuX3Zpc2liaWxpdHlDaGFuZ2VFbWl0dGVyLm9uKCd2aXNpYmlsaXR5Q2hhbmdlJywgZnVuY3Rpb24gKHBhZ2VJbkZvY3VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhZ2VJbkZvY3VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX3N0YXJ0VGltZXJzKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fZW1pdFN1bW1hcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fc3RvcFRpbWVycygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGF0Ll92aXNpYmlsaXR5Q2hhbmdlRW1pdHRlciB8fCB0aGF0Ll92aXNpYmlsaXR5Q2hhbmdlRW1pdHRlci5pc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgdGhhdC5fc3RhcnRUaW1lcnMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgaW50ZXJuYWwgdGltZXJzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKExhdGVuY3lNb25pdG9yLCBbe1xuICAgICAgICBrZXk6ICdfc3RhcnRUaW1lcnMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3N0YXJ0VGltZXJzKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIFRpbWVyIGFscmVhZHkgc3RhcnRlZCwgaWdub3JlIHRoaXNcbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGVja0xhdGVuY3lJRCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NoZWNrTGF0ZW5jeSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YUVtaXRJbnRlcnZhbE1zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdEludGVydmFsSUQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczIuX2VtaXRTdW1tYXJ5KCk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcy5kYXRhRW1pdEludGVydmFsTXMpO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzRnVuY3Rpb24yLmRlZmF1bHQpKHRoaXMuX2VtaXRJbnRlcnZhbElELnVucmVmKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0SW50ZXJ2YWxJRC51bnJlZigpOyAvLyBEb2Vzbid0IGJsb2NrIGV4aXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcCBpbnRlcm5hbCB0aW1lcnNcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19zdG9wVGltZXJzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zdG9wVGltZXJzKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NoZWNrTGF0ZW5jeUlEKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2NoZWNrTGF0ZW5jeUlEKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja0xhdGVuY3lJRCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0SW50ZXJ2YWxJRCkge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fZW1pdEludGVydmFsSUQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXRJbnRlcnZhbElEID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXQgc3VtbWFyeSBvbmx5IGlmIHRoZXJlIHdlcmUgZXZlbnRzLiBJdCBtaWdodCBub3QgaGF2ZSBhbnkgZXZlbnRzIGlmIGl0IHdhcyBmb3JjZWQgdmlhIGEgcGFnZSBoaWRkZW4vc2hvd1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2VtaXRTdW1tYXJ5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9lbWl0U3VtbWFyeSgpIHtcbiAgICAgICAgICAgIHZhciBzdW1tYXJ5ID0gdGhpcy5nZXRTdW1tYXJ5KCk7XG4gICAgICAgICAgICBpZiAoc3VtbWFyeS5ldmVudHMgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgc3VtbWFyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGluZyB0aGlzIGZ1bmN0aW9uIHdpbGwgZW5kIHRoZSBjb2xsZWN0aW9uIHBlcmlvZC4gSWYgYSB0aW1pbmcgZXZlbnQgd2FzIGFscmVhZHkgZmlyZWQgYW5kIHNvbWV3aGVyZSBpbiB0aGUgcXVldWUsXG4gICAgICAgICAqIGl0IHdpbGwgbm90IGNvdW50IGZvciB0aGlzIHRpbWUgcGVyaW9kXG4gICAgICAgICAqIEByZXR1cm5zIHtTdW1tYXJ5T2JqZWN0fVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0U3VtbWFyeScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdW1tYXJ5KCkge1xuICAgICAgICAgICAgLy8gV2UgbWlnaHQgd2FudCB0byBhZGp1c3QgZm9yIHRoZSBudW1iZXIgb2YgZXhwZWN0ZWQgZXZlbnRzXG4gICAgICAgICAgICAvLyBFeGFtcGxlOiBmaXJzdCAxIGV2ZW50IGl0IGNvbWVzIGJhY2ssIHRoZW4gc3VjaCBhIGxvbmcgYmxvY2tlciB0aGF0IHRoZSBuZXh0IGVtaXQgY2hlY2sgY29tZXNcbiAgICAgICAgICAgIC8vIFRoZW4gdGhpcyBmaXJlcyAtIGxvb2tzIGxpa2Ugbm8gbGF0ZW5jeSEhXG4gICAgICAgICAgICB2YXIgbGF0ZW5jeSA9IHtcbiAgICAgICAgICAgICAgICBldmVudHM6IHRoaXMuX2xhdGVuY3lEYXRhLmV2ZW50cyxcbiAgICAgICAgICAgICAgICBtaW5NczogdGhpcy5fbGF0ZW5jeURhdGEubWluTXMsXG4gICAgICAgICAgICAgICAgbWF4TXM6IHRoaXMuX2xhdGVuY3lEYXRhLm1heE1zLFxuICAgICAgICAgICAgICAgIGF2Z01zOiB0aGlzLl9sYXRlbmN5RGF0YS5ldmVudHMgPyB0aGlzLl9sYXRlbmN5RGF0YS50b3RhbE1zIC8gdGhpcy5fbGF0ZW5jeURhdGEuZXZlbnRzIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICAgICAgICAgIGxlbmd0aE1zOiB0aGlzLmdldERlbHRhTVModGhpcy5fbGF0ZW5jeURhdGEuc3RhcnRUaW1lKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX2xhdGVuY3lEYXRhID0gdGhpcy5faW5pdExhdGVuY3lEYXRhKCk7IC8vIENsZWFyXG5cbiAgICAgICAgICAgIGRlYnVnKCdTdW1tYXJ5OiAlTycsIGxhdGVuY3kpO1xuICAgICAgICAgICAgcmV0dXJuIGxhdGVuY3k7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmFuZG9tbHkgY2FsbHMgYW4gYXN5bmMgZm4gZXZlcnkgcm91Z2hseSBsYXRlbmN5Q2hlY2tJbnRlcnZhbE1zIChwbHVzIHNvbWUgcmFuZG9tbmVzcykuIElmIG5vIGFzeW5jIGZuIGlzIGZvdW5kLFxuICAgICAgICAgKiBpdCB3aWxsIHNpbXBseSByZXBvcnQgb24gZXZlbnQgbG9vcCBsYXRlbmN5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2NoZWNrTGF0ZW5jeScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tMYXRlbmN5KCkge1xuICAgICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIC8vIFJhbmRvbW5lc3MgaXMgbmVlZGVkIHRvIGF2b2lkIGFsaWdubWVudCBieSBhY2NpZGVudCB0byByZWd1bGFyIHRoaW5ncyBpbiB0aGUgZXZlbnQgbG9vcFxuICAgICAgICAgICAgdmFyIHJhbmRvbW5lc3MgPSBNYXRoLnJhbmRvbSgpICogdGhhdC5fbGF0ZWN5Q2hlY2tNdWx0aXBseSAtIHRoYXQuX2xhdGVjeUNoZWNrU3VidHJhY3Q7XG5cbiAgICAgICAgICAgIC8vIFdlIHVzZSB0aGlzIHRvIGVuc3VyZSB0aGF0IGluIGNhc2Ugc29tZSBvdmVybGFwIHNvbWVob3csIHdlIGRvbid0IHRha2UgdGhlIHdyb25nIHN0YXJ0VGltZS9vZmZzZXRcbiAgICAgICAgICAgIHZhciBsb2NhbERhdGEgPSB7XG4gICAgICAgICAgICAgICAgZGVsdGFPZmZzZXQ6IE1hdGguY2VpbCh0aGF0LmxhdGVuY3lDaGVja0ludGVydmFsTXMgKyByYW5kb21uZXNzKSxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWU6IHRoYXQubm93KClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBjYiA9IGZ1bmN0aW9uIGNiKCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBhbHJlYWR5IHN0b3BwZWQsIGlnbm9yZSB0aGlzIGRhdGFwb2ludFxuICAgICAgICAgICAgICAgIGlmICghX3RoaXMzLl9jaGVja0xhdGVuY3lJRCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkZWx0YU1TID0gdGhhdC5nZXREZWx0YU1TKGxvY2FsRGF0YS5zdGFydFRpbWUpIC0gbG9jYWxEYXRhLmRlbHRhT2Zmc2V0O1xuICAgICAgICAgICAgICAgIHRoYXQuX2NoZWNrTGF0ZW5jeSgpOyAvLyBTdGFydCBhZ2FpbiBBU0FQXG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGRhdGEgcG9pbnQuIElmIHRoaXMgZ2V0cyBjb21wbGV4LCByZWZhY3RvciBpdFxuICAgICAgICAgICAgICAgIHRoYXQuX2xhdGVuY3lEYXRhLmV2ZW50cysrO1xuICAgICAgICAgICAgICAgIHRoYXQuX2xhdGVuY3lEYXRhLm1pbk1zID0gTWF0aC5taW4odGhhdC5fbGF0ZW5jeURhdGEubWluTXMsIGRlbHRhTVMpO1xuICAgICAgICAgICAgICAgIHRoYXQuX2xhdGVuY3lEYXRhLm1heE1zID0gTWF0aC5tYXgodGhhdC5fbGF0ZW5jeURhdGEubWF4TXMsIGRlbHRhTVMpO1xuICAgICAgICAgICAgICAgIHRoYXQuX2xhdGVuY3lEYXRhLnRvdGFsTXMgKz0gZGVsdGFNUztcbiAgICAgICAgICAgICAgICBkZWJ1ZygnTVM6ICVzIERhdGE6ICVPJywgZGVsdGFNUywgdGhhdC5fbGF0ZW5jeURhdGEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlYnVnKCdsb2NhbERhdGE6ICVPJywgbG9jYWxEYXRhKTtcblxuICAgICAgICAgICAgdGhpcy5fY2hlY2tMYXRlbmN5SUQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGdldHMgcmlkIG9mIGluY2x1ZGluZyBldmVudCBsb29wXG4gICAgICAgICAgICAgICAgaWYgKHRoYXQuYXN5bmNUZXN0Rm4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgdGltaW5nIHJlbGF0ZWQgdGhpbmdzXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsRGF0YS5kZWx0YU9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsRGF0YS5zdGFydFRpbWUgPSB0aGF0Lm5vdygpO1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmFzeW5jVGVzdEZuKGNiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXRUaW1lb3V0IGlzIG5vdCBtb3JlIGFjY3VyYXRlIHRoYW4gMW1zLCBzbyB0aGlzIHdpbGwgZW5zdXJlIHBvc2l0aXZlIG51bWJlcnMuIEFkZCAxIHRvIGVtaXR0ZWQgZGF0YSB0byByZW1vdmUuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgbm90IHRoZSBiZXN0LCBidXQgZm9yIG5vdyBpdCdsbCBiZSBqdXN0IGZpbmUuIFRoaXMgaXNuJ3QgbWVhbnQgdG8gYmUgc3ViIG1zIGFjY3VyYXRlLlxuICAgICAgICAgICAgICAgICAgICBsb2NhbERhdGEuZGVsdGFPZmZzZXQgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gZnVuY3Rpb24gdG8gdGVzdCwgd2UgbWVhbiBjaGVjayBsYXRlbmN5IHdoaWNoIGlzIGEgc3BlY2lhbCBjYXNlIHRoYXQgaXMgcmVhbGx5IGNiID0+IGNiKClcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXZvaWQgdGhhdCBmb3IgdGhlIGZldyBleHRyYSBmdW5jdGlvbiBhbGwgb3ZlcmhlYWRzLiBBbHNvLCB3ZSB3YW50IHRvIGtlZXAgdGhlIHRpbWVycyBkaWZmZXJlbnRcbiAgICAgICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBsb2NhbERhdGEuZGVsdGFPZmZzZXQpO1xuXG4gICAgICAgICAgICBpZiAoKDAsIF9pc0Z1bmN0aW9uMi5kZWZhdWx0KSh0aGlzLl9jaGVja0xhdGVuY3lJRC51bnJlZikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja0xhdGVuY3lJRC51bnJlZigpOyAvLyBEb2Vzbid0IGJsb2NrIGV4aXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2luaXRMYXRlbmN5RGF0YScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdExhdGVuY3lEYXRhKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWU6IHRoaXMubm93KCksXG4gICAgICAgICAgICAgICAgbWluTXM6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgICAgICAgICAgICBtYXhNczogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuICAgICAgICAgICAgICAgIGV2ZW50czogMCxcbiAgICAgICAgICAgICAgICB0b3RhbE1zOiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIExhdGVuY3lNb25pdG9yO1xufShfZXZlbnRzMi5kZWZhdWx0KTtcblxuZnVuY3Rpb24gaXNCcm93c2VyKCkge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gTGF0ZW5jeU1vbml0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MYXRlbmN5TW9uaXRvci5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBDb25uZWN0aW9uID0gcmVxdWlyZSgnaW50ZXJmYWNlLWNvbm5lY3Rpb24nKS5Db25uZWN0aW9uXG5jb25zdCBwdWxsID0gcmVxdWlyZSgncHVsbC1zdHJlYW0vcHVsbCcpXG5cbi8qKlxuICogQ3JlYXRlcyBhIHB1bGwgc3RyZWFtIHRvIHJ1biB0aGUgZ2l2ZW4gQ29ubmVjdGlvbiBzdHJlYW0gdGhyb3VnaFxuICogdGhlIGdpdmVuIE9ic2VydmVyLiBUaGlzIHByb3ZpZGVzIGEgd2F5IHRvIG1vcmUgZWFzaWx5IG1vbml0b3IgY29ubmVjdGlvbnNcbiAqIGFuZCB0aGVpciBtZXRhZGF0YS4gQSBuZXcgQ29ubmVjdGlvbiB3aWxsIGJlIHJldHVybmVkIHRoYXQgY29udGFpbnNcbiAqIGhhcyB0aGUgYXR0YWNoZWQgT2JzZXJ2ZXIuXG4gKlxuICogQHBhcmFtIHtUcmFuc3BvcnR9IHRyYW5zcG9ydFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3RvY29sXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB7T2JzZXJ2ZXJ9IG9ic2VydmVyXG4gKiBAcmV0dXJucyB7Q29ubmVjdGlvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAodHJhbnNwb3J0LCBwcm90b2NvbCwgY29ubmVjdGlvbiwgb2JzZXJ2ZXIpID0+IHtcbiAgY29uc3QgcGVlckluZm8gPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29ubmVjdGlvbi5nZXRQZWVySW5mbygoZXJyLCBwZWVySW5mbykgPT4ge1xuICAgICAgaWYgKCFlcnIgJiYgcGVlckluZm8pIHtcbiAgICAgICAgcmVzb2x2ZShwZWVySW5mbylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNldFBlZXJJbmZvID0gY29ubmVjdGlvbi5zZXRQZWVySW5mb1xuICAgICAgY29ubmVjdGlvbi5zZXRQZWVySW5mbyA9IChwaSkgPT4ge1xuICAgICAgICBzZXRQZWVySW5mby5jYWxsKGNvbm5lY3Rpb24sIHBpKVxuICAgICAgICByZXNvbHZlKHBpKVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG5cbiAgY29uc3Qgc3RyZWFtID0ge1xuICAgIHNvdXJjZTogcHVsbChcbiAgICAgIGNvbm5lY3Rpb24sXG4gICAgICBvYnNlcnZlci5pbmNvbWluZyh0cmFuc3BvcnQsIHByb3RvY29sLCBwZWVySW5mbykpLFxuICAgIHNpbms6IHB1bGwoXG4gICAgICBvYnNlcnZlci5vdXRnb2luZyh0cmFuc3BvcnQsIHByb3RvY29sLCBwZWVySW5mbyksXG4gICAgICBjb25uZWN0aW9uKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBDb25uZWN0aW9uKHN0cmVhbSwgY29ubmVjdGlvbilcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBGU00gPSByZXF1aXJlKCdmc20tZXZlbnQnKVxuY29uc3QgbXVsdGlzdHJlYW0gPSByZXF1aXJlKCdtdWx0aXN0cmVhbS1zZWxlY3QnKVxuY29uc3Qgd2l0aElzID0gcmVxdWlyZSgnY2xhc3MtaXMnKVxuXG5jb25zdCBCYXNlQ29ubmVjdGlvbiA9IHJlcXVpcmUoJy4vYmFzZScpXG5cbmNsYXNzIEluY29taW5nQ29ubmVjdGlvbkZTTSBleHRlbmRzIEJhc2VDb25uZWN0aW9uIHtcbiAgY29uc3RydWN0b3IgKHsgY29ubmVjdGlvbiwgX3N3aXRjaCwgdHJhbnNwb3J0S2V5LCBwZWVySW5mbyB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgX3N3aXRjaCxcbiAgICAgIG5hbWU6IGBpbmM6JHtfc3dpdGNoLl9wZWVySW5mby5pZC50b0I1OFN0cmluZygpLnNsaWNlKDAsIDgpfWBcbiAgICB9KVxuICAgIHRoaXMuY29ubiA9IGNvbm5lY3Rpb25cbiAgICB0aGlzLnRoZWlyUGVlckluZm8gPSBwZWVySW5mbyB8fCBudWxsXG4gICAgdGhpcy50aGVpckI1OElkID0gdGhpcy50aGVpclBlZXJJbmZvID8gdGhpcy50aGVpclBlZXJJbmZvLmlkLnRvQjU4U3RyaW5nKCkgOiBudWxsXG4gICAgdGhpcy5vdXJQZWVySW5mbyA9IHRoaXMuc3dpdGNoLl9wZWVySW5mb1xuICAgIHRoaXMudHJhbnNwb3J0S2V5ID0gdHJhbnNwb3J0S2V5XG4gICAgdGhpcy5wcm90b2NvbE11eGVyID0gdGhpcy5zd2l0Y2gucHJvdG9jb2xNdXhlcih0aGlzLnRyYW5zcG9ydEtleSlcbiAgICB0aGlzLm1zTGlzdGVuZXIgPSBuZXcgbXVsdGlzdHJlYW0uTGlzdGVuZXIoKVxuXG4gICAgdGhpcy5fc3RhdGUgPSBGU00oJ0RJQUxFRCcsIHtcbiAgICAgIERJU0NPTk5FQ1RFRDoge1xuICAgICAgICBkaXNjb25uZWN0OiAnRElTQ09OTkVDVEVEJ1xuICAgICAgfSxcbiAgICAgIERJQUxFRDogeyAvLyBCYXNlIGNvbm5lY3Rpb24gdG8gcGVlciBlc3RhYmxpc2hlZFxuICAgICAgICBwcml2YXRpemU6ICdQUklWQVRJWklORycsXG4gICAgICAgIGVuY3J5cHQ6ICdFTkNSWVBUSU5HJ1xuICAgICAgfSxcbiAgICAgIFBSSVZBVElaSU5HOiB7IC8vIFByb3RlY3RpbmcgdGhlIGJhc2UgY29ubmVjdGlvblxuICAgICAgICBkb25lOiAnUFJJVkFUSVpFRCcsXG4gICAgICAgIGRpc2Nvbm5lY3Q6ICdESVNDT05ORUNUSU5HJ1xuICAgICAgfSxcbiAgICAgIFBSSVZBVElaRUQ6IHsgLy8gQmFzZSBjb25uZWN0aW9uIGlzIHByb3RlY3RlZFxuICAgICAgICBlbmNyeXB0OiAnRU5DUllQVElORydcbiAgICAgIH0sXG4gICAgICBFTkNSWVBUSU5HOiB7IC8vIEVuY3J5cHRpbmcgdGhlIGJhc2UgY29ubmVjdGlvblxuICAgICAgICBkb25lOiAnRU5DUllQVEVEJyxcbiAgICAgICAgZGlzY29ubmVjdDogJ0RJU0NPTk5FQ1RJTkcnXG4gICAgICB9LFxuICAgICAgRU5DUllQVEVEOiB7IC8vIFVwZ3JhZGluZyBjb3VsZCBub3QgaGFwcGVuLCB0aGUgY29ubmVjdGlvbiBpcyBlbmNyeXB0ZWQgYW5kIHdhaXRpbmdcbiAgICAgICAgdXBncmFkZTogJ1VQR1JBRElORycsXG4gICAgICAgIGRpc2Nvbm5lY3Q6ICdESVNDT05ORUNUSU5HJ1xuICAgICAgfSxcbiAgICAgIFVQR1JBRElORzogeyAvLyBBdHRlbXB0aW5nIHRvIHVwZ3JhZGUgdGhlIGNvbm5lY3Rpb24gd2l0aCBtdXhlcnNcbiAgICAgICAgZG9uZTogJ01VWEVEJ1xuICAgICAgfSxcbiAgICAgIE1VWEVEOiB7XG4gICAgICAgIGRpc2Nvbm5lY3Q6ICdESVNDT05ORUNUSU5HJ1xuICAgICAgfSxcbiAgICAgIERJU0NPTk5FQ1RJTkc6IHsgLy8gU2h1dHRpbmcgZG93biB0aGUgY29ubmVjdGlvblxuICAgICAgICBkb25lOiAnRElTQ09OTkVDVEVEJ1xuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLl9zdGF0ZS5vbignRElTQ09OTkVDVEVEJywgKCkgPT4gdGhpcy5fb25EaXNjb25uZWN0ZWQoKSlcbiAgICB0aGlzLl9zdGF0ZS5vbignUFJJVkFUSVpJTkcnLCAoKSA9PiB0aGlzLl9vblByaXZhdGl6aW5nKCkpXG4gICAgdGhpcy5fc3RhdGUub24oJ1BSSVZBVElaRUQnLCAoKSA9PiB0aGlzLl9vblByaXZhdGl6ZWQoKSlcbiAgICB0aGlzLl9zdGF0ZS5vbignRU5DUllQVElORycsICgpID0+IHRoaXMuX29uRW5jcnlwdGluZygpKVxuICAgIHRoaXMuX3N0YXRlLm9uKCdFTkNSWVBURUQnLCAoKSA9PiB7XG4gICAgICB0aGlzLmxvZygnc3VjY2Vzc2Z1bGx5IGVuY3J5cHRlZCBjb25uZWN0aW9uIHRvICVzJywgdGhpcy50aGVpckI1OElkIHx8ICd1bmtub3duIHBlZXInKVxuICAgICAgdGhpcy5lbWl0KCdlbmNyeXB0ZWQnLCB0aGlzLmNvbm4pXG4gICAgfSlcbiAgICB0aGlzLl9zdGF0ZS5vbignVVBHUkFESU5HJywgKCkgPT4gdGhpcy5fb25VcGdyYWRpbmcoKSlcbiAgICB0aGlzLl9zdGF0ZS5vbignTVVYRUQnLCAoKSA9PiB7XG4gICAgICB0aGlzLmxvZygnc3VjY2Vzc2Z1bGx5IG11eGVkIGNvbm5lY3Rpb24gdG8gJXMnLCB0aGlzLnRoZWlyQjU4SWQgfHwgJ3Vua25vd24gcGVlcicpXG4gICAgICB0aGlzLmVtaXQoJ211eGVkJywgdGhpcy5jb25uKVxuICAgIH0pXG4gICAgdGhpcy5fc3RhdGUub24oJ0RJU0NPTk5FQ1RJTkcnLCAoKSA9PiB7XG4gICAgICB0aGlzLl9zdGF0ZSgnZG9uZScpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBlbmNyeXB0IGB0aGlzLmNvbm5gIHdpdGggdGhlIFN3aXRjaCdzIGNyeXB0by5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGZpcmVzIEluY29taW5nQ29ubmVjdGlvbkZTTSNlcnJvclxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF9vbkVuY3J5cHRpbmcgKCkge1xuICAgIHRoaXMubG9nKCdlbmNyeXB0aW5nIGNvbm5lY3Rpb24gdmlhICVzJywgdGhpcy5zd2l0Y2guY3J5cHRvLnRhZylcblxuICAgIHRoaXMubXNMaXN0ZW5lci5hZGRIYW5kbGVyKHRoaXMuc3dpdGNoLmNyeXB0by50YWcsIChwcm90b2NvbCwgX2Nvbm4pID0+IHtcbiAgICAgIHRoaXMuY29ubiA9IHRoaXMuc3dpdGNoLmNyeXB0by5lbmNyeXB0KHRoaXMub3VyUGVlckluZm8uaWQsIF9jb25uLCB1bmRlZmluZWQsIChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNsb3NlKGVycilcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm4uZ2V0UGVlckluZm8oKF8sIHBlZXJJbmZvKSA9PiB7XG4gICAgICAgICAgdGhpcy50aGVpclBlZXJJbmZvID0gcGVlckluZm9cbiAgICAgICAgICB0aGlzLl9zdGF0ZSgnZG9uZScpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0sIG51bGwpXG5cbiAgICAvLyBTdGFydCBoYW5kbGluZyB0aGUgY29ubmVjdGlvblxuICAgIHRoaXMubXNMaXN0ZW5lci5oYW5kbGUodGhpcy5jb25uLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnY3J5cHRvIGhhbmRzaGFraW5nIGZhaWxlZCcsIGVycilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgX29uVXBncmFkaW5nICgpIHtcbiAgICB0aGlzLmxvZygnYWRkaW5nIHRoZSBwcm90b2NvbCBtdXhlciB0byB0aGUgY29ubmVjdGlvbicpXG4gICAgdGhpcy5wcm90b2NvbE11eGVyKHRoaXMuY29ubiwgdGhpcy5tc0xpc3RlbmVyKVxuICAgIHRoaXMuX3N0YXRlKCdkb25lJylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdpdGhJcyhJbmNvbWluZ0Nvbm5lY3Rpb25GU00sIHtcbiAgY2xhc3NOYW1lOiAnSW5jb21pbmdDb25uZWN0aW9uRlNNJyxcbiAgc3ltYm9sTmFtZTogJ2xpYnAycC1zd2l0Y2gvSW5jb21pbmdDb25uZWN0aW9uRlNNJ1xufSlcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBMUlUgPSByZXF1aXJlKCdoYXNobHJ1JylcblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgTGVhc3QgUmVjZW50bHkgVXNlZCBDYWNoZVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhTaXplXG4gKiBAcmV0dXJucyB7TFJVQ2FjaGV9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gKG1heFNpemUpID0+IHtcbiAgY29uc3QgcGF0Y2hlZCA9IExSVShtYXhTaXplKVxuICBwYXRjaGVkLmRlbGV0ZSA9IHBhdGNoZWQucmVtb3ZlXG4gIHJldHVybiBwYXRjaGVkXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJylcbmNvbnN0IEJpZyA9IHJlcXVpcmUoJ2JpZ251bWJlci5qcycpXG5jb25zdCBNb3ZpbmdBdmVyYWdlID0gcmVxdWlyZSgnbW92aW5nLWF2ZXJhZ2UnKVxuY29uc3QgcmV0aW1lciA9IHJlcXVpcmUoJ3JldGltZXInKVxuXG4vKipcbiAqIEEgcXVldWUgYmFzZWQgbWFuYWdlciBmb3Igc3RhdCBwcm9jZXNzaW5nXG4gKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBpbml0aWFsQ291bnRlcnNcbiAqIEBwYXJhbSB7YW55fSBvcHRpb25zXG4gKi9cbmNsYXNzIFN0YXRzIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKGluaXRpYWxDb3VudGVycywgb3B0aW9ucykge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5fcXVldWUgPSBbXVxuICAgIHRoaXMuX3N0YXRzID0ge31cblxuICAgIHRoaXMuX2ZyZXF1ZW5jeUxhc3RUaW1lID0gRGF0ZS5ub3coKVxuICAgIHRoaXMuX2ZyZXF1ZW5jeUFjY3VtdWxhdG9ycyA9IHt9XG4gICAgdGhpcy5fbW92aW5nQXZlcmFnZXMgPSB7fVxuXG4gICAgdGhpcy5fdXBkYXRlID0gdGhpcy5fdXBkYXRlLmJpbmQodGhpcylcblxuICAgIGNvbnN0IGludGVydmFscyA9IHRoaXMuX29wdGlvbnMubW92aW5nQXZlcmFnZUludGVydmFsc1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsQ291bnRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBpbml0aWFsQ291bnRlcnNbaV1cbiAgICAgIHRoaXMuX3N0YXRzW2tleV0gPSBCaWcoMClcbiAgICAgIHRoaXMuX21vdmluZ0F2ZXJhZ2VzW2tleV0gPSB7fVxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBpbnRlcnZhbHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGludGVydmFsID0gaW50ZXJ2YWxzW2tdXG4gICAgICAgIHZhciBtYSA9IHRoaXMuX21vdmluZ0F2ZXJhZ2VzW2tleV1baW50ZXJ2YWxdID0gTW92aW5nQXZlcmFnZShpbnRlcnZhbClcbiAgICAgICAgbWEucHVzaCh0aGlzLl9mcmVxdWVuY3lMYXN0VGltZSwgMClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGludGVybmFsIHRpbWVyIGlmIHRoZXJlIGFyZSBpdGVtcyBpbiB0aGUgcXVldWUuIFRoaXNcbiAgICogc2hvdWxkIG9ubHkgbmVlZCB0byBiZSBjYWxsZWQgaWYgYFN0YXRzLnN0b3BgIHdhcyBwcmV2aW91c2x5IGNhbGxlZCwgYXNcbiAgICogYFN0YXRzLnB1c2hgIHdpbGwgYWxzbyBzdGFydCB0aGUgcHJvY2Vzc2luZy5cbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBzdGFydCAoKSB7XG4gICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgdGhpcy5fcmVzZXRDb21wdXRlVGltZW91dCgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIHByb2Nlc3NpbmcgYW5kIGNvbXB1dGluZyBvZiBzdGF0cyBieSBjbGVhcmluZyB0aGUgaW50ZXJuYWxcbiAgICogdGltZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgc3RvcCAoKSB7XG4gICAgaWYgKHRoaXMuX3RpbWVvdXQpIHtcbiAgICAgIHRoaXMuX3RpbWVvdXQuY2xlYXIoKVxuICAgICAgdGhpcy5fdGltZW91dCA9IG51bGxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBjdXJyZW50IHN0YXRzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7TWFwPHN0cmluZywgU3RhdD59XG4gICAqL1xuICBnZXQgc25hcHNob3QgKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9zdGF0cylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIGludGVybmFsIG1vdmluZ0F2ZXJhZ2VzXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheTxNb3ZpbmdBdmVyYWdlPn1cbiAgICovXG4gIGdldCBtb3ZpbmdBdmVyYWdlcyAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX21vdmluZ0F2ZXJhZ2VzKVxuICB9XG5cbiAgLyoqXG4gICAqIFB1c2hlcyB0aGUgZ2l2ZW4gb3BlcmF0aW9uIGRhdGEgdG8gdGhlIHF1ZXVlLCBhbG9uZyB3aXRoIHRoZVxuICAgKiBjdXJyZW50IFRpbWVzdGFtcCwgdGhlbiByZXNldHMgdGhlIHVwZGF0ZSB0aW1lci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvdW50ZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluY1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHB1c2ggKGNvdW50ZXIsIGluYykge1xuICAgIHRoaXMuX3F1ZXVlLnB1c2goW2NvdW50ZXIsIGluYywgRGF0ZS5ub3coKV0pXG4gICAgdGhpcy5fcmVzZXRDb21wdXRlVGltZW91dCgpXG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIHRoZSB0aW1lb3V0IGZvciB0cmlnZ2VyaW5nIHVwZGF0ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgX3Jlc2V0Q29tcHV0ZVRpbWVvdXQgKCkge1xuICAgIGlmICh0aGlzLl90aW1lb3V0KSB7XG4gICAgICB0aGlzLl90aW1lb3V0LnJlc2NoZWR1bGUodGhpcy5fbmV4dFRpbWVvdXQoKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdGltZW91dCA9IHJldGltZXIodGhpcy5fdXBkYXRlLCB0aGlzLl9uZXh0VGltZW91dCgpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIGFuZCByZXR1cm5zIHRoZSB0aW1lb3V0IGZvciB0aGUgbmV4dCB1cGRhdGUgYmFzZWQgb25cbiAgICogdGhlIHVyZ2VuY3kgb2YgdGhlIHVwZGF0ZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIF9uZXh0VGltZW91dCAoKSB7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSBuZWVkIGZvciBhbiB1cGRhdGUsIGRlcGVuZGluZyBvbiB0aGUgcXVldWUgbGVuZ3RoXG4gICAgY29uc3QgdXJnZW5jeSA9IHRoaXMuX3F1ZXVlLmxlbmd0aCAvIHRoaXMuX29wdGlvbnMuY29tcHV0ZVRocm90dGxlTWF4UXVldWVTaXplXG4gICAgY29uc3QgdGltZW91dCA9IE1hdGgubWF4KHRoaXMuX29wdGlvbnMuY29tcHV0ZVRocm90dGxlVGltZW91dCAqICgxIC0gdXJnZW5jeSksIDApXG4gICAgcmV0dXJuIHRpbWVvdXRcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGVyZSBhcmUgaXRlbXMgaW4gdGhlIHF1ZXVlLCB0aGV5IHdpbGwgd2lsbCBiZSBwcm9jZXNzZWQgYW5kXG4gICAqIHRoZSBmcmVxdWVuY3kgZm9yIGFsbCBpdGVtcyB3aWxsIGJlIHVwZGF0ZWQgYmFzZWQgb24gdGhlIFRpbWVzdGFtcFxuICAgKiBvZiB0aGUgbGFzdCBpdGVtIGluIHRoZSBxdWV1ZS4gVGhlIGB1cGRhdGVgIGV2ZW50IHdpbGwgYWxzbyBiZSBlbWl0dGVkXG4gICAqIHdpdGggdGhlIGxhdGVzdCBzdGF0cy5cbiAgICpcbiAgICogSWYgdGhlcmUgYXJlIG5vIGl0ZW1zIGluIHRoZSBxdWV1ZSwgbm8gYWN0aW9uIGlzIHRha2VuLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF91cGRhdGUgKCkge1xuICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsXG4gICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgbGV0IGxhc3RcbiAgICAgIHdoaWxlICh0aGlzLl9xdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgY29uc3Qgb3AgPSBsYXN0ID0gdGhpcy5fcXVldWUuc2hpZnQoKVxuICAgICAgICB0aGlzLl9hcHBseU9wKG9wKVxuICAgICAgfVxuXG4gICAgICB0aGlzLl91cGRhdGVGcmVxdWVuY3kobGFzdFsyXSkgLy8gY29udGFpbnMgdGltZXN0YW1wIG9mIGxhc3Qgb3BcblxuICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLl9zdGF0cylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRm9yIGVhY2gga2V5IGluIHRoZSBzdGF0cywgdGhlIGZyZXF1bmN5IGFuZCBtb3ZpbmcgYXZlcmFnZXNcbiAgICogd2lsbCBiZSB1cGRhdGVkIHZpYSBTdGF0cy5fdXBkYXRlRnJlcXVlbmN5Rm9yIGJhc2VkIG9uIHRoZSB0aW1lXG4gICAqIGRpZmZlcmVuY2UgYmV0d2VlbiBjYWxscyB0byB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtUaW1lc3RhbXB9IGxhdGVzdFRpbWVcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBfdXBkYXRlRnJlcXVlbmN5IChsYXRlc3RUaW1lKSB7XG4gICAgY29uc3QgdGltZURpZmYgPSBsYXRlc3RUaW1lIC0gdGhpcy5fZnJlcXVlbmN5TGFzdFRpbWVcblxuICAgIE9iamVjdC5rZXlzKHRoaXMuX3N0YXRzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIHRoaXMuX3VwZGF0ZUZyZXF1ZW5jeUZvcihrZXksIHRpbWVEaWZmLCBsYXRlc3RUaW1lKVxuICAgIH0pXG5cbiAgICB0aGlzLl9mcmVxdWVuY3lMYXN0VGltZSA9IGxhdGVzdFRpbWVcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBgbW92aW5nQXZlcmFnZXNgIGZvciB0aGUgZ2l2ZW4gYGtleWAgYW5kIGFsc29cbiAgICogcmVzZXRzIHRoZSBgZnJlcXVlbmN5QWNjdW11bGF0b3JgIGZvciB0aGUgYGtleWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVEaWZmTVMgVGltZSBpbiBtaWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHtUaW1lc3RhbXB9IGxhdGVzdFRpbWUgVGltZSBpbiB0aWNrc1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF91cGRhdGVGcmVxdWVuY3lGb3IgKGtleSwgdGltZURpZmZNUywgbGF0ZXN0VGltZSkge1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fZnJlcXVlbmN5QWNjdW11bGF0b3JzW2tleV0gfHwgMFxuICAgIHRoaXMuX2ZyZXF1ZW5jeUFjY3VtdWxhdG9yc1trZXldID0gMFxuICAgIC8vIGlmIGB0aW1lRGlmZmAgaXMgemVybywgYGh6YCBiZWNvbWVzIEluZmluaXR5LCBzbyB3ZSBmYWxsYmFjayB0byAxbXNcbiAgICBjb25zdCBzYWZlVGltZURpZmYgPSB0aW1lRGlmZk1TIHx8IDFcbiAgICBjb25zdCBoeiA9IChjb3VudCAvIHNhZmVUaW1lRGlmZikgKiAxMDAwXG5cbiAgICBsZXQgbW92aW5nQXZlcmFnZXMgPSB0aGlzLl9tb3ZpbmdBdmVyYWdlc1trZXldXG4gICAgaWYgKCFtb3ZpbmdBdmVyYWdlcykge1xuICAgICAgbW92aW5nQXZlcmFnZXMgPSB0aGlzLl9tb3ZpbmdBdmVyYWdlc1trZXldID0ge31cbiAgICB9XG5cbiAgICBjb25zdCBpbnRlcnZhbHMgPSB0aGlzLl9vcHRpb25zLm1vdmluZ0F2ZXJhZ2VJbnRlcnZhbHNcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW50ZXJ2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbW92aW5nQXZlcmFnZUludGVydmFsID0gaW50ZXJ2YWxzW2ldXG4gICAgICB2YXIgbW92aW5nQXZlcmFnZSA9IG1vdmluZ0F2ZXJhZ2VzW21vdmluZ0F2ZXJhZ2VJbnRlcnZhbF1cbiAgICAgIGlmICghbW92aW5nQXZlcmFnZSkge1xuICAgICAgICBtb3ZpbmdBdmVyYWdlID0gbW92aW5nQXZlcmFnZXNbbW92aW5nQXZlcmFnZUludGVydmFsXSA9IE1vdmluZ0F2ZXJhZ2UobW92aW5nQXZlcmFnZUludGVydmFsKVxuICAgICAgfVxuICAgICAgbW92aW5nQXZlcmFnZS5wdXNoKGxhdGVzdFRpbWUsIGh6KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgdGhlIGdpdmVuIG9wZXJhdGlvbiwgYG9wYCwgdGhlIHN0YXRzIGFuZCBgZnJlcXVlbmN5QWNjdW11bGF0b3JgXG4gICAqIHdpbGwgYmUgdXBkYXRlZCBvciBpbml0aWFsaXplZCBpZiB0aGV5IGRvbid0IGFscmVhZHkgZXhpc3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nLCBudW1iZXI+fSBvcFxuICAgKiBAdGhyb3dzIHtJbnZhbGlkTnVtYmVyfVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF9hcHBseU9wIChvcCkge1xuICAgIGNvbnN0IGtleSA9IG9wWzBdXG4gICAgY29uc3QgaW5jID0gb3BbMV1cblxuICAgIGlmICh0eXBlb2YgaW5jICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluY3JlbWVudCBudW1iZXI6JywgaW5jKVxuICAgIH1cblxuICAgIGxldCBuXG5cbiAgICBpZiAoIXRoaXMuX3N0YXRzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIG4gPSB0aGlzLl9zdGF0c1trZXldID0gQmlnKDApXG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSB0aGlzLl9zdGF0c1trZXldXG4gICAgfVxuICAgIHRoaXMuX3N0YXRzW2tleV0gPSBuLnBsdXMoaW5jKVxuXG4gICAgaWYgKCF0aGlzLl9mcmVxdWVuY3lBY2N1bXVsYXRvcnNba2V5XSkge1xuICAgICAgdGhpcy5fZnJlcXVlbmN5QWNjdW11bGF0b3JzW2tleV0gPSAwXG4gICAgfVxuICAgIHRoaXMuX2ZyZXF1ZW5jeUFjY3VtdWxhdG9yc1trZXldICs9IGluY1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdHNcbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQkxBQ0tfTElTVF9UVEw6IDUgKiA2MCAqIDFlMywgLy8gSG93IGxvbmcgYmVmb3JlIGFuIGVycm9yZWQgcGVlciBjYW4gYmUgZGlhbGVkIGFnYWluXG4gIEJMQUNLX0xJU1RfQVRURU1QVFM6IDUsIC8vIE51bSBvZiB1bnN1Y2Nlc3NmdWwgZGlhbHMgYmVmb3JlIGEgcGVlciBpcyBwZXJtYW5lbnRseSBibGFja2xpc3RlZFxuICBESUFMX1RJTUVPVVQ6IDMwZTMsIC8vIEhvdyBsb25nIGluIG1zIGEgZGlhbCBhdHRlbXB0IGlzIGFsbG93ZWQgdG8gdGFrZVxuICBNQVhfQ09MRF9DQUxMUzogNTAsIC8vIEhvdyBtYW55IGRpYWxzIHcvbyBwcm90b2NvbHMgdGhhdCBjYW4gYmUgcXVldWVkXG4gIE1BWF9QQVJBTExFTF9ESUFMUzogMTAwLCAvLyBNYXhpbXVtIGFsbG93ZWQgY29uY3VycmVudCBkaWFsc1xuICBRVUFSVEVSX0hPVVI6IDE1ICogNjBlMyxcbiAgUFJJT1JJVFlfSElHSDogMTAsXG4gIFBSSU9SSVRZX0xPVzogMjBcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBvbmNlID0gcmVxdWlyZSgnb25jZScpXG5jb25zdCBRdWV1ZSA9IHJlcXVpcmUoJy4vcXVldWUnKVxuY29uc3QgeyBESUFMX0FCT1JURUQgfSA9IHJlcXVpcmUoJy4uL2Vycm9ycycpXG5jb25zdCBuZXh0VGljayA9IHJlcXVpcmUoJ2FzeW5jL25leHRUaWNrJylcbmNvbnN0IHJldGltZXIgPSByZXF1aXJlKCdyZXRpbWVyJylcbmNvbnN0IHsgUVVBUlRFUl9IT1VSLCBQUklPUklUWV9ISUdIIH0gPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpXG5jb25zdCBsb2cgPSBkZWJ1ZygnbGlicDJwOnN3aXRjaDpkaWFsOm1hbmFnZXInKVxuY29uc3Qgbm9vcCA9ICgpID0+IHt9XG5cbmNsYXNzIERpYWxRdWV1ZU1hbmFnZXIge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3dpdGNofSBfc3dpdGNoXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoX3N3aXRjaCkge1xuICAgIHRoaXMuX3F1ZXVlID0gbmV3IFNldCgpXG4gICAgdGhpcy5fY29sZENhbGxRdWV1ZSA9IG5ldyBTZXQoKVxuICAgIHRoaXMuX2RpYWxpbmdRdWV1ZXMgPSBuZXcgU2V0KClcbiAgICB0aGlzLl9xdWV1ZXMgPSB7fVxuICAgIHRoaXMuc3dpdGNoID0gX3N3aXRjaFxuICAgIHRoaXMuX2NsZWFuSW50ZXJ2YWwgPSByZXRpbWVyKHRoaXMuX2NsZWFuLmJpbmQodGhpcyksIFFVQVJURVJfSE9VUilcbiAgICB0aGlzLnN0YXJ0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIHRocm91Z2ggYWxsIHF1ZXVlcywgYWJvcnRzIGFuZCByZW1vdmVzIHRoZW0gaWYgdGhleVxuICAgKiBhcmUgbm8gbG9uZ2VyIHZhbGlkLiBBIHF1ZXVlIHRoYXQgaXMgYmxhY2tsaXN0ZWQgaW5kZWZpbml0ZWx5LFxuICAgKiBpcyBjb25zaWRlcmVkIG5vIGxvbmdlciB2YWxpZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jbGVhbiAoKSB7XG4gICAgY29uc3QgcXVldWVzID0gT2JqZWN0LnZhbHVlcyh0aGlzLl9xdWV1ZXMpXG4gICAgcXVldWVzLmZvckVhY2goZGlhbFF1ZXVlID0+IHtcbiAgICAgIC8vIENsZWFyIGlmIHRoZSBxdWV1ZSBoYXMgcmVhY2hlZCBtYXggYmxhY2tsaXN0XG4gICAgICBpZiAoZGlhbFF1ZXVlLmJsYWNrTGlzdGVkID09PSBJbmZpbml0eSkge1xuICAgICAgICBkaWFsUXVldWUuYWJvcnQoKVxuICAgICAgICBkZWxldGUgdGhpcy5fcXVldWVzW2RpYWxRdWV1ZS5pZF1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgYmxhY2tsaXN0ZWQgcXVldWVzXG4gICAgICBpZiAoZGlhbFF1ZXVlLmJsYWNrTGlzdGVkKSByZXR1cm5cblxuICAgICAgLy8gQ2xlYXIgaWYgcGVlciBpcyBubyBsb25nZXIgYWN0aXZlXG4gICAgICAvLyBUbyBhdm9pZCByZWFsbG9jYXRpbmcgbWVtb3J5LCBkb250IGRlbGV0ZSBxdWV1ZXMgb2ZcbiAgICAgIC8vIGNvbm5lY3RlZCBwZWVycywgYXMgdGhlc2UgYXJlIGhpZ2hseSBsaWtlbHkgdG8gbGV2ZXJhZ2UgdGhlXG4gICAgICAvLyBxdWV1ZXMgaW4gdGhlIGltbWVkaWF0ZSB0ZXJtXG4gICAgICBpZiAoIWRpYWxRdWV1ZS5pc1J1bm5pbmcgJiYgZGlhbFF1ZXVlLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgbGV0IGlzQ29ubmVjdGVkID0gZmFsc2VcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBwZWVySW5mbyA9IHRoaXMuc3dpdGNoLl9wZWVyQm9vay5nZXQoZGlhbFF1ZXVlLmlkKVxuICAgICAgICAgIGlzQ29ubmVjdGVkID0gQm9vbGVhbihwZWVySW5mby5pc0Nvbm5lY3RlZCgpKVxuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgLy8gSWYgd2UgZ2V0IGFuIGVycm9yLCB0aGF0IG1lYW5zIHRoZSBwZWVyYm9vayBkb2VzbnQgaGF2ZSB0aGUgcGVlclxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0Nvbm5lY3RlZCkge1xuICAgICAgICAgIGRpYWxRdWV1ZS5hYm9ydCgpXG4gICAgICAgICAgZGVsZXRlIHRoaXMuX3F1ZXVlc1tkaWFsUXVldWUuaWRdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5fY2xlYW5JbnRlcnZhbC5yZXNjaGVkdWxlKFFVQVJURVJfSE9VUilcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvd3MgdGhlIGBEaWFsUXVldWVNYW5hZ2VyYCB0byBleGVjdXRlIGRpYWxzXG4gICAqL1xuICBzdGFydCAoKSB7XG4gICAgdGhpcy5pc1J1bm5pbmcgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZXMgb3ZlciBhbGwgaXRlbXMgaW4gdGhlIERpYWxlclF1ZXVlXG4gICAqIGFuZCBleGVjdXRlcyB0aGVyZSBjYWxsYmFjayB3aXRoIGFuIGVycm9yLlxuICAgKlxuICAgKiBUaGlzIGNhdXNlcyB0aGUgZW50aXJlIERpYWxlclF1ZXVlIHRvIGJlIGRyYWluZWRcbiAgICovXG4gIHN0b3AgKCkge1xuICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2VcbiAgICAvLyBDbGVhciB0aGUgZ2VuZXJhbCBxdWV1ZVxuICAgIHRoaXMuX3F1ZXVlLmNsZWFyKClcbiAgICAvLyBDbGVhciB0aGUgY29sZCBjYWxsIHF1ZXVlXG4gICAgdGhpcy5fY29sZENhbGxRdWV1ZS5jbGVhcigpXG5cbiAgICB0aGlzLl9jbGVhbkludGVydmFsLmNsZWFyKClcblxuICAgIC8vIEFib3J0IHRoZSBpbmRpdmlkdWFsIHBlZXIgcXVldWVzXG4gICAgY29uc3QgcXVldWVzID0gT2JqZWN0LnZhbHVlcyh0aGlzLl9xdWV1ZXMpXG4gICAgcXVldWVzLmZvckVhY2goZGlhbFF1ZXVlID0+IHtcbiAgICAgIGRpYWxRdWV1ZS5hYm9ydCgpXG4gICAgICBkZWxldGUgdGhpcy5fcXVldWVzW2RpYWxRdWV1ZS5pZF1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGBkaWFsUmVxdWVzdGAgdG8gdGhlIHF1ZXVlIGFuZCBlbnN1cmVzIHF1ZXVlIGlzIHJ1bm5pbmdcbiAgICpcbiAgICogQHBhcmFtIHtEaWFsUmVxdWVzdH0gZGlhbFJlcXVlc3RcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBhZGQgKHsgcGVlckluZm8sIHByb3RvY29sLCBvcHRpb25zLCBjYWxsYmFjayB9KSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IG9uY2UoY2FsbGJhY2spIDogbm9vcFxuXG4gICAgLy8gQWRkIHRoZSBkaWFsIHRvIGl0cyByZXNwZWN0aXZlIHF1ZXVlXG4gICAgY29uc3QgdGFyZ2V0UXVldWUgPSB0aGlzLmdldFF1ZXVlKHBlZXJJbmZvKVxuXG4gICAgLy8gQ29sZCBDYWxsXG4gICAgaWYgKG9wdGlvbnMucHJpb3JpdHkgPiBQUklPUklUWV9ISUdIKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIHRvbyBtYW55IGNvbGQgY2FsbHMsIGFib3J0IHRoZSBkaWFsIGltbWVkaWF0ZWx5XG4gICAgICBpZiAodGhpcy5fY29sZENhbGxRdWV1ZS5zaXplID49IHRoaXMuc3dpdGNoLmRpYWxlci5NQVhfQ09MRF9DQUxMUykge1xuICAgICAgICByZXR1cm4gbmV4dFRpY2soY2FsbGJhY2ssIERJQUxfQUJPUlRFRCgpKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcXVldWUuaGFzKHRhcmdldFF1ZXVlLmlkKSkge1xuICAgICAgICByZXR1cm4gbmV4dFRpY2soY2FsbGJhY2ssIERJQUxfQUJPUlRFRCgpKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRhcmdldFF1ZXVlLmFkZChwcm90b2NvbCwgb3B0aW9ucy51c2VGU00sIGNhbGxiYWNrKVxuXG4gICAgLy8gSWYgd2UncmUgYWxyZWFkeSBjb25uZWN0ZWQgdG8gdGhlIHBlZXIsIHN0YXJ0IHRoZSBxdWV1ZSBub3dcbiAgICAvLyBXaGlsZSBpdCBtaWdodCBjYXVzZSBxdWV1ZXMgdG8gZ28gb3ZlciB0aGUgbWF4IHBhcmFsbGVsIGFtb3VudCxcbiAgICAvLyBpdCBhdm9pZHMgYmxvY2tpbmcgcGVlcnMgd2UncmUgYWxyZWFkeSBjb25uZWN0ZWQgdG9cbiAgICBpZiAocGVlckluZm8uaXNDb25uZWN0ZWQoKSkge1xuICAgICAgdGFyZ2V0UXVldWUuc3RhcnQoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgZGlhbGluZyBpcyBub3QgYWxsb3dlZCwgYWJvcnRcbiAgICBpZiAoIXRhcmdldFF1ZXVlLmlzRGlhbEFsbG93ZWQoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBpZCB0byBpdHMgcmVzcGVjdGl2ZSBxdWV1ZSBzZXQgaWYgdGhlIHF1ZXVlIGlzbid0IHJ1bm5pbmdcbiAgICBpZiAoIXRhcmdldFF1ZXVlLmlzUnVubmluZykge1xuICAgICAgaWYgKG9wdGlvbnMucHJpb3JpdHkgPD0gUFJJT1JJVFlfSElHSCkge1xuICAgICAgICB0aGlzLl9xdWV1ZS5hZGQodGFyZ2V0UXVldWUuaWQpXG4gICAgICAgIHRoaXMuX2NvbGRDYWxsUXVldWUuZGVsZXRlKHRhcmdldFF1ZXVlLmlkKVxuICAgICAgLy8gT25seSBhZGQgaXQgdG8gdGhlIGNvbGQgcXVldWUgaWYgaXQncyBub3QgaW4gdGhlIG5vcm1hbCBxdWV1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY29sZENhbGxRdWV1ZS5hZGQodGFyZ2V0UXVldWUuaWQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5ydW4oKVxuICB9XG5cbiAgLyoqXG4gICAqIFdpbGwgZXhlY3V0ZSB1cCB0byBgTUFYX1BBUkFMTEVMX0RJQUxTYCBkaWFsc1xuICAgKi9cbiAgcnVuICgpIHtcbiAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSByZXR1cm5cblxuICAgIGlmICh0aGlzLl9kaWFsaW5nUXVldWVzLnNpemUgPCB0aGlzLnN3aXRjaC5kaWFsZXIuTUFYX1BBUkFMTEVMX0RJQUxTKSB7XG4gICAgICBsZXQgbmV4dFF1ZXVlID0geyBkb25lOiB0cnVlIH1cbiAgICAgIC8vIENoZWNrIHRoZSBxdWV1ZSBmaXJzdCBhbmQgZmFsbCBiYWNrIHRvIHRoZSBjb2xkIGNhbGwgcXVldWVcbiAgICAgIGlmICh0aGlzLl9xdWV1ZS5zaXplID4gMCkge1xuICAgICAgICBuZXh0UXVldWUgPSB0aGlzLl9xdWV1ZS52YWx1ZXMoKS5uZXh0KClcbiAgICAgICAgdGhpcy5fcXVldWUuZGVsZXRlKG5leHRRdWV1ZS52YWx1ZSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fY29sZENhbGxRdWV1ZS5zaXplID4gMCkge1xuICAgICAgICBuZXh0UXVldWUgPSB0aGlzLl9jb2xkQ2FsbFF1ZXVlLnZhbHVlcygpLm5leHQoKVxuICAgICAgICB0aGlzLl9jb2xkQ2FsbFF1ZXVlLmRlbGV0ZShuZXh0UXVldWUudmFsdWUpXG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0UXVldWUuZG9uZSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgbGV0IHRhcmdldFF1ZXVlID0gdGhpcy5fcXVldWVzW25leHRRdWV1ZS52YWx1ZV1cblxuICAgICAgaWYgKCF0YXJnZXRRdWV1ZSkge1xuICAgICAgICBsb2coJ21pc3NpbmcgcXVldWUgJXMsIG1heWJlIGl0IHdhcyBhYm9ydGVkPycsIG5leHRRdWV1ZS52YWx1ZSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2RpYWxpbmdRdWV1ZXMuYWRkKHRhcmdldFF1ZXVlLmlkKVxuICAgICAgdGFyZ2V0UXVldWUuc3RhcnQoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXaWxsIHJlbW92ZSB0aGUgYHBlZXJJbmZvYCBmcm9tIHRoZSBkaWFsIGJsYWNrbGlzdFxuICAgKiBAcGFyYW0ge1BlZXJJbmZvfSBwZWVySW5mb1xuICAgKi9cbiAgY2xlYXJCbGFja2xpc3QgKHBlZXJJbmZvKSB7XG4gICAgY29uc3QgcXVldWUgPSB0aGlzLmdldFF1ZXVlKHBlZXJJbmZvKVxuICAgIHF1ZXVlLmJsYWNrTGlzdGVkID0gbnVsbFxuICAgIHF1ZXVlLmJsYWNrTGlzdENvdW50ID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEEgaGFuZGxlciBmb3Igd2hlbiBkaWFsaW5nIHF1ZXVlcyBzdG9wLiBUaGlzIHdpbGwgdHJpZ2dlclxuICAgKiBgcnVuKClgIGluIG9yZGVyIHRvIGtlZXAgdGhlIHF1ZXVlIHByb2Nlc3NpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBwZWVyIGlkIG9mIHRoZSBxdWV1ZSB0aGF0IHN0b3BwZWRcbiAgICovXG4gIF9vblF1ZXVlU3RvcHBlZCAoaWQpIHtcbiAgICB0aGlzLl9kaWFsaW5nUXVldWVzLmRlbGV0ZShpZClcbiAgICB0aGlzLnJ1bigpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYFF1ZXVlYCBmb3IgdGhlIGdpdmVuIGBwZWVySW5mb2BcbiAgICogQHBhcmFtIHtQZWVySW5mb30gcGVlckluZm9cbiAgICogQHJldHVybnMge1F1ZXVlfVxuICAgKi9cbiAgZ2V0UXVldWUgKHBlZXJJbmZvKSB7XG4gICAgY29uc3QgaWQgPSBwZWVySW5mby5pZC50b0I1OFN0cmluZygpXG5cbiAgICB0aGlzLl9xdWV1ZXNbaWRdID0gdGhpcy5fcXVldWVzW2lkXSB8fCBuZXcgUXVldWUoaWQsIHRoaXMuc3dpdGNoLCB0aGlzLl9vblF1ZXVlU3RvcHBlZC5iaW5kKHRoaXMpKVxuICAgIHJldHVybiB0aGlzLl9xdWV1ZXNbaWRdXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEaWFsUXVldWVNYW5hZ2VyXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgSWRlbnRpZnkgPSByZXF1aXJlKCdsaWJwMnAtaWRlbnRpZnknKVxuXG4vKipcbiAqIEZvciBhIGdpdmVuIG11bHRpc3RyZWFtLCByZWdpc3RlcnMgdG8gaGFuZGxlIHRoZSBnaXZlbiBjb25uZWN0aW9uXG4gKiBAcGFyYW0ge011bHRpc3RyZWFtRGlhbGVyfSBtdWx0aXN0cmVhbVxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqL1xubW9kdWxlLmV4cG9ydHMubXNIYW5kbGUgPSAobXVsdGlzdHJlYW0sIGNvbm5lY3Rpb24pID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBtdWx0aXN0cmVhbS5oYW5kbGUoY29ubmVjdGlvbiwgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICByZXNvbHZlKClcbiAgICB9KVxuICB9KVxufVxuXG4vKipcbiAqIEZvciBhIGdpdmVuIG11bHRpc3RyZWFtLCBzZWxlY3RzIHRoZSBnaXZlbiBwcm90b2NvbFxuICogQHBhcmFtIHtNdWx0aXN0cmVhbURpYWxlcn0gbXVsdGlzdHJlYW1cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm90b2NvbFxuICogQHJldHVybnMge1Byb21pc2V9IFJlc29sdmVzIHRoZSBzZWxlY3RlZCBDb25uZWN0aW9uXG4gKi9cbm1vZHVsZS5leHBvcnRzLm1zU2VsZWN0ID0gKG11bHRpc3RyZWFtLCBwcm90b2NvbCkgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIG11bHRpc3RyZWFtLnNlbGVjdChwcm90b2NvbCwgKGVyciwgY29ubmVjdGlvbikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICByZXNvbHZlKGNvbm5lY3Rpb24pXG4gICAgfSlcbiAgfSlcbn1cblxuLyoqXG4gKiBSdW5zIGlkZW50aWZ5IGZvciB0aGUgZ2l2ZW4gY29ubmVjdGlvbiBhbmQgdmVyaWZpZXMgaXQgYWdhaW5zdCB0aGVcbiAqIFBlZXJJbmZvIHByb3ZpZGVkXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB7UGVlckluZm99IGNyeXB0b1BlZXJJbmZvIFRoZSBQZWVySW5mbyBkZXRlcm1pbmVkIGR1cmluZyBjcnlwdG8gZXhjaGFuZ2VcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBSZXNvbHZlcyB7cGVlckluZm8sIG9ic2VydmVkQWRkcnN9XG4gKi9cbm1vZHVsZS5leHBvcnRzLmlkZW50aWZ5RGlhbGVyID0gKGNvbm5lY3Rpb24sIGNyeXB0b1BlZXJJbmZvKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgSWRlbnRpZnkuZGlhbGVyKGNvbm5lY3Rpb24sIGNyeXB0b1BlZXJJbmZvLCAoZXJyLCBwZWVySW5mbywgb2JzZXJ2ZWRBZGRycykgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICByZXNvbHZlKHsgcGVlckluZm8sIG9ic2VydmVkQWRkcnMgfSlcbiAgICB9KVxuICB9KVxufVxuXG4vKipcbiAqIEdldCB1bmlxdWUgdmFsdWVzIGZyb20gYGFycmAgdXNpbmcgYGdldFZhbHVlYCB0byBkZXRlcm1pbmVcbiAqIHdoYXQgaXMgdXNlZCBmb3IgdW5pcXVlbmVzc1xuICogQHBhcmFtIHtBcnJheX0gYXJyIFRoZSBhcnJheSB0byBnZXQgdW5pcXVlIHZhbHVlcyBmb3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWUpfSBnZXRWYWx1ZSBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoYXQgaXMgY29tcGFyZWRcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xubW9kdWxlLmV4cG9ydHMudW5pcXVlQnkgPSAoYXJyLCBnZXRWYWx1ZSkgPT4ge1xuICByZXR1cm4gWy4uLm5ldyBNYXAoYXJyLm1hcCgoaSkgPT4gW2dldFZhbHVlKGkpLCBpXSkpLnZhbHVlcygpXVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuTGlzdGVuZXIgPSBleHBvcnRzLmxpc3RlbmVyID0gcmVxdWlyZSgnLi9saXN0ZW5lcicpXG5leHBvcnRzLkRpYWxlciA9IGV4cG9ydHMuZGlhbGVyID0gcmVxdWlyZSgnLi9kaWFsZXInKVxuZXhwb3J0cy5tYXRjaFNlbXZlciA9IHJlcXVpcmUoJy4vbGlzdGVuZXIvbWF0Y2gtc2VtdmVyJylcbmV4cG9ydHMubWF0Y2hFeGFjdCA9IHJlcXVpcmUoJy4vbGlzdGVuZXIvbWF0Y2gtZXhhY3QnKVxuZXhwb3J0cy5jb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgRlNNID0gcmVxdWlyZSgnZnNtLWV2ZW50JylcbmNvbnN0IENpcmN1aXQgPSByZXF1aXJlKCdsaWJwMnAtY2lyY3VpdCcpXG5jb25zdCBtdWx0aXN0cmVhbSA9IHJlcXVpcmUoJ211bHRpc3RyZWFtLXNlbGVjdCcpXG5jb25zdCB3aXRoSXMgPSByZXF1aXJlKCdjbGFzcy1pcycpXG5jb25zdCBCYXNlQ29ubmVjdGlvbiA9IHJlcXVpcmUoJy4vYmFzZScpXG5jb25zdCBwYXJhbGxlbCA9IHJlcXVpcmUoJ2FzeW5jL3BhcmFsbGVsJylcbmNvbnN0IG5leHRUaWNrID0gcmVxdWlyZSgnYXN5bmMvbmV4dFRpY2snKVxuY29uc3QgaWRlbnRpZnkgPSByZXF1aXJlKCdsaWJwMnAtaWRlbnRpZnknKVxuY29uc3QgZXJyQ29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcbmNvbnN0IHsgbXNIYW5kbGUsIG1zU2VsZWN0LCBpZGVudGlmeURpYWxlciB9ID0gcmVxdWlyZSgnLi4vdXRpbHMnKVxuXG5jb25zdCBvYnNlcnZlQ29ubmVjdGlvbiA9IHJlcXVpcmUoJy4uL29ic2VydmUtY29ubmVjdGlvbicpXG5jb25zdCB7XG4gIENPTk5FQ1RJT05fRkFJTEVELFxuICBESUFMX1NFTEYsXG4gIElOVkFMSURfU1RBVEVfVFJBTlNJVElPTixcbiAgTk9fVFJBTlNQT1JUU19SRUdJU1RFUkVELFxuICBtYXliZVVuZXhwZWN0ZWRFbmRcbn0gPSByZXF1aXJlKCcuLi9lcnJvcnMnKVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENvbm5lY3Rpb25PcHRpb25zXG4gKiBAcHJvcGVydHkge1N3aXRjaH0gX3N3aXRjaCBPdXIgc3dpdGNoIGluc3RhbmNlXG4gKiBAcHJvcGVydHkge1BlZXJJbmZvfSBwZWVySW5mbyBUaGUgUGVlckluZm8gb2YgdGhlIHBlZXIgdG8gZGlhbFxuICogQHByb3BlcnR5IHtNdXhlcn0gbXV4ZXIgT3B0aW9uYWwgLSBBIG11eGVkIGNvbm5lY3Rpb25cbiAqIEBwcm9wZXJ0eSB7Q29ubmVjdGlvbn0gY29ubiBPcHRpb25hbCAtIFRoZSBiYXNlIGNvbm5lY3Rpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIE9wdGlvbmFsIC0gaWRlbnRpZnkgdGhlIGNvbm5lY3Rpb24gYXMgaW5jb21pbmcgb3Igb3V0Z29pbmcuIERlZmF1bHRzIHRvIG91dC5cbiAqL1xuXG4vKipcbiAqIENvbm5lY3Rpb25GU00gaGFuZGxlcyB0aGUgY29tcGxleCBsb2dpYyBvZiBtYW5hZ2luZyBhIGNvbm5lY3Rpb25cbiAqIGJldHdlZW4gcGVlcnMuIENvbm5lY3Rpb25GU00gaXMgaW50ZXJuYWxseSBjb21wb3NlZCBvZiBhIHN0YXRlIG1hY2hpbmVcbiAqIHRvIGhlbHAgaW1wcm92ZSB0aGUgdXNhYmlsaXR5IGFuZCBkZWJ1Z2dhYmlsaXR5IG9mIGNvbm5lY3Rpb25zLiBUaGVcbiAqIHN0YXRlIG1hY2hpbmUgYWxzbyBoZWxwcyB0byBpbXByb3ZlIHRoZSBhYmlsaXR5IHRvIGhhbmRsZSBkaWFsIGJhY2tvZmYsXG4gKiBjb2FsZXNjaW5nIGRpYWxzIGFuZCBkaWFsIGxvY2tzLlxuICovXG5jbGFzcyBDb25uZWN0aW9uRlNNIGV4dGVuZHMgQmFzZUNvbm5lY3Rpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtDb25uZWN0aW9uT3B0aW9uc30gY29ubmVjdGlvbk9wdGlvbnNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeyBfc3dpdGNoLCBwZWVySW5mbywgbXV4ZXIsIGNvbm4sIHR5cGUgPSAnb3V0JyB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgX3N3aXRjaCxcbiAgICAgIG5hbWU6IGAke3R5cGV9OiR7X3N3aXRjaC5fcGVlckluZm8uaWQudG9CNThTdHJpbmcoKS5zbGljZSgwLCA4KX1gXG4gICAgfSlcblxuICAgIHRoaXMudGhlaXJQZWVySW5mbyA9IHBlZXJJbmZvXG4gICAgdGhpcy50aGVpckI1OElkID0gdGhpcy50aGVpclBlZXJJbmZvLmlkLnRvQjU4U3RyaW5nKClcblxuICAgIHRoaXMuY29ubiA9IGNvbm4gLy8gVGhlIGJhc2UgY29ubmVjdGlvblxuICAgIHRoaXMubXV4ZXIgPSBtdXhlciAvLyBUaGUgdXBncmFkZWQvbXV4ZWQgY29ubmVjdGlvblxuXG4gICAgbGV0IHN0YXJ0U3RhdGUgPSAnRElTQ09OTkVDVEVEJ1xuICAgIGlmICh0aGlzLm11eGVyKSB7XG4gICAgICBzdGFydFN0YXRlID0gJ01VWEVEJ1xuICAgIH1cblxuICAgIHRoaXMuX3N0YXRlID0gRlNNKHN0YXJ0U3RhdGUsIHtcbiAgICAgIERJU0NPTk5FQ1RFRDogeyAvLyBObyBhY3RpdmUgY29ubmVjdGlvbnMgZXhpc3QgZm9yIHRoZSBwZWVyXG4gICAgICAgIGRpYWw6ICdESUFMSU5HJyxcbiAgICAgICAgZGlzY29ubmVjdDogJ0RJU0NPTk5FQ1RFRCcsXG4gICAgICAgIGRvbmU6ICdESVNDT05ORUNURUQnXG4gICAgICB9LFxuICAgICAgRElBTElORzogeyAvLyBDcmVhdGluZyBhbiBpbml0aWFsIGNvbm5lY3Rpb25cbiAgICAgICAgYWJvcnQ6ICdBQk9SVEVEJyxcbiAgICAgICAgLy8gZW1pdCBldmVudHMgZm9yIGRpZmZlcmVudCB0cmFuc3BvcnQgZGlhbHM/XG4gICAgICAgIGRvbmU6ICdESUFMRUQnLFxuICAgICAgICBlcnJvcjogJ0VSUk9SRUQnLFxuICAgICAgICBkaXNjb25uZWN0OiAnRElTQ09OTkVDVElORydcbiAgICAgIH0sXG4gICAgICBESUFMRUQ6IHsgLy8gQmFzZSBjb25uZWN0aW9uIHRvIHBlZXIgZXN0YWJsaXNoZWRcbiAgICAgICAgZW5jcnlwdDogJ0VOQ1JZUFRJTkcnLFxuICAgICAgICBwcml2YXRpemU6ICdQUklWQVRJWklORydcbiAgICAgIH0sXG4gICAgICBQUklWQVRJWklORzogeyAvLyBQcm90ZWN0aW5nIHRoZSBiYXNlIGNvbm5lY3Rpb25cbiAgICAgICAgZG9uZTogJ1BSSVZBVElaRUQnLFxuICAgICAgICBhYm9ydDogJ0FCT1JURUQnLFxuICAgICAgICBkaXNjb25uZWN0OiAnRElTQ09OTkVDVElORydcbiAgICAgIH0sXG4gICAgICBQUklWQVRJWkVEOiB7IC8vIEJhc2UgY29ubmVjdGlvbiBpcyBwcm90ZWN0ZWRcbiAgICAgICAgZW5jcnlwdDogJ0VOQ1JZUFRJTkcnXG4gICAgICB9LFxuICAgICAgRU5DUllQVElORzogeyAvLyBFbmNyeXB0aW5nIHRoZSBiYXNlIGNvbm5lY3Rpb25cbiAgICAgICAgZG9uZTogJ0VOQ1JZUFRFRCcsXG4gICAgICAgIGVycm9yOiAnRVJST1JFRCcsXG4gICAgICAgIGRpc2Nvbm5lY3Q6ICdESVNDT05ORUNUSU5HJ1xuICAgICAgfSxcbiAgICAgIEVOQ1JZUFRFRDogeyAvLyBVcGdyYWRpbmcgY291bGQgbm90IGhhcHBlbiwgdGhlIGNvbm5lY3Rpb24gaXMgZW5jcnlwdGVkIGFuZCB3YWl0aW5nXG4gICAgICAgIHVwZ3JhZGU6ICdVUEdSQURJTkcnLFxuICAgICAgICBkaXNjb25uZWN0OiAnRElTQ09OTkVDVElORydcbiAgICAgIH0sXG4gICAgICBVUEdSQURJTkc6IHsgLy8gQXR0ZW1wdGluZyB0byB1cGdyYWRlIHRoZSBjb25uZWN0aW9uIHdpdGggbXV4ZXJzXG4gICAgICAgIHN0b3A6ICdDT05ORUNURUQnLCAvLyBJZiB3ZSBjYW5ub3QgbXV4LCBzdG9wIHVwZ3JhZGluZ1xuICAgICAgICBkb25lOiAnTVVYRUQnLFxuICAgICAgICBlcnJvcjogJ0VSUk9SRUQnLFxuICAgICAgICBkaXNjb25uZWN0OiAnRElTQ09OTkVDVElORydcbiAgICAgIH0sXG4gICAgICBNVVhFRDoge1xuICAgICAgICBkaXNjb25uZWN0OiAnRElTQ09OTkVDVElORydcbiAgICAgIH0sXG4gICAgICBDT05ORUNURUQ6IHsgLy8gQSBub24gbXV4ZWQgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZFxuICAgICAgICBkaXNjb25uZWN0OiAnRElTQ09OTkVDVElORydcbiAgICAgIH0sXG4gICAgICBESVNDT05ORUNUSU5HOiB7IC8vIFNodXR0aW5nIGRvd24gdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgZG9uZTogJ0RJU0NPTk5FQ1RFRCcsXG4gICAgICAgIGRpc2Nvbm5lY3Q6ICdESVNDT05ORUNUSU5HJ1xuICAgICAgfSxcbiAgICAgIEFCT1JURUQ6IHsgfSwgLy8gQSBzZXZlcmUgZXZlbnQgb2NjdXJyZWRcbiAgICAgIEVSUk9SRUQ6IHsgLy8gQW4gZXJyb3Igb2NjdXJyZWQsIGJ1dCBmdXR1cmUgZGlhbHMgbWF5IGJlIGFsbG93ZWRcbiAgICAgICAgZGlzY29ubmVjdDogJ0RJU0NPTk5FQ1RJTkcnIC8vIFRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIG9wdGlvbnMgaGVyZSwgYnV0IHRoaXMgaXMgYSBsaWtlbHkgYWN0aW9uXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuX3N0YXRlLm9uKCdESVNDT05ORUNURUQnLCAoKSA9PiB0aGlzLl9vbkRpc2Nvbm5lY3RlZCgpKVxuICAgIHRoaXMuX3N0YXRlLm9uKCdESUFMSU5HJywgKCkgPT4gdGhpcy5fb25EaWFsaW5nKCkpXG4gICAgdGhpcy5fc3RhdGUub24oJ0RJQUxFRCcsICgpID0+IHRoaXMuX29uRGlhbGVkKCkpXG4gICAgdGhpcy5fc3RhdGUub24oJ1BSSVZBVElaSU5HJywgKCkgPT4gdGhpcy5fb25Qcml2YXRpemluZygpKVxuICAgIHRoaXMuX3N0YXRlLm9uKCdQUklWQVRJWkVEJywgKCkgPT4gdGhpcy5fb25Qcml2YXRpemVkKCkpXG4gICAgdGhpcy5fc3RhdGUub24oJ0VOQ1JZUFRJTkcnLCAoKSA9PiB0aGlzLl9vbkVuY3J5cHRpbmcoKSlcbiAgICB0aGlzLl9zdGF0ZS5vbignRU5DUllQVEVEJywgKCkgPT4ge1xuICAgICAgdGhpcy5sb2coJ3N1Y2Nlc3NmdWxseSBlbmNyeXB0ZWQgY29ubmVjdGlvbiB0byAlcycsIHRoaXMudGhlaXJCNThJZClcbiAgICAgIHRoaXMuZW1pdCgnZW5jcnlwdGVkJywgdGhpcy5jb25uKVxuICAgIH0pXG4gICAgdGhpcy5fc3RhdGUub24oJ1VQR1JBRElORycsICgpID0+IHRoaXMuX29uVXBncmFkaW5nKCkpXG4gICAgdGhpcy5fc3RhdGUub24oJ01VWEVEJywgKCkgPT4ge1xuICAgICAgdGhpcy5sb2coJ3N1Y2Nlc3NmdWxseSBtdXhlZCBjb25uZWN0aW9uIHRvICVzJywgdGhpcy50aGVpckI1OElkKVxuICAgICAgZGVsZXRlIHRoaXMuc3dpdGNoLmNvbm5zW3RoaXMudGhlaXJCNThJZF1cbiAgICAgIHRoaXMuZW1pdCgnbXV4ZWQnLCB0aGlzLm11eGVyKVxuICAgIH0pXG4gICAgdGhpcy5fc3RhdGUub24oJ0NPTk5FQ1RFRCcsICgpID0+IHtcbiAgICAgIHRoaXMubG9nKCd1bm11eGVkIGNvbm5lY3Rpb24gb3BlbmVkIHRvICVzJywgdGhpcy50aGVpckI1OElkKVxuICAgICAgdGhpcy5lbWl0KCd1bm11eGVkJywgdGhpcy5jb25uKVxuICAgIH0pXG4gICAgdGhpcy5fc3RhdGUub24oJ0RJU0NPTk5FQ1RJTkcnLCAoKSA9PiB0aGlzLl9vbkRpc2Nvbm5lY3RpbmcoKSlcbiAgICB0aGlzLl9zdGF0ZS5vbignQUJPUlRFRCcsICgpID0+IHRoaXMuX29uQWJvcnRlZCgpKVxuICAgIHRoaXMuX3N0YXRlLm9uKCdFUlJPUkVEJywgKCkgPT4gdGhpcy5fb25FcnJvcmVkKCkpXG4gICAgdGhpcy5fc3RhdGUub24oJ2Vycm9yJywgKGVycikgPT4gdGhpcy5fb25TdGF0ZUVycm9yKGVycikpXG4gIH1cblxuICAvKipcbiAgICogUHV0cyB0aGUgc3RhdGUgaW50byBkaWFsaW5nIG1vZGVcbiAgICpcbiAgICogQGZpcmVzIENvbm5lY3Rpb25GU00jRXJyb3IgTWF5IGVtaXQgYSBESUFMX1NFTEYgZXJyb3JcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBkaWFsICgpIHtcbiAgICBpZiAodGhpcy50aGVpckI1OElkID09PSB0aGlzLm91clBlZXJJbmZvLmlkLnRvQjU4U3RyaW5nKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgRElBTF9TRUxGKCkpXG4gICAgfSBlbHNlIGlmICh0aGlzLmdldFN0YXRlKCkgPT09ICdESUFMSU5HJykge1xuICAgICAgcmV0dXJuIHRoaXMubG9nKCdhdHRlbXB0ZWQgdG8gZGlhbCB3aGlsZSBhbHJlYWR5IGRpYWxpbmcsIGlnbm9yaW5nJylcbiAgICB9XG5cbiAgICB0aGlzLl9zdGF0ZSgnZGlhbCcpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhdGVzIGEgaGFuZHNoYWtlIGZvciB0aGUgZ2l2ZW4gcHJvdG9jb2xcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3RvY29sIFRoZSBwcm90b2NvbCB0byBuZWdvdGlhdGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgQ29ubmVjdGlvbil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgc2hha2UgKHByb3RvY29sLCBjYWxsYmFjaykge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIHByb3RvY29sIHNldCB5ZXQsIGRvbid0IHBlcmZvcm0gdGhlIGhhbmRzaGFrZVxuICAgIGlmICghcHJvdG9jb2wpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBudWxsKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm11eGVyICYmIHRoaXMubXV4ZXIubmV3U3RyZWFtKSB7XG4gICAgICByZXR1cm4gdGhpcy5tdXhlci5uZXdTdHJlYW0oKGVyciwgc3RyZWFtKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCBudWxsKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sb2coJ2NyZWF0ZWQgbmV3IHN0cmVhbSB0byAlcycsIHRoaXMudGhlaXJCNThJZClcbiAgICAgICAgdGhpcy5fcHJvdG9jb2xIYW5kc2hha2UocHJvdG9jb2wsIHN0cmVhbSwgY2FsbGJhY2spXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMuX3Byb3RvY29sSGFuZHNoYWtlKHByb3RvY29sLCB0aGlzLmNvbm4sIGNhbGxiYWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIFB1dHMgdGhlIHN0YXRlIGludG8gbXV4aW5nIG1vZGVcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICB1cGdyYWRlICgpIHtcbiAgICB0aGlzLl9zdGF0ZSgndXBncmFkZScpXG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgZGlhbGluZy4gVHJhbnNpdGlvbnMgc3RhdGUgd2hlbiBzdWNjZXNzZnVsLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZmlyZXMgQ29ubmVjdGlvbkZTTSNlcnJvclxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF9vbkRpYWxpbmcgKCkge1xuICAgIHRoaXMubG9nKCdkaWFsaW5nICVzJywgdGhpcy50aGVpckI1OElkKVxuXG4gICAgaWYgKCF0aGlzLnN3aXRjaC5oYXNUcmFuc3BvcnRzKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsb3NlKE5PX1RSQU5TUE9SVFNfUkVHSVNURVJFRCgpKVxuICAgIH1cblxuICAgIGNvbnN0IHRLZXlzID0gdGhpcy5zd2l0Y2guYXZhaWxhYmxlVHJhbnNwb3J0cyh0aGlzLnRoZWlyUGVlckluZm8pXG5cbiAgICBjb25zdCBjaXJjdWl0RW5hYmxlZCA9IEJvb2xlYW4odGhpcy5zd2l0Y2gudHJhbnNwb3J0c1tDaXJjdWl0LnRhZ10pXG5cbiAgICBpZiAoY2lyY3VpdEVuYWJsZWQgJiYgIXRLZXlzLmluY2x1ZGVzKENpcmN1aXQudGFnKSkge1xuICAgICAgdEtleXMucHVzaChDaXJjdWl0LnRhZylcbiAgICB9XG5cbiAgICBjb25zdCBuZXh0VHJhbnNwb3J0ID0gKGtleSkgPT4ge1xuICAgICAgbGV0IHRyYW5zcG9ydCA9IGtleVxuICAgICAgaWYgKCF0cmFuc3BvcnQpIHtcbiAgICAgICAgaWYgKCFjaXJjdWl0RW5hYmxlZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNsb3NlKFxuICAgICAgICAgICAgQ09OTkVDVElPTl9GQUlMRUQoYENpcmN1aXQgbm90IGVuYWJsZWQgYW5kIGFsbCB0cmFuc3BvcnRzIGZhaWxlZCB0byBkaWFsIHBlZXIgJHt0aGlzLnRoZWlyQjU4SWR9IWApXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2UoXG4gICAgICAgICAgQ09OTkVDVElPTl9GQUlMRUQoYE5vIGF2YWlsYWJsZSB0cmFuc3BvcnRzIHRvIGRpYWwgcGVlciAke3RoaXMudGhlaXJCNThJZH0hYClcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAodHJhbnNwb3J0ID09PSBDaXJjdWl0LnRhZykge1xuICAgICAgICB0aGlzLnRoZWlyUGVlckluZm8ubXVsdGlhZGRycy5hZGQoYC9wMnAtY2lyY3VpdC9wMnAvJHt0aGlzLnRoZWlyQjU4SWR9YClcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2coJ2RpYWxpbmcgdHJhbnNwb3J0ICVzJywgdHJhbnNwb3J0KVxuICAgICAgdGhpcy5zd2l0Y2gudHJhbnNwb3J0LmRpYWwodHJhbnNwb3J0LCB0aGlzLnRoZWlyUGVlckluZm8sIChlcnJvcnMsIF9jb25uKSA9PiB7XG4gICAgICAgIGlmIChlcnJvcnMpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yOmNvbm5lY3Rpb25fYXR0ZW1wdF9mYWlsZWQnLCBlcnJvcnMpXG4gICAgICAgICAgdGhpcy5sb2coZXJyb3JzKVxuICAgICAgICAgIHJldHVybiBuZXh0VHJhbnNwb3J0KHRLZXlzLnNoaWZ0KCkpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbm4gPSBvYnNlcnZlQ29ubmVjdGlvbih0cmFuc3BvcnQsIG51bGwsIF9jb25uLCB0aGlzLnN3aXRjaC5vYnNlcnZlcilcbiAgICAgICAgdGhpcy5fc3RhdGUoJ2RvbmUnKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBuZXh0VHJhbnNwb3J0KHRLZXlzLnNoaWZ0KCkpXG4gIH1cblxuICAvKipcbiAgICogT25jZSBhIGNvbm5lY3Rpb24gaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGRpYWxlZCwgdGhlIGNvbm5lY3Rpb25cbiAgICogd2lsbCBiZSBwcml2YXRpemVkIG9yIGVuY3J5cHRlZCBkZXBlbmRpbmcgb24gdGhlIHByZXNlbmNlIG9mIHRoZVxuICAgKiBTd2l0Y2gucHJvdGVjdG9yLlxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF9vbkRpYWxlZCAoKSB7XG4gICAgdGhpcy5sb2coJ3N1Y2Nlc3NmdWxseSBkaWFsZWQgJXMnLCB0aGlzLnRoZWlyQjU4SWQpXG5cbiAgICB0aGlzLmVtaXQoJ2Nvbm5lY3RlZCcsIHRoaXMuY29ubilcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBkaXNjb25uZWN0aW5nLiBIYW5kbGVzIGFueSBuZWVkZWQgY2xlYW51cFxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF9vbkRpc2Nvbm5lY3RpbmcgKCkge1xuICAgIHRoaXMubG9nKCdkaXNjb25uZWN0aW5nIGZyb20gJXMnLCB0aGlzLnRoZWlyQjU4SWQsIEJvb2xlYW4odGhpcy5tdXhlcikpXG5cbiAgICBkZWxldGUgdGhpcy5zd2l0Y2guY29ubnNbdGhpcy50aGVpckI1OElkXVxuXG4gICAgbGV0IHRhc2tzID0gW11cblxuICAgIC8vIENsZWFuIHVwIHN0b3JlZCBjb25uZWN0aW9uc1xuICAgIGlmICh0aGlzLm11eGVyKSB7XG4gICAgICB0YXNrcy5wdXNoKChjYikgPT4ge1xuICAgICAgICB0aGlzLm11eGVyLmVuZCgoKSA9PiB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMubXV4ZXJcbiAgICAgICAgICBjYigpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmUgdGhlIGJhc2UgY29ubmVjdGlvbiwgYWJvcnQgaXRcbiAgICAvLyBJZ25vcmUgYWJvcnQgZXJyb3JzLCBzaW5jZSB3ZSdyZSBjbG9zaW5nXG4gICAgaWYgKHRoaXMuY29ubikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5jb25uLnNvdXJjZS5hYm9ydCgpXG4gICAgICB9IGNhdGNoIChfKSB7IH1cbiAgICAgIGRlbGV0ZSB0aGlzLmNvbm5cbiAgICB9XG5cbiAgICBwYXJhbGxlbCh0YXNrcywgKCkgPT4ge1xuICAgICAgdGhpcy5fc3RhdGUoJ2RvbmUnKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZW5jcnlwdCBgdGhpcy5jb25uYCB3aXRoIHRoZSBTd2l0Y2gncyBjcnlwdG8uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBmaXJlcyBDb25uZWN0aW9uRlNNI2Vycm9yXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgX29uRW5jcnlwdGluZyAoKSB7XG4gICAgY29uc3QgbXNEaWFsZXIgPSBuZXcgbXVsdGlzdHJlYW0uRGlhbGVyKClcbiAgICBtc0RpYWxlci5oYW5kbGUodGhpcy5jb25uLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlKG1heWJlVW5leHBlY3RlZEVuZChlcnIpKVxuICAgICAgfVxuXG4gICAgICB0aGlzLmxvZygnc2VsZWN0aW5nIGNyeXB0byAlcyB0byAlcycsIHRoaXMuc3dpdGNoLmNyeXB0by50YWcsIHRoaXMudGhlaXJCNThJZClcblxuICAgICAgbXNEaWFsZXIuc2VsZWN0KHRoaXMuc3dpdGNoLmNyeXB0by50YWcsIChlcnIsIF9jb25uKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jbG9zZShtYXliZVVuZXhwZWN0ZWRFbmQoZXJyKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9ic2VydmVkQ29ubiA9IG9ic2VydmVDb25uZWN0aW9uKG51bGwsIHRoaXMuc3dpdGNoLmNyeXB0by50YWcsIF9jb25uLCB0aGlzLnN3aXRjaC5vYnNlcnZlcilcbiAgICAgICAgY29uc3QgZW5jcnlwdGVkQ29ubiA9IHRoaXMuc3dpdGNoLmNyeXB0by5lbmNyeXB0KHRoaXMub3VyUGVlckluZm8uaWQsIG9ic2VydmVkQ29ubiwgdGhpcy50aGVpclBlZXJJbmZvLmlkLCAoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2UoZXJyKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY29ubiA9IGVuY3J5cHRlZENvbm5cbiAgICAgICAgICB0aGlzLmNvbm4uc2V0UGVlckluZm8odGhpcy50aGVpclBlZXJJbmZvKVxuICAgICAgICAgIHRoaXMuX3N0YXRlKCdkb25lJylcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyBvdmVyIGVhY2ggTXV4ZXIgb24gdGhlIFN3aXRjaCBhbmQgYXR0ZW1wdHMgdG8gdXBncmFkZVxuICAgKiB0aGUgZ2l2ZW4gYGNvbm5lY3Rpb25gLiBTdWNjZXNzZnVsIG11eGVkIGNvbm5lY3Rpb25zIHdpbGwgYmUgc3RvcmVkXG4gICAqIG9uIHRoZSBTd2l0Y2gubXV4ZWRDb25ucyB3aXRoIGBiNThJZGAgYXMgdGhlaXIga2V5IGZvciBmdXR1cmUgcmVmZXJlbmNlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF9vblVwZ3JhZGluZyAoKSB7XG4gICAgY29uc3QgbXV4ZXJzID0gT2JqZWN0LmtleXModGhpcy5zd2l0Y2gubXV4ZXJzKVxuICAgIHRoaXMubG9nKCd1cGdyYWRpbmcgY29ubmVjdGlvbiB0byAlcycsIHRoaXMudGhlaXJCNThJZClcblxuICAgIGlmIChtdXhlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhdGUoJ3N0b3AnKVxuICAgIH1cblxuICAgIGNvbnN0IG1zRGlhbGVyID0gbmV3IG11bHRpc3RyZWFtLkRpYWxlcigpXG4gICAgbXNEaWFsZXIuaGFuZGxlKHRoaXMuY29ubiwgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlkVXBncmFkZShlcnIpXG4gICAgICB9XG5cbiAgICAgIC8vIDEuIHRyeSB0byBoYW5kc2hha2UgaW4gb25lIG9mIHRoZSBtdXhlcnMgYXZhaWxhYmxlXG4gICAgICAvLyAyLiBpZiBzdWNjZWVkc1xuICAgICAgLy8gIC0gYWRkIHRoZSBtdXhlZENvbm4gdG8gdGhlIGxpc3Qgb2YgbXV4ZWRDb25uc1xuICAgICAgLy8gIC0gYWRkIGluY29tbWluZyBuZXcgc3RyZWFtcyB0byBjb25uSGFuZGxlclxuICAgICAgY29uc3QgbmV4dE11eGVyID0gKGtleSkgPT4ge1xuICAgICAgICB0aGlzLmxvZygnc2VsZWN0aW5nICVzJywga2V5KVxuICAgICAgICBtc0RpYWxlci5zZWxlY3Qoa2V5LCAoZXJyLCBfY29ubikgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChtdXhlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaWRVcGdyYWRlKGVycilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5leHRNdXhlcihtdXhlcnMuc2hpZnQoKSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBvYnNlcnZlIG11eGVkIGNvbm5lY3Rpb25zXG4gICAgICAgICAgY29uc3QgY29ubiA9IG9ic2VydmVDb25uZWN0aW9uKG51bGwsIGtleSwgX2Nvbm4sIHRoaXMuc3dpdGNoLm9ic2VydmVyKVxuXG4gICAgICAgICAgdGhpcy5tdXhlciA9IHRoaXMuc3dpdGNoLm11eGVyc1trZXldLmRpYWxlcihjb25uKVxuXG4gICAgICAgICAgdGhpcy5tdXhlci5vbmNlKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICAvLyBGb3IgaW5jb21pbmcgc3RyZWFtcywgaW4gY2FzZSBpZGVudGlmeSBpcyBvblxuICAgICAgICAgIHRoaXMubXV4ZXIub24oJ3N0cmVhbScsIChjb25uKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZygnbmV3IHN0cmVhbSBjcmVhdGVkIHZpYSBtdXhlciB0byAlcycsIHRoaXMudGhlaXJCNThJZClcbiAgICAgICAgICAgIGNvbm4uc2V0UGVlckluZm8odGhpcy50aGVpclBlZXJJbmZvKVxuICAgICAgICAgICAgdGhpcy5zd2l0Y2gucHJvdG9jb2xNdXhlcihudWxsKShjb25uKVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICB0aGlzLl9kaWRVcGdyYWRlKG51bGwpXG5cbiAgICAgICAgICAvLyBSdW4gaWRlbnRpZnkgb24gdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICBpZiAodGhpcy5zd2l0Y2guaWRlbnRpZnkpIHtcbiAgICAgICAgICAgIHRoaXMuX2lkZW50aWZ5KChlcnIsIHJlc3VsdHMpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb3NlKGVycilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnRoZWlyUGVlckluZm8gPSB0aGlzLnN3aXRjaC5fcGVlckJvb2sucHV0KHJlc3VsdHMucGVlckluZm8pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgbmV4dE11eGVyKG11eGVycy5zaGlmdCgpKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUnVucyB0aGUgaWRlbnRpZnkgcHJvdG9jb2wgb24gdGhlIGNvbm5lY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbihlcnJvciwgeyBQZWVySW5mbyB9KX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBfaWRlbnRpZnkgKGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLm11eGVyKSB7XG4gICAgICByZXR1cm4gbmV4dFRpY2soY2FsbGJhY2ssIGVyckNvZGUoJ1RoZSBjb25uZWN0aW9uIHdhcyBhbHJlYWR5IGNsb3NlZCcsICdFUlJfQ09OTkVDVElPTl9DTE9TRUQnKSlcbiAgICB9XG4gICAgdGhpcy5tdXhlci5uZXdTdHJlYW0oYXN5bmMgKGVyciwgY29ubikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIGNvbnN0IG1zID0gbmV3IG11bHRpc3RyZWFtLkRpYWxlcigpXG4gICAgICBsZXQgcmVzdWx0c1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgbXNIYW5kbGUobXMsIGNvbm4pXG4gICAgICAgIGNvbnN0IG1zQ29ubiA9IGF3YWl0IG1zU2VsZWN0KG1zLCBpZGVudGlmeS5tdWx0aWNvZGVjKVxuICAgICAgICByZXN1bHRzID0gYXdhaXQgaWRlbnRpZnlEaWFsZXIobXNDb25uLCB0aGlzLnRoZWlyUGVlckluZm8pXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBbmFseXNlcyB0aGUgZ2l2ZW4gZXJyb3IsIGlmIGl0IGV4aXN0cywgdG8gZGV0ZXJtaW5lIHdoZXJlIHRoZSBzdGF0ZSBtYWNoaW5lXG4gICAqIG5lZWRzIHRvIGdvLlxuICAgKlxuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBfZGlkVXBncmFkZSAoZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgdGhpcy5sb2coJ0Vycm9yIHVwZ3JhZGluZyBjb25uZWN0aW9uOicsIGVycilcbiAgICAgIHRoaXMuc3dpdGNoLmNvbm5zW3RoaXMudGhlaXJCNThJZF0gPSB0aGlzXG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yOnVwZ3JhZGVfZmFpbGVkJywgZXJyKVxuICAgICAgLy8gQ2FudCB1cGdyYWRlLCBob2xkIHRoZSBlbmNyeXB0ZWQgY29ubmVjdGlvblxuICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlKCdzdG9wJylcbiAgICB9XG5cbiAgICAvLyBtb3ZlIHRoZSBzdGF0ZSBtYWNoaW5lIGZvcndhcmRcbiAgICB0aGlzLl9zdGF0ZSgnZG9uZScpXG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgdGhlIHByb3RvY29sIGhhbmRzaGFrZSBmb3IgdGhlIGdpdmVuIHByb3RvY29sXG4gICAqIG92ZXIgdGhlIGdpdmVuIGNvbm5lY3Rpb24uIFRoZSByZXN1bHRpbmcgZXJyb3Igb3IgY29ubmVjdGlvblxuICAgKiB3aWxsIGJlIHJldHVybmVkIHZpYSB0aGUgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm90b2NvbFxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb25cbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgQ29ubmVjdGlvbil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgX3Byb3RvY29sSGFuZHNoYWtlIChwcm90b2NvbCwgY29ubmVjdGlvbiwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBtc0RpYWxlciA9IG5ldyBtdWx0aXN0cmVhbS5EaWFsZXIoKVxuICAgIG1zRGlhbGVyLmhhbmRsZShjb25uZWN0aW9uLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIG51bGwpXG4gICAgICB9XG5cbiAgICAgIG1zRGlhbGVyLnNlbGVjdChwcm90b2NvbCwgKGVyciwgX2Nvbm4pID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHRoaXMubG9nKCdjb3VsZCBub3QgcGVyZm9ybSBwcm90b2NvbCBoYW5kc2hha2U6JywgZXJyKVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIG51bGwpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb25uID0gb2JzZXJ2ZUNvbm5lY3Rpb24obnVsbCwgcHJvdG9jb2wsIF9jb25uLCB0aGlzLnN3aXRjaC5vYnNlcnZlcilcbiAgICAgICAgdGhpcy5sb2coJ3N1Y2Nlc3NmdWxseSBwZXJmb3JtZWQgaGFuZHNoYWtlIG9mICVzIHRvICVzJywgcHJvdG9jb2wsIHRoaXMudGhlaXJCNThJZClcbiAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0aW9uJywgY29ubilcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgY29ubilcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBzdGF0ZSB0cmFuc2l0aW9uIGVycm9yc1xuICAgKlxuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBfb25TdGF0ZUVycm9yIChlcnIpIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgSU5WQUxJRF9TVEFURV9UUkFOU0lUSU9OKGVycikpXG4gICAgdGhpcy5sb2coZXJyKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2l0aElzKENvbm5lY3Rpb25GU00sIHtcbiAgY2xhc3NOYW1lOiAnQ29ubmVjdGlvbkZTTScsXG4gIHN5bWJvbE5hbWU6ICdsaWJwMnAtc3dpdGNoL0Nvbm5lY3Rpb25GU00nXG59KVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0c1xuZXhwb3J0cy5tdWx0aWNvZGVjID0gJy9pcGZzL2lkLzEuMC4wJ1xuZXhwb3J0cy5saXN0ZW5lciA9IHJlcXVpcmUoJy4vbGlzdGVuZXInKVxuZXhwb3J0cy5kaWFsZXIgPSByZXF1aXJlKCcuL2RpYWxlcicpXG5leHBvcnRzLm1lc3NhZ2UgPSByZXF1aXJlKCcuL21lc3NhZ2UnKVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHRyeUVhY2ggPSByZXF1aXJlKCdhc3luYy90cnlFYWNoJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuXG5jb25zdCBsb2cgPSBkZWJ1ZygnbGlicDJwOnN3aXRjaDpkaWFsZXInKVxuXG5jb25zdCBEaWFsUXVldWUgPSByZXF1aXJlKCcuL3F1ZXVlJylcblxuLyoqXG4gKiBUcmFjayBkaWFscyBwZXIgcGVlciBhbmQgbGltaXRlZCB0aGVtLlxuICovXG5jbGFzcyBMaW1pdERpYWxlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgZGlhbGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGVyUGVlckxpbWl0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkaWFsVGltZW91dFxuICAgKi9cbiAgY29uc3RydWN0b3IgKHBlclBlZXJMaW1pdCwgZGlhbFRpbWVvdXQpIHtcbiAgICBsb2coJ2NyZWF0ZTogJXMgcGVlciBsaW1pdCwgJXMgZGlhbCB0aW1lb3V0JywgcGVyUGVlckxpbWl0LCBkaWFsVGltZW91dClcbiAgICB0aGlzLnBlclBlZXJMaW1pdCA9IHBlclBlZXJMaW1pdFxuICAgIHRoaXMuZGlhbFRpbWVvdXQgPSBkaWFsVGltZW91dFxuICAgIHRoaXMucXVldWVzID0gbmV3IE1hcCgpXG4gIH1cblxuICAvKipcbiAgICogRGlhbCBhIGxpc3Qgb2YgbXVsdGlhZGRycyBvbiB0aGUgZ2l2ZW4gdHJhbnNwb3J0LlxuICAgKlxuICAgKiBAcGFyYW0ge1BlZXJJZH0gcGVlclxuICAgKiBAcGFyYW0ge1N3YXJtVHJhbnNwb3J0fSB0cmFuc3BvcnRcbiAgICogQHBhcmFtIHtBcnJheTxNdWx0aWFkZHI+fSBhZGRyc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBDb25uZWN0aW9uKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBkaWFsTWFueSAocGVlciwgdHJhbnNwb3J0LCBhZGRycywgY2FsbGJhY2spIHtcbiAgICBsb2coJ2RpYWxNYW55OnN0YXJ0JylcbiAgICAvLyB3ZSB1c2UgYSB0b2tlbiB0byB0cmFjayBpZiB3ZSB3YW50IHRvIGNhbmNlbCBmb2xsb3dpbmcgZGlhbHNcbiAgICBjb25zdCB0b2tlbiA9IHsgY2FuY2VsOiBmYWxzZSB9XG5cbiAgICBsZXQgZXJyb3JzID0gW11cbiAgICBjb25zdCB0YXNrcyA9IGFkZHJzLm1hcCgobSkgPT4ge1xuICAgICAgcmV0dXJuIChjYikgPT4gdGhpcy5kaWFsU2luZ2xlKHBlZXIsIHRyYW5zcG9ydCwgbSwgdG9rZW4sIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goZXJyKVxuICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIHJlc3VsdClcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHRyeUVhY2godGFza3MsIChfLCByZXN1bHQpID0+IHtcbiAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LmNvbm4pIHtcbiAgICAgICAgbG9nKCdkaWFsTWFueTpzdWNjZXNzJylcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3VsdClcbiAgICAgIH1cblxuICAgICAgbG9nKCdkaWFsTWFueTplcnJvcicpXG4gICAgICBjYWxsYmFjayhlcnJvcnMpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBEaWFsIGEgc2luZ2xlIG11bHRpYWRkciBvbiB0aGUgZ2l2ZW4gdHJhbnNwb3J0LlxuICAgKlxuICAgKiBAcGFyYW0ge1BlZXJJZH0gcGVlclxuICAgKiBAcGFyYW0ge1N3YXJtVHJhbnNwb3J0fSB0cmFuc3BvcnRcbiAgICogQHBhcmFtIHtNdWx0aWFkZHJ9IGFkZHJcbiAgICogQHBhcmFtIHtDYW5jZWxUb2tlbn0gdG9rZW5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgQ29ubmVjdGlvbil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZGlhbFNpbmdsZSAocGVlciwgdHJhbnNwb3J0LCBhZGRyLCB0b2tlbiwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBwcyA9IHBlZXIudG9CNThTdHJpbmcoKVxuICAgIGxvZygnZGlhbFNpbmdsZTogJXM6JXMnLCBwcywgYWRkci50b1N0cmluZygpKVxuICAgIGxldCBxXG4gICAgaWYgKHRoaXMucXVldWVzLmhhcyhwcykpIHtcbiAgICAgIHEgPSB0aGlzLnF1ZXVlcy5nZXQocHMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHEgPSBuZXcgRGlhbFF1ZXVlKHRoaXMucGVyUGVlckxpbWl0LCB0aGlzLmRpYWxUaW1lb3V0KVxuICAgICAgdGhpcy5xdWV1ZXMuc2V0KHBzLCBxKVxuICAgIH1cblxuICAgIHEucHVzaCh0cmFuc3BvcnQsIGFkZHIsIHRva2VuLCBjYWxsYmFjaylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExpbWl0RGlhbGVyXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgbWFmbXQgPSByZXF1aXJlKCdtYWZtdCcpXG5jb25zdCBtdWx0aWFkZHIgPSByZXF1aXJlKCdtdWx0aWFkZHInKVxuXG5jb25zdCBDaXJjdWl0RGlhbGVyID0gcmVxdWlyZSgnLi9jaXJjdWl0L2RpYWxlcicpXG5jb25zdCB1dGlsc0ZhY3RvcnkgPSByZXF1aXJlKCcuL2NpcmN1aXQvdXRpbHMnKVxuXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJylcbmNvbnN0IGxvZyA9IGRlYnVnKCdsaWJwMnA6Y2lyY3VpdDp0cmFuc3BvcnRkaWFsZXInKVxubG9nLmVyciA9IGRlYnVnKCdsaWJwMnA6Y2lyY3VpdDplcnJvcjp0cmFuc3BvcnRkaWFsZXInKVxuXG5jb25zdCBjcmVhdGVMaXN0ZW5lciA9IHJlcXVpcmUoJy4vbGlzdGVuZXInKVxuXG5jbGFzcyBDaXJjdWl0IHtcbiAgc3RhdGljIGdldCB0YWcgKCkge1xuICAgIHJldHVybiAnQ2lyY3VpdCdcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIERpYWxlci5cbiAgICpcbiAgICogQHBhcmFtIHtTd2FybX0gc3dhcm0gLSB0aGUgc3dhcm1cbiAgICogQHBhcmFtIHthbnl9IG9wdGlvbnMgLSBjb25maWcgb3B0aW9uc1xuICAgKlxuICAgKiBAbWVtYmVyT2YgRGlhbGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoc3dhcm0sIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgICB0aGlzLnN3YXJtID0gc3dhcm1cbiAgICB0aGlzLmRpYWxlciA9IG51bGxcbiAgICB0aGlzLnV0aWxzID0gdXRpbHNGYWN0b3J5KHN3YXJtKVxuICAgIHRoaXMucGVlckluZm8gPSB0aGlzLnN3YXJtLl9wZWVySW5mb1xuICAgIHRoaXMucmVsYXlzID0gdGhpcy5maWx0ZXIodGhpcy5wZWVySW5mby5tdWx0aWFkZHJzLnRvQXJyYXkoKSlcblxuICAgIC8vIGlmIG5vIGV4cGxpY2l0IHJlbGF5cywgYWRkIGEgZGVmYXVsdCByZWxheSBhZGRyXG4gICAgaWYgKHRoaXMucmVsYXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5wZWVySW5mb1xuICAgICAgICAubXVsdGlhZGRyc1xuICAgICAgICAuYWRkKGAvcDJwLWNpcmN1aXQvaXBmcy8ke3RoaXMucGVlckluZm8uaWQudG9CNThTdHJpbmcoKX1gKVxuICAgIH1cblxuICAgIHRoaXMuZGlhbGVyID0gbmV3IENpcmN1aXREaWFsZXIoc3dhcm0sIG9wdGlvbnMpXG5cbiAgICB0aGlzLnN3YXJtLm9uKCdwZWVyLW11eC1lc3RhYmxpc2hlZCcsIChwZWVySW5mbykgPT4ge1xuICAgICAgdGhpcy5kaWFsZXIuY2FuSG9wKHBlZXJJbmZvKVxuICAgIH0pXG4gICAgdGhpcy5zd2FybS5vbigncGVlci1tdXgtY2xvc2VkJywgKHBlZXJJbmZvKSA9PiB7XG4gICAgICB0aGlzLmRpYWxlci5yZWxheVBlZXJzLmRlbGV0ZShwZWVySW5mby5pZC50b0I1OFN0cmluZygpKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRGlhbCB0aGUgcmVsYXlzIGluIHRoZSBBZGRyZXNzZXMuU3dhcm0gY29uZmlnXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJlbGF5c1xuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgX2RpYWxTd2FybVJlbGF5cyAoKSB7XG4gICAgLy8gaWYgd2UgaGF2ZSByZWxheSBhZGRyZXNzZXMgaW4gc3dhcm0gY29uZmlnLCB0aGVuIGRpYWwgdGhvc2UgcmVsYXlzXG4gICAgdGhpcy5yZWxheXMuZm9yRWFjaCgocmVsYXkpID0+IHtcbiAgICAgIGxldCByZWxheVNlZ21lbnRzID0gcmVsYXlcbiAgICAgICAgLnRvU3RyaW5nKClcbiAgICAgICAgLnNwbGl0KCcvcDJwLWNpcmN1aXQnKVxuICAgICAgICAuZmlsdGVyKHNlZ21lbnQgPT4gc2VnbWVudC5sZW5ndGgpXG5cbiAgICAgIHJlbGF5U2VnbWVudHMuZm9yRWFjaCgocmVsYXlTZWdtZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IG1hID0gdGhpcy51dGlscy5wZWVySW5mb0Zyb21NYShtdWx0aWFkZHIocmVsYXlTZWdtZW50KSlcbiAgICAgICAgdGhpcy5kaWFsZXIuX2RpYWxSZWxheShtYSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBEaWFsIGEgcGVlciBvdmVyIGEgcmVsYXlcbiAgICpcbiAgICogQHBhcmFtIHttdWx0aWFkZHJ9IG1hIC0gdGhlIG11bHRpYWRkciBvZiB0aGUgcGVlciB0byBkaWFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gZGlhbCBvcHRpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gYSBjYWxsYmFjayBjYWxsZWQgb25jZSBkaWFsZWRcbiAgICogQHJldHVybnMge0Nvbm5lY3Rpb259IC0gdGhlIGNvbm5lY3Rpb25cbiAgICpcbiAgICogQG1lbWJlck9mIERpYWxlclxuICAgKi9cbiAgZGlhbCAobWEsIG9wdGlvbnMsIGNiKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlhbGVyLmRpYWwobWEsIG9wdGlvbnMsIGNiKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGxpc3RlbmVyXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHJldHVybiB7bGlzdGVuZXJ9XG4gICAqL1xuICBjcmVhdGVMaXN0ZW5lciAob3B0aW9ucywgaGFuZGxlcikge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaGFuZGxlciA9IG9wdGlvbnNcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge31cbiAgICB9XG5cbiAgICBjb25zdCBsaXN0ZW5lciA9IGNyZWF0ZUxpc3RlbmVyKHRoaXMuc3dhcm0sIG9wdGlvbnMsIGhhbmRsZXIpXG4gICAgbGlzdGVuZXIub24oJ2xpc3RlbicsIHRoaXMuX2RpYWxTd2FybVJlbGF5cy5iaW5kKHRoaXMpKVxuICAgIHJldHVybiBsaXN0ZW5lclxuICB9XG5cbiAgLyoqXG4gICAqIEZpbHRlciBjaGVjayBmb3IgYWxsIG11bHRpYWRkcmVzc2VzXG4gICAqIHRoYXQgdGhpcyB0cmFuc3BvcnQgY2FuIGRpYWwgb25cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IG11bHRpYWRkcnNcbiAgICogQHJldHVybnMge0FycmF5PG11bHRpYWRkcj59XG4gICAqXG4gICAqIEBtZW1iZXJPZiBEaWFsZXJcbiAgICovXG4gIGZpbHRlciAobXVsdGlhZGRycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShtdWx0aWFkZHJzKSkge1xuICAgICAgbXVsdGlhZGRycyA9IFttdWx0aWFkZHJzXVxuICAgIH1cbiAgICByZXR1cm4gbXVsdGlhZGRycy5maWx0ZXIoKG1hKSA9PiB7XG4gICAgICByZXR1cm4gbWFmbXQuQ2lyY3VpdC5tYXRjaGVzKG1hKVxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDaXJjdWl0XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleHRyYWN0RGF0YUZyb21CbG9jayAoYmxvY2ssIGJsb2NrU3RhcnQsIHJlcXVlc3RlZFN0YXJ0LCByZXF1ZXN0ZWRFbmQpIHtcbiAgY29uc3QgYmxvY2tMZW5ndGggPSBibG9jay5sZW5ndGhcbiAgY29uc3QgYmxvY2tFbmQgPSBibG9ja1N0YXJ0ICsgYmxvY2tMZW5ndGhcblxuICBpZiAocmVxdWVzdGVkU3RhcnQgPj0gYmxvY2tFbmQgfHwgcmVxdWVzdGVkRW5kIDwgYmxvY2tTdGFydCkge1xuICAgIC8vIElmIHdlIGFyZSBsb29raW5nIGZvciBhIGJ5dGUgcmFuZ2UgdGhhdCBpcyBzdGFydHMgYWZ0ZXIgdGhlIHN0YXJ0IG9mIHRoZSBibG9jayxcbiAgICAvLyByZXR1cm4gYW4gZW1wdHkgYmxvY2suICBUaGlzIGNhbiBoYXBwZW4gd2hlbiBpbnRlcm5hbCBub2RlcyBjb250YWluIGRhdGFcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICBpZiAocmVxdWVzdGVkRW5kID49IGJsb2NrU3RhcnQgJiYgcmVxdWVzdGVkRW5kIDwgYmxvY2tFbmQpIHtcbiAgICAvLyBJZiB0aGUgZW5kIGJ5dGUgaXMgaW4gdGhlIGN1cnJlbnQgYmxvY2ssIHRydW5jYXRlIHRoZSBibG9jayB0byB0aGUgZW5kIGJ5dGVcbiAgICBibG9jayA9IGJsb2NrLnNsaWNlKDAsIHJlcXVlc3RlZEVuZCAtIGJsb2NrU3RhcnQpXG4gIH1cblxuICBpZiAocmVxdWVzdGVkU3RhcnQgPj0gYmxvY2tTdGFydCAmJiByZXF1ZXN0ZWRTdGFydCA8IGJsb2NrRW5kKSB7XG4gICAgLy8gSWYgdGhlIHN0YXJ0IGJ5dGUgaXMgaW4gdGhlIGN1cnJlbnQgYmxvY2ssIHNraXAgdG8gdGhlIHN0YXJ0IGJ5dGVcbiAgICBibG9jayA9IGJsb2NrLnNsaWNlKHJlcXVlc3RlZFN0YXJ0IC0gYmxvY2tTdGFydClcbiAgfVxuXG4gIHJldHVybiBibG9ja1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGVyckNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpXG5cbmNvbnN0IHZhbGlkYXRlT2Zmc2V0QW5kTGVuZ3RoID0gKHNpemUsIG9mZnNldCwgbGVuZ3RoKSA9PiB7XG4gIGlmICghb2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gMFxuICB9XG5cbiAgaWYgKG9mZnNldCA8IDApIHtcbiAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignT2Zmc2V0IG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAnKSwgJ0VSUl9JTlZBTElEX1BBUkFNUycpXG4gIH1cblxuICBpZiAob2Zmc2V0ID4gc2l6ZSkge1xuICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdPZmZzZXQgbXVzdCBiZSBsZXNzIHRoYW4gdGhlIGZpbGUgc2l6ZScpLCAnRVJSX0lOVkFMSURfUEFSQU1TJylcbiAgfVxuXG4gIGlmICghbGVuZ3RoICYmIGxlbmd0aCAhPT0gMCkge1xuICAgIGxlbmd0aCA9IHNpemUgLSBvZmZzZXRcbiAgfVxuXG4gIGlmIChsZW5ndGggPCAwKSB7XG4gICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ0xlbmd0aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwJyksICdFUlJfSU5WQUxJRF9QQVJBTVMnKVxuICB9XG5cbiAgaWYgKG9mZnNldCArIGxlbmd0aCA+IHNpemUpIHtcbiAgICBsZW5ndGggPSBzaXplIC0gb2Zmc2V0XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9mZnNldCxcbiAgICBsZW5ndGhcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkYXRlT2Zmc2V0QW5kTGVuZ3RoXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZGlyZWN0b3J5Q29udGVudCA9IChjaWQsIG5vZGUsIHVuaXhmcywgcGF0aCwgcmVzb2x2ZSwgZGVwdGgsIGlwbGQpID0+IHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uICogKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0IHx8IDBcbiAgICBjb25zdCBsZW5ndGggPSBvcHRpb25zLmxlbmd0aCB8fCBub2RlLkxpbmtzLmxlbmd0aFxuICAgIGNvbnN0IGxpbmtzID0gbm9kZS5MaW5rcy5zbGljZShvZmZzZXQsIGxlbmd0aClcblxuICAgIGZvciAoY29uc3QgbGluayBvZiBsaW5rcykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzb2x2ZShsaW5rLkhhc2gsIGxpbmsuTmFtZSwgYCR7cGF0aH0vJHtsaW5rLk5hbWV9YCwgW10sIGRlcHRoICsgMSwgaXBsZClcblxuICAgICAgeWllbGQgcmVzdWx0LmVudHJ5XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGlyZWN0b3J5Q29udGVudFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGhhbXRTaGFyZGVkRGlyZWN0b3J5Q29udGVudCA9IChjaWQsIG5vZGUsIHVuaXhmcywgcGF0aCwgcmVzb2x2ZSwgZGVwdGgsIGlwbGQpID0+IHtcbiAgcmV0dXJuIChvcHRpb25zID0ge30pID0+IHtcbiAgICByZXR1cm4gbGlzdERpcmVjdG9yeShub2RlLCBwYXRoLCByZXNvbHZlLCBkZXB0aCwgaXBsZCwgb3B0aW9ucylcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiAqIGxpc3REaXJlY3RvcnkgKG5vZGUsIHBhdGgsIHJlc29sdmUsIGRlcHRoLCBpcGxkLCBvcHRpb25zKSB7XG4gIGNvbnN0IGxpbmtzID0gbm9kZS5MaW5rc1xuXG4gIGZvciAoY29uc3QgbGluayBvZiBsaW5rcykge1xuICAgIGNvbnN0IG5hbWUgPSBsaW5rLk5hbWUuc3Vic3RyaW5nKDIpXG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzb2x2ZShsaW5rLkhhc2gsIG5hbWUsIGAke3BhdGh9LyR7bmFtZX1gLCBbXSwgZGVwdGggKyAxLCBpcGxkKVxuXG4gICAgICB5aWVsZCByZXN1bHQuZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZGVzY2VuZCBpbnRvIHN1YnNoYXJkXG4gICAgICBub2RlID0gYXdhaXQgaXBsZC5nZXQobGluay5IYXNoKVxuXG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGZpbGUgb2YgbGlzdERpcmVjdG9yeShub2RlLCBwYXRoLCByZXNvbHZlLCBkZXB0aCwgaXBsZCwgb3B0aW9ucykpIHtcbiAgICAgICAgeWllbGQgZmlsZVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhbXRTaGFyZGVkRGlyZWN0b3J5Q29udGVudFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGV4dHJhY3REYXRhRnJvbUJsb2NrID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvZXh0cmFjdC1kYXRhLWZyb20tYmxvY2snKVxuY29uc3QgdmFsaWRhdGVPZmZzZXRBbmRMZW5ndGggPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscy92YWxpZGF0ZS1vZmZzZXQtYW5kLWxlbmd0aCcpXG5jb25zdCBVbml4RlMgPSByZXF1aXJlKCdpcGZzLXVuaXhmcycpXG5jb25zdCBlcnJDb2RlID0gcmVxdWlyZSgnZXJyLWNvZGUnKVxuXG5hc3luYyBmdW5jdGlvbiAqIGVtaXRCeXRlcyAoaXBsZCwgbm9kZSwgc3RhcnQsIGVuZCwgc3RyZWFtUG9zaXRpb24gPSAwKSB7XG4gIC8vIGEgYHJhd2Agbm9kZVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG5vZGUpKSB7XG4gICAgY29uc3QgYnVmID0gZXh0cmFjdERhdGFGcm9tQmxvY2sobm9kZSwgc3RyZWFtUG9zaXRpb24sIHN0YXJ0LCBlbmQpXG5cbiAgICBpZiAoYnVmLmxlbmd0aCkge1xuICAgICAgeWllbGQgYnVmXG4gICAgfVxuXG4gICAgc3RyZWFtUG9zaXRpb24gKz0gYnVmLmxlbmd0aFxuXG4gICAgcmV0dXJuIHN0cmVhbVBvc2l0aW9uXG4gIH1cblxuICBsZXQgZmlsZVxuXG4gIHRyeSB7XG4gICAgZmlsZSA9IFVuaXhGUy51bm1hcnNoYWwobm9kZS5EYXRhKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBlcnJDb2RlKGVyciwgJ0VSUl9OT1RfVU5JWEZTJylcbiAgfVxuXG4gIC8vIG1pZ2h0IGJlIGEgdW5peGZzIGByYXdgIG5vZGUgb3IgaGF2ZSBkYXRhIG9uIGludGVybWVkaWF0ZSBub2Rlc1xuICBjb25zdCBub2RlSGFzRGF0YSA9IEJvb2xlYW4oZmlsZS5kYXRhICYmIGZpbGUuZGF0YS5sZW5ndGgpXG5cbiAgaWYgKG5vZGVIYXNEYXRhKSB7XG4gICAgY29uc3QgYnVmID0gZXh0cmFjdERhdGFGcm9tQmxvY2soZmlsZS5kYXRhLCBzdHJlYW1Qb3NpdGlvbiwgc3RhcnQsIGVuZClcblxuICAgIGlmIChidWYubGVuZ3RoKSB7XG4gICAgICB5aWVsZCBidWZcbiAgICB9XG5cbiAgICBzdHJlYW1Qb3NpdGlvbiArPSBmaWxlLmRhdGEubGVuZ3RoXG4gIH1cblxuICBsZXQgY2hpbGRTdGFydCA9IHN0cmVhbVBvc2l0aW9uXG5cbiAgLy8gd29yayBvdXQgd2hpY2ggY2hpbGQgbm9kZXMgY29udGFpbiB0aGUgcmVxdWVzdGVkIGRhdGFcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLkxpbmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGRMaW5rID0gbm9kZS5MaW5rc1tpXVxuICAgIGNvbnN0IGNoaWxkRW5kID0gc3RyZWFtUG9zaXRpb24gKyBmaWxlLmJsb2NrU2l6ZXNbaV1cblxuICAgIGlmICgoc3RhcnQgPj0gY2hpbGRTdGFydCAmJiBzdGFydCA8IGNoaWxkRW5kKSB8fCAvLyBjaGlsZCBoYXMgb2Zmc2V0IGJ5dGVcbiAgICAgICAgKGVuZCA+IGNoaWxkU3RhcnQgJiYgZW5kIDw9IGNoaWxkRW5kKSB8fCAvLyBjaGlsZCBoYXMgZW5kIGJ5dGVcbiAgICAgICAgKHN0YXJ0IDwgY2hpbGRTdGFydCAmJiBlbmQgPiBjaGlsZEVuZCkpIHsgLy8gY2hpbGQgaXMgYmV0d2VlbiBvZmZzZXQgYW5kIGVuZCBieXRlc1xuICAgICAgY29uc3QgY2hpbGQgPSBhd2FpdCBpcGxkLmdldChjaGlsZExpbmsuSGFzaClcblxuICAgICAgZm9yIGF3YWl0IChjb25zdCBidWYgb2YgZW1pdEJ5dGVzKGlwbGQsIGNoaWxkLCBzdGFydCwgZW5kLCBzdHJlYW1Qb3NpdGlvbikpIHtcbiAgICAgICAgc3RyZWFtUG9zaXRpb24gKz0gYnVmLmxlbmd0aFxuXG4gICAgICAgIHlpZWxkIGJ1ZlxuICAgICAgfVxuICAgIH1cblxuICAgIHN0cmVhbVBvc2l0aW9uID0gY2hpbGRFbmRcbiAgICBjaGlsZFN0YXJ0ID0gY2hpbGRFbmQgKyAxXG4gIH1cbn1cblxuY29uc3QgZmlsZUNvbnRlbnQgPSAoY2lkLCBub2RlLCB1bml4ZnMsIHBhdGgsIHJlc29sdmUsIGRlcHRoLCBpcGxkKSA9PiB7XG4gIHJldHVybiAob3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3QgZmlsZVNpemUgPSB1bml4ZnMuZmlsZVNpemUoKVxuXG4gICAgY29uc3Qge1xuICAgICAgb2Zmc2V0LFxuICAgICAgbGVuZ3RoXG4gICAgfSA9IHZhbGlkYXRlT2Zmc2V0QW5kTGVuZ3RoKGZpbGVTaXplLCBvcHRpb25zLm9mZnNldCwgb3B0aW9ucy5sZW5ndGgpXG5cbiAgICBjb25zdCBzdGFydCA9IG9mZnNldFxuICAgIGNvbnN0IGVuZCA9IG9mZnNldCArIGxlbmd0aFxuXG4gICAgcmV0dXJuIGVtaXRCeXRlcyhpcGxkLCBub2RlLCBzdGFydCwgZW5kKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmlsZUNvbnRlbnRcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBCdWNrZXQgPSByZXF1aXJlKCdoYW10LXNoYXJkaW5nL3NyYy9idWNrZXQnKVxuY29uc3QgRGlyU2hhcmRlZCA9IHJlcXVpcmUoJ2lwZnMtdW5peGZzLWltcG9ydGVyL3NyYy9kaXItc2hhcmRlZCcpXG5cbmNvbnN0IGFkZExpbmtzVG9IYW10QnVja2V0ID0gKGxpbmtzLCBidWNrZXQsIHJvb3RCdWNrZXQpID0+IHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgIGxpbmtzLm1hcChsaW5rID0+IHtcbiAgICAgIGlmIChsaW5rLk5hbWUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IHBhcnNlSW50KGxpbmsuTmFtZSwgMTYpXG5cbiAgICAgICAgcmV0dXJuIGJ1Y2tldC5fcHV0T2JqZWN0QXQocG9zLCBuZXcgQnVja2V0KHtcbiAgICAgICAgICBoYXNoRm46IERpclNoYXJkZWQuaGFzaEZuXG4gICAgICAgIH0sIGJ1Y2tldCwgcG9zKSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJvb3RCdWNrZXQucHV0KGxpbmsuTmFtZS5zdWJzdHJpbmcoMiksIHRydWUpXG4gICAgfSlcbiAgKVxufVxuXG5jb25zdCB0b1ByZWZpeCA9IChwb3NpdGlvbikgPT4ge1xuICByZXR1cm4gcG9zaXRpb25cbiAgICAudG9TdHJpbmcoJzE2JylcbiAgICAudG9VcHBlckNhc2UoKVxuICAgIC5wYWRTdGFydCgyLCAnMCcpXG4gICAgLnN1YnN0cmluZygwLCAyKVxufVxuXG5jb25zdCB0b0J1Y2tldFBhdGggPSAocG9zaXRpb24pID0+IHtcbiAgbGV0IGJ1Y2tldCA9IHBvc2l0aW9uLmJ1Y2tldFxuICBjb25zdCBwYXRoID0gW11cblxuICB3aGlsZSAoYnVja2V0Ll9wYXJlbnQpIHtcbiAgICBwYXRoLnB1c2goYnVja2V0KVxuXG4gICAgYnVja2V0ID0gYnVja2V0Ll9wYXJlbnRcbiAgfVxuXG4gIHBhdGgucHVzaChidWNrZXQpXG5cbiAgcmV0dXJuIHBhdGgucmV2ZXJzZSgpXG59XG5cbmNvbnN0IGZpbmRTaGFyZENpZCA9IGFzeW5jIChub2RlLCBuYW1lLCBpcGxkLCBjb250ZXh0KSA9PiB7XG4gIGlmICghY29udGV4dCkge1xuICAgIGNvbnRleHQgPSB7XG4gICAgICByb290QnVja2V0OiBuZXcgQnVja2V0KHtcbiAgICAgICAgaGFzaEZuOiBEaXJTaGFyZGVkLmhhc2hGblxuICAgICAgfSksXG4gICAgICBoYW10RGVwdGg6IDFcbiAgICB9XG5cbiAgICBjb250ZXh0Lmxhc3RCdWNrZXQgPSBjb250ZXh0LnJvb3RCdWNrZXRcbiAgfVxuXG4gIGF3YWl0IGFkZExpbmtzVG9IYW10QnVja2V0KG5vZGUuTGlua3MsIGNvbnRleHQubGFzdEJ1Y2tldCwgY29udGV4dC5yb290QnVja2V0KVxuXG4gIGNvbnN0IHBvc2l0aW9uID0gYXdhaXQgY29udGV4dC5yb290QnVja2V0Ll9maW5kTmV3QnVja2V0QW5kUG9zKG5hbWUpXG4gIGxldCBwcmVmaXggPSB0b1ByZWZpeChwb3NpdGlvbi5wb3MpXG4gIGNvbnN0IGJ1Y2tldFBhdGggPSB0b0J1Y2tldFBhdGgocG9zaXRpb24pXG5cbiAgaWYgKGJ1Y2tldFBhdGgubGVuZ3RoID4gKGNvbnRleHQuaGFtdERlcHRoKSkge1xuICAgIGNvbnRleHQubGFzdEJ1Y2tldCA9IGJ1Y2tldFBhdGhbY29udGV4dC5oYW10RGVwdGhdXG5cbiAgICBwcmVmaXggPSB0b1ByZWZpeChjb250ZXh0Lmxhc3RCdWNrZXQuX3Bvc0F0UGFyZW50KVxuICB9XG5cbiAgY29uc3QgbGluayA9IG5vZGUuTGlua3MuZmluZChsaW5rID0+IHtcbiAgICBjb25zdCBlbnRyeVByZWZpeCA9IGxpbmsuTmFtZS5zdWJzdHJpbmcoMCwgMilcbiAgICBjb25zdCBlbnRyeU5hbWUgPSBsaW5rLk5hbWUuc3Vic3RyaW5nKDIpXG5cbiAgICBpZiAoZW50cnlQcmVmaXggIT09IHByZWZpeCkge1xuICAgICAgLy8gbm90IHRoZSBlbnRyeSBvciBzdWJzaGFyZCB3ZSdyZSBsb29raW5nIGZvclxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGVudHJ5TmFtZSAmJiBlbnRyeU5hbWUgIT09IG5hbWUpIHtcbiAgICAgIC8vIG5vdCB0aGUgZW50cnkgd2UncmUgbG9va2luZyBmb3JcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH0pXG5cbiAgaWYgKCFsaW5rKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGlmIChsaW5rLk5hbWUuc3Vic3RyaW5nKDIpID09PSBuYW1lKSB7XG4gICAgcmV0dXJuIGxpbmsuSGFzaFxuICB9XG5cbiAgY29udGV4dC5oYW10RGVwdGgrK1xuXG4gIG5vZGUgPSBhd2FpdCBpcGxkLmdldChsaW5rLkhhc2gpXG5cbiAgcmV0dXJuIGZpbmRTaGFyZENpZChub2RlLCBuYW1lLCBpcGxkLCBjb250ZXh0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRTaGFyZENpZFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGNvZGVzID0ge307XG5cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yVHlwZShjb2RlLCBtZXNzYWdlLCBCYXNlKSB7XG4gIGlmICghQmFzZSkge1xuICAgIEJhc2UgPSBFcnJvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9XG4gIH1cblxuICB2YXIgTm9kZUVycm9yID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0Jhc2UpIHtcbiAgICBfaW5oZXJpdHNMb29zZShOb2RlRXJyb3IsIF9CYXNlKTtcblxuICAgIGZ1bmN0aW9uIE5vZGVFcnJvcihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICByZXR1cm4gX0Jhc2UuY2FsbCh0aGlzLCBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpKSB8fCB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBOb2RlRXJyb3I7XG4gIH0oQmFzZSk7XG5cbiAgTm9kZUVycm9yLnByb3RvdHlwZS5uYW1lID0gQmFzZS5uYW1lO1xuICBOb2RlRXJyb3IucHJvdG90eXBlLmNvZGUgPSBjb2RlO1xuICBjb2Rlc1tjb2RlXSA9IE5vZGVFcnJvcjtcbn0gLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjguMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXG5cblxuZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkge1xuICAgIHZhciBsZW4gPSBleHBlY3RlZC5sZW5ndGg7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaSk7XG4gICAgfSk7XG5cbiAgICBpZiAobGVuID4gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZC5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpLCBcIiwgb3IgXCIpICsgZXhwZWN0ZWRbbGVuIC0gMV07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0sIFwiIG9yIFwiKS5jb25jYXQoZXhwZWN0ZWRbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSk7XG4gIH1cbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGhcblxuXG5mdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgc2VhcmNoLCBwb3MpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoIXBvcyB8fCBwb3MgPCAwID8gMCA6ICtwb3MsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxuXG5cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvaW5jbHVkZXNcblxuXG5mdW5jdGlvbiBpbmNsdWRlcyhzdHIsIHNlYXJjaCwgc3RhcnQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cblxuICBpZiAoc3RhcnQgKyBzZWFyY2gubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoLCBzdGFydCkgIT09IC0xO1xuICB9XG59XG5cbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfT1BUX1ZBTFVFJywgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiAnVGhlIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcIicgKyBuYW1lICsgJ1wiJztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJywgZnVuY3Rpb24gKG5hbWUsIGV4cGVjdGVkLCBhY3R1YWwpIHtcbiAgLy8gZGV0ZXJtaW5lcjogJ211c3QgYmUnIG9yICdtdXN0IG5vdCBiZSdcbiAgdmFyIGRldGVybWluZXI7XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgc3RhcnRzV2l0aChleHBlY3RlZCwgJ25vdCAnKSkge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBub3QgYmUnO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IGJlJztcbiAgfVxuXG4gIHZhciBtc2c7XG5cbiAgaWYgKGVuZHNXaXRoKG5hbWUsICcgYXJndW1lbnQnKSkge1xuICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcbiAgICBtc2cgPSBcIlRoZSBcIi5jb25jYXQobmFtZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdHlwZSA9IGluY2x1ZGVzKG5hbWUsICcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcbiAgICBtc2cgPSBcIlRoZSBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIiBcIikuY29uY2F0KHR5cGUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH1cblxuICBtc2cgKz0gXCIuIFJlY2VpdmVkIHR5cGUgXCIuY29uY2F0KHR5cGVvZiBhY3R1YWwpO1xuICByZXR1cm4gbXNnO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRicsICdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCcsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiAnVGhlICcgKyBuYW1lICsgJyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkJztcbn0pO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRScsICdQcmVtYXR1cmUgY2xvc2UnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9ERVNUUk9ZRUQnLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gJ0Nhbm5vdCBjYWxsICcgKyBuYW1lICsgJyBhZnRlciBhIHN0cmVhbSB3YXMgZGVzdHJveWVkJztcbn0pO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTVVMVElQTEVfQ0FMTEJBQ0snLCAnQ2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fQ0FOTk9UX1BJUEUnLCAnQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCcsICd3cml0ZSBhZnRlciBlbmQnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUycsICdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScsIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9VTktOT1dOX0VOQ09ESU5HJywgZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBhcmc7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UJywgJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG5tb2R1bGUuZXhwb3J0cy5jb2RlcyA9IGNvZGVzO1xuIiwiJ3VzZSBzdHJpY3QnOyAvLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5cbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfSAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG5cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvckFuZENsb3NlTlQoc2VsZiwgZXJyKSB7XG4gIGVtaXRFcnJvck5UKHNlbGYsIGVycik7XG4gIGVtaXRDbG9zZU5UKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBlbWl0Q2xvc2VOVChzZWxmKSB7XG4gIGlmIChzZWxmLl93cml0YWJsZVN0YXRlICYmICFzZWxmLl93cml0YWJsZVN0YXRlLmVtaXRDbG9zZSkgcmV0dXJuO1xuICBpZiAoc2VsZi5fcmVhZGFibGVTdGF0ZSAmJiAhc2VsZi5fcmVhZGFibGVTdGF0ZS5lbWl0Q2xvc2UpIHJldHVybjtcbiAgc2VsZi5lbWl0KCdjbG9zZScpO1xufVxuXG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5hbENhbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUucHJlZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbmZ1bmN0aW9uIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyKSB7XG4gIC8vIFdlIGhhdmUgdGVzdHMgdGhhdCByZWx5IG9uIGVycm9ycyBiZWluZyBlbWl0dGVkXG4gIC8vIGluIHRoZSBzYW1lIHRpY2ssIHNvIGNoYW5naW5nIHRoaXMgaXMgc2VtdmVyIG1ham9yLlxuICAvLyBGb3Igbm93IHdoZW4geW91IG9wdC1pbiB0byBhdXRvRGVzdHJveSB3ZSBhbGxvd1xuICAvLyB0aGUgZXJyb3IgdG8gYmUgZW1pdHRlZCBuZXh0VGljay4gSW4gYSBmdXR1cmVcbiAgLy8gc2VtdmVyIG1ham9yIHVwZGF0ZSB3ZSBzaG91bGQgY2hhbmdlIHRoZSBkZWZhdWx0IHRvIHRoaXMuXG4gIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIGlmIChyU3RhdGUgJiYgclN0YXRlLmF1dG9EZXN0cm95IHx8IHdTdGF0ZSAmJiB3U3RhdGUuYXV0b0Rlc3Ryb3kpIHN0cmVhbS5kZXN0cm95KGVycik7ZWxzZSBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzdHJveTogZGVzdHJveSxcbiAgdW5kZXN0cm95OiB1bmRlc3Ryb3ksXG4gIGVycm9yT3JEZXN0cm95OiBlcnJvck9yRGVzdHJveVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEVSUl9JTlZBTElEX09QVF9WQUxVRSA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLkVSUl9JTlZBTElEX09QVF9WQUxVRTtcblxuZnVuY3Rpb24gaGlnaFdhdGVyTWFya0Zyb20ob3B0aW9ucywgaXNEdXBsZXgsIGR1cGxleEtleSkge1xuICByZXR1cm4gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrICE9IG51bGwgPyBvcHRpb25zLmhpZ2hXYXRlck1hcmsgOiBpc0R1cGxleCA/IG9wdGlvbnNbZHVwbGV4S2V5XSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEhpZ2hXYXRlck1hcmsoc3RhdGUsIG9wdGlvbnMsIGR1cGxleEtleSwgaXNEdXBsZXgpIHtcbiAgdmFyIGh3bSA9IGhpZ2hXYXRlck1hcmtGcm9tKG9wdGlvbnMsIGlzRHVwbGV4LCBkdXBsZXhLZXkpO1xuXG4gIGlmIChod20gIT0gbnVsbCkge1xuICAgIGlmICghKGlzRmluaXRlKGh3bSkgJiYgTWF0aC5mbG9vcihod20pID09PSBod20pIHx8IGh3bSA8IDApIHtcbiAgICAgIHZhciBuYW1lID0gaXNEdXBsZXggPyBkdXBsZXhLZXkgOiAnaGlnaFdhdGVyTWFyayc7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfT1BUX1ZBTFVFKG5hbWUsIGh3bSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoaHdtKTtcbiAgfSAvLyBEZWZhdWx0IHZhbHVlXG5cblxuICByZXR1cm4gc3RhdGUub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0SGlnaFdhdGVyTWFyazogZ2V0SGlnaFdhdGVyTWFya1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdSZWFkYWJsZS5mcm9tIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGJyb3dzZXInKVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnYnVmZmVyJyksXG4gICAgQnVmZmVyID0gX3JlcXVpcmUuQnVmZmVyO1xuXG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZSgndXRpbCcpLFxuICAgIGluc3BlY3QgPSBfcmVxdWlyZTIuaW5zcGVjdDtcblxudmFyIGN1c3RvbSA9IGluc3BlY3QgJiYgaW5zcGVjdC5jdXN0b20gfHwgJ2luc3BlY3QnO1xuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5jb3B5LmNhbGwoc3JjLCB0YXJnZXQsIG9mZnNldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG5cbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJ1ZmZlckxpc3QsIFt7XG4gICAga2V5OiBcInB1c2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgIGRhdGE6IHYsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICAgICsrdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVuc2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgIGRhdGE6IHYsXG4gICAgICAgIG5leHQ6IHRoaXMuaGVhZFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICAgICsrdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImpvaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gam9pbihzKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuXG4gICAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29uY2F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgb3IgY2hhcmFjdGVycyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29uc3VtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25zdW1lKG4sIGhhc1N0cmluZ3MpIHtcbiAgICAgIHZhciByZXQ7XG5cbiAgICAgIGlmIChuIDwgdGhpcy5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIC8vIGBzbGljZWAgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICAgIHJldCA9IHRoaXMuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgICAgICB0aGlzLmhlYWQuZGF0YSA9IHRoaXMuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICAgICAgfSBlbHNlIGlmIChuID09PSB0aGlzLmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgLy8gRmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoLlxuICAgICAgICByZXQgPSB0aGlzLnNoaWZ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXIuXG4gICAgICAgIHJldCA9IGhhc1N0cmluZ3MgPyB0aGlzLl9nZXRTdHJpbmcobikgOiB0aGlzLl9nZXRCdWZmZXIobik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpcnN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpcnN0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIH0gLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFN0cmluZyhuKSB7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBjID0gMTtcbiAgICAgIHZhciByZXQgPSBwLmRhdGE7XG4gICAgICBuIC09IHJldC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgICAgIG4gLT0gbmI7XG5cbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICsrYztcbiAgICAgICAgICAgIGlmIChwLm5leHQpIHRoaXMuaGVhZCA9IHAubmV4dDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHA7XG4gICAgICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgKytjO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCAtPSBjO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEJ1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QnVmZmVyKG4pIHtcbiAgICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBjID0gMTtcbiAgICAgIHAuZGF0YS5jb3B5KHJldCk7XG4gICAgICBuIC09IHAuZGF0YS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICAgICAgbiAtPSBuYjtcblxuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICAgICAgKytjO1xuICAgICAgICAgICAgaWYgKHAubmV4dCkgdGhpcy5oZWFkID0gcC5uZXh0O2Vsc2UgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gcDtcbiAgICAgICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICArK2M7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoIC09IGM7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gLy8gTWFrZSBzdXJlIHRoZSBsaW5rZWQgbGlzdCBvbmx5IHNob3dzIHRoZSBtaW5pbWFsIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbi5cblxuICB9LCB7XG4gICAga2V5OiBjdXN0b20sXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKF8sIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBpbnNwZWN0KHRoaXMsIF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgLy8gT25seSBpbnNwZWN0IG9uZSBsZXZlbC5cbiAgICAgICAgZGVwdGg6IDAsXG4gICAgICAgIC8vIEl0IHNob3VsZCBub3QgcmVjdXJzZS5cbiAgICAgICAgY3VzdG9tSW5zcGVjdDogZmFsc2VcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfT2JqZWN0JHNldFByb3RvdHlwZU87XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBmaW5pc2hlZCA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpO1xuXG52YXIga0xhc3RSZXNvbHZlID0gU3ltYm9sKCdsYXN0UmVzb2x2ZScpO1xudmFyIGtMYXN0UmVqZWN0ID0gU3ltYm9sKCdsYXN0UmVqZWN0Jyk7XG52YXIga0Vycm9yID0gU3ltYm9sKCdlcnJvcicpO1xudmFyIGtFbmRlZCA9IFN5bWJvbCgnZW5kZWQnKTtcbnZhciBrTGFzdFByb21pc2UgPSBTeW1ib2woJ2xhc3RQcm9taXNlJyk7XG52YXIga0hhbmRsZVByb21pc2UgPSBTeW1ib2woJ2hhbmRsZVByb21pc2UnKTtcbnZhciBrU3RyZWFtID0gU3ltYm9sKCdzdHJlYW0nKTtcblxuZnVuY3Rpb24gY3JlYXRlSXRlclJlc3VsdCh2YWx1ZSwgZG9uZSkge1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBkb25lOiBkb25lXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlYWRBbmRSZXNvbHZlKGl0ZXIpIHtcbiAgdmFyIHJlc29sdmUgPSBpdGVyW2tMYXN0UmVzb2x2ZV07XG5cbiAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICB2YXIgZGF0YSA9IGl0ZXJba1N0cmVhbV0ucmVhZCgpOyAvLyB3ZSBkZWZlciBpZiBkYXRhIGlzIG51bGxcbiAgICAvLyB3ZSBjYW4gYmUgZXhwZWN0aW5nIGVpdGhlciAnZW5kJyBvclxuICAgIC8vICdlcnJvcidcblxuICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICBpdGVyW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgaXRlcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgIGl0ZXJba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvblJlYWRhYmxlKGl0ZXIpIHtcbiAgLy8gd2Ugd2FpdCBmb3IgdGhlIG5leHQgdGljaywgYmVjYXVzZSBpdCBtaWdodFxuICAvLyBlbWl0IGFuIGVycm9yIHdpdGggcHJvY2Vzcy5uZXh0VGlja1xuICBwcm9jZXNzLm5leHRUaWNrKHJlYWRBbmRSZXNvbHZlLCBpdGVyKTtcbn1cblxuZnVuY3Rpb24gd3JhcEZvck5leHQobGFzdFByb21pc2UsIGl0ZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBsYXN0UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpdGVyW2tFbmRlZF0pIHtcbiAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGl0ZXJba0hhbmRsZVByb21pc2VdKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSwgcmVqZWN0KTtcbiAgfTtcbn1cblxudmFyIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnVuY3Rpb24gKCkge30pO1xudmFyIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZigoX09iamVjdCRzZXRQcm90b3R5cGVPID0ge1xuICBnZXQgc3RyZWFtKCkge1xuICAgIHJldHVybiB0aGlzW2tTdHJlYW1dO1xuICB9LFxuXG4gIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vIGlmIHdlIGhhdmUgZGV0ZWN0ZWQgYW4gZXJyb3IgaW4gdGhlIG1lYW53aGlsZVxuICAgIC8vIHJlamVjdCBzdHJhaWdodCBhd2F5XG4gICAgdmFyIGVycm9yID0gdGhpc1trRXJyb3JdO1xuXG4gICAgaWYgKGVycm9yICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIGlmICh0aGlzW2tFbmRlZF0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpc1trU3RyZWFtXS5kZXN0cm95ZWQpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gZGVmZXIgdmlhIG5leHRUaWNrIGJlY2F1c2UgaWYgLmRlc3Ryb3koZXJyKSBpc1xuICAgICAgLy8gY2FsbGVkLCB0aGUgZXJyb3Igd2lsbCBiZSBlbWl0dGVkIHZpYSBuZXh0VGljaywgYW5kXG4gICAgICAvLyB3ZSBjYW5ub3QgZ3VhcmFudGVlIHRoYXQgdGhlcmUgaXMgbm8gZXJyb3IgbGluZ2VyaW5nIGFyb3VuZFxuICAgICAgLy8gd2FpdGluZyB0byBiZSBlbWl0dGVkLlxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzW2tFcnJvcl0pIHtcbiAgICAgICAgICAgIHJlamVjdChfdGhpc1trRXJyb3JdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IC8vIGlmIHdlIGhhdmUgbXVsdGlwbGUgbmV4dCgpIGNhbGxzXG4gICAgLy8gd2Ugd2lsbCB3YWl0IGZvciB0aGUgcHJldmlvdXMgUHJvbWlzZSB0byBmaW5pc2hcbiAgICAvLyB0aGlzIGxvZ2ljIGlzIG9wdGltaXplZCB0byBzdXBwb3J0IGZvciBhd2FpdCBsb29wcyxcbiAgICAvLyB3aGVyZSBuZXh0KCkgaXMgb25seSBjYWxsZWQgb25jZSBhdCBhIHRpbWVcblxuXG4gICAgdmFyIGxhc3RQcm9taXNlID0gdGhpc1trTGFzdFByb21pc2VdO1xuICAgIHZhciBwcm9taXNlO1xuXG4gICAgaWYgKGxhc3RQcm9taXNlKSB7XG4gICAgICBwcm9taXNlID0gbmV3IFByb21pc2Uod3JhcEZvck5leHQobGFzdFByb21pc2UsIHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZmFzdCBwYXRoIG5lZWRlZCB0byBzdXBwb3J0IG11bHRpcGxlIHRoaXMucHVzaCgpXG4gICAgICAvLyB3aXRob3V0IHRyaWdnZXJpbmcgdGhlIG5leHQoKSBxdWV1ZVxuICAgICAgdmFyIGRhdGEgPSB0aGlzW2tTdHJlYW1dLnJlYWQoKTtcblxuICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgICB9XG5cbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh0aGlzW2tIYW5kbGVQcm9taXNlXSk7XG4gICAgfVxuXG4gICAgdGhpc1trTGFzdFByb21pc2VdID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxufSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3Qkc2V0UHJvdG90eXBlTywgU3ltYm9sLmFzeW5jSXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3Qkc2V0UHJvdG90eXBlTywgXCJyZXR1cm5cIiwgZnVuY3Rpb24gX3JldHVybigpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgLy8gZGVzdHJveShlcnIsIGNiKSBpcyBhIHByaXZhdGUgQVBJXG4gIC8vIHdlIGNhbiBndWFyYW50ZWUgd2UgaGF2ZSB0aGF0IGhlcmUsIGJlY2F1c2Ugd2UgY29udHJvbCB0aGVcbiAgLy8gUmVhZGFibGUgY2xhc3MgdGhpcyBpcyBhdHRhY2hlZCB0b1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIF90aGlzMltrU3RyZWFtXS5kZXN0cm95KG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH0pO1xuICB9KTtcbn0pLCBfT2JqZWN0JHNldFByb3RvdHlwZU8pLCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlKTtcblxudmFyIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9IGZ1bmN0aW9uIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcihzdHJlYW0pIHtcbiAgdmFyIF9PYmplY3QkY3JlYXRlO1xuXG4gIHZhciBpdGVyYXRvciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlLCAoX09iamVjdCRjcmVhdGUgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrU3RyZWFtLCB7XG4gICAgdmFsdWU6IHN0cmVhbSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlc29sdmUsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlamVjdCwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFcnJvciwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFbmRlZCwge1xuICAgIHZhbHVlOiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrSGFuZGxlUHJvbWlzZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBkYXRhID0gaXRlcmF0b3Jba1N0cmVhbV0ucmVhZCgpO1xuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IHJlc29sdmU7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IHJlamVjdDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfT2JqZWN0JGNyZWF0ZSkpO1xuICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgZmluaXNoZWQoc3RyZWFtLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVyciAmJiBlcnIuY29kZSAhPT0gJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJykge1xuICAgICAgdmFyIHJlamVjdCA9IGl0ZXJhdG9yW2tMYXN0UmVqZWN0XTsgLy8gcmVqZWN0IGlmIHdlIGFyZSB3YWl0aW5nIGZvciBkYXRhIGluIHRoZSBQcm9taXNlXG4gICAgICAvLyByZXR1cm5lZCBieSBuZXh0KCkgYW5kIHN0b3JlIHRoZSBlcnJvclxuXG4gICAgICBpZiAocmVqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdG9yW2tFcnJvcl0gPSBlcnI7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlc29sdmUgPSBpdGVyYXRvcltrTGFzdFJlc29sdmVdO1xuXG4gICAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGl0ZXJhdG9yW2tFbmRlZF0gPSB0cnVlO1xuICB9KTtcbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIG9uUmVhZGFibGUuYmluZChudWxsLCBpdGVyYXRvcikpO1xuICByZXR1cm4gaXRlcmF0b3I7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjsiLCIndXNlIHN0cmljdCdcblxuY29uc3QgbWggPSByZXF1aXJlKCdtdWx0aWhhc2hlcycpXG5jb25zdCBtYyA9IHJlcXVpcmUoJ211bHRpY29kZWMnKVxuXG5jb25zdCBwZXJzaXN0ID0gKG5vZGUsIGlwbGQsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFvcHRpb25zLmNvZGVjICYmIG5vZGUubGVuZ3RoKSB7XG4gICAgb3B0aW9ucy5jaWRWZXJzaW9uID0gMVxuICAgIG9wdGlvbnMuY29kZWMgPSAncmF3J1xuICB9XG5cbiAgaWYgKGlzTmFOKG9wdGlvbnMuaGFzaEFsZykpIHtcbiAgICBvcHRpb25zLmhhc2hBbGcgPSBtaC5uYW1lc1tvcHRpb25zLmhhc2hBbGddXG4gIH1cblxuICBpZiAob3B0aW9ucy5oYXNoQWxnICE9PSBtaC5uYW1lc1snc2hhMi0yNTYnXSkge1xuICAgIG9wdGlvbnMuY2lkVmVyc2lvbiA9IDFcbiAgfVxuXG4gIGlmIChvcHRpb25zLmZvcm1hdCkge1xuICAgIG9wdGlvbnMuY29kZWMgPSBvcHRpb25zLmZvcm1hdFxuICB9XG5cbiAgY29uc3QgZm9ybWF0ID0gbWNbb3B0aW9ucy5jb2RlYy50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoLy0vZywgJ18nKV1cblxuICByZXR1cm4gaXBsZC5wdXQobm9kZSwgZm9ybWF0LCBvcHRpb25zKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBlcnNpc3RcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIERBR0xpbmssXG4gIERBR05vZGVcbn0gPSByZXF1aXJlKCdpcGxkLWRhZy1wYicpXG5jb25zdCBVbml4RlMgPSByZXF1aXJlKCdpcGZzLXVuaXhmcycpXG5jb25zdCBtdWx0aWhhc2hpbmcgPSByZXF1aXJlKCdtdWx0aWhhc2hpbmctYXN5bmMnKVxuY29uc3QgRGlyID0gcmVxdWlyZSgnLi9kaXInKVxuY29uc3QgcGVyc2lzdCA9IHJlcXVpcmUoJy4vdXRpbHMvcGVyc2lzdCcpXG5jb25zdCBCdWNrZXQgPSByZXF1aXJlKCdoYW10LXNoYXJkaW5nJylcbmNvbnN0IGV4dGVuZCA9IHJlcXVpcmUoJ2RlZXAtZXh0ZW5kJylcblxuY29uc3QgaGFzaEZuID0gYXN5bmMgZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGNvbnN0IGhhc2ggPSBhd2FpdCBtdWx0aWhhc2hpbmcoQnVmZmVyLmZyb20odmFsdWUsICd1dGY4JyksICdtdXJtdXIzLTEyOCcpXG5cbiAgLy8gTXVsdGloYXNoaW5nIGluc2VydHMgcHJlYW1ibGUgb2YgMiBieXRlcy4gUmVtb3ZlIGl0LlxuICAvLyBBbHNvLCBtdXJtdXIzIG91dHB1dHMgMTI4IGJpdCBidXQsIGFjY2lkZW50bHksIElQRlMgR28nc1xuICAvLyBpbXBsZW1lbnRhdGlvbiBvbmx5IHVzZXMgdGhlIGZpcnN0IDY0LCBzbyB3ZSBtdXN0IGRvIHRoZSBzYW1lXG4gIC8vIGZvciBwYXJpdHkuLlxuICBjb25zdCBqdXN0SGFzaCA9IGhhc2guc2xpY2UoMiwgMTApXG4gIGNvbnN0IGxlbmd0aCA9IGp1c3RIYXNoLmxlbmd0aFxuICBjb25zdCByZXN1bHQgPSBCdWZmZXIuYWxsb2MobGVuZ3RoKVxuICAvLyBUT0RPOiBpbnZlcnQgYnVmZmVyIGJlY2F1c2UgdGhhdCdzIGhvdyBHbyBpbXBsIGRvZXMgaXRcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdFtsZW5ndGggLSBpIC0gMV0gPSBqdXN0SGFzaFtpXVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuaGFzaEZuLmNvZGUgPSAweDIyIC8vIFRPRE86IGdldCB0aGlzIGZyb20gbXVsdGloYXNoaW5nLWFzeW5jP1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgaGFzaEZuOiBoYXNoRm5cbn1cblxuY2xhc3MgRGlyU2hhcmRlZCBleHRlbmRzIERpciB7XG4gIGNvbnN0cnVjdG9yIChwcm9wcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKVxuXG4gICAgc3VwZXIocHJvcHMsIG9wdGlvbnMpXG5cbiAgICB0aGlzLl9idWNrZXQgPSBCdWNrZXQob3B0aW9ucylcbiAgfVxuXG4gIGFzeW5jIHB1dCAobmFtZSwgdmFsdWUpIHtcbiAgICBhd2FpdCB0aGlzLl9idWNrZXQucHV0KG5hbWUsIHZhbHVlKVxuICB9XG5cbiAgZ2V0IChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2J1Y2tldC5nZXQobmFtZSlcbiAgfVxuXG4gIGNoaWxkQ291bnQgKCkge1xuICAgIHJldHVybiB0aGlzLl9idWNrZXQubGVhZkNvdW50KClcbiAgfVxuXG4gIGRpcmVjdENoaWxkcmVuQ291bnQgKCkge1xuICAgIHJldHVybiB0aGlzLl9idWNrZXQuY2hpbGRyZW5Db3VudCgpXG4gIH1cblxuICBvbmx5Q2hpbGQgKCkge1xuICAgIHJldHVybiB0aGlzLl9idWNrZXQub25seUNoaWxkKClcbiAgfVxuXG4gIGFzeW5jICogZWFjaENoaWxkU2VyaWVzICgpIHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHsga2V5LCB2YWx1ZSB9IG9mIHRoaXMuX2J1Y2tldC5lYWNoTGVhZlNlcmllcygpKSB7XG4gICAgICB5aWVsZCB7XG4gICAgICAgIGtleSxcbiAgICAgICAgY2hpbGQ6IHZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgKiBmbHVzaCAocGF0aCwgaXBsZCkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgZW50cnkgb2YgZmx1c2gocGF0aCwgdGhpcy5fYnVja2V0LCBpcGxkLCB0aGlzLm9wdGlvbnMpKSB7XG4gICAgICB5aWVsZCBlbnRyeVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERpclNoYXJkZWRcblxubW9kdWxlLmV4cG9ydHMuaGFzaEZuID0gaGFzaEZuXG5cbmFzeW5jIGZ1bmN0aW9uICogZmx1c2ggKHBhdGgsIGJ1Y2tldCwgaXBsZCwgb3B0aW9ucykge1xuICBjb25zdCBjaGlsZHJlbiA9IGJ1Y2tldC5fY2hpbGRyZW5cbiAgY29uc3QgbGlua3MgPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuLmdldChpKVxuXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbFByZWZpeCA9IGkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkucGFkU3RhcnQoMiwgJzAnKVxuXG4gICAgaWYgKEJ1Y2tldC5pc0J1Y2tldChjaGlsZCkpIHtcbiAgICAgIGxldCBzaGFyZFxuXG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IHN1YlNoYXJkIG9mIGF3YWl0IGZsdXNoKCcnLCBjaGlsZCwgaXBsZCwgb3B0aW9ucykpIHtcbiAgICAgICAgc2hhcmQgPSBzdWJTaGFyZFxuICAgICAgfVxuXG4gICAgICBsaW5rcy5wdXNoKGF3YWl0IG5ldyBEQUdMaW5rKGxhYmVsUHJlZml4LCBzaGFyZC5ub2RlLnNpemUsIHNoYXJkLmNpZCkpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY2hpbGQudmFsdWUuZmx1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnN0IGRpciA9IGNoaWxkLnZhbHVlXG4gICAgICBsZXQgZmx1c2hlZERpclxuXG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGVudHJ5IG9mIGRpci5mbHVzaChkaXIucGF0aCwgaXBsZCkpIHtcbiAgICAgICAgZmx1c2hlZERpciA9IGVudHJ5XG5cbiAgICAgICAgeWllbGQgZmx1c2hlZERpclxuICAgICAgfVxuXG4gICAgICBjb25zdCBsYWJlbCA9IGxhYmVsUHJlZml4ICsgY2hpbGQua2V5XG4gICAgICBsaW5rcy5wdXNoKG5ldyBEQUdMaW5rKGxhYmVsLCBmbHVzaGVkRGlyLm5vZGUuc2l6ZSwgZmx1c2hlZERpci5jaWQpKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGNoaWxkLnZhbHVlXG5cbiAgICAgIGlmICghdmFsdWUubm9kZSkge1xuICAgICAgICBpZiAodmFsdWUuY2lkKSB7XG4gICAgICAgICAgdmFsdWUubm9kZSA9IGF3YWl0IGlwbGQuZ2V0KHZhbHVlLmNpZClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxhYmVsID0gbGFiZWxQcmVmaXggKyBjaGlsZC5rZXlcbiAgICAgIGNvbnN0IHNpemUgPSB2YWx1ZS5ub2RlLmxlbmd0aCB8fCB2YWx1ZS5ub2RlLnNpemUgfHwgdmFsdWUubm9kZS5TaXplXG5cbiAgICAgIGxpbmtzLnB1c2goYXdhaXQgbmV3IERBR0xpbmsobGFiZWwsIHNpemUsIHZhbHVlLmNpZCkpXG4gICAgfVxuICB9XG5cbiAgLy8gZ28taXBmcyB1c2VzIGxpdHRsZSBlbmRpYW4sIHRoYXQncyB3aHkgd2UgaGF2ZSB0b1xuICAvLyByZXZlcnNlIHRoZSBiaXQgZmllbGQgYmVmb3JlIHN0b3JpbmcgaXRcbiAgY29uc3QgZGF0YSA9IEJ1ZmZlci5mcm9tKGNoaWxkcmVuLmJpdEZpZWxkKCkucmV2ZXJzZSgpKVxuICBjb25zdCBkaXIgPSBuZXcgVW5peEZTKCdoYW10LXNoYXJkZWQtZGlyZWN0b3J5JywgZGF0YSlcbiAgZGlyLmZhbm91dCA9IGJ1Y2tldC50YWJsZVNpemUoKVxuICBkaXIuaGFzaFR5cGUgPSBvcHRpb25zLmhhc2hGbi5jb2RlXG5cbiAgY29uc3Qgbm9kZSA9IERBR05vZGUuY3JlYXRlKGRpci5tYXJzaGFsKCksIGxpbmtzKVxuICBjb25zdCBjaWQgPSBhd2FpdCBwZXJzaXN0KG5vZGUsIGlwbGQsIG9wdGlvbnMpXG5cbiAgeWllbGQge1xuICAgIGNpZCxcbiAgICBub2RlLFxuICAgIHVuaXhmczogZGlyLFxuICAgIHBhdGhcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJhdGNoID0gcmVxdWlyZSgnYXN5bmMtaXRlcmF0b3ItYmF0Y2gnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzeW5jIGZ1bmN0aW9uICogKHNvdXJjZSwgcmVkdWNlKSB7XG4gIGNvbnN0IHJvb3RzID0gW11cblxuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGJhdGNoKHNvdXJjZSwgSW5maW5pdHkpKSB7XG4gICAgcm9vdHMucHVzaChhd2FpdCByZWR1Y2UoY2h1bmspKVxuICB9XG5cbiAgeWllbGQgcm9vdHNbMF1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBiYXRjaCA9IHJlcXVpcmUoJ2FzeW5jLWl0ZXJhdG9yLWJhdGNoJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAqIHRyaWNrbGVSZWR1Y2VUb1Jvb3QgKHNvdXJjZSwgcmVkdWNlLCBvcHRpb25zKSB7XG4gIHlpZWxkIHRyaWNrbGVTdHJlYW0oc291cmNlLCByZWR1Y2UsIG9wdGlvbnMpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHRyaWNrbGVTdHJlYW0gKHNvdXJjZSwgcmVkdWNlLCBvcHRpb25zKSB7XG4gIGxldCByb290XG4gIGxldCBpdGVyYXRpb24gPSAwXG4gIGxldCBtYXhEZXB0aCA9IDFcbiAgbGV0IHN1YlRyZWUgPSByb290ID0gbmV3IFJvb3Qob3B0aW9ucy5sYXllclJlcGVhdClcblxuICBmb3IgYXdhaXQgKGNvbnN0IGxheWVyIG9mIGJhdGNoKHNvdXJjZSwgb3B0aW9ucy5tYXhDaGlsZHJlblBlck5vZGUpKSB7XG4gICAgaWYgKHN1YlRyZWUuaXNGdWxsKCkpIHtcbiAgICAgIGlmIChzdWJUcmVlICE9PSByb290KSB7XG4gICAgICAgIHJvb3QuYWRkQ2hpbGQoYXdhaXQgc3ViVHJlZS5yZWR1Y2UocmVkdWNlKSlcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZXJhdGlvbiAmJiBpdGVyYXRpb24gJSBvcHRpb25zLmxheWVyUmVwZWF0ID09PSAwKSB7XG4gICAgICAgIG1heERlcHRoKytcbiAgICAgIH1cblxuICAgICAgc3ViVHJlZSA9IG5ldyBTdWJUcmVlKG1heERlcHRoLCBvcHRpb25zLmxheWVyUmVwZWF0LCBpdGVyYXRpb24pXG5cbiAgICAgIGl0ZXJhdGlvbisrXG4gICAgfVxuXG4gICAgc3ViVHJlZS5hcHBlbmQobGF5ZXIpXG4gIH1cblxuICBpZiAoc3ViVHJlZSAmJiBzdWJUcmVlICE9PSByb290KSB7XG4gICAgcm9vdC5hZGRDaGlsZChhd2FpdCBzdWJUcmVlLnJlZHVjZShyZWR1Y2UpKVxuICB9XG5cbiAgcmV0dXJuIHJvb3QucmVkdWNlKHJlZHVjZSlcbn1cblxuY2xhc3MgU3ViVHJlZSB7XG4gIGNvbnN0cnVjdG9yIChtYXhEZXB0aCwgbGF5ZXJSZXBlYXQsIGl0ZXJhdGlvbikge1xuICAgIHRoaXMubWF4RGVwdGggPSBtYXhEZXB0aFxuICAgIHRoaXMubGF5ZXJSZXBlYXQgPSBsYXllclJlcGVhdFxuICAgIHRoaXMuY3VycmVudERlcHRoID0gMVxuICAgIHRoaXMuaXRlcmF0aW9uID0gaXRlcmF0aW9uXG5cbiAgICB0aGlzLnJvb3QgPSB0aGlzLm5vZGUgPSB0aGlzLnBhcmVudCA9IHtcbiAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgIGRlcHRoOiB0aGlzLmN1cnJlbnREZXB0aCxcbiAgICAgIG1heERlcHRoLFxuICAgICAgbWF4Q2hpbGRyZW46ICh0aGlzLm1heERlcHRoIC0gdGhpcy5jdXJyZW50RGVwdGgpICogdGhpcy5sYXllclJlcGVhdFxuICAgIH1cbiAgfVxuXG4gIGlzRnVsbCAoKSB7XG4gICAgaWYgKCF0aGlzLnJvb3QuZGF0YSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY3VycmVudERlcHRoIDwgdGhpcy5tYXhEZXB0aCAmJiB0aGlzLm5vZGUubWF4Q2hpbGRyZW4pIHtcbiAgICAgIC8vIGNhbiBkZXNjZW5kXG4gICAgICB0aGlzLl9hZGROZXh0Tm9kZVRvUGFyZW50KHRoaXMubm9kZSlcblxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gdHJ5IHRvIGZpbmQgbmV3IG5vZGUgZnJvbSBub2RlLnBhcmVudFxuICAgIGNvbnN0IGRpc3RhbnRSZWxhdGl2ZSA9IHRoaXMuX2ZpbmRQYXJlbnQodGhpcy5ub2RlLCB0aGlzLmN1cnJlbnREZXB0aClcblxuICAgIGlmIChkaXN0YW50UmVsYXRpdmUpIHtcbiAgICAgIHRoaXMuX2FkZE5leHROb2RlVG9QYXJlbnQoZGlzdGFudFJlbGF0aXZlKVxuXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgX2FkZE5leHROb2RlVG9QYXJlbnQgKHBhcmVudCkge1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50XG5cbiAgICAvLyBmaW5kIHNpdGUgZm9yIG5ldyBub2RlXG4gICAgY29uc3QgbmV4dE5vZGUgPSB7XG4gICAgICBjaGlsZHJlbjogW10sXG4gICAgICBkZXB0aDogcGFyZW50LmRlcHRoICsgMSxcbiAgICAgIHBhcmVudCxcbiAgICAgIG1heERlcHRoOiB0aGlzLm1heERlcHRoLFxuICAgICAgbWF4Q2hpbGRyZW46IE1hdGguZmxvb3IocGFyZW50LmNoaWxkcmVuLmxlbmd0aCAvIHRoaXMubGF5ZXJSZXBlYXQpICogdGhpcy5sYXllclJlcGVhdFxuICAgIH1cblxuICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKG5leHROb2RlKVxuXG4gICAgdGhpcy5jdXJyZW50RGVwdGggPSBuZXh0Tm9kZS5kZXB0aFxuICAgIHRoaXMubm9kZSA9IG5leHROb2RlXG4gIH1cblxuICBhcHBlbmQgKGxheWVyKSB7XG4gICAgdGhpcy5ub2RlLmRhdGEgPSBsYXllclxuICB9XG5cbiAgcmVkdWNlIChyZWR1Y2UpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVkdWNlKHRoaXMucm9vdCwgcmVkdWNlKVxuICB9XG5cbiAgYXN5bmMgX3JlZHVjZSAobm9kZSwgcmVkdWNlKSB7XG4gICAgbGV0IGNoaWxkcmVuID0gW11cblxuICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgY2hpbGRyZW4gPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgbm9kZS5jaGlsZHJlblxuICAgICAgICAgIC5maWx0ZXIoY2hpbGQgPT4gY2hpbGQuZGF0YSlcbiAgICAgICAgICAubWFwKGNoaWxkID0+IHRoaXMuX3JlZHVjZShjaGlsZCwgcmVkdWNlKSlcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gcmVkdWNlKG5vZGUuZGF0YS5jb25jYXQoY2hpbGRyZW4pKVxuICB9XG5cbiAgX2ZpbmRQYXJlbnQgKG5vZGUsIGRlcHRoKSB7XG4gICAgY29uc3QgcGFyZW50ID0gbm9kZS5wYXJlbnRcblxuICAgIGlmICghcGFyZW50IHx8IHBhcmVudC5kZXB0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPT09IHBhcmVudC5tYXhDaGlsZHJlbiB8fCAhcGFyZW50Lm1heENoaWxkcmVuKSB7XG4gICAgICAvLyB0aGlzIGxheWVyIGlzIGZ1bGwsIG1heSBiZSBhYmxlIHRvIHRyYXZlcnNlIHRvIGEgZGlmZmVyZW50IGJyYW5jaFxuICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRQYXJlbnQocGFyZW50LCBkZXB0aClcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50XG4gIH1cbn1cblxuY2xhc3MgUm9vdCBleHRlbmRzIFN1YlRyZWUge1xuICBjb25zdHJ1Y3RvciAobGF5ZXJSZXBlYXQpIHtcbiAgICBzdXBlcigwLCBsYXllclJlcGVhdClcblxuICAgIHRoaXMucm9vdC5kZXB0aCA9IDBcbiAgICB0aGlzLmN1cnJlbnREZXB0aCA9IDFcbiAgfVxuXG4gIGFkZENoaWxkIChjaGlsZCkge1xuICAgIHRoaXMucm9vdC5jaGlsZHJlbi5wdXNoKGNoaWxkKVxuICB9XG5cbiAgcmVkdWNlIChyZWR1Y2UpIHtcbiAgICByZXR1cm4gcmVkdWNlKHRoaXMucm9vdC5kYXRhLmNvbmNhdCh0aGlzLnJvb3QuY2hpbGRyZW4pKVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgYmF0Y2ggPSByZXF1aXJlKCdhc3luYy1pdGVyYXRvci1iYXRjaCcpXG5cbmFzeW5jIGZ1bmN0aW9uICogYmFsYW5jZWQgKHNvdXJjZSwgcmVkdWNlLCBvcHRpb25zKSB7XG4gIHlpZWxkIGF3YWl0IHJlZHVjZVRvUGFyZW50cyhzb3VyY2UsIHJlZHVjZSwgb3B0aW9ucylcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVkdWNlVG9QYXJlbnRzIChzb3VyY2UsIHJlZHVjZSwgb3B0aW9ucykge1xuICBjb25zdCByb290cyA9IFtdXG5cbiAgZm9yIGF3YWl0IChjb25zdCBjaHVua2VkIG9mIGJhdGNoKHNvdXJjZSwgb3B0aW9ucy5tYXhDaGlsZHJlblBlck5vZGUpKSB7XG4gICAgcm9vdHMucHVzaChhd2FpdCByZWR1Y2UoY2h1bmtlZCkpXG4gIH1cblxuICBpZiAocm9vdHMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiByZWR1Y2VUb1BhcmVudHMocm9vdHMsIHJlZHVjZSwgb3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiByb290c1swXVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhbGFuY2VkXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJ2JsJylcblxubW9kdWxlLmV4cG9ydHMgPSBhc3luYyBmdW5jdGlvbiAqIGZpeGVkU2l6ZUNodW5rZXIgKHNvdXJjZSwgb3B0aW9ucykge1xuICBsZXQgYmwgPSBuZXcgQnVmZmVyTGlzdCgpXG4gIGxldCBjdXJyZW50TGVuZ3RoID0gMFxuICBsZXQgZW1pdHRlZCA9IGZhbHNlXG4gIGNvbnN0IG1heENodW5rU2l6ZSA9IG9wdGlvbnMubWF4Q2h1bmtTaXplXG5cbiAgZm9yIGF3YWl0IChjb25zdCBidWZmZXIgb2Ygc291cmNlKSB7XG4gICAgYmwuYXBwZW5kKGJ1ZmZlcilcblxuICAgIGN1cnJlbnRMZW5ndGggKz0gYnVmZmVyLmxlbmd0aFxuXG4gICAgd2hpbGUgKGN1cnJlbnRMZW5ndGggPj0gbWF4Q2h1bmtTaXplKSB7XG4gICAgICB5aWVsZCBibC5zbGljZSgwLCBtYXhDaHVua1NpemUpXG4gICAgICBlbWl0dGVkID0gdHJ1ZVxuXG4gICAgICAvLyB0aHJvdyBhd2F5IGNvbnN1bWVkIGJ5dGVzXG4gICAgICBpZiAobWF4Q2h1bmtTaXplID09PSBibC5sZW5ndGgpIHtcbiAgICAgICAgYmwgPSBuZXcgQnVmZmVyTGlzdCgpXG4gICAgICAgIGN1cnJlbnRMZW5ndGggPSAwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuZXdCbCA9IG5ldyBCdWZmZXJMaXN0KClcbiAgICAgICAgbmV3QmwuYXBwZW5kKGJsLnNoYWxsb3dTbGljZShtYXhDaHVua1NpemUpKVxuICAgICAgICBibCA9IG5ld0JsXG5cbiAgICAgICAgLy8gdXBkYXRlIG91ciBvZmZzZXRcbiAgICAgICAgY3VycmVudExlbmd0aCAtPSBtYXhDaHVua1NpemVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIWVtaXR0ZWQgfHwgY3VycmVudExlbmd0aCkge1xuICAgIC8vIHJldHVybiBhbnkgcmVtYWluaW5nIGJ5dGVzIG9yIGFuIGVtcHR5IGJ1ZmZlclxuICAgIHlpZWxkIGJsLnNsaWNlKDAsIGN1cnJlbnRMZW5ndGgpXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnYmwnKVxuY29uc3QgeyBjcmVhdGUgfSA9IHJlcXVpcmUoJ3JhYmluLXdhc20nKVxuY29uc3QgZXJyY29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcblxubW9kdWxlLmV4cG9ydHMgPSBhc3luYyBmdW5jdGlvbiAqIHJhYmluQ2h1bmtlciAoc291cmNlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJhYmluID0ganNSYWJpbigpXG5cbiAgbGV0IG1pbiwgbWF4LCBhdmdcblxuICBpZiAob3B0aW9ucy5taW5DaHVua1NpemUgJiYgb3B0aW9ucy5tYXhDaHVua1NpemUgJiYgb3B0aW9ucy5hdmdDaHVua1NpemUpIHtcbiAgICBhdmcgPSBvcHRpb25zLmF2Z0NodW5rU2l6ZVxuICAgIG1pbiA9IG9wdGlvbnMubWluQ2h1bmtTaXplXG4gICAgbWF4ID0gb3B0aW9ucy5tYXhDaHVua1NpemVcbiAgfSBlbHNlIGlmICghb3B0aW9ucy5hdmdDaHVua1NpemUpIHtcbiAgICB0aHJvdyBlcnJjb2RlKG5ldyBFcnJvcigncGxlYXNlIHNwZWNpZnkgYW4gYXZlcmFnZSBjaHVuayBzaXplJyksICdFUlJfSU5WQUxJRF9BVkdfQ0hVTktfU0laRScpXG4gIH0gZWxzZSB7XG4gICAgYXZnID0gb3B0aW9ucy5hdmdDaHVua1NpemVcbiAgICBtaW4gPSBhdmcgLyAzXG4gICAgbWF4ID0gYXZnICsgKGF2ZyAvIDIpXG4gIH1cblxuICAvLyB2YWxpZGF0ZSBtaW4vbWF4L2F2ZyBpbiB0aGUgc2FtZSB3YXkgYXMgZ29cbiAgaWYgKG1pbiA8IDE2KSB7XG4gICAgdGhyb3cgZXJyY29kZShuZXcgRXJyb3IoJ3JhYmluIG1pbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxNicpLCAnRVJSX0lOVkFMSURfTUlOX0NIVU5LX1NJWkUnKVxuICB9XG5cbiAgaWYgKG1heCA8IG1pbikge1xuICAgIG1heCA9IG1pblxuICB9XG5cbiAgaWYgKGF2ZyA8IG1pbikge1xuICAgIGF2ZyA9IG1pblxuICB9XG5cbiAgY29uc3Qgc2l6ZXBvdyA9IE1hdGguZmxvb3IoTWF0aC5sb2cyKGF2ZykpXG5cbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiByYWJpbihzb3VyY2UsIHtcbiAgICBtaW46IG1pbixcbiAgICBtYXg6IG1heCxcbiAgICBiaXRzOiBzaXplcG93LFxuICAgIHdpbmRvdzogb3B0aW9ucy53aW5kb3csXG4gICAgcG9seW5vbWlhbDogb3B0aW9ucy5wb2x5bm9taWFsXG4gIH0pKSB7XG4gICAgeWllbGQgY2h1bmtcbiAgfVxufVxuXG5jb25zdCBqc1JhYmluID0gKCkgPT4ge1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gKiAoc291cmNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgciA9IGF3YWl0IGNyZWF0ZShvcHRpb25zLmJpdHMsIG9wdGlvbnMubWluLCBvcHRpb25zLm1heCwgb3B0aW9ucy53aW5kb3cpXG4gICAgY29uc3QgYnVmZmVycyA9IG5ldyBCdWZmZXJMaXN0KClcbiAgICBsZXQgcGVuZGluZyA9IFtdXG5cbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHNvdXJjZSkge1xuICAgICAgYnVmZmVycy5hcHBlbmQoY2h1bmspXG4gICAgICBwZW5kaW5nLnB1c2goY2h1bmspXG5cbiAgICAgIGNvbnN0IHNpemVzID0gci5maW5nZXJwcmludChCdWZmZXIuY29uY2F0KHBlbmRpbmcpKVxuICAgICAgcGVuZGluZyA9IFtdXG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNpemUgPSBzaXplc1tpXVxuICAgICAgICB2YXIgYnVmID0gYnVmZmVycy5zbGljZSgwLCBzaXplKVxuICAgICAgICBidWZmZXJzLmNvbnN1bWUoc2l6ZSlcblxuICAgICAgICB5aWVsZCBidWZcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYnVmZmVycy5sZW5ndGgpIHtcbiAgICAgIHlpZWxkIGJ1ZmZlcnMuc2xpY2UoMClcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIERBR05vZGVcbn0gPSByZXF1aXJlKCdpcGxkLWRhZy1wYicpXG5jb25zdCBCdWNrZXQgPSByZXF1aXJlKCdoYW10LXNoYXJkaW5nL3NyYy9idWNrZXQnKVxuY29uc3QgRGlyU2hhcmRlZCA9IHJlcXVpcmUoJ2lwZnMtdW5peGZzLWltcG9ydGVyL3NyYy9kaXItc2hhcmRlZCcpXG5jb25zdCBsb2cgPSByZXF1aXJlKCdkZWJ1ZycpKCdpcGZzOm1mczpjb3JlOnV0aWxzOmhhbXQtdXRpbHMnKVxuY29uc3QgVW5peEZTID0gcmVxdWlyZSgnaXBmcy11bml4ZnMnKVxuY29uc3QgbWMgPSByZXF1aXJlKCdtdWx0aWNvZGVjJylcbmNvbnN0IG1oID0gcmVxdWlyZSgnbXVsdGloYXNoZXMnKVxuY29uc3QgbGFzdCA9IHJlcXVpcmUoJ2FzeW5jLWl0ZXJhdG9yLWxhc3QnKVxuXG5jb25zdCB1cGRhdGVIYW10RGlyZWN0b3J5ID0gYXN5bmMgKGNvbnRleHQsIGxpbmtzLCBidWNrZXQsIG9wdGlvbnMpID0+IHtcbiAgLy8gdXBkYXRlIHBhcmVudCB3aXRoIG5ldyBiaXQgZmllbGRcbiAgY29uc3QgZGF0YSA9IEJ1ZmZlci5mcm9tKGJ1Y2tldC5fY2hpbGRyZW4uYml0RmllbGQoKS5yZXZlcnNlKCkpXG4gIGNvbnN0IGRpciA9IG5ldyBVbml4RlMoJ2hhbXQtc2hhcmRlZC1kaXJlY3RvcnknLCBkYXRhKVxuICBkaXIuZmFub3V0ID0gYnVja2V0LnRhYmxlU2l6ZSgpXG4gIGRpci5oYXNoVHlwZSA9IERpclNoYXJkZWQuaGFzaEZuLmNvZGVcblxuICBjb25zdCBmb3JtYXQgPSBtY1tvcHRpb25zLmZvcm1hdC50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoLy0vZywgJ18nKV1cbiAgY29uc3QgaGFzaEFsZyA9IG1oLm5hbWVzW29wdGlvbnMuaGFzaEFsZ11cblxuICBjb25zdCBwYXJlbnQgPSBEQUdOb2RlLmNyZWF0ZShkaXIubWFyc2hhbCgpLCBsaW5rcylcbiAgY29uc3QgY2lkID0gYXdhaXQgY29udGV4dC5pcGxkLnB1dChwYXJlbnQsIGZvcm1hdCwge1xuICAgIGNpZFZlcnNpb246IG9wdGlvbnMuY2lkVmVyc2lvbixcbiAgICBoYXNoQWxnLFxuICAgIGhhc2hPbmx5OiAhb3B0aW9ucy5mbHVzaFxuICB9KVxuXG4gIHJldHVybiB7XG4gICAgbm9kZTogcGFyZW50LFxuICAgIGNpZFxuICB9XG59XG5cbmNvbnN0IHJlY3JlYXRlSGFtdExldmVsID0gYXN5bmMgKGxpbmtzLCByb290QnVja2V0LCBwYXJlbnRCdWNrZXQsIHBvc2l0aW9uQXRQYXJlbnQpID0+IHtcbiAgLy8gcmVjcmVhdGUgdGhpcyBsZXZlbCBvZiB0aGUgSEFNVFxuICBjb25zdCBidWNrZXQgPSBuZXcgQnVja2V0KHtcbiAgICBoYXNoRm46IERpclNoYXJkZWQuaGFzaEZuLFxuICAgIGhhc2g6IHBhcmVudEJ1Y2tldCA/IHBhcmVudEJ1Y2tldC5fb3B0aW9ucy5oYXNoIDogdW5kZWZpbmVkXG4gIH0sIHBhcmVudEJ1Y2tldCwgcG9zaXRpb25BdFBhcmVudClcblxuICBpZiAocGFyZW50QnVja2V0KSB7XG4gICAgcGFyZW50QnVja2V0Ll9wdXRPYmplY3RBdChwb3NpdGlvbkF0UGFyZW50LCBidWNrZXQpXG4gIH1cblxuICBhd2FpdCBhZGRMaW5rc1RvSGFtdEJ1Y2tldChsaW5rcywgYnVja2V0LCByb290QnVja2V0KVxuXG4gIHJldHVybiBidWNrZXRcbn1cblxuY29uc3QgYWRkTGlua3NUb0hhbXRCdWNrZXQgPSBhc3luYyAobGlua3MsIGJ1Y2tldCwgcm9vdEJ1Y2tldCkgPT4ge1xuICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBsaW5rcy5tYXAobGluayA9PiB7XG4gICAgICBpZiAobGluay5OYW1lLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBjb25zdCBwb3MgPSBwYXJzZUludChsaW5rLk5hbWUsIDE2KVxuXG4gICAgICAgIGJ1Y2tldC5fcHV0T2JqZWN0QXQocG9zLCBuZXcgQnVja2V0KHtcbiAgICAgICAgICBoYXNoRm46IERpclNoYXJkZWQuaGFzaEZuXG4gICAgICAgIH0sIGJ1Y2tldCwgcG9zKSlcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChyb290QnVja2V0IHx8IGJ1Y2tldCkucHV0KGxpbmsuTmFtZS5zdWJzdHJpbmcoMiksIHtcbiAgICAgICAgc2l6ZTogbGluay5UU2l6ZSxcbiAgICAgICAgY2lkOiBsaW5rLkhhc2hcbiAgICAgIH0pXG4gICAgfSlcbiAgKVxufVxuXG5jb25zdCB0b1ByZWZpeCA9IChwb3NpdGlvbikgPT4ge1xuICByZXR1cm4gcG9zaXRpb25cbiAgICAudG9TdHJpbmcoJzE2JylcbiAgICAudG9VcHBlckNhc2UoKVxuICAgIC5wYWRTdGFydCgyLCAnMCcpXG4gICAgLnN1YnN0cmluZygwLCAyKVxufVxuXG5jb25zdCBnZW5lcmF0ZVBhdGggPSBhc3luYyAoY29udGV4dCwgZmlsZU5hbWUsIHJvb3ROb2RlKSA9PiB7XG4gIC8vIHN0YXJ0IGF0IHRoZSByb290IGJ1Y2tldCBhbmQgZGVzY2VuZCwgbG9hZGluZyBub2RlcyBhcyB3ZSBnb1xuICBjb25zdCByb290QnVja2V0ID0gYXdhaXQgcmVjcmVhdGVIYW10TGV2ZWwocm9vdE5vZGUuTGlua3MsIG51bGwsIG51bGwsIG51bGwpXG4gIGNvbnN0IHBvc2l0aW9uID0gYXdhaXQgcm9vdEJ1Y2tldC5fZmluZE5ld0J1Y2tldEFuZFBvcyhmaWxlTmFtZSlcblxuICAvLyB0aGUgcGF0aCB0byB0aGUgcm9vdCBidWNrZXRcbiAgbGV0IHBhdGggPSBbe1xuICAgIGJ1Y2tldDogcG9zaXRpb24uYnVja2V0LFxuICAgIHByZWZpeDogdG9QcmVmaXgocG9zaXRpb24ucG9zKVxuICB9XVxuICBsZXQgY3VycmVudEJ1Y2tldCA9IHBvc2l0aW9uLmJ1Y2tldFxuXG4gIHdoaWxlIChjdXJyZW50QnVja2V0ICE9PSByb290QnVja2V0KSB7XG4gICAgcGF0aC5wdXNoKHtcbiAgICAgIGJ1Y2tldDogY3VycmVudEJ1Y2tldCxcbiAgICAgIHByZWZpeDogdG9QcmVmaXgoY3VycmVudEJ1Y2tldC5fcG9zQXRQYXJlbnQpXG4gICAgfSlcblxuICAgIGN1cnJlbnRCdWNrZXQgPSBjdXJyZW50QnVja2V0Ll9wYXJlbnRcbiAgfVxuXG4gIHBhdGgucmV2ZXJzZSgpXG4gIHBhdGhbMF0ubm9kZSA9IHJvb3ROb2RlXG5cbiAgLy8gbG9hZCBEQUdOb2RlIGZvciBlYWNoIHBhdGggc2VnbWVudFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZWdtZW50ID0gcGF0aFtpXVxuXG4gICAgLy8gZmluZCBwcmVmaXggaW4gbGlua3NcbiAgICBjb25zdCBsaW5rID0gc2VnbWVudC5ub2RlLkxpbmtzXG4gICAgICAuZmlsdGVyKGxpbmsgPT4gbGluay5OYW1lLnN1YnN0cmluZygwLCAyKSA9PT0gc2VnbWVudC5wcmVmaXgpXG4gICAgICAucG9wKClcblxuICAgIC8vIGVudHJ5IHdhcyBub3QgaW4gc2hhcmRcbiAgICBpZiAoIWxpbmspIHtcbiAgICAgIC8vIHJlYWNoZWQgYm90dG9tIG9mIHRyZWUsIGZpbGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgY3VycmVudCBidWNrZXRcbiAgICAgIGxvZyhgTGluayAke3NlZ21lbnQucHJlZml4fSR7ZmlsZU5hbWV9IHdpbGwgYmUgYWRkZWRgKVxuICAgICAgLy8gcmV0dXJuIHBhdGhcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgLy8gZm91bmQgZW50cnlcbiAgICBpZiAobGluay5OYW1lID09PSBgJHtzZWdtZW50LnByZWZpeH0ke2ZpbGVOYW1lfWApIHtcbiAgICAgIGxvZyhgTGluayAke3NlZ21lbnQucHJlZml4fSR7ZmlsZU5hbWV9IHdpbGwgYmUgcmVwbGFjZWRgKVxuICAgICAgLy8gZmlsZSBhbHJlYWR5IGV4aXN0ZWQsIGZpbGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgY3VycmVudCBidWNrZXRcbiAgICAgIC8vIHJldHVybiBwYXRoXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIC8vIGZvdW5kIHN1YnNoYXJkXG4gICAgbG9nKGBGb3VuZCBzdWJzaGFyZCAke3NlZ21lbnQucHJlZml4fWApXG4gICAgY29uc3Qgbm9kZSA9IGF3YWl0IGNvbnRleHQuaXBsZC5nZXQobGluay5IYXNoKVxuXG4gICAgLy8gc3Vic2hhcmQgaGFzbid0IGJlZW4gbG9hZGVkLCBkZXNjZW5kIHRvIHRoZSBuZXh0IGxldmVsIG9mIHRoZSBIQU1UXG4gICAgaWYgKCFwYXRoW2kgKyAxXSkge1xuICAgICAgbG9nKGBMb2FkZWQgbmV3IHN1YnNoYXJkICR7c2VnbWVudC5wcmVmaXh9YClcblxuICAgICAgYXdhaXQgcmVjcmVhdGVIYW10TGV2ZWwobm9kZS5MaW5rcywgcm9vdEJ1Y2tldCwgc2VnbWVudC5idWNrZXQsIHBhcnNlSW50KHNlZ21lbnQucHJlZml4LCAxNikpXG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGF3YWl0IHJvb3RCdWNrZXQuX2ZpbmROZXdCdWNrZXRBbmRQb3MoZmlsZU5hbWUpXG5cbiAgICAgIC8vIGktLVxuICAgICAgcGF0aC5wdXNoKHtcbiAgICAgICAgYnVja2V0OiBwb3NpdGlvbi5idWNrZXQsXG4gICAgICAgIHByZWZpeDogdG9QcmVmaXgocG9zaXRpb24ucG9zKSxcbiAgICAgICAgbm9kZTogbm9kZVxuICAgICAgfSlcblxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBjb25zdCBuZXh0U2VnbWVudCA9IHBhdGhbaSArIDFdXG5cbiAgICAvLyBhZGQgaW50ZXJtZWRpYXRlIGxpbmtzIHRvIGJ1Y2tldFxuICAgIGF3YWl0IGFkZExpbmtzVG9IYW10QnVja2V0KG5vZGUuTGlua3MsIG5leHRTZWdtZW50LmJ1Y2tldCwgcm9vdEJ1Y2tldClcblxuICAgIG5leHRTZWdtZW50Lm5vZGUgPSBub2RlXG4gIH1cblxuICBhd2FpdCByb290QnVja2V0LnB1dChmaWxlTmFtZSwgdHJ1ZSlcblxuICBwYXRoLnJldmVyc2UoKVxuXG4gIHJldHVybiB7XG4gICAgcm9vdEJ1Y2tldCxcbiAgICBwYXRoXG4gIH1cbn1cblxuY29uc3QgY3JlYXRlU2hhcmQgPSBhc3luYyAoY29udGV4dCwgY29udGVudHMsIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgc2hhcmQgPSBuZXcgRGlyU2hhcmRlZCh7XG4gICAgcm9vdDogdHJ1ZSxcbiAgICBkaXI6IHRydWUsXG4gICAgcGFyZW50OiBudWxsLFxuICAgIHBhcmVudEtleTogbnVsbCxcbiAgICBwYXRoOiAnJyxcbiAgICBkaXJ0eTogdHJ1ZSxcbiAgICBmbGF0OiBmYWxzZVxuICB9LCBvcHRpb25zKVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBhd2FpdCBzaGFyZC5fYnVja2V0LnB1dChjb250ZW50c1tpXS5uYW1lLCB7XG4gICAgICBzaXplOiBjb250ZW50c1tpXS5zaXplLFxuICAgICAgY2lkOiBjb250ZW50c1tpXS5jaWRcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIGxhc3Qoc2hhcmQuZmx1c2goJycsIGNvbnRleHQuaXBsZCwgbnVsbCkpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZW5lcmF0ZVBhdGgsXG4gIHVwZGF0ZUhhbXREaXJlY3RvcnksXG4gIHJlY3JlYXRlSGFtdExldmVsLFxuICBhZGRMaW5rc1RvSGFtdEJ1Y2tldCxcbiAgdG9QcmVmaXgsXG4gIGNyZWF0ZVNoYXJkXG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNyBEYXZpZCBNLiBMZWUsIElJXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTG9jYWwgcmVmZXJlbmNlIHRvIFRpbWVvdXRFcnJvclxuICogQHByaXZhdGVcbiAqL1xudmFyIFRpbWVvdXRFcnJvcjtcblxuLyoqXG4gKiBSZWplY3RzIGEgcHJvbWlzZSB3aXRoIGEge0BsaW5rIFRpbWVvdXRFcnJvcn0gaWYgaXQgZG9lcyBub3Qgc2V0dGxlIHdpdGhpblxuICogdGhlIHNwZWNpZmllZCB0aW1lb3V0LlxuICpcbiAqIEBwYXJhbSB7UHJvbWlzZX0gcHJvbWlzZSBUaGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0TWlsbGlzIE51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBvbiBzZXR0bGluZy5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBFaXRoZXIgcmVzb2x2ZXMvcmVqZWN0cyB3aXRoIGBwcm9taXNlYCwgb3IgcmVqZWN0cyB3aXRoXG4gKiAgICAgICAgICAgICAgICAgICBgVGltZW91dEVycm9yYCwgd2hpY2hldmVyIHNldHRsZXMgZmlyc3QuXG4gKi9cbnZhciB0aW1lb3V0ID0gbW9kdWxlLmV4cG9ydHMudGltZW91dCA9IGZ1bmN0aW9uKHByb21pc2UsIHRpbWVvdXRNaWxsaXMpIHtcbiAgdmFyIGVycm9yID0gbmV3IFRpbWVvdXRFcnJvcigpLFxuICAgICAgdGltZW91dDtcblxuICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICBwcm9taXNlLFxuICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9LCB0aW1lb3V0TWlsbGlzKTtcbiAgICB9KSxcbiAgXSkudGhlbihmdW5jdGlvbih2KSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIHJldHVybiB2O1xuICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGhyb3cgZXJyO1xuICB9KTtcbn07XG5cbi8qKlxuICogRXhjZXB0aW9uIGluZGljYXRpbmcgdGhhdCB0aGUgdGltZW91dCBleHBpcmVkLlxuICovXG5UaW1lb3V0RXJyb3IgPSBtb2R1bGUuZXhwb3J0cy5UaW1lb3V0RXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgRXJyb3IuY2FsbCh0aGlzKVxuICB0aGlzLnN0YWNrID0gRXJyb3IoKS5zdGFja1xuICB0aGlzLm1lc3NhZ2UgPSAnVGltZW91dCc7XG59O1xuXG5UaW1lb3V0RXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuVGltZW91dEVycm9yLnByb3RvdHlwZS5uYW1lID0gXCJUaW1lb3V0RXJyb3JcIjtcbiIsImNvbnN0IGV2ZW50cyA9IHt9XG5cbmNvbnN0IG9ic2VydmFibGUgPSAod29ya2VyKSA9PiB7XG4gIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGV2ZW50KSA9PiB7XG4gICAgb2JzZXJ2YWJsZS5kaXNwYXRjaEV2ZW50KCdtZXNzYWdlJywgd29ya2VyLCBldmVudClcbiAgfSlcblxuICBpZiAod29ya2VyLnBvcnQpIHtcbiAgICB3b3JrZXIucG9ydC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGV2ZW50KSA9PiB7XG4gICAgICBvYnNlcnZhYmxlLmRpc3BhdGNoRXZlbnQoJ21lc3NhZ2UnLCB3b3JrZXIsIGV2ZW50KVxuICAgIH0pXG4gIH1cbn1cblxub2JzZXJ2YWJsZS5hZGRFdmVudExpc3RlbmVyID0gKHR5cGUsIGZuKSA9PiB7XG4gIGlmICghZXZlbnRzW3R5cGVdKSB7XG4gICAgZXZlbnRzW3R5cGVdID0gW11cbiAgfVxuXG4gIGV2ZW50c1t0eXBlXS5wdXNoKGZuKVxufVxuXG5vYnNlcnZhYmxlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSAodHlwZSwgZm4pID0+IHtcbiAgaWYgKCFldmVudHNbdHlwZV0pIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGV2ZW50c1t0eXBlXSA9IGV2ZW50c1t0eXBlXVxuICAgIC5maWx0ZXIobGlzdGVuZXIgPT4gbGlzdGVuZXIgPT09IGZuKVxufVxuXG5vYnNlcnZhYmxlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gIGNvbnN0IHR5cGUgPSBhcmdzLnNoaWZ0KClcblxuICBpZiAoIWV2ZW50c1t0eXBlXSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgZXZlbnRzW3R5cGVdLmZvckVhY2goZm4gPT4gZm4uYXBwbHkobnVsbCwgYXJncykpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gb2JzZXJ2YWJsZVxuIiwiY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5jb25zdCBzaG9ydGlkID0gcmVxdWlyZSgnc2hvcnRpZCcpXG5jb25zdCB7XG4gIFdPUktFUl9SRVFVRVNUX1JFQURfTE9DSyxcbiAgV09SS0VSX1JFTEVBU0VfUkVBRF9MT0NLLFxuICBNQVNURVJfR1JBTlRfUkVBRF9MT0NLLFxuICBXT1JLRVJfUkVRVUVTVF9XUklURV9MT0NLLFxuICBXT1JLRVJfUkVMRUFTRV9XUklURV9MT0NLLFxuICBNQVNURVJfR1JBTlRfV1JJVEVfTE9DS1xufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IG9ic2VydmVyID0gcmVxdWlyZSgnb2JzZXJ2YWJsZS13ZWJ3b3JrZXJzJylcblxuY29uc3QgaGFuZGxlV29ya2VyTG9ja1JlcXVlc3QgPSAoZW1pdHRlciwgbWFzdGVyRXZlbnQsIHJlcXVlc3RUeXBlLCByZWxlYXNlVHlwZSwgZ3JhbnRUeXBlKSA9PiB7XG4gIHJldHVybiAod29ya2VyLCBldmVudCkgPT4ge1xuICAgIGlmICghZXZlbnQgfHwgIWV2ZW50LmRhdGEgfHwgZXZlbnQuZGF0YS50eXBlICE9PSByZXF1ZXN0VHlwZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdEV2ZW50ID0ge1xuICAgICAgdHlwZTogZXZlbnQuZGF0YS50eXBlLFxuICAgICAgbmFtZTogZXZlbnQuZGF0YS5uYW1lLFxuICAgICAgaWRlbnRpZmllcjogZXZlbnQuZGF0YS5pZGVudGlmaWVyXG4gICAgfVxuXG4gICAgZW1pdHRlci5lbWl0KG1hc3RlckV2ZW50LCByZXF1ZXN0RXZlbnQubmFtZSwgKCkgPT4ge1xuICAgICAgLy8gZ3JhbnQgbG9jayB0byB3b3JrZXJcbiAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IGdyYW50VHlwZSxcbiAgICAgICAgbmFtZTogcmVxdWVzdEV2ZW50Lm5hbWUsXG4gICAgICAgIGlkZW50aWZpZXI6IHJlcXVlc3RFdmVudC5pZGVudGlmaWVyXG4gICAgICB9KVxuXG4gICAgICAvLyB3YWl0IGZvciB3b3JrZXIgdG8gZmluaXNoXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3QgcmVsZWFzZUV2ZW50TGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAoIWV2ZW50IHx8ICFldmVudC5kYXRhKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCByZWxlYXNlRXZlbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBldmVudC5kYXRhLnR5cGUsXG4gICAgICAgICAgICBuYW1lOiBldmVudC5kYXRhLm5hbWUsXG4gICAgICAgICAgICBpZGVudGlmaWVyOiBldmVudC5kYXRhLmlkZW50aWZpZXJcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmVsZWFzZUV2ZW50ICYmIHJlbGVhc2VFdmVudC50eXBlID09PSByZWxlYXNlVHlwZSAmJiByZWxlYXNlRXZlbnQuaWRlbnRpZmllciA9PT0gcmVxdWVzdEV2ZW50LmlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgcmVsZWFzZUV2ZW50TGlzdGVuZXIpXG4gICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHJlbGVhc2VFdmVudExpc3RlbmVyKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5cbmNvbnN0IG1ha2VXb3JrZXJMb2NrUmVxdWVzdCA9IChnbG9iYWwsIG5hbWUsIHJlcXVlc3RUeXBlLCBncmFudFR5cGUsIHJlbGVhc2VUeXBlKSA9PiB7XG4gIHJldHVybiAoZm4pID0+IHtcbiAgICBjb25zdCBpZCA9IHNob3J0aWQuZ2VuZXJhdGUoKVxuXG4gICAgZ2xvYmFsLnBvc3RNZXNzYWdlKHtcbiAgICAgIHR5cGU6IHJlcXVlc3RUeXBlLFxuICAgICAgaWRlbnRpZmllcjogaWQsXG4gICAgICBuYW1lXG4gICAgfSlcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoIWV2ZW50IHx8ICFldmVudC5kYXRhKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXNwb25zZUV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6IGV2ZW50LmRhdGEudHlwZSxcbiAgICAgICAgICBpZGVudGlmaWVyOiBldmVudC5kYXRhLmlkZW50aWZpZXJcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXNwb25zZUV2ZW50ICYmIHJlc3BvbnNlRXZlbnQudHlwZSA9PT0gZ3JhbnRUeXBlICYmIHJlc3BvbnNlRXZlbnQuaWRlbnRpZmllciA9PT0gaWQpIHtcbiAgICAgICAgICBnbG9iYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyKVxuXG4gICAgICAgICAgbGV0IGVycm9yXG5cbiAgICAgICAgICBmbigpXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICBlcnJvciA9IGVyclxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiByZWxlYXNlVHlwZSxcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBpZCxcbiAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcilcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lcilcbiAgICB9KVxuICB9XG59XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBnbG9iYWw6IGdsb2JhbCxcbiAgc2luZ2xlUHJvY2VzczogZmFsc2Vcbn1cblxubW9kdWxlLmV4cG9ydHMgPSAob3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpXG4gIGNvbnN0IGlzTWFzdGVyID0gISFvcHRpb25zLmdsb2JhbC5kb2N1bWVudCB8fCBvcHRpb25zLnNpbmdsZVByb2Nlc3NcblxuICBpZiAoaXNNYXN0ZXIpIHtcbiAgICBjb25zdCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpXG5cbiAgICBvYnNlcnZlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlV29ya2VyTG9ja1JlcXVlc3QoZW1pdHRlciwgJ3JlcXVlc3RSZWFkTG9jaycsIFdPUktFUl9SRVFVRVNUX1JFQURfTE9DSywgV09SS0VSX1JFTEVBU0VfUkVBRF9MT0NLLCBNQVNURVJfR1JBTlRfUkVBRF9MT0NLKSlcbiAgICBvYnNlcnZlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlV29ya2VyTG9ja1JlcXVlc3QoZW1pdHRlciwgJ3JlcXVlc3RXcml0ZUxvY2snLCBXT1JLRVJfUkVRVUVTVF9XUklURV9MT0NLLCBXT1JLRVJfUkVMRUFTRV9XUklURV9MT0NLLCBNQVNURVJfR1JBTlRfV1JJVEVfTE9DSykpXG5cbiAgICByZXR1cm4gZW1pdHRlclxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpc1dvcmtlcjogdHJ1ZSxcbiAgICByZWFkTG9jazogKG5hbWUsIG9wdGlvbnMpID0+IG1ha2VXb3JrZXJMb2NrUmVxdWVzdChvcHRpb25zLmdsb2JhbCwgbmFtZSwgV09SS0VSX1JFUVVFU1RfUkVBRF9MT0NLLCBNQVNURVJfR1JBTlRfUkVBRF9MT0NLLCBXT1JLRVJfUkVMRUFTRV9SRUFEX0xPQ0spLFxuICAgIHdyaXRlTG9jazogKG5hbWUsIG9wdGlvbnMpID0+IG1ha2VXb3JrZXJMb2NrUmVxdWVzdChvcHRpb25zLmdsb2JhbCwgbmFtZSwgV09SS0VSX1JFUVVFU1RfV1JJVEVfTE9DSywgTUFTVEVSX0dSQU5UX1dSSVRFX0xPQ0ssIFdPUktFUl9SRUxFQVNFX1dSSVRFX0xPQ0spXG4gIH1cbn1cbiIsImNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuY29uc3Qgc2hvcnRpZCA9IHJlcXVpcmUoJ3Nob3J0aWQnKVxuY29uc3Qge1xuICBXT1JLRVJfUkVRVUVTVF9SRUFEX0xPQ0ssXG4gIFdPUktFUl9SRUxFQVNFX1JFQURfTE9DSyxcbiAgTUFTVEVSX0dSQU5UX1JFQURfTE9DSyxcbiAgV09SS0VSX1JFUVVFU1RfV1JJVEVfTE9DSyxcbiAgV09SS0VSX1JFTEVBU0VfV1JJVEVfTE9DSyxcbiAgTUFTVEVSX0dSQU5UX1dSSVRFX0xPQ0tcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5sZXQgY2x1c3RlclxuXG5jb25zdCBoYW5kbGVXb3JrZXJMb2NrUmVxdWVzdCA9IChlbWl0dGVyLCBtYXN0ZXJFdmVudCwgcmVxdWVzdFR5cGUsIHJlbGVhc2VUeXBlLCBncmFudFR5cGUpID0+IHtcbiAgcmV0dXJuICh3b3JrZXIsIHJlcXVlc3RFdmVudCkgPT4ge1xuICAgIGlmIChyZXF1ZXN0RXZlbnQgJiYgcmVxdWVzdEV2ZW50LnR5cGUgPT09IHJlcXVlc3RUeXBlKSB7XG4gICAgICBlbWl0dGVyLmVtaXQobWFzdGVyRXZlbnQsIHJlcXVlc3RFdmVudC5uYW1lLCAoKSA9PiB7XG4gICAgICAgIC8vIGdyYW50IGxvY2sgdG8gd29ya2VyXG4gICAgICAgIHdvcmtlci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBncmFudFR5cGUsXG4gICAgICAgICAgbmFtZTogcmVxdWVzdEV2ZW50Lm5hbWUsXG4gICAgICAgICAgaWRlbnRpZmllcjogcmVxdWVzdEV2ZW50LmlkZW50aWZpZXJcbiAgICAgICAgfSlcblxuICAgICAgICAvLyB3YWl0IGZvciB3b3JrZXIgdG8gZmluaXNoXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlbGVhc2VFdmVudExpc3RlbmVyID0gKHJlbGVhc2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlbGVhc2VFdmVudCAmJiByZWxlYXNlRXZlbnQudHlwZSA9PT0gcmVsZWFzZVR5cGUgJiYgcmVsZWFzZUV2ZW50LmlkZW50aWZpZXIgPT09IHJlcXVlc3RFdmVudC5pZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgIHdvcmtlci5yZW1vdmVMaXN0ZW5lcignbWVzc2FnZScsIHJlbGVhc2VFdmVudExpc3RlbmVyKVxuICAgICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3b3JrZXIub24oJ21lc3NhZ2UnLCByZWxlYXNlRXZlbnRMaXN0ZW5lcilcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IG1ha2VXb3JrZXJMb2NrUmVxdWVzdCA9IChuYW1lLCByZXF1ZXN0VHlwZSwgZ3JhbnRUeXBlLCByZWxlYXNlVHlwZSkgPT4ge1xuICByZXR1cm4gKGZuKSA9PiB7XG4gICAgY29uc3QgaWQgPSBzaG9ydGlkLmdlbmVyYXRlKClcblxuICAgIHByb2Nlc3Muc2VuZCh7XG4gICAgICB0eXBlOiByZXF1ZXN0VHlwZSxcbiAgICAgIGlkZW50aWZpZXI6IGlkLFxuICAgICAgbmFtZVxuICAgIH0pXG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgbGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09IGdyYW50VHlwZSAmJiBldmVudC5pZGVudGlmaWVyID09PSBpZCkge1xuICAgICAgICAgIHByb2Nlc3MucmVtb3ZlTGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lcilcblxuICAgICAgICAgIGxldCBlcnJvciA9IG51bGxcblxuICAgICAgICAgIGZuKClcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIGVycm9yID0gZXJyXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICBwcm9jZXNzLnNlbmQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IHJlbGVhc2VUeXBlLFxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGlkLFxuICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3Mub24oJ21lc3NhZ2UnLCBsaXN0ZW5lcilcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICBjbHVzdGVyID0gcmVxdWlyZSgnY2x1c3RlcicpXG5cbiAgICBpZiAoIU9iamVjdC5rZXlzKGNsdXN0ZXIpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoY2x1c3Rlci5pc01hc3RlciB8fCBvcHRpb25zLnNpbmdsZVByb2Nlc3MpIHtcbiAgICBjb25zdCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpXG5cbiAgICBjbHVzdGVyLm9uKCdtZXNzYWdlJywgaGFuZGxlV29ya2VyTG9ja1JlcXVlc3QoZW1pdHRlciwgJ3JlcXVlc3RSZWFkTG9jaycsIFdPUktFUl9SRVFVRVNUX1JFQURfTE9DSywgV09SS0VSX1JFTEVBU0VfUkVBRF9MT0NLLCBNQVNURVJfR1JBTlRfUkVBRF9MT0NLKSlcbiAgICBjbHVzdGVyLm9uKCdtZXNzYWdlJywgaGFuZGxlV29ya2VyTG9ja1JlcXVlc3QoZW1pdHRlciwgJ3JlcXVlc3RXcml0ZUxvY2snLCBXT1JLRVJfUkVRVUVTVF9XUklURV9MT0NLLCBXT1JLRVJfUkVMRUFTRV9XUklURV9MT0NLLCBNQVNURVJfR1JBTlRfV1JJVEVfTE9DSykpXG5cbiAgICByZXR1cm4gZW1pdHRlclxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpc1dvcmtlcjogdHJ1ZSxcbiAgICByZWFkTG9jazogKG5hbWUsIG9wdGlvbnMpID0+IG1ha2VXb3JrZXJMb2NrUmVxdWVzdChuYW1lLCBXT1JLRVJfUkVRVUVTVF9SRUFEX0xPQ0ssIE1BU1RFUl9HUkFOVF9SRUFEX0xPQ0ssIFdPUktFUl9SRUxFQVNFX1JFQURfTE9DSyksXG4gICAgd3JpdGVMb2NrOiAobmFtZSwgb3B0aW9ucykgPT4gbWFrZVdvcmtlckxvY2tSZXF1ZXN0KG5hbWUsIFdPUktFUl9SRVFVRVNUX1dSSVRFX0xPQ0ssIE1BU1RFUl9HUkFOVF9XUklURV9MT0NLLCBXT1JLRVJfUkVMRUFTRV9XUklURV9MT0NLKVxuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNyZWF0ZUhhc2ggPSByZXF1aXJlKFwiY3JlYXRlLWhhc2hcIik7XG5jb25zdCBwYmtkZjJfMSA9IHJlcXVpcmUoXCJwYmtkZjJcIik7XG5jb25zdCByYW5kb21CeXRlcyA9IHJlcXVpcmUoXCJyYW5kb21ieXRlc1wiKTtcbmNvbnN0IF93b3JkbGlzdHNfMSA9IHJlcXVpcmUoXCIuL193b3JkbGlzdHNcIik7XG5sZXQgREVGQVVMVF9XT1JETElTVCA9IF93b3JkbGlzdHNfMS5fZGVmYXVsdDtcbmNvbnN0IElOVkFMSURfTU5FTU9OSUMgPSAnSW52YWxpZCBtbmVtb25pYyc7XG5jb25zdCBJTlZBTElEX0VOVFJPUFkgPSAnSW52YWxpZCBlbnRyb3B5JztcbmNvbnN0IElOVkFMSURfQ0hFQ0tTVU0gPSAnSW52YWxpZCBtbmVtb25pYyBjaGVja3N1bSc7XG5jb25zdCBXT1JETElTVF9SRVFVSVJFRCA9ICdBIHdvcmRsaXN0IGlzIHJlcXVpcmVkIGJ1dCBhIGRlZmF1bHQgY291bGQgbm90IGJlIGZvdW5kLlxcbicgK1xuICAgICdQbGVhc2UgcGFzcyBhIDIwNDggd29yZCBhcnJheSBleHBsaWNpdGx5Lic7XG5mdW5jdGlvbiBwYmtkZjJQcm9taXNlKHBhc3N3b3JkLCBzYWx0TWl4aW4sIGl0ZXJhdGlvbnMsIGtleWxlbiwgZGlnZXN0KSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IChlcnIsIGRlcml2ZWRLZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShkZXJpdmVkS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcGJrZGYyXzEucGJrZGYyKHBhc3N3b3JkLCBzYWx0TWl4aW4sIGl0ZXJhdGlvbnMsIGtleWxlbiwgZGlnZXN0LCBjYWxsYmFjayk7XG4gICAgfSkpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplKHN0cikge1xuICAgIHJldHVybiAoc3RyIHx8ICcnKS5ub3JtYWxpemUoJ05GS0QnKTtcbn1cbmZ1bmN0aW9uIGxwYWQoc3RyLCBwYWRTdHJpbmcsIGxlbmd0aCkge1xuICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgIHN0ciA9IHBhZFN0cmluZyArIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIGJpbmFyeVRvQnl0ZShiaW4pIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoYmluLCAyKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzVG9CaW5hcnkoYnl0ZXMpIHtcbiAgICByZXR1cm4gYnl0ZXMubWFwKCh4KSA9PiBscGFkKHgudG9TdHJpbmcoMiksICcwJywgOCkpLmpvaW4oJycpO1xufVxuZnVuY3Rpb24gZGVyaXZlQ2hlY2tzdW1CaXRzKGVudHJvcHlCdWZmZXIpIHtcbiAgICBjb25zdCBFTlQgPSBlbnRyb3B5QnVmZmVyLmxlbmd0aCAqIDg7XG4gICAgY29uc3QgQ1MgPSBFTlQgLyAzMjtcbiAgICBjb25zdCBoYXNoID0gY3JlYXRlSGFzaCgnc2hhMjU2JylcbiAgICAgICAgLnVwZGF0ZShlbnRyb3B5QnVmZmVyKVxuICAgICAgICAuZGlnZXN0KCk7XG4gICAgcmV0dXJuIGJ5dGVzVG9CaW5hcnkoQXJyYXkuZnJvbShoYXNoKSkuc2xpY2UoMCwgQ1MpO1xufVxuZnVuY3Rpb24gc2FsdChwYXNzd29yZCkge1xuICAgIHJldHVybiAnbW5lbW9uaWMnICsgKHBhc3N3b3JkIHx8ICcnKTtcbn1cbmZ1bmN0aW9uIG1uZW1vbmljVG9TZWVkU3luYyhtbmVtb25pYywgcGFzc3dvcmQpIHtcbiAgICBjb25zdCBtbmVtb25pY0J1ZmZlciA9IEJ1ZmZlci5mcm9tKG5vcm1hbGl6ZShtbmVtb25pYyksICd1dGY4Jyk7XG4gICAgY29uc3Qgc2FsdEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHNhbHQobm9ybWFsaXplKHBhc3N3b3JkKSksICd1dGY4Jyk7XG4gICAgcmV0dXJuIHBia2RmMl8xLnBia2RmMlN5bmMobW5lbW9uaWNCdWZmZXIsIHNhbHRCdWZmZXIsIDIwNDgsIDY0LCAnc2hhNTEyJyk7XG59XG5leHBvcnRzLm1uZW1vbmljVG9TZWVkU3luYyA9IG1uZW1vbmljVG9TZWVkU3luYztcbmZ1bmN0aW9uIG1uZW1vbmljVG9TZWVkKG1uZW1vbmljLCBwYXNzd29yZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc3QgbW5lbW9uaWNCdWZmZXIgPSBCdWZmZXIuZnJvbShub3JtYWxpemUobW5lbW9uaWMpLCAndXRmOCcpO1xuICAgICAgICBjb25zdCBzYWx0QnVmZmVyID0gQnVmZmVyLmZyb20oc2FsdChub3JtYWxpemUocGFzc3dvcmQpKSwgJ3V0ZjgnKTtcbiAgICAgICAgcmV0dXJuIHBia2RmMlByb21pc2UobW5lbW9uaWNCdWZmZXIsIHNhbHRCdWZmZXIsIDIwNDgsIDY0LCAnc2hhNTEyJyk7XG4gICAgfSk7XG59XG5leHBvcnRzLm1uZW1vbmljVG9TZWVkID0gbW5lbW9uaWNUb1NlZWQ7XG5mdW5jdGlvbiBtbmVtb25pY1RvRW50cm9weShtbmVtb25pYywgd29yZGxpc3QpIHtcbiAgICB3b3JkbGlzdCA9IHdvcmRsaXN0IHx8IERFRkFVTFRfV09SRExJU1Q7XG4gICAgaWYgKCF3b3JkbGlzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoV09SRExJU1RfUkVRVUlSRUQpO1xuICAgIH1cbiAgICBjb25zdCB3b3JkcyA9IG5vcm1hbGl6ZShtbmVtb25pYykuc3BsaXQoJyAnKTtcbiAgICBpZiAod29yZHMubGVuZ3RoICUgMyAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9NTkVNT05JQyk7XG4gICAgfVxuICAgIC8vIGNvbnZlcnQgd29yZCBpbmRpY2VzIHRvIDExIGJpdCBiaW5hcnkgc3RyaW5nc1xuICAgIGNvbnN0IGJpdHMgPSB3b3Jkc1xuICAgICAgICAubWFwKCh3b3JkKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gd29yZGxpc3QuaW5kZXhPZih3b3JkKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfTU5FTU9OSUMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBscGFkKGluZGV4LnRvU3RyaW5nKDIpLCAnMCcsIDExKTtcbiAgICB9KVxuICAgICAgICAuam9pbignJyk7XG4gICAgLy8gc3BsaXQgdGhlIGJpbmFyeSBzdHJpbmcgaW50byBFTlQvQ1NcbiAgICBjb25zdCBkaXZpZGVySW5kZXggPSBNYXRoLmZsb29yKGJpdHMubGVuZ3RoIC8gMzMpICogMzI7XG4gICAgY29uc3QgZW50cm9weUJpdHMgPSBiaXRzLnNsaWNlKDAsIGRpdmlkZXJJbmRleCk7XG4gICAgY29uc3QgY2hlY2tzdW1CaXRzID0gYml0cy5zbGljZShkaXZpZGVySW5kZXgpO1xuICAgIC8vIGNhbGN1bGF0ZSB0aGUgY2hlY2tzdW0gYW5kIGNvbXBhcmVcbiAgICBjb25zdCBlbnRyb3B5Qnl0ZXMgPSBlbnRyb3B5Qml0cy5tYXRjaCgvKC57MSw4fSkvZykubWFwKGJpbmFyeVRvQnl0ZSk7XG4gICAgaWYgKGVudHJvcHlCeXRlcy5sZW5ndGggPCAxNikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9FTlRST1BZKTtcbiAgICB9XG4gICAgaWYgKGVudHJvcHlCeXRlcy5sZW5ndGggPiAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9FTlRST1BZKTtcbiAgICB9XG4gICAgaWYgKGVudHJvcHlCeXRlcy5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX0VOVFJPUFkpO1xuICAgIH1cbiAgICBjb25zdCBlbnRyb3B5ID0gQnVmZmVyLmZyb20oZW50cm9weUJ5dGVzKTtcbiAgICBjb25zdCBuZXdDaGVja3N1bSA9IGRlcml2ZUNoZWNrc3VtQml0cyhlbnRyb3B5KTtcbiAgICBpZiAobmV3Q2hlY2tzdW0gIT09IGNoZWNrc3VtQml0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9DSEVDS1NVTSk7XG4gICAgfVxuICAgIHJldHVybiBlbnRyb3B5LnRvU3RyaW5nKCdoZXgnKTtcbn1cbmV4cG9ydHMubW5lbW9uaWNUb0VudHJvcHkgPSBtbmVtb25pY1RvRW50cm9weTtcbmZ1bmN0aW9uIGVudHJvcHlUb01uZW1vbmljKGVudHJvcHksIHdvcmRsaXN0KSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZW50cm9weSkpIHtcbiAgICAgICAgZW50cm9weSA9IEJ1ZmZlci5mcm9tKGVudHJvcHksICdoZXgnKTtcbiAgICB9XG4gICAgd29yZGxpc3QgPSB3b3JkbGlzdCB8fCBERUZBVUxUX1dPUkRMSVNUO1xuICAgIGlmICghd29yZGxpc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFdPUkRMSVNUX1JFUVVJUkVEKTtcbiAgICB9XG4gICAgLy8gMTI4IDw9IEVOVCA8PSAyNTZcbiAgICBpZiAoZW50cm9weS5sZW5ndGggPCAxNikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKElOVkFMSURfRU5UUk9QWSk7XG4gICAgfVxuICAgIGlmIChlbnRyb3B5Lmxlbmd0aCA+IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoSU5WQUxJRF9FTlRST1BZKTtcbiAgICB9XG4gICAgaWYgKGVudHJvcHkubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKElOVkFMSURfRU5UUk9QWSk7XG4gICAgfVxuICAgIGNvbnN0IGVudHJvcHlCaXRzID0gYnl0ZXNUb0JpbmFyeShBcnJheS5mcm9tKGVudHJvcHkpKTtcbiAgICBjb25zdCBjaGVja3N1bUJpdHMgPSBkZXJpdmVDaGVja3N1bUJpdHMoZW50cm9weSk7XG4gICAgY29uc3QgYml0cyA9IGVudHJvcHlCaXRzICsgY2hlY2tzdW1CaXRzO1xuICAgIGNvbnN0IGNodW5rcyA9IGJpdHMubWF0Y2goLyguezEsMTF9KS9nKTtcbiAgICBjb25zdCB3b3JkcyA9IGNodW5rcy5tYXAoKGJpbmFyeSkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IGJpbmFyeVRvQnl0ZShiaW5hcnkpO1xuICAgICAgICByZXR1cm4gd29yZGxpc3RbaW5kZXhdO1xuICAgIH0pO1xuICAgIHJldHVybiB3b3JkbGlzdFswXSA9PT0gJ1xcdTMwNDJcXHUzMDQ0XFx1MzA1M1xcdTMwNGZcXHUzMDU3XFx1MzA5MycgLy8gSmFwYW5lc2Ugd29yZGxpc3RcbiAgICAgICAgPyB3b3Jkcy5qb2luKCdcXHUzMDAwJylcbiAgICAgICAgOiB3b3Jkcy5qb2luKCcgJyk7XG59XG5leHBvcnRzLmVudHJvcHlUb01uZW1vbmljID0gZW50cm9weVRvTW5lbW9uaWM7XG5mdW5jdGlvbiBnZW5lcmF0ZU1uZW1vbmljKHN0cmVuZ3RoLCBybmcsIHdvcmRsaXN0KSB7XG4gICAgc3RyZW5ndGggPSBzdHJlbmd0aCB8fCAxMjg7XG4gICAgaWYgKHN0cmVuZ3RoICUgMzIgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihJTlZBTElEX0VOVFJPUFkpO1xuICAgIH1cbiAgICBybmcgPSBybmcgfHwgcmFuZG9tQnl0ZXM7XG4gICAgcmV0dXJuIGVudHJvcHlUb01uZW1vbmljKHJuZyhzdHJlbmd0aCAvIDgpLCB3b3JkbGlzdCk7XG59XG5leHBvcnRzLmdlbmVyYXRlTW5lbW9uaWMgPSBnZW5lcmF0ZU1uZW1vbmljO1xuZnVuY3Rpb24gdmFsaWRhdGVNbmVtb25pYyhtbmVtb25pYywgd29yZGxpc3QpIHtcbiAgICB0cnkge1xuICAgICAgICBtbmVtb25pY1RvRW50cm9weShtbmVtb25pYywgd29yZGxpc3QpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy52YWxpZGF0ZU1uZW1vbmljID0gdmFsaWRhdGVNbmVtb25pYztcbmZ1bmN0aW9uIHNldERlZmF1bHRXb3JkbGlzdChsYW5ndWFnZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IF93b3JkbGlzdHNfMS53b3JkbGlzdHNbbGFuZ3VhZ2VdO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgREVGQVVMVF9XT1JETElTVCA9IHJlc3VsdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgd29yZGxpc3QgZm9yIGxhbmd1YWdlIFwiJyArIGxhbmd1YWdlICsgJ1wiJyk7XG4gICAgfVxufVxuZXhwb3J0cy5zZXREZWZhdWx0V29yZGxpc3QgPSBzZXREZWZhdWx0V29yZGxpc3Q7XG5mdW5jdGlvbiBnZXREZWZhdWx0V29yZGxpc3QoKSB7XG4gICAgaWYgKCFERUZBVUxUX1dPUkRMSVNUKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gRGVmYXVsdCBXb3JkbGlzdCBzZXQnKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKF93b3JkbGlzdHNfMS53b3JkbGlzdHMpLmZpbHRlcigobGFuZykgPT4ge1xuICAgICAgICBpZiAobGFuZyA9PT0gJ0pBJyB8fCBsYW5nID09PSAnRU4nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF93b3JkbGlzdHNfMS53b3JkbGlzdHNbbGFuZ10uZXZlcnkoKHdvcmQsIGluZGV4KSA9PiB3b3JkID09PSBERUZBVUxUX1dPUkRMSVNUW2luZGV4XSk7XG4gICAgfSlbMF07XG59XG5leHBvcnRzLmdldERlZmF1bHRXb3JkbGlzdCA9IGdldERlZmF1bHRXb3JkbGlzdDtcbnZhciBfd29yZGxpc3RzXzIgPSByZXF1aXJlKFwiLi9fd29yZGxpc3RzXCIpO1xuZXhwb3J0cy53b3JkbGlzdHMgPSBfd29yZGxpc3RzXzIud29yZGxpc3RzO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdpbW1lZGlhdGUnKVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8vIEZvciAob2xkKSBicm93c2VyIHN1cHBvcnRcbnZhciB4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBhc3NpZ24gPSByZXF1aXJlKCd4dGVuZC9tdXRhYmxlJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdXBwb3J0cyAoKSB7XG4gIHZhciBtYW5pZmVzdCA9IHh0ZW5kLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcblxuICByZXR1cm4gYXNzaWduKG1hbmlmZXN0LCB7XG4gICAgLy8gRmVhdHVyZXMgb2YgYWJzdHJhY3QtbGV2ZWxkb3duXG4gICAgYnVmZmVyS2V5czogbWFuaWZlc3QuYnVmZmVyS2V5cyB8fCBmYWxzZSxcbiAgICBzbmFwc2hvdHM6IG1hbmlmZXN0LnNuYXBzaG90cyB8fCBmYWxzZSxcbiAgICBwZXJtYW5lbmNlOiBtYW5pZmVzdC5wZXJtYW5lbmNlIHx8IGZhbHNlLFxuICAgIHNlZWs6IG1hbmlmZXN0LnNlZWsgfHwgZmFsc2UsXG4gICAgY2xlYXI6IG1hbmlmZXN0LmNsZWFyIHx8IGZhbHNlLFxuXG4gICAgLy8gRmVhdHVyZXMgb2YgYWJzdHJhY3QtbGV2ZWxkb3duIHRoYXQgbGV2ZWx1cCBkb2Vzbid0IGhhdmVcbiAgICBzdGF0dXM6IG1hbmlmZXN0LnN0YXR1cyB8fCBmYWxzZSxcblxuICAgIC8vIEZlYXR1cmVzIG9mIGRpc2stYmFzZWQgaW1wbGVtZW50YXRpb25zXG4gICAgY3JlYXRlSWZNaXNzaW5nOiBtYW5pZmVzdC5jcmVhdGVJZk1pc3NpbmcgfHwgZmFsc2UsXG4gICAgZXJyb3JJZkV4aXN0czogbWFuaWZlc3QuZXJyb3JJZkV4aXN0cyB8fCBmYWxzZSxcblxuICAgIC8vIEZlYXR1cmVzIG9mIGxldmVsKHVwKSB0aGF0IGFic3RyYWN0LWxldmVsZG93biBkb2Vzbid0IGhhdmUgeWV0XG4gICAgZGVmZXJyZWRPcGVuOiBtYW5pZmVzdC5kZWZlcnJlZE9wZW4gfHwgZmFsc2UsXG4gICAgb3BlbkNhbGxiYWNrOiBtYW5pZmVzdC5vcGVuQ2FsbGJhY2sgfHwgZmFsc2UsXG4gICAgcHJvbWlzZXM6IG1hbmlmZXN0LnByb21pc2VzIHx8IGZhbHNlLFxuICAgIHN0cmVhbXM6IG1hbmlmZXN0LnN0cmVhbXMgfHwgZmFsc2UsXG4gICAgZW5jb2RpbmdzOiBtYW5pZmVzdC5lbmNvZGluZ3MgfHwgZmFsc2UsXG5cbiAgICAvLyBNZXRob2RzIHRoYXQgYXJlIG5vdCBwYXJ0IG9mIGFic3RyYWN0LWxldmVsZG93biBvciBsZXZlbHVwXG4gICAgYWRkaXRpb25hbE1ldGhvZHM6IHh0ZW5kKG1hbmlmZXN0LmFkZGl0aW9uYWxNZXRob2RzKVxuICB9KVxufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgQk4gPSByZXF1aXJlKCcuL2JuJylcblxuZnVuY3Rpb24gRUNKUG9pbnQgKHgsIHksIHopIHtcbiAgaWYgKHggPT09IG51bGwgJiYgeSA9PT0gbnVsbCAmJiB6ID09PSBudWxsKSB7XG4gICAgdGhpcy54ID0gRUNKUG9pbnQub25lXG4gICAgdGhpcy55ID0gRUNKUG9pbnQub25lXG4gICAgdGhpcy56ID0gRUNKUG9pbnQuemVyb1xuICB9IGVsc2Uge1xuICAgIHRoaXMueCA9IHhcbiAgICB0aGlzLnkgPSB5XG4gICAgdGhpcy56ID0gelxuICB9XG5cbiAgdGhpcy56T25lID0gdGhpcy56ID09PSBFQ0pQb2ludC5vbmVcbn1cblxuRUNKUG9pbnQuemVybyA9IEJOLmZyb21OdW1iZXIoMClcbkVDSlBvaW50Lm9uZSA9IEJOLmZyb21OdW1iZXIoMSlcblxuRUNKUG9pbnQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuaW5mKSByZXR1cm4gdGhpc1xuXG4gIHJldHVybiBuZXcgRUNKUG9pbnQodGhpcy54LCB0aGlzLnkucmVkTmVnKCksIHRoaXMueilcbn1cblxuRUNKUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChwKSB7XG4gIC8vIE8gKyBQID0gUFxuICBpZiAodGhpcy5pbmYpIHJldHVybiBwXG5cbiAgLy8gUCArIE8gPSBQXG4gIGlmIChwLmluZikgcmV0dXJuIHRoaXNcblxuICAvLyBodHRwOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0wLmh0bWwjYWRkaXRpb24tYWRkLTE5OTgtY21vLTJcbiAgLy8gMTJNICsgNFMgKyA3QVxuICB2YXIgcHoyID0gcC56LnJlZFNxcigpXG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKVxuICB2YXIgdTEgPSB0aGlzLngucmVkTXVsKHB6MilcbiAgdmFyIHUyID0gcC54LnJlZE11bCh6MilcbiAgdmFyIHMxID0gdGhpcy55LnJlZE11bChwejIpLnJlZE11bChwLnopXG4gIHZhciBzMiA9IHAueS5yZWRNdWwoejIpLnJlZE11bCh0aGlzLnopXG5cbiAgdmFyIGggPSB1MS5yZWRTdWIodTIpXG4gIHZhciByID0gczEucmVkU3ViKHMyKVxuICBpZiAoaC5pc1plcm8oKSkge1xuICAgIGlmIChyLmlzWmVybygpKSByZXR1cm4gdGhpcy5kYmwoKVxuICAgIHJldHVybiBuZXcgRUNKUG9pbnQobnVsbCwgbnVsbCwgbnVsbClcbiAgfVxuXG4gIHZhciBoMiA9IGgucmVkU3FyKClcbiAgdmFyIHYgPSB1MS5yZWRNdWwoaDIpXG4gIHZhciBoMyA9IGgyLnJlZE11bChoKVxuXG4gIHZhciBueCA9IHIucmVkU3FyKCkucmVkSUFkZChoMykucmVkSVN1Yih2KS5yZWRJU3ViKHYpXG4gIHZhciBueSA9IHIucmVkTXVsKHYucmVkSVN1YihueCkpLnJlZElTdWIoczEucmVkTXVsKGgzKSlcbiAgdmFyIG56ID0gdGhpcy56LnJlZE11bChwLnopLnJlZE11bChoKVxuXG4gIHJldHVybiBuZXcgRUNKUG9pbnQobngsIG55LCBueilcbn1cblxuRUNKUG9pbnQucHJvdG90eXBlLm1peGVkQWRkID0gZnVuY3Rpb24gKHApIHtcbiAgLy8gTyArIFAgPSBQXG4gIGlmICh0aGlzLmluZikgcmV0dXJuIHAudG9FQ0pQb2ludCgpXG5cbiAgLy8gUCArIE8gPSBQXG4gIGlmIChwLmluZikgcmV0dXJuIHRoaXNcblxuICAvLyBodHRwOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0wLmh0bWwjYWRkaXRpb24tYWRkLTE5OTgtY21vLTJcbiAgLy8gICB3aXRoIHAueiA9IDFcbiAgLy8gOE0gKyAzUyArIDdBXG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKVxuICB2YXIgdTEgPSB0aGlzLnhcbiAgdmFyIHUyID0gcC54LnJlZE11bCh6MilcbiAgdmFyIHMxID0gdGhpcy55XG4gIHZhciBzMiA9IHAueS5yZWRNdWwoejIpLnJlZE11bCh0aGlzLnopXG5cbiAgdmFyIGggPSB1MS5yZWRTdWIodTIpXG4gIHZhciByID0gczEucmVkU3ViKHMyKVxuICBpZiAoaC5pc1plcm8oKSkge1xuICAgIGlmIChyLmlzWmVybygpKSByZXR1cm4gdGhpcy5kYmwoKVxuICAgIHJldHVybiBuZXcgRUNKUG9pbnQobnVsbCwgbnVsbCwgbnVsbClcbiAgfVxuXG4gIHZhciBoMiA9IGgucmVkU3FyKClcbiAgdmFyIHYgPSB1MS5yZWRNdWwoaDIpXG4gIHZhciBoMyA9IGgyLnJlZE11bChoKVxuXG4gIHZhciBueCA9IHIucmVkU3FyKCkucmVkSUFkZChoMykucmVkSVN1Yih2KS5yZWRJU3ViKHYpXG4gIHZhciBueSA9IHIucmVkTXVsKHYucmVkSVN1YihueCkpLnJlZElTdWIoczEucmVkTXVsKGgzKSlcbiAgdmFyIG56ID0gdGhpcy56LnJlZE11bChoKVxuXG4gIHJldHVybiBuZXcgRUNKUG9pbnQobngsIG55LCBueilcbn1cblxuRUNKUG9pbnQucHJvdG90eXBlLmRibCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuaW5mKSByZXR1cm4gdGhpc1xuXG4gIHZhciBueFxuICB2YXIgbnlcbiAgdmFyIG56XG5cbiAgLy8gWiA9IDFcbiAgaWYgKHRoaXMuek9uZSkge1xuICAgIC8vIGh0dHA6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbCNkb3VibGluZy1tZGJsLTIwMDctYmxcbiAgICAvLyAxTSArIDVTICsgNkEgKyAzKjIgKyAxKjMgKyAxKjhcblxuICAgIC8vIFhYID0gWDFeMlxuICAgIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKVxuICAgIC8vIFlZID0gWTFeMlxuICAgIHZhciB5eSA9IHRoaXMueS5yZWRTcXIoKVxuICAgIC8vIFlZWVkgPSBZWV4yXG4gICAgdmFyIHl5eXkgPSB5eS5yZWRTcXIoKVxuICAgIC8vIFMgPSAyICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKVxuICAgIHZhciBzID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KVxuICAgIHMgPSBzLnJlZElBZGQocylcbiAgICAvLyBNID0gMyAqIFhYXG4gICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpXG4gICAgLy8gVCA9IE0gXiAyIC0gMipTXG4gICAgdmFyIHQgPSBtLnJlZFNxcigpLnJlZElTdWIocykucmVkSVN1YihzKVxuXG4gICAgLy8gOCAqIFlZWVlcbiAgICB2YXIgeXl5eTggPSB5eXl5LnJlZElBZGQoeXl5eSkucmVkSUFkZCh5eXl5KS5yZWRJQWRkKHl5eXkpXG5cbiAgICAvLyBYMyA9IFRcbiAgICBueCA9IHRcbiAgICAvLyBZMyA9IE0gKiAoUyAtIFQpIC0gOCAqIFlZWVlcbiAgICBueSA9IG0ucmVkTXVsKHMucmVkSVN1Yih0KSkucmVkSVN1Yih5eXl5OClcbiAgICAvLyBaMyA9IDIqWTFcbiAgICBueiA9IHRoaXMueS5yZWRBZGQodGhpcy55KVxuICB9IGVsc2Uge1xuICAgIC8vIGh0dHA6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbCNkb3VibGluZy1kYmwtMjAwOS1sXG4gICAgLy8gMk0gKyA1UyArIDZBICsgMyoyICsgMSozICsgMSo4XG5cbiAgICAvLyBBID0gWDFeMlxuICAgIHZhciBhID0gdGhpcy54LnJlZFNxcigpXG4gICAgLy8gQiA9IFkxXjJcbiAgICB2YXIgYiA9IHRoaXMueS5yZWRTcXIoKVxuICAgIC8vIEMgPSBCXjJcbiAgICB2YXIgYyA9IGIucmVkU3FyKClcbiAgICAvLyBEID0gMiAqICgoWDEgKyBCKV4yIC0gQSAtIEMpXG4gICAgdmFyIGQgPSB0aGlzLngucmVkQWRkKGIpLnJlZFNxcigpLnJlZElTdWIoYSkucmVkSVN1YihjKVxuICAgIGQgPSBkLnJlZElBZGQoZClcbiAgICAvLyBFID0gMyAqIEFcbiAgICB2YXIgZSA9IGEucmVkQWRkKGEpLnJlZElBZGQoYSlcbiAgICAvLyBGID0gRV4yXG4gICAgdmFyIGYgPSBlLnJlZFNxcigpXG5cbiAgICAvLyA4ICogQ1xuICAgIHZhciBjOCA9IGMucmVkSUFkZChjKS5yZWRJQWRkKGMpLnJlZElBZGQoYylcblxuICAgIC8vIFgzID0gRiAtIDIgKiBEXG4gICAgbnggPSBmLnJlZElTdWIoZCkucmVkSVN1YihkKVxuICAgIC8vIFkzID0gRSAqIChEIC0gWDMpIC0gOCAqIENcbiAgICBueSA9IGUucmVkTXVsKGQucmVkSVN1YihueCkpLnJlZElTdWIoYzgpXG4gICAgLy8gWjMgPSAyICogWTEgKiBaMVxuICAgIG56ID0gdGhpcy55LnJlZE11bCh0aGlzLnopXG4gICAgbnogPSBuei5yZWRJQWRkKG56KVxuICB9XG5cbiAgcmV0dXJuIG5ldyBFQ0pQb2ludChueCwgbnksIG56KVxufVxuXG5FQ0pQb2ludC5wcm90b3R5cGUuZGJscCA9IGZ1bmN0aW9uIChwb3cpIHtcbiAgaWYgKHBvdyA9PT0gMCB8fCB0aGlzLmluZikgcmV0dXJuIHRoaXNcblxuICB2YXIgcG9pbnQgPSB0aGlzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG93OyBpKyspIHBvaW50ID0gcG9pbnQuZGJsKClcblxuICByZXR1cm4gcG9pbnRcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEVDSlBvaW50LnByb3RvdHlwZSwgJ2luZicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuei5pc1plcm8oKVxuICB9XG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVDSlBvaW50XG4iLCIndXNlIHN0cmljdCdcbmV4cG9ydHMudW11bFRvMTB4MTAgPSBmdW5jdGlvbiAobnVtMSwgbnVtMiwgb3V0KSB7XG4gIHZhciBhID0gbnVtMS53b3Jkc1xuICB2YXIgYiA9IG51bTIud29yZHNcbiAgdmFyIG8gPSBvdXQud29yZHNcbiAgdmFyIGMgPSAwXG4gIHZhciBsb1xuICB2YXIgbWlkXG4gIHZhciBoaVxuICB2YXIgYTAgPSBhWzBdIHwgMFxuICB2YXIgYWwwID0gYTAgJiAweDFmZmZcbiAgdmFyIGFoMCA9IGEwID4+PiAxM1xuICB2YXIgYTEgPSBhWzFdIHwgMFxuICB2YXIgYWwxID0gYTEgJiAweDFmZmZcbiAgdmFyIGFoMSA9IGExID4+PiAxM1xuICB2YXIgYTIgPSBhWzJdIHwgMFxuICB2YXIgYWwyID0gYTIgJiAweDFmZmZcbiAgdmFyIGFoMiA9IGEyID4+PiAxM1xuICB2YXIgYTMgPSBhWzNdIHwgMFxuICB2YXIgYWwzID0gYTMgJiAweDFmZmZcbiAgdmFyIGFoMyA9IGEzID4+PiAxM1xuICB2YXIgYTQgPSBhWzRdIHwgMFxuICB2YXIgYWw0ID0gYTQgJiAweDFmZmZcbiAgdmFyIGFoNCA9IGE0ID4+PiAxM1xuICB2YXIgYTUgPSBhWzVdIHwgMFxuICB2YXIgYWw1ID0gYTUgJiAweDFmZmZcbiAgdmFyIGFoNSA9IGE1ID4+PiAxM1xuICB2YXIgYTYgPSBhWzZdIHwgMFxuICB2YXIgYWw2ID0gYTYgJiAweDFmZmZcbiAgdmFyIGFoNiA9IGE2ID4+PiAxM1xuICB2YXIgYTcgPSBhWzddIHwgMFxuICB2YXIgYWw3ID0gYTcgJiAweDFmZmZcbiAgdmFyIGFoNyA9IGE3ID4+PiAxM1xuICB2YXIgYTggPSBhWzhdIHwgMFxuICB2YXIgYWw4ID0gYTggJiAweDFmZmZcbiAgdmFyIGFoOCA9IGE4ID4+PiAxM1xuICB2YXIgYTkgPSBhWzldIHwgMFxuICB2YXIgYWw5ID0gYTkgJiAweDFmZmZcbiAgdmFyIGFoOSA9IGE5ID4+PiAxM1xuICB2YXIgYjAgPSBiWzBdIHwgMFxuICB2YXIgYmwwID0gYjAgJiAweDFmZmZcbiAgdmFyIGJoMCA9IGIwID4+PiAxM1xuICB2YXIgYjEgPSBiWzFdIHwgMFxuICB2YXIgYmwxID0gYjEgJiAweDFmZmZcbiAgdmFyIGJoMSA9IGIxID4+PiAxM1xuICB2YXIgYjIgPSBiWzJdIHwgMFxuICB2YXIgYmwyID0gYjIgJiAweDFmZmZcbiAgdmFyIGJoMiA9IGIyID4+PiAxM1xuICB2YXIgYjMgPSBiWzNdIHwgMFxuICB2YXIgYmwzID0gYjMgJiAweDFmZmZcbiAgdmFyIGJoMyA9IGIzID4+PiAxM1xuICB2YXIgYjQgPSBiWzRdIHwgMFxuICB2YXIgYmw0ID0gYjQgJiAweDFmZmZcbiAgdmFyIGJoNCA9IGI0ID4+PiAxM1xuICB2YXIgYjUgPSBiWzVdIHwgMFxuICB2YXIgYmw1ID0gYjUgJiAweDFmZmZcbiAgdmFyIGJoNSA9IGI1ID4+PiAxM1xuICB2YXIgYjYgPSBiWzZdIHwgMFxuICB2YXIgYmw2ID0gYjYgJiAweDFmZmZcbiAgdmFyIGJoNiA9IGI2ID4+PiAxM1xuICB2YXIgYjcgPSBiWzddIHwgMFxuICB2YXIgYmw3ID0gYjcgJiAweDFmZmZcbiAgdmFyIGJoNyA9IGI3ID4+PiAxM1xuICB2YXIgYjggPSBiWzhdIHwgMFxuICB2YXIgYmw4ID0gYjggJiAweDFmZmZcbiAgdmFyIGJoOCA9IGI4ID4+PiAxM1xuICB2YXIgYjkgPSBiWzldIHwgMFxuICB2YXIgYmw5ID0gYjkgJiAweDFmZmZcbiAgdmFyIGJoOSA9IGI5ID4+PiAxM1xuXG4gIG91dC5sZW5ndGggPSAxOVxuICAvKiBrID0gMCAqL1xuICBsbyA9IE1hdGguaW11bChhbDAsIGJsMClcbiAgbWlkID0gTWF0aC5pbXVsKGFsMCwgYmgwKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoMCwgYmwwKVxuICBoaSA9IE1hdGguaW11bChhaDAsIGJoMClcbiAgdmFyIHcwID0gYyArIGxvICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKVxuICBjID0gaGkgKyAobWlkID4+PiAxMykgKyAodzAgPj4+IDI2KVxuICB3MCAmPSAweDNmZmZmZmZcbiAgLyogayA9IDEgKi9cbiAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDApXG4gIG1pZCA9IE1hdGguaW11bChhbDEsIGJoMClcbiAgbWlkICs9IE1hdGguaW11bChhaDEsIGJsMClcbiAgaGkgPSBNYXRoLmltdWwoYWgxLCBiaDApXG4gIGxvICs9IE1hdGguaW11bChhbDAsIGJsMSlcbiAgbWlkICs9IE1hdGguaW11bChhbDAsIGJoMSlcbiAgbWlkICs9IE1hdGguaW11bChhaDAsIGJsMSlcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMCwgYmgxKVxuICB2YXIgdzEgPSBjICsgbG8gKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpXG4gIGMgPSBoaSArIChtaWQgPj4+IDEzKSArICh3MSA+Pj4gMjYpXG4gIHcxICY9IDB4M2ZmZmZmZlxuICAvKiBrID0gMiAqL1xuICBsbyA9IE1hdGguaW11bChhbDIsIGJsMClcbiAgbWlkID0gTWF0aC5pbXVsKGFsMiwgYmgwKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoMiwgYmwwKVxuICBoaSA9IE1hdGguaW11bChhaDIsIGJoMClcbiAgbG8gKz0gTWF0aC5pbXVsKGFsMSwgYmwxKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsMSwgYmgxKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoMSwgYmwxKVxuICBoaSArPSBNYXRoLmltdWwoYWgxLCBiaDEpXG4gIGxvICs9IE1hdGguaW11bChhbDAsIGJsMilcbiAgbWlkICs9IE1hdGguaW11bChhbDAsIGJoMilcbiAgbWlkICs9IE1hdGguaW11bChhaDAsIGJsMilcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMCwgYmgyKVxuICB2YXIgdzIgPSBjICsgbG8gKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpXG4gIGMgPSBoaSArIChtaWQgPj4+IDEzKSArICh3MiA+Pj4gMjYpXG4gIHcyICY9IDB4M2ZmZmZmZlxuICAvKiBrID0gMyAqL1xuICBsbyA9IE1hdGguaW11bChhbDMsIGJsMClcbiAgbWlkID0gTWF0aC5pbXVsKGFsMywgYmgwKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoMywgYmwwKVxuICBoaSA9IE1hdGguaW11bChhaDMsIGJoMClcbiAgbG8gKz0gTWF0aC5pbXVsKGFsMiwgYmwxKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsMiwgYmgxKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoMiwgYmwxKVxuICBoaSArPSBNYXRoLmltdWwoYWgyLCBiaDEpXG4gIGxvICs9IE1hdGguaW11bChhbDEsIGJsMilcbiAgbWlkICs9IE1hdGguaW11bChhbDEsIGJoMilcbiAgbWlkICs9IE1hdGguaW11bChhaDEsIGJsMilcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMSwgYmgyKVxuICBsbyArPSBNYXRoLmltdWwoYWwwLCBibDMpXG4gIG1pZCArPSBNYXRoLmltdWwoYWwwLCBiaDMpXG4gIG1pZCArPSBNYXRoLmltdWwoYWgwLCBibDMpXG4gIGhpICs9IE1hdGguaW11bChhaDAsIGJoMylcbiAgdmFyIHczID0gYyArIGxvICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKVxuICBjID0gaGkgKyAobWlkID4+PiAxMykgKyAodzMgPj4+IDI2KVxuICB3MyAmPSAweDNmZmZmZmZcbiAgLyogayA9IDQgKi9cbiAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDApXG4gIG1pZCA9IE1hdGguaW11bChhbDQsIGJoMClcbiAgbWlkICs9IE1hdGguaW11bChhaDQsIGJsMClcbiAgaGkgPSBNYXRoLmltdWwoYWg0LCBiaDApXG4gIGxvICs9IE1hdGguaW11bChhbDMsIGJsMSlcbiAgbWlkICs9IE1hdGguaW11bChhbDMsIGJoMSlcbiAgbWlkICs9IE1hdGguaW11bChhaDMsIGJsMSlcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMywgYmgxKVxuICBsbyArPSBNYXRoLmltdWwoYWwyLCBibDIpXG4gIG1pZCArPSBNYXRoLmltdWwoYWwyLCBiaDIpXG4gIG1pZCArPSBNYXRoLmltdWwoYWgyLCBibDIpXG4gIGhpICs9IE1hdGguaW11bChhaDIsIGJoMilcbiAgbG8gKz0gTWF0aC5pbXVsKGFsMSwgYmwzKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsMSwgYmgzKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoMSwgYmwzKVxuICBoaSArPSBNYXRoLmltdWwoYWgxLCBiaDMpXG4gIGxvICs9IE1hdGguaW11bChhbDAsIGJsNClcbiAgbWlkICs9IE1hdGguaW11bChhbDAsIGJoNClcbiAgbWlkICs9IE1hdGguaW11bChhaDAsIGJsNClcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMCwgYmg0KVxuICB2YXIgdzQgPSBjICsgbG8gKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpXG4gIGMgPSBoaSArIChtaWQgPj4+IDEzKSArICh3NCA+Pj4gMjYpXG4gIHc0ICY9IDB4M2ZmZmZmZlxuICAvKiBrID0gNSAqL1xuICBsbyA9IE1hdGguaW11bChhbDUsIGJsMClcbiAgbWlkID0gTWF0aC5pbXVsKGFsNSwgYmgwKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNSwgYmwwKVxuICBoaSA9IE1hdGguaW11bChhaDUsIGJoMClcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNCwgYmwxKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNCwgYmgxKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNCwgYmwxKVxuICBoaSArPSBNYXRoLmltdWwoYWg0LCBiaDEpXG4gIGxvICs9IE1hdGguaW11bChhbDMsIGJsMilcbiAgbWlkICs9IE1hdGguaW11bChhbDMsIGJoMilcbiAgbWlkICs9IE1hdGguaW11bChhaDMsIGJsMilcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMywgYmgyKVxuICBsbyArPSBNYXRoLmltdWwoYWwyLCBibDMpXG4gIG1pZCArPSBNYXRoLmltdWwoYWwyLCBiaDMpXG4gIG1pZCArPSBNYXRoLmltdWwoYWgyLCBibDMpXG4gIGhpICs9IE1hdGguaW11bChhaDIsIGJoMylcbiAgbG8gKz0gTWF0aC5pbXVsKGFsMSwgYmw0KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsMSwgYmg0KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoMSwgYmw0KVxuICBoaSArPSBNYXRoLmltdWwoYWgxLCBiaDQpXG4gIGxvICs9IE1hdGguaW11bChhbDAsIGJsNSlcbiAgbWlkICs9IE1hdGguaW11bChhbDAsIGJoNSlcbiAgbWlkICs9IE1hdGguaW11bChhaDAsIGJsNSlcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMCwgYmg1KVxuICB2YXIgdzUgPSBjICsgbG8gKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpXG4gIGMgPSBoaSArIChtaWQgPj4+IDEzKSArICh3NSA+Pj4gMjYpXG4gIHc1ICY9IDB4M2ZmZmZmZlxuICAvKiBrID0gNiAqL1xuICBsbyA9IE1hdGguaW11bChhbDYsIGJsMClcbiAgbWlkID0gTWF0aC5pbXVsKGFsNiwgYmgwKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNiwgYmwwKVxuICBoaSA9IE1hdGguaW11bChhaDYsIGJoMClcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNSwgYmwxKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNSwgYmgxKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNSwgYmwxKVxuICBoaSArPSBNYXRoLmltdWwoYWg1LCBiaDEpXG4gIGxvICs9IE1hdGguaW11bChhbDQsIGJsMilcbiAgbWlkICs9IE1hdGguaW11bChhbDQsIGJoMilcbiAgbWlkICs9IE1hdGguaW11bChhaDQsIGJsMilcbiAgaGkgKz0gTWF0aC5pbXVsKGFoNCwgYmgyKVxuICBsbyArPSBNYXRoLmltdWwoYWwzLCBibDMpXG4gIG1pZCArPSBNYXRoLmltdWwoYWwzLCBiaDMpXG4gIG1pZCArPSBNYXRoLmltdWwoYWgzLCBibDMpXG4gIGhpICs9IE1hdGguaW11bChhaDMsIGJoMylcbiAgbG8gKz0gTWF0aC5pbXVsKGFsMiwgYmw0KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsMiwgYmg0KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoMiwgYmw0KVxuICBoaSArPSBNYXRoLmltdWwoYWgyLCBiaDQpXG4gIGxvICs9IE1hdGguaW11bChhbDEsIGJsNSlcbiAgbWlkICs9IE1hdGguaW11bChhbDEsIGJoNSlcbiAgbWlkICs9IE1hdGguaW11bChhaDEsIGJsNSlcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMSwgYmg1KVxuICBsbyArPSBNYXRoLmltdWwoYWwwLCBibDYpXG4gIG1pZCArPSBNYXRoLmltdWwoYWwwLCBiaDYpXG4gIG1pZCArPSBNYXRoLmltdWwoYWgwLCBibDYpXG4gIGhpICs9IE1hdGguaW11bChhaDAsIGJoNilcbiAgdmFyIHc2ID0gYyArIGxvICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKVxuICBjID0gaGkgKyAobWlkID4+PiAxMykgKyAodzYgPj4+IDI2KVxuICB3NiAmPSAweDNmZmZmZmZcbiAgLyogayA9IDcgKi9cbiAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDApXG4gIG1pZCA9IE1hdGguaW11bChhbDcsIGJoMClcbiAgbWlkICs9IE1hdGguaW11bChhaDcsIGJsMClcbiAgaGkgPSBNYXRoLmltdWwoYWg3LCBiaDApXG4gIGxvICs9IE1hdGguaW11bChhbDYsIGJsMSlcbiAgbWlkICs9IE1hdGguaW11bChhbDYsIGJoMSlcbiAgbWlkICs9IE1hdGguaW11bChhaDYsIGJsMSlcbiAgaGkgKz0gTWF0aC5pbXVsKGFoNiwgYmgxKVxuICBsbyArPSBNYXRoLmltdWwoYWw1LCBibDIpXG4gIG1pZCArPSBNYXRoLmltdWwoYWw1LCBiaDIpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg1LCBibDIpXG4gIGhpICs9IE1hdGguaW11bChhaDUsIGJoMilcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNCwgYmwzKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNCwgYmgzKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNCwgYmwzKVxuICBoaSArPSBNYXRoLmltdWwoYWg0LCBiaDMpXG4gIGxvICs9IE1hdGguaW11bChhbDMsIGJsNClcbiAgbWlkICs9IE1hdGguaW11bChhbDMsIGJoNClcbiAgbWlkICs9IE1hdGguaW11bChhaDMsIGJsNClcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMywgYmg0KVxuICBsbyArPSBNYXRoLmltdWwoYWwyLCBibDUpXG4gIG1pZCArPSBNYXRoLmltdWwoYWwyLCBiaDUpXG4gIG1pZCArPSBNYXRoLmltdWwoYWgyLCBibDUpXG4gIGhpICs9IE1hdGguaW11bChhaDIsIGJoNSlcbiAgbG8gKz0gTWF0aC5pbXVsKGFsMSwgYmw2KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsMSwgYmg2KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoMSwgYmw2KVxuICBoaSArPSBNYXRoLmltdWwoYWgxLCBiaDYpXG4gIGxvICs9IE1hdGguaW11bChhbDAsIGJsNylcbiAgbWlkICs9IE1hdGguaW11bChhbDAsIGJoNylcbiAgbWlkICs9IE1hdGguaW11bChhaDAsIGJsNylcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMCwgYmg3KVxuICB2YXIgdzcgPSBjICsgbG8gKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpXG4gIGMgPSBoaSArIChtaWQgPj4+IDEzKSArICh3NyA+Pj4gMjYpXG4gIHc3ICY9IDB4M2ZmZmZmZlxuICAvKiBrID0gOCAqL1xuICBsbyA9IE1hdGguaW11bChhbDgsIGJsMClcbiAgbWlkID0gTWF0aC5pbXVsKGFsOCwgYmgwKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOCwgYmwwKVxuICBoaSA9IE1hdGguaW11bChhaDgsIGJoMClcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNywgYmwxKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNywgYmgxKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNywgYmwxKVxuICBoaSArPSBNYXRoLmltdWwoYWg3LCBiaDEpXG4gIGxvICs9IE1hdGguaW11bChhbDYsIGJsMilcbiAgbWlkICs9IE1hdGguaW11bChhbDYsIGJoMilcbiAgbWlkICs9IE1hdGguaW11bChhaDYsIGJsMilcbiAgaGkgKz0gTWF0aC5pbXVsKGFoNiwgYmgyKVxuICBsbyArPSBNYXRoLmltdWwoYWw1LCBibDMpXG4gIG1pZCArPSBNYXRoLmltdWwoYWw1LCBiaDMpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg1LCBibDMpXG4gIGhpICs9IE1hdGguaW11bChhaDUsIGJoMylcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNCwgYmw0KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNCwgYmg0KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNCwgYmw0KVxuICBoaSArPSBNYXRoLmltdWwoYWg0LCBiaDQpXG4gIGxvICs9IE1hdGguaW11bChhbDMsIGJsNSlcbiAgbWlkICs9IE1hdGguaW11bChhbDMsIGJoNSlcbiAgbWlkICs9IE1hdGguaW11bChhaDMsIGJsNSlcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMywgYmg1KVxuICBsbyArPSBNYXRoLmltdWwoYWwyLCBibDYpXG4gIG1pZCArPSBNYXRoLmltdWwoYWwyLCBiaDYpXG4gIG1pZCArPSBNYXRoLmltdWwoYWgyLCBibDYpXG4gIGhpICs9IE1hdGguaW11bChhaDIsIGJoNilcbiAgbG8gKz0gTWF0aC5pbXVsKGFsMSwgYmw3KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsMSwgYmg3KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoMSwgYmw3KVxuICBoaSArPSBNYXRoLmltdWwoYWgxLCBiaDcpXG4gIGxvICs9IE1hdGguaW11bChhbDAsIGJsOClcbiAgbWlkICs9IE1hdGguaW11bChhbDAsIGJoOClcbiAgbWlkICs9IE1hdGguaW11bChhaDAsIGJsOClcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMCwgYmg4KVxuICB2YXIgdzggPSBjICsgbG8gKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpXG4gIGMgPSBoaSArIChtaWQgPj4+IDEzKSArICh3OCA+Pj4gMjYpXG4gIHc4ICY9IDB4M2ZmZmZmZlxuICAvKiBrID0gOSAqL1xuICBsbyA9IE1hdGguaW11bChhbDksIGJsMClcbiAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgwKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOSwgYmwwKVxuICBoaSA9IE1hdGguaW11bChhaDksIGJoMClcbiAgbG8gKz0gTWF0aC5pbXVsKGFsOCwgYmwxKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsOCwgYmgxKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOCwgYmwxKVxuICBoaSArPSBNYXRoLmltdWwoYWg4LCBiaDEpXG4gIGxvICs9IE1hdGguaW11bChhbDcsIGJsMilcbiAgbWlkICs9IE1hdGguaW11bChhbDcsIGJoMilcbiAgbWlkICs9IE1hdGguaW11bChhaDcsIGJsMilcbiAgaGkgKz0gTWF0aC5pbXVsKGFoNywgYmgyKVxuICBsbyArPSBNYXRoLmltdWwoYWw2LCBibDMpXG4gIG1pZCArPSBNYXRoLmltdWwoYWw2LCBiaDMpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg2LCBibDMpXG4gIGhpICs9IE1hdGguaW11bChhaDYsIGJoMylcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNSwgYmw0KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNSwgYmg0KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNSwgYmw0KVxuICBoaSArPSBNYXRoLmltdWwoYWg1LCBiaDQpXG4gIGxvICs9IE1hdGguaW11bChhbDQsIGJsNSlcbiAgbWlkICs9IE1hdGguaW11bChhbDQsIGJoNSlcbiAgbWlkICs9IE1hdGguaW11bChhaDQsIGJsNSlcbiAgaGkgKz0gTWF0aC5pbXVsKGFoNCwgYmg1KVxuICBsbyArPSBNYXRoLmltdWwoYWwzLCBibDYpXG4gIG1pZCArPSBNYXRoLmltdWwoYWwzLCBiaDYpXG4gIG1pZCArPSBNYXRoLmltdWwoYWgzLCBibDYpXG4gIGhpICs9IE1hdGguaW11bChhaDMsIGJoNilcbiAgbG8gKz0gTWF0aC5pbXVsKGFsMiwgYmw3KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsMiwgYmg3KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoMiwgYmw3KVxuICBoaSArPSBNYXRoLmltdWwoYWgyLCBiaDcpXG4gIGxvICs9IE1hdGguaW11bChhbDEsIGJsOClcbiAgbWlkICs9IE1hdGguaW11bChhbDEsIGJoOClcbiAgbWlkICs9IE1hdGguaW11bChhaDEsIGJsOClcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMSwgYmg4KVxuICBsbyArPSBNYXRoLmltdWwoYWwwLCBibDkpXG4gIG1pZCArPSBNYXRoLmltdWwoYWwwLCBiaDkpXG4gIG1pZCArPSBNYXRoLmltdWwoYWgwLCBibDkpXG4gIGhpICs9IE1hdGguaW11bChhaDAsIGJoOSlcbiAgdmFyIHc5ID0gYyArIGxvICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKVxuICBjID0gaGkgKyAobWlkID4+PiAxMykgKyAodzkgPj4+IDI2KVxuICB3OSAmPSAweDNmZmZmZmZcbiAgLyogayA9IDEwICovXG4gIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwxKVxuICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDEpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg5LCBibDEpXG4gIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgxKVxuICBsbyArPSBNYXRoLmltdWwoYWw4LCBibDIpXG4gIG1pZCArPSBNYXRoLmltdWwoYWw4LCBiaDIpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg4LCBibDIpXG4gIGhpICs9IE1hdGguaW11bChhaDgsIGJoMilcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNywgYmwzKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNywgYmgzKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNywgYmwzKVxuICBoaSArPSBNYXRoLmltdWwoYWg3LCBiaDMpXG4gIGxvICs9IE1hdGguaW11bChhbDYsIGJsNClcbiAgbWlkICs9IE1hdGguaW11bChhbDYsIGJoNClcbiAgbWlkICs9IE1hdGguaW11bChhaDYsIGJsNClcbiAgaGkgKz0gTWF0aC5pbXVsKGFoNiwgYmg0KVxuICBsbyArPSBNYXRoLmltdWwoYWw1LCBibDUpXG4gIG1pZCArPSBNYXRoLmltdWwoYWw1LCBiaDUpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg1LCBibDUpXG4gIGhpICs9IE1hdGguaW11bChhaDUsIGJoNSlcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNCwgYmw2KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNCwgYmg2KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNCwgYmw2KVxuICBoaSArPSBNYXRoLmltdWwoYWg0LCBiaDYpXG4gIGxvICs9IE1hdGguaW11bChhbDMsIGJsNylcbiAgbWlkICs9IE1hdGguaW11bChhbDMsIGJoNylcbiAgbWlkICs9IE1hdGguaW11bChhaDMsIGJsNylcbiAgaGkgKz0gTWF0aC5pbXVsKGFoMywgYmg3KVxuICBsbyArPSBNYXRoLmltdWwoYWwyLCBibDgpXG4gIG1pZCArPSBNYXRoLmltdWwoYWwyLCBiaDgpXG4gIG1pZCArPSBNYXRoLmltdWwoYWgyLCBibDgpXG4gIGhpICs9IE1hdGguaW11bChhaDIsIGJoOClcbiAgbG8gKz0gTWF0aC5pbXVsKGFsMSwgYmw5KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsMSwgYmg5KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoMSwgYmw5KVxuICBoaSArPSBNYXRoLmltdWwoYWgxLCBiaDkpXG4gIHZhciB3MTAgPSBjICsgbG8gKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpXG4gIGMgPSBoaSArIChtaWQgPj4+IDEzKSArICh3MTAgPj4+IDI2KVxuICB3MTAgJj0gMHgzZmZmZmZmXG4gIC8qIGsgPSAxMSAqL1xuICBsbyA9IE1hdGguaW11bChhbDksIGJsMilcbiAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgyKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOSwgYmwyKVxuICBoaSA9IE1hdGguaW11bChhaDksIGJoMilcbiAgbG8gKz0gTWF0aC5pbXVsKGFsOCwgYmwzKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsOCwgYmgzKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOCwgYmwzKVxuICBoaSArPSBNYXRoLmltdWwoYWg4LCBiaDMpXG4gIGxvICs9IE1hdGguaW11bChhbDcsIGJsNClcbiAgbWlkICs9IE1hdGguaW11bChhbDcsIGJoNClcbiAgbWlkICs9IE1hdGguaW11bChhaDcsIGJsNClcbiAgaGkgKz0gTWF0aC5pbXVsKGFoNywgYmg0KVxuICBsbyArPSBNYXRoLmltdWwoYWw2LCBibDUpXG4gIG1pZCArPSBNYXRoLmltdWwoYWw2LCBiaDUpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg2LCBibDUpXG4gIGhpICs9IE1hdGguaW11bChhaDYsIGJoNSlcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNSwgYmw2KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNSwgYmg2KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNSwgYmw2KVxuICBoaSArPSBNYXRoLmltdWwoYWg1LCBiaDYpXG4gIGxvICs9IE1hdGguaW11bChhbDQsIGJsNylcbiAgbWlkICs9IE1hdGguaW11bChhbDQsIGJoNylcbiAgbWlkICs9IE1hdGguaW11bChhaDQsIGJsNylcbiAgaGkgKz0gTWF0aC5pbXVsKGFoNCwgYmg3KVxuICBsbyArPSBNYXRoLmltdWwoYWwzLCBibDgpXG4gIG1pZCArPSBNYXRoLmltdWwoYWwzLCBiaDgpXG4gIG1pZCArPSBNYXRoLmltdWwoYWgzLCBibDgpXG4gIGhpICs9IE1hdGguaW11bChhaDMsIGJoOClcbiAgbG8gKz0gTWF0aC5pbXVsKGFsMiwgYmw5KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsMiwgYmg5KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoMiwgYmw5KVxuICBoaSArPSBNYXRoLmltdWwoYWgyLCBiaDkpXG4gIHZhciB3MTEgPSBjICsgbG8gKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpXG4gIGMgPSBoaSArIChtaWQgPj4+IDEzKSArICh3MTEgPj4+IDI2KVxuICB3MTEgJj0gMHgzZmZmZmZmXG4gIC8qIGsgPSAxMiAqL1xuICBsbyA9IE1hdGguaW11bChhbDksIGJsMylcbiAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgzKVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOSwgYmwzKVxuICBoaSA9IE1hdGguaW11bChhaDksIGJoMylcbiAgbG8gKz0gTWF0aC5pbXVsKGFsOCwgYmw0KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsOCwgYmg0KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOCwgYmw0KVxuICBoaSArPSBNYXRoLmltdWwoYWg4LCBiaDQpXG4gIGxvICs9IE1hdGguaW11bChhbDcsIGJsNSlcbiAgbWlkICs9IE1hdGguaW11bChhbDcsIGJoNSlcbiAgbWlkICs9IE1hdGguaW11bChhaDcsIGJsNSlcbiAgaGkgKz0gTWF0aC5pbXVsKGFoNywgYmg1KVxuICBsbyArPSBNYXRoLmltdWwoYWw2LCBibDYpXG4gIG1pZCArPSBNYXRoLmltdWwoYWw2LCBiaDYpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg2LCBibDYpXG4gIGhpICs9IE1hdGguaW11bChhaDYsIGJoNilcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNSwgYmw3KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNSwgYmg3KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNSwgYmw3KVxuICBoaSArPSBNYXRoLmltdWwoYWg1LCBiaDcpXG4gIGxvICs9IE1hdGguaW11bChhbDQsIGJsOClcbiAgbWlkICs9IE1hdGguaW11bChhbDQsIGJoOClcbiAgbWlkICs9IE1hdGguaW11bChhaDQsIGJsOClcbiAgaGkgKz0gTWF0aC5pbXVsKGFoNCwgYmg4KVxuICBsbyArPSBNYXRoLmltdWwoYWwzLCBibDkpXG4gIG1pZCArPSBNYXRoLmltdWwoYWwzLCBiaDkpXG4gIG1pZCArPSBNYXRoLmltdWwoYWgzLCBibDkpXG4gIGhpICs9IE1hdGguaW11bChhaDMsIGJoOSlcbiAgdmFyIHcxMiA9IGMgKyBsbyArICgobWlkICYgMHgxZmZmKSA8PCAxMylcbiAgYyA9IGhpICsgKG1pZCA+Pj4gMTMpICsgKHcxMiA+Pj4gMjYpXG4gIHcxMiAmPSAweDNmZmZmZmZcbiAgLyogayA9IDEzICovXG4gIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw0KVxuICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDQpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg5LCBibDQpXG4gIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg0KVxuICBsbyArPSBNYXRoLmltdWwoYWw4LCBibDUpXG4gIG1pZCArPSBNYXRoLmltdWwoYWw4LCBiaDUpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg4LCBibDUpXG4gIGhpICs9IE1hdGguaW11bChhaDgsIGJoNSlcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNywgYmw2KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNywgYmg2KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNywgYmw2KVxuICBoaSArPSBNYXRoLmltdWwoYWg3LCBiaDYpXG4gIGxvICs9IE1hdGguaW11bChhbDYsIGJsNylcbiAgbWlkICs9IE1hdGguaW11bChhbDYsIGJoNylcbiAgbWlkICs9IE1hdGguaW11bChhaDYsIGJsNylcbiAgaGkgKz0gTWF0aC5pbXVsKGFoNiwgYmg3KVxuICBsbyArPSBNYXRoLmltdWwoYWw1LCBibDgpXG4gIG1pZCArPSBNYXRoLmltdWwoYWw1LCBiaDgpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg1LCBibDgpXG4gIGhpICs9IE1hdGguaW11bChhaDUsIGJoOClcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNCwgYmw5KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNCwgYmg5KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNCwgYmw5KVxuICBoaSArPSBNYXRoLmltdWwoYWg0LCBiaDkpXG4gIHZhciB3MTMgPSBjICsgbG8gKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpXG4gIGMgPSBoaSArIChtaWQgPj4+IDEzKSArICh3MTMgPj4+IDI2KVxuICB3MTMgJj0gMHgzZmZmZmZmXG4gIC8qIGsgPSAxNCAqL1xuICBsbyA9IE1hdGguaW11bChhbDksIGJsNSlcbiAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg1KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOSwgYmw1KVxuICBoaSA9IE1hdGguaW11bChhaDksIGJoNSlcbiAgbG8gKz0gTWF0aC5pbXVsKGFsOCwgYmw2KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsOCwgYmg2KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOCwgYmw2KVxuICBoaSArPSBNYXRoLmltdWwoYWg4LCBiaDYpXG4gIGxvICs9IE1hdGguaW11bChhbDcsIGJsNylcbiAgbWlkICs9IE1hdGguaW11bChhbDcsIGJoNylcbiAgbWlkICs9IE1hdGguaW11bChhaDcsIGJsNylcbiAgaGkgKz0gTWF0aC5pbXVsKGFoNywgYmg3KVxuICBsbyArPSBNYXRoLmltdWwoYWw2LCBibDgpXG4gIG1pZCArPSBNYXRoLmltdWwoYWw2LCBiaDgpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg2LCBibDgpXG4gIGhpICs9IE1hdGguaW11bChhaDYsIGJoOClcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNSwgYmw5KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNSwgYmg5KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNSwgYmw5KVxuICBoaSArPSBNYXRoLmltdWwoYWg1LCBiaDkpXG4gIHZhciB3MTQgPSBjICsgbG8gKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpXG4gIGMgPSBoaSArIChtaWQgPj4+IDEzKSArICh3MTQgPj4+IDI2KVxuICB3MTQgJj0gMHgzZmZmZmZmXG4gIC8qIGsgPSAxNSAqL1xuICBsbyA9IE1hdGguaW11bChhbDksIGJsNilcbiAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg2KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOSwgYmw2KVxuICBoaSA9IE1hdGguaW11bChhaDksIGJoNilcbiAgbG8gKz0gTWF0aC5pbXVsKGFsOCwgYmw3KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsOCwgYmg3KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOCwgYmw3KVxuICBoaSArPSBNYXRoLmltdWwoYWg4LCBiaDcpXG4gIGxvICs9IE1hdGguaW11bChhbDcsIGJsOClcbiAgbWlkICs9IE1hdGguaW11bChhbDcsIGJoOClcbiAgbWlkICs9IE1hdGguaW11bChhaDcsIGJsOClcbiAgaGkgKz0gTWF0aC5pbXVsKGFoNywgYmg4KVxuICBsbyArPSBNYXRoLmltdWwoYWw2LCBibDkpXG4gIG1pZCArPSBNYXRoLmltdWwoYWw2LCBiaDkpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg2LCBibDkpXG4gIGhpICs9IE1hdGguaW11bChhaDYsIGJoOSlcbiAgdmFyIHcxNSA9IGMgKyBsbyArICgobWlkICYgMHgxZmZmKSA8PCAxMylcbiAgYyA9IGhpICsgKG1pZCA+Pj4gMTMpICsgKHcxNSA+Pj4gMjYpXG4gIHcxNSAmPSAweDNmZmZmZmZcbiAgLyogayA9IDE2ICovXG4gIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw3KVxuICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDcpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg5LCBibDcpXG4gIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg3KVxuICBsbyArPSBNYXRoLmltdWwoYWw4LCBibDgpXG4gIG1pZCArPSBNYXRoLmltdWwoYWw4LCBiaDgpXG4gIG1pZCArPSBNYXRoLmltdWwoYWg4LCBibDgpXG4gIGhpICs9IE1hdGguaW11bChhaDgsIGJoOClcbiAgbG8gKz0gTWF0aC5pbXVsKGFsNywgYmw5KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsNywgYmg5KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoNywgYmw5KVxuICBoaSArPSBNYXRoLmltdWwoYWg3LCBiaDkpXG4gIHZhciB3MTYgPSBjICsgbG8gKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpXG4gIGMgPSBoaSArIChtaWQgPj4+IDEzKSArICh3MTYgPj4+IDI2KVxuICB3MTYgJj0gMHgzZmZmZmZmXG4gIC8qIGsgPSAxNyAqL1xuICBsbyA9IE1hdGguaW11bChhbDksIGJsOClcbiAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg4KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOSwgYmw4KVxuICBoaSA9IE1hdGguaW11bChhaDksIGJoOClcbiAgbG8gKz0gTWF0aC5pbXVsKGFsOCwgYmw5KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFsOCwgYmg5KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOCwgYmw5KVxuICBoaSArPSBNYXRoLmltdWwoYWg4LCBiaDkpXG4gIHZhciB3MTcgPSBjICsgbG8gKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpXG4gIGMgPSBoaSArIChtaWQgPj4+IDEzKSArICh3MTcgPj4+IDI2KVxuICB3MTcgJj0gMHgzZmZmZmZmXG4gIC8qIGsgPSAxOCAqL1xuICBsbyA9IE1hdGguaW11bChhbDksIGJsOSlcbiAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg5KVxuICBtaWQgKz0gTWF0aC5pbXVsKGFoOSwgYmw5KVxuICBoaSA9IE1hdGguaW11bChhaDksIGJoOSlcbiAgdmFyIHcxOCA9IGMgKyBsbyArICgobWlkICYgMHgxZmZmKSA8PCAxMylcbiAgYyA9IGhpICsgKG1pZCA+Pj4gMTMpICsgKHcxOCA+Pj4gMjYpXG4gIHcxOCAmPSAweDNmZmZmZmZcbiAgb1swXSA9IHcwXG4gIG9bMV0gPSB3MVxuICBvWzJdID0gdzJcbiAgb1szXSA9IHczXG4gIG9bNF0gPSB3NFxuICBvWzVdID0gdzVcbiAgb1s2XSA9IHc2XG4gIG9bN10gPSB3N1xuICBvWzhdID0gdzhcbiAgb1s5XSA9IHc5XG4gIG9bMTBdID0gdzEwXG4gIG9bMTFdID0gdzExXG4gIG9bMTJdID0gdzEyXG4gIG9bMTNdID0gdzEzXG4gIG9bMTRdID0gdzE0XG4gIG9bMTVdID0gdzE1XG4gIG9bMTZdID0gdzE2XG4gIG9bMTddID0gdzE3XG4gIG9bMThdID0gdzE4XG4gIGlmIChjICE9PSAwKSB7XG4gICAgb1sxOV0gPSBjXG4gICAgb3V0Lmxlbmd0aCsrXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcInNoYTFcIjoge1xuICAgIFwic2VjdXJpdHlTdHJlbmd0aFwiOiAxMjgsXG4gICAgXCJvdXRsZW5cIjogMTYwLFxuICAgIFwic2VlZGxlblwiOiA0NDBcbiAgfSxcbiAgXCJzaGEyMjRcIjoge1xuICAgIFwic2VjdXJpdHlTdHJlbmd0aFwiOiAxOTIsXG4gICAgXCJvdXRsZW5cIjogMjI0LFxuICAgIFwic2VlZGxlblwiOiA0NDBcbiAgfSxcbiAgXCJzaGEyNTZcIjoge1xuICAgIFwic2VjdXJpdHlTdHJlbmd0aFwiOiAyNTYsXG4gICAgXCJvdXRsZW5cIjogMjU2LFxuICAgIFwic2VlZGxlblwiOiA0NDBcbiAgfSxcbiAgXCJzaGEzODRcIjoge1xuICAgIFwic2VjdXJpdHlTdHJlbmd0aFwiOiAyNTYsXG4gICAgXCJvdXRsZW5cIjogMzg0LFxuICAgIFwic2VlZGxlblwiOiA4ODhcbiAgfSxcbiAgXCJzaGE1MTJcIjoge1xuICAgIFwic2VjdXJpdHlTdHJlbmd0aFwiOiAyNTYsXG4gICAgXCJvdXRsZW5cIjogNTEyLFxuICAgIFwic2VlZGxlblwiOiA4ODhcbiAgfVxufVxuIiwiLyoqXG4gKiBKYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIFBLQ1MjMSBQU1Mgc2lnbmF0dXJlIHBhZGRpbmcuXG4gKlxuICogQGF1dGhvciBTdGVmYW4gU2llZ2xcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9yYW5kb20nKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vLyBzaG9ydGN1dCBmb3IgUFNTIEFQSVxudmFyIHBzcyA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucHNzID0gZm9yZ2UucHNzIHx8IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBQU1Mgc2lnbmF0dXJlIHNjaGVtZSBvYmplY3QuXG4gKlxuICogVGhlcmUgYXJlIHNldmVyYWwgd2F5cyB0byBwcm92aWRlIGEgc2FsdCBmb3IgZW5jb2Rpbmc6XG4gKlxuICogMS4gU3BlY2lmeSB0aGUgc2FsdExlbmd0aCBvbmx5IGFuZCB0aGUgYnVpbHQtaW4gUFJORyB3aWxsIGdlbmVyYXRlIGl0LlxuICogMi4gU3BlY2lmeSB0aGUgc2FsdExlbmd0aCBhbmQgYSBjdXN0b20gUFJORyB3aXRoICdnZXRCeXRlc1N5bmMnIGRlZmluZWQgdGhhdFxuICogICB3aWxsIGJlIHVzZWQuXG4gKiAzLiBTcGVjaWZ5IHRoZSBzYWx0IGl0c2VsZiBhcyBhIGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBtZCB0aGUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0IHRvIHVzZSwgYSBmb3JnZSBtZCBpbnN0YW5jZS5cbiAqICAgICAgICAgIG1nZiB0aGUgbWFzayBnZW5lcmF0aW9uIGZ1bmN0aW9uIHRvIHVzZSwgYSBmb3JnZSBtZ2YgaW5zdGFuY2UuXG4gKiAgICAgICAgICBbc2FsdExlbmd0aF0gdGhlIGxlbmd0aCBvZiB0aGUgc2FsdCBpbiBvY3RldHMuXG4gKiAgICAgICAgICBbcHJuZ10gdGhlIHBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvciB0byB1c2UgdG8gcHJvZHVjZSBhIHNhbHQuXG4gKiAgICAgICAgICBbc2FsdF0gdGhlIHNhbHQgdG8gdXNlIHdoZW4gZW5jb2RpbmcuXG4gKlxuICogQHJldHVybiBhIHNpZ25hdHVyZSBzY2hlbWUgb2JqZWN0LlxuICovXG5wc3MuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3L2xlZ2FjeSBhcmdzOiBoYXNoLCBtZ2YsIHNMZW5cbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBtZDogYXJndW1lbnRzWzBdLFxuICAgICAgbWdmOiBhcmd1bWVudHNbMV0sXG4gICAgICBzYWx0TGVuZ3RoOiBhcmd1bWVudHNbMl1cbiAgICB9O1xuICB9XG5cbiAgdmFyIGhhc2ggPSBvcHRpb25zLm1kO1xuICB2YXIgbWdmID0gb3B0aW9ucy5tZ2Y7XG4gIHZhciBoTGVuID0gaGFzaC5kaWdlc3RMZW5ndGg7XG5cbiAgdmFyIHNhbHRfID0gb3B0aW9ucy5zYWx0IHx8IG51bGw7XG4gIGlmKHR5cGVvZiBzYWx0XyA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBhc3N1bWUgYmluYXJ5LWVuY29kZWQgc3RyaW5nXG4gICAgc2FsdF8gPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihzYWx0Xyk7XG4gIH1cblxuICB2YXIgc0xlbjtcbiAgaWYoJ3NhbHRMZW5ndGgnIGluIG9wdGlvbnMpIHtcbiAgICBzTGVuID0gb3B0aW9ucy5zYWx0TGVuZ3RoO1xuICB9IGVsc2UgaWYoc2FsdF8gIT09IG51bGwpIHtcbiAgICBzTGVuID0gc2FsdF8ubGVuZ3RoKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTYWx0IGxlbmd0aCBub3Qgc3BlY2lmaWVkIG9yIHNwZWNpZmljIHNhbHQgbm90IGdpdmVuLicpO1xuICB9XG5cbiAgaWYoc2FsdF8gIT09IG51bGwgJiYgc2FsdF8ubGVuZ3RoKCkgIT09IHNMZW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dpdmVuIHNhbHQgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIGxlbmd0aCBvZiBnaXZlbiBzYWx0LicpO1xuICB9XG5cbiAgdmFyIHBybmcgPSBvcHRpb25zLnBybmcgfHwgZm9yZ2UucmFuZG9tO1xuXG4gIHZhciBwc3NvYmogPSB7fTtcblxuICAvKipcbiAgICogRW5jb2RlcyBhIFBTUyBzaWduYXR1cmUuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gaW1wbGVtZW50cyBFTVNBLVBTUy1FTkNPREUgYXMgcGVyIFJGQyAzNDQ3LCBzZWN0aW9uIDkuMS4xLlxuICAgKlxuICAgKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB3aXRoIHRoZSBoYXNoIHRvIHNpZ24uXG4gICAqIEBwYXJhbSBtb2RzQml0cyB0aGUgbGVuZ3RoIG9mIHRoZSBSU0EgbW9kdWx1cyBpbiBiaXRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBlbmNvZGVkIG1lc3NhZ2UgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgbGVuZ3RoXG4gICAqICAgICAgICAgICBjZWlsKChtb2RCaXRzIC0gMSkgLyA4KS5cbiAgICovXG4gIHBzc29iai5lbmNvZGUgPSBmdW5jdGlvbihtZCwgbW9kQml0cykge1xuICAgIHZhciBpO1xuICAgIHZhciBlbUJpdHMgPSBtb2RCaXRzIC0gMTtcbiAgICB2YXIgZW1MZW4gPSBNYXRoLmNlaWwoZW1CaXRzIC8gOCk7XG5cbiAgICAvKiAyLiBMZXQgbUhhc2ggPSBIYXNoKE0pLCBhbiBvY3RldCBzdHJpbmcgb2YgbGVuZ3RoIGhMZW4uICovXG4gICAgdmFyIG1IYXNoID0gbWQuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcblxuICAgIC8qIDMuIElmIGVtTGVuIDwgaExlbiArIHNMZW4gKyAyLCBvdXRwdXQgXCJlbmNvZGluZyBlcnJvclwiIGFuZCBzdG9wLiAqL1xuICAgIGlmKGVtTGVuIDwgaExlbiArIHNMZW4gKyAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lc3NhZ2UgaXMgdG9vIGxvbmcgdG8gZW5jcnlwdC4nKTtcbiAgICB9XG5cbiAgICAvKiA0LiBHZW5lcmF0ZSBhIHJhbmRvbSBvY3RldCBzdHJpbmcgc2FsdCBvZiBsZW5ndGggc0xlbjsgaWYgc0xlbiA9IDAsXG4gICAgICogICAgdGhlbiBzYWx0IGlzIHRoZSBlbXB0eSBzdHJpbmcuICovXG4gICAgdmFyIHNhbHQ7XG4gICAgaWYoc2FsdF8gPT09IG51bGwpIHtcbiAgICAgIHNhbHQgPSBwcm5nLmdldEJ5dGVzU3luYyhzTGVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2FsdCA9IHNhbHRfLmJ5dGVzKCk7XG4gICAgfVxuXG4gICAgLyogNS4gTGV0IE0nID0gKDB4KTAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIHx8IG1IYXNoIHx8IHNhbHQ7ICovXG4gICAgdmFyIG1fID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICAgIG1fLmZpbGxXaXRoQnl0ZSgwLCA4KTtcbiAgICBtXy5wdXRCeXRlcyhtSGFzaCk7XG4gICAgbV8ucHV0Qnl0ZXMoc2FsdCk7XG5cbiAgICAvKiA2LiBMZXQgSCA9IEhhc2goTScpLCBhbiBvY3RldCBzdHJpbmcgb2YgbGVuZ3RoIGhMZW4uICovXG4gICAgaGFzaC5zdGFydCgpO1xuICAgIGhhc2gudXBkYXRlKG1fLmdldEJ5dGVzKCkpO1xuICAgIHZhciBoID0gaGFzaC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gICAgLyogNy4gR2VuZXJhdGUgYW4gb2N0ZXQgc3RyaW5nIFBTIGNvbnNpc3Rpbmcgb2YgZW1MZW4gLSBzTGVuIC0gaExlbiAtIDJcbiAgICAgKiAgICB6ZXJvIG9jdGV0cy4gIFRoZSBsZW5ndGggb2YgUFMgbWF5IGJlIDAuICovXG4gICAgdmFyIHBzID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICAgIHBzLmZpbGxXaXRoQnl0ZSgwLCBlbUxlbiAtIHNMZW4gLSBoTGVuIC0gMik7XG5cbiAgICAvKiA4LiBMZXQgREIgPSBQUyB8fCAweDAxIHx8IHNhbHQ7IERCIGlzIGFuIG9jdGV0IHN0cmluZyBvZiBsZW5ndGhcbiAgICAgKiAgICBlbUxlbiAtIGhMZW4gLSAxLiAqL1xuICAgIHBzLnB1dEJ5dGUoMHgwMSk7XG4gICAgcHMucHV0Qnl0ZXMoc2FsdCk7XG4gICAgdmFyIGRiID0gcHMuZ2V0Qnl0ZXMoKTtcblxuICAgIC8qIDkuIExldCBkYk1hc2sgPSBNR0YoSCwgZW1MZW4gLSBoTGVuIC0gMSkuICovXG4gICAgdmFyIG1hc2tMZW4gPSBlbUxlbiAtIGhMZW4gLSAxO1xuICAgIHZhciBkYk1hc2sgPSBtZ2YuZ2VuZXJhdGUoaCwgbWFza0xlbik7XG5cbiAgICAvKiAxMC4gTGV0IG1hc2tlZERCID0gREIgXFx4b3IgZGJNYXNrLiAqL1xuICAgIHZhciBtYXNrZWREQiA9ICcnO1xuICAgIGZvcihpID0gMDsgaSA8IG1hc2tMZW47IGkrKykge1xuICAgICAgbWFza2VkREIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYi5jaGFyQ29kZUF0KGkpIF4gZGJNYXNrLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cblxuICAgIC8qIDExLiBTZXQgdGhlIGxlZnRtb3N0IDhlbUxlbiAtIGVtQml0cyBiaXRzIG9mIHRoZSBsZWZ0bW9zdCBvY3RldCBpblxuICAgICAqICAgICBtYXNrZWREQiB0byB6ZXJvLiAqL1xuICAgIHZhciBtYXNrID0gKDB4RkYwMCA+PiAoOCAqIGVtTGVuIC0gZW1CaXRzKSkgJiAweEZGO1xuICAgIG1hc2tlZERCID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXNrZWREQi5jaGFyQ29kZUF0KDApICYgfm1hc2spICtcbiAgICAgIG1hc2tlZERCLnN1YnN0cigxKTtcblxuICAgIC8qIDEyLiBMZXQgRU0gPSBtYXNrZWREQiB8fCBIIHx8IDB4YmMuXG4gICAgICogMTMuIE91dHB1dCBFTS4gKi9cbiAgICByZXR1cm4gbWFza2VkREIgKyBoICsgU3RyaW5nLmZyb21DaGFyQ29kZSgweGJjKTtcbiAgfTtcblxuICAvKipcbiAgICogVmVyaWZpZXMgYSBQU1Mgc2lnbmF0dXJlLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGltcGxlbWVudHMgRU1TQS1QU1MtVkVSSUZZIGFzIHBlciBSRkMgMzQ0Nywgc2VjdGlvbiA5LjEuMi5cbiAgICpcbiAgICogQHBhcmFtIG1IYXNoIHRoZSBtZXNzYWdlIGRpZ2VzdCBoYXNoLCBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZywgdG9cbiAgICogICAgICAgICBjb21wYXJlIGFnYWluc3QgdGhlIHNpZ25hdHVyZS5cbiAgICogQHBhcmFtIGVtIHRoZSBlbmNvZGVkIG1lc3NhZ2UsIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nXG4gICAqICAgICAgICAgIChSU0EgZGVjcnlwdGlvbiByZXN1bHQpLlxuICAgKiBAcGFyYW0gbW9kc0JpdHMgdGhlIGxlbmd0aCBvZiB0aGUgUlNBIG1vZHVsdXMgaW4gYml0cy5cbiAgICpcbiAgICogQHJldHVybiB0cnVlIGlmIHRoZSBzaWduYXR1cmUgd2FzIHZlcmlmaWVkLCBmYWxzZSBpZiBub3QuXG4gICAqL1xuICBwc3NvYmoudmVyaWZ5ID0gZnVuY3Rpb24obUhhc2gsIGVtLCBtb2RCaXRzKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGVtQml0cyA9IG1vZEJpdHMgLSAxO1xuICAgIHZhciBlbUxlbiA9IE1hdGguY2VpbChlbUJpdHMgLyA4KTtcblxuICAgIC8qIGMuIENvbnZlcnQgdGhlIG1lc3NhZ2UgcmVwcmVzZW50YXRpdmUgbSB0byBhbiBlbmNvZGVkIG1lc3NhZ2UgRU1cbiAgICAgKiAgICBvZiBsZW5ndGggZW1MZW4gPSBjZWlsKChtb2RCaXRzIC0gMSkgLyA4KSBvY3RldHMsIHdoZXJlIG1vZEJpdHNcbiAgICAgKiAgICBpcyB0aGUgbGVuZ3RoIGluIGJpdHMgb2YgdGhlIFJTQSBtb2R1bHVzIG4gKi9cbiAgICBlbSA9IGVtLnN1YnN0cigtZW1MZW4pO1xuXG4gICAgLyogMy4gSWYgZW1MZW4gPCBoTGVuICsgc0xlbiArIDIsIG91dHB1dCBcImluY29uc2lzdGVudFwiIGFuZCBzdG9wLiAqL1xuICAgIGlmKGVtTGVuIDwgaExlbiArIHNMZW4gKyAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29uc2lzdGVudCBwYXJhbWV0ZXJzIHRvIFBTUyBzaWduYXR1cmUgdmVyaWZpY2F0aW9uLicpO1xuICAgIH1cblxuICAgIC8qIDQuIElmIHRoZSByaWdodG1vc3Qgb2N0ZXQgb2YgRU0gZG9lcyBub3QgaGF2ZSBoZXhhZGVjaW1hbCB2YWx1ZVxuICAgICAqICAgIDB4YmMsIG91dHB1dCBcImluY29uc2lzdGVudFwiIGFuZCBzdG9wLiAqL1xuICAgIGlmKGVtLmNoYXJDb2RlQXQoZW1MZW4gLSAxKSAhPT0gMHhiYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNvZGVkIG1lc3NhZ2UgZG9lcyBub3QgZW5kIGluIDB4QkMuJyk7XG4gICAgfVxuXG4gICAgLyogNS4gTGV0IG1hc2tlZERCIGJlIHRoZSBsZWZ0bW9zdCBlbUxlbiAtIGhMZW4gLSAxIG9jdGV0cyBvZiBFTSwgYW5kXG4gICAgICogICAgbGV0IEggYmUgdGhlIG5leHQgaExlbiBvY3RldHMuICovXG4gICAgdmFyIG1hc2tMZW4gPSBlbUxlbiAtIGhMZW4gLSAxO1xuICAgIHZhciBtYXNrZWREQiA9IGVtLnN1YnN0cigwLCBtYXNrTGVuKTtcbiAgICB2YXIgaCA9IGVtLnN1YnN0cihtYXNrTGVuLCBoTGVuKTtcblxuICAgIC8qIDYuIElmIHRoZSBsZWZ0bW9zdCA4ZW1MZW4gLSBlbUJpdHMgYml0cyBvZiB0aGUgbGVmdG1vc3Qgb2N0ZXQgaW5cbiAgICAgKiAgICBtYXNrZWREQiBhcmUgbm90IGFsbCBlcXVhbCB0byB6ZXJvLCBvdXRwdXQgXCJpbmNvbnNpc3RlbnRcIiBhbmQgc3RvcC4gKi9cbiAgICB2YXIgbWFzayA9ICgweEZGMDAgPj4gKDggKiBlbUxlbiAtIGVtQml0cykpICYgMHhGRjtcbiAgICBpZigobWFza2VkREIuY2hhckNvZGVBdCgwKSAmIG1hc2spICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpdHMgYmV5b25kIGtleXNpemUgbm90IHplcm8gYXMgZXhwZWN0ZWQuJyk7XG4gICAgfVxuXG4gICAgLyogNy4gTGV0IGRiTWFzayA9IE1HRihILCBlbUxlbiAtIGhMZW4gLSAxKS4gKi9cbiAgICB2YXIgZGJNYXNrID0gbWdmLmdlbmVyYXRlKGgsIG1hc2tMZW4pO1xuXG4gICAgLyogOC4gTGV0IERCID0gbWFza2VkREIgXFx4b3IgZGJNYXNrLiAqL1xuICAgIHZhciBkYiA9ICcnO1xuICAgIGZvcihpID0gMDsgaSA8IG1hc2tMZW47IGkrKykge1xuICAgICAgZGIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXNrZWREQi5jaGFyQ29kZUF0KGkpIF4gZGJNYXNrLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cblxuICAgIC8qIDkuIFNldCB0aGUgbGVmdG1vc3QgOGVtTGVuIC0gZW1CaXRzIGJpdHMgb2YgdGhlIGxlZnRtb3N0IG9jdGV0XG4gICAgICogaW4gREIgdG8gemVyby4gKi9cbiAgICBkYiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGIuY2hhckNvZGVBdCgwKSAmIH5tYXNrKSArIGRiLnN1YnN0cigxKTtcblxuICAgIC8qIDEwLiBJZiB0aGUgZW1MZW4gLSBoTGVuIC0gc0xlbiAtIDIgbGVmdG1vc3Qgb2N0ZXRzIG9mIERCIGFyZSBub3QgemVyb1xuICAgICAqIG9yIGlmIHRoZSBvY3RldCBhdCBwb3NpdGlvbiBlbUxlbiAtIGhMZW4gLSBzTGVuIC0gMSAodGhlIGxlZnRtb3N0XG4gICAgICogcG9zaXRpb24gaXMgXCJwb3NpdGlvbiAxXCIpIGRvZXMgbm90IGhhdmUgaGV4YWRlY2ltYWwgdmFsdWUgMHgwMSxcbiAgICAgKiBvdXRwdXQgXCJpbmNvbnNpc3RlbnRcIiBhbmQgc3RvcC4gKi9cbiAgICB2YXIgY2hlY2tMZW4gPSBlbUxlbiAtIGhMZW4gLSBzTGVuIC0gMjtcbiAgICBmb3IoaSA9IDA7IGkgPCBjaGVja0xlbjsgaSsrKSB7XG4gICAgICBpZihkYi5jaGFyQ29kZUF0KGkpICE9PSAweDAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTGVmdG1vc3Qgb2N0ZXRzIG5vdCB6ZXJvIGFzIGV4cGVjdGVkJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoZGIuY2hhckNvZGVBdChjaGVja0xlbikgIT09IDB4MDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb25zaXN0ZW50IFBTUyBzaWduYXR1cmUsIDB4MDEgbWFya2VyIG5vdCBmb3VuZCcpO1xuICAgIH1cblxuICAgIC8qIDExLiBMZXQgc2FsdCBiZSB0aGUgbGFzdCBzTGVuIG9jdGV0cyBvZiBEQi4gKi9cbiAgICB2YXIgc2FsdCA9IGRiLnN1YnN0cigtc0xlbik7XG5cbiAgICAvKiAxMi4gIExldCBNJyA9ICgweCkwMCAwMCAwMCAwMCAwMCAwMCAwMCAwMCB8fCBtSGFzaCB8fCBzYWx0ICovXG4gICAgdmFyIG1fID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICAgIG1fLmZpbGxXaXRoQnl0ZSgwLCA4KTtcbiAgICBtXy5wdXRCeXRlcyhtSGFzaCk7XG4gICAgbV8ucHV0Qnl0ZXMoc2FsdCk7XG5cbiAgICAvKiAxMy4gTGV0IEgnID0gSGFzaChNJyksIGFuIG9jdGV0IHN0cmluZyBvZiBsZW5ndGggaExlbi4gKi9cbiAgICBoYXNoLnN0YXJ0KCk7XG4gICAgaGFzaC51cGRhdGUobV8uZ2V0Qnl0ZXMoKSk7XG4gICAgdmFyIGhfID0gaGFzaC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gICAgLyogMTQuIElmIEggPSBIJywgb3V0cHV0IFwiY29uc2lzdGVudC5cIiBPdGhlcndpc2UsIG91dHB1dCBcImluY29uc2lzdGVudC5cIiAqL1xuICAgIHJldHVybiBoID09PSBoXztcbiAgfTtcblxuICByZXR1cm4gcHNzb2JqO1xufTtcbiIsIi8qKlxuICogTm9kZS5qcyBtb2R1bGUgZm9yIEZvcmdlIG1hc2sgZ2VuZXJhdGlvbiBmdW5jdGlvbnMuXG4gKlxuICogQGF1dGhvciBTdGVmYW4gU2llZ2xcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMiBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL21nZjEnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5tZ2YgPSBmb3JnZS5tZ2YgfHwge307XG5mb3JnZS5tZ2YubWdmMSA9IGZvcmdlLm1nZjE7XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy50b0NhbGxiYWNrID0gKGRvV29yaykgPT4ge1xuICByZXR1cm4gZnVuY3Rpb24gKGlucHV0LCBjYWxsYmFjaykge1xuICAgIGxldCByZXNcbiAgICB0cnkge1xuICAgICAgcmVzID0gZG9Xb3JrKGlucHV0KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaywgZXJyKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaywgbnVsbCwgcmVzKVxuICB9XG59XG5cbmV4cG9ydHMudG9CdWYgPSAoZG9Xb3JrLCBvdGhlcikgPT4gKGlucHV0KSA9PiB7XG4gIGxldCByZXN1bHQgPSBkb1dvcmsoaW5wdXQsIG90aGVyKVxuICByZXR1cm4gQnVmZmVyLmZyb20ocmVzdWx0LCAnaGV4Jylcbn1cblxuZXhwb3J0cy5mcm9tU3RyaW5nID0gKGRvV29yaywgb3RoZXIpID0+IChfaW5wdXQpID0+IHtcbiAgY29uc3QgaW5wdXQgPSBCdWZmZXIuaXNCdWZmZXIoX2lucHV0KSA/IF9pbnB1dC50b1N0cmluZygpIDogX2lucHV0XG4gIHJldHVybiBkb1dvcmsoaW5wdXQsIG90aGVyKVxufVxuXG5leHBvcnRzLmZyb21OdW1iZXJUbzMyQml0QnVmID0gKGRvV29yaywgb3RoZXIpID0+IChpbnB1dCkgPT4ge1xuICBsZXQgbnVtYmVyID0gZG9Xb3JrKGlucHV0LCBvdGhlcilcbiAgY29uc3QgYnl0ZXMgPSBuZXcgQXJyYXkoNClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIGJ5dGVzW2ldID0gbnVtYmVyICYgMHhmZlxuICAgIG51bWJlciA9IG51bWJlciA+PiA4XG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZXMpXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgYmxha2UgPSByZXF1aXJlKCdibGFrZWpzJylcblxuY29uc3QgdG9DYWxsYmFjayA9IHJlcXVpcmUoJy4vdXRpbHMnKS50b0NhbGxiYWNrXG5cbmNvbnN0IG1pbkIgPSAweGIyMDFcbmNvbnN0IG1pblMgPSAweGIyNDFcblxuY29uc3QgYmxha2UyYiA9IHtcbiAgaW5pdDogYmxha2UuYmxha2UyYkluaXQsXG4gIHVwZGF0ZTogYmxha2UuYmxha2UyYlVwZGF0ZSxcbiAgZGlnZXN0OiBibGFrZS5ibGFrZTJiRmluYWxcbn1cblxuY29uc3QgYmxha2UycyA9IHtcbiAgaW5pdDogYmxha2UuYmxha2Uyc0luaXQsXG4gIHVwZGF0ZTogYmxha2UuYmxha2Uyc1VwZGF0ZSxcbiAgZGlnZXN0OiBibGFrZS5ibGFrZTJzRmluYWxcbn1cblxuY29uc3QgbWFrZUIySGFzaCA9IChzaXplLCBoZikgPT4gdG9DYWxsYmFjaygoYnVmKSA9PiB7XG4gIGNvbnN0IGN0eCA9IGhmLmluaXQoc2l6ZSwgbnVsbClcbiAgaGYudXBkYXRlKGN0eCwgYnVmKVxuICByZXR1cm4gQnVmZmVyLmZyb20oaGYuZGlnZXN0KGN0eCkpXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9ICh0YWJsZSkgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICB0YWJsZVttaW5CICsgaV0gPSBtYWtlQjJIYXNoKGkgKyAxLCBibGFrZTJiKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIHRhYmxlW21pblMgKyBpXSA9IG1ha2VCMkhhc2goaSArIDEsIGJsYWtlMnMpXG4gIH1cbn1cbiIsIi8qIGdsb2JhbCBzZWxmICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBub2RlaWZ5ID0gcmVxdWlyZSgnbm9kZWlmeScpXG5cbmNvbnN0IHdlYkNyeXB0byA9IGdldFdlYkNyeXB0bygpXG5cbmZ1bmN0aW9uIGdldFdlYkNyeXB0byAoKSB7XG4gIGlmIChzZWxmLmNyeXB0bykge1xuICAgIHJldHVybiBzZWxmLmNyeXB0by5zdWJ0bGUgfHwgc2VsZi5jcnlwdG8ud2Via2l0U3VidGxlXG4gIH1cblxuICBpZiAoc2VsZi5tc0NyeXB0bykge1xuICAgIHJldHVybiBzZWxmLm1zQ3J5cHRvLnN1YnRsZVxuICB9XG59XG5cbmZ1bmN0aW9uIHdlYkNyeXB0b0hhc2ggKHR5cGUpIHtcbiAgaWYgKCF3ZWJDcnlwdG8pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSB1c2UgYSBicm93c2VyIHdpdGggd2ViY3J5cHRvIHN1cHBvcnQgYW5kIGVuc3VyZSB0aGUgY29kZSBoYXMgYmVlbiBkZWxpdmVyZWQgc2VjdXJlbHkgdmlhIEhUVFBTL1RMUyBhbmQgcnVuIHdpdGhpbiBhIFNlY3VyZSBDb250ZXh0JylcbiAgfVxuXG4gIHJldHVybiAoZGF0YSwgY2FsbGJhY2spID0+IHtcbiAgICBjb25zdCByZXMgPSB3ZWJDcnlwdG8uZGlnZXN0KHsgbmFtZTogdHlwZSB9LCBkYXRhKVxuXG4gICAgaWYgKHR5cGVvZiByZXMudGhlbiAhPT0gJ2Z1bmN0aW9uJykgeyAvLyBJRTExXG4gICAgICByZXMub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKGBoYXNoaW5nIGRhdGEgdXNpbmcgJHt0eXBlfWApKVxuICAgICAgfVxuICAgICAgcmVzLm9uY29tcGxldGUgPSAoZSkgPT4ge1xuICAgICAgICBjYWxsYmFjayhudWxsLCBlLnRhcmdldC5yZXN1bHQpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBub2RlaWZ5KFxuICAgICAgcmVzLnRoZW4oKHJhdykgPT4gQnVmZmVyLmZyb20obmV3IFVpbnQ4QXJyYXkocmF3KSkpLFxuICAgICAgY2FsbGJhY2tcbiAgICApXG4gIH1cbn1cblxuZnVuY3Rpb24gc2hhMSAoYnVmLCBjYWxsYmFjaykge1xuICB3ZWJDcnlwdG9IYXNoKCdTSEEtMScpKGJ1ZiwgY2FsbGJhY2spXG59XG5cbmZ1bmN0aW9uIHNoYTIyNTYgKGJ1ZiwgY2FsbGJhY2spIHtcbiAgd2ViQ3J5cHRvSGFzaCgnU0hBLTI1NicpKGJ1ZiwgY2FsbGJhY2spXG59XG5cbmZ1bmN0aW9uIHNoYTI1MTIgKGJ1ZiwgY2FsbGJhY2spIHtcbiAgd2ViQ3J5cHRvSGFzaCgnU0hBLTUxMicpKGJ1ZiwgY2FsbGJhY2spXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzaGExOiBzaGExLFxuICBzaGEyMjU2OiBzaGEyMjU2LFxuICBzaGEyNTEyOiBzaGEyNTEyXG59XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBidWZmZXJzID0gW10sIGxlbmd0aCA9IDBcblxuICAvL2p1c3QgdXNlZCBmb3IgZGVidWdnaW5nLi4uXG4gIGZ1bmN0aW9uIGNhbGNMZW5ndGggKCkge1xuICAgIHJldHVybiBidWZmZXJzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEgKyBiLmxlbmd0aFxuICAgIH0sIDApXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgIGRhdGE6IHRoaXMsXG4gICAgYWRkOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkYXRhIG11c3QgYmUgYSBidWZmZXIsIHdhczogJyArIEpTT04uc3RyaW5naWZ5KGRhdGEpKVxuICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGggPSBsZW5ndGggKyBkYXRhLmxlbmd0aFxuICAgICAgYnVmZmVycy5wdXNoKGRhdGEpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgaGFzOiBmdW5jdGlvbiAobikge1xuICAgICAgaWYobnVsbCA9PSBuKSByZXR1cm4gbGVuZ3RoID4gMFxuICAgICAgcmV0dXJuIGxlbmd0aCA+PSBuXG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIChuKSB7XG4gICAgICB2YXIgX2xlbmd0aFxuICAgICAgaWYobiA9PSBudWxsIHx8IG4gPT09IGxlbmd0aCkge1xuICAgICAgICBsZW5ndGggPSAwXG4gICAgICAgIHZhciBfYnVmZmVycyA9IGJ1ZmZlcnNcbiAgICAgICAgYnVmZmVycyA9IFtdXG4gICAgICAgIGlmKF9idWZmZXJzLmxlbmd0aCA9PSAxKVxuICAgICAgICAgIHJldHVybiBfYnVmZmVyc1swXVxuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoX2J1ZmZlcnMpXG4gICAgICB9IGVsc2UgaWYgKGJ1ZmZlcnMubGVuZ3RoID4gMSAmJiBuIDw9IChfbGVuZ3RoID0gYnVmZmVyc1swXS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBidWYgPSBidWZmZXJzWzBdLnNsaWNlKDAsIG4pXG4gICAgICAgIGlmKG4gPT09IF9sZW5ndGgpIHtcbiAgICAgICAgICBidWZmZXJzLnNoaWZ0KClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBidWZmZXJzWzBdID0gYnVmZmVyc1swXS5zbGljZShuLCBfbGVuZ3RoKVxuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCAtPSBuXG4gICAgICAgIHJldHVybiBidWZcbiAgICAgIH0gIGVsc2UgaWYobiA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgb3V0ID0gW10sIGxlbiA9IDBcblxuICAgICAgICB3aGlsZSgobGVuICsgYnVmZmVyc1swXS5sZW5ndGgpIDwgbikge1xuICAgICAgICAgIHZhciBiID0gYnVmZmVycy5zaGlmdCgpXG4gICAgICAgICAgbGVuICs9IGIubGVuZ3RoXG4gICAgICAgICAgb3V0LnB1c2goYilcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGxlbiA8IG4pIHtcbiAgICAgICAgICBvdXQucHVzaChidWZmZXJzWzBdLnNsaWNlKDAsIG4gLSBsZW4pKVxuICAgICAgICAgIGJ1ZmZlcnNbMF0gPSBidWZmZXJzWzBdLnNsaWNlKG4gLSBsZW4sIGJ1ZmZlcnNbMF0ubGVuZ3RoKVxuICAgICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoID0gbGVuZ3RoIC0gblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KG91dClcbiAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgZ2V0ICcgKyBuICsgJyBieXRlcycpXG4gICAgfVxuICB9XG5cbn1cblxuXG5cblxuXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgbXVsdGloYXNoID0gcmVxdWlyZSgnbXVsdGloYXNoZXMnKVxuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnLi9jcnlwdG8nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IE11bHRpaGFzaGluZ1xuXG4vKipcbiAqIEhhc2ggdGhlIGdpdmVuIGBidWZgIHVzaW5nIHRoZSBhbGdvcml0aG0gc3BlY2lmaWVkXG4gKiBieSBgZnVuY2AuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiAtIFRoZSB2YWx1ZSB0byBoYXNoLlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBmdW5jIC0gVGhlIGFsZ29yaXRobSB0byB1c2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gLSBPcHRpb25hbGx5IHRyaW0gdGhlIHJlc3VsdCB0byB0aGlzIGxlbmd0aC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEJ1ZmZlcil9IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBNdWx0aWhhc2hpbmcgKGJ1ZiwgZnVuYywgbGVuZ3RoLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gbGVuZ3RoXG4gICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gIH1cblxuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGNhbGxiYWNrJylcbiAgfVxuXG4gIE11bHRpaGFzaGluZy5kaWdlc3QoYnVmLCBmdW5jLCBsZW5ndGgsIChlcnIsIGRpZ2VzdCkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgfVxuXG4gICAgY2FsbGJhY2sobnVsbCwgbXVsdGloYXNoLmVuY29kZShkaWdlc3QsIGZ1bmMsIGxlbmd0aCkpXG4gIH0pXG59XG5cbi8qKlxuICogVGhlIGBidWZmZXJgIG1vZHVsZSBmb3IgZWFzeSB1c2UgaW4gdGhlIGJyb3dzZXIuXG4gKlxuICogQHR5cGUge0J1ZmZlcn1cbiAqL1xuTXVsdGloYXNoaW5nLkJ1ZmZlciA9IEJ1ZmZlciAvLyBmb3IgYnJvd3NlciB0aGluZ3NcblxuLyoqXG4gKiBFeHBvc2UgbXVsdGloYXNoIGl0c2VsZiwgdG8gYXZvaWQgc2lsbHkgZG91YmxlIHJlcXVpcmVzLlxuICovXG5NdWx0aWhhc2hpbmcubXVsdGloYXNoID0gbXVsdGloYXNoXG5cbi8qKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiAtIFRoZSB2YWx1ZSB0byBoYXNoLlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBmdW5jIC0gVGhlIGFsZ29yaXRobSB0byB1c2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gLSBPcHRpb25hbGx5IHRyaW0gdGhlIHJlc3VsdCB0byB0aGlzIGxlbmd0aC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEJ1ZmZlcil9IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5NdWx0aWhhc2hpbmcuZGlnZXN0ID0gZnVuY3Rpb24gKGJ1ZiwgZnVuYywgbGVuZ3RoLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gbGVuZ3RoXG4gICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gIH1cblxuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGNhbGxiYWNrJylcbiAgfVxuXG4gIGxldCBjYiA9IGNhbGxiYWNrXG4gIGlmIChsZW5ndGgpIHtcbiAgICBjYiA9IChlcnIsIGRpZ2VzdCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBkaWdlc3Quc2xpY2UoMCwgbGVuZ3RoKSlcbiAgICB9XG4gIH1cblxuICBsZXQgaGFzaFxuICB0cnkge1xuICAgIGhhc2ggPSBNdWx0aWhhc2hpbmcuY3JlYXRlSGFzaChmdW5jKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gY2IoZXJyKVxuICB9XG5cbiAgaGFzaChidWYsIGNiKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gZnVuY1xuICpcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gLSBUaGUgdG8gYGZ1bmNgIGNvcnJlc3BvbmRpbmcgaGFzaCBmdW5jdGlvbi5cbiAqL1xuTXVsdGloYXNoaW5nLmNyZWF0ZUhhc2ggPSBmdW5jdGlvbiAoZnVuYykge1xuICBmdW5jID0gbXVsdGloYXNoLmNvZXJjZUNvZGUoZnVuYylcbiAgaWYgKCFNdWx0aWhhc2hpbmcuZnVuY3Rpb25zW2Z1bmNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aWhhc2ggZnVuY3Rpb24gJyArIGZ1bmMgKyAnIG5vdCB5ZXQgc3VwcG9ydGVkJylcbiAgfVxuXG4gIHJldHVybiBNdWx0aWhhc2hpbmcuZnVuY3Rpb25zW2Z1bmNdXG59XG5cbi8qKlxuICogTWFwcGluZyBvZiBtdWx0aWhhc2ggY29kZXMgdG8gdGhlaXIgaGFzaGluZyBmdW5jdGlvbnMuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5NdWx0aWhhc2hpbmcuZnVuY3Rpb25zID0ge1xuICAvLyBzaGExXG4gIDB4MTE6IGNyeXB0by5zaGExLFxuICAvLyBzaGEyLTI1NlxuICAweDEyOiBjcnlwdG8uc2hhMjI1NixcbiAgLy8gc2hhMi01MTJcbiAgMHgxMzogY3J5cHRvLnNoYTI1MTIsXG4gIC8vIHNoYTMtNTEyXG4gIDB4MTQ6IGNyeXB0by5zaGEzNTEyLFxuICAvLyBzaGEzLTM4NFxuICAweDE1OiBjcnlwdG8uc2hhMzM4NCxcbiAgLy8gc2hhMy0yNTZcbiAgMHgxNjogY3J5cHRvLnNoYTMyNTYsXG4gIC8vIHNoYTMtMjI0XG4gIDB4MTc6IGNyeXB0by5zaGEzMjI0LFxuICAvLyBzaGFrZS0xMjhcbiAgMHgxODogY3J5cHRvLnNoYWtlMTI4LFxuICAvLyBzaGFrZS0yNTZcbiAgMHgxOTogY3J5cHRvLnNoYWtlMjU2LFxuICAvLyBrZWNjYWstMjI0XG4gIDB4MUE6IGNyeXB0by5rZWNjYWsyMjQsXG4gIC8vIGtlY2Nhay0yNTZcbiAgMHgxQjogY3J5cHRvLmtlY2NhazI1NixcbiAgLy8ga2VjY2FrLTM4NFxuICAweDFDOiBjcnlwdG8ua2VjY2FrMzg0LFxuICAvLyBrZWNjYWstNTEyXG4gIDB4MUQ6IGNyeXB0by5rZWNjYWs1MTIsXG4gIC8vIG11cm11cjMtMTI4XG4gIDB4MjI6IGNyeXB0by5tdXJtdXIzMTI4LFxuICAvLyBtdXJtdXIzLTMyXG4gIDB4MjM6IGNyeXB0by5tdXJtdXIzMzIsXG4gIC8vIGRibC1zaGEyLTI1NlxuICAweDU2OiBjcnlwdG8uZGJsU2hhMjI1NlxufVxuXG4vLyBhZGQgYmxha2UgZnVuY3Rpb25zXG5jcnlwdG8uYWRkQmxha2UoTXVsdGloYXNoaW5nLmZ1bmN0aW9ucylcblxuTXVsdGloYXNoaW5nLnZhbGlkYXRlID0gKGRhdGEsIGhhc2gsIGNhbGxiYWNrKSA9PiB7XG4gIGxldCBhbGdvID0gbXVsdGloYXNoLmRlY29kZShoYXNoKS5uYW1lXG4gIE11bHRpaGFzaGluZyhkYXRhLCBhbGdvLCAoZXJyLCBuZXdIYXNoKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICBjYWxsYmFjayhlcnIsIEJ1ZmZlci5jb21wYXJlKGhhc2gsIG5ld0hhc2gpID09PSAwKVxuICB9KVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzb2NrZXQsIGNhbGxiYWNrKSB7XG4gIHZhciByZW1vdmUgPSBzb2NrZXQgJiYgKHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyIHx8IHNvY2tldC5yZW1vdmVMaXN0ZW5lcik7XG5cbiAgZnVuY3Rpb24gY2xlYW51cCAoKSB7XG4gICAgaWYgKHR5cGVvZiByZW1vdmUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVtb3ZlLmNhbGwoc29ja2V0LCAnb3BlbicsIGhhbmRsZU9wZW4pO1xuICAgICAgcmVtb3ZlLmNhbGwoc29ja2V0LCAnZXJyb3InLCBoYW5kbGVFcnIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU9wZW4oZXZ0KSB7XG4gICAgY2xlYW51cCgpOyBjYWxsYmFjaygpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRXJyIChldnQpIHtcbiAgICBjbGVhbnVwKCk7IGNhbGxiYWNrKGV2dCk7XG4gIH1cblxuICAvLyBpZiB0aGUgc29ja2V0IGlzIGNsb3Npbmcgb3IgY2xvc2VkLCByZXR1cm4gZW5kXG4gIGlmIChzb2NrZXQucmVhZHlTdGF0ZSA+PSAyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKHRydWUpO1xuICB9XG5cbiAgLy8gaWYgb3BlbiwgdHJpZ2dlciB0aGUgY2FsbGJhY2tcbiAgaWYgKHNvY2tldC5yZWFkeVN0YXRlID09PSAxKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gIH1cblxuICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIGhhbmRsZU9wZW4pO1xuICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnIpO1xufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLnRvQ2FsbGJhY2sgPSAoZG9Xb3JrKSA9PiB7XG4gIHJldHVybiBmdW5jdGlvbiAoaW5wdXQsIGNhbGxiYWNrKSB7XG4gICAgbGV0IHJlc1xuICAgIHRyeSB7XG4gICAgICByZXMgPSBkb1dvcmsoaW5wdXQpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBlcnIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBudWxsLCByZXMpXG4gIH1cbn1cblxuZXhwb3J0cy50b0J1ZiA9IChkb1dvcmssIG90aGVyKSA9PiAoaW5wdXQpID0+IHtcbiAgbGV0IHJlc3VsdCA9IGRvV29yayhpbnB1dCwgb3RoZXIpXG4gIHJldHVybiBCdWZmZXIuZnJvbShyZXN1bHQsICdoZXgnKVxufVxuXG5leHBvcnRzLmZyb21TdHJpbmcgPSAoZG9Xb3JrLCBvdGhlcikgPT4gKF9pbnB1dCkgPT4ge1xuICBjb25zdCBpbnB1dCA9IEJ1ZmZlci5pc0J1ZmZlcihfaW5wdXQpID8gX2lucHV0LnRvU3RyaW5nKCkgOiBfaW5wdXRcbiAgcmV0dXJuIGRvV29yayhpbnB1dCwgb3RoZXIpXG59XG5cbmV4cG9ydHMuZnJvbU51bWJlclRvMzJCaXRCdWYgPSAoZG9Xb3JrLCBvdGhlcikgPT4gKGlucHV0KSA9PiB7XG4gIGxldCBudW1iZXIgPSBkb1dvcmsoaW5wdXQsIG90aGVyKVxuICBjb25zdCBieXRlcyA9IG5ldyBBcnJheSg0KVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgYnl0ZXNbaV0gPSBudW1iZXIgJiAweGZmXG4gICAgbnVtYmVyID0gbnVtYmVyID4+IDhcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuZnJvbShieXRlcylcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBibGFrZSA9IHJlcXVpcmUoJ2JsYWtlanMnKVxuXG5jb25zdCB0b0NhbGxiYWNrID0gcmVxdWlyZSgnLi91dGlscycpLnRvQ2FsbGJhY2tcblxuY29uc3QgbWluQiA9IDB4YjIwMVxuY29uc3QgbWluUyA9IDB4YjI0MVxuXG5jb25zdCBibGFrZTJiID0ge1xuICBpbml0OiBibGFrZS5ibGFrZTJiSW5pdCxcbiAgdXBkYXRlOiBibGFrZS5ibGFrZTJiVXBkYXRlLFxuICBkaWdlc3Q6IGJsYWtlLmJsYWtlMmJGaW5hbFxufVxuXG5jb25zdCBibGFrZTJzID0ge1xuICBpbml0OiBibGFrZS5ibGFrZTJzSW5pdCxcbiAgdXBkYXRlOiBibGFrZS5ibGFrZTJzVXBkYXRlLFxuICBkaWdlc3Q6IGJsYWtlLmJsYWtlMnNGaW5hbFxufVxuXG5jb25zdCBtYWtlQjJIYXNoID0gKHNpemUsIGhmKSA9PiB0b0NhbGxiYWNrKChidWYpID0+IHtcbiAgY29uc3QgY3R4ID0gaGYuaW5pdChzaXplLCBudWxsKVxuICBoZi51cGRhdGUoY3R4LCBidWYpXG4gIHJldHVybiBCdWZmZXIuZnJvbShoZi5kaWdlc3QoY3R4KSlcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gKHRhYmxlKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgIHRhYmxlW21pbkIgKyBpXSA9IG1ha2VCMkhhc2goaSArIDEsIGJsYWtlMmIpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgdGFibGVbbWluUyArIGldID0gbWFrZUIySGFzaChpICsgMSwgYmxha2UycylcbiAgfVxufVxuIiwiLyogZ2xvYmFsIHNlbGYgKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG5vZGVpZnkgPSByZXF1aXJlKCdub2RlaWZ5JylcblxuY29uc3Qgd2ViQ3J5cHRvID0gZ2V0V2ViQ3J5cHRvKClcblxuZnVuY3Rpb24gZ2V0V2ViQ3J5cHRvICgpIHtcbiAgaWYgKHNlbGYuY3J5cHRvKSB7XG4gICAgcmV0dXJuIHNlbGYuY3J5cHRvLnN1YnRsZSB8fCBzZWxmLmNyeXB0by53ZWJraXRTdWJ0bGVcbiAgfVxuXG4gIGlmIChzZWxmLm1zQ3J5cHRvKSB7XG4gICAgcmV0dXJuIHNlbGYubXNDcnlwdG8uc3VidGxlXG4gIH1cbn1cblxuZnVuY3Rpb24gd2ViQ3J5cHRvSGFzaCAodHlwZSkge1xuICBpZiAoIXdlYkNyeXB0bykge1xuICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHVzZSBhIGJyb3dzZXIgd2l0aCB3ZWJjcnlwdG8gc3VwcG9ydCBhbmQgZW5zdXJlIHRoZSBjb2RlIGhhcyBiZWVuIGRlbGl2ZXJlZCBzZWN1cmVseSB2aWEgSFRUUFMvVExTIGFuZCBydW4gd2l0aGluIGEgU2VjdXJlIENvbnRleHQnKVxuICB9XG5cbiAgcmV0dXJuIChkYXRhLCBjYWxsYmFjaykgPT4ge1xuICAgIGNvbnN0IHJlcyA9IHdlYkNyeXB0by5kaWdlc3QoeyBuYW1lOiB0eXBlIH0sIGRhdGEpXG5cbiAgICBpZiAodHlwZW9mIHJlcy50aGVuICE9PSAnZnVuY3Rpb24nKSB7IC8vIElFMTFcbiAgICAgIHJlcy5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoYGhhc2hpbmcgZGF0YSB1c2luZyAke3R5cGV9YCkpXG4gICAgICB9XG4gICAgICByZXMub25jb21wbGV0ZSA9IChlKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGUudGFyZ2V0LnJlc3VsdClcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIG5vZGVpZnkoXG4gICAgICByZXMudGhlbigocmF3KSA9PiBCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShyYXcpKSksXG4gICAgICBjYWxsYmFja1xuICAgIClcbiAgfVxufVxuXG5mdW5jdGlvbiBzaGExIChidWYsIGNhbGxiYWNrKSB7XG4gIHdlYkNyeXB0b0hhc2goJ1NIQS0xJykoYnVmLCBjYWxsYmFjaylcbn1cblxuZnVuY3Rpb24gc2hhMjI1NiAoYnVmLCBjYWxsYmFjaykge1xuICB3ZWJDcnlwdG9IYXNoKCdTSEEtMjU2JykoYnVmLCBjYWxsYmFjaylcbn1cblxuZnVuY3Rpb24gc2hhMjUxMiAoYnVmLCBjYWxsYmFjaykge1xuICB3ZWJDcnlwdG9IYXNoKCdTSEEtNTEyJykoYnVmLCBjYWxsYmFjaylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNoYTE6IHNoYTEsXG4gIHNoYTIyNTY6IHNoYTIyNTYsXG4gIHNoYTI1MTI6IHNoYTI1MTJcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBIZWFwID0gcmVxdWlyZSgnaGVhcCcpXG5jb25zdCBkaXN0YW5jZSA9IHJlcXVpcmUoJ3hvci1kaXN0YW5jZScpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJylcbmNvbnN0IHByb21pc2lmeSA9IHJlcXVpcmUoJ3Byb21pc2lmeS1lczYnKVxuXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuXG5jb25zdCBsb2cgPSBkZWJ1ZygnbGlicDJwOmRodDpwZWVyLXF1ZXVlJylcblxuLyoqXG4gKiBQZWVyUXVldWUgaXMgYSBoZWFwIHRoYXQgc29ydHMgaXRzIGVudHJpZXMgKFBlZXJJZHMpIGJ5IHRoZWlyXG4gKiB4b3IgZGlzdGFuY2UgdG8gdGhlIGluaXRhbCBwcm92aWRlZCBrZXkuXG4gKi9cbmNsYXNzIFBlZXJRdWV1ZSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgZnJvbSBhIGdpdmVuIHBlZXIgaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UGVlcklkfSBpZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQZWVyUXVldWU+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21QZWVySWQgKGlkKSB7XG4gICAgY29uc3Qga2V5ID0gYXdhaXQgcHJvbWlzaWZ5KGNiID0+IHV0aWxzLmNvbnZlcnRQZWVySWQoaWQsIGNiKSkoKVxuICAgIHJldHVybiBuZXcgUGVlclF1ZXVlKGtleSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgZnJvbSBhIGdpdmVuIGJ1ZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGtleUJ1ZmZlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQZWVyUXVldWU+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21LZXkgKGtleUJ1ZmZlcikge1xuICAgIGNvbnN0IGtleSA9IGF3YWl0IHByb21pc2lmeShjYiA9PiB1dGlscy5jb252ZXJ0QnVmZmVyKGtleUJ1ZmZlciwgY2IpKSgpXG4gICAgcmV0dXJuIG5ldyBQZWVyUXVldWUoa2V5KVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBQZWVyUXVldWUuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBmcm9tIC0gVGhlIHNoYTItMjU2IGVuY29kZWQgcGVlciBpZFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGZyb20pIHtcbiAgICBsb2coJ2NyZWF0ZTogJWInLCBmcm9tKVxuICAgIHRoaXMuZnJvbSA9IGZyb21cbiAgICB0aGlzLmhlYXAgPSBuZXcgSGVhcCh1dGlscy54b3JDb21wYXJlKVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBQZWVySWQgdG8gdGhlIHF1ZXVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1BlZXJJZH0gaWRcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBlbnF1ZXVlIChpZCkge1xuICAgIGxvZygnZW5xdWV1ZSAlcycsIGlkLnRvQjU4U3RyaW5nKCkpXG4gICAgY29uc3Qga2V5ID0gYXdhaXQgcHJvbWlzaWZ5KGNiID0+IHV0aWxzLmNvbnZlcnRQZWVySWQoaWQsIGNiKSkoKVxuXG4gICAgY29uc3QgZWwgPSB7XG4gICAgICBpZDogaWQsXG4gICAgICBkaXN0YW5jZTogZGlzdGFuY2UodGhpcy5mcm9tLCBrZXkpXG4gICAgfVxuXG4gICAgdGhpcy5oZWFwLnB1c2goZWwpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2xvc2VzdCBwZWVyIHRvIHRoZSBgZnJvbWAgcGVlci5cbiAgICpcbiAgICogQHJldHVybnMge1BlZXJJZH1cbiAgICovXG4gIGRlcXVldWUgKCkge1xuICAgIGNvbnN0IGVsID0gdGhpcy5oZWFwLnBvcCgpXG4gICAgbG9nKCdkZXF1ZXVlICVzJywgZWwuaWQudG9CNThTdHJpbmcoKSlcbiAgICByZXR1cm4gZWwuaWRcbiAgfVxuXG4gIGdldCBsZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLmhlYXAuc2l6ZSgpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQZWVyUXVldWVcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJylcblxubW9kdWxlLmV4cG9ydHMgPSAoZGh0KSA9PiB7XG4gIGNvbnN0IGxvZyA9IHV0aWxzLmxvZ2dlcihkaHQucGVlckluZm8uaWQsICdycGM6cGluZycpXG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgYFBpbmdgIERIVCBtZXNzYWdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtQZWVySW5mb30gcGVlclxuICAgKiBAcGFyYW0ge01lc3NhZ2V9IG1zZ1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBNZXNzYWdlKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiBwaW5nIChwZWVyLCBtc2csIGNhbGxiYWNrKSB7XG4gICAgbG9nKCdmcm9tICVzJywgcGVlci5pZC50b0I1OFN0cmluZygpKVxuICAgIGNhbGxiYWNrKG51bGwsIG1zZylcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKVxuY29uc3QgZXJyY29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcblxubW9kdWxlLmV4cG9ydHMgPSAoZGh0KSA9PiB7XG4gIGNvbnN0IGxvZyA9IHV0aWxzLmxvZ2dlcihkaHQucGVlckluZm8uaWQsICdycGM6cHV0LXZhbHVlJylcblxuICAvKipcbiAgICogUHJvY2VzcyBgUHV0VmFsdWVgIERIVCBtZXNzYWdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtQZWVySW5mb30gcGVlclxuICAgKiBAcGFyYW0ge01lc3NhZ2V9IG1zZ1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBNZXNzYWdlKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiBwdXRWYWx1ZSAocGVlciwgbXNnLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGtleSA9IG1zZy5rZXlcbiAgICBsb2coJ2tleTogJWInLCBrZXkpXG5cbiAgICBjb25zdCByZWNvcmQgPSBtc2cucmVjb3JkXG5cbiAgICBpZiAoIXJlY29yZCkge1xuICAgICAgY29uc3QgZXJyTXNnID0gYEVtcHR5IHJlY29yZCBmcm9tOiAke3BlZXIuaWQudG9CNThTdHJpbmcoKX1gXG5cbiAgICAgIGxvZy5lcnJvcihlcnJNc2cpXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9FTVBUWV9SRUNPUkQnKSlcbiAgICB9XG5cbiAgICBkaHQuX3ZlcmlmeVJlY29yZExvY2FsbHkocmVjb3JkLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGxvZy5lcnJvcihlcnIubWVzc2FnZSlcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cblxuICAgICAgcmVjb3JkLnRpbWVSZWNlaXZlZCA9IG5ldyBEYXRlKClcblxuICAgICAgY29uc3Qga2V5ID0gdXRpbHMuYnVmZmVyVG9LZXkocmVjb3JkLmtleSlcblxuICAgICAgZGh0LmRhdGFzdG9yZS5wdXQoa2V5LCByZWNvcmQuc2VyaWFsaXplKCksIChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhudWxsLCBtc2cpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJylcbmNvbnN0IGVycmNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpXG5jb25zdCBwcm9taXNlVG9DYWxsYmFjayA9IHJlcXVpcmUoJ3Byb21pc2UtdG8tY2FsbGJhY2snKVxuXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJylcblxubW9kdWxlLmV4cG9ydHMgPSAoZGh0KSA9PiB7XG4gIGNvbnN0IGxvZyA9IHV0aWxzLmxvZ2dlcihkaHQucGVlckluZm8uaWQsICdycGM6YWRkLXByb3ZpZGVyJylcbiAgLyoqXG4gICAqIFByb2Nlc3MgYEFkZFByb3ZpZGVyYCBESFQgbWVzc2FnZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UGVlckluZm99IHBlZXJcbiAgICogQHBhcmFtIHtNZXNzYWdlfSBtc2dcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gYWRkUHJvdmlkZXIgKHBlZXIsIG1zZywgY2FsbGJhY2spIHtcbiAgICBsb2coJ3N0YXJ0JylcblxuICAgIGlmICghbXNnLmtleSB8fCBtc2cua2V5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycmNvZGUobmV3IEVycm9yKCdNaXNzaW5nIGtleScpLCAnRVJSX01JU1NJTkdfS0VZJykpXG4gICAgfVxuXG4gICAgbGV0IGNpZFxuICAgIHRyeSB7XG4gICAgICBjaWQgPSBuZXcgQ0lEKG1zZy5rZXkpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zdCBlcnJNc2cgPSBgSW52YWxpZCBDSUQ6ICR7ZXJyLm1lc3NhZ2V9YFxuXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyY29kZShuZXcgRXJyb3IoZXJyTXNnKSwgJ0VSUl9JTlZBTElEX0NJRCcpKVxuICAgIH1cblxuICAgIGxldCBmb3VuZFByb3ZpZGVyID0gZmFsc2VcbiAgICBtc2cucHJvdmlkZXJQZWVycy5mb3JFYWNoKChwaSkgPT4ge1xuICAgICAgLy8gSWdub3JlIHByb3ZpZGVycyBub3QgZnJvbSB0aGUgb3JpZ2luYXRvclxuICAgICAgaWYgKCFwaS5pZC5pc0VxdWFsKHBlZXIuaWQpKSB7XG4gICAgICAgIGxvZygnaW52YWxpZCBwcm92aWRlciBwZWVyICVzIGZyb20gJXMnLCBwaS5pZC50b0I1OFN0cmluZygpLCBwZWVyLmlkLnRvQjU4U3RyaW5nKCkpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAocGkubXVsdGlhZGRycy5zaXplIDwgMSkge1xuICAgICAgICBsb2coJ25vIHZhbGlkIGFkZHJlc3NlcyBmb3IgcHJvdmlkZXIgJXMuIElnbm9yZScsIHBlZXIuaWQudG9CNThTdHJpbmcoKSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGxvZygncmVjZWl2ZWQgcHJvdmlkZXIgJXMgZm9yICVzIChhZGRycyAlcyknLCBwZWVyLmlkLnRvQjU4U3RyaW5nKCksIGNpZC50b0Jhc2VFbmNvZGVkU3RyaW5nKCksIHBpLm11bHRpYWRkcnMudG9BcnJheSgpLm1hcCgobSkgPT4gbS50b1N0cmluZygpKSlcblxuICAgICAgaWYgKCFkaHQuX2lzU2VsZihwaS5pZCkpIHtcbiAgICAgICAgZm91bmRQcm92aWRlciA9IHRydWVcbiAgICAgICAgZGh0LnBlZXJCb29rLnB1dChwaSlcbiAgICAgICAgcHJvbWlzZVRvQ2FsbGJhY2soZGh0LnByb3ZpZGVycy5hZGRQcm92aWRlcihjaWQsIHBpLmlkKSkoZXJyID0+IGNhbGxiYWNrKGVycikpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIFByZXZpb3VzIHZlcnNpb25zIG9mIHRoZSBKUyBESFQgc2VudCBlcnJvbmVvdXMgcHJvdmlkZXJzIGluIHRoZVxuICAgIC8vIGBwcm92aWRlclBlZXJzYCBmaWVsZC4gSW4gb3JkZXIgdG8gYWNjb21tb2RhdGUgb2xkZXIgY2xpZW50cyB0aGF0IGhhdmVcbiAgICAvLyB0aGlzIGJ1Zywgd2UgZmFsbCBiYWNrIHRvIGFzc3VtaW5nIHRoZSBvcmlnaW5hdG9yIGlzIHRoZSBwcm92aWRlciBpZlxuICAgIC8vIHdlIGNhbid0IGZpbmQgYW55IHZhbGlkIHByb3ZpZGVycyBpbiB0aGUgcGF5bG9hZC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbGlicDJwL2pzLWxpYnAycC1rYWQtZGh0L3B1bGwvMTI3XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2xpYnAycC9qcy1saWJwMnAta2FkLWRodC9pc3N1ZXMvMTI4XG4gICAgaWYgKCFmb3VuZFByb3ZpZGVyKSB7XG4gICAgICBwcm9taXNlVG9DYWxsYmFjayhkaHQucHJvdmlkZXJzLmFkZFByb3ZpZGVyKGNpZCwgcGVlci5pZCkpKGVyciA9PiBjYWxsYmFjayhlcnIpKVxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHdhdGVyZmFsbCA9IHJlcXVpcmUoJ2FzeW5jL3dhdGVyZmFsbCcpXG5cbmNvbnN0IE1lc3NhZ2UgPSByZXF1aXJlKCcuLi8uLi9tZXNzYWdlJylcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChkaHQpID0+IHtcbiAgY29uc3QgbG9nID0gdXRpbHMubG9nZ2VyKGRodC5wZWVySW5mby5pZCwgJ3JwYzpmaW5kLW5vZGUnKVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIGBGaW5kTm9kZWAgREhUIG1lc3NhZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BlZXJJbmZvfSBwZWVyXG4gICAqIEBwYXJhbSB7TWVzc2FnZX0gbXNnXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIE1lc3NhZ2UpfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uIGZpbmROb2RlIChwZWVyLCBtc2csIGNhbGxiYWNrKSB7XG4gICAgbG9nKCdzdGFydCcpXG5cbiAgICB3YXRlcmZhbGwoW1xuICAgICAgKGNiKSA9PiB7XG4gICAgICAgIGlmIChtc2cua2V5LmVxdWFscyhkaHQucGVlckluZm8uaWQuaWQpKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKG51bGwsIFtkaHQucGVlckluZm9dKVxuICAgICAgICB9XG5cbiAgICAgICAgZGh0Ll9iZXR0ZXJQZWVyc1RvUXVlcnkobXNnLCBwZWVyLCBjYilcbiAgICAgIH0sXG4gICAgICAoY2xvc2VyLCBjYikgPT4ge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBNZXNzYWdlKG1zZy50eXBlLCBCdWZmZXIuYWxsb2MoMCksIG1zZy5jbHVzdGVyTGV2ZWwpXG5cbiAgICAgICAgaWYgKGNsb3Nlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmVzcG9uc2UuY2xvc2VyUGVlcnMgPSBjbG9zZXJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2coJ2hhbmRsZSBGaW5kTm9kZSAlczogY291bGQgbm90IGZpbmQgYW55dGhpbmcnLCBwZWVyLmlkLnRvQjU4U3RyaW5nKCkpXG4gICAgICAgIH1cblxuICAgICAgICBjYihudWxsLCByZXNwb25zZSlcbiAgICAgIH1cbiAgICBdLCBjYWxsYmFjaylcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IENJRCA9IHJlcXVpcmUoJ2NpZHMnKVxuY29uc3QgcGFyYWxsZWwgPSByZXF1aXJlKCdhc3luYy9wYXJhbGxlbCcpXG5jb25zdCBQZWVySW5mbyA9IHJlcXVpcmUoJ3BlZXItaW5mbycpXG5jb25zdCBwcm9taXNlVG9DYWxsYmFjayA9IHJlcXVpcmUoJ3Byb21pc2UtdG8tY2FsbGJhY2snKVxuY29uc3QgZXJyY29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcblxuY29uc3QgTWVzc2FnZSA9IHJlcXVpcmUoJy4uLy4uL21lc3NhZ2UnKVxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpXG5cbm1vZHVsZS5leHBvcnRzID0gKGRodCkgPT4ge1xuICBjb25zdCBsb2cgPSB1dGlscy5sb2dnZXIoZGh0LnBlZXJJbmZvLmlkLCAncnBjOmdldC1wcm92aWRlcnMnKVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIGBHZXRQcm92aWRlcnNgIERIVCBtZXNzYWdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtQZWVySW5mb30gcGVlclxuICAgKiBAcGFyYW0ge01lc3NhZ2V9IG1zZ1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBNZXNzYWdlKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiBnZXRQcm92aWRlcnMgKHBlZXIsIG1zZywgY2FsbGJhY2spIHtcbiAgICBsZXQgY2lkXG4gICAgdHJ5IHtcbiAgICAgIGNpZCA9IG5ldyBDSUQobXNnLmtleSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnJjb2RlKG5ldyBFcnJvcihgSW52YWxpZCBDSUQ6ICR7ZXJyLm1lc3NhZ2V9YCksICdFUlJfSU5WQUxJRF9DSUQnKSlcbiAgICB9XG5cbiAgICBsb2coJyVzJywgY2lkLnRvQmFzZUVuY29kZWRTdHJpbmcoKSlcblxuICAgIGNvbnN0IGRzS2V5ID0gdXRpbHMuYnVmZmVyVG9LZXkoY2lkLmJ1ZmZlcilcblxuICAgIHBhcmFsbGVsKFtcbiAgICAgIChjYikgPT4gZGh0LmRhdGFzdG9yZS5oYXMoZHNLZXksIChlcnIsIGV4aXN0cykgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgbG9nLmVycm9yKCdGYWlsZWQgdG8gY2hlY2sgZGF0YXN0b3JlIGV4aXN0ZW5jZScsIGVycilcbiAgICAgICAgICByZXR1cm4gY2IobnVsbCwgZmFsc2UpXG4gICAgICAgIH1cblxuICAgICAgICBjYihudWxsLCBleGlzdHMpXG4gICAgICB9KSxcbiAgICAgIChjYikgPT4gcHJvbWlzZVRvQ2FsbGJhY2soZGh0LnByb3ZpZGVycy5nZXRQcm92aWRlcnMoY2lkKSkoY2IpLFxuICAgICAgKGNiKSA9PiBkaHQuX2JldHRlclBlZXJzVG9RdWVyeShtc2csIHBlZXIsIGNiKVxuICAgIF0sIChlcnIsIHJlcykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuICAgICAgY29uc3QgaGFzID0gcmVzWzBdXG4gICAgICBjb25zdCBjbG9zZXIgPSByZXNbMl1cbiAgICAgIGNvbnN0IHByb3ZpZGVycyA9IHJlc1sxXS5tYXAoKHApID0+IHtcbiAgICAgICAgaWYgKGRodC5wZWVyQm9vay5oYXMocCkpIHtcbiAgICAgICAgICByZXR1cm4gZGh0LnBlZXJCb29rLmdldChwKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRodC5wZWVyQm9vay5wdXQobmV3IFBlZXJJbmZvKHApKVxuICAgICAgfSlcblxuICAgICAgaWYgKGhhcykge1xuICAgICAgICBwcm92aWRlcnMucHVzaChkaHQucGVlckluZm8pXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gbmV3IE1lc3NhZ2UobXNnLnR5cGUsIG1zZy5rZXksIG1zZy5jbHVzdGVyTGV2ZWwpXG5cbiAgICAgIGlmIChwcm92aWRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXNwb25zZS5wcm92aWRlclBlZXJzID0gcHJvdmlkZXJzXG4gICAgICB9XG5cbiAgICAgIGlmIChjbG9zZXIubGVuZ3RoID4gMCkge1xuICAgICAgICByZXNwb25zZS5jbG9zZXJQZWVycyA9IGNsb3NlclxuICAgICAgfVxuXG4gICAgICBsb2coJ2dvdCAlcyBwcm92aWRlcnMgJXMgY2xvc2VyUGVlcnMnLCBwcm92aWRlcnMubGVuZ3RoLCBjbG9zZXIubGVuZ3RoKVxuXG4gICAgICBjYWxsYmFjayhudWxsLCByZXNwb25zZSlcbiAgICB9KVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcGFyYWxsZWwgPSByZXF1aXJlKCdhc3luYy9wYXJhbGxlbCcpXG5jb25zdCBSZWNvcmQgPSByZXF1aXJlKCdsaWJwMnAtcmVjb3JkJykuUmVjb3JkXG5cbmNvbnN0IGVycmNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpXG5cbmNvbnN0IE1lc3NhZ2UgPSByZXF1aXJlKCcuLi8uLi9tZXNzYWdlJylcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChkaHQpID0+IHtcbiAgY29uc3QgbG9nID0gdXRpbHMubG9nZ2VyKGRodC5wZWVySW5mby5pZCwgJ3JwYzpnZXQtdmFsdWUnKVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIGBHZXRWYWx1ZWAgREhUIG1lc3NhZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BlZXJJbmZvfSBwZWVyXG4gICAqIEBwYXJhbSB7TWVzc2FnZX0gbXNnXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIE1lc3NhZ2UpfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFZhbHVlIChwZWVyLCBtc2csIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qga2V5ID0gbXNnLmtleVxuXG4gICAgbG9nKCdrZXk6ICViJywga2V5KVxuXG4gICAgaWYgKCFrZXkgfHwga2V5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycmNvZGUobmV3IEVycm9yKCdJbnZhbGlkIGtleScpLCAnRVJSX0lOVkFMSURfS0VZJykpXG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgTWVzc2FnZShNZXNzYWdlLlRZUEVTLkdFVF9WQUxVRSwga2V5LCBtc2cuY2x1c3RlckxldmVsKVxuXG4gICAgaWYgKHV0aWxzLmlzUHVibGljS2V5S2V5KGtleSkpIHtcbiAgICAgIGxvZygnaXMgcHVibGljIGtleScpXG4gICAgICBjb25zdCBpZCA9IHV0aWxzLmZyb21QdWJsaWNLZXlLZXkoa2V5KVxuICAgICAgbGV0IGluZm9cblxuICAgICAgaWYgKGRodC5faXNTZWxmKGlkKSkge1xuICAgICAgICBpbmZvID0gZGh0LnBlZXJJbmZvXG4gICAgICB9IGVsc2UgaWYgKGRodC5wZWVyQm9vay5oYXMoaWQpKSB7XG4gICAgICAgIGluZm8gPSBkaHQucGVlckJvb2suZ2V0KGlkKVxuICAgICAgfVxuXG4gICAgICBpZiAoaW5mbyAmJiBpbmZvLmlkLnB1YktleSkge1xuICAgICAgICBsb2coJ3JldHVybmluZyBmb3VuZCBwdWJsaWMga2V5JylcbiAgICAgICAgcmVzcG9uc2UucmVjb3JkID0gbmV3IFJlY29yZChrZXksIGluZm8uaWQucHViS2V5LmJ5dGVzKVxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzcG9uc2UpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFyYWxsZWwoW1xuICAgICAgKGNiKSA9PiBkaHQuX2NoZWNrTG9jYWxEYXRhc3RvcmUoa2V5LCBjYiksXG4gICAgICAoY2IpID0+IGRodC5fYmV0dGVyUGVlcnNUb1F1ZXJ5KG1zZywgcGVlciwgY2IpXG4gICAgXSwgKGVyciwgcmVzKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlY29yZCA9IHJlc1swXVxuICAgICAgY29uc3QgY2xvc2VyID0gcmVzWzFdXG5cbiAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgbG9nKCdnb3QgcmVjb3JkJylcbiAgICAgICAgcmVzcG9uc2UucmVjb3JkID0gcmVjb3JkXG4gICAgICB9XG5cbiAgICAgIGlmIChjbG9zZXIubGVuZ3RoID4gMCkge1xuICAgICAgICBsb2coJ2dvdCBjbG9zZXIgJXMnLCBjbG9zZXIubGVuZ3RoKVxuICAgICAgICByZXNwb25zZS5jbG9zZXJQZWVycyA9IGNsb3NlclxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCByZXNwb25zZSlcbiAgICB9KVxuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIlxuXG5jb25zdCBFRSA9IHJlcXVpcmUoXCJldmVudHNcIikuRXZlbnRFbWl0dGVyXG5cbmZ1bmN0aW9uIERhdGFRdWV1ZSgpIHtcbiAgY29uc3QgZWUgPSBuZXcgRUUoKVxuICBsZXQgcSA9IFtdXG4gIGxldCBlZFxuXG4gIGZ1bmN0aW9uIHVubGVhaygpIHtcbiAgICBlZS5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJlcnJcIilcbiAgICBlZS5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJkYXRhXCIpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFwcGVuZDogZGF0YSA9PiB7XG4gICAgICBpZiAoZWQpIHJldHVybiBlZFxuICAgICAgcS5wdXNoKGRhdGEpXG4gICAgICBlZS5lbWl0KFwiZGF0YVwiKVxuICAgIH0sXG4gICAgcHJlcGVuZDogZGF0YSA9PiB7IC8vYmV0dGVyIG9ubHkgY2FsbCB0aGlzIGJlZm9yZSB0aGUgZ2V0IHF1ZXVlIHN0YXJ0c1xuICAgICAgaWYgKGVkKSByZXR1cm4gZWRcbiAgICAgIHEudW5zaGlmdChkYXRhKVxuICAgIH0sXG4gICAgZXJyb3I6IGUgPT4ge1xuICAgICAgZWQgPSBlXG4gICAgICBlZS5lbWl0KFwiZXJyXCIsIGUpXG4gICAgfSxcbiAgICBnZXQ6IGNiID0+IHtcbiAgICAgIHVubGVhaygpXG4gICAgICBpZiAoZWQpIHJldHVybiBjYihlZClcbiAgICAgIGlmIChxLmxlbmd0aCkgcmV0dXJuIGNiKG51bGwsIHEuc2hpZnQoKSlcbiAgICAgIGVlLm9uY2UoXCJlcnJcIiwgZSA9PiB7XG4gICAgICAgIHVubGVhaygpXG4gICAgICAgIGNiKGUpXG4gICAgICB9KVxuICAgICAgZWUub25jZShcImRhdGFcIiwgKCkgPT4ge1xuICAgICAgICB1bmxlYWsoKVxuICAgICAgICByZXR1cm4gY2IobnVsbCwgcS5zaGlmdCgpKVxuICAgICAgfSlcbiAgICB9LFxuICAgIGhlaWdodDogKCkgPT4gcS5sZW5ndGhcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBEYXRhUXVldWVcbiIsInZhciB2MSA9IHJlcXVpcmUoJy4vdjEnKTtcbnZhciB2NCA9IHJlcXVpcmUoJy4vdjQnKTtcblxudmFyIHV1aWQgPSB2NDtcbnV1aWQudjEgPSB2MTtcbnV1aWQudjQgPSB2NDtcblxubW9kdWxlLmV4cG9ydHMgPSB1dWlkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbJyMwMDAwQ0MnLCAnIzAwMDBGRicsICcjMDAzM0NDJywgJyMwMDMzRkYnLCAnIzAwNjZDQycsICcjMDA2NkZGJywgJyMwMDk5Q0MnLCAnIzAwOTlGRicsICcjMDBDQzAwJywgJyMwMENDMzMnLCAnIzAwQ0M2NicsICcjMDBDQzk5JywgJyMwMENDQ0MnLCAnIzAwQ0NGRicsICcjMzMwMENDJywgJyMzMzAwRkYnLCAnIzMzMzNDQycsICcjMzMzM0ZGJywgJyMzMzY2Q0MnLCAnIzMzNjZGRicsICcjMzM5OUNDJywgJyMzMzk5RkYnLCAnIzMzQ0MwMCcsICcjMzNDQzMzJywgJyMzM0NDNjYnLCAnIzMzQ0M5OScsICcjMzNDQ0NDJywgJyMzM0NDRkYnLCAnIzY2MDBDQycsICcjNjYwMEZGJywgJyM2NjMzQ0MnLCAnIzY2MzNGRicsICcjNjZDQzAwJywgJyM2NkNDMzMnLCAnIzk5MDBDQycsICcjOTkwMEZGJywgJyM5OTMzQ0MnLCAnIzk5MzNGRicsICcjOTlDQzAwJywgJyM5OUNDMzMnLCAnI0NDMDAwMCcsICcjQ0MwMDMzJywgJyNDQzAwNjYnLCAnI0NDMDA5OScsICcjQ0MwMENDJywgJyNDQzAwRkYnLCAnI0NDMzMwMCcsICcjQ0MzMzMzJywgJyNDQzMzNjYnLCAnI0NDMzM5OScsICcjQ0MzM0NDJywgJyNDQzMzRkYnLCAnI0NDNjYwMCcsICcjQ0M2NjMzJywgJyNDQzk5MDAnLCAnI0NDOTkzMycsICcjQ0NDQzAwJywgJyNDQ0NDMzMnLCAnI0ZGMDAwMCcsICcjRkYwMDMzJywgJyNGRjAwNjYnLCAnI0ZGMDA5OScsICcjRkYwMENDJywgJyNGRjAwRkYnLCAnI0ZGMzMwMCcsICcjRkYzMzMzJywgJyNGRjMzNjYnLCAnI0ZGMzM5OScsICcjRkYzM0NDJywgJyNGRjMzRkYnLCAnI0ZGNjYwMCcsICcjRkY2NjMzJywgJyNGRjk5MDAnLCAnI0ZGOTkzMycsICcjRkZDQzAwJywgJyNGRkNDMzMnXTtcbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXG5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cblxuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlIHx8IC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgd2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSB8fCAvLyBJcyBmaXJlZm94ID49IHYzMT9cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEgfHwgLy8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKTtcbn1cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgYXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgKyB0aGlzLm5hbWVzcGFjZSArICh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArIGFyZ3NbMF0gKyAodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgKyAnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdGhpcy51c2VDb2xvcnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpOyAvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICBpZiAobWF0Y2ggPT09ICclJScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbmRleCsrO1xuXG4gICAgaWYgKG1hdGNoID09PSAnJWMnKSB7XG4gICAgICAvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBsb2coKSB7XG4gIHZhciBfY29uc29sZTtcblxuICAvLyBUaGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gKHR5cGVvZiBjb25zb2xlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoY29uc29sZSkpID09PSAnb2JqZWN0JyAmJiBjb25zb2xlLmxvZyAmJiAoX2NvbnNvbGUgPSBjb25zb2xlKS5sb2cuYXBwbHkoX2NvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikgey8vIFN3YWxsb3dcbiAgICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgfVxufVxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuXG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuICB9IGNhdGNoIChlcnJvcikge30gLy8gU3dhbGxvd1xuICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXG5cbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcbiAgICAvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuICAgIHJldHVybiBsb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7Ly8gU3dhbGxvd1xuICAgIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcbnZhciBmb3JtYXR0ZXJzID0gbW9kdWxlLmV4cG9ydHMuZm9ybWF0dGVycztcbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuICB9XG59O1xuXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgbXVsdGloYXNoID0gcmVxdWlyZSgnbXVsdGloYXNoZXMnKVxuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnLi9jcnlwdG8nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IE11bHRpaGFzaGluZ1xuXG4vKipcbiAqIEhhc2ggdGhlIGdpdmVuIGBidWZgIHVzaW5nIHRoZSBhbGdvcml0aG0gc3BlY2lmaWVkXG4gKiBieSBgZnVuY2AuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiAtIFRoZSB2YWx1ZSB0byBoYXNoLlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBmdW5jIC0gVGhlIGFsZ29yaXRobSB0byB1c2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gLSBPcHRpb25hbGx5IHRyaW0gdGhlIHJlc3VsdCB0byB0aGlzIGxlbmd0aC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEJ1ZmZlcil9IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBNdWx0aWhhc2hpbmcgKGJ1ZiwgZnVuYywgbGVuZ3RoLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gbGVuZ3RoXG4gICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gIH1cblxuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGNhbGxiYWNrJylcbiAgfVxuXG4gIE11bHRpaGFzaGluZy5kaWdlc3QoYnVmLCBmdW5jLCBsZW5ndGgsIChlcnIsIGRpZ2VzdCkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgfVxuXG4gICAgY2FsbGJhY2sobnVsbCwgbXVsdGloYXNoLmVuY29kZShkaWdlc3QsIGZ1bmMsIGxlbmd0aCkpXG4gIH0pXG59XG5cbi8qKlxuICogVGhlIGBidWZmZXJgIG1vZHVsZSBmb3IgZWFzeSB1c2UgaW4gdGhlIGJyb3dzZXIuXG4gKlxuICogQHR5cGUge0J1ZmZlcn1cbiAqL1xuTXVsdGloYXNoaW5nLkJ1ZmZlciA9IEJ1ZmZlciAvLyBmb3IgYnJvd3NlciB0aGluZ3NcblxuLyoqXG4gKiBFeHBvc2UgbXVsdGloYXNoIGl0c2VsZiwgdG8gYXZvaWQgc2lsbHkgZG91YmxlIHJlcXVpcmVzLlxuICovXG5NdWx0aWhhc2hpbmcubXVsdGloYXNoID0gbXVsdGloYXNoXG5cbi8qKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiAtIFRoZSB2YWx1ZSB0byBoYXNoLlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBmdW5jIC0gVGhlIGFsZ29yaXRobSB0byB1c2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gLSBPcHRpb25hbGx5IHRyaW0gdGhlIHJlc3VsdCB0byB0aGlzIGxlbmd0aC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIEJ1ZmZlcil9IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5NdWx0aWhhc2hpbmcuZGlnZXN0ID0gZnVuY3Rpb24gKGJ1ZiwgZnVuYywgbGVuZ3RoLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gbGVuZ3RoXG4gICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gIH1cblxuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGNhbGxiYWNrJylcbiAgfVxuXG4gIGxldCBjYiA9IGNhbGxiYWNrXG4gIGlmIChsZW5ndGgpIHtcbiAgICBjYiA9IChlcnIsIGRpZ2VzdCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBkaWdlc3Quc2xpY2UoMCwgbGVuZ3RoKSlcbiAgICB9XG4gIH1cblxuICBsZXQgaGFzaFxuICB0cnkge1xuICAgIGhhc2ggPSBNdWx0aWhhc2hpbmcuY3JlYXRlSGFzaChmdW5jKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gY2IoZXJyKVxuICB9XG5cbiAgaGFzaChidWYsIGNiKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gZnVuY1xuICpcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gLSBUaGUgdG8gYGZ1bmNgIGNvcnJlc3BvbmRpbmcgaGFzaCBmdW5jdGlvbi5cbiAqL1xuTXVsdGloYXNoaW5nLmNyZWF0ZUhhc2ggPSBmdW5jdGlvbiAoZnVuYykge1xuICBmdW5jID0gbXVsdGloYXNoLmNvZXJjZUNvZGUoZnVuYylcbiAgaWYgKCFNdWx0aWhhc2hpbmcuZnVuY3Rpb25zW2Z1bmNdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aWhhc2ggZnVuY3Rpb24gJyArIGZ1bmMgKyAnIG5vdCB5ZXQgc3VwcG9ydGVkJylcbiAgfVxuXG4gIHJldHVybiBNdWx0aWhhc2hpbmcuZnVuY3Rpb25zW2Z1bmNdXG59XG5cbi8qKlxuICogTWFwcGluZyBvZiBtdWx0aWhhc2ggY29kZXMgdG8gdGhlaXIgaGFzaGluZyBmdW5jdGlvbnMuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5NdWx0aWhhc2hpbmcuZnVuY3Rpb25zID0ge1xuICAvLyBzaGExXG4gIDB4MTE6IGNyeXB0by5zaGExLFxuICAvLyBzaGEyLTI1NlxuICAweDEyOiBjcnlwdG8uc2hhMjI1NixcbiAgLy8gc2hhMi01MTJcbiAgMHgxMzogY3J5cHRvLnNoYTI1MTIsXG4gIC8vIHNoYTMtNTEyXG4gIDB4MTQ6IGNyeXB0by5zaGEzNTEyLFxuICAvLyBzaGEzLTM4NFxuICAweDE1OiBjcnlwdG8uc2hhMzM4NCxcbiAgLy8gc2hhMy0yNTZcbiAgMHgxNjogY3J5cHRvLnNoYTMyNTYsXG4gIC8vIHNoYTMtMjI0XG4gIDB4MTc6IGNyeXB0by5zaGEzMjI0LFxuICAvLyBzaGFrZS0xMjhcbiAgMHgxODogY3J5cHRvLnNoYWtlMTI4LFxuICAvLyBzaGFrZS0yNTZcbiAgMHgxOTogY3J5cHRvLnNoYWtlMjU2LFxuICAvLyBrZWNjYWstMjI0XG4gIDB4MUE6IGNyeXB0by5rZWNjYWsyMjQsXG4gIC8vIGtlY2Nhay0yNTZcbiAgMHgxQjogY3J5cHRvLmtlY2NhazI1NixcbiAgLy8ga2VjY2FrLTM4NFxuICAweDFDOiBjcnlwdG8ua2VjY2FrMzg0LFxuICAvLyBrZWNjYWstNTEyXG4gIDB4MUQ6IGNyeXB0by5rZWNjYWs1MTIsXG4gIC8vIG11cm11cjMtMTI4XG4gIDB4MjI6IGNyeXB0by5tdXJtdXIzMTI4LFxuICAvLyBtdXJtdXIzLTMyXG4gIDB4MjM6IGNyeXB0by5tdXJtdXIzMzIsXG4gIC8vIGRibC1zaGEyLTI1NlxuICAweDU2OiBjcnlwdG8uZGJsU2hhMjI1NlxufVxuXG4vLyBhZGQgYmxha2UgZnVuY3Rpb25zXG5jcnlwdG8uYWRkQmxha2UoTXVsdGloYXNoaW5nLmZ1bmN0aW9ucylcbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGBtZXNzYWdlIFByb3Bvc2Uge1xuICBvcHRpb25hbCBieXRlcyByYW5kID0gMTtcbiAgb3B0aW9uYWwgYnl0ZXMgcHVia2V5ID0gMjtcbiAgb3B0aW9uYWwgc3RyaW5nIGV4Y2hhbmdlcyA9IDM7XG4gIG9wdGlvbmFsIHN0cmluZyBjaXBoZXJzID0gNDtcbiAgb3B0aW9uYWwgc3RyaW5nIGhhc2hlcyA9IDU7XG59XG5cbm1lc3NhZ2UgRXhjaGFuZ2Uge1xuICBvcHRpb25hbCBieXRlcyBlcHVia2V5ID0gMTtcbiAgb3B0aW9uYWwgYnl0ZXMgc2lnbmF0dXJlID0gMjtcbn1gXG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgY29kZXMgPSB7fTtcblxuZnVuY3Rpb24gY3JlYXRlRXJyb3JUeXBlKGNvZGUsIG1lc3NhZ2UsIEJhc2UpIHtcbiAgaWYgKCFCYXNlKSB7XG4gICAgQmFzZSA9IEVycm9yO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBOb2RlRXJyb3IgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfQmFzZSkge1xuICAgIF9pbmhlcml0c0xvb3NlKE5vZGVFcnJvciwgX0Jhc2UpO1xuXG4gICAgZnVuY3Rpb24gTm9kZUVycm9yKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIHJldHVybiBfQmFzZS5jYWxsKHRoaXMsIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykpIHx8IHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5vZGVFcnJvcjtcbiAgfShCYXNlKTtcblxuICBOb2RlRXJyb3IucHJvdG90eXBlLm5hbWUgPSBCYXNlLm5hbWU7XG4gIE5vZGVFcnJvci5wcm90b3R5cGUuY29kZSA9IGNvZGU7XG4gIGNvZGVzW2NvZGVdID0gTm9kZUVycm9yO1xufSAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92MTAuOC4wL2xpYi9pbnRlcm5hbC9lcnJvcnMuanNcblxuXG5mdW5jdGlvbiBvbmVPZihleHBlY3RlZCwgdGhpbmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0ZWQpKSB7XG4gICAgdmFyIGxlbiA9IGV4cGVjdGVkLmxlbmd0aDtcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpKTtcbiAgICB9KTtcblxuICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICByZXR1cm4gXCJvbmUgb2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyksIFwiLCBvciBcIikgKyBleHBlY3RlZFtsZW4gLSAxXTtcbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSwgXCIgb3IgXCIpLmNvbmNhdChleHBlY3RlZFsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIm9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIm9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChTdHJpbmcoZXhwZWN0ZWQpKTtcbiAgfVxufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3RhcnRzV2l0aFxuXG5cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCBzZWFyY2gsIHBvcykge1xuICByZXR1cm4gc3RyLnN1YnN0cighcG9zIHx8IHBvcyA8IDAgPyAwIDogK3Bvcywgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2VuZHNXaXRoXG5cblxuZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzZWFyY2gsIHRoaXNfbGVuKSB7XG4gIGlmICh0aGlzX2xlbiA9PT0gdW5kZWZpbmVkIHx8IHRoaXNfbGVuID4gc3RyLmxlbmd0aCkge1xuICAgIHRoaXNfbGVuID0gc3RyLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKHRoaXNfbGVuIC0gc2VhcmNoLmxlbmd0aCwgdGhpc19sZW4pID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9pbmNsdWRlc1xuXG5cbmZ1bmN0aW9uIGluY2x1ZGVzKHN0ciwgc2VhcmNoLCBzdGFydCkge1xuICBpZiAodHlwZW9mIHN0YXJ0ICE9PSAnbnVtYmVyJykge1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuXG4gIGlmIChzdGFydCArIHNlYXJjaC5sZW5ndGggPiBzdHIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZihzZWFyY2gsIHN0YXJ0KSAhPT0gLTE7XG4gIH1cbn1cblxuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9PUFRfVkFMVUUnLCBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuICdUaGUgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwiJyArIG5hbWUgKyAnXCInO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLCBmdW5jdGlvbiAobmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCkge1xuICAvLyBkZXRlcm1pbmVyOiAnbXVzdCBiZScgb3IgJ211c3Qgbm90IGJlJ1xuICB2YXIgZGV0ZXJtaW5lcjtcblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJyAmJiBzdGFydHNXaXRoKGV4cGVjdGVkLCAnbm90ICcpKSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IG5vdCBiZSc7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5yZXBsYWNlKC9ebm90IC8sICcnKTtcbiAgfSBlbHNlIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3QgYmUnO1xuICB9XG5cbiAgdmFyIG1zZztcblxuICBpZiAoZW5kc1dpdGgobmFtZSwgJyBhcmd1bWVudCcpKSB7XG4gICAgLy8gRm9yIGNhc2VzIGxpa2UgJ2ZpcnN0IGFyZ3VtZW50J1xuICAgIG1zZyA9IFwiVGhlIFwiLmNvbmNhdChuYW1lLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0eXBlID0gaW5jbHVkZXMobmFtZSwgJy4nKSA/ICdwcm9wZXJ0eScgOiAnYXJndW1lbnQnO1xuICAgIG1zZyA9IFwiVGhlIFxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiIFwiKS5jb25jYXQodHlwZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfVxuXG4gIG1zZyArPSBcIi4gUmVjZWl2ZWQgdHlwZSBcIi5jb25jYXQodHlwZW9mIGFjdHVhbCk7XG4gIHJldHVybiBtc2c7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GJywgJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEJywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuICdUaGUgJyArIG5hbWUgKyAnIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQnO1xufSk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJywgJ1ByZW1hdHVyZSBjbG9zZScpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX0RFU1RST1lFRCcsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiAnQ2Fubm90IGNhbGwgJyArIG5hbWUgKyAnIGFmdGVyIGEgc3RyZWFtIHdhcyBkZXN0cm95ZWQnO1xufSk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9NVUxUSVBMRV9DQUxMQkFDSycsICdDYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9DQU5OT1RfUElQRScsICdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EJywgJ3dyaXRlIGFmdGVyIGVuZCcpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX05VTExfVkFMVUVTJywgJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJywgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1VOS05PV05fRU5DT0RJTkcnLCBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiAnVW5rbm93biBlbmNvZGluZzogJyArIGFyZztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQnLCAnc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbm1vZHVsZS5leHBvcnRzLmNvZGVzID0gY29kZXM7XG4iLCIndXNlIHN0cmljdCc7IC8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcblxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9IC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcblxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBpZiAoIV90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycik7XG4gICAgICB9IGVsc2UgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZU5ULCBfdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yQW5kQ2xvc2VOVChzZWxmLCBlcnIpIHtcbiAgZW1pdEVycm9yTlQoc2VsZiwgZXJyKTtcbiAgZW1pdENsb3NlTlQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIGVtaXRDbG9zZU5UKHNlbGYpIHtcbiAgaWYgKHNlbGYuX3dyaXRhYmxlU3RhdGUgJiYgIXNlbGYuX3dyaXRhYmxlU3RhdGUuZW1pdENsb3NlKSByZXR1cm47XG4gIGlmIChzZWxmLl9yZWFkYWJsZVN0YXRlICYmICFzZWxmLl9yZWFkYWJsZVN0YXRlLmVtaXRDbG9zZSkgcmV0dXJuO1xuICBzZWxmLmVtaXQoJ2Nsb3NlJyk7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxuZnVuY3Rpb24gZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpIHtcbiAgLy8gV2UgaGF2ZSB0ZXN0cyB0aGF0IHJlbHkgb24gZXJyb3JzIGJlaW5nIGVtaXR0ZWRcbiAgLy8gaW4gdGhlIHNhbWUgdGljaywgc28gY2hhbmdpbmcgdGhpcyBpcyBzZW12ZXIgbWFqb3IuXG4gIC8vIEZvciBub3cgd2hlbiB5b3Ugb3B0LWluIHRvIGF1dG9EZXN0cm95IHdlIGFsbG93XG4gIC8vIHRoZSBlcnJvciB0byBiZSBlbWl0dGVkIG5leHRUaWNrLiBJbiBhIGZ1dHVyZVxuICAvLyBzZW12ZXIgbWFqb3IgdXBkYXRlIHdlIHNob3VsZCBjaGFuZ2UgdGhlIGRlZmF1bHQgdG8gdGhpcy5cbiAgdmFyIHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgaWYgKHJTdGF0ZSAmJiByU3RhdGUuYXV0b0Rlc3Ryb3kgfHwgd1N0YXRlICYmIHdTdGF0ZS5hdXRvRGVzdHJveSkgc3RyZWFtLmRlc3Ryb3koZXJyKTtlbHNlIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveSxcbiAgZXJyb3JPckRlc3Ryb3k6IGVycm9yT3JEZXN0cm95XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVJSX0lOVkFMSURfT1BUX1ZBTFVFID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMuRVJSX0lOVkFMSURfT1BUX1ZBTFVFO1xuXG5mdW5jdGlvbiBoaWdoV2F0ZXJNYXJrRnJvbShvcHRpb25zLCBpc0R1cGxleCwgZHVwbGV4S2V5KSB7XG4gIHJldHVybiBvcHRpb25zLmhpZ2hXYXRlck1hcmsgIT0gbnVsbCA/IG9wdGlvbnMuaGlnaFdhdGVyTWFyayA6IGlzRHVwbGV4ID8gb3B0aW9uc1tkdXBsZXhLZXldIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0SGlnaFdhdGVyTWFyayhzdGF0ZSwgb3B0aW9ucywgZHVwbGV4S2V5LCBpc0R1cGxleCkge1xuICB2YXIgaHdtID0gaGlnaFdhdGVyTWFya0Zyb20ob3B0aW9ucywgaXNEdXBsZXgsIGR1cGxleEtleSk7XG5cbiAgaWYgKGh3bSAhPSBudWxsKSB7XG4gICAgaWYgKCEoaXNGaW5pdGUoaHdtKSAmJiBNYXRoLmZsb29yKGh3bSkgPT09IGh3bSkgfHwgaHdtIDwgMCkge1xuICAgICAgdmFyIG5hbWUgPSBpc0R1cGxleCA/IGR1cGxleEtleSA6ICdoaWdoV2F0ZXJNYXJrJztcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9PUFRfVkFMVUUobmFtZSwgaHdtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5mbG9vcihod20pO1xuICB9IC8vIERlZmF1bHQgdmFsdWVcblxuXG4gIHJldHVybiBzdGF0ZS5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRIaWdoV2F0ZXJNYXJrOiBnZXRIaWdoV2F0ZXJNYXJrXG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWRhYmxlLmZyb20gaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgYnJvd3NlcicpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdidWZmZXInKSxcbiAgICBCdWZmZXIgPSBfcmVxdWlyZS5CdWZmZXI7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCd1dGlsJyksXG4gICAgaW5zcGVjdCA9IF9yZXF1aXJlMi5pbnNwZWN0O1xuXG52YXIgY3VzdG9tID0gaW5zcGVjdCAmJiBpbnNwZWN0LmN1c3RvbSB8fCAnaW5zcGVjdCc7XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBCdWZmZXIucHJvdG90eXBlLmNvcHkuY2FsbChzcmMsIHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcblxuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQnVmZmVyTGlzdCwgW3tcbiAgICBrZXk6IFwicHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgZGF0YTogdixcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgKyt0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5zaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgZGF0YTogdixcbiAgICAgICAgbmV4dDogdGhpcy5oZWFkXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICAgKyt0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgICAgLS10aGlzLmxlbmd0aDtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiam9pblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG5cbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb25jYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBvciBjaGFyYWN0ZXJzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG5cbiAgfSwge1xuICAgIGtleTogXCJjb25zdW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnN1bWUobiwgaGFzU3RyaW5ncykge1xuICAgICAgdmFyIHJldDtcblxuICAgICAgaWYgKG4gPCB0aGlzLmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgLy8gYHNsaWNlYCBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5ncy5cbiAgICAgICAgcmV0ID0gdGhpcy5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgICAgIHRoaXMuaGVhZC5kYXRhID0gdGhpcy5oZWFkLmRhdGEuc2xpY2Uobik7XG4gICAgICB9IGVsc2UgaWYgKG4gPT09IHRoaXMuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAvLyBGaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2guXG4gICAgICAgIHJldCA9IHRoaXMuc2hpZnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlci5cbiAgICAgICAgcmV0ID0gaGFzU3RyaW5ncyA/IHRoaXMuX2dldFN0cmluZyhuKSA6IHRoaXMuX2dldEJ1ZmZlcihuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmlyc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlyc3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgfSAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U3RyaW5nKG4pIHtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGMgPSAxO1xuICAgICAgdmFyIHJldCA9IHAuZGF0YTtcbiAgICAgIG4gLT0gcmV0Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICAgICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICAgICAgbiAtPSBuYjtcblxuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgKytjO1xuICAgICAgICAgICAgaWYgKHAubmV4dCkgdGhpcy5oZWFkID0gcC5uZXh0O2Vsc2UgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gcDtcbiAgICAgICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICArK2M7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoIC09IGM7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0QnVmZmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRCdWZmZXIobikge1xuICAgICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGMgPSAxO1xuICAgICAgcC5kYXRhLmNvcHkocmV0KTtcbiAgICAgIG4gLT0gcC5kYXRhLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICAgICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICAgICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgICAgICBuIC09IG5iO1xuXG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICAgICArK2M7XG4gICAgICAgICAgICBpZiAocC5uZXh0KSB0aGlzLmhlYWQgPSBwLm5leHQ7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBwO1xuICAgICAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgICsrYztcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggLT0gYztcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSAvLyBNYWtlIHN1cmUgdGhlIGxpbmtlZCBsaXN0IG9ubHkgc2hvd3MgdGhlIG1pbmltYWwgbmVjZXNzYXJ5IGluZm9ybWF0aW9uLlxuXG4gIH0sIHtcbiAgICBrZXk6IGN1c3RvbSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoXywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGluc3BlY3QodGhpcywgX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucywge1xuICAgICAgICAvLyBPbmx5IGluc3BlY3Qgb25lIGxldmVsLlxuICAgICAgICBkZXB0aDogMCxcbiAgICAgICAgLy8gSXQgc2hvdWxkIG5vdCByZWN1cnNlLlxuICAgICAgICBjdXN0b21JbnNwZWN0OiBmYWxzZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9PYmplY3Qkc2V0UHJvdG90eXBlTztcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIGZpbmlzaGVkID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJyk7XG5cbnZhciBrTGFzdFJlc29sdmUgPSBTeW1ib2woJ2xhc3RSZXNvbHZlJyk7XG52YXIga0xhc3RSZWplY3QgPSBTeW1ib2woJ2xhc3RSZWplY3QnKTtcbnZhciBrRXJyb3IgPSBTeW1ib2woJ2Vycm9yJyk7XG52YXIga0VuZGVkID0gU3ltYm9sKCdlbmRlZCcpO1xudmFyIGtMYXN0UHJvbWlzZSA9IFN5bWJvbCgnbGFzdFByb21pc2UnKTtcbnZhciBrSGFuZGxlUHJvbWlzZSA9IFN5bWJvbCgnaGFuZGxlUHJvbWlzZScpO1xudmFyIGtTdHJlYW0gPSBTeW1ib2woJ3N0cmVhbScpO1xuXG5mdW5jdGlvbiBjcmVhdGVJdGVyUmVzdWx0KHZhbHVlLCBkb25lKSB7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGRvbmU6IGRvbmVcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVhZEFuZFJlc29sdmUoaXRlcikge1xuICB2YXIgcmVzb2x2ZSA9IGl0ZXJba0xhc3RSZXNvbHZlXTtcblxuICBpZiAocmVzb2x2ZSAhPT0gbnVsbCkge1xuICAgIHZhciBkYXRhID0gaXRlcltrU3RyZWFtXS5yZWFkKCk7IC8vIHdlIGRlZmVyIGlmIGRhdGEgaXMgbnVsbFxuICAgIC8vIHdlIGNhbiBiZSBleHBlY3RpbmcgZWl0aGVyICdlbmQnIG9yXG4gICAgLy8gJ2Vycm9yJ1xuXG4gICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgIGl0ZXJba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICBpdGVyW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgaXRlcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uUmVhZGFibGUoaXRlcikge1xuICAvLyB3ZSB3YWl0IGZvciB0aGUgbmV4dCB0aWNrLCBiZWNhdXNlIGl0IG1pZ2h0XG4gIC8vIGVtaXQgYW4gZXJyb3Igd2l0aCBwcm9jZXNzLm5leHRUaWNrXG4gIHByb2Nlc3MubmV4dFRpY2socmVhZEFuZFJlc29sdmUsIGl0ZXIpO1xufVxuXG5mdW5jdGlvbiB3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgaXRlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGxhc3RQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGl0ZXJba0VuZGVkXSkge1xuICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaXRlcltrSGFuZGxlUHJvbWlzZV0ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9LCByZWplY3QpO1xuICB9O1xufVxuXG52YXIgQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihmdW5jdGlvbiAoKSB7fSk7XG52YXIgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LnNldFByb3RvdHlwZU9mKChfT2JqZWN0JHNldFByb3RvdHlwZU8gPSB7XG4gIGdldCBzdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXNba1N0cmVhbV07XG4gIH0sXG5cbiAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gaWYgd2UgaGF2ZSBkZXRlY3RlZCBhbiBlcnJvciBpbiB0aGUgbWVhbndoaWxlXG4gICAgLy8gcmVqZWN0IHN0cmFpZ2h0IGF3YXlcbiAgICB2YXIgZXJyb3IgPSB0aGlzW2tFcnJvcl07XG5cbiAgICBpZiAoZXJyb3IgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXNba0VuZGVkXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzW2tTdHJlYW1dLmRlc3Ryb3llZCkge1xuICAgICAgLy8gV2UgbmVlZCB0byBkZWZlciB2aWEgbmV4dFRpY2sgYmVjYXVzZSBpZiAuZGVzdHJveShlcnIpIGlzXG4gICAgICAvLyBjYWxsZWQsIHRoZSBlcnJvciB3aWxsIGJlIGVtaXR0ZWQgdmlhIG5leHRUaWNrLCBhbmRcbiAgICAgIC8vIHdlIGNhbm5vdCBndWFyYW50ZWUgdGhhdCB0aGVyZSBpcyBubyBlcnJvciBsaW5nZXJpbmcgYXJvdW5kXG4gICAgICAvLyB3YWl0aW5nIHRvIGJlIGVtaXR0ZWQuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXNba0Vycm9yXSkge1xuICAgICAgICAgICAgcmVqZWN0KF90aGlzW2tFcnJvcl0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gLy8gaWYgd2UgaGF2ZSBtdWx0aXBsZSBuZXh0KCkgY2FsbHNcbiAgICAvLyB3ZSB3aWxsIHdhaXQgZm9yIHRoZSBwcmV2aW91cyBQcm9taXNlIHRvIGZpbmlzaFxuICAgIC8vIHRoaXMgbG9naWMgaXMgb3B0aW1pemVkIHRvIHN1cHBvcnQgZm9yIGF3YWl0IGxvb3BzLFxuICAgIC8vIHdoZXJlIG5leHQoKSBpcyBvbmx5IGNhbGxlZCBvbmNlIGF0IGEgdGltZVxuXG5cbiAgICB2YXIgbGFzdFByb21pc2UgPSB0aGlzW2tMYXN0UHJvbWlzZV07XG4gICAgdmFyIHByb21pc2U7XG5cbiAgICBpZiAobGFzdFByb21pc2UpIHtcbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgdGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmYXN0IHBhdGggbmVlZGVkIHRvIHN1cHBvcnQgbXVsdGlwbGUgdGhpcy5wdXNoKClcbiAgICAgIC8vIHdpdGhvdXQgdHJpZ2dlcmluZyB0aGUgbmV4dCgpIHF1ZXVlXG4gICAgICB2YXIgZGF0YSA9IHRoaXNba1N0cmVhbV0ucmVhZCgpO1xuXG4gICAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICAgIH1cblxuICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHRoaXNba0hhbmRsZVByb21pc2VdKTtcbiAgICB9XG5cbiAgICB0aGlzW2tMYXN0UHJvbWlzZV0gPSBwcm9taXNlO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG59LCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRzZXRQcm90b3R5cGVPLCBTeW1ib2wuYXN5bmNJdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRzZXRQcm90b3R5cGVPLCBcInJldHVyblwiLCBmdW5jdGlvbiBfcmV0dXJuKCkge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAvLyBkZXN0cm95KGVyciwgY2IpIGlzIGEgcHJpdmF0ZSBBUElcbiAgLy8gd2UgY2FuIGd1YXJhbnRlZSB3ZSBoYXZlIHRoYXQgaGVyZSwgYmVjYXVzZSB3ZSBjb250cm9sIHRoZVxuICAvLyBSZWFkYWJsZSBjbGFzcyB0aGlzIGlzIGF0dGFjaGVkIHRvXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgX3RoaXMyW2tTdHJlYW1dLmRlc3Ryb3kobnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfSk7XG4gIH0pO1xufSksIF9PYmplY3Qkc2V0UHJvdG90eXBlTyksIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUpO1xuXG52YXIgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID0gZnVuY3Rpb24gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHN0cmVhbSkge1xuICB2YXIgX09iamVjdCRjcmVhdGU7XG5cbiAgdmFyIGl0ZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUsIChfT2JqZWN0JGNyZWF0ZSA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtTdHJlYW0sIHtcbiAgICB2YWx1ZTogc3RyZWFtLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtMYXN0UmVzb2x2ZSwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtMYXN0UmVqZWN0LCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0Vycm9yLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0VuZGVkLCB7XG4gICAgdmFsdWU6IHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtIYW5kbGVQcm9taXNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGRhdGEgPSBpdGVyYXRvcltrU3RyZWFtXS5yZWFkKCk7XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gcmVzb2x2ZTtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gcmVqZWN0O1xuICAgICAgfVxuICAgIH0sXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9PYmplY3QkY3JlYXRlKSk7XG4gIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICBmaW5pc2hlZChzdHJlYW0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyICYmIGVyci5jb2RlICE9PSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnKSB7XG4gICAgICB2YXIgcmVqZWN0ID0gaXRlcmF0b3Jba0xhc3RSZWplY3RdOyAvLyByZWplY3QgaWYgd2UgYXJlIHdhaXRpbmcgZm9yIGRhdGEgaW4gdGhlIFByb21pc2VcbiAgICAgIC8vIHJldHVybmVkIGJ5IG5leHQoKSBhbmQgc3RvcmUgdGhlIGVycm9yXG5cbiAgICAgIGlmIChyZWplY3QgIT09IG51bGwpIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0b3Jba0Vycm9yXSA9IGVycjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVzb2x2ZSA9IGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV07XG5cbiAgICBpZiAocmVzb2x2ZSAhPT0gbnVsbCkge1xuICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgaXRlcmF0b3Jba0VuZGVkXSA9IHRydWU7XG4gIH0pO1xuICBzdHJlYW0ub24oJ3JlYWRhYmxlJywgb25SZWFkYWJsZS5iaW5kKG51bGwsIGl0ZXJhdG9yKSk7XG4gIHJldHVybiBpdGVyYXRvcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yOyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtcyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKSB8fFxuICAgIHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fFxuICAgIHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8XG4gICAgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJykgfHxcbiAgICBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtcyA8IG4gKiAxLjUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgfVxuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICovXG5leHBvcnRzLmluc3RhbmNlcyA9IFtdO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gIHZhciBoYXNoID0gMCwgaTtcblxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICB2YXIgcHJldlRpbWU7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG4gIGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG4gIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XG4gICAgZXhwb3J0cy5pbml0KGRlYnVnKTtcbiAgfVxuXG4gIGV4cG9ydHMuaW5zdGFuY2VzLnB1c2goZGVidWcpO1xuXG4gIHJldHVybiBkZWJ1Zztcbn1cblxuZnVuY3Rpb24gZGVzdHJveSAoKSB7XG4gIHZhciBpbmRleCA9IGV4cG9ydHMuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBleHBvcnRzLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBpO1xuICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwb3J0cy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBleHBvcnRzLmluc3RhbmNlc1tpXTtcbiAgICBpbnN0YW5jZS5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG52YXIgaGFzQmluYXJ5ID0gcmVxdWlyZSgnaGFzLWJpbmFyeTInKTtcbnZhciBzbGljZUJ1ZmZlciA9IHJlcXVpcmUoJ2FycmF5YnVmZmVyLnNsaWNlJyk7XG52YXIgYWZ0ZXIgPSByZXF1aXJlKCdhZnRlcicpO1xudmFyIHV0ZjggPSByZXF1aXJlKCcuL3V0ZjgnKTtcblxudmFyIGJhc2U2NGVuY29kZXI7XG5pZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICBiYXNlNjRlbmNvZGVyID0gcmVxdWlyZSgnYmFzZTY0LWFycmF5YnVmZmVyJyk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UgYXJlIHJ1bm5pbmcgYW4gYW5kcm9pZCBicm93c2VyLiBUaGF0IHJlcXVpcmVzIHVzIHRvIHVzZVxuICogQXJyYXlCdWZmZXIgd2l0aCBwb2xsaW5nIHRyYW5zcG9ydHMuLi5cbiAqXG4gKiBodHRwOi8vZ2hpbmRhLm5ldC9qcGVnLWJsb2ItYWpheC1hbmRyb2lkL1xuICovXG5cbnZhciBpc0FuZHJvaWQgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UgYXJlIHJ1bm5pbmcgaW4gUGhhbnRvbUpTLlxuICogVXBsb2FkaW5nIGEgQmxvYiB3aXRoIFBoYW50b21KUyBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseSwgYXMgcmVwb3J0ZWQgaGVyZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hcml5YS9waGFudG9tanMvaXNzdWVzLzExMzk1XG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbnZhciBpc1BoYW50b21KUyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9QaGFudG9tSlMvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIFdoZW4gdHJ1ZSwgYXZvaWRzIHVzaW5nIEJsb2JzIHRvIGVuY29kZSBwYXlsb2Fkcy5cbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xudmFyIGRvbnRTZW5kQmxvYnMgPSBpc0FuZHJvaWQgfHwgaXNQaGFudG9tSlM7XG5cbi8qKlxuICogQ3VycmVudCBwcm90b2NvbCB2ZXJzaW9uLlxuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSAzO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlcy5cbiAqL1xuXG52YXIgcGFja2V0cyA9IGV4cG9ydHMucGFja2V0cyA9IHtcbiAgICBvcGVuOiAgICAgMCAgICAvLyBub24td3NcbiAgLCBjbG9zZTogICAgMSAgICAvLyBub24td3NcbiAgLCBwaW5nOiAgICAgMlxuICAsIHBvbmc6ICAgICAzXG4gICwgbWVzc2FnZTogIDRcbiAgLCB1cGdyYWRlOiAgNVxuICAsIG5vb3A6ICAgICA2XG59O1xuXG52YXIgcGFja2V0c2xpc3QgPSBrZXlzKHBhY2tldHMpO1xuXG4vKipcbiAqIFByZW1hZGUgZXJyb3IgcGFja2V0LlxuICovXG5cbnZhciBlcnIgPSB7IHR5cGU6ICdlcnJvcicsIGRhdGE6ICdwYXJzZXIgZXJyb3InIH07XG5cbi8qKlxuICogQ3JlYXRlIGEgYmxvYiBhcGkgZXZlbiBmb3IgYmxvYiBidWlsZGVyIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XG4gKi9cblxudmFyIEJsb2IgPSByZXF1aXJlKCdibG9iJyk7XG5cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldC5cbiAqXG4gKiAgICAgPHBhY2tldCB0eXBlIGlkPiBbIDxkYXRhPiBdXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgNWhlbGxvIHdvcmxkXG4gKiAgICAgM1xuICogICAgIDRcbiAqXG4gKiBCaW5hcnkgaXMgZW5jb2RlZCBpbiBhbiBpZGVudGljYWwgcHJpbmNpcGxlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdXRmOGVuY29kZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBzdXBwb3J0c0JpbmFyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gc3VwcG9ydHNCaW5hcnk7XG4gICAgc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdXRmOGVuY29kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gdXRmOGVuY29kZTtcbiAgICB1dGY4ZW5jb2RlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBkYXRhID0gKHBhY2tldC5kYXRhID09PSB1bmRlZmluZWQpXG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHBhY2tldC5kYXRhLmJ1ZmZlciB8fCBwYWNrZXQuZGF0YTtcblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBkYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgIHJldHVybiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIG1pZ2h0IGJlIGFuIG9iamVjdCB3aXRoIHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBkYXRhQXNCYXNlNjRTdHJpbmcgfVxuICBpZiAoZGF0YSAmJiBkYXRhLmJhc2U2NCkge1xuICAgIHJldHVybiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBTZW5kaW5nIGRhdGEgYXMgYSB1dGYtOCBzdHJpbmdcbiAgdmFyIGVuY29kZWQgPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcblxuICAvLyBkYXRhIGZyYWdtZW50IGlzIG9wdGlvbmFsXG4gIGlmICh1bmRlZmluZWQgIT09IHBhY2tldC5kYXRhKSB7XG4gICAgZW5jb2RlZCArPSB1dGY4ZW5jb2RlID8gdXRmOC5lbmNvZGUoU3RyaW5nKHBhY2tldC5kYXRhKSwgeyBzdHJpY3Q6IGZhbHNlIH0pIDogU3RyaW5nKHBhY2tldC5kYXRhKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjaygnJyArIGVuY29kZWQpO1xuXG59O1xuXG5mdW5jdGlvbiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LCBjYWxsYmFjaykge1xuICAvLyBwYWNrZXQgZGF0YSBpcyBhbiBvYmplY3QgeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXSArIHBhY2tldC5kYXRhLmRhdGE7XG4gIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGhlbHBlcnMgZm9yIGJpbmFyeSB0eXBlc1xuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHBhY2tldC5kYXRhO1xuICB2YXIgY29udGVudEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIHZhciByZXN1bHRCdWZmZXIgPSBuZXcgVWludDhBcnJheSgxICsgZGF0YS5ieXRlTGVuZ3RoKTtcblxuICByZXN1bHRCdWZmZXJbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRCdWZmZXJbaSsxXSA9IGNvbnRlbnRBcnJheVtpXTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjayhyZXN1bHRCdWZmZXIuYnVmZmVyKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHsgdHlwZTogcGFja2V0LnR5cGUsIGRhdGE6IGZyLnJlc3VsdCB9LCBzdXBwb3J0c0JpbmFyeSwgdHJ1ZSwgY2FsbGJhY2spO1xuICB9O1xuICByZXR1cm4gZnIucmVhZEFzQXJyYXlCdWZmZXIocGFja2V0LmRhdGEpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAoZG9udFNlbmRCbG9icykge1xuICAgIHJldHVybiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gIGxlbmd0aFswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtsZW5ndGguYnVmZmVyLCBwYWNrZXQuZGF0YV0pO1xuXG4gIHJldHVybiBjYWxsYmFjayhibG9iKTtcbn1cblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0IHdpdGggYmluYXJ5IGRhdGEgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCwgaGFzIGB0eXBlYCBhbmQgYGRhdGFgXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqL1xuXG5leHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgY2FsbGJhY2spIHtcbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBpZiAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIHBhY2tldC5kYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYjY0ID0gZnIucmVzdWx0LnNwbGl0KCcsJylbMV07XG4gICAgICBjYWxsYmFjayhtZXNzYWdlICsgYjY0KTtcbiAgICB9O1xuICAgIHJldHVybiBmci5yZWFkQXNEYXRhVVJMKHBhY2tldC5kYXRhKTtcbiAgfVxuXG4gIHZhciBiNjRkYXRhO1xuICB0cnkge1xuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB3aXRoIHR5cGVkIGFycmF5c1xuICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKTtcbiAgICB2YXIgYmFzaWMgPSBuZXcgQXJyYXkodHlwZWQubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBiYXNpY1tpXSA9IHR5cGVkW2ldO1xuICAgIH1cbiAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBiYXNpYyk7XG4gIH1cbiAgbWVzc2FnZSArPSBidG9hKGI2NGRhdGEpO1xuICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQuIENoYW5nZXMgZm9ybWF0IHRvIEJsb2IgaWYgcmVxdWVzdGVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYWNrZXQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgdXRmOGRlY29kZSkge1xuICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxuICAvLyBTdHJpbmcgZGF0YVxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGRhdGEuY2hhckF0KDApID09PSAnYicpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldChkYXRhLnN1YnN0cigxKSwgYmluYXJ5VHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHV0ZjhkZWNvZGUpIHtcbiAgICAgIGRhdGEgPSB0cnlEZWNvZGUoZGF0YSk7XG4gICAgICBpZiAoZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHR5cGUgPSBkYXRhLmNoYXJBdCgwKTtcblxuICAgIGlmIChOdW1iZXIodHlwZSkgIT0gdHlwZSB8fCAhcGFja2V0c2xpc3RbdHlwZV0pIHtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc3Vic3RyaW5nKDEpIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIGFzQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHR5cGUgPSBhc0FycmF5WzBdO1xuICB2YXIgcmVzdCA9IHNsaWNlQnVmZmVyKGRhdGEsIDEpO1xuICBpZiAoQmxvYiAmJiBiaW5hcnlUeXBlID09PSAnYmxvYicpIHtcbiAgICByZXN0ID0gbmV3IEJsb2IoW3Jlc3RdKTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogcmVzdCB9O1xufTtcblxuZnVuY3Rpb24gdHJ5RGVjb2RlKGRhdGEpIHtcbiAgdHJ5IHtcbiAgICBkYXRhID0gdXRmOC5kZWNvZGUoZGF0YSwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQgZW5jb2RlZCBpbiBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihtc2csIGJpbmFyeVR5cGUpIHtcbiAgdmFyIHR5cGUgPSBwYWNrZXRzbGlzdFttc2cuY2hhckF0KDApXTtcbiAgaWYgKCFiYXNlNjRlbmNvZGVyKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogeyBiYXNlNjQ6IHRydWUsIGRhdGE6IG1zZy5zdWJzdHIoMSkgfSB9O1xuICB9XG5cbiAgdmFyIGRhdGEgPSBiYXNlNjRlbmNvZGVyLmRlY29kZShtc2cuc3Vic3RyKDEpKTtcblxuICBpZiAoYmluYXJ5VHlwZSA9PT0gJ2Jsb2InICYmIEJsb2IpIHtcbiAgICBkYXRhID0gbmV3IEJsb2IoW2RhdGFdKTtcbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkuXG4gKlxuICogICAgIDxsZW5ndGg+OmRhdGFcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAxMTpoZWxsbyB3b3JsZDI6aGlcbiAqXG4gKiBJZiBhbnkgY29udGVudHMgYXJlIGJpbmFyeSwgdGhleSB3aWxsIGJlIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ3MuIEJhc2U2NFxuICogZW5jb2RlZCBzdHJpbmdzIGFyZSBtYXJrZWQgd2l0aCBhIGIgYmVmb3JlIHRoZSBsZW5ndGggc3BlY2lmaWVyXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKHBhY2tldHMsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IG51bGw7XG4gIH1cblxuICB2YXIgaXNCaW5hcnkgPSBoYXNCaW5hcnkocGFja2V0cyk7XG5cbiAgaWYgKHN1cHBvcnRzQmluYXJ5ICYmIGlzQmluYXJ5KSB7XG4gICAgaWYgKEJsb2IgJiYgIWRvbnRTZW5kQmxvYnMpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IocGFja2V0cywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soJzA6Jyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlLmxlbmd0aCArICc6JyArIG1lc3NhZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsICFpc0JpbmFyeSA/IGZhbHNlIDogc3VwcG9ydHNCaW5hcnksIGZhbHNlLCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICBkb25lQ2FsbGJhY2sobnVsbCwgc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRzLmpvaW4oJycpKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFzeW5jIGFycmF5IG1hcCB1c2luZyBhZnRlclxuICovXG5cbmZ1bmN0aW9uIG1hcChhcnksIGVhY2gsIGRvbmUpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShhcnkubGVuZ3RoKTtcbiAgdmFyIG5leHQgPSBhZnRlcihhcnkubGVuZ3RoLCBkb25lKTtcblxuICB2YXIgZWFjaFdpdGhJbmRleCA9IGZ1bmN0aW9uKGksIGVsLCBjYikge1xuICAgIGVhY2goZWwsIGZ1bmN0aW9uKGVycm9yLCBtc2cpIHtcbiAgICAgIHJlc3VsdFtpXSA9IG1zZztcbiAgICAgIGNiKGVycm9yLCByZXN1bHQpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgZWFjaFdpdGhJbmRleChpLCBhcnlbaV0sIG5leHQpO1xuICB9XG59XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFBvc3NpYmxlIGJpbmFyeSBjb250ZW50cyBhcmVcbiAqIGRlY29kZWQgZnJvbSB0aGVpciBiYXNlNjQgcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5KGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBwYWNrZXQ7XG4gIGlmIChkYXRhID09PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSAnJywgbiwgbXNnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hyID0gZGF0YS5jaGFyQXQoaSk7XG5cbiAgICBpZiAoY2hyICE9PSAnOicpIHtcbiAgICAgIGxlbmd0aCArPSBjaHI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoID09PSAnJyB8fCAobGVuZ3RoICE9IChuID0gTnVtYmVyKGxlbmd0aCkpKSkge1xuICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgfVxuXG4gICAgbXNnID0gZGF0YS5zdWJzdHIoaSArIDEsIG4pO1xuXG4gICAgaWYgKGxlbmd0aCAhPSBtc2cubGVuZ3RoKSB7XG4gICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICB9XG5cbiAgICBpZiAobXNnLmxlbmd0aCkge1xuICAgICAgcGFja2V0ID0gZXhwb3J0cy5kZWNvZGVQYWNrZXQobXNnLCBiaW5hcnlUeXBlLCBmYWxzZSk7XG5cbiAgICAgIGlmIChlcnIudHlwZSA9PT0gcGFja2V0LnR5cGUgJiYgZXJyLmRhdGEgPT09IHBhY2tldC5kYXRhKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciBpbiBpbmRpdmlkdWFsIHBhY2tldCAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXQgPSBjYWxsYmFjayhwYWNrZXQsIGkgKyBuLCBsKTtcbiAgICAgIGlmIChmYWxzZSA9PT0gcmV0KSByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYWR2YW5jZSBjdXJzb3JcbiAgICBpICs9IG47XG4gICAgbGVuZ3RoID0gJyc7XG4gIH1cblxuICBpZiAobGVuZ3RoICE9PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpIGFzIGJpbmFyeS5cbiAqXG4gKiA8MSA9IGJpbmFyeSwgMCA9IHN0cmluZz48bnVtYmVyIGZyb20gMC05PjxudW1iZXIgZnJvbSAwLTk+Wy4uLl08bnVtYmVyXG4gKiAyNTU+PGRhdGE+XG4gKlxuICogRXhhbXBsZTpcbiAqIDEgMyAyNTUgMSAyIDMsIGlmIHRoZSBiaW5hcnkgY29udGVudHMgYXJlIGludGVycHJldGVkIGFzIDggYml0IGludGVnZXJzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IGVuY29kZWQgcGF5bG9hZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEFycmF5QnVmZmVyKDApKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGRvbmVDYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgZW5jb2RlZFBhY2tldHMpIHtcbiAgICB2YXIgdG90YWxMZW5ndGggPSBlbmNvZGVkUGFja2V0cy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBwKSB7XG4gICAgICB2YXIgbGVuO1xuICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJyl7XG4gICAgICAgIGxlbiA9IHAubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gcC5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYyArIGxlbi50b1N0cmluZygpLmxlbmd0aCArIGxlbiArIDI7IC8vIHN0cmluZy9iaW5hcnkgaWRlbnRpZmllciArIHNlcGFyYXRvciA9IDJcbiAgICB9LCAwKTtcblxuICAgIHZhciByZXN1bHRBcnJheSA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcblxuICAgIHZhciBidWZmZXJJbmRleCA9IDA7XG4gICAgZW5jb2RlZFBhY2tldHMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgcCA9PT0gJ3N0cmluZyc7XG4gICAgICB2YXIgYWIgPSBwO1xuICAgICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkocC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gcC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGFiID0gdmlldy5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1N0cmluZykgeyAvLyBub3QgdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAwO1xuICAgICAgfSBlbHNlIHsgLy8gdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuU3RyID0gYWIuYnl0ZUxlbmd0aC50b1N0cmluZygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAyNTU7XG5cbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gdmlld1tpXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRBcnJheS5idWZmZXIpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRW5jb2RlIGFzIEJsb2JcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICAgIHZhciBiaW5hcnlJZGVudGlmaWVyID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMTtcbiAgICAgIGlmICh0eXBlb2YgZW5jb2RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShlbmNvZGVkLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBlbmNvZGVkLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RlZCA9IHZpZXcuYnVmZmVyO1xuICAgICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbiA9IChlbmNvZGVkIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICAgID8gZW5jb2RlZC5ieXRlTGVuZ3RoXG4gICAgICAgIDogZW5jb2RlZC5zaXplO1xuXG4gICAgICB2YXIgbGVuU3RyID0gbGVuLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgbGVuZ3RoQXJ5ID0gbmV3IFVpbnQ4QXJyYXkobGVuU3RyLmxlbmd0aCArIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGVuZ3RoQXJ5W2ldID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aEFyeVtsZW5TdHIubGVuZ3RoXSA9IDI1NTtcblxuICAgICAgaWYgKEJsb2IpIHtcbiAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbYmluYXJ5SWRlbnRpZmllci5idWZmZXIsIGxlbmd0aEFyeS5idWZmZXIsIGVuY29kZWRdKTtcbiAgICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIGJsb2IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBCbG9iKHJlc3VsdHMpKTtcbiAgfSk7XG59O1xuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBTdHJpbmdzIGFyZSBkZWNvZGVkIGJ5XG4gKiBpbnRlcnByZXRpbmcgZWFjaCBieXRlIGFzIGEga2V5IGNvZGUgZm9yIGVudHJpZXMgbWFya2VkIHRvIHN0YXJ0IHdpdGggMC4gU2VlXG4gKiBkZXNjcmlwdGlvbiBvZiBlbmNvZGVQYXlsb2FkQXNCaW5hcnlcbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGJ1ZmZlclRhaWwgPSBkYXRhO1xuICB2YXIgYnVmZmVycyA9IFtdO1xuXG4gIHdoaWxlIChidWZmZXJUYWlsLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgdmFyIHRhaWxBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclRhaWwpO1xuICAgIHZhciBpc1N0cmluZyA9IHRhaWxBcnJheVswXSA9PT0gMDtcbiAgICB2YXIgbXNnTGVuZ3RoID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgOyBpKyspIHtcbiAgICAgIGlmICh0YWlsQXJyYXlbaV0gPT09IDI1NSkgYnJlYWs7XG5cbiAgICAgIC8vIDMxMCA9IGNoYXIgbGVuZ3RoIG9mIE51bWJlci5NQVhfVkFMVUVcbiAgICAgIGlmIChtc2dMZW5ndGgubGVuZ3RoID4gMzEwKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBtc2dMZW5ndGggKz0gdGFpbEFycmF5W2ldO1xuICAgIH1cblxuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAyICsgbXNnTGVuZ3RoLmxlbmd0aCk7XG4gICAgbXNnTGVuZ3RoID0gcGFyc2VJbnQobXNnTGVuZ3RoKTtcblxuICAgIHZhciBtc2cgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAwLCBtc2dMZW5ndGgpO1xuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXNnID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShtc2cpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgdG8gdHlwZWQgYXJyYXlzXG4gICAgICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KG1zZyk7XG4gICAgICAgIG1zZyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbXNnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodHlwZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYnVmZmVycy5wdXNoKG1zZyk7XG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIG1zZ0xlbmd0aCk7XG4gIH1cblxuICB2YXIgdG90YWwgPSBidWZmZXJzLmxlbmd0aDtcbiAgYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGJ1ZmZlciwgaSkge1xuICAgIGNhbGxiYWNrKGV4cG9ydHMuZGVjb2RlUGFja2V0KGJ1ZmZlciwgYmluYXJ5VHlwZSwgdHJ1ZSksIGksIHRvdGFsKTtcbiAgfSk7XG59O1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB0cmFuc3BvcnRzID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzL2luZGV4Jyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnNvY2tldCcpO1xudmFyIGluZGV4ID0gcmVxdWlyZSgnaW5kZXhvZicpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXVyaSA9IHJlcXVpcmUoJ3BhcnNldXJpJyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqXG4gKiBTb2NrZXQgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB1cmkgb3Igb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU29ja2V0ICh1cmksIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tldCkpIHJldHVybiBuZXcgU29ja2V0KHVyaSwgb3B0cyk7XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgaWYgKHVyaSAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIHVyaSkge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gbnVsbDtcbiAgfVxuXG4gIGlmICh1cmkpIHtcbiAgICB1cmkgPSBwYXJzZXVyaSh1cmkpO1xuICAgIG9wdHMuaG9zdG5hbWUgPSB1cmkuaG9zdDtcbiAgICBvcHRzLnNlY3VyZSA9IHVyaS5wcm90b2NvbCA9PT0gJ2h0dHBzJyB8fCB1cmkucHJvdG9jb2wgPT09ICd3c3MnO1xuICAgIG9wdHMucG9ydCA9IHVyaS5wb3J0O1xuICAgIGlmICh1cmkucXVlcnkpIG9wdHMucXVlcnkgPSB1cmkucXVlcnk7XG4gIH0gZWxzZSBpZiAob3B0cy5ob3N0KSB7XG4gICAgb3B0cy5ob3N0bmFtZSA9IHBhcnNldXJpKG9wdHMuaG9zdCkuaG9zdDtcbiAgfVxuXG4gIHRoaXMuc2VjdXJlID0gbnVsbCAhPSBvcHRzLnNlY3VyZSA/IG9wdHMuc2VjdXJlXG4gICAgOiAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJiAnaHR0cHM6JyA9PT0gbG9jYXRpb24ucHJvdG9jb2wpO1xuXG4gIGlmIChvcHRzLmhvc3RuYW1lICYmICFvcHRzLnBvcnQpIHtcbiAgICAvLyBpZiBubyBwb3J0IGlzIHNwZWNpZmllZCBtYW51YWxseSwgdXNlIHRoZSBwcm90b2NvbCBkZWZhdWx0XG4gICAgb3B0cy5wb3J0ID0gdGhpcy5zZWN1cmUgPyAnNDQzJyA6ICc4MCc7XG4gIH1cblxuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcbiAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWUgfHxcbiAgICAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyA/IGxvY2F0aW9uLmhvc3RuYW1lIDogJ2xvY2FsaG9zdCcpO1xuICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQgfHwgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgbG9jYXRpb24ucG9ydFxuICAgICAgPyBsb2NhdGlvbi5wb3J0XG4gICAgICA6ICh0aGlzLnNlY3VyZSA/IDQ0MyA6IDgwKSk7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5IHx8IHt9O1xuICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB0aGlzLnF1ZXJ5KSB0aGlzLnF1ZXJ5ID0gcGFyc2Vxcy5kZWNvZGUodGhpcy5xdWVyeSk7XG4gIHRoaXMudXBncmFkZSA9IGZhbHNlICE9PSBvcHRzLnVwZ3JhZGU7XG4gIHRoaXMucGF0aCA9IChvcHRzLnBhdGggfHwgJy9lbmdpbmUuaW8nKS5yZXBsYWNlKC9cXC8kLywgJycpICsgJy8nO1xuICB0aGlzLmZvcmNlSlNPTlAgPSAhIW9wdHMuZm9yY2VKU09OUDtcbiAgdGhpcy5qc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuICB0aGlzLmZvcmNlQmFzZTY0ID0gISFvcHRzLmZvcmNlQmFzZTY0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSAhIW9wdHMuZW5hYmxlc1hEUjtcbiAgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZSAhPT0gb3B0cy53aXRoQ3JlZGVudGlhbHM7XG4gIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtIHx8ICd0JztcbiAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gIHRoaXMudHJhbnNwb3J0cyA9IG9wdHMudHJhbnNwb3J0cyB8fCBbJ3BvbGxpbmcnLCAnd2Vic29ja2V0J107XG4gIHRoaXMudHJhbnNwb3J0T3B0aW9ucyA9IG9wdHMudHJhbnNwb3J0T3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcbiAgdGhpcy5wb2xpY3lQb3J0ID0gb3B0cy5wb2xpY3lQb3J0IHx8IDg0MztcbiAgdGhpcy5yZW1lbWJlclVwZ3JhZGUgPSBvcHRzLnJlbWVtYmVyVXBncmFkZSB8fCBmYWxzZTtcbiAgdGhpcy5iaW5hcnlUeXBlID0gbnVsbDtcbiAgdGhpcy5vbmx5QmluYXJ5VXBncmFkZXMgPSBvcHRzLm9ubHlCaW5hcnlVcGdyYWRlcztcbiAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IGZhbHNlICE9PSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlID8gKG9wdHMucGVyTWVzc2FnZURlZmxhdGUgfHwge30pIDogZmFsc2U7XG5cbiAgaWYgKHRydWUgPT09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUpIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcbiAgaWYgKHRoaXMucGVyTWVzc2FnZURlZmxhdGUgJiYgbnVsbCA9PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuICAgIHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkID0gMTAyNDtcbiAgfVxuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4IHx8IG51bGw7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXkgfHwgbnVsbDtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlIHx8IG51bGw7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydCB8fCBudWxsO1xuICB0aGlzLmNhID0gb3B0cy5jYSB8fCBudWxsO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnMgfHwgbnVsbDtcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuICB0aGlzLmZvcmNlTm9kZSA9ICEhb3B0cy5mb3JjZU5vZGU7XG5cbiAgLy8gZGV0ZWN0IFJlYWN0TmF0aXZlIGVudmlyb25tZW50XG4gIHRoaXMuaXNSZWFjdE5hdGl2ZSA9ICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdzdHJpbmcnICYmIG5hdmlnYXRvci5wcm9kdWN0LnRvTG93ZXJDYXNlKCkgPT09ICdyZWFjdG5hdGl2ZScpO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgb3IgUmVhY3ROYXRpdmUgY2xpZW50XG4gIGlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcy5pc1JlYWN0TmF0aXZlKSB7XG4gICAgaWYgKG9wdHMuZXh0cmFIZWFkZXJzICYmIE9iamVjdC5rZXlzKG9wdHMuZXh0cmFIZWFkZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmxvY2FsQWRkcmVzcykge1xuICAgICAgdGhpcy5sb2NhbEFkZHJlc3MgPSBvcHRzLmxvY2FsQWRkcmVzcztcbiAgICB9XG4gIH1cblxuICAvLyBzZXQgb24gaGFuZHNoYWtlXG4gIHRoaXMuaWQgPSBudWxsO1xuICB0aGlzLnVwZ3JhZGVzID0gbnVsbDtcbiAgdGhpcy5waW5nSW50ZXJ2YWwgPSBudWxsO1xuICB0aGlzLnBpbmdUaW1lb3V0ID0gbnVsbDtcblxuICAvLyBzZXQgb24gaGVhcnRiZWF0XG4gIHRoaXMucGluZ0ludGVydmFsVGltZXIgPSBudWxsO1xuICB0aGlzLnBpbmdUaW1lb3V0VGltZXIgPSBudWxsO1xuXG4gIHRoaXMub3BlbigpO1xufVxuXG5Tb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7IC8vIHRoaXMgaXMgYW4gaW50XG5cbi8qKlxuICogRXhwb3NlIGRlcHMgZm9yIGxlZ2FjeSBjb21wYXRpYmlsaXR5XG4gKiBhbmQgc3RhbmRhbG9uZSBicm93c2VyIGFjY2Vzcy5cbiAqL1xuXG5Tb2NrZXQuU29ja2V0ID0gU29ja2V0O1xuU29ja2V0LlRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0Jyk7XG5Tb2NrZXQudHJhbnNwb3J0cyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cy9pbmRleCcpO1xuU29ja2V0LnBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRyYW5zcG9ydCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY3JlYXRlVHJhbnNwb3J0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVidWcoJ2NyZWF0aW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcbiAgdmFyIHF1ZXJ5ID0gY2xvbmUodGhpcy5xdWVyeSk7XG5cbiAgLy8gYXBwZW5kIGVuZ2luZS5pbyBwcm90b2NvbCBpZGVudGlmaWVyXG4gIHF1ZXJ5LkVJTyA9IHBhcnNlci5wcm90b2NvbDtcblxuICAvLyB0cmFuc3BvcnQgbmFtZVxuICBxdWVyeS50cmFuc3BvcnQgPSBuYW1lO1xuXG4gIC8vIHBlci10cmFuc3BvcnQgb3B0aW9uc1xuICB2YXIgb3B0aW9ucyA9IHRoaXMudHJhbnNwb3J0T3B0aW9uc1tuYW1lXSB8fCB7fTtcblxuICAvLyBzZXNzaW9uIGlkIGlmIHdlIGFscmVhZHkgaGF2ZSBvbmVcbiAgaWYgKHRoaXMuaWQpIHF1ZXJ5LnNpZCA9IHRoaXMuaWQ7XG5cbiAgdmFyIHRyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRzW25hbWVdKHtcbiAgICBxdWVyeTogcXVlcnksXG4gICAgc29ja2V0OiB0aGlzLFxuICAgIGFnZW50OiBvcHRpb25zLmFnZW50IHx8IHRoaXMuYWdlbnQsXG4gICAgaG9zdG5hbWU6IG9wdGlvbnMuaG9zdG5hbWUgfHwgdGhpcy5ob3N0bmFtZSxcbiAgICBwb3J0OiBvcHRpb25zLnBvcnQgfHwgdGhpcy5wb3J0LFxuICAgIHNlY3VyZTogb3B0aW9ucy5zZWN1cmUgfHwgdGhpcy5zZWN1cmUsXG4gICAgcGF0aDogb3B0aW9ucy5wYXRoIHx8IHRoaXMucGF0aCxcbiAgICBmb3JjZUpTT05QOiBvcHRpb25zLmZvcmNlSlNPTlAgfHwgdGhpcy5mb3JjZUpTT05QLFxuICAgIGpzb25wOiBvcHRpb25zLmpzb25wIHx8IHRoaXMuanNvbnAsXG4gICAgZm9yY2VCYXNlNjQ6IG9wdGlvbnMuZm9yY2VCYXNlNjQgfHwgdGhpcy5mb3JjZUJhc2U2NCxcbiAgICBlbmFibGVzWERSOiBvcHRpb25zLmVuYWJsZXNYRFIgfHwgdGhpcy5lbmFibGVzWERSLFxuICAgIHdpdGhDcmVkZW50aWFsczogb3B0aW9ucy53aXRoQ3JlZGVudGlhbHMgfHwgdGhpcy53aXRoQ3JlZGVudGlhbHMsXG4gICAgdGltZXN0YW1wUmVxdWVzdHM6IG9wdGlvbnMudGltZXN0YW1wUmVxdWVzdHMgfHwgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyxcbiAgICB0aW1lc3RhbXBQYXJhbTogb3B0aW9ucy50aW1lc3RhbXBQYXJhbSB8fCB0aGlzLnRpbWVzdGFtcFBhcmFtLFxuICAgIHBvbGljeVBvcnQ6IG9wdGlvbnMucG9saWN5UG9ydCB8fCB0aGlzLnBvbGljeVBvcnQsXG4gICAgcGZ4OiBvcHRpb25zLnBmeCB8fCB0aGlzLnBmeCxcbiAgICBrZXk6IG9wdGlvbnMua2V5IHx8IHRoaXMua2V5LFxuICAgIHBhc3NwaHJhc2U6IG9wdGlvbnMucGFzc3BocmFzZSB8fCB0aGlzLnBhc3NwaHJhc2UsXG4gICAgY2VydDogb3B0aW9ucy5jZXJ0IHx8IHRoaXMuY2VydCxcbiAgICBjYTogb3B0aW9ucy5jYSB8fCB0aGlzLmNhLFxuICAgIGNpcGhlcnM6IG9wdGlvbnMuY2lwaGVycyB8fCB0aGlzLmNpcGhlcnMsXG4gICAgcmVqZWN0VW5hdXRob3JpemVkOiBvcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZCB8fCB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSB8fCB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLFxuICAgIGV4dHJhSGVhZGVyczogb3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgdGhpcy5leHRyYUhlYWRlcnMsXG4gICAgZm9yY2VOb2RlOiBvcHRpb25zLmZvcmNlTm9kZSB8fCB0aGlzLmZvcmNlTm9kZSxcbiAgICBsb2NhbEFkZHJlc3M6IG9wdGlvbnMubG9jYWxBZGRyZXNzIHx8IHRoaXMubG9jYWxBZGRyZXNzLFxuICAgIHJlcXVlc3RUaW1lb3V0OiBvcHRpb25zLnJlcXVlc3RUaW1lb3V0IHx8IHRoaXMucmVxdWVzdFRpbWVvdXQsXG4gICAgcHJvdG9jb2xzOiBvcHRpb25zLnByb3RvY29scyB8fCB2b2lkICgwKSxcbiAgICBpc1JlYWN0TmF0aXZlOiB0aGlzLmlzUmVhY3ROYXRpdmVcbiAgfSk7XG5cbiAgcmV0dXJuIHRyYW5zcG9ydDtcbn07XG5cbmZ1bmN0aW9uIGNsb25lIChvYmopIHtcbiAgdmFyIG8gPSB7fTtcbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBvW2ldID0gb2JqW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbztcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyB0cmFuc3BvcnQgdG8gdXNlIGFuZCBzdGFydHMgcHJvYmUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblNvY2tldC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRyYW5zcG9ydDtcbiAgaWYgKHRoaXMucmVtZW1iZXJVcGdyYWRlICYmIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgJiYgdGhpcy50cmFuc3BvcnRzLmluZGV4T2YoJ3dlYnNvY2tldCcpICE9PSAtMSkge1xuICAgIHRyYW5zcG9ydCA9ICd3ZWJzb2NrZXQnO1xuICB9IGVsc2UgaWYgKDAgPT09IHRoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcbiAgICAvLyBFbWl0IGVycm9yIG9uIG5leHQgdGljayBzbyBpdCBjYW4gYmUgbGlzdGVuZWQgdG9cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgJ05vIHRyYW5zcG9ydHMgYXZhaWxhYmxlJyk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIHRyYW5zcG9ydCA9IHRoaXMudHJhbnNwb3J0c1swXTtcbiAgfVxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG5cbiAgLy8gUmV0cnkgd2l0aCB0aGUgbmV4dCB0cmFuc3BvcnQgaWYgdGhlIHRyYW5zcG9ydCBpcyBkaXNhYmxlZCAoanNvbnA6IGZhbHNlKVxuICB0cnkge1xuICAgIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLnRyYW5zcG9ydHMuc2hpZnQoKTtcbiAgICB0aGlzLm9wZW4oKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0cmFuc3BvcnQub3BlbigpO1xuICB0aGlzLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydC4gRGlzYWJsZXMgdGhlIGV4aXN0aW5nIG9uZSAoaWYgYW55KS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNldFRyYW5zcG9ydCA9IGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcbiAgZGVidWcoJ3NldHRpbmcgdHJhbnNwb3J0ICVzJywgdHJhbnNwb3J0Lm5hbWUpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMudHJhbnNwb3J0KSB7XG4gICAgZGVidWcoJ2NsZWFyaW5nIGV4aXN0aW5nIHRyYW5zcG9ydCAlcycsIHRoaXMudHJhbnNwb3J0Lm5hbWUpO1xuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG5cbiAgLy8gc2V0IHVwIHRyYW5zcG9ydFxuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0IGxpc3RlbmVyc1xuICB0cmFuc3BvcnRcbiAgLm9uKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm9uRHJhaW4oKTtcbiAgfSlcbiAgLm9uKCdwYWNrZXQnLCBmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuICB9KVxuICAub24oJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcbiAgICBzZWxmLm9uRXJyb3IoZSk7XG4gIH0pXG4gIC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbkNsb3NlKCd0cmFuc3BvcnQgY2xvc2UnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFByb2JlcyBhIHRyYW5zcG9ydC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucHJvYmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICBkZWJ1ZygncHJvYmluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydChuYW1lLCB7IHByb2JlOiAxIH0pO1xuICB2YXIgZmFpbGVkID0gZmFsc2U7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gb25UcmFuc3BvcnRPcGVuICgpIHtcbiAgICBpZiAoc2VsZi5vbmx5QmluYXJ5VXBncmFkZXMpIHtcbiAgICAgIHZhciB1cGdyYWRlTG9zZXNCaW5hcnkgPSAhdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiBzZWxmLnRyYW5zcG9ydC5zdXBwb3J0c0JpbmFyeTtcbiAgICAgIGZhaWxlZCA9IGZhaWxlZCB8fCB1cGdyYWRlTG9zZXNCaW5hcnk7XG4gICAgfVxuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIG9wZW5lZCcsIG5hbWUpO1xuICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICdwaW5nJywgZGF0YTogJ3Byb2JlJyB9XSk7XG4gICAgdHJhbnNwb3J0Lm9uY2UoJ3BhY2tldCcsIGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcbiAgICAgIGlmICgncG9uZycgPT09IG1zZy50eXBlICYmICdwcm9iZScgPT09IG1zZy5kYXRhKSB7XG4gICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIHBvbmcnLCBuYW1lKTtcbiAgICAgICAgc2VsZi51cGdyYWRpbmcgPSB0cnVlO1xuICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGluZycsIHRyYW5zcG9ydCk7XG4gICAgICAgIGlmICghdHJhbnNwb3J0KSByZXR1cm47XG4gICAgICAgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PT0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICAgICAgZGVidWcoJ3BhdXNpbmcgY3VycmVudCB0cmFuc3BvcnQgXCIlc1wiJywgc2VsZi50cmFuc3BvcnQubmFtZSk7XG4gICAgICAgIHNlbGYudHJhbnNwb3J0LnBhdXNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG4gICAgICAgICAgaWYgKCdjbG9zZWQnID09PSBzZWxmLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICAgICAgICBkZWJ1ZygnY2hhbmdpbmcgdHJhbnNwb3J0IGFuZCBzZW5kaW5nIHVwZ3JhZGUgcGFja2V0Jyk7XG5cbiAgICAgICAgICBjbGVhbnVwKCk7XG5cbiAgICAgICAgICBzZWxmLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICd1cGdyYWRlJyB9XSk7XG4gICAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlJywgdHJhbnNwb3J0KTtcbiAgICAgICAgICB0cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICAgIHNlbGYudXBncmFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5mbHVzaCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCcsIG5hbWUpO1xuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcicpO1xuICAgICAgICBlcnIudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG4gICAgICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyZWV6ZVRyYW5zcG9ydCAoKSB7XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgLy8gQW55IGNhbGxiYWNrIGNhbGxlZCBieSB0cmFuc3BvcnQgc2hvdWxkIGJlIGlnbm9yZWQgc2luY2Ugbm93XG4gICAgZmFpbGVkID0gdHJ1ZTtcblxuICAgIGNsZWFudXAoKTtcblxuICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICAvLyBIYW5kbGUgYW55IGVycm9yIHRoYXQgaGFwcGVucyB3aGlsZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9uZXJyb3IgKGVycikge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcigncHJvYmUgZXJyb3I6ICcgKyBlcnIpO1xuICAgIGVycm9yLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuXG4gICAgZnJlZXplVHJhbnNwb3J0KCk7XG5cbiAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQgYmVjYXVzZSBvZiBlcnJvcjogJXMnLCBuYW1lLCBlcnIpO1xuXG4gICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnJvcik7XG4gIH1cblxuICBmdW5jdGlvbiBvblRyYW5zcG9ydENsb3NlICgpIHtcbiAgICBvbmVycm9yKCd0cmFuc3BvcnQgY2xvc2VkJyk7XG4gIH1cblxuICAvLyBXaGVuIHRoZSBzb2NrZXQgaXMgY2xvc2VkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25jbG9zZSAoKSB7XG4gICAgb25lcnJvcignc29ja2V0IGNsb3NlZCcpO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgc29ja2V0IGlzIHVwZ3JhZGVkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgZnVuY3Rpb24gb251cGdyYWRlICh0bykge1xuICAgIGlmICh0cmFuc3BvcnQgJiYgdG8ubmFtZSAhPT0gdHJhbnNwb3J0Lm5hbWUpIHtcbiAgICAgIGRlYnVnKCdcIiVzXCIgd29ya3MgLSBhYm9ydGluZyBcIiVzXCInLCB0by5uYW1lLCB0cmFuc3BvcnQubmFtZSk7XG4gICAgICBmcmVlemVUcmFuc3BvcnQoKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBvbiB0aGUgdHJhbnNwb3J0IGFuZCBvbiBzZWxmXG4gIGZ1bmN0aW9uIGNsZWFudXAgKCkge1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG4gIH1cblxuICB0cmFuc3BvcnQub25jZSgnb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gIHRyYW5zcG9ydC5vbmNlKCdlcnJvcicsIG9uZXJyb3IpO1xuICB0cmFuc3BvcnQub25jZSgnY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcblxuICB0aGlzLm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIHRoaXMub25jZSgndXBncmFkaW5nJywgb251cGdyYWRlKTtcblxuICB0cmFuc3BvcnQub3BlbigpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBjb25uZWN0aW9uIGlzIGRlZW1lZCBvcGVuLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdzb2NrZXQgb3BlbicpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PT0gdGhpcy50cmFuc3BvcnQubmFtZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG4gIHRoaXMuZmx1c2goKTtcblxuICAvLyB3ZSBjaGVjayBmb3IgYHJlYWR5U3RhdGVgIGluIGNhc2UgYW4gYG9wZW5gXG4gIC8vIGxpc3RlbmVyIGFscmVhZHkgY2xvc2VkIHRoZSBzb2NrZXRcbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudXBncmFkZSAmJiB0aGlzLnRyYW5zcG9ydC5wYXVzZSkge1xuICAgIGRlYnVnKCdzdGFydGluZyB1cGdyYWRlIHByb2JlcycpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy51cGdyYWRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMucHJvYmUodGhpcy51cGdyYWRlc1tpXSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8XG4gICAgICAnY2xvc2luZycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCdzb2NrZXQgcmVjZWl2ZTogdHlwZSBcIiVzXCIsIGRhdGEgXCIlc1wiJywgcGFja2V0LnR5cGUsIHBhY2tldC5kYXRhKTtcblxuICAgIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcblxuICAgIC8vIFNvY2tldCBpcyBsaXZlIC0gYW55IHBhY2tldCBjb3VudHNcbiAgICB0aGlzLmVtaXQoJ2hlYXJ0YmVhdCcpO1xuXG4gICAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgICAgY2FzZSAnb3Blbic6XG4gICAgICAgIHRoaXMub25IYW5kc2hha2UoSlNPTi5wYXJzZShwYWNrZXQuZGF0YSkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncG9uZyc6XG4gICAgICAgIHRoaXMuc2V0UGluZygpO1xuICAgICAgICB0aGlzLmVtaXQoJ3BvbmcnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignc2VydmVyIGVycm9yJyk7XG4gICAgICAgIGVyci5jb2RlID0gcGFja2V0LmRhdGE7XG4gICAgICAgIHRoaXMub25FcnJvcihlcnIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbWVzc2FnZSc6XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgcGFja2V0LmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ3BhY2tldCByZWNlaXZlZCB3aXRoIHNvY2tldCByZWFkeVN0YXRlIFwiJXNcIicsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gaGFuZHNoYWtlIGNvbXBsZXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhhbmRzaGFrZSBvYmpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25IYW5kc2hha2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmVtaXQoJ2hhbmRzaGFrZScsIGRhdGEpO1xuICB0aGlzLmlkID0gZGF0YS5zaWQ7XG4gIHRoaXMudHJhbnNwb3J0LnF1ZXJ5LnNpZCA9IGRhdGEuc2lkO1xuICB0aGlzLnVwZ3JhZGVzID0gdGhpcy5maWx0ZXJVcGdyYWRlcyhkYXRhLnVwZ3JhZGVzKTtcbiAgdGhpcy5waW5nSW50ZXJ2YWwgPSBkYXRhLnBpbmdJbnRlcnZhbDtcbiAgdGhpcy5waW5nVGltZW91dCA9IGRhdGEucGluZ1RpbWVvdXQ7XG4gIHRoaXMub25PcGVuKCk7XG4gIC8vIEluIGNhc2Ugb3BlbiBoYW5kbGVyIGNsb3NlcyBzb2NrZXRcbiAgaWYgKCdjbG9zZWQnID09PSB0aGlzLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgdGhpcy5zZXRQaW5nKCk7XG5cbiAgLy8gUHJvbG9uZyBsaXZlbmVzcyBvZiBzb2NrZXQgb24gaGVhcnRiZWF0XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xuICB0aGlzLm9uKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcbn07XG5cbi8qKlxuICogUmVzZXRzIHBpbmcgdGltZW91dC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uSGVhcnRiZWF0ID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcbiAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5waW5nVGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCdjbG9zZWQnID09PSBzZWxmLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICBzZWxmLm9uQ2xvc2UoJ3BpbmcgdGltZW91dCcpO1xuICB9LCB0aW1lb3V0IHx8IChzZWxmLnBpbmdJbnRlcnZhbCArIHNlbGYucGluZ1RpbWVvdXQpKTtcbn07XG5cbi8qKlxuICogUGluZ3Mgc2VydmVyIGV2ZXJ5IGB0aGlzLnBpbmdJbnRlcnZhbGAgYW5kIGV4cGVjdHMgcmVzcG9uc2VcbiAqIHdpdGhpbiBgdGhpcy5waW5nVGltZW91dGAgb3IgY2xvc2VzIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZXRQaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNsZWFyVGltZW91dChzZWxmLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgc2VsZi5waW5nSW50ZXJ2YWxUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cml0aW5nIHBpbmcgcGFja2V0IC0gZXhwZWN0aW5nIHBvbmcgd2l0aGluICVzbXMnLCBzZWxmLnBpbmdUaW1lb3V0KTtcbiAgICBzZWxmLnBpbmcoKTtcbiAgICBzZWxmLm9uSGVhcnRiZWF0KHNlbGYucGluZ1RpbWVvdXQpO1xuICB9LCBzZWxmLnBpbmdJbnRlcnZhbCk7XG59O1xuXG4vKipcbiogU2VuZHMgYSBwaW5nIHBhY2tldC5cbipcbiogQGFwaSBwcml2YXRlXG4qL1xuXG5Tb2NrZXQucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5zZW5kUGFja2V0KCdwaW5nJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuZW1pdCgncGluZycpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIG9uIGBkcmFpbmAgZXZlbnRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMud3JpdGVCdWZmZXIuc3BsaWNlKDAsIHRoaXMucHJldkJ1ZmZlckxlbik7XG5cbiAgLy8gc2V0dGluZyBwcmV2QnVmZmVyTGVuID0gMCBpcyB2ZXJ5IGltcG9ydGFudFxuICAvLyBmb3IgZXhhbXBsZSwgd2hlbiB1cGdyYWRpbmcsIHVwZ3JhZGUgcGFja2V0IGlzIHNlbnQgb3ZlcixcbiAgLy8gYW5kIGEgbm9uemVybyBwcmV2QnVmZmVyTGVuIGNvdWxkIGNhdXNlIHByb2JsZW1zIG9uIGBkcmFpbmBcbiAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcblxuICBpZiAoMCA9PT0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5mbHVzaCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEZsdXNoIHdyaXRlIGJ1ZmZlcnMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdjbG9zZWQnICE9PSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy50cmFuc3BvcnQud3JpdGFibGUgJiZcbiAgICAhdGhpcy51cGdyYWRpbmcgJiYgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICBkZWJ1ZygnZmx1c2hpbmcgJWQgcGFja2V0cyBpbiBzb2NrZXQnLCB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCk7XG4gICAgdGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLndyaXRlQnVmZmVyKTtcbiAgICAvLyBrZWVwIHRyYWNrIG9mIGN1cnJlbnQgbGVuZ3RoIG9mIHdyaXRlQnVmZmVyXG4gICAgLy8gc3BsaWNlIHdyaXRlQnVmZmVyIGFuZCBjYWxsYmFja0J1ZmZlciBvbiBgZHJhaW5gXG4gICAgdGhpcy5wcmV2QnVmZmVyTGVuID0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7XG4gICAgdGhpcy5lbWl0KCdmbHVzaCcpO1xuICB9XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtTb2NrZXR9IGZvciBjaGFpbmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS53cml0ZSA9XG5Tb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobXNnLCBvcHRpb25zLCBmbikge1xuICB0aGlzLnNlbmRQYWNrZXQoJ21lc3NhZ2UnLCBtc2csIG9wdGlvbnMsIGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWNrZXQgdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2VuZFBhY2tldCA9IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBvcHRpb25zLCBmbikge1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGRhdGEpIHtcbiAgICBmbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2Ygb3B0aW9ucykge1xuICAgIGZuID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuXG4gIGlmICgnY2xvc2luZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnY2xvc2VkJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuY29tcHJlc3MgPSBmYWxzZSAhPT0gb3B0aW9ucy5jb21wcmVzcztcblxuICB2YXIgcGFja2V0ID0ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgZGF0YTogZGF0YSxcbiAgICBvcHRpb25zOiBvcHRpb25zXG4gIH07XG4gIHRoaXMuZW1pdCgncGFja2V0Q3JlYXRlJywgcGFja2V0KTtcbiAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIGlmIChmbikgdGhpcy5vbmNlKCdmbHVzaCcsIGZuKTtcbiAgdGhpcy5mbHVzaCgpO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NpbmcnO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy51cGdyYWRpbmcpIHtcbiAgICAgICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy51cGdyYWRpbmcpIHtcbiAgICAgIHdhaXRGb3JVcGdyYWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2UgKCkge1xuICAgIHNlbGYub25DbG9zZSgnZm9yY2VkIGNsb3NlJyk7XG4gICAgZGVidWcoJ3NvY2tldCBjbG9zaW5nIC0gdGVsbGluZyB0cmFuc3BvcnQgdG8gY2xvc2UnKTtcbiAgICBzZWxmLnRyYW5zcG9ydC5jbG9zZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW51cEFuZENsb3NlICgpIHtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRlRXJyb3InLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgIGNsb3NlKCk7XG4gIH1cblxuICBmdW5jdGlvbiB3YWl0Rm9yVXBncmFkZSAoKSB7XG4gICAgLy8gd2FpdCBmb3IgdXBncmFkZSB0byBmaW5pc2ggc2luY2Ugd2UgY2FuJ3Qgc2VuZCBwYWNrZXRzIHdoaWxlIHBhdXNpbmcgYSB0cmFuc3BvcnRcbiAgICBzZWxmLm9uY2UoJ3VwZ3JhZGUnLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgIHNlbGYub25jZSgndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgZXJyb3JcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGRlYnVnKCdzb2NrZXQgZXJyb3IgJWonLCBlcnIpO1xuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB0aGlzLm9uQ2xvc2UoJ3RyYW5zcG9ydCBlcnJvcicsIGVycik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAocmVhc29uLCBkZXNjKSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnY2xvc2luZycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCdzb2NrZXQgY2xvc2Ugd2l0aCByZWFzb246IFwiJXNcIicsIHJlYXNvbik7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gY2xlYXIgdGltZXJzXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ0ludGVydmFsVGltZXIpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuXG4gICAgLy8gc3RvcCBldmVudCBmcm9tIGZpcmluZyBhZ2FpbiBmb3IgdHJhbnNwb3J0XG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCdjbG9zZScpO1xuXG4gICAgLy8gZW5zdXJlIHRyYW5zcG9ydCB3b24ndCBzdGF5IG9wZW5cbiAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuXG4gICAgLy8gaWdub3JlIGZ1cnRoZXIgdHJhbnNwb3J0IGNvbW11bmljYXRpb25cbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblxuICAgIC8vIHNldCByZWFkeSBzdGF0ZVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXG4gICAgLy8gY2xlYXIgc2Vzc2lvbiBpZFxuICAgIHRoaXMuaWQgPSBudWxsO1xuXG4gICAgLy8gZW1pdCBjbG9zZSBldmVudFxuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24sIGRlc2MpO1xuXG4gICAgLy8gY2xlYW4gYnVmZmVycyBhZnRlciwgc28gdXNlcnMgY2FuIHN0aWxsXG4gICAgLy8gZ3JhYiB0aGUgYnVmZmVycyBvbiBgY2xvc2VgIGV2ZW50XG4gICAgc2VsZi53cml0ZUJ1ZmZlciA9IFtdO1xuICAgIHNlbGYucHJldkJ1ZmZlckxlbiA9IDA7XG4gIH1cbn07XG5cbi8qKlxuICogRmlsdGVycyB1cGdyYWRlcywgcmV0dXJuaW5nIG9ubHkgdGhvc2UgbWF0Y2hpbmcgY2xpZW50IHRyYW5zcG9ydHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2VydmVyIHVwZ3JhZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5maWx0ZXJVcGdyYWRlcyA9IGZ1bmN0aW9uICh1cGdyYWRlcykge1xuICB2YXIgZmlsdGVyZWRVcGdyYWRlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IHVwZ3JhZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgIGlmICh+aW5kZXgodGhpcy50cmFuc3BvcnRzLCB1cGdyYWRlc1tpXSkpIGZpbHRlcmVkVXBncmFkZXMucHVzaCh1cGdyYWRlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGZpbHRlcmVkVXBncmFkZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgTWVzc2FnZSB9ID0gcmVxdWlyZSgnLi9pbmRleCcpXG5jb25zdCBTaWduUHJlZml4ID0gQnVmZmVyLmZyb20oJ2xpYnAycC1wdWJzdWI6JylcblxubW9kdWxlLmV4cG9ydHMuU2lnblByZWZpeCA9IFNpZ25QcmVmaXhcblxuLyoqXG4gKiBTaWducyB0aGUgcHJvdmlkZWQgbWVzc2FnZSB3aXRoIHRoZSBnaXZlbiBgcGVlcklkYFxuICpcbiAqIEBwYXJhbSB7UGVlcklkfSBwZWVySWRcbiAqIEBwYXJhbSB7TWVzc2FnZX0gbWVzc2FnZVxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgTWVzc2FnZSl9IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xubW9kdWxlLmV4cG9ydHMuc2lnbk1lc3NhZ2UgPSBmdW5jdGlvbiAocGVlcklkLCBtZXNzYWdlLCBjYWxsYmFjaykge1xuICAvLyBHZXQgdGhlIG1lc3NhZ2UgaW4gYnl0ZXMsIGFuZCBwcmVwZW5kIHdpdGggdGhlIHB1YnN1YiBwcmVmaXhcbiAgY29uc3QgYnl0ZXMgPSBCdWZmZXIuY29uY2F0KFtcbiAgICBTaWduUHJlZml4LFxuICAgIE1lc3NhZ2UuZW5jb2RlKG1lc3NhZ2UpXG4gIF0pXG5cbiAgLy8gU2lnbiB0aGUgYnl0ZXMgd2l0aCB0aGUgcHJpdmF0ZSBrZXlcbiAgcGVlcklkLnByaXZLZXkuc2lnbihieXRlcywgKGVyciwgc2lnbmF0dXJlKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcblxuICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgIC4uLm1lc3NhZ2UsXG4gICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgICAgIGtleTogcGVlcklkLnB1YktleS5ieXRlc1xuICAgIH0pXG4gIH0pXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnbGlicDJwLWNyeXB0bycpXG5jb25zdCBiczU4ID0gcmVxdWlyZSgnYnM1OCcpXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0c1xuXG4vKipcbiAqIEdlbmVyYXRlYSByYW5kb20gc2VxdWVuY2UgbnVtYmVyLlxuICpcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLnJhbmRvbVNlcW5vID0gKCkgPT4ge1xuICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKDIwKVxufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgbWVzc2FnZSBpZCwgYmFzZWQgb24gdGhlIGBmcm9tYCBhbmQgYHNlcW5vYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZnJvbVxuICogQHBhcmFtIHtCdWZmZXJ9IHNlcW5vXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5tc2dJZCA9IChmcm9tLCBzZXFubykgPT4ge1xuICByZXR1cm4gZnJvbSArIHNlcW5vLnRvU3RyaW5nKCdoZXgnKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGFueSBtZW1iZXIgb2YgdGhlIGZpcnN0IHNldCBpcyBhbHNvIGEgbWVtYmVyXG4gKiBvZiB0aGUgc2Vjb25kIHNldC5cbiAqXG4gKiBAcGFyYW0ge1NldHxBcnJheX0gYVxuICogQHBhcmFtIHtTZXR8QXJyYXl9IGJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5hbnlNYXRjaCA9IChhLCBiKSA9PiB7XG4gIGxldCBiSGFzXG4gIGlmIChBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgYkhhcyA9ICh2YWwpID0+IGIuaW5kZXhPZih2YWwpID4gLTFcbiAgfSBlbHNlIHtcbiAgICBiSGFzID0gKHZhbCkgPT4gYi5oYXModmFsKVxuICB9XG5cbiAgZm9yIChsZXQgdmFsIG9mIGEpIHtcbiAgICBpZiAoYkhhcyh2YWwpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIE1ha2UgZXZlcnl0aGluZyBhbiBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge2FueX0gbWF5YmVBcnJheVxuICogQHJldHVybnMge0FycmF5fVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5lbnN1cmVBcnJheSA9IChtYXliZUFycmF5KSA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheShtYXliZUFycmF5KSkge1xuICAgIHJldHVybiBbbWF5YmVBcnJheV1cbiAgfVxuXG4gIHJldHVybiBtYXliZUFycmF5XG59XG5cbmV4cG9ydHMubm9ybWFsaXplSW5ScGNNZXNzYWdlcyA9IChtZXNzYWdlcykgPT4ge1xuICBpZiAoIW1lc3NhZ2VzKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2VzXG4gIH1cbiAgcmV0dXJuIG1lc3NhZ2VzLm1hcCgobXNnKSA9PiB7XG4gICAgY29uc3QgbSA9IE9iamVjdC5hc3NpZ24oe30sIG1zZylcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKG1zZy5mcm9tKSkge1xuICAgICAgbS5mcm9tID0gYnM1OC5lbmNvZGUobXNnLmZyb20pXG4gICAgfVxuICAgIHJldHVybiBtXG4gIH0pXG59XG5cbmV4cG9ydHMubm9ybWFsaXplT3V0UnBjTWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gIGNvbnN0IG0gPSBPYmplY3QuYXNzaWduKHt9LCBtZXNzYWdlKVxuICBpZiAodHlwZW9mIG1lc3NhZ2UuZnJvbSA9PT0gJ3N0cmluZycgfHwgbWVzc2FnZS5mcm9tIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgbS5mcm9tID0gYnM1OC5kZWNvZGUobWVzc2FnZS5mcm9tKVxuICB9XG4gIHJldHVybiBtXG59XG5cbmV4cG9ydHMubm9ybWFsaXplT3V0UnBjTWVzc2FnZXMgPSAobWVzc2FnZXMpID0+IHtcbiAgaWYgKCFtZXNzYWdlcykge1xuICAgIHJldHVybiBtZXNzYWdlc1xuICB9XG4gIHJldHVybiBtZXNzYWdlcy5tYXAoZXhwb3J0cy5ub3JtYWxpemVPdXRScGNNZXNzYWdlKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGxwID0gcmVxdWlyZSgncHVsbC1sZW5ndGgtcHJlZml4ZWQnKVxuY29uc3QgUHVzaGFibGUgPSByZXF1aXJlKCdwdWxsLXB1c2hhYmxlJylcbmNvbnN0IHB1bGwgPSByZXF1aXJlKCdwdWxsLXN0cmVhbScpXG5jb25zdCBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdhc3luYy9zZXRJbW1lZGlhdGUnKVxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJylcblxuY29uc3QgeyBSUEMgfSA9IHJlcXVpcmUoJy4vbWVzc2FnZScpXG5cbi8qKlxuICogVGhlIGtub3duIHN0YXRlIG9mIGEgY29ubmVjdGVkIHBlZXIuXG4gKi9cbmNsYXNzIFBlZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtQZWVySW5mb30gaW5mb1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGluZm8pIHtcbiAgICBzdXBlcigpXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UGVlckluZm99XG4gICAgICovXG4gICAgdGhpcy5pbmZvID0gaW5mb1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtDb25uZWN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuY29ubiA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7U2V0fVxuICAgICAqL1xuICAgIHRoaXMudG9waWNzID0gbmV3IFNldCgpXG4gICAgLyoqXG4gICAgICogQHR5cGUge1B1c2hhYmxlfVxuICAgICAqL1xuICAgIHRoaXMuc3RyZWFtID0gbnVsbFxuXG4gICAgdGhpcy5fcmVmZXJlbmNlcyA9IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBJcyB0aGUgcGVlciBjb25uZWN0ZWQgY3VycmVudGx5P1xuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc0Nvbm5lY3RlZCAoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5jb25uKVxuICB9XG5cbiAgLyoqXG4gICAqIERvIHdlIGhhdmUgYSBjb25uZWN0aW9uIHRvIHdyaXRlIG9uP1xuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1dyaXRhYmxlICgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLnN0cmVhbSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgbWVzc2FnZSB0byB0aGlzIHBlZXIuXG4gICAqIFRocm93cyBpZiB0aGVyZSBpcyBubyBgc3RyZWFtYCB0byB3cml0ZSB0byBhdmFpbGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBtc2dcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIHdyaXRlIChtc2cpIHtcbiAgICBpZiAoIXRoaXMuaXNXcml0YWJsZSkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLmluZm8uaWQudG9CNThTdHJpbmcoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB3cml0YWJsZSBjb25uZWN0aW9uIHRvICcgKyBpZClcbiAgICB9XG5cbiAgICB0aGlzLnN0cmVhbS5wdXNoKG1zZylcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggdGhlIHBlZXIgdG8gYSBjb25uZWN0aW9uIGFuZCBzZXR1cCBhIHdyaXRlIHN0cmVhbVxuICAgKlxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGF0dGFjaENvbm5lY3Rpb24gKGNvbm4pIHtcbiAgICB0aGlzLmNvbm4gPSBjb25uXG4gICAgdGhpcy5zdHJlYW0gPSBuZXcgUHVzaGFibGUoKVxuXG4gICAgcHVsbChcbiAgICAgIHRoaXMuc3RyZWFtLFxuICAgICAgbHAuZW5jb2RlKCksXG4gICAgICBjb25uLFxuICAgICAgcHVsbC5vbkVuZCgoKSA9PiB7XG4gICAgICAgIHRoaXMuY29ubiA9IG51bGxcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBudWxsXG4gICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKVxuICAgICAgfSlcbiAgICApXG5cbiAgICB0aGlzLmVtaXQoJ2Nvbm5lY3Rpb24nKVxuICB9XG5cbiAgX3NlbmRSYXdTdWJzY3JpcHRpb25zICh0b3BpY3MsIHN1YnNjcmliZSkge1xuICAgIGlmICh0b3BpY3Muc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgc3VicyA9IFtdXG4gICAgdG9waWNzLmZvckVhY2goKHRvcGljKSA9PiB7XG4gICAgICBzdWJzLnB1c2goe1xuICAgICAgICBzdWJzY3JpYmU6IHN1YnNjcmliZSxcbiAgICAgICAgdG9waWNJRDogdG9waWNcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHRoaXMud3JpdGUoUlBDLmVuY29kZSh7XG4gICAgICBzdWJzY3JpcHRpb25zOiBzdWJzXG4gICAgfSkpXG4gIH1cblxuICAvKipcbiAgICogU2VuZCB0aGUgZ2l2ZW4gc3Vic2NyaXB0aW9ucyB0byB0aGlzIHBlZXIuXG4gICAqIEBwYXJhbSB7U2V0fEFycmF5fSB0b3BpY3NcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIHNlbmRTdWJzY3JpcHRpb25zICh0b3BpY3MpIHtcbiAgICB0aGlzLl9zZW5kUmF3U3Vic2NyaXB0aW9ucyh0b3BpY3MsIHRydWUpXG4gIH1cblxuICAvKipcbiAgICogU2VuZCB0aGUgZ2l2ZW4gdW5zdWJzY3JpcHRpb25zIHRvIHRoaXMgcGVlci5cbiAgICogQHBhcmFtIHtTZXR8QXJyYXl9IHRvcGljc1xuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgc2VuZFVuc3Vic2NyaXB0aW9ucyAodG9waWNzKSB7XG4gICAgdGhpcy5fc2VuZFJhd1N1YnNjcmlwdGlvbnModG9waWNzLCBmYWxzZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIG1lc3NhZ2VzIHRvIHRoaXMgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBtc2dzXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBzZW5kTWVzc2FnZXMgKG1zZ3MpIHtcbiAgICB0aGlzLndyaXRlKFJQQy5lbmNvZGUoe1xuICAgICAgbXNnczogbXNnc1xuICAgIH0pKVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1bGsgcHJvY2VzcyBzdWJzY3JpcHRpb24gdXBkYXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY2hhbmdlc1xuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgdXBkYXRlU3Vic2NyaXB0aW9ucyAoY2hhbmdlcykge1xuICAgIGNoYW5nZXMuZm9yRWFjaCgoc3Vib3B0KSA9PiB7XG4gICAgICBpZiAoc3Vib3B0LnN1YnNjcmliZSkge1xuICAgICAgICB0aGlzLnRvcGljcy5hZGQoc3Vib3B0LnRvcGljSUQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRvcGljcy5kZWxldGUoc3Vib3B0LnRvcGljSUQpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIG9wZW4gY29ubmVjdGlvbiB0byBwZWVyXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBjbG9zZSAoY2FsbGJhY2spIHtcbiAgICAvLyBGb3JjZSByZW1vdmFsIG9mIHBlZXJcbiAgICB0aGlzLl9yZWZlcmVuY2VzID0gMVxuXG4gICAgLy8gRW5kIHRoZSBwdXNoYWJsZVxuICAgIGlmICh0aGlzLnN0cmVhbSkge1xuICAgICAgdGhpcy5zdHJlYW0uZW5kKClcbiAgICB9XG5cbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgdGhpcy5jb25uID0gbnVsbFxuICAgICAgdGhpcy5zdHJlYW0gPSBudWxsXG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJylcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGVlclxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHByb3RvbnMgPSByZXF1aXJlKCdwcm90b25zJylcblxuY29uc3QgcnBjUHJvdG8gPSBwcm90b25zKHJlcXVpcmUoJy4vcnBjLnByb3RvLmpzJykpXG5jb25zdCBSUEMgPSBycGNQcm90by5SUENcbmNvbnN0IHRvcGljRGVzY3JpcHRvclByb3RvID0gcHJvdG9ucyhyZXF1aXJlKCcuL3RvcGljLWRlc2NyaXB0b3IucHJvdG8uanMnKSlcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzXG5leHBvcnRzLnJwYyA9IHJwY1Byb3RvXG5leHBvcnRzLnRkID0gdG9waWNEZXNjcmlwdG9yUHJvdG9cbmV4cG9ydHMuUlBDID0gUlBDXG5leHBvcnRzLk1lc3NhZ2UgPSBSUEMuTWVzc2FnZVxuZXhwb3J0cy5TdWJPcHRzID0gUlBDLlN1Yk9wdHNcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB0aHJvdHRsZSA9IHJlcXVpcmUoJ2xvZGFzaC50aHJvdHRsZScpXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBUaW1lQ2FjaGVcblxuZnVuY3Rpb24gVGltZUNhY2hlIChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUaW1lQ2FjaGUpKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lQ2FjaGUob3B0aW9ucylcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgY29uc3QgdmFsaWRpdHkgPSBvcHRpb25zLnZhbGlkaXR5IHx8IDMwIC8vIHNlY29uZHNcblxuICBjb25zdCBlbnRyaWVzID0gbmV3IE1hcCgpXG5cbiAgY29uc3Qgc3dlZXAgPSB0aHJvdHRsZSgoKSA9PiB7XG4gICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSwga2V5KSA9PiB7XG4gICAgICBjb25zdCB2ID0gZW50cnkudmFsaWRpdHkgfHwgdmFsaWRpdHlcbiAgICAgIGNvbnN0IGRlbHRhID0gZ2V0VGltZUVsYXBzZWQoZW50cnkudGltZXN0YW1wKVxuICAgICAgaWYgKGRlbHRhID4gdikge1xuICAgICAgICBlbnRyaWVzLmRlbGV0ZShrZXkpXG4gICAgICB9XG4gICAgfSlcbiAgfSwgMjAwKVxuXG4gIHRoaXMucHV0ID0gKGtleSwgdmFsdWUsIHZhbGlkaXR5KSA9PiB7XG4gICAgaWYgKCF0aGlzLmhhcyhrZXkpKSB7XG4gICAgICBlbnRyaWVzLnNldChrZXksIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgIHZhbGlkaXR5OiB2YWxpZGl0eVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBzd2VlcCgpXG4gIH1cblxuICB0aGlzLmdldCA9IChrZXkpID0+IHtcbiAgICBpZiAoZW50cmllcy5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGVudHJpZXMuZ2V0KGtleSkudmFsdWVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXkgZG9lcyBub3QgZXhpc3QnKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuaGFzID0gKGtleSkgPT4ge1xuICAgIHJldHVybiBlbnRyaWVzLmhhcyhrZXkpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZUVsYXBzZWQgKHByZXZUaW1lKSB7XG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKVxuICBjb25zdCBhID0gY3VycmVudFRpbWUuZ2V0VGltZSgpIC0gcHJldlRpbWUuZ2V0VGltZSgpXG5cbiAgcmV0dXJuIE1hdGguZmxvb3IoYSAvIDEwMDApXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9ldmVudHMgPSByZXF1aXJlKCdldmVudHMnKTtcblxudmFyIF9ldmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvKiBnbG9iYWwgZG9jdW1lbnQgKi9cblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbGF0ZW5jeS1tb25pdG9yOlZpc2liaWxpdHlDaGFuZ2VFbWl0dGVyJyk7XG5cbi8qKlxuICogTGlzdGVuIHRvIHBhZ2UgdmlzaWJpbGl0eSBjaGFuZ2UgZXZlbnRzIChpLmUuIHdoZW4gdGhlIHBhZ2UgaXMgZm9jdXNlZCAvIGJsdXJyZWQpIGJ5IGFuIGV2ZW50IGVtaXR0ZXIuXG4gKlxuICogV2FybmluZzogVGhpcyBkb2VzIG5vdCB3b3JrIG9uIGFsbCBicm93c2VycywgYnV0IHNob3VsZCB3b3JrIG9uIGFsbCBtb2Rlcm4gYnJvd3NlcnNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICBjb25zdCBteVZpc2liaWxpdHlFbWl0dGVyID0gbmV3IFZpc2liaWxpdHlDaGFuZ2VFbWl0dGVyKCk7XG4gKlxuICogICAgIG15VmlzaWJpbGl0eUVtaXR0ZXIub24oJ3Zpc2liaWxpdHlDaGFuZ2UnLCAocGFnZUluRm9jdXMpID0+IHtcbiAqICAgICAgICBpZiAoIHBhZ2VJbkZvY3VzICl7XG4gKiAgICAgICAgICAgIC8vIFBhZ2UgaXMgaW4gZm9jdXNcbiAqICAgICAgICAgICAgY29uc29sZS5sb2coJ0luIGZvY3VzJyk7XG4gKiAgICAgICAgfVxuICogICAgICAgIGVsc2Uge1xuICogICAgICAgICAgICAvLyBQYWdlIGlzIGJsdXJyZWRcbiAqICAgICAgICAgICAgY29uc29sZS5sb2coJ091dCBvZiBmb2N1cycpO1xuICogICAgICAgIH1cbiAqICAgICB9KTtcbiAqICAgICAvLyBUbyBhY2Nlc3MgdGhlIHZpc2liaWxpdHkgc3RhdGUgZGlyZWN0bHksIGNhbGw6XG4gKiAgICAgY29uc29sZS5sb2coJ0FtIEkgZm9jdXNlZCBub3c/ICcgKyBteVZpc2liaWxpdHlFbWl0dGVyLmlzVmlzaWJsZSgpKTtcbiAqXG4gKiBAY2xhc3MgVmlzaWJpbGl0eUNoYW5nZUVtaXR0ZXJcbiAqL1xuXG52YXIgVmlzaWJpbGl0eUNoYW5nZUVtaXR0ZXIgPSBmdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICAgIF9pbmhlcml0cyhWaXNpYmlsaXR5Q2hhbmdlRW1pdHRlciwgX0V2ZW50RW1pdHRlcik7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVmlzaWJpbGl0eUNoYW5nZUVtaXR0ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBWaXNpYmlsaXR5Q2hhbmdlRW1pdHRlcigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZpc2liaWxpdHlDaGFuZ2VFbWl0dGVyKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVmlzaWJpbGl0eUNoYW5nZUVtaXR0ZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihWaXNpYmlsaXR5Q2hhbmdlRW1pdHRlcikpLmNhbGwodGhpcykpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBkZWJ1ZygnVGhpcyBpcyBub3QgYSBicm93c2VyLCBubyBcImRvY3VtZW50XCIgZm91bmQuIFN0b3BwaW5nLicpO1xuICAgICAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5faW5pdGlhbGl6ZVZpc2liaWxpdHlWYXJOYW1lcygpO1xuICAgICAgICBfdGhpcy5fYWRkVmlzaWJpbGl0eUNoYW5nZUxpc3RlbmVyKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBkb2N1bWVudC5oaWRkZW4gYW5kIGRvY3VtZW50LnZpc2liaWxpdHlDaGFuZ2UgYXJlIHRoZSB0d28gdmFyaWFibGVzIHdlIG5lZWQgdG8gY2hlY2sgZm9yO1xuICAgICAqIFNpbmNlIHRoZXNlIHZhcmlhYmxlcyBhcmUgbmFtZWQgZGlmZmVyZW50bHkgaW4gZGlmZmVyZW50IGJyb3dzZXJzLCB0aGlzIGZ1bmN0aW9uIHNldHNcbiAgICAgKiB0aGUgYXBwcm9wcmlhdGUgbmFtZSBiYXNlZCBvbiB0aGUgYnJvd3NlciBiZWluZyB1c2VkLiBPbmNlIGV4ZWN1dGVkLCB0aGEgYWN0dWFsIG5hbWVzIG9mXG4gICAgICogZG9jdW1lbnQuaGlkZGVuIGFuZCBkb2N1bWVudC52aXNpYmlsaXR5Q2hhbmdlIGFyZSBmb3VuZCBpbiB0aGlzLl9oaWRkZW4gYW5kIHRoaXMuX3Zpc2liaWxpdHlDaGFuZ2VcbiAgICAgKiByZXNwZWN0aXZlbHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoVmlzaWJpbGl0eUNoYW5nZUVtaXR0ZXIsIFt7XG4gICAgICAgIGtleTogJ19pbml0aWFsaXplVmlzaWJpbGl0eVZhck5hbWVzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0aWFsaXplVmlzaWJpbGl0eVZhck5hbWVzKCkge1xuICAgICAgICAgICAgdmFyIGhpZGRlbiA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciB2aXNpYmlsaXR5Q2hhbmdlID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudC5oaWRkZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gT3BlcmEgMTIuMTAgYW5kIEZpcmVmb3ggMTggYW5kIGxhdGVyIHN1cHBvcnRcbiAgICAgICAgICAgICAgICBoaWRkZW4gPSAnaGlkZGVuJztcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ3Zpc2liaWxpdHljaGFuZ2UnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQubW96SGlkZGVuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGhpZGRlbiA9ICdtb3pIaWRkZW4nO1xuICAgICAgICAgICAgICAgIHZpc2liaWxpdHlDaGFuZ2UgPSAnbW96dmlzaWJpbGl0eWNoYW5nZSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudC5tc0hpZGRlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBoaWRkZW4gPSAnbXNIaWRkZW4nO1xuICAgICAgICAgICAgICAgIHZpc2liaWxpdHlDaGFuZ2UgPSAnbXN2aXNpYmlsaXR5Y2hhbmdlJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50LndlYmtpdEhpZGRlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBoaWRkZW4gPSAnd2Via2l0SGlkZGVuJztcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ3dlYmtpdHZpc2liaWxpdHljaGFuZ2UnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faGlkZGVuID0gaGlkZGVuO1xuICAgICAgICAgICAgdGhpcy5fdmlzaWJpbGl0eUNoYW5nZSA9IHZpc2liaWxpdHlDaGFuZ2U7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgZG9jdW1lbnQgdGhhdCBsaXN0ZW5zIHRvIGNoYW5nZXMgaW4gZG9jdW1lbnQudmlzaWJpbGl0eUNoYW5nZVxuICAgICAgICAgKiAob3Igd2hhdGV2ZXIgbmFtZSBieSB3aGljaCB0aGUgdmlzaWJpbGl0eUNoYW5nZSB2YXJpYWJsZSBpcyBrbm93biBpbiB0aGUgYnJvd3NlcilcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19hZGRWaXNpYmlsaXR5Q2hhbmdlTGlzdGVuZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZFZpc2liaWxpdHlDaGFuZ2VMaXN0ZW5lcigpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGRvY3VtZW50W3RoaXMuX2hpZGRlbl0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ0NoZWNraW5nIHBhZ2UgdmlzaWJpbGl0eSByZXF1aXJlcyBhIGJyb3dzZXIgdGhhdCBzdXBwb3J0cyB0aGUgUGFnZSBWaXNpYmlsaXR5IEFQSS4nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIHBhZ2UgdmlzaWJpbGl0eSBjaGFuZ2VcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKHRoaXMuX3Zpc2liaWxpdHlDaGFuZ2UsIHRoaXMuX2hhbmRsZVZpc2liaWxpdHlDaGFuZ2UuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiByZXR1cm5zIGBgYHRydWVgYGAgaWYgdGhlIHBhZ2UgaXMgdmlzaWJsZSBvciBgYGBmYWxzZWBgYCBpZiB0aGUgcGFnZSBpcyBub3QgdmlzaWJsZSBhbmRcbiAgICAgICAgICogYGBgdW5kZWZpbmVkYGBgIGlmIHRoZSBwYWdlIHZpc2liaWxpdHkgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIuXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufHZvaWR9IHdoZXRoZXIgdGhlIHBhZ2UgaXMgbm93IHZpc2libGUgb3Igbm90ICh1bmRlZmluZWQgaXMgdW5rbm93bilcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2lzVmlzaWJsZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1Zpc2libGUoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faGlkZGVuID09PSB1bmRlZmluZWQgfHwgZG9jdW1lbnRbdGhpcy5faGlkZGVuXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICFkb2N1bWVudFt0aGlzLl9oaWRkZW5dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIGRvY3VtZW50LnZpc2liaWxpdHlDaGFuZ2UgaGFzIGNoYW5nZWRcbiAgICAgICAgICogSXQgZW1pdHMgYW4gZXZlbnQgY2FsbGVkIHZpc2liaWxpdHlDaGFuZ2UgYW5kIHNlbmRzIHRoZSB2YWx1ZSBvZiBkb2N1bWVudC5oaWRkZW4gYXMgYVxuICAgICAgICAgKiBwYXJhbWV0ZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKCkge1xuICAgICAgICAgICAgdmFyIHZpc2libGUgPSAhZG9jdW1lbnRbdGhpcy5faGlkZGVuXTtcbiAgICAgICAgICAgIGRlYnVnKHZpc2libGUgPyAnUGFnZSBWaXNpYmxlJyA6ICdQYWdlIEhpZGRlbicpO1xuICAgICAgICAgICAgLy8gRW1pdCB0aGUgZXZlbnRcbiAgICAgICAgICAgIHRoaXMuZW1pdCgndmlzaWJpbGl0eUNoYW5nZScsIHZpc2libGUpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFZpc2liaWxpdHlDaGFuZ2VFbWl0dGVyO1xufShfZXZlbnRzMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVmlzaWJpbGl0eUNoYW5nZUVtaXR0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WaXNpYmlsaXR5Q2hhbmdlRW1pdHRlci5qcy5tYXBcbiIsIi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJ2xpZ2h0c2VhZ3JlZW4nLFxuICAnZm9yZXN0Z3JlZW4nLFxuICAnZ29sZGVucm9kJyxcbiAgJ2RvZGdlcmJsdWUnLFxuICAnZGFya29yY2hpZCcsXG4gICdjcmltc29uJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuY29uc3Qgd2l0aElzID0gcmVxdWlyZSgnY2xhc3MtaXMnKVxuXG5jbGFzcyBCYXNlQ29ubmVjdGlvbiBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yICh7IF9zd2l0Y2gsIG5hbWUgfSkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMuc3dpdGNoID0gX3N3aXRjaFxuICAgIHRoaXMub3VyUGVlckluZm8gPSB0aGlzLnN3aXRjaC5fcGVlckluZm9cbiAgICB0aGlzLmxvZyA9IGRlYnVnKGBsaWJwMnA6Y29ubjoke25hbWV9YClcbiAgICB0aGlzLmxvZy5lcnJvciA9IGRlYnVnKGBsaWJwMnA6Y29ubjoke25hbWV9OmVycm9yYClcbiAgfVxuXG4gIC8qKlxuICAgKiBQdXRzIHRoZSBzdGF0ZSBpbnRvIGl0cyBkaXNjb25uZWN0aW5nIGZsb3dcbiAgICpcbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyIFdpbGwgYmUgZW1pdHRlZCBpZiBwcm92aWRlZFxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGNsb3NlIChlcnIpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUuX3N0YXRlID09PSAnRElTQ09OTkVDVElORycpIHJldHVyblxuICAgIHRoaXMubG9nKCdjbG9zaW5nIGNvbm5lY3Rpb24gdG8gJXMnLCB0aGlzLnRoZWlyQjU4SWQpXG4gICAgaWYgKGVyciAmJiB0aGlzLl9ldmVudHMuZXJyb3IpIHtcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgfVxuICAgIHRoaXMuX3N0YXRlKCdkaXNjb25uZWN0JylcbiAgfVxuXG4gIGVtaXQgKGV2ZW50TmFtZSwgLi4uYXJncykge1xuICAgIGlmIChldmVudE5hbWUgPT09ICdlcnJvcicgJiYgIXRoaXMuX2V2ZW50cy5lcnJvcikge1xuICAgICAgdGhpcy5sb2cuZXJyb3IoLi4uYXJncylcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuZW1pdChldmVudE5hbWUsIC4uLmFyZ3MpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGNvbm5lY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGNvbm5lY3Rpb25cbiAgICovXG4gIGdldFN0YXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUuX3N0YXRlXG4gIH1cblxuICAvKipcbiAgICogUHV0cyB0aGUgc3RhdGUgaW50byBlbmNyeXB0aW5nIG1vZGVcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBlbmNyeXB0ICgpIHtcbiAgICB0aGlzLl9zdGF0ZSgnZW5jcnlwdCcpXG4gIH1cblxuICAvKipcbiAgICogUHV0cyB0aGUgc3RhdGUgaW50byBwcml2YXRpemluZyBtb2RlXG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgcHJvdGVjdCAoKSB7XG4gICAgdGhpcy5fc3RhdGUoJ3ByaXZhdGl6ZScpXG4gIH1cblxuICAvKipcbiAgICogUHV0cyB0aGUgc3RhdGUgaW50byBtdXhpbmcgbW9kZVxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHVwZ3JhZGUgKCkge1xuICAgIHRoaXMuX3N0YXRlKCd1cGdyYWRlJylcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBkaXNjb25uZWN0ZWQuXG4gICAqXG4gICAqIEBmaXJlcyBCYXNlQ29ubmVjdGlvbiNjbG9zZVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF9vbkRpc2Nvbm5lY3RlZCAoKSB7XG4gICAgdGhpcy5zd2l0Y2guY29ubmVjdGlvbi5yZW1vdmUodGhpcylcbiAgICB0aGlzLmxvZygnZGlzY29ubmVjdGVkIGZyb20gJXMnLCB0aGlzLnRoZWlyQjU4SWQpXG4gICAgdGhpcy5lbWl0KCdjbG9zZScpXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKVxuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIHByaXZhdGl6ZWRcbiAgICpcbiAgICogQGZpcmVzIEJhc2VDb25uZWN0aW9uI3ByaXZhdGVcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBfb25Qcml2YXRpemVkICgpIHtcbiAgICB0aGlzLmVtaXQoJ3ByaXZhdGUnLCB0aGlzLmNvbm4pXG4gIH1cblxuICAvKipcbiAgICogV3JhcHMgdGhpcy5jb25uIHdpdGggdGhlIFN3aXRjaC5wcm90ZWN0b3IgZm9yIHByaXZhdGUgY29ubmVjdGlvbnNcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGZpcmVzIENvbm5lY3Rpb25GU00jZXJyb3JcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBfb25Qcml2YXRpemluZyAoKSB7XG4gICAgaWYgKCF0aGlzLnN3aXRjaC5wcm90ZWN0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGF0ZSgnZG9uZScpXG4gICAgfVxuXG4gICAgdGhpcy5jb25uID0gdGhpcy5zd2l0Y2gucHJvdGVjdG9yLnByb3RlY3QodGhpcy5jb25uLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlKGVycilcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2coJ3N1Y2Nlc3NmdWxseSBwcml2YXRpemVkIGNvbm4gdG8gJXMnLCB0aGlzLnRoZWlyQjU4SWQpXG4gICAgICB0aGlzLmNvbm4uc2V0UGVlckluZm8odGhpcy50aGVpclBlZXJJbmZvKVxuICAgICAgdGhpcy5fc3RhdGUoJ2RvbmUnKVxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3aXRoSXMoQmFzZUNvbm5lY3Rpb24sIHtcbiAgY2xhc3NOYW1lOiAnQmFzZUNvbm5lY3Rpb24nLFxuICBzeW1ib2xOYW1lOiAnbGlicDJwLXN3aXRjaC9CYXNlQ29ubmVjdGlvbidcbn0pXG4iLCI7KGZ1bmN0aW9uIChnbG9iYWxPYmplY3QpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4vKlxyXG4gKiAgICAgIGJpZ251bWJlci5qcyB2OC4xLjFcclxuICogICAgICBBIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgYXJiaXRyYXJ5LXByZWNpc2lvbiBhcml0aG1ldGljLlxyXG4gKiAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZ251bWJlci5qc1xyXG4gKiAgICAgIENvcHlyaWdodCAoYykgMjAxOSBNaWNoYWVsIE1jbGF1Z2hsaW4gPE04Y2g4OGxAZ21haWwuY29tPlxyXG4gKiAgICAgIE1JVCBMaWNlbnNlZC5cclxuICpcclxuICogICAgICBCaWdOdW1iZXIucHJvdG90eXBlIG1ldGhvZHMgICAgIHwgIEJpZ051bWJlciBtZXRob2RzXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgYWJzb2x1dGVWYWx1ZSAgICAgICAgICAgIGFicyAgICB8ICBjbG9uZVxyXG4gKiAgICAgIGNvbXBhcmVkVG8gICAgICAgICAgICAgICAgICAgICAgfCAgY29uZmlnICAgICAgICAgICAgICAgc2V0XHJcbiAqICAgICAgZGVjaW1hbFBsYWNlcyAgICAgICAgICAgIGRwICAgICB8ICAgICAgREVDSU1BTF9QTEFDRVNcclxuICogICAgICBkaXZpZGVkQnkgICAgICAgICAgICAgICAgZGl2ICAgIHwgICAgICBST1VORElOR19NT0RFXHJcbiAqICAgICAgZGl2aWRlZFRvSW50ZWdlckJ5ICAgICAgIGlkaXYgICB8ICAgICAgRVhQT05FTlRJQUxfQVRcclxuICogICAgICBleHBvbmVudGlhdGVkQnkgICAgICAgICAgcG93ICAgIHwgICAgICBSQU5HRVxyXG4gKiAgICAgIGludGVnZXJWYWx1ZSAgICAgICAgICAgICAgICAgICAgfCAgICAgIENSWVBUT1xyXG4gKiAgICAgIGlzRXF1YWxUbyAgICAgICAgICAgICAgICBlcSAgICAgfCAgICAgIE1PRFVMT19NT0RFXHJcbiAqICAgICAgaXNGaW5pdGUgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgUE9XX1BSRUNJU0lPTlxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW4gICAgICAgICAgICBndCAgICAgfCAgICAgIEZPUk1BVFxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW5PckVxdWFsVG8gICBndGUgICAgfCAgICAgIEFMUEhBQkVUXHJcbiAqICAgICAgaXNJbnRlZ2VyICAgICAgICAgICAgICAgICAgICAgICB8ICBpc0JpZ051bWJlclxyXG4gKiAgICAgIGlzTGVzc1RoYW4gICAgICAgICAgICAgICBsdCAgICAgfCAgbWF4aW11bSAgICAgICAgICAgICAgbWF4XHJcbiAqICAgICAgaXNMZXNzVGhhbk9yRXF1YWxUbyAgICAgIGx0ZSAgICB8ICBtaW5pbXVtICAgICAgICAgICAgICBtaW5cclxuICogICAgICBpc05hTiAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHJhbmRvbVxyXG4gKiAgICAgIGlzTmVnYXRpdmUgICAgICAgICAgICAgICAgICAgICAgfCAgc3VtXHJcbiAqICAgICAgaXNQb3NpdGl2ZSAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgaXNaZXJvICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbWludXMgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbW9kdWxvICAgICAgICAgICAgICAgICAgIG1vZCAgICB8XHJcbiAqICAgICAgbXVsdGlwbGllZEJ5ICAgICAgICAgICAgIHRpbWVzICB8XHJcbiAqICAgICAgbmVnYXRlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcGx1cyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcHJlY2lzaW9uICAgICAgICAgICAgICAgIHNkICAgICB8XHJcbiAqICAgICAgc2hpZnRlZEJ5ICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgc3F1YXJlUm9vdCAgICAgICAgICAgICAgIHNxcnQgICB8XHJcbiAqICAgICAgdG9FeHBvbmVudGlhbCAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GaXhlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9Gb3JtYXQgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GcmFjdGlvbiAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9KU09OICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9OdW1iZXIgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9QcmVjaXNpb24gICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9TdHJpbmcgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdmFsdWVPZiAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqXHJcbiAqL1xyXG5cclxuXHJcbiAgdmFyIEJpZ051bWJlcixcclxuICAgIGlzTnVtZXJpYyA9IC9eLT8oPzpcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspKD86ZVsrLV0/XFxkKyk/JC9pLFxyXG4gICAgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcsXHJcblxyXG4gICAgbWF0aGNlaWwgPSBNYXRoLmNlaWwsXHJcbiAgICBtYXRoZmxvb3IgPSBNYXRoLmZsb29yLFxyXG5cclxuICAgIGJpZ251bWJlckVycm9yID0gJ1tCaWdOdW1iZXIgRXJyb3JdICcsXHJcbiAgICB0b29NYW55RGlnaXRzID0gYmlnbnVtYmVyRXJyb3IgKyAnTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czogJyxcclxuXHJcbiAgICBCQVNFID0gMWUxNCxcclxuICAgIExPR19CQVNFID0gMTQsXHJcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gMHgxZmZmZmZmZmZmZmZmZiwgICAgICAgICAvLyAyXjUzIC0gMVxyXG4gICAgLy8gTUFYX0lOVDMyID0gMHg3ZmZmZmZmZiwgICAgICAgICAgICAgICAgICAgLy8gMl4zMSAtIDFcclxuICAgIFBPV1NfVEVOID0gWzEsIDEwLCAxMDAsIDFlMywgMWU0LCAxZTUsIDFlNiwgMWU3LCAxZTgsIDFlOSwgMWUxMCwgMWUxMSwgMWUxMiwgMWUxM10sXHJcbiAgICBTUVJUX0JBU0UgPSAxZTcsXHJcblxyXG4gICAgLy8gRURJVEFCTEVcclxuICAgIC8vIFRoZSBsaW1pdCBvbiB0aGUgdmFsdWUgb2YgREVDSU1BTF9QTEFDRVMsIFRPX0VYUF9ORUcsIFRPX0VYUF9QT1MsIE1JTl9FWFAsIE1BWF9FWFAsIGFuZFxyXG4gICAgLy8gdGhlIGFyZ3VtZW50cyB0byB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCwgYW5kIHRvUHJlY2lzaW9uLlxyXG4gICAgTUFYID0gMUU5OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhfSU5UMzJcclxuXHJcblxyXG4gIC8qXHJcbiAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBCaWdOdW1iZXIgY29uc3RydWN0b3IuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY2xvbmUoY29uZmlnT2JqZWN0KSB7XHJcbiAgICB2YXIgZGl2LCBjb252ZXJ0QmFzZSwgcGFyc2VOdW1lcmljLFxyXG4gICAgICBQID0gQmlnTnVtYmVyLnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IEJpZ051bWJlciwgdG9TdHJpbmc6IG51bGwsIHZhbHVlT2Y6IG51bGwgfSxcclxuICAgICAgT05FID0gbmV3IEJpZ051bWJlcigxKSxcclxuXHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVESVRBQkxFIENPTkZJRyBERUZBVUxUUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWVzIGJlbG93IG11c3QgYmUgaW50ZWdlcnMgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2VzIHN0YXRlZC5cclxuICAgICAgLy8gVGhlIHZhbHVlcyBjYW4gYWxzbyBiZSBjaGFuZ2VkIGF0IHJ1bi10aW1lIHVzaW5nIEJpZ051bWJlci5zZXQuXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIG9wZXJhdGlvbnMgaW52b2x2aW5nIGRpdmlzaW9uLlxyXG4gICAgICBERUNJTUFMX1BMQUNFUyA9IDIwLCAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBUaGUgcm91bmRpbmcgbW9kZSB1c2VkIHdoZW4gcm91bmRpbmcgdG8gdGhlIGFib3ZlIGRlY2ltYWwgcGxhY2VzLCBhbmQgd2hlbiB1c2luZ1xyXG4gICAgICAvLyB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCBhbmQgdG9QcmVjaXNpb24sIGFuZCByb3VuZCAoZGVmYXVsdCB2YWx1ZSkuXHJcbiAgICAgIC8vIFVQICAgICAgICAgMCBBd2F5IGZyb20gemVyby5cclxuICAgICAgLy8gRE9XTiAgICAgICAxIFRvd2FyZHMgemVyby5cclxuICAgICAgLy8gQ0VJTCAgICAgICAyIFRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBGTE9PUiAgICAgIDMgVG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgIC8vIEhBTEZfVVAgICAgNCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdXAuXHJcbiAgICAgIC8vIEhBTEZfRE9XTiAgNSBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgZG93bi5cclxuICAgICAgLy8gSEFMRl9FVkVOICA2IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIGV2ZW4gbmVpZ2hib3VyLlxyXG4gICAgICAvLyBIQUxGX0NFSUwgIDcgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBIQUxGX0ZMT09SIDggVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICBST1VORElOR19NT0RFID0gNCwgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOFxyXG5cclxuICAgICAgLy8gRVhQT05FTlRJQUxfQVQgOiBbVE9fRVhQX05FRyAsIFRPX0VYUF9QT1NdXHJcblxyXG4gICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGJlbmVhdGggd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IC03XHJcbiAgICAgIFRPX0VYUF9ORUcgPSAtNywgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byAtTUFYXHJcblxyXG4gICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGFib3ZlIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAyMVxyXG4gICAgICBUT19FWFBfUE9TID0gMjEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBSQU5HRSA6IFtNSU5fRVhQLCBNQVhfRVhQXVxyXG5cclxuICAgICAgLy8gVGhlIG1pbmltdW0gZXhwb25lbnQgdmFsdWUsIGJlbmVhdGggd2hpY2ggdW5kZXJmbG93IHRvIHplcm8gb2NjdXJzLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogLTMyNCAgKDVlLTMyNClcclxuICAgICAgTUlOX0VYUCA9IC0xZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtMSB0byAtTUFYXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBleHBvbmVudCB2YWx1ZSwgYWJvdmUgd2hpY2ggb3ZlcmZsb3cgdG8gSW5maW5pdHkgb2NjdXJzLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogIDMwOCAgKDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KVxyXG4gICAgICAvLyBGb3IgTUFYX0VYUCA+IDFlNywgZS5nLiBuZXcgQmlnTnVtYmVyKCcxZTEwMDAwMDAwMCcpLnBsdXMoMSkgbWF5IGJlIHNsb3cuXHJcbiAgICAgIE1BWF9FWFAgPSAxZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSB0byBNQVhcclxuXHJcbiAgICAgIC8vIFdoZXRoZXIgdG8gdXNlIGNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24sIGlmIGF2YWlsYWJsZS5cclxuICAgICAgQ1JZUFRPID0gZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlIG9yIGZhbHNlXHJcblxyXG4gICAgICAvLyBUaGUgbW9kdWxvIG1vZGUgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBtb2R1bHVzOiBhIG1vZCBuLlxyXG4gICAgICAvLyBUaGUgcXVvdGllbnQgKHEgPSBhIC8gbikgaXMgY2FsY3VsYXRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcm91bmRpbmcgbW9kZS5cclxuICAgICAgLy8gVGhlIHJlbWFpbmRlciAocikgaXMgY2FsY3VsYXRlZCBhczogciA9IGEgLSBuICogcS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVVAgICAgICAgIDAgVGhlIHJlbWFpbmRlciBpcyBwb3NpdGl2ZSBpZiB0aGUgZGl2aWRlbmQgaXMgbmVnYXRpdmUsIGVsc2UgaXMgbmVnYXRpdmUuXHJcbiAgICAgIC8vIERPV04gICAgICAxIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlkZW5kLlxyXG4gICAgICAvLyAgICAgICAgICAgICBUaGlzIG1vZHVsbyBtb2RlIGlzIGNvbW1vbmx5IGtub3duIGFzICd0cnVuY2F0ZWQgZGl2aXNpb24nIGFuZCBpc1xyXG4gICAgICAvLyAgICAgICAgICAgICBlcXVpdmFsZW50IHRvIChhICUgbikgaW4gSmF2YVNjcmlwdC5cclxuICAgICAgLy8gRkxPT1IgICAgIDMgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aXNvciAoUHl0aG9uICUpLlxyXG4gICAgICAvLyBIQUxGX0VWRU4gNiBUaGlzIG1vZHVsbyBtb2RlIGltcGxlbWVudHMgdGhlIElFRUUgNzU0IHJlbWFpbmRlciBmdW5jdGlvbi5cclxuICAgICAgLy8gRVVDTElEICAgIDkgRXVjbGlkaWFuIGRpdmlzaW9uLiBxID0gc2lnbihuKSAqIGZsb29yKGEgLyBhYnMobikpLlxyXG4gICAgICAvLyAgICAgICAgICAgICBUaGUgcmVtYWluZGVyIGlzIGFsd2F5cyBwb3NpdGl2ZS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVGhlIHRydW5jYXRlZCBkaXZpc2lvbiwgZmxvb3JlZCBkaXZpc2lvbiwgRXVjbGlkaWFuIGRpdmlzaW9uIGFuZCBJRUVFIDc1NCByZW1haW5kZXJcclxuICAgICAgLy8gbW9kZXMgYXJlIGNvbW1vbmx5IHVzZWQgZm9yIHRoZSBtb2R1bHVzIG9wZXJhdGlvbi5cclxuICAgICAgLy8gQWx0aG91Z2ggdGhlIG90aGVyIHJvdW5kaW5nIG1vZGVzIGNhbiBhbHNvIGJlIHVzZWQsIHRoZXkgbWF5IG5vdCBnaXZlIHVzZWZ1bCByZXN1bHRzLlxyXG4gICAgICBNT0RVTE9fTU9ERSA9IDEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOVxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgcmVzdWx0IG9mIHRoZSBleHBvbmVudGlhdGVkQnkgb3BlcmF0aW9uLlxyXG4gICAgICAvLyBJZiBQT1dfUFJFQ0lTSU9OIGlzIDAsIHRoZXJlIHdpbGwgYmUgdW5saW1pdGVkIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgICAgUE9XX1BSRUNJU0lPTiA9IDAsICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gVGhlIGZvcm1hdCBzcGVjaWZpY2F0aW9uIHVzZWQgYnkgdGhlIEJpZ051bWJlci5wcm90b3R5cGUudG9Gb3JtYXQgbWV0aG9kLlxyXG4gICAgICBGT1JNQVQgPSB7XHJcbiAgICAgICAgcHJlZml4OiAnJyxcclxuICAgICAgICBncm91cFNpemU6IDMsXHJcbiAgICAgICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAgICAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICAgIGZyYWN0aW9uR3JvdXBTaXplOiAwLFxyXG4gICAgICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgICAgc3VmZml4OiAnJ1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLy8gVGhlIGFscGhhYmV0IHVzZWQgZm9yIGJhc2UgY29udmVyc2lvbi4gSXQgbXVzdCBiZSBhdCBsZWFzdCAyIGNoYXJhY3RlcnMgbG9uZywgd2l0aCBubyAnKycsXHJcbiAgICAgIC8vICctJywgJy4nLCB3aGl0ZXNwYWNlLCBvciByZXBlYXRlZCBjaGFyYWN0ZXIuXHJcbiAgICAgIC8vICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiRfJ1xyXG4gICAgICBBTFBIQUJFVCA9ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonO1xyXG5cclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgICAvLyBDT05TVFJVQ1RPUlxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogVGhlIEJpZ051bWJlciBjb25zdHJ1Y3RvciBhbmQgZXhwb3J0ZWQgZnVuY3Rpb24uXHJcbiAgICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBhIEJpZ051bWJlciBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogdiB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEEgbnVtZXJpYyB2YWx1ZS5cclxuICAgICAqIFtiXSB7bnVtYmVyfSBUaGUgYmFzZSBvZiB2LiBJbnRlZ2VyLCAyIHRvIEFMUEhBQkVULmxlbmd0aCBpbmNsdXNpdmUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEJpZ051bWJlcih2LCBiKSB7XHJcbiAgICAgIHZhciBhbHBoYWJldCwgYywgY2FzZUNoYW5nZWQsIGUsIGksIGlzTnVtLCBsZW4sIHN0cixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIC8vIEVuYWJsZSBjb25zdHJ1Y3RvciBjYWxsIHdpdGhvdXQgYG5ld2AuXHJcbiAgICAgIGlmICghKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpKSByZXR1cm4gbmV3IEJpZ051bWJlcih2LCBiKTtcclxuXHJcbiAgICAgIGlmIChiID09IG51bGwpIHtcclxuXHJcbiAgICAgICAgaWYgKHYgJiYgdi5faXNCaWdOdW1iZXIgPT09IHRydWUpIHtcclxuICAgICAgICAgIHgucyA9IHYucztcclxuXHJcbiAgICAgICAgICBpZiAoIXYuYyB8fCB2LmUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHYuZSA8IE1JTl9FWFApIHtcclxuICAgICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeC5lID0gdi5lO1xyXG4gICAgICAgICAgICB4LmMgPSB2LmMuc2xpY2UoKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoKGlzTnVtID0gdHlwZW9mIHYgPT0gJ251bWJlcicpICYmIHYgKiAwID09IDApIHtcclxuXHJcbiAgICAgICAgICAvLyBVc2UgYDEgLyBuYCB0byBoYW5kbGUgbWludXMgemVybyBhbHNvLlxyXG4gICAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gKHYgPSAtdiwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgICAvLyBGYXN0IHBhdGggZm9yIGludGVnZXJzLCB3aGVyZSBuIDwgMjE0NzQ4MzY0OCAoMioqMzEpLlxyXG4gICAgICAgICAgaWYgKHYgPT09IH5+dikge1xyXG4gICAgICAgICAgICBmb3IgKGUgPSAwLCBpID0gdjsgaSA+PSAxMDsgaSAvPSAxMCwgZSsrKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChlID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgICAgICB4LmMgPSBbdl07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBzdHIgPSBTdHJpbmcodik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICBpZiAoIWlzTnVtZXJpYy50ZXN0KHN0ciA9IFN0cmluZyh2KSkpIHJldHVybiBwYXJzZU51bWVyaWMoeCwgc3RyLCBpc051bSk7XHJcblxyXG4gICAgICAgICAgeC5zID0gc3RyLmNoYXJDb2RlQXQoMCkgPT0gNDUgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRpYWwgZm9ybT9cclxuICAgICAgICBpZiAoKGkgPSBzdHIuc2VhcmNoKC9lL2kpKSA+IDApIHtcclxuXHJcbiAgICAgICAgICAvLyBEZXRlcm1pbmUgZXhwb25lbnQuXHJcbiAgICAgICAgICBpZiAoZSA8IDApIGUgPSBpO1xyXG4gICAgICAgICAgZSArPSArc3RyLnNsaWNlKGkgKyAxKTtcclxuICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgaSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlIDwgMCkge1xyXG5cclxuICAgICAgICAgIC8vIEludGVnZXIuXHJcbiAgICAgICAgICBlID0gc3RyLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQmFzZSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7Yn0nXHJcbiAgICAgICAgaW50Q2hlY2soYiwgMiwgQUxQSEFCRVQubGVuZ3RoLCAnQmFzZScpO1xyXG5cclxuICAgICAgICAvLyBBbGxvdyBleHBvbmVudGlhbCBub3RhdGlvbiB0byBiZSB1c2VkIHdpdGggYmFzZSAxMCBhcmd1bWVudCwgd2hpbGVcclxuICAgICAgICAvLyBhbHNvIHJvdW5kaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFzIHdpdGggb3RoZXIgYmFzZXMuXHJcbiAgICAgICAgaWYgKGIgPT0gMTApIHtcclxuICAgICAgICAgIHggPSBuZXcgQmlnTnVtYmVyKHYpO1xyXG4gICAgICAgICAgcmV0dXJuIHJvdW5kKHgsIERFQ0lNQUxfUExBQ0VTICsgeC5lICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSBTdHJpbmcodik7XHJcblxyXG4gICAgICAgIGlmIChpc051bSA9IHR5cGVvZiB2ID09ICdudW1iZXInKSB7XHJcblxyXG4gICAgICAgICAgLy8gQXZvaWQgcG90ZW50aWFsIGludGVycHJldGF0aW9uIG9mIEluZmluaXR5IGFuZCBOYU4gYXMgYmFzZSA0NCsgdmFsdWVzLlxyXG4gICAgICAgICAgaWYgKHYgKiAwICE9IDApIHJldHVybiBwYXJzZU51bWVyaWMoeCwgc3RyLCBpc051bSwgYik7XHJcblxyXG4gICAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRyAmJiBzdHIucmVwbGFjZSgvXjBcXC4wKnxcXC4vLCAnJykubGVuZ3RoID4gMTUpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICh0b29NYW55RGlnaXRzICsgdik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhbHBoYWJldCA9IEFMUEhBQkVULnNsaWNlKDAsIGIpO1xyXG4gICAgICAgIGUgPSBpID0gMDtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBzdHIgaXMgYSB2YWxpZCBiYXNlIGIgbnVtYmVyLlxyXG4gICAgICAgIC8vIERvbid0IHVzZSBSZWdFeHAsIHNvIGFscGhhYmV0IGNhbiBjb250YWluIHNwZWNpYWwgY2hhcmFjdGVycy5cclxuICAgICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgaWYgKGFscGhhYmV0LmluZGV4T2YoYyA9IHN0ci5jaGFyQXQoaSkpIDwgMCkge1xyXG4gICAgICAgICAgICBpZiAoYyA9PSAnLicpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgJy4nIGlzIG5vdCB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCBpdCBoYXMgbm90IGJlIGZvdW5kIGJlZm9yZS5cclxuICAgICAgICAgICAgICBpZiAoaSA+IGUpIHtcclxuICAgICAgICAgICAgICAgIGUgPSBsZW47XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNhc2VDaGFuZ2VkKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEFsbG93IGUuZy4gaGV4YWRlY2ltYWwgJ0ZGJyBhcyB3ZWxsIGFzICdmZicuXHJcbiAgICAgICAgICAgICAgaWYgKHN0ciA9PSBzdHIudG9VcHBlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvTG93ZXJDYXNlKCkpIHx8XHJcbiAgICAgICAgICAgICAgICAgIHN0ciA9PSBzdHIudG9Mb3dlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvVXBwZXJDYXNlKCkpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpID0gLTE7XHJcbiAgICAgICAgICAgICAgICBlID0gMDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBTdHJpbmcodiksIGlzTnVtLCBiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFByZXZlbnQgbGF0ZXIgY2hlY2sgZm9yIGxlbmd0aCBvbiBjb252ZXJ0ZWQgbnVtYmVyLlxyXG4gICAgICAgIGlzTnVtID0gZmFsc2U7XHJcbiAgICAgICAgc3RyID0gY29udmVydEJhc2Uoc3RyLCBiLCAxMCwgeC5zKTtcclxuXHJcbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICBlbHNlIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChpID0gMDsgc3RyLmNoYXJDb2RlQXQoaSkgPT09IDQ4OyBpKyspO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IHN0ci5jaGFyQ29kZUF0KC0tbGVuKSA9PT0gNDg7KTtcclxuXHJcbiAgICAgIGlmIChzdHIgPSBzdHIuc2xpY2UoaSwgKytsZW4pKSB7XHJcbiAgICAgICAgbGVuIC09IGk7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgICAgaWYgKGlzTnVtICYmIEJpZ051bWJlci5ERUJVRyAmJlxyXG4gICAgICAgICAgbGVuID4gMTUgJiYgKHYgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHYgIT09IG1hdGhmbG9vcih2KSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICh0b29NYW55RGlnaXRzICsgKHgucyAqIHYpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgICBpZiAoKGUgPSBlIC0gaSAtIDEpID4gTUFYX0VYUCkge1xyXG5cclxuICAgICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgeC5jID0gW107XHJcblxyXG4gICAgICAgICAgLy8gVHJhbnNmb3JtIGJhc2VcclxuXHJcbiAgICAgICAgICAvLyBlIGlzIHRoZSBiYXNlIDEwIGV4cG9uZW50LlxyXG4gICAgICAgICAgLy8gaSBpcyB3aGVyZSB0byBzbGljZSBzdHIgdG8gZ2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBjb2VmZmljaWVudCBhcnJheS5cclxuICAgICAgICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XHJcbiAgICAgICAgICBpZiAoZSA8IDApIGkgKz0gTE9HX0JBU0U7ICAvLyBpIDwgMVxyXG5cclxuICAgICAgICAgIGlmIChpIDwgbGVuKSB7XHJcbiAgICAgICAgICAgIGlmIChpKSB4LmMucHVzaCgrc3RyLnNsaWNlKDAsIGkpKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGVuIC09IExPR19CQVNFOyBpIDwgbGVuOykge1xyXG4gICAgICAgICAgICAgIHguYy5wdXNoKCtzdHIuc2xpY2UoaSwgaSArPSBMT0dfQkFTRSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpID0gTE9HX0JBU0UgLSAoc3RyID0gc3RyLnNsaWNlKGkpKS5sZW5ndGg7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpIC09IGxlbjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmb3IgKDsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgIHguYy5wdXNoKCtzdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gQ09OU1RSVUNUT1IgUFJPUEVSVElFU1xyXG5cclxuXHJcbiAgICBCaWdOdW1iZXIuY2xvbmUgPSBjbG9uZTtcclxuXHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfVVAgPSAwO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0RPV04gPSAxO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0NFSUwgPSAyO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0ZMT09SID0gMztcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX1VQID0gNDtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0RPV04gPSA1O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRVZFTiA9IDY7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9DRUlMID0gNztcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0ZMT09SID0gODtcclxuICAgIEJpZ051bWJlci5FVUNMSUQgPSA5O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogQ29uZmlndXJlIGluZnJlcXVlbnRseS1jaGFuZ2luZyBsaWJyYXJ5LXdpZGUgc2V0dGluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQWNjZXB0IGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgb3B0aW9uYWwgcHJvcGVydGllcyAoaWYgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaXNcclxuICAgICAqIGEgbnVtYmVyLCBpdCBtdXN0IGJlIGFuIGludGVnZXIgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2Ugc3RhdGVkKTpcclxuICAgICAqXHJcbiAgICAgKiAgIERFQ0lNQUxfUExBQ0VTICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYXHJcbiAgICAgKiAgIFJPVU5ESU5HX01PREUgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOFxyXG4gICAgICogICBFWFBPTkVOVElBTF9BVCAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAgb3IgIFstTUFYIHRvIDAsIDAgdG8gTUFYXVxyXG4gICAgICogICBSQU5HRSAgICAgICAgICAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAobm90IHplcm8pICBvciAgWy1NQVggdG8gLTEsIDEgdG8gTUFYXVxyXG4gICAgICogICBDUllQVE8gICAgICAgICAgIHtib29sZWFufSAgICAgICAgICB0cnVlIG9yIGZhbHNlXHJcbiAgICAgKiAgIE1PRFVMT19NT0RFICAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOVxyXG4gICAgICogICBQT1dfUFJFQ0lTSU9OICAgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIE1BWFxyXG4gICAgICogICBBTFBIQUJFVCAgICAgICAgIHtzdHJpbmd9ICAgICAgICAgICBBIHN0cmluZyBvZiB0d28gb3IgbW9yZSB1bmlxdWUgY2hhcmFjdGVycyB3aGljaCBkb2VzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdCBjb250YWluICcuJy5cclxuICAgICAqICAgRk9STUFUICAgICAgICAgICB7b2JqZWN0fSAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggc29tZSBvZiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICAgKiAgICAgcHJlZml4ICAgICAgICAgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGdyb3VwU2l6ZSAgICAgICAgICAgICAge251bWJlcn1cclxuICAgICAqICAgICBzZWNvbmRhcnlHcm91cFNpemUgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgZ3JvdXBTZXBhcmF0b3IgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGRlY2ltYWxTZXBhcmF0b3IgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBmcmFjdGlvbkdyb3VwU2l6ZSAgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB7c3RyaW5nfVxyXG4gICAgICogICAgIHN1ZmZpeCAgICAgICAgICAgICAgICAge3N0cmluZ31cclxuICAgICAqXHJcbiAgICAgKiAoVGhlIHZhbHVlcyBhc3NpZ25lZCB0byB0aGUgYWJvdmUgRk9STUFUIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3QgY2hlY2tlZCBmb3IgdmFsaWRpdHkuKVxyXG4gICAgICpcclxuICAgICAqIEUuZy5cclxuICAgICAqIEJpZ051bWJlci5jb25maWcoeyBERUNJTUFMX1BMQUNFUyA6IDIwLCBST1VORElOR19NT0RFIDogNCB9KVxyXG4gICAgICpcclxuICAgICAqIElnbm9yZSBwcm9wZXJ0aWVzL3BhcmFtZXRlcnMgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkLCBleGNlcHQgZm9yIEFMUEhBQkVULlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBjdXJyZW50IHZhbHVlcy5cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLmNvbmZpZyA9IEJpZ051bWJlci5zZXQgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgIHZhciBwLCB2O1xyXG5cclxuICAgICAgaWYgKG9iaiAhPSBudWxsKSB7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09ICdvYmplY3QnKSB7XHJcblxyXG4gICAgICAgICAgLy8gREVDSU1BTF9QTEFDRVMge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIERFQ0lNQUxfUExBQ0VTIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdERUNJTUFMX1BMQUNFUycpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIERFQ0lNQUxfUExBQ0VTID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBST1VORElOR19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUk9VTkRJTkdfTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUk9VTkRJTkdfTU9ERScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIDgsIHApO1xyXG4gICAgICAgICAgICBST1VORElOR19NT0RFID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBFWFBPTkVOVElBTF9BVCB7bnVtYmVyfG51bWJlcltdfVxyXG4gICAgICAgICAgLy8gSW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgICAvLyBbaW50ZWdlciAtTUFYIHRvIDAgaW5jbHVzaXZlLCAwIHRvIE1BWCBpbmNsdXNpdmVdLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEVYUE9ORU5USUFMX0FUIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdFWFBPTkVOVElBTF9BVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ICYmIHYucG9wKSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlswXSwgLU1BWCwgMCwgcCk7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBUT19FWFBfTkVHID0gdlswXTtcclxuICAgICAgICAgICAgICBUT19FWFBfUE9TID0gdlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9ORUcgPSAtKFRPX0VYUF9QT1MgPSB2IDwgMCA/IC12IDogdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSQU5HRSB7bnVtYmVyfG51bWJlcltdfSBOb24temVybyBpbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gLTEgaW5jbHVzaXZlLCBpbnRlZ2VyIDEgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUkFOR0Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfGNhbm5vdCBiZSB6ZXJvfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1JBTkdFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgJiYgdi5wb3ApIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzBdLCAtTUFYLCAtMSwgcCk7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMSwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBNSU5fRVhQID0gdlswXTtcclxuICAgICAgICAgICAgICBNQVhfRVhQID0gdlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgICBNSU5fRVhQID0gLShNQVhfRVhQID0gdiA8IDAgPyAtdiA6IHYpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIGNhbm5vdCBiZSB6ZXJvOiAnICsgdik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ1JZUFRPIHtib29sZWFufSB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIENSWVBUTyBub3QgdHJ1ZSBvciBmYWxzZToge3Z9J1xyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdDUllQVE8nKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiA9PT0gISF2KSB7XHJcbiAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvICE9ICd1bmRlZmluZWQnICYmIGNyeXB0byAmJlxyXG4gICAgICAgICAgICAgICAgIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHx8IGNyeXB0by5yYW5kb21CeXRlcykpIHtcclxuICAgICAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIENSWVBUTyA9ICF2O1xyXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBDUllQVE8gPSB2O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBub3QgdHJ1ZSBvciBmYWxzZTogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTU9EVUxPX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA5IGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBNT0RVTE9fTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnTU9EVUxPX01PREUnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCA5LCBwKTtcclxuICAgICAgICAgICAgTU9EVUxPX01PREUgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFBPV19QUkVDSVNJT04ge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFBPV19QUkVDSVNJT04ge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1BPV19QUkVDSVNJT04nKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBGT1JNQVQge29iamVjdH1cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBGT1JNQVQgbm90IGFuIG9iamVjdDoge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0ZPUk1BVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnb2JqZWN0JykgRk9STUFUID0gdjtcclxuICAgICAgICAgICAgZWxzZSB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgbm90IGFuIG9iamVjdDogJyArIHYpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEFMUEhBQkVUIHtzdHJpbmd9XHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQUxQSEFCRVQgaW52YWxpZDoge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0FMUEhBQkVUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuXHJcbiAgICAgICAgICAgIC8vIERpc2FsbG93IGlmIG9ubHkgb25lIGNoYXJhY3RlcixcclxuICAgICAgICAgICAgLy8gb3IgaWYgaXQgY29udGFpbnMgJysnLCAnLScsICcuJywgd2hpdGVzcGFjZSwgb3IgYSByZXBlYXRlZCBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnc3RyaW5nJyAmJiAhL14uJHxbKy0uXFxzXXwoLikuKlxcMS8udGVzdCh2KSkge1xyXG4gICAgICAgICAgICAgIEFMUEhBQkVUID0gdjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBpbnZhbGlkOiAnICsgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gT2JqZWN0IGV4cGVjdGVkOiB7dn0nXHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdPYmplY3QgZXhwZWN0ZWQ6ICcgKyBvYmopO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBERUNJTUFMX1BMQUNFUzogREVDSU1BTF9QTEFDRVMsXHJcbiAgICAgICAgUk9VTkRJTkdfTU9ERTogUk9VTkRJTkdfTU9ERSxcclxuICAgICAgICBFWFBPTkVOVElBTF9BVDogW1RPX0VYUF9ORUcsIFRPX0VYUF9QT1NdLFxyXG4gICAgICAgIFJBTkdFOiBbTUlOX0VYUCwgTUFYX0VYUF0sXHJcbiAgICAgICAgQ1JZUFRPOiBDUllQVE8sXHJcbiAgICAgICAgTU9EVUxPX01PREU6IE1PRFVMT19NT0RFLFxyXG4gICAgICAgIFBPV19QUkVDSVNJT046IFBPV19QUkVDSVNJT04sXHJcbiAgICAgICAgRk9STUFUOiBGT1JNQVQsXHJcbiAgICAgICAgQUxQSEFCRVQ6IEFMUEhBQkVUXHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdiBpcyBhIEJpZ051bWJlciBpbnN0YW5jZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqXHJcbiAgICAgKiBJZiBCaWdOdW1iZXIuREVCVUcgaXMgdHJ1ZSwgdGhyb3cgaWYgYSBCaWdOdW1iZXIgaW5zdGFuY2UgaXMgbm90IHdlbGwtZm9ybWVkLlxyXG4gICAgICpcclxuICAgICAqIHYge2FueX1cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gSW52YWxpZCBCaWdOdW1iZXI6IHt2fSdcclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLmlzQmlnTnVtYmVyID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgaWYgKCF2IHx8IHYuX2lzQmlnTnVtYmVyICE9PSB0cnVlKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmICghQmlnTnVtYmVyLkRFQlVHKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgIHZhciBpLCBuLFxyXG4gICAgICAgIGMgPSB2LmMsXHJcbiAgICAgICAgZSA9IHYuZSxcclxuICAgICAgICBzID0gdi5zO1xyXG5cclxuICAgICAgb3V0OiBpZiAoe30udG9TdHJpbmcuY2FsbChjKSA9PSAnW29iamVjdCBBcnJheV0nKSB7XHJcblxyXG4gICAgICAgIGlmICgocyA9PT0gMSB8fCBzID09PSAtMSkgJiYgZSA+PSAtTUFYICYmIGUgPD0gTUFYICYmIGUgPT09IG1hdGhmbG9vcihlKSkge1xyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSBmaXJzdCBlbGVtZW50IGlzIHplcm8sIHRoZSBCaWdOdW1iZXIgdmFsdWUgbXVzdCBiZSB6ZXJvLlxyXG4gICAgICAgICAgaWYgKGNbMF0gPT09IDApIHtcclxuICAgICAgICAgICAgaWYgKGUgPT09IDAgJiYgYy5sZW5ndGggPT09IDEpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBicmVhayBvdXQ7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBkaWdpdHMgdGhhdCBjWzBdIHNob3VsZCBoYXZlLCBiYXNlZCBvbiB0aGUgZXhwb25lbnQuXHJcbiAgICAgICAgICBpID0gKGUgKyAxKSAlIExPR19CQVNFO1xyXG4gICAgICAgICAgaWYgKGkgPCAxKSBpICs9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgZGlnaXRzIG9mIGNbMF0uXHJcbiAgICAgICAgICAvL2lmIChNYXRoLmNlaWwoTWF0aC5sb2coY1swXSArIDEpIC8gTWF0aC5MTjEwKSA9PSBpKSB7XHJcbiAgICAgICAgICBpZiAoU3RyaW5nKGNbMF0pLmxlbmd0aCA9PSBpKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIG4gPSBjW2ldO1xyXG4gICAgICAgICAgICAgIGlmIChuIDwgMCB8fCBuID49IEJBU0UgfHwgbiAhPT0gbWF0aGZsb29yKG4pKSBicmVhayBvdXQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIExhc3QgZWxlbWVudCBjYW5ub3QgYmUgemVybywgdW5sZXNzIGl0IGlzIHRoZSBvbmx5IGVsZW1lbnQuXHJcbiAgICAgICAgICAgIGlmIChuICE9PSAwKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAvLyBJbmZpbml0eS9OYU5cclxuICAgICAgfSBlbHNlIGlmIChjID09PSBudWxsICYmIGUgPT09IG51bGwgJiYgKHMgPT09IG51bGwgfHwgcyA9PT0gMSB8fCBzID09PSAtMSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnSW52YWxpZCBCaWdOdW1iZXI6ICcgKyB2KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtYXhpbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLm1heGltdW0gPSBCaWdOdW1iZXIubWF4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gbWF4T3JNaW4oYXJndW1lbnRzLCBQLmx0KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtaW5pbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLm1pbmltdW0gPSBCaWdOdW1iZXIubWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gbWF4T3JNaW4oYXJndW1lbnRzLCBQLmd0KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdpdGggYSByYW5kb20gdmFsdWUgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIDAgYW5kIGxlc3MgdGhhbiAxLFxyXG4gICAgICogYW5kIHdpdGggZHAsIG9yIERFQ0lNQUxfUExBQ0VTIGlmIGRwIGlzIG9taXR0ZWQsIGRlY2ltYWwgcGxhY2VzIChvciBsZXNzIGlmIHRyYWlsaW5nXHJcbiAgICAgKiB6ZXJvcyBhcmUgcHJvZHVjZWQpLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfSdcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBjcnlwdG8gdW5hdmFpbGFibGUnXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5yYW5kb20gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgcG93Ml81MyA9IDB4MjAwMDAwMDAwMDAwMDA7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gYSA1MyBiaXQgaW50ZWdlciBuLCB3aGVyZSAwIDw9IG4gPCA5MDA3MTk5MjU0NzQwOTkyLlxyXG4gICAgICAvLyBDaGVjayBpZiBNYXRoLnJhbmRvbSgpIHByb2R1Y2VzIG1vcmUgdGhhbiAzMiBiaXRzIG9mIHJhbmRvbW5lc3MuXHJcbiAgICAgIC8vIElmIGl0IGRvZXMsIGFzc3VtZSBhdCBsZWFzdCA1MyBiaXRzIGFyZSBwcm9kdWNlZCwgb3RoZXJ3aXNlIGFzc3VtZSBhdCBsZWFzdCAzMCBiaXRzLlxyXG4gICAgICAvLyAweDQwMDAwMDAwIGlzIDJeMzAsIDB4ODAwMDAwIGlzIDJeMjMsIDB4MWZmZmZmIGlzIDJeMjEgLSAxLlxyXG4gICAgICB2YXIgcmFuZG9tNTNiaXRJbnQgPSAoTWF0aC5yYW5kb20oKSAqIHBvdzJfNTMpICYgMHgxZmZmZmZcclxuICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0aGZsb29yKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKTsgfVxyXG4gICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoKE1hdGgucmFuZG9tKCkgKiAweDQwMDAwMDAwIHwgMCkgKiAweDgwMDAwMCkgK1xyXG4gICAgICAgICAoTWF0aC5yYW5kb20oKSAqIDB4ODAwMDAwIHwgMCk7IH07XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGRwKSB7XHJcbiAgICAgICAgdmFyIGEsIGIsIGUsIGssIHYsXHJcbiAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgIGMgPSBbXSxcclxuICAgICAgICAgIHJhbmQgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgICAgIGlmIChkcCA9PSBudWxsKSBkcCA9IERFQ0lNQUxfUExBQ0VTO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcblxyXG4gICAgICAgIGsgPSBtYXRoY2VpbChkcCAvIExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgaWYgKENSWVBUTykge1xyXG5cclxuICAgICAgICAgIC8vIEJyb3dzZXJzIHN1cHBvcnRpbmcgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5cclxuICAgICAgICAgIGlmIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XHJcblxyXG4gICAgICAgICAgICBhID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoayAqPSAyKSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDUzIGJpdHM6XHJcbiAgICAgICAgICAgICAgLy8gKChNYXRoLnBvdygyLCAzMikgLSAxKSAqIE1hdGgucG93KDIsIDIxKSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTEwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMFxyXG4gICAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgPj4+IDExKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExIDExMTExMTExIDExMTExMTExXHJcbiAgICAgICAgICAgICAgLy8gMHgyMDAwMCBpcyAyXjIxLlxyXG4gICAgICAgICAgICAgIHYgPSBhW2ldICogMHgyMDAwMCArIChhW2kgKyAxXSA+Pj4gMTEpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBSZWplY3Rpb24gc2FtcGxpbmc6XHJcbiAgICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICAgIC8vIFByb2JhYmlsaXR5IHRoYXQgdiA+PSA5ZTE1LCBpc1xyXG4gICAgICAgICAgICAgIC8vIDcxOTkyNTQ3NDA5OTIgLyA5MDA3MTk5MjU0NzQwOTkyIH49IDAuMDAwOCwgaS5lLiAxIGluIDEyNTFcclxuICAgICAgICAgICAgICBpZiAodiA+PSA5ZTE1KSB7XHJcbiAgICAgICAgICAgICAgICBiID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMikpO1xyXG4gICAgICAgICAgICAgICAgYVtpXSA9IGJbMF07XHJcbiAgICAgICAgICAgICAgICBhW2kgKyAxXSA9IGJbMV07XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9IHYgPD0gODk5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICBjLnB1c2godiAlIDFlMTQpO1xyXG4gICAgICAgICAgICAgICAgaSArPSAyO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gayAvIDI7XHJcblxyXG4gICAgICAgICAgLy8gTm9kZS5qcyBzdXBwb3J0aW5nIGNyeXB0by5yYW5kb21CeXRlcy5cclxuICAgICAgICAgIH0gZWxzZSBpZiAoY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBidWZmZXJcclxuICAgICAgICAgICAgYSA9IGNyeXB0by5yYW5kb21CeXRlcyhrICo9IDcpO1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyAweDEwMDAwMDAwMDAwMDAgaXMgMl40OCwgMHgxMDAwMDAwMDAwMCBpcyAyXjQwXHJcbiAgICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAgaXMgMl4zMiwgMHgxMDAwMDAwIGlzIDJeMjRcclxuICAgICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcclxuICAgICAgICAgICAgICB2ID0gKChhW2ldICYgMzEpICogMHgxMDAwMDAwMDAwMDAwKSArIChhW2kgKyAxXSAqIDB4MTAwMDAwMDAwMDApICtcclxuICAgICAgICAgICAgICAgICAoYVtpICsgMl0gKiAweDEwMDAwMDAwMCkgKyAoYVtpICsgM10gKiAweDEwMDAwMDApICtcclxuICAgICAgICAgICAgICAgICAoYVtpICsgNF0gPDwgMTYpICsgKGFbaSArIDVdIDw8IDgpICsgYVtpICsgNl07XHJcblxyXG4gICAgICAgICAgICAgIGlmICh2ID49IDllMTUpIHtcclxuICAgICAgICAgICAgICAgIGNyeXB0by5yYW5kb21CeXRlcyg3KS5jb3B5KGEsIGkpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICBjLnB1c2godiAlIDFlMTQpO1xyXG4gICAgICAgICAgICAgICAgaSArPSA3O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gayAvIDc7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBDUllQVE8gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdjcnlwdG8gdW5hdmFpbGFibGUnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVzZSBNYXRoLnJhbmRvbS5cclxuICAgICAgICBpZiAoIUNSWVBUTykge1xyXG5cclxuICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuICAgICAgICAgICAgdiA9IHJhbmRvbTUzYml0SW50KCk7XHJcbiAgICAgICAgICAgIGlmICh2IDwgOWUxNSkgY1tpKytdID0gdiAlIDFlMTQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBrID0gY1stLWldO1xyXG4gICAgICAgIGRwICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHRyYWlsaW5nIGRpZ2l0cyB0byB6ZXJvcyBhY2NvcmRpbmcgdG8gZHAuXHJcbiAgICAgICAgaWYgKGsgJiYgZHApIHtcclxuICAgICAgICAgIHYgPSBQT1dTX1RFTltMT0dfQkFTRSAtIGRwXTtcclxuICAgICAgICAgIGNbaV0gPSBtYXRoZmxvb3IoayAvIHYpICogdjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVyby5cclxuICAgICAgICBmb3IgKDsgY1tpXSA9PT0gMDsgYy5wb3AoKSwgaS0tKTtcclxuXHJcbiAgICAgICAgLy8gWmVybz9cclxuICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgIGMgPSBbZSA9IDBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8gYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICAgIGZvciAoZSA9IC0xIDsgY1swXSA9PT0gMDsgYy5zcGxpY2UoMCwgMSksIGUgLT0gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICAgIC8vIENvdW50IHRoZSBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYyB0byBkZXRlcm1pbmUgbGVhZGluZyB6ZXJvcywgYW5kLi4uXHJcbiAgICAgICAgICBmb3IgKGkgPSAxLCB2ID0gY1swXTsgdiA+PSAxMDsgdiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgICAgICAvLyBhZGp1c3QgdGhlIGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgaWYgKGkgPCBMT0dfQkFTRSkgZSAtPSBMT0dfQkFTRSAtIGk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByYW5kLmUgPSBlO1xyXG4gICAgICAgIHJhbmQuYyA9IGM7XHJcbiAgICAgICAgcmV0dXJuIHJhbmQ7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuc3VtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgaSA9IDEsXHJcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cyxcclxuICAgICAgICBzdW0gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbMF0pO1xyXG4gICAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOykgc3VtID0gc3VtLnBsdXMoYXJnc1tpKytdKTtcclxuICAgICAgcmV0dXJuIHN1bTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8vIFBSSVZBVEUgRlVOQ1RJT05TXHJcblxyXG5cclxuICAgIC8vIENhbGxlZCBieSBCaWdOdW1iZXIgYW5kIEJpZ051bWJlci5wcm90b3R5cGUudG9TdHJpbmcuXHJcbiAgICBjb252ZXJ0QmFzZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBkZWNpbWFsID0gJzAxMjM0NTY3ODknO1xyXG5cclxuICAgICAgLypcclxuICAgICAgICogQ29udmVydCBzdHJpbmcgb2YgYmFzZUluIHRvIGFuIGFycmF5IG9mIG51bWJlcnMgb2YgYmFzZU91dC5cclxuICAgICAgICogRWcuIHRvQmFzZU91dCgnMjU1JywgMTAsIDE2KSByZXR1cm5zIFsxNSwgMTVdLlxyXG4gICAgICAgKiBFZy4gdG9CYXNlT3V0KCdmZicsIDE2LCAxMCkgcmV0dXJucyBbMiwgNSwgNV0uXHJcbiAgICAgICAqL1xyXG4gICAgICBmdW5jdGlvbiB0b0Jhc2VPdXQoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIGFscGhhYmV0KSB7XHJcbiAgICAgICAgdmFyIGosXHJcbiAgICAgICAgICBhcnIgPSBbMF0sXHJcbiAgICAgICAgICBhcnJMLFxyXG4gICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICBmb3IgKDsgaSA8IGxlbjspIHtcclxuICAgICAgICAgIGZvciAoYXJyTCA9IGFyci5sZW5ndGg7IGFyckwtLTsgYXJyW2FyckxdICo9IGJhc2VJbik7XHJcblxyXG4gICAgICAgICAgYXJyWzBdICs9IGFscGhhYmV0LmluZGV4T2Yoc3RyLmNoYXJBdChpKyspKTtcclxuXHJcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgYXJyLmxlbmd0aDsgaisrKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYXJyW2pdID4gYmFzZU91dCAtIDEpIHtcclxuICAgICAgICAgICAgICBpZiAoYXJyW2ogKyAxXSA9PSBudWxsKSBhcnJbaiArIDFdID0gMDtcclxuICAgICAgICAgICAgICBhcnJbaiArIDFdICs9IGFycltqXSAvIGJhc2VPdXQgfCAwO1xyXG4gICAgICAgICAgICAgIGFycltqXSAlPSBiYXNlT3V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXJyLnJldmVyc2UoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ29udmVydCBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VJbiB0byBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VPdXQuXHJcbiAgICAgIC8vIElmIHRoZSBjYWxsZXIgaXMgdG9TdHJpbmcsIHdlIGFyZSBjb252ZXJ0aW5nIGZyb20gYmFzZSAxMCB0byBiYXNlT3V0LlxyXG4gICAgICAvLyBJZiB0aGUgY2FsbGVyIGlzIEJpZ051bWJlciwgd2UgYXJlIGNvbnZlcnRpbmcgZnJvbSBiYXNlSW4gdG8gYmFzZSAxMC5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIsIGJhc2VJbiwgYmFzZU91dCwgc2lnbiwgY2FsbGVySXNUb1N0cmluZykge1xyXG4gICAgICAgIHZhciBhbHBoYWJldCwgZCwgZSwgaywgciwgeCwgeGMsIHksXHJcbiAgICAgICAgICBpID0gc3RyLmluZGV4T2YoJy4nKSxcclxuICAgICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMsXHJcbiAgICAgICAgICBybSA9IFJPVU5ESU5HX01PREU7XHJcblxyXG4gICAgICAgIC8vIE5vbi1pbnRlZ2VyLlxyXG4gICAgICAgIGlmIChpID49IDApIHtcclxuICAgICAgICAgIGsgPSBQT1dfUFJFQ0lTSU9OO1xyXG5cclxuICAgICAgICAgIC8vIFVubGltaXRlZCBwcmVjaXNpb24uXHJcbiAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gMDtcclxuICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoYmFzZUluKTtcclxuICAgICAgICAgIHggPSB5LnBvdyhzdHIubGVuZ3RoIC0gaSk7XHJcbiAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gaztcclxuXHJcbiAgICAgICAgICAvLyBDb252ZXJ0IHN0ciBhcyBpZiBhbiBpbnRlZ2VyLCB0aGVuIHJlc3RvcmUgdGhlIGZyYWN0aW9uIHBhcnQgYnkgZGl2aWRpbmcgdGhlXHJcbiAgICAgICAgICAvLyByZXN1bHQgYnkgaXRzIGJhc2UgcmFpc2VkIHRvIGEgcG93ZXIuXHJcblxyXG4gICAgICAgICAgeS5jID0gdG9CYXNlT3V0KHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKHguYyksIHguZSwgJzAnKSxcclxuICAgICAgICAgICAxMCwgYmFzZU91dCwgZGVjaW1hbCk7XHJcbiAgICAgICAgICB5LmUgPSB5LmMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29udmVydCB0aGUgbnVtYmVyIGFzIGludGVnZXIuXHJcblxyXG4gICAgICAgIHhjID0gdG9CYXNlT3V0KHN0ciwgYmFzZUluLCBiYXNlT3V0LCBjYWxsZXJJc1RvU3RyaW5nXHJcbiAgICAgICAgID8gKGFscGhhYmV0ID0gQUxQSEFCRVQsIGRlY2ltYWwpXHJcbiAgICAgICAgIDogKGFscGhhYmV0ID0gZGVjaW1hbCwgQUxQSEFCRVQpKTtcclxuXHJcbiAgICAgICAgLy8geGMgbm93IHJlcHJlc2VudHMgc3RyIGFzIGFuIGludGVnZXIgYW5kIGNvbnZlcnRlZCB0byBiYXNlT3V0LiBlIGlzIHRoZSBleHBvbmVudC5cclxuICAgICAgICBlID0gayA9IHhjLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoOyB4Y1stLWtdID09IDA7IHhjLnBvcCgpKTtcclxuXHJcbiAgICAgICAgLy8gWmVybz9cclxuICAgICAgICBpZiAoIXhjWzBdKSByZXR1cm4gYWxwaGFiZXQuY2hhckF0KDApO1xyXG5cclxuICAgICAgICAvLyBEb2VzIHN0ciByZXByZXNlbnQgYW4gaW50ZWdlcj8gSWYgc28sIG5vIG5lZWQgZm9yIHRoZSBkaXZpc2lvbi5cclxuICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgIC0tZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5jID0geGM7XHJcbiAgICAgICAgICB4LmUgPSBlO1xyXG5cclxuICAgICAgICAgIC8vIFRoZSBzaWduIGlzIG5lZWRlZCBmb3IgY29ycmVjdCByb3VuZGluZy5cclxuICAgICAgICAgIHgucyA9IHNpZ247XHJcbiAgICAgICAgICB4ID0gZGl2KHgsIHksIGRwLCBybSwgYmFzZU91dCk7XHJcbiAgICAgICAgICB4YyA9IHguYztcclxuICAgICAgICAgIHIgPSB4LnI7XHJcbiAgICAgICAgICBlID0geC5lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8geGMgbm93IHJlcHJlc2VudHMgc3RyIGNvbnZlcnRlZCB0byBiYXNlT3V0LlxyXG5cclxuICAgICAgICAvLyBUSGUgaW5kZXggb2YgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgIGQgPSBlICsgZHAgKyAxO1xyXG5cclxuICAgICAgICAvLyBUaGUgcm91bmRpbmcgZGlnaXQ6IHRoZSBkaWdpdCB0byB0aGUgcmlnaHQgb2YgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgaSA9IHhjW2RdO1xyXG5cclxuICAgICAgICAvLyBMb29rIGF0IHRoZSByb3VuZGluZyBkaWdpdHMgYW5kIG1vZGUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcm91bmQgdXAuXHJcblxyXG4gICAgICAgIGsgPSBiYXNlT3V0IC8gMjtcclxuICAgICAgICByID0gciB8fCBkIDwgMCB8fCB4Y1tkICsgMV0gIT0gbnVsbDtcclxuXHJcbiAgICAgICAgciA9IHJtIDwgNCA/IChpICE9IG51bGwgfHwgcikgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgICAgICAgICAgOiBpID4gayB8fCBpID09IGsgJiYocm0gPT0gNCB8fCByIHx8IHJtID09IDYgJiYgeGNbZCAtIDFdICYgMSB8fFxyXG4gICAgICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBpbmRleCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgbm90IGdyZWF0ZXIgdGhhbiB6ZXJvLCBvciB4YyByZXByZXNlbnRzXHJcbiAgICAgICAgLy8gemVybywgdGhlbiB0aGUgcmVzdWx0IG9mIHRoZSBiYXNlIGNvbnZlcnNpb24gaXMgemVybyBvciwgaWYgcm91bmRpbmcgdXAsIGEgdmFsdWVcclxuICAgICAgICAvLyBzdWNoIGFzIDAuMDAwMDEuXHJcbiAgICAgICAgaWYgKGQgPCAxIHx8ICF4Y1swXSkge1xyXG5cclxuICAgICAgICAgIC8vIDFeLWRwIG9yIDBcclxuICAgICAgICAgIHN0ciA9IHIgPyB0b0ZpeGVkUG9pbnQoYWxwaGFiZXQuY2hhckF0KDEpLCAtZHAsIGFscGhhYmV0LmNoYXJBdCgwKSkgOiBhbHBoYWJldC5jaGFyQXQoMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyBUcnVuY2F0ZSB4YyB0byB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgeGMubGVuZ3RoID0gZDtcclxuXHJcbiAgICAgICAgICAvLyBSb3VuZCB1cD9cclxuICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBSb3VuZGluZyB1cCBtYXkgbWVhbiB0aGUgcHJldmlvdXMgZGlnaXQgaGFzIHRvIGJlIHJvdW5kZWQgdXAgYW5kIHNvIG9uLlxyXG4gICAgICAgICAgICBmb3IgKC0tYmFzZU91dDsgKyt4Y1stLWRdID4gYmFzZU91dDspIHtcclxuICAgICAgICAgICAgICB4Y1tkXSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgIGlmICghZCkge1xyXG4gICAgICAgICAgICAgICAgKytlO1xyXG4gICAgICAgICAgICAgICAgeGMgPSBbMV0uY29uY2F0KHhjKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICBmb3IgKGsgPSB4Yy5sZW5ndGg7ICF4Y1stLWtdOyk7XHJcblxyXG4gICAgICAgICAgLy8gRS5nLiBbNCwgMTEsIDE1XSBiZWNvbWVzIDRiZi5cclxuICAgICAgICAgIGZvciAoaSA9IDAsIHN0ciA9ICcnOyBpIDw9IGs7IHN0ciArPSBhbHBoYWJldC5jaGFyQXQoeGNbaSsrXSkpO1xyXG5cclxuICAgICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm9zLCBkZWNpbWFsIHBvaW50IGFuZCB0cmFpbGluZyB6ZXJvcyBhcyByZXF1aXJlZC5cclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChzdHIsIGUsIGFscGhhYmV0LmNoYXJBdCgwKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUaGUgY2FsbGVyIHdpbGwgYWRkIHRoZSBzaWduLlxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvLyBQZXJmb3JtIGRpdmlzaW9uIGluIHRoZSBzcGVjaWZpZWQgYmFzZS4gQ2FsbGVkIGJ5IGRpdiBhbmQgY29udmVydEJhc2UuXHJcbiAgICBkaXYgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgLy8gQXNzdW1lIG5vbi16ZXJvIHggYW5kIGsuXHJcbiAgICAgIGZ1bmN0aW9uIG11bHRpcGx5KHgsIGssIGJhc2UpIHtcclxuICAgICAgICB2YXIgbSwgdGVtcCwgeGxvLCB4aGksXHJcbiAgICAgICAgICBjYXJyeSA9IDAsXHJcbiAgICAgICAgICBpID0geC5sZW5ndGgsXHJcbiAgICAgICAgICBrbG8gPSBrICUgU1FSVF9CQVNFLFxyXG4gICAgICAgICAga2hpID0gayAvIFNRUlRfQkFTRSB8IDA7XHJcblxyXG4gICAgICAgIGZvciAoeCA9IHguc2xpY2UoKTsgaS0tOykge1xyXG4gICAgICAgICAgeGxvID0geFtpXSAlIFNRUlRfQkFTRTtcclxuICAgICAgICAgIHhoaSA9IHhbaV0gLyBTUVJUX0JBU0UgfCAwO1xyXG4gICAgICAgICAgbSA9IGtoaSAqIHhsbyArIHhoaSAqIGtsbztcclxuICAgICAgICAgIHRlbXAgPSBrbG8gKiB4bG8gKyAoKG0gJSBTUVJUX0JBU0UpICogU1FSVF9CQVNFKSArIGNhcnJ5O1xyXG4gICAgICAgICAgY2FycnkgPSAodGVtcCAvIGJhc2UgfCAwKSArIChtIC8gU1FSVF9CQVNFIHwgMCkgKyBraGkgKiB4aGk7XHJcbiAgICAgICAgICB4W2ldID0gdGVtcCAlIGJhc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY2FycnkpIHggPSBbY2FycnldLmNvbmNhdCh4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYiwgYUwsIGJMKSB7XHJcbiAgICAgICAgdmFyIGksIGNtcDtcclxuXHJcbiAgICAgICAgaWYgKGFMICE9IGJMKSB7XHJcbiAgICAgICAgICBjbXAgPSBhTCA+IGJMID8gMSA6IC0xO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgZm9yIChpID0gY21wID0gMDsgaSA8IGFMOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChhW2ldICE9IGJbaV0pIHtcclxuICAgICAgICAgICAgICBjbXAgPSBhW2ldID4gYltpXSA/IDEgOiAtMTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYiwgYUwsIGJhc2UpIHtcclxuICAgICAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgICAgIC8vIFN1YnRyYWN0IGIgZnJvbSBhLlxyXG4gICAgICAgIGZvciAoOyBhTC0tOykge1xyXG4gICAgICAgICAgYVthTF0gLT0gaTtcclxuICAgICAgICAgIGkgPSBhW2FMXSA8IGJbYUxdID8gMSA6IDA7XHJcbiAgICAgICAgICBhW2FMXSA9IGkgKiBiYXNlICsgYVthTF0gLSBiW2FMXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoOyAhYVswXSAmJiBhLmxlbmd0aCA+IDE7IGEuc3BsaWNlKDAsIDEpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8geDogZGl2aWRlbmQsIHk6IGRpdmlzb3IuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSwgZHAsIHJtLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIGNtcCwgZSwgaSwgbW9yZSwgbiwgcHJvZCwgcHJvZEwsIHEsIHFjLCByZW0sIHJlbUwsIHJlbTAsIHhpLCB4TCwgeWMwLFxyXG4gICAgICAgICAgeUwsIHl6LFxyXG4gICAgICAgICAgcyA9IHgucyA9PSB5LnMgPyAxIDogLTEsXHJcbiAgICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgTmFOLCBJbmZpbml0eSBvciAwP1xyXG4gICAgICAgIGlmICgheGMgfHwgIXhjWzBdIHx8ICF5YyB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihcclxuXHJcbiAgICAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgTmFOLCBvciBib3RoIEluZmluaXR5IG9yIDAuXHJcbiAgICAgICAgICAgIXgucyB8fCAheS5zIHx8ICh4YyA/IHljICYmIHhjWzBdID09IHljWzBdIDogIXljKSA/IE5hTiA6XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIHggaXMgwrEwIG9yIHkgaXMgwrFJbmZpbml0eSwgb3IgcmV0dXJuIMKxSW5maW5pdHkgYXMgeSBpcyDCsTAuXHJcbiAgICAgICAgICAgIHhjICYmIHhjWzBdID09IDAgfHwgIXljID8gcyAqIDAgOiBzIC8gMFxyXG4gICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcSA9IG5ldyBCaWdOdW1iZXIocyk7XHJcbiAgICAgICAgcWMgPSBxLmMgPSBbXTtcclxuICAgICAgICBlID0geC5lIC0geS5lO1xyXG4gICAgICAgIHMgPSBkcCArIGUgKyAxO1xyXG5cclxuICAgICAgICBpZiAoIWJhc2UpIHtcclxuICAgICAgICAgIGJhc2UgPSBCQVNFO1xyXG4gICAgICAgICAgZSA9IGJpdEZsb29yKHguZSAvIExPR19CQVNFKSAtIGJpdEZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgICAgICAgIHMgPSBzIC8gTE9HX0JBU0UgfCAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVzdWx0IGV4cG9uZW50IG1heSBiZSBvbmUgbGVzcyB0aGVuIHRoZSBjdXJyZW50IHZhbHVlIG9mIGUuXHJcbiAgICAgICAgLy8gVGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgQmlnTnVtYmVycyBmcm9tIGNvbnZlcnRCYXNlIG1heSBoYXZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoaSA9IDA7IHljW2ldID09ICh4Y1tpXSB8fCAwKTsgaSsrKTtcclxuXHJcbiAgICAgICAgaWYgKHljW2ldID4gKHhjW2ldIHx8IDApKSBlLS07XHJcblxyXG4gICAgICAgIGlmIChzIDwgMCkge1xyXG4gICAgICAgICAgcWMucHVzaCgxKTtcclxuICAgICAgICAgIG1vcmUgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4TCA9IHhjLmxlbmd0aDtcclxuICAgICAgICAgIHlMID0geWMubGVuZ3RoO1xyXG4gICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICBzICs9IDI7XHJcblxyXG4gICAgICAgICAgLy8gTm9ybWFsaXNlIHhjIGFuZCB5YyBzbyBoaWdoZXN0IG9yZGVyIGRpZ2l0IG9mIHljIGlzID49IGJhc2UgLyAyLlxyXG5cclxuICAgICAgICAgIG4gPSBtYXRoZmxvb3IoYmFzZSAvICh5Y1swXSArIDEpKTtcclxuXHJcbiAgICAgICAgICAvLyBOb3QgbmVjZXNzYXJ5LCBidXQgdG8gaGFuZGxlIG9kZCBiYXNlcyB3aGVyZSB5Y1swXSA9PSAoYmFzZSAvIDIpIC0gMS5cclxuICAgICAgICAgIC8vIGlmIChuID4gMSB8fCBuKysgPT0gMSAmJiB5Y1swXSA8IGJhc2UgLyAyKSB7XHJcbiAgICAgICAgICBpZiAobiA+IDEpIHtcclxuICAgICAgICAgICAgeWMgPSBtdWx0aXBseSh5YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgIHhjID0gbXVsdGlwbHkoeGMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgeGkgPSB5TDtcclxuICAgICAgICAgIHJlbSA9IHhjLnNsaWNlKDAsIHlMKTtcclxuICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgIC8vIEFkZCB6ZXJvcyB0byBtYWtlIHJlbWFpbmRlciBhcyBsb25nIGFzIGRpdmlzb3IuXHJcbiAgICAgICAgICBmb3IgKDsgcmVtTCA8IHlMOyByZW1bcmVtTCsrXSA9IDApO1xyXG4gICAgICAgICAgeXogPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgeXogPSBbMF0uY29uY2F0KHl6KTtcclxuICAgICAgICAgIHljMCA9IHljWzBdO1xyXG4gICAgICAgICAgaWYgKHljWzFdID49IGJhc2UgLyAyKSB5YzArKztcclxuICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBwcmV2ZW50IHRyaWFsIGRpZ2l0IG4gPiBiYXNlLCB3aGVuIHVzaW5nIGJhc2UgMy5cclxuICAgICAgICAgIC8vIGVsc2UgaWYgKGJhc2UgPT0gMyAmJiB5YzAgPT0gMSkgeWMwID0gMSArIDFlLTE1O1xyXG5cclxuICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgbiA9IDA7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgY21wID0gY29tcGFyZSh5YywgcmVtLCB5TCwgcmVtTCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xyXG5cclxuICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdHJpYWwgZGlnaXQsIG4uXHJcblxyXG4gICAgICAgICAgICAgIHJlbTAgPSByZW1bMF07XHJcbiAgICAgICAgICAgICAgaWYgKHlMICE9IHJlbUwpIHJlbTAgPSByZW0wICogYmFzZSArIChyZW1bMV0gfHwgMCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIG4gaXMgaG93IG1hbnkgdGltZXMgdGhlIGRpdmlzb3IgZ29lcyBpbnRvIHRoZSBjdXJyZW50IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBuID0gbWF0aGZsb29yKHJlbTAgLyB5YzApO1xyXG5cclxuICAgICAgICAgICAgICAvLyAgQWxnb3JpdGhtOlxyXG4gICAgICAgICAgICAgIC8vICBwcm9kdWN0ID0gZGl2aXNvciBtdWx0aXBsaWVkIGJ5IHRyaWFsIGRpZ2l0IChuKS5cclxuICAgICAgICAgICAgICAvLyAgQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgLy8gIElmIHByb2R1Y3QgaXMgZ3JlYXRlciB0aGFuIHJlbWFpbmRlcjpcclxuICAgICAgICAgICAgICAvLyAgICBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdCwgZGVjcmVtZW50IHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAgIC8vICBTdWJ0cmFjdCBwcm9kdWN0IGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vICBJZiBwcm9kdWN0IHdhcyBsZXNzIHRoYW4gcmVtYWluZGVyIGF0IHRoZSBsYXN0IGNvbXBhcmU6XHJcbiAgICAgICAgICAgICAgLy8gICAgQ29tcGFyZSBuZXcgcmVtYWluZGVyIGFuZCBkaXZpc29yLlxyXG4gICAgICAgICAgICAgIC8vICAgIElmIHJlbWFpbmRlciBpcyBncmVhdGVyIHRoYW4gZGl2aXNvcjpcclxuICAgICAgICAgICAgICAvLyAgICAgIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIsIGluY3JlbWVudCB0cmlhbCBkaWdpdC5cclxuXHJcbiAgICAgICAgICAgICAgaWYgKG4gPiAxKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbiBtYXkgYmUgPiBiYXNlIG9ubHkgd2hlbiBiYXNlIGlzIDMuXHJcbiAgICAgICAgICAgICAgICBpZiAobiA+PSBiYXNlKSBuID0gYmFzZSAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3IgKiB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICAgIHByb2QgPSBtdWx0aXBseSh5YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBwcm9kdWN0ID4gcmVtYWluZGVyIHRoZW4gdHJpYWwgZGlnaXQgbiB0b28gaGlnaC5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gaGlnaCBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIGlzIG5vdCBrbm93biB0byBoYXZlXHJcbiAgICAgICAgICAgICAgICAvLyBldmVyIGJlZW4gbW9yZSB0aGFuIDEgdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZShwcm9kLCByZW0sIHByb2RMLCByZW1MKSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIG4tLTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LlxyXG4gICAgICAgICAgICAgICAgICBzdWJ0cmFjdChwcm9kLCB5TCA8IHByb2RMID8geXogOiB5YywgcHJvZEwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICBjbXAgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAwIG9yIDEsIGNtcCBpcyAtMS5cclxuICAgICAgICAgICAgICAgIC8vIElmIG4gaXMgMCwgdGhlcmUgaXMgbm8gbmVlZCB0byBjb21wYXJlIHljIGFuZCByZW0gYWdhaW4gYmVsb3csXHJcbiAgICAgICAgICAgICAgICAvLyBzbyBjaGFuZ2UgY21wIHRvIDEgdG8gYXZvaWQgaXQuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDEsIGxlYXZlIGNtcCBhcyAtMSwgc28geWMgYW5kIHJlbSBhcmUgY29tcGFyZWQgYWdhaW4uXHJcbiAgICAgICAgICAgICAgICBpZiAobiA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBkaXZpc29yIDwgcmVtYWluZGVyLCBzbyBuIG11c3QgYmUgYXQgbGVhc3QgMS5cclxuICAgICAgICAgICAgICAgICAgY21wID0gbiA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3JcclxuICAgICAgICAgICAgICAgIHByb2QgPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGlmIChwcm9kTCA8IHJlbUwpIHByb2QgPSBbMF0uY29uY2F0KHByb2QpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBwcm9kdWN0IGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgcHJvZCwgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAvLyBJZiBwcm9kdWN0IHdhcyA8IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBpZiAoY21wID09IC0xKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCBuZXcgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IG5ldyByZW1haW5kZXIsIHN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBUcmlhbCBkaWdpdCBuIHRvbyBsb3cuXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGxvdyBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIHZlcnkgcmFyZWx5IDIgdG9vIGxvdy5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKHljLCByZW0sIHlMLCByZW1MKSA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgbisrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgICAgc3VidHJhY3QocmVtLCB5TCA8IHJlbUwgPyB5eiA6IHljLCByZW1MLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgIG4rKztcclxuICAgICAgICAgICAgICByZW0gPSBbMF07XHJcbiAgICAgICAgICAgIH0gLy8gZWxzZSBjbXAgPT09IDEgYW5kIG4gd2lsbCBiZSAwXHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIG5leHQgZGlnaXQsIG4sIHRvIHRoZSByZXN1bHQgYXJyYXkuXHJcbiAgICAgICAgICAgIHFjW2krK10gPSBuO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChyZW1bMF0pIHtcclxuICAgICAgICAgICAgICByZW1bcmVtTCsrXSA9IHhjW3hpXSB8fCAwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJlbSA9IFt4Y1t4aV1dO1xyXG4gICAgICAgICAgICAgIHJlbUwgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IHdoaWxlICgoeGkrKyA8IHhMIHx8IHJlbVswXSAhPSBudWxsKSAmJiBzLS0pO1xyXG5cclxuICAgICAgICAgIG1vcmUgPSByZW1bMF0gIT0gbnVsbDtcclxuXHJcbiAgICAgICAgICAvLyBMZWFkaW5nIHplcm8/XHJcbiAgICAgICAgICBpZiAoIXFjWzBdKSBxYy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYmFzZSA9PSBCQVNFKSB7XHJcblxyXG4gICAgICAgICAgLy8gVG8gY2FsY3VsYXRlIHEuZSwgZmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHFjWzBdLlxyXG4gICAgICAgICAgZm9yIChpID0gMSwgcyA9IHFjWzBdOyBzID49IDEwOyBzIC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgICAgIHJvdW5kKHEsIGRwICsgKHEuZSA9IGkgKyBlICogTE9HX0JBU0UgLSAxKSArIDEsIHJtLCBtb3JlKTtcclxuXHJcbiAgICAgICAgLy8gQ2FsbGVyIGlzIGNvbnZlcnRCYXNlLlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBxLmUgPSBlO1xyXG4gICAgICAgICAgcS5yID0gK21vcmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcTtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIgbiBpbiBmaXhlZC1wb2ludCBvciBleHBvbmVudGlhbFxyXG4gICAgICogbm90YXRpb24gcm91bmRlZCB0byB0aGUgc3BlY2lmaWVkIGRlY2ltYWwgcGxhY2VzIG9yIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgICAqXHJcbiAgICAgKiBuOiBhIEJpZ051bWJlci5cclxuICAgICAqIGk6IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBkaWdpdCByZXF1aXJlZCAoaS5lLiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cCkuXHJcbiAgICAgKiBybTogdGhlIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAgKiBpZDogMSAodG9FeHBvbmVudGlhbCkgb3IgMiAodG9QcmVjaXNpb24pLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmb3JtYXQobiwgaSwgcm0sIGlkKSB7XHJcbiAgICAgIHZhciBjMCwgZSwgbmUsIGxlbiwgc3RyO1xyXG5cclxuICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICBpZiAoIW4uYykgcmV0dXJuIG4udG9TdHJpbmcoKTtcclxuXHJcbiAgICAgIGMwID0gbi5jWzBdO1xyXG4gICAgICBuZSA9IG4uZTtcclxuXHJcbiAgICAgIGlmIChpID09IG51bGwpIHtcclxuICAgICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcbiAgICAgICAgc3RyID0gaWQgPT0gMSB8fCBpZCA9PSAyICYmIChuZSA8PSBUT19FWFBfTkVHIHx8IG5lID49IFRPX0VYUF9QT1MpXHJcbiAgICAgICAgID8gdG9FeHBvbmVudGlhbChzdHIsIG5lKVxyXG4gICAgICAgICA6IHRvRml4ZWRQb2ludChzdHIsIG5lLCAnMCcpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG4gPSByb3VuZChuZXcgQmlnTnVtYmVyKG4pLCBpLCBybSk7XHJcblxyXG4gICAgICAgIC8vIG4uZSBtYXkgaGF2ZSBjaGFuZ2VkIGlmIHRoZSB2YWx1ZSB3YXMgcm91bmRlZCB1cC5cclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcbiAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gdG9QcmVjaXNpb24gcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbiBpZiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAgICAgIC8vIHNwZWNpZmllZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHMgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlclxyXG4gICAgICAgIC8vIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLlxyXG5cclxuICAgICAgICAvLyBFeHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgICBpZiAoaWQgPT0gMSB8fCBpZCA9PSAyICYmIChpIDw9IGUgfHwgZSA8PSBUT19FWFBfTkVHKSkge1xyXG5cclxuICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcz9cclxuICAgICAgICAgIGZvciAoOyBsZW4gPCBpOyBzdHIgKz0gJzAnLCBsZW4rKyk7XHJcbiAgICAgICAgICBzdHIgPSB0b0V4cG9uZW50aWFsKHN0ciwgZSk7XHJcblxyXG4gICAgICAgIC8vIEZpeGVkLXBvaW50IG5vdGF0aW9uLlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpIC09IG5lO1xyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KHN0ciwgZSwgJzAnKTtcclxuXHJcbiAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgICBpZiAoZSArIDEgPiBsZW4pIHtcclxuICAgICAgICAgICAgaWYgKC0taSA+IDApIGZvciAoc3RyICs9ICcuJzsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgKz0gZSAtIGxlbjtcclxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGUgKyAxID09IGxlbikgc3RyICs9ICcuJztcclxuICAgICAgICAgICAgICBmb3IgKDsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG4ucyA8IDAgJiYgYzAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEhhbmRsZSBCaWdOdW1iZXIubWF4IGFuZCBCaWdOdW1iZXIubWluLlxyXG4gICAgZnVuY3Rpb24gbWF4T3JNaW4oYXJncywgbWV0aG9kKSB7XHJcbiAgICAgIHZhciBuLFxyXG4gICAgICAgIGkgPSAxLFxyXG4gICAgICAgIG0gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbMF0pO1xyXG5cclxuICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbiA9IG5ldyBCaWdOdW1iZXIoYXJnc1tpXSk7XHJcblxyXG4gICAgICAgIC8vIElmIGFueSBudW1iZXIgaXMgTmFOLCByZXR1cm4gTmFOLlxyXG4gICAgICAgIGlmICghbi5zKSB7XHJcbiAgICAgICAgICBtID0gbjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kLmNhbGwobSwgbikpIHtcclxuICAgICAgICAgIG0gPSBuO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG07XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBTdHJpcCB0cmFpbGluZyB6ZXJvcywgY2FsY3VsYXRlIGJhc2UgMTAgZXhwb25lbnQgYW5kIGNoZWNrIGFnYWluc3QgTUlOX0VYUCBhbmQgTUFYX0VYUC5cclxuICAgICAqIENhbGxlZCBieSBtaW51cywgcGx1cyBhbmQgdGltZXMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG5vcm1hbGlzZShuLCBjLCBlKSB7XHJcbiAgICAgIHZhciBpID0gMSxcclxuICAgICAgICBqID0gYy5sZW5ndGg7XHJcblxyXG4gICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKDsgIWNbLS1qXTsgYy5wb3AoKSk7XHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGJhc2UgMTAgZXhwb25lbnQuIEZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgICBmb3IgKGogPSBjWzBdOyBqID49IDEwOyBqIC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgIGlmICgoZSA9IGkgKyBlICogTE9HX0JBU0UgLSAxKSA+IE1BWF9FWFApIHtcclxuXHJcbiAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgbi5jID0gbi5lID0gbnVsbDtcclxuXHJcbiAgICAgIC8vIFVuZGVyZmxvdz9cclxuICAgICAgfSBlbHNlIGlmIChlIDwgTUlOX0VYUCkge1xyXG5cclxuICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgIG4uYyA9IFtuLmUgPSAwXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuLmUgPSBlO1xyXG4gICAgICAgIG4uYyA9IGM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBIYW5kbGUgdmFsdWVzIHRoYXQgZmFpbCB0aGUgdmFsaWRpdHkgdGVzdCBpbiBCaWdOdW1iZXIuXHJcbiAgICBwYXJzZU51bWVyaWMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2ksXHJcbiAgICAgICAgZG90QWZ0ZXIgPSAvXihbXi5dKylcXC4kLyxcclxuICAgICAgICBkb3RCZWZvcmUgPSAvXlxcLihbXi5dKykkLyxcclxuICAgICAgICBpc0luZmluaXR5T3JOYU4gPSAvXi0/KEluZmluaXR5fE5hTikkLyxcclxuICAgICAgICB3aGl0ZXNwYWNlT3JQbHVzID0gL15cXHMqXFwrKD89W1xcdy5dKXxeXFxzK3xcXHMrJC9nO1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCBzdHIsIGlzTnVtLCBiKSB7XHJcbiAgICAgICAgdmFyIGJhc2UsXHJcbiAgICAgICAgICBzID0gaXNOdW0gPyBzdHIgOiBzdHIucmVwbGFjZSh3aGl0ZXNwYWNlT3JQbHVzLCAnJyk7XHJcblxyXG4gICAgICAgIC8vIE5vIGV4Y2VwdGlvbiBvbiDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAgICBpZiAoaXNJbmZpbml0eU9yTmFOLnRlc3QocykpIHtcclxuICAgICAgICAgIHgucyA9IGlzTmFOKHMpID8gbnVsbCA6IHMgPCAwID8gLTEgOiAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAoIWlzTnVtKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBiYXNlUHJlZml4ID0gL14oLT8pMChbeGJvXSkoPz1cXHdbXFx3Ll0qJCkvaVxyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKGJhc2VQcmVmaXgsIGZ1bmN0aW9uIChtLCBwMSwgcDIpIHtcclxuICAgICAgICAgICAgICBiYXNlID0gKHAyID0gcDIudG9Mb3dlckNhc2UoKSkgPT0gJ3gnID8gMTYgOiBwMiA9PSAnYicgPyAyIDogODtcclxuICAgICAgICAgICAgICByZXR1cm4gIWIgfHwgYiA9PSBiYXNlID8gcDEgOiBtO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChiKSB7XHJcbiAgICAgICAgICAgICAgYmFzZSA9IGI7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEUuZy4gJzEuJyB0byAnMScsICcuMScgdG8gJzAuMSdcclxuICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKGRvdEFmdGVyLCAnJDEnKS5yZXBsYWNlKGRvdEJlZm9yZSwgJzAuJDEnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHN0ciAhPSBzKSByZXR1cm4gbmV3IEJpZ051bWJlcihzLCBiYXNlKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTm90IGEgbnVtYmVyOiB7bn0nXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTm90IGEgYmFzZSB7Yn0gbnVtYmVyOiB7bn0nXHJcbiAgICAgICAgICBpZiAoQmlnTnVtYmVyLkRFQlVHKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ05vdCBhJyArIChiID8gJyBiYXNlICcgKyBiIDogJycpICsgJyBudW1iZXI6ICcgKyBzdHIpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIE5hTlxyXG4gICAgICAgICAgeC5zID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSb3VuZCB4IHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLiBDaGVjayBmb3Igb3Zlci91bmRlci1mbG93LlxyXG4gICAgICogSWYgciBpcyB0cnV0aHksIGl0IGlzIGtub3duIHRoYXQgdGhlcmUgYXJlIG1vcmUgZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcm91bmQoeCwgc2QsIHJtLCByKSB7XHJcbiAgICAgIHZhciBkLCBpLCBqLCBrLCBuLCBuaSwgcmQsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgcG93czEwID0gUE9XU19URU47XHJcblxyXG4gICAgICAvLyBpZiB4IGlzIG5vdCBJbmZpbml0eSBvciBOYU4uLi5cclxuICAgICAgaWYgKHhjKSB7XHJcblxyXG4gICAgICAgIC8vIHJkIGlzIHRoZSByb3VuZGluZyBkaWdpdCwgaS5lLiB0aGUgZGlnaXQgYWZ0ZXIgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgLy8gbiBpcyBhIGJhc2UgMWUxNCBudW1iZXIsIHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCBvZiBhcnJheSB4LmMgY29udGFpbmluZyByZC5cclxuICAgICAgICAvLyBuaSBpcyB0aGUgaW5kZXggb2YgbiB3aXRoaW4geC5jLlxyXG4gICAgICAgIC8vIGQgaXMgdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygbi5cclxuICAgICAgICAvLyBpIGlzIHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiBpbmNsdWRpbmcgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAvLyBqIGlzIHRoZSBhY3R1YWwgaW5kZXggb2YgcmQgd2l0aGluIG4gKGlmIDwgMCwgcmQgaXMgYSBsZWFkaW5nIHplcm8pLlxyXG4gICAgICAgIG91dDoge1xyXG5cclxuICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy5cclxuICAgICAgICAgIGZvciAoZCA9IDEsIGsgPSB4Y1swXTsgayA+PSAxMDsgayAvPSAxMCwgZCsrKTtcclxuICAgICAgICAgIGkgPSBzZCAtIGQ7XHJcblxyXG4gICAgICAgICAgLy8gSWYgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgICAgaSArPSBMT0dfQkFTRTtcclxuICAgICAgICAgICAgaiA9IHNkO1xyXG4gICAgICAgICAgICBuID0geGNbbmkgPSAwXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxyXG4gICAgICAgICAgICByZCA9IG4gLyBwb3dzMTBbZCAtIGogLSAxXSAlIDEwIHwgMDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5pID0gbWF0aGNlaWwoKGkgKyAxKSAvIExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChuaSA+PSB4Yy5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOZWVkZWQgYnkgc3FydC5cclxuICAgICAgICAgICAgICAgIGZvciAoOyB4Yy5sZW5ndGggPD0gbmk7IHhjLnB1c2goMCkpO1xyXG4gICAgICAgICAgICAgICAgbiA9IHJkID0gMDtcclxuICAgICAgICAgICAgICAgIGQgPSAxO1xyXG4gICAgICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuICAgICAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyAxO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhayBvdXQ7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIG4gPSBrID0geGNbbmldO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygbi5cclxuICAgICAgICAgICAgICBmb3IgKGQgPSAxOyBrID49IDEwOyBrIC89IDEwLCBkKyspO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuLlxyXG4gICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4sIGFkanVzdGVkIGZvciBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgICAgICAgIC8vIFRoZSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiBuIGlzIGdpdmVuIGJ5IExPR19CQVNFIC0gZC5cclxuICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgZDtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICAgICAgcmQgPSBqIDwgMCA/IDAgOiBuIC8gcG93czEwW2QgLSBqIC0gMV0gJSAxMCB8IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByID0gciB8fCBzZCA8IDAgfHxcclxuXHJcbiAgICAgICAgICAvLyBBcmUgdGhlcmUgYW55IG5vbi16ZXJvIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQ/XHJcbiAgICAgICAgICAvLyBUaGUgZXhwcmVzc2lvbiAgbiAlIHBvd3MxMFtkIC0gaiAtIDFdICByZXR1cm5zIGFsbCBkaWdpdHMgb2YgbiB0byB0aGUgcmlnaHRcclxuICAgICAgICAgIC8vIG9mIHRoZSBkaWdpdCBhdCBqLCBlLmcuIGlmIG4gaXMgOTA4NzE0IGFuZCBqIGlzIDIsIHRoZSBleHByZXNzaW9uIGdpdmVzIDcxNC5cclxuICAgICAgICAgICB4Y1tuaSArIDFdICE9IG51bGwgfHwgKGogPCAwID8gbiA6IG4gJSBwb3dzMTBbZCAtIGogLSAxXSk7XHJcblxyXG4gICAgICAgICAgciA9IHJtIDwgNFxyXG4gICAgICAgICAgID8gKHJkIHx8IHIpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICAgIDogcmQgPiA1IHx8IHJkID09IDUgJiYgKHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmXHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBkaWdpdCB0byB0aGUgbGVmdCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgb2RkLlxyXG4gICAgICAgICAgICAoKGkgPiAwID8gaiA+IDAgPyBuIC8gcG93czEwW2QgLSBqXSA6IDAgOiB4Y1tuaSAtIDFdKSAlIDEwKSAmIDEgfHxcclxuICAgICAgICAgICAgIHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgICAgICBpZiAoc2QgPCAxIHx8ICF4Y1swXSkge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ29udmVydCBzZCB0byBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgICAgICBzZCAtPSB4LmUgKyAxO1xyXG5cclxuICAgICAgICAgICAgICAvLyAxLCAwLjEsIDAuMDEsIDAuMDAxLCAwLjAwMDEgZXRjLlxyXG4gICAgICAgICAgICAgIHhjWzBdID0gcG93czEwWyhMT0dfQkFTRSAtIHNkICUgTE9HX0JBU0UpICUgTE9HX0JBU0VdO1xyXG4gICAgICAgICAgICAgIHguZSA9IC1zZCB8fCAwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgICAgIHhjWzBdID0geC5lID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIGV4Y2VzcyBkaWdpdHMuXHJcbiAgICAgICAgICBpZiAoaSA9PSAwKSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IG5pO1xyXG4gICAgICAgICAgICBrID0gMTtcclxuICAgICAgICAgICAgbmktLTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IG5pICsgMTtcclxuICAgICAgICAgICAgayA9IHBvd3MxMFtMT0dfQkFTRSAtIGldO1xyXG5cclxuICAgICAgICAgICAgLy8gRS5nLiA1NjcwMCBiZWNvbWVzIDU2MDAwIGlmIDcgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAvLyBqID4gMCBtZWFucyBpID4gbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2Ygbi5cclxuICAgICAgICAgICAgeGNbbmldID0gaiA+IDAgPyBtYXRoZmxvb3IobiAvIHBvd3MxMFtkIC0gal0gJSBwb3dzMTBbal0pICogayA6IDA7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IDspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIGRpZ2l0IHRvIGJlIHJvdW5kZWQgdXAgaXMgaW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuLi5cclxuICAgICAgICAgICAgICBpZiAobmkgPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGkgd2lsbCBiZSB0aGUgbGVuZ3RoIG9mIHhjWzBdIGJlZm9yZSBrIGlzIGFkZGVkLlxyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMSwgaiA9IHhjWzBdOyBqID49IDEwOyBqIC89IDEwLCBpKyspO1xyXG4gICAgICAgICAgICAgICAgaiA9IHhjWzBdICs9IGs7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAxOyBqID49IDEwOyBqIC89IDEwLCBrKyspO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGlmIGkgIT0gayB0aGUgbGVuZ3RoIGhhcyBpbmNyZWFzZWQuXHJcbiAgICAgICAgICAgICAgICBpZiAoaSAhPSBrKSB7XHJcbiAgICAgICAgICAgICAgICAgIHguZSsrO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoeGNbMF0gPT0gQkFTRSkgeGNbMF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB4Y1tuaV0gKz0gaztcclxuICAgICAgICAgICAgICAgIGlmICh4Y1tuaV0gIT0gQkFTRSkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB4Y1tuaS0tXSA9IDA7XHJcbiAgICAgICAgICAgICAgICBrID0gMTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICBmb3IgKGkgPSB4Yy5sZW5ndGg7IHhjWy0taV0gPT09IDA7IHhjLnBvcCgpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE92ZXJmbG93PyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoeC5lID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gVW5kZXJmbG93PyBaZXJvLlxyXG4gICAgICAgIH0gZWxzZSBpZiAoeC5lIDwgTUlOX0VYUCkge1xyXG4gICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHZhbHVlT2Yobikge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICBpZiAoZSA9PT0gbnVsbCkgcmV0dXJuIG4udG9TdHJpbmcoKTtcclxuXHJcbiAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuXHJcbiAgICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgICA/IHRvRXhwb25lbnRpYWwoc3RyLCBlKVxyXG4gICAgICAgIDogdG9GaXhlZFBvaW50KHN0ciwgZSwgJzAnKTtcclxuXHJcbiAgICAgIHJldHVybiBuLnMgPCAwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBQUk9UT1RZUEUvSU5TVEFOQ0UgTUVUSE9EU1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIuXHJcbiAgICAgKi9cclxuICAgIFAuYWJzb2x1dGVWYWx1ZSA9IFAuYWJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgeCA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgIGlmICh4LnMgPCAwKSB4LnMgPSAxO1xyXG4gICAgICByZXR1cm4geDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm5cclxuICAgICAqICAgMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiAgIC0xIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqICAgMCBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgdmFsdWUsXHJcbiAgICAgKiAgIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIGVpdGhlciBpcyBOYU4uXHJcbiAgICAgKi9cclxuICAgIFAuY29tcGFyZWRUbyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIElmIGRwIGlzIHVuZGVmaW5lZCBvciBudWxsIG9yIHRydWUgb3IgZmFsc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG9mIHRoZVxyXG4gICAgICogdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICpcclxuICAgICAqIE90aGVyd2lzZSwgaWYgZHAgaXMgYSBudW1iZXIsIHJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBkcCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvclxyXG4gICAgICogUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXM6IGludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC5kZWNpbWFsUGxhY2VzID0gUC5kcCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgdmFyIGMsIG4sIHYsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICAgIHJldHVybiByb3VuZChuZXcgQmlnTnVtYmVyKHgpLCBkcCArIHguZSArIDEsIHJtKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCEoYyA9IHguYykpIHJldHVybiBudWxsO1xyXG4gICAgICBuID0gKCh2ID0gYy5sZW5ndGggLSAxKSAtIGJpdEZsb29yKHRoaXMuZSAvIExPR19CQVNFKSkgKiBMT0dfQkFTRTtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgbnVtYmVyLlxyXG4gICAgICBpZiAodiA9IGNbdl0pIGZvciAoOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tKTtcclxuICAgICAgaWYgKG4gPCAwKSBuID0gMDtcclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuIC8gMCA9IElcclxuICAgICAqICBuIC8gTiA9IE5cclxuICAgICAqICBuIC8gSSA9IDBcclxuICAgICAqICAwIC8gbiA9IDBcclxuICAgICAqICAwIC8gMCA9IE5cclxuICAgICAqICAwIC8gTiA9IE5cclxuICAgICAqICAwIC8gSSA9IDBcclxuICAgICAqICBOIC8gbiA9IE5cclxuICAgICAqICBOIC8gMCA9IE5cclxuICAgICAqICBOIC8gTiA9IE5cclxuICAgICAqICBOIC8gSSA9IE5cclxuICAgICAqICBJIC8gbiA9IElcclxuICAgICAqICBJIC8gMCA9IElcclxuICAgICAqICBJIC8gTiA9IE5cclxuICAgICAqICBJIC8gSSA9IE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBkaXZpZGVkIGJ5IHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5kaXZpZGVkQnkgPSBQLmRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBkaXYodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSwgREVDSU1BTF9QTEFDRVMsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGludGVnZXIgcGFydCBvZiBkaXZpZGluZyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIGJ5IHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAuZGl2aWRlZFRvSW50ZWdlckJ5ID0gUC5pZGl2ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGRpdih0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpLCAwLCAxKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGV4cG9uZW50aWF0ZWQgYnkgbi5cclxuICAgICAqXHJcbiAgICAgKiBJZiBtIGlzIHByZXNlbnQsIHJldHVybiB0aGUgcmVzdWx0IG1vZHVsbyBtLlxyXG4gICAgICogSWYgbiBpcyBuZWdhdGl2ZSByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKiBJZiBQT1dfUFJFQ0lTSU9OIGlzIG5vbi16ZXJvIGFuZCBtIGlzIG5vdCBwcmVzZW50LCByb3VuZCB0byBQT1dfUFJFQ0lTSU9OIHVzaW5nIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIG1vZHVsYXIgcG93ZXIgb3BlcmF0aW9uIHdvcmtzIGVmZmljaWVudGx5IHdoZW4geCwgbiwgYW5kIG0gYXJlIGludGVnZXJzLCBvdGhlcndpc2UgaXRcclxuICAgICAqIGlzIGVxdWl2YWxlbnQgdG8gY2FsY3VsYXRpbmcgeC5leHBvbmVudGlhdGVkQnkobikubW9kdWxvKG0pIHdpdGggYSBQT1dfUFJFQ0lTSU9OIG9mIDAuXHJcbiAgICAgKlxyXG4gICAgICogbiB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IFRoZSBleHBvbmVudC4gQW4gaW50ZWdlci5cclxuICAgICAqIFttXSB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IFRoZSBtb2R1bHVzLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBFeHBvbmVudCBub3QgYW4gaW50ZWdlcjoge259J1xyXG4gICAgICovXHJcbiAgICBQLmV4cG9uZW50aWF0ZWRCeSA9IFAucG93ID0gZnVuY3Rpb24gKG4sIG0pIHtcclxuICAgICAgdmFyIGhhbGYsIGlzTW9kRXhwLCBpLCBrLCBtb3JlLCBuSXNCaWcsIG5Jc05lZywgbklzT2RkLCB5LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgbiA9IG5ldyBCaWdOdW1iZXIobik7XHJcblxyXG4gICAgICAvLyBBbGxvdyBOYU4gYW5kIMKxSW5maW5pdHksIGJ1dCBub3Qgb3RoZXIgbm9uLWludGVnZXJzLlxyXG4gICAgICBpZiAobi5jICYmICFuLmlzSW50ZWdlcigpKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdFeHBvbmVudCBub3QgYW4gaW50ZWdlcjogJyArIHZhbHVlT2YobikpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobSAhPSBudWxsKSBtID0gbmV3IEJpZ051bWJlcihtKTtcclxuXHJcbiAgICAgIC8vIEV4cG9uZW50IG9mIE1BWF9TQUZFX0lOVEVHRVIgaXMgMTUuXHJcbiAgICAgIG5Jc0JpZyA9IG4uZSA+IDE0O1xyXG5cclxuICAgICAgLy8gSWYgeCBpcyBOYU4sIMKxSW5maW5pdHksIMKxMCBvciDCsTEsIG9yIG4gaXMgwrFJbmZpbml0eSwgTmFOIG9yIMKxMC5cclxuICAgICAgaWYgKCF4LmMgfHwgIXguY1swXSB8fCB4LmNbMF0gPT0gMSAmJiAheC5lICYmIHguYy5sZW5ndGggPT0gMSB8fCAhbi5jIHx8ICFuLmNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gVGhlIHNpZ24gb2YgdGhlIHJlc3VsdCBvZiBwb3cgd2hlbiB4IGlzIG5lZ2F0aXZlIGRlcGVuZHMgb24gdGhlIGV2ZW5uZXNzIG9mIG4uXHJcbiAgICAgICAgLy8gSWYgK24gb3ZlcmZsb3dzIHRvIMKxSW5maW5pdHksIHRoZSBldmVubmVzcyBvZiBuIHdvdWxkIGJlIG5vdCBiZSBrbm93bi5cclxuICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihNYXRoLnBvdygrdmFsdWVPZih4KSwgbklzQmlnID8gMiAtIGlzT2RkKG4pIDogK3ZhbHVlT2YobikpKTtcclxuICAgICAgICByZXR1cm4gbSA/IHkubW9kKG0pIDogeTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbklzTmVnID0gbi5zIDwgMDtcclxuXHJcbiAgICAgIGlmIChtKSB7XHJcblxyXG4gICAgICAgIC8vIHggJSBtIHJldHVybnMgTmFOIGlmIGFicyhtKSBpcyB6ZXJvLCBvciBtIGlzIE5hTi5cclxuICAgICAgICBpZiAobS5jID8gIW0uY1swXSA6ICFtLnMpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAgIGlzTW9kRXhwID0gIW5Jc05lZyAmJiB4LmlzSW50ZWdlcigpICYmIG0uaXNJbnRlZ2VyKCk7XHJcblxyXG4gICAgICAgIGlmIChpc01vZEV4cCkgeCA9IHgubW9kKG0pO1xyXG5cclxuICAgICAgLy8gT3ZlcmZsb3cgdG8gwrFJbmZpbml0eTogPj0yKioxZTEwIG9yID49MS4wMDAwMDI0KioxZTE1LlxyXG4gICAgICAvLyBVbmRlcmZsb3cgdG8gwrEwOiA8PTAuNzkqKjFlMTAgb3IgPD0wLjk5OTk5NzUqKjFlMTUuXHJcbiAgICAgIH0gZWxzZSBpZiAobi5lID4gOSAmJiAoeC5lID4gMCB8fCB4LmUgPCAtMSB8fCAoeC5lID09IDBcclxuICAgICAgICAvLyBbMSwgMjQwMDAwMDAwXVxyXG4gICAgICAgID8geC5jWzBdID4gMSB8fCBuSXNCaWcgJiYgeC5jWzFdID49IDI0ZTdcclxuICAgICAgICAvLyBbODAwMDAwMDAwMDAwMDBdICBbOTk5OTk3NTAwMDAwMDBdXHJcbiAgICAgICAgOiB4LmNbMF0gPCA4ZTEzIHx8IG5Jc0JpZyAmJiB4LmNbMF0gPD0gOTk5OTk3NWU3KSkpIHtcclxuXHJcbiAgICAgICAgLy8gSWYgeCBpcyBuZWdhdGl2ZSBhbmQgbiBpcyBvZGQsIGsgPSAtMCwgZWxzZSBrID0gMC5cclxuICAgICAgICBrID0geC5zIDwgMCAmJiBpc09kZChuKSA/IC0wIDogMDtcclxuXHJcbiAgICAgICAgLy8gSWYgeCA+PSAxLCBrID0gwrFJbmZpbml0eS5cclxuICAgICAgICBpZiAoeC5lID4gLTEpIGsgPSAxIC8gaztcclxuXHJcbiAgICAgICAgLy8gSWYgbiBpcyBuZWdhdGl2ZSByZXR1cm4gwrEwLCBlbHNlIHJldHVybiDCsUluZmluaXR5LlxyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKG5Jc05lZyA/IDEgLyBrIDogayk7XHJcblxyXG4gICAgICB9IGVsc2UgaWYgKFBPV19QUkVDSVNJT04pIHtcclxuXHJcbiAgICAgICAgLy8gVHJ1bmNhdGluZyBlYWNoIGNvZWZmaWNpZW50IGFycmF5IHRvIGEgbGVuZ3RoIG9mIGsgYWZ0ZXIgZWFjaCBtdWx0aXBsaWNhdGlvblxyXG4gICAgICAgIC8vIGVxdWF0ZXMgdG8gdHJ1bmNhdGluZyBzaWduaWZpY2FudCBkaWdpdHMgdG8gUE9XX1BSRUNJU0lPTiArIFsyOCwgNDFdLFxyXG4gICAgICAgIC8vIGkuZS4gdGhlcmUgd2lsbCBiZSBhIG1pbmltdW0gb2YgMjggZ3VhcmQgZGlnaXRzIHJldGFpbmVkLlxyXG4gICAgICAgIGsgPSBtYXRoY2VpbChQT1dfUFJFQ0lTSU9OIC8gTE9HX0JBU0UgKyAyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG5Jc0JpZykge1xyXG4gICAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKDAuNSk7XHJcbiAgICAgICAgaWYgKG5Jc05lZykgbi5zID0gMTtcclxuICAgICAgICBuSXNPZGQgPSBpc09kZChuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpID0gTWF0aC5hYnMoK3ZhbHVlT2YobikpO1xyXG4gICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgLy8gUGVyZm9ybXMgNTQgbG9vcCBpdGVyYXRpb25zIGZvciBuIG9mIDkwMDcxOTkyNTQ3NDA5OTEuXHJcbiAgICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICAgIGlmIChuSXNPZGQpIHtcclxuICAgICAgICAgIHkgPSB5LnRpbWVzKHgpO1xyXG4gICAgICAgICAgaWYgKCF5LmMpIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgICAgIGlmICh5LmMubGVuZ3RoID4gaykgeS5jLmxlbmd0aCA9IGs7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTW9kRXhwKSB7XHJcbiAgICAgICAgICAgIHkgPSB5Lm1vZChtKTsgICAgLy95ID0geS5taW51cyhkaXYoeSwgbSwgMCwgTU9EVUxPX01PREUpLnRpbWVzKG0pKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpKSB7XHJcbiAgICAgICAgICBpID0gbWF0aGZsb29yKGkgLyAyKTtcclxuICAgICAgICAgIGlmIChpID09PSAwKSBicmVhaztcclxuICAgICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuID0gbi50aW1lcyhoYWxmKTtcclxuICAgICAgICAgIHJvdW5kKG4sIG4uZSArIDEsIDEpO1xyXG5cclxuICAgICAgICAgIGlmIChuLmUgPiAxNCkge1xyXG4gICAgICAgICAgICBuSXNPZGQgPSBpc09kZChuKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgPSArdmFsdWVPZihuKTtcclxuICAgICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHggPSB4LnRpbWVzKHgpO1xyXG5cclxuICAgICAgICBpZiAoaykge1xyXG4gICAgICAgICAgaWYgKHguYyAmJiB4LmMubGVuZ3RoID4gaykgeC5jLmxlbmd0aCA9IGs7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc01vZEV4cCkge1xyXG4gICAgICAgICAgeCA9IHgubW9kKG0pOyAgICAvL3ggPSB4Lm1pbnVzKGRpdih4LCBtLCAwLCBNT0RVTE9fTU9ERSkudGltZXMobSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGlzTW9kRXhwKSByZXR1cm4geTtcclxuICAgICAgaWYgKG5Jc05lZykgeSA9IE9ORS5kaXYoeSk7XHJcblxyXG4gICAgICByZXR1cm4gbSA/IHkubW9kKG0pIDogayA/IHJvdW5kKHksIFBPV19QUkVDSVNJT04sIFJPVU5ESU5HX01PREUsIG1vcmUpIDogeTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIGFuIGludGVnZXJcclxuICAgICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtybX0nXHJcbiAgICAgKi9cclxuICAgIFAuaW50ZWdlclZhbHVlID0gZnVuY3Rpb24gKHJtKSB7XHJcbiAgICAgIHZhciBuID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcbiAgICAgIHJldHVybiByb3VuZChuLCBuLmUgKyAxLCBybSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzRXF1YWxUbyA9IFAuZXEgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA9PT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgYSBmaW5pdGUgbnVtYmVyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzRmluaXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmM7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0dyZWF0ZXJUaGFuID0gUC5ndCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpID4gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzR3JlYXRlclRoYW5PckVxdWFsVG8gPSBQLmd0ZSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAxIHx8IGIgPT09IDA7XHJcblxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhbiBpbnRlZ2VyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzSW50ZWdlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jICYmIGJpdEZsb29yKHRoaXMuZSAvIExPR19CQVNFKSA+IHRoaXMuYy5sZW5ndGggLSAyO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNMZXNzVGhhbiA9IFAubHQgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA8IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0xlc3NUaGFuT3JFcXVhbFRvID0gUC5sdGUgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gKGIgPSBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpKSA9PT0gLTEgfHwgYiA9PT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgTmFOLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTmFOID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gIXRoaXMucztcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbmVnYXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucyA8IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIHBvc2l0aXZlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnMgPiAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyAwIG9yIC0wLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jICYmIHRoaXMuY1swXSA9PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuIC0gMCA9IG5cclxuICAgICAqICBuIC0gTiA9IE5cclxuICAgICAqICBuIC0gSSA9IC1JXHJcbiAgICAgKiAgMCAtIG4gPSAtblxyXG4gICAgICogIDAgLSAwID0gMFxyXG4gICAgICogIDAgLSBOID0gTlxyXG4gICAgICogIDAgLSBJID0gLUlcclxuICAgICAqICBOIC0gbiA9IE5cclxuICAgICAqICBOIC0gMCA9IE5cclxuICAgICAqICBOIC0gTiA9IE5cclxuICAgICAqICBOIC0gSSA9IE5cclxuICAgICAqICBJIC0gbiA9IElcclxuICAgICAqICBJIC0gMCA9IElcclxuICAgICAqICBJIC0gTiA9IE5cclxuICAgICAqICBJIC0gSSA9IE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtaW51cyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5taW51cyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBpLCBqLCB0LCB4TFR5LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGEgPSB4LnM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuICAgICAgYiA9IHkucztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICAgIGlmICghYSB8fCAhYikgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICAgIHkucyA9IC1iO1xyXG4gICAgICAgIHJldHVybiB4LnBsdXMoeSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgICAgICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiB4YyA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnTnVtYmVyKHljID8geCA6IE5hTik7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgICByZXR1cm4geWNbMF0gPyAoeS5zID0gLWIsIHkpIDogbmV3IEJpZ051bWJlcih4Y1swXSA/IHggOlxyXG5cclxuICAgICAgICAgICAvLyBJRUVFIDc1NCAoMjAwOCkgNi4zOiBuIC0gbiA9IC0wIHdoZW4gcm91bmRpbmcgdG8gLUluZmluaXR5XHJcbiAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9PSAzID8gLTAgOiAwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHhlID0gYml0Rmxvb3IoeGUpO1xyXG4gICAgICB5ZSA9IGJpdEZsb29yKHllKTtcclxuICAgICAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGlzIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgICBpZiAoYSA9IHhlIC0geWUpIHtcclxuXHJcbiAgICAgICAgaWYgKHhMVHkgPSBhIDwgMCkge1xyXG4gICAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcblxyXG4gICAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLlxyXG4gICAgICAgIGZvciAoYiA9IGE7IGItLTsgdC5wdXNoKDApKTtcclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRzIGVxdWFsLiBDaGVjayBkaWdpdCBieSBkaWdpdC5cclxuICAgICAgICBqID0gKHhMVHkgPSAoYSA9IHhjLmxlbmd0aCkgPCAoYiA9IHljLmxlbmd0aCkpID8gYSA6IGI7XHJcblxyXG4gICAgICAgIGZvciAoYSA9IGIgPSAwOyBiIDwgajsgYisrKSB7XHJcblxyXG4gICAgICAgICAgaWYgKHhjW2JdICE9IHljW2JdKSB7XHJcbiAgICAgICAgICAgIHhMVHkgPSB4Y1tiXSA8IHljW2JdO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHggPCB5PyBQb2ludCB4YyB0byB0aGUgYXJyYXkgb2YgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICAgIGlmICh4TFR5KSB0ID0geGMsIHhjID0geWMsIHljID0gdCwgeS5zID0gLXkucztcclxuXHJcbiAgICAgIGIgPSAoaiA9IHljLmxlbmd0aCkgLSAoaSA9IHhjLmxlbmd0aCk7XHJcblxyXG4gICAgICAvLyBBcHBlbmQgemVyb3MgdG8geGMgaWYgc2hvcnRlci5cclxuICAgICAgLy8gTm8gbmVlZCB0byBhZGQgemVyb3MgdG8geWMgaWYgc2hvcnRlciBhcyBzdWJ0cmFjdCBvbmx5IG5lZWRzIHRvIHN0YXJ0IGF0IHljLmxlbmd0aC5cclxuICAgICAgaWYgKGIgPiAwKSBmb3IgKDsgYi0tOyB4Y1tpKytdID0gMCk7XHJcbiAgICAgIGIgPSBCQVNFIC0gMTtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IHljIGZyb20geGMuXHJcbiAgICAgIGZvciAoOyBqID4gYTspIHtcclxuXHJcbiAgICAgICAgaWYgKHhjWy0tal0gPCB5Y1tqXSkge1xyXG4gICAgICAgICAgZm9yIChpID0gajsgaSAmJiAheGNbLS1pXTsgeGNbaV0gPSBiKTtcclxuICAgICAgICAgIC0teGNbaV07XHJcbiAgICAgICAgICB4Y1tqXSArPSBCQVNFO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeGNbal0gLT0geWNbal07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgIGZvciAoOyB4Y1swXSA9PSAwOyB4Yy5zcGxpY2UoMCwgMSksIC0teWUpO1xyXG5cclxuICAgICAgLy8gWmVybz9cclxuICAgICAgaWYgKCF4Y1swXSkge1xyXG5cclxuICAgICAgICAvLyBGb2xsb3dpbmcgSUVFRSA3NTQgKDIwMDgpIDYuMyxcclxuICAgICAgICAvLyBuIC0gbiA9ICswICBidXQgIG4gLSBuID0gLTAgIHdoZW4gcm91bmRpbmcgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgICAgeS5zID0gUk9VTkRJTkdfTU9ERSA9PSAzID8gLTEgOiAxO1xyXG4gICAgICAgIHkuYyA9IFt5LmUgPSAwXTtcclxuICAgICAgICByZXR1cm4geTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgSW5maW5pdHkgYXMgK3ggLSAreSAhPSBJbmZpbml0eSAmJiAteCAtIC15ICE9IEluZmluaXR5XHJcbiAgICAgIC8vIGZvciBmaW5pdGUgeCBhbmQgeS5cclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICAgbiAlIDAgPSAgTlxyXG4gICAgICogICBuICUgTiA9ICBOXHJcbiAgICAgKiAgIG4gJSBJID0gIG5cclxuICAgICAqICAgMCAlIG4gPSAgMFxyXG4gICAgICogIC0wICUgbiA9IC0wXHJcbiAgICAgKiAgIDAgJSAwID0gIE5cclxuICAgICAqICAgMCAlIE4gPSAgTlxyXG4gICAgICogICAwICUgSSA9ICAwXHJcbiAgICAgKiAgIE4gJSBuID0gIE5cclxuICAgICAqICAgTiAlIDAgPSAgTlxyXG4gICAgICogICBOICUgTiA9ICBOXHJcbiAgICAgKiAgIE4gJSBJID0gIE5cclxuICAgICAqICAgSSAlIG4gPSAgTlxyXG4gICAgICogICBJICUgMCA9ICBOXHJcbiAgICAgKiAgIEkgJSBOID0gIE5cclxuICAgICAqICAgSSAlIEkgPSAgTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1vZHVsbyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS4gVGhlIHJlc3VsdCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSBvZiBNT0RVTE9fTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5tb2R1bG8gPSBQLm1vZCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBxLCBzLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gTmFOIGlmIHggaXMgSW5maW5pdHkgb3IgTmFOLCBvciB5IGlzIE5hTiBvciB6ZXJvLlxyXG4gICAgICBpZiAoIXguYyB8fCAheS5zIHx8IHkuYyAmJiAheS5jWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFJldHVybiB4IGlmIHkgaXMgSW5maW5pdHkgb3IgeCBpcyB6ZXJvLlxyXG4gICAgICB9IGVsc2UgaWYgKCF5LmMgfHwgeC5jICYmICF4LmNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKE1PRFVMT19NT0RFID09IDkpIHtcclxuXHJcbiAgICAgICAgLy8gRXVjbGlkaWFuIGRpdmlzaW9uOiBxID0gc2lnbih5KSAqIGZsb29yKHggLyBhYnMoeSkpXHJcbiAgICAgICAgLy8gciA9IHggLSBxeSAgICB3aGVyZSAgMCA8PSByIDwgYWJzKHkpXHJcbiAgICAgICAgcyA9IHkucztcclxuICAgICAgICB5LnMgPSAxO1xyXG4gICAgICAgIHEgPSBkaXYoeCwgeSwgMCwgMyk7XHJcbiAgICAgICAgeS5zID0gcztcclxuICAgICAgICBxLnMgKj0gcztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBxID0gZGl2KHgsIHksIDAsIE1PRFVMT19NT0RFKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgeSA9IHgubWludXMocS50aW1lcyh5KSk7XHJcblxyXG4gICAgICAvLyBUbyBtYXRjaCBKYXZhU2NyaXB0ICUsIGVuc3VyZSBzaWduIG9mIHplcm8gaXMgc2lnbiBvZiBkaXZpZGVuZC5cclxuICAgICAgaWYgKCF5LmNbMF0gJiYgTU9EVUxPX01PREUgPT0gMSkgeS5zID0geC5zO1xyXG5cclxuICAgICAgcmV0dXJuIHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gKiAwID0gMFxyXG4gICAgICogIG4gKiBOID0gTlxyXG4gICAgICogIG4gKiBJID0gSVxyXG4gICAgICogIDAgKiBuID0gMFxyXG4gICAgICogIDAgKiAwID0gMFxyXG4gICAgICogIDAgKiBOID0gTlxyXG4gICAgICogIDAgKiBJID0gTlxyXG4gICAgICogIE4gKiBuID0gTlxyXG4gICAgICogIE4gKiAwID0gTlxyXG4gICAgICogIE4gKiBOID0gTlxyXG4gICAgICogIE4gKiBJID0gTlxyXG4gICAgICogIEkgKiBuID0gSVxyXG4gICAgICogIEkgKiAwID0gTlxyXG4gICAgICogIEkgKiBOID0gTlxyXG4gICAgICogIEkgKiBJID0gSVxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG11bHRpcGxpZWQgYnkgdGhlIHZhbHVlXHJcbiAgICAgKiBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAubXVsdGlwbGllZEJ5ID0gUC50aW1lcyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBjLCBlLCBpLCBqLCBrLCBtLCB4Y0wsIHhsbywgeGhpLCB5Y0wsIHlsbywgeWhpLCB6YyxcclxuICAgICAgICBiYXNlLCBzcXJ0QmFzZSxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9ICh5ID0gbmV3IEJpZ051bWJlcih5LCBiKSkuYztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4sIMKxSW5maW5pdHkgb3IgwrEwP1xyXG4gICAgICBpZiAoIXhjIHx8ICF5YyB8fCAheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIGlzIE5hTiwgb3Igb25lIGlzIDAgYW5kIHRoZSBvdGhlciBpcyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoIXgucyB8fCAheS5zIHx8IHhjICYmICF4Y1swXSAmJiAheWMgfHwgeWMgJiYgIXljWzBdICYmICF4Yykge1xyXG4gICAgICAgICAgeS5jID0geS5lID0geS5zID0gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeS5zICo9IHgucztcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgaXMgwrFJbmZpbml0eS5cclxuICAgICAgICAgIGlmICgheGMgfHwgIXljKSB7XHJcbiAgICAgICAgICAgIHkuYyA9IHkuZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiBlaXRoZXIgaXMgwrEwLlxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeS5jID0gWzBdO1xyXG4gICAgICAgICAgICB5LmUgPSAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGUgPSBiaXRGbG9vcih4LmUgLyBMT0dfQkFTRSkgKyBiaXRGbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgICAgIHkucyAqPSB4LnM7XHJcbiAgICAgIHhjTCA9IHhjLmxlbmd0aDtcclxuICAgICAgeWNMID0geWMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gRW5zdXJlIHhjIHBvaW50cyB0byBsb25nZXIgYXJyYXkgYW5kIHhjTCB0byBpdHMgbGVuZ3RoLlxyXG4gICAgICBpZiAoeGNMIDwgeWNMKSB6YyA9IHhjLCB4YyA9IHljLCB5YyA9IHpjLCBpID0geGNMLCB4Y0wgPSB5Y0wsIHljTCA9IGk7XHJcblxyXG4gICAgICAvLyBJbml0aWFsaXNlIHRoZSByZXN1bHQgYXJyYXkgd2l0aCB6ZXJvcy5cclxuICAgICAgZm9yIChpID0geGNMICsgeWNMLCB6YyA9IFtdOyBpLS07IHpjLnB1c2goMCkpO1xyXG5cclxuICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgIHNxcnRCYXNlID0gU1FSVF9CQVNFO1xyXG5cclxuICAgICAgZm9yIChpID0geWNMOyAtLWkgPj0gMDspIHtcclxuICAgICAgICBjID0gMDtcclxuICAgICAgICB5bG8gPSB5Y1tpXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgIHloaSA9IHljW2ldIC8gc3FydEJhc2UgfCAwO1xyXG5cclxuICAgICAgICBmb3IgKGsgPSB4Y0wsIGogPSBpICsgazsgaiA+IGk7KSB7XHJcbiAgICAgICAgICB4bG8gPSB4Y1stLWtdICUgc3FydEJhc2U7XHJcbiAgICAgICAgICB4aGkgPSB4Y1trXSAvIHNxcnRCYXNlIHwgMDtcclxuICAgICAgICAgIG0gPSB5aGkgKiB4bG8gKyB4aGkgKiB5bG87XHJcbiAgICAgICAgICB4bG8gPSB5bG8gKiB4bG8gKyAoKG0gJSBzcXJ0QmFzZSkgKiBzcXJ0QmFzZSkgKyB6Y1tqXSArIGM7XHJcbiAgICAgICAgICBjID0gKHhsbyAvIGJhc2UgfCAwKSArIChtIC8gc3FydEJhc2UgfCAwKSArIHloaSAqIHhoaTtcclxuICAgICAgICAgIHpjW2otLV0gPSB4bG8gJSBiYXNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgemNbal0gPSBjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYykge1xyXG4gICAgICAgICsrZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB6Yy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgemMsIGUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG5lZ2F0ZWQsXHJcbiAgICAgKiBpLmUuIG11bHRpcGxpZWQgYnkgLTEuXHJcbiAgICAgKi9cclxuICAgIFAubmVnYXRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICB4LnMgPSAteC5zIHx8IG51bGw7XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuICsgMCA9IG5cclxuICAgICAqICBuICsgTiA9IE5cclxuICAgICAqICBuICsgSSA9IElcclxuICAgICAqICAwICsgbiA9IG5cclxuICAgICAqICAwICsgMCA9IDBcclxuICAgICAqICAwICsgTiA9IE5cclxuICAgICAqICAwICsgSSA9IElcclxuICAgICAqICBOICsgbiA9IE5cclxuICAgICAqICBOICsgMCA9IE5cclxuICAgICAqICBOICsgTiA9IE5cclxuICAgICAqICBOICsgSSA9IE5cclxuICAgICAqICBJICsgbiA9IElcclxuICAgICAqICBJICsgMCA9IElcclxuICAgICAqICBJICsgTiA9IE5cclxuICAgICAqICBJICsgSSA9IElcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBwbHVzIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLnBsdXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgdCxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBhID0geC5zO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcbiAgICAgIGIgPSB5LnM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICBpZiAoIWEgfHwgIWIpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgICAgeS5zID0gLWI7XHJcbiAgICAgICAgcmV0dXJuIHgubWludXMoeSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgwrFJbmZpbml0eS5cclxuICAgICAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoYSAvIDApO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkgcmV0dXJuIHljWzBdID8geSA6IG5ldyBCaWdOdW1iZXIoeGNbMF0gPyB4IDogYSAqIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgICAgeWUgPSBiaXRGbG9vcih5ZSk7XHJcbiAgICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLiBGYXN0ZXIgdG8gdXNlIHJldmVyc2UgdGhlbiBkbyB1bnNoaWZ0cy5cclxuICAgICAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcbiAgICAgICAgaWYgKGEgPiAwKSB7XHJcbiAgICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgICBmb3IgKDsgYS0tOyB0LnB1c2goMCkpO1xyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhID0geGMubGVuZ3RoO1xyXG4gICAgICBiID0geWMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gUG9pbnQgeGMgdG8gdGhlIGxvbmdlciBhcnJheSwgYW5kIGIgdG8gdGhlIHNob3J0ZXIgbGVuZ3RoLlxyXG4gICAgICBpZiAoYSAtIGIgPCAwKSB0ID0geWMsIHljID0geGMsIHhjID0gdCwgYiA9IGE7XHJcblxyXG4gICAgICAvLyBPbmx5IHN0YXJ0IGFkZGluZyBhdCB5Yy5sZW5ndGggLSAxIGFzIHRoZSBmdXJ0aGVyIGRpZ2l0cyBvZiB4YyBjYW4gYmUgaWdub3JlZC5cclxuICAgICAgZm9yIChhID0gMDsgYjspIHtcclxuICAgICAgICBhID0gKHhjWy0tYl0gPSB4Y1tiXSArIHljW2JdICsgYSkgLyBCQVNFIHwgMDtcclxuICAgICAgICB4Y1tiXSA9IEJBU0UgPT09IHhjW2JdID8gMCA6IHhjW2JdICUgQkFTRTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGEpIHtcclxuICAgICAgICB4YyA9IFthXS5jb25jYXQoeGMpO1xyXG4gICAgICAgICsreWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIHplcm8sIGFzICt4ICsgK3kgIT0gMCAmJiAteCArIC15ICE9IDBcclxuICAgICAgLy8geWUgPSBNQVhfRVhQICsgMSBwb3NzaWJsZVxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHhjLCB5ZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogSWYgc2QgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgdHJ1ZSBvciBmYWxzZSwgcmV0dXJuIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mXHJcbiAgICAgKiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICogSWYgc2QgaXMgdHJ1ZSBpbmNsdWRlIGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvcyBpbiB0aGUgY291bnQuXHJcbiAgICAgKlxyXG4gICAgICogT3RoZXJ3aXNlLCBpZiBzZCBpcyBhIG51bWJlciwgcmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvclxyXG4gICAgICogUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIHNkIHtudW1iZXJ8Ym9vbGVhbn0gbnVtYmVyOiBzaWduaWZpY2FudCBkaWdpdHM6IGludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgYm9vbGVhbjogd2hldGhlciB0byBjb3VudCBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3M6IHRydWUgb3IgZmFsc2UuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAucHJlY2lzaW9uID0gUC5zZCA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgICAgdmFyIGMsIG4sIHYsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoc2QgIT0gbnVsbCAmJiBzZCAhPT0gISFzZCkge1xyXG4gICAgICAgIGludENoZWNrKHNkLCAxLCBNQVgpO1xyXG4gICAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICAgIHJldHVybiByb3VuZChuZXcgQmlnTnVtYmVyKHgpLCBzZCwgcm0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIShjID0geC5jKSkgcmV0dXJuIG51bGw7XHJcbiAgICAgIHYgPSBjLmxlbmd0aCAtIDE7XHJcbiAgICAgIG4gPSB2ICogTE9HX0JBU0UgKyAxO1xyXG5cclxuICAgICAgaWYgKHYgPSBjW3ZdKSB7XHJcblxyXG4gICAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgZWxlbWVudC5cclxuICAgICAgICBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcblxyXG4gICAgICAgIC8vIEFkZCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudC5cclxuICAgICAgICBmb3IgKHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBuKyspO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2QgJiYgeC5lICsgMSA+IG4pIG4gPSB4LmUgKyAxO1xyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgc2hpZnRlZCBieSBrIHBsYWNlc1xyXG4gICAgICogKHBvd2VycyBvZiAxMCkuIFNoaWZ0IHRvIHRoZSByaWdodCBpZiBuID4gMCwgYW5kIHRvIHRoZSBsZWZ0IGlmIG4gPCAwLlxyXG4gICAgICpcclxuICAgICAqIGsge251bWJlcn0gSW50ZWdlciwgLU1BWF9TQUZFX0lOVEVHRVIgdG8gTUFYX1NBRkVfSU5URUdFUiBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtrfSdcclxuICAgICAqL1xyXG4gICAgUC5zaGlmdGVkQnkgPSBmdW5jdGlvbiAoaykge1xyXG4gICAgICBpbnRDaGVjayhrLCAtTUFYX1NBRkVfSU5URUdFUiwgTUFYX1NBRkVfSU5URUdFUik7XHJcbiAgICAgIHJldHVybiB0aGlzLnRpbWVzKCcxZScgKyBrKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgc3FydCgtbikgPSAgTlxyXG4gICAgICogIHNxcnQoTikgPSAgTlxyXG4gICAgICogIHNxcnQoLUkpID0gIE5cclxuICAgICAqICBzcXJ0KEkpID0gIElcclxuICAgICAqICBzcXJ0KDApID0gIDBcclxuICAgICAqICBzcXJ0KC0wKSA9IC0wXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLFxyXG4gICAgICogcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAuc3F1YXJlUm9vdCA9IFAuc3FydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIG0sIG4sIHIsIHJlcCwgdCxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBjID0geC5jLFxyXG4gICAgICAgIHMgPSB4LnMsXHJcbiAgICAgICAgZSA9IHguZSxcclxuICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTICsgNCxcclxuICAgICAgICBoYWxmID0gbmV3IEJpZ051bWJlcignMC41Jyk7XHJcblxyXG4gICAgICAvLyBOZWdhdGl2ZS9OYU4vSW5maW5pdHkvemVybz9cclxuICAgICAgaWYgKHMgIT09IDEgfHwgIWMgfHwgIWNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcighcyB8fCBzIDwgMCAmJiAoIWMgfHwgY1swXSkgPyBOYU4gOiBjID8geCA6IDEgLyAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5pdGlhbCBlc3RpbWF0ZS5cclxuICAgICAgcyA9IE1hdGguc3FydCgrdmFsdWVPZih4KSk7XHJcblxyXG4gICAgICAvLyBNYXRoLnNxcnQgdW5kZXJmbG93L292ZXJmbG93P1xyXG4gICAgICAvLyBQYXNzIHggdG8gTWF0aC5zcXJ0IGFzIGludGVnZXIsIHRoZW4gYWRqdXN0IHRoZSBleHBvbmVudCBvZiB0aGUgcmVzdWx0LlxyXG4gICAgICBpZiAocyA9PSAwIHx8IHMgPT0gMSAvIDApIHtcclxuICAgICAgICBuID0gY29lZmZUb1N0cmluZyhjKTtcclxuICAgICAgICBpZiAoKG4ubGVuZ3RoICsgZSkgJSAyID09IDApIG4gKz0gJzAnO1xyXG4gICAgICAgIHMgPSBNYXRoLnNxcnQoK24pO1xyXG4gICAgICAgIGUgPSBiaXRGbG9vcigoZSArIDEpIC8gMikgLSAoZSA8IDAgfHwgZSAlIDIpO1xyXG5cclxuICAgICAgICBpZiAocyA9PSAxIC8gMCkge1xyXG4gICAgICAgICAgbiA9ICcxZScgKyBlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuID0gcy50b0V4cG9uZW50aWFsKCk7XHJcbiAgICAgICAgICBuID0gbi5zbGljZSgwLCBuLmluZGV4T2YoJ2UnKSArIDEpICsgZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKHMgKyAnJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGZvciB6ZXJvLlxyXG4gICAgICAvLyByIGNvdWxkIGJlIHplcm8gaWYgTUlOX0VYUCBpcyBjaGFuZ2VkIGFmdGVyIHRoZSB0aGlzIHZhbHVlIHdhcyBjcmVhdGVkLlxyXG4gICAgICAvLyBUaGlzIHdvdWxkIGNhdXNlIGEgZGl2aXNpb24gYnkgemVybyAoeC90KSBhbmQgaGVuY2UgSW5maW5pdHkgYmVsb3csIHdoaWNoIHdvdWxkIGNhdXNlXHJcbiAgICAgIC8vIGNvZWZmVG9TdHJpbmcgdG8gdGhyb3cuXHJcbiAgICAgIGlmIChyLmNbMF0pIHtcclxuICAgICAgICBlID0gci5lO1xyXG4gICAgICAgIHMgPSBlICsgZHA7XHJcbiAgICAgICAgaWYgKHMgPCAzKSBzID0gMDtcclxuXHJcbiAgICAgICAgLy8gTmV3dG9uLVJhcGhzb24gaXRlcmF0aW9uLlxyXG4gICAgICAgIGZvciAoOyA7KSB7XHJcbiAgICAgICAgICB0ID0gcjtcclxuICAgICAgICAgIHIgPSBoYWxmLnRpbWVzKHQucGx1cyhkaXYoeCwgdCwgZHAsIDEpKSk7XHJcblxyXG4gICAgICAgICAgaWYgKGNvZWZmVG9TdHJpbmcodC5jKS5zbGljZSgwLCBzKSA9PT0gKG4gPSBjb2VmZlRvU3RyaW5nKHIuYykpLnNsaWNlKDAsIHMpKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgZXhwb25lbnQgb2YgciBtYXkgaGVyZSBiZSBvbmUgbGVzcyB0aGFuIHRoZSBmaW5hbCByZXN1bHQgZXhwb25lbnQsXHJcbiAgICAgICAgICAgIC8vIGUuZyAwLjAwMDk5OTkgKGUtNCkgLS0gPiAwLjAwMSAoZS0zKSwgc28gYWRqdXN0IHMgc28gdGhlIHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgICAvLyBhcmUgaW5kZXhlZCBjb3JyZWN0bHkuXHJcbiAgICAgICAgICAgIGlmIChyLmUgPCBlKSAtLXM7XHJcbiAgICAgICAgICAgIG4gPSBuLnNsaWNlKHMgLSAzLCBzICsgMSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgNHRoIHJvdW5kaW5nIGRpZ2l0IG1heSBiZSBpbiBlcnJvciBieSAtMSBzbyBpZiB0aGUgNCByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgICAgLy8gYXJlIDk5OTkgb3IgNDk5OSAoaS5lLiBhcHByb2FjaGluZyBhIHJvdW5kaW5nIGJvdW5kYXJ5KSBjb250aW51ZSB0aGVcclxuICAgICAgICAgICAgLy8gaXRlcmF0aW9uLlxyXG4gICAgICAgICAgICBpZiAobiA9PSAnOTk5OScgfHwgIXJlcCAmJiBuID09ICc0OTk5Jykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBPbiB0aGUgZmlyc3QgaXRlcmF0aW9uIG9ubHksIGNoZWNrIHRvIHNlZSBpZiByb3VuZGluZyB1cCBnaXZlcyB0aGVcclxuICAgICAgICAgICAgICAvLyBleGFjdCByZXN1bHQgYXMgdGhlIG5pbmVzIG1heSBpbmZpbml0ZWx5IHJlcGVhdC5cclxuICAgICAgICAgICAgICBpZiAoIXJlcCkge1xyXG4gICAgICAgICAgICAgICAgcm91bmQodCwgdC5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodC50aW1lcyh0KS5lcSh4KSkge1xyXG4gICAgICAgICAgICAgICAgICByID0gdDtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBkcCArPSA0O1xyXG4gICAgICAgICAgICAgIHMgKz0gNDtcclxuICAgICAgICAgICAgICByZXAgPSAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiByb3VuZGluZyBkaWdpdHMgYXJlIG51bGwsIDB7MCw0fSBvciA1MHswLDN9LCBjaGVjayBmb3IgZXhhY3RcclxuICAgICAgICAgICAgICAvLyByZXN1bHQuIElmIG5vdCwgdGhlbiB0aGVyZSBhcmUgZnVydGhlciBkaWdpdHMgYW5kIG0gd2lsbCBiZSB0cnV0aHkuXHJcbiAgICAgICAgICAgICAgaWYgKCErbiB8fCAhK24uc2xpY2UoMSkgJiYgbi5jaGFyQXQoMCkgPT0gJzUnKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVHJ1bmNhdGUgdG8gdGhlIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgcm91bmQociwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAxKTtcclxuICAgICAgICAgICAgICAgIG0gPSAhci50aW1lcyhyKS5lcSh4KTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcm91bmQociwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAxLCBST1VORElOR19NT0RFLCBtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBleHBvbmVudGlhbCBub3RhdGlvbiBhbmRcclxuICAgICAqIHJvdW5kZWQgdXNpbmcgUk9VTkRJTkdfTU9ERSB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9FeHBvbmVudGlhbCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBkcCsrO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIHJtLCAxKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGluZ1xyXG4gICAgICogdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIE5vdGU6IGFzIHdpdGggSmF2YVNjcmlwdCdzIG51bWJlciB0eXBlLCAoLTApLnRvRml4ZWQoMCkgaXMgJzAnLFxyXG4gICAgICogYnV0IGUuZy4gKC0wLjAwMDAxKS50b0ZpeGVkKDApIGlzICctMCcuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvRml4ZWQgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgZHAgPSBkcCArIHRoaXMuZSArIDE7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBkcCwgcm0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uIHJvdW5kZWRcclxuICAgICAqIHVzaW5nIHJtIG9yIFJPVU5ESU5HX01PREUgdG8gZHAgZGVjaW1hbCBwbGFjZXMsIGFuZCBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBwcm9wZXJ0aWVzXHJcbiAgICAgKiBvZiB0aGUgZm9ybWF0IG9yIEZPUk1BVCBvYmplY3QgKHNlZSBCaWdOdW1iZXIuc2V0KS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZm9ybWF0dGluZyBvYmplY3QgbWF5IGNvbnRhaW4gc29tZSBvciBhbGwgb2YgdGhlIHByb3BlcnRpZXMgc2hvd24gYmVsb3cuXHJcbiAgICAgKlxyXG4gICAgICogRk9STUFUID0ge1xyXG4gICAgICogICBwcmVmaXg6ICcnLFxyXG4gICAgICogICBncm91cFNpemU6IDMsXHJcbiAgICAgKiAgIHNlY29uZGFyeUdyb3VwU2l6ZTogMCxcclxuICAgICAqICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgICAqICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICogICBmcmFjdGlvbkdyb3VwU2l6ZTogMCxcclxuICAgICAqICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAqICAgc3VmZml4OiAnJ1xyXG4gICAgICogfTtcclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbZm9ybWF0XSB7b2JqZWN0fSBGb3JtYXR0aW5nIG9wdGlvbnMuIFNlZSBGT1JNQVQgcGJqZWN0IGFib3ZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IG5vdCBhbiBvYmplY3Q6IHtmb3JtYXR9J1xyXG4gICAgICovXHJcbiAgICBQLnRvRm9ybWF0ID0gZnVuY3Rpb24gKGRwLCBybSwgZm9ybWF0KSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcclxuICAgICAgICBpZiAoZHAgIT0gbnVsbCAmJiBybSAmJiB0eXBlb2Ygcm0gPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgIGZvcm1hdCA9IHJtO1xyXG4gICAgICAgICAgcm0gPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZHAgJiYgdHlwZW9mIGRwID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBkcDtcclxuICAgICAgICAgIGRwID0gcm0gPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBGT1JNQVQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmb3JtYXQgIT0gJ29iamVjdCcpIHtcclxuICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0FyZ3VtZW50IG5vdCBhbiBvYmplY3Q6ICcgKyBmb3JtYXQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzdHIgPSB4LnRvRml4ZWQoZHAsIHJtKTtcclxuXHJcbiAgICAgIGlmICh4LmMpIHtcclxuICAgICAgICB2YXIgaSxcclxuICAgICAgICAgIGFyciA9IHN0ci5zcGxpdCgnLicpLFxyXG4gICAgICAgICAgZzEgPSArZm9ybWF0Lmdyb3VwU2l6ZSxcclxuICAgICAgICAgIGcyID0gK2Zvcm1hdC5zZWNvbmRhcnlHcm91cFNpemUsXHJcbiAgICAgICAgICBncm91cFNlcGFyYXRvciA9IGZvcm1hdC5ncm91cFNlcGFyYXRvciB8fCAnJyxcclxuICAgICAgICAgIGludFBhcnQgPSBhcnJbMF0sXHJcbiAgICAgICAgICBmcmFjdGlvblBhcnQgPSBhcnJbMV0sXHJcbiAgICAgICAgICBpc05lZyA9IHgucyA8IDAsXHJcbiAgICAgICAgICBpbnREaWdpdHMgPSBpc05lZyA/IGludFBhcnQuc2xpY2UoMSkgOiBpbnRQYXJ0LFxyXG4gICAgICAgICAgbGVuID0gaW50RGlnaXRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKGcyKSBpID0gZzEsIGcxID0gZzIsIGcyID0gaSwgbGVuIC09IGk7XHJcblxyXG4gICAgICAgIGlmIChnMSA+IDAgJiYgbGVuID4gMCkge1xyXG4gICAgICAgICAgaSA9IGxlbiAlIGcxIHx8IGcxO1xyXG4gICAgICAgICAgaW50UGFydCA9IGludERpZ2l0cy5zdWJzdHIoMCwgaSk7XHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSArPSBnMSkgaW50UGFydCArPSBncm91cFNlcGFyYXRvciArIGludERpZ2l0cy5zdWJzdHIoaSwgZzEpO1xyXG4gICAgICAgICAgaWYgKGcyID4gMCkgaW50UGFydCArPSBncm91cFNlcGFyYXRvciArIGludERpZ2l0cy5zbGljZShpKTtcclxuICAgICAgICAgIGlmIChpc05lZykgaW50UGFydCA9ICctJyArIGludFBhcnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSBmcmFjdGlvblBhcnRcclxuICAgICAgICAgPyBpbnRQYXJ0ICsgKGZvcm1hdC5kZWNpbWFsU2VwYXJhdG9yIHx8ICcnKSArICgoZzIgPSArZm9ybWF0LmZyYWN0aW9uR3JvdXBTaXplKVxyXG4gICAgICAgICAgPyBmcmFjdGlvblBhcnQucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcZHsnICsgZzIgKyAnfVxcXFxCJywgJ2cnKSxcclxuICAgICAgICAgICAnJCYnICsgKGZvcm1hdC5mcmFjdGlvbkdyb3VwU2VwYXJhdG9yIHx8ICcnKSlcclxuICAgICAgICAgIDogZnJhY3Rpb25QYXJ0KVxyXG4gICAgICAgICA6IGludFBhcnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiAoZm9ybWF0LnByZWZpeCB8fCAnJykgKyBzdHIgKyAoZm9ybWF0LnN1ZmZpeCB8fCAnJyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGFuIGFycmF5IG9mIHR3byBCaWdOdW1iZXJzIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgYXMgYSBzaW1wbGVcclxuICAgICAqIGZyYWN0aW9uIHdpdGggYW4gaW50ZWdlciBudW1lcmF0b3IgYW5kIGFuIGludGVnZXIgZGVub21pbmF0b3IuXHJcbiAgICAgKiBUaGUgZGVub21pbmF0b3Igd2lsbCBiZSBhIHBvc2l0aXZlIG5vbi16ZXJvIHZhbHVlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc3BlY2lmaWVkXHJcbiAgICAgKiBtYXhpbXVtIGRlbm9taW5hdG9yLiBJZiBhIG1heGltdW0gZGVub21pbmF0b3IgaXMgbm90IHNwZWNpZmllZCwgdGhlIGRlbm9taW5hdG9yIHdpbGwgYmVcclxuICAgICAqIHRoZSBsb3dlc3QgdmFsdWUgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgbnVtYmVyIGV4YWN0bHkuXHJcbiAgICAgKlxyXG4gICAgICogW21kXSB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEludGVnZXIgPj0gMSwgb3IgSW5maW5pdHkuIFRoZSBtYXhpbXVtIGRlbm9taW5hdG9yLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfSA6IHttZH0nXHJcbiAgICAgKi9cclxuICAgIFAudG9GcmFjdGlvbiA9IGZ1bmN0aW9uIChtZCkge1xyXG4gICAgICB2YXIgZCwgZDAsIGQxLCBkMiwgZSwgZXhwLCBuLCBuMCwgbjEsIHEsIHIsIHMsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgeGMgPSB4LmM7XHJcblxyXG4gICAgICBpZiAobWQgIT0gbnVsbCkge1xyXG4gICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKG1kKTtcclxuXHJcbiAgICAgICAgLy8gVGhyb3cgaWYgbWQgaXMgbGVzcyB0aGFuIG9uZSBvciBpcyBub3QgYW4gaW50ZWdlciwgdW5sZXNzIGl0IGlzIEluZmluaXR5LlxyXG4gICAgICAgIGlmICghbi5pc0ludGVnZXIoKSAmJiAobi5jIHx8IG4ucyAhPT0gMSkgfHwgbi5sdChPTkUpKSB7XHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnQXJndW1lbnQgJyArXHJcbiAgICAgICAgICAgICAgKG4uaXNJbnRlZ2VyKCkgPyAnb3V0IG9mIHJhbmdlOiAnIDogJ25vdCBhbiBpbnRlZ2VyOiAnKSArIHZhbHVlT2YobikpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCF4YykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoeCk7XHJcblxyXG4gICAgICBkID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBuMSA9IGQwID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBkMSA9IG4wID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgICBzID0gY29lZmZUb1N0cmluZyh4Yyk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgaW5pdGlhbCBkZW5vbWluYXRvci5cclxuICAgICAgLy8gZCBpcyBhIHBvd2VyIG9mIDEwIGFuZCB0aGUgbWluaW11bSBtYXggZGVub21pbmF0b3IgdGhhdCBzcGVjaWZpZXMgdGhlIHZhbHVlIGV4YWN0bHkuXHJcbiAgICAgIGUgPSBkLmUgPSBzLmxlbmd0aCAtIHguZSAtIDE7XHJcbiAgICAgIGQuY1swXSA9IFBPV1NfVEVOWyhleHAgPSBlICUgTE9HX0JBU0UpIDwgMCA/IExPR19CQVNFICsgZXhwIDogZXhwXTtcclxuICAgICAgbWQgPSAhbWQgfHwgbi5jb21wYXJlZFRvKGQpID4gMCA/IChlID4gMCA/IGQgOiBuMSkgOiBuO1xyXG5cclxuICAgICAgZXhwID0gTUFYX0VYUDtcclxuICAgICAgTUFYX0VYUCA9IDEgLyAwO1xyXG4gICAgICBuID0gbmV3IEJpZ051bWJlcihzKTtcclxuXHJcbiAgICAgIC8vIG4wID0gZDEgPSAwXHJcbiAgICAgIG4wLmNbMF0gPSAwO1xyXG5cclxuICAgICAgZm9yICg7IDspICB7XHJcbiAgICAgICAgcSA9IGRpdihuLCBkLCAwLCAxKTtcclxuICAgICAgICBkMiA9IGQwLnBsdXMocS50aW1lcyhkMSkpO1xyXG4gICAgICAgIGlmIChkMi5jb21wYXJlZFRvKG1kKSA9PSAxKSBicmVhaztcclxuICAgICAgICBkMCA9IGQxO1xyXG4gICAgICAgIGQxID0gZDI7XHJcbiAgICAgICAgbjEgPSBuMC5wbHVzKHEudGltZXMoZDIgPSBuMSkpO1xyXG4gICAgICAgIG4wID0gZDI7XHJcbiAgICAgICAgZCA9IG4ubWludXMocS50aW1lcyhkMiA9IGQpKTtcclxuICAgICAgICBuID0gZDI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGQyID0gZGl2KG1kLm1pbnVzKGQwKSwgZDEsIDAsIDEpO1xyXG4gICAgICBuMCA9IG4wLnBsdXMoZDIudGltZXMobjEpKTtcclxuICAgICAgZDAgPSBkMC5wbHVzKGQyLnRpbWVzKGQxKSk7XHJcbiAgICAgIG4wLnMgPSBuMS5zID0geC5zO1xyXG4gICAgICBlID0gZSAqIDI7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggZnJhY3Rpb24gaXMgY2xvc2VyIHRvIHgsIG4wL2QwIG9yIG4xL2QxXHJcbiAgICAgIHIgPSBkaXYobjEsIGQxLCBlLCBST1VORElOR19NT0RFKS5taW51cyh4KS5hYnMoKS5jb21wYXJlZFRvKFxyXG4gICAgICAgICAgZGl2KG4wLCBkMCwgZSwgUk9VTkRJTkdfTU9ERSkubWludXMoeCkuYWJzKCkpIDwgMSA/IFtuMSwgZDFdIDogW24wLCBkMF07XHJcblxyXG4gICAgICBNQVhfRVhQID0gZXhwO1xyXG5cclxuICAgICAgcmV0dXJuIHI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBjb252ZXJ0ZWQgdG8gYSBudW1iZXIgcHJpbWl0aXZlLlxyXG4gICAgICovXHJcbiAgICBQLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gK3ZhbHVlT2YodGhpcyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHNcclxuICAgICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0gb3IgUk9VTkRJTkdfTU9ERS4gSWYgc2QgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzXHJcbiAgICAgKiBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLCB0aGVuIHVzZVxyXG4gICAgICogZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3NkfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b1ByZWNpc2lvbiA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgICAgaWYgKHNkICE9IG51bGwpIGludENoZWNrKHNkLCAxLCBNQVgpO1xyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIHNkLCBybSwgMik7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gYmFzZSBiLCBvciBiYXNlIDEwIGlmIGIgaXNcclxuICAgICAqIG9taXR0ZWQuIElmIGEgYmFzZSBpcyBzcGVjaWZpZWQsIGluY2x1ZGluZyBiYXNlIDEwLCByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kXHJcbiAgICAgKiBST1VORElOR19NT0RFLiBJZiBhIGJhc2UgaXMgbm90IHNwZWNpZmllZCwgYW5kIHRoaXMgQmlnTnVtYmVyIGhhcyBhIHBvc2l0aXZlIGV4cG9uZW50XHJcbiAgICAgKiB0aGF0IGlzIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiBUT19FWFBfUE9TLCBvciBhIG5lZ2F0aXZlIGV4cG9uZW50IGVxdWFsIHRvIG9yIGxlc3MgdGhhblxyXG4gICAgICogVE9fRVhQX05FRywgcmV0dXJuIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFtiXSB7bnVtYmVyfSBJbnRlZ2VyLCAyIHRvIEFMUEhBQkVULmxlbmd0aCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEJhc2Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2J9J1xyXG4gICAgICovXHJcbiAgICBQLnRvU3RyaW5nID0gZnVuY3Rpb24gKGIpIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICBuID0gdGhpcyxcclxuICAgICAgICBzID0gbi5zLFxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICAvLyBJbmZpbml0eSBvciBOYU4/XHJcbiAgICAgIGlmIChlID09PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHMpIHtcclxuICAgICAgICAgIHN0ciA9ICdJbmZpbml0eSc7XHJcbiAgICAgICAgICBpZiAocyA8IDApIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc3RyID0gJ05hTic7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChiID09IG51bGwpIHtcclxuICAgICAgICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgICAgICA/IHRvRXhwb25lbnRpYWwoY29lZmZUb1N0cmluZyhuLmMpLCBlKVxyXG4gICAgICAgICAgIDogdG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgZSwgJzAnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDEwKSB7XHJcbiAgICAgICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgREVDSU1BTF9QTEFDRVMgKyBlICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBuLmUsICcwJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGludENoZWNrKGIsIDIsIEFMUEhBQkVULmxlbmd0aCwgJ0Jhc2UnKTtcclxuICAgICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyksIDEwLCBiLCBzLCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzIDwgMCAmJiBuLmNbMF0pIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYXMgdG9TdHJpbmcsIGJ1dCBkbyBub3QgYWNjZXB0IGEgYmFzZSBhcmd1bWVudCwgYW5kIGluY2x1ZGUgdGhlIG1pbnVzIHNpZ24gZm9yXHJcbiAgICAgKiBuZWdhdGl2ZSB6ZXJvLlxyXG4gICAgICovXHJcbiAgICBQLnZhbHVlT2YgPSBQLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlT2YodGhpcyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBQLl9pc0JpZ051bWJlciA9IHRydWU7XHJcblxyXG4gICAgaWYgKGhhc1N5bWJvbCkge1xyXG4gICAgICBQW1N5bWJvbC50b1N0cmluZ1RhZ10gPSAnQmlnTnVtYmVyJztcclxuXHJcbiAgICAgIC8vIE5vZGUuanMgdjEwLjEyLjArXHJcbiAgICAgIFBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gPSBQLnZhbHVlT2Y7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvbmZpZ09iamVjdCAhPSBudWxsKSBCaWdOdW1iZXIuc2V0KGNvbmZpZ09iamVjdCk7XHJcblxyXG4gICAgcmV0dXJuIEJpZ051bWJlcjtcclxuICB9XHJcblxyXG5cclxuICAvLyBQUklWQVRFIEhFTFBFUiBGVU5DVElPTlNcclxuXHJcbiAgLy8gVGhlc2UgZnVuY3Rpb25zIGRvbid0IG5lZWQgYWNjZXNzIHRvIHZhcmlhYmxlcyxcclxuICAvLyBlLmcuIERFQ0lNQUxfUExBQ0VTLCBpbiB0aGUgc2NvcGUgb2YgdGhlIGBjbG9uZWAgZnVuY3Rpb24gYWJvdmUuXHJcblxyXG5cclxuICBmdW5jdGlvbiBiaXRGbG9vcihuKSB7XHJcbiAgICB2YXIgaSA9IG4gfCAwO1xyXG4gICAgcmV0dXJuIG4gPiAwIHx8IG4gPT09IGkgPyBpIDogaSAtIDE7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gUmV0dXJuIGEgY29lZmZpY2llbnQgYXJyYXkgYXMgYSBzdHJpbmcgb2YgYmFzZSAxMCBkaWdpdHMuXHJcbiAgZnVuY3Rpb24gY29lZmZUb1N0cmluZyhhKSB7XHJcbiAgICB2YXIgcywgeixcclxuICAgICAgaSA9IDEsXHJcbiAgICAgIGogPSBhLmxlbmd0aCxcclxuICAgICAgciA9IGFbMF0gKyAnJztcclxuXHJcbiAgICBmb3IgKDsgaSA8IGo7KSB7XHJcbiAgICAgIHMgPSBhW2krK10gKyAnJztcclxuICAgICAgeiA9IExPR19CQVNFIC0gcy5sZW5ndGg7XHJcbiAgICAgIGZvciAoOyB6LS07IHMgPSAnMCcgKyBzKTtcclxuICAgICAgciArPSBzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoaiA9IHIubGVuZ3RoOyByLmNoYXJDb2RlQXQoLS1qKSA9PT0gNDg7KTtcclxuXHJcbiAgICByZXR1cm4gci5zbGljZSgwLCBqICsgMSB8fCAxKTtcclxuICB9XHJcblxyXG5cclxuICAvLyBDb21wYXJlIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXJzIHggYW5kIHkuXHJcbiAgZnVuY3Rpb24gY29tcGFyZSh4LCB5KSB7XHJcbiAgICB2YXIgYSwgYixcclxuICAgICAgeGMgPSB4LmMsXHJcbiAgICAgIHljID0geS5jLFxyXG4gICAgICBpID0geC5zLFxyXG4gICAgICBqID0geS5zLFxyXG4gICAgICBrID0geC5lLFxyXG4gICAgICBsID0geS5lO1xyXG5cclxuICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICBpZiAoIWkgfHwgIWopIHJldHVybiBudWxsO1xyXG5cclxuICAgIGEgPSB4YyAmJiAheGNbMF07XHJcbiAgICBiID0geWMgJiYgIXljWzBdO1xyXG5cclxuICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgaWYgKGEgfHwgYikgcmV0dXJuIGEgPyBiID8gMCA6IC1qIDogaTtcclxuXHJcbiAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICBpZiAoaSAhPSBqKSByZXR1cm4gaTtcclxuXHJcbiAgICBhID0gaSA8IDA7XHJcbiAgICBiID0gayA9PSBsO1xyXG5cclxuICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4gYiA/IDAgOiAheGMgXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIC8vIENvbXBhcmUgZXhwb25lbnRzLlxyXG4gICAgaWYgKCFiKSByZXR1cm4gayA+IGwgXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIGogPSAoayA9IHhjLmxlbmd0aCkgPCAobCA9IHljLmxlbmd0aCkgPyBrIDogbDtcclxuXHJcbiAgICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgZm9yIChpID0gMDsgaSA8IGo7IGkrKykgaWYgKHhjW2ldICE9IHljW2ldKSByZXR1cm4geGNbaV0gPiB5Y1tpXSBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBsZW5ndGhzLlxyXG4gICAgcmV0dXJuIGsgPT0gbCA/IDAgOiBrID4gbCBeIGEgPyAxIDogLTE7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBDaGVjayB0aGF0IG4gaXMgYSBwcmltaXRpdmUgbnVtYmVyLCBhbiBpbnRlZ2VyLCBhbmQgaW4gcmFuZ2UsIG90aGVyd2lzZSB0aHJvdy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBpbnRDaGVjayhuLCBtaW4sIG1heCwgbmFtZSkge1xyXG4gICAgaWYgKG4gPCBtaW4gfHwgbiA+IG1heCB8fCBuICE9PSBtYXRoZmxvb3IobikpIHtcclxuICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgIChiaWdudW1iZXJFcnJvciArIChuYW1lIHx8ICdBcmd1bWVudCcpICsgKHR5cGVvZiBuID09ICdudW1iZXInXHJcbiAgICAgICAgID8gbiA8IG1pbiB8fCBuID4gbWF4ID8gJyBvdXQgb2YgcmFuZ2U6ICcgOiAnIG5vdCBhbiBpbnRlZ2VyOiAnXHJcbiAgICAgICAgIDogJyBub3QgYSBwcmltaXRpdmUgbnVtYmVyOiAnKSArIFN0cmluZyhuKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQXNzdW1lcyBmaW5pdGUgbi5cclxuICBmdW5jdGlvbiBpc09kZChuKSB7XHJcbiAgICB2YXIgayA9IG4uYy5sZW5ndGggLSAxO1xyXG4gICAgcmV0dXJuIGJpdEZsb29yKG4uZSAvIExPR19CQVNFKSA9PSBrICYmIG4uY1trXSAlIDIgIT0gMDtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiB0b0V4cG9uZW50aWFsKHN0ciwgZSkge1xyXG4gICAgcmV0dXJuIChzdHIubGVuZ3RoID4gMSA/IHN0ci5jaGFyQXQoMCkgKyAnLicgKyBzdHIuc2xpY2UoMSkgOiBzdHIpICtcclxuICAgICAoZSA8IDAgPyAnZScgOiAnZSsnKSArIGU7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gdG9GaXhlZFBvaW50KHN0ciwgZSwgeikge1xyXG4gICAgdmFyIGxlbiwgenM7XHJcblxyXG4gICAgLy8gTmVnYXRpdmUgZXhwb25lbnQ/XHJcbiAgICBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAgIC8vIFByZXBlbmQgemVyb3MuXHJcbiAgICAgIGZvciAoenMgPSB6ICsgJy4nOyArK2U7IHpzICs9IHopO1xyXG4gICAgICBzdHIgPSB6cyArIHN0cjtcclxuXHJcbiAgICAvLyBQb3NpdGl2ZSBleHBvbmVudFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIEFwcGVuZCB6ZXJvcy5cclxuICAgICAgaWYgKCsrZSA+IGxlbikge1xyXG4gICAgICAgIGZvciAoenMgPSB6LCBlIC09IGxlbjsgLS1lOyB6cyArPSB6KTtcclxuICAgICAgICBzdHIgKz0genM7XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IGxlbikge1xyXG4gICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCBlKSArICcuJyArIHN0ci5zbGljZShlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdHI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gRVhQT1JUXHJcblxyXG5cclxuICBCaWdOdW1iZXIgPSBjbG9uZSgpO1xyXG4gIEJpZ051bWJlclsnZGVmYXVsdCddID0gQmlnTnVtYmVyLkJpZ051bWJlciA9IEJpZ051bWJlcjtcclxuXHJcbiAgLy8gQU1ELlxyXG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJpZ051bWJlcjsgfSk7XHJcblxyXG4gIC8vIE5vZGUuanMgYW5kIG90aGVyIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMuXHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJpZ051bWJlcjtcclxuXHJcbiAgLy8gQnJvd3Nlci5cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKCFnbG9iYWxPYmplY3QpIHtcclxuICAgICAgZ2xvYmFsT2JqZWN0ID0gdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiA/IHNlbGYgOiB3aW5kb3c7XHJcbiAgICB9XHJcblxyXG4gICAgZ2xvYmFsT2JqZWN0LkJpZ051bWJlciA9IEJpZ051bWJlcjtcclxuICB9XHJcbn0pKHRoaXMpO1xyXG4iLCIndXNlIHN0cmljdCdcblxudmFyIGdldFRpbWUgPSByZXF1aXJlKCcuL3RpbWUnKVxuXG5mdW5jdGlvbiBSZXRpbWVyIChjYWxsYmFjaywgdGltZW91dCwgYXJncykge1xuICB2YXIgdGhhdCA9IHRoaXNcblxuICB0aGlzLl9zdGFydGVkID0gZ2V0VGltZSgpXG4gIHRoaXMuX3Jlc2NoZWR1bGVkID0gMFxuICB0aGlzLl9zY2hlZHVsZWQgPSB0aW1lb3V0XG4gIHRoaXMuX2FyZ3MgPSBhcmdzXG5cbiAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KHRpbWVyV3JhcHBlciwgdGltZW91dClcblxuICBmdW5jdGlvbiB0aW1lcldyYXBwZXIgKCkge1xuICAgIGlmICh0aGF0Ll9yZXNjaGVkdWxlZCA+IDApIHtcbiAgICAgIHRoYXQuX3NjaGVkdWxlZCA9IHRoYXQuX3Jlc2NoZWR1bGVkIC0gKGdldFRpbWUoKSAtIHRoYXQuX3N0YXJ0ZWQpXG4gICAgICB0aGF0Ll90aW1lciA9IHNldFRpbWVvdXQodGltZXJXcmFwcGVyLCB0aGF0Ll9zY2hlZHVsZWQpXG4gICAgICB0aGF0Ll9yZXNjaGVkdWxlZCA9IDBcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgdGhhdC5fYXJncylcbiAgICB9XG4gIH1cbn1cblxuUmV0aW1lci5wcm90b3R5cGUucmVzY2hlZHVsZSA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gIHZhciBub3cgPSBnZXRUaW1lKClcbiAgaWYgKChub3cgKyB0aW1lb3V0KSAtICh0aGlzLl9zdGFydGVkICsgdGhpcy5fc2NoZWR1bGVkKSA8IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9zdGFydGVkID0gbm93XG4gICAgdGhpcy5fcmVzY2hlZHVsZWQgPSB0aW1lb3V0XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5SZXRpbWVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKVxufVxuXG5mdW5jdGlvbiByZXRpbWVyICgpIHtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxiYWNrIG5lZWRlZCcpXG4gIH1cblxuICBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RpbWVvdXQgbmVlZGVkJylcbiAgfVxuXG4gIHZhciBhcmdzXG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMilcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFJldGltZXIoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sIGFyZ3MpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmV0aW1lclxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IENvbm5lY3Rpb25GU00gPSByZXF1aXJlKCcuLi9jb25uZWN0aW9uJylcbmNvbnN0IHsgRElBTF9BQk9SVEVELCBFUlJfQkxBQ0tMSVNURUQgfSA9IHJlcXVpcmUoJy4uL2Vycm9ycycpXG5jb25zdCBuZXh0VGljayA9IHJlcXVpcmUoJ2FzeW5jL25leHRUaWNrJylcbmNvbnN0IG9uY2UgPSByZXF1aXJlKCdvbmNlJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuY29uc3QgbG9nID0gZGVidWcoJ2xpYnAycDpzd2l0Y2g6ZGlhbCcpXG5sb2cuZXJyb3IgPSBkZWJ1ZygnbGlicDJwOnN3aXRjaDpkaWFsOmVycm9yJylcblxuLyoqXG4gKiBDb21wb25lbnRzIHJlcXVpcmVkIHRvIGV4ZWN1dGUgYSBkaWFsXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEaWFsUmVxdWVzdFxuICogQHByb3BlcnR5IHtQZWVySW5mb30gcGVlckluZm8gLSBUaGUgcGVlciB0byBkaWFsIHRvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3Byb3RvY29sXSAtIFRoZSBwcm90b2NvbCB0byBjcmVhdGUgYSBzdHJlYW0gZm9yXG4gKiBAcHJvcGVydHkge29iamVjdH0gb3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBvcHRpb25zLnVzZUZTTSAtIElmIGBjYWxsYmFja2Agc2hvdWxkIHJldHVybiBhIENvbm5lY3Rpb25GU01cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBvcHRpb25zLnByaW9yaXR5IC0gVGhlIHByaW9yaXR5IG9mIHRoZSBkaWFsXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKEVycm9yLCBDb25uZWN0aW9ufENvbm5lY3Rpb25GU00pfSBjYWxsYmFja1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTmV3Q29ubmVjdGlvblxuICogQHByb3BlcnR5IHtDb25uZWN0aW9uRlNNfSBjb25uZWN0aW9uRlNNXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGRpZENyZWF0ZVxuICovXG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gY3JlYXRlIGEgbmV3IGNvbm5lY3Rpb24gb3Igc3RyZWFtICh3aGVuIG11eGVkKSxcbiAqIHZpYSBuZWdvdGlhdGlvbiBvZiB0aGUgZ2l2ZW4gYHByb3RvY29sYC4gSWYgbm8gYHByb3RvY29sYCBpc1xuICogcHJvdmlkZWQsIG5vIGFjdGlvbiB3aWxsIGJlIHRha2VuIGFuZCBgY2FsbGJhY2tgIHdpbGwgYmUgY2FsbGVkXG4gKiBpbW1lZGlhdGVseSB3aXRoIG5vIGVycm9yIG9yIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMucHJvdG9jb2xcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbkZTTX0gb3B0aW9ucy5jb25uZWN0aW9uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBDb25uZWN0aW9uKX0gb3B0aW9ucy5jYWxsYmFja1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3Rpb25XaXRoUHJvdG9jb2wgKHsgcHJvdG9jb2wsIGNvbm5lY3Rpb24sIGNhbGxiYWNrIH0pIHtcbiAgaWYgKCFwcm90b2NvbCkge1xuICAgIHJldHVybiBjYWxsYmFjaygpXG4gIH1cbiAgY29ubmVjdGlvbi5zaGFrZShwcm90b2NvbCwgKGVyciwgY29ubikgPT4ge1xuICAgIGlmICghY29ubikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICB9XG5cbiAgICBjb25uLnNldFBlZXJJbmZvKGNvbm5lY3Rpb24udGhlaXJQZWVySW5mbylcbiAgICBjYWxsYmFjayhudWxsLCBjb25uKVxuICB9KVxufVxuXG4vKipcbiAqIEEgY29udmVuaWVuY2UgYXJyYXkgd3JhcHBlciBmb3IgY29udHJvbGxpbmdcbiAqIGEgcGVyIHBlZXIgcXVldWVcbiAqXG4gKiBAcmV0dXJucyB7UXVldWV9XG4gKi9cbmNsYXNzIFF1ZXVlIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGVlcklkXG4gICAqIEBwYXJhbSB7U3dpdGNofSBfc3dpdGNoXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nKX0gb25TdG9wcGVkIENhbGxlZCB3aGVuIHRoZSBxdWV1ZSBzdG9wc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHBlZXJJZCwgX3N3aXRjaCwgb25TdG9wcGVkKSB7XG4gICAgdGhpcy5pZCA9IHBlZXJJZFxuICAgIHRoaXMuc3dpdGNoID0gX3N3aXRjaFxuICAgIHRoaXMuX3F1ZXVlID0gW11cbiAgICB0aGlzLmJsYWNrTGlzdGVkID0gbnVsbFxuICAgIHRoaXMuYmxhY2tMaXN0Q291bnQgPSAwXG4gICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZVxuICAgIHRoaXMub25TdG9wcGVkID0gb25TdG9wcGVkXG4gIH1cbiAgZ2V0IGxlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlLmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGRpYWwgcmVxdWVzdCB0byB0aGUgcXVldWUuIFRoZSBxdWV1ZSBpcyBub3QgYXV0b21hdGljYWxseSBzdGFydGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm90b2NvbFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVzZUZTTSBJZiBjYWxsYmFjayBzaG91bGQgdXNlIGEgQ29ubmVjdGlvbkZTTSBpbnN0ZWFkXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIENvbm5lY3Rpb24pfSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGFkZCAocHJvdG9jb2wsIHVzZUZTTSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuaXNEaWFsQWxsb3dlZCgpKSB7XG4gICAgICByZXR1cm4gbmV4dFRpY2soY2FsbGJhY2ssIEVSUl9CTEFDS0xJU1RFRCgpKVxuICAgIH1cbiAgICB0aGlzLl9xdWV1ZS5wdXNoKHsgcHJvdG9jb2wsIHVzZUZTTSwgY2FsbGJhY2sgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IGRpYWxpbmcgaXMgY3VycmVudGx5IGFsbG93ZWRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc0RpYWxBbGxvd2VkICgpIHtcbiAgICBpZiAodGhpcy5ibGFja0xpc3RlZCkge1xuICAgICAgLy8gSWYgdGhlIGJsYWNrbGlzdCB0dGwgaGFzIHBhc3NlZCwgcmVzZXQgaXRcbiAgICAgIGlmIChEYXRlLm5vdygpID4gdGhpcy5ibGFja0xpc3RlZCkge1xuICAgICAgICB0aGlzLmJsYWNrTGlzdGVkID0gbnVsbFxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgLy8gRGlhbCBpcyBub3QgYWxsb3dlZFxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIHRoZSBxdWV1ZS4gSWYgdGhlIHF1ZXVlIHdhcyBzdGFydGVkIGB0cnVlYCB3aWxsIGJlIHJldHVybmVkLlxuICAgKiBJZiB0aGUgcXVldWUgd2FzIGFscmVhZHkgcnVubmluZyBgZmFsc2VgIGlzIHJldHVybmVkLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXJ0ICgpIHtcbiAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICBsb2coJ3N0YXJ0aW5nIGRpYWwgcXVldWUgdG8gJXMnLCB0aGlzLmlkKVxuICAgICAgdGhpcy5pc1J1bm5pbmcgPSB0cnVlXG4gICAgICB0aGlzLl9ydW4oKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgdGhlIHF1ZXVlXG4gICAqL1xuICBzdG9wICgpIHtcbiAgICBpZiAodGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIGxvZygnc3RvcHBpbmcgZGlhbCBxdWV1ZSB0byAlcycsIHRoaXMuaWQpXG4gICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlXG4gICAgICB0aGlzLm9uU3RvcHBlZCh0aGlzLmlkKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyB0aGUgcXVldWUgYW5kIGVycm9ycyB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggZGlhbCByZXF1ZXN0XG4gICAqL1xuICBhYm9ydCAoKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgICAgbGV0IGRpYWwgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpXG4gICAgICBkaWFsLmNhbGxiYWNrKERJQUxfQUJPUlRFRCgpKVxuICAgIH1cbiAgICB0aGlzLnN0b3AoKVxuICB9XG5cbiAgLyoqXG4gICAqIE1hcmtzIHRoZSBxdWV1ZSBhcyBibGFja2xpc3RlZC4gVGhlIHF1ZXVlIHdpbGwgYmUgaW1tZWRpYXRlbHkgYWJvcnRlZC5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBibGFja2xpc3QgKCkge1xuICAgIHRoaXMuYmxhY2tMaXN0Q291bnQrK1xuXG4gICAgaWYgKHRoaXMuYmxhY2tMaXN0Q291bnQgPj0gdGhpcy5zd2l0Y2guZGlhbGVyLkJMQUNLX0xJU1RfQVRURU1QVFMpIHtcbiAgICAgIHRoaXMuYmxhY2tMaXN0ZWQgPSBJbmZpbml0eVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHR0bCA9IHRoaXMuc3dpdGNoLmRpYWxlci5CTEFDS19MSVNUX1RUTCAqIE1hdGgucG93KHRoaXMuYmxhY2tMaXN0Q291bnQsIDMpXG4gICAgY29uc3QgbWluVFRMID0gdHRsICogMC45XG4gICAgY29uc3QgbWF4VFRMID0gdHRsICogMS4xXG5cbiAgICAvLyBBZGQgYSByYW5kb20gaml0dGVyIG9mIDIwJSB0byB0aGUgdHRsXG4gICAgdHRsID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heFRUTCAtIG1pblRUTCkgKyBtaW5UVEwpXG5cbiAgICB0aGlzLmJsYWNrTGlzdGVkID0gRGF0ZS5ub3coKSArIHR0bFxuICAgIHRoaXMuYWJvcnQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGZpbmQgYSBtdXhlZCBjb25uZWN0aW9uIGZvciB0aGUgZ2l2ZW4gcGVlci4gSWYgb25lXG4gICAqIGlzbid0IGZvdW5kLCBhIG5ldyBvbmUgd2lsbCBiZSBjcmVhdGVkLlxuICAgKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdHdvIGl0ZW1zLiBUaGUgQ29ubmVjdGlvbkZTTSBhbmQgd2V0aGVyXG4gICAqIG9yIG5vdCB0aGUgQ29ubmVjdGlvbkZTTSB3YXMganVzdCBjcmVhdGVkLiBUaGUgbGF0dGVyIGNhbiBiZSB1c2VkXG4gICAqIHRvIGRldGVybWluZSBkaWFsaW5nIG5lZWRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1BlZXJJbmZvfSBwZWVySW5mb1xuICAgKiBAcmV0dXJucyB7TmV3Q29ubmVjdGlvbn1cbiAgICovXG4gIF9nZXRPckNyZWF0ZUNvbm5lY3Rpb24gKHBlZXJJbmZvKSB7XG4gICAgbGV0IGNvbm5lY3Rpb25GU00gPSB0aGlzLnN3aXRjaC5jb25uZWN0aW9uLmdldE9uZSh0aGlzLmlkKVxuICAgIGxldCBkaWRDcmVhdGUgPSBmYWxzZVxuXG4gICAgaWYgKCFjb25uZWN0aW9uRlNNKSB7XG4gICAgICBjb25uZWN0aW9uRlNNID0gbmV3IENvbm5lY3Rpb25GU00oe1xuICAgICAgICBfc3dpdGNoOiB0aGlzLnN3aXRjaCxcbiAgICAgICAgcGVlckluZm8sXG4gICAgICAgIG11eGVyOiBudWxsLFxuICAgICAgICBjb25uOiBudWxsXG4gICAgICB9KVxuXG4gICAgICB0aGlzLnN3aXRjaC5jb25uZWN0aW9uLmFkZChjb25uZWN0aW9uRlNNKVxuXG4gICAgICAvLyBBZGQgY29udHJvbCBldmVudHMgYW5kIHN0YXJ0IHRoZSBkaWFsZXJcbiAgICAgIGNvbm5lY3Rpb25GU00ub25jZSgnY29ubmVjdGVkJywgKCkgPT4gY29ubmVjdGlvbkZTTS5wcm90ZWN0KCkpXG4gICAgICBjb25uZWN0aW9uRlNNLm9uY2UoJ3ByaXZhdGUnLCAoKSA9PiBjb25uZWN0aW9uRlNNLmVuY3J5cHQoKSlcbiAgICAgIGNvbm5lY3Rpb25GU00ub25jZSgnZW5jcnlwdGVkJywgKCkgPT4gY29ubmVjdGlvbkZTTS51cGdyYWRlKCkpXG5cbiAgICAgIGRpZENyZWF0ZSA9IHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4geyBjb25uZWN0aW9uRlNNLCBkaWRDcmVhdGUgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHRoZSBuZXh0IGRpYWwgaW4gdGhlIHF1ZXVlIGZvciB0aGUgZ2l2ZW4gcGVlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF9ydW4gKCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm8gaXRlbXMgaW4gdGhlIHF1ZXVlIG9yIHdlJ3JlIHN0b3BwZWQsIGV4aXRcbiAgICBpZiAodGhpcy5sZW5ndGggPCAxIHx8ICF0aGlzLmlzUnVubmluZykge1xuICAgICAgbG9nKCdzdG9wcGluZyB0aGUgcXVldWUgZm9yICVzJywgdGhpcy5pZClcbiAgICAgIHJldHVybiB0aGlzLnN0b3AoKVxuICAgIH1cblxuICAgIGNvbnN0IG5leHQgPSBvbmNlKCgpID0+IHtcbiAgICAgIGxvZygnc3RhcnRpbmcgbmV4dCBkaWFsIHRvICVzJywgdGhpcy5pZClcbiAgICAgIHRoaXMuX3J1bigpXG4gICAgfSlcblxuICAgIGNvbnN0IHBlZXJJbmZvID0gdGhpcy5zd2l0Y2guX3BlZXJCb29rLmdldCh0aGlzLmlkKVxuICAgIGxldCBxdWV1ZWREaWFsID0gdGhpcy5fcXVldWUuc2hpZnQoKVxuICAgIGxldCB7IGNvbm5lY3Rpb25GU00sIGRpZENyZWF0ZSB9ID0gdGhpcy5fZ2V0T3JDcmVhdGVDb25uZWN0aW9uKHBlZXJJbmZvKVxuXG4gICAgLy8gSWYgdGhlIGRpYWwgZXhwZWN0cyBhIENvbm5lY3Rpb25GU00sIHdlIGNhbiBwcm92aWRlIHRoYXQgYmFjayBub3dcbiAgICBpZiAocXVldWVkRGlhbC51c2VGU00pIHtcbiAgICAgIG5leHRUaWNrKHF1ZXVlZERpYWwuY2FsbGJhY2ssIG51bGwsIGNvbm5lY3Rpb25GU00pXG4gICAgfVxuXG4gICAgLy8gSWYgd2UgY2FuIGhhbmRzaGFrZSBwcm90b2NvbHMsIGdldCBhIG5ldyBzdHJlYW0gYW5kIGNhbGwgcnVuIGFnYWluXG4gICAgaWYgKFsnTVVYRUQnLCAnQ09OTkVDVEVEJ10uaW5jbHVkZXMoY29ubmVjdGlvbkZTTS5nZXRTdGF0ZSgpKSkge1xuICAgICAgcXVldWVkRGlhbC5jb25uZWN0aW9uID0gY29ubmVjdGlvbkZTTVxuICAgICAgY3JlYXRlQ29ubmVjdGlvbldpdGhQcm90b2NvbChxdWV1ZWREaWFsKVxuICAgICAgbmV4dCgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBlcnJvciwgZXJyb3IgdGhlIHF1ZXVlZCBkaWFsXG4gICAgLy8gSW4gdGhlIGZ1dHVyZSwgaXQgbWF5IGJlIGRlc2lyZWQgdG8gZXJyb3IgdGhlIG90aGVyIHF1ZXVlZCBkaWFscyxcbiAgICAvLyBkZXBlbmRpbmcgb24gdGhlIGVycm9yLlxuICAgIGNvbm5lY3Rpb25GU00ub25jZSgnZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICBxdWV1ZWREaWFsLmNhbGxiYWNrKGVycilcbiAgICAgIC8vIERvbnQgYmxhY2tsaXN0IHBlZXJzIHdlIGhhdmUgaWRlbnRpZmllZCBhbmQgdGhhdCB3ZSBhcmUgY29ubmVjdGVkIHRvXG4gICAgICBpZiAocGVlckluZm8ucHJvdG9jb2xzLnNpemUgPiAwICYmIHBlZXJJbmZvLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aGlzLmJsYWNrbGlzdCgpXG4gICAgfSlcblxuICAgIGNvbm5lY3Rpb25GU00ub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICBuZXh0KClcbiAgICB9KVxuXG4gICAgLy8gSWYgd2UncmUgbm90IG11eGVkIHlldCwgYWRkIGxpc3RlbmVyc1xuICAgIGNvbm5lY3Rpb25GU00ub25jZSgnbXV4ZWQnLCAoKSA9PiB7XG4gICAgICB0aGlzLmJsYWNrTGlzdENvdW50ID0gMCAvLyByZXNldCBibGFja2xpc3Rpbmcgb24gZ29vZCBjb25uZWN0aW9uc1xuICAgICAgcXVldWVkRGlhbC5jb25uZWN0aW9uID0gY29ubmVjdGlvbkZTTVxuICAgICAgY3JlYXRlQ29ubmVjdGlvbldpdGhQcm90b2NvbChxdWV1ZWREaWFsKVxuICAgICAgbmV4dCgpXG4gICAgfSlcblxuICAgIGNvbm5lY3Rpb25GU00ub25jZSgndW5tdXhlZCcsICgpID0+IHtcbiAgICAgIHRoaXMuYmxhY2tMaXN0Q291bnQgPSAwXG4gICAgICBxdWV1ZWREaWFsLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uRlNNXG4gICAgICBjcmVhdGVDb25uZWN0aW9uV2l0aFByb3RvY29sKHF1ZXVlZERpYWwpXG4gICAgICBuZXh0KClcbiAgICB9KVxuXG4gICAgLy8gSWYgd2UgaGF2ZSBhIG5ldyBjb25uZWN0aW9uLCBzdGFydCBkaWFsaW5nXG4gICAgaWYgKGRpZENyZWF0ZSkge1xuICAgICAgY29ubmVjdGlvbkZTTS5kaWFsKClcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBRdWV1ZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0c1xuXG5leHBvcnRzLlBST1RPQ09MX0lEID0gJy9tdWx0aXN0cmVhbS8xLjAuMCdcblxuZXhwb3J0cy5lcnJvcnMgPSB7XG4gIE1VTFRJQ09ERUNfTk9UX1NVUFBPUlRFRDogJ0VSUl9NVUxUSUNPREVDX05PVF9TVVBQT1JURUQnXG59XG4iLCIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBNYXRjaCBwcm90b2NvbHMgZXhhY3RseS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbXlQcm90b2NvbFxuICogQHBhcmFtIHtzdHJpbmd9IHNlbmRlclByb3RvY29sXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBib29sZWFuKX0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAdHlwZSB7bWF0Y2hIYW5kbGVyfVxuICovXG5mdW5jdGlvbiBtYXRjaEV4YWN0IChteVByb3RvY29sLCBzZW5kZXJQcm90b2NvbCwgY2FsbGJhY2spIHtcbiAgY29uc3QgcmVzdWx0ID0gbXlQcm90b2NvbCA9PT0gc2VuZGVyUHJvdG9jb2xcbiAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdGNoRXhhY3RcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBzZW12ZXIgPSByZXF1aXJlKCdzZW12ZXInKVxuXG4vKipcbiAqIE1hdGNoIHByb3RvY29scyB1c2luZyBzZW12ZXIgYH5gIG1hdGNoaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBteVByb3RvY29sXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VuZGVyUHJvdG9jb2xcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIGJvb2xlYW4pfSBjYWxsYmFja1xuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEB0eXBlIHttYXRjaEhhbmRsZXJ9XG4gKi9cbmZ1bmN0aW9uIG1hdGNoU2VtdmVyIChteVByb3RvY29sLCBzZW5kZXJQcm90b2NvbCwgY2FsbGJhY2spIHtcbiAgY29uc3QgbXBzID0gbXlQcm90b2NvbC5zcGxpdCgnLycpXG4gIGNvbnN0IHNwcyA9IHNlbmRlclByb3RvY29sLnNwbGl0KCcvJylcbiAgY29uc3QgbXlOYW1lID0gbXBzWzFdXG4gIGNvbnN0IG15VmVyc2lvbiA9IG1wc1syXVxuXG4gIGNvbnN0IHNlbmRlck5hbWUgPSBzcHNbMV1cbiAgY29uc3Qgc2VuZGVyVmVyc2lvbiA9IHNwc1syXVxuXG4gIGlmIChteU5hbWUgIT09IHNlbmRlck5hbWUpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZmFsc2UpXG4gIH1cbiAgLy8gZG9lcyBteSBwcm90b2NvbCBzYXRpc2Z5IHRoZSBzZW5kZXI/XG4gIGNvbnN0IHZhbGlkID0gc2VtdmVyLnNhdGlzZmllcyhteVZlcnNpb24sICd+JyArIHNlbmRlclZlcnNpb24pXG5cbiAgY2FsbGJhY2sobnVsbCwgdmFsaWQpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hTZW12ZXJcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxuY29uc3QgcHVsbCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtL3B1bGwnKVxuY29uc3QgbWFwID0gcmVxdWlyZSgncHVsbC1zdHJlYW0vdGhyb3VnaHMvbWFwJylcbmNvbnN0IGNvbGxlY3QgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS9zaW5rcy9jb2xsZWN0JylcbmNvbnN0IHRha2UgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS90aHJvdWdocy90YWtlJylcbmNvbnN0IHB1bGxMUCA9IHJlcXVpcmUoJ3B1bGwtbGVuZ3RoLXByZWZpeGVkJylcbmNvbnN0IENvbm5lY3Rpb24gPSByZXF1aXJlKCdpbnRlcmZhY2UtY29ubmVjdGlvbicpLkNvbm5lY3Rpb25cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJylcbmNvbnN0IHNlbGVjdCA9IHJlcXVpcmUoJy4uL3NlbGVjdCcpXG5jb25zdCBvbmNlID0gcmVxdWlyZSgnb25jZScpXG5cbmNvbnN0IFBST1RPQ09MX0lEID0gcmVxdWlyZSgnLi8uLi9jb25zdGFudHMnKS5QUk9UT0NPTF9JRFxuXG4vKipcbiAqXG4gKi9cbmNsYXNzIERpYWxlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgRGlhbGVyLlxuICAgKi9cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuY29ubiA9IG51bGxcbiAgICB0aGlzLmxvZyA9IHV0aWwubG9nLmRpYWxlcigpXG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSB0aGUgbXVsdGlzdHJlYW0gaGFuZHNoYWtlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb259IHJhd0Nvbm4gLSBUaGUgY29ubmVjdGlvbiBvbiB3aGljaFxuICAgKiB0byBwZXJmb3JtIHRoZSBoYW5kc2hha2UuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayAtIENhbGxlZCB3aGVuIHRoZSBoYW5kc2hha2UgY29tcGxldGVkLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgaGFuZGxlIChyYXdDb25uLCBjYWxsYmFjaykge1xuICAgIHRoaXMubG9nKCdkaWFsZXIgaGFuZGxlIGNvbm4nKVxuICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjaylcbiAgICBjb25zdCBzID0gc2VsZWN0KFBST1RPQ09MX0lELCAoZXJyLCBjb25uKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG4gICAgICB0aGlzLmxvZygnaGFuZHNoYWtlIHN1Y2Nlc3MnKVxuXG4gICAgICB0aGlzLmNvbm4gPSBuZXcgQ29ubmVjdGlvbihjb25uLCByYXdDb25uKVxuXG4gICAgICBjYWxsYmFjaygpXG4gICAgfSwgdGhpcy5sb2cpXG5cbiAgICAvLyBIYW5kbGUgdW5leHBlY3RlZCBlcnJvcnMgZnJvbSBwdWxsLCBsaWtlICdhbHJlYWR5IHBpcGVkJ1xuICAgIHRyeSB7XG4gICAgICBwdWxsKFxuICAgICAgICByYXdDb25uLFxuICAgICAgICBzLFxuICAgICAgICByYXdDb25uXG4gICAgICApXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmxvZy5lcnJvcihlcnIpXG4gICAgICBjYWxsYmFjayhlcnIpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCBhIHByb3RvY29sXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm90b2NvbCAtIEEgc3RyaW5nIG9mIHRoZSBwcm90b2NvbCB0aGF0IHdlIHdhbnQgdG8gaGFuZHNoYWtlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBDb25uZWN0aW9uKX0gY2FsbGJhY2sgLSBgZXJyYCBpc1xuICAgKiBhbiBlcnJvciBvYmplY3QgdGhhdCBnZXRzIHBhc3NlZCBpZiBzb21ldGhpbmcgd3JvbmcgaGFwcFxuICAgKiBlbmQgKGUuZzogaWYgdGhlIHByb3RvY29sIHNlbGVjdGVkIGlzIG5vdCBzdXBwb3J0ZWQgYnlcbiAgICogdGhlIG90aGVyIGVuZCkgYW5kIGNvbm4gaXMgdGhlIGNvbm5lY3Rpb24gaGFuZHNoYWtlZFxuICAgKiB3aXRoIHRoZSBvdGhlciBlbmQuXG4gICAqXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBzZWxlY3QgKHByb3RvY29sLCBjYWxsYmFjaykge1xuICAgIHRoaXMubG9nKCdkaWFsZXIgc2VsZWN0ICcgKyBwcm90b2NvbClcbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spXG4gICAgaWYgKCF0aGlzLmNvbm4pIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ211bHRpc3RyZWFtIGhhbmRzaGFrZSBoYXMgbm90IGZpbmFsaXplZCB5ZXQnKSlcbiAgICB9XG5cbiAgICBjb25zdCBzID0gc2VsZWN0KHByb3RvY29sLCAoZXJyLCBjb25uKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoaXMuY29ubiA9IG5ldyBDb25uZWN0aW9uKGNvbm4sIHRoaXMuY29ubilcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKG51bGwsIG5ldyBDb25uZWN0aW9uKGNvbm4sIHRoaXMuY29ubikpXG4gICAgfSwgdGhpcy5sb2cpXG5cbiAgICBwdWxsKFxuICAgICAgdGhpcy5jb25uLFxuICAgICAgcyxcbiAgICAgIHRoaXMuY29ublxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IGFsbCBhdmFpbGFibGUgcHJvdG9jb2xzLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBBcnJheTxzdHJpbmc+KX0gY2FsbGJhY2sgLSBJZlxuICAgKiBzb21ldGhpbmcgd3JvbmcgaGFwcGVuZCBgRXJyb3JgIGV4aXN0cywgb3RoZXJ3aXNlXG4gICAqIGBwcm90b2NvbHNgIGlzIGEgbGlzdCBvZiB0aGUgc3VwcG9ydGVkXG4gICAqIHByb3RvY29scyBvbiB0aGUgb3RoZXIgZW5kLlxuICAgKlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgbHMgKGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrKVxuXG4gICAgY29uc3QgbHNTdHJlYW0gPSBzZWxlY3QoJ2xzJywgKGVyciwgY29ubikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICBwdWxsKFxuICAgICAgICBjb25uLFxuICAgICAgICBwdWxsTFAuZGVjb2RlKCksXG4gICAgICAgIGNvbGxlY3RMcyhjb25uKSxcbiAgICAgICAgbWFwKHN0cmluZ2lmeSksXG4gICAgICAgIGNvbGxlY3QoKGVyciwgbGlzdCkgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGxpc3Quc2xpY2UoMSkpXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfSwgdGhpcy5sb2cpXG5cbiAgICBwdWxsKFxuICAgICAgdGhpcy5jb25uLFxuICAgICAgbHNTdHJlYW0sXG4gICAgICB0aGlzLmNvbm5cbiAgICApXG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5IChidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygpLnNsaWNlKDAsIC0xKVxufVxuXG5mdW5jdGlvbiBjb2xsZWN0THMgKGNvbm4pIHtcbiAgbGV0IGZpcnN0ID0gdHJ1ZVxuICBsZXQgY291bnRlciA9IDBcblxuICByZXR1cm4gdGFrZSgobXNnKSA9PiB7XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICB2YXJpbnQuZGVjb2RlKG1zZylcbiAgICAgIGNvdW50ZXIgPSB2YXJpbnQuZGVjb2RlKG1zZywgdmFyaW50LmRlY29kZS5ieXRlcylcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvdW50ZXItLSA+IDBcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEaWFsZXJcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwdWxsID0gcmVxdWlyZSgncHVsbC1zdHJlYW0vcHVsbCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3Qgc2VsZWN0ID0gcmVxdWlyZSgnLi4vc2VsZWN0JylcbmNvbnN0IHNlbGVjdEhhbmRsZXIgPSByZXF1aXJlKCcuL3NlbGVjdC1oYW5kbGVyJylcbmNvbnN0IGxzSGFuZGxlciA9IHJlcXVpcmUoJy4vbHMtaGFuZGxlcicpXG5jb25zdCBtYXRjaEV4YWN0ID0gcmVxdWlyZSgnLi9tYXRjaC1leGFjdCcpXG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLy4uL3V0aWwnKVxuY29uc3QgQ29ubmVjdGlvbiA9IHJlcXVpcmUoJ2ludGVyZmFjZS1jb25uZWN0aW9uJykuQ29ubmVjdGlvblxuXG5jb25zdCBQUk9UT0NPTF9JRCA9IHJlcXVpcmUoJy4vLi4vY29uc3RhbnRzJykuUFJPVE9DT0xfSURcblxuLyoqXG4gKiBMaXN0ZW5lclxuICovXG5jbGFzcyBMaXN0ZW5lciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgTGlzdGVuZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5oYW5kbGVycyA9IHtcbiAgICAgIGxzOiB7XG4gICAgICAgIGhhbmRsZXJGdW5jOiAocHJvdG9jb2wsIGNvbm4pID0+IGxzSGFuZGxlcih0aGlzLCBjb25uKSxcbiAgICAgICAgbWF0Y2hGdW5jOiBtYXRjaEV4YWN0XG5cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sb2cgPSB1dGlsLmxvZy5saXN0ZW5lcigpXG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSB0aGUgbXVsdGlzdHJlYW0gaGFuZHNoYWtlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb259IHJhd0Nvbm4gLSBUaGUgY29ubmVjdGlvbiBvbiB3aGljaFxuICAgKiB0byBwZXJmb3JtIHRoZSBoYW5kc2hha2UuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayAtIENhbGxlZCB3aGVuIHRoZSBoYW5kc2hha2UgY29tcGxldGVkLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgaGFuZGxlIChyYXdDb25uLCBjYWxsYmFjaykge1xuICAgIHRoaXMubG9nKCdsaXN0ZW5lciBoYW5kbGUgY29ubicpXG5cbiAgICBjb25zdCBzZWxlY3RTdHJlYW0gPSBzZWxlY3QoUFJPVE9DT0xfSUQsIChlcnIsIGNvbm4pID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2hDb25uID0gbmV3IENvbm5lY3Rpb24oY29ubiwgcmF3Q29ubilcblxuICAgICAgY29uc3Qgc2ggPSBzZWxlY3RIYW5kbGVyKHNoQ29ubiwgdGhpcy5oYW5kbGVycywgdGhpcy5sb2cpXG5cbiAgICAgIHB1bGwoXG4gICAgICAgIHNoQ29ubixcbiAgICAgICAgc2gsXG4gICAgICAgIHNoQ29ublxuICAgICAgKVxuXG4gICAgICBjYWxsYmFjaygpXG4gICAgfSwgdGhpcy5sb2cpXG5cbiAgICBwdWxsKFxuICAgICAgcmF3Q29ubixcbiAgICAgIHNlbGVjdFN0cmVhbSxcbiAgICAgIHJhd0Nvbm5cbiAgICApXG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGEgZ2l2ZW4gYHByb3RvY29sYC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3RvY29sIC0gQSBzdHJpbmcgaWRlbnRpZnlpbmcgdGhlIHByb3RvY29sLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgQ29ubmVjdGlvbil9IGhhbmRsZXJGdW5jIC0gV2lsbCBiZSBjYWxsZWQgaWYgdGhlcmUgaXMgYSBoYW5kc2hha2UgcGVyZm9ybWVkIG9uIGBwcm90b2NvbGAuXG4gICAqIEBwYXJhbSB7bWF0Y2hIYW5kbGVyfSBbbWF0Y2hGdW5jPW1hdGNoRXhhY3RdXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBhZGRIYW5kbGVyIChwcm90b2NvbCwgaGFuZGxlckZ1bmMsIG1hdGNoRnVuYykge1xuICAgIHRoaXMubG9nKCdhZGRpbmcgaGFuZGxlcjogJyArIHByb3RvY29sKVxuICAgIGFzc2VydCh0eXBlb2YgaGFuZGxlckZ1bmMgPT09ICdmdW5jdGlvbicsICdoYW5kbGVyIG11c3QgYmUgYSBmdW5jdGlvbicpXG5cbiAgICBpZiAodGhpcy5oYW5kbGVyc1twcm90b2NvbF0pIHtcbiAgICAgIHRoaXMubG9nKCdvdmVyd3JpdGluZyBoYW5kbGVyIGZvciAnICsgcHJvdG9jb2wpXG4gICAgfVxuXG4gICAgaWYgKCFtYXRjaEZ1bmMpIHtcbiAgICAgIG1hdGNoRnVuYyA9IG1hdGNoRXhhY3RcbiAgICB9XG5cbiAgICB0aGlzLmhhbmRsZXJzW3Byb3RvY29sXSA9IHtcbiAgICAgIGhhbmRsZXJGdW5jOiBoYW5kbGVyRnVuYyxcbiAgICAgIG1hdGNoRnVuYzogbWF0Y2hGdW5jXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlY2VpdmVzIGEgcHJvdG9jb2wgYW5kIGEgY2FsbGJhY2sgYW5kIHNob3VsZFxuICAgKiBjYWxsIGBjYWxsYmFjayhlcnIsIHJlc3VsdClgIHdoZXJlIGBlcnJgIGlzIGlmXG4gICAqIHRoZXJlIHdhcyBhIGVycm9yIG9uIHRoZSBtYXRjaGluZyBmdW5jdGlvbiwgYW5kXG4gICAqIGByZXN1bHRgIGlzIGEgYm9vbGVhbiB0aGF0IHJlcHJlc2VudHMgaWYgYVxuICAgKiBtYXRjaCBoYXBwZW5lZC5cbiAgICpcbiAgICogQGNhbGxiYWNrIG1hdGNoSGFuZGxlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbXlQcm90b2NvbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VuZGVyUHJvdG9jb2xcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgYm9vbGVhbil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RlbmVyXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcHJvdG9ucyA9IHJlcXVpcmUoJ3Byb3RvbnMnKVxuY29uc3Qgc2NoZW1hID0gYFxubWVzc2FnZSBJZGVudGlmeSB7XG4gIC8vIHByb3RvY29sVmVyc2lvbiBkZXRlcm1pbmVzIGNvbXBhdGliaWxpdHkgYmV0d2VlbiBwZWVyc1xuICBvcHRpb25hbCBzdHJpbmcgcHJvdG9jb2xWZXJzaW9uID0gNTsgLy8gZS5nLiBpcGZzLzEuMC4wXG5cbiAgLy8gYWdlbnRWZXJzaW9uIGlzIGxpa2UgYSBVc2VyQWdlbnQgc3RyaW5nIGluIGJyb3dzZXJzLCBvciBjbGllbnQgdmVyc2lvbiBpbiBiaXR0b3JyZW50XG4gIC8vIGluY2x1ZGVzIHRoZSBjbGllbnQgbmFtZSBhbmQgY2xpZW50LlxuICBvcHRpb25hbCBzdHJpbmcgYWdlbnRWZXJzaW9uID0gNjsgLy8gZS5nLiBnby1pcGZzLzAuMS4wXG5cbiAgLy8gcHVibGljS2V5IGlzIHRoaXMgbm9kZSdzIHB1YmxpYyBrZXkgKHdoaWNoIGFsc28gZ2l2ZXMgaXRzIG5vZGUuSUQpXG4gIC8vIC0gbWF5IG5vdCBuZWVkIHRvIGJlIHNlbnQsIGFzIHNlY3VyZSBjaGFubmVsIGltcGxpZXMgaXQgaGFzIGJlZW4gc2VudC5cbiAgLy8gLSB0aGVuIGFnYWluLCBpZiB3ZSBjaGFuZ2UgLyBkaXNhYmxlIHNlY3VyZSBjaGFubmVsLCBtYXkgc3RpbGwgd2FudCBpdC5cbiAgb3B0aW9uYWwgYnl0ZXMgcHVibGljS2V5ID0gMTtcblxuICAvLyBsaXN0ZW5BZGRycyBhcmUgdGhlIG11bHRpYWRkcnMgdGhlIHNlbmRlciBub2RlIGxpc3RlbnMgZm9yIG9wZW4gY29ubmVjdGlvbnMgb25cbiAgcmVwZWF0ZWQgYnl0ZXMgbGlzdGVuQWRkcnMgPSAyO1xuXG4gIC8vIG9zZXJ2ZWRBZGRyIGlzIHRoZSBtdWx0aWFkZHIgb2YgdGhlIHJlbW90ZSBlbmRwb2ludCB0aGF0IHRoZSBzZW5kZXIgbm9kZSBwZXJjZWl2ZXNcbiAgLy8gdGhpcyBpcyB1c2VmdWwgaW5mb3JtYXRpb24gdG8gY29udmV5IHRvIHRoZSBvdGhlciBzaWRlLCBhcyBpdCBoZWxwcyB0aGUgcmVtb3RlIGVuZHBvaW50XG4gIC8vIGRldGVybWluZSB3aGV0aGVyIGl0cyBjb25uZWN0aW9uIHRvIHRoZSBsb2NhbCBwZWVyIGdvZXMgdGhyb3VnaCBOQVQuXG4gIG9wdGlvbmFsIGJ5dGVzIG9ic2VydmVkQWRkciA9IDQ7XG5cbiAgcmVwZWF0ZWQgc3RyaW5nIHByb3RvY29scyA9IDM7XG59XG5gXG5cbm1vZHVsZS5leHBvcnRzID0gcHJvdG9ucyhzY2hlbWEpLklkZW50aWZ5XG4iLCIndXNlIHN0cmljdCdcbmNvbnN0IFBlZXJJbmZvID0gcmVxdWlyZSgncGVlci1pbmZvJylcbmNvbnN0IFBlZXJJZCA9IHJlcXVpcmUoJ3BlZXItaWQnKVxuY29uc3QgbXVsdGlhZGRyID0gcmVxdWlyZSgnbXVsdGlhZGRyJylcbmNvbnN0IHB1bGwgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS9wdWxsJylcbmNvbnN0IHRha2UgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS90aHJvdWdocy90YWtlJylcbmNvbnN0IGNvbGxlY3QgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS9zaW5rcy9jb2xsZWN0JylcbmNvbnN0IGxwID0gcmVxdWlyZSgncHVsbC1sZW5ndGgtcHJlZml4ZWQnKVxuXG5jb25zdCBtc2cgPSByZXF1aXJlKCcuL21lc3NhZ2UnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChjb25uLCBleHBlY3RlZFBlZXJJbmZvLCBjYWxsYmFjaykgPT4ge1xuICBpZiAodHlwZW9mIGV4cGVjdGVkUGVlckluZm8gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGV4cGVjdGVkUGVlckluZm9cbiAgICBleHBlY3RlZFBlZXJJbmZvID0gbnVsbFxuICAgIGNvbnNvbGUud2FybignV0FSTklORzogbm8gZXhwZWN0ZWQgcGVlciBpbmZvIHdhcyBnaXZlbiwgaWRlbnRpZnkgd2lsbCBub3QgYmUgYWJsZSB0byB2ZXJpZnkgcGVlciBpbnRlZ3JpdHknKVxuICB9XG5cbiAgcHVsbChcbiAgICBjb25uLFxuICAgIGxwLmRlY29kZSgpLFxuICAgIHRha2UoMSksXG4gICAgY29sbGVjdCgoZXJyLCBkYXRhKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG5cbiAgICAgIC8vIGNvbm5lY3Rpb24gZ290IGNsb3NlZCBncmFjaW91c2x5XG4gICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignY29ubiB3YXMgY2xvc2VkLCBkaWQgbm90IHJlY2VpdmUgZGF0YScpKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBpbnB1dCA9IG1zZy5kZWNvZGUoZGF0YVswXSlcblxuICAgICAgUGVlcklkLmNyZWF0ZUZyb21QdWJLZXkoaW5wdXQucHVibGljS2V5LCAoZXJyLCBpZCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBlZXJJbmZvID0gbmV3IFBlZXJJbmZvKGlkKVxuICAgICAgICBpZiAoZXhwZWN0ZWRQZWVySW5mbyAmJiBleHBlY3RlZFBlZXJJbmZvLmlkLnRvQjU4U3RyaW5nKCkgIT09IGlkLnRvQjU4U3RyaW5nKCkpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdpbnZhbGlkIHBlZXInKSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5wdXQubGlzdGVuQWRkcnNcbiAgICAgICAgICAgIC5tYXAobXVsdGlhZGRyKVxuICAgICAgICAgICAgLmZvckVhY2goKG1hKSA9PiBwZWVySW5mby5tdWx0aWFkZHJzLmFkZChtYSkpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb2JzZXJ2ZWRBZGRyXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvYnNlcnZlZEFkZHIgPSBnZXRPYnNlcnZlZEFkZHJzKGlucHV0KVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29weSB0aGUgcHJvdG9jb2xzXG4gICAgICAgIHBlZXJJbmZvLnByb3RvY29scyA9IG5ldyBTZXQoaW5wdXQucHJvdG9jb2xzKVxuXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHBlZXJJbmZvLCBvYnNlcnZlZEFkZHIpXG4gICAgICB9KVxuICAgIH0pXG4gIClcbn1cblxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZWRBZGRycyAoaW5wdXQpIHtcbiAgaWYgKCFoYXNPYnNlcnZlZEFkZHIoaW5wdXQpKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICBsZXQgYWRkcnMgPSBpbnB1dC5vYnNlcnZlZEFkZHJcblxuICBpZiAoIUFycmF5LmlzQXJyYXkoYWRkcnMpKSB7XG4gICAgYWRkcnMgPSBbYWRkcnNdXG4gIH1cblxuICByZXR1cm4gYWRkcnMubWFwKChvYSkgPT4gbXVsdGlhZGRyKG9hKSlcbn1cblxuZnVuY3Rpb24gaGFzT2JzZXJ2ZWRBZGRyIChpbnB1dCkge1xuICByZXR1cm4gaW5wdXQub2JzZXJ2ZWRBZGRyICYmIGlucHV0Lm9ic2VydmVkQWRkci5sZW5ndGggPiAwXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcHVsbCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtL3B1bGwnKVxuY29uc3QgdmFsdWVzID0gcmVxdWlyZSgncHVsbC1zdHJlYW0vc291cmNlcy92YWx1ZXMnKVxuY29uc3QgbHAgPSByZXF1aXJlKCdwdWxsLWxlbmd0aC1wcmVmaXhlZCcpXG5cbmNvbnN0IG1zZyA9IHJlcXVpcmUoJy4vbWVzc2FnZScpXG5cbm1vZHVsZS5leHBvcnRzID0gKGNvbm4sIHBJbmZvU2VsZikgPT4ge1xuICAvLyBzZW5kIHdoYXQgSSBzZWUgZnJvbSB0aGUgb3RoZXIgKyBteSBJbmZvXG4gIGNvbm4uZ2V0T2JzZXJ2ZWRBZGRycygoZXJyLCBvYnNlcnZlZEFkZHJzKSA9PiB7XG4gICAgaWYgKGVycikgeyByZXR1cm4gfVxuICAgIG9ic2VydmVkQWRkcnMgPSBvYnNlcnZlZEFkZHJzWzBdXG5cbiAgICBsZXQgcHVibGljS2V5ID0gQnVmZmVyLmFsbG9jKDApXG4gICAgaWYgKHBJbmZvU2VsZi5pZC5wdWJLZXkpIHtcbiAgICAgIHB1YmxpY0tleSA9IHBJbmZvU2VsZi5pZC5wdWJLZXkuYnl0ZXNcbiAgICB9XG5cbiAgICBjb25zdCBtc2dTZW5kID0gbXNnLmVuY29kZSh7XG4gICAgICBwcm90b2NvbFZlcnNpb246ICdpcGZzLzAuMS4wJyxcbiAgICAgIGFnZW50VmVyc2lvbjogJ25hJyxcbiAgICAgIHB1YmxpY0tleTogcHVibGljS2V5LFxuICAgICAgbGlzdGVuQWRkcnM6IHBJbmZvU2VsZi5tdWx0aWFkZHJzLnRvQXJyYXkoKS5tYXAoKG1hKSA9PiBtYS5idWZmZXIpLFxuICAgICAgb2JzZXJ2ZWRBZGRyOiBvYnNlcnZlZEFkZHJzID8gb2JzZXJ2ZWRBZGRycy5idWZmZXIgOiBCdWZmZXIuZnJvbSgnJyksXG4gICAgICBwcm90b2NvbHM6IEFycmF5LmZyb20ocEluZm9TZWxmLnByb3RvY29scylcbiAgICB9KVxuXG4gICAgcHVsbChcbiAgICAgIHZhbHVlcyhbbXNnU2VuZF0pLFxuICAgICAgbHAuZW5jb2RlKCksXG4gICAgICBjb25uXG4gICAgKVxuICB9KVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IENvbm5lY3Rpb24gPSByZXF1aXJlKCdpbnRlcmZhY2UtY29ubmVjdGlvbicpLkNvbm5lY3Rpb25cbmNvbnN0IHB1bGwgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS9wdWxsJylcbmNvbnN0IGVtcHR5ID0gcmVxdWlyZSgncHVsbC1zdHJlYW0vc291cmNlcy9lbXB0eScpXG5jb25zdCB0aW1lb3V0ID0gcmVxdWlyZSgnYXN5bmMvdGltZW91dCcpXG5jb25zdCBxdWV1ZSA9IHJlcXVpcmUoJ2FzeW5jL3F1ZXVlJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuY29uc3Qgb25jZSA9IHJlcXVpcmUoJ29uY2UnKVxuXG5jb25zdCBsb2cgPSBkZWJ1ZygnbGlicDJwOnN3aXRjaDpkaWFsZXI6cXVldWUnKVxubG9nLmVycm9yID0gZGVidWcoJ2xpYnAycDpzd2l0Y2g6ZGlhbGVyOnF1ZXVlOmVycm9yJylcblxuLyoqXG4gKiBRdWV1ZSB1cCB0aGUgYW1vdW50IG9mIGRpYWxzIHRvIGEgZ2l2ZW4gcGVlci5cbiAqL1xuY2xhc3MgRGlhbFF1ZXVlIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBkaWFsIHF1ZXVlLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGltaXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRpYWxUaW1lb3V0XG4gICAqL1xuICBjb25zdHJ1Y3RvciAobGltaXQsIGRpYWxUaW1lb3V0KSB7XG4gICAgdGhpcy5kaWFsVGltZW91dCA9IGRpYWxUaW1lb3V0XG5cbiAgICB0aGlzLnF1ZXVlID0gcXVldWUoKHRhc2ssIGNiKSA9PiB7XG4gICAgICB0aGlzLl9kb1dvcmsodGFzay50cmFuc3BvcnQsIHRhc2suYWRkciwgdGFzay50b2tlbiwgY2IpXG4gICAgfSwgbGltaXQpXG4gIH1cblxuICAvKipcbiAgICogVGhlIGFjdHVhbCB3b3JrIGRvbmUgYnkgdGhlIHF1ZXVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N3YXJtVHJhbnNwb3J0fSB0cmFuc3BvcnRcbiAgICogQHBhcmFtIHtNdWx0aWFkZHJ9IGFkZHJcbiAgICogQHBhcmFtIHtDYW5jZWxUb2tlbn0gdG9rZW5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgQ29ubmVjdGlvbil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RvV29yayAodHJhbnNwb3J0LCBhZGRyLCB0b2tlbiwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spXG4gICAgbG9nKCd3b3JrOnN0YXJ0JylcbiAgICB0aGlzLl9kaWFsV2l0aFRpbWVvdXQodHJhbnNwb3J0LCBhZGRyLCAoZXJyLCBjb25uKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGxvZy5lcnJvcihgJHt0cmFuc3BvcnQuY29uc3RydWN0b3IubmFtZX06d29ya2AsIGVycilcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLmNhbmNlbCkge1xuICAgICAgICBsb2coJ3dvcms6Y2FuY2VsJylcbiAgICAgICAgLy8gY2xlYW4gdXAgYWxyZWFkeSBkb25lIGRpYWxzXG4gICAgICAgIHB1bGwoZW1wdHkoKSwgY29ubilcbiAgICAgICAgLy8gSWYgd2UgY2FuIGNsb3NlIHRoZSBjb25uZWN0aW9uLCBkbyBpdFxuICAgICAgICBpZiAodHlwZW9mIGNvbm4uY2xvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gY29ubi5jbG9zZSgoXykgPT4gY2FsbGJhY2sobnVsbCkpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpXG4gICAgICB9XG5cbiAgICAgIC8vIG9uZSBpcyBlbm91Z2hcbiAgICAgIHRva2VuLmNhbmNlbCA9IHRydWVcblxuICAgICAgbG9nKCd3b3JrOnN1Y2Nlc3MnKVxuXG4gICAgICBjb25zdCBwcm94eUNvbm4gPSBuZXcgQ29ubmVjdGlvbigpXG4gICAgICBwcm94eUNvbm4uc2V0SW5uZXJDb25uKGNvbm4pXG4gICAgICBjYWxsYmFjayhudWxsLCB7IG11bHRpYWRkcjogYWRkciwgY29ubjogY29ubiB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRGlhbCB0aGUgZ2l2ZW4gdHJhbnNwb3J0LCB0aW1pbmcgb3V0IHdpdGggdGhlIHNldCB0aW1lb3V0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N3YXJtVHJhbnNwb3J0fSB0cmFuc3BvcnRcbiAgICogQHBhcmFtIHtNdWx0aWFkZHJ9IGFkZHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgQ29ubmVjdGlvbil9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RpYWxXaXRoVGltZW91dCAodHJhbnNwb3J0LCBhZGRyLCBjYWxsYmFjaykge1xuICAgIHRpbWVvdXQoKGNiKSA9PiB7XG4gICAgICBjb25zdCBjb25uID0gdHJhbnNwb3J0LmRpYWwoYWRkciwgKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgICAgfVxuXG4gICAgICAgIGNiKG51bGwsIGNvbm4pXG4gICAgICB9KVxuICAgIH0sIHRoaXMuZGlhbFRpbWVvdXQpKGNhbGxiYWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBuZXcgd29yayB0byB0aGUgcXVldWUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3dhcm1UcmFuc3BvcnR9IHRyYW5zcG9ydFxuICAgKiBAcGFyYW0ge011bHRpYWRkcn0gYWRkclxuICAgKiBAcGFyYW0ge0NhbmNlbFRva2VufSB0b2tlblxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBDb25uZWN0aW9uKX0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBwdXNoICh0cmFuc3BvcnQsIGFkZHIsIHRva2VuLCBjYWxsYmFjaykge1xuICAgIHRoaXMucXVldWUucHVzaCh7IHRyYW5zcG9ydCwgYWRkciwgdG9rZW4gfSwgY2FsbGJhY2spXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEaWFsUXVldWVcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBtdWx0aWFkZHIgPSByZXF1aXJlKCdtdWx0aWFkZHInKVxuY29uc3QgUGVlckluZm8gPSByZXF1aXJlKCdwZWVyLWluZm8nKVxuY29uc3QgUGVlcklkID0gcmVxdWlyZSgncGVlci1pZCcpXG5jb25zdCBwcm90byA9IHJlcXVpcmUoJy4uL3Byb3RvY29sJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3dhcm0pIHtcbiAgLyoqXG4gICAqIEdldCBiNTggc3RyaW5nIGZyb20gbXVsdGlhZGRyIG9yIHBlZXJpbmZvXG4gICAqXG4gICAqIEBwYXJhbSB7TXVsdGlhZGRyfFBlZXJJbmZvfSBwZWVyXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRCNThTdHJpbmcgKHBlZXIpIHtcbiAgICBsZXQgYjU4SWQgPSBudWxsXG4gICAgaWYgKG11bHRpYWRkci5pc011bHRpYWRkcihwZWVyKSkge1xuICAgICAgY29uc3QgcmVsYXlNYSA9IG11bHRpYWRkcihwZWVyKVxuICAgICAgYjU4SWQgPSByZWxheU1hLmdldFBlZXJJZCgpXG4gICAgfSBlbHNlIGlmIChQZWVySW5mby5pc1BlZXJJbmZvKHBlZXIpKSB7XG4gICAgICBiNThJZCA9IHBlZXIuaWQudG9CNThTdHJpbmcoKVxuICAgIH1cblxuICAgIHJldHVybiBiNThJZFxuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB0byBtYWtlIGEgcGVlciBpbmZvIGZyb20gYSBtdWx0aWFkZHJzXG4gICAqXG4gICAqIEBwYXJhbSB7TXVsdGlhZGRyfFBlZXJJbmZvfFBlZXJJZH0gbWFcbiAgICogQHBhcmFtIHtTd2FybX0gc3dhcm1cbiAgICogQHJldHVybiB7UGVlckluZm99XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAvLyBUT0RPOiB0aGlzIGlzIHJpcHBlZCBvZmYgb2YgbGlicDJwLCBzaG91bGQgcHJvYmFibHkgYmUgYSBnZW5lcmFsbHkgYXZhaWxhYmxlIHV0aWwgZnVuY3Rpb25cbiAgZnVuY3Rpb24gcGVlckluZm9Gcm9tTWEgKHBlZXIpIHtcbiAgICBsZXQgcFxuICAgIC8vIFBlZXJJbmZvXG4gICAgaWYgKFBlZXJJbmZvLmlzUGVlckluZm8ocGVlcikpIHtcbiAgICAgIHAgPSBwZWVyXG4gICAgICAvLyBNdWx0aWFkZHIgaW5zdGFuY2UgKG5vdCBzdHJpbmcpXG4gICAgfSBlbHNlIGlmIChtdWx0aWFkZHIuaXNNdWx0aWFkZHIocGVlcikpIHtcbiAgICAgIGNvbnN0IHBlZXJJZEI1OFN0ciA9IHBlZXIuZ2V0UGVlcklkKClcbiAgICAgIHRyeSB7XG4gICAgICAgIHAgPSBzd2FybS5fcGVlckJvb2suZ2V0KHBlZXJJZEI1OFN0cilcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBwID0gbmV3IFBlZXJJbmZvKFBlZXJJZC5jcmVhdGVGcm9tQjU4U3RyaW5nKHBlZXJJZEI1OFN0cikpXG4gICAgICB9XG4gICAgICBwLm11bHRpYWRkcnMuYWRkKHBlZXIpXG4gICAgICAvLyBQZWVySWRcbiAgICB9IGVsc2UgaWYgKFBlZXJJZC5pc1BlZXJJZChwZWVyKSkge1xuICAgICAgY29uc3QgcGVlcklkQjU4U3RyID0gcGVlci50b0I1OFN0cmluZygpXG4gICAgICBwID0gc3dhcm0uX3BlZXJCb29rLmhhcyhwZWVySWRCNThTdHIpID8gc3dhcm0uX3BlZXJCb29rLmdldChwZWVySWRCNThTdHIpIDogcGVlclxuICAgIH1cblxuICAgIHJldHVybiBwXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHBlZXIgaGFzIGFuIGV4aXN0aW5nIGNvbm5lY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBlZXJJZFxuICAgKiBAcGFyYW0ge1N3YXJtfSBzd2FybVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gaXNQZWVyQ29ubmVjdGVkIChwZWVySWQpIHtcbiAgICByZXR1cm4gc3dhcm0ubXV4ZWRDb25uc1twZWVySWRdIHx8IHN3YXJtLmNvbm5zW3BlZXJJZF1cbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBhIHJlc3BvbnNlXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyZWFtSGFuZGxlcn0gc3RyZWFtSGFuZGxlclxuICAgKiBAcGFyYW0ge0NpcmN1aXRSZWxheS5TdGF0dXN9IHN0YXR1c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGZ1bmN0aW9uIHdyaXRlUmVzcG9uc2UgKHN0cmVhbUhhbmRsZXIsIHN0YXR1cywgY2IpIHtcbiAgICBjYiA9IGNiIHx8ICgoKSA9PiB7fSlcbiAgICBzdHJlYW1IYW5kbGVyLndyaXRlKHByb3RvLkNpcmN1aXRSZWxheS5lbmNvZGUoe1xuICAgICAgdHlwZTogcHJvdG8uQ2lyY3VpdFJlbGF5LlR5cGUuU1RBVFVTLFxuICAgICAgY29kZTogc3RhdHVzXG4gICAgfSkpXG4gICAgcmV0dXJuIGNiKClcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBpbmNvbW1pbmcgSE9QL1NUT1AgbWVzc2FnZVxuICAgKlxuICAgKiBAcGFyYW0ge0NpcmN1aXRSZWxheX0gbXNnXG4gICAqIEBwYXJhbSB7U3RyZWFtSGFuZGxlcn0gc3RyZWFtSGFuZGxlclxuICAgKiBAcGFyYW0ge0NpcmN1aXRSZWxheS5UeXBlfSB0eXBlXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKi9cbiAgZnVuY3Rpb24gdmFsaWRhdGVBZGRycyAobXNnLCBzdHJlYW1IYW5kbGVyLCB0eXBlLCBjYikge1xuICAgIHRyeSB7XG4gICAgICBtc2cuZHN0UGVlci5hZGRycy5mb3JFYWNoKChhZGRyKSA9PiB7XG4gICAgICAgIHJldHVybiBtdWx0aWFkZHIoYWRkcilcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB3cml0ZVJlc3BvbnNlKHN0cmVhbUhhbmRsZXIsIHR5cGUgPT09IHByb3RvLkNpcmN1aXRSZWxheS5UeXBlLkhPUFxuICAgICAgICA/IHByb3RvLkNpcmN1aXRSZWxheS5TdGF0dXMuSE9QX0RTVF9NVUxUSUFERFJfSU5WQUxJRFxuICAgICAgICA6IHByb3RvLkNpcmN1aXRSZWxheS5TdGF0dXMuU1RPUF9EU1RfTVVMVElBRERSX0lOVkFMSUQpXG4gICAgICByZXR1cm4gY2IoZXJyKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBtc2cuc3JjUGVlci5hZGRycy5mb3JFYWNoKChhZGRyKSA9PiB7XG4gICAgICAgIHJldHVybiBtdWx0aWFkZHIoYWRkcilcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB3cml0ZVJlc3BvbnNlKHN0cmVhbUhhbmRsZXIsIHR5cGUgPT09IHByb3RvLkNpcmN1aXRSZWxheS5UeXBlLkhPUFxuICAgICAgICA/IHByb3RvLkNpcmN1aXRSZWxheS5TdGF0dXMuSE9QX1NSQ19NVUxUSUFERFJfSU5WQUxJRFxuICAgICAgICA6IHByb3RvLkNpcmN1aXRSZWxheS5TdGF0dXMuU1RPUF9TUkNfTVVMVElBRERSX0lOVkFMSUQpXG4gICAgICByZXR1cm4gY2IoZXJyKVxuICAgIH1cblxuICAgIHJldHVybiBjYihudWxsKVxuICB9XG5cbiAgZnVuY3Rpb24gcGVlcklkRnJvbUlkIChpZCkge1xuICAgIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gUGVlcklkLmNyZWF0ZUZyb21CNThTdHJpbmcoaWQpXG4gICAgfVxuXG4gICAgcmV0dXJuIFBlZXJJZC5jcmVhdGVGcm9tQnl0ZXMoaWQpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGdldEI1OFN0cmluZyxcbiAgICBwZWVySW5mb0Zyb21NYSxcbiAgICBpc1BlZXJDb25uZWN0ZWQsXG4gICAgdmFsaWRhdGVBZGRycyxcbiAgICB3cml0ZVJlc3BvbnNlLFxuICAgIHBlZXJJZEZyb21JZFxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3Qgb25jZSA9IHJlcXVpcmUoJ29uY2UnKVxuY29uc3QgUGVlcklkID0gcmVxdWlyZSgncGVlci1pZCcpXG5jb25zdCB3YXRlcmZhbGwgPSByZXF1aXJlKCdhc3luYy93YXRlcmZhbGwnKVxuY29uc3Qgc2V0SW1tZWRpYXRlID0gcmVxdWlyZSgnYXN5bmMvc2V0SW1tZWRpYXRlJylcbmNvbnN0IG11bHRpYWRkciA9IHJlcXVpcmUoJ211bHRpYWRkcicpXG5cbmNvbnN0IENvbm5lY3Rpb24gPSByZXF1aXJlKCdpbnRlcmZhY2UtY29ubmVjdGlvbicpLkNvbm5lY3Rpb25cblxuY29uc3QgdXRpbHNGYWN0b3J5ID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBTdHJlYW1IYW5kbGVyID0gcmVxdWlyZSgnLi9zdHJlYW0taGFuZGxlcicpXG5cbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuY29uc3QgbG9nID0gZGVidWcoJ2xpYnAycDpjaXJjdWl0OmRpYWxlcicpXG5sb2cuZXJyID0gZGVidWcoJ2xpYnAycDpjaXJjdWl0OmVycm9yOmRpYWxlcicpXG5cbmNvbnN0IG11bHRpY29kZWMgPSByZXF1aXJlKCcuLi9tdWx0aWNvZGVjJylcbmNvbnN0IHByb3RvID0gcmVxdWlyZSgnLi4vcHJvdG9jb2wnKVxuXG5jbGFzcyBEaWFsZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBEaWFsZXIuXG4gICAqIEBwYXJhbSB7U3dhcm19IHN3YXJtIC0gdGhlIHN3YXJtXG4gICAqIEBwYXJhbSB7YW55fSBvcHRpb25zIC0gY29uZmlnIG9wdGlvbnNcbiAgICpcbiAgICogQG1lbWJlck9mIERpYWxlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKHN3YXJtLCBvcHRpb25zKSB7XG4gICAgdGhpcy5zd2FybSA9IHN3YXJtXG4gICAgdGhpcy5yZWxheVBlZXJzID0gbmV3IE1hcCgpXG4gICAgdGhpcy5yZWxheUNvbm5zID0gbmV3IE1hcCgpXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMudXRpbHMgPSB1dGlsc0ZhY3Rvcnkoc3dhcm0pXG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIHRoYXQgcmV0dXJucyBhIHJlbGF5IGNvbm5lY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHsqfSByZWxheVxuICAgKiBAcGFyYW0geyp9IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gLSBjYWxsYmFja1xuICAgKi9cbiAgX2RpYWxSZWxheUhlbHBlciAocmVsYXksIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMucmVsYXlDb25ucy5oYXMocmVsYXkuaWQudG9CNThTdHJpbmcoKSkpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB0aGlzLnJlbGF5Q29ubnMuZ2V0KHJlbGF5LmlkLnRvQjU4U3RyaW5nKCkpKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9kaWFsUmVsYXkocmVsYXksIGNhbGxiYWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIERpYWwgYSBwZWVyIG92ZXIgYSByZWxheVxuICAgKlxuICAgKiBAcGFyYW0ge211bHRpYWRkcn0gbWEgLSB0aGUgbXVsdGlhZGRyIG9mIHRoZSBwZWVyIHRvIGRpYWxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBhIGNhbGxiYWNrIGNhbGxlZCBvbmNlIGRpYWxlZFxuICAgKiBAcmV0dXJucyB7Q29ubmVjdGlvbn0gLSB0aGUgY29ubmVjdGlvblxuICAgKlxuICAgKi9cbiAgZGlhbCAobWEsIGNiKSB7XG4gICAgY2IgPSBjYiB8fCAoKCkgPT4geyB9KVxuICAgIGNvbnN0IHN0ck1hID0gbWEudG9TdHJpbmcoKVxuICAgIGlmICghc3RyTWEuaW5jbHVkZXMoJy9wMnAtY2lyY3VpdCcpKSB7XG4gICAgICBsb2cuZXJyKCdpbnZhbGlkIGNpcmN1aXQgYWRkcmVzcycpXG4gICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdpbnZhbGlkIGNpcmN1aXQgYWRkcmVzcycpKVxuICAgIH1cblxuICAgIGNvbnN0IGFkZHIgPSBzdHJNYS5zcGxpdCgncDJwLWNpcmN1aXQnKSAvLyBleHRyYWN0IHJlbGF5IGFkZHJlc3MgaWYgYW55XG4gICAgY29uc3QgcmVsYXkgPSBhZGRyWzBdID09PSAnLycgPyBudWxsIDogbXVsdGlhZGRyKGFkZHJbMF0pXG4gICAgY29uc3QgcGVlciA9IG11bHRpYWRkcihhZGRyWzFdIHx8IGFkZHJbMF0pXG5cbiAgICBjb25zdCBkc3RDb25uID0gbmV3IENvbm5lY3Rpb24oKVxuICAgIHNldEltbWVkaWF0ZShcbiAgICAgIHRoaXMuX2RpYWxQZWVyLmJpbmQodGhpcyksXG4gICAgICBwZWVyLFxuICAgICAgcmVsYXksXG4gICAgICAoZXJyLCBjb25uKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBsb2cuZXJyKGVycilcbiAgICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgICB9XG5cbiAgICAgICAgZHN0Q29ubi5zZXRJbm5lckNvbm4oY29ubilcbiAgICAgICAgY2IobnVsbCwgZHN0Q29ubilcbiAgICAgIH0pXG5cbiAgICByZXR1cm4gZHN0Q29ublxuICB9XG5cbiAgLyoqXG4gICAqIERvZXMgdGhlIHBlZXIgc3VwcG9ydCB0aGUgSE9QIHByb3RvY29sXG4gICAqXG4gICAqIEBwYXJhbSB7UGVlckluZm99IHBlZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBjYW5Ib3AgKHBlZXIsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8ICgoKSA9PiB7IH0pKVxuXG4gICAgdGhpcy5fZGlhbFJlbGF5SGVscGVyKHBlZXIsIChlcnIsIGNvbm4pID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2ggPSBuZXcgU3RyZWFtSGFuZGxlcihjb25uKVxuICAgICAgd2F0ZXJmYWxsKFtcbiAgICAgICAgKGNiKSA9PiBzaC53cml0ZShwcm90by5DaXJjdWl0UmVsYXkuZW5jb2RlKHtcbiAgICAgICAgICB0eXBlOiBwcm90by5DaXJjdWl0UmVsYXkuVHlwZS5DQU5fSE9QXG4gICAgICAgIH0pLCBjYiksXG4gICAgICAgIChjYikgPT4gc2gucmVhZChjYilcbiAgICAgIF0sIChlcnIsIG1zZykgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHByb3RvLkNpcmN1aXRSZWxheS5kZWNvZGUobXNnKVxuXG4gICAgICAgIGlmIChyZXNwb25zZS5jb2RlICE9PSBwcm90by5DaXJjdWl0UmVsYXkuU3RhdHVzLlNVQ0NFU1MpIHtcbiAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYEhPUCBub3Qgc3VwcG9ydGVkLCBza2lwcGluZyAtICR7dGhpcy51dGlscy5nZXRCNThTdHJpbmcocGVlcil9YClcbiAgICAgICAgICBsb2coZXJyKVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cblxuICAgICAgICBsb2coJ0hPUCBzdXBwb3J0ZWQgYWRkaW5nIGFzIHJlbGF5IC0gJXMnLCB0aGlzLnV0aWxzLmdldEI1OFN0cmluZyhwZWVyKSlcbiAgICAgICAgdGhpcy5yZWxheVBlZXJzLnNldCh0aGlzLnV0aWxzLmdldEI1OFN0cmluZyhwZWVyKSwgcGVlcilcbiAgICAgICAgc2guY2xvc2UoKVxuICAgICAgICBjYWxsYmFjaygpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRGlhbCB0aGUgZGVzdGluYXRpb24gcGVlciBvdmVyIGEgcmVsYXlcbiAgICpcbiAgICogQHBhcmFtIHttdWx0aWFkZHJ9IGRzdE1hXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbnxQZWVySW5mb30gcmVsYXlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICogQHJldHVybiB7RnVuY3Rpb258dm9pZH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kaWFsUGVlciAoZHN0TWEsIHJlbGF5LCBjYikge1xuICAgIGlmICh0eXBlb2YgcmVsYXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gcmVsYXlcbiAgICAgIHJlbGF5ID0gbnVsbFxuICAgIH1cblxuICAgIGlmICghY2IpIHtcbiAgICAgIGNiID0gKCkgPT4ge31cbiAgICB9XG5cbiAgICBkc3RNYSA9IG11bHRpYWRkcihkc3RNYSlcbiAgICAvLyBpZiBubyByZWxheSBwcm92aWRlZCwgZGlhbCBvbiBhbGwgYXZhaWxhYmxlIHJlbGF5cyB1bnRpbCBvbmUgc3VjY2VlZHNcbiAgICBpZiAoIXJlbGF5KSB7XG4gICAgICBjb25zdCByZWxheXMgPSBBcnJheS5mcm9tKHRoaXMucmVsYXlQZWVycy52YWx1ZXMoKSlcbiAgICAgIGxldCBuZXh0ID0gKG5leHRSZWxheSkgPT4ge1xuICAgICAgICBpZiAoIW5leHRSZWxheSkge1xuICAgICAgICAgIGxldCBlcnIgPSBgbm8gcmVsYXkgcGVlcnMgd2VyZSBmb3VuZCBvciBhbGwgcmVsYXlzIGZhaWxlZCB0byBkaWFsYFxuICAgICAgICAgIGxvZy5lcnIoZXJyKVxuICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fbmVnb3RpYXRlUmVsYXkoXG4gICAgICAgICAgbmV4dFJlbGF5LFxuICAgICAgICAgIGRzdE1hLFxuICAgICAgICAgIChlcnIsIGNvbm4pID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgbG9nLmVycihlcnIpXG4gICAgICAgICAgICAgIHJldHVybiBuZXh0KHJlbGF5cy5zaGlmdCgpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2IobnVsbCwgY29ubilcbiAgICAgICAgICB9KVxuICAgICAgfVxuICAgICAgbmV4dChyZWxheXMuc2hpZnQoKSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX25lZ290aWF0ZVJlbGF5KFxuICAgICAgICByZWxheSxcbiAgICAgICAgZHN0TWEsXG4gICAgICAgIChlcnIsIGNvbm4pID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBsb2cuZXJyKCdBbiBlcnJvciBoYXMgb2NjdXJyZWQgbmVnb3RpYXRpbmcgdGhlIHJlbGF5IGNvbm5lY3Rpb24nLCBlcnIpXG4gICAgICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjYihudWxsLCBjb25uKVxuICAgICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBOZWdvdGlhdGUgdGhlIHJlbGF5IGNvbm5lY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtNdWx0aWFkZHJ8UGVlckluZm98Q29ubmVjdGlvbn0gcmVsYXkgLSB0aGUgQ29ubmVjdGlvbiBvciBQZWVySW5mbyBvZiB0aGUgcmVsYXlcbiAgICogQHBhcmFtIHttdWx0aWFkZHJ9IGRzdE1hIC0gdGhlIG11bHRpYWRkciBvZiB0aGUgcGVlciB0byByZWxheSB0aGUgY29ubmVjdGlvbiBmb3JcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBhIGNhbGxiYWNrIHdoaWNoIGdldHMgdGhlIG5lZ290aWF0ZWQgcmVsYXkgY29ubmVjdGlvblxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQG1lbWJlck9mIERpYWxlclxuICAgKi9cbiAgX25lZ290aWF0ZVJlbGF5IChyZWxheSwgZHN0TWEsIGNhbGxiYWNrKSB7XG4gICAgZHN0TWEgPSBtdWx0aWFkZHIoZHN0TWEpXG4gICAgcmVsYXkgPSB0aGlzLnV0aWxzLnBlZXJJbmZvRnJvbU1hKHJlbGF5KVxuICAgIGNvbnN0IHNyY01hcyA9IHRoaXMuc3dhcm0uX3BlZXJJbmZvLm11bHRpYWRkcnMudG9BcnJheSgpXG4gICAgdGhpcy5fZGlhbFJlbGF5SGVscGVyKHJlbGF5LCAoZXJyLCBjb25uKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGxvZy5lcnIoZXJyKVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuICAgICAgbGV0IHNoID0gbmV3IFN0cmVhbUhhbmRsZXIoY29ubilcbiAgICAgIHdhdGVyZmFsbChbXG4gICAgICAgIChjYikgPT4ge1xuICAgICAgICAgIGxvZygnbmVnb3RpYXRpbmcgcmVsYXkgZm9yIHBlZXIgJXMnLCBkc3RNYS5nZXRQZWVySWQoKSlcbiAgICAgICAgICBsZXQgZHN0UGVlcklkXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRzdFBlZXJJZCA9IFBlZXJJZC5jcmVhdGVGcm9tQjU4U3RyaW5nKGRzdE1hLmdldFBlZXJJZCgpKS5pZFxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgICAgICB9XG4gICAgICAgICAgc2gud3JpdGUoXG4gICAgICAgICAgICBwcm90by5DaXJjdWl0UmVsYXkuZW5jb2RlKHtcbiAgICAgICAgICAgICAgdHlwZTogcHJvdG8uQ2lyY3VpdFJlbGF5LlR5cGUuSE9QLFxuICAgICAgICAgICAgICBzcmNQZWVyOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuc3dhcm0uX3BlZXJJbmZvLmlkLmlkLFxuICAgICAgICAgICAgICAgIGFkZHJzOiBzcmNNYXMubWFwKChhZGRyKSA9PiBhZGRyLmJ1ZmZlcilcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHN0UGVlcjoge1xuICAgICAgICAgICAgICAgIGlkOiBkc3RQZWVySWQsXG4gICAgICAgICAgICAgICAgYWRkcnM6IFtkc3RNYS5idWZmZXJdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCBjYilcbiAgICAgICAgfSxcbiAgICAgICAgKGNiKSA9PiBzaC5yZWFkKGNiKVxuICAgICAgXSwgKGVyciwgbXNnKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBwcm90by5DaXJjdWl0UmVsYXkuZGVjb2RlKG1zZylcbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gcHJvdG8uQ2lyY3VpdFJlbGF5LlR5cGUuU1RBVFVTKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihgR290IGludmFsaWQgbWVzc2FnZSB0eXBlIC0gYCArXG4gICAgICAgICAgICBgZXhwZWN0ZWQgJHtwcm90by5DaXJjdWl0UmVsYXkuVHlwZS5TVEFUVVN9IGdvdCAke21lc3NhZ2UudHlwZX1gKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXNzYWdlLmNvZGUgIT09IHByb3RvLkNpcmN1aXRSZWxheS5TdGF0dXMuU1VDQ0VTUykge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoYEdvdCAke21lc3NhZ2UuY29kZX0gZXJyb3IgY29kZSB0cnlpbmcgdG8gZGlhbCBvdmVyIHJlbGF5YCkpXG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhudWxsLCBuZXcgQ29ubmVjdGlvbihzaC5yZXN0KCkpKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIERpYWwgYSByZWxheSBwZWVyIGJ5IGl0cyBQZWVySW5mb1xuICAgKlxuICAgKiBAcGFyYW0ge1BlZXJJbmZvfSBwZWVyIC0gdGhlIFBlZXJJbmZvIG9mIHRoZSByZWxheSBwZWVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gYSBjYWxsYmFjayB3aXRoIHRoZSBjb25uZWN0aW9uIHRvIHRoZSByZWxheSBwZWVyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RpYWxSZWxheSAocGVlciwgY2IpIHtcbiAgICBjYiA9IG9uY2UoY2IgfHwgKCgpID0+IHsgfSkpXG5cbiAgICB0aGlzLnN3YXJtLmRpYWwoXG4gICAgICBwZWVyLFxuICAgICAgbXVsdGljb2RlYy5yZWxheSxcbiAgICAgIG9uY2UoKGVyciwgY29ubikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgbG9nLmVycihlcnIpXG4gICAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgICAgfVxuICAgICAgICBjYihudWxsLCBjb25uKVxuICAgICAgfSkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEaWFsZXJcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdhc3luYy9zZXRJbW1lZGlhdGUnKVxuXG5jb25zdCBtdWx0aWNvZGVjID0gcmVxdWlyZSgnLi9tdWx0aWNvZGVjJylcbmNvbnN0IEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5jb25zdCBtdWx0aWFkZHIgPSByZXF1aXJlKCdtdWx0aWFkZHInKVxuY29uc3QgbWFmbXQgPSByZXF1aXJlKCdtYWZtdCcpXG5jb25zdCBTdG9wID0gcmVxdWlyZSgnLi9jaXJjdWl0L3N0b3AnKVxuY29uc3QgSG9wID0gcmVxdWlyZSgnLi9jaXJjdWl0L2hvcCcpXG5jb25zdCBwcm90byA9IHJlcXVpcmUoJy4vcHJvdG9jb2wnKVxuY29uc3QgdXRpbHNGYWN0b3J5ID0gcmVxdWlyZSgnLi9jaXJjdWl0L3V0aWxzJylcblxuY29uc3QgU3RyZWFtSGFuZGxlciA9IHJlcXVpcmUoJy4vY2lyY3VpdC9zdHJlYW0taGFuZGxlcicpXG5cbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuXG5jb25zdCBsb2cgPSBkZWJ1ZygnbGlicDJwOmNpcmN1aXQ6bGlzdGVuZXInKVxubG9nLmVyciA9IGRlYnVnKCdsaWJwMnA6Y2lyY3VpdDplcnJvcjpsaXN0ZW5lcicpXG5cbm1vZHVsZS5leHBvcnRzID0gKHN3YXJtLCBvcHRpb25zLCBjb25uSGFuZGxlcikgPT4ge1xuICBjb25zdCBsaXN0ZW5lciA9IG5ldyBFRSgpXG4gIGNvbnN0IHV0aWxzID0gdXRpbHNGYWN0b3J5KHN3YXJtKVxuXG4gIGxpc3RlbmVyLnN0b3BIYW5kbGVyID0gbmV3IFN0b3Aoc3dhcm0pXG4gIGxpc3RlbmVyLnN0b3BIYW5kbGVyLm9uKCdjb25uZWN0aW9uJywgKGNvbm4pID0+IGxpc3RlbmVyLmVtaXQoJ2Nvbm5lY3Rpb24nLCBjb25uKSlcbiAgbGlzdGVuZXIuaG9wSGFuZGxlciA9IG5ldyBIb3Aoc3dhcm0sIG9wdGlvbnMuaG9wKVxuXG4gIC8qKlxuICAgKiBBZGQgc3dhcm0gaGFuZGxlciBhbmQgbGlzdGVuIGZvciBpbmNvbWluZyBjb25uZWN0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0ge011bHRpYWRkcn0gbWFcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGxpc3RlbmVyLmxpc3RlbiA9IChtYSwgY2FsbGJhY2spID0+IHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8ICgoKSA9PiB7fSlcblxuICAgIHN3YXJtLmhhbmRsZShtdWx0aWNvZGVjLnJlbGF5LCAoXywgY29ubikgPT4ge1xuICAgICAgY29uc3Qgc2ggPSBuZXcgU3RyZWFtSGFuZGxlcihjb25uKVxuXG4gICAgICBzaC5yZWFkKChlcnIsIG1zZykgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgbG9nLmVycihlcnIpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVxdWVzdCA9IG51bGxcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXF1ZXN0ID0gcHJvdG8uQ2lyY3VpdFJlbGF5LmRlY29kZShtc2cpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJldHVybiB1dGlscy53cml0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgc2gsXG4gICAgICAgICAgICBwcm90by5DaXJjdWl0UmVsYXkuU3RhdHVzLk1BTEZPUk1FRF9NRVNTQUdFKVxuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChyZXF1ZXN0LnR5cGUpIHtcbiAgICAgICAgICBjYXNlIHByb3RvLkNpcmN1aXRSZWxheS5UeXBlLkNBTl9IT1A6XG4gICAgICAgICAgY2FzZSBwcm90by5DaXJjdWl0UmVsYXkuVHlwZS5IT1A6IHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lci5ob3BIYW5kbGVyLmhhbmRsZShyZXF1ZXN0LCBzaClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIHByb3RvLkNpcmN1aXRSZWxheS5UeXBlLlNUT1A6IHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lci5zdG9wSGFuZGxlci5oYW5kbGUocmVxdWVzdCwgc2gsIGNvbm5IYW5kbGVyKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHV0aWxzLndyaXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAgIHNoLFxuICAgICAgICAgICAgICBwcm90by5DaXJjdWl0UmVsYXkuU3RhdHVzLklOVkFMSURfTVNHX1RZUEUpXG4gICAgICAgICAgICByZXR1cm4gc2guY2xvc2UoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IGxpc3RlbmVyLmVtaXQoJ2xpc3RlbicpKVxuICAgIGNhbGxiYWNrKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgc3dhcm0gbGlzdGVuZXJcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGxpc3RlbmVyLmNsb3NlID0gKGNiKSA9PiB7XG4gICAgc3dhcm0udW5oYW5kbGUobXVsdGljb2RlYy5yZWxheSlcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4gbGlzdGVuZXIuZW1pdCgnY2xvc2UnKSlcbiAgICBjYigpXG4gIH1cblxuICAvKipcbiAgICogR2V0IGZpeGVkIHVwIG11bHRpYWRkcnNcbiAgICpcbiAgICogTk9URTogVGhpcyBtZXRob2Qgd2lsbCBncmFiIHRoZSBwZWVycyBtdWx0aWFkZHJzIGFuZCBleHBhbmQgdGhlbSBzdWNoIHRoYXQ6XG4gICAqXG4gICAqIGEpIElmIGl0J3MgYW4gZXhpc3RpbmcgL3AycC1jaXJjdWl0IGFkZHJlc3MgZm9yIGEgc3BlY2lmaWMgcmVsYXkgaS5lLlxuICAgKiAgICBgL2lwNC8wLjAuMC4wL3RjcC8wL2lwZnMvUW1SZWxheS9wMnAtY2lyY3VpdGAgdGhpcyBtZXRob2Qgd2lsbCBleHBhbmQgdGhlXG4gICAqICAgIGFkZHJlc3MgdG8gYC9pcDQvMC4wLjAuMC90Y3AvMC9pcGZzL1FtUmVsYXkvcDJwLWNpcmN1aXQvaXBmcy9RbVBlZXJgIHdoZXJlXG4gICAqICAgIGBRbVBlZXJgIGlzIHRoaXMgcGVlcnMgaWRcbiAgICogYikgSWYgaXQncyBub3QgYSAvcDJwLWNpcmN1aXQgYWRkcmVzcywgaXQgd2lsbCBlbmNhcHN1bGF0ZSB0aGUgYWRkcmVzcyBhcyBhIC9wMnAtY2lyY3VpdFxuICAgKiAgICBhZGRyLCBzdWNoIHdoZW4gZGlhbGluZyBvdmVyIGEgcmVsYXkgd2l0aCB0aGlzIGFkZHJlc3MsIGl0IHdpbGwgY3JlYXRlIHRoZSBjaXJjdWl0IHVzaW5nXG4gICAqICAgIHRoZSBlbmNhcHN1bGF0ZWQgdHJhbnNwb3J0IGFkZHJlc3MuIFRoaXMgaXMgdXNlZnVsIHdoZW4gZm9yIGV4YW1wbGUsIGEgcGVlciBzaG91bGQgb25seVxuICAgKiAgICBiZSBkaWFsZWQgb3ZlciBUQ1AgcmF0aGVyIHRoYW4gYW55IG90aGVyIHRyYW5zcG9ydFxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgbGlzdGVuZXIuZ2V0QWRkcnMgPSAoY2FsbGJhY2spID0+IHtcbiAgICBsZXQgYWRkcnMgPSBzd2FybS5fcGVlckluZm8ubXVsdGlhZGRycy50b0FycmF5KClcblxuICAgIC8vIGdldCBhbGwgdGhlIGV4cGxpY2l0IHJlbGF5IGFkZHJzIGV4Y2x1ZGluZyBzZWxmXG4gICAgbGV0IHAycEFkZHJzID0gYWRkcnMuZmlsdGVyKChhZGRyKSA9PiB7XG4gICAgICByZXR1cm4gbWFmbXQuQ2lyY3VpdC5tYXRjaGVzKGFkZHIpICYmXG4gICAgICAgICFhZGRyLnRvU3RyaW5nKCkuaW5jbHVkZXMoc3dhcm0uX3BlZXJJbmZvLmlkLnRvQjU4U3RyaW5nKCkpXG4gICAgfSlcblxuICAgIC8vIHVzZSB0aGUgZXhwbGljaXQgcmVsYXlzIGluc3RlYWQgb2YgYW55IHJlbGF5XG4gICAgaWYgKHAycEFkZHJzLmxlbmd0aCkge1xuICAgICAgYWRkcnMgPSBwMnBBZGRyc1xuICAgIH1cblxuICAgIGxldCBsaXN0ZW5BZGRycyA9IFtdXG4gICAgYWRkcnMuZm9yRWFjaCgoYWRkcikgPT4ge1xuICAgICAgY29uc3QgcGVlck1hID0gYC9wMnAtY2lyY3VpdC9pcGZzLyR7c3dhcm0uX3BlZXJJbmZvLmlkLnRvQjU4U3RyaW5nKCl9YFxuICAgICAgaWYgKGFkZHIudG9TdHJpbmcoKSA9PT0gcGVlck1hKSB7XG4gICAgICAgIGxpc3RlbkFkZHJzLnB1c2gobXVsdGlhZGRyKHBlZXJNYSkpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoIW1hZm10LkNpcmN1aXQubWF0Y2hlcyhhZGRyKSkge1xuICAgICAgICBpZiAoYWRkci5nZXRQZWVySWQoKSkge1xuICAgICAgICAgIC8vIGJ5IGRlZmF1bHQgd2UncmUgcmVhY2hhYmxlIG92ZXIgYW55IHJlbGF5XG4gICAgICAgICAgbGlzdGVuQWRkcnMucHVzaChtdWx0aWFkZHIoYC9wMnAtY2lyY3VpdGApLmVuY2Fwc3VsYXRlKGFkZHIpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG1hID0gYCR7YWRkcn0vaXBmcy8ke3N3YXJtLl9wZWVySW5mby5pZC50b0I1OFN0cmluZygpfWBcbiAgICAgICAgICBsaXN0ZW5BZGRycy5wdXNoKG11bHRpYWRkcihgL3AycC1jaXJjdWl0YCkuZW5jYXBzdWxhdGUobWEpKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0ZW5BZGRycy5wdXNoKGFkZHIuZW5jYXBzdWxhdGUoYC9pcGZzLyR7c3dhcm0uX3BlZXJJbmZvLmlkLnRvQjU4U3RyaW5nKCl9YCkpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGNhbGxiYWNrKG51bGwsIGxpc3RlbkFkZHJzKVxuICB9XG5cbiAgcmV0dXJuIGxpc3RlbmVyXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgU3BhcnNlQXJyYXkgPSByZXF1aXJlKCdzcGFyc2UtYXJyYXknKVxuY29uc3Qgd3JhcEhhc2ggPSByZXF1aXJlKCcuL2NvbnN1bWFibGUtaGFzaCcpXG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBiaXRzOiA4XG59XG5cbmNsYXNzIEJ1Y2tldCB7XG4gIGNvbnN0cnVjdG9yIChvcHRpb25zLCBwYXJlbnQsIHBvc0F0UGFyZW50KSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKVxuICAgIHRoaXMuX3BvcENvdW50ID0gMFxuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudFxuICAgIHRoaXMuX3Bvc0F0UGFyZW50ID0gcG9zQXRQYXJlbnRcblxuICAgIGlmICghdGhpcy5fb3B0aW9ucy5oYXNoRm4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGxlYXNlIGRlZmluZSBhbiBvcHRpb25zLmhhc2hGbicpXG4gICAgfVxuXG4gICAgLy8gbWFrZSBzdXJlIHdlIG9ubHkgd3JhcCBvcHRpb25zLmhhc2hGbiBvbmNlIGluIHRoZSB3aG9sZSB0cmVlXG4gICAgaWYgKCF0aGlzLl9vcHRpb25zLmhhc2gpIHtcbiAgICAgIHRoaXMuX29wdGlvbnMuaGFzaCA9IHdyYXBIYXNoKHRoaXMuX29wdGlvbnMuaGFzaEZuKVxuICAgIH1cbiAgICB0aGlzLl9jaGlsZHJlbiA9IG5ldyBTcGFyc2VBcnJheSgpXG4gIH1cblxuICBzdGF0aWMgaXNCdWNrZXQgKG8pIHtcbiAgICByZXR1cm4gbyBpbnN0YW5jZW9mIEJ1Y2tldFxuICB9XG5cbiAgYXN5bmMgcHV0IChrZXksIHZhbHVlKSB7XG4gICAgY29uc3QgcGxhY2UgPSBhd2FpdCB0aGlzLl9maW5kTmV3QnVja2V0QW5kUG9zKGtleSlcblxuICAgIGF3YWl0IHBsYWNlLmJ1Y2tldC5fcHV0QXQocGxhY2UsIGtleSwgdmFsdWUpXG4gIH1cblxuICBhc3luYyBnZXQgKGtleSkge1xuICAgIGNvbnN0IGNoaWxkID0gYXdhaXQgdGhpcy5fZmluZENoaWxkKGtleSlcblxuICAgIGlmIChjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkLnZhbHVlXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZGVsIChrZXkpIHtcbiAgICBjb25zdCBwbGFjZSA9IGF3YWl0IHRoaXMuX2ZpbmRQbGFjZShrZXkpXG4gICAgY29uc3QgY2hpbGQgPSBwbGFjZS5idWNrZXQuX2F0KHBsYWNlLnBvcylcblxuICAgIGlmIChjaGlsZCAmJiBjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgcGxhY2UuYnVja2V0Ll9kZWxBdChwbGFjZS5wb3MpXG4gICAgfVxuICB9XG5cbiAgbGVhZkNvdW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4uY29tcGFjdEFycmF5KCkucmVkdWNlKChhY2MsIGNoaWxkKSA9PiB7XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBCdWNrZXQpIHtcbiAgICAgICAgcmV0dXJuIGFjYyArIGNoaWxkLmxlYWZDb3VudCgpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY2MgKyAxXG4gICAgfSwgMClcbiAgfVxuXG4gIGNoaWxkcmVuQ291bnQgKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbi5sZW5ndGhcbiAgfVxuXG4gIG9ubHlDaGlsZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLmdldCgwKVxuICB9XG5cbiAgKiBlYWNoTGVhZlNlcmllcyAoKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbi5jb21wYWN0QXJyYXkoKVxuXG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgQnVja2V0KSB7XG4gICAgICAgIGZvciAoY29uc3QgYzIgb2YgY2hpbGQuZWFjaExlYWZTZXJpZXMoKSkge1xuICAgICAgICAgIHlpZWxkIGMyXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkIGNoaWxkXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2VyaWFsaXplIChtYXAsIHJlZHVjZSkge1xuICAgIC8vIHNlcmlhbGl6ZSB0byBhIGN1c3RvbSBub24tc3BhcnNlIHJlcHJlc2VudGF0aW9uXG4gICAgcmV0dXJuIHJlZHVjZSh0aGlzLl9jaGlsZHJlbi5yZWR1Y2UoKGFjYywgY2hpbGQsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgQnVja2V0KSB7XG4gICAgICAgICAgYWNjLnB1c2goY2hpbGQuc2VyaWFsaXplKG1hcCwgcmVkdWNlKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY2MucHVzaChtYXAoY2hpbGQsIGluZGV4KSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY1xuICAgIH0sIFtdKSlcbiAgfVxuXG4gIGFzeW5jIGFzeW5jVHJhbnNmb3JtIChhc3luY01hcCwgYXN5bmNSZWR1Y2UpIHtcbiAgICByZXR1cm4gYXN5bmNUcmFuc2Zvcm1CdWNrZXQodGhpcywgYXN5bmNNYXAsIGFzeW5jUmVkdWNlKVxuICB9XG5cbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUobWFwTm9kZSwgcmVkdWNlTm9kZXMpXG4gIH1cblxuICBwcmV0dHlQcmludCAoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCksIG51bGwsICcgICcpXG4gIH1cblxuICB0YWJsZVNpemUgKCkge1xuICAgIHJldHVybiBNYXRoLnBvdygyLCB0aGlzLl9vcHRpb25zLmJpdHMpXG4gIH1cblxuICBhc3luYyBfZmluZENoaWxkIChrZXkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9maW5kUGxhY2Uoa2V5KVxuICAgIGNvbnN0IGNoaWxkID0gcmVzdWx0LmJ1Y2tldC5fYXQocmVzdWx0LnBvcylcblxuICAgIGlmIChjaGlsZCAmJiBjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgcmV0dXJuIGNoaWxkXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX2ZpbmRQbGFjZSAoa2V5KSB7XG4gICAgY29uc3QgaGFzaFZhbHVlID0gdGhpcy5fb3B0aW9ucy5oYXNoKGtleSlcbiAgICBjb25zdCBpbmRleCA9IGF3YWl0IGhhc2hWYWx1ZS50YWtlKHRoaXMuX29wdGlvbnMuYml0cylcblxuICAgIGNvbnN0IGNoaWxkID0gdGhpcy5fY2hpbGRyZW4uZ2V0KGluZGV4KVxuXG4gICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgQnVja2V0KSB7XG4gICAgICByZXR1cm4gY2hpbGQuX2ZpbmRQbGFjZShoYXNoVmFsdWUpXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGJ1Y2tldDogdGhpcyxcbiAgICAgIHBvczogaW5kZXgsXG4gICAgICBoYXNoOiBoYXNoVmFsdWVcbiAgICB9XG4gIH1cblxuICBhc3luYyBfZmluZE5ld0J1Y2tldEFuZFBvcyAoa2V5KSB7XG4gICAgY29uc3QgcGxhY2UgPSBhd2FpdCB0aGlzLl9maW5kUGxhY2Uoa2V5KVxuICAgIGNvbnN0IGNoaWxkID0gcGxhY2UuYnVja2V0Ll9hdChwbGFjZS5wb3MpXG5cbiAgICBpZiAoY2hpbGQgJiYgY2hpbGQua2V5ICE9PSBrZXkpIHtcbiAgICAgIC8vIGNvbmZsaWN0XG5cbiAgICAgIGNvbnN0IGJ1Y2tldCA9IG5ldyBCdWNrZXQodGhpcy5fb3B0aW9ucywgcGxhY2UuYnVja2V0LCBwbGFjZS5wb3MpXG4gICAgICBwbGFjZS5idWNrZXQuX3B1dE9iamVjdEF0KHBsYWNlLnBvcywgYnVja2V0KVxuXG4gICAgICAvLyBwdXQgdGhlIHByZXZpb3VzIHZhbHVlXG4gICAgICBjb25zdCBuZXdQbGFjZSA9IGF3YWl0IGJ1Y2tldC5fZmluZFBsYWNlKGNoaWxkLmhhc2gpXG4gICAgICBuZXdQbGFjZS5idWNrZXQuX3B1dEF0KG5ld1BsYWNlLCBjaGlsZC5rZXksIGNoaWxkLnZhbHVlKVxuXG4gICAgICByZXR1cm4gYnVja2V0Ll9maW5kTmV3QnVja2V0QW5kUG9zKHBsYWNlLmhhc2gpXG4gICAgfVxuXG4gICAgLy8gbm8gY29uZmxpY3QsIHdlIGZvdW5kIHRoZSBwbGFjZVxuICAgIHJldHVybiBwbGFjZVxuICB9XG5cbiAgX3B1dEF0IChwbGFjZSwga2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3B1dE9iamVjdEF0KHBsYWNlLnBvcywge1xuICAgICAga2V5OiBrZXksXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBoYXNoOiBwbGFjZS5oYXNoXG4gICAgfSlcbiAgfVxuXG4gIF9wdXRPYmplY3RBdCAocG9zLCBvYmplY3QpIHtcbiAgICBpZiAoIXRoaXMuX2NoaWxkcmVuLmdldChwb3MpKSB7XG4gICAgICB0aGlzLl9wb3BDb3VudCsrXG4gICAgfVxuICAgIHRoaXMuX2NoaWxkcmVuLnNldChwb3MsIG9iamVjdClcbiAgfVxuXG4gIF9kZWxBdCAocG9zKSB7XG4gICAgaWYgKHRoaXMuX2NoaWxkcmVuLmdldChwb3MpKSB7XG4gICAgICB0aGlzLl9wb3BDb3VudC0tXG4gICAgfVxuICAgIHRoaXMuX2NoaWxkcmVuLnVuc2V0KHBvcylcbiAgICB0aGlzLl9sZXZlbCgpXG4gIH1cblxuICBfbGV2ZWwgKCkge1xuICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgdGhpcy5fcG9wQ291bnQgPD0gMSkge1xuICAgICAgaWYgKHRoaXMuX3BvcENvdW50ID09PSAxKSB7XG4gICAgICAgIC8vIHJlbW92ZSBteXNlbGYgZnJvbSBwYXJlbnQsIHJlcGxhY2luZyBtZSB3aXRoIG15IG9ubHkgY2hpbGRcbiAgICAgICAgY29uc3Qgb25seUNoaWxkID0gdGhpcy5fY2hpbGRyZW4uZmluZChleGlzdHMpXG5cbiAgICAgICAgaWYgKCEob25seUNoaWxkIGluc3RhbmNlb2YgQnVja2V0KSkge1xuICAgICAgICAgIGNvbnN0IGhhc2ggPSBvbmx5Q2hpbGQuaGFzaFxuICAgICAgICAgIGhhc2gudW50YWtlKHRoaXMuX29wdGlvbnMuYml0cylcbiAgICAgICAgICBjb25zdCBwbGFjZSA9IHtcbiAgICAgICAgICAgIHBvczogdGhpcy5fcG9zQXRQYXJlbnQsXG4gICAgICAgICAgICBoYXNoOiBoYXNoXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3BhcmVudC5fcHV0QXQocGxhY2UsIG9ubHlDaGlsZC5rZXksIG9ubHlDaGlsZC52YWx1ZSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcGFyZW50Ll9kZWxBdCh0aGlzLl9wb3NBdFBhcmVudClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfYXQgKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLmdldChpbmRleClcbiAgfVxufVxuXG5mdW5jdGlvbiBleGlzdHMgKG8pIHtcbiAgcmV0dXJuIEJvb2xlYW4obylcbn1cblxuZnVuY3Rpb24gbWFwTm9kZSAobm9kZSwgaW5kZXgpIHtcbiAgcmV0dXJuIG5vZGUua2V5XG59XG5cbmZ1bmN0aW9uIHJlZHVjZU5vZGVzIChub2Rlcykge1xuICByZXR1cm4gbm9kZXNcbn1cblxuYXN5bmMgZnVuY3Rpb24gYXN5bmNUcmFuc2Zvcm1CdWNrZXQgKGJ1Y2tldCwgYXN5bmNNYXAsIGFzeW5jUmVkdWNlKSB7XG4gIGNvbnN0IG91dHB1dCA9IFtdXG5cbiAgZm9yIChjb25zdCBjaGlsZCBvZiBidWNrZXQuX2NoaWxkcmVuLmNvbXBhY3RBcnJheSgpKSB7XG4gICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgQnVja2V0KSB7XG4gICAgICBhd2FpdCBhc3luY1RyYW5zZm9ybUJ1Y2tldChjaGlsZCwgYXN5bmNNYXAsIGFzeW5jUmVkdWNlKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtYXBwZWRDaGlsZHJlbiA9IGF3YWl0IGFzeW5jTWFwKGNoaWxkKVxuXG4gICAgICBvdXRwdXQucHVzaCh7XG4gICAgICAgIGJpdEZpZWxkOiBidWNrZXQuX2NoaWxkcmVuLmJpdEZpZWxkKCksXG4gICAgICAgIGNoaWxkcmVuOiBtYXBwZWRDaGlsZHJlblxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gYXN5bmNSZWR1Y2Uob3V0cHV0KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQnVja2V0XG4iLCIvKiFcbiAqIEBkZXNjcmlwdGlvbiBSZWN1cnNpdmUgb2JqZWN0IGV4dGVuZGluZ1xuICogQGF1dGhvciBWaWFjaGVzbGF2IExvdHNtYW5vdiA8bG90c21hbm92ODlAZ21haWwuY29tPlxuICogQGxpY2Vuc2UgTUlUXG4gKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTggVmlhY2hlc2xhdiBMb3RzbWFub3ZcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZlxuICogdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTXG4gKiBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1JcbiAqIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUlxuICogSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAqIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBpc1NwZWNpZmljVmFsdWUodmFsKSB7XG5cdHJldHVybiAoXG5cdFx0dmFsIGluc3RhbmNlb2YgQnVmZmVyXG5cdFx0fHwgdmFsIGluc3RhbmNlb2YgRGF0ZVxuXHRcdHx8IHZhbCBpbnN0YW5jZW9mIFJlZ0V4cFxuXHQpID8gdHJ1ZSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjbG9uZVNwZWNpZmljVmFsdWUodmFsKSB7XG5cdGlmICh2YWwgaW5zdGFuY2VvZiBCdWZmZXIpIHtcblx0XHR2YXIgeCA9IEJ1ZmZlci5hbGxvY1xuXHRcdFx0PyBCdWZmZXIuYWxsb2ModmFsLmxlbmd0aClcblx0XHRcdDogbmV3IEJ1ZmZlcih2YWwubGVuZ3RoKTtcblx0XHR2YWwuY29weSh4KTtcblx0XHRyZXR1cm4geDtcblx0fSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKSB7XG5cdFx0cmV0dXJuIG5ldyBEYXRlKHZhbC5nZXRUaW1lKCkpO1xuXHR9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuXHRcdHJldHVybiBuZXcgUmVnRXhwKHZhbCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHNpdHVhdGlvbicpO1xuXHR9XG59XG5cbi8qKlxuICogUmVjdXJzaXZlIGNsb25pbmcgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGRlZXBDbG9uZUFycmF5KGFycikge1xuXHR2YXIgY2xvbmUgPSBbXTtcblx0YXJyLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG5cdFx0aWYgKHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyAmJiBpdGVtICE9PSBudWxsKSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuXHRcdFx0XHRjbG9uZVtpbmRleF0gPSBkZWVwQ2xvbmVBcnJheShpdGVtKTtcblx0XHRcdH0gZWxzZSBpZiAoaXNTcGVjaWZpY1ZhbHVlKGl0ZW0pKSB7XG5cdFx0XHRcdGNsb25lW2luZGV4XSA9IGNsb25lU3BlY2lmaWNWYWx1ZShpdGVtKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lW2luZGV4XSA9IGRlZXBFeHRlbmQoe30sIGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjbG9uZVtpbmRleF0gPSBpdGVtO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBjbG9uZTtcbn1cblxuZnVuY3Rpb24gc2FmZUdldFByb3BlcnR5KG9iamVjdCwgcHJvcGVydHkpIHtcblx0cmV0dXJuIHByb3BlcnR5ID09PSAnX19wcm90b19fJyA/IHVuZGVmaW5lZCA6IG9iamVjdFtwcm9wZXJ0eV07XG59XG5cbi8qKlxuICogRXh0ZW5pbmcgb2JqZWN0IHRoYXQgZW50ZXJlZCBpbiBmaXJzdCBhcmd1bWVudC5cbiAqXG4gKiBSZXR1cm5zIGV4dGVuZGVkIG9iamVjdCBvciBmYWxzZSBpZiBoYXZlIG5vIHRhcmdldCBvYmplY3Qgb3IgaW5jb3JyZWN0IHR5cGUuXG4gKlxuICogSWYgeW91IHdpc2ggdG8gY2xvbmUgc291cmNlIG9iamVjdCAod2l0aG91dCBtb2RpZnkgaXQpLCBqdXN0IHVzZSBlbXB0eSBuZXdcbiAqIG9iamVjdCBhcyBmaXJzdCBhcmd1bWVudCwgbGlrZSB0aGlzOlxuICogICBkZWVwRXh0ZW5kKHt9LCB5b3VyT2JqXzEsIFt5b3VyT2JqX05dKTtcbiAqL1xudmFyIGRlZXBFeHRlbmQgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgvKm9ial8xLCBbb2JqXzJdLCBbb2JqX05dKi8pIHtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxIHx8IHR5cGVvZiBhcmd1bWVudHNbMF0gIT09ICdvYmplY3QnKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50c1swXTtcblx0fVxuXG5cdHZhciB0YXJnZXQgPSBhcmd1bWVudHNbMF07XG5cblx0Ly8gY29udmVydCBhcmd1bWVudHMgdG8gYXJyYXkgYW5kIGN1dCBvZmYgdGFyZ2V0IG9iamVjdFxuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cblx0dmFyIHZhbCwgc3JjLCBjbG9uZTtcblxuXHRhcmdzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuXHRcdC8vIHNraXAgYXJndW1lbnQgaWYgaXNuJ3QgYW4gb2JqZWN0LCBpcyBudWxsLCBvciBpcyBhbiBhcnJheVxuXHRcdGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShvYmopKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0T2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdHNyYyA9IHNhZmVHZXRQcm9wZXJ0eSh0YXJnZXQsIGtleSk7IC8vIHNvdXJjZSB2YWx1ZVxuXHRcdFx0dmFsID0gc2FmZUdldFByb3BlcnR5KG9iaiwga2V5KTsgLy8gbmV3IHZhbHVlXG5cblx0XHRcdC8vIHJlY3Vyc2lvbiBwcmV2ZW50aW9uXG5cdFx0XHRpZiAodmFsID09PSB0YXJnZXQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIGlmIG5ldyB2YWx1ZSBpc24ndCBvYmplY3QgdGhlbiBqdXN0IG92ZXJ3cml0ZSBieSBuZXcgdmFsdWVcblx0XHRcdCAqIGluc3RlYWQgb2YgZXh0ZW5kaW5nLlxuXHRcdFx0ICovXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWwgIT09ICdvYmplY3QnIHx8IHZhbCA9PT0gbnVsbCkge1xuXHRcdFx0XHR0YXJnZXRba2V5XSA9IHZhbDtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHQvLyBqdXN0IGNsb25lIGFycmF5cyAoYW5kIHJlY3Vyc2l2ZSBjbG9uZSBvYmplY3RzIGluc2lkZSlcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG5cdFx0XHRcdHRhcmdldFtrZXldID0gZGVlcENsb25lQXJyYXkodmFsKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHQvLyBjdXN0b20gY2xvbmluZyBhbmQgb3ZlcndyaXRlIGZvciBzcGVjaWZpYyBvYmplY3RzXG5cdFx0XHR9IGVsc2UgaWYgKGlzU3BlY2lmaWNWYWx1ZSh2YWwpKSB7XG5cdFx0XHRcdHRhcmdldFtrZXldID0gY2xvbmVTcGVjaWZpY1ZhbHVlKHZhbCk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0Ly8gb3ZlcndyaXRlIGJ5IG5ldyB2YWx1ZSBpZiBzb3VyY2UgaXNuJ3Qgb2JqZWN0IG9yIGFycmF5XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBzcmMgIT09ICdvYmplY3QnIHx8IHNyYyA9PT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KHNyYykpIHtcblx0XHRcdFx0dGFyZ2V0W2tleV0gPSBkZWVwRXh0ZW5kKHt9LCB2YWwpO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdC8vIHNvdXJjZSB2YWx1ZSBhbmQgbmV3IHZhbHVlIGlzIG9iamVjdHMgYm90aCwgZXh0ZW5kaW5nLi4uXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YXJnZXRba2V5XSA9IGRlZXBFeHRlbmQoc3JjLCB2YWwpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXG5cdHJldHVybiB0YXJnZXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEJ1Y2tldCA9IHJlcXVpcmUoJy4vYnVja2V0JylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVIQU1UIChvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgQnVja2V0KG9wdGlvbnMpXG59XG5cbm1vZHVsZS5leHBvcnRzLmlzQnVja2V0ID0gQnVja2V0LmlzQnVja2V0XG4iLCIndXNlIHN0cmljdCdcblxuYXN5bmMgZnVuY3Rpb24gKiBiYXRjaCAoc291cmNlLCBzaXplKSB7XG4gIGxldCB0aGluZ3MgPSBbXVxuXG4gIGZvciBhd2FpdCAoY29uc3Qgc2V0IG9mIHNvdXJjZSkge1xuICAgIHRoaW5ncyA9IHRoaW5ncy5jb25jYXQoc2V0KVxuXG4gICAgd2hpbGUgKHRoaW5ncy5sZW5ndGggPj0gc2l6ZSkge1xuICAgICAgeWllbGQgdGhpbmdzLnNsaWNlKDAsIHNpemUpXG5cbiAgICAgIHRoaW5ncyA9IHRoaW5ncy5zbGljZShzaXplKVxuICAgIH1cbiAgfVxuXG4gIHdoaWxlICh0aGluZ3MubGVuZ3RoKSB7XG4gICAgeWllbGQgdGhpbmdzLnNsaWNlKDAsIHNpemUpXG5cbiAgICB0aGluZ3MgPSB0aGluZ3Muc2xpY2Uoc2l6ZSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhdGNoXG4iLCIndXNlIHN0cmljdCdcbnZhciBEdXBsZXhTdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5EdXBsZXhcbiAgLCB1dGlsICAgICAgICAgPSByZXF1aXJlKCd1dGlsJylcblxuZnVuY3Rpb24gQnVmZmVyTGlzdCAoY2FsbGJhY2spIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlckxpc3QpKVxuICAgIHJldHVybiBuZXcgQnVmZmVyTGlzdChjYWxsYmFjaylcblxuICB0aGlzLl9idWZzICA9IFtdXG4gIHRoaXMubGVuZ3RoID0gMFxuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2tcblxuICAgIHZhciBwaXBlciA9IGZ1bmN0aW9uIHBpcGVyIChlcnIpIHtcbiAgICAgIGlmICh0aGlzLl9jYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9jYWxsYmFjayhlcnIpXG4gICAgICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbFxuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKVxuXG4gICAgdGhpcy5vbigncGlwZScsIGZ1bmN0aW9uIG9uUGlwZSAoc3JjKSB7XG4gICAgICBzcmMub24oJ2Vycm9yJywgcGlwZXIpXG4gICAgfSlcbiAgICB0aGlzLm9uKCd1bnBpcGUnLCBmdW5jdGlvbiBvblVucGlwZSAoc3JjKSB7XG4gICAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgcGlwZXIpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmFwcGVuZChjYWxsYmFjaylcbiAgfVxuXG4gIER1cGxleFN0cmVhbS5jYWxsKHRoaXMpXG59XG5cblxudXRpbC5pbmhlcml0cyhCdWZmZXJMaXN0LCBEdXBsZXhTdHJlYW0pXG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuX29mZnNldCA9IGZ1bmN0aW9uIF9vZmZzZXQgKG9mZnNldCkge1xuICB2YXIgdG90ID0gMCwgaSA9IDAsIF90XG4gIGlmIChvZmZzZXQgPT09IDApIHJldHVybiBbIDAsIDAgXVxuICBmb3IgKDsgaSA8IHRoaXMuX2J1ZnMubGVuZ3RoOyBpKyspIHtcbiAgICBfdCA9IHRvdCArIHRoaXMuX2J1ZnNbaV0ubGVuZ3RoXG4gICAgaWYgKG9mZnNldCA8IF90IHx8IGkgPT0gdGhpcy5fYnVmcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gWyBpLCBvZmZzZXQgLSB0b3QgXVxuICAgIH1cbiAgICB0b3QgPSBfdFxuICB9XG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9yZXZlcnNlT2Zmc2V0ID0gZnVuY3Rpb24gKGJsT2Zmc2V0KSB7XG4gIHZhciBidWZmZXJJZCA9IGJsT2Zmc2V0WzBdXG4gIHZhciBvZmZzZXQgPSBibE9mZnNldFsxXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcklkOyBpKyspIHtcbiAgICBvZmZzZXQgKz0gdGhpcy5fYnVmc1tpXS5sZW5ndGhcbiAgfVxuICByZXR1cm4gb2Zmc2V0XG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZCAoYnVmKSB7XG4gIHZhciBpID0gMFxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgIHRoaXMuX2FwcGVuZEJ1ZmZlcihidWYpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShidWYpKSB7XG4gICAgZm9yICg7IGkgPCBidWYubGVuZ3RoOyBpKyspXG4gICAgICB0aGlzLmFwcGVuZChidWZbaV0pXG4gIH0gZWxzZSBpZiAoYnVmIGluc3RhbmNlb2YgQnVmZmVyTGlzdCkge1xuICAgIC8vIHVud3JhcCBhcmd1bWVudCBpbnRvIGluZGl2aWR1YWwgQnVmZmVyTGlzdHNcbiAgICBmb3IgKDsgaSA8IGJ1Zi5fYnVmcy5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMuYXBwZW5kKGJ1Zi5fYnVmc1tpXSlcbiAgfSBlbHNlIGlmIChidWYgIT0gbnVsbCkge1xuICAgIC8vIGNvZXJjZSBudW1iZXIgYXJndW1lbnRzIHRvIHN0cmluZ3MsIHNpbmNlIEJ1ZmZlcihudW1iZXIpIGRvZXNcbiAgICAvLyB1bmluaXRpYWxpemVkIG1lbW9yeSBhbGxvY2F0aW9uXG4gICAgaWYgKHR5cGVvZiBidWYgPT0gJ251bWJlcicpXG4gICAgICBidWYgPSBidWYudG9TdHJpbmcoKVxuXG4gICAgdGhpcy5fYXBwZW5kQnVmZmVyKEJ1ZmZlci5mcm9tKGJ1ZikpXG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9hcHBlbmRCdWZmZXIgPSBmdW5jdGlvbiBhcHBlbmRCdWZmZXIgKGJ1Zikge1xuICB0aGlzLl9idWZzLnB1c2goYnVmKVxuICB0aGlzLmxlbmd0aCArPSBidWYubGVuZ3RoXG59XG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gX3dyaXRlIChidWYsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICB0aGlzLl9hcHBlbmRCdWZmZXIoYnVmKVxuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJylcbiAgICBjYWxsYmFjaygpXG59XG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiBfcmVhZCAoc2l6ZSkge1xuICBpZiAoIXRoaXMubGVuZ3RoKVxuICAgIHJldHVybiB0aGlzLnB1c2gobnVsbClcblxuICBzaXplID0gTWF0aC5taW4oc2l6ZSwgdGhpcy5sZW5ndGgpXG4gIHRoaXMucHVzaCh0aGlzLnNsaWNlKDAsIHNpemUpKVxuICB0aGlzLmNvbnN1bWUoc2l6ZSlcbn1cblxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiBlbmQgKGNodW5rKSB7XG4gIER1cGxleFN0cmVhbS5wcm90b3R5cGUuZW5kLmNhbGwodGhpcywgY2h1bmspXG5cbiAgaWYgKHRoaXMuX2NhbGxiYWNrKSB7XG4gICAgdGhpcy5fY2FsbGJhY2sobnVsbCwgdGhpcy5zbGljZSgpKVxuICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbFxuICB9XG59XG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpbmRleCkge1xuICBpZiAoaW5kZXggPiB0aGlzLmxlbmd0aCB8fCBpbmRleCA8IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldChpbmRleClcbiAgcmV0dXJuIHRoaXMuX2J1ZnNbb2Zmc2V0WzBdXVtvZmZzZXRbMV1dXG59XG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICBpZiAodHlwZW9mIHN0YXJ0ID09ICdudW1iZXInICYmIHN0YXJ0IDwgMClcbiAgICBzdGFydCArPSB0aGlzLmxlbmd0aFxuICBpZiAodHlwZW9mIGVuZCA9PSAnbnVtYmVyJyAmJiBlbmQgPCAwKVxuICAgIGVuZCArPSB0aGlzLmxlbmd0aFxuICByZXR1cm4gdGhpcy5jb3B5KG51bGwsIDAsIHN0YXJ0LCBlbmQpXG59XG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKGRzdCwgZHN0U3RhcnQsIHNyY1N0YXJ0LCBzcmNFbmQpIHtcbiAgaWYgKHR5cGVvZiBzcmNTdGFydCAhPSAnbnVtYmVyJyB8fCBzcmNTdGFydCA8IDApXG4gICAgc3JjU3RhcnQgPSAwXG4gIGlmICh0eXBlb2Ygc3JjRW5kICE9ICdudW1iZXInIHx8IHNyY0VuZCA+IHRoaXMubGVuZ3RoKVxuICAgIHNyY0VuZCA9IHRoaXMubGVuZ3RoXG4gIGlmIChzcmNTdGFydCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm4gZHN0IHx8IEJ1ZmZlci5hbGxvYygwKVxuICBpZiAoc3JjRW5kIDw9IDApXG4gICAgcmV0dXJuIGRzdCB8fCBCdWZmZXIuYWxsb2MoMClcblxuICB2YXIgY29weSAgID0gISFkc3RcbiAgICAsIG9mZiAgICA9IHRoaXMuX29mZnNldChzcmNTdGFydClcbiAgICAsIGxlbiAgICA9IHNyY0VuZCAtIHNyY1N0YXJ0XG4gICAgLCBieXRlcyAgPSBsZW5cbiAgICAsIGJ1Zm9mZiA9IChjb3B5ICYmIGRzdFN0YXJ0KSB8fCAwXG4gICAgLCBzdGFydCAgPSBvZmZbMV1cbiAgICAsIGxcbiAgICAsIGlcblxuICAvLyBjb3B5L3NsaWNlIGV2ZXJ5dGhpbmdcbiAgaWYgKHNyY1N0YXJ0ID09PSAwICYmIHNyY0VuZCA9PSB0aGlzLmxlbmd0aCkge1xuICAgIGlmICghY29weSkgeyAvLyBzbGljZSwgYnV0IGZ1bGwgY29uY2F0IGlmIG11bHRpcGxlIGJ1ZmZlcnNcbiAgICAgIHJldHVybiB0aGlzLl9idWZzLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IHRoaXMuX2J1ZnNbMF1cbiAgICAgICAgOiBCdWZmZXIuY29uY2F0KHRoaXMuX2J1ZnMsIHRoaXMubGVuZ3RoKVxuICAgIH1cblxuICAgIC8vIGNvcHksIG5lZWQgdG8gY29weSBpbmRpdmlkdWFsIGJ1ZmZlcnNcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fYnVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fYnVmc1tpXS5jb3B5KGRzdCwgYnVmb2ZmKVxuICAgICAgYnVmb2ZmICs9IHRoaXMuX2J1ZnNbaV0ubGVuZ3RoXG4gICAgfVxuXG4gICAgcmV0dXJuIGRzdFxuICB9XG5cbiAgLy8gZWFzeSwgY2hlYXAgY2FzZSB3aGVyZSBpdCdzIGEgc3Vic2V0IG9mIG9uZSBvZiB0aGUgYnVmZmVyc1xuICBpZiAoYnl0ZXMgPD0gdGhpcy5fYnVmc1tvZmZbMF1dLmxlbmd0aCAtIHN0YXJ0KSB7XG4gICAgcmV0dXJuIGNvcHlcbiAgICAgID8gdGhpcy5fYnVmc1tvZmZbMF1dLmNvcHkoZHN0LCBkc3RTdGFydCwgc3RhcnQsIHN0YXJ0ICsgYnl0ZXMpXG4gICAgICA6IHRoaXMuX2J1ZnNbb2ZmWzBdXS5zbGljZShzdGFydCwgc3RhcnQgKyBieXRlcylcbiAgfVxuXG4gIGlmICghY29weSkgLy8gYSBzbGljZSwgd2UgbmVlZCBzb21ldGhpbmcgdG8gY29weSBpbiB0b1xuICAgIGRzdCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW4pXG5cbiAgZm9yIChpID0gb2ZmWzBdOyBpIDwgdGhpcy5fYnVmcy5sZW5ndGg7IGkrKykge1xuICAgIGwgPSB0aGlzLl9idWZzW2ldLmxlbmd0aCAtIHN0YXJ0XG5cbiAgICBpZiAoYnl0ZXMgPiBsKSB7XG4gICAgICB0aGlzLl9idWZzW2ldLmNvcHkoZHN0LCBidWZvZmYsIHN0YXJ0KVxuICAgICAgYnVmb2ZmICs9IGxcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYnVmc1tpXS5jb3B5KGRzdCwgYnVmb2ZmLCBzdGFydCwgc3RhcnQgKyBieXRlcylcbiAgICAgIGJ1Zm9mZiArPSBsXG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGJ5dGVzIC09IGxcblxuICAgIGlmIChzdGFydClcbiAgICAgIHN0YXJ0ID0gMFxuICB9XG5cbiAgLy8gc2FmZWd1YXJkIHNvIHRoYXQgd2UgZG9uJ3QgcmV0dXJuIHVuaW5pdGlhbGl6ZWQgbWVtb3J5XG4gIGlmIChkc3QubGVuZ3RoID4gYnVmb2ZmKSByZXR1cm4gZHN0LnNsaWNlKDAsIGJ1Zm9mZilcblxuICByZXR1cm4gZHN0XG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnNoYWxsb3dTbGljZSA9IGZ1bmN0aW9uIHNoYWxsb3dTbGljZSAoc3RhcnQsIGVuZCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDBcbiAgZW5kID0gdHlwZW9mIGVuZCAhPT0gJ251bWJlcicgPyB0aGlzLmxlbmd0aCA6IGVuZFxuXG4gIGlmIChzdGFydCA8IDApXG4gICAgc3RhcnQgKz0gdGhpcy5sZW5ndGhcbiAgaWYgKGVuZCA8IDApXG4gICAgZW5kICs9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlckxpc3QoKVxuICB9XG4gIHZhciBzdGFydE9mZnNldCA9IHRoaXMuX29mZnNldChzdGFydClcbiAgICAsIGVuZE9mZnNldCA9IHRoaXMuX29mZnNldChlbmQpXG4gICAgLCBidWZmZXJzID0gdGhpcy5fYnVmcy5zbGljZShzdGFydE9mZnNldFswXSwgZW5kT2Zmc2V0WzBdICsgMSlcblxuICBpZiAoZW5kT2Zmc2V0WzFdID09IDApXG4gICAgYnVmZmVycy5wb3AoKVxuICBlbHNlXG4gICAgYnVmZmVyc1tidWZmZXJzLmxlbmd0aC0xXSA9IGJ1ZmZlcnNbYnVmZmVycy5sZW5ndGgtMV0uc2xpY2UoMCwgZW5kT2Zmc2V0WzFdKVxuXG4gIGlmIChzdGFydE9mZnNldFsxXSAhPSAwKVxuICAgIGJ1ZmZlcnNbMF0gPSBidWZmZXJzWzBdLnNsaWNlKHN0YXJ0T2Zmc2V0WzFdKVxuXG4gIHJldHVybiBuZXcgQnVmZmVyTGlzdChidWZmZXJzKVxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy5zbGljZShzdGFydCwgZW5kKS50b1N0cmluZyhlbmNvZGluZylcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uc3VtZSA9IGZ1bmN0aW9uIGNvbnN1bWUgKGJ5dGVzKSB7XG4gIC8vIGZpcnN0LCBub3JtYWxpemUgdGhlIGFyZ3VtZW50LCBpbiBhY2NvcmRhbmNlIHdpdGggaG93IEJ1ZmZlciBkb2VzIGl0XG4gIGJ5dGVzID0gTWF0aC50cnVuYyhieXRlcylcbiAgLy8gZG8gbm90aGluZyBpZiBub3QgYSBwb3NpdGl2ZSBudW1iZXJcbiAgaWYgKE51bWJlci5pc05hTihieXRlcykgfHwgYnl0ZXMgPD0gMCkgcmV0dXJuIHRoaXNcblxuICB3aGlsZSAodGhpcy5fYnVmcy5sZW5ndGgpIHtcbiAgICBpZiAoYnl0ZXMgPj0gdGhpcy5fYnVmc1swXS5sZW5ndGgpIHtcbiAgICAgIGJ5dGVzIC09IHRoaXMuX2J1ZnNbMF0ubGVuZ3RoXG4gICAgICB0aGlzLmxlbmd0aCAtPSB0aGlzLl9idWZzWzBdLmxlbmd0aFxuICAgICAgdGhpcy5fYnVmcy5zaGlmdCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2J1ZnNbMF0gPSB0aGlzLl9idWZzWzBdLnNsaWNlKGJ5dGVzKVxuICAgICAgdGhpcy5sZW5ndGggLT0gYnl0ZXNcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuZHVwbGljYXRlID0gZnVuY3Rpb24gZHVwbGljYXRlICgpIHtcbiAgdmFyIGkgPSAwXG4gICAgLCBjb3B5ID0gbmV3IEJ1ZmZlckxpc3QoKVxuXG4gIGZvciAoOyBpIDwgdGhpcy5fYnVmcy5sZW5ndGg7IGkrKylcbiAgICBjb3B5LmFwcGVuZCh0aGlzLl9idWZzW2ldKVxuXG4gIHJldHVybiBjb3B5XG59XG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiBfZGVzdHJveSAoZXJyLCBjYikge1xuICB0aGlzLl9idWZzLmxlbmd0aCA9IDBcbiAgdGhpcy5sZW5ndGggPSAwXG4gIGNiKGVycilcbn1cblxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gKHNlYXJjaCwgb2Zmc2V0LCBlbmNvZGluZykge1xuICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gdW5kZWZpbmVkXG4gIH1cbiAgaWYgKHR5cGVvZiBzZWFyY2ggPT09ICdmdW5jdGlvbicgfHwgQXJyYXkuaXNBcnJheShzZWFyY2gpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBCdWZmZXJMaXN0LCBvciBVaW50OEFycmF5LicpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlYXJjaCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHNlYXJjaCA9IEJ1ZmZlci5mcm9tKFtzZWFyY2hdKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBzZWFyY2ggPT09ICdzdHJpbmcnKSB7XG4gICAgc2VhcmNoID0gQnVmZmVyLmZyb20oc2VhcmNoLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChzZWFyY2ggaW5zdGFuY2VvZiBCdWZmZXJMaXN0KSB7XG4gICAgc2VhcmNoID0gc2VhcmNoLnNsaWNlKClcbiAgfSBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKHNlYXJjaCkpIHtcbiAgICBzZWFyY2ggPSBCdWZmZXIuZnJvbShzZWFyY2gpXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0IHx8IDApXG4gIGlmIChpc05hTihvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gMFxuICB9XG5cbiAgaWYgKG9mZnNldCA8IDApIHtcbiAgICBvZmZzZXQgPSB0aGlzLmxlbmd0aCArIG9mZnNldFxuICB9XG5cbiAgaWYgKG9mZnNldCA8IDApIHtcbiAgICBvZmZzZXQgPSAwXG4gIH1cblxuICBpZiAoc2VhcmNoLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvZmZzZXQgPiB0aGlzLmxlbmd0aCA/IHRoaXMubGVuZ3RoIDogb2Zmc2V0XG4gIH1cblxuICB2YXIgYmxPZmZzZXQgPSB0aGlzLl9vZmZzZXQob2Zmc2V0KVxuICB2YXIgYmxJbmRleCA9IGJsT2Zmc2V0WzBdIC8vIGluZGV4IG9mIHdoaWNoIGludGVybmFsIGJ1ZmZlciB3ZSdyZSB3b3JraW5nIG9uXG4gIHZhciBidWZmT2Zmc2V0ID0gYmxPZmZzZXRbMV0gLy8gb2Zmc2V0IG9mIHRoZSBpbnRlcm5hbCBidWZmZXIgd2UncmUgd29ya2luZyBvblxuXG4gIC8vIHNjYW4gb3ZlciBlYWNoIGJ1ZmZlclxuICBmb3IgKGJsSW5kZXg7IGJsSW5kZXggPCB0aGlzLl9idWZzLmxlbmd0aDsgYmxJbmRleCsrKSB7XG4gICAgdmFyIGJ1ZmYgPSB0aGlzLl9idWZzW2JsSW5kZXhdXG4gICAgd2hpbGUoYnVmZk9mZnNldCA8IGJ1ZmYubGVuZ3RoKSB7XG4gICAgICB2YXIgYXZhaWxhYmxlV2luZG93ID0gYnVmZi5sZW5ndGggLSBidWZmT2Zmc2V0XG4gICAgICBpZiAoYXZhaWxhYmxlV2luZG93ID49IHNlYXJjaC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5hdGl2ZVNlYXJjaFJlc3VsdCA9IGJ1ZmYuaW5kZXhPZihzZWFyY2gsIGJ1ZmZPZmZzZXQpXG4gICAgICAgIGlmIChuYXRpdmVTZWFyY2hSZXN1bHQgIT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JldmVyc2VPZmZzZXQoW2JsSW5kZXgsIG5hdGl2ZVNlYXJjaFJlc3VsdF0pXG4gICAgICAgIH1cbiAgICAgICAgYnVmZk9mZnNldCA9IGJ1ZmYubGVuZ3RoIC0gc2VhcmNoLmxlbmd0aCArIDEgLy8gZW5kIG9mIG5hdGl2ZSBzZWFyY2ggd2luZG93XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmV2T2Zmc2V0ID0gdGhpcy5fcmV2ZXJzZU9mZnNldChbYmxJbmRleCwgYnVmZk9mZnNldF0pXG4gICAgICAgIGlmICh0aGlzLl9tYXRjaChyZXZPZmZzZXQsIHNlYXJjaCkpIHtcbiAgICAgICAgICByZXR1cm4gcmV2T2Zmc2V0XG4gICAgICAgIH1cbiAgICAgICAgYnVmZk9mZnNldCsrXG4gICAgICB9XG4gICAgfVxuICAgIGJ1ZmZPZmZzZXQgPSAwXG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9tYXRjaCA9IGZ1bmN0aW9uKG9mZnNldCwgc2VhcmNoKSB7XG4gIGlmICh0aGlzLmxlbmd0aCAtIG9mZnNldCA8IHNlYXJjaC5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBmb3IgKHZhciBzZWFyY2hPZmZzZXQgPSAwOyBzZWFyY2hPZmZzZXQgPCBzZWFyY2gubGVuZ3RoIDsgc2VhcmNoT2Zmc2V0KyspIHtcbiAgICBpZih0aGlzLmdldChvZmZzZXQgKyBzZWFyY2hPZmZzZXQpICE9PSBzZWFyY2hbc2VhcmNoT2Zmc2V0XSl7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuXG47KGZ1bmN0aW9uICgpIHtcbiAgdmFyIG1ldGhvZHMgPSB7XG4gICAgICAncmVhZERvdWJsZUJFJyA6IDhcbiAgICAsICdyZWFkRG91YmxlTEUnIDogOFxuICAgICwgJ3JlYWRGbG9hdEJFJyAgOiA0XG4gICAgLCAncmVhZEZsb2F0TEUnICA6IDRcbiAgICAsICdyZWFkSW50MzJCRScgIDogNFxuICAgICwgJ3JlYWRJbnQzMkxFJyAgOiA0XG4gICAgLCAncmVhZFVJbnQzMkJFJyA6IDRcbiAgICAsICdyZWFkVUludDMyTEUnIDogNFxuICAgICwgJ3JlYWRJbnQxNkJFJyAgOiAyXG4gICAgLCAncmVhZEludDE2TEUnICA6IDJcbiAgICAsICdyZWFkVUludDE2QkUnIDogMlxuICAgICwgJ3JlYWRVSW50MTZMRScgOiAyXG4gICAgLCAncmVhZEludDgnICAgICA6IDFcbiAgICAsICdyZWFkVUludDgnICAgIDogMVxuICAgICwgJ3JlYWRJbnRCRScgICAgOiBudWxsXG4gICAgLCAncmVhZEludExFJyAgICA6IG51bGxcbiAgICAsICdyZWFkVUludEJFJyAgIDogbnVsbFxuICAgICwgJ3JlYWRVSW50TEUnICAgOiBudWxsXG4gIH1cblxuICBmb3IgKHZhciBtIGluIG1ldGhvZHMpIHtcbiAgICAoZnVuY3Rpb24gKG0pIHtcbiAgICAgIGlmIChtZXRob2RzW21dID09PSBudWxsKSB7XG4gICAgICAgIEJ1ZmZlckxpc3QucHJvdG90eXBlW21dID0gZnVuY3Rpb24gKG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYnl0ZUxlbmd0aClbbV0oMCwgYnl0ZUxlbmd0aClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIEJ1ZmZlckxpc3QucHJvdG90eXBlW21dID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbWV0aG9kc1ttXSlbbV0oMClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0obSkpXG4gIH1cbn0oKSlcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlckxpc3RcbiIsImNvbnN0IFJhYmluID0gcmVxdWlyZSgnLi9yYWJpbicpXG5jb25zdCBnZXRSYWJpbiA9IHJlcXVpcmUoJy4uL2Rpc3QvcmFiaW4td2FzbS5ub2RlLmpzJylcblxuY29uc3QgY3JlYXRlID0gYXN5bmMgKGJpdHMsIG1pbiwgbWF4LCB3aW5kb3dTaXplKSA9PiB7XG4gICAgY29uc3QgY29tcGlsZWQgPSBhd2FpdCBnZXRSYWJpbigpXG5cbiAgICByZXR1cm4gbmV3IFJhYmluKGJpdHMsIG1pbiwgbWF4LCB3aW5kb3dTaXplLCBjb21waWxlZClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgUmFiaW4sXG4gICAgY3JlYXRlXG59XG4iLCJcbm1vZHVsZS5leHBvcnRzID0ge1xuICBXT1JLRVJfUkVRVUVTVF9SRUFEX0xPQ0s6ICdsb2NrOndvcmtlcjpyZXF1ZXN0LXJlYWQnLFxuICBXT1JLRVJfUkVMRUFTRV9SRUFEX0xPQ0s6ICdsb2NrOndvcmtlcjpyZWxlYXNlLXJlYWQnLFxuICBNQVNURVJfR1JBTlRfUkVBRF9MT0NLOiAnbG9jazptYXN0ZXI6Z3JhbnQtcmVhZCcsXG5cbiAgV09SS0VSX1JFUVVFU1RfV1JJVEVfTE9DSzogJ2xvY2s6d29ya2VyOnJlcXVlc3Qtd3JpdGUnLFxuICBXT1JLRVJfUkVMRUFTRV9XUklURV9MT0NLOiAnbG9jazp3b3JrZXI6cmVsZWFzZS13cml0ZScsXG4gIE1BU1RFUl9HUkFOVF9XUklURV9MT0NLOiAnbG9jazptYXN0ZXI6Z3JhbnQtd3JpdGUnXG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2luZGV4Jyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIGJyb3dzZXJpZnkgYnkgZGVmYXVsdCBvbmx5IHB1bGxzIGluIGZpbGVzIHRoYXQgYXJlIGhhcmQgY29kZWQgaW4gcmVxdWlyZXNcbi8vIEluIG9yZGVyIG9mIGxhc3QgdG8gZmlyc3QgaW4gdGhpcyBmaWxlLCB0aGUgZGVmYXVsdCB3b3JkbGlzdCB3aWxsIGJlIGNob3NlblxuLy8gYmFzZWQgb24gd2hhdCBpcyBwcmVzZW50LiAoQnVuZGxlcyBtYXkgcmVtb3ZlIHdvcmRsaXN0cyB0aGV5IGRvbid0IG5lZWQpXG5jb25zdCB3b3JkbGlzdHMgPSB7fTtcbmV4cG9ydHMud29yZGxpc3RzID0gd29yZGxpc3RzO1xubGV0IF9kZWZhdWx0O1xuZXhwb3J0cy5fZGVmYXVsdCA9IF9kZWZhdWx0O1xudHJ5IHtcbiAgICBleHBvcnRzLl9kZWZhdWx0ID0gX2RlZmF1bHQgPSByZXF1aXJlKCcuL3dvcmRsaXN0cy9jemVjaC5qc29uJyk7XG4gICAgd29yZGxpc3RzLmN6ZWNoID0gX2RlZmF1bHQ7XG59XG5jYXRjaCAoZXJyKSB7IH1cbnRyeSB7XG4gICAgZXhwb3J0cy5fZGVmYXVsdCA9IF9kZWZhdWx0ID0gcmVxdWlyZSgnLi93b3JkbGlzdHMvY2hpbmVzZV9zaW1wbGlmaWVkLmpzb24nKTtcbiAgICB3b3JkbGlzdHMuY2hpbmVzZV9zaW1wbGlmaWVkID0gX2RlZmF1bHQ7XG59XG5jYXRjaCAoZXJyKSB7IH1cbnRyeSB7XG4gICAgZXhwb3J0cy5fZGVmYXVsdCA9IF9kZWZhdWx0ID0gcmVxdWlyZSgnLi93b3JkbGlzdHMvY2hpbmVzZV90cmFkaXRpb25hbC5qc29uJyk7XG4gICAgd29yZGxpc3RzLmNoaW5lc2VfdHJhZGl0aW9uYWwgPSBfZGVmYXVsdDtcbn1cbmNhdGNoIChlcnIpIHsgfVxudHJ5IHtcbiAgICBleHBvcnRzLl9kZWZhdWx0ID0gX2RlZmF1bHQgPSByZXF1aXJlKCcuL3dvcmRsaXN0cy9rb3JlYW4uanNvbicpO1xuICAgIHdvcmRsaXN0cy5rb3JlYW4gPSBfZGVmYXVsdDtcbn1cbmNhdGNoIChlcnIpIHsgfVxudHJ5IHtcbiAgICBleHBvcnRzLl9kZWZhdWx0ID0gX2RlZmF1bHQgPSByZXF1aXJlKCcuL3dvcmRsaXN0cy9mcmVuY2guanNvbicpO1xuICAgIHdvcmRsaXN0cy5mcmVuY2ggPSBfZGVmYXVsdDtcbn1cbmNhdGNoIChlcnIpIHsgfVxudHJ5IHtcbiAgICBleHBvcnRzLl9kZWZhdWx0ID0gX2RlZmF1bHQgPSByZXF1aXJlKCcuL3dvcmRsaXN0cy9pdGFsaWFuLmpzb24nKTtcbiAgICB3b3JkbGlzdHMuaXRhbGlhbiA9IF9kZWZhdWx0O1xufVxuY2F0Y2ggKGVycikgeyB9XG50cnkge1xuICAgIGV4cG9ydHMuX2RlZmF1bHQgPSBfZGVmYXVsdCA9IHJlcXVpcmUoJy4vd29yZGxpc3RzL3NwYW5pc2guanNvbicpO1xuICAgIHdvcmRsaXN0cy5zcGFuaXNoID0gX2RlZmF1bHQ7XG59XG5jYXRjaCAoZXJyKSB7IH1cbnRyeSB7XG4gICAgZXhwb3J0cy5fZGVmYXVsdCA9IF9kZWZhdWx0ID0gcmVxdWlyZSgnLi93b3JkbGlzdHMvamFwYW5lc2UuanNvbicpO1xuICAgIHdvcmRsaXN0cy5qYXBhbmVzZSA9IF9kZWZhdWx0O1xuICAgIHdvcmRsaXN0cy5KQSA9IF9kZWZhdWx0O1xufVxuY2F0Y2ggKGVycikgeyB9XG50cnkge1xuICAgIGV4cG9ydHMuX2RlZmF1bHQgPSBfZGVmYXVsdCA9IHJlcXVpcmUoJy4vd29yZGxpc3RzL3BvcnR1Z3Vlc2UuanNvbicpO1xuICAgIHdvcmRsaXN0cy5wb3J0dWd1ZXNlID0gX2RlZmF1bHQ7XG59XG5jYXRjaCAoZXJyKSB7IH1cbnRyeSB7XG4gICAgZXhwb3J0cy5fZGVmYXVsdCA9IF9kZWZhdWx0ID0gcmVxdWlyZSgnLi93b3JkbGlzdHMvZW5nbGlzaC5qc29uJyk7XG4gICAgd29yZGxpc3RzLmVuZ2xpc2ggPSBfZGVmYXVsdDtcbiAgICB3b3JkbGlzdHMuRU4gPSBfZGVmYXVsdDtcbn1cbmNhdGNoIChlcnIpIHsgfVxuIiwibW9kdWxlLmV4cG9ydHMgPSBleHRlbmRcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0XG59XG4iLCIvKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgbWFzayBnZW5lcmF0aW9uIGZ1bmN0aW9uIE1HRjEuXG4gKlxuICogQGF1dGhvciBTdGVmYW4gU2llZ2xcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEyIFN0ZWZhbiBTaWVnbCA8c3Rlc2llQGJyb2tlbnBpcGUuZGU+XG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbmZvcmdlLm1nZiA9IGZvcmdlLm1nZiB8fCB7fTtcbnZhciBtZ2YxID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5tZ2YubWdmMSA9IGZvcmdlLm1nZjEgPSBmb3JnZS5tZ2YxIHx8IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBNR0YxIG1hc2sgZ2VuZXJhdGlvbiBmdW5jdGlvbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBBUEkgdG8gdXNlIChlZzogZm9yZ2UubWQuc2hhMS5jcmVhdGUoKSkuXG4gKlxuICogQHJldHVybiBhIG1hc2sgZ2VuZXJhdGlvbiBmdW5jdGlvbiBvYmplY3QuXG4gKi9cbm1nZjEuY3JlYXRlID0gZnVuY3Rpb24obWQpIHtcbiAgdmFyIG1nZiA9IHtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBtYXNrIG9mIHNwZWNpZmllZCBsZW5ndGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VlZCBUaGUgc2VlZCBmb3IgbWFzayBnZW5lcmF0aW9uLlxuICAgICAqIEBwYXJhbSBtYXNrTGVuIE51bWJlciBvZiBieXRlcyB0byBnZW5lcmF0ZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBnZW5lcmF0ZWQgbWFzay5cbiAgICAgKi9cbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24oc2VlZCwgbWFza0xlbikge1xuICAgICAgLyogMi4gTGV0IFQgYmUgdGhlIGVtcHR5IG9jdGV0IHN0cmluZy4gKi9cbiAgICAgIHZhciB0ID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuXG4gICAgICAvKiAzLiBGb3IgY291bnRlciBmcm9tIDAgdG8gY2VpbChtYXNrTGVuIC8gaExlbiksIGRvIHRoZSBmb2xsb3dpbmc6ICovXG4gICAgICB2YXIgbGVuID0gTWF0aC5jZWlsKG1hc2tMZW4gLyBtZC5kaWdlc3RMZW5ndGgpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8qIGEuIENvbnZlcnQgY291bnRlciB0byBhbiBvY3RldCBzdHJpbmcgQyBvZiBsZW5ndGggNCBvY3RldHMgKi9cbiAgICAgICAgdmFyIGMgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgICAgIGMucHV0SW50MzIoaSk7XG5cbiAgICAgICAgLyogYi4gQ29uY2F0ZW5hdGUgdGhlIGhhc2ggb2YgdGhlIHNlZWQgbWdmU2VlZCBhbmQgQyB0byB0aGUgb2N0ZXRcbiAgICAgICAgICogc3RyaW5nIFQ6ICovXG4gICAgICAgIG1kLnN0YXJ0KCk7XG4gICAgICAgIG1kLnVwZGF0ZShzZWVkICsgYy5nZXRCeXRlcygpKTtcbiAgICAgICAgdC5wdXRCdWZmZXIobWQuZGlnZXN0KCkpO1xuICAgICAgfVxuXG4gICAgICAvKiBPdXRwdXQgdGhlIGxlYWRpbmcgbWFza0xlbiBvY3RldHMgb2YgVCBhcyB0aGUgb2N0ZXQgc3RyaW5nIG1hc2suICovXG4gICAgICB0LnRydW5jYXRlKHQubGVuZ3RoKCkgLSBtYXNrTGVuKTtcbiAgICAgIHJldHVybiB0LmdldEJ5dGVzKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBtZ2Y7XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHNoYTMgPSByZXF1aXJlKCdqcy1zaGEzJylcbmNvbnN0IG11cm11cjMgPSByZXF1aXJlKCdtdXJtdXJoYXNoM2pzJylcblxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IHNoYSA9IHJlcXVpcmUoJy4vY3J5cHRvLXNoYTEtMicpXG5cbmNvbnN0IHRvQ2FsbGJhY2sgPSB1dGlscy50b0NhbGxiYWNrXG5jb25zdCB0b0J1ZiA9IHV0aWxzLnRvQnVmXG5jb25zdCBmcm9tU3RyaW5nID0gdXRpbHMuZnJvbVN0cmluZ1xuY29uc3QgZnJvbU51bWJlclRvMzJCaXRCdWYgPSB1dGlscy5mcm9tTnVtYmVyVG8zMkJpdEJ1ZlxuXG5jb25zdCBkYmxTaGEyMjU2ID0gKGJ1ZiwgY2IpID0+IHtcbiAgc2hhLnNoYTIyNTYoYnVmLCAoZXJyLCBmaXJzdEhhc2gpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBjYihlcnIpXG4gICAgfVxuICAgIHNoYS5zaGEyMjU2KChCdWZmZXIuZnJvbShmaXJzdEhhc2gpKSwgY2IpXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzaGExOiBzaGEuc2hhMSxcbiAgc2hhMjI1Njogc2hhLnNoYTIyNTYsXG4gIHNoYTI1MTI6IHNoYS5zaGEyNTEyLFxuICBzaGEzNTEyOiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMuc2hhM181MTIpKSxcbiAgc2hhMzM4NDogdG9DYWxsYmFjayh0b0J1ZihzaGEzLnNoYTNfMzg0KSksXG4gIHNoYTMyNTY6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5zaGEzXzI1NikpLFxuICBzaGEzMjI0OiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMuc2hhM18yMjQpKSxcbiAgc2hha2UxMjg6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5zaGFrZV8xMjgsIDEyOCkpLFxuICBzaGFrZTI1NjogdG9DYWxsYmFjayh0b0J1ZihzaGEzLnNoYWtlXzI1NiwgMjU2KSksXG4gIGtlY2NhazIyNDogdG9DYWxsYmFjayh0b0J1ZihzaGEzLmtlY2Nha18yMjQpKSxcbiAga2VjY2FrMjU2OiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMua2VjY2FrXzI1NikpLFxuICBrZWNjYWszODQ6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5rZWNjYWtfMzg0KSksXG4gIGtlY2NhazUxMjogdG9DYWxsYmFjayh0b0J1ZihzaGEzLmtlY2Nha181MTIpKSxcbiAgbXVybXVyMzEyODogdG9DYWxsYmFjayh0b0J1Zihmcm9tU3RyaW5nKG11cm11cjMueDY0Lmhhc2gxMjgpKSksXG4gIG11cm11cjMzMjogdG9DYWxsYmFjayhmcm9tTnVtYmVyVG8zMkJpdEJ1Zihmcm9tU3RyaW5nKG11cm11cjMueDg2Lmhhc2gzMikpKSxcbiAgYWRkQmxha2U6IHJlcXVpcmUoJy4vYmxha2UnKSxcbiAgZGJsU2hhMjI1NjogZGJsU2hhMjI1NlxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9oZWFwJyk7XG4iLCJ2YXIgcm5nID0gcmVxdWlyZSgnLi9saWIvcm5nJyk7XG52YXIgYnl0ZXNUb1V1aWQgPSByZXF1aXJlKCcuL2xpYi9ieXRlc1RvVXVpZCcpO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICBpZiAodHlwZW9mKG9wdGlvbnMpID09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gb3B0aW9ucyA9PT0gJ2JpbmFyeScgPyBuZXcgQXJyYXkoMTYpIDogbnVsbDtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gKHJuZHNbNl0gJiAweDBmKSB8IDB4NDA7XG4gIHJuZHNbOF0gPSAocm5kc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcbiAgaWYgKGJ1Zikge1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgKytpaSkge1xuICAgICAgYnVmW2kgKyBpaV0gPSBybmRzW2lpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmIHx8IGJ5dGVzVG9VdWlkKHJuZHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHY0O1xuIiwidmFyIHJuZyA9IHJlcXVpcmUoJy4vbGliL3JuZycpO1xudmFyIGJ5dGVzVG9VdWlkID0gcmVxdWlyZSgnLi9saWIvYnl0ZXNUb1V1aWQnKTtcblxuLy8gKipgdjEoKWAgLSBHZW5lcmF0ZSB0aW1lLWJhc2VkIFVVSUQqKlxuLy9cbi8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy9VVUlELmpzXG4vLyBhbmQgaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L3V1aWQuaHRtbFxuXG52YXIgX25vZGVJZDtcbnZhciBfY2xvY2tzZXE7XG5cbi8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxudmFyIF9sYXN0TVNlY3MgPSAwO1xudmFyIF9sYXN0TlNlY3MgPSAwO1xuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkIGZvciBBUEkgZGV0YWlsc1xuZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gIHZhciBiID0gYnVmIHx8IFtdO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICB2YXIgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxO1xuXG4gIC8vIG5vZGUgYW5kIGNsb2Nrc2VxIG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gcmFuZG9tIHZhbHVlcyBpZiB0aGV5J3JlIG5vdFxuICAvLyBzcGVjaWZpZWQuICBXZSBkbyB0aGlzIGxhemlseSB0byBtaW5pbWl6ZSBpc3N1ZXMgcmVsYXRlZCB0byBpbnN1ZmZpY2llbnRcbiAgLy8gc3lzdGVtIGVudHJvcHkuICBTZWUgIzE4OVxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICB2YXIgc2VlZEJ5dGVzID0gcm5nKCk7XG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtcbiAgICAgICAgc2VlZEJ5dGVzWzBdIHwgMHgwMSxcbiAgICAgICAgc2VlZEJ5dGVzWzFdLCBzZWVkQnl0ZXNbMl0sIHNlZWRCeXRlc1szXSwgc2VlZEJ5dGVzWzRdLCBzZWVkQnl0ZXNbNV1cbiAgICAgIF07XG4gICAgfVxuICAgIGlmIChjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxuICAgICAgY2xvY2tzZXEgPSBfY2xvY2tzZXEgPSAoc2VlZEJ5dGVzWzZdIDw8IDggfCBzZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuICB2YXIgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1zZWNzIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgLy8gUGVyIDQuMi4xLjIsIHVzZSBjb3VudCBvZiB1dWlkJ3MgZ2VuZXJhdGVkIGR1cmluZyB0aGUgY3VycmVudCBjbG9ja1xuICAvLyBjeWNsZSB0byBzaW11bGF0ZSBoaWdoZXIgcmVzb2x1dGlvbiBjbG9ja1xuICB2YXIgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7XG5cbiAgLy8gVGltZSBzaW5jZSBsYXN0IHV1aWQgY3JlYXRpb24gKGluIG1zZWNzKVxuICB2YXIgZHQgPSAobXNlY3MgLSBfbGFzdE1TZWNzKSArIChuc2VjcyAtIF9sYXN0TlNlY3MpLzEwMDAwO1xuXG4gIC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cbiAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09PSB1bmRlZmluZWQpIHtcbiAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgfVxuXG4gIC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcbiAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09PSB1bmRlZmluZWQpIHtcbiAgICBuc2VjcyA9IDA7XG4gIH1cblxuICAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXVpZC52MSgpOiBDYW5cXCd0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlYycpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxO1xuXG4gIC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDtcblxuICAvLyBgdGltZV9sb3dgXG4gIHZhciB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgYltpKytdID0gdGwgPj4+IDI0ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bCAmIDB4ZmY7XG5cbiAgLy8gYHRpbWVfbWlkYFxuICB2YXIgdG1oID0gKG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCkgJiAweGZmZmZmZmY7XG4gIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRtaCAmIDB4ZmY7XG5cbiAgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcbiAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuICBiW2krK10gPSB0bWggPj4+IDE2ICYgMHhmZjtcblxuICAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcbiAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwO1xuXG4gIC8vIGBjbG9ja19zZXFfbG93YFxuICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7XG5cbiAgLy8gYG5vZGVgXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgNjsgKytuKSB7XG4gICAgYltpICsgbl0gPSBub2RlW25dO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZiA/IGJ1ZiA6IGJ5dGVzVG9VdWlkKGIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHYxO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG4gIGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG4gIGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1ZztcbiAgY3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuICBjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcbiAgY3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuICBjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcbiAgY3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuICBPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcbiAgfSk7XG4gIC8qKlxuICAqIEFjdGl2ZSBgZGVidWdgIGluc3RhbmNlcy5cbiAgKi9cblxuICBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMgPSBbXTtcbiAgLyoqXG4gICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gICovXG5cbiAgY3JlYXRlRGVidWcubmFtZXMgPSBbXTtcbiAgY3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcbiAgLyoqXG4gICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICAqXG4gICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICAqL1xuXG4gIGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcbiAgLyoqXG4gICogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcbiAgKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2VcbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cblxuICBmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgICB2YXIgaGFzaCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuICAgICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG4gIH1cblxuICBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuICAvKipcbiAgKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuICAgIHZhciBwcmV2VGltZTtcblxuICAgIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgICAgLy8gRGlzYWJsZWQ/XG4gICAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlbGYgPSBkZWJ1ZzsgLy8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblxuICAgICAgdmFyIGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG4gICAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgICAgc2VsZi5kaWZmID0gbXM7XG4gICAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgICBwcmV2VGltZSA9IGN1cnI7XG4gICAgICBhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICAgIH0gLy8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblxuXG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uIChtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAgIC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgdmFyIGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblxuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7IC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblxuICAgICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICBpbmRleC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7IC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cbiAgICAgIGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcbiAgICAgIHZhciBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcbiAgICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cblxuICAgIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICBkZWJ1Zy5lbmFibGVkID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuICAgIGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuICAgIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcbiAgICBkZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcbiAgICBkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7IC8vIERlYnVnLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuICAgIC8vIGRlYnVnLnJhd0xvZyA9IHJhd0xvZztcbiAgICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXG4gICAgaWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcbiAgICB9XG5cbiAgICBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMucHVzaChkZWJ1Zyk7XG4gICAgcmV0dXJuIGRlYnVnO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB2YXIgaW5kZXggPSBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGNyZWF0ZURlYnVnLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG4gICAgcmV0dXJuIGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG4gIH1cbiAgLyoqXG4gICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICAqIEBhcGkgcHVibGljXG4gICovXG5cblxuICBmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICAgIGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG4gICAgY3JlYXRlRGVidWcubmFtZXMgPSBbXTtcbiAgICBjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuICAgIHZhciBpO1xuICAgIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gICAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKCFzcGxpdFtpXSkge1xuICAgICAgICAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cbiAgICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgICAgY3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZURlYnVnLmluc3RhbmNlc1tpXTtcbiAgICAgIGluc3RhbmNlLmVuYWJsZWQgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICAqXG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgY3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcbiAgfVxuICAvKipcbiAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICAgIGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgKiBDb2VyY2UgYHZhbGAuXG4gICpcbiAgKiBAcGFyYW0ge01peGVkfSB2YWxcbiAgKiBAcmV0dXJuIHtNaXhlZH1cbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuICByZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG5cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBzaGEzID0gcmVxdWlyZSgnanMtc2hhMycpXG5jb25zdCBtdXJtdXIzID0gcmVxdWlyZSgnbXVybXVyaGFzaDNqcycpXG5cbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBzaGEgPSByZXF1aXJlKCcuL2NyeXB0by1zaGExLTInKVxuXG5jb25zdCB0b0NhbGxiYWNrID0gdXRpbHMudG9DYWxsYmFja1xuY29uc3QgdG9CdWYgPSB1dGlscy50b0J1ZlxuY29uc3QgZnJvbVN0cmluZyA9IHV0aWxzLmZyb21TdHJpbmdcbmNvbnN0IGZyb21OdW1iZXJUbzMyQml0QnVmID0gdXRpbHMuZnJvbU51bWJlclRvMzJCaXRCdWZcblxuY29uc3QgZGJsU2hhMjI1NiA9IChidWYsIGNiKSA9PiB7XG4gIHNoYS5zaGEyMjU2KGJ1ZiwgKGVyciwgZmlyc3RIYXNoKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2IoZXJyKVxuICAgIH1cbiAgICBzaGEuc2hhMjI1NigoQnVmZmVyLmZyb20oZmlyc3RIYXNoKSksIGNiKVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2hhMTogc2hhLnNoYTEsXG4gIHNoYTIyNTY6IHNoYS5zaGEyMjU2LFxuICBzaGEyNTEyOiBzaGEuc2hhMjUxMixcbiAgc2hhMzUxMjogdG9DYWxsYmFjayh0b0J1ZihzaGEzLnNoYTNfNTEyKSksXG4gIHNoYTMzODQ6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5zaGEzXzM4NCkpLFxuICBzaGEzMjU2OiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMuc2hhM18yNTYpKSxcbiAgc2hhMzIyNDogdG9DYWxsYmFjayh0b0J1ZihzaGEzLnNoYTNfMjI0KSksXG4gIHNoYWtlMTI4OiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMuc2hha2VfMTI4LCAxMjgpKSxcbiAgc2hha2UyNTY6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5zaGFrZV8yNTYsIDI1NikpLFxuICBrZWNjYWsyMjQ6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5rZWNjYWtfMjI0KSksXG4gIGtlY2NhazI1NjogdG9DYWxsYmFjayh0b0J1ZihzaGEzLmtlY2Nha18yNTYpKSxcbiAga2VjY2FrMzg0OiB0b0NhbGxiYWNrKHRvQnVmKHNoYTMua2VjY2FrXzM4NCkpLFxuICBrZWNjYWs1MTI6IHRvQ2FsbGJhY2sodG9CdWYoc2hhMy5rZWNjYWtfNTEyKSksXG4gIG11cm11cjMxMjg6IHRvQ2FsbGJhY2sodG9CdWYoZnJvbVN0cmluZyhtdXJtdXIzLng2NC5oYXNoMTI4KSkpLFxuICBtdXJtdXIzMzI6IHRvQ2FsbGJhY2soZnJvbU51bWJlclRvMzJCaXRCdWYoZnJvbVN0cmluZyhtdXJtdXIzLng4Ni5oYXNoMzIpKSksXG4gIGFkZEJsYWtlOiByZXF1aXJlKCcuL2JsYWtlJyksXG4gIGRibFNoYTIyNTY6IGRibFNoYTIyNTZcbn1cbiIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtcyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JykgfHxcbiAgICBwbHVyYWwobXMsIGgsICdob3VyJykgfHxcbiAgICBwbHVyYWwobXMsIG0sICdtaW51dGUnKSB8fFxuICAgIHBsdXJhbChtcywgcywgJ3NlY29uZCcpIHx8XG4gICAgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobXMgPCBuICogMS41KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIH1cbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cbiIsIlxuLyoqXG4gKiBHZXRzIHRoZSBrZXlzIGZvciBhbiBvYmplY3QuXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGtleXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyAob2JqKXtcbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGkpKSB7XG4gICAgICBhcnIucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3V0ZjhqcyB2Mi4xLjIgYnkgQG1hdGhpYXMgKi9cblxudmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbi8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5mdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHR2YXIgb3V0cHV0ID0gW107XG5cdHZhciBjb3VudGVyID0gMDtcblx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdHZhciB2YWx1ZTtcblx0dmFyIGV4dHJhO1xuXHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dHB1dDtcbn1cblxuLy8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcbmZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0dmFyIGluZGV4ID0gLTE7XG5cdHZhciB2YWx1ZTtcblx0dmFyIG91dHB1dCA9ICcnO1xuXHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdH1cblx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSB7XG5cdGlmIChjb2RlUG9pbnQgPj0gMHhEODAwICYmIGNvZGVQb2ludCA8PSAweERGRkYpIHtcblx0XHRpZiAoc3RyaWN0KSB7XG5cdFx0XHR0aHJvdyBFcnJvcihcblx0XHRcdFx0J0xvbmUgc3Vycm9nYXRlIFUrJyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArXG5cdFx0XHRcdCcgaXMgbm90IGEgc2NhbGFyIHZhbHVlJ1xuXHRcdFx0KTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHJldHVybiB0cnVlO1xufVxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ5dGUoY29kZVBvaW50LCBzaGlmdCkge1xuXHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IHNoaWZ0KSAmIDB4M0YpIHwgMHg4MCk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQsIHN0cmljdCkge1xuXHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkZGODApID09IDApIHsgLy8gMS1ieXRlIHNlcXVlbmNlXG5cdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHR9XG5cdHZhciBzeW1ib2wgPSAnJztcblx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGODAwKSA9PSAwKSB7IC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhDMCk7XG5cdH1cblx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZGRjAwMDApID09IDApIHsgLy8gMy1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKCFjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSkge1xuXHRcdFx0Y29kZVBvaW50ID0gMHhGRkZEO1xuXHRcdH1cblx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTIpICYgMHgwRikgfCAweEUwKTtcblx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHR9XG5cdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRTAwMDAwKSA9PSAwKSB7IC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxOCkgJiAweDA3KSB8IDB4RjApO1xuXHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuXHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdH1cblx0c3ltYm9sICs9IHN0cmluZ0Zyb21DaGFyQ29kZSgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcblx0cmV0dXJuIHN5bWJvbDtcbn1cblxuZnVuY3Rpb24gdXRmOGVuY29kZShzdHJpbmcsIG9wdHMpIHtcblx0b3B0cyA9IG9wdHMgfHwge307XG5cdHZhciBzdHJpY3QgPSBmYWxzZSAhPT0gb3B0cy5zdHJpY3Q7XG5cblx0dmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG5cdHZhciBsZW5ndGggPSBjb2RlUG9pbnRzLmxlbmd0aDtcblx0dmFyIGluZGV4ID0gLTE7XG5cdHZhciBjb2RlUG9pbnQ7XG5cdHZhciBieXRlU3RyaW5nID0gJyc7XG5cdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0Y29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG5cdFx0Ynl0ZVN0cmluZyArPSBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50LCBzdHJpY3QpO1xuXHR9XG5cdHJldHVybiBieXRlU3RyaW5nO1xufVxuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG5cdGlmIChieXRlSW5kZXggPj0gYnl0ZUNvdW50KSB7XG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHR9XG5cblx0dmFyIGNvbnRpbnVhdGlvbkJ5dGUgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdGJ5dGVJbmRleCsrO1xuXG5cdGlmICgoY29udGludWF0aW9uQnl0ZSAmIDB4QzApID09IDB4ODApIHtcblx0XHRyZXR1cm4gY29udGludWF0aW9uQnl0ZSAmIDB4M0Y7XG5cdH1cblxuXHQvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgaXTigJlzIG5vdCBhIGNvbnRpbnVhdGlvbiBieXRlXG5cdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVN5bWJvbChzdHJpY3QpIHtcblx0dmFyIGJ5dGUxO1xuXHR2YXIgYnl0ZTI7XG5cdHZhciBieXRlMztcblx0dmFyIGJ5dGU0O1xuXHR2YXIgY29kZVBvaW50O1xuXG5cdGlmIChieXRlSW5kZXggPiBieXRlQ291bnQpIHtcblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdH1cblxuXHRpZiAoYnl0ZUluZGV4ID09IGJ5dGVDb3VudCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIFJlYWQgZmlyc3QgYnl0ZVxuXHRieXRlMSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0Ynl0ZUluZGV4Kys7XG5cblx0Ly8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG5cdGlmICgoYnl0ZTEgJiAweDgwKSA9PSAwKSB7XG5cdFx0cmV0dXJuIGJ5dGUxO1xuXHR9XG5cblx0Ly8gMi1ieXRlIHNlcXVlbmNlXG5cdGlmICgoYnl0ZTEgJiAweEUwKSA9PSAweEMwKSB7XG5cdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDFGKSA8PCA2KSB8IGJ5dGUyO1xuXHRcdGlmIChjb2RlUG9pbnQgPj0gMHg4MCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHR9XG5cdH1cblxuXHQvLyAzLWJ5dGUgc2VxdWVuY2UgKG1heSBpbmNsdWRlIHVucGFpcmVkIHN1cnJvZ2F0ZXMpXG5cdGlmICgoYnl0ZTEgJiAweEYwKSA9PSAweEUwKSB7XG5cdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTM7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweDA4MDApIHtcblx0XHRcdHJldHVybiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSA/IGNvZGVQb2ludCA6IDB4RkZGRDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHR9XG5cdH1cblxuXHQvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0aWYgKChieXRlMSAmIDB4RjgpID09IDB4RjApIHtcblx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdGJ5dGU0ID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwNykgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwQykgfFxuXHRcdFx0KGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTQ7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweDAxMDAwMCAmJiBjb2RlUG9pbnQgPD0gMHgxMEZGRkYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0fVxuXHR9XG5cblx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgVVRGLTggZGV0ZWN0ZWQnKTtcbn1cblxudmFyIGJ5dGVBcnJheTtcbnZhciBieXRlQ291bnQ7XG52YXIgYnl0ZUluZGV4O1xuZnVuY3Rpb24gdXRmOGRlY29kZShieXRlU3RyaW5nLCBvcHRzKSB7XG5cdG9wdHMgPSBvcHRzIHx8IHt9O1xuXHR2YXIgc3RyaWN0ID0gZmFsc2UgIT09IG9wdHMuc3RyaWN0O1xuXG5cdGJ5dGVBcnJheSA9IHVjczJkZWNvZGUoYnl0ZVN0cmluZyk7XG5cdGJ5dGVDb3VudCA9IGJ5dGVBcnJheS5sZW5ndGg7XG5cdGJ5dGVJbmRleCA9IDA7XG5cdHZhciBjb2RlUG9pbnRzID0gW107XG5cdHZhciB0bXA7XG5cdHdoaWxlICgodG1wID0gZGVjb2RlU3ltYm9sKHN0cmljdCkpICE9PSBmYWxzZSkge1xuXHRcdGNvZGVQb2ludHMucHVzaCh0bXApO1xuXHR9XG5cdHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0dmVyc2lvbjogJzIuMS4yJyxcblx0ZW5jb2RlOiB1dGY4ZW5jb2RlLFxuXHRkZWNvZGU6IHV0ZjhkZWNvZGVcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFmdGVyXG5cbmZ1bmN0aW9uIGFmdGVyKGNvdW50LCBjYWxsYmFjaywgZXJyX2NiKSB7XG4gICAgdmFyIGJhaWwgPSBmYWxzZVxuICAgIGVycl9jYiA9IGVycl9jYiB8fCBub29wXG4gICAgcHJveHkuY291bnQgPSBjb3VudFxuXG4gICAgcmV0dXJuIChjb3VudCA9PT0gMCkgPyBjYWxsYmFjaygpIDogcHJveHlcblxuICAgIGZ1bmN0aW9uIHByb3h5KGVyciwgcmVzdWx0KSB7XG4gICAgICAgIGlmIChwcm94eS5jb3VudCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FmdGVyIGNhbGxlZCB0b28gbWFueSB0aW1lcycpXG4gICAgICAgIH1cbiAgICAgICAgLS1wcm94eS5jb3VudFxuXG4gICAgICAgIC8vIGFmdGVyIGZpcnN0IGVycm9yLCByZXN0IGFyZSBwYXNzZWQgdG8gZXJyX2NiXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGJhaWwgPSB0cnVlXG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgICAvLyBmdXR1cmUgZXJyb3IgY2FsbGJhY2tzIHdpbGwgZ28gdG8gZXJyb3IgaGFuZGxlclxuICAgICAgICAgICAgY2FsbGJhY2sgPSBlcnJfY2JcbiAgICAgICAgfSBlbHNlIGlmIChwcm94eS5jb3VudCA9PT0gMCAmJiAhYmFpbCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBub29wKCkge31cbiIsIi8qKlxyXG4gKiBDcmVhdGUgYSBibG9iIGJ1aWxkZXIgZXZlbiB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxyXG4gKi9cclxuXHJcbnZhciBCbG9iQnVpbGRlciA9IHR5cGVvZiBCbG9iQnVpbGRlciAhPT0gJ3VuZGVmaW5lZCcgPyBCbG9iQnVpbGRlciA6XHJcbiAgdHlwZW9mIFdlYktpdEJsb2JCdWlsZGVyICE9PSAndW5kZWZpbmVkJyA/IFdlYktpdEJsb2JCdWlsZGVyIDpcclxuICB0eXBlb2YgTVNCbG9iQnVpbGRlciAhPT0gJ3VuZGVmaW5lZCcgPyBNU0Jsb2JCdWlsZGVyIDpcclxuICB0eXBlb2YgTW96QmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnID8gTW96QmxvYkJ1aWxkZXIgOiBcclxuICBmYWxzZTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIGlzIHN1cHBvcnRlZFxyXG4gKi9cclxuXHJcbnZhciBibG9iU3VwcG9ydGVkID0gKGZ1bmN0aW9uKCkge1xyXG4gIHRyeSB7XHJcbiAgICB2YXIgYSA9IG5ldyBCbG9iKFsnaGknXSk7XHJcbiAgICByZXR1cm4gYS5zaXplID09PSAyO1xyXG4gIH0gY2F0Y2goZSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufSkoKTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIHN1cHBvcnRzIEFycmF5QnVmZmVyVmlld3NcclxuICogRmFpbHMgaW4gU2FmYXJpIDYsIHNvIHdlIG5lZWQgdG8gbWFwIHRvIEFycmF5QnVmZmVycyB0aGVyZS5cclxuICovXHJcblxyXG52YXIgYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID0gYmxvYlN1cHBvcnRlZCAmJiAoZnVuY3Rpb24oKSB7XHJcbiAgdHJ5IHtcclxuICAgIHZhciBiID0gbmV3IEJsb2IoW25ldyBVaW50OEFycmF5KFsxLDJdKV0pO1xyXG4gICAgcmV0dXJuIGIuc2l6ZSA9PT0gMjtcclxuICB9IGNhdGNoKGUpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn0pKCk7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgQmxvYkJ1aWxkZXIgaXMgc3VwcG9ydGVkXHJcbiAqL1xyXG5cclxudmFyIGJsb2JCdWlsZGVyU3VwcG9ydGVkID0gQmxvYkJ1aWxkZXJcclxuICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuYXBwZW5kXHJcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmdldEJsb2I7XHJcblxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgbWFwcyBBcnJheUJ1ZmZlclZpZXdzIHRvIEFycmF5QnVmZmVyc1xyXG4gKiBVc2VkIGJ5IEJsb2JCdWlsZGVyIGNvbnN0cnVjdG9yIGFuZCBvbGQgYnJvd3NlcnMgdGhhdCBkaWRuJ3RcclxuICogc3VwcG9ydCBpdCBpbiB0aGUgQmxvYiBjb25zdHJ1Y3Rvci5cclxuICovXHJcblxyXG5mdW5jdGlvbiBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSkge1xyXG4gIHJldHVybiBhcnkubWFwKGZ1bmN0aW9uKGNodW5rKSB7XHJcbiAgICBpZiAoY2h1bmsuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcclxuICAgICAgdmFyIGJ1ZiA9IGNodW5rLmJ1ZmZlcjtcclxuXHJcbiAgICAgIC8vIGlmIHRoaXMgaXMgYSBzdWJhcnJheSwgbWFrZSBhIGNvcHkgc28gd2Ugb25seVxyXG4gICAgICAvLyBpbmNsdWRlIHRoZSBzdWJhcnJheSByZWdpb24gZnJvbSB0aGUgdW5kZXJseWluZyBidWZmZXJcclxuICAgICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggIT09IGJ1Zi5ieXRlTGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIGNvcHkgPSBuZXcgVWludDhBcnJheShjaHVuay5ieXRlTGVuZ3RoKTtcclxuICAgICAgICBjb3B5LnNldChuZXcgVWludDhBcnJheShidWYsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpKTtcclxuICAgICAgICBidWYgPSBjb3B5LmJ1ZmZlcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGJ1ZjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY2h1bms7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEJsb2JCdWlsZGVyQ29uc3RydWN0b3IoYXJ5LCBvcHRpb25zKSB7XHJcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIHZhciBiYiA9IG5ldyBCbG9iQnVpbGRlcigpO1xyXG4gIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KS5mb3JFYWNoKGZ1bmN0aW9uKHBhcnQpIHtcclxuICAgIGJiLmFwcGVuZChwYXJ0KTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIChvcHRpb25zLnR5cGUpID8gYmIuZ2V0QmxvYihvcHRpb25zLnR5cGUpIDogYmIuZ2V0QmxvYigpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gQmxvYkNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xyXG4gIHJldHVybiBuZXcgQmxvYihtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSksIG9wdGlvbnMgfHwge30pO1xyXG59O1xyXG5cclxuaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJykge1xyXG4gIEJsb2JCdWlsZGVyQ29uc3RydWN0b3IucHJvdG90eXBlID0gQmxvYi5wcm90b3R5cGU7XHJcbiAgQmxvYkNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IEJsb2IucHJvdG90eXBlO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcclxuICBpZiAoYmxvYlN1cHBvcnRlZCkge1xyXG4gICAgcmV0dXJuIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA/IEJsb2IgOiBCbG9iQ29uc3RydWN0b3I7XHJcbiAgfSBlbHNlIGlmIChibG9iQnVpbGRlclN1cHBvcnRlZCkge1xyXG4gICAgcmV0dXJuIEJsb2JCdWlsZGVyQ29uc3RydWN0b3I7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG59KSgpO1xyXG4iLCIvKipcbiAqIEFuIGFic3RyYWN0aW9uIGZvciBzbGljaW5nIGFuIGFycmF5YnVmZmVyIGV2ZW4gd2hlblxuICogQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlIGlzIG5vdCBzdXBwb3J0ZWRcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyYXlidWZmZXIsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYXJyYXlidWZmZXIuYnl0ZUxlbmd0aDtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICBlbmQgPSBlbmQgfHwgYnl0ZXM7XG5cbiAgaWYgKGFycmF5YnVmZmVyLnNsaWNlKSB7IHJldHVybiBhcnJheWJ1ZmZlci5zbGljZShzdGFydCwgZW5kKTsgfVxuXG4gIGlmIChzdGFydCA8IDApIHsgc3RhcnQgKz0gYnl0ZXM7IH1cbiAgaWYgKGVuZCA8IDApIHsgZW5kICs9IGJ5dGVzOyB9XG4gIGlmIChlbmQgPiBieXRlcykgeyBlbmQgPSBieXRlczsgfVxuXG4gIGlmIChzdGFydCA+PSBieXRlcyB8fCBzdGFydCA+PSBlbmQgfHwgYnl0ZXMgPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKDApO1xuICB9XG5cbiAgdmFyIGFidiA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcbiAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGVuZCAtIHN0YXJ0KTtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0LCBpaSA9IDA7IGkgPCBlbmQ7IGkrKywgaWkrKykge1xuICAgIHJlc3VsdFtpaV0gPSBhYnZbaV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5idWZmZXI7XG59O1xuIiwiLypcbiAqIGJhc2U2NC1hcnJheWJ1ZmZlclxuICogaHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlclxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBOaWtsYXMgdm9uIEhlcnR6ZW5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuKGZ1bmN0aW9uKGNoYXJzKXtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbihhcnJheWJ1ZmZlcikge1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSxcbiAgICBpLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9IFwiXCI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz0zKSB7XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaV0gPj4gMl07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpXSAmIDMpIDw8IDQpIHwgKGJ5dGVzW2kgKyAxXSA+PiA0KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpICsgMV0gJiAxNSkgPDwgMikgfCAoYnl0ZXNbaSArIDJdID4+IDYpXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG4gICAgfVxuXG4gICAgaWYgKChsZW4gJSAzKSA9PT0gMikge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyBcIj1cIjtcbiAgICB9IGVsc2UgaWYgKGxlbiAlIDMgPT09IDEpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgXCI9PVwiO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlNjQ7XG4gIH07XG5cbiAgZXhwb3J0cy5kZWNvZGUgPSAgZnVuY3Rpb24oYmFzZTY0KSB7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJhc2U2NC5sZW5ndGggKiAwLjc1LFxuICAgIGxlbiA9IGJhc2U2NC5sZW5ndGgsIGksIHAgPSAwLFxuICAgIGVuY29kZWQxLCBlbmNvZGVkMiwgZW5jb2RlZDMsIGVuY29kZWQ0O1xuXG4gICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMV0gPT09IFwiPVwiKSB7XG4gICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDJdID09PSBcIj1cIikge1xuICAgICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXJyYXlidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyTGVuZ3RoKSxcbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgIGVuY29kZWQxID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaV0pO1xuICAgICAgZW5jb2RlZDIgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpKzFdKTtcbiAgICAgIGVuY29kZWQzID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaSsyXSk7XG4gICAgICBlbmNvZGVkNCA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2krM10pO1xuXG4gICAgICBieXRlc1twKytdID0gKGVuY29kZWQxIDw8IDIpIHwgKGVuY29kZWQyID4+IDQpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDIgJiAxNSkgPDwgNCkgfCAoZW5jb2RlZDMgPj4gMik7XG4gICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMyAmIDMpIDw8IDYpIHwgKGVuY29kZWQ0ICYgNjMpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheWJ1ZmZlcjtcbiAgfTtcbn0pKFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiKTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0O1xuXG4vKipcbiAqIFRyYW5zcG9ydCBhYnN0cmFjdCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFRyYW5zcG9ydCAob3B0cykge1xuICB0aGlzLnBhdGggPSBvcHRzLnBhdGg7XG4gIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lO1xuICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQ7XG4gIHRoaXMuc2VjdXJlID0gb3B0cy5zZWN1cmU7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbTtcbiAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcbiAgdGhpcy5zb2NrZXQgPSBvcHRzLnNvY2tldDtcbiAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuICB0aGlzLndpdGhDcmVkZW50aWFscyA9IG9wdHMud2l0aENyZWRlbnRpYWxzO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgdGhpcy5mb3JjZU5vZGUgPSBvcHRzLmZvcmNlTm9kZTtcblxuICAvLyByZXN1bHRzIG9mIFJlYWN0TmF0aXZlIGVudmlyb25tZW50IGRldGVjdGlvblxuICB0aGlzLmlzUmVhY3ROYXRpdmUgPSBvcHRzLmlzUmVhY3ROYXRpdmU7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcbiAgdGhpcy5sb2NhbEFkZHJlc3MgPSBvcHRzLmxvY2FsQWRkcmVzcztcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoVHJhbnNwb3J0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogRW1pdHMgYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7VHJhbnNwb3J0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKG1zZywgZGVzYykge1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci50eXBlID0gJ1RyYW5zcG9ydEVycm9yJztcbiAgZXJyLmRlc2NyaXB0aW9uID0gZGVzYztcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPcGVucyB0aGUgdHJhbnNwb3J0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICAgIHRoaXMuZG9PcGVuKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5kb0Nsb3NlKCk7XG4gICAgdGhpcy5vbkNsb3NlKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgbXVsdGlwbGUgcGFja2V0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAocGFja2V0cykge1xuICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLndyaXRlKHBhY2tldHMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IG5vdCBvcGVuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gb3BlblxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgcGFja2V0ID0gcGFyc2VyLmRlY29kZVBhY2tldChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlKTtcbiAgdGhpcy5vblBhY2tldChwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBhIGRlY29kZWQgcGFja2V0LlxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25QYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy5lbWl0KCdjbG9zZScpO1xufTtcbiIsIi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJyMwMDAwQ0MnLCAnIzAwMDBGRicsICcjMDAzM0NDJywgJyMwMDMzRkYnLCAnIzAwNjZDQycsICcjMDA2NkZGJywgJyMwMDk5Q0MnLFxuICAnIzAwOTlGRicsICcjMDBDQzAwJywgJyMwMENDMzMnLCAnIzAwQ0M2NicsICcjMDBDQzk5JywgJyMwMENDQ0MnLCAnIzAwQ0NGRicsXG4gICcjMzMwMENDJywgJyMzMzAwRkYnLCAnIzMzMzNDQycsICcjMzMzM0ZGJywgJyMzMzY2Q0MnLCAnIzMzNjZGRicsICcjMzM5OUNDJyxcbiAgJyMzMzk5RkYnLCAnIzMzQ0MwMCcsICcjMzNDQzMzJywgJyMzM0NDNjYnLCAnIzMzQ0M5OScsICcjMzNDQ0NDJywgJyMzM0NDRkYnLFxuICAnIzY2MDBDQycsICcjNjYwMEZGJywgJyM2NjMzQ0MnLCAnIzY2MzNGRicsICcjNjZDQzAwJywgJyM2NkNDMzMnLCAnIzk5MDBDQycsXG4gICcjOTkwMEZGJywgJyM5OTMzQ0MnLCAnIzk5MzNGRicsICcjOTlDQzAwJywgJyM5OUNDMzMnLCAnI0NDMDAwMCcsICcjQ0MwMDMzJyxcbiAgJyNDQzAwNjYnLCAnI0NDMDA5OScsICcjQ0MwMENDJywgJyNDQzAwRkYnLCAnI0NDMzMwMCcsICcjQ0MzMzMzJywgJyNDQzMzNjYnLFxuICAnI0NDMzM5OScsICcjQ0MzM0NDJywgJyNDQzMzRkYnLCAnI0NDNjYwMCcsICcjQ0M2NjMzJywgJyNDQzk5MDAnLCAnI0NDOTkzMycsXG4gICcjQ0NDQzAwJywgJyNDQ0NDMzMnLCAnI0ZGMDAwMCcsICcjRkYwMDMzJywgJyNGRjAwNjYnLCAnI0ZGMDA5OScsICcjRkYwMENDJyxcbiAgJyNGRjAwRkYnLCAnI0ZGMzMwMCcsICcjRkYzMzMzJywgJyNGRjMzNjYnLCAnI0ZGMzM5OScsICcjRkYzM0NDJywgJyNGRjMzRkYnLFxuICAnI0ZGNjYwMCcsICcjRkY2NjMzJywgJyNGRjk5MDAnLCAnI0ZGOTkzMycsICcjRkZDQzAwJywgJyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG4gIHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuICAgIC8vIGRvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnIubWVzc2FnZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm47XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKVxuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cblxuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG4gIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfVxuXG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbnZhciBYSFIgPSByZXF1aXJlKCcuL3BvbGxpbmcteGhyJyk7XG52YXIgSlNPTlAgPSByZXF1aXJlKCcuL3BvbGxpbmctanNvbnAnKTtcbnZhciB3ZWJzb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydCB0cmFuc3BvcnRzLlxuICovXG5cbmV4cG9ydHMucG9sbGluZyA9IHBvbGxpbmc7XG5leHBvcnRzLndlYnNvY2tldCA9IHdlYnNvY2tldDtcblxuLyoqXG4gKiBQb2xsaW5nIHRyYW5zcG9ydCBwb2x5bW9ycGhpYyBjb25zdHJ1Y3Rvci5cbiAqIERlY2lkZXMgb24geGhyIHZzIGpzb25wIGJhc2VkIG9uIGZlYXR1cmUgZGV0ZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBvbGxpbmcgKG9wdHMpIHtcbiAgdmFyIHhocjtcbiAgdmFyIHhkID0gZmFsc2U7XG4gIHZhciB4cyA9IGZhbHNlO1xuICB2YXIganNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcblxuICBpZiAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cbiAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICB4ZCA9IG9wdHMuaG9zdG5hbWUgIT09IGxvY2F0aW9uLmhvc3RuYW1lIHx8IHBvcnQgIT09IG9wdHMucG9ydDtcbiAgICB4cyA9IG9wdHMuc2VjdXJlICE9PSBpc1NTTDtcbiAgfVxuXG4gIG9wdHMueGRvbWFpbiA9IHhkO1xuICBvcHRzLnhzY2hlbWUgPSB4cztcbiAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO1xuXG4gIGlmICgnb3BlbicgaW4geGhyICYmICFvcHRzLmZvcmNlSlNPTlApIHtcbiAgICByZXR1cm4gbmV3IFhIUihvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWpzb25wKSB0aHJvdyBuZXcgRXJyb3IoJ0pTT05QIGRpc2FibGVkJyk7XG4gICAgcmV0dXJuIG5ldyBKU09OUChvcHRzKTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IGBcbm1lc3NhZ2UgUlBDIHtcbiAgcmVwZWF0ZWQgU3ViT3B0cyBzdWJzY3JpcHRpb25zID0gMTtcbiAgcmVwZWF0ZWQgTWVzc2FnZSBtc2dzID0gMjtcblxuICBtZXNzYWdlIFN1Yk9wdHMge1xuICAgIG9wdGlvbmFsIGJvb2wgc3Vic2NyaWJlID0gMTsgLy8gc3Vic2NyaWJlIG9yIHVuc3ViY3JpYmVcbiAgICBvcHRpb25hbCBzdHJpbmcgdG9waWNJRCA9IDI7XG4gIH1cblxuICBtZXNzYWdlIE1lc3NhZ2Uge1xuICAgIG9wdGlvbmFsIGJ5dGVzIGZyb20gPSAxO1xuICAgIG9wdGlvbmFsIGJ5dGVzIGRhdGEgPSAyO1xuICAgIG9wdGlvbmFsIGJ5dGVzIHNlcW5vID0gMztcbiAgICByZXBlYXRlZCBzdHJpbmcgdG9waWNJRHMgPSA0O1xuICAgIG9wdGlvbmFsIGJ5dGVzIHNpZ25hdHVyZSA9IDU7XG4gICAgb3B0aW9uYWwgYnl0ZXMga2V5ID0gNjtcbiAgfVxufWBcbiIsIid1c2Ugc3RyaWN0J1xubW9kdWxlLmV4cG9ydHMgPSBgXG4vLyB0b3BpY0NJRCA9IGNpZChtZXJrbGVkYWdfcHJvdG9idWYodG9waWNEZXNjcmlwdG9yKSk7IChub3QgdGhlIHRvcGljLm5hbWUpXG5tZXNzYWdlIFRvcGljRGVzY3JpcHRvciB7XG4gIG9wdGlvbmFsIHN0cmluZyBuYW1lID0gMTtcbiAgb3B0aW9uYWwgQXV0aE9wdHMgYXV0aCA9IDI7XG4gIG9wdGlvbmFsIEVuY09wdHMgZW5jID0gMjtcblxuICBtZXNzYWdlIEF1dGhPcHRzIHtcbiAgICBvcHRpb25hbCBBdXRoTW9kZSBtb2RlID0gMTtcbiAgICByZXBlYXRlZCBieXRlcyBrZXlzID0gMjsgLy8gcm9vdCBrZXlzIHRvIHRydXN0XG5cbiAgICBlbnVtIEF1dGhNb2RlIHtcbiAgICAgIE5PTkUgPSAwOyAvLyBubyBhdXRoZW50aWNhdGlvbiwgYW55b25lIGNhbiBwdWJsaXNoXG4gICAgICBLRVkgPSAxOyAvLyBvbmx5IG1lc3NhZ2VzIHNpZ25lZCBieSBrZXlzIGluIHRoZSB0b3BpYyBkZXNjcmlwdG9yIGFyZSBhY2NlcHRlZFxuICAgICAgV09UID0gMjsgLy8gd2ViIG9mIHRydXN0LCBjZXJ0aWZpY2F0ZXMgY2FuIGFsbG93IHB1Ymxpc2hlciBzZXQgdG8gZ3Jvd1xuICAgIH1cbiAgfVxuXG4gIG1lc3NhZ2UgRW5jT3B0cyB7XG4gICAgb3B0aW9uYWwgRW5jTW9kZSBtb2RlID0gMTtcbiAgICByZXBlYXRlZCBieXRlcyBrZXlIYXNoZXMgPSAyOyAvLyB0aGUgaGFzaGVzIG9mIHRoZSBzaGFyZWQga2V5cyB1c2VkIChzYWx0ZWQpXG5cbiAgICBlbnVtIEVuY01vZGUge1xuICAgICAgTk9ORSA9IDA7IC8vIG5vIGVuY3J5cHRpb24sIGFueW9uZSBjYW4gcmVhZFxuICAgICAgU0hBUkVES0VZID0gMTsgLy8gbWVzc2FnZXMgYXJlIGVuY3J5cHRlZCB3aXRoIHNoYXJlZCBrZXlcbiAgICAgIFdPVCA9IDI7IC8vIHdlYiBvZiB0cnVzdCwgY2VydGlmaWNhdGVzIGNhbiBhbGxvdyBwdWJsaXNoZXIgc2V0IHRvIGdyb3dcbiAgICB9XG4gIH1cbn1gXG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4ocmVzdWx0LCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG4gKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0b1xuICogaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgXG4gKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgXG4gKiB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlXG4gKiB0aHJvdHRsZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiByZXR1cm4gdGhlXG4gKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBpbnZvY2F0aW9ucyB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGV4Y2Vzc2l2ZWx5IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBzY3JvbGxpbmcuXG4gKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKSk7XG4gKlxuICogLy8gSW52b2tlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXMuXG4gKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHsgJ3RyYWlsaW5nJzogZmFsc2UgfSk7XG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdGhyb3R0bGVkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIHRocm90dGxlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG4gIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7XG4gICAgJ2xlYWRpbmcnOiBsZWFkaW5nLFxuICAgICdtYXhXYWl0Jzogd2FpdCxcbiAgICAndHJhaWxpbmcnOiB0cmFpbGluZ1xuICB9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGhyb3R0bGU7XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Z1snZGVmYXVsdCddID0gY3JlYXRlRGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICB2YXIgaGFzaCA9IDAsIGk7XG5cbiAgZm9yIChpIGluIG5hbWVzcGFjZSkge1xuICAgIGhhc2ggID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cbiAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmluaXQpIHtcbiAgICBleHBvcnRzLmluaXQoZGVidWcpO1xuICB9XG5cbiAgcmV0dXJuIGRlYnVnO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0VGltZSAoKSB7XG4gIHJldHVybiBEYXRlLm5vdygpXG59XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBTZW1WZXJcblxudmFyIGRlYnVnXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICAgIHByb2Nlc3MuZW52ICYmXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyAmJlxuICAgIC9cXGJzZW12ZXJcXGIvaS50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcpKSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKVxuICAgIGFyZ3MudW5zaGlmdCgnU0VNVkVSJylcbiAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKVxuICB9XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9XG59XG5cbi8vIE5vdGU6IHRoaXMgaXMgdGhlIHNlbXZlci5vcmcgdmVyc2lvbiBvZiB0aGUgc3BlYyB0aGF0IGl0IGltcGxlbWVudHNcbi8vIE5vdCBuZWNlc3NhcmlseSB0aGUgcGFja2FnZSB2ZXJzaW9uIG9mIHRoaXMgY29kZS5cbmV4cG9ydHMuU0VNVkVSX1NQRUNfVkVSU0lPTiA9ICcyLjAuMCdcblxudmFyIE1BWF9MRU5HVEggPSAyNTZcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHxcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gOTAwNzE5OTI1NDc0MDk5MVxuXG4vLyBNYXggc2FmZSBzZWdtZW50IGxlbmd0aCBmb3IgY29lcmNpb24uXG52YXIgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCA9IDE2XG5cbi8vIFRoZSBhY3R1YWwgcmVnZXhwcyBnbyBvbiBleHBvcnRzLnJlXG52YXIgcmUgPSBleHBvcnRzLnJlID0gW11cbnZhciBzcmMgPSBleHBvcnRzLnNyYyA9IFtdXG52YXIgdCA9IGV4cG9ydHMudG9rZW5zID0ge31cbnZhciBSID0gMFxuXG5mdW5jdGlvbiB0b2sgKG4pIHtcbiAgdFtuXSA9IFIrK1xufVxuXG4vLyBUaGUgZm9sbG93aW5nIFJlZ3VsYXIgRXhwcmVzc2lvbnMgY2FuIGJlIHVzZWQgZm9yIHRva2VuaXppbmcsXG4vLyB2YWxpZGF0aW5nLCBhbmQgcGFyc2luZyBTZW1WZXIgdmVyc2lvbiBzdHJpbmdzLlxuXG4vLyAjIyBOdW1lcmljIElkZW50aWZpZXJcbi8vIEEgc2luZ2xlIGAwYCwgb3IgYSBub24temVybyBkaWdpdCBmb2xsb3dlZCBieSB6ZXJvIG9yIG1vcmUgZGlnaXRzLlxuXG50b2soJ05VTUVSSUNJREVOVElGSUVSJylcbnNyY1t0Lk5VTUVSSUNJREVOVElGSUVSXSA9ICcwfFsxLTldXFxcXGQqJ1xudG9rKCdOVU1FUklDSURFTlRJRklFUkxPT1NFJylcbnNyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdID0gJ1swLTldKydcblxuLy8gIyMgTm9uLW51bWVyaWMgSWRlbnRpZmllclxuLy8gWmVybyBvciBtb3JlIGRpZ2l0cywgZm9sbG93ZWQgYnkgYSBsZXR0ZXIgb3IgaHlwaGVuLCBhbmQgdGhlbiB6ZXJvIG9yXG4vLyBtb3JlIGxldHRlcnMsIGRpZ2l0cywgb3IgaHlwaGVucy5cblxudG9rKCdOT05OVU1FUklDSURFTlRJRklFUicpXG5zcmNbdC5OT05OVU1FUklDSURFTlRJRklFUl0gPSAnXFxcXGQqW2EtekEtWi1dW2EtekEtWjAtOS1dKidcblxuLy8gIyMgTWFpbiBWZXJzaW9uXG4vLyBUaHJlZSBkb3Qtc2VwYXJhdGVkIG51bWVyaWMgaWRlbnRpZmllcnMuXG5cbnRvaygnTUFJTlZFUlNJT04nKVxuc3JjW3QuTUFJTlZFUlNJT05dID0gJygnICsgc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdICsgJylcXFxcLicgK1xuICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1t0Lk5VTUVSSUNJREVOVElGSUVSXSArICcpXFxcXC4nICtcbiAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbdC5OVU1FUklDSURFTlRJRklFUl0gKyAnKSdcblxudG9rKCdNQUlOVkVSU0lPTkxPT1NFJylcbnNyY1t0Lk1BSU5WRVJTSU9OTE9PU0VdID0gJygnICsgc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnKVxcXFwuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXSArICcpXFxcXC4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdICsgJyknXG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb24gSWRlbnRpZmllclxuLy8gQSBudW1lcmljIGlkZW50aWZpZXIsIG9yIGEgbm9uLW51bWVyaWMgaWRlbnRpZmllci5cblxudG9rKCdQUkVSRUxFQVNFSURFTlRJRklFUicpXG5zcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUl0gPSAnKD86JyArIHNyY1t0Lk5VTUVSSUNJREVOVElGSUVSXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3wnICsgc3JjW3QuTk9OTlVNRVJJQ0lERU5USUZJRVJdICsgJyknXG5cbnRvaygnUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRScpXG5zcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXSA9ICcoPzonICsgc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3wnICsgc3JjW3QuTk9OTlVNRVJJQ0lERU5USUZJRVJdICsgJyknXG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb25cbi8vIEh5cGhlbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgZG90LXNlcGFyYXRlZCBwcmUtcmVsZWFzZSB2ZXJzaW9uXG4vLyBpZGVudGlmaWVycy5cblxudG9rKCdQUkVSRUxFQVNFJylcbnNyY1t0LlBSRVJFTEVBU0VdID0gJyg/Oi0oJyArIHNyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSXSArXG4gICAgICAgICAgICAgICAgICAnKD86XFxcXC4nICsgc3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJdICsgJykqKSknXG5cbnRvaygnUFJFUkVMRUFTRUxPT1NFJylcbnNyY1t0LlBSRVJFTEVBU0VMT09TRV0gPSAnKD86LT8oJyArIHNyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdICtcbiAgICAgICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuJyArIHNyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdICsgJykqKSknXG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhIElkZW50aWZpZXJcbi8vIEFueSBjb21iaW5hdGlvbiBvZiBkaWdpdHMsIGxldHRlcnMsIG9yIGh5cGhlbnMuXG5cbnRvaygnQlVJTERJREVOVElGSUVSJylcbnNyY1t0LkJVSUxESURFTlRJRklFUl0gPSAnWzAtOUEtWmEtei1dKydcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGFcbi8vIFBsdXMgc2lnbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgcGVyaW9kLXNlcGFyYXRlZCBidWlsZCBtZXRhZGF0YVxuLy8gaWRlbnRpZmllcnMuXG5cbnRvaygnQlVJTEQnKVxuc3JjW3QuQlVJTERdID0gJyg/OlxcXFwrKCcgKyBzcmNbdC5CVUlMRElERU5USUZJRVJdICtcbiAgICAgICAgICAgICAnKD86XFxcXC4nICsgc3JjW3QuQlVJTERJREVOVElGSUVSXSArICcpKikpJ1xuXG4vLyAjIyBGdWxsIFZlcnNpb24gU3RyaW5nXG4vLyBBIG1haW4gdmVyc2lvbiwgZm9sbG93ZWQgb3B0aW9uYWxseSBieSBhIHByZS1yZWxlYXNlIHZlcnNpb24gYW5kXG4vLyBidWlsZCBtZXRhZGF0YS5cblxuLy8gTm90ZSB0aGF0IHRoZSBvbmx5IG1ham9yLCBtaW5vciwgcGF0Y2gsIGFuZCBwcmUtcmVsZWFzZSBzZWN0aW9ucyBvZlxuLy8gdGhlIHZlcnNpb24gc3RyaW5nIGFyZSBjYXB0dXJpbmcgZ3JvdXBzLiAgVGhlIGJ1aWxkIG1ldGFkYXRhIGlzIG5vdCBhXG4vLyBjYXB0dXJpbmcgZ3JvdXAsIGJlY2F1c2UgaXQgc2hvdWxkIG5vdCBldmVyIGJlIHVzZWQgaW4gdmVyc2lvblxuLy8gY29tcGFyaXNvbi5cblxudG9rKCdGVUxMJylcbnRvaygnRlVMTFBMQUlOJylcbnNyY1t0LkZVTExQTEFJTl0gPSAndj8nICsgc3JjW3QuTUFJTlZFUlNJT05dICtcbiAgICAgICAgICAgICAgICAgIHNyY1t0LlBSRVJFTEVBU0VdICsgJz8nICtcbiAgICAgICAgICAgICAgICAgIHNyY1t0LkJVSUxEXSArICc/J1xuXG5zcmNbdC5GVUxMXSA9ICdeJyArIHNyY1t0LkZVTExQTEFJTl0gKyAnJCdcblxuLy8gbGlrZSBmdWxsLCBidXQgYWxsb3dzIHYxLjIuMyBhbmQgPTEuMi4zLCB3aGljaCBwZW9wbGUgZG8gc29tZXRpbWVzLlxuLy8gYWxzbywgMS4wLjBhbHBoYTEgKHByZXJlbGVhc2Ugd2l0aG91dCB0aGUgaHlwaGVuKSB3aGljaCBpcyBwcmV0dHlcbi8vIGNvbW1vbiBpbiB0aGUgbnBtIHJlZ2lzdHJ5LlxudG9rKCdMT09TRVBMQUlOJylcbnNyY1t0LkxPT1NFUExBSU5dID0gJ1t2PVxcXFxzXSonICsgc3JjW3QuTUFJTlZFUlNJT05MT09TRV0gK1xuICAgICAgICAgICAgICAgICAgc3JjW3QuUFJFUkVMRUFTRUxPT1NFXSArICc/JyArXG4gICAgICAgICAgICAgICAgICBzcmNbdC5CVUlMRF0gKyAnPydcblxudG9rKCdMT09TRScpXG5zcmNbdC5MT09TRV0gPSAnXicgKyBzcmNbdC5MT09TRVBMQUlOXSArICckJ1xuXG50b2soJ0dUTFQnKVxuc3JjW3QuR1RMVF0gPSAnKCg/Ojx8Pik/PT8pJ1xuXG4vLyBTb21ldGhpbmcgbGlrZSBcIjIuKlwiIG9yIFwiMS4yLnhcIi5cbi8vIE5vdGUgdGhhdCBcIngueFwiIGlzIGEgdmFsaWQgeFJhbmdlIGlkZW50aWZlciwgbWVhbmluZyBcImFueSB2ZXJzaW9uXCJcbi8vIE9ubHkgdGhlIGZpcnN0IGl0ZW0gaXMgc3RyaWN0bHkgcmVxdWlyZWQuXG50b2soJ1hSQU5HRUlERU5USUZJRVJMT09TRScpXG5zcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdID0gc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnfHh8WHxcXFxcKidcbnRvaygnWFJBTkdFSURFTlRJRklFUicpXG5zcmNbdC5YUkFOR0VJREVOVElGSUVSXSA9IHNyY1t0Lk5VTUVSSUNJREVOVElGSUVSXSArICd8eHxYfFxcXFwqJ1xuXG50b2soJ1hSQU5HRVBMQUlOJylcbnNyY1t0LlhSQU5HRVBMQUlOXSA9ICdbdj1cXFxcc10qKCcgKyBzcmNbdC5YUkFOR0VJREVOVElGSUVSXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuKCcgKyBzcmNbdC5YUkFOR0VJREVOVElGSUVSXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuKCcgKyBzcmNbdC5YUkFOR0VJREVOVElGSUVSXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgJyg/OicgKyBzcmNbdC5QUkVSRUxFQVNFXSArICcpPycgK1xuICAgICAgICAgICAgICAgICAgIHNyY1t0LkJVSUxEXSArICc/JyArXG4gICAgICAgICAgICAgICAgICAgJyk/KT8nXG5cbnRvaygnWFJBTkdFUExBSU5MT09TRScpXG5zcmNbdC5YUkFOR0VQTEFJTkxPT1NFXSA9ICdbdj1cXFxcc10qKCcgKyBzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLignICsgc3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4oJyArIHNyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyg/OicgKyBzcmNbdC5QUkVSRUxFQVNFTE9PU0VdICsgJyk/JyArXG4gICAgICAgICAgICAgICAgICAgICAgICBzcmNbdC5CVUlMRF0gKyAnPycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyk/KT8nXG5cbnRvaygnWFJBTkdFJylcbnNyY1t0LlhSQU5HRV0gPSAnXicgKyBzcmNbdC5HVExUXSArICdcXFxccyonICsgc3JjW3QuWFJBTkdFUExBSU5dICsgJyQnXG50b2soJ1hSQU5HRUxPT1NFJylcbnNyY1t0LlhSQU5HRUxPT1NFXSA9ICdeJyArIHNyY1t0LkdUTFRdICsgJ1xcXFxzKicgKyBzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXSArICckJ1xuXG4vLyBDb2VyY2lvbi5cbi8vIEV4dHJhY3QgYW55dGhpbmcgdGhhdCBjb3VsZCBjb25jZWl2YWJseSBiZSBhIHBhcnQgb2YgYSB2YWxpZCBzZW12ZXJcbnRvaygnQ09FUkNFJylcbnNyY1t0LkNPRVJDRV0gPSAnKF58W15cXFxcZF0pJyArXG4gICAgICAgICAgICAgICcoXFxcXGR7MSwnICsgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCArICd9KScgK1xuICAgICAgICAgICAgICAnKD86XFxcXC4oXFxcXGR7MSwnICsgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCArICd9KSk/JyArXG4gICAgICAgICAgICAgICcoPzpcXFxcLihcXFxcZHsxLCcgKyBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIICsgJ30pKT8nICtcbiAgICAgICAgICAgICAgJyg/OiR8W15cXFxcZF0pJ1xudG9rKCdDT0VSQ0VSVEwnKVxucmVbdC5DT0VSQ0VSVExdID0gbmV3IFJlZ0V4cChzcmNbdC5DT0VSQ0VdLCAnZycpXG5cbi8vIFRpbGRlIHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJyZWFzb25hYmx5IGF0IG9yIGdyZWF0ZXIgdGhhblwiXG50b2soJ0xPTkVUSUxERScpXG5zcmNbdC5MT05FVElMREVdID0gJyg/On4+PyknXG5cbnRvaygnVElMREVUUklNJylcbnNyY1t0LlRJTERFVFJJTV0gPSAnKFxcXFxzKiknICsgc3JjW3QuTE9ORVRJTERFXSArICdcXFxccysnXG5yZVt0LlRJTERFVFJJTV0gPSBuZXcgUmVnRXhwKHNyY1t0LlRJTERFVFJJTV0sICdnJylcbnZhciB0aWxkZVRyaW1SZXBsYWNlID0gJyQxfidcblxudG9rKCdUSUxERScpXG5zcmNbdC5USUxERV0gPSAnXicgKyBzcmNbdC5MT05FVElMREVdICsgc3JjW3QuWFJBTkdFUExBSU5dICsgJyQnXG50b2soJ1RJTERFTE9PU0UnKVxuc3JjW3QuVElMREVMT09TRV0gPSAnXicgKyBzcmNbdC5MT05FVElMREVdICsgc3JjW3QuWFJBTkdFUExBSU5MT09TRV0gKyAnJCdcblxuLy8gQ2FyZXQgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcImF0IGxlYXN0IGFuZCBiYWNrd2FyZHMgY29tcGF0aWJsZSB3aXRoXCJcbnRvaygnTE9ORUNBUkVUJylcbnNyY1t0LkxPTkVDQVJFVF0gPSAnKD86XFxcXF4pJ1xuXG50b2soJ0NBUkVUVFJJTScpXG5zcmNbdC5DQVJFVFRSSU1dID0gJyhcXFxccyopJyArIHNyY1t0LkxPTkVDQVJFVF0gKyAnXFxcXHMrJ1xucmVbdC5DQVJFVFRSSU1dID0gbmV3IFJlZ0V4cChzcmNbdC5DQVJFVFRSSU1dLCAnZycpXG52YXIgY2FyZXRUcmltUmVwbGFjZSA9ICckMV4nXG5cbnRvaygnQ0FSRVQnKVxuc3JjW3QuQ0FSRVRdID0gJ14nICsgc3JjW3QuTE9ORUNBUkVUXSArIHNyY1t0LlhSQU5HRVBMQUlOXSArICckJ1xudG9rKCdDQVJFVExPT1NFJylcbnNyY1t0LkNBUkVUTE9PU0VdID0gJ14nICsgc3JjW3QuTE9ORUNBUkVUXSArIHNyY1t0LlhSQU5HRVBMQUlOTE9PU0VdICsgJyQnXG5cbi8vIEEgc2ltcGxlIGd0L2x0L2VxIHRoaW5nLCBvciBqdXN0IFwiXCIgdG8gaW5kaWNhdGUgXCJhbnkgdmVyc2lvblwiXG50b2soJ0NPTVBBUkFUT1JMT09TRScpXG5zcmNbdC5DT01QQVJBVE9STE9PU0VdID0gJ14nICsgc3JjW3QuR1RMVF0gKyAnXFxcXHMqKCcgKyBzcmNbdC5MT09TRVBMQUlOXSArICcpJHxeJCdcbnRvaygnQ09NUEFSQVRPUicpXG5zcmNbdC5DT01QQVJBVE9SXSA9ICdeJyArIHNyY1t0LkdUTFRdICsgJ1xcXFxzKignICsgc3JjW3QuRlVMTFBMQUlOXSArICcpJHxeJCdcblxuLy8gQW4gZXhwcmVzc2lvbiB0byBzdHJpcCBhbnkgd2hpdGVzcGFjZSBiZXR3ZWVuIHRoZSBndGx0IGFuZCB0aGUgdGhpbmdcbi8vIGl0IG1vZGlmaWVzLCBzbyB0aGF0IGA+IDEuMi4zYCA9PT4gYD4xLjIuM2BcbnRvaygnQ09NUEFSQVRPUlRSSU0nKVxuc3JjW3QuQ09NUEFSQVRPUlRSSU1dID0gJyhcXFxccyopJyArIHNyY1t0LkdUTFRdICtcbiAgICAgICAgICAgICAgICAgICAgICAnXFxcXHMqKCcgKyBzcmNbdC5MT09TRVBMQUlOXSArICd8JyArIHNyY1t0LlhSQU5HRVBMQUlOXSArICcpJ1xuXG4vLyB0aGlzIG9uZSBoYXMgdG8gdXNlIHRoZSAvZyBmbGFnXG5yZVt0LkNPTVBBUkFUT1JUUklNXSA9IG5ldyBSZWdFeHAoc3JjW3QuQ09NUEFSQVRPUlRSSU1dLCAnZycpXG52YXIgY29tcGFyYXRvclRyaW1SZXBsYWNlID0gJyQxJDIkMydcblxuLy8gU29tZXRoaW5nIGxpa2UgYDEuMi4zIC0gMS4yLjRgXG4vLyBOb3RlIHRoYXQgdGhlc2UgYWxsIHVzZSB0aGUgbG9vc2UgZm9ybSwgYmVjYXVzZSB0aGV5J2xsIGJlXG4vLyBjaGVja2VkIGFnYWluc3QgZWl0aGVyIHRoZSBzdHJpY3Qgb3IgbG9vc2UgY29tcGFyYXRvciBmb3JtXG4vLyBsYXRlci5cbnRvaygnSFlQSEVOUkFOR0UnKVxuc3JjW3QuSFlQSEVOUkFOR0VdID0gJ15cXFxccyooJyArIHNyY1t0LlhSQU5HRVBMQUlOXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgJ1xcXFxzKy1cXFxccysnICtcbiAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbdC5YUkFOR0VQTEFJTl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICdcXFxccyokJ1xuXG50b2soJ0hZUEhFTlJBTkdFTE9PU0UnKVxuc3JjW3QuSFlQSEVOUkFOR0VMT09TRV0gPSAnXlxcXFxzKignICsgc3JjW3QuWFJBTkdFUExBSU5MT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcXFxzKy1cXFxccysnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1t0LlhSQU5HRVBMQUlOTE9PU0VdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXFxccyokJ1xuXG4vLyBTdGFyIHJhbmdlcyBiYXNpY2FsbHkganVzdCBhbGxvdyBhbnl0aGluZyBhdCBhbGwuXG50b2soJ1NUQVInKVxuc3JjW3QuU1RBUl0gPSAnKDx8Pik/PT9cXFxccypcXFxcKidcblxuLy8gQ29tcGlsZSB0byBhY3R1YWwgcmVnZXhwIG9iamVjdHMuXG4vLyBBbGwgYXJlIGZsYWctZnJlZSwgdW5sZXNzIHRoZXkgd2VyZSBjcmVhdGVkIGFib3ZlIHdpdGggYSBmbGFnLlxuZm9yICh2YXIgaSA9IDA7IGkgPCBSOyBpKyspIHtcbiAgZGVidWcoaSwgc3JjW2ldKVxuICBpZiAoIXJlW2ldKSB7XG4gICAgcmVbaV0gPSBuZXcgUmVnRXhwKHNyY1tpXSlcbiAgfVxufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VcbmZ1bmN0aW9uIHBhcnNlICh2ZXJzaW9uLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgbG9vc2U6ICEhb3B0aW9ucyxcbiAgICAgIGluY2x1ZGVQcmVyZWxlYXNlOiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgcmV0dXJuIHZlcnNpb25cbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgaWYgKHZlcnNpb24ubGVuZ3RoID4gTUFYX0xFTkdUSCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICB2YXIgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LkxPT1NFXSA6IHJlW3QuRlVMTF1cbiAgaWYgKCFyLnRlc3QodmVyc2lvbikpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuZXhwb3J0cy52YWxpZCA9IHZhbGlkXG5mdW5jdGlvbiB2YWxpZCAodmVyc2lvbiwgb3B0aW9ucykge1xuICB2YXIgdiA9IHBhcnNlKHZlcnNpb24sIG9wdGlvbnMpXG4gIHJldHVybiB2ID8gdi52ZXJzaW9uIDogbnVsbFxufVxuXG5leHBvcnRzLmNsZWFuID0gY2xlYW5cbmZ1bmN0aW9uIGNsZWFuICh2ZXJzaW9uLCBvcHRpb25zKSB7XG4gIHZhciBzID0gcGFyc2UodmVyc2lvbi50cmltKCkucmVwbGFjZSgvXls9dl0rLywgJycpLCBvcHRpb25zKVxuICByZXR1cm4gcyA/IHMudmVyc2lvbiA6IG51bGxcbn1cblxuZXhwb3J0cy5TZW1WZXIgPSBTZW1WZXJcblxuZnVuY3Rpb24gU2VtVmVyICh2ZXJzaW9uLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgbG9vc2U6ICEhb3B0aW9ucyxcbiAgICAgIGluY2x1ZGVQcmVyZWxlYXNlOiBmYWxzZVxuICAgIH1cbiAgfVxuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgIGlmICh2ZXJzaW9uLmxvb3NlID09PSBvcHRpb25zLmxvb3NlKSB7XG4gICAgICByZXR1cm4gdmVyc2lvblxuICAgIH0gZWxzZSB7XG4gICAgICB2ZXJzaW9uID0gdmVyc2lvbi52ZXJzaW9uXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgVmVyc2lvbjogJyArIHZlcnNpb24pXG4gIH1cblxuICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmVyc2lvbiBpcyBsb25nZXIgdGhhbiAnICsgTUFYX0xFTkdUSCArICcgY2hhcmFjdGVycycpXG4gIH1cblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpXG4gIH1cblxuICBkZWJ1ZygnU2VtVmVyJywgdmVyc2lvbiwgb3B0aW9ucylcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG5cbiAgdmFyIG0gPSB2ZXJzaW9uLnRyaW0oKS5tYXRjaChvcHRpb25zLmxvb3NlID8gcmVbdC5MT09TRV0gOiByZVt0LkZVTExdKVxuXG4gIGlmICghbSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgVmVyc2lvbjogJyArIHZlcnNpb24pXG4gIH1cblxuICB0aGlzLnJhdyA9IHZlcnNpb25cblxuICAvLyB0aGVzZSBhcmUgYWN0dWFsbHkgbnVtYmVyc1xuICB0aGlzLm1ham9yID0gK21bMV1cbiAgdGhpcy5taW5vciA9ICttWzJdXG4gIHRoaXMucGF0Y2ggPSArbVszXVxuXG4gIGlmICh0aGlzLm1ham9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1ham9yIDwgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWFqb3IgdmVyc2lvbicpXG4gIH1cblxuICBpZiAodGhpcy5taW5vciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5taW5vciA8IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1pbm9yIHZlcnNpb24nKVxuICB9XG5cbiAgaWYgKHRoaXMucGF0Y2ggPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMucGF0Y2ggPCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwYXRjaCB2ZXJzaW9uJylcbiAgfVxuXG4gIC8vIG51bWJlcmlmeSBhbnkgcHJlcmVsZWFzZSBudW1lcmljIGlkc1xuICBpZiAoIW1bNF0pIHtcbiAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICB9IGVsc2Uge1xuICAgIHRoaXMucHJlcmVsZWFzZSA9IG1bNF0uc3BsaXQoJy4nKS5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgICBpZiAoL15bMC05XSskLy50ZXN0KGlkKSkge1xuICAgICAgICB2YXIgbnVtID0gK2lkXG4gICAgICAgIGlmIChudW0gPj0gMCAmJiBudW0gPCBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgcmV0dXJuIG51bVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaWRcbiAgICB9KVxuICB9XG5cbiAgdGhpcy5idWlsZCA9IG1bNV0gPyBtWzVdLnNwbGl0KCcuJykgOiBbXVxuICB0aGlzLmZvcm1hdCgpXG59XG5cblNlbVZlci5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnZlcnNpb24gPSB0aGlzLm1ham9yICsgJy4nICsgdGhpcy5taW5vciArICcuJyArIHRoaXMucGF0Y2hcbiAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICB0aGlzLnZlcnNpb24gKz0gJy0nICsgdGhpcy5wcmVyZWxlYXNlLmpvaW4oJy4nKVxuICB9XG4gIHJldHVybiB0aGlzLnZlcnNpb25cbn1cblxuU2VtVmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudmVyc2lvblxufVxuXG5TZW1WZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgZGVidWcoJ1NlbVZlci5jb21wYXJlJywgdGhpcy52ZXJzaW9uLCB0aGlzLm9wdGlvbnMsIG90aGVyKVxuICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiB0aGlzLmNvbXBhcmVNYWluKG90aGVyKSB8fCB0aGlzLmNvbXBhcmVQcmUob3RoZXIpXG59XG5cblNlbVZlci5wcm90b3R5cGUuY29tcGFyZU1haW4gPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKHRoaXMubWFqb3IsIG90aGVyLm1ham9yKSB8fFxuICAgICAgICAgY29tcGFyZUlkZW50aWZpZXJzKHRoaXMubWlub3IsIG90aGVyLm1pbm9yKSB8fFxuICAgICAgICAgY29tcGFyZUlkZW50aWZpZXJzKHRoaXMucGF0Y2gsIG90aGVyLnBhdGNoKVxufVxuXG5TZW1WZXIucHJvdG90eXBlLmNvbXBhcmVQcmUgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gIH1cblxuICAvLyBOT1QgaGF2aW5nIGEgcHJlcmVsZWFzZSBpcyA+IGhhdmluZyBvbmVcbiAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xXG4gIH0gZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICByZXR1cm4gMVxuICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgIHJldHVybiAwXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgZG8ge1xuICAgIHZhciBhID0gdGhpcy5wcmVyZWxlYXNlW2ldXG4gICAgdmFyIGIgPSBvdGhlci5wcmVyZWxlYXNlW2ldXG4gICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpXG4gICAgaWYgKGEgPT09IHVuZGVmaW5lZCAmJiBiID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAxXG4gICAgfSBlbHNlIGlmIChhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH0gZWxzZSBpZiAoYSA9PT0gYikge1xuICAgICAgY29udGludWVcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyhhLCBiKVxuICAgIH1cbiAgfSB3aGlsZSAoKytpKVxufVxuXG5TZW1WZXIucHJvdG90eXBlLmNvbXBhcmVCdWlsZCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgfVxuXG4gIHZhciBpID0gMFxuICBkbyB7XG4gICAgdmFyIGEgPSB0aGlzLmJ1aWxkW2ldXG4gICAgdmFyIGIgPSBvdGhlci5idWlsZFtpXVxuICAgIGRlYnVnKCdwcmVyZWxlYXNlIGNvbXBhcmUnLCBpLCBhLCBiKVxuICAgIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH0gZWxzZSBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9IGVsc2UgaWYgKGEgPT09IGIpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYilcbiAgICB9XG4gIH0gd2hpbGUgKCsraSlcbn1cblxuLy8gcHJlbWlub3Igd2lsbCBidW1wIHRoZSB2ZXJzaW9uIHVwIHRvIHRoZSBuZXh0IG1pbm9yIHJlbGVhc2UsIGFuZCBpbW1lZGlhdGVseVxuLy8gZG93biB0byBwcmUtcmVsZWFzZS4gcHJlbWFqb3IgYW5kIHByZXBhdGNoIHdvcmsgdGhlIHNhbWUgd2F5LlxuU2VtVmVyLnByb3RvdHlwZS5pbmMgPSBmdW5jdGlvbiAocmVsZWFzZSwgaWRlbnRpZmllcikge1xuICBzd2l0Y2ggKHJlbGVhc2UpIHtcbiAgICBjYXNlICdwcmVtYWpvcic6XG4gICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgIHRoaXMubWlub3IgPSAwXG4gICAgICB0aGlzLm1ham9yKytcbiAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdwcmVtaW5vcic6XG4gICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgIHRoaXMubWlub3IrK1xuICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3ByZXBhdGNoJzpcbiAgICAgIC8vIElmIHRoaXMgaXMgYWxyZWFkeSBhIHByZXJlbGVhc2UsIGl0IHdpbGwgYnVtcCB0byB0aGUgbmV4dCB2ZXJzaW9uXG4gICAgICAvLyBkcm9wIGFueSBwcmVyZWxlYXNlcyB0aGF0IG1pZ2h0IGFscmVhZHkgZXhpc3QsIHNpbmNlIHRoZXkgYXJlIG5vdFxuICAgICAgLy8gcmVsZXZhbnQgYXQgdGhpcyBwb2ludC5cbiAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyKVxuICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpXG4gICAgICBicmVha1xuICAgIC8vIElmIHRoZSBpbnB1dCBpcyBhIG5vbi1wcmVyZWxlYXNlIHZlcnNpb24sIHRoaXMgYWN0cyB0aGUgc2FtZSBhc1xuICAgIC8vIHByZXBhdGNoLlxuICAgIGNhc2UgJ3ByZXJlbGVhc2UnOlxuICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcilcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgJ21ham9yJzpcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmUtbWFqb3IgdmVyc2lvbiwgYnVtcCB1cCB0byB0aGUgc2FtZSBtYWpvciB2ZXJzaW9uLlxuICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtYWpvci5cbiAgICAgIC8vIDEuMC4wLTUgYnVtcHMgdG8gMS4wLjBcbiAgICAgIC8vIDEuMS4wIGJ1bXBzIHRvIDIuMC4wXG4gICAgICBpZiAodGhpcy5taW5vciAhPT0gMCB8fFxuICAgICAgICAgIHRoaXMucGF0Y2ggIT09IDAgfHxcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMubWFqb3IrK1xuICAgICAgfVxuICAgICAgdGhpcy5taW5vciA9IDBcbiAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdtaW5vcic6XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1pbm9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWlub3IgdmVyc2lvbi5cbiAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWlub3IuXG4gICAgICAvLyAxLjIuMC01IGJ1bXBzIHRvIDEuMi4wXG4gICAgICAvLyAxLjIuMSBidW1wcyB0byAxLjMuMFxuICAgICAgaWYgKHRoaXMucGF0Y2ggIT09IDAgfHwgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLm1pbm9yKytcbiAgICAgIH1cbiAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdwYXRjaCc6XG4gICAgICAvLyBJZiB0aGlzIGlzIG5vdCBhIHByZS1yZWxlYXNlIHZlcnNpb24sIGl0IHdpbGwgaW5jcmVtZW50IHRoZSBwYXRjaC5cbiAgICAgIC8vIElmIGl0IGlzIGEgcHJlLXJlbGVhc2UgaXQgd2lsbCBidW1wIHVwIHRvIHRoZSBzYW1lIHBhdGNoIHZlcnNpb24uXG4gICAgICAvLyAxLjIuMC01IHBhdGNoZXMgdG8gMS4yLjBcbiAgICAgIC8vIDEuMi4wIHBhdGNoZXMgdG8gMS4yLjFcbiAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMucGF0Y2grK1xuICAgICAgfVxuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgIGJyZWFrXG4gICAgLy8gVGhpcyBwcm9iYWJseSBzaG91bGRuJ3QgYmUgdXNlZCBwdWJsaWNseS5cbiAgICAvLyAxLjAuMCBcInByZVwiIHdvdWxkIGJlY29tZSAxLjAuMC0wIHdoaWNoIGlzIHRoZSB3cm9uZyBkaXJlY3Rpb24uXG4gICAgY2FzZSAncHJlJzpcbiAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFswXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLnByZXJlbGVhc2UubGVuZ3RoXG4gICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcmVyZWxlYXNlW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlW2ldKytcbiAgICAgICAgICAgIGkgPSAtMlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBkaWRuJ3QgaW5jcmVtZW50IGFueXRoaW5nXG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLnB1c2goMClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlkZW50aWZpZXIpIHtcbiAgICAgICAgLy8gMS4yLjAtYmV0YS4xIGJ1bXBzIHRvIDEuMi4wLWJldGEuMixcbiAgICAgICAgLy8gMS4yLjAtYmV0YS5mb29ibHogb3IgMS4yLjAtYmV0YSBidW1wcyB0byAxLjIuMC1iZXRhLjBcbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZVswXSA9PT0gaWRlbnRpZmllcikge1xuICAgICAgICAgIGlmIChpc05hTih0aGlzLnByZXJlbGVhc2VbMV0pKSB7XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgMF1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW2lkZW50aWZpZXIsIDBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluY3JlbWVudCBhcmd1bWVudDogJyArIHJlbGVhc2UpXG4gIH1cbiAgdGhpcy5mb3JtYXQoKVxuICB0aGlzLnJhdyA9IHRoaXMudmVyc2lvblxuICByZXR1cm4gdGhpc1xufVxuXG5leHBvcnRzLmluYyA9IGluY1xuZnVuY3Rpb24gaW5jICh2ZXJzaW9uLCByZWxlYXNlLCBsb29zZSwgaWRlbnRpZmllcikge1xuICBpZiAodHlwZW9mIChsb29zZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgaWRlbnRpZmllciA9IGxvb3NlXG4gICAgbG9vc2UgPSB1bmRlZmluZWRcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgbG9vc2UpLmluYyhyZWxlYXNlLCBpZGVudGlmaWVyKS52ZXJzaW9uXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5leHBvcnRzLmRpZmYgPSBkaWZmXG5mdW5jdGlvbiBkaWZmICh2ZXJzaW9uMSwgdmVyc2lvbjIpIHtcbiAgaWYgKGVxKHZlcnNpb24xLCB2ZXJzaW9uMikpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9IGVsc2Uge1xuICAgIHZhciB2MSA9IHBhcnNlKHZlcnNpb24xKVxuICAgIHZhciB2MiA9IHBhcnNlKHZlcnNpb24yKVxuICAgIHZhciBwcmVmaXggPSAnJ1xuICAgIGlmICh2MS5wcmVyZWxlYXNlLmxlbmd0aCB8fCB2Mi5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcHJlZml4ID0gJ3ByZSdcbiAgICAgIHZhciBkZWZhdWx0UmVzdWx0ID0gJ3ByZXJlbGVhc2UnXG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiB2MSkge1xuICAgICAgaWYgKGtleSA9PT0gJ21ham9yJyB8fCBrZXkgPT09ICdtaW5vcicgfHwga2V5ID09PSAncGF0Y2gnKSB7XG4gICAgICAgIGlmICh2MVtrZXldICE9PSB2MltrZXldKSB7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeCArIGtleVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0UmVzdWx0IC8vIG1heSBiZSB1bmRlZmluZWRcbiAgfVxufVxuXG5leHBvcnRzLmNvbXBhcmVJZGVudGlmaWVycyA9IGNvbXBhcmVJZGVudGlmaWVyc1xuXG52YXIgbnVtZXJpYyA9IC9eWzAtOV0rJC9cbmZ1bmN0aW9uIGNvbXBhcmVJZGVudGlmaWVycyAoYSwgYikge1xuICB2YXIgYW51bSA9IG51bWVyaWMudGVzdChhKVxuICB2YXIgYm51bSA9IG51bWVyaWMudGVzdChiKVxuXG4gIGlmIChhbnVtICYmIGJudW0pIHtcbiAgICBhID0gK2FcbiAgICBiID0gK2JcbiAgfVxuXG4gIHJldHVybiBhID09PSBiID8gMFxuICAgIDogKGFudW0gJiYgIWJudW0pID8gLTFcbiAgICA6IChibnVtICYmICFhbnVtKSA/IDFcbiAgICA6IGEgPCBiID8gLTFcbiAgICA6IDFcbn1cblxuZXhwb3J0cy5yY29tcGFyZUlkZW50aWZpZXJzID0gcmNvbXBhcmVJZGVudGlmaWVyc1xuZnVuY3Rpb24gcmNvbXBhcmVJZGVudGlmaWVycyAoYSwgYikge1xuICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGIsIGEpXG59XG5cbmV4cG9ydHMubWFqb3IgPSBtYWpvclxuZnVuY3Rpb24gbWFqb3IgKGEsIGxvb3NlKSB7XG4gIHJldHVybiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5tYWpvclxufVxuXG5leHBvcnRzLm1pbm9yID0gbWlub3JcbmZ1bmN0aW9uIG1pbm9yIChhLCBsb29zZSkge1xuICByZXR1cm4gbmV3IFNlbVZlcihhLCBsb29zZSkubWlub3Jcbn1cblxuZXhwb3J0cy5wYXRjaCA9IHBhdGNoXG5mdW5jdGlvbiBwYXRjaCAoYSwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBTZW1WZXIoYSwgbG9vc2UpLnBhdGNoXG59XG5cbmV4cG9ydHMuY29tcGFyZSA9IGNvbXBhcmVcbmZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5jb21wYXJlKG5ldyBTZW1WZXIoYiwgbG9vc2UpKVxufVxuXG5leHBvcnRzLmNvbXBhcmVMb29zZSA9IGNvbXBhcmVMb29zZVxuZnVuY3Rpb24gY29tcGFyZUxvb3NlIChhLCBiKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIHRydWUpXG59XG5cbmV4cG9ydHMuY29tcGFyZUJ1aWxkID0gY29tcGFyZUJ1aWxkXG5mdW5jdGlvbiBjb21wYXJlQnVpbGQgKGEsIGIsIGxvb3NlKSB7XG4gIHZhciB2ZXJzaW9uQSA9IG5ldyBTZW1WZXIoYSwgbG9vc2UpXG4gIHZhciB2ZXJzaW9uQiA9IG5ldyBTZW1WZXIoYiwgbG9vc2UpXG4gIHJldHVybiB2ZXJzaW9uQS5jb21wYXJlKHZlcnNpb25CKSB8fCB2ZXJzaW9uQS5jb21wYXJlQnVpbGQodmVyc2lvbkIpXG59XG5cbmV4cG9ydHMucmNvbXBhcmUgPSByY29tcGFyZVxuZnVuY3Rpb24gcmNvbXBhcmUgKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGIsIGEsIGxvb3NlKVxufVxuXG5leHBvcnRzLnNvcnQgPSBzb3J0XG5mdW5jdGlvbiBzb3J0IChsaXN0LCBsb29zZSkge1xuICByZXR1cm4gbGlzdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuY29tcGFyZUJ1aWxkKGEsIGIsIGxvb3NlKVxuICB9KVxufVxuXG5leHBvcnRzLnJzb3J0ID0gcnNvcnRcbmZ1bmN0aW9uIHJzb3J0IChsaXN0LCBsb29zZSkge1xuICByZXR1cm4gbGlzdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuY29tcGFyZUJ1aWxkKGIsIGEsIGxvb3NlKVxuICB9KVxufVxuXG5leHBvcnRzLmd0ID0gZ3RcbmZ1bmN0aW9uIGd0IChhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPiAwXG59XG5cbmV4cG9ydHMubHQgPSBsdFxuZnVuY3Rpb24gbHQgKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8IDBcbn1cblxuZXhwb3J0cy5lcSA9IGVxXG5mdW5jdGlvbiBlcSAoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpID09PSAwXG59XG5cbmV4cG9ydHMubmVxID0gbmVxXG5mdW5jdGlvbiBuZXEgKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSAhPT0gMFxufVxuXG5leHBvcnRzLmd0ZSA9IGd0ZVxuZnVuY3Rpb24gZ3RlIChhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPj0gMFxufVxuXG5leHBvcnRzLmx0ZSA9IGx0ZVxuZnVuY3Rpb24gbHRlIChhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPD0gMFxufVxuXG5leHBvcnRzLmNtcCA9IGNtcFxuZnVuY3Rpb24gY21wIChhLCBvcCwgYiwgbG9vc2UpIHtcbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgJz09PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKVxuICAgICAgICBhID0gYS52ZXJzaW9uXG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdvYmplY3QnKVxuICAgICAgICBiID0gYi52ZXJzaW9uXG4gICAgICByZXR1cm4gYSA9PT0gYlxuXG4gICAgY2FzZSAnIT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpXG4gICAgICAgIGEgPSBhLnZlcnNpb25cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpXG4gICAgICAgIGIgPSBiLnZlcnNpb25cbiAgICAgIHJldHVybiBhICE9PSBiXG5cbiAgICBjYXNlICcnOlxuICAgIGNhc2UgJz0nOlxuICAgIGNhc2UgJz09JzpcbiAgICAgIHJldHVybiBlcShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJyE9JzpcbiAgICAgIHJldHVybiBuZXEoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc+JzpcbiAgICAgIHJldHVybiBndChhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJz49JzpcbiAgICAgIHJldHVybiBndGUoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc8JzpcbiAgICAgIHJldHVybiBsdChhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJzw9JzpcbiAgICAgIHJldHVybiBsdGUoYSwgYiwgbG9vc2UpXG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBvcGVyYXRvcjogJyArIG9wKVxuICB9XG59XG5cbmV4cG9ydHMuQ29tcGFyYXRvciA9IENvbXBhcmF0b3JcbmZ1bmN0aW9uIENvbXBhcmF0b3IgKGNvbXAsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBsb29zZTogISFvcHRpb25zLFxuICAgICAgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgaWYgKGNvbXAubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSkge1xuICAgICAgcmV0dXJuIGNvbXBcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcCA9IGNvbXAudmFsdWVcbiAgICB9XG4gIH1cblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29tcGFyYXRvcikpIHtcbiAgICByZXR1cm4gbmV3IENvbXBhcmF0b3IoY29tcCwgb3B0aW9ucylcbiAgfVxuXG4gIGRlYnVnKCdjb21wYXJhdG9yJywgY29tcCwgb3B0aW9ucylcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG4gIHRoaXMucGFyc2UoY29tcClcblxuICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSkge1xuICAgIHRoaXMudmFsdWUgPSAnJ1xuICB9IGVsc2Uge1xuICAgIHRoaXMudmFsdWUgPSB0aGlzLm9wZXJhdG9yICsgdGhpcy5zZW12ZXIudmVyc2lvblxuICB9XG5cbiAgZGVidWcoJ2NvbXAnLCB0aGlzKVxufVxuXG52YXIgQU5ZID0ge31cbkNvbXBhcmF0b3IucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKGNvbXApIHtcbiAgdmFyIHIgPSB0aGlzLm9wdGlvbnMubG9vc2UgPyByZVt0LkNPTVBBUkFUT1JMT09TRV0gOiByZVt0LkNPTVBBUkFUT1JdXG4gIHZhciBtID0gY29tcC5tYXRjaChyKVxuXG4gIGlmICghbSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY29tcGFyYXRvcjogJyArIGNvbXApXG4gIH1cblxuICB0aGlzLm9wZXJhdG9yID0gbVsxXSAhPT0gdW5kZWZpbmVkID8gbVsxXSA6ICcnXG4gIGlmICh0aGlzLm9wZXJhdG9yID09PSAnPScpIHtcbiAgICB0aGlzLm9wZXJhdG9yID0gJydcbiAgfVxuXG4gIC8vIGlmIGl0IGxpdGVyYWxseSBpcyBqdXN0ICc+JyBvciAnJyB0aGVuIGFsbG93IGFueXRoaW5nLlxuICBpZiAoIW1bMl0pIHtcbiAgICB0aGlzLnNlbXZlciA9IEFOWVxuICB9IGVsc2Uge1xuICAgIHRoaXMuc2VtdmVyID0gbmV3IFNlbVZlcihtWzJdLCB0aGlzLm9wdGlvbnMubG9vc2UpXG4gIH1cbn1cblxuQ29tcGFyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnZhbHVlXG59XG5cbkNvbXBhcmF0b3IucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiAodmVyc2lvbikge1xuICBkZWJ1ZygnQ29tcGFyYXRvci50ZXN0JywgdmVyc2lvbiwgdGhpcy5vcHRpb25zLmxvb3NlKVxuXG4gIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZIHx8IHZlcnNpb24gPT09IEFOWSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMub3B0aW9ucylcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNtcCh2ZXJzaW9uLCB0aGlzLm9wZXJhdG9yLCB0aGlzLnNlbXZlciwgdGhpcy5vcHRpb25zKVxufVxuXG5Db21wYXJhdG9yLnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24gKGNvbXAsIG9wdGlvbnMpIHtcbiAgaWYgKCEoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBDb21wYXJhdG9yIGlzIHJlcXVpcmVkJylcbiAgfVxuXG4gIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgbG9vc2U6ICEhb3B0aW9ucyxcbiAgICAgIGluY2x1ZGVQcmVyZWxlYXNlOiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHZhciByYW5nZVRtcFxuXG4gIGlmICh0aGlzLm9wZXJhdG9yID09PSAnJykge1xuICAgIGlmICh0aGlzLnZhbHVlID09PSAnJykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmFuZ2VUbXAgPSBuZXcgUmFuZ2UoY29tcC52YWx1ZSwgb3B0aW9ucylcbiAgICByZXR1cm4gc2F0aXNmaWVzKHRoaXMudmFsdWUsIHJhbmdlVG1wLCBvcHRpb25zKVxuICB9IGVsc2UgaWYgKGNvbXAub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgaWYgKGNvbXAudmFsdWUgPT09ICcnKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByYW5nZVRtcCA9IG5ldyBSYW5nZSh0aGlzLnZhbHVlLCBvcHRpb25zKVxuICAgIHJldHVybiBzYXRpc2ZpZXMoY29tcC5zZW12ZXIsIHJhbmdlVG1wLCBvcHRpb25zKVxuICB9XG5cbiAgdmFyIHNhbWVEaXJlY3Rpb25JbmNyZWFzaW5nID1cbiAgICAodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPicpICYmXG4gICAgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJz4nKVxuICB2YXIgc2FtZURpcmVjdGlvbkRlY3JlYXNpbmcgPVxuICAgICh0aGlzLm9wZXJhdG9yID09PSAnPD0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJzw9JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPCcpXG4gIHZhciBzYW1lU2VtVmVyID0gdGhpcy5zZW12ZXIudmVyc2lvbiA9PT0gY29tcC5zZW12ZXIudmVyc2lvblxuICB2YXIgZGlmZmVyZW50RGlyZWN0aW9uc0luY2x1c2l2ZSA9XG4gICAgKHRoaXMub3BlcmF0b3IgPT09ICc+PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJzw9JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPD0nKVxuICB2YXIgb3Bwb3NpdGVEaXJlY3Rpb25zTGVzc1RoYW4gPVxuICAgIGNtcCh0aGlzLnNlbXZlciwgJzwnLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiZcbiAgICAoKHRoaXMub3BlcmF0b3IgPT09ICc+PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJz4nKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPD0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8JykpXG4gIHZhciBvcHBvc2l0ZURpcmVjdGlvbnNHcmVhdGVyVGhhbiA9XG4gICAgY21wKHRoaXMuc2VtdmVyLCAnPicsIGNvbXAuc2VtdmVyLCBvcHRpb25zKSAmJlxuICAgICgodGhpcy5vcGVyYXRvciA9PT0gJzw9JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPCcpICYmXG4gICAgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJz4nKSlcblxuICByZXR1cm4gc2FtZURpcmVjdGlvbkluY3JlYXNpbmcgfHwgc2FtZURpcmVjdGlvbkRlY3JlYXNpbmcgfHxcbiAgICAoc2FtZVNlbVZlciAmJiBkaWZmZXJlbnREaXJlY3Rpb25zSW5jbHVzaXZlKSB8fFxuICAgIG9wcG9zaXRlRGlyZWN0aW9uc0xlc3NUaGFuIHx8IG9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuXG59XG5cbmV4cG9ydHMuUmFuZ2UgPSBSYW5nZVxuZnVuY3Rpb24gUmFuZ2UgKHJhbmdlLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgbG9vc2U6ICEhb3B0aW9ucyxcbiAgICAgIGluY2x1ZGVQcmVyZWxlYXNlOiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGlmIChyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSB7XG4gICAgaWYgKHJhbmdlLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UgJiZcbiAgICAgICAgcmFuZ2UuaW5jbHVkZVByZXJlbGVhc2UgPT09ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgICAgcmV0dXJuIHJhbmdlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UucmF3LCBvcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIGlmIChyYW5nZSBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLnZhbHVlLCBvcHRpb25zKVxuICB9XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJhbmdlKSkge1xuICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH1cblxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuXG4gIC8vIEZpcnN0LCBzcGxpdCBiYXNlZCBvbiBib29sZWFuIG9yIHx8XG4gIHRoaXMucmF3ID0gcmFuZ2VcbiAgdGhpcy5zZXQgPSByYW5nZS5zcGxpdCgvXFxzKlxcfFxcfFxccyovKS5tYXAoZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VSYW5nZShyYW5nZS50cmltKCkpXG4gIH0sIHRoaXMpLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgIC8vIHRocm93IG91dCBhbnkgdGhhdCBhcmUgbm90IHJlbGV2YW50IGZvciB3aGF0ZXZlciByZWFzb25cbiAgICByZXR1cm4gYy5sZW5ndGhcbiAgfSlcblxuICBpZiAoIXRoaXMuc2V0Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgU2VtVmVyIFJhbmdlOiAnICsgcmFuZ2UpXG4gIH1cblxuICB0aGlzLmZvcm1hdCgpXG59XG5cblJhbmdlLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmFuZ2UgPSB0aGlzLnNldC5tYXAoZnVuY3Rpb24gKGNvbXBzKSB7XG4gICAgcmV0dXJuIGNvbXBzLmpvaW4oJyAnKS50cmltKClcbiAgfSkuam9pbignfHwnKS50cmltKClcbiAgcmV0dXJuIHRoaXMucmFuZ2Vcbn1cblxuUmFuZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yYW5nZVxufVxuXG5SYW5nZS5wcm90b3R5cGUucGFyc2VSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICB2YXIgbG9vc2UgPSB0aGlzLm9wdGlvbnMubG9vc2VcbiAgcmFuZ2UgPSByYW5nZS50cmltKClcbiAgLy8gYDEuMi4zIC0gMS4yLjRgID0+IGA+PTEuMi4zIDw9MS4yLjRgXG4gIHZhciBociA9IGxvb3NlID8gcmVbdC5IWVBIRU5SQU5HRUxPT1NFXSA6IHJlW3QuSFlQSEVOUkFOR0VdXG4gIHJhbmdlID0gcmFuZ2UucmVwbGFjZShociwgaHlwaGVuUmVwbGFjZSlcbiAgZGVidWcoJ2h5cGhlbiByZXBsYWNlJywgcmFuZ2UpXG4gIC8vIGA+IDEuMi4zIDwgMS4yLjVgID0+IGA+MS4yLjMgPDEuMi41YFxuICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5DT01QQVJBVE9SVFJJTV0sIGNvbXBhcmF0b3JUcmltUmVwbGFjZSlcbiAgZGVidWcoJ2NvbXBhcmF0b3IgdHJpbScsIHJhbmdlLCByZVt0LkNPTVBBUkFUT1JUUklNXSlcblxuICAvLyBgfiAxLjIuM2AgPT4gYH4xLjIuM2BcbiAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuVElMREVUUklNXSwgdGlsZGVUcmltUmVwbGFjZSlcblxuICAvLyBgXiAxLjIuM2AgPT4gYF4xLjIuM2BcbiAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuQ0FSRVRUUklNXSwgY2FyZXRUcmltUmVwbGFjZSlcblxuICAvLyBub3JtYWxpemUgc3BhY2VzXG4gIHJhbmdlID0gcmFuZ2Uuc3BsaXQoL1xccysvKS5qb2luKCcgJylcblxuICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSB0cmltbWVkIGFuZFxuICAvLyByZWFkeSB0byBiZSBzcGxpdCBpbnRvIGNvbXBhcmF0b3JzLlxuXG4gIHZhciBjb21wUmUgPSBsb29zZSA/IHJlW3QuQ09NUEFSQVRPUkxPT1NFXSA6IHJlW3QuQ09NUEFSQVRPUl1cbiAgdmFyIHNldCA9IHJhbmdlLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uIChjb21wKSB7XG4gICAgcmV0dXJuIHBhcnNlQ29tcGFyYXRvcihjb21wLCB0aGlzLm9wdGlvbnMpXG4gIH0sIHRoaXMpLmpvaW4oJyAnKS5zcGxpdCgvXFxzKy8pXG4gIGlmICh0aGlzLm9wdGlvbnMubG9vc2UpIHtcbiAgICAvLyBpbiBsb29zZSBtb2RlLCB0aHJvdyBvdXQgYW55IHRoYXQgYXJlIG5vdCB2YWxpZCBjb21wYXJhdG9yc1xuICAgIHNldCA9IHNldC5maWx0ZXIoZnVuY3Rpb24gKGNvbXApIHtcbiAgICAgIHJldHVybiAhIWNvbXAubWF0Y2goY29tcFJlKVxuICAgIH0pXG4gIH1cbiAgc2V0ID0gc2V0Lm1hcChmdW5jdGlvbiAoY29tcCkge1xuICAgIHJldHVybiBuZXcgQ29tcGFyYXRvcihjb21wLCB0aGlzLm9wdGlvbnMpXG4gIH0sIHRoaXMpXG5cbiAgcmV0dXJuIHNldFxufVxuXG5SYW5nZS5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uIChyYW5nZSwgb3B0aW9ucykge1xuICBpZiAoIShyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgUmFuZ2UgaXMgcmVxdWlyZWQnKVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuc2V0LnNvbWUoZnVuY3Rpb24gKHRoaXNDb21wYXJhdG9ycykge1xuICAgIHJldHVybiAoXG4gICAgICBpc1NhdGlzZmlhYmxlKHRoaXNDb21wYXJhdG9ycywgb3B0aW9ucykgJiZcbiAgICAgIHJhbmdlLnNldC5zb21lKGZ1bmN0aW9uIChyYW5nZUNvbXBhcmF0b3JzKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgaXNTYXRpc2ZpYWJsZShyYW5nZUNvbXBhcmF0b3JzLCBvcHRpb25zKSAmJlxuICAgICAgICAgIHRoaXNDb21wYXJhdG9ycy5ldmVyeShmdW5jdGlvbiAodGhpc0NvbXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiByYW5nZUNvbXBhcmF0b3JzLmV2ZXJ5KGZ1bmN0aW9uIChyYW5nZUNvbXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXNDb21wYXJhdG9yLmludGVyc2VjdHMocmFuZ2VDb21wYXJhdG9yLCBvcHRpb25zKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICB9KVxuICAgIClcbiAgfSlcbn1cblxuLy8gdGFrZSBhIHNldCBvZiBjb21wYXJhdG9ycyBhbmQgZGV0ZXJtaW5lIHdoZXRoZXIgdGhlcmVcbi8vIGV4aXN0cyBhIHZlcnNpb24gd2hpY2ggY2FuIHNhdGlzZnkgaXRcbmZ1bmN0aW9uIGlzU2F0aXNmaWFibGUgKGNvbXBhcmF0b3JzLCBvcHRpb25zKSB7XG4gIHZhciByZXN1bHQgPSB0cnVlXG4gIHZhciByZW1haW5pbmdDb21wYXJhdG9ycyA9IGNvbXBhcmF0b3JzLnNsaWNlKClcbiAgdmFyIHRlc3RDb21wYXJhdG9yID0gcmVtYWluaW5nQ29tcGFyYXRvcnMucG9wKClcblxuICB3aGlsZSAocmVzdWx0ICYmIHJlbWFpbmluZ0NvbXBhcmF0b3JzLmxlbmd0aCkge1xuICAgIHJlc3VsdCA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLmV2ZXJ5KGZ1bmN0aW9uIChvdGhlckNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiB0ZXN0Q29tcGFyYXRvci5pbnRlcnNlY3RzKG90aGVyQ29tcGFyYXRvciwgb3B0aW9ucylcbiAgICB9KVxuXG4gICAgdGVzdENvbXBhcmF0b3IgPSByZW1haW5pbmdDb21wYXJhdG9ycy5wb3AoKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vLyBNb3N0bHkganVzdCBmb3IgdGVzdGluZyBhbmQgbGVnYWN5IEFQSSByZWFzb25zXG5leHBvcnRzLnRvQ29tcGFyYXRvcnMgPSB0b0NvbXBhcmF0b3JzXG5mdW5jdGlvbiB0b0NvbXBhcmF0b3JzIChyYW5nZSwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKS5zZXQubWFwKGZ1bmN0aW9uIChjb21wKSB7XG4gICAgcmV0dXJuIGNvbXAubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gYy52YWx1ZVxuICAgIH0pLmpvaW4oJyAnKS50cmltKCkuc3BsaXQoJyAnKVxuICB9KVxufVxuXG4vLyBjb21wcmlzZWQgb2YgeHJhbmdlcywgdGlsZGVzLCBzdGFycywgYW5kIGd0bHQncyBhdCB0aGlzIHBvaW50LlxuLy8gYWxyZWFkeSByZXBsYWNlZCB0aGUgaHlwaGVuIHJhbmdlc1xuLy8gdHVybiBpbnRvIGEgc2V0IG9mIEpVU1QgY29tcGFyYXRvcnMuXG5mdW5jdGlvbiBwYXJzZUNvbXBhcmF0b3IgKGNvbXAsIG9wdGlvbnMpIHtcbiAgZGVidWcoJ2NvbXAnLCBjb21wLCBvcHRpb25zKVxuICBjb21wID0gcmVwbGFjZUNhcmV0cyhjb21wLCBvcHRpb25zKVxuICBkZWJ1ZygnY2FyZXQnLCBjb21wKVxuICBjb21wID0gcmVwbGFjZVRpbGRlcyhjb21wLCBvcHRpb25zKVxuICBkZWJ1ZygndGlsZGVzJywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VYUmFuZ2VzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCd4cmFuZ2UnLCBjb21wKVxuICBjb21wID0gcmVwbGFjZVN0YXJzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCdzdGFycycsIGNvbXApXG4gIHJldHVybiBjb21wXG59XG5cbmZ1bmN0aW9uIGlzWCAoaWQpIHtcbiAgcmV0dXJuICFpZCB8fCBpZC50b0xvd2VyQ2FzZSgpID09PSAneCcgfHwgaWQgPT09ICcqJ1xufVxuXG4vLyB+LCB+PiAtLSA+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyB+MiwgfjIueCwgfjIueC54LCB+PjIsIH4+Mi54IH4+Mi54LnggLS0gPiA+PTIuMC4wIDwzLjAuMFxuLy8gfjIuMCwgfjIuMC54LCB+PjIuMCwgfj4yLjAueCAtLSA+ID49Mi4wLjAgPDIuMS4wXG4vLyB+MS4yLCB+MS4yLngsIH4+MS4yLCB+PjEuMi54IC0tID4gPj0xLjIuMCA8MS4zLjBcbi8vIH4xLjIuMywgfj4xLjIuMyAtLSA+ID49MS4yLjMgPDEuMy4wXG4vLyB+MS4yLjAsIH4+MS4yLjAgLS0gPiA+PTEuMi4wIDwxLjMuMFxuZnVuY3Rpb24gcmVwbGFjZVRpbGRlcyAoY29tcCwgb3B0aW9ucykge1xuICByZXR1cm4gY29tcC50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24gKGNvbXApIHtcbiAgICByZXR1cm4gcmVwbGFjZVRpbGRlKGNvbXAsIG9wdGlvbnMpXG4gIH0pLmpvaW4oJyAnKVxufVxuXG5mdW5jdGlvbiByZXBsYWNlVGlsZGUgKGNvbXAsIG9wdGlvbnMpIHtcbiAgdmFyIHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5USUxERUxPT1NFXSA6IHJlW3QuVElMREVdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgZnVuY3Rpb24gKF8sIE0sIG0sIHAsIHByKSB7XG4gICAgZGVidWcoJ3RpbGRlJywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgdmFyIHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLjAuMCA8JyArICgrTSArIDEpICsgJy4wLjAnXG4gICAgfSBlbHNlIGlmIChpc1gocCkpIHtcbiAgICAgIC8vIH4xLjIgPT0gPj0xLjIuMCA8MS4zLjBcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCdcbiAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZVRpbGRlIHByJywgcHIpXG4gICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICsgJy0nICsgcHIgK1xuICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCdcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gfjEuMi4zID09ID49MS4yLjMgPDEuMy4wXG4gICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICtcbiAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnXG4gICAgfVxuXG4gICAgZGVidWcoJ3RpbGRlIHJldHVybicsIHJldClcbiAgICByZXR1cm4gcmV0XG4gIH0pXG59XG5cbi8vIF4gLS0gPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gXjIsIF4yLngsIF4yLngueCAtLSA+ID49Mi4wLjAgPDMuMC4wXG4vLyBeMi4wLCBeMi4wLnggLS0gPiA+PTIuMC4wIDwzLjAuMFxuLy8gXjEuMiwgXjEuMi54IC0tID4gPj0xLjIuMCA8Mi4wLjBcbi8vIF4xLjIuMyAtLSA+ID49MS4yLjMgPDIuMC4wXG4vLyBeMS4yLjAgLS0gPiA+PTEuMi4wIDwyLjAuMFxuZnVuY3Rpb24gcmVwbGFjZUNhcmV0cyAoY29tcCwgb3B0aW9ucykge1xuICByZXR1cm4gY29tcC50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24gKGNvbXApIHtcbiAgICByZXR1cm4gcmVwbGFjZUNhcmV0KGNvbXAsIG9wdGlvbnMpXG4gIH0pLmpvaW4oJyAnKVxufVxuXG5mdW5jdGlvbiByZXBsYWNlQ2FyZXQgKGNvbXAsIG9wdGlvbnMpIHtcbiAgZGVidWcoJ2NhcmV0JywgY29tcCwgb3B0aW9ucylcbiAgdmFyIHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5DQVJFVExPT1NFXSA6IHJlW3QuQ0FSRVRdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgZnVuY3Rpb24gKF8sIE0sIG0sIHAsIHByKSB7XG4gICAgZGVidWcoJ2NhcmV0JywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgdmFyIHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLjAuMCA8JyArICgrTSArIDEpICsgJy4wLjAnXG4gICAgfSBlbHNlIGlmIChpc1gocCkpIHtcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4wIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4wIDwnICsgKCtNICsgMSkgKyAnLjAuMCdcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZUNhcmV0IHByJywgcHIpXG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpIHtcbiAgICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICsgJy0nICsgcHIgK1xuICAgICAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgbSArICcuJyArICgrcCArIDEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArICctJyArIHByICtcbiAgICAgICAgICAgICAgICAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJ1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICsgJy0nICsgcHIgK1xuICAgICAgICAgICAgICAnIDwnICsgKCtNICsgMSkgKyAnLjAuMCdcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ25vIHByJylcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgaWYgKG0gPT09ICcwJykge1xuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgK1xuICAgICAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgbSArICcuJyArICgrcCArIDEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArXG4gICAgICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCdcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArXG4gICAgICAgICAgICAgICcgPCcgKyAoK00gKyAxKSArICcuMC4wJ1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlYnVnKCdjYXJldCByZXR1cm4nLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG5mdW5jdGlvbiByZXBsYWNlWFJhbmdlcyAoY29tcCwgb3B0aW9ucykge1xuICBkZWJ1ZygncmVwbGFjZVhSYW5nZXMnLCBjb21wLCBvcHRpb25zKVxuICByZXR1cm4gY29tcC5zcGxpdCgvXFxzKy8pLm1hcChmdW5jdGlvbiAoY29tcCkge1xuICAgIHJldHVybiByZXBsYWNlWFJhbmdlKGNvbXAsIG9wdGlvbnMpXG4gIH0pLmpvaW4oJyAnKVxufVxuXG5mdW5jdGlvbiByZXBsYWNlWFJhbmdlIChjb21wLCBvcHRpb25zKSB7XG4gIGNvbXAgPSBjb21wLnRyaW0oKVxuICB2YXIgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LlhSQU5HRUxPT1NFXSA6IHJlW3QuWFJBTkdFXVxuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIGZ1bmN0aW9uIChyZXQsIGd0bHQsIE0sIG0sIHAsIHByKSB7XG4gICAgZGVidWcoJ3hSYW5nZScsIGNvbXAsIHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpXG4gICAgdmFyIHhNID0gaXNYKE0pXG4gICAgdmFyIHhtID0geE0gfHwgaXNYKG0pXG4gICAgdmFyIHhwID0geG0gfHwgaXNYKHApXG4gICAgdmFyIGFueVggPSB4cFxuXG4gICAgaWYgKGd0bHQgPT09ICc9JyAmJiBhbnlYKSB7XG4gICAgICBndGx0ID0gJydcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSdyZSBpbmNsdWRpbmcgcHJlcmVsZWFzZXMgaW4gdGhlIG1hdGNoLCB0aGVuIHdlIG5lZWRcbiAgICAvLyB0byBmaXggdGhpcyB0byAtMCwgdGhlIGxvd2VzdCBwb3NzaWJsZSBwcmVyZWxlYXNlIHZhbHVlXG4gICAgcHIgPSBvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gJy0wJyA6ICcnXG5cbiAgICBpZiAoeE0pIHtcbiAgICAgIGlmIChndGx0ID09PSAnPicgfHwgZ3RsdCA9PT0gJzwnKSB7XG4gICAgICAgIC8vIG5vdGhpbmcgaXMgYWxsb3dlZFxuICAgICAgICByZXQgPSAnPDAuMC4wLTAnXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGZvcmJpZGRlblxuICAgICAgICByZXQgPSAnKidcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGd0bHQgJiYgYW55WCkge1xuICAgICAgLy8gd2Uga25vdyBwYXRjaCBpcyBhbiB4LCBiZWNhdXNlIHdlIGhhdmUgYW55IHggYXQgYWxsLlxuICAgICAgLy8gcmVwbGFjZSBYIHdpdGggMFxuICAgICAgaWYgKHhtKSB7XG4gICAgICAgIG0gPSAwXG4gICAgICB9XG4gICAgICBwID0gMFxuXG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nKSB7XG4gICAgICAgIC8vID4xID0+ID49Mi4wLjBcbiAgICAgICAgLy8gPjEuMiA9PiA+PTEuMy4wXG4gICAgICAgIC8vID4xLjIuMyA9PiA+PSAxLjIuNFxuICAgICAgICBndGx0ID0gJz49J1xuICAgICAgICBpZiAoeG0pIHtcbiAgICAgICAgICBNID0gK00gKyAxXG4gICAgICAgICAgbSA9IDBcbiAgICAgICAgICBwID0gMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSArbSArIDFcbiAgICAgICAgICBwID0gMFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGd0bHQgPT09ICc8PScpIHtcbiAgICAgICAgLy8gPD0wLjcueCBpcyBhY3R1YWxseSA8MC44LjAsIHNpbmNlIGFueSAwLjcueCBzaG91bGRcbiAgICAgICAgLy8gcGFzcy4gIFNpbWlsYXJseSwgPD03LnggaXMgYWN0dWFsbHkgPDguMC4wLCBldGMuXG4gICAgICAgIGd0bHQgPSAnPCdcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSArbSArIDFcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXQgPSBndGx0ICsgTSArICcuJyArIG0gKyAnLicgKyBwICsgcHJcbiAgICB9IGVsc2UgaWYgKHhtKSB7XG4gICAgICByZXQgPSAnPj0nICsgTSArICcuMC4wJyArIHByICsgJyA8JyArICgrTSArIDEpICsgJy4wLjAnICsgcHJcbiAgICB9IGVsc2UgaWYgKHhwKSB7XG4gICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAnICsgcHIgK1xuICAgICAgICAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJyArIHByXG4gICAgfVxuXG4gICAgZGVidWcoJ3hSYW5nZSByZXR1cm4nLCByZXQpXG5cbiAgICByZXR1cm4gcmV0XG4gIH0pXG59XG5cbi8vIEJlY2F1c2UgKiBpcyBBTkQtZWQgd2l0aCBldmVyeXRoaW5nIGVsc2UgaW4gdGhlIGNvbXBhcmF0b3IsXG4vLyBhbmQgJycgbWVhbnMgXCJhbnkgdmVyc2lvblwiLCBqdXN0IHJlbW92ZSB0aGUgKnMgZW50aXJlbHkuXG5mdW5jdGlvbiByZXBsYWNlU3RhcnMgKGNvbXAsIG9wdGlvbnMpIHtcbiAgZGVidWcoJ3JlcGxhY2VTdGFycycsIGNvbXAsIG9wdGlvbnMpXG4gIC8vIExvb3NlbmVzcyBpcyBpZ25vcmVkIGhlcmUuICBzdGFyIGlzIGFsd2F5cyBhcyBsb29zZSBhcyBpdCBnZXRzIVxuICByZXR1cm4gY29tcC50cmltKCkucmVwbGFjZShyZVt0LlNUQVJdLCAnJylcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBwYXNzZWQgdG8gc3RyaW5nLnJlcGxhY2UocmVbdC5IWVBIRU5SQU5HRV0pXG4vLyBNLCBtLCBwYXRjaCwgcHJlcmVsZWFzZSwgYnVpbGRcbi8vIDEuMiAtIDMuNC41ID0+ID49MS4yLjAgPD0zLjQuNVxuLy8gMS4yLjMgLSAzLjQgPT4gPj0xLjIuMCA8My41LjAgQW55IDMuNC54IHdpbGwgZG9cbi8vIDEuMiAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMFxuZnVuY3Rpb24gaHlwaGVuUmVwbGFjZSAoJDAsXG4gIGZyb20sIGZNLCBmbSwgZnAsIGZwciwgZmIsXG4gIHRvLCB0TSwgdG0sIHRwLCB0cHIsIHRiKSB7XG4gIGlmIChpc1goZk0pKSB7XG4gICAgZnJvbSA9ICcnXG4gIH0gZWxzZSBpZiAoaXNYKGZtKSkge1xuICAgIGZyb20gPSAnPj0nICsgZk0gKyAnLjAuMCdcbiAgfSBlbHNlIGlmIChpc1goZnApKSB7XG4gICAgZnJvbSA9ICc+PScgKyBmTSArICcuJyArIGZtICsgJy4wJ1xuICB9IGVsc2Uge1xuICAgIGZyb20gPSAnPj0nICsgZnJvbVxuICB9XG5cbiAgaWYgKGlzWCh0TSkpIHtcbiAgICB0byA9ICcnXG4gIH0gZWxzZSBpZiAoaXNYKHRtKSkge1xuICAgIHRvID0gJzwnICsgKCt0TSArIDEpICsgJy4wLjAnXG4gIH0gZWxzZSBpZiAoaXNYKHRwKSkge1xuICAgIHRvID0gJzwnICsgdE0gKyAnLicgKyAoK3RtICsgMSkgKyAnLjAnXG4gIH0gZWxzZSBpZiAodHByKSB7XG4gICAgdG8gPSAnPD0nICsgdE0gKyAnLicgKyB0bSArICcuJyArIHRwICsgJy0nICsgdHByXG4gIH0gZWxzZSB7XG4gICAgdG8gPSAnPD0nICsgdG9cbiAgfVxuXG4gIHJldHVybiAoZnJvbSArICcgJyArIHRvKS50cmltKClcbn1cblxuLy8gaWYgQU5ZIG9mIHRoZSBzZXRzIG1hdGNoIEFMTCBvZiBpdHMgY29tcGFyYXRvcnMsIHRoZW4gcGFzc1xuUmFuZ2UucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiAodmVyc2lvbikge1xuICBpZiAoIXZlcnNpb24pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRlc3RTZXQodGhpcy5zZXRbaV0sIHZlcnNpb24sIHRoaXMub3B0aW9ucykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiB0ZXN0U2V0IChzZXQsIHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXNldFtpXS50ZXN0KHZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBpZiAodmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgIC8vIEZpbmQgdGhlIHNldCBvZiB2ZXJzaW9ucyB0aGF0IGFyZSBhbGxvd2VkIHRvIGhhdmUgcHJlcmVsZWFzZXNcbiAgICAvLyBGb3IgZXhhbXBsZSwgXjEuMi4zLXByLjEgZGVzdWdhcnMgdG8gPj0xLjIuMy1wci4xIDwyLjAuMFxuICAgIC8vIFRoYXQgc2hvdWxkIGFsbG93IGAxLjIuMy1wci4yYCB0byBwYXNzLlxuICAgIC8vIEhvd2V2ZXIsIGAxLjIuNC1hbHBoYS5ub3RyZWFkeWAgc2hvdWxkIE5PVCBiZSBhbGxvd2VkLFxuICAgIC8vIGV2ZW4gdGhvdWdoIGl0J3Mgd2l0aGluIHRoZSByYW5nZSBzZXQgYnkgdGhlIGNvbXBhcmF0b3JzLlxuICAgIGZvciAoaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYnVnKHNldFtpXS5zZW12ZXIpXG4gICAgICBpZiAoc2V0W2ldLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgYWxsb3dlZCA9IHNldFtpXS5zZW12ZXJcbiAgICAgICAgaWYgKGFsbG93ZWQubWFqb3IgPT09IHZlcnNpb24ubWFqb3IgJiZcbiAgICAgICAgICAgIGFsbG93ZWQubWlub3IgPT09IHZlcnNpb24ubWlub3IgJiZcbiAgICAgICAgICAgIGFsbG93ZWQucGF0Y2ggPT09IHZlcnNpb24ucGF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmVyc2lvbiBoYXMgYSAtcHJlLCBidXQgaXQncyBub3Qgb25lIG9mIHRoZSBvbmVzIHdlIGxpa2UuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnRzLnNhdGlzZmllcyA9IHNhdGlzZmllc1xuZnVuY3Rpb24gc2F0aXNmaWVzICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykge1xuICB0cnkge1xuICAgIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiByYW5nZS50ZXN0KHZlcnNpb24pXG59XG5cbmV4cG9ydHMubWF4U2F0aXNmeWluZyA9IG1heFNhdGlzZnlpbmdcbmZ1bmN0aW9uIG1heFNhdGlzZnlpbmcgKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykge1xuICB2YXIgbWF4ID0gbnVsbFxuICB2YXIgbWF4U1YgPSBudWxsXG4gIHRyeSB7XG4gICAgdmFyIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmVyc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgIGlmIChyYW5nZU9iai50ZXN0KHYpKSB7XG4gICAgICAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgICBpZiAoIW1heCB8fCBtYXhTVi5jb21wYXJlKHYpID09PSAtMSkge1xuICAgICAgICAvLyBjb21wYXJlKG1heCwgdiwgdHJ1ZSlcbiAgICAgICAgbWF4ID0gdlxuICAgICAgICBtYXhTViA9IG5ldyBTZW1WZXIobWF4LCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG1heFxufVxuXG5leHBvcnRzLm1pblNhdGlzZnlpbmcgPSBtaW5TYXRpc2Z5aW5nXG5mdW5jdGlvbiBtaW5TYXRpc2Z5aW5nICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgdmFyIG1pbiA9IG51bGxcbiAgdmFyIG1pblNWID0gbnVsbFxuICB0cnkge1xuICAgIHZhciByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZlcnNpb25zLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkge1xuICAgICAgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtaW4gfHwgbWluU1YuY29tcGFyZSh2KSA9PT0gMSkge1xuICAgICAgICAvLyBjb21wYXJlKG1pbiwgdiwgdHJ1ZSlcbiAgICAgICAgbWluID0gdlxuICAgICAgICBtaW5TViA9IG5ldyBTZW1WZXIobWluLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG1pblxufVxuXG5leHBvcnRzLm1pblZlcnNpb24gPSBtaW5WZXJzaW9uXG5mdW5jdGlvbiBtaW5WZXJzaW9uIChyYW5nZSwgbG9vc2UpIHtcbiAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKVxuXG4gIHZhciBtaW52ZXIgPSBuZXcgU2VtVmVyKCcwLjAuMCcpXG4gIGlmIChyYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICBtaW52ZXIgPSBuZXcgU2VtVmVyKCcwLjAuMC0wJylcbiAgaWYgKHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXJcbiAgfVxuXG4gIG1pbnZlciA9IG51bGxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZS5zZXQubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV1cblxuICAgIGNvbXBhcmF0b3JzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBhcmF0b3IpIHtcbiAgICAgIC8vIENsb25lIHRvIGF2b2lkIG1hbmlwdWxhdGluZyB0aGUgY29tcGFyYXRvcidzIHNlbXZlciBvYmplY3QuXG4gICAgICB2YXIgY29tcHZlciA9IG5ldyBTZW1WZXIoY29tcGFyYXRvci5zZW12ZXIudmVyc2lvbilcbiAgICAgIHN3aXRjaCAoY29tcGFyYXRvci5vcGVyYXRvcikge1xuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICBpZiAoY29tcHZlci5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29tcHZlci5wYXRjaCsrXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXB2ZXIucHJlcmVsZWFzZS5wdXNoKDApXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbXB2ZXIucmF3ID0gY29tcHZlci5mb3JtYXQoKVxuICAgICAgICAgIC8qIGZhbGx0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJyc6XG4gICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICBpZiAoIW1pbnZlciB8fCBndChtaW52ZXIsIGNvbXB2ZXIpKSB7XG4gICAgICAgICAgICBtaW52ZXIgPSBjb21wdmVyXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgLyogSWdub3JlIG1heGltdW0gdmVyc2lvbnMgKi9cbiAgICAgICAgICBicmVha1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBvcGVyYXRpb246ICcgKyBjb21wYXJhdG9yLm9wZXJhdG9yKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBpZiAobWludmVyICYmIHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXJcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydHMudmFsaWRSYW5nZSA9IHZhbGlkUmFuZ2VcbmZ1bmN0aW9uIHZhbGlkUmFuZ2UgKHJhbmdlLCBvcHRpb25zKSB7XG4gIHRyeSB7XG4gICAgLy8gUmV0dXJuICcqJyBpbnN0ZWFkIG9mICcnIHNvIHRoYXQgdHJ1dGhpbmVzcyB3b3Jrcy5cbiAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgaXQncyBpbnZhbGlkIGFueXdheVxuICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpLnJhbmdlIHx8ICcqJ1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgbGVzcyB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlXG5leHBvcnRzLmx0ciA9IGx0clxuZnVuY3Rpb24gbHRyICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykge1xuICByZXR1cm4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJzwnLCBvcHRpb25zKVxufVxuXG4vLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2UuXG5leHBvcnRzLmd0ciA9IGd0clxuZnVuY3Rpb24gZ3RyICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykge1xuICByZXR1cm4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJz4nLCBvcHRpb25zKVxufVxuXG5leHBvcnRzLm91dHNpZGUgPSBvdXRzaWRlXG5mdW5jdGlvbiBvdXRzaWRlICh2ZXJzaW9uLCByYW5nZSwgaGlsbywgb3B0aW9ucykge1xuICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKVxuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcblxuICB2YXIgZ3RmbiwgbHRlZm4sIGx0Zm4sIGNvbXAsIGVjb21wXG4gIHN3aXRjaCAoaGlsbykge1xuICAgIGNhc2UgJz4nOlxuICAgICAgZ3RmbiA9IGd0XG4gICAgICBsdGVmbiA9IGx0ZVxuICAgICAgbHRmbiA9IGx0XG4gICAgICBjb21wID0gJz4nXG4gICAgICBlY29tcCA9ICc+PSdcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnPCc6XG4gICAgICBndGZuID0gbHRcbiAgICAgIGx0ZWZuID0gZ3RlXG4gICAgICBsdGZuID0gZ3RcbiAgICAgIGNvbXAgPSAnPCdcbiAgICAgIGVjb21wID0gJzw9J1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBwcm92aWRlIGEgaGlsbyB2YWwgb2YgXCI8XCIgb3IgXCI+XCInKVxuICB9XG5cbiAgLy8gSWYgaXQgc2F0aXNpZmVzIHRoZSByYW5nZSBpdCBpcyBub3Qgb3V0c2lkZVxuICBpZiAoc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gRnJvbSBub3cgb24sIHZhcmlhYmxlIHRlcm1zIGFyZSBhcyBpZiB3ZSdyZSBpbiBcImd0clwiIG1vZGUuXG4gIC8vIGJ1dCBub3RlIHRoYXQgZXZlcnl0aGluZyBpcyBmbGlwcGVkIGZvciB0aGUgXCJsdHJcIiBmdW5jdGlvbi5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBjb21wYXJhdG9ycyA9IHJhbmdlLnNldFtpXVxuXG4gICAgdmFyIGhpZ2ggPSBudWxsXG4gICAgdmFyIGxvdyA9IG51bGxcblxuICAgIGNvbXBhcmF0b3JzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBhcmF0b3IpIHtcbiAgICAgIGlmIChjb21wYXJhdG9yLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICAgIGNvbXBhcmF0b3IgPSBuZXcgQ29tcGFyYXRvcignPj0wLjAuMCcpXG4gICAgICB9XG4gICAgICBoaWdoID0gaGlnaCB8fCBjb21wYXJhdG9yXG4gICAgICBsb3cgPSBsb3cgfHwgY29tcGFyYXRvclxuICAgICAgaWYgKGd0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGhpZ2guc2VtdmVyLCBvcHRpb25zKSkge1xuICAgICAgICBoaWdoID0gY29tcGFyYXRvclxuICAgICAgfSBlbHNlIGlmIChsdGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBsb3cuc2VtdmVyLCBvcHRpb25zKSkge1xuICAgICAgICBsb3cgPSBjb21wYXJhdG9yXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIElmIHRoZSBlZGdlIHZlcnNpb24gY29tcGFyYXRvciBoYXMgYSBvcGVyYXRvciB0aGVuIG91ciB2ZXJzaW9uXG4gICAgLy8gaXNuJ3Qgb3V0c2lkZSBpdFxuICAgIGlmIChoaWdoLm9wZXJhdG9yID09PSBjb21wIHx8IGhpZ2gub3BlcmF0b3IgPT09IGVjb21wKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbG93ZXN0IHZlcnNpb24gY29tcGFyYXRvciBoYXMgYW4gb3BlcmF0b3IgYW5kIG91ciB2ZXJzaW9uXG4gICAgLy8gaXMgbGVzcyB0aGFuIGl0IHRoZW4gaXQgaXNuJ3QgaGlnaGVyIHRoYW4gdGhlIHJhbmdlXG4gICAgaWYgKCghbG93Lm9wZXJhdG9yIHx8IGxvdy5vcGVyYXRvciA9PT0gY29tcCkgJiZcbiAgICAgICAgbHRlZm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSBpZiAobG93Lm9wZXJhdG9yID09PSBlY29tcCAmJiBsdGZuKHZlcnNpb24sIGxvdy5zZW12ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZXhwb3J0cy5wcmVyZWxlYXNlID0gcHJlcmVsZWFzZVxuZnVuY3Rpb24gcHJlcmVsZWFzZSAodmVyc2lvbiwgb3B0aW9ucykge1xuICB2YXIgcGFyc2VkID0gcGFyc2UodmVyc2lvbiwgb3B0aW9ucylcbiAgcmV0dXJuIChwYXJzZWQgJiYgcGFyc2VkLnByZXJlbGVhc2UubGVuZ3RoKSA/IHBhcnNlZC5wcmVyZWxlYXNlIDogbnVsbFxufVxuXG5leHBvcnRzLmludGVyc2VjdHMgPSBpbnRlcnNlY3RzXG5mdW5jdGlvbiBpbnRlcnNlY3RzIChyMSwgcjIsIG9wdGlvbnMpIHtcbiAgcjEgPSBuZXcgUmFuZ2UocjEsIG9wdGlvbnMpXG4gIHIyID0gbmV3IFJhbmdlKHIyLCBvcHRpb25zKVxuICByZXR1cm4gcjEuaW50ZXJzZWN0cyhyMilcbn1cblxuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2VcbmZ1bmN0aW9uIGNvZXJjZSAodmVyc2lvbiwgb3B0aW9ucykge1xuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgIHJldHVybiB2ZXJzaW9uXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdudW1iZXInKSB7XG4gICAgdmVyc2lvbiA9IFN0cmluZyh2ZXJzaW9uKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIHZhciBtYXRjaCA9IG51bGxcbiAgaWYgKCFvcHRpb25zLnJ0bCkge1xuICAgIG1hdGNoID0gdmVyc2lvbi5tYXRjaChyZVt0LkNPRVJDRV0pXG4gIH0gZWxzZSB7XG4gICAgLy8gRmluZCB0aGUgcmlnaHQtbW9zdCBjb2VyY2libGUgc3RyaW5nIHRoYXQgZG9lcyBub3Qgc2hhcmVcbiAgICAvLyBhIHRlcm1pbnVzIHdpdGggYSBtb3JlIGxlZnQtd2FyZCBjb2VyY2libGUgc3RyaW5nLlxuICAgIC8vIEVnLCAnMS4yLjMuNCcgd2FudHMgdG8gY29lcmNlICcyLjMuNCcsIG5vdCAnMy40JyBvciAnNCdcbiAgICAvL1xuICAgIC8vIFdhbGsgdGhyb3VnaCB0aGUgc3RyaW5nIGNoZWNraW5nIHdpdGggYSAvZyByZWdleHBcbiAgICAvLyBNYW51YWxseSBzZXQgdGhlIGluZGV4IHNvIGFzIHRvIHBpY2sgdXAgb3ZlcmxhcHBpbmcgbWF0Y2hlcy5cbiAgICAvLyBTdG9wIHdoZW4gd2UgZ2V0IGEgbWF0Y2ggdGhhdCBlbmRzIGF0IHRoZSBzdHJpbmcgZW5kLCBzaW5jZSBub1xuICAgIC8vIGNvZXJjaWJsZSBzdHJpbmcgY2FuIGJlIG1vcmUgcmlnaHQtd2FyZCB3aXRob3V0IHRoZSBzYW1lIHRlcm1pbnVzLlxuICAgIHZhciBuZXh0XG4gICAgd2hpbGUgKChuZXh0ID0gcmVbdC5DT0VSQ0VSVExdLmV4ZWModmVyc2lvbikpICYmXG4gICAgICAoIW1hdGNoIHx8IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoICE9PSB2ZXJzaW9uLmxlbmd0aClcbiAgICApIHtcbiAgICAgIGlmICghbWF0Y2ggfHxcbiAgICAgICAgICBuZXh0LmluZGV4ICsgbmV4dFswXS5sZW5ndGggIT09IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSB7XG4gICAgICAgIG1hdGNoID0gbmV4dFxuICAgICAgfVxuICAgICAgcmVbdC5DT0VSQ0VSVExdLmxhc3RJbmRleCA9IG5leHQuaW5kZXggKyBuZXh0WzFdLmxlbmd0aCArIG5leHRbMl0ubGVuZ3RoXG4gICAgfVxuICAgIC8vIGxlYXZlIGl0IGluIGEgY2xlYW4gc3RhdGVcbiAgICByZVt0LkNPRVJDRVJUTF0ubGFzdEluZGV4ID0gLTFcbiAgfVxuXG4gIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4gcGFyc2UobWF0Y2hbMl0gK1xuICAgICcuJyArIChtYXRjaFszXSB8fCAnMCcpICtcbiAgICAnLicgKyAobWF0Y2hbNF0gfHwgJzAnKSwgb3B0aW9ucylcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwdWxsID0gcmVxdWlyZSgncHVsbC1zdHJlYW0vcHVsbCcpXG5jb25zdCB2YWx1ZXMgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS9zb3VyY2VzL3ZhbHVlcycpXG5jb25zdCBjb2xsZWN0ID0gcmVxdWlyZSgncHVsbC1zdHJlYW0vc2lua3MvY29sbGVjdCcpXG5jb25zdCBwdWxsTFAgPSByZXF1aXJlKCdwdWxsLWxlbmd0aC1wcmVmaXhlZCcpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJylcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzXG5cbmZ1bmN0aW9uIHJhbmRvbUlkICgpIHtcbiAgcmV0dXJuICgofn4oTWF0aC5yYW5kb20oKSAqIDFlOSkpLnRvU3RyaW5nKDM2KSlcbn1cblxuLy8gcHJlZml4ZXMgYSBtZXNzYWdlIHdpdGggYSB2YXJpbnRcbi8vIFRPRE8gdGhpcyBpcyBhIHB1bGwtc3RyZWFtICdjcmVlcCcgKHB1bGwgc3RyZWFtIHRvIGFkZCBhIGJ5dGU/JylcbmZ1bmN0aW9uIGVuY29kZSAobXNnLCBjYWxsYmFjaykge1xuICBwdWxsKFxuICAgIHZhbHVlcyhCdWZmZXIuaXNCdWZmZXIobXNnKSA/IFttc2ddIDogW0J1ZmZlci5mcm9tKG1zZyldKSxcbiAgICBwdWxsTFAuZW5jb2RlKCksXG4gICAgY29sbGVjdCgoZXJyLCBlbmNvZGVkKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCBlbmNvZGVkWzBdKVxuICAgIH0pXG4gIClcbn1cblxuZXhwb3J0cy53cml0ZUVuY29kZWQgPSAod3JpdGVyLCBtc2csIGNhbGxiYWNrKSA9PiB7XG4gIGVuY29kZShtc2csIChlcnIsIG1zZykgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgfVxuICAgIHdyaXRlci53cml0ZShtc2cpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvZ2dlciAodHlwZSkge1xuICBjb25zdCBySWQgPSByYW5kb21JZCgpXG5cbiAgZnVuY3Rpb24gcHJpbnRlciAobG9nZ2VyKSB7XG4gICAgcmV0dXJuIChtc2cpID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG1zZykpIHtcbiAgICAgICAgbXNnID0gbXNnLmpvaW4oJyAnKVxuICAgICAgfVxuICAgICAgbG9nZ2VyKCcoJXMpICVzJywgcklkLCBtc2cpXG4gICAgfVxuICB9XG5cbiAgY29uc3QgbG9nID0gcHJpbnRlcihkZWJ1ZygnbXNzOicgKyB0eXBlKSlcbiAgbG9nLmVycm9yID0gcHJpbnRlcihkZWJ1ZygnbXNzOicgKyB0eXBlICsgJzplcnJvcicpKVxuXG4gIHJldHVybiBsb2dcbn1cblxuZXhwb3J0cy5sb2cgPSB7fVxuXG5leHBvcnRzLmxvZy5kaWFsZXIgPSAoKSA9PiB7XG4gIHJldHVybiBjcmVhdGVMb2dnZXIoJ2RpYWxlclxcdCcpXG59XG5leHBvcnRzLmxvZy5saXN0ZW5lciA9ICgpID0+IHtcbiAgcmV0dXJuIGNyZWF0ZUxvZ2dlcignbGlzdGVuZXJcXHQnKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGhhbmRzaGFrZSA9IHJlcXVpcmUoJ3B1bGwtaGFuZHNoYWtlJylcbmNvbnN0IHB1bGxMUCA9IHJlcXVpcmUoJ3B1bGwtbGVuZ3RoLXByZWZpeGVkJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3Qgd3JpdGVFbmNvZGVkID0gdXRpbC53cml0ZUVuY29kZWRcblxuY29uc3QgZXJyQ29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcbmNvbnN0IHsgZXJyb3JzIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5cbmZ1bmN0aW9uIHNlbGVjdCAobXVsdGljb2RlYywgY2FsbGJhY2ssIGxvZykge1xuICBjb25zdCBzdHJlYW0gPSBoYW5kc2hha2Uoe1xuICAgIHRpbWVvdXQ6IDYwICogMTAwMFxuICB9LCBjYWxsYmFjaylcblxuICBjb25zdCBzaGFrZSA9IHN0cmVhbS5oYW5kc2hha2VcblxuICBsb2coJ3dyaXRpbmcgbXVsdGljb2RlYzogJyArIG11bHRpY29kZWMpXG4gIHdyaXRlRW5jb2RlZChzaGFrZSwgQnVmZmVyLmZyb20obXVsdGljb2RlYyArICdcXG4nKSwgY2FsbGJhY2spXG5cbiAgcHVsbExQLmRlY29kZUZyb21SZWFkZXIoc2hha2UsIChlcnIsIGRhdGEpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIH1cbiAgICBjb25zdCBwcm90b2NvbCA9IGRhdGEudG9TdHJpbmcoKS5zbGljZSgwLCAtMSlcblxuICAgIGlmIChwcm90b2NvbCAhPT0gbXVsdGljb2RlYykge1xuICAgICAgY29uc3QgZXJyID0gZXJyQ29kZShuZXcgRXJyb3IoYFwiJHttdWx0aWNvZGVjfVwiIG5vdCBzdXBwb3J0ZWRgKSwgZXJyb3JzLk1VTFRJQ09ERUNfTk9UX1NVUFBPUlRFRClcblxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgc2hha2UucmVzdCgpKVxuICAgIH1cblxuICAgIGxvZygncmVjZWl2ZWQgYWNrOiAnICsgcHJvdG9jb2wpXG4gICAgY2FsbGJhY2sobnVsbCwgc2hha2UucmVzdCgpKVxuICB9KVxuXG4gIHJldHVybiBzdHJlYW1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZWxlY3RcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwdWxsID0gcmVxdWlyZSgncHVsbC1zdHJlYW0vcHVsbCcpXG5jb25zdCB2YWx1ZXMgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS9zb3VyY2VzL3ZhbHVlcycpXG5jb25zdCBwdWxsTFAgPSByZXF1aXJlKCdwdWxsLWxlbmd0aC1wcmVmaXhlZCcpXG5jb25zdCB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxuXG5mdW5jdGlvbiBsc0hhbmRsZXIgKHNlbGYsIGNvbm4pIHtcbiAgY29uc3QgcHJvdG9zID0gT2JqZWN0LmtleXMoc2VsZi5oYW5kbGVycykuZmlsdGVyKChrZXkpID0+IGtleSAhPT0gJ2xzJylcblxuICBjb25zdCBuUHJvdG9zID0gcHJvdG9zLmxlbmd0aFxuICAvLyB0b3RhbCBzaXplIG9mIHRoZSBsaXN0IG9mIHByb3RvY29scywgaW5jbHVkaW5nIHZhcmludCBhbmQgbmV3bGluZVxuICBjb25zdCBzaXplID0gcHJvdG9zLnJlZHVjZSgoc2l6ZSwgcHJvdG8pID0+IHtcbiAgICBjb25zdCBwID0gQnVmZmVyLmZyb20ocHJvdG8gKyAnXFxuJylcbiAgICBjb25zdCBlbCA9IHZhcmludC5lbmNvZGluZ0xlbmd0aChwLmxlbmd0aClcbiAgICByZXR1cm4gc2l6ZSArIGVsXG4gIH0sIDApXG5cbiAgY29uc3QgYnVmID0gQnVmZmVyLmNvbmNhdChbXG4gICAgQnVmZmVyLmZyb20odmFyaW50LmVuY29kZShuUHJvdG9zKSksXG4gICAgQnVmZmVyLmZyb20odmFyaW50LmVuY29kZShzaXplKSksXG4gICAgQnVmZmVyLmZyb20oJ1xcbicpXG4gIF0pXG5cbiAgY29uc3QgZW5jb2RlZFByb3RvcyA9IHByb3Rvcy5tYXAoKHByb3RvKSA9PiB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHByb3RvICsgJ1xcbicpXG4gIH0pXG5cbiAgcHVsbChcbiAgICB2YWx1ZXMoW2J1Zl0uY29uY2F0KGVuY29kZWRQcm90b3MpKSxcbiAgICBwdWxsTFAuZW5jb2RlKCksXG4gICAgY29ublxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbHNIYW5kbGVyXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgaGFuZHNoYWtlID0gcmVxdWlyZSgncHVsbC1oYW5kc2hha2UnKVxuY29uc3QgbHAgPSByZXF1aXJlKCdwdWxsLWxlbmd0aC1wcmVmaXhlZCcpXG5jb25zdCBDb25uZWN0aW9uID0gcmVxdWlyZSgnaW50ZXJmYWNlLWNvbm5lY3Rpb24nKS5Db25uZWN0aW9uXG5jb25zdCB3cml0ZUVuY29kZWQgPSByZXF1aXJlKCcuLi91dGlsLmpzJykud3JpdGVFbmNvZGVkXG5jb25zdCBzb21lID0gcmVxdWlyZSgnYXN5bmMvc29tZScpXG5cbmZ1bmN0aW9uIHNlbGVjdEhhbmRsZXIgKHJhd0Nvbm4sIGhhbmRsZXJzTWFwLCBsb2cpIHtcbiAgY29uc3QgY2IgPSAoZXJyKSA9PiB7XG4gICAgLy8gaW5jb21pbmcgZXJyb3JzIGFyZSBpcnJlbGV2YW50IGZvciB0aGUgYXBwXG4gICAgbG9nLmVycm9yKGVycilcbiAgfVxuXG4gIGNvbnN0IHN0cmVhbSA9IGhhbmRzaGFrZSh7IHRpbWVvdXQ6IDYwICogMTAwMCB9LCBjYilcbiAgY29uc3Qgc2hha2UgPSBzdHJlYW0uaGFuZHNoYWtlXG5cbiAgbmV4dCgpXG4gIHJldHVybiBzdHJlYW1cblxuICBmdW5jdGlvbiBuZXh0ICgpIHtcbiAgICBscC5kZWNvZGVGcm9tUmVhZGVyKHNoYWtlLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICB9XG4gICAgICBsb2coJ3JlY2VpdmVkOicsIGRhdGEudG9TdHJpbmcoKSlcbiAgICAgIGNvbnN0IHByb3RvY29sID0gZGF0YS50b1N0cmluZygpLnNsaWNlKDAsIC0xKVxuXG4gICAgICBtYXRjaGVyKHByb3RvY29sLCBoYW5kbGVyc01hcCwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleSA9IHJlc3VsdFxuXG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBsb2coJ3NlbmQgYWNrIGJhY2sgb2Y6ICcgKyBwcm90b2NvbClcbiAgICAgICAgICB3cml0ZUVuY29kZWQoc2hha2UsIGRhdGEsIGNiKVxuXG4gICAgICAgICAgY29uc3QgY29ubiA9IG5ldyBDb25uZWN0aW9uKHNoYWtlLnJlc3QoKSwgcmF3Q29ubilcbiAgICAgICAgICBoYW5kbGVyc01hcFtrZXldLmhhbmRsZXJGdW5jKHByb3RvY29sLCBjb25uKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZygnbm90IHN1cHBvcnRlZCBwcm90b2NvbDogJyArIHByb3RvY29sKVxuICAgICAgICAgIHdyaXRlRW5jb2RlZChzaGFrZSwgQnVmZmVyLmZyb20oJ25hXFxuJykpXG4gICAgICAgICAgbmV4dCgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRjaGVyIChwcm90b2NvbCwgaGFuZGxlcnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHN1cHBvcnRlZFByb3RvY29scyA9IE9iamVjdC5rZXlzKGhhbmRsZXJzKVxuICBsZXQgc3VwcG9ydGVkUHJvdG9jb2wgPSBmYWxzZVxuXG4gIHNvbWUoc3VwcG9ydGVkUHJvdG9jb2xzLFxuICAgIChzcCwgY2IpID0+IHtcbiAgICAgIGhhbmRsZXJzW3NwXS5tYXRjaEZ1bmMoc3AsIHByb3RvY29sLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHN1cHBvcnRlZFByb3RvY29sID0gc3BcbiAgICAgICAgfVxuICAgICAgICBjYigpXG4gICAgICB9KVxuICAgIH0sXG4gICAgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuICAgICAgY2FsbGJhY2sobnVsbCwgc3VwcG9ydGVkUHJvdG9jb2wpXG4gICAgfVxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2VsZWN0SGFuZGxlclxuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCBwcm90b2J1ZiA9IHJlcXVpcmUoJ3Byb3RvbnMnKVxubW9kdWxlLmV4cG9ydHMgPSBwcm90b2J1ZihgXG5tZXNzYWdlIENpcmN1aXRSZWxheSB7XG5cbiAgZW51bSBTdGF0dXMge1xuICAgIFNVQ0NFU1MgICAgICAgICAgICAgICAgICAgID0gMTAwO1xuICAgIEhPUF9TUkNfQUREUl9UT09fTE9ORyAgICAgID0gMjIwO1xuICAgIEhPUF9EU1RfQUREUl9UT09fTE9ORyAgICAgID0gMjIxO1xuICAgIEhPUF9TUkNfTVVMVElBRERSX0lOVkFMSUQgID0gMjUwO1xuICAgIEhPUF9EU1RfTVVMVElBRERSX0lOVkFMSUQgID0gMjUxO1xuICAgIEhPUF9OT19DT05OX1RPX0RTVCAgICAgICAgID0gMjYwO1xuICAgIEhPUF9DQU5UX0RJQUxfRFNUICAgICAgICAgID0gMjYxO1xuICAgIEhPUF9DQU5UX09QRU5fRFNUX1NUUkVBTSAgID0gMjYyO1xuICAgIEhPUF9DQU5UX1NQRUFLX1JFTEFZICAgICAgID0gMjcwO1xuICAgIEhPUF9DQU5UX1JFTEFZX1RPX1NFTEYgICAgID0gMjgwO1xuICAgIFNUT1BfU1JDX0FERFJfVE9PX0xPTkcgICAgID0gMzIwO1xuICAgIFNUT1BfRFNUX0FERFJfVE9PX0xPTkcgICAgID0gMzIxO1xuICAgIFNUT1BfU1JDX01VTFRJQUREUl9JTlZBTElEID0gMzUwO1xuICAgIFNUT1BfRFNUX01VTFRJQUREUl9JTlZBTElEID0gMzUxO1xuICAgIFNUT1BfUkVMQVlfUkVGVVNFRCAgICAgICAgID0gMzkwO1xuICAgIE1BTEZPUk1FRF9NRVNTQUdFICAgICAgICAgID0gNDAwO1xuICB9XG5cbiAgZW51bSBUeXBlIHsgLy8gUlBDIGlkZW50aWZpZXIsIGVpdGhlciBIT1AsIFNUT1Agb3IgU1RBVFVTXG4gICAgSE9QID0gMTtcbiAgICBTVE9QID0gMjtcbiAgICBTVEFUVVMgPSAzO1xuICAgIENBTl9IT1AgPSA0O1xuICB9XG5cbiAgbWVzc2FnZSBQZWVyIHtcbiAgICByZXF1aXJlZCBieXRlcyBpZCA9IDE7ICAgIC8vIHBlZXIgaWRcbiAgICByZXBlYXRlZCBieXRlcyBhZGRycyA9IDI7IC8vIHBlZXIncyBrbm93biBhZGRyZXNzZXNcbiAgfVxuXG4gIG9wdGlvbmFsIFR5cGUgdHlwZSA9IDE7ICAgICAvLyBUeXBlIG9mIHRoZSBtZXNzYWdlXG5cbiAgb3B0aW9uYWwgUGVlciBzcmNQZWVyID0gMjsgIC8vIHNyY1BlZXIgYW5kIGRzdFBlZXIgYXJlIHVzZWQgd2hlbiBUeXBlIGlzIEhPUCBvciBTVEFUVVNcbiAgb3B0aW9uYWwgUGVlciBkc3RQZWVyID0gMztcblxuICBvcHRpb25hbCBTdGF0dXMgY29kZSA9IDQ7ICAgLy8gU3RhdHVzIGNvZGUsIHVzZWQgd2hlbiBUeXBlIGlzIFNUQVRVU1xufVxuYClcbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmVsYXk6ICcvbGlicDJwL2NpcmN1aXQvcmVsYXkvMC4xLjAnXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdmFsdWVzID0gcmVxdWlyZSgncHVsbC1zdHJlYW0vc291cmNlcy92YWx1ZXMnKVxuY29uc3QgY29sbGVjdCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtL3NpbmtzL2NvbGxlY3QnKVxuY29uc3QgZW1wdHkgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS9zb3VyY2VzL2VtcHR5JylcbmNvbnN0IHB1bGwgPSByZXF1aXJlKCdwdWxsLXN0cmVhbS9wdWxsJylcbmNvbnN0IGxwID0gcmVxdWlyZSgncHVsbC1sZW5ndGgtcHJlZml4ZWQnKVxuY29uc3QgaGFuZHNoYWtlID0gcmVxdWlyZSgncHVsbC1oYW5kc2hha2UnKVxuXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJylcbmNvbnN0IGxvZyA9IGRlYnVnKCdsaWJwMnA6Y2lyY3VpdDpzdHJlYW0taGFuZGxlcicpXG5sb2cuZXJyID0gZGVidWcoJ2xpYnAycDpjaXJjdWl0OmVycm9yOnN0cmVhbS1oYW5kbGVyJylcblxuY2xhc3MgU3RyZWFtSGFuZGxlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzdHJlYW0gaGFuZGxlciBmb3IgY29ubmVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm4gLSBjb25uZWN0aW9uIHRvIHJlYWQvd3JpdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbnx1bmRlZmluZWR9IGNiIC0gaGFuZHNoYWtlIGNhbGxiYWNrIGNhbGxlZCBvbiBlcnJvclxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZW91dCAtIGhhbmRzaGFrZSB0aW1lb3V0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhMZW5ndGggLSBtYXggYnl0ZXMgbGVuZ3RoIG9mIG1lc3NhZ2VcbiAgICovXG4gIGNvbnN0cnVjdG9yIChjb25uLCBjYiwgdGltZW91dCwgbWF4TGVuZ3RoKSB7XG4gICAgdGhpcy5jb25uID0gY29ublxuICAgIHRoaXMuc3RyZWFtID0gbnVsbFxuICAgIHRoaXMuc2hha2UgPSBudWxsXG4gICAgdGhpcy50aW1lb3V0ID0gY2IgfHwgMTAwMCAqIDYwXG4gICAgdGhpcy5tYXhMZW5ndGggPSBtYXhMZW5ndGggfHwgNDA5NlxuXG4gICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dCB8fCAxMDAwICogNjBcbiAgICB9XG5cbiAgICB0aGlzLnN0cmVhbSA9IGhhbmRzaGFrZSh7IHRpbWVvdXQ6IHRoaXMudGltZW91dCB9LCBjYilcbiAgICB0aGlzLnNoYWtlID0gdGhpcy5zdHJlYW0uaGFuZHNoYWtlXG5cbiAgICBwdWxsKHRoaXMuc3RyZWFtLCBjb25uLCB0aGlzLnN0cmVhbSlcbiAgfVxuXG4gIGlzVmFsaWQgKCkge1xuICAgIHJldHVybiB0aGlzLmNvbm4gJiYgdGhpcy5zaGFrZSAmJiB0aGlzLnN0cmVhbVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYW5kIGRlY29kZSBtZXNzYWdlXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqIEByZXR1cm5zIHt2b2lkfEZ1bmN0aW9ufVxuICAgKi9cbiAgcmVhZCAoY2IpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm4gY2IobmV3IEVycm9yKGBoYW5kbGVyIGlzIG5vdCBpbiBhIHZhbGlkIHN0YXRlYCkpXG4gICAgfVxuXG4gICAgbHAuZGVjb2RlRnJvbVJlYWRlcihcbiAgICAgIHRoaXMuc2hha2UsXG4gICAgICB7IG1heExlbmd0aDogdGhpcy5tYXhMZW5ndGggfSxcbiAgICAgIChlcnIsIG1zZykgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgbG9nLmVycihlcnIpXG4gICAgICAgICAgLy8gdGhpcy5zaGFrZS5hYm9ydChlcnIpXG4gICAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYihudWxsLCBtc2cpXG4gICAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZSBhbmQgd3JpdGUgYXJyYXkgb2YgYnVmZmVyc1xuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcltdfSBtc2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAqL1xuICB3cml0ZSAobXNnLCBjYikge1xuICAgIGNiID0gY2IgfHwgKCgpID0+IHt9KVxuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihgaGFuZGxlciBpcyBub3QgaW4gYSB2YWxpZCBzdGF0ZWApKVxuICAgIH1cblxuICAgIHB1bGwoXG4gICAgICB2YWx1ZXMoW21zZ10pLFxuICAgICAgbHAuZW5jb2RlKCksXG4gICAgICBjb2xsZWN0KChlcnIsIGVuY29kZWQpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGxvZy5lcnIoZXJyKVxuICAgICAgICAgIHRoaXMuc2hha2UuYWJvcnQoZXJyKVxuICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgIH1cblxuICAgICAgICBlbmNvZGVkLmZvckVhY2goKGUpID0+IHRoaXMuc2hha2Uud3JpdGUoZSkpXG4gICAgICAgIGNiKClcbiAgICAgIH0pXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmF3IENvbm5lY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge251bGx8Q29ubmVjdGlvbnwqfVxuICAgKi9cbiAgZ2V0UmF3Q29ubiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29ublxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgaGFuZHNoYWtlIHJlc3Qgc3RyZWFtIGFuZCBpbnZhbGlkYXRlIGhhbmRsZXJcbiAgICpcbiAgICogQHJldHVybiB7Knx7c291cmNlLCBzaW5rfX1cbiAgICovXG4gIHJlc3QgKCkge1xuICAgIGNvbnN0IHJlc3QgPSB0aGlzLnNoYWtlLnJlc3QoKVxuXG4gICAgdGhpcy5jb25uID0gbnVsbFxuICAgIHRoaXMuc3RyZWFtID0gbnVsbFxuICAgIHRoaXMuc2hha2UgPSBudWxsXG4gICAgcmV0dXJuIHJlc3RcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZSB0aGUgc3RyZWFtXG4gICAqXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBjbG9zZSAoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gY2xvc2Ugc3RyZWFtXG4gICAgcHVsbChcbiAgICAgIGVtcHR5KCksXG4gICAgICB0aGlzLnJlc3QoKVxuICAgIClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbUhhbmRsZXJcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdhc3luYy9zZXRJbW1lZGlhdGUnKVxuXG5jb25zdCBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuY29uc3QgQ29ubmVjdGlvbiA9IHJlcXVpcmUoJ2ludGVyZmFjZS1jb25uZWN0aW9uJykuQ29ubmVjdGlvblxuY29uc3QgdXRpbHNGYWN0b3J5ID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBQZWVySW5mbyA9IHJlcXVpcmUoJ3BlZXItaW5mbycpXG5jb25zdCBwcm90byA9IHJlcXVpcmUoJy4uL3Byb3RvY29sJykuQ2lyY3VpdFJlbGF5XG5jb25zdCBzZXJpZXMgPSByZXF1aXJlKCdhc3luYy9zZXJpZXMnKVxuXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJylcblxuY29uc3QgbG9nID0gZGVidWcoJ2xpYnAycDpjaXJjdWl0OnN0b3AnKVxubG9nLmVyciA9IGRlYnVnKCdsaWJwMnA6Y2lyY3VpdDplcnJvcjpzdG9wJylcblxuY2xhc3MgU3RvcCBleHRlbmRzIEVFIHtcbiAgY29uc3RydWN0b3IgKHN3YXJtKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuc3dhcm0gPSBzd2FybVxuICAgIHRoaXMudXRpbHMgPSB1dGlsc0ZhY3Rvcnkoc3dhcm0pXG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHRoZSBpbmNvbWluZyBTVE9QIG1lc3NhZ2VcbiAgICpcbiAgICogQHBhcmFtIHt7fX0gbXNnICAtIHRoZSBwYXJzZWQgcHJvdG9idWYgbWVzc2FnZVxuICAgKiBAcGFyYW0ge1N0cmVhbUhhbmRsZXJ9IHNoICAtIHRoZSBzdHJlYW0gaGFuZGxlciB3cmFwcGVkIGNvbm5lY3Rpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgIC0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGhhbmRsZSAobXNnLCBzaCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8ICgoKSA9PiB7fSlcblxuICAgIHNlcmllcyhbXG4gICAgICAoY2IpID0+IHRoaXMudXRpbHMudmFsaWRhdGVBZGRycyhtc2csIHNoLCBwcm90by5UeXBlLlNUT1AsIGNiKSxcbiAgICAgIChjYikgPT4gdGhpcy51dGlscy53cml0ZVJlc3BvbnNlKHNoLCBwcm90by5TdGF0dXMuU3VjY2VzcywgY2IpXG4gICAgXSwgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICAvLyB3ZSBkb24ndCByZXR1cm4gdGhlIGVycm9yIGhlcmUsXG4gICAgICAgIC8vIHNpbmNlIG11bHRpc3RyZWFtIHNlbGVjdCBkb24ndCBleHBlY3Qgb25lXG4gICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgcmV0dXJuIGxvZyhlcnIpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBlZXJJbmZvID0gbmV3IFBlZXJJbmZvKHRoaXMudXRpbHMucGVlcklkRnJvbUlkKG1zZy5zcmNQZWVyLmlkKSlcbiAgICAgIG1zZy5zcmNQZWVyLmFkZHJzLmZvckVhY2goKGFkZHIpID0+IHBlZXJJbmZvLm11bHRpYWRkcnMuYWRkKGFkZHIpKVxuICAgICAgY29uc3QgbmV3Q29ubiA9IG5ldyBDb25uZWN0aW9uKHNoLnJlc3QoKSlcbiAgICAgIG5ld0Nvbm4uc2V0UGVlckluZm8ocGVlckluZm8pXG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5lbWl0KCdjb25uZWN0aW9uJywgbmV3Q29ubikpXG4gICAgICBjYWxsYmFjayhuZXdDb25uKVxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTdG9wXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcHVsbCA9IHJlcXVpcmUoJ3B1bGwtc3RyZWFtL3B1bGwnKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpXG5jb25zdCBQZWVySW5mbyA9IHJlcXVpcmUoJ3BlZXItaW5mbycpXG5jb25zdCBQZWVySWQgPSByZXF1aXJlKCdwZWVyLWlkJylcbmNvbnN0IEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5jb25zdCBvbmNlID0gcmVxdWlyZSgnb25jZScpXG5jb25zdCB1dGlsc0ZhY3RvcnkgPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IFN0cmVhbUhhbmRsZXIgPSByZXF1aXJlKCcuL3N0cmVhbS1oYW5kbGVyJylcbmNvbnN0IHByb3RvID0gcmVxdWlyZSgnLi4vcHJvdG9jb2wnKS5DaXJjdWl0UmVsYXlcbmNvbnN0IG11bHRpYWRkciA9IHJlcXVpcmUoJ211bHRpYWRkcicpXG5jb25zdCBzZXJpZXMgPSByZXF1aXJlKCdhc3luYy9zZXJpZXMnKVxuY29uc3Qgd2F0ZXJmYWxsID0gcmVxdWlyZSgnYXN5bmMvd2F0ZXJmYWxsJylcbmNvbnN0IHNldEltbWVkaWF0ZSA9IHJlcXVpcmUoJ2FzeW5jL3NldEltbWVkaWF0ZScpXG5cbmNvbnN0IG11bHRpY29kZWMgPSByZXF1aXJlKCcuLy4uL211bHRpY29kZWMnKVxuXG5jb25zdCBsb2cgPSBkZWJ1ZygnbGlicDJwOmNpcmN1aXQ6cmVsYXknKVxubG9nLmVyciA9IGRlYnVnKCdsaWJwMnA6Y2lyY3VpdDplcnJvcjpyZWxheScpXG5cbmNsYXNzIEhvcCBleHRlbmRzIEVFIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIENpcmN1aXQgb2JqZWN0XG4gICAqXG4gICAqIFRoaXMgY2xhc3Mgd2lsbCBoYW5kbGUgaW5jb21pbmcgY2lyY3VpdCBjb25uZWN0aW9ucyBhbmRcbiAgICogZWl0aGVyIHN0YXJ0IGEgcmVsYXkgb3IgaGFuZCB0aGUgcmVsYXllZCBjb25uZWN0aW9uIHRvXG4gICAqIHRoZSBzd2FybVxuICAgKlxuICAgKiBAcGFyYW0ge1N3YXJtfSBzd2FybVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHN3YXJtLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuc3dhcm0gPSBzd2FybVxuICAgIHRoaXMucGVlckluZm8gPSB0aGlzLnN3YXJtLl9wZWVySW5mb1xuICAgIHRoaXMudXRpbHMgPSB1dGlsc0ZhY3Rvcnkoc3dhcm0pXG4gICAgdGhpcy5jb25maWcgPSBvcHRpb25zIHx8IHsgYWN0aXZlOiBmYWxzZSwgZW5hYmxlZDogZmFsc2UgfVxuICAgIHRoaXMuYWN0aXZlID0gdGhpcy5jb25maWcuYWN0aXZlXG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHRoZSByZWxheSBtZXNzYWdlXG4gICAqXG4gICAqIEBwYXJhbSB7Q2lyY3VpdFJlbGF5fSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7U3RyZWFtSGFuZGxlcn0gc2hcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBoYW5kbGUgKG1lc3NhZ2UsIHNoKSB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5lbmFibGVkKSB7XG4gICAgICB0aGlzLnV0aWxzLndyaXRlUmVzcG9uc2UoXG4gICAgICAgIHNoLFxuICAgICAgICBwcm90by5TdGF0dXMuSE9QX0NBTlRfU1BFQUtfUkVMQVkpXG4gICAgICByZXR1cm4gc2guY2xvc2UoKVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIG1lc3NhZ2UgaXMgYENBTl9IT1BgXG4gICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gcHJvdG8uVHlwZS5DQU5fSE9QKSB7XG4gICAgICB0aGlzLnV0aWxzLndyaXRlUmVzcG9uc2UoXG4gICAgICAgIHNoLFxuICAgICAgICBwcm90by5TdGF0dXMuU1VDQ0VTUylcbiAgICAgIHJldHVybiBzaC5jbG9zZSgpXG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyBhIHJlbGF5IHJlcXVlc3QgLSB2YWxpZGF0ZSBhbmQgY3JlYXRlIGEgY2lyY3VpdFxuICAgIGxldCBzcmNQZWVySWQgPSBudWxsXG4gICAgbGV0IGRzdFBlZXJJZCA9IG51bGxcbiAgICB0cnkge1xuICAgICAgc3JjUGVlcklkID0gUGVlcklkLmNyZWF0ZUZyb21CeXRlcyhtZXNzYWdlLnNyY1BlZXIuaWQpLnRvQjU4U3RyaW5nKClcbiAgICAgIGRzdFBlZXJJZCA9IFBlZXJJZC5jcmVhdGVGcm9tQnl0ZXMobWVzc2FnZS5kc3RQZWVyLmlkKS50b0I1OFN0cmluZygpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cuZXJyKGVycilcblxuICAgICAgaWYgKCFzcmNQZWVySWQpIHtcbiAgICAgICAgdGhpcy51dGlscy53cml0ZVJlc3BvbnNlKFxuICAgICAgICAgIHNoLFxuICAgICAgICAgIHByb3RvLlN0YXR1cy5IT1BfU1JDX01VTFRJQUREUl9JTlZBTElEKVxuICAgICAgICByZXR1cm4gc2guY2xvc2UoKVxuICAgICAgfVxuXG4gICAgICBpZiAoIWRzdFBlZXJJZCkge1xuICAgICAgICB0aGlzLnV0aWxzLndyaXRlUmVzcG9uc2UoXG4gICAgICAgICAgc2gsXG4gICAgICAgICAgcHJvdG8uU3RhdHVzLkhPUF9EU1RfTVVMVElBRERSX0lOVkFMSUQpXG4gICAgICAgIHJldHVybiBzaC5jbG9zZSgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNyY1BlZXJJZCA9PT0gZHN0UGVlcklkKSB7XG4gICAgICB0aGlzLnV0aWxzLndyaXRlUmVzcG9uc2UoXG4gICAgICAgIHNoLFxuICAgICAgICBwcm90by5TdGF0dXMuSE9QX0NBTlRfUkVMQVlfVE9fU0VMRilcbiAgICAgIHJldHVybiBzaC5jbG9zZSgpXG4gICAgfVxuXG4gICAgaWYgKCFtZXNzYWdlLmRzdFBlZXIuYWRkcnMubGVuZ3RoKSB7XG4gICAgICAvLyBUT0RPOiB1c2UgZW5jYXBzdWxhdGUgaGVyZVxuICAgICAgY29uc3QgYWRkciA9IG11bHRpYWRkcihgL3AycC1jaXJjdWl0L2lwZnMvJHtkc3RQZWVySWR9YCkuYnVmZmVyXG4gICAgICBtZXNzYWdlLmRzdFBlZXIuYWRkcnMucHVzaChhZGRyKVxuICAgIH1cblxuICAgIGxvZygndHJ5aW5nIHRvIGVzdGFibGlzaCBhIGNpcmN1aXQ6ICVzIDwtPiAlcycsIHNyY1BlZXJJZCwgZHN0UGVlcklkKVxuICAgIGNvbnN0IG5vUGVlciA9ICgpID0+IHtcbiAgICAgIC8vIGxvZy5lcnIoZXJyKVxuICAgICAgdGhpcy51dGlscy53cml0ZVJlc3BvbnNlKFxuICAgICAgICBzaCxcbiAgICAgICAgcHJvdG8uU3RhdHVzLkhPUF9OT19DT05OX1RPX0RTVClcbiAgICAgIHJldHVybiBzaC5jbG9zZSgpXG4gICAgfVxuXG4gICAgY29uc3QgaXNDb25uZWN0ZWQgPSAoY2IpID0+IHtcbiAgICAgIGxldCBkc3RQZWVyXG4gICAgICB0cnkge1xuICAgICAgICBkc3RQZWVyID0gdGhpcy5zd2FybS5fcGVlckJvb2suZ2V0KGRzdFBlZXJJZClcbiAgICAgICAgaWYgKCFkc3RQZWVyLmlzQ29ubmVjdGVkKCkgJiYgIXRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBObyBDb25uZWN0aW9uIHRvIHBlZXIgJHtkc3RQZWVySWR9YClcbiAgICAgICAgICBub1BlZXIoZXJyKVxuICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgbm9QZWVyKGVycilcbiAgICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYigpXG4gICAgfVxuXG4gICAgc2VyaWVzKFtcbiAgICAgIChjYikgPT4gdGhpcy51dGlscy52YWxpZGF0ZUFkZHJzKG1lc3NhZ2UsIHNoLCBwcm90by5UeXBlLkhPUCwgY2IpLFxuICAgICAgKGNiKSA9PiBpc0Nvbm5lY3RlZChjYiksXG4gICAgICAoY2IpID0+IHRoaXMuX2NpcmN1aXQoc2gsIG1lc3NhZ2UsIGNiKVxuICAgIF0sIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgbG9nLmVycihlcnIpXG4gICAgICAgIHNoLmNsb3NlKClcbiAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLmVtaXQoJ2NpcmN1aXQ6ZXJyb3InLCBlcnIpKVxuICAgICAgfVxuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuZW1pdCgnY2lyY3VpdDpzdWNjZXNzJykpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25uZWN0IHRvIFNUT1BcbiAgICpcbiAgICogQHBhcmFtIHtQZWVySW5mb30gcGVlclxuICAgKiBAcGFyYW0ge1N0cmVhbUhhbmRsZXJ9IHNyY1NoXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgX2Nvbm5lY3RUb1N0b3AgKHBlZXIsIHNyY1NoLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2RpYWxQZWVyKHBlZXIsIChlcnIsIGRzdENvbm4pID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy51dGlscy53cml0ZVJlc3BvbnNlKFxuICAgICAgICAgIHNyY1NoLFxuICAgICAgICAgIHByb3RvLlN0YXR1cy5IT1BfQ0FOVF9ESUFMX0RTVClcbiAgICAgICAgbG9nLmVycihlcnIpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnV0aWxzLndyaXRlUmVzcG9uc2UoXG4gICAgICAgIHNyY1NoLFxuICAgICAgICBwcm90by5TdGF0dXMuU1VDQ0VTUyxcbiAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGxvZy5lcnIoZXJyKVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGRzdENvbm4pXG4gICAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBOZWdvdGlhdGUgU1RPUFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmVhbUhhbmRsZXJ9IGRzdFNoXG4gICAqIEBwYXJhbSB7U3RyZWFtSGFuZGxlcn0gc3JjU2hcbiAgICogQHBhcmFtIHtDaXJjdWl0UmVsYXl9IG1lc3NhZ2VcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBfbmVnb3RpYXRlU3RvcCAoZHN0U2gsIHNyY1NoLCBtZXNzYWdlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHN0b3BNc2cgPSBPYmplY3QuYXNzaWduKHt9LCBtZXNzYWdlLCB7XG4gICAgICB0eXBlOiBwcm90by5UeXBlLlNUT1AgLy8gY2hhbmdlIHRoZSBtZXNzYWdlIHR5cGVcbiAgICB9KVxuICAgIGRzdFNoLndyaXRlKHByb3RvLmVuY29kZShzdG9wTXNnKSxcbiAgICAgIChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHRoaXMudXRpbHMud3JpdGVSZXNwb25zZShcbiAgICAgICAgICAgIHNyY1NoLFxuICAgICAgICAgICAgcHJvdG8uU3RhdHVzLkhPUF9DQU5UX09QRU5fRFNUX1NUUkVBTSlcbiAgICAgICAgICBsb2cuZXJyKGVycilcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVhZCByZXNwb25zZSBmcm9tIFNUT1BcbiAgICAgICAgZHN0U2gucmVhZCgoZXJyLCBtc2cpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBsb2cuZXJyKGVycilcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHByb3RvLmRlY29kZShtc2cpXG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY29kZSAhPT0gcHJvdG8uU3RhdHVzLlNVQ0NFU1MpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoYFVuYWJsZSB0byBjcmVhdGUgY2lyY3VpdCFgKSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbXNnKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIG1ha2UgYSBjaXJjdWl0IGZyb20gQSA8LT4gUiA8LT4gQiB3aGVyZSBSIGlzIHRoaXMgcmVsYXlcbiAgICpcbiAgICogQHBhcmFtIHtTdHJlYW1IYW5kbGVyfSBzcmNTaCAtIHRoZSBzb3VyY2Ugc3RyZWFtIGhhbmRsZXJcbiAgICogQHBhcmFtIHtDaXJjdWl0UmVsYXl9IG1lc3NhZ2UgLSB0aGUgbWVzc2FnZSB3aXRoIHRoZSBzcmMgYW5kIGRzdCBlbnRyaWVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gY2FsbGJhY2sgdG8gc2lnbmFsIHN1Y2Nlc3Mgb3IgZmFpbHVyZVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jaXJjdWl0IChzcmNTaCwgbWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICBsZXQgZHN0U2ggPSBudWxsXG4gICAgd2F0ZXJmYWxsKFtcbiAgICAgIChjYikgPT4gdGhpcy5fY29ubmVjdFRvU3RvcChtZXNzYWdlLmRzdFBlZXIsIHNyY1NoLCBjYiksXG4gICAgICAoX2RzdENvbm4sIGNiKSA9PiB7XG4gICAgICAgIGRzdFNoID0gbmV3IFN0cmVhbUhhbmRsZXIoX2RzdENvbm4pXG4gICAgICAgIHRoaXMuX25lZ290aWF0ZVN0b3AoZHN0U2gsIHNyY1NoLCBtZXNzYWdlLCBjYilcbiAgICAgIH1cbiAgICBdLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIC8vIGNsb3NlL2VuZCB0aGUgc291cmNlIHN0cmVhbSBpZiB0aGVyZSB3YXMgYW4gZXJyb3JcbiAgICAgICAgaWYgKHNyY1NoKSB7XG4gICAgICAgICAgc3JjU2guY2xvc2UoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRzdFNoKSB7XG4gICAgICAgICAgZHN0U2guY2xvc2UoKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNyYyA9IHNyY1NoLnJlc3QoKVxuICAgICAgY29uc3QgZHN0ID0gZHN0U2gucmVzdCgpXG5cbiAgICAgIGNvbnN0IHNyY0lkU3RyID0gUGVlcklkLmNyZWF0ZUZyb21CeXRlcyhtZXNzYWdlLnNyY1BlZXIuaWQpLnRvQjU4U3RyaW5nKClcbiAgICAgIGNvbnN0IGRzdElkU3RyID0gUGVlcklkLmNyZWF0ZUZyb21CeXRlcyhtZXNzYWdlLmRzdFBlZXIuaWQpLnRvQjU4U3RyaW5nKClcblxuICAgICAgLy8gY2lyY3VpdCB0aGUgc3JjIGFuZCBkc3Qgc3RyZWFtc1xuICAgICAgcHVsbChcbiAgICAgICAgc3JjLFxuICAgICAgICBkc3QsXG4gICAgICAgIHNyY1xuICAgICAgKVxuICAgICAgbG9nKCdjaXJjdWl0ICVzIDwtPiAlcyBlc3RhYmxpc2hlZCcsIHNyY0lkU3RyLCBkc3RJZFN0cilcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIERpYWwgdGhlIGRlc3QgcGVlciBhbmQgY3JlYXRlIGEgY2lyY3VpdFxuICAgKlxuICAgKiBAcGFyYW0ge011bHRpYWRkcn0gZHN0UGVlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kaWFsUGVlciAoZHN0UGVlciwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBwZWVySW5mbyA9IG5ldyBQZWVySW5mbyhQZWVySWQuY3JlYXRlRnJvbUJ5dGVzKGRzdFBlZXIuaWQpKVxuICAgIGRzdFBlZXIuYWRkcnMuZm9yRWFjaCgoYSkgPT4gcGVlckluZm8ubXVsdGlhZGRycy5hZGQoYSkpXG4gICAgdGhpcy5zd2FybS5kaWFsKHBlZXJJbmZvLCBtdWx0aWNvZGVjLnJlbGF5LCBvbmNlKChlcnIsIGNvbm4pID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgbG9nLmVycihlcnIpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGNvbm4pXG4gICAgfSkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIb3BcbiIsIid1c2Ugc3RyaWN0J1xuXG4vLyBKUyB0cmVhdHMgc3ViamVjdHMgb2YgYml0d2lzZSBvcGVyYXRvcnMgYXMgU0lHTkVEIDMyIGJpdCBudW1iZXJzLFxuLy8gd2hpY2ggbWVhbnMgdGhlIG1heGltdW0gYW1vdW50IG9mIGJpdHMgd2UgY2FuIHN0b3JlIGluc2lkZSBlYWNoIGJ5dGVcbi8vIGlzIDcuLlxuY29uc3QgQklUU19QRVJfQllURSA9IDdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBTcGFyc2VBcnJheSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLl9iaXRBcnJheXMgPSBbXVxuICAgIHRoaXMuX2RhdGEgPSBbXVxuICAgIHRoaXMuX2xlbmd0aCA9IDBcbiAgICB0aGlzLl9jaGFuZ2VkTGVuZ3RoID0gZmFsc2VcbiAgICB0aGlzLl9jaGFuZ2VkRGF0YSA9IGZhbHNlXG4gIH1cblxuICBzZXQgKGluZGV4LCB2YWx1ZSkge1xuICAgIGxldCBwb3MgPSB0aGlzLl9pbnRlcm5hbFBvc2l0aW9uRm9yKGluZGV4LCBmYWxzZSlcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gdW5zZXR0aW5nXG4gICAgICBpZiAocG9zICE9PSAtMSkge1xuICAgICAgICAvLyByZW1vdmUgaXRlbSBmcm9tIGJpdCBhcnJheSBhbmQgYXJyYXkgaXRzZWxmXG4gICAgICAgIHRoaXMuX3Vuc2V0SW50ZXJuYWxQb3MocG9zKVxuICAgICAgICB0aGlzLl91bnNldEJpdChpbmRleClcbiAgICAgICAgdGhpcy5fY2hhbmdlZExlbmd0aCA9IHRydWVcbiAgICAgICAgdGhpcy5fY2hhbmdlZERhdGEgPSB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBuZWVkc1NvcnQgPSBmYWxzZVxuICAgICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgICAgcG9zID0gdGhpcy5fZGF0YS5sZW5ndGhcbiAgICAgICAgdGhpcy5fc2V0Qml0KGluZGV4KVxuICAgICAgICB0aGlzLl9jaGFuZ2VkRGF0YSA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5lZWRzU29ydCA9IHRydWVcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldEludGVybmFsUG9zKHBvcywgaW5kZXgsIHZhbHVlLCBuZWVkc1NvcnQpXG4gICAgICB0aGlzLl9jaGFuZ2VkTGVuZ3RoID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHVuc2V0IChpbmRleCkge1xuICAgIHRoaXMuc2V0KGluZGV4LCB1bmRlZmluZWQpXG4gIH1cblxuICBnZXQgKGluZGV4KSB7XG4gICAgdGhpcy5fc29ydERhdGEoKVxuICAgIGNvbnN0IHBvcyA9IHRoaXMuX2ludGVybmFsUG9zaXRpb25Gb3IoaW5kZXgsIHRydWUpXG4gICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFbcG9zXVsxXVxuICB9XG5cbiAgcHVzaCAodmFsdWUpIHtcbiAgICB0aGlzLnNldCh0aGlzLmxlbmd0aCwgdmFsdWUpXG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoXG4gIH1cblxuICBnZXQgbGVuZ3RoICgpIHtcbiAgICB0aGlzLl9zb3J0RGF0YSgpXG4gICAgaWYgKHRoaXMuX2NoYW5nZWRMZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxhc3QgPSB0aGlzLl9kYXRhW3RoaXMuX2RhdGEubGVuZ3RoIC0gMV1cbiAgICAgIHRoaXMuX2xlbmd0aCA9IGxhc3QgPyBsYXN0WzBdICsgMSA6IDBcbiAgICAgIHRoaXMuX2NoYW5nZWRMZW5ndGggPSBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbGVuZ3RoXG4gIH1cblxuICBmb3JFYWNoIChpdGVyYXRvcikge1xuICAgIGxldCBpID0gMFxuICAgIHdoaWxlKGkgPCB0aGlzLmxlbmd0aCkge1xuICAgICAgaXRlcmF0b3IodGhpcy5nZXQoaSksIGksIHRoaXMpXG4gICAgICBpKytcbiAgICB9XG4gIH1cblxuICBtYXAgKGl0ZXJhdG9yKSB7XG4gICAgbGV0IGkgPSAwXG4gICAgbGV0IG1hcHBlZCA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgICB3aGlsZShpIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgIG1hcHBlZFtpXSA9IGl0ZXJhdG9yKHRoaXMuZ2V0KGkpLCBpLCB0aGlzKVxuICAgICAgaSsrXG4gICAgfVxuICAgIHJldHVybiBtYXBwZWRcbiAgfVxuXG4gIHJlZHVjZSAocmVkdWNlciwgaW5pdGlhbFZhbHVlKSB7XG4gICAgbGV0IGkgPSAwXG4gICAgbGV0IGFjYyA9IGluaXRpYWxWYWx1ZVxuICAgIHdoaWxlKGkgPCB0aGlzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldChpKVxuICAgICAgYWNjID0gcmVkdWNlcihhY2MsIHZhbHVlLCBpKVxuICAgICAgaSsrXG4gICAgfVxuICAgIHJldHVybiBhY2NcbiAgfVxuXG4gIGZpbmQgKGZpbmRlcikge1xuICAgIGxldCBpID0gMCwgZm91bmQsIGxhc3RcbiAgICB3aGlsZSAoKGkgPCB0aGlzLmxlbmd0aCkgJiYgIWZvdW5kKSB7XG4gICAgICBsYXN0ID0gdGhpcy5nZXQoaSlcbiAgICAgIGZvdW5kID0gZmluZGVyKGxhc3QpXG4gICAgICBpKytcbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kID8gbGFzdCA6IHVuZGVmaW5lZFxuICB9XG5cbiAgX2ludGVybmFsUG9zaXRpb25Gb3IgKGluZGV4LCBub0NyZWF0ZSkge1xuICAgIGNvbnN0IGJ5dGVQb3MgPSB0aGlzLl9ieXRlUG9zRm9yKGluZGV4LCBub0NyZWF0ZSlcbiAgICBpZiAoYnl0ZVBvcyA+PSB0aGlzLl9iaXRBcnJheXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgY29uc3QgYnl0ZSA9IHRoaXMuX2JpdEFycmF5c1tieXRlUG9zXVxuICAgIGNvbnN0IGJpdFBvcyA9IGluZGV4IC0gYnl0ZVBvcyAqIEJJVFNfUEVSX0JZVEVcbiAgICBjb25zdCBleGlzdHMgPSAoYnl0ZSAmICgxIDw8IGJpdFBvcykpID4gMFxuICAgIGlmICghZXhpc3RzKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgY29uc3QgcHJldmlvdXNQb3BDb3VudCA9IHRoaXMuX2JpdEFycmF5cy5zbGljZSgwLCBieXRlUG9zKS5yZWR1Y2UocG9wQ291bnRSZWR1Y2UsIDApXG5cbiAgICBjb25zdCBtYXNrID0gfigweGZmZmZmZmZmIDw8IChiaXRQb3MgKyAxKSlcbiAgICBjb25zdCBieXRlUG9wQ291bnQgPSBwb3BDb3VudChieXRlICYgbWFzaylcbiAgICBjb25zdCBhcnJheVBvcyA9IHByZXZpb3VzUG9wQ291bnQgKyBieXRlUG9wQ291bnQgLSAxXG4gICAgcmV0dXJuIGFycmF5UG9zXG4gIH1cblxuICBfYnl0ZVBvc0ZvciAoaW5kZXgsIG5vQ3JlYXRlKSB7XG4gICAgY29uc3QgYnl0ZVBvcyA9IE1hdGguZmxvb3IoaW5kZXggLyBCSVRTX1BFUl9CWVRFKVxuICAgIGNvbnN0IHRhcmdldExlbmd0aCA9IGJ5dGVQb3MgKyAxXG4gICAgd2hpbGUgKCFub0NyZWF0ZSAmJiB0aGlzLl9iaXRBcnJheXMubGVuZ3RoIDwgdGFyZ2V0TGVuZ3RoKSB7XG4gICAgICB0aGlzLl9iaXRBcnJheXMucHVzaCgwKVxuICAgIH1cbiAgICByZXR1cm4gYnl0ZVBvc1xuICB9XG5cbiAgX3NldEJpdCAoaW5kZXgpIHtcbiAgICBjb25zdCBieXRlUG9zID0gdGhpcy5fYnl0ZVBvc0ZvcihpbmRleCwgZmFsc2UpXG4gICAgdGhpcy5fYml0QXJyYXlzW2J5dGVQb3NdIHw9ICgxIDw8IChpbmRleCAtIChieXRlUG9zICogQklUU19QRVJfQllURSkpKVxuICB9XG5cbiAgX3Vuc2V0Qml0KGluZGV4KSB7XG4gICAgY29uc3QgYnl0ZVBvcyA9IHRoaXMuX2J5dGVQb3NGb3IoaW5kZXgsIGZhbHNlKVxuICAgIHRoaXMuX2JpdEFycmF5c1tieXRlUG9zXSAmPSB+KDEgPDwgKGluZGV4IC0gKGJ5dGVQb3MgKiBCSVRTX1BFUl9CWVRFKSkpXG4gIH1cblxuICBfc2V0SW50ZXJuYWxQb3MocG9zLCBpbmRleCwgdmFsdWUsIG5lZWRzU29ydCkge1xuICAgIGNvbnN0IGRhdGEgPXRoaXMuX2RhdGFcbiAgICBjb25zdCBlbGVtID0gW2luZGV4LCB2YWx1ZV1cbiAgICBpZiAobmVlZHNTb3J0KSB7XG4gICAgICB0aGlzLl9zb3J0RGF0YSgpXG4gICAgICBkYXRhW3Bvc10gPSBlbGVtXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5ldyBlbGVtZW50LiBqdXN0IHNob3ZlIGl0IGludG8gdGhlIGFycmF5XG4gICAgICAvLyBidXQgYmUgbmljZSBhYm91dCB3aGVyZSB3ZSBzaG92ZSBpdFxuICAgICAgLy8gaW4gb3JkZXIgdG8gbWFrZSBzb3J0aW5nIGl0IGxhdGVyIGVhc2llclxuICAgICAgaWYgKGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGlmIChkYXRhW2RhdGEubGVuZ3RoIC0gMV1bMF0gPj0gaW5kZXgpIHtcbiAgICAgICAgICBkYXRhLnB1c2goZWxlbSlcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhWzBdWzBdIDw9IGluZGV4KSB7XG4gICAgICAgICAgZGF0YS51bnNoaWZ0KGVsZW0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcmFuZG9tSW5kZXggPSBNYXRoLnJvdW5kKGRhdGEubGVuZ3RoIC8gMilcbiAgICAgICAgICB0aGlzLl9kYXRhID0gZGF0YS5zbGljZSgwLCByYW5kb21JbmRleCkuY29uY2F0KGVsZW0pLmNvbmNhdChkYXRhLnNsaWNlKHJhbmRvbUluZGV4KSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZGF0YS5wdXNoKGVsZW0pXG4gICAgICB9XG4gICAgICB0aGlzLl9jaGFuZ2VkRGF0YSA9IHRydWVcbiAgICAgIHRoaXMuX2NoYW5nZWRMZW5ndGggPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgX3Vuc2V0SW50ZXJuYWxQb3MgKHBvcykge1xuICAgIHRoaXMuX2RhdGEuc3BsaWNlKHBvcywgMSlcbiAgfVxuXG4gIF9zb3J0RGF0YSAoKSB7XG4gICAgaWYgKHRoaXMuX2NoYW5nZWREYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhLnNvcnQoc29ydEludGVybmFsKVxuICAgIH1cblxuICAgIHRoaXMuX2NoYW5nZWREYXRhID0gZmFsc2VcbiAgfVxuXG4gIGJpdEZpZWxkICgpIHtcbiAgICBjb25zdCBieXRlcyA9IFtdXG4gICAgbGV0IHBlbmRpbmdCaXRzRm9yUmVzdWx0aW5nQnl0ZSA9IDhcbiAgICBsZXQgcGVuZGluZ0JpdHNGb3JOZXdCeXRlID0gMFxuICAgIGxldCByZXN1bHRpbmdCeXRlID0gMFxuICAgIGxldCBuZXdCeXRlXG4gICAgY29uc3QgcGVuZGluZyA9IHRoaXMuX2JpdEFycmF5cy5zbGljZSgpXG4gICAgd2hpbGUgKHBlbmRpbmcubGVuZ3RoIHx8IHBlbmRpbmdCaXRzRm9yTmV3Qnl0ZSkge1xuICAgICAgaWYgKHBlbmRpbmdCaXRzRm9yTmV3Qnl0ZSA9PT0gMCkge1xuICAgICAgICBuZXdCeXRlID0gcGVuZGluZy5zaGlmdCgpXG4gICAgICAgIHBlbmRpbmdCaXRzRm9yTmV3Qnl0ZSA9IDdcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXNpbmdCaXRzID0gTWF0aC5taW4ocGVuZGluZ0JpdHNGb3JOZXdCeXRlLCBwZW5kaW5nQml0c0ZvclJlc3VsdGluZ0J5dGUpXG4gICAgICBjb25zdCBtYXNrID0gfigwYjExMTExMTExIDw8IHVzaW5nQml0cylcbiAgICAgIGNvbnN0IG1hc2tlZCA9IG5ld0J5dGUgJiBtYXNrXG4gICAgICByZXN1bHRpbmdCeXRlIHw9IG1hc2tlZCA8PCAoOCAtIHBlbmRpbmdCaXRzRm9yUmVzdWx0aW5nQnl0ZSlcbiAgICAgIG5ld0J5dGUgPSBuZXdCeXRlID4+PiB1c2luZ0JpdHNcbiAgICAgIHBlbmRpbmdCaXRzRm9yTmV3Qnl0ZSAtPSB1c2luZ0JpdHNcbiAgICAgIHBlbmRpbmdCaXRzRm9yUmVzdWx0aW5nQnl0ZSAtPSB1c2luZ0JpdHNcblxuICAgICAgaWYgKCFwZW5kaW5nQml0c0ZvclJlc3VsdGluZ0J5dGUgfHwgKCFwZW5kaW5nQml0c0Zvck5ld0J5dGUgJiYgIXBlbmRpbmcubGVuZ3RoKSkge1xuICAgICAgICBieXRlcy5wdXNoKHJlc3VsdGluZ0J5dGUpXG4gICAgICAgIHJlc3VsdGluZ0J5dGUgPSAwXG4gICAgICAgIHBlbmRpbmdCaXRzRm9yUmVzdWx0aW5nQnl0ZSA9IDhcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgemVyb2VzXG4gICAgZm9yKHZhciBpID0gYnl0ZXMubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBieXRlc1tpXVxuICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgIGJ5dGVzLnBvcCgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBieXRlc1xuICB9XG5cbiAgY29tcGFjdEFycmF5ICgpIHtcbiAgICB0aGlzLl9zb3J0RGF0YSgpXG4gICAgcmV0dXJuIHRoaXMuX2RhdGEubWFwKHZhbHVlT25seSlcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BDb3VudFJlZHVjZSAoY291bnQsIGJ5dGUpIHtcbiAgcmV0dXJuIGNvdW50ICsgcG9wQ291bnQoYnl0ZSlcbn1cblxuZnVuY3Rpb24gcG9wQ291bnQoX3YpIHtcbiAgbGV0IHYgPSBfdlxuICB2ID0gdiAtICgodiA+PiAxKSAmIDB4NTU1NTU1NTUpICAgICAgICAgICAgICAgICAgICAvLyByZXVzZSBpbnB1dCBhcyB0ZW1wb3JhcnlcbiAgdiA9ICh2ICYgMHgzMzMzMzMzMykgKyAoKHYgPj4gMikgJiAweDMzMzMzMzMzKSAgICAgLy8gdGVtcFxuICByZXR1cm4gKCh2ICsgKHYgPj4gNCkgJiAweEYwRjBGMEYpICogMHgxMDEwMTAxKSA+PiAyNFxufVxuXG5mdW5jdGlvbiBzb3J0SW50ZXJuYWwgKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gLSBiWzBdXG59XG5cbmZ1bmN0aW9uIHZhbHVlT25seSAoZWxlbSkge1xuICByZXR1cm4gZWxlbVsxXVxufSIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBDb25zdW1hYmxlQnVmZmVyID0gcmVxdWlyZSgnLi9jb25zdW1hYmxlLWJ1ZmZlcicpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd3JhcEhhc2ggKGhhc2hGbikge1xuICByZXR1cm4gZnVuY3Rpb24gaGFzaGluZyAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbmZpbml0ZUhhc2gpIHtcbiAgICAgIC8vIGFscmVhZHkgYSBoYXNoLiByZXR1cm4gaXRcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IEluZmluaXRlSGFzaCh2YWx1ZSwgaGFzaEZuKVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBJbmZpbml0ZUhhc2gge1xuICBjb25zdHJ1Y3RvciAodmFsdWUsIGhhc2hGbikge1xuICAgIGlmICgodHlwZW9mIHZhbHVlKSAhPT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2FuIG9ubHkgaGFzaCBzdHJpbmdzIG9yIGJ1ZmZlcnMnKVxuICAgIH1cbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlXG4gICAgdGhpcy5faGFzaEZuID0gaGFzaEZuXG4gICAgdGhpcy5fZGVwdGggPSAtMVxuICAgIHRoaXMuX2F2YWlsYWJsZUJpdHMgPSAwXG4gICAgdGhpcy5fY3VycmVudEJ1ZmZlckluZGV4ID0gMFxuICAgIHRoaXMuX2J1ZmZlcnMgPSBbXVxuICB9XG5cbiAgYXN5bmMgdGFrZSAoYml0cykge1xuICAgIGxldCBwZW5kaW5nQml0cyA9IGJpdHNcblxuICAgIHdoaWxlICh0aGlzLl9hdmFpbGFibGVCaXRzIDwgcGVuZGluZ0JpdHMpIHtcbiAgICAgIGF3YWl0IHRoaXMuX3Byb2R1Y2VNb3JlQml0cygpXG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9IDBcblxuICAgIHdoaWxlIChwZW5kaW5nQml0cyA+IDApIHtcbiAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLl9idWZmZXJzW3RoaXMuX2N1cnJlbnRCdWZmZXJJbmRleF1cbiAgICAgIGNvbnN0IGF2YWlsYWJsZSA9IE1hdGgubWluKGhhc2guYXZhaWxhYmxlQml0cygpLCBwZW5kaW5nQml0cylcbiAgICAgIGNvbnN0IHRvb2sgPSBoYXNoLnRha2UoYXZhaWxhYmxlKVxuICAgICAgcmVzdWx0ID0gKHJlc3VsdCA8PCBhdmFpbGFibGUpICsgdG9va1xuICAgICAgcGVuZGluZ0JpdHMgLT0gYXZhaWxhYmxlXG4gICAgICB0aGlzLl9hdmFpbGFibGVCaXRzIC09IGF2YWlsYWJsZVxuXG4gICAgICBpZiAoaGFzaC5hdmFpbGFibGVCaXRzKCkgPT09IDApIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJ1ZmZlckluZGV4KytcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICB1bnRha2UgKGJpdHMpIHtcbiAgICBsZXQgcGVuZGluZ0JpdHMgPSBiaXRzXG5cbiAgICB3aGlsZSAocGVuZGluZ0JpdHMgPiAwKSB7XG4gICAgICBjb25zdCBoYXNoID0gdGhpcy5fYnVmZmVyc1t0aGlzLl9jdXJyZW50QnVmZmVySW5kZXhdXG4gICAgICBjb25zdCBhdmFpbGFibGVGb3JVbnRha2UgPSBNYXRoLm1pbihoYXNoLnRvdGFsQml0cygpIC0gaGFzaC5hdmFpbGFibGVCaXRzKCksIHBlbmRpbmdCaXRzKVxuICAgICAgaGFzaC51bnRha2UoYXZhaWxhYmxlRm9yVW50YWtlKVxuICAgICAgcGVuZGluZ0JpdHMgLT0gYXZhaWxhYmxlRm9yVW50YWtlXG4gICAgICB0aGlzLl9hdmFpbGFibGVCaXRzICs9IGF2YWlsYWJsZUZvclVudGFrZVxuXG4gICAgICBpZiAodGhpcy5fY3VycmVudEJ1ZmZlckluZGV4ID4gMCAmJiBoYXNoLnRvdGFsQml0cygpID09PSBoYXNoLmF2YWlsYWJsZUJpdHMoKSkge1xuICAgICAgICB0aGlzLl9kZXB0aC0tXG4gICAgICAgIHRoaXMuX2N1cnJlbnRCdWZmZXJJbmRleC0tXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX3Byb2R1Y2VNb3JlQml0cyAoKSB7XG4gICAgdGhpcy5fZGVwdGgrK1xuXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLl9kZXB0aCA/IHRoaXMuX3ZhbHVlICsgdGhpcy5fZGVwdGggOiB0aGlzLl92YWx1ZVxuICAgIGNvbnN0IGhhc2hWYWx1ZSA9IGF3YWl0IHRoaXMuX2hhc2hGbih2YWx1ZSlcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQ29uc3VtYWJsZUJ1ZmZlcihoYXNoVmFsdWUpXG5cbiAgICB0aGlzLl9idWZmZXJzLnB1c2goYnVmZmVyKVxuICAgIHRoaXMuX2F2YWlsYWJsZUJpdHMgKz0gYnVmZmVyLmF2YWlsYWJsZUJpdHMoKVxuICB9XG59XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuZXhwb3J0cy5maW5pc2hlZCA9IHJlcXVpcmUoJy4vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qcycpO1xuZXhwb3J0cy5waXBlbGluZSA9IHJlcXVpcmUoJy4vbGliL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUuanMnKTtcbiIsIi8qKlxuICogUmFiaW4gZmluZ2VycHJpbnRpbmdcbiAqXG4gKiBAY2xhc3MgUmFiaW5cbiAqL1xuY2xhc3MgUmFiaW4ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmFiaW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtiaXRzPTEyXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWluPTggKiAxMDI0XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4PTMyICogMTAyNF1cbiAgICAgKiBAcGFyYW0geyBfX2ltcG9ydF9fKFwiLi8uLi9kaXN0L3JhYmluXCIpLmRlZmF1bHQgfSBhc01vZHVsZVxuICAgICAqIEBtZW1iZXJvZiBSYWJpblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGJpdHMgPSAxMiwgbWluID0gOCAqIDEwMjQsIG1heCA9IDMyICogMTAyNCwgd2luZG93U2l6ZSA9IDY0LCBhc01vZHVsZSkge1xuICAgICAgICB0aGlzLmJpdHMgPSBiaXRzXG4gICAgICAgIHRoaXMubWluID0gbWluXG4gICAgICAgIHRoaXMubWF4ID0gbWF4XG4gICAgICAgIHRoaXMuYXNNb2R1bGUgPSBhc01vZHVsZVxuICAgICAgICB0aGlzLnJhYmluID0gbmV3IGFzTW9kdWxlLlJhYmluKGJpdHMsIG1pbiwgbWF4LCB3aW5kb3dTaXplKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmdlcnByaW50cyB0aGUgYnVmZmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fVxuICAgICAqIEBtZW1iZXJvZiBSYWJpblxuICAgICAqL1xuICAgIGZpbmdlcnByaW50KGJ1Zikge1xuICAgICAgICBjb25zdCBsZW5ndGhzID0gbmV3IEludDMyQXJyYXkoTWF0aC5jZWlsKGJ1Zi5sZW5ndGgvdGhpcy5taW4pKVxuICAgICAgICBjb25zdCBsZW5ndGhzUHRyID0gdGhpcy5hc01vZHVsZS5uZXdBcnJheShsZW5ndGhzKVxuICAgICAgICBjb25zdCBwb2ludGVyID0gdGhpcy5hc01vZHVsZS5uZXdBcnJheShidWYpXG5cbiAgICAgICAgLy8gcnVuIGZpbmRlcnByaW50XG4gICAgICAgIHRoaXMucmFiaW4uZmluZ2VycHJpbnQocG9pbnRlciwgbGVuZ3Roc1B0cilcblxuICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSB0aGlzLmFzTW9kdWxlLmdldEFycmF5KEludDMyQXJyYXksIGxlbmd0aHNQdHIpXG5cbiAgICAgICAgLy9mcmVlIG1lbW9yeVxuICAgICAgICB0aGlzLmFzTW9kdWxlLmZyZWVBcnJheShsZW5ndGhzUHRyKVxuICAgICAgICB0aGlzLmFzTW9kdWxlLmZyZWVBcnJheShwb2ludGVyKVxuXG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzLiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9pcGZzL2pzLWlwZnMvaXNzdWVzLzIxMTgjaXNzdWVjb21tZW50LTQ5NzcyMjYyNVxuICAgICAgICAvLyBjbGVhbiBleHRyYSAwcyBpbiB0aGUgYXJyYXlcbiAgICAgICAgY29uc3QgY2xlYW5BcnIgPSBbXVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb2Nlc3NlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYocHJvY2Vzc2VkW2ldID09PSAwKSBicmVha1xuICAgICAgICAgICAgY2xlYW5BcnJbaV0gPSBwcm9jZXNzZWRbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xlYW5BcnJcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmFiaW4iLCJcbmNvbnN0IHsgaW5zdGFudGlhdGVTdHJlYW1pbmcgfSA9IHJlcXVpcmUoXCJhc3NlbWJseXNjcmlwdC9saWIvbG9hZGVyXCIpO1xuXG5sb2FkV2ViQXNzZW1ibHkuc3VwcG9ydGVkID0gdHlwZW9mIFdlYkFzc2VtYmx5ICE9PSAndW5kZWZpbmVkJ1xuXG5mdW5jdGlvbiBsb2FkV2ViQXNzZW1ibHkgKGltcCA9IHt9KSB7XG4gIGlmICghbG9hZFdlYkFzc2VtYmx5LnN1cHBvcnRlZCkgcmV0dXJuIG51bGxcbiAgXG4gIHZhciB3YXNtID0gbmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsOTAsMTYsOTYsMCwwLDk2LDIsMTI3LDEyNywxLDEyNyw5Niw0LDEyNywxMjcsMTI3LDEyNywwLDk2LDEsMTI3LDEsMTI3LDk2LDMsMTI3LDEyNywxMjcsMCw5NiwxLDEyNiwxLDEyNyw5NiwyLDEyNiwxMjYsMSwxMjYsOTYsNSwxMjcsMTI3LDEyNywxMjcsMTI3LDEsMTI3LDk2LDMsMTI3LDEyNywxMjYsMCw5NiwyLDEyNywxMjcsMSwxMjYsOTYsMywxMjcsMTI3LDEyNywxLDEyNyw5NiwxLDEyNywwLDk2LDIsMTI3LDEyNywwLDk2LDEsMTI3LDEsMTI2LDk2LDIsMTI3LDEyNiwwLDk2LDAsMSwxMjcsMiwxMywxLDMsMTAxLDExMCwxMTgsNSw5Nyw5OCwxMTEsMTE0LDExNiwwLDIsMyw1Nyw1NiwzLDMsMTIsMywzLDE1LDUsNiwxLDgsNCwxLDksMTEsNyw0LDEwLDEwLDExLDAsMCwwLDMsMTIsMywxMiwzLDEyLDEzLDE0LDEzLDE0LDEzLDE0LDEzLDE0LDEzLDE0LDEzLDE0LDEzLDE0LDEzLDE0LDEzLDE0LDEzLDE0LDEzLDE0LDEzLDE0LDEzLDE0LDEzLDE0LDQsNCwxLDExMiwwLDEsNSwzLDEsMCwxLDYsMjYsNSwxMjcsMSw2NSwwLDExLDEyNywxLDY1LDAsMTEsMTI3LDEsNjUsMCwxMSwxMjcsMSw2NSwwLDExLDEyNywxLDY1LDAsMTEsNywyNTMsNiw0NCw2LDEwOSwxMDEsMTA5LDExMSwxMTQsMTIxLDIsMCw1LDExNiw5Nyw5OCwxMDgsMTAxLDEsMCw2LDEwMCwxMDEsMTAzLDExNCwxMDEsMTAxLDAsNywzLDEwOSwxMTEsMTAwLDAsOCwxNiw4Miw5Nyw5OCwxMDUsMTEwLDM1LDEwMywxMDEsMTE2LDU4LDExOSwxMDUsMTEwLDEwMCwxMTEsMTE5LDAsMjMsMTYsODIsOTcsOTgsMTA1LDExMCwzNSwxMTUsMTAxLDExNiw1OCwxMTksMTA1LDExMCwxMDAsMTExLDExOSwwLDI0LDIxLDgyLDk3LDk4LDEwNSwxMTAsMzUsMTAzLDEwMSwxMTYsNTgsMTE5LDEwNSwxMTAsMTAwLDExMSwxMTksOTUsMTE1LDEwNSwxMjIsMTAxLDAsMjUsMjEsODIsOTcsOTgsMTA1LDExMCwzNSwxMTUsMTAxLDExNiw1OCwxMTksMTA1LDExMCwxMDAsMTExLDExOSw5NSwxMTUsMTA1LDEyMiwxMDEsMCwyNiwxNCw4Miw5Nyw5OCwxMDUsMTEwLDM1LDEwMywxMDEsMTE2LDU4LDExOSwxMTIsMTExLDExNSwwLDI3LDE0LDgyLDk3LDk4LDEwNSwxMTAsMzUsMTE1LDEwMSwxMTYsNTgsMTE5LDExMiwxMTEsMTE1LDAsMjgsMTUsODIsOTcsOTgsMTA1LDExMCwzNSwxMDMsMTAxLDExNiw1OCw5OSwxMTEsMTE3LDExMCwxMTYsMCwyOSwxNSw4Miw5Nyw5OCwxMDUsMTEwLDM1LDExNSwxMDEsMTE2LDU4LDk5LDExMSwxMTcsMTEwLDExNiwwLDMwLDEzLDgyLDk3LDk4LDEwNSwxMTAsMzUsMTAzLDEwMSwxMTYsNTgsMTEyLDExMSwxMTUsMCwzMSwxMyw4Miw5Nyw5OCwxMDUsMTEwLDM1LDExNSwxMDEsMTE2LDU4LDExMiwxMTEsMTE1LDAsMzIsMTUsODIsOTcsOTgsMTA1LDExMCwzNSwxMDMsMTAxLDExNiw1OCwxMTUsMTE2LDk3LDExNCwxMTYsMCwzMywxNSw4Miw5Nyw5OCwxMDUsMTEwLDM1LDExNSwxMDEsMTE2LDU4LDExNSwxMTYsOTcsMTE0LDExNiwwLDM0LDE2LDgyLDk3LDk4LDEwNSwxMTAsMzUsMTAzLDEwMSwxMTYsNTgsMTAwLDEwNSwxMDMsMTAxLDExNSwxMTYsMCwzNSwxNiw4Miw5Nyw5OCwxMDUsMTEwLDM1LDExNSwxMDEsMTE2LDU4LDEwMCwxMDUsMTAzLDEwMSwxMTUsMTE2LDAsMzYsMjEsODIsOTcsOTgsMTA1LDExMCwzNSwxMDMsMTAxLDExNiw1OCw5OSwxMDQsMTE3LDExMCwxMDcsOTUsMTE1LDExNiw5NywxMTQsMTE2LDAsMzcsMjEsODIsOTcsOTgsMTA1LDExMCwzNSwxMTUsMTAxLDExNiw1OCw5OSwxMDQsMTE3LDExMCwxMDcsOTUsMTE1LDExNiw5NywxMTQsMTE2LDAsMzgsMjIsODIsOTcsOTgsMTA1LDExMCwzNSwxMDMsMTAxLDExNiw1OCw5OSwxMDQsMTE3LDExMCwxMDcsOTUsMTA4LDEwMSwxMTAsMTAzLDExNiwxMDQsMCwzOSwyMiw4Miw5Nyw5OCwxMDUsMTEwLDM1LDExNSwxMDEsMTE2LDU4LDk5LDEwNCwxMTcsMTEwLDEwNyw5NSwxMDgsMTAxLDExMCwxMDMsMTE2LDEwNCwwLDQwLDMxLDgyLDk3LDk4LDEwNSwxMTAsMzUsMTAzLDEwMSwxMTYsNTgsOTksMTA0LDExNywxMTAsMTA3LDk1LDk5LDExNywxMTYsOTUsMTAyLDEwNSwxMTAsMTAzLDEwMSwxMTQsMTEyLDExNCwxMDUsMTEwLDExNiwwLDQxLDMxLDgyLDk3LDk4LDEwNSwxMTAsMzUsMTE1LDEwMSwxMTYsNTgsOTksMTA0LDExNywxMTAsMTA3LDk1LDk5LDExNywxMTYsOTUsMTAyLDEwNSwxMTAsMTAzLDEwMSwxMTQsMTEyLDExNCwxMDUsMTEwLDExNiwwLDQyLDIwLDgyLDk3LDk4LDEwNSwxMTAsMzUsMTAzLDEwMSwxMTYsNTgsMTEyLDExMSwxMDgsMTIxLDExMCwxMTEsMTA5LDEwNSw5NywxMDgsMCw0MywyMCw4Miw5Nyw5OCwxMDUsMTEwLDM1LDExNSwxMDEsMTE2LDU4LDExMiwxMTEsMTA4LDEyMSwxMTAsMTExLDEwOSwxMDUsOTcsMTA4LDAsNDQsMjcsODIsOTcsOTgsMTA1LDExMCwzNSwxMDMsMTAxLDExNiw1OCwxMTIsMTExLDEwOCwxMjEsMTEwLDExMSwxMDksMTA1LDk3LDEwOCw5NSwxMDAsMTAxLDEwMywxMTQsMTAxLDEwMSwwLDQ1LDI3LDgyLDk3LDk4LDEwNSwxMTAsMzUsMTE1LDEwMSwxMTYsNTgsMTEyLDExMSwxMDgsMTIxLDExMCwxMTEsMTA5LDEwNSw5NywxMDgsOTUsMTAwLDEwMSwxMDMsMTE0LDEwMSwxMDEsMCw0NiwyNiw4Miw5Nyw5OCwxMDUsMTEwLDM1LDEwMywxMDEsMTE2LDU4LDExMiwxMTEsMTA4LDEyMSwxMTAsMTExLDEwOSwxMDUsOTcsMTA4LDk1LDExNSwxMDQsMTA1LDEwMiwxMTYsMCw0NywyNiw4Miw5Nyw5OCwxMDUsMTEwLDM1LDExNSwxMDEsMTE2LDU4LDExMiwxMTEsMTA4LDEyMSwxMTAsMTExLDEwOSwxMDUsOTcsMTA4LDk1LDExNSwxMDQsMTA1LDEwMiwxMTYsMCw0OCwyMiw4Miw5Nyw5OCwxMDUsMTEwLDM1LDEwMywxMDEsMTE2LDU4LDk3LDExOCwxMDEsMTE0LDk3LDEwMywxMDEsOTUsOTgsMTA1LDExNiwxMTUsMCw0OSwyMiw4Miw5Nyw5OCwxMDUsMTEwLDM1LDExNSwxMDEsMTE2LDU4LDk3LDExOCwxMDEsMTE0LDk3LDEwMywxMDEsOTUsOTgsMTA1LDExNiwxMTUsMCw1MCwxNyw4Miw5Nyw5OCwxMDUsMTEwLDM1LDEwMywxMDEsMTE2LDU4LDEwOSwxMDUsMTEwLDExNSwxMDUsMTIyLDEwMSwwLDUxLDE3LDgyLDk3LDk4LDEwNSwxMTAsMzUsMTE1LDEwMSwxMTYsNTgsMTA5LDEwNSwxMTAsMTE1LDEwNSwxMjIsMTAxLDAsNTIsMTcsODIsOTcsOTgsMTA1LDExMCwzNSwxMDMsMTAxLDExNiw1OCwxMDksOTcsMTIwLDExNSwxMDUsMTIyLDEwMSwwLDUzLDE3LDgyLDk3LDk4LDEwNSwxMTAsMzUsMTE1LDEwMSwxMTYsNTgsMTA5LDk3LDEyMCwxMTUsMTA1LDEyMiwxMDEsMCw1NCwxNCw4Miw5Nyw5OCwxMDUsMTEwLDM1LDEwMywxMDEsMTE2LDU4LDEwOSw5NywxMTUsMTA3LDAsNTUsMTQsODIsOTcsOTgsMTA1LDExMCwzNSwxMTUsMTAxLDExNiw1OCwxMDksOTcsMTE1LDEwNywwLDU2LDE3LDgyLDk3LDk4LDEwNSwxMTAsMzUsOTksMTExLDExMCwxMTUsMTE2LDExNCwxMTcsOTksMTE2LDExMSwxMTQsMCwxNSwxNyw4Miw5Nyw5OCwxMDUsMTEwLDM1LDEwMiwxMDUsMTEwLDEwMywxMDEsMTE0LDExMiwxMTQsMTA1LDExMCwxMTYsMCwxNiwxNCwxMDksMTAxLDEwOSwxMTEsMTE0LDEyMSw0Niw5OSwxMTEsMTA5LDExMiw5NywxMTQsMTAxLDAsMTgsMTUsMTA5LDEwMSwxMDksMTExLDExNCwxMjEsNDYsOTcsMTA4LDEwOCwxMTEsOTksOTcsMTE2LDEwMSwwLDQsMTEsMTA5LDEwMSwxMDksMTExLDExNCwxMjEsNDYsMTAyLDExNCwxMDEsMTAxLDAsMTksMTIsMTA5LDEwMSwxMDksMTExLDExNCwxMjEsNDYsMTE0LDEwMSwxMTUsMTAxLDExNiwwLDIwLDgsMSwyMSw5LDcsMSwwLDY1LDAsMTEsMSwyMiwxMCwxODgsMzAsNTYsMTA0LDEsMywxMjcsMzIsMCw2NSwxMjgsMTI4LDEyOCwxMjgsNCw3NSw0LDY0LDAsMTEsMzUsMSwzNCwxLDMyLDAsNjUsMSwzMiwwLDY1LDEsNzUsMjcsMTA2LDY1LDcsMTA2LDY1LDEyMCwxMTMsMzQsMCw2MywwLDM0LDIsNjUsMTYsMTE2LDc1LDQsNjQsMzIsMiwzMiwwLDMyLDEsMTA3LDY1LDI1NSwyNTUsMywxMDYsNjUsMTI4LDEyOCwxMjQsMTEzLDY1LDE2LDExOCwzNCwzLDMyLDIsMzIsMyw3NCwyNyw2NCwwLDY1LDAsNzIsNCw2NCwzMiwzLDY0LDAsNjUsMCw3Miw0LDY0LDAsMTEsMTEsMTEsMzIsMCwzNiwxLDMyLDEsMTEsNTEsMSwxLDEyNywzMiwwLDY1LDI0OCwyNTUsMjU1LDI1NSwzLDc1LDQsNjQsNjUsMCw2NSwyMDAsMCw2NSwyNiw2NSwyLDE2LDAsMCwxMSw2NSwxLDY1LDMyLDMyLDAsNjUsNywxMDYsMTAzLDEwNywxMTYsMTYsMSwzNCwxLDMyLDAsNTQsMiwwLDMyLDEsMTEsMTQ1LDMsMSwxLDEyNywzMiwxLDY5LDQsNjQsMTUsMTEsMzIsMCw2NSwwLDU4LDAsMCwzMiwwLDMyLDEsMTA2LDY1LDEsMTA3LDY1LDAsNTgsMCwwLDMyLDEsNjUsMiw3Nyw0LDY0LDE1LDExLDMyLDAsNjUsMSwxMDYsNjUsMCw1OCwwLDAsMzIsMCw2NSwyLDEwNiw2NSwwLDU4LDAsMCwzMiwwLDMyLDEsMTA2LDM0LDIsNjUsMiwxMDcsNjUsMCw1OCwwLDAsMzIsMiw2NSwzLDEwNyw2NSwwLDU4LDAsMCwzMiwxLDY1LDYsNzcsNCw2NCwxNSwxMSwzMiwwLDY1LDMsMTA2LDY1LDAsNTgsMCwwLDMyLDAsMzIsMSwxMDYsNjUsNCwxMDcsNjUsMCw1OCwwLDAsMzIsMSw2NSw4LDc3LDQsNjQsMTUsMTEsNjUsMCwzMiwwLDEwNyw2NSwzLDExMywzNCwyLDMyLDAsMTA2LDM0LDAsNjUsMCw1NCwyLDAsMzIsMSwzMiwyLDEwNyw2NSwxMjQsMTEzLDM0LDEsMzIsMCwxMDYsNjUsNCwxMDcsNjUsMCw1NCwyLDAsMzIsMSw2NSw4LDc3LDQsNjQsMTUsMTEsMzIsMCw2NSw0LDEwNiw2NSwwLDU0LDIsMCwzMiwwLDY1LDgsMTA2LDY1LDAsNTQsMiwwLDMyLDAsMzIsMSwxMDYsMzQsMiw2NSwxMiwxMDcsNjUsMCw1NCwyLDAsMzIsMiw2NSw4LDEwNyw2NSwwLDU0LDIsMCwzMiwxLDY1LDI0LDc3LDQsNjQsMTUsMTEsMzIsMCw2NSwxMiwxMDYsNjUsMCw1NCwyLDAsMzIsMCw2NSwxNiwxMDYsNjUsMCw1NCwyLDAsMzIsMCw2NSwyMCwxMDYsNjUsMCw1NCwyLDAsMzIsMCw2NSwyNCwxMDYsNjUsMCw1NCwyLDAsMzIsMCwzMiwxLDEwNiwzNCwyLDY1LDI4LDEwNyw2NSwwLDU0LDIsMCwzMiwyLDY1LDI0LDEwNyw2NSwwLDU0LDIsMCwzMiwyLDY1LDIwLDEwNyw2NSwwLDU0LDIsMCwzMiwyLDY1LDE2LDEwNyw2NSwwLDU0LDIsMCwzMiwwLDY1LDQsMTEzLDY1LDI0LDEwNiwzNCwyLDMyLDAsMTA2LDMzLDAsMzIsMSwzMiwyLDEwNywzMywxLDMsNjQsMzIsMSw2NSwzMiw3OSw0LDY0LDMyLDAsNjYsMCw1NSwzLDAsMzIsMCw2NSw4LDEwNiw2NiwwLDU1LDMsMCwzMiwwLDY1LDE2LDEwNiw2NiwwLDU1LDMsMCwzMiwwLDY1LDI0LDEwNiw2NiwwLDU1LDMsMCwzMiwxLDY1LDMyLDEwNywzMywxLDMyLDAsNjUsMzIsMTA2LDMzLDAsMTIsMSwxMSwxMSwxMSw2LDAsMzIsMCwxNiwxLDExLDc2LDEsMSwxMjcsNjUsMTI4LDE2LDE2LDIsMzQsMSw2NSw4LDEwNiw2NSwxMjgsMTYsMTYsMywzMiwwLDY5LDQsNjQsNjUsMTIsMTYsMSwzMywwLDExLDMyLDAsNjUsMCw1NCwyLDAsMzIsMCw2NSwwLDU0LDIsNCwzMiwwLDY1LDAsNTQsMiw4LDMyLDAsMzIsMSw1NCwyLDAsMzIsMCw2NSwwLDU0LDIsNCwzMiwwLDY1LDEyOCwxNiw1NCwyLDgsMzIsMCwxMSw4LDAsNjUsMTIsMTYsMSwxNiw1LDExLDcwLDIsMSwxMjcsMSwxMjYsNjYsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI3LDMzLDIsMyw2NCwyLDY0LDMyLDEsNjUsMTkyLDAsNzgsMTMsMCwzMiwwLDMyLDIsMTMxLDY2LDAsODYsNCw2NCw2NSw2MywzMiwxLDEwNywxNSw1LDMyLDIsNjYsMSwxMzYsMzMsMiwzMiwxLDY1LDEsMTA2LDMzLDEsMTIsMiwxMSwwLDExLDExLDY1LDEyNywxMSwxNzUsMiwyLDEsMTI3LDIsMTI2LDMsNjQsMiwxMjcsNjYsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI3LDMzLDMsNjUsMCwzMywyLDMsNjQsMiw2NCwzMiwyLDY1LDE5MiwwLDc4LDEzLDAsNjUsNjMsMzIsMiwxMDcsMzIsMCwzMiwzLDEzMSw2NiwwLDg2LDEzLDIsMjYsMzIsMyw2NiwxLDEzNiwzMywzLDMyLDIsNjUsMSwxMDYsMzMsMiwxMiwxLDExLDExLDY1LDEyNywxMSwyLDEyNywzMiwxLDMzLDQsNjYsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI3LDMzLDMsNjUsMCwzMywyLDMsNjQsMiw2NCwzMiwyLDY1LDE5MiwwLDc4LDEzLDAsNjUsNjMsMzIsMiwxMDcsMzIsMywzMiw0LDEzMSw2NiwwLDg2LDEzLDIsMjYsMzIsMyw2NiwxLDEzNiwzMywzLDMyLDIsNjUsMSwxMDYsMzMsMiwxMiwxLDExLDExLDY1LDEyNywxMSw3OCw0LDY0LDMyLDEsMiwxMjcsNjYsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI3LDMzLDMsNjUsMCwzMywyLDMsNjQsMiw2NCwzMiwyLDY1LDE5MiwwLDc4LDEzLDAsNjUsNjMsMzIsMiwxMDcsMzIsMCwzMiwzLDEzMSw2NiwwLDg2LDEzLDIsMjYsMzIsMyw2NiwxLDEzNiwzMywzLDMyLDIsNjUsMSwxMDYsMzMsMiwxMiwxLDExLDExLDY1LDEyNywxMSwyLDEyNyw2NiwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjcsMzMsMyw2NSwwLDMzLDIsMyw2NCwyLDY0LDMyLDIsNjUsMTkyLDAsNzgsMTMsMCw2NSw2MywzMiwyLDEwNywzMiwxLDMyLDMsMTMxLDY2LDAsODYsMTMsMiwyNiwzMiwzLDY2LDEsMTM2LDMzLDMsMzIsMiw2NSwxLDEwNiwzMywyLDEyLDEsMTEsMTEsNjUsMTI3LDExLDEwNywxNzIsMTM0LDMyLDAsMTMzLDMzLDAsMTIsMSwxMSwxMSwzMiwwLDExLDk2LDEsMSwxMjcsMzIsMSw2NSwyNDgsMjU1LDI1NSwyNTUsMyw3NSw0LDY0LDY1LDAsNjUsOCw2NSwyMyw2NSwzNCwxNiwwLDAsMTEsMzIsMSwxNiwyLDM0LDIsNjUsOCwxMDYsMzIsMSwxNiwzLDMyLDAsNjksNCw2NCw2NSwxMiwxNiwxLDMzLDAsMTEsMzIsMCw2NSwwLDU0LDIsMCwzMiwwLDY1LDAsNTQsMiw0LDMyLDAsNjUsMCw1NCwyLDgsMzIsMCwzMiwyLDU0LDIsMCwzMiwwLDY1LDAsNTQsMiw0LDMyLDAsMzIsMSw1NCwyLDgsMzIsMCwxMSw0OSwwLDMyLDEsMzIsMCw0MCwyLDgsNjUsMywxMTgsNzksNCw2NCw2NSwwLDY1LDgsNjUsNTAsNjUsNjMsMTYsMCwwLDExLDMyLDAsNDAsMiw0LDMyLDAsNDAsMiwwLDMyLDEsNjUsMywxMTYsMTA2LDEwNiwzMiwyLDU1LDMsOCwxMSw0MywwLDMyLDEsMzIsMCw0MCwyLDgsNzksNCw2NCw2NSwwLDY1LDgsNjUsNTAsNjUsNjMsMTYsMCwwLDExLDMyLDAsNDAsMiw0LDMyLDEsMzIsMCw0MCwyLDAsMTA2LDEwNiwzMiwyLDU4LDAsOCwxMSw0MSwwLDMyLDEsMzIsMCw0MCwyLDgsNzksNCw2NCw2NSwwLDY1LDgsNjUsMzksNjUsNjMsMTYsMCwwLDExLDMyLDAsNDAsMiw0LDMyLDEsMzIsMCw0MCwyLDAsMTA2LDEwNiw0NSwwLDgsMTEsNDcsMCwzMiwxLDMyLDAsNDAsMiw4LDY1LDMsMTE4LDc5LDQsNjQsNjUsMCw2NSw4LDY1LDM5LDY1LDYzLDE2LDAsMCwxMSwzMiwwLDQwLDIsNCwzMiwwLDQwLDIsMCwzMiwxLDY1LDMsMTE2LDEwNiwxMDYsNDEsMyw4LDExLDE2NiwxMCwyLDMsMTI3LDUsMTI2LDM1LDIsNjksNCw2NCwzLDY0LDMyLDIsNjUsMTI4LDIsNzIsNCw2NCwzMiwyLDY1LDI1NSwxLDExMywxNzMsMzMsNCwzMiwwLDQxLDMsNzIsMzMsNiwzLDY0LDIsMTI3LDMyLDQsMzMsNSw2NiwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjcsMzMsNCw2NSwwLDMzLDEsMyw2NCwzMiwxLDY1LDE5MiwwLDcyLDQsNjQsNjUsNjMsMzIsMSwxMDcsMzIsNCwzMiw1LDEzMSw2NiwwLDg2LDEzLDIsMjYsMzIsNCw2NiwxLDEzNiwzMyw0LDMyLDEsNjUsMSwxMDYsMzMsMSwxMiwxLDExLDExLDY1LDEyNywxMSwyLDEyNywzMiw2LDMzLDcsNjYsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI3LDMzLDQsNjUsMCwzMywxLDMsNjQsMzIsMSw2NSwxOTIsMCw3Miw0LDY0LDY1LDYzLDMyLDEsMTA3LDMyLDQsMzIsNywxMzEsNjYsMCw4NiwxMywyLDI2LDMyLDQsNjYsMSwxMzYsMzMsNCwzMiwxLDY1LDEsMTA2LDMzLDEsMTIsMSwxMSwxMSw2NSwxMjcsMTEsNzgsNCw2NCwzMiw2LDIsMTI3LDY2LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyNywzMyw0LDY1LDAsMzMsMSwzLDY0LDMyLDEsNjUsMTkyLDAsNzIsNCw2NCw2NSw2MywzMiwxLDEwNywzMiw0LDMyLDUsMTMxLDY2LDAsODYsMTMsMiwyNiwzMiw0LDY2LDEsMTM2LDMzLDQsMzIsMSw2NSwxLDEwNiwzMywxLDEyLDEsMTEsMTEsNjUsMTI3LDExLDIsMTI3LDY2LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyNywzMyw0LDY1LDAsMzMsMSwzLDY0LDMyLDEsNjUsMTkyLDAsNzIsNCw2NCw2NSw2MywzMiwxLDEwNywzMiw0LDMyLDYsMTMxLDY2LDAsODYsMTMsMiwyNiwzMiw0LDY2LDEsMTM2LDMzLDQsMzIsMSw2NSwxLDEwNiwzMywxLDEyLDEsMTEsMTEsNjUsMTI3LDExLDEwNywxNzIsMTM0LDMyLDUsMTMzLDMzLDQsMTIsMSwxMSwxMSw2NSwwLDMzLDEsMyw2NCwzMiwxLDMyLDAsNDAsMiw0LDY1LDEsMTA3LDcyLDQsNjQsMzIsNSw2Niw4LDEzNCwzMyw0LDMyLDAsNDEsMyw3MiwzMyw2LDMsNjQsMiwxMjcsMzIsNCwzMyw1LDY2LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyNywzMyw0LDY1LDAsMzMsMywzLDY0LDMyLDMsNjUsMTkyLDAsNzIsNCw2NCw2NSw2MywzMiwzLDEwNywzMiw0LDMyLDUsMTMxLDY2LDAsODYsMTMsMiwyNiwzMiw0LDY2LDEsMTM2LDMzLDQsMzIsMyw2NSwxLDEwNiwzMywzLDEyLDEsMTEsMTEsNjUsMTI3LDExLDIsMTI3LDMyLDYsMzMsNyw2NiwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjcsMzMsNCw2NSwwLDMzLDMsMyw2NCwzMiwzLDY1LDE5MiwwLDcyLDQsNjQsNjUsNjMsMzIsMywxMDcsMzIsNCwzMiw3LDEzMSw2NiwwLDg2LDEzLDIsMjYsMzIsNCw2NiwxLDEzNiwzMyw0LDMyLDMsNjUsMSwxMDYsMzMsMywxMiwxLDExLDExLDY1LDEyNywxMSw3OCw0LDY0LDMyLDYsMiwxMjcsNjYsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI3LDMzLDQsNjUsMCwzMywzLDMsNjQsMzIsMyw2NSwxOTIsMCw3Miw0LDY0LDY1LDYzLDMyLDMsMTA3LDMyLDQsMzIsNSwxMzEsNjYsMCw4NiwxMywyLDI2LDMyLDQsNjYsMSwxMzYsMzMsNCwzMiwzLDY1LDEsMTA2LDMzLDMsMTIsMSwxMSwxMSw2NSwxMjcsMTEsMiwxMjcsNjYsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI3LDMzLDQsNjUsMCwzMywzLDMsNjQsMzIsMyw2NSwxOTIsMCw3Miw0LDY0LDY1LDYzLDMyLDMsMTA3LDMyLDQsMzIsNiwxMzEsNjYsMCw4NiwxMywyLDI2LDMyLDQsNjYsMSwxMzYsMzMsNCwzMiwzLDY1LDEsMTA2LDMzLDMsMTIsMSwxMSwxMSw2NSwxMjcsMTEsMTA3LDE3MiwxMzQsMzIsNSwxMzMsMzMsNCwxMiwxLDExLDExLDMyLDEsNjUsMSwxMDYsMzMsMSwxMiwxLDExLDExLDM1LDQsMzIsMiwzMiw1LDE2LDEwLDMyLDIsNjUsMSwxMDYsMzMsMiwxMiwxLDExLDExLDIsMTI3LDMyLDAsNDEsMyw3MiwzMyw0LDY2LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyNywzMyw1LDY1LDAsMzMsMiwzLDY0LDMyLDIsNjUsMTkyLDAsNzIsNCw2NCw2NSw2MywzMiwyLDEwNywzMiw0LDMyLDUsMTMxLDY2LDAsODYsMTMsMiwyNiwzMiw1LDY2LDEsMTM2LDMzLDUsMzIsMiw2NSwxLDEwNiwzMywyLDEyLDEsMTEsMTEsNjUsMTI3LDExLDE3MiwzMyw4LDY1LDAsMzMsMiwzLDY0LDMyLDIsNjUsMTI4LDIsNzIsNCw2NCwzNSwzLDMzLDMsMzIsMiwxNzIsMzIsOCwxMzQsMzMsNSwzMiwwLDQxLDMsNzIsMzMsNiwzLDY0LDIsMTI3LDY2LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyNywzMyw0LDY1LDAsMzMsMSwzLDY0LDMyLDEsNjUsMTkyLDAsNzIsNCw2NCw2NSw2MywzMiwxLDEwNywzMiw0LDMyLDUsMTMxLDY2LDAsODYsMTMsMiwyNiwzMiw0LDY2LDEsMTM2LDMzLDQsMzIsMSw2NSwxLDEwNiwzMywxLDEyLDEsMTEsMTEsNjUsMTI3LDExLDIsMTI3LDMyLDYsMzMsNyw2NiwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjcsMzMsNCw2NSwwLDMzLDEsMyw2NCwzMiwxLDY1LDE5MiwwLDcyLDQsNjQsNjUsNjMsMzIsMSwxMDcsMzIsNCwzMiw3LDEzMSw2NiwwLDg2LDEzLDIsMjYsMzIsNCw2NiwxLDEzNiwzMyw0LDMyLDEsNjUsMSwxMDYsMzMsMSwxMiwxLDExLDExLDY1LDEyNywxMSw3OCw0LDY0LDMyLDYsMiwxMjcsNjYsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI3LDMzLDQsNjUsMCwzMywxLDMsNjQsMzIsMSw2NSwxOTIsMCw3Miw0LDY0LDY1LDYzLDMyLDEsMTA3LDMyLDQsMzIsNSwxMzEsNjYsMCw4NiwxMywyLDI2LDMyLDQsNjYsMSwxMzYsMzMsNCwzMiwxLDY1LDEsMTA2LDMzLDEsMTIsMSwxMSwxMSw2NSwxMjcsMTEsMiwxMjcsNjYsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI3LDMzLDQsNjUsMCwzMywxLDMsNjQsMzIsMSw2NSwxOTIsMCw3Miw0LDY0LDY1LDYzLDMyLDEsMTA3LDMyLDQsMzIsNiwxMzEsNjYsMCw4NiwxMywyLDI2LDMyLDQsNjYsMSwxMzYsMzMsNCwzMiwxLDY1LDEsMTA2LDMzLDEsMTIsMSwxMSwxMSw2NSwxMjcsMTEsMTA3LDE3MiwxMzQsMzIsNSwxMzMsMzMsNSwxMiwxLDExLDExLDMyLDMsMzIsMiwzMiwyLDE3MiwzMiw4LDEzNCwzMiw1LDEzMiwxNiwxMCwzMiwyLDY1LDEsMTA2LDMzLDIsMTIsMSwxMSwxMSw2NSwxLDM2LDIsMTEsMzIsMCw2NiwwLDU1LDMsMjQsMzIsMCw2NiwwLDU1LDMsMzIsNjUsMCwzMywyLDMsNjQsMzIsMiwzMiwwLDQwLDIsNCw3Miw0LDY0LDMyLDAsNDAsMiwwLDMyLDIsNjUsMCwxNiwxMSwzMiwyLDY1LDEsMTA2LDMzLDIsMTIsMSwxMSwxMSwzMiwwLDY2LDAsNTUsMyw0MCwzMiwwLDY1LDAsNTQsMiw4LDMyLDAsNjYsMCw1NSwzLDE2LDMyLDAsNjYsMCw1NSwzLDQwLDMyLDAsNDAsMiwwLDMyLDAsNDAsMiw4LDE2LDEyLDMzLDEsMzIsMCw0MCwyLDAsMzIsMCw0MCwyLDgsNjUsMSwxNiwxMSwzMiwwLDMyLDAsNDEsMyw0MCwzNSw0LDMyLDEsNjUsMjU1LDEsMTEzLDE2LDEzLDEzMyw1NSwzLDQwLDMyLDAsMzIsMCw0MCwyLDgsNjUsMSwxMDYsMzIsMCw0MCwyLDQsMTExLDU0LDIsOCwzMiwwLDQxLDMsNDAsMzIsMCw0MSwzLDg4LDEzNiwxNjcsMzMsMSwzMiwwLDMyLDAsNDEsMyw0MCw2Niw4LDEzNCw1NSwzLDQwLDMyLDAsMzIsMCw0MSwzLDQwLDY2LDEsMTMyLDU1LDMsNDAsMzIsMCwzMiwwLDQxLDMsNDAsMzUsMywzMiwxLDY1LDI1NSwxLDExMywxNiwxMywxMzMsNTUsMyw0MCwxMSwyMzQsMSwwLDMyLDAsNjksNCw2NCw2NSwxMjgsMSwxNiwxLDMzLDAsMTEsMzIsMCw2NSwwLDU0LDIsMCwzMiwwLDY1LDAsNTQsMiw0LDMyLDAsNjUsMCw1NCwyLDgsMzIsMCw2NiwwLDU1LDMsMTYsMzIsMCw2NiwwLDU1LDMsMjQsMzIsMCw2NiwwLDU1LDMsMzIsMzIsMCw2NiwwLDU1LDMsNDAsMzIsMCw2NiwwLDU1LDMsNDgsMzIsMCw2NiwwLDU1LDMsNTYsMzIsMCw2NiwwLDU1LDMsNjQsMzIsMCw2NiwwLDU1LDMsNzIsMzIsMCw2NiwwLDU1LDMsODAsMzIsMCw2NiwwLDU1LDMsODgsMzIsMCw2NiwwLDU1LDMsOTYsMzIsMCw2NiwwLDU1LDMsMTA0LDMyLDAsNjYsMCw1NSwzLDExMiwzMiwwLDY2LDAsNTUsMywxMjAsMzIsMCwzMiwxLDE3Myw1NSwzLDk2LDMyLDAsMzIsMiwxNzMsNTUsMywxMDQsMzIsMCwzMiwzLDE3Myw1NSwzLDExMiwzMiwwLDY1LDEyLDE2LDEsMzIsNCwxNiw5LDU0LDIsMCwzMiwwLDMyLDQsNTQsMiw0LDMyLDAsNjYsMSwzMiwwLDQxLDMsOTYsMTM0LDY2LDEsMTI1LDU1LDMsMTIwLDMyLDAsNjYsMjQzLDEzMCwxODMsMjE4LDIxNiwyMzAsMjMyLDMwLDU1LDMsNzIsMzIsMCw2Niw1Myw1NSwzLDgwLDMyLDAsMzIsMCw0MSwzLDgwLDY2LDgsMTI1LDU1LDMsODgsMzIsMCwxNiwxNCwzMiwwLDExLDIwNiw0LDEsNSwxMjcsMzIsMSw0MCwyLDgsMzMsNCwzMiwxLDQwLDIsMCw2NSw4LDEwNiwzMyw1LDMsNjQsMiwxMjcsNjUsMCwzMywzLDMsNjQsMzIsMywzMiw0LDcyLDQsNjQsMzIsMywzMiw1LDEwNiw0NSwwLDAsMzMsMSwzMiwwLDQwLDIsMCwzMiwwLDQwLDIsOCwxNiwxMiwzMyw2LDMyLDAsNDAsMiwwLDMyLDAsNDAsMiw4LDMyLDEsMTYsMTEsMzIsMCwzMiwwLDQxLDMsNDAsMzUsNCwzMiw2LDY1LDI1NSwxLDExMywxNiwxMywxMzMsNTUsMyw0MCwzMiwwLDMyLDAsNDAsMiw4LDY1LDEsMTA2LDMyLDAsNDAsMiw0LDExMSw1NCwyLDgsMzIsMCw0MSwzLDQwLDMyLDAsNDEsMyw4OCwxMzYsMTY3LDMzLDYsMzIsMCwzMiwwLDQxLDMsNDAsNjYsOCwxMzQsNTUsMyw0MCwzMiwwLDMyLDAsNDEsMyw0MCwzMiwxLDE3MywxMzIsNTUsMyw0MCwzMiwwLDMyLDAsNDEsMyw0MCwzNSwzLDMyLDYsNjUsMjU1LDEsMTEzLDE2LDEzLDEzMyw1NSwzLDQwLDMyLDAsMzIsMCw0MSwzLDE2LDY2LDEsMTI0LDU1LDMsMTYsMzIsMCwzMiwwLDQxLDMsMjQsNjYsMSwxMjQsNTUsMywyNCwyLDEyNywzMiwwLDQxLDMsMTYsMzIsMCw0MSwzLDEwNCw5MCwzNCwxLDQsNjQsMzIsMCw0MSwzLDQwLDMyLDAsNDEsMywxMjAsMTMxLDY2LDAsODEsMzMsMSwxMSwzMiwxLDY5LDExLDQsMTI3LDMyLDAsNDEsMywxNiwzMiwwLDQxLDMsMTEyLDkwLDUsMzIsMSwxMSw0LDY0LDMyLDAsMzIsMCw0MSwzLDMyLDU1LDMsNDgsMzIsMCwzMiwwLDQxLDMsMTYsNTUsMyw1NiwzMiwwLDMyLDAsNDEsMyw0MCw1NSwzLDY0LDY1LDAsMzMsMSwzLDY0LDMyLDEsMzIsMCw0MCwyLDQsNzIsNCw2NCwzMiwwLDQwLDIsMCwzMiwxLDY1LDAsMTYsMTEsMzIsMSw2NSwxLDEwNiwzMywxLDEyLDEsMTEsMTEsMzIsMCw2NiwwLDU1LDMsNDAsMzIsMCw2NSwwLDU0LDIsOCwzMiwwLDY2LDAsNTUsMywxNiwzMiwwLDY2LDAsNTUsMyw0MCwzMiwwLDQwLDIsMCwzMiwwLDQwLDIsOCwxNiwxMiwzMywxLDMyLDAsNDAsMiwwLDMyLDAsNDAsMiw4LDY1LDEsMTYsMTEsMzIsMCwzMiwwLDQxLDMsNDAsMzUsNCwzMiwxLDY1LDI1NSwxLDExMywxNiwxMywxMzMsNTUsMyw0MCwzMiwwLDMyLDAsNDAsMiw4LDY1LDEsMTA2LDMyLDAsNDAsMiw0LDExMSw1NCwyLDgsMzIsMCw0MSwzLDQwLDMyLDAsNDEsMyw4OCwxMzYsMTY3LDMzLDEsMzIsMCwzMiwwLDQxLDMsNDAsNjYsOCwxMzQsNTUsMyw0MCwzMiwwLDMyLDAsNDEsMyw0MCw2NiwxLDEzMiw1NSwzLDQwLDMyLDAsMzIsMCw0MSwzLDQwLDM1LDMsMzIsMSw2NSwyNTUsMSwxMTMsMTYsMTMsMTMzLDU1LDMsNDAsMzIsMyw2NSwxLDEwNiwxMiwzLDUsMzIsMyw2NSwxLDEwNiwzMywzLDEyLDIsMTEsMCwxMSwxMSw2NSwxMjcsMTEsMzQsMSw2NSwwLDc4LDQsNjQsMzIsNCwzMiwxLDEwNywzMyw0LDMyLDEsMzIsNSwxMDYsMzMsNSwzMiw3LDM0LDEsNjUsMSwxMDYsMzMsNywzMiwyLDQwLDIsNCwzMiwyLDQwLDIsMCwzMiwxLDY1LDIsMTE2LDEwNiwxMDYsMzIsMCw0MSwzLDU2LDYyLDIsOCwzMiwyLDQwLDIsNCwzMiwyLDQwLDIsMCwzMiwxLDY1LDIsMTE2LDEwNiwxMDYsNDAsMiw4LDI2LDEyLDEsMTEsMTEsMTEsODgsMSwxLDEyNywzMiwwLDMyLDEsNzAsNCw2NCw2NSwwLDE1LDExLDMsNjQsMzIsMiw2NSwwLDcxLDM0LDMsNCw2NCwzMiwwLDQ1LDAsMCwzMiwxLDQ1LDAsMCw3MCwzMywzLDExLDMyLDMsNCw2NCwzMiwyLDY1LDEsMTA3LDMzLDIsMzIsMCw2NSwxLDEwNiwzMywwLDMyLDEsNjUsMSwxMDYsMzMsMSwxMiwxLDExLDExLDMyLDIsNCwxMjcsMzIsMCw0NSwwLDAsMzIsMSw0NSwwLDAsMTA3LDUsNjUsMCwxMSwxMSwxMCwwLDMyLDAsMzIsMSwzMiwyLDE2LDE3LDExLDMsMCwxLDExLDYsMCwzNSwwLDM2LDEsMTEsMTksMCw2NSwxMzYsMSwzNiwwLDM1LDAsMzYsMSwxNiw2LDM2LDMsMTYsNiwzNiw0LDExLDMsMCwxLDExLDcsMCwzMiwwLDQwLDIsMCwxMSw5LDAsMzIsMCwzMiwxLDU0LDIsMCwxMSw3LDAsMzIsMCw0MCwyLDQsMTEsOSwwLDMyLDAsMzIsMSw1NCwyLDQsMTEsNywwLDMyLDAsNDAsMiw4LDExLDksMCwzMiwwLDMyLDEsNTQsMiw4LDExLDcsMCwzMiwwLDQxLDMsMTYsMTEsOSwwLDMyLDAsMzIsMSw1NSwzLDE2LDExLDcsMCwzMiwwLDQxLDMsMjQsMTEsOSwwLDMyLDAsMzIsMSw1NSwzLDI0LDExLDcsMCwzMiwwLDQxLDMsMzIsMTEsOSwwLDMyLDAsMzIsMSw1NSwzLDMyLDExLDcsMCwzMiwwLDQxLDMsNDAsMTEsOSwwLDMyLDAsMzIsMSw1NSwzLDQwLDExLDcsMCwzMiwwLDQxLDMsNDgsMTEsOSwwLDMyLDAsMzIsMSw1NSwzLDQ4LDExLDcsMCwzMiwwLDQxLDMsNTYsMTEsOSwwLDMyLDAsMzIsMSw1NSwzLDU2LDExLDcsMCwzMiwwLDQxLDMsNjQsMTEsOSwwLDMyLDAsMzIsMSw1NSwzLDY0LDExLDcsMCwzMiwwLDQxLDMsNzIsMTEsOSwwLDMyLDAsMzIsMSw1NSwzLDcyLDExLDcsMCwzMiwwLDQxLDMsODAsMTEsOSwwLDMyLDAsMzIsMSw1NSwzLDgwLDExLDcsMCwzMiwwLDQxLDMsODgsMTEsOSwwLDMyLDAsMzIsMSw1NSwzLDg4LDExLDcsMCwzMiwwLDQxLDMsOTYsMTEsOSwwLDMyLDAsMzIsMSw1NSwzLDk2LDExLDcsMCwzMiwwLDQxLDMsMTA0LDExLDksMCwzMiwwLDMyLDEsNTUsMywxMDQsMTEsNywwLDMyLDAsNDEsMywxMTIsMTEsOSwwLDMyLDAsMzIsMSw1NSwzLDExMiwxMSw3LDAsMzIsMCw0MSwzLDEyMCwxMSw5LDAsMzIsMCwzMiwxLDU1LDMsMTIwLDExLDExLDEyOCwxLDIsMCw2NSw4LDExLDU3LDI3LDAsMCwwLDEyNiwwLDEwOCwwLDEwNSwwLDk4LDAsNDcsMCwxMDUsMCwxMTAsMCwxMTYsMCwxMDEsMCwxMTQsMCwxMTAsMCw5NywwLDEwOCwwLDQ3LDAsMTE2LDAsMTIxLDAsMTEyLDAsMTAxLDAsMTAwLDAsOTcsMCwxMTQsMCwxMTQsMCw5NywwLDEyMSwwLDQ2LDAsMTE2LDAsMTE1LDAsNjUsMjAwLDAsMTEsNTksMjgsMCwwLDAsMTI2LDAsMTA4LDAsMTA1LDAsOTgsMCw0NywwLDEwNSwwLDExMCwwLDExNiwwLDEwMSwwLDExNCwwLDExMCwwLDk3LDAsMTA4LDAsNDcsMCw5NywwLDExNCwwLDExNCwwLDk3LDAsMTIxLDAsOTgsMCwxMTcsMCwxMDIsMCwxMDIsMCwxMDEsMCwxMTQsMCw0NiwwLDExNiwwLDExNSwwLDMyLDE2LDExNSwxMTEsMTE3LDExNCw5OSwxMDEsNzcsOTcsMTEyLDExMiwxMDUsMTEwLDEwMyw4NSw4Miw3NiwxNCwxMTQsOTcsOTgsMTA1LDExMCw0NiwxMTksOTcsMTE1LDEwOSw0NiwxMDksOTcsMTEyXSlcbiAgLy8gbWFrZSBpdCB3b3JrIGFzeW5jIGJlY2F1c2UgYnJvd3NlcnMgdGhyb3cgd2hlbiBhIHdhc20gbW9kdWxlIGlzIGJpZ2dlciB0aGFuIDRrYiBhbmQgbG9hZCBzeW5jXG4gIHJldHVybiBpbnN0YW50aWF0ZVN0cmVhbWluZyhuZXcgUmVzcG9uc2UobmV3IEJsb2IoW3dhc21dLCB7dHlwZTogJ2FwcGxpY2F0aW9uL3dhc20nfSkpLCBpbXApXG59XG5tb2R1bGUuZXhwb3J0cyA9IGxvYWRXZWJBc3NlbWJseVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWxwaGFiZXQgPSByZXF1aXJlKCcuL2FscGhhYmV0Jyk7XG52YXIgYnVpbGQgPSByZXF1aXJlKCcuL2J1aWxkJyk7XG52YXIgaXNWYWxpZCA9IHJlcXVpcmUoJy4vaXMtdmFsaWQnKTtcblxuLy8gaWYgeW91IGFyZSB1c2luZyBjbHVzdGVyIG9yIG11bHRpcGxlIHNlcnZlcnMgdXNlIHRoaXMgdG8gbWFrZSBlYWNoIGluc3RhbmNlXG4vLyBoYXMgYSB1bmlxdWUgdmFsdWUgZm9yIHdvcmtlclxuLy8gTm90ZTogSSBkb24ndCBrbm93IGlmIHRoaXMgaXMgYXV0b21hdGljYWxseSBzZXQgd2hlbiB1c2luZyB0aGlyZFxuLy8gcGFydHkgY2x1c3RlciBzb2x1dGlvbnMgc3VjaCBhcyBwbTIuXG52YXIgY2x1c3RlcldvcmtlcklkID0gcmVxdWlyZSgnLi91dGlsL2NsdXN0ZXItd29ya2VyLWlkJykgfHwgMDtcblxuLyoqXG4gKiBTZXQgdGhlIHNlZWQuXG4gKiBIaWdobHkgcmVjb21tZW5kZWQgaWYgeW91IGRvbid0IHdhbnQgcGVvcGxlIHRvIHRyeSB0byBmaWd1cmUgb3V0IHlvdXIgaWQgc2NoZW1hLlxuICogZXhwb3NlZCBhcyBzaG9ydGlkLnNlZWQoaW50KVxuICogQHBhcmFtIHNlZWQgSW50ZWdlciB2YWx1ZSB0byBzZWVkIHRoZSByYW5kb20gYWxwaGFiZXQuICBBTFdBWVMgVVNFIFRIRSBTQU1FIFNFRUQgb3IgeW91IG1pZ2h0IGdldCBvdmVybGFwcy5cbiAqL1xuZnVuY3Rpb24gc2VlZChzZWVkVmFsdWUpIHtcbiAgICBhbHBoYWJldC5zZWVkKHNlZWRWYWx1ZSk7XG4gICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4vKipcbiAqIFNldCB0aGUgY2x1c3RlciB3b3JrZXIgb3IgbWFjaGluZSBpZFxuICogZXhwb3NlZCBhcyBzaG9ydGlkLndvcmtlcihpbnQpXG4gKiBAcGFyYW0gd29ya2VySWQgd29ya2VyIG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlci4gIE51bWJlciBsZXNzIHRoYW4gMTYgaXMgcmVjb21tZW5kZWQuXG4gKiByZXR1cm5zIHNob3J0aWQgbW9kdWxlIHNvIGl0IGNhbiBiZSBjaGFpbmVkLlxuICovXG5mdW5jdGlvbiB3b3JrZXIod29ya2VySWQpIHtcbiAgICBjbHVzdGVyV29ya2VySWQgPSB3b3JrZXJJZDtcbiAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbi8qKlxuICpcbiAqIHNldHMgbmV3IGNoYXJhY3RlcnMgdG8gdXNlIGluIHRoZSBhbHBoYWJldFxuICogcmV0dXJucyB0aGUgc2h1ZmZsZWQgYWxwaGFiZXRcbiAqL1xuZnVuY3Rpb24gY2hhcmFjdGVycyhuZXdDaGFyYWN0ZXJzKSB7XG4gICAgaWYgKG5ld0NoYXJhY3RlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhbHBoYWJldC5jaGFyYWN0ZXJzKG5ld0NoYXJhY3RlcnMpO1xuICAgIH1cblxuICAgIHJldHVybiBhbHBoYWJldC5zaHVmZmxlZCgpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIHVuaXF1ZSBpZFxuICogUmV0dXJucyBzdHJpbmcgaWRcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGUoKSB7XG4gIHJldHVybiBidWlsZChjbHVzdGVyV29ya2VySWQpO1xufVxuXG4vLyBFeHBvcnQgYWxsIG90aGVyIGZ1bmN0aW9ucyBhcyBwcm9wZXJ0aWVzIG9mIHRoZSBnZW5lcmF0ZSBmdW5jdGlvblxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmF0ZTtcbm1vZHVsZS5leHBvcnRzLmdlbmVyYXRlID0gZ2VuZXJhdGU7XG5tb2R1bGUuZXhwb3J0cy5zZWVkID0gc2VlZDtcbm1vZHVsZS5leHBvcnRzLndvcmtlciA9IHdvcmtlcjtcbm1vZHVsZS5leHBvcnRzLmNoYXJhY3RlcnMgPSBjaGFyYWN0ZXJzO1xubW9kdWxlLmV4cG9ydHMuaXNWYWxpZCA9IGlzVmFsaWQ7XG4iLCJtb2R1bGUuZXhwb3J0cz1bXG4gICAgXCLnmoRcIixcbiAgICBcIuS4gFwiLFxuICAgIFwi5pivXCIsXG4gICAgXCLlnKhcIixcbiAgICBcIuS4jVwiLFxuICAgIFwi5LqGXCIsXG4gICAgXCLmnIlcIixcbiAgICBcIuWSjFwiLFxuICAgIFwi5Lq6XCIsXG4gICAgXCLov5lcIixcbiAgICBcIuS4rVwiLFxuICAgIFwi5aSnXCIsXG4gICAgXCLkuLpcIixcbiAgICBcIuS4ilwiLFxuICAgIFwi5LiqXCIsXG4gICAgXCLlm71cIixcbiAgICBcIuaIkVwiLFxuICAgIFwi5LulXCIsXG4gICAgXCLopoFcIixcbiAgICBcIuS7llwiLFxuICAgIFwi5pe2XCIsXG4gICAgXCLmnaVcIixcbiAgICBcIueUqFwiLFxuICAgIFwi5LusXCIsXG4gICAgXCLnlJ9cIixcbiAgICBcIuWIsFwiLFxuICAgIFwi5L2cXCIsXG4gICAgXCLlnLBcIixcbiAgICBcIuS6jlwiLFxuICAgIFwi5Ye6XCIsXG4gICAgXCLlsLFcIixcbiAgICBcIuWIhlwiLFxuICAgIFwi5a+5XCIsXG4gICAgXCLmiJBcIixcbiAgICBcIuS8mlwiLFxuICAgIFwi5Y+vXCIsXG4gICAgXCLkuLtcIixcbiAgICBcIuWPkVwiLFxuICAgIFwi5bm0XCIsXG4gICAgXCLliqhcIixcbiAgICBcIuWQjFwiLFxuICAgIFwi5belXCIsXG4gICAgXCLkuZ9cIixcbiAgICBcIuiDvVwiLFxuICAgIFwi5LiLXCIsXG4gICAgXCLov4dcIixcbiAgICBcIuWtkFwiLFxuICAgIFwi6K+0XCIsXG4gICAgXCLkuqdcIixcbiAgICBcIuenjVwiLFxuICAgIFwi6Z2iXCIsXG4gICAgXCLogIxcIixcbiAgICBcIuaWuVwiLFxuICAgIFwi5ZCOXCIsXG4gICAgXCLlpJpcIixcbiAgICBcIuWumlwiLFxuICAgIFwi6KGMXCIsXG4gICAgXCLlraZcIixcbiAgICBcIuazlVwiLFxuICAgIFwi5omAXCIsXG4gICAgXCLmsJFcIixcbiAgICBcIuW+l1wiLFxuICAgIFwi57uPXCIsXG4gICAgXCLljYFcIixcbiAgICBcIuS4iVwiLFxuICAgIFwi5LmLXCIsXG4gICAgXCLov5tcIixcbiAgICBcIuedgFwiLFxuICAgIFwi562JXCIsXG4gICAgXCLpg6hcIixcbiAgICBcIuW6plwiLFxuICAgIFwi5a62XCIsXG4gICAgXCLnlLVcIixcbiAgICBcIuWKm1wiLFxuICAgIFwi6YeMXCIsXG4gICAgXCLlpoJcIixcbiAgICBcIuawtFwiLFxuICAgIFwi5YyWXCIsXG4gICAgXCLpq5hcIixcbiAgICBcIuiHqlwiLFxuICAgIFwi5LqMXCIsXG4gICAgXCLnkIZcIixcbiAgICBcIui1t1wiLFxuICAgIFwi5bCPXCIsXG4gICAgXCLnialcIixcbiAgICBcIueOsFwiLFxuICAgIFwi5a6eXCIsXG4gICAgXCLliqBcIixcbiAgICBcIumHj1wiLFxuICAgIFwi6YO9XCIsXG4gICAgXCLkuKRcIixcbiAgICBcIuS9k1wiLFxuICAgIFwi5Yi2XCIsXG4gICAgXCLmnLpcIixcbiAgICBcIuW9k1wiLFxuICAgIFwi5L2/XCIsXG4gICAgXCLngrlcIixcbiAgICBcIuS7jlwiLFxuICAgIFwi5LiaXCIsXG4gICAgXCLmnKxcIixcbiAgICBcIuWOu1wiLFxuICAgIFwi5oqKXCIsXG4gICAgXCLmgKdcIixcbiAgICBcIuWlvVwiLFxuICAgIFwi5bqUXCIsXG4gICAgXCLlvIBcIixcbiAgICBcIuWug1wiLFxuICAgIFwi5ZCIXCIsXG4gICAgXCLov5hcIixcbiAgICBcIuWboFwiLFxuICAgIFwi55SxXCIsXG4gICAgXCLlhbZcIixcbiAgICBcIuS6m1wiLFxuICAgIFwi54S2XCIsXG4gICAgXCLliY1cIixcbiAgICBcIuWkllwiLFxuICAgIFwi5aSpXCIsXG4gICAgXCLmlL9cIixcbiAgICBcIuWbm1wiLFxuICAgIFwi5pelXCIsXG4gICAgXCLpgqNcIixcbiAgICBcIuekvlwiLFxuICAgIFwi5LmJXCIsXG4gICAgXCLkuotcIixcbiAgICBcIuW5s1wiLFxuICAgIFwi5b2iXCIsXG4gICAgXCLnm7hcIixcbiAgICBcIuWFqFwiLFxuICAgIFwi6KGoXCIsXG4gICAgXCLpl7RcIixcbiAgICBcIuagt1wiLFxuICAgIFwi5LiOXCIsXG4gICAgXCLlhbNcIixcbiAgICBcIuWQhFwiLFxuICAgIFwi6YeNXCIsXG4gICAgXCLmlrBcIixcbiAgICBcIue6v1wiLFxuICAgIFwi5YaFXCIsXG4gICAgXCLmlbBcIixcbiAgICBcIuato1wiLFxuICAgIFwi5b+DXCIsXG4gICAgXCLlj41cIixcbiAgICBcIuS9oFwiLFxuICAgIFwi5piOXCIsXG4gICAgXCLnnItcIixcbiAgICBcIuWOn1wiLFxuICAgIFwi5Y+IXCIsXG4gICAgXCLkuYhcIixcbiAgICBcIuWIqVwiLFxuICAgIFwi5q+UXCIsXG4gICAgXCLmiJZcIixcbiAgICBcIuS9hlwiLFxuICAgIFwi6LSoXCIsXG4gICAgXCLmsJRcIixcbiAgICBcIuesrFwiLFxuICAgIFwi5ZCRXCIsXG4gICAgXCLpgZNcIixcbiAgICBcIuWRvVwiLFxuICAgIFwi5q2kXCIsXG4gICAgXCLlj5hcIixcbiAgICBcIuadoVwiLFxuICAgIFwi5Y+qXCIsXG4gICAgXCLmsqFcIixcbiAgICBcIue7k1wiLFxuICAgIFwi6KejXCIsXG4gICAgXCLpl65cIixcbiAgICBcIuaEj1wiLFxuICAgIFwi5bu6XCIsXG4gICAgXCLmnIhcIixcbiAgICBcIuWFrFwiLFxuICAgIFwi5pegXCIsXG4gICAgXCLns7tcIixcbiAgICBcIuWGm1wiLFxuICAgIFwi5b6IXCIsXG4gICAgXCLmg4VcIixcbiAgICBcIuiAhVwiLFxuICAgIFwi5pyAXCIsXG4gICAgXCLnq4tcIixcbiAgICBcIuS7o1wiLFxuICAgIFwi5oOzXCIsXG4gICAgXCLlt7JcIixcbiAgICBcIumAmlwiLFxuICAgIFwi5bm2XCIsXG4gICAgXCLmj5BcIixcbiAgICBcIuebtFwiLFxuICAgIFwi6aKYXCIsXG4gICAgXCLlhZpcIixcbiAgICBcIueoi1wiLFxuICAgIFwi5bGVXCIsXG4gICAgXCLkupRcIixcbiAgICBcIuaenFwiLFxuICAgIFwi5paZXCIsXG4gICAgXCLosaFcIixcbiAgICBcIuWRmFwiLFxuICAgIFwi6Z2pXCIsXG4gICAgXCLkvY1cIixcbiAgICBcIuWFpVwiLFxuICAgIFwi5bi4XCIsXG4gICAgXCLmlodcIixcbiAgICBcIuaAu1wiLFxuICAgIFwi5qyhXCIsXG4gICAgXCLlk4FcIixcbiAgICBcIuW8j1wiLFxuICAgIFwi5rS7XCIsXG4gICAgXCLorr5cIixcbiAgICBcIuWPilwiLFxuICAgIFwi566hXCIsXG4gICAgXCLniblcIixcbiAgICBcIuS7tlwiLFxuICAgIFwi6ZW/XCIsXG4gICAgXCLmsYJcIixcbiAgICBcIuiAgVwiLFxuICAgIFwi5aS0XCIsXG4gICAgXCLln7pcIixcbiAgICBcIui1hFwiLFxuICAgIFwi6L65XCIsXG4gICAgXCLmtYFcIixcbiAgICBcIui3r1wiLFxuICAgIFwi57qnXCIsXG4gICAgXCLlsJFcIixcbiAgICBcIuWbvlwiLFxuICAgIFwi5bGxXCIsXG4gICAgXCLnu59cIixcbiAgICBcIuaOpVwiLFxuICAgIFwi55+lXCIsXG4gICAgXCLovoNcIixcbiAgICBcIuWwhlwiLFxuICAgIFwi57uEXCIsXG4gICAgXCLop4FcIixcbiAgICBcIuiuoVwiLFxuICAgIFwi5YirXCIsXG4gICAgXCLlpblcIixcbiAgICBcIuaJi1wiLFxuICAgIFwi6KeSXCIsXG4gICAgXCLmnJ9cIixcbiAgICBcIuaguVwiLFxuICAgIFwi6K66XCIsXG4gICAgXCLov5BcIixcbiAgICBcIuWGnFwiLFxuICAgIFwi5oyHXCIsXG4gICAgXCLlh6BcIixcbiAgICBcIuS5nVwiLFxuICAgIFwi5Yy6XCIsXG4gICAgXCLlvLpcIixcbiAgICBcIuaUvlwiLFxuICAgIFwi5YazXCIsXG4gICAgXCLopb9cIixcbiAgICBcIuiiq1wiLFxuICAgIFwi5bmyXCIsXG4gICAgXCLlgZpcIixcbiAgICBcIuW/hVwiLFxuICAgIFwi5oiYXCIsXG4gICAgXCLlhYhcIixcbiAgICBcIuWbnlwiLFxuICAgIFwi5YiZXCIsXG4gICAgXCLku7tcIixcbiAgICBcIuWPllwiLFxuICAgIFwi5o2uXCIsXG4gICAgXCLlpIRcIixcbiAgICBcIumYn1wiLFxuICAgIFwi5Y2XXCIsXG4gICAgXCLnu5lcIixcbiAgICBcIuiJslwiLFxuICAgIFwi5YWJXCIsXG4gICAgXCLpl6hcIixcbiAgICBcIuWNs1wiLFxuICAgIFwi5L+dXCIsXG4gICAgXCLmsrtcIixcbiAgICBcIuWMl1wiLFxuICAgIFwi6YCgXCIsXG4gICAgXCLnmb5cIixcbiAgICBcIuinhFwiLFxuICAgIFwi54OtXCIsXG4gICAgXCLpooZcIixcbiAgICBcIuS4g1wiLFxuICAgIFwi5rW3XCIsXG4gICAgXCLlj6NcIixcbiAgICBcIuS4nFwiLFxuICAgIFwi5a+8XCIsXG4gICAgXCLlmahcIixcbiAgICBcIuWOi1wiLFxuICAgIFwi5b+XXCIsXG4gICAgXCLkuJZcIixcbiAgICBcIumHkVwiLFxuICAgIFwi5aKeXCIsXG4gICAgXCLkuolcIixcbiAgICBcIua1jlwiLFxuICAgIFwi6Zi2XCIsXG4gICAgXCLmsrlcIixcbiAgICBcIuaAnVwiLFxuICAgIFwi5pyvXCIsXG4gICAgXCLmnoFcIixcbiAgICBcIuS6pFwiLFxuICAgIFwi5Y+XXCIsXG4gICAgXCLogZRcIixcbiAgICBcIuS7gFwiLFxuICAgIFwi6K6kXCIsXG4gICAgXCLlha1cIixcbiAgICBcIuWFsVwiLFxuICAgIFwi5p2DXCIsXG4gICAgXCLmlLZcIixcbiAgICBcIuivgVwiLFxuICAgIFwi5pS5XCIsXG4gICAgXCLmuIVcIixcbiAgICBcIue+jlwiLFxuICAgIFwi5YaNXCIsXG4gICAgXCLph4dcIixcbiAgICBcIui9rFwiLFxuICAgIFwi5pu0XCIsXG4gICAgXCLljZVcIixcbiAgICBcIumjjlwiLFxuICAgIFwi5YiHXCIsXG4gICAgXCLmiZNcIixcbiAgICBcIueZvVwiLFxuICAgIFwi5pWZXCIsXG4gICAgXCLpgJ9cIixcbiAgICBcIuiKsVwiLFxuICAgIFwi5bimXCIsXG4gICAgXCLlrolcIixcbiAgICBcIuWculwiLFxuICAgIFwi6LqrXCIsXG4gICAgXCLovaZcIixcbiAgICBcIuS+i1wiLFxuICAgIFwi55yfXCIsXG4gICAgXCLliqFcIixcbiAgICBcIuWFt1wiLFxuICAgIFwi5LiHXCIsXG4gICAgXCLmr49cIixcbiAgICBcIuebrlwiLFxuICAgIFwi6IezXCIsXG4gICAgXCLovr5cIixcbiAgICBcIui1sFwiLFxuICAgIFwi56evXCIsXG4gICAgXCLnpLpcIixcbiAgICBcIuiurlwiLFxuICAgIFwi5aOwXCIsXG4gICAgXCLmiqVcIixcbiAgICBcIuaWl1wiLFxuICAgIFwi5a6MXCIsXG4gICAgXCLnsbtcIixcbiAgICBcIuWFq1wiLFxuICAgIFwi56a7XCIsXG4gICAgXCLljY5cIixcbiAgICBcIuWQjVwiLFxuICAgIFwi56GuXCIsXG4gICAgXCLmiY1cIixcbiAgICBcIuenkVwiLFxuICAgIFwi5bygXCIsXG4gICAgXCLkv6FcIixcbiAgICBcIumprFwiLFxuICAgIFwi6IqCXCIsXG4gICAgXCLor51cIixcbiAgICBcIuexs1wiLFxuICAgIFwi5pW0XCIsXG4gICAgXCLnqbpcIixcbiAgICBcIuWFg1wiLFxuICAgIFwi5Ya1XCIsXG4gICAgXCLku4pcIixcbiAgICBcIumbhlwiLFxuICAgIFwi5ripXCIsXG4gICAgXCLkvKBcIixcbiAgICBcIuWcn1wiLFxuICAgIFwi6K64XCIsXG4gICAgXCLmraVcIixcbiAgICBcIue+pFwiLFxuICAgIFwi5bm/XCIsXG4gICAgXCLnn7NcIixcbiAgICBcIuiusFwiLFxuICAgIFwi6ZyAXCIsXG4gICAgXCLmrrVcIixcbiAgICBcIueglFwiLFxuICAgIFwi55WMXCIsXG4gICAgXCLmi4lcIixcbiAgICBcIuael1wiLFxuICAgIFwi5b6LXCIsXG4gICAgXCLlj6tcIixcbiAgICBcIuS4lFwiLFxuICAgIFwi56m2XCIsXG4gICAgXCLop4JcIixcbiAgICBcIui2ilwiLFxuICAgIFwi57uHXCIsXG4gICAgXCLoo4VcIixcbiAgICBcIuW9sVwiLFxuICAgIFwi566XXCIsXG4gICAgXCLkvY5cIixcbiAgICBcIuaMgVwiLFxuICAgIFwi6Z+zXCIsXG4gICAgXCLkvJdcIixcbiAgICBcIuS5plwiLFxuICAgIFwi5biDXCIsXG4gICAgXCLlpI1cIixcbiAgICBcIuWuuVwiLFxuICAgIFwi5YS/XCIsXG4gICAgXCLpobtcIixcbiAgICBcIumZhVwiLFxuICAgIFwi5ZWGXCIsXG4gICAgXCLpnZ5cIixcbiAgICBcIumqjFwiLFxuICAgIFwi6L+eXCIsXG4gICAgXCLmlq1cIixcbiAgICBcIua3sVwiLFxuICAgIFwi6Zq+XCIsXG4gICAgXCLov5FcIixcbiAgICBcIuefv1wiLFxuICAgIFwi5Y2DXCIsXG4gICAgXCLlkahcIixcbiAgICBcIuWnlFwiLFxuICAgIFwi57SgXCIsXG4gICAgXCLmioBcIixcbiAgICBcIuWkh1wiLFxuICAgIFwi5Y2KXCIsXG4gICAgXCLlip5cIixcbiAgICBcIumdklwiLFxuICAgIFwi55yBXCIsXG4gICAgXCLliJdcIixcbiAgICBcIuS5oFwiLFxuICAgIFwi5ZONXCIsXG4gICAgXCLnuqZcIixcbiAgICBcIuaUr1wiLFxuICAgIFwi6IisXCIsXG4gICAgXCLlj7JcIixcbiAgICBcIuaEn1wiLFxuICAgIFwi5YqzXCIsXG4gICAgXCLkvr9cIixcbiAgICBcIuWbolwiLFxuICAgIFwi5b6AXCIsXG4gICAgXCLphbhcIixcbiAgICBcIuWOhlwiLFxuICAgIFwi5biCXCIsXG4gICAgXCLlhYtcIixcbiAgICBcIuS9lVwiLFxuICAgIFwi6ZmkXCIsXG4gICAgXCLmtohcIixcbiAgICBcIuaehFwiLFxuICAgIFwi5bqcXCIsXG4gICAgXCLnp7BcIixcbiAgICBcIuWkqlwiLFxuICAgIFwi5YeGXCIsXG4gICAgXCLnsr5cIixcbiAgICBcIuWAvFwiLFxuICAgIFwi5Y+3XCIsXG4gICAgXCLnjodcIixcbiAgICBcIuaXj1wiLFxuICAgIFwi57u0XCIsXG4gICAgXCLliJJcIixcbiAgICBcIumAiVwiLFxuICAgIFwi5qCHXCIsXG4gICAgXCLlhplcIixcbiAgICBcIuWtmFwiLFxuICAgIFwi5YCZXCIsXG4gICAgXCLmr5tcIixcbiAgICBcIuS6slwiLFxuICAgIFwi5b+rXCIsXG4gICAgXCLmlYhcIixcbiAgICBcIuaWr1wiLFxuICAgIFwi6ZmiXCIsXG4gICAgXCLmn6VcIixcbiAgICBcIuaxn1wiLFxuICAgIFwi5Z6LXCIsXG4gICAgXCLnnLxcIixcbiAgICBcIueOi1wiLFxuICAgIFwi5oyJXCIsXG4gICAgXCLmoLxcIixcbiAgICBcIuWFu1wiLFxuICAgIFwi5piTXCIsXG4gICAgXCLnva5cIixcbiAgICBcIua0vlwiLFxuICAgIFwi5bGCXCIsXG4gICAgXCLniYdcIixcbiAgICBcIuWni1wiLFxuICAgIFwi5Y20XCIsXG4gICAgXCLkuJNcIixcbiAgICBcIueKtlwiLFxuICAgIFwi6IKyXCIsXG4gICAgXCLljoJcIixcbiAgICBcIuS6rFwiLFxuICAgIFwi6K+GXCIsXG4gICAgXCLpgIJcIixcbiAgICBcIuWxnlwiLFxuICAgIFwi5ZyGXCIsXG4gICAgXCLljIVcIixcbiAgICBcIueBq1wiLFxuICAgIFwi5L2PXCIsXG4gICAgXCLosINcIixcbiAgICBcIua7oVwiLFxuICAgIFwi5Y6/XCIsXG4gICAgXCLlsYBcIixcbiAgICBcIueFp1wiLFxuICAgIFwi5Y+CXCIsXG4gICAgXCLnuqJcIixcbiAgICBcIue7hlwiLFxuICAgIFwi5byVXCIsXG4gICAgXCLlkKxcIixcbiAgICBcIuivpVwiLFxuICAgIFwi6ZOBXCIsXG4gICAgXCLku7dcIixcbiAgICBcIuS4pVwiLFxuICAgIFwi6aaWXCIsXG4gICAgXCLlupVcIixcbiAgICBcIua2slwiLFxuICAgIFwi5a6YXCIsXG4gICAgXCLlvrdcIixcbiAgICBcIumaj1wiLFxuICAgIFwi55eFXCIsXG4gICAgXCLoi49cIixcbiAgICBcIuWksVwiLFxuICAgIFwi5bCUXCIsXG4gICAgXCLmrbtcIixcbiAgICBcIuiuslwiLFxuICAgIFwi6YWNXCIsXG4gICAgXCLlpbNcIixcbiAgICBcIum7hFwiLFxuICAgIFwi5o6oXCIsXG4gICAgXCLmmL5cIixcbiAgICBcIuiwiFwiLFxuICAgIFwi572qXCIsXG4gICAgXCLnpZ5cIixcbiAgICBcIuiJulwiLFxuICAgIFwi5ZGiXCIsXG4gICAgXCLluK1cIixcbiAgICBcIuWQq1wiLFxuICAgIFwi5LyBXCIsXG4gICAgXCLmnJtcIixcbiAgICBcIuWvhlwiLFxuICAgIFwi5om5XCIsXG4gICAgXCLokKVcIixcbiAgICBcIumhuVwiLFxuICAgIFwi6ZiyXCIsXG4gICAgXCLkuL5cIixcbiAgICBcIueQg1wiLFxuICAgIFwi6IuxXCIsXG4gICAgXCLmsKdcIixcbiAgICBcIuWKv1wiLFxuICAgIFwi5ZGKXCIsXG4gICAgXCLmnY5cIixcbiAgICBcIuWPsFwiLFxuICAgIFwi6JC9XCIsXG4gICAgXCLmnKhcIixcbiAgICBcIuW4rlwiLFxuICAgIFwi6L2uXCIsXG4gICAgXCLnoLRcIixcbiAgICBcIuS6mlwiLFxuICAgIFwi5biIXCIsXG4gICAgXCLlm7RcIixcbiAgICBcIuazqFwiLFxuICAgIFwi6L+cXCIsXG4gICAgXCLlrZdcIixcbiAgICBcIuadkFwiLFxuICAgIFwi5o6SXCIsXG4gICAgXCLkvptcIixcbiAgICBcIuays1wiLFxuICAgIFwi5oCBXCIsXG4gICAgXCLlsIFcIixcbiAgICBcIuWPplwiLFxuICAgIFwi5pa9XCIsXG4gICAgXCLlh49cIixcbiAgICBcIuagkVwiLFxuICAgIFwi5rq2XCIsXG4gICAgXCLmgI5cIixcbiAgICBcIuatolwiLFxuICAgIFwi5qGIXCIsXG4gICAgXCLoqIBcIixcbiAgICBcIuWjq1wiLFxuICAgIFwi5Z2HXCIsXG4gICAgXCLmraZcIixcbiAgICBcIuWbulwiLFxuICAgIFwi5Y+2XCIsXG4gICAgXCLpsbxcIixcbiAgICBcIuazolwiLFxuICAgIFwi6KeGXCIsXG4gICAgXCLku4VcIixcbiAgICBcIui0uVwiLFxuICAgIFwi57SnXCIsXG4gICAgXCLniLFcIixcbiAgICBcIuW3plwiLFxuICAgIFwi56ugXCIsXG4gICAgXCLml6lcIixcbiAgICBcIuacnVwiLFxuICAgIFwi5a6zXCIsXG4gICAgXCLnu61cIixcbiAgICBcIui9u1wiLFxuICAgIFwi5pyNXCIsXG4gICAgXCLor5VcIixcbiAgICBcIumjn1wiLFxuICAgIFwi5YWFXCIsXG4gICAgXCLlhbVcIixcbiAgICBcIua6kFwiLFxuICAgIFwi5YikXCIsXG4gICAgXCLmiqRcIixcbiAgICBcIuWPuFwiLFxuICAgIFwi6LazXCIsXG4gICAgXCLmn5BcIixcbiAgICBcIue7g1wiLFxuICAgIFwi5beuXCIsXG4gICAgXCLoh7RcIixcbiAgICBcIuadv1wiLFxuICAgIFwi55SwXCIsXG4gICAgXCLpmY1cIixcbiAgICBcIum7kVwiLFxuICAgIFwi54qvXCIsXG4gICAgXCLotJ9cIixcbiAgICBcIuWHu1wiLFxuICAgIFwi6IyDXCIsXG4gICAgXCLnu6dcIixcbiAgICBcIuWFtFwiLFxuICAgIFwi5Ly8XCIsXG4gICAgXCLkvZlcIixcbiAgICBcIuWdmlwiLFxuICAgIFwi5puyXCIsXG4gICAgXCLovpNcIixcbiAgICBcIuS/rlwiLFxuICAgIFwi5pWFXCIsXG4gICAgXCLln45cIixcbiAgICBcIuWkq1wiLFxuICAgIFwi5aSfXCIsXG4gICAgXCLpgIFcIixcbiAgICBcIueslFwiLFxuICAgIFwi6Ii5XCIsXG4gICAgXCLljaBcIixcbiAgICBcIuWPs1wiLFxuICAgIFwi6LSiXCIsXG4gICAgXCLlkINcIixcbiAgICBcIuWvjFwiLFxuICAgIFwi5pilXCIsXG4gICAgXCLogYxcIixcbiAgICBcIuiniVwiLFxuICAgIFwi5rGJXCIsXG4gICAgXCLnlLtcIixcbiAgICBcIuWKn1wiLFxuICAgIFwi5be0XCIsXG4gICAgXCLot59cIixcbiAgICBcIuiZvVwiLFxuICAgIFwi5p2CXCIsXG4gICAgXCLpo55cIixcbiAgICBcIuajgFwiLFxuICAgIFwi5ZC4XCIsXG4gICAgXCLliqlcIixcbiAgICBcIuWNh1wiLFxuICAgIFwi6ZizXCIsXG4gICAgXCLkupJcIixcbiAgICBcIuWInVwiLFxuICAgIFwi5YibXCIsXG4gICAgXCLmipdcIixcbiAgICBcIuiAg1wiLFxuICAgIFwi5oqVXCIsXG4gICAgXCLlnY9cIixcbiAgICBcIuetllwiLFxuICAgIFwi5Y+kXCIsXG4gICAgXCLlvoRcIixcbiAgICBcIuaNolwiLFxuICAgIFwi5pyqXCIsXG4gICAgXCLot5FcIixcbiAgICBcIueVmVwiLFxuICAgIFwi6ZKiXCIsXG4gICAgXCLmm75cIixcbiAgICBcIuerr1wiLFxuICAgIFwi6LSjXCIsXG4gICAgXCLnq5lcIixcbiAgICBcIueugFwiLFxuICAgIFwi6L+wXCIsXG4gICAgXCLpkrFcIixcbiAgICBcIuWJr1wiLFxuICAgIFwi5bC9XCIsXG4gICAgXCLluJ1cIixcbiAgICBcIuWwhFwiLFxuICAgIFwi6I2JXCIsXG4gICAgXCLlhrJcIixcbiAgICBcIuaJv1wiLFxuICAgIFwi54usXCIsXG4gICAgXCLku6RcIixcbiAgICBcIumZkFwiLFxuICAgIFwi6Zi/XCIsXG4gICAgXCLlrqNcIixcbiAgICBcIueOr1wiLFxuICAgIFwi5Y+MXCIsXG4gICAgXCLor7dcIixcbiAgICBcIui2hVwiLFxuICAgIFwi5b6uXCIsXG4gICAgXCLorqlcIixcbiAgICBcIuaOp1wiLFxuICAgIFwi5beeXCIsXG4gICAgXCLoia9cIixcbiAgICBcIui9tFwiLFxuICAgIFwi5om+XCIsXG4gICAgXCLlkKZcIixcbiAgICBcIue6qlwiLFxuICAgIFwi55uKXCIsXG4gICAgXCLkvp1cIixcbiAgICBcIuS8mFwiLFxuICAgIFwi6aG2XCIsXG4gICAgXCLnoYBcIixcbiAgICBcIui9vVwiLFxuICAgIFwi5YCSXCIsXG4gICAgXCLmiL9cIixcbiAgICBcIueqgVwiLFxuICAgIFwi5Z2QXCIsXG4gICAgXCLnsolcIixcbiAgICBcIuaVjFwiLFxuICAgIFwi55WlXCIsXG4gICAgXCLlrqJcIixcbiAgICBcIuiigVwiLFxuICAgIFwi5Ya3XCIsXG4gICAgXCLog5xcIixcbiAgICBcIue7nVwiLFxuICAgIFwi5p6QXCIsXG4gICAgXCLlnZdcIixcbiAgICBcIuWJglwiLFxuICAgIFwi5rWLXCIsXG4gICAgXCLkuJ1cIixcbiAgICBcIuWNj1wiLFxuICAgIFwi6K+JXCIsXG4gICAgXCLlv7VcIixcbiAgICBcIumZiFwiLFxuICAgIFwi5LuNXCIsXG4gICAgXCLnvZdcIixcbiAgICBcIuebkFwiLFxuICAgIFwi5Y+LXCIsXG4gICAgXCLmtItcIixcbiAgICBcIumUmVwiLFxuICAgIFwi6IumXCIsXG4gICAgXCLlpJxcIixcbiAgICBcIuWIkVwiLFxuICAgIFwi56e7XCIsXG4gICAgXCLpopFcIixcbiAgICBcIumAkFwiLFxuICAgIFwi6Z2gXCIsXG4gICAgXCLmt7dcIixcbiAgICBcIuavjVwiLFxuICAgIFwi55+tXCIsXG4gICAgXCLnmq5cIixcbiAgICBcIue7iFwiLFxuICAgIFwi6IGaXCIsXG4gICAgXCLmsb1cIixcbiAgICBcIuadkVwiLFxuICAgIFwi5LqRXCIsXG4gICAgXCLlk6pcIixcbiAgICBcIuaXolwiLFxuICAgIFwi6LedXCIsXG4gICAgXCLljatcIixcbiAgICBcIuWBnFwiLFxuICAgIFwi54OIXCIsXG4gICAgXCLlpK5cIixcbiAgICBcIuWvn1wiLFxuICAgIFwi54OnXCIsXG4gICAgXCLov4VcIixcbiAgICBcIuWig1wiLFxuICAgIFwi6IulXCIsXG4gICAgXCLljbBcIixcbiAgICBcIua0slwiLFxuICAgIFwi5Yi7XCIsXG4gICAgXCLmi6xcIixcbiAgICBcIua/gFwiLFxuICAgIFwi5a2UXCIsXG4gICAgXCLmkJ5cIixcbiAgICBcIueUmlwiLFxuICAgIFwi5a6kXCIsXG4gICAgXCLlvoVcIixcbiAgICBcIuaguFwiLFxuICAgIFwi5qChXCIsXG4gICAgXCLmlaNcIixcbiAgICBcIuS+tVwiLFxuICAgIFwi5ZCnXCIsXG4gICAgXCLnlLJcIixcbiAgICBcIua4uFwiLFxuICAgIFwi5LmFXCIsXG4gICAgXCLoj5xcIixcbiAgICBcIuWRs1wiLFxuICAgIFwi5penXCIsXG4gICAgXCLmqKFcIixcbiAgICBcIua5llwiLFxuICAgIFwi6LSnXCIsXG4gICAgXCLmjZ9cIixcbiAgICBcIumihFwiLFxuICAgIFwi6Zi7XCIsXG4gICAgXCLmr6tcIixcbiAgICBcIuaZrlwiLFxuICAgIFwi56izXCIsXG4gICAgXCLkuZlcIixcbiAgICBcIuWmiFwiLFxuICAgIFwi5qSNXCIsXG4gICAgXCLmga9cIixcbiAgICBcIuaJqVwiLFxuICAgIFwi6ZO2XCIsXG4gICAgXCLor61cIixcbiAgICBcIuaMpVwiLFxuICAgIFwi6YWSXCIsXG4gICAgXCLlrohcIixcbiAgICBcIuaLv1wiLFxuICAgIFwi5bqPXCIsXG4gICAgXCLnurhcIixcbiAgICBcIuWMu1wiLFxuICAgIFwi57y6XCIsXG4gICAgXCLpm6hcIixcbiAgICBcIuWQl1wiLFxuICAgIFwi6ZKIXCIsXG4gICAgXCLliJhcIixcbiAgICBcIuWVilwiLFxuICAgIFwi5oClXCIsXG4gICAgXCLllLFcIixcbiAgICBcIuivr1wiLFxuICAgIFwi6K6tXCIsXG4gICAgXCLmhL9cIixcbiAgICBcIuWuoVwiLFxuICAgIFwi6ZmEXCIsXG4gICAgXCLojrdcIixcbiAgICBcIuiMtlwiLFxuICAgIFwi6bKcXCIsXG4gICAgXCLnsq5cIixcbiAgICBcIuaWpFwiLFxuICAgIFwi5a2pXCIsXG4gICAgXCLohLFcIixcbiAgICBcIuehq1wiLFxuICAgIFwi6IKlXCIsXG4gICAgXCLlloRcIixcbiAgICBcIum+mVwiLFxuICAgIFwi5ryUXCIsXG4gICAgXCLniLZcIixcbiAgICBcIua4kFwiLFxuICAgIFwi6KGAXCIsXG4gICAgXCLmrKJcIixcbiAgICBcIuaisFwiLFxuICAgIFwi5o6MXCIsXG4gICAgXCLmrYxcIixcbiAgICBcIuaymVwiLFxuICAgIFwi5YiaXCIsXG4gICAgXCLmlLtcIixcbiAgICBcIuiwk1wiLFxuICAgIFwi55u+XCIsXG4gICAgXCLorqhcIixcbiAgICBcIuaZmlwiLFxuICAgIFwi57KSXCIsXG4gICAgXCLkubFcIixcbiAgICBcIueHg1wiLFxuICAgIFwi55+bXCIsXG4gICAgXCLkuY5cIixcbiAgICBcIuadgFwiLFxuICAgIFwi6I2vXCIsXG4gICAgXCLlroFcIixcbiAgICBcIumygVwiLFxuICAgIFwi6LS1XCIsXG4gICAgXCLpkp9cIixcbiAgICBcIueFpFwiLFxuICAgIFwi6K+7XCIsXG4gICAgXCLnj61cIixcbiAgICBcIuS8r1wiLFxuICAgIFwi6aaZXCIsXG4gICAgXCLku4tcIixcbiAgICBcIui/q1wiLFxuICAgIFwi5Y+lXCIsXG4gICAgXCLkuLBcIixcbiAgICBcIuWfuVwiLFxuICAgIFwi5o+hXCIsXG4gICAgXCLlhbBcIixcbiAgICBcIuaLhVwiLFxuICAgIFwi5bymXCIsXG4gICAgXCLom4tcIixcbiAgICBcIuayiVwiLFxuICAgIFwi5YGHXCIsXG4gICAgXCLnqb9cIixcbiAgICBcIuaJp1wiLFxuICAgIFwi562UXCIsXG4gICAgXCLkuZBcIixcbiAgICBcIuiwgVwiLFxuICAgIFwi6aG6XCIsXG4gICAgXCLng59cIixcbiAgICBcIue8qVwiLFxuICAgIFwi5b6BXCIsXG4gICAgXCLohLhcIixcbiAgICBcIuWWnFwiLFxuICAgIFwi5p2+XCIsXG4gICAgXCLohJpcIixcbiAgICBcIuWbsFwiLFxuICAgIFwi5byCXCIsXG4gICAgXCLlhY1cIixcbiAgICBcIuiDjFwiLFxuICAgIFwi5pifXCIsXG4gICAgXCLnpo9cIixcbiAgICBcIuS5sFwiLFxuICAgIFwi5p+TXCIsXG4gICAgXCLkupVcIixcbiAgICBcIuamglwiLFxuICAgIFwi5oWiXCIsXG4gICAgXCLmgJVcIixcbiAgICBcIuejgVwiLFxuICAgIFwi5YCNXCIsXG4gICAgXCLnpZZcIixcbiAgICBcIueah1wiLFxuICAgIFwi5L+DXCIsXG4gICAgXCLpnZlcIixcbiAgICBcIuihpVwiLFxuICAgIFwi6K+EXCIsXG4gICAgXCLnv7tcIixcbiAgICBcIuiCiVwiLFxuICAgIFwi6Le1XCIsXG4gICAgXCLlsLxcIixcbiAgICBcIuiho1wiLFxuICAgIFwi5a69XCIsXG4gICAgXCLmiaxcIixcbiAgICBcIuajiVwiLFxuICAgIFwi5biMXCIsXG4gICAgXCLkvKRcIixcbiAgICBcIuaTjVwiLFxuICAgIFwi5Z6CXCIsXG4gICAgXCLnp4tcIixcbiAgICBcIuWunFwiLFxuICAgIFwi5rCiXCIsXG4gICAgXCLlpZdcIixcbiAgICBcIuedo1wiLFxuICAgIFwi5oyvXCIsXG4gICAgXCLmnrZcIixcbiAgICBcIuS6rlwiLFxuICAgIFwi5pyrXCIsXG4gICAgXCLlrqpcIixcbiAgICBcIuW6hlwiLFxuICAgIFwi57yWXCIsXG4gICAgXCLniZtcIixcbiAgICBcIuinplwiLFxuICAgIFwi5pigXCIsXG4gICAgXCLpm7dcIixcbiAgICBcIumUgFwiLFxuICAgIFwi6K+XXCIsXG4gICAgXCLluqdcIixcbiAgICBcIuWxhVwiLFxuICAgIFwi5oqTXCIsXG4gICAgXCLoo4JcIixcbiAgICBcIuiDnlwiLFxuICAgIFwi5ZG8XCIsXG4gICAgXCLlqJhcIixcbiAgICBcIuaZr1wiLFxuICAgIFwi5aiBXCIsXG4gICAgXCLnu79cIixcbiAgICBcIuaZtlwiLFxuICAgIFwi5Y6aXCIsXG4gICAgXCLnm59cIixcbiAgICBcIuihoVwiLFxuICAgIFwi6bihXCIsXG4gICAgXCLlrZlcIixcbiAgICBcIuW7tlwiLFxuICAgIFwi5Y2xXCIsXG4gICAgXCLog7ZcIixcbiAgICBcIuWxi1wiLFxuICAgIFwi5LmhXCIsXG4gICAgXCLkuLRcIixcbiAgICBcIumZhlwiLFxuICAgIFwi6aG+XCIsXG4gICAgXCLmjolcIixcbiAgICBcIuWRgFwiLFxuICAgIFwi54GvXCIsXG4gICAgXCLlsoFcIixcbiAgICBcIuaOqlwiLFxuICAgIFwi5p2fXCIsXG4gICAgXCLogJBcIixcbiAgICBcIuWJp1wiLFxuICAgIFwi546JXCIsXG4gICAgXCLotbVcIixcbiAgICBcIui3s1wiLFxuICAgIFwi5ZOlXCIsXG4gICAgXCLlraNcIixcbiAgICBcIuivvlwiLFxuICAgIFwi5YevXCIsXG4gICAgXCLog6FcIixcbiAgICBcIuminVwiLFxuICAgIFwi5qy+XCIsXG4gICAgXCLnu41cIixcbiAgICBcIuWNt1wiLFxuICAgIFwi6b2QXCIsXG4gICAgXCLkvJ9cIixcbiAgICBcIuiSuFwiLFxuICAgIFwi5q6WXCIsXG4gICAgXCLmsLhcIixcbiAgICBcIuWul1wiLFxuICAgIFwi6IuXXCIsXG4gICAgXCLlt51cIixcbiAgICBcIueCiVwiLFxuICAgIFwi5bKpXCIsXG4gICAgXCLlvLFcIixcbiAgICBcIumbtlwiLFxuICAgIFwi5p2oXCIsXG4gICAgXCLlpY9cIixcbiAgICBcIuayv1wiLFxuICAgIFwi6ZyyXCIsXG4gICAgXCLmnYZcIixcbiAgICBcIuaOolwiLFxuICAgIFwi5ruRXCIsXG4gICAgXCLplYdcIixcbiAgICBcIumlrVwiLFxuICAgIFwi5rWTXCIsXG4gICAgXCLoiKpcIixcbiAgICBcIuaAgFwiLFxuICAgIFwi6LW2XCIsXG4gICAgXCLlupNcIixcbiAgICBcIuWkulwiLFxuICAgIFwi5LyKXCIsXG4gICAgXCLngbVcIixcbiAgICBcIueojlwiLFxuICAgIFwi6YCUXCIsXG4gICAgXCLnga1cIixcbiAgICBcIui1m1wiLFxuICAgIFwi5b2SXCIsXG4gICAgXCLlj6xcIixcbiAgICBcIum8k1wiLFxuICAgIFwi5pKtXCIsXG4gICAgXCLnm5hcIixcbiAgICBcIuijgVwiLFxuICAgIFwi6ZmpXCIsXG4gICAgXCLlurdcIixcbiAgICBcIuWUr1wiLFxuICAgIFwi5b2VXCIsXG4gICAgXCLoj4xcIixcbiAgICBcIue6r1wiLFxuICAgIFwi5YCfXCIsXG4gICAgXCLns5ZcIixcbiAgICBcIuebllwiLFxuICAgIFwi5qiqXCIsXG4gICAgXCLnrKZcIixcbiAgICBcIuengVwiLFxuICAgIFwi5YqqXCIsXG4gICAgXCLloIJcIixcbiAgICBcIuWfn1wiLFxuICAgIFwi5p6qXCIsXG4gICAgXCLmtqZcIixcbiAgICBcIuW5hVwiLFxuICAgIFwi5ZOIXCIsXG4gICAgXCLnq59cIixcbiAgICBcIueGn1wiLFxuICAgIFwi6JmrXCIsXG4gICAgXCLms71cIixcbiAgICBcIuiEkVwiLFxuICAgIFwi5aOkXCIsXG4gICAgXCLnorNcIixcbiAgICBcIuasp1wiLFxuICAgIFwi6YGNXCIsXG4gICAgXCLkvqdcIixcbiAgICBcIuWvqFwiLFxuICAgIFwi5pWiXCIsXG4gICAgXCLlvbtcIixcbiAgICBcIuiZkVwiLFxuICAgIFwi5pacXCIsXG4gICAgXCLoloRcIixcbiAgICBcIuW6rVwiLFxuICAgIFwi57qzXCIsXG4gICAgXCLlvLlcIixcbiAgICBcIumlslwiLFxuICAgIFwi5Ly4XCIsXG4gICAgXCLmiphcIixcbiAgICBcIum6plwiLFxuICAgIFwi5rm/XCIsXG4gICAgXCLmmpdcIixcbiAgICBcIuiNt1wiLFxuICAgIFwi55OmXCIsXG4gICAgXCLloZ5cIixcbiAgICBcIuW6ilwiLFxuICAgIFwi562RXCIsXG4gICAgXCLmgbZcIixcbiAgICBcIuaIt1wiLFxuICAgIFwi6K6/XCIsXG4gICAgXCLloZRcIixcbiAgICBcIuWlh1wiLFxuICAgIFwi6YCPXCIsXG4gICAgXCLmooFcIixcbiAgICBcIuWIgFwiLFxuICAgIFwi5peLXCIsXG4gICAgXCLov7lcIixcbiAgICBcIuWNoVwiLFxuICAgIFwi5rCvXCIsXG4gICAgXCLpgYdcIixcbiAgICBcIuS7vVwiLFxuICAgIFwi5q+SXCIsXG4gICAgXCLms6VcIixcbiAgICBcIumAgFwiLFxuICAgIFwi5rSXXCIsXG4gICAgXCLmkYZcIixcbiAgICBcIueBsFwiLFxuICAgIFwi5b2pXCIsXG4gICAgXCLljZZcIixcbiAgICBcIuiAl1wiLFxuICAgIFwi5aSPXCIsXG4gICAgXCLmi6lcIixcbiAgICBcIuW/mVwiLFxuICAgIFwi6ZOcXCIsXG4gICAgXCLnjK5cIixcbiAgICBcIuehrFwiLFxuICAgIFwi5LqIXCIsXG4gICAgXCLnuYFcIixcbiAgICBcIuWciFwiLFxuICAgIFwi6ZuqXCIsXG4gICAgXCLlh71cIixcbiAgICBcIuS6plwiLFxuICAgIFwi5oq9XCIsXG4gICAgXCLnr4dcIixcbiAgICBcIumYtVwiLFxuICAgIFwi6Zi0XCIsXG4gICAgXCLkuIFcIixcbiAgICBcIuWwulwiLFxuICAgIFwi6L+9XCIsXG4gICAgXCLloIZcIixcbiAgICBcIumbhFwiLFxuICAgIFwi6L+OXCIsXG4gICAgXCLms5tcIixcbiAgICBcIueIuFwiLFxuICAgIFwi5qW8XCIsXG4gICAgXCLpgb9cIixcbiAgICBcIuiwi1wiLFxuICAgIFwi5ZCoXCIsXG4gICAgXCLph45cIixcbiAgICBcIueMqlwiLFxuICAgIFwi5peXXCIsXG4gICAgXCLntK9cIixcbiAgICBcIuWBj1wiLFxuICAgIFwi5YW4XCIsXG4gICAgXCLppoZcIixcbiAgICBcIue0olwiLFxuICAgIFwi56emXCIsXG4gICAgXCLohIJcIixcbiAgICBcIua9rlwiLFxuICAgIFwi54i3XCIsXG4gICAgXCLosYZcIixcbiAgICBcIuW/vVwiLFxuICAgIFwi5omYXCIsXG4gICAgXCLmg4pcIixcbiAgICBcIuWhkVwiLFxuICAgIFwi6YGXXCIsXG4gICAgXCLmhIhcIixcbiAgICBcIuacsVwiLFxuICAgIFwi5pu/XCIsXG4gICAgXCLnuqRcIixcbiAgICBcIueyl1wiLFxuICAgIFwi5YC+XCIsXG4gICAgXCLlsJpcIixcbiAgICBcIueXm1wiLFxuICAgIFwi5qWaXCIsXG4gICAgXCLosKJcIixcbiAgICBcIuWli1wiLFxuICAgIFwi6LStXCIsXG4gICAgXCLno6hcIixcbiAgICBcIuWQm1wiLFxuICAgIFwi5rGgXCIsXG4gICAgXCLml4FcIixcbiAgICBcIueijlwiLFxuICAgIFwi6aqoXCIsXG4gICAgXCLnm5FcIixcbiAgICBcIuaNlVwiLFxuICAgIFwi5byfXCIsXG4gICAgXCLmmrRcIixcbiAgICBcIuWJslwiLFxuICAgIFwi6LSvXCIsXG4gICAgXCLmropcIixcbiAgICBcIumHilwiLFxuICAgIFwi6K+NXCIsXG4gICAgXCLkuqFcIixcbiAgICBcIuWjgVwiLFxuICAgIFwi6aG/XCIsXG4gICAgXCLlrp1cIixcbiAgICBcIuWNiFwiLFxuICAgIFwi5bCYXCIsXG4gICAgXCLpl7tcIixcbiAgICBcIuaPrVwiLFxuICAgIFwi54KuXCIsXG4gICAgXCLmrotcIixcbiAgICBcIuWGrFwiLFxuICAgIFwi5qGlXCIsXG4gICAgXCLlpodcIixcbiAgICBcIuitplwiLFxuICAgIFwi57u8XCIsXG4gICAgXCLmi5tcIixcbiAgICBcIuWQtFwiLFxuICAgIFwi5LuYXCIsXG4gICAgXCLmta5cIixcbiAgICBcIumBrVwiLFxuICAgIFwi5b6QXCIsXG4gICAgXCLmgqhcIixcbiAgICBcIuaRh1wiLFxuICAgIFwi6LC3XCIsXG4gICAgXCLotZ5cIixcbiAgICBcIueusVwiLFxuICAgIFwi6ZqUXCIsXG4gICAgXCLorqJcIixcbiAgICBcIueUt1wiLFxuICAgIFwi5ZC5XCIsXG4gICAgXCLlm61cIixcbiAgICBcIue6t1wiLFxuICAgIFwi5ZSQXCIsXG4gICAgXCLotKVcIixcbiAgICBcIuWui1wiLFxuICAgIFwi5467XCIsXG4gICAgXCLlt6hcIixcbiAgICBcIuiAlVwiLFxuICAgIFwi5Z2mXCIsXG4gICAgXCLojaNcIixcbiAgICBcIumXrVwiLFxuICAgIFwi5rm+XCIsXG4gICAgXCLplK5cIixcbiAgICBcIuWHoVwiLFxuICAgIFwi6am7XCIsXG4gICAgXCLplIVcIixcbiAgICBcIuaVkVwiLFxuICAgIFwi5oGpXCIsXG4gICAgXCLliaVcIixcbiAgICBcIuWHnVwiLFxuICAgIFwi56KxXCIsXG4gICAgXCLpvb9cIixcbiAgICBcIuaIqlwiLFxuICAgIFwi54K8XCIsXG4gICAgXCLpurtcIixcbiAgICBcIue6ulwiLFxuICAgIFwi56aBXCIsXG4gICAgXCLlup9cIixcbiAgICBcIuebm1wiLFxuICAgIFwi54mIXCIsXG4gICAgXCLnvJNcIixcbiAgICBcIuWHgFwiLFxuICAgIFwi552bXCIsXG4gICAgXCLmmIxcIixcbiAgICBcIuWpmlwiLFxuICAgIFwi5raJXCIsXG4gICAgXCLnrZJcIixcbiAgICBcIuWYtFwiLFxuICAgIFwi5o+SXCIsXG4gICAgXCLlsrhcIixcbiAgICBcIuacl1wiLFxuICAgIFwi5bqEXCIsXG4gICAgXCLooZdcIixcbiAgICBcIuiXj1wiLFxuICAgIFwi5aeRXCIsXG4gICAgXCLotLhcIixcbiAgICBcIuiFkFwiLFxuICAgIFwi5aW0XCIsXG4gICAgXCLllaZcIixcbiAgICBcIuaDr1wiLFxuICAgIFwi5LmYXCIsXG4gICAgXCLkvJlcIixcbiAgICBcIuaBolwiLFxuICAgIFwi5YyAXCIsXG4gICAgXCLnurFcIixcbiAgICBcIuaJjlwiLFxuICAgIFwi6L6pXCIsXG4gICAgXCLogLNcIixcbiAgICBcIuW9qlwiLFxuICAgIFwi6IejXCIsXG4gICAgXCLkur9cIixcbiAgICBcIueSg1wiLFxuICAgIFwi5oq1XCIsXG4gICAgXCLohIlcIixcbiAgICBcIuengFwiLFxuICAgIFwi6JCoXCIsXG4gICAgXCLkv4RcIixcbiAgICBcIue9kVwiLFxuICAgIFwi6IieXCIsXG4gICAgXCLlupdcIixcbiAgICBcIuWWt1wiLFxuICAgIFwi57q1XCIsXG4gICAgXCLlr7hcIixcbiAgICBcIuaxl1wiLFxuICAgIFwi5oyCXCIsXG4gICAgXCLmtKpcIixcbiAgICBcIui0ulwiLFxuICAgIFwi6ZeqXCIsXG4gICAgXCLmn6xcIixcbiAgICBcIueIhlwiLFxuICAgIFwi54OvXCIsXG4gICAgXCLmtKVcIixcbiAgICBcIueou1wiLFxuICAgIFwi5aKZXCIsXG4gICAgXCLova9cIixcbiAgICBcIuWLh1wiLFxuICAgIFwi5YOPXCIsXG4gICAgXCLmu5pcIixcbiAgICBcIuWOmFwiLFxuICAgIFwi6JKZXCIsXG4gICAgXCLoirNcIixcbiAgICBcIuiCr1wiLFxuICAgIFwi5Z2hXCIsXG4gICAgXCLmn7FcIixcbiAgICBcIuiNoVwiLFxuICAgIFwi6IW/XCIsXG4gICAgXCLku6pcIixcbiAgICBcIuaXhVwiLFxuICAgIFwi5bC+XCIsXG4gICAgXCLovadcIixcbiAgICBcIuWGsFwiLFxuICAgIFwi6LShXCIsXG4gICAgXCLnmbtcIixcbiAgICBcIum7jlwiLFxuICAgIFwi5YmKXCIsXG4gICAgXCLpkrtcIixcbiAgICBcIuWLklwiLFxuICAgIFwi6YCDXCIsXG4gICAgXCLpmpxcIixcbiAgICBcIuawqFwiLFxuICAgIFwi6YOtXCIsXG4gICAgXCLls7BcIixcbiAgICBcIuW4gVwiLFxuICAgIFwi5rivXCIsXG4gICAgXCLkvI9cIixcbiAgICBcIui9qFwiLFxuICAgIFwi5LqpXCIsXG4gICAgXCLmr5VcIixcbiAgICBcIuaTplwiLFxuICAgIFwi6I6rXCIsXG4gICAgXCLliLpcIixcbiAgICBcIua1qlwiLFxuICAgIFwi56eYXCIsXG4gICAgXCLmj7RcIixcbiAgICBcIuagqlwiLFxuICAgIFwi5YGlXCIsXG4gICAgXCLllK5cIixcbiAgICBcIuiCoVwiLFxuICAgIFwi5bKbXCIsXG4gICAgXCLnlJhcIixcbiAgICBcIuazoVwiLFxuICAgIFwi552hXCIsXG4gICAgXCLnq6VcIixcbiAgICBcIumTuFwiLFxuICAgIFwi5rGkXCIsXG4gICAgXCLpmIBcIixcbiAgICBcIuS8kVwiLFxuICAgIFwi5rGHXCIsXG4gICAgXCLoiI1cIixcbiAgICBcIueJp1wiLFxuICAgIFwi57uVXCIsXG4gICAgXCLngrhcIixcbiAgICBcIuWTslwiLFxuICAgIFwi56O3XCIsXG4gICAgXCLnu6lcIixcbiAgICBcIuaci1wiLFxuICAgIFwi5rehXCIsXG4gICAgXCLlsJZcIixcbiAgICBcIuWQr1wiLFxuICAgIFwi6Zm3XCIsXG4gICAgXCLmn7RcIixcbiAgICBcIuWRiFwiLFxuICAgIFwi5b6SXCIsXG4gICAgXCLpopxcIixcbiAgICBcIuazqlwiLFxuICAgIFwi56iNXCIsXG4gICAgXCLlv5hcIixcbiAgICBcIuaztVwiLFxuICAgIFwi6JOdXCIsXG4gICAgXCLmi5ZcIixcbiAgICBcIua0nlwiLFxuICAgIFwi5o6IXCIsXG4gICAgXCLplZxcIixcbiAgICBcIui+m1wiLFxuICAgIFwi5aOuXCIsXG4gICAgXCLplItcIixcbiAgICBcIui0q1wiLFxuICAgIFwi6JmaXCIsXG4gICAgXCLlvK9cIixcbiAgICBcIuaRqVwiLFxuICAgIFwi5rOwXCIsXG4gICAgXCLlubxcIixcbiAgICBcIuW7t1wiLFxuICAgIFwi5bCKXCIsXG4gICAgXCLnqpdcIixcbiAgICBcIue6slwiLFxuICAgIFwi5byEXCIsXG4gICAgXCLpmrZcIixcbiAgICBcIueWkVwiLFxuICAgIFwi5rCPXCIsXG4gICAgXCLlrqtcIixcbiAgICBcIuWnkFwiLFxuICAgIFwi6ZyHXCIsXG4gICAgXCLnkZ5cIixcbiAgICBcIuaAqlwiLFxuICAgIFwi5bCkXCIsXG4gICAgXCLnkLRcIixcbiAgICBcIuW+qlwiLFxuICAgIFwi5o+PXCIsXG4gICAgXCLohpxcIixcbiAgICBcIui/nVwiLFxuICAgIFwi5aS5XCIsXG4gICAgXCLohbBcIixcbiAgICBcIue8mFwiLFxuICAgIFwi54+gXCIsXG4gICAgXCLnqbdcIixcbiAgICBcIuajrlwiLFxuICAgIFwi5p6dXCIsXG4gICAgXCLnq7lcIixcbiAgICBcIuayn1wiLFxuICAgIFwi5YKsXCIsXG4gICAgXCLnu7NcIixcbiAgICBcIuW/hlwiLFxuICAgIFwi6YKmXCIsXG4gICAgXCLlialcIixcbiAgICBcIuW5uFwiLFxuICAgIFwi5rWGXCIsXG4gICAgXCLmoI9cIixcbiAgICBcIuaLpVwiLFxuICAgIFwi54mZXCIsXG4gICAgXCLotK5cIixcbiAgICBcIuekvFwiLFxuICAgIFwi5rukXCIsXG4gICAgXCLpkqBcIixcbiAgICBcIue6uVwiLFxuICAgIFwi572iXCIsXG4gICAgXCLmi41cIixcbiAgICBcIuWSsVwiLFxuICAgIFwi5ZaKXCIsXG4gICAgXCLoopZcIixcbiAgICBcIuWfg1wiLFxuICAgIFwi5YukXCIsXG4gICAgXCLnvZpcIixcbiAgICBcIueEplwiLFxuICAgIFwi5r2cXCIsXG4gICAgXCLkvI1cIixcbiAgICBcIuWiqFwiLFxuICAgIFwi5qyyXCIsXG4gICAgXCLnvJ1cIixcbiAgICBcIuWnk1wiLFxuICAgIFwi5YiKXCIsXG4gICAgXCLppbFcIixcbiAgICBcIuS7v1wiLFxuICAgIFwi5aWWXCIsXG4gICAgXCLpk51cIixcbiAgICBcIumsvFwiLFxuICAgIFwi5Li9XCIsXG4gICAgXCLot6hcIixcbiAgICBcIum7mFwiLFxuICAgIFwi5oyWXCIsXG4gICAgXCLpk75cIixcbiAgICBcIuaJq1wiLFxuICAgIFwi5ZadXCIsXG4gICAgXCLoootcIixcbiAgICBcIueCrVwiLFxuICAgIFwi5rGhXCIsXG4gICAgXCLluZVcIixcbiAgICBcIuivuFwiLFxuICAgIFwi5bynXCIsXG4gICAgXCLlirFcIixcbiAgICBcIuaihVwiLFxuICAgIFwi5aW2XCIsXG4gICAgXCLmtIFcIixcbiAgICBcIueBvlwiLFxuICAgIFwi6IifXCIsXG4gICAgXCLpibRcIixcbiAgICBcIuiLr1wiLFxuICAgIFwi6K68XCIsXG4gICAgXCLmirFcIixcbiAgICBcIuavgVwiLFxuICAgIFwi5oeCXCIsXG4gICAgXCLlr5JcIixcbiAgICBcIuaZulwiLFxuICAgIFwi5Z+UXCIsXG4gICAgXCLlr4RcIixcbiAgICBcIuWxilwiLFxuICAgIFwi6LeDXCIsXG4gICAgXCLmuKFcIixcbiAgICBcIuaMkVwiLFxuICAgIFwi5Li5XCIsXG4gICAgXCLoibBcIixcbiAgICBcIui0nVwiLFxuICAgIFwi56KwXCIsXG4gICAgXCLmi5RcIixcbiAgICBcIueIuVwiLFxuICAgIFwi5oi0XCIsXG4gICAgXCLnoIFcIixcbiAgICBcIuaiplwiLFxuICAgIFwi6Iq9XCIsXG4gICAgXCLnhpRcIixcbiAgICBcIui1pFwiLFxuICAgIFwi5riUXCIsXG4gICAgXCLlk61cIixcbiAgICBcIuaVrFwiLFxuICAgIFwi6aKXXCIsXG4gICAgXCLlpZRcIixcbiAgICBcIumThVwiLFxuICAgIFwi5LuyXCIsXG4gICAgXCLomY5cIixcbiAgICBcIueogFwiLFxuICAgIFwi5aa5XCIsXG4gICAgXCLkuY9cIixcbiAgICBcIuePjVwiLFxuICAgIFwi55SzXCIsXG4gICAgXCLmoYxcIixcbiAgICBcIumBtVwiLFxuICAgIFwi5YWBXCIsXG4gICAgXCLpmoZcIixcbiAgICBcIuieulwiLFxuICAgIFwi5LuTXCIsXG4gICAgXCLprY9cIixcbiAgICBcIumUkFwiLFxuICAgIFwi5pmTXCIsXG4gICAgXCLmsK5cIixcbiAgICBcIuWFvFwiLFxuICAgIFwi6ZqQXCIsXG4gICAgXCLnoo1cIixcbiAgICBcIui1q1wiLFxuICAgIFwi5ouoXCIsXG4gICAgXCLlv6BcIixcbiAgICBcIuiCg1wiLFxuICAgIFwi57y4XCIsXG4gICAgXCLnibVcIixcbiAgICBcIuaKolwiLFxuICAgIFwi5Y2aXCIsXG4gICAgXCLlt6dcIixcbiAgICBcIuWjs1wiLFxuICAgIFwi5YWEXCIsXG4gICAgXCLmnZxcIixcbiAgICBcIuiur1wiLFxuICAgIFwi6K+aXCIsXG4gICAgXCLnoqdcIixcbiAgICBcIuelpVwiLFxuICAgIFwi5p+vXCIsXG4gICAgXCLpobVcIixcbiAgICBcIuW3oVwiLFxuICAgIFwi55+pXCIsXG4gICAgXCLmgrJcIixcbiAgICBcIueBjFwiLFxuICAgIFwi6b6EXCIsXG4gICAgXCLkvKZcIixcbiAgICBcIuelqFwiLFxuICAgIFwi5a+7XCIsXG4gICAgXCLmoYJcIixcbiAgICBcIumTulwiLFxuICAgIFwi5ZyjXCIsXG4gICAgXCLmgZBcIixcbiAgICBcIuaBsFwiLFxuICAgIFwi6YORXCIsXG4gICAgXCLotqNcIixcbiAgICBcIuaKrFwiLFxuICAgIFwi6I2SXCIsXG4gICAgXCLohb5cIixcbiAgICBcIui0tFwiLFxuICAgIFwi5p+UXCIsXG4gICAgXCLmu7RcIixcbiAgICBcIueMm1wiLFxuICAgIFwi6ZiUXCIsXG4gICAgXCLovoZcIixcbiAgICBcIuWmu1wiLFxuICAgIFwi5aGrXCIsXG4gICAgXCLmkqRcIixcbiAgICBcIuWCqFwiLFxuICAgIFwi562+XCIsXG4gICAgXCLpl7lcIixcbiAgICBcIuaJsFwiLFxuICAgIFwi57SrXCIsXG4gICAgXCLnoIJcIixcbiAgICBcIumAklwiLFxuICAgIFwi5oiPXCIsXG4gICAgXCLlkIpcIixcbiAgICBcIumZtlwiLFxuICAgIFwi5LyQXCIsXG4gICAgXCLlloJcIixcbiAgICBcIueWl1wiLFxuICAgIFwi55O2XCIsXG4gICAgXCLlqYZcIixcbiAgICBcIuaKmlwiLFxuICAgIFwi6IeCXCIsXG4gICAgXCLmkbhcIixcbiAgICBcIuW/jVwiLFxuICAgIFwi6Jm+XCIsXG4gICAgXCLonKFcIixcbiAgICBcIumCu1wiLFxuICAgIFwi6IO4XCIsXG4gICAgXCLlt6lcIixcbiAgICBcIuaMpFwiLFxuICAgIFwi5YG2XCIsXG4gICAgXCLlvINcIixcbiAgICBcIuanvVwiLFxuICAgIFwi5YqyXCIsXG4gICAgXCLkubNcIixcbiAgICBcIumCk1wiLFxuICAgIFwi5ZCJXCIsXG4gICAgXCLku4FcIixcbiAgICBcIueDglwiLFxuICAgIFwi56CWXCIsXG4gICAgXCLnp59cIixcbiAgICBcIuS5jFwiLFxuICAgIFwi6IiwXCIsXG4gICAgXCLkvLRcIixcbiAgICBcIueTnFwiLFxuICAgIFwi5rWFXCIsXG4gICAgXCLkuJlcIixcbiAgICBcIuaaglwiLFxuICAgIFwi54elXCIsXG4gICAgXCLmqaFcIixcbiAgICBcIuafs1wiLFxuICAgIFwi6L+3XCIsXG4gICAgXCLmmpZcIixcbiAgICBcIueJjFwiLFxuICAgIFwi56enXCIsXG4gICAgXCLog4ZcIixcbiAgICBcIuivplwiLFxuICAgIFwi57CnXCIsXG4gICAgXCLouI9cIixcbiAgICBcIueTt1wiLFxuICAgIFwi6LCxXCIsXG4gICAgXCLlkYZcIixcbiAgICBcIuWuvlwiLFxuICAgIFwi57OKXCIsXG4gICAgXCLmtJtcIixcbiAgICBcIui+iVwiLFxuICAgIFwi5oSkXCIsXG4gICAgXCLnq55cIixcbiAgICBcIumamVwiLFxuICAgIFwi5oCSXCIsXG4gICAgXCLnsphcIixcbiAgICBcIuS5g1wiLFxuICAgIFwi57uqXCIsXG4gICAgXCLogqlcIixcbiAgICBcIuexjVwiLFxuICAgIFwi5pWPXCIsXG4gICAgXCLmtoJcIixcbiAgICBcIueGmVwiLFxuICAgIFwi55qGXCIsXG4gICAgXCLkvqZcIixcbiAgICBcIuaCrFwiLFxuICAgIFwi5o6YXCIsXG4gICAgXCLkuqtcIixcbiAgICBcIue6oFwiLFxuICAgIFwi6YaSXCIsXG4gICAgXCLni4JcIixcbiAgICBcIumUgVwiLFxuICAgIFwi5reAXCIsXG4gICAgXCLmgahcIixcbiAgICBcIueJslwiLFxuICAgIFwi6Zy4XCIsXG4gICAgXCLniKxcIixcbiAgICBcIui1j1wiLFxuICAgIFwi6YCGXCIsXG4gICAgXCLnjqlcIixcbiAgICBcIumZtVwiLFxuICAgIFwi56WdXCIsXG4gICAgXCLnp5JcIixcbiAgICBcIua1mVwiLFxuICAgIFwi6LKMXCIsXG4gICAgXCLlvblcIixcbiAgICBcIuW9vFwiLFxuICAgIFwi5oKJXCIsXG4gICAgXCLpuK1cIixcbiAgICBcIui2i1wiLFxuICAgIFwi5YekXCIsXG4gICAgXCLmmahcIixcbiAgICBcIueVnFwiLFxuICAgIFwi6L6IXCIsXG4gICAgXCLnp6lcIixcbiAgICBcIuWNtVwiLFxuICAgIFwi572yXCIsXG4gICAgXCLmoq9cIixcbiAgICBcIueCjlwiLFxuICAgIFwi5rupXCIsXG4gICAgXCLmo4tcIixcbiAgICBcIumpsVwiLFxuICAgIFwi562bXCIsXG4gICAgXCLls6FcIixcbiAgICBcIuWGklwiLFxuICAgIFwi5ZWlXCIsXG4gICAgXCLlr79cIixcbiAgICBcIuivkVwiLFxuICAgIFwi5rW4XCIsXG4gICAgXCLms4lcIixcbiAgICBcIuW4vVwiLFxuICAgIFwi6L+fXCIsXG4gICAgXCLnoYVcIixcbiAgICBcIueWhlwiLFxuICAgIFwi6LS3XCIsXG4gICAgXCLmvI9cIixcbiAgICBcIueov1wiLFxuICAgIFwi5YagXCIsXG4gICAgXCLlq6lcIixcbiAgICBcIuiDgVwiLFxuICAgIFwi6IqvXCIsXG4gICAgXCLniaJcIixcbiAgICBcIuWPm1wiLFxuICAgIFwi6JqAXCIsXG4gICAgXCLlpaVcIixcbiAgICBcIum4o1wiLFxuICAgIFwi5bKtXCIsXG4gICAgXCLnvopcIixcbiAgICBcIuWHrVwiLFxuICAgIFwi5LiyXCIsXG4gICAgXCLloZhcIixcbiAgICBcIue7mFwiLFxuICAgIFwi6YW1XCIsXG4gICAgXCLono1cIixcbiAgICBcIuebhlwiLFxuICAgIFwi6ZShXCIsXG4gICAgXCLluplcIixcbiAgICBcIuetuVwiLFxuICAgIFwi5Ya7XCIsXG4gICAgXCLovoVcIixcbiAgICBcIuaRhFwiLFxuICAgIFwi6KKtXCIsXG4gICAgXCLnrYtcIixcbiAgICBcIuaLklwiLFxuICAgIFwi5YOaXCIsXG4gICAgXCLml7FcIixcbiAgICBcIumSvlwiLFxuICAgIFwi6bifXCIsXG4gICAgXCLmvIZcIixcbiAgICBcIuayiFwiLFxuICAgIFwi55yJXCIsXG4gICAgXCLnlo9cIixcbiAgICBcIua3u1wiLFxuICAgIFwi5qOSXCIsXG4gICAgXCLnqZdcIixcbiAgICBcIuehnVwiLFxuICAgIFwi6Z+pXCIsXG4gICAgXCLpgLxcIixcbiAgICBcIuaJrVwiLFxuICAgIFwi5L6oXCIsXG4gICAgXCLlh4lcIixcbiAgICBcIuaMulwiLFxuICAgIFwi56KXXCIsXG4gICAgXCLmoL1cIixcbiAgICBcIueCklwiLFxuICAgIFwi5p2vXCIsXG4gICAgXCLmgqNcIixcbiAgICBcIummj1wiLFxuICAgIFwi5YqdXCIsXG4gICAgXCLosapcIixcbiAgICBcIui+vVwiLFxuICAgIFwi5YuDXCIsXG4gICAgXCLpuL9cIixcbiAgICBcIuaXplwiLFxuICAgIFwi5ZCPXCIsXG4gICAgXCLmi5xcIixcbiAgICBcIueLl1wiLFxuICAgIFwi5Z+LXCIsXG4gICAgXCLovopcIixcbiAgICBcIuaOqVwiLFxuICAgIFwi6aWuXCIsXG4gICAgXCLmkKxcIixcbiAgICBcIumqglwiLFxuICAgIFwi6L6eXCIsXG4gICAgXCLli75cIixcbiAgICBcIuaJo1wiLFxuICAgIFwi5LywXCIsXG4gICAgXCLokotcIixcbiAgICBcIue7klwiLFxuICAgIFwi6Zu+XCIsXG4gICAgXCLkuIhcIixcbiAgICBcIuactVwiLFxuICAgIFwi5aeGXCIsXG4gICAgXCLmi59cIixcbiAgICBcIuWuh1wiLFxuICAgIFwi6L6RXCIsXG4gICAgXCLpmZVcIixcbiAgICBcIumblVwiLFxuICAgIFwi5YG/XCIsXG4gICAgXCLok4RcIixcbiAgICBcIuW0h1wiLFxuICAgIFwi5YmqXCIsXG4gICAgXCLlgKFcIixcbiAgICBcIuWOhVwiLFxuICAgIFwi5ZKsXCIsXG4gICAgXCLpqbZcIixcbiAgICBcIuiWr1wiLFxuICAgIFwi5Yi3XCIsXG4gICAgXCLmlqVcIixcbiAgICBcIueVqlwiLFxuICAgIFwi6LWLXCIsXG4gICAgXCLlpYlcIixcbiAgICBcIuS9m1wiLFxuICAgIFwi5rWHXCIsXG4gICAgXCLmvKtcIixcbiAgICBcIuabvFwiLFxuICAgIFwi5omHXCIsXG4gICAgXCLpkplcIixcbiAgICBcIuahg1wiLFxuICAgIFwi5om2XCIsXG4gICAgXCLku5RcIixcbiAgICBcIui/lFwiLFxuICAgIFwi5L+XXCIsXG4gICAgXCLkuo9cIixcbiAgICBcIuiFlFwiLFxuICAgIFwi6Z6LXCIsXG4gICAgXCLmo7FcIixcbiAgICBcIuimhlwiLFxuICAgIFwi5qGGXCIsXG4gICAgXCLmgoRcIixcbiAgICBcIuWPlFwiLFxuICAgIFwi5pKeXCIsXG4gICAgXCLpqpdcIixcbiAgICBcIuWLmFwiLFxuICAgIFwi5pe6XCIsXG4gICAgXCLmsrhcIixcbiAgICBcIuWtpFwiLFxuICAgIFwi5ZCQXCIsXG4gICAgXCLlrZ9cIixcbiAgICBcIua4oFwiLFxuICAgIFwi5bGIXCIsXG4gICAgXCLnlr5cIixcbiAgICBcIuWmmVwiLFxuICAgIFwi5oOcXCIsXG4gICAgXCLku7BcIixcbiAgICBcIueLoFwiLFxuICAgIFwi6IOAXCIsXG4gICAgXCLosJBcIixcbiAgICBcIuaKm1wiLFxuICAgIFwi6ZyJXCIsXG4gICAgXCLmoZFcIixcbiAgICBcIuWyl1wiLFxuICAgIFwi5ZibXCIsXG4gICAgXCLoobBcIixcbiAgICBcIuebl1wiLFxuICAgIFwi5riXXCIsXG4gICAgXCLohI9cIixcbiAgICBcIui1llwiLFxuICAgIFwi5raMXCIsXG4gICAgXCLnlJxcIixcbiAgICBcIuabuVwiLFxuICAgIFwi6ZiFXCIsXG4gICAgXCLogoxcIixcbiAgICBcIuWTqVwiLFxuICAgIFwi5Y6JXCIsXG4gICAgXCLng4NcIixcbiAgICBcIue6rFwiLFxuICAgIFwi5q+FXCIsXG4gICAgXCLmmKhcIixcbiAgICBcIuS8qlwiLFxuICAgIFwi55eHXCIsXG4gICAgXCLnha5cIixcbiAgICBcIuWPuVwiLFxuICAgIFwi6ZKJXCIsXG4gICAgXCLmkK1cIixcbiAgICBcIuiMjlwiLFxuICAgIFwi56y8XCIsXG4gICAgXCLphbdcIixcbiAgICBcIuWBt1wiLFxuICAgIFwi5byTXCIsXG4gICAgXCLplKVcIixcbiAgICBcIuaBklwiLFxuICAgIFwi5p2wXCIsXG4gICAgXCLlnZFcIixcbiAgICBcIum8u1wiLFxuICAgIFwi57+8XCIsXG4gICAgXCLnurZcIixcbiAgICBcIuWPmVwiLFxuICAgIFwi54uxXCIsXG4gICAgXCLpgK5cIixcbiAgICBcIue9kFwiLFxuICAgIFwi57ucXCIsXG4gICAgXCLmo5pcIixcbiAgICBcIuaKkVwiLFxuICAgIFwi6IaoXCIsXG4gICAgXCLolKxcIixcbiAgICBcIuWvulwiLFxuICAgIFwi6aqkXCIsXG4gICAgXCLnqYZcIixcbiAgICBcIuWGtlwiLFxuICAgIFwi5p6vXCIsXG4gICAgXCLlhoxcIixcbiAgICBcIuWwuFwiLFxuICAgIFwi5Ye4XCIsXG4gICAgXCLnu4VcIixcbiAgICBcIuWdr1wiLFxuICAgIFwi54m6XCIsXG4gICAgXCLnhLBcIixcbiAgICBcIui9sFwiLFxuICAgIFwi5qyjXCIsXG4gICAgXCLmmYtcIixcbiAgICBcIueYplwiLFxuICAgIFwi5b6hXCIsXG4gICAgXCLplK1cIixcbiAgICBcIumUplwiLFxuICAgIFwi5LinXCIsXG4gICAgXCLml6xcIixcbiAgICBcIumUu1wiLFxuICAgIFwi5Z6EXCIsXG4gICAgXCLmkJxcIixcbiAgICBcIuaJkVwiLFxuICAgIFwi6YKAXCIsXG4gICAgXCLkuq1cIixcbiAgICBcIumFr1wiLFxuICAgIFwi6L+IXCIsXG4gICAgXCLoiJJcIixcbiAgICBcIuiEhlwiLFxuICAgIFwi6YW2XCIsXG4gICAgXCLpl7JcIixcbiAgICBcIuW/p1wiLFxuICAgIFwi6YWaXCIsXG4gICAgXCLpob1cIixcbiAgICBcIue+vVwiLFxuICAgIFwi5raoXCIsXG4gICAgXCLljbhcIixcbiAgICBcIuS7l1wiLFxuICAgIFwi6ZmqXCIsXG4gICAgXCLovp9cIixcbiAgICBcIuaDqVwiLFxuICAgIFwi5p2tXCIsXG4gICAgXCLlp5pcIixcbiAgICBcIuiCmlwiLFxuICAgIFwi5o2JXCIsXG4gICAgXCLpo5hcIixcbiAgICBcIua8glwiLFxuICAgIFwi5piGXCIsXG4gICAgXCLmrLpcIixcbiAgICBcIuWQvlwiLFxuICAgIFwi6YOOXCIsXG4gICAgXCLng7dcIixcbiAgICBcIuaxgVwiLFxuICAgIFwi5ZG1XCIsXG4gICAgXCLppbBcIixcbiAgICBcIuiQp1wiLFxuICAgIFwi6ZuFXCIsXG4gICAgXCLpgq5cIixcbiAgICBcIui/gVwiLFxuICAgIFwi54eVXCIsXG4gICAgXCLmkpJcIixcbiAgICBcIuWnu1wiLFxuICAgIFwi6LW0XCIsXG4gICAgXCLlrrRcIixcbiAgICBcIueDplwiLFxuICAgIFwi5YC6XCIsXG4gICAgXCLluJBcIixcbiAgICBcIuaWkVwiLFxuICAgIFwi6ZODXCIsXG4gICAgXCLml6hcIixcbiAgICBcIumGh1wiLFxuICAgIFwi6JGjXCIsXG4gICAgXCLppbxcIixcbiAgICBcIumbj1wiLFxuICAgIFwi5ae/XCIsXG4gICAgXCLmi4xcIixcbiAgICBcIuWChVwiLFxuICAgIFwi6IW5XCIsXG4gICAgXCLlpqVcIixcbiAgICBcIuaPiVwiLFxuICAgIFwi6LSkXCIsXG4gICAgXCLmi4ZcIixcbiAgICBcIuatqlwiLFxuICAgIFwi6JGhXCIsXG4gICAgXCLog7pcIixcbiAgICBcIuS4olwiLFxuICAgIFwi5rWpXCIsXG4gICAgXCLlvr1cIixcbiAgICBcIuaYglwiLFxuICAgIFwi5Z6rXCIsXG4gICAgXCLmjKFcIixcbiAgICBcIuiniFwiLFxuICAgIFwi6LSqXCIsXG4gICAgXCLmhbBcIixcbiAgICBcIue8tFwiLFxuICAgIFwi5rGqXCIsXG4gICAgXCLmhYxcIixcbiAgICBcIuWGr1wiLFxuICAgIFwi6K+6XCIsXG4gICAgXCLlp5xcIixcbiAgICBcIuiwilwiLFxuICAgIFwi5Ye2XCIsXG4gICAgXCLliqNcIixcbiAgICBcIuivrFwiLFxuICAgIFwi6ICAXCIsXG4gICAgXCLmmI9cIixcbiAgICBcIui6ulwiLFxuICAgIFwi55uIXCIsXG4gICAgXCLpqpFcIixcbiAgICBcIuS5lFwiLFxuICAgIFwi5rqqXCIsXG4gICAgXCLkuJtcIixcbiAgICBcIuWNolwiLFxuICAgIFwi5oq5XCIsXG4gICAgXCLpl7dcIixcbiAgICBcIuWSqFwiLFxuICAgIFwi5YiuXCIsXG4gICAgXCLpqb5cIixcbiAgICBcIue8hlwiLFxuICAgIFwi5oKfXCIsXG4gICAgXCLmkZhcIixcbiAgICBcIumTklwiLFxuICAgIFwi5o63XCIsXG4gICAgXCLpoodcIixcbiAgICBcIuW5u1wiLFxuICAgIFwi5p+EXCIsXG4gICAgXCLmg6BcIixcbiAgICBcIuaDqFwiLFxuICAgIFwi5L2zXCIsXG4gICAgXCLku4dcIixcbiAgICBcIuiFilwiLFxuICAgIFwi56qdXCIsXG4gICAgXCLmtqRcIixcbiAgICBcIuWJkVwiLFxuICAgIFwi556nXCIsXG4gICAgXCLloKFcIixcbiAgICBcIuazvFwiLFxuICAgIFwi6JGxXCIsXG4gICAgXCLnvalcIixcbiAgICBcIumcjVwiLFxuICAgIFwi5o2eXCIsXG4gICAgXCLog45cIixcbiAgICBcIuiLjVwiLFxuICAgIFwi5ruoXCIsXG4gICAgXCLkv6lcIixcbiAgICBcIuaNhVwiLFxuICAgIFwi5rmYXCIsXG4gICAgXCLnoI1cIixcbiAgICBcIumcnlwiLFxuICAgIFwi6YK1XCIsXG4gICAgXCLokIRcIixcbiAgICBcIueWr1wiLFxuICAgIFwi5reuXCIsXG4gICAgXCLpgYJcIixcbiAgICBcIueGilwiLFxuICAgIFwi57KqXCIsXG4gICAgXCLng5hcIixcbiAgICBcIuWuv1wiLFxuICAgIFwi5qGjXCIsXG4gICAgXCLmiIhcIixcbiAgICBcIumps1wiLFxuICAgIFwi5auCXCIsXG4gICAgXCLoo5VcIixcbiAgICBcIuW+mVwiLFxuICAgIFwi566tXCIsXG4gICAgXCLmjZBcIixcbiAgICBcIuiCoFwiLFxuICAgIFwi5pKRXCIsXG4gICAgXCLmmZJcIixcbiAgICBcIui+qFwiLFxuICAgIFwi5q6/XCIsXG4gICAgXCLojrJcIixcbiAgICBcIuaRilwiLFxuICAgIFwi5pCFXCIsXG4gICAgXCLphbFcIixcbiAgICBcIuWxj1wiLFxuICAgIFwi55arXCIsXG4gICAgXCLlk4BcIixcbiAgICBcIuiUoVwiLFxuICAgIFwi5aC1XCIsXG4gICAgXCLmsqtcIixcbiAgICBcIueasVwiLFxuICAgIFwi55WFXCIsXG4gICAgXCLlj6BcIixcbiAgICBcIumYgVwiLFxuICAgIFwi6I6xXCIsXG4gICAgXCLmlbJcIixcbiAgICBcIui+llwiLFxuICAgIFwi6ZKpXCIsXG4gICAgXCLnl5VcIixcbiAgICBcIuWdnVwiLFxuICAgIFwi5be3XCIsXG4gICAgXCLppb9cIixcbiAgICBcIueluFwiLFxuICAgIFwi5LiYXCIsXG4gICAgXCLnjoRcIixcbiAgICBcIua6nFwiLFxuICAgIFwi5puwXCIsXG4gICAgXCLpgLtcIixcbiAgICBcIuW9rVwiLFxuICAgIFwi5bCdXCIsXG4gICAgXCLljb9cIixcbiAgICBcIuWmqFwiLFxuICAgIFwi6ImHXCIsXG4gICAgXCLlkJ5cIixcbiAgICBcIumfplwiLFxuICAgIFwi5oCoXCIsXG4gICAgXCLnn65cIixcbiAgICBcIuath1wiXG5dXG4iLCJtb2R1bGUuZXhwb3J0cz1bXG4gICAgXCJhYmRpa2FjZVwiLFxuICAgIFwiYWJlY2VkYVwiLFxuICAgIFwiYWRyZXNhXCIsXG4gICAgXCJhZ3Jlc2VcIixcbiAgICBcImFrY2VcIixcbiAgICBcImFrdG92a2FcIixcbiAgICBcImFsZWpcIixcbiAgICBcImFsa29ob2xcIixcbiAgICBcImFtcHV0YWNlXCIsXG4gICAgXCJhbmFuYXNcIixcbiAgICBcImFuZHVsa2FcIixcbiAgICBcImFuZWtkb3RhXCIsXG4gICAgXCJhbmtldGFcIixcbiAgICBcImFudGlrYVwiLFxuICAgIFwiYW51bG92YXRcIixcbiAgICBcImFyY2hhXCIsXG4gICAgXCJhcm9nYW5jZVwiLFxuICAgIFwiYXNmYWx0XCIsXG4gICAgXCJhc2lzdGVudFwiLFxuICAgIFwiYXNwaXJhY2VcIixcbiAgICBcImFzdG1hXCIsXG4gICAgXCJhc3Ryb25vbVwiLFxuICAgIFwiYXRsYXNcIixcbiAgICBcImF0bGV0aWthXCIsXG4gICAgXCJhdG9sXCIsXG4gICAgXCJhdXRvYnVzXCIsXG4gICAgXCJhenlsXCIsXG4gICAgXCJiYWJrYVwiLFxuICAgIFwiYmFjaG9yXCIsXG4gICAgXCJiYWNpbFwiLFxuICAgIFwiYmFjdWxrYVwiLFxuICAgIFwiYmFkYXRlbFwiLFxuICAgIFwiYmFnZXRhXCIsXG4gICAgXCJiYWdyXCIsXG4gICAgXCJiYWhub1wiLFxuICAgIFwiYmFrdGVyaWVcIixcbiAgICBcImJhbGFkYVwiLFxuICAgIFwiYmFsZXRrYVwiLFxuICAgIFwiYmFsa29uXCIsXG4gICAgXCJiYWxvbmVrXCIsXG4gICAgXCJiYWx2YW5cIixcbiAgICBcImJhbHphXCIsXG4gICAgXCJiYW1idXNcIixcbiAgICBcImJhbmtvbWF0XCIsXG4gICAgXCJiYXJiYXJcIixcbiAgICBcImJhcmV0XCIsXG4gICAgXCJiYXJtYW5cIixcbiAgICBcImJhcm9rb1wiLFxuICAgIFwiYmFydmFcIixcbiAgICBcImJhdGVya2FcIixcbiAgICBcImJhdG9oXCIsXG4gICAgXCJiYXZsbmFcIixcbiAgICBcImJhemFsa2FcIixcbiAgICBcImJhemlsaWthXCIsXG4gICAgXCJiYXp1a2FcIixcbiAgICBcImJlZG5hXCIsXG4gICAgXCJiZXJhblwiLFxuICAgIFwiYmVzZWRhXCIsXG4gICAgXCJiZXN0aWVcIixcbiAgICBcImJldG9uXCIsXG4gICAgXCJiZXppbmthXCIsXG4gICAgXCJiZXptb2NcIixcbiAgICBcImJlenRha1wiLFxuICAgIFwiYmljeWtsXCIsXG4gICAgXCJiaWRsb1wiLFxuICAgIFwiYmlmdGVrXCIsXG4gICAgXCJiaWtpbnlcIixcbiAgICBcImJpbGFuY2VcIixcbiAgICBcImJpb2dyYWZcIixcbiAgICBcImJpb2xvZ1wiLFxuICAgIFwiYml0dmFcIixcbiAgICBcImJpem9uXCIsXG4gICAgXCJibGFob2J5dFwiLFxuICAgIFwiYmxhdG91Y2hcIixcbiAgICBcImJsZWNoYVwiLFxuICAgIFwiYmxlZHVsZVwiLFxuICAgIFwiYmxlc2tcIixcbiAgICBcImJsaWthdFwiLFxuICAgIFwiYmxpem5hXCIsXG4gICAgXCJibG9rb3ZhdFwiLFxuICAgIFwiYmxvdWRpdFwiLFxuICAgIFwiYmx1ZFwiLFxuICAgIFwiYm9iZWtcIixcbiAgICBcImJvYnJcIixcbiAgICBcImJvZGxpbmFcIixcbiAgICBcImJvZG5vdXRcIixcbiAgICBcImJvaGF0b3N0XCIsXG4gICAgXCJib2prb3RcIixcbiAgICBcImJvam92YXRcIixcbiAgICBcImJva29yeXNcIixcbiAgICBcImJvbGVzdFwiLFxuICAgIFwiYm9yZWNcIixcbiAgICBcImJvcm92aWNlXCIsXG4gICAgXCJib3RhXCIsXG4gICAgXCJib3ViZWxcIixcbiAgICBcImJvdWNoYXRcIixcbiAgICBcImJvdWRhXCIsXG4gICAgXCJib3VsZVwiLFxuICAgIFwiYm91cmF0XCIsXG4gICAgXCJib3hlclwiLFxuICAgIFwiYnJhZGF2a2FcIixcbiAgICBcImJyYW1ib3JhXCIsXG4gICAgXCJicmFua2FcIixcbiAgICBcImJyYXRyXCIsXG4gICAgXCJicmVwdGFcIixcbiAgICBcImJyaWtldGFcIixcbiAgICBcImJya29cIixcbiAgICBcImJybG9oXCIsXG4gICAgXCJicm9uelwiLFxuICAgIFwiYnJvc2tldlwiLFxuICAgIFwiYnJ1bmV0a2FcIixcbiAgICBcImJydXNpbmthXCIsXG4gICAgXCJicnpkYVwiLFxuICAgIFwiYnJ6eVwiLFxuICAgIFwiYnVibGluYVwiLFxuICAgIFwiYnVibm92YXRcIixcbiAgICBcImJ1Y2h0YVwiLFxuICAgIFwiYnVkaXRlbFwiLFxuICAgIFwiYnVka2FcIixcbiAgICBcImJ1ZG92YVwiLFxuICAgIFwiYnVmZXRcIixcbiAgICBcImJ1amFyb3N0XCIsXG4gICAgXCJidWt2aWNlXCIsXG4gICAgXCJidWxkb2tcIixcbiAgICBcImJ1bHZhXCIsXG4gICAgXCJidW5kYVwiLFxuICAgIFwiYnVua3JcIixcbiAgICBcImJ1cnphXCIsXG4gICAgXCJidXRpa1wiLFxuICAgIFwiYnV2b2xcIixcbiAgICBcImJ1em9sYVwiLFxuICAgIFwiYnlkbGV0XCIsXG4gICAgXCJieWxpbmFcIixcbiAgICBcImJ5dG92a2FcIixcbiAgICBcImJ6dWtvdFwiLFxuICAgIFwiY2FwYXJ0XCIsXG4gICAgXCJjYXJldm5hXCIsXG4gICAgXCJjZWRyXCIsXG4gICAgXCJjZWR1bGVcIixcbiAgICBcImNlamNoXCIsXG4gICAgXCJjZWpuXCIsXG4gICAgXCJjZWxhXCIsXG4gICAgXCJjZWxlclwiLFxuICAgIFwiY2Vsa2VtXCIsXG4gICAgXCJjZWxuaWNlXCIsXG4gICAgXCJjZW5pbmFcIixcbiAgICBcImNlbm5vc3RcIixcbiAgICBcImNlbm92a2FcIixcbiAgICBcImNlbnRydW1cIixcbiAgICBcImNlbnpvclwiLFxuICAgIFwiY2VzdG9waXNcIixcbiAgICBcImNldGthXCIsXG4gICAgXCJjaGFsdXBhXCIsXG4gICAgXCJjaGFwYWRsb1wiLFxuICAgIFwiY2hhcml0YVwiLFxuICAgIFwiY2hhdGFcIixcbiAgICBcImNoZWNodGF0XCIsXG4gICAgXCJjaGVtaWVcIixcbiAgICBcImNoaWNob3RcIixcbiAgICBcImNoaXJ1cmdcIixcbiAgICBcImNobGFkXCIsXG4gICAgXCJjaGxlYmFcIixcbiAgICBcImNobHViaXRcIixcbiAgICBcImNobWVsXCIsXG4gICAgXCJjaG11cmFcIixcbiAgICBcImNob2JvdFwiLFxuICAgIFwiY2hvY2hvbFwiLFxuICAgIFwiY2hvZGJhXCIsXG4gICAgXCJjaG9sZXJhXCIsXG4gICAgXCJjaG9tb3V0XCIsXG4gICAgXCJjaG9waXRcIixcbiAgICBcImNob3JvYmFcIixcbiAgICBcImNob3ZcIixcbiAgICBcImNocmFwb3RcIixcbiAgICBcImNocmxpdFwiLFxuICAgIFwiY2hydFwiLFxuICAgIFwiY2hydXBcIixcbiAgICBcImNodGl2b3N0XCIsXG4gICAgXCJjaHVkaW5hXCIsXG4gICAgXCJjaHV0bmF0XCIsXG4gICAgXCJjaHZhdFwiLFxuICAgIFwiY2h2aWxrYVwiLFxuICAgIFwiY2h2b3N0XCIsXG4gICAgXCJjaHliYVwiLFxuICAgIFwiY2h5c3RhdFwiLFxuICAgIFwiY2h5dGl0XCIsXG4gICAgXCJjaWJ1bGVcIixcbiAgICBcImNpZ2FyZXRhXCIsXG4gICAgXCJjaWhlbG5hXCIsXG4gICAgXCJjaWhsYVwiLFxuICAgIFwiY2lua290XCIsXG4gICAgXCJjaXJrdXNcIixcbiAgICBcImNpc3Rlcm5hXCIsXG4gICAgXCJjaXRhY2VcIixcbiAgICBcImNpdHJ1c1wiLFxuICAgIFwiY2l6aW5lY1wiLFxuICAgIFwiY2l6b3N0XCIsXG4gICAgXCJjbG9uYVwiLFxuICAgIFwiY29rb2xpdlwiLFxuICAgIFwiY291dmF0XCIsXG4gICAgXCJjdGl0ZWxcIixcbiAgICBcImN0bm9zdFwiLFxuICAgIFwiY3Vkbm9zdFwiLFxuICAgIFwiY3VrZXRhXCIsXG4gICAgXCJjdWtyXCIsXG4gICAgXCJjdXBvdFwiLFxuICAgIFwiY3Zha25vdXRcIixcbiAgICBcImN2YWxcIixcbiAgICBcImN2aWtcIixcbiAgICBcImN2cmtvdFwiLFxuICAgIFwiY3lrbGlzdGFcIixcbiAgICBcImRhbGVrb1wiLFxuICAgIFwiZGFyZWJhXCIsXG4gICAgXCJkYXRlbFwiLFxuICAgIFwiZGF0dW1cIixcbiAgICBcImRjZXJhXCIsXG4gICAgXCJkZWJhdGFcIixcbiAgICBcImRlY2hvdmthXCIsXG4gICAgXCJkZWNpYmVsXCIsXG4gICAgXCJkZWZpY2l0XCIsXG4gICAgXCJkZWZsYWNlXCIsXG4gICAgXCJkZWtsXCIsXG4gICAgXCJkZWtyZXRcIixcbiAgICBcImRlbW9rcmF0XCIsXG4gICAgXCJkZXByZXNlXCIsXG4gICAgXCJkZXJieVwiLFxuICAgIFwiZGVza2FcIixcbiAgICBcImRldGVrdGl2XCIsXG4gICAgXCJkaWtvYnJhelwiLFxuICAgIFwiZGlrdG92YXRcIixcbiAgICBcImRpb2RhXCIsXG4gICAgXCJkaXBsb21cIixcbiAgICBcImRpc2tcIixcbiAgICBcImRpc3BsZWpcIixcbiAgICBcImRpdmFkbG9cIixcbiAgICBcImRpdm9jaFwiLFxuICAgIFwiZGxhaGFcIixcbiAgICBcImRsb3Vob1wiLFxuICAgIFwiZGx1aG9waXNcIixcbiAgICBcImRuZXNcIixcbiAgICBcImRvYnJvXCIsXG4gICAgXCJkb2J5dGVrXCIsXG4gICAgXCJkb2NlbnRcIixcbiAgICBcImRvY2h1dGl0XCIsXG4gICAgXCJkb2RuZXNcIixcbiAgICBcImRvaGxlZFwiLFxuICAgIFwiZG9ob2RhXCIsXG4gICAgXCJkb2hyYVwiLFxuICAgIFwiZG9qZW1cIixcbiAgICBcImRvam5pY2VcIixcbiAgICBcImRva2xhZFwiLFxuICAgIFwiZG9rb2xhXCIsXG4gICAgXCJkb2t0b3JcIixcbiAgICBcImRva3VtZW50XCIsXG4gICAgXCJkb2xhclwiLFxuICAgIFwiZG9sZXZhXCIsXG4gICAgXCJkb2xpbmFcIixcbiAgICBcImRvbWFcIixcbiAgICBcImRvbWluYW50XCIsXG4gICAgXCJkb21sdXZpdFwiLFxuICAgIFwiZG9tb3ZcIixcbiAgICBcImRvbnV0aXRcIixcbiAgICBcImRvcGFkXCIsXG4gICAgXCJkb3Bpc1wiLFxuICAgIFwiZG9wbG5pdFwiLFxuICAgIFwiZG9wb3N1ZFwiLFxuICAgIFwiZG9wcm92b2RcIixcbiAgICBcImRvcHVzdGl0XCIsXG4gICAgXCJkb3Jheml0XCIsXG4gICAgXCJkb3Jvc3RcIixcbiAgICBcImRvcnRcIixcbiAgICBcImRvc2FoXCIsXG4gICAgXCJkb3Nsb3ZcIixcbiAgICBcImRvc3RhdGVrXCIsXG4gICAgXCJkb3N1ZFwiLFxuICAgIFwiZG9zeXRhXCIsXG4gICAgXCJkb3RhelwiLFxuICAgIFwiZG90ZWtcIixcbiAgICBcImRvdGtub3V0XCIsXG4gICAgXCJkb3VmYXRcIixcbiAgICBcImRvdXRuYXRcIixcbiAgICBcImRvdm96Y2VcIixcbiAgICBcImRvemFkdVwiLFxuICAgIFwiZG96bmF0XCIsXG4gICAgXCJkb3pvcmNlXCIsXG4gICAgXCJkcmFob3RhXCIsXG4gICAgXCJkcmFrXCIsXG4gICAgXCJkcmFtYXRpa1wiLFxuICAgIFwiZHJhdmVjXCIsXG4gICAgXCJkcmF6ZVwiLFxuICAgIFwiZHJkb2xcIixcbiAgICBcImRyb2Jub3N0XCIsXG4gICAgXCJkcm9nZXJpZVwiLFxuICAgIFwiZHJvemRcIixcbiAgICBcImRyc25vc3RcIixcbiAgICBcImRydGl0XCIsXG4gICAgXCJkcnpvc3RcIixcbiAgICBcImR1YmVuXCIsXG4gICAgXCJkdWNob3Zub1wiLFxuICAgIFwiZHVkZWtcIixcbiAgICBcImR1aGFcIixcbiAgICBcImR1aG92a2FcIixcbiAgICBcImR1c2l0XCIsXG4gICAgXCJkdXNub1wiLFxuICAgIFwiZHV0b3N0XCIsXG4gICAgXCJkdm9qaWNlXCIsXG4gICAgXCJkdm9yZWNcIixcbiAgICBcImR5bmFtaXRcIixcbiAgICBcImVrb2xvZ1wiLFxuICAgIFwiZWtvbm9taWVcIixcbiAgICBcImVsZWt0cm9uXCIsXG4gICAgXCJlbGlwc2FcIixcbiAgICBcImVtYWlsXCIsXG4gICAgXCJlbWlzZVwiLFxuICAgIFwiZW1vY2VcIixcbiAgICBcImVtcGF0aWVcIixcbiAgICBcImVwaXpvZGFcIixcbiAgICBcImVwb2NoYVwiLFxuICAgIFwiZXBvcGVqXCIsXG4gICAgXCJlcG9zXCIsXG4gICAgXCJlc2VqXCIsXG4gICAgXCJlc2VuY2VcIixcbiAgICBcImVza29ydGFcIixcbiAgICBcImVza3ltb1wiLFxuICAgIFwiZXRpa2V0YVwiLFxuICAgIFwiZXVmb3JpZVwiLFxuICAgIFwiZXZvbHVjZVwiLFxuICAgIFwiZXhla3VjZVwiLFxuICAgIFwiZXhrdXJ6ZVwiLFxuICAgIFwiZXhwZWRpY2VcIixcbiAgICBcImV4cGxvemVcIixcbiAgICBcImV4cG9ydFwiLFxuICAgIFwiZXh0cmFrdFwiLFxuICAgIFwiZmFja2FcIixcbiAgICBcImZhamZrYVwiLFxuICAgIFwiZmFrdWx0YVwiLFxuICAgIFwiZmFuYXRpa1wiLFxuICAgIFwiZmFudGF6aWVcIixcbiAgICBcImZhcm1hY2llXCIsXG4gICAgXCJmYXZvcml0XCIsXG4gICAgXCJmYXpvbGVcIixcbiAgICBcImZlZGVyYWNlXCIsXG4gICAgXCJmZWpldG9uXCIsXG4gICAgXCJmZW5rYVwiLFxuICAgIFwiZmlhbGthXCIsXG4gICAgXCJmaWd1cmFudFwiLFxuICAgIFwiZmlsb3pvZlwiLFxuICAgIFwiZmlsdHJcIixcbiAgICBcImZpbmFuY2VcIixcbiAgICBcImZpbnRhXCIsXG4gICAgXCJmaXhhY2VcIixcbiAgICBcImZqb3JkXCIsXG4gICAgXCJmbGFuZWxcIixcbiAgICBcImZsaXJ0XCIsXG4gICAgXCJmbG90aWxhXCIsXG4gICAgXCJmb25kXCIsXG4gICAgXCJmb3Nmb3JcIixcbiAgICBcImZvdGJhbFwiLFxuICAgIFwiZm90a2FcIixcbiAgICBcImZvdG9uXCIsXG4gICAgXCJmcmFrY2VcIixcbiAgICBcImZyZXNrYVwiLFxuICAgIFwiZnJvbnRhXCIsXG4gICAgXCJmdWthclwiLFxuICAgIFwiZnVua2NlXCIsXG4gICAgXCJmeXppa2FcIixcbiAgICBcImdhbGVqZVwiLFxuICAgIFwiZ2FyYW50XCIsXG4gICAgXCJnZW5ldGlrYVwiLFxuICAgIFwiZ2VvbG9nXCIsXG4gICAgXCJnaWxvdGluYVwiLFxuICAgIFwiZ2xhenVyYVwiLFxuICAgIFwiZ2xlanRcIixcbiAgICBcImdvbGVtXCIsXG4gICAgXCJnb2xmaXN0YVwiLFxuICAgIFwiZ290aWthXCIsXG4gICAgXCJncmFmXCIsXG4gICAgXCJncmFtb2ZvblwiLFxuICAgIFwiZ3JhbnVsZVwiLFxuICAgIFwiZ3JlcFwiLFxuICAgIFwiZ3JpbFwiLFxuICAgIFwiZ3JvZ1wiLFxuICAgIFwiZ3JvdGVza2FcIixcbiAgICBcImd1bWFcIixcbiAgICBcImhhZGljZVwiLFxuICAgIFwiaGFkclwiLFxuICAgIFwiaGFsYVwiLFxuICAgIFwiaGFsZW5rYVwiLFxuICAgIFwiaGFuYmFcIixcbiAgICBcImhhbm9waXNcIixcbiAgICBcImhhcmZhXCIsXG4gICAgXCJoYXJwdW5hXCIsXG4gICAgXCJoYXZyYW5cIixcbiAgICBcImhlYmtvc3RcIixcbiAgICBcImhlamthbFwiLFxuICAgIFwiaGVqbm9cIixcbiAgICBcImhlanRtYW5cIixcbiAgICBcImhla3RhclwiLFxuICAgIFwiaGVsbWFcIixcbiAgICBcImhlbWF0b21cIixcbiAgICBcImhlcmVjXCIsXG4gICAgXCJoZXJuYVwiLFxuICAgIFwiaGVzbG9cIixcbiAgICBcImhlemt5XCIsXG4gICAgXCJoaXN0b3Jpa1wiLFxuICAgIFwiaGxhZG92a2FcIixcbiAgICBcImhsYXNpdmt5XCIsXG4gICAgXCJobGF2YVwiLFxuICAgIFwiaGxlZGF0XCIsXG4gICAgXCJobGVuXCIsXG4gICAgXCJobG9kYXZlY1wiLFxuICAgIFwiaGxvaFwiLFxuICAgIFwiaGxvdXBvc3RcIixcbiAgICBcImhsdGF0XCIsXG4gICAgXCJobHViaW5hXCIsXG4gICAgXCJobHVjaG90YVwiLFxuICAgIFwiaG1hdFwiLFxuICAgIFwiaG1vdGFcIixcbiAgICBcImhteXpcIixcbiAgICBcImhuaXNcIixcbiAgICBcImhub2ppdm9cIixcbiAgICBcImhub3V0XCIsXG4gICAgXCJob2JsaW5hXCIsXG4gICAgXCJob2JvalwiLFxuICAgIFwiaG9jaFwiLFxuICAgIFwiaG9kaW55XCIsXG4gICAgXCJob2RsYXRcIixcbiAgICBcImhvZG5vdGFcIixcbiAgICBcImhvZG92YXRcIixcbiAgICBcImhvam5vc3RcIixcbiAgICBcImhva2VqXCIsXG4gICAgXCJob2xpbmthXCIsXG4gICAgXCJob2xrYVwiLFxuICAgIFwiaG9sdWJcIixcbiAgICBcImhvbW9sZVwiLFxuICAgIFwiaG9uaXRiYVwiLFxuICAgIFwiaG9ub3JhY2VcIixcbiAgICBcImhvcmFsXCIsXG4gICAgXCJob3JkYVwiLFxuICAgIFwiaG9yaXpvbnRcIixcbiAgICBcImhvcmtvXCIsXG4gICAgXCJob3JsaXZlY1wiLFxuICAgIFwiaG9ybW9uXCIsXG4gICAgXCJob3JuaW5hXCIsXG4gICAgXCJob3Jvc2tvcFwiLFxuICAgIFwiaG9yc3R2b1wiLFxuICAgIFwiaG9zcG9kYVwiLFxuICAgIFwiaG9zdGluYVwiLFxuICAgIFwiaG90b3Zvc3RcIixcbiAgICBcImhvdWJhXCIsXG4gICAgXCJob3VmXCIsXG4gICAgXCJob3VwYXRcIixcbiAgICBcImhvdXNrYVwiLFxuICAgIFwiaG92b3JcIixcbiAgICBcImhyYWRiYVwiLFxuICAgIFwiaHJhbmljZVwiLFxuICAgIFwiaHJhdm9zdFwiLFxuICAgIFwiaHJhemRhXCIsXG4gICAgXCJocmJvbGVrXCIsXG4gICAgXCJocmRpbmFcIixcbiAgICBcImhyZGxvXCIsXG4gICAgXCJocmRvc3RcIixcbiAgICBcImhybmVrXCIsXG4gICAgXCJocm9ia2FcIixcbiAgICBcImhyb21hZGFcIixcbiAgICBcImhyb3RcIixcbiAgICBcImhyb3VkYVwiLFxuICAgIFwiaHJvemVuXCIsXG4gICAgXCJocnN0a2FcIixcbiAgICBcImhydWJvc3RcIixcbiAgICBcImhyeXphdFwiLFxuICAgIFwiaHViZW5vc3RcIixcbiAgICBcImh1Ym5vdXRcIixcbiAgICBcImh1ZGJhXCIsXG4gICAgXCJodWtvdFwiLFxuICAgIFwiaHVtclwiLFxuICAgIFwiaHVzaXRhXCIsXG4gICAgXCJodXN0b3RhXCIsXG4gICAgXCJodm96ZFwiLFxuICAgIFwiaHlibm9zdFwiLFxuICAgIFwiaHlkcmFudFwiLFxuICAgIFwiaHlnaWVuYVwiLFxuICAgIFwiaHltbmFcIixcbiAgICBcImh5c3RlcmlrXCIsXG4gICAgXCJpZHlsa2FcIixcbiAgICBcImlobmVkXCIsXG4gICAgXCJpa29uYVwiLFxuICAgIFwiaWx1emVcIixcbiAgICBcImltdW5pdGFcIixcbiAgICBcImluZmVrY2VcIixcbiAgICBcImluZmxhY2VcIixcbiAgICBcImlua2Fzb1wiLFxuICAgIFwiaW5vdmFjZVwiLFxuICAgIFwiaW5zcGVrY2VcIixcbiAgICBcImludGVybmV0XCIsXG4gICAgXCJpbnZhbGlkYVwiLFxuICAgIFwiaW52ZXN0b3JcIixcbiAgICBcImluemVyY2VcIixcbiAgICBcImlyb25pZVwiLFxuICAgIFwiamFibGtvXCIsXG4gICAgXCJqYWNodGFcIixcbiAgICBcImphaG9kYVwiLFxuICAgIFwiamFrbWlsZVwiLFxuICAgIFwiamFrb3N0XCIsXG4gICAgXCJqYWxvdmVjXCIsXG4gICAgXCJqYW50YXJcIixcbiAgICBcImphcm1hcmtcIixcbiAgICBcImphcm9cIixcbiAgICBcImphc2FuXCIsXG4gICAgXCJqYXNub1wiLFxuICAgIFwiamF0a2FcIixcbiAgICBcImphdm9yXCIsXG4gICAgXCJqYXp5a1wiLFxuICAgIFwiamVkaW5lY1wiLFxuICAgIFwiamVkbGVcIixcbiAgICBcImplZG5hdGVsXCIsXG4gICAgXCJqZWhsYW5cIixcbiAgICBcImpla290XCIsXG4gICAgXCJqZWxlblwiLFxuICAgIFwiamVsaXRvXCIsXG4gICAgXCJqZW1ub3N0XCIsXG4gICAgXCJqZW5vbVwiLFxuICAgIFwiamVwaWNlXCIsXG4gICAgXCJqZXNldGVyXCIsXG4gICAgXCJqZXZpdFwiLFxuICAgIFwiamV6ZGVjXCIsXG4gICAgXCJqZXplcm9cIixcbiAgICBcImppbmFrXCIsXG4gICAgXCJqaW5keVwiLFxuICAgIFwiamlub2NoXCIsXG4gICAgXCJqaXNrcmFcIixcbiAgICBcImppc3RvdGFcIixcbiAgICBcImppdHJuaWNlXCIsXG4gICAgXCJqaXp2YVwiLFxuICAgIFwiam1lbm92YXRcIixcbiAgICBcImpvZ3VydFwiLFxuICAgIFwianVydGFcIixcbiAgICBcImthYmFyZXRcIixcbiAgICBcImthYmVsXCIsXG4gICAgXCJrYWJpbmV0XCIsXG4gICAgXCJrYWNobmFcIixcbiAgICBcImthZGV0XCIsXG4gICAgXCJrYWRpZGxvXCIsXG4gICAgXCJrYWhhblwiLFxuICAgIFwia2FqYWtcIixcbiAgICBcImthanV0YVwiLFxuICAgIFwia2FrYW9cIixcbiAgICBcImtha3R1c1wiLFxuICAgIFwia2FsYW1pdGFcIixcbiAgICBcImthbGhvdHlcIixcbiAgICBcImthbGliclwiLFxuICAgIFwia2Fsbm9zdFwiLFxuICAgIFwia2FtZXJhXCIsXG4gICAgXCJrYW1rb2xpdlwiLFxuICAgIFwia2FtbmFcIixcbiAgICBcImthbmliYWxcIixcbiAgICBcImthbm9lXCIsXG4gICAgXCJrYW50b3JcIixcbiAgICBcImthcGFsaW5hXCIsXG4gICAgXCJrYXBlbGFcIixcbiAgICBcImthcGl0b2xhXCIsXG4gICAgXCJrYXBrYVwiLFxuICAgIFwia2FwbGVcIixcbiAgICBcImthcG90YVwiLFxuICAgIFwia2FwclwiLFxuICAgIFwia2FwdXN0YVwiLFxuICAgIFwia2FweWJhcmFcIixcbiAgICBcImthcmFtZWxcIixcbiAgICBcImthcm90a2FcIixcbiAgICBcImthcnRvblwiLFxuICAgIFwia2FzYVwiLFxuICAgIFwia2F0YWxvZ1wiLFxuICAgIFwia2F0ZWRyYVwiLFxuICAgIFwia2F1Y2VcIixcbiAgICBcImthdXphXCIsXG4gICAgXCJrYXZhbGVjXCIsXG4gICAgXCJrYXphamthXCIsXG4gICAgXCJrYXpldGFcIixcbiAgICBcImtheml2b3N0XCIsXG4gICAgXCJrZGVrb2xpdlwiLFxuICAgIFwia2Rlc2lcIixcbiAgICBcImtlZGx1YmVuXCIsXG4gICAgXCJrZW1wXCIsXG4gICAgXCJrZXJhbWlrYVwiLFxuICAgIFwia2lub1wiLFxuICAgIFwia2xhY2VrXCIsXG4gICAgXCJrbGFkaXZvXCIsXG4gICAgXCJrbGFtXCIsXG4gICAgXCJrbGFwb3RcIixcbiAgICBcImtsYXNpa2FcIixcbiAgICBcImtsYXVuXCIsXG4gICAgXCJrbGVjXCIsXG4gICAgXCJrbGVuYmFcIixcbiAgICBcImtsZXBhdFwiLFxuICAgIFwia2xlc25vdXRcIixcbiAgICBcImtsaWRcIixcbiAgICBcImtsaW1hXCIsXG4gICAgXCJrbGlzbmFcIixcbiAgICBcImtsb2JvdWtcIixcbiAgICBcImtsb2thblwiLFxuICAgIFwia2xvcGFcIixcbiAgICBcImtsb3ViXCIsXG4gICAgXCJrbHVib3ZuYVwiLFxuICAgIFwia2x1c2F0XCIsXG4gICAgXCJrbHV6a29zdFwiLFxuICAgIFwia21lblwiLFxuICAgIFwia21pdGF0XCIsXG4gICAgXCJrbW90clwiLFxuICAgIFwia25paGFcIixcbiAgICBcImtub3RcIixcbiAgICBcImtvYWxpY2VcIixcbiAgICBcImtvYmVyZWNcIixcbiAgICBcImtvYmthXCIsXG4gICAgXCJrb2JsaWhhXCIsXG4gICAgXCJrb2J5bGFcIixcbiAgICBcImtvY291clwiLFxuICAgIFwia29ob3V0XCIsXG4gICAgXCJrb2plbmVjXCIsXG4gICAgXCJrb2tvc1wiLFxuICAgIFwia29rdGVqbFwiLFxuICAgIFwia29sYXBzXCIsXG4gICAgXCJrb2xlZGFcIixcbiAgICBcImtvbGl6ZVwiLFxuICAgIFwia29sb1wiLFxuICAgIFwia29tYW5kb1wiLFxuICAgIFwia29tZXRhXCIsXG4gICAgXCJrb21pa1wiLFxuICAgIFwia29tbmF0YVwiLFxuICAgIFwia29tb3JhXCIsXG4gICAgXCJrb21wYXNcIixcbiAgICBcImtvbXVuaXRhXCIsXG4gICAgXCJrb25hdFwiLFxuICAgIFwia29uY2VwdFwiLFxuICAgIFwia29uZGljZVwiLFxuICAgIFwia29uZWNcIixcbiAgICBcImtvbmZlc2VcIixcbiAgICBcImtvbmdyZXNcIixcbiAgICBcImtvbmluYVwiLFxuICAgIFwia29ua3Vyc1wiLFxuICAgIFwia29udGFrdFwiLFxuICAgIFwia29uemVydmFcIixcbiAgICBcImtvcGFuZWNcIixcbiAgICBcImtvcGllXCIsXG4gICAgXCJrb3Bub3V0XCIsXG4gICAgXCJrb3Byb3ZrYVwiLFxuICAgIFwia29yYmVsXCIsXG4gICAgXCJrb3Jla3RvclwiLFxuICAgIFwia29ybWlkbG9cIixcbiAgICBcImtvcm9wdGV2XCIsXG4gICAgXCJrb3JwdXNcIixcbiAgICBcImtvcnVuYVwiLFxuICAgIFwia29yeXRvXCIsXG4gICAgXCJrb3J6ZXRcIixcbiAgICBcImtvc2F0ZWNcIixcbiAgICBcImtvc3RrYVwiLFxuICAgIFwia290ZWxcIixcbiAgICBcImtvdGxldGFcIixcbiAgICBcImtvdG91bFwiLFxuICAgIFwia291a2F0XCIsXG4gICAgXCJrb3VwZWxuYVwiLFxuICAgIFwia291c2VrXCIsXG4gICAgXCJrb3V6bG9cIixcbiAgICBcImtvdmJvalwiLFxuICAgIFwia296YVwiLFxuICAgIFwia296b3JvaFwiLFxuICAgIFwia3JhYmljZVwiLFxuICAgIFwia3JhY2hcIixcbiAgICBcImtyYWppbmFcIixcbiAgICBcImtyYWxvdmF0XCIsXG4gICAgXCJrcmFzb3Bpc1wiLFxuICAgIFwia3JhdmF0YVwiLFxuICAgIFwia3JlZGl0XCIsXG4gICAgXCJrcmVqY2FyXCIsXG4gICAgXCJrcmVzYmFcIixcbiAgICBcImtyZXZldGFcIixcbiAgICBcImtyaWtldFwiLFxuICAgIFwia3JpdGlrXCIsXG4gICAgXCJrcml6ZVwiLFxuICAgIFwia3JrYXZlY1wiLFxuICAgIFwia3JtZWxlY1wiLFxuICAgIFwia3JtaXZvXCIsXG4gICAgXCJrcm9jYW5cIixcbiAgICBcImtyb2tcIixcbiAgICBcImtyb25pa2FcIixcbiAgICBcImtyb3BpdFwiLFxuICAgIFwia3JvdXBhXCIsXG4gICAgXCJrcm92a2FcIixcbiAgICBcImtydGVrXCIsXG4gICAgXCJrcnVoYWRsb1wiLFxuICAgIFwia3J1cGljZVwiLFxuICAgIFwia3J1dG9zdFwiLFxuICAgIFwia3J2aW5rYVwiLFxuICAgIFwia3J5Y2hsZVwiLFxuICAgIFwia3J5cHRhXCIsXG4gICAgXCJrcnlzdGFsXCIsXG4gICAgXCJrcnl0XCIsXG4gICAgXCJrdWRsYW5rYVwiLFxuICAgIFwia3VmclwiLFxuICAgIFwia3Vqbm9zdFwiLFxuICAgIFwia3VrbGFcIixcbiAgICBcImt1bGFqZGFcIixcbiAgICBcImt1bGljaFwiLFxuICAgIFwia3Vsa2FcIixcbiAgICBcImt1bG9tZXRcIixcbiAgICBcImt1bHR1cmFcIixcbiAgICBcImt1bmFcIixcbiAgICBcImt1cG9kaXZ1XCIsXG4gICAgXCJrdXJ0XCIsXG4gICAgXCJrdXJ6b3JcIixcbiAgICBcImt1dGlsXCIsXG4gICAgXCJrdmFsaXRhXCIsXG4gICAgXCJrdmFzaW5rYVwiLFxuICAgIFwia3Zlc3RvclwiLFxuICAgIFwia3lub2xvZ1wiLFxuICAgIFwia3lzZWxpbmFcIixcbiAgICBcImt5dGFyYVwiLFxuICAgIFwia3l0aWNlXCIsXG4gICAgXCJreXRrYVwiLFxuICAgIFwia3l0b3ZlY1wiLFxuICAgIFwia3l2YWRsb1wiLFxuICAgIFwibGFicmFkb3JcIixcbiAgICBcImxhY2h0YW5cIixcbiAgICBcImxhZG5vc3RcIixcbiAgICBcImxhaWtcIixcbiAgICBcImxha29tZWNcIixcbiAgICBcImxhbWVsYVwiLFxuICAgIFwibGFtcGFcIixcbiAgICBcImxhbm92a2FcIixcbiAgICBcImxhc2ljZVwiLFxuICAgIFwibGFzb1wiLFxuICAgIFwibGFzdHVyYVwiLFxuICAgIFwibGF0aW5rYVwiLFxuICAgIFwibGF2aW5hXCIsXG4gICAgXCJsZWJrYVwiLFxuICAgIFwibGVja2R5XCIsXG4gICAgXCJsZWRlblwiLFxuICAgIFwibGVkbmljZVwiLFxuICAgIFwibGVkb3ZrYVwiLFxuICAgIFwibGVkdmluYVwiLFxuICAgIFwibGVnZW5kYVwiLFxuICAgIFwibGVnaWVcIixcbiAgICBcImxlZ3JhY2VcIixcbiAgICBcImxlaGNlXCIsXG4gICAgXCJsZWhrb3N0XCIsXG4gICAgXCJsZWhub3V0XCIsXG4gICAgXCJsZWt0dmFyXCIsXG4gICAgXCJsZW5vY2hvZFwiLFxuICAgIFwibGVudGlsa2FcIixcbiAgICBcImxlcGVua2FcIixcbiAgICBcImxlcGlkbG9cIixcbiAgICBcImxldGFkbG9cIixcbiAgICBcImxldGVjXCIsXG4gICAgXCJsZXRtb1wiLFxuICAgIFwibGV0b2tydWhcIixcbiAgICBcImxldmhhcnRcIixcbiAgICBcImxldml0YWNlXCIsXG4gICAgXCJsZXZvYm9rXCIsXG4gICAgXCJsaWJyYVwiLFxuICAgIFwibGljaG90a2FcIixcbiAgICBcImxpZG9qZWRcIixcbiAgICBcImxpZHNrb3N0XCIsXG4gICAgXCJsaWhvdmluYVwiLFxuICAgIFwibGlqYXZlY1wiLFxuICAgIFwibGlsZWtcIixcbiAgICBcImxpbWV0a2FcIixcbiAgICBcImxpbmllXCIsXG4gICAgXCJsaW5rYVwiLFxuICAgIFwibGlub2xldW1cIixcbiAgICBcImxpc3RvcGFkXCIsXG4gICAgXCJsaXRpbmFcIixcbiAgICBcImxpdG92YXRcIixcbiAgICBcImxvYmlzdGFcIixcbiAgICBcImxvZGl2b2RcIixcbiAgICBcImxvZ2lrYVwiLFxuICAgIFwibG9nb3BlZFwiLFxuICAgIFwibG9rYWxpdGFcIixcbiAgICBcImxva2V0XCIsXG4gICAgXCJsb21jb3ZhdFwiLFxuICAgIFwibG9wYXRhXCIsXG4gICAgXCJsb3B1Y2hcIixcbiAgICBcImxvcmRcIixcbiAgICBcImxvc29zXCIsXG4gICAgXCJsb3RyXCIsXG4gICAgXCJsb3VkYWxcIixcbiAgICBcImxvdWhcIixcbiAgICBcImxvdWthXCIsXG4gICAgXCJsb3Vza2F0XCIsXG4gICAgXCJsb3ZlY1wiLFxuICAgIFwibHN0aXZvc3RcIixcbiAgICBcImx1Y2VybmFcIixcbiAgICBcImx1Y2lmZXJcIixcbiAgICBcImx1bXBcIixcbiAgICBcImx1c2tcIixcbiAgICBcImx1c3RyYWNlXCIsXG4gICAgXCJsdmljZVwiLFxuICAgIFwibHlyYVwiLFxuICAgIFwibHlyaWthXCIsXG4gICAgXCJseXNpbmFcIixcbiAgICBcIm1hZGFtXCIsXG4gICAgXCJtYWRsb1wiLFxuICAgIFwibWFnaXN0clwiLFxuICAgIFwibWFoYWdvblwiLFxuICAgIFwibWFqZXRla1wiLFxuICAgIFwibWFqaXRlbFwiLFxuICAgIFwibWFqb3JpdGFcIixcbiAgICBcIm1ha2FrXCIsXG4gICAgXCJtYWtvdmljZVwiLFxuICAgIFwibWFrcmVsYVwiLFxuICAgIFwibWFsYmFcIixcbiAgICBcIm1hbGluYVwiLFxuICAgIFwibWFsb3ZhdFwiLFxuICAgIFwibWFsdmljZVwiLFxuICAgIFwibWFtaW5rYVwiLFxuICAgIFwibWFuZGxlXCIsXG4gICAgXCJtYW5rb1wiLFxuICAgIFwibWFybm9zdFwiLFxuICAgIFwibWFzYWtyXCIsXG4gICAgXCJtYXNrb3RcIixcbiAgICBcIm1hc29wdXN0XCIsXG4gICAgXCJtYXRpY2VcIixcbiAgICBcIm1hdHJpa2FcIixcbiAgICBcIm1hdHVyaXRhXCIsXG4gICAgXCJtYXphbmVjXCIsXG4gICAgXCJtYXppdm9cIixcbiAgICBcIm1hemxpdFwiLFxuICAgIFwibWF6dXJrYVwiLFxuICAgIFwibWRsb2JhXCIsXG4gICAgXCJtZWNoYW5pa1wiLFxuICAgIFwibWVkaXRhY2VcIixcbiAgICBcIm1lZG92aW5hXCIsXG4gICAgXCJtZWxhc2FcIixcbiAgICBcIm1lbG91blwiLFxuICAgIFwibWVudG9sa2FcIixcbiAgICBcIm1ldGxhXCIsXG4gICAgXCJtZXRvZGFcIixcbiAgICBcIm1ldHJcIixcbiAgICBcIm1lemVyYVwiLFxuICAgIFwibWlncmFjZVwiLFxuICAgIFwibWlobm91dFwiLFxuICAgIFwibWlodWxlXCIsXG4gICAgXCJtaWtpbmFcIixcbiAgICBcIm1pa3JvZm9uXCIsXG4gICAgXCJtaWxlbmVjXCIsXG4gICAgXCJtaWxpbWV0clwiLFxuICAgIFwibWlsb3N0XCIsXG4gICAgXCJtaW1pa2FcIixcbiAgICBcIm1pbmNvdm5hXCIsXG4gICAgXCJtaW5pYmFyXCIsXG4gICAgXCJtaW5vbWV0XCIsXG4gICAgXCJtaW51bG9zdFwiLFxuICAgIFwibWlza2FcIixcbiAgICBcIm1pc3RyXCIsXG4gICAgXCJtaXhvdmF0XCIsXG4gICAgXCJtbGFkb3N0XCIsXG4gICAgXCJtbGhhXCIsXG4gICAgXCJtbGhvdmluYVwiLFxuICAgIFwibWxva1wiLFxuICAgIFwibWxzYXRcIixcbiAgICBcIm1sdXZpdFwiLFxuICAgIFwibW5pY2hcIixcbiAgICBcIm1ub2hlbVwiLFxuICAgIFwibW9iaWxcIixcbiAgICBcIm1vY25vc3RcIixcbiAgICBcIm1vZGVsa2FcIixcbiAgICBcIm1vZGxpdGJhXCIsXG4gICAgXCJtb2h5bGFcIixcbiAgICBcIm1va3JvXCIsXG4gICAgXCJtb2xla3VsYVwiLFxuICAgIFwibW9tZW50a2FcIixcbiAgICBcIm1vbmFyY2hhXCIsXG4gICAgXCJtb25va2xcIixcbiAgICBcIm1vbnN0cnVtXCIsXG4gICAgXCJtb250b3ZhdFwiLFxuICAgIFwibW9uenVuXCIsXG4gICAgXCJtb3NhelwiLFxuICAgIFwibW9za3l0XCIsXG4gICAgXCJtb3N0XCIsXG4gICAgXCJtb3RpdmFjZVwiLFxuICAgIFwibW90b3JrYVwiLFxuICAgIFwibW90eWthXCIsXG4gICAgXCJtb3VjaGFcIixcbiAgICBcIm1vdWRyb3N0XCIsXG4gICAgXCJtb3phaWthXCIsXG4gICAgXCJtb3pla1wiLFxuICAgIFwibW96b2xcIixcbiAgICBcIm1yYW1vclwiLFxuICAgIFwibXJhdmVuZWNcIixcbiAgICBcIm1ya2V2XCIsXG4gICAgXCJtcnR2b2xhXCIsXG4gICAgXCJtcnpldFwiLFxuICAgIFwibXJ6dXRvc3RcIixcbiAgICBcIm1zdGl0ZWxcIixcbiAgICBcIm11ZHJjXCIsXG4gICAgXCJtdWZsb25cIixcbiAgICBcIm11bGF0XCIsXG4gICAgXCJtdW1pZVwiLFxuICAgIFwibXVuaWNlXCIsXG4gICAgXCJtdXNldFwiLFxuICAgIFwibXV0YWNlXCIsXG4gICAgXCJtdXpldW1cIixcbiAgICBcIm11emlrYW50XCIsXG4gICAgXCJteXNsaXZlY1wiLFxuICAgIFwibXpkYVwiLFxuICAgIFwibmFib3VyYXRcIixcbiAgICBcIm5hY2h5dGF0XCIsXG4gICAgXCJuYWRhY2VcIixcbiAgICBcIm5hZGJ5dGVrXCIsXG4gICAgXCJuYWRob3pcIixcbiAgICBcIm5hZG9icm9cIixcbiAgICBcIm5hZHBpc1wiLFxuICAgIFwibmFobGFzXCIsXG4gICAgXCJuYWhuYXRcIixcbiAgICBcIm5haG9kaWxlXCIsXG4gICAgXCJuYWhyYWRpdFwiLFxuICAgIFwibmFpdml0YVwiLFxuICAgIFwibmFqZWRub3VcIixcbiAgICBcIm5hamlzdG9cIixcbiAgICBcIm5ham1vdXRcIixcbiAgICBcIm5ha2xvbml0XCIsXG4gICAgXCJuYWtvbmVjXCIsXG4gICAgXCJuYWtybWl0XCIsXG4gICAgXCJuYWxldm9cIixcbiAgICBcIm5hbWF6YXRcIixcbiAgICBcIm5hbWx1dml0XCIsXG4gICAgXCJuYW5vbWV0clwiLFxuICAgIFwibmFva29cIixcbiAgICBcIm5hb3Bha1wiLFxuICAgIFwibmFvc3Ryb1wiLFxuICAgIFwibmFwYWRhdFwiLFxuICAgIFwibmFwZXZub1wiLFxuICAgIFwibmFwbG5pdFwiLFxuICAgIFwibmFwbm91dFwiLFxuICAgIFwibmFwb3NsZWRcIixcbiAgICBcIm5hcHJvc3RvXCIsXG4gICAgXCJuYXJvZGl0XCIsXG4gICAgXCJuYXJ1YnlcIixcbiAgICBcIm5hcnljaGxvXCIsXG4gICAgXCJuYXNhZGl0XCIsXG4gICAgXCJuYXNla2F0XCIsXG4gICAgXCJuYXNsZXBvXCIsXG4gICAgXCJuYXN0YXRcIixcbiAgICBcIm5hdG9saWtcIixcbiAgICBcIm5hdmVuZWtcIixcbiAgICBcIm5hdnJjaFwiLFxuICAgIFwibmF2emRvcnlcIixcbiAgICBcIm5henZhdFwiLFxuICAgIFwibmViZVwiLFxuICAgIFwibmVjaGF0XCIsXG4gICAgXCJuZWNreVwiLFxuICAgIFwibmVkYWxla29cIixcbiAgICBcIm5lZGJhdFwiLFxuICAgIFwibmVkdWhcIixcbiAgICBcIm5lZ2FjZVwiLFxuICAgIFwibmVoZXRcIixcbiAgICBcIm5laG9kYVwiLFxuICAgIFwibmVqZW5cIixcbiAgICBcIm5lanBydmVcIixcbiAgICBcIm5la2xpZFwiLFxuICAgIFwibmVsaWJvc3RcIixcbiAgICBcIm5lbWlsb3N0XCIsXG4gICAgXCJuZW1vY1wiLFxuICAgIFwibmVvY2hvdGFcIixcbiAgICBcIm5lb25rYVwiLFxuICAgIFwibmVwb2tvalwiLFxuICAgIFwibmVyb3N0XCIsXG4gICAgXCJuZXJ2XCIsXG4gICAgXCJuZXNteXNsXCIsXG4gICAgXCJuZXNvdWxhZFwiLFxuICAgIFwibmV0dm9yXCIsXG4gICAgXCJuZXVyb25cIixcbiAgICBcIm5ldmluYVwiLFxuICAgIFwibmV6dnlrbGVcIixcbiAgICBcIm5pY290YVwiLFxuICAgIFwibmlqYWtcIixcbiAgICBcIm5pa2FtXCIsXG4gICAgXCJuaWtkeVwiLFxuICAgIFwibmlrbFwiLFxuICAgIFwibmlrdGVyYWtcIixcbiAgICBcIm5pdHJvXCIsXG4gICAgXCJub2NsZWhcIixcbiAgICBcIm5vaGF2aWNlXCIsXG4gICAgXCJub21pbmFjZVwiLFxuICAgIFwibm9yYVwiLFxuICAgIFwibm9yZWtcIixcbiAgICBcIm5vc2l0ZWxcIixcbiAgICBcIm5vc25vc3RcIixcbiAgICBcIm5vdXplXCIsXG4gICAgXCJub3ZpbnlcIixcbiAgICBcIm5vdm90YVwiLFxuICAgIFwibm96ZHJhXCIsXG4gICAgXCJudWRhXCIsXG4gICAgXCJudWRsZVwiLFxuICAgIFwibnVnZXRcIixcbiAgICBcIm51dGl0XCIsXG4gICAgXCJudXRub3N0XCIsXG4gICAgXCJudXRyaWVcIixcbiAgICBcIm55bWZhXCIsXG4gICAgXCJvYmFsXCIsXG4gICAgXCJvYmFydml0XCIsXG4gICAgXCJvYmF2YVwiLFxuICAgIFwib2JkaXZcIixcbiAgICBcIm9iZWNcIixcbiAgICBcIm9iZWhuYXRcIixcbiAgICBcIm9iZWptb3V0XCIsXG4gICAgXCJvYmV6aXRhXCIsXG4gICAgXCJvYmhham9iYVwiLFxuICAgIFwib2JpbG5pY2VcIixcbiAgICBcIm9iamFzbml0XCIsXG4gICAgXCJvYmpla3RcIixcbiAgICBcIm9ia2xvcGl0XCIsXG4gICAgXCJvYmxhc3RcIixcbiAgICBcIm9ibGVrXCIsXG4gICAgXCJvYmxpYmFcIixcbiAgICBcIm9ibG9oYVwiLFxuICAgIFwib2JsdWRhXCIsXG4gICAgXCJvYm5vc1wiLFxuICAgIFwib2JvaGF0aXRcIixcbiAgICBcIm9ib2pla1wiLFxuICAgIFwib2JvdXRcIixcbiAgICBcIm9icmF6ZWNcIixcbiAgICBcIm9icm5hXCIsXG4gICAgXCJvYnJ1YmFcIixcbiAgICBcIm9icnlzXCIsXG4gICAgXCJvYnNhaFwiLFxuICAgIFwib2JzbHVoYVwiLFxuICAgIFwib2JzdGFyYXRcIixcbiAgICBcIm9idXZcIixcbiAgICBcIm9idmF6XCIsXG4gICAgXCJvYnZpbml0XCIsXG4gICAgXCJvYnZvZFwiLFxuICAgIFwib2J2eWtsZVwiLFxuICAgIFwib2J5dmF0ZWxcIixcbiAgICBcIm9iem9yXCIsXG4gICAgXCJvY2FzXCIsXG4gICAgXCJvY2VsXCIsXG4gICAgXCJvY2VuaXRcIixcbiAgICBcIm9jaGxhZGl0XCIsXG4gICAgXCJvY2hvdGFcIixcbiAgICBcIm9jaHJhbmFcIixcbiAgICBcIm9jaXRub3V0XCIsXG4gICAgXCJvZGJvalwiLFxuICAgIFwib2RieXRcIixcbiAgICBcIm9kY2hvZFwiLFxuICAgIFwib2RjaXppdFwiLFxuICAgIFwib2RlYnJhdFwiLFxuICAgIFwib2Rlc2xhdFwiLFxuICAgIFwib2RldnpkYXRcIixcbiAgICBcIm9kZXp2YVwiLFxuICAgIFwib2RoYWRjZVwiLFxuICAgIFwib2Rob2RpdFwiLFxuICAgIFwib2RqZXRcIixcbiAgICBcIm9kamludWRcIixcbiAgICBcIm9ka2F6XCIsXG4gICAgXCJvZGtvdXBpdFwiLFxuICAgIFwib2RsaXZcIixcbiAgICBcIm9kbHVrYVwiLFxuICAgIFwib2RtbGthXCIsXG4gICAgXCJvZG9sbm9zdFwiLFxuICAgIFwib2RwYWRcIixcbiAgICBcIm9kcGlzXCIsXG4gICAgXCJvZHBsb3V0XCIsXG4gICAgXCJvZHBvclwiLFxuICAgIFwib2RwdXN0aXRcIixcbiAgICBcIm9kcHlrYXRcIixcbiAgICBcIm9kcmF6a2FcIixcbiAgICBcIm9kc291ZGl0XCIsXG4gICAgXCJvZHN0dXBcIixcbiAgICBcIm9kc3VuXCIsXG4gICAgXCJvZHRva1wiLFxuICAgIFwib2R0dWRcIixcbiAgICBcIm9kdmFoYVwiLFxuICAgIFwib2R2ZXRhXCIsXG4gICAgXCJvZHZvbGF0XCIsXG4gICAgXCJvZHZyYWNldFwiLFxuICAgIFwib2R6bmFrXCIsXG4gICAgXCJvZmluYVwiLFxuICAgIFwib2ZzYWpkXCIsXG4gICAgXCJvaGxhc1wiLFxuICAgIFwib2huaXNrb1wiLFxuICAgIFwib2hyYWRhXCIsXG4gICAgXCJvaHJveml0XCIsXG4gICAgXCJvaHJ5emVrXCIsXG4gICAgXCJva2FwXCIsXG4gICAgXCJva2VuaWNlXCIsXG4gICAgXCJva2xpa2FcIixcbiAgICBcIm9rbm9cIixcbiAgICBcIm9rb3V6bGl0XCIsXG4gICAgXCJva292eVwiLFxuICAgIFwib2tyYXNhXCIsXG4gICAgXCJva3Jlc1wiLFxuICAgIFwib2tyc2VrXCIsXG4gICAgXCJva3J1aFwiLFxuICAgIFwib2t1cGFudFwiLFxuICAgIFwib2t1cmthXCIsXG4gICAgXCJva3VzaXRcIixcbiAgICBcIm9sZWpuaW5hXCIsXG4gICAgXCJvbGl6b3ZhdFwiLFxuICAgIFwib21ha1wiLFxuICAgIFwib21lbGV0YVwiLFxuICAgIFwib21leml0XCIsXG4gICAgXCJvbWxhZGluYVwiLFxuICAgIFwib21sb3V2YXRcIixcbiAgICBcIm9tbHV2YVwiLFxuICAgIFwib215bFwiLFxuICAgIFwib25laGR5XCIsXG4gICAgXCJvcGFrb3ZhdFwiLFxuICAgIFwib3Bhc2VrXCIsXG4gICAgXCJvcGVyYWNlXCIsXG4gICAgXCJvcGljZVwiLFxuICAgIFwib3BpbG9zdFwiLFxuICAgIFwib3Bpc292YXRcIixcbiAgICBcIm9wb3JhXCIsXG4gICAgXCJvcG96aWNlXCIsXG4gICAgXCJvcHJhdmR1XCIsXG4gICAgXCJvcHJvdGlcIixcbiAgICBcIm9yYml0YWxcIixcbiAgICBcIm9yY2hlc3RyXCIsXG4gICAgXCJvcmdpZVwiLFxuICAgIFwib3JsaWNlXCIsXG4gICAgXCJvcmxvalwiLFxuICAgIFwib3J0ZWxcIixcbiAgICBcIm9zYWRhXCIsXG4gICAgXCJvc2Nobm91dFwiLFxuICAgIFwib3Npa2FcIixcbiAgICBcIm9zaXZvXCIsXG4gICAgXCJvc2xhdmFcIixcbiAgICBcIm9zbGVwaXRcIixcbiAgICBcIm9zbG5pdFwiLFxuICAgIFwib3Nsb3ZpdFwiLFxuICAgIFwib3Nub3ZhXCIsXG4gICAgXCJvc29iYVwiLFxuICAgIFwib3NvbGl0XCIsXG4gICAgXCJvc3BhbGVjXCIsXG4gICAgXCJvc3RlblwiLFxuICAgIFwib3N0cmFoYVwiLFxuICAgIFwib3N0dWRhXCIsXG4gICAgXCJvc3R5Y2hcIixcbiAgICBcIm9zdm9qaXRcIixcbiAgICBcIm90ZXBsaXRcIixcbiAgICBcIm90aXNrXCIsXG4gICAgXCJvdG9wXCIsXG4gICAgXCJvdHJoYXRcIixcbiAgICBcIm90cmxvc3RcIixcbiAgICBcIm90cm9rXCIsXG4gICAgXCJvdHJ1YnlcIixcbiAgICBcIm90dm9yXCIsXG4gICAgXCJvdmFub3V0XCIsXG4gICAgXCJvdmFyXCIsXG4gICAgXCJvdmVzXCIsXG4gICAgXCJvdmxpdm5pdFwiLFxuICAgIFwib3ZvY2VcIixcbiAgICBcIm94aWRcIixcbiAgICBcIm96ZG9iYVwiLFxuICAgIFwicGFjaGF0ZWxcIixcbiAgICBcInBhY2llbnRcIixcbiAgICBcInBhZG91Y2hcIixcbiAgICBcInBhaG9yZWtcIixcbiAgICBcInBha3RcIixcbiAgICBcInBhbGFuZGFcIixcbiAgICBcInBhbGVjXCIsXG4gICAgXCJwYWxpdm9cIixcbiAgICBcInBhbHViYVwiLFxuICAgIFwicGFtZmxldFwiLFxuICAgIFwicGFtbHNla1wiLFxuICAgIFwicGFuZW5rYVwiLFxuICAgIFwicGFuaWthXCIsXG4gICAgXCJwYW5uYVwiLFxuICAgIFwicGFub3ZhdFwiLFxuICAgIFwicGFuc3R2b1wiLFxuICAgIFwicGFudG9mbGVcIixcbiAgICBcInBhcHJpa2FcIixcbiAgICBcInBhcmtldGFcIixcbiAgICBcInBhcm9kaWVcIixcbiAgICBcInBhcnRhXCIsXG4gICAgXCJwYXJ1a2FcIixcbiAgICBcInBhcnliYVwiLFxuICAgIFwicGFzZWthXCIsXG4gICAgXCJwYXNpdml0YVwiLFxuICAgIFwicGFzdGVsa2FcIixcbiAgICBcInBhdGVudFwiLFxuICAgIFwicGF0cm9uYVwiLFxuICAgIFwicGF2b3VrXCIsXG4gICAgXCJwYXpuZWh0XCIsXG4gICAgXCJwYXpvdXJla1wiLFxuICAgIFwicGVja2FcIixcbiAgICBcInBlZGFnb2dcIixcbiAgICBcInBlanNla1wiLFxuICAgIFwicGVrbG9cIixcbiAgICBcInBlbG90b25cIixcbiAgICBcInBlbmFsdGFcIixcbiAgICBcInBlbmRyZWtcIixcbiAgICBcInBlbnplXCIsXG4gICAgXCJwZXJpc2tvcFwiLFxuICAgIFwicGVyb1wiLFxuICAgIFwicGVzdHJvc3RcIixcbiAgICBcInBldGFyZGFcIixcbiAgICBcInBldGljZVwiLFxuICAgIFwicGV0cm9sZWpcIixcbiAgICBcInBldm5pbmFcIixcbiAgICBcInBleGVzb1wiLFxuICAgIFwicGlhbmlzdGFcIixcbiAgICBcInBpaGFcIixcbiAgICBcInBpamF2aWNlXCIsXG4gICAgXCJwaWtsZVwiLFxuICAgIFwicGlrbmlrXCIsXG4gICAgXCJwaWxpbmFcIixcbiAgICBcInBpbG5vc3RcIixcbiAgICBcInBpbHVsa2FcIixcbiAgICBcInBpbnpldGFcIixcbiAgICBcInBpcGV0YVwiLFxuICAgIFwicGlzYXRlbFwiLFxuICAgIFwicGlzdG9sZVwiLFxuICAgIFwicGl0ZXZuYVwiLFxuICAgIFwicGl2bmljZVwiLFxuICAgIFwicGl2b3ZhclwiLFxuICAgIFwicGxhY2VudGFcIixcbiAgICBcInBsYWthdFwiLFxuICAgIFwicGxhbWVuXCIsXG4gICAgXCJwbGFuZXRhXCIsXG4gICAgXCJwbGFzdGlrYVwiLFxuICAgIFwicGxhdGl0XCIsXG4gICAgXCJwbGF2aWRsb1wiLFxuICAgIFwicGxhelwiLFxuICAgIFwicGxlY2hcIixcbiAgICBcInBsZW1lbm9cIixcbiAgICBcInBsZW50YVwiLFxuICAgIFwicGxlc1wiLFxuICAgIFwicGxldGl2b1wiLFxuICAgIFwicGxldmVsXCIsXG4gICAgXCJwbGl2YXRcIixcbiAgICBcInBsbml0XCIsXG4gICAgXCJwbG5vXCIsXG4gICAgXCJwbG9jaGFcIixcbiAgICBcInBsb2RpbmFcIixcbiAgICBcInBsb21iYVwiLFxuICAgIFwicGxvdXRcIixcbiAgICBcInBsdWtcIixcbiAgICBcInBseW5cIixcbiAgICBcInBvYmF2aXRcIixcbiAgICBcInBvYnl0XCIsXG4gICAgXCJwb2Nob2RcIixcbiAgICBcInBvY2l0XCIsXG4gICAgXCJwb2N0aXZlY1wiLFxuICAgIFwicG9kYXRcIixcbiAgICBcInBvZGNlbml0XCIsXG4gICAgXCJwb2RlcHNhdFwiLFxuICAgIFwicG9kaGxlZFwiLFxuICAgIFwicG9kaXZpdFwiLFxuICAgIFwicG9ka2xhZFwiLFxuICAgIFwicG9kbWFuaXRcIixcbiAgICBcInBvZG5pa1wiLFxuICAgIFwicG9kb2JhXCIsXG4gICAgXCJwb2Rwb3JhXCIsXG4gICAgXCJwb2RyYXpcIixcbiAgICBcInBvZHN0YXRhXCIsXG4gICAgXCJwb2R2b2RcIixcbiAgICBcInBvZHppbVwiLFxuICAgIFwicG9lemllXCIsXG4gICAgXCJwb2hhbmthXCIsXG4gICAgXCJwb2hudXRrYVwiLFxuICAgIFwicG9ob3ZvclwiLFxuICAgIFwicG9ocm9tYVwiLFxuICAgIFwicG9oeWJcIixcbiAgICBcInBvaW50YVwiLFxuICAgIFwicG9qaXN0a2FcIixcbiAgICBcInBvam1vdXRcIixcbiAgICBcInBva2F6aXRcIixcbiAgICBcInBva2xlc1wiLFxuICAgIFwicG9rb2pcIixcbiAgICBcInBva3Jva1wiLFxuICAgIFwicG9rdXRhXCIsXG4gICAgXCJwb2t5blwiLFxuICAgIFwicG9sZWRuZVwiLFxuICAgIFwicG9saWJla1wiLFxuICAgIFwicG9sa25vdXRcIixcbiAgICBcInBvbG9oYVwiLFxuICAgIFwicG9seW5vbVwiLFxuICAgIFwicG9tYWx1XCIsXG4gICAgXCJwb21pbm91dFwiLFxuICAgIFwicG9tbGthXCIsXG4gICAgXCJwb21vY1wiLFxuICAgIFwicG9tc3RhXCIsXG4gICAgXCJwb215c2xldFwiLFxuICAgIFwicG9uZWNoYXRcIixcbiAgICBcInBvbm9ya2FcIixcbiAgICBcInBvbnVyb3N0XCIsXG4gICAgXCJwb3BhZGF0XCIsXG4gICAgXCJwb3BlbFwiLFxuICAgIFwicG9waXNla1wiLFxuICAgIFwicG9wbGFjaFwiLFxuICAgIFwicG9wcm9zaXRcIixcbiAgICBcInBvcHNhdFwiLFxuICAgIFwicG9wdWRcIixcbiAgICBcInBvcmFkY2VcIixcbiAgICBcInBvcmNlXCIsXG4gICAgXCJwb3JvZFwiLFxuICAgIFwicG9ydWNoYVwiLFxuICAgIFwicG9yeXZcIixcbiAgICBcInBvc2FkaXRcIixcbiAgICBcInBvc2VkXCIsXG4gICAgXCJwb3NpbGFcIixcbiAgICBcInBvc2tva1wiLFxuICAgIFwicG9zbGFuZWNcIixcbiAgICBcInBvc291ZGl0XCIsXG4gICAgXCJwb3Nwb2x1XCIsXG4gICAgXCJwb3N0YXZhXCIsXG4gICAgXCJwb3N1ZGVrXCIsXG4gICAgXCJwb3N5cFwiLFxuICAgIFwicG90YWhcIixcbiAgICBcInBvdGthblwiLFxuICAgIFwicG90bGVza1wiLFxuICAgIFwicG90b21la1wiLFxuICAgIFwicG90cmF2YVwiLFxuICAgIFwicG90dXBhXCIsXG4gICAgXCJwb3R2b3JhXCIsXG4gICAgXCJwb3VrYXpcIixcbiAgICBcInBvdXRvXCIsXG4gICAgXCJwb3V6ZHJvXCIsXG4gICAgXCJwb3ZhaGFcIixcbiAgICBcInBvdmlkbGFcIixcbiAgICBcInBvdmxha1wiLFxuICAgIFwicG92b3pcIixcbiAgICBcInBvdnJjaFwiLFxuICAgIFwicG92c3RhdFwiLFxuICAgIFwicG92eWtcIixcbiAgICBcInBvdnpkZWNoXCIsXG4gICAgXCJwb3pkcmF2XCIsXG4gICAgXCJwb3plbWVrXCIsXG4gICAgXCJwb3puYXRla1wiLFxuICAgIFwicG96b3JcIixcbiAgICBcInBvenZhdFwiLFxuICAgIFwicHJhY292YXRcIixcbiAgICBcInByYWhvcnlcIixcbiAgICBcInByYWt0aWthXCIsXG4gICAgXCJwcmFsZXNcIixcbiAgICBcInByYW90ZWNcIixcbiAgICBcInByYXBvcmVrXCIsXG4gICAgXCJwcmFzZVwiLFxuICAgIFwicHJhdmRhXCIsXG4gICAgXCJwcmluY2lwXCIsXG4gICAgXCJwcmtub1wiLFxuICAgIFwicHJvYnVkaXRcIixcbiAgICBcInByb2NlbnRvXCIsXG4gICAgXCJwcm9kZWpcIixcbiAgICBcInByb2Zlc2VcIixcbiAgICBcInByb2hyYVwiLFxuICAgIFwicHJvamVrdFwiLFxuICAgIFwicHJvbG9taXRcIixcbiAgICBcInByb21pbGVcIixcbiAgICBcInByb25pa2F0XCIsXG4gICAgXCJwcm9wYWRcIixcbiAgICBcInByb3Jva1wiLFxuICAgIFwicHJvc2JhXCIsXG4gICAgXCJwcm90b25cIixcbiAgICBcInByb3V0ZWtcIixcbiAgICBcInByb3ZhelwiLFxuICAgIFwicHJza2F2a2FcIixcbiAgICBcInByc3RlblwiLFxuICAgIFwicHJ1ZGtvc3RcIixcbiAgICBcInBydXRcIixcbiAgICBcInBydmVrXCIsXG4gICAgXCJwcnZvaG9yeVwiLFxuICAgIFwicHNhbmVjXCIsXG4gICAgXCJwc292b2RcIixcbiAgICBcInBzdHJ1aFwiLFxuICAgIFwicHRhY3R2b1wiLFxuICAgIFwicHViZXJ0YVwiLFxuICAgIFwicHVjaFwiLFxuICAgIFwicHVkbFwiLFxuICAgIFwicHVrYXZlY1wiLFxuICAgIFwicHVrbGluYVwiLFxuICAgIFwicHVrcmxlXCIsXG4gICAgXCJwdWx0XCIsXG4gICAgXCJwdW1wYVwiLFxuICAgIFwicHVuY1wiLFxuICAgIFwicHVwZW5cIixcbiAgICBcInB1c2FcIixcbiAgICBcInB1c2lua2FcIixcbiAgICBcInB1c3RpbmFcIixcbiAgICBcInB1dG92YXRcIixcbiAgICBcInB1dHlrYVwiLFxuICAgIFwicHlyYW1pZGFcIixcbiAgICBcInB5c2tcIixcbiAgICBcInB5dGVsXCIsXG4gICAgXCJyYWNla1wiLFxuICAgIFwicmFjaG90XCIsXG4gICAgXCJyYWRpYWNlXCIsXG4gICAgXCJyYWRuaWNlXCIsXG4gICAgXCJyYWRvblwiLFxuICAgIFwicmFmdFwiLFxuICAgIFwicmFnYnlcIixcbiAgICBcInJha2V0YVwiLFxuICAgIFwicmFrb3ZpbmFcIixcbiAgICBcInJhbWVub1wiLFxuICAgIFwicmFtcG91Y2hcIixcbiAgICBcInJhbmRlXCIsXG4gICAgXCJyYXJhY2hcIixcbiAgICBcInJhcml0YVwiLFxuICAgIFwicmFzb3ZuYVwiLFxuICAgIFwicmFzdHJcIixcbiAgICBcInJhdG9sZXN0XCIsXG4gICAgXCJyYXphbmNlXCIsXG4gICAgXCJyYXppZGxvXCIsXG4gICAgXCJyZWFnb3ZhdFwiLFxuICAgIFwicmVha2NlXCIsXG4gICAgXCJyZWNlcHRcIixcbiAgICBcInJlZGFrdG9yXCIsXG4gICAgXCJyZWZlcmVudFwiLFxuICAgIFwicmVmbGV4XCIsXG4gICAgXCJyZWpub2tcIixcbiAgICBcInJla2xhbWFcIixcbiAgICBcInJla29yZFwiLFxuICAgIFwicmVrcnV0XCIsXG4gICAgXCJyZWt0b3JcIixcbiAgICBcInJlcHV0YWNlXCIsXG4gICAgXCJyZXZpemVcIixcbiAgICBcInJldm1hXCIsXG4gICAgXCJyZXZvbHZlclwiLFxuICAgIFwicmV6ZXJ2YVwiLFxuICAgIFwicmlza292YXRcIixcbiAgICBcInJpemlrb1wiLFxuICAgIFwicm9ib3Rpa2FcIixcbiAgICBcInJvZG9rbWVuXCIsXG4gICAgXCJyb2hvdmthXCIsXG4gICAgXCJyb2tsZVwiLFxuICAgIFwicm9rb2tvXCIsXG4gICAgXCJyb21hbmV0b1wiLFxuICAgIFwicm9wb3ZvZFwiLFxuICAgIFwicm9wdWNoYVwiLFxuICAgIFwicm9yZWpzXCIsXG4gICAgXCJyb3NvbFwiLFxuICAgIFwicm9zdGxpbmFcIixcbiAgICBcInJvdG1pc3RyXCIsXG4gICAgXCJyb3RvcGVkXCIsXG4gICAgXCJyb3R1bmRhXCIsXG4gICAgXCJyb3ViZW5rYVwiLFxuICAgIFwicm91Y2hvXCIsXG4gICAgXCJyb3VwXCIsXG4gICAgXCJyb3VyYVwiLFxuICAgIFwicm92aW5hXCIsXG4gICAgXCJyb3ZuaWNlXCIsXG4gICAgXCJyb3pib3JcIixcbiAgICBcInJvemNob2RcIixcbiAgICBcInJvemRhdFwiLFxuICAgIFwicm96ZXpuYXRcIixcbiAgICBcInJvemhvZGNlXCIsXG4gICAgXCJyb3ppbmthXCIsXG4gICAgXCJyb3pqZXpkXCIsXG4gICAgXCJyb3prYXpcIixcbiAgICBcInJvemxvaGFcIixcbiAgICBcInJvem1hclwiLFxuICAgIFwicm96cGFkXCIsXG4gICAgXCJyb3pydWNoXCIsXG4gICAgXCJyb3pzYWhcIixcbiAgICBcInJvenRva1wiLFxuICAgIFwicm96dW1cIixcbiAgICBcInJvenZvZFwiLFxuICAgIFwicnVicmlrYVwiLFxuICAgIFwicnVjaGFkbG9cIixcbiAgICBcInJ1a2F2aWNlXCIsXG4gICAgXCJydWtvcGlzXCIsXG4gICAgXCJyeWJhXCIsXG4gICAgXCJyeWJvbG92XCIsXG4gICAgXCJyeWNobG9zdFwiLFxuICAgIFwicnlkbG9cIixcbiAgICBcInJ5cGFkbG9cIixcbiAgICBcInJ5dGluYVwiLFxuICAgIFwicnl6b3N0XCIsXG4gICAgXCJzYWRpc3RhXCIsXG4gICAgXCJzYWhhdFwiLFxuICAgIFwic2Frb1wiLFxuICAgIFwic2FtZWNcIixcbiAgICBcInNhbWl6ZGF0XCIsXG4gICAgXCJzYW1vdGFcIixcbiAgICBcInNhbml0a2FcIixcbiAgICBcInNhcmRpbmthXCIsXG4gICAgXCJzYXNhbmthXCIsXG4gICAgXCJzYXRlbGl0XCIsXG4gICAgXCJzYXpiYVwiLFxuICAgIFwic2F6ZW5pY2VcIixcbiAgICBcInNib3JcIixcbiAgICBcInNjaG92YXRcIixcbiAgICBcInNlYnJhbmthXCIsXG4gICAgXCJzZWNlc2VcIixcbiAgICBcInNlZGFkbG9cIixcbiAgICBcInNlZGltZW50XCIsXG4gICAgXCJzZWRsb1wiLFxuICAgIFwic2VobmF0XCIsXG4gICAgXCJzZWptb3V0XCIsXG4gICAgXCJzZWtlcmFcIixcbiAgICBcInNla3RhXCIsXG4gICAgXCJzZWt1bmRhXCIsXG4gICAgXCJzZWt2b2plXCIsXG4gICAgXCJzZW1lbm9cIixcbiAgICBcInNlbm9cIixcbiAgICBcInNlcnZpc1wiLFxuICAgIFwic2VzYWRpdFwiLFxuICAgIFwic2VzaG9yYVwiLFxuICAgIFwic2Vza29rXCIsXG4gICAgXCJzZXNsYXRcIixcbiAgICBcInNlc3RyYVwiLFxuICAgIFwic2VzdXZcIixcbiAgICBcInNlc3lwYXRcIixcbiAgICBcInNldGJhXCIsXG4gICAgXCJzZXRpbmFcIixcbiAgICBcInNldGthdFwiLFxuICAgIFwic2V0bm91dFwiLFxuICAgIFwic2V0cnZhdFwiLFxuICAgIFwic2V2ZXJcIixcbiAgICBcInNlem5hbVwiLFxuICAgIFwic2hvZGFcIixcbiAgICBcInNocm5vdXRcIixcbiAgICBcInNpZm9uXCIsXG4gICAgXCJzaWxuaWNlXCIsXG4gICAgXCJzaXJrYVwiLFxuICAgIFwic2lyb3Rla1wiLFxuICAgIFwic2lydXBcIixcbiAgICBcInNpdHVhY2VcIixcbiAgICBcInNrYWZhbmRyXCIsXG4gICAgXCJza2FsaXNrb1wiLFxuICAgIFwic2thbnplblwiLFxuICAgIFwic2thdXRcIixcbiAgICBcInNrZXB0aWtcIixcbiAgICBcInNraWNhXCIsXG4gICAgXCJza2xhZGJhXCIsXG4gICAgXCJza2xlbmljZVwiLFxuICAgIFwic2tsb1wiLFxuICAgIFwic2tsdXpcIixcbiAgICBcInNrb2JhXCIsXG4gICAgXCJza29rYW5cIixcbiAgICBcInNrb3JvXCIsXG4gICAgXCJza3JpcHRhXCIsXG4gICAgXCJza3J6XCIsXG4gICAgXCJza3VwaW5hXCIsXG4gICAgXCJza3Zvc3RcIixcbiAgICBcInNrdnJuYVwiLFxuICAgIFwic2xhYmlrYVwiLFxuICAgIFwic2xhZGlkbG9cIixcbiAgICBcInNsYW5pbmFcIixcbiAgICBcInNsYXN0XCIsXG4gICAgXCJzbGF2bm9zdFwiLFxuICAgIFwic2xlZG92YXRcIixcbiAgICBcInNsZXBlY1wiLFxuICAgIFwic2xldmFcIixcbiAgICBcInNsZXppbmFcIixcbiAgICBcInNsaWJcIixcbiAgICBcInNsaW5hXCIsXG4gICAgXCJzbGl6bmljZVwiLFxuICAgIFwic2xvblwiLFxuICAgIFwic2xvdXBla1wiLFxuICAgIFwic2xvdm9cIixcbiAgICBcInNsdWNoXCIsXG4gICAgXCJzbHVoYVwiLFxuICAgIFwic2x1bmNlXCIsXG4gICAgXCJzbHVwa2FcIixcbiAgICBcInNsemFcIixcbiAgICBcInNtYXJhZ2RcIixcbiAgICBcInNtZXRhbmFcIixcbiAgICBcInNtaWxzdHZvXCIsXG4gICAgXCJzbWxvdXZhXCIsXG4gICAgXCJzbW9nXCIsXG4gICAgXCJzbXJhZFwiLFxuICAgIFwic21ya1wiLFxuICAgIFwic21ydGthXCIsXG4gICAgXCJzbXV0ZWtcIixcbiAgICBcInNteXNsXCIsXG4gICAgXCJzbmFkXCIsXG4gICAgXCJzbmFoYVwiLFxuICAgIFwic25vYlwiLFxuICAgIFwic29ib3RhXCIsXG4gICAgXCJzb2NoYVwiLFxuICAgIFwic29kb3ZrYVwiLFxuICAgIFwic29rb2xcIixcbiAgICBcInNvcGthXCIsXG4gICAgXCJzb3R2YVwiLFxuICAgIFwic291Ym9qXCIsXG4gICAgXCJzb3VjaXRcIixcbiAgICBcInNvdWRjZVwiLFxuICAgIFwic291aGxhc1wiLFxuICAgIFwic291bGFkXCIsXG4gICAgXCJzb3VtcmFrXCIsXG4gICAgXCJzb3VwcmF2YVwiLFxuICAgIFwic291c2VkXCIsXG4gICAgXCJzb3V0b2tcIixcbiAgICBcInNvdXZpc2V0XCIsXG4gICAgXCJzcGFsb3ZuYVwiLFxuICAgIFwic3Bhc2l0ZWxcIixcbiAgICBcInNwaXNcIixcbiAgICBcInNwbGF2XCIsXG4gICAgXCJzcG9kZWtcIixcbiAgICBcInNwb2plbmVjXCIsXG4gICAgXCJzcG9sdVwiLFxuICAgIFwic3BvbnpvclwiLFxuICAgIFwic3Bvcm5vc3RcIixcbiAgICBcInNwb3VzdGFcIixcbiAgICBcInNwcmNoYVwiLFxuICAgIFwic3B1c3RpdFwiLFxuICAgIFwic3JhbmRhXCIsXG4gICAgXCJzcmF6XCIsXG4gICAgXCJzcmRjZVwiLFxuICAgIFwic3JuYVwiLFxuICAgIFwic3JuZWNcIixcbiAgICBcInNyb3ZuYXRcIixcbiAgICBcInNycGVuXCIsXG4gICAgXCJzcnN0XCIsXG4gICAgXCJzcnViXCIsXG4gICAgXCJzdGFuaWNlXCIsXG4gICAgXCJzdGFyb3N0YVwiLFxuICAgIFwic3RhdGlrYVwiLFxuICAgIFwic3RhdmJhXCIsXG4gICAgXCJzdGVobm9cIixcbiAgICBcInN0ZXprYVwiLFxuICAgIFwic3RvZG9sYVwiLFxuICAgIFwic3RvbGVrXCIsXG4gICAgXCJzdG9wYVwiLFxuICAgIFwic3Rvcm5vXCIsXG4gICAgXCJzdG91cGF0XCIsXG4gICAgXCJzdHJhY2hcIixcbiAgICBcInN0cmVzXCIsXG4gICAgXCJzdHJobm91dFwiLFxuICAgIFwic3Ryb21cIixcbiAgICBcInN0cnVuYVwiLFxuICAgIFwic3R1ZG5hXCIsXG4gICAgXCJzdHVwbmljZVwiLFxuICAgIFwic3R2b2xcIixcbiAgICBcInN0eWtcIixcbiAgICBcInN1Ympla3RcIixcbiAgICBcInN1YnRyb3B5XCIsXG4gICAgXCJzdWNoYXJcIixcbiAgICBcInN1ZG9zdFwiLFxuICAgIFwic3Vrbm9cIixcbiAgICBcInN1bmRhdFwiLFxuICAgIFwic3Vub3V0XCIsXG4gICAgXCJzdXJpa2F0YVwiLFxuICAgIFwic3Vyb3ZpbmFcIixcbiAgICBcInN2YWhcIixcbiAgICBcInN2YWxzdHZvXCIsXG4gICAgXCJzdmV0clwiLFxuICAgIFwic3ZhdGJhXCIsXG4gICAgXCJzdmF6ZWtcIixcbiAgICBcInN2aXNsZVwiLFxuICAgIFwic3ZpdGVrXCIsXG4gICAgXCJzdm9ib2RhXCIsXG4gICAgXCJzdm9kaWRsb1wiLFxuICAgIFwic3ZvcmthXCIsXG4gICAgXCJzdnJhYlwiLFxuICAgIFwic3lrYXZrYVwiLFxuICAgIFwic3lrb3RcIixcbiAgICBcInN5bmVrXCIsXG4gICAgXCJzeW5vdmVjXCIsXG4gICAgXCJzeXBhdFwiLFxuICAgIFwic3lwa29zdFwiLFxuICAgIFwic3lyb3Zvc3RcIixcbiAgICBcInN5c2VsXCIsXG4gICAgXCJzeXRvc3RcIixcbiAgICBcInRhYmxldGthXCIsXG4gICAgXCJ0YWJ1bGVcIixcbiAgICBcInRhaG91blwiLFxuICAgIFwidGFqZW1ub1wiLFxuICAgIFwidGFqZnVuXCIsXG4gICAgXCJ0YWpnYVwiLFxuICAgIFwidGFqaXRcIixcbiAgICBcInRham5vc3RcIixcbiAgICBcInRha3Rpa2FcIixcbiAgICBcInRhbWhsZVwiLFxuICAgIFwidGFtcG9uXCIsXG4gICAgXCJ0YW5jb3ZhdFwiLFxuICAgIFwidGFuZWNcIixcbiAgICBcInRhbmtlclwiLFxuICAgIFwidGFwZXRhXCIsXG4gICAgXCJ0YXZlbmluYVwiLFxuICAgIFwidGF6YXRlbFwiLFxuICAgIFwidGVjaG5pa2FcIixcbiAgICBcInRlaGR5XCIsXG4gICAgXCJ0ZWt1dGluYVwiLFxuICAgIFwidGVsZWZvblwiLFxuICAgIFwidGVtbm90YVwiLFxuICAgIFwidGVuZGVuY2VcIixcbiAgICBcInRlbmlzdGFcIixcbiAgICBcInRlbm9yXCIsXG4gICAgXCJ0ZXBsb3RhXCIsXG4gICAgXCJ0ZXBuYVwiLFxuICAgIFwidGVwcnZlXCIsXG4gICAgXCJ0ZXJhcGllXCIsXG4gICAgXCJ0ZXJtb3NrYVwiLFxuICAgIFwidGV4dGlsXCIsXG4gICAgXCJ0aWNob1wiLFxuICAgIFwidGlza29waXNcIixcbiAgICBcInRpdHVsZWtcIixcbiAgICBcInRrYWRsZWNcIixcbiAgICBcInRrYW5pbmFcIixcbiAgICBcInRsYXBrYVwiLFxuICAgIFwidGxlc2thdFwiLFxuICAgIFwidGx1a290XCIsXG4gICAgXCJ0bHVwYVwiLFxuICAgIFwidG1lbFwiLFxuICAgIFwidG9hbGV0YVwiLFxuICAgIFwidG9waW5rYVwiLFxuICAgIFwidG9wb2xcIixcbiAgICBcInRvcnpvXCIsXG4gICAgXCJ0b3VoYVwiLFxuICAgIFwidG91bGVjXCIsXG4gICAgXCJ0cmFkaWNlXCIsXG4gICAgXCJ0cmFrdG9yXCIsXG4gICAgXCJ0cmFtcFwiLFxuICAgIFwidHJhc2FcIixcbiAgICBcInRyYXZlcnphXCIsXG4gICAgXCJ0cmVmaXRcIixcbiAgICBcInRyZXN0XCIsXG4gICAgXCJ0cmV6b3JcIixcbiAgICBcInRyaGF2aW5hXCIsXG4gICAgXCJ0cmhsaW5hXCIsXG4gICAgXCJ0cm9jaHVcIixcbiAgICBcInRyb2ppY2VcIixcbiAgICBcInRyb3NrYVwiLFxuICAgIFwidHJvdWJhXCIsXG4gICAgXCJ0cnBjZVwiLFxuICAgIFwidHJwaXRlbFwiLFxuICAgIFwidHJwa29zdFwiLFxuICAgIFwidHJ1YmVjXCIsXG4gICAgXCJ0cnVjaGxpdFwiLFxuICAgIFwidHJ1aGxpY2VcIixcbiAgICBcInRydXNcIixcbiAgICBcInRydmF0XCIsXG4gICAgXCJ0dWR5XCIsXG4gICAgXCJ0dWhub3V0XCIsXG4gICAgXCJ0dWhvc3RcIixcbiAgICBcInR1bmRyYVwiLFxuICAgIFwidHVyaXN0YVwiLFxuICAgIFwidHVybmFqXCIsXG4gICAgXCJ0dXplbXNrb1wiLFxuICAgIFwidHZhcm9oXCIsXG4gICAgXCJ0dm9yYmFcIixcbiAgICBcInR2cmRvc3RcIixcbiAgICBcInR2cnpcIixcbiAgICBcInR5Z3JcIixcbiAgICBcInR5a2V2XCIsXG4gICAgXCJ1Ym9ob3N0XCIsXG4gICAgXCJ1Ym96ZVwiLFxuICAgIFwidWJyYXRcIixcbiAgICBcInVicm91c2VrXCIsXG4gICAgXCJ1YnJ1c1wiLFxuICAgIFwidWJ5dG92bmFcIixcbiAgICBcInVjaG9cIixcbiAgICBcInVjdGl2b3N0XCIsXG4gICAgXCJ1ZGl2aXRcIixcbiAgICBcInVocmFkaXRcIixcbiAgICBcInVqZWRuYXRcIixcbiAgICBcInVqaXN0aXRcIixcbiAgICBcInVqbW91dFwiLFxuICAgIFwidWthemF0ZWxcIixcbiAgICBcInVrbGlkbml0XCIsXG4gICAgXCJ1a2xvbml0XCIsXG4gICAgXCJ1a290dml0XCIsXG4gICAgXCJ1a3Jvaml0XCIsXG4gICAgXCJ1bGljZVwiLFxuICAgIFwidWxpdGFcIixcbiAgICBcInVsb3ZpdFwiLFxuICAgIFwidW15dmFkbG9cIixcbiAgICBcInVuYXZpdFwiLFxuICAgIFwidW5pZm9ybWFcIixcbiAgICBcInVuaWtub3V0XCIsXG4gICAgXCJ1cGFkbm91dFwiLFxuICAgIFwidXBsYXRuaXRcIixcbiAgICBcInVwbHlub3V0XCIsXG4gICAgXCJ1cG91dGF0XCIsXG4gICAgXCJ1cHJhdml0XCIsXG4gICAgXCJ1cmFuXCIsXG4gICAgXCJ1cmF6aXRcIixcbiAgICBcInVzZWRub3V0XCIsXG4gICAgXCJ1c2lsb3ZhdFwiLFxuICAgIFwidXNtcnRpdFwiLFxuICAgIFwidXNuYWRuaXRcIixcbiAgICBcInVzbm91dFwiLFxuICAgIFwidXNvdWRpdFwiLFxuICAgIFwidXN0bGF0XCIsXG4gICAgXCJ1c3Rybm91dFwiLFxuICAgIFwidXRhaG92YXRcIixcbiAgICBcInV0a2F0XCIsXG4gICAgXCJ1dGx1bWl0XCIsXG4gICAgXCJ1dG9ub3V0XCIsXG4gICAgXCJ1dG9wZW5lY1wiLFxuICAgIFwidXRyb3VzaXRcIixcbiAgICBcInV2YWxpdFwiLFxuICAgIFwidXZvbG5pdFwiLFxuICAgIFwidXZvem92a2FcIixcbiAgICBcInV6ZHJhdml0XCIsXG4gICAgXCJ1emVsXCIsXG4gICAgXCJ1emVuaW5hXCIsXG4gICAgXCJ1emxpbmFcIixcbiAgICBcInV6bmF0XCIsXG4gICAgXCJ2YWdvblwiLFxuICAgIFwidmFsY2hhXCIsXG4gICAgXCJ2YWxvdW5cIixcbiAgICBcInZhbmFcIixcbiAgICBcInZhbmRhbFwiLFxuICAgIFwidmFuaWxrYVwiLFxuICAgIFwidmFyYW5cIixcbiAgICBcInZhcmhhbnlcIixcbiAgICBcInZhcm92YXRcIixcbiAgICBcInZjZWxrdVwiLFxuICAgIFwidmNob2RcIixcbiAgICBcInZkb3ZhXCIsXG4gICAgXCJ2ZWRyb1wiLFxuICAgIFwidmVnZXRhY2VcIixcbiAgICBcInZlamNlXCIsXG4gICAgXCJ2ZWxibG91ZFwiLFxuICAgIFwidmVsZXRyaFwiLFxuICAgIFwidmVsaXRlbFwiLFxuICAgIFwidmVsbW9jXCIsXG4gICAgXCJ2ZWxyeWJhXCIsXG4gICAgXCJ2ZW5rb3ZcIixcbiAgICBcInZlcmFuZGFcIixcbiAgICBcInZlcnplXCIsXG4gICAgXCJ2ZXNlbGthXCIsXG4gICAgXCJ2ZXNrcnplXCIsXG4gICAgXCJ2ZXNuaWNlXCIsXG4gICAgXCJ2ZXNwb2R1XCIsXG4gICAgXCJ2ZXN0YVwiLFxuICAgIFwidmV0ZXJpbmFcIixcbiAgICBcInZldmVya2FcIixcbiAgICBcInZpYnJhY2VcIixcbiAgICBcInZpY2hyXCIsXG4gICAgXCJ2aWRlb2hyYVwiLFxuICAgIFwidmlkaW5hXCIsXG4gICAgXCJ2aWRsZVwiLFxuICAgIFwidmlsYVwiLFxuICAgIFwidmluaWNlXCIsXG4gICAgXCJ2aXNldFwiLFxuICAgIFwidml0YWxpdGFcIixcbiAgICBcInZpemVcIixcbiAgICBcInZpeml0a2FcIixcbiAgICBcInZqZXpkXCIsXG4gICAgXCJ2a2xhZFwiLFxuICAgIFwidmt1c1wiLFxuICAgIFwidmxhamthXCIsXG4gICAgXCJ2bGFrXCIsXG4gICAgXCJ2bGFzZWNcIixcbiAgICBcInZsZXZvXCIsXG4gICAgXCJ2bGhrb3N0XCIsXG4gICAgXCJ2bGl2XCIsXG4gICAgXCJ2bG5vdmthXCIsXG4gICAgXCJ2bG91cGF0XCIsXG4gICAgXCJ2bnVjb3ZhdFwiLFxuICAgIFwidm51a1wiLFxuICAgIFwidm9kYVwiLFxuICAgIFwidm9kaXZvc3RcIixcbiAgICBcInZvZG96bmFrXCIsXG4gICAgXCJ2b2RzdHZvXCIsXG4gICAgXCJ2b2plbnNreVwiLFxuICAgIFwidm9qbmFcIixcbiAgICBcInZvanNrb1wiLFxuICAgIFwidm9sYW50XCIsXG4gICAgXCJ2b2xiYVwiLFxuICAgIFwidm9saXRcIixcbiAgICBcInZvbG5vXCIsXG4gICAgXCJ2b3Nrb3ZrYVwiLFxuICAgIFwidm96aWRsb1wiLFxuICAgIFwidm96b3ZuYVwiLFxuICAgIFwidnByYXZvXCIsXG4gICAgXCJ2cmFiZWNcIixcbiAgICBcInZyYWNldFwiLFxuICAgIFwidnJhaFwiLFxuICAgIFwidnJhdGFcIixcbiAgICBcInZyYmFcIixcbiAgICBcInZyY2hvbGVrXCIsXG4gICAgXCJ2cmhhdFwiLFxuICAgIFwidnJzdHZhXCIsXG4gICAgXCJ2cnR1bGVcIixcbiAgICBcInZzYWRpdFwiLFxuICAgIFwidnN0b3VwaXRcIixcbiAgICBcInZzdHVwXCIsXG4gICAgXCJ2dGlwXCIsXG4gICAgXCJ2eWJhdml0XCIsXG4gICAgXCJ2eWJyYXRcIixcbiAgICBcInZ5Y2hvdmF0XCIsXG4gICAgXCJ2eWRhdFwiLFxuICAgIFwidnlkcmFcIixcbiAgICBcInZ5Zm90aXRcIixcbiAgICBcInZ5aGxlZGF0XCIsXG4gICAgXCJ2eWhub3V0XCIsXG4gICAgXCJ2eWhvZGl0XCIsXG4gICAgXCJ2eWhyYWRpdFwiLFxuICAgIFwidnlodWJpdFwiLFxuICAgIFwidnlqYXNuaXRcIixcbiAgICBcInZ5amV0XCIsXG4gICAgXCJ2eWptb3V0XCIsXG4gICAgXCJ2eWtsb3BpdFwiLFxuICAgIFwidnlrb25hdFwiLFxuICAgIFwidnlsZWthdFwiLFxuICAgIFwidnltYXphdFwiLFxuICAgIFwidnltZXppdFwiLFxuICAgIFwidnltaXpldFwiLFxuICAgIFwidnlteXNsZXRcIixcbiAgICBcInZ5bmVjaGF0XCIsXG4gICAgXCJ2eW5pa2F0XCIsXG4gICAgXCJ2eW51dGl0XCIsXG4gICAgXCJ2eXBhZGF0XCIsXG4gICAgXCJ2eXBsYXRpdFwiLFxuICAgIFwidnlwcmF2aXRcIixcbiAgICBcInZ5cHVzdGl0XCIsXG4gICAgXCJ2eXJheml0XCIsXG4gICAgXCJ2eXJvdm5hdFwiLFxuICAgIFwidnlydmF0XCIsXG4gICAgXCJ2eXNsb3ZpdFwiLFxuICAgIFwidnlzb2tvXCIsXG4gICAgXCJ2eXN0YXZpdFwiLFxuICAgIFwidnlzdW5vdXRcIixcbiAgICBcInZ5c3lwYXRcIixcbiAgICBcInZ5dGFzaXRcIixcbiAgICBcInZ5dGVzYXRcIixcbiAgICBcInZ5dHJhdGl0XCIsXG4gICAgXCJ2eXZpbm91dFwiLFxuICAgIFwidnl2b2xhdFwiLFxuICAgIFwidnl2cmhlbFwiLFxuICAgIFwidnl6ZG9iaXRcIixcbiAgICBcInZ5em5hdFwiLFxuICAgIFwidnphZHVcIixcbiAgICBcInZ6YnVkaXRcIixcbiAgICBcInZ6Y2hvcGl0XCIsXG4gICAgXCJ2emRvclwiLFxuICAgIFwidnpkdWNoXCIsXG4gICAgXCJ2emR5Y2hhdFwiLFxuICAgIFwidnplc3R1cFwiLFxuICAgIFwidnpobGVkZW1cIixcbiAgICBcInZ6a2F6XCIsXG4gICAgXCJ2emx5a2F0XCIsXG4gICAgXCJ2em5pa1wiLFxuICAgIFwidnpvcmVrXCIsXG4gICAgXCJ2enBvdXJhXCIsXG4gICAgXCJ2enRhaFwiLFxuICAgIFwidnp0ZWtcIixcbiAgICBcInh5bG9mb25cIixcbiAgICBcInphYnJhdFwiLFxuICAgIFwiemFieWRsZXRcIixcbiAgICBcInphY2hvdmF0XCIsXG4gICAgXCJ6YWRhcm1vXCIsXG4gICAgXCJ6YWR1c2l0XCIsXG4gICAgXCJ6YWZvdWthdFwiLFxuICAgIFwiemFobHRpdFwiLFxuICAgIFwiemFob2RpdFwiLFxuICAgIFwiemFocmFkYVwiLFxuICAgIFwiemFoeW5vdXRcIixcbiAgICBcInphamF0ZWNcIixcbiAgICBcInphamV0XCIsXG4gICAgXCJ6YWppc3RpdFwiLFxuICAgIFwiemFrbGVwYXRcIixcbiAgICBcInpha291cGl0XCIsXG4gICAgXCJ6YWxlcGl0XCIsXG4gICAgXCJ6YW1leml0XCIsXG4gICAgXCJ6YW1vdGF0XCIsXG4gICAgXCJ6YW15c2xldFwiLFxuICAgIFwiemFuZWNoYXRcIixcbiAgICBcInphbmlrYXRcIixcbiAgICBcInphcGxhdGl0XCIsXG4gICAgXCJ6YXBvaml0XCIsXG4gICAgXCJ6YXBzYXRcIixcbiAgICBcInphcmF6aXRcIixcbiAgICBcInphc3Rhdml0XCIsXG4gICAgXCJ6YXN1bm91dFwiLFxuICAgIFwiemF0YWppdFwiLFxuICAgIFwiemF0ZW1uaXRcIixcbiAgICBcInphdGtub3V0XCIsXG4gICAgXCJ6YXVqbW91dFwiLFxuICAgIFwiemF2YWxpdFwiLFxuICAgIFwiemF2ZWxldFwiLFxuICAgIFwiemF2aW5pdFwiLFxuICAgIFwiemF2b2xhdFwiLFxuICAgIFwiemF2cnRhdFwiLFxuICAgIFwiemF6dm9uaXRcIixcbiAgICBcInpiYXZpdFwiLFxuICAgIFwiemJydXN1XCIsXG4gICAgXCJ6YnVkb3ZhdFwiLFxuICAgIFwiemJ5dGVrXCIsXG4gICAgXCJ6ZGFsZWthXCIsXG4gICAgXCJ6ZGFybWFcIixcbiAgICBcInpkYXRub3N0XCIsXG4gICAgXCJ6ZGl2b1wiLFxuICAgIFwiemRvYml0XCIsXG4gICAgXCJ6ZHJvalwiLFxuICAgIFwiemR2aWhcIixcbiAgICBcInpkeW1hZGxvXCIsXG4gICAgXCJ6ZWxlbmluYVwiLFxuICAgIFwiemVtYW5cIixcbiAgICBcInplbWluYVwiLFxuICAgIFwiemVwdGF0XCIsXG4gICAgXCJ6ZXphZHVcIixcbiAgICBcInplemRvbGFcIixcbiAgICBcInpoYXRpdFwiLFxuICAgIFwiemhsdG5vdXRcIixcbiAgICBcInpobHVib2thXCIsXG4gICAgXCJ6aG90b3ZpdFwiLFxuICAgIFwiemhydWJhXCIsXG4gICAgXCJ6aW1hXCIsXG4gICAgXCJ6aW1uaWNlXCIsXG4gICAgXCJ6amVtbml0XCIsXG4gICAgXCJ6a2xhbWF0XCIsXG4gICAgXCJ6a291bWF0XCIsXG4gICAgXCJ6a3JhdGthXCIsXG4gICAgXCJ6a3VtYXZrYVwiLFxuICAgIFwiemxhdG9cIixcbiAgICBcInpsZWhrYVwiLFxuICAgIFwiemxvYmFcIixcbiAgICBcInpsb21cIixcbiAgICBcInpsb3N0XCIsXG4gICAgXCJ6bG96dnlrXCIsXG4gICAgXCJ6bWFwb3ZhdFwiLFxuICAgIFwiem1hclwiLFxuICAgIFwiem1hdGVrXCIsXG4gICAgXCJ6bWlqZVwiLFxuICAgIFwiem1pemV0XCIsXG4gICAgXCJ6bW9jbml0XCIsXG4gICAgXCJ6bW9kcmF0XCIsXG4gICAgXCJ6bXJ6bGluYVwiLFxuICAgIFwiem11dG92YXRcIixcbiAgICBcInpuYWtcIixcbiAgICBcInpuYWxvc3RcIixcbiAgICBcInpuYW1lbmF0XCIsXG4gICAgXCJ6bm92dVwiLFxuICAgIFwiem9icmF6aXRcIixcbiAgICBcInpvdGF2aXRcIixcbiAgICBcInpvdWJla1wiLFxuICAgIFwiem91ZmFsZVwiLFxuICAgIFwienBsb2RpdFwiLFxuICAgIFwienBvbWFsaXRcIixcbiAgICBcInpwcmF2YVwiLFxuICAgIFwienByb3N0aXRcIixcbiAgICBcInpwcnVka2FcIixcbiAgICBcInpwcnZ1XCIsXG4gICAgXCJ6cmFkYVwiLFxuICAgIFwienJhbml0XCIsXG4gICAgXCJ6cmNhZGxvXCIsXG4gICAgXCJ6cm5pdG9zdFwiLFxuICAgIFwienJub1wiLFxuICAgIFwienJvdm5hXCIsXG4gICAgXCJ6cnljaGxpdFwiLFxuICAgIFwienJ6YXZvc3RcIixcbiAgICBcInp0aWNoYVwiLFxuICAgIFwienRyYXRpdFwiLFxuICAgIFwienVib3ZpbmFcIixcbiAgICBcInp1YnJcIixcbiAgICBcInp2ZWRub3V0XCIsXG4gICAgXCJ6dmVua3VcIixcbiAgICBcInp2ZXNlbGFcIixcbiAgICBcInp2b25cIixcbiAgICBcInp2cmF0XCIsXG4gICAgXCJ6dnVrb3ZvZFwiLFxuICAgIFwienZ5a1wiXG5dXG4iLCJtb2R1bGUuZXhwb3J0cz1bXG4gICAgXCJhYmFjb1wiLFxuICAgIFwiYWJiYWdsaW9cIixcbiAgICBcImFiYmluYXRvXCIsXG4gICAgXCJhYmV0ZVwiLFxuICAgIFwiYWJpc3NvXCIsXG4gICAgXCJhYm9saXJlXCIsXG4gICAgXCJhYnJhc2l2b1wiLFxuICAgIFwiYWJyb2dhdG9cIixcbiAgICBcImFjY2FkZXJlXCIsXG4gICAgXCJhY2Nlbm5vXCIsXG4gICAgXCJhY2N1c2F0b1wiLFxuICAgIFwiYWNldG9uZVwiLFxuICAgIFwiYWNoaWxsZVwiLFxuICAgIFwiYWNpZG9cIixcbiAgICBcImFjcXVhXCIsXG4gICAgXCJhY3JlXCIsXG4gICAgXCJhY3JpbGljb1wiLFxuICAgIFwiYWNyb2JhdGFcIixcbiAgICBcImFjdXRvXCIsXG4gICAgXCJhZGFnaW9cIixcbiAgICBcImFkZGViaXRvXCIsXG4gICAgXCJhZGRvbWVcIixcbiAgICBcImFkZWd1YXRvXCIsXG4gICAgXCJhZGVyaXJlXCIsXG4gICAgXCJhZGlwZVwiLFxuICAgIFwiYWRvdHRhcmVcIixcbiAgICBcImFkdWxhcmVcIixcbiAgICBcImFmZmFiaWxlXCIsXG4gICAgXCJhZmZldHRvXCIsXG4gICAgXCJhZmZpc3NvXCIsXG4gICAgXCJhZmZyYW50b1wiLFxuICAgIFwiYWZvcmlzbWFcIixcbiAgICBcImFmb3NvXCIsXG4gICAgXCJhZnJpY2Fub1wiLFxuICAgIFwiYWdhdmVcIixcbiAgICBcImFnZW50ZVwiLFxuICAgIFwiYWdldm9sZVwiLFxuICAgIFwiYWdnYW5jaW9cIixcbiAgICBcImFnaXJlXCIsXG4gICAgXCJhZ2l0YXJlXCIsXG4gICAgXCJhZ29uaXNtb1wiLFxuICAgIFwiYWdyaWNvbG9cIixcbiAgICBcImFncnVtZXRvXCIsXG4gICAgXCJhZ3V6em9cIixcbiAgICBcImFsYWJhcmRhXCIsXG4gICAgXCJhbGF0b1wiLFxuICAgIFwiYWxiYXRyb1wiLFxuICAgIFwiYWxiZXJhdG9cIixcbiAgICBcImFsYm9cIixcbiAgICBcImFsYnVtZVwiLFxuICAgIFwiYWxjZVwiLFxuICAgIFwiYWxjb2xpY29cIixcbiAgICBcImFsZXR0b25lXCIsXG4gICAgXCJhbGZhXCIsXG4gICAgXCJhbGdlYnJhXCIsXG4gICAgXCJhbGlhbnRlXCIsXG4gICAgXCJhbGliaVwiLFxuICAgIFwiYWxpbWVudG9cIixcbiAgICBcImFsbGFnYXRvXCIsXG4gICAgXCJhbGxlZ3JvXCIsXG4gICAgXCJhbGxpZXZvXCIsXG4gICAgXCJhbGxvZG9sYVwiLFxuICAgIFwiYWxsdXNpdm9cIixcbiAgICBcImFsbWVub1wiLFxuICAgIFwiYWxvZ2Vub1wiLFxuICAgIFwiYWxwYWNhXCIsXG4gICAgXCJhbHBlc3RyZVwiLFxuICAgIFwiYWx0YWxlbmFcIixcbiAgICBcImFsdGVybm9cIixcbiAgICBcImFsdGljY2lvXCIsXG4gICAgXCJhbHRyb3ZlXCIsXG4gICAgXCJhbHVubm9cIixcbiAgICBcImFsdmVvbG9cIixcbiAgICBcImFsemFyZVwiLFxuICAgIFwiYW1hbGdhbWFcIixcbiAgICBcImFtYW5pdGFcIixcbiAgICBcImFtYXJlbmFcIixcbiAgICBcImFtYml0b1wiLFxuICAgIFwiYW1icmF0b1wiLFxuICAgIFwiYW1lYmFcIixcbiAgICBcImFtZXJpY2FcIixcbiAgICBcImFtZXRpc3RhXCIsXG4gICAgXCJhbWljb1wiLFxuICAgIFwiYW1tYXNzb1wiLFxuICAgIFwiYW1tZW5kYVwiLFxuICAgIFwiYW1taXJhcmVcIixcbiAgICBcImFtbW9uaXRvXCIsXG4gICAgXCJhbW9yZVwiLFxuICAgIFwiYW1waW9cIixcbiAgICBcImFtcGxpYXJlXCIsXG4gICAgXCJhbXVsZXRvXCIsXG4gICAgXCJhbmFjYXJkb1wiLFxuICAgIFwiYW5hZ3JhZmVcIixcbiAgICBcImFuYWxpc3RhXCIsXG4gICAgXCJhbmFyY2hpYVwiLFxuICAgIFwiYW5hdHJhXCIsXG4gICAgXCJhbmNhXCIsXG4gICAgXCJhbmNlbGxhXCIsXG4gICAgXCJhbmNvcmFcIixcbiAgICBcImFuZGFyZVwiLFxuICAgIFwiYW5kcmVhXCIsXG4gICAgXCJhbmVsbG9cIixcbiAgICBcImFuZ2Vsb1wiLFxuICAgIFwiYW5nb2xhcmVcIixcbiAgICBcImFuZ3VzdG9cIixcbiAgICBcImFuaW1hXCIsXG4gICAgXCJhbm5lZ2FyZVwiLFxuICAgIFwiYW5uaWRhdG9cIixcbiAgICBcImFubm9cIixcbiAgICBcImFubnVuY2lvXCIsXG4gICAgXCJhbm9uaW1vXCIsXG4gICAgXCJhbnRpY2lwb1wiLFxuICAgIFwiYW56aVwiLFxuICAgIFwiYXBhdGljb1wiLFxuICAgIFwiYXBlcnR1cmFcIixcbiAgICBcImFwb2RlXCIsXG4gICAgXCJhcHBhcmlyZVwiLFxuICAgIFwiYXBwZXRpdG9cIixcbiAgICBcImFwcG9nZ2lvXCIsXG4gICAgXCJhcHByb2RvXCIsXG4gICAgXCJhcHB1bnRvXCIsXG4gICAgXCJhcHJpbGVcIixcbiAgICBcImFyYWJpY2FcIixcbiAgICBcImFyYWNoaWRlXCIsXG4gICAgXCJhcmFnb3N0YVwiLFxuICAgIFwiYXJhbGRpY2FcIixcbiAgICBcImFyYW5jaW9cIixcbiAgICBcImFyYXR1cmFcIixcbiAgICBcImFyYXp6b1wiLFxuICAgIFwiYXJiaXRyb1wiLFxuICAgIFwiYXJjaGl2aW9cIixcbiAgICBcImFyZGl0b1wiLFxuICAgIFwiYXJlbmlsZVwiLFxuICAgIFwiYXJnZW50b1wiLFxuICAgIFwiYXJnaW5lXCIsXG4gICAgXCJhcmd1dG9cIixcbiAgICBcImFyaWFcIixcbiAgICBcImFybW9uaWFcIixcbiAgICBcImFybmVzZVwiLFxuICAgIFwiYXJyZWRhdG9cIixcbiAgICBcImFycmluZ2FcIixcbiAgICBcImFycm9zdG9cIixcbiAgICBcImFyc2VuaWNvXCIsXG4gICAgXCJhcnNvXCIsXG4gICAgXCJhcnRlZmljZVwiLFxuICAgIFwiYXJ6aWxsb1wiLFxuICAgIFwiYXNjaXV0dG9cIixcbiAgICBcImFzY29sdG9cIixcbiAgICBcImFzZXBzaVwiLFxuICAgIFwiYXNldHRpY29cIixcbiAgICBcImFzZmFsdG9cIixcbiAgICBcImFzaW5vXCIsXG4gICAgXCJhc29sYVwiLFxuICAgIFwiYXNwaXJhdG9cIixcbiAgICBcImFzcHJvXCIsXG4gICAgXCJhc3NhZ2dpb1wiLFxuICAgIFwiYXNzZVwiLFxuICAgIFwiYXNzb2x1dG9cIixcbiAgICBcImFzc3VyZG9cIixcbiAgICBcImFzdGFcIixcbiAgICBcImFzdGVudXRvXCIsXG4gICAgXCJhc3RpY2VcIixcbiAgICBcImFzdHJhdHRvXCIsXG4gICAgXCJhdGF2aWNvXCIsXG4gICAgXCJhdGVpc21vXCIsXG4gICAgXCJhdG9taWNvXCIsXG4gICAgXCJhdG9ub1wiLFxuICAgIFwiYXR0ZXNhXCIsXG4gICAgXCJhdHRpdmFyZVwiLFxuICAgIFwiYXR0b3Jub1wiLFxuICAgIFwiYXR0cml0b1wiLFxuICAgIFwiYXR0dWFsZVwiLFxuICAgIFwiYXVzaWxpb1wiLFxuICAgIFwiYXVzdHJpYVwiLFxuICAgIFwiYXV0aXN0YVwiLFxuICAgIFwiYXV0b25vbW9cIixcbiAgICBcImF1dHVubm9cIixcbiAgICBcImF2YW56YXRvXCIsXG4gICAgXCJhdmVyZVwiLFxuICAgIFwiYXZ2ZW5pcmVcIixcbiAgICBcImF2dmlzb1wiLFxuICAgIFwiYXZ2b2xnZXJlXCIsXG4gICAgXCJhemlvbmVcIixcbiAgICBcImF6b3RvXCIsXG4gICAgXCJhenppbW9cIixcbiAgICBcImF6enVycm9cIixcbiAgICBcImJhYmVsZVwiLFxuICAgIFwiYmFjY2Fub1wiLFxuICAgIFwiYmFjaW5vXCIsXG4gICAgXCJiYWNvXCIsXG4gICAgXCJiYWRlc3NhXCIsXG4gICAgXCJiYWRpbGF0YVwiLFxuICAgIFwiYmFnbmF0b1wiLFxuICAgIFwiYmFpdGFcIixcbiAgICBcImJhbGNvbmVcIixcbiAgICBcImJhbGRvXCIsXG4gICAgXCJiYWxlbmFcIixcbiAgICBcImJhbGxhdGFcIixcbiAgICBcImJhbHphbm9cIixcbiAgICBcImJhbWJpbm9cIixcbiAgICBcImJhbmRpcmVcIixcbiAgICBcImJhcmFvbmRhXCIsXG4gICAgXCJiYXJiYXJvXCIsXG4gICAgXCJiYXJjYVwiLFxuICAgIFwiYmFyaXRvbm9cIixcbiAgICBcImJhcmx1bWVcIixcbiAgICBcImJhcm9jY29cIixcbiAgICBcImJhc2lsaWNvXCIsXG4gICAgXCJiYXNzb1wiLFxuICAgIFwiYmF0b3N0YVwiLFxuICAgIFwiYmF0dHV0b1wiLFxuICAgIFwiYmF1bGVcIixcbiAgICBcImJhdmFcIixcbiAgICBcImJhdm9zYVwiLFxuICAgIFwiYmVjY29cIixcbiAgICBcImJlZmZhXCIsXG4gICAgXCJiZWxnaW9cIixcbiAgICBcImJlbHZhXCIsXG4gICAgXCJiZW5kYVwiLFxuICAgIFwiYmVuZXZvbGVcIixcbiAgICBcImJlbmlnbm9cIixcbiAgICBcImJlbnppbmFcIixcbiAgICBcImJlcmVcIixcbiAgICBcImJlcmxpbmFcIixcbiAgICBcImJldGFcIixcbiAgICBcImJpYml0YVwiLFxuICAgIFwiYmljaVwiLFxuICAgIFwiYmlkb25lXCIsXG4gICAgXCJiaWZpZG9cIixcbiAgICBcImJpZ2FcIixcbiAgICBcImJpbGFuY2lhXCIsXG4gICAgXCJiaW1ib1wiLFxuICAgIFwiYmlub2NvbG9cIixcbiAgICBcImJpb2xvZ29cIixcbiAgICBcImJpcGVkZVwiLFxuICAgIFwiYmlwb2xhcmVcIixcbiAgICBcImJpcmJhbnRlXCIsXG4gICAgXCJiaXJyYVwiLFxuICAgIFwiYmlzY290dG9cIixcbiAgICBcImJpc2VzdG9cIixcbiAgICBcImJpc25vbm5vXCIsXG4gICAgXCJiaXNvbnRlXCIsXG4gICAgXCJiaXN0dXJpXCIsXG4gICAgXCJiaXp6YXJyb1wiLFxuICAgIFwiYmxhbmRvXCIsXG4gICAgXCJibGF0dGFcIixcbiAgICBcImJvbGxpdG9cIixcbiAgICBcImJvbmlmaWNvXCIsXG4gICAgXCJib3Jkb1wiLFxuICAgIFwiYm9zY29cIixcbiAgICBcImJvdGFuaWNvXCIsXG4gICAgXCJib3R0aW5vXCIsXG4gICAgXCJib3p6b2xvXCIsXG4gICAgXCJicmFjY2lvXCIsXG4gICAgXCJicmFkaXBvXCIsXG4gICAgXCJicmFtYVwiLFxuICAgIFwiYnJhbmNhXCIsXG4gICAgXCJicmF2dXJhXCIsXG4gICAgXCJicmV0ZWxsYVwiLFxuICAgIFwiYnJldmV0dG9cIixcbiAgICBcImJyZXp6YVwiLFxuICAgIFwiYnJpZ2xpYVwiLFxuICAgIFwiYnJpbGxhbnRlXCIsXG4gICAgXCJicmluZGFyZVwiLFxuICAgIFwiYnJvY2NvbG9cIixcbiAgICBcImJyb2RvXCIsXG4gICAgXCJicm9uemluYVwiLFxuICAgIFwiYnJ1bGxvXCIsXG4gICAgXCJicnVub1wiLFxuICAgIFwiYnViYm9uZVwiLFxuICAgIFwiYnVjYVwiLFxuICAgIFwiYnVkaW5vXCIsXG4gICAgXCJidWZmb25lXCIsXG4gICAgXCJidWlvXCIsXG4gICAgXCJidWxib1wiLFxuICAgIFwiYnVvbm9cIixcbiAgICBcImJ1cmxvbmVcIixcbiAgICBcImJ1cnJhc2NhXCIsXG4gICAgXCJidXNzb2xhXCIsXG4gICAgXCJidXN0YVwiLFxuICAgIFwiY2FkZXR0b1wiLFxuICAgIFwiY2FkdWNvXCIsXG4gICAgXCJjYWxhbWFyb1wiLFxuICAgIFwiY2FsY29sb1wiLFxuICAgIFwiY2FsZXNzZVwiLFxuICAgIFwiY2FsaWJyb1wiLFxuICAgIFwiY2FsbW9cIixcbiAgICBcImNhbG9yaWFcIixcbiAgICBcImNhbWJ1c2FcIixcbiAgICBcImNhbWVyYXRhXCIsXG4gICAgXCJjYW1pY2lhXCIsXG4gICAgXCJjYW1taW5vXCIsXG4gICAgXCJjYW1vbGFcIixcbiAgICBcImNhbXBhbGVcIixcbiAgICBcImNhbmFwYVwiLFxuICAgIFwiY2FuZGVsYVwiLFxuICAgIFwiY2FuZVwiLFxuICAgIFwiY2FuaW5vXCIsXG4gICAgXCJjYW5vdHRvXCIsXG4gICAgXCJjYW50aW5hXCIsXG4gICAgXCJjYXBhY2VcIixcbiAgICBcImNhcGVsbG9cIixcbiAgICBcImNhcGl0b2xvXCIsXG4gICAgXCJjYXBvZ2lyb1wiLFxuICAgIFwiY2FwcGVyb1wiLFxuICAgIFwiY2FwcmFcIixcbiAgICBcImNhcHN1bGFcIixcbiAgICBcImNhcmFwYWNlXCIsXG4gICAgXCJjYXJjYXNzYVwiLFxuICAgIFwiY2FyZG9cIixcbiAgICBcImNhcmlzbWFcIixcbiAgICBcImNhcm92YW5hXCIsXG4gICAgXCJjYXJyZXR0b1wiLFxuICAgIFwiY2FydG9saW5hXCIsXG4gICAgXCJjYXNhY2Npb1wiLFxuICAgIFwiY2FzY2F0YVwiLFxuICAgIFwiY2FzZXJtYVwiLFxuICAgIFwiY2Fzb1wiLFxuICAgIFwiY2Fzc29uZVwiLFxuICAgIFwiY2FzdGVsbG9cIixcbiAgICBcImNhc3VhbGVcIixcbiAgICBcImNhdGFzdGFcIixcbiAgICBcImNhdGVuYVwiLFxuICAgIFwiY2F0cmFtZVwiLFxuICAgIFwiY2F1dG9cIixcbiAgICBcImNhdmlsbG9cIixcbiAgICBcImNlZGliaWxlXCIsXG4gICAgXCJjZWRyYXRhXCIsXG4gICAgXCJjZWZhbG9cIixcbiAgICBcImNlbGVicmVcIixcbiAgICBcImNlbGx1bGFyZVwiLFxuICAgIFwiY2VuYVwiLFxuICAgIFwiY2Vub25lXCIsXG4gICAgXCJjZW50ZXNpbW9cIixcbiAgICBcImNlcmFtaWNhXCIsXG4gICAgXCJjZXJjYXJlXCIsXG4gICAgXCJjZXJ0b1wiLFxuICAgIFwiY2VydW1lXCIsXG4gICAgXCJjZXJ2ZWxsb1wiLFxuICAgIFwiY2Vzb2lhXCIsXG4gICAgXCJjZXNwb1wiLFxuICAgIFwiY2V0b1wiLFxuICAgIFwiY2hlbGFcIixcbiAgICBcImNoaWFyb1wiLFxuICAgIFwiY2hpY2NhXCIsXG4gICAgXCJjaGllZGVyZVwiLFxuICAgIFwiY2hpbWVyYVwiLFxuICAgIFwiY2hpbmFcIixcbiAgICBcImNoaXJ1cmdvXCIsXG4gICAgXCJjaGl0YXJyYVwiLFxuICAgIFwiY2lhb1wiLFxuICAgIFwiY2ljbGlzbW9cIixcbiAgICBcImNpZnJhcmVcIixcbiAgICBcImNpZ25vXCIsXG4gICAgXCJjaWxpbmRyb1wiLFxuICAgIFwiY2lvdHRvbG9cIixcbiAgICBcImNpcmNhXCIsXG4gICAgXCJjaXJyb3NpXCIsXG4gICAgXCJjaXRyaWNvXCIsXG4gICAgXCJjaXR0YWRpbm9cIixcbiAgICBcImNpdWZmb1wiLFxuICAgIFwiY2l2ZXR0YVwiLFxuICAgIFwiY2l2aWxlXCIsXG4gICAgXCJjbGFzc2ljb1wiLFxuICAgIFwiY2xpbmljYVwiLFxuICAgIFwiY2xvcm9cIixcbiAgICBcImNvY2NvXCIsXG4gICAgXCJjb2RhcmRvXCIsXG4gICAgXCJjb2RpY2VcIixcbiAgICBcImNvZXJlbnRlXCIsXG4gICAgXCJjb2dub21lXCIsXG4gICAgXCJjb2xsYXJlXCIsXG4gICAgXCJjb2xtYXRvXCIsXG4gICAgXCJjb2xvcmVcIixcbiAgICBcImNvbHBvc29cIixcbiAgICBcImNvbHRpdmF0b1wiLFxuICAgIFwiY29semFcIixcbiAgICBcImNvbWFcIixcbiAgICBcImNvbWV0YVwiLFxuICAgIFwiY29tbWFuZG9cIixcbiAgICBcImNvbW9kb1wiLFxuICAgIFwiY29tcHV0ZXJcIixcbiAgICBcImNvbXVuZVwiLFxuICAgIFwiY29uY2lzb1wiLFxuICAgIFwiY29uZHVycmVcIixcbiAgICBcImNvbmZlcm1hXCIsXG4gICAgXCJjb25nZWxhcmVcIixcbiAgICBcImNvbml1Z2VcIixcbiAgICBcImNvbm5lc3NvXCIsXG4gICAgXCJjb25vc2NlcmVcIixcbiAgICBcImNvbnN1bW9cIixcbiAgICBcImNvbnRpbnVvXCIsXG4gICAgXCJjb252ZWdub1wiLFxuICAgIFwiY29wZXJ0b1wiLFxuICAgIFwiY29waW9uZVwiLFxuICAgIFwiY29wcGlhXCIsXG4gICAgXCJjb3ByaWNhcG9cIixcbiAgICBcImNvcmF6emFcIixcbiAgICBcImNvcmRhdGFcIixcbiAgICBcImNvcmljYXRvXCIsXG4gICAgXCJjb3JuaWNlXCIsXG4gICAgXCJjb3JvbGxhXCIsXG4gICAgXCJjb3Jwb1wiLFxuICAgIFwiY29ycmVkb1wiLFxuICAgIFwiY29yc2lhXCIsXG4gICAgXCJjb3J0ZXNlXCIsXG4gICAgXCJjb3NtaWNvXCIsXG4gICAgXCJjb3N0YW50ZVwiLFxuICAgIFwiY290dHVyYVwiLFxuICAgIFwiY292YXRvXCIsXG4gICAgXCJjcmF0ZXJlXCIsXG4gICAgXCJjcmF2YXR0YVwiLFxuICAgIFwiY3JlYXRvXCIsXG4gICAgXCJjcmVkZXJlXCIsXG4gICAgXCJjcmVtb3NvXCIsXG4gICAgXCJjcmVzY2l0YVwiLFxuICAgIFwiY3JldGFcIixcbiAgICBcImNyaWNldG9cIixcbiAgICBcImNyaW5hbGVcIixcbiAgICBcImNyaXNpXCIsXG4gICAgXCJjcml0aWNvXCIsXG4gICAgXCJjcm9jZVwiLFxuICAgIFwiY3JvbmFjYVwiLFxuICAgIFwiY3Jvc3RhdGFcIixcbiAgICBcImNydWNpYWxlXCIsXG4gICAgXCJjcnVzY2FcIixcbiAgICBcImN1Y2lyZVwiLFxuICAgIFwiY3VjdWxvXCIsXG4gICAgXCJjdWdpbm9cIixcbiAgICBcImN1bGxhdG9cIixcbiAgICBcImN1cG9sYVwiLFxuICAgIFwiY3VyYXRvcmVcIixcbiAgICBcImN1cnNvcmVcIixcbiAgICBcImN1cnZvXCIsXG4gICAgXCJjdXNjaW5vXCIsXG4gICAgXCJjdXN0b2RlXCIsXG4gICAgXCJkYWRvXCIsXG4gICAgXCJkYWlub1wiLFxuICAgIFwiZGFsbWF0YVwiLFxuICAgIFwiZGFtZXJpbm9cIixcbiAgICBcImRhbmllbGFcIixcbiAgICBcImRhbm5vc29cIixcbiAgICBcImRhbnphcmVcIixcbiAgICBcImRhdGF0b1wiLFxuICAgIFwiZGF2YW50aVwiLFxuICAgIFwiZGF2dmVyb1wiLFxuICAgIFwiZGVidXR0b1wiLFxuICAgIFwiZGVjZW5uaW9cIixcbiAgICBcImRlY2lzb1wiLFxuICAgIFwiZGVjbGlub1wiLFxuICAgIFwiZGVjb2xsb1wiLFxuICAgIFwiZGVjcmV0b1wiLFxuICAgIFwiZGVkaWNhdG9cIixcbiAgICBcImRlZmluaXRvXCIsXG4gICAgXCJkZWZvcm1lXCIsXG4gICAgXCJkZWdub1wiLFxuICAgIFwiZGVsZWdhcmVcIixcbiAgICBcImRlbGZpbm9cIixcbiAgICBcImRlbGlyaW9cIixcbiAgICBcImRlbHRhXCIsXG4gICAgXCJkZW1lbnphXCIsXG4gICAgXCJkZW5vdGF0b1wiLFxuICAgIFwiZGVudHJvXCIsXG4gICAgXCJkZXBvc2l0b1wiLFxuICAgIFwiZGVyYXBhdGFcIixcbiAgICBcImRlcml2YXJlXCIsXG4gICAgXCJkZXJvZ2FcIixcbiAgICBcImRlc2NyaXR0b1wiLFxuICAgIFwiZGVzZXJ0b1wiLFxuICAgIFwiZGVzaWRlcmlvXCIsXG4gICAgXCJkZXN1bWVyZVwiLFxuICAgIFwiZGV0ZXJzaXZvXCIsXG4gICAgXCJkZXZvdG9cIixcbiAgICBcImRpYW1ldHJvXCIsXG4gICAgXCJkaWNlbWJyZVwiLFxuICAgIFwiZGllZHJvXCIsXG4gICAgXCJkaWZlc29cIixcbiAgICBcImRpZmZ1c29cIixcbiAgICBcImRpZ2VyaXJlXCIsXG4gICAgXCJkaWdpdGFsZVwiLFxuICAgIFwiZGlsdXZpb1wiLFxuICAgIFwiZGluYW1pY29cIixcbiAgICBcImRpbm5hbnppXCIsXG4gICAgXCJkaXBpbnRvXCIsXG4gICAgXCJkaXBsb21hXCIsXG4gICAgXCJkaXBvbG9cIixcbiAgICBcImRpcmFkYXJlXCIsXG4gICAgXCJkaXJlXCIsXG4gICAgXCJkaXJvdHRvXCIsXG4gICAgXCJkaXJ1cG9cIixcbiAgICBcImRpc2FnaW9cIixcbiAgICBcImRpc2NyZXRvXCIsXG4gICAgXCJkaXNmYXJlXCIsXG4gICAgXCJkaXNnZWxvXCIsXG4gICAgXCJkaXNwb3N0b1wiLFxuICAgIFwiZGlzdGFuemFcIixcbiAgICBcImRpc3VtYW5vXCIsXG4gICAgXCJkaXRvXCIsXG4gICAgXCJkaXZhbm9cIixcbiAgICBcImRpdmVsdG9cIixcbiAgICBcImRpdmlkZXJlXCIsXG4gICAgXCJkaXZvcmF0b1wiLFxuICAgIFwiZG9ibG9uZVwiLFxuICAgIFwiZG9jZW50ZVwiLFxuICAgIFwiZG9nYW5hbGVcIixcbiAgICBcImRvZ21hXCIsXG4gICAgXCJkb2xjZVwiLFxuICAgIFwiZG9tYXRvXCIsXG4gICAgXCJkb21lbmljYVwiLFxuICAgIFwiZG9taW5hcmVcIixcbiAgICBcImRvbmRvbG9cIixcbiAgICBcImRvbm9cIixcbiAgICBcImRvcm1pcmVcIixcbiAgICBcImRvdGVcIixcbiAgICBcImRvdHRvcmVcIixcbiAgICBcImRvdnV0b1wiLFxuICAgIFwiZG96emluYVwiLFxuICAgIFwiZHJhZ29cIixcbiAgICBcImRydWlkb1wiLFxuICAgIFwiZHViYmlvXCIsXG4gICAgXCJkdWJpdGFyZVwiLFxuICAgIFwiZHVjYWxlXCIsXG4gICAgXCJkdW5hXCIsXG4gICAgXCJkdW9tb1wiLFxuICAgIFwiZHVwbGljZVwiLFxuICAgIFwiZHVyYXR1cm9cIixcbiAgICBcImViYW5vXCIsXG4gICAgXCJlY2Nlc3NvXCIsXG4gICAgXCJlY2NvXCIsXG4gICAgXCJlY2xpc3NpXCIsXG4gICAgXCJlY29ub21pYVwiLFxuICAgIFwiZWRlcmFcIixcbiAgICBcImVkaWNvbGFcIixcbiAgICBcImVkaWxlXCIsXG4gICAgXCJlZGl0b3JpYVwiLFxuICAgIFwiZWR1Y2FyZVwiLFxuICAgIFwiZWdlbW9uaWFcIixcbiAgICBcImVnbGlcIixcbiAgICBcImVnb2lzbW9cIixcbiAgICBcImVncmVnaW9cIixcbiAgICBcImVsYWJvcmF0b1wiLFxuICAgIFwiZWxhcmdpcmVcIixcbiAgICBcImVsZWdhbnRlXCIsXG4gICAgXCJlbGVuY2F0b1wiLFxuICAgIFwiZWxldHRvXCIsXG4gICAgXCJlbGV2YXJlXCIsXG4gICAgXCJlbGZpY29cIixcbiAgICBcImVsaWNhXCIsXG4gICAgXCJlbG1vXCIsXG4gICAgXCJlbHNhXCIsXG4gICAgXCJlbHVzb1wiLFxuICAgIFwiZW1hbmF0b1wiLFxuICAgIFwiZW1ibGVtYVwiLFxuICAgIFwiZW1lc3NvXCIsXG4gICAgXCJlbWlyb1wiLFxuICAgIFwiZW1vdGl2b1wiLFxuICAgIFwiZW1vemlvbmVcIixcbiAgICBcImVtcGlyaWNvXCIsXG4gICAgXCJlbXVsb1wiLFxuICAgIFwiZW5kZW1pY29cIixcbiAgICBcImVuZHVyb1wiLFxuICAgIFwiZW5lcmdpYVwiLFxuICAgIFwiZW5mYXNpXCIsXG4gICAgXCJlbm90ZWNhXCIsXG4gICAgXCJlbnRyYXJlXCIsXG4gICAgXCJlbnppbWFcIixcbiAgICBcImVwYXRpdGVcIixcbiAgICBcImVwaWxvZ29cIixcbiAgICBcImVwaXNvZGlvXCIsXG4gICAgXCJlcG9jYWxlXCIsXG4gICAgXCJlcHB1cmVcIixcbiAgICBcImVxdWF0b3JlXCIsXG4gICAgXCJlcmFyaW9cIixcbiAgICBcImVyYmFcIixcbiAgICBcImVyYm9zb1wiLFxuICAgIFwiZXJlZGVcIixcbiAgICBcImVyZW1pdGFcIixcbiAgICBcImVyaWdlcmVcIixcbiAgICBcImVybWV0aWNvXCIsXG4gICAgXCJlcm9lXCIsXG4gICAgXCJlcm9zaXZvXCIsXG4gICAgXCJlcnJhbnRlXCIsXG4gICAgXCJlc2Fnb25vXCIsXG4gICAgXCJlc2FtZVwiLFxuICAgIFwiZXNhbmltZVwiLFxuICAgIFwiZXNhdWRpcmVcIixcbiAgICBcImVzY2FcIixcbiAgICBcImVzZW1waW9cIixcbiAgICBcImVzZXJjaXRvXCIsXG4gICAgXCJlc2liaXRvXCIsXG4gICAgXCJlc2lnZW50ZVwiLFxuICAgIFwiZXNpc3RlcmVcIixcbiAgICBcImVzaXRvXCIsXG4gICAgXCJlc29mYWdvXCIsXG4gICAgXCJlc29ydGF0b1wiLFxuICAgIFwiZXNvc29cIixcbiAgICBcImVzcGFuc29cIixcbiAgICBcImVzcHJlc3NvXCIsXG4gICAgXCJlc3NlbnphXCIsXG4gICAgXCJlc3NvXCIsXG4gICAgXCJlc3Rlc29cIixcbiAgICBcImVzdGltYXJlXCIsXG4gICAgXCJlc3RvbmlhXCIsXG4gICAgXCJlc3Ryb3NvXCIsXG4gICAgXCJlc3VsdGFyZVwiLFxuICAgIFwiZXRpbGljb1wiLFxuICAgIFwiZXRuaWNvXCIsXG4gICAgXCJldHJ1c2NvXCIsXG4gICAgXCJldHRvXCIsXG4gICAgXCJldWNsaWRlb1wiLFxuICAgIFwiZXVyb3BhXCIsXG4gICAgXCJldmFzb1wiLFxuICAgIFwiZXZpZGVuemFcIixcbiAgICBcImV2aXRhdG9cIixcbiAgICBcImV2b2x1dG9cIixcbiAgICBcImV2dml2YVwiLFxuICAgIFwiZmFiYnJpY2FcIixcbiAgICBcImZhY2NlbmRhXCIsXG4gICAgXCJmYWNoaXJvXCIsXG4gICAgXCJmYWxjb1wiLFxuICAgIFwiZmFtaWdsaWFcIixcbiAgICBcImZhbmFsZVwiLFxuICAgIFwiZmFuZmFyYVwiLFxuICAgIFwiZmFuZ29cIixcbiAgICBcImZhbnRhc21hXCIsXG4gICAgXCJmYXJlXCIsXG4gICAgXCJmYXJmYWxsYVwiLFxuICAgIFwiZmFyaW5vc29cIixcbiAgICBcImZhcm1hY29cIixcbiAgICBcImZhc2NpYVwiLFxuICAgIFwiZmFzdG9zb1wiLFxuICAgIFwiZmFzdWxsb1wiLFxuICAgIFwiZmF0aWNhcmVcIixcbiAgICBcImZhdG9cIixcbiAgICBcImZhdm9sb3NvXCIsXG4gICAgXCJmZWJicmVcIixcbiAgICBcImZlY29sYVwiLFxuICAgIFwiZmVkZVwiLFxuICAgIFwiZmVnYXRvXCIsXG4gICAgXCJmZWxwYVwiLFxuICAgIFwiZmVsdHJvXCIsXG4gICAgXCJmZW1taW5hXCIsXG4gICAgXCJmZW5kZXJlXCIsXG4gICAgXCJmZW5vbWVub1wiLFxuICAgIFwiZmVybWVudG9cIixcbiAgICBcImZlcnJvXCIsXG4gICAgXCJmZXJ0aWxlXCIsXG4gICAgXCJmZXNzdXJhXCIsXG4gICAgXCJmZXN0aXZvXCIsXG4gICAgXCJmZXR0YVwiLFxuICAgIFwiZmV1ZG9cIixcbiAgICBcImZpYWJhXCIsXG4gICAgXCJmaWR1Y2lhXCIsXG4gICAgXCJmaWZhXCIsXG4gICAgXCJmaWd1cmF0b1wiLFxuICAgIFwiZmlsb1wiLFxuICAgIFwiZmluYW56YVwiLFxuICAgIFwiZmluZXN0cmFcIixcbiAgICBcImZpbmlyZVwiLFxuICAgIFwiZmlvcmVcIixcbiAgICBcImZpc2NhbGVcIixcbiAgICBcImZpc2ljb1wiLFxuICAgIFwiZml1bWVcIixcbiAgICBcImZsYWNvbmVcIixcbiAgICBcImZsYW1lbmNvXCIsXG4gICAgXCJmbGVib1wiLFxuICAgIFwiZmxlbW1hXCIsXG4gICAgXCJmbG9yaWRvXCIsXG4gICAgXCJmbHVlbnRlXCIsXG4gICAgXCJmbHVvcm9cIixcbiAgICBcImZvYmljb1wiLFxuICAgIFwiZm9jYWNjaWFcIixcbiAgICBcImZvY29zb1wiLFxuICAgIFwiZm9kZXJhdG9cIixcbiAgICBcImZvZ2xpb1wiLFxuICAgIFwiZm9sYXRhXCIsXG4gICAgXCJmb2xjbG9yZVwiLFxuICAgIFwiZm9sZ29yZVwiLFxuICAgIFwiZm9uZGVudGVcIixcbiAgICBcImZvbmV0aWNvXCIsXG4gICAgXCJmb25pYVwiLFxuICAgIFwiZm9udGFuYVwiLFxuICAgIFwiZm9yYml0b1wiLFxuICAgIFwiZm9yY2hldHRhXCIsXG4gICAgXCJmb3Jlc3RhXCIsXG4gICAgXCJmb3JtaWNhXCIsXG4gICAgXCJmb3JuYWlvXCIsXG4gICAgXCJmb3JvXCIsXG4gICAgXCJmb3J0ZXp6YVwiLFxuICAgIFwiZm9yemFyZVwiLFxuICAgIFwiZm9zZmF0b1wiLFxuICAgIFwiZm9zc29cIixcbiAgICBcImZyYWNhc3NvXCIsXG4gICAgXCJmcmFuYVwiLFxuICAgIFwiZnJhc3Npbm9cIixcbiAgICBcImZyYXRlbGxvXCIsXG4gICAgXCJmcmVjY2V0dGFcIixcbiAgICBcImZyZW5hdGFcIixcbiAgICBcImZyZXNjb1wiLFxuICAgIFwiZnJpZ29cIixcbiAgICBcImZyb2xsaW5vXCIsXG4gICAgXCJmcm9uZGVcIixcbiAgICBcImZydWdhbGVcIixcbiAgICBcImZydXR0YVwiLFxuICAgIFwiZnVjaWxhdGFcIixcbiAgICBcImZ1Y3NpYVwiLFxuICAgIFwiZnVnZ2VudGVcIixcbiAgICBcImZ1bG1pbmVcIixcbiAgICBcImZ1bHZvXCIsXG4gICAgXCJmdW1hbnRlXCIsXG4gICAgXCJmdW1ldHRvXCIsXG4gICAgXCJmdW1vc29cIixcbiAgICBcImZ1bmVcIixcbiAgICBcImZ1bnppb25lXCIsXG4gICAgXCJmdW9jb1wiLFxuICAgIFwiZnVyYm9cIixcbiAgICBcImZ1cmdvbmVcIixcbiAgICBcImZ1cm9yZVwiLFxuICAgIFwiZnVzb1wiLFxuICAgIFwiZnV0aWxlXCIsXG4gICAgXCJnYWJiaWFub1wiLFxuICAgIFwiZ2FmZmVcIixcbiAgICBcImdhbGF0ZW9cIixcbiAgICBcImdhbGxpbmFcIixcbiAgICBcImdhbG9wcG9cIixcbiAgICBcImdhbWJlcm9cIixcbiAgICBcImdhbW1hXCIsXG4gICAgXCJnYXJhbnppYVwiLFxuICAgIFwiZ2FyYm9cIixcbiAgICBcImdhcm9mYW5vXCIsXG4gICAgXCJnYXJ6b25lXCIsXG4gICAgXCJnYXNkb3R0b1wiLFxuICAgIFwiZ2Fzb2xpb1wiLFxuICAgIFwiZ2FzdHJpY29cIixcbiAgICBcImdhdHRvXCIsXG4gICAgXCJnYXVkaW9cIixcbiAgICBcImdhemVib1wiLFxuICAgIFwiZ2F6emVsbGFcIixcbiAgICBcImdlY29cIixcbiAgICBcImdlbGF0aW5hXCIsXG4gICAgXCJnZWxzb1wiLFxuICAgIFwiZ2VtZWxsb1wiLFxuICAgIFwiZ2VtbWF0b1wiLFxuICAgIFwiZ2VuZVwiLFxuICAgIFwiZ2VuaXRvcmVcIixcbiAgICBcImdlbm5haW9cIixcbiAgICBcImdlbm90aXBvXCIsXG4gICAgXCJnZXJnb1wiLFxuICAgIFwiZ2hlcGFyZG9cIixcbiAgICBcImdoaWFjY2lvXCIsXG4gICAgXCJnaGlzYVwiLFxuICAgIFwiZ2lhbGxvXCIsXG4gICAgXCJnaWxkYVwiLFxuICAgIFwiZ2luZXByb1wiLFxuICAgIFwiZ2lvY2FyZVwiLFxuICAgIFwiZ2lvaWVsbG9cIixcbiAgICBcImdpb3Jub1wiLFxuICAgIFwiZ2lvdmVcIixcbiAgICBcImdpcmF0b1wiLFxuICAgIFwiZ2lyb25lXCIsXG4gICAgXCJnaXR0YXRhXCIsXG4gICAgXCJnaXVkaXppb1wiLFxuICAgIFwiZ2l1cmF0b1wiLFxuICAgIFwiZ2l1c3RvXCIsXG4gICAgXCJnbG9idWxvXCIsXG4gICAgXCJnbHV0aW5lXCIsXG4gICAgXCJnbm9tb1wiLFxuICAgIFwiZ29iYmFcIixcbiAgICBcImdvbGZcIixcbiAgICBcImdvbWl0b1wiLFxuICAgIFwiZ29tbW9uZVwiLFxuICAgIFwiZ29uZmlvXCIsXG4gICAgXCJnb25uYVwiLFxuICAgIFwiZ292ZXJub1wiLFxuICAgIFwiZ3JhY2lsZVwiLFxuICAgIFwiZ3JhZG9cIixcbiAgICBcImdyYWZpY29cIixcbiAgICBcImdyYW1tb1wiLFxuICAgIFwiZ3JhbmRlXCIsXG4gICAgXCJncmF0dGFyZVwiLFxuICAgIFwiZ3Jhdm9zb1wiLFxuICAgIFwiZ3JhemlhXCIsXG4gICAgXCJncmVjYVwiLFxuICAgIFwiZ3JlZ2dlXCIsXG4gICAgXCJncmlmb25lXCIsXG4gICAgXCJncmlnaW9cIixcbiAgICBcImdyaW56YVwiLFxuICAgIFwiZ3JvdHRhXCIsXG4gICAgXCJncnVwcG9cIixcbiAgICBcImd1YWRhZ25vXCIsXG4gICAgXCJndWFpb1wiLFxuICAgIFwiZ3VhbnRvXCIsXG4gICAgXCJndWFyZGFyZVwiLFxuICAgIFwiZ3Vmb1wiLFxuICAgIFwiZ3VpZGFyZVwiLFxuICAgIFwiaWJlcm5hdG9cIixcbiAgICBcImljb25hXCIsXG4gICAgXCJpZGVudGljb1wiLFxuICAgIFwiaWRpbGxpb1wiLFxuICAgIFwiaWRvbG9cIixcbiAgICBcImlkcmFcIixcbiAgICBcImlkcmljb1wiLFxuICAgIFwiaWRyb2dlbm9cIixcbiAgICBcImlnaWVuZVwiLFxuICAgIFwiaWduYXJvXCIsXG4gICAgXCJpZ25vcmF0b1wiLFxuICAgIFwiaWxhcmVcIixcbiAgICBcImlsbGVzb1wiLFxuICAgIFwiaWxsb2dpY29cIixcbiAgICBcImlsbHVkZXJlXCIsXG4gICAgXCJpbWJhbGxvXCIsXG4gICAgXCJpbWJldnV0b1wiLFxuICAgIFwiaW1ib2Njb1wiLFxuICAgIFwiaW1idXRvXCIsXG4gICAgXCJpbW1hbmVcIixcbiAgICBcImltbWVyc29cIixcbiAgICBcImltbW9sYXRvXCIsXG4gICAgXCJpbXBhY2NvXCIsXG4gICAgXCJpbXBldG9cIixcbiAgICBcImltcGllZ29cIixcbiAgICBcImltcG9ydG9cIixcbiAgICBcImltcHJvbnRhXCIsXG4gICAgXCJpbmFsYXJlXCIsXG4gICAgXCJpbmFyY2FyZVwiLFxuICAgIFwiaW5hdHRpdm9cIixcbiAgICBcImluY2FudG9cIixcbiAgICBcImluY2VuZGlvXCIsXG4gICAgXCJpbmNoaW5vXCIsXG4gICAgXCJpbmNpc2l2b1wiLFxuICAgIFwiaW5jbHVzb1wiLFxuICAgIFwiaW5jb250cm9cIixcbiAgICBcImluY3JvY2lvXCIsXG4gICAgXCJpbmN1Ym9cIixcbiAgICBcImluZGFnaW5lXCIsXG4gICAgXCJpbmRpYVwiLFxuICAgIFwiaW5kb2xlXCIsXG4gICAgXCJpbmVkaXRvXCIsXG4gICAgXCJpbmZhdHRpXCIsXG4gICAgXCJpbmZpbGFyZVwiLFxuICAgIFwiaW5mbGl0dG9cIixcbiAgICBcImluZ2FnZ2lvXCIsXG4gICAgXCJpbmdlZ25vXCIsXG4gICAgXCJpbmdsZXNlXCIsXG4gICAgXCJpbmdvcmRvXCIsXG4gICAgXCJpbmdyb3Nzb1wiLFxuICAgIFwiaW5uZXNjb1wiLFxuICAgIFwiaW5vZG9yZVwiLFxuICAgIFwiaW5vbHRyYXJlXCIsXG4gICAgXCJpbm9uZGF0b1wiLFxuICAgIFwiaW5zYW5vXCIsXG4gICAgXCJpbnNldHRvXCIsXG4gICAgXCJpbnNpZW1lXCIsXG4gICAgXCJpbnNvbm5pYVwiLFxuICAgIFwiaW5zdWxpbmFcIixcbiAgICBcImludGFzYXRvXCIsXG4gICAgXCJpbnRlcm9cIixcbiAgICBcImludG9uYWNvXCIsXG4gICAgXCJpbnR1aXRvXCIsXG4gICAgXCJpbnVtaWRpcmVcIixcbiAgICBcImludmFsaWRvXCIsXG4gICAgXCJpbnZlY2VcIixcbiAgICBcImludml0b1wiLFxuICAgIFwiaXBlcmJvbGVcIixcbiAgICBcImlwbm90aWNvXCIsXG4gICAgXCJpcG90ZXNpXCIsXG4gICAgXCJpcHBpY2FcIixcbiAgICBcImlyaWRlXCIsXG4gICAgXCJpcmxhbmRhXCIsXG4gICAgXCJpcm9uaWNvXCIsXG4gICAgXCJpcnJpZ2F0b1wiLFxuICAgIFwiaXJyb3JhcmVcIixcbiAgICBcImlzb2xhdG9cIixcbiAgICBcImlzb3RvcG9cIixcbiAgICBcImlzdGVyaWNvXCIsXG4gICAgXCJpc3RpdHV0b1wiLFxuICAgIFwiaXN0cmljZVwiLFxuICAgIFwiaXRhbGlhXCIsXG4gICAgXCJpdGVyYXJlXCIsXG4gICAgXCJsYWJicm9cIixcbiAgICBcImxhYmlyaW50b1wiLFxuICAgIFwibGFjY2FcIixcbiAgICBcImxhY2VyYXRvXCIsXG4gICAgXCJsYWNyaW1hXCIsXG4gICAgXCJsYWN1bmFcIixcbiAgICBcImxhZGRvdmVcIixcbiAgICBcImxhZ29cIixcbiAgICBcImxhbXBvXCIsXG4gICAgXCJsYW5jZXR0YVwiLFxuICAgIFwibGFudGVybmFcIixcbiAgICBcImxhcmRvc29cIixcbiAgICBcImxhcmdhXCIsXG4gICAgXCJsYXJpbmdlXCIsXG4gICAgXCJsYXN0cmFcIixcbiAgICBcImxhdGVuemFcIixcbiAgICBcImxhdGlub1wiLFxuICAgIFwibGF0dHVnYVwiLFxuICAgIFwibGF2YWduYVwiLFxuICAgIFwibGF2b3JvXCIsXG4gICAgXCJsZWdhbGVcIixcbiAgICBcImxlZ2dlcm9cIixcbiAgICBcImxlbWJvXCIsXG4gICAgXCJsZW50ZXp6YVwiLFxuICAgIFwibGVuemFcIixcbiAgICBcImxlb25lXCIsXG4gICAgXCJsZXByZVwiLFxuICAgIFwibGVzaXZvXCIsXG4gICAgXCJsZXNzYXRvXCIsXG4gICAgXCJsZXN0b1wiLFxuICAgIFwibGV0dGVyYWxlXCIsXG4gICAgXCJsZXZhXCIsXG4gICAgXCJsZXZpZ2F0b1wiLFxuICAgIFwibGliZXJvXCIsXG4gICAgXCJsaWRvXCIsXG4gICAgXCJsaWV2aXRvXCIsXG4gICAgXCJsaWxsYVwiLFxuICAgIFwibGltYXR1cmFcIixcbiAgICBcImxpbWl0YXJlXCIsXG4gICAgXCJsaW1waWRvXCIsXG4gICAgXCJsaW5lYXJlXCIsXG4gICAgXCJsaW5ndWFcIixcbiAgICBcImxpcXVpZG9cIixcbiAgICBcImxpcmFcIixcbiAgICBcImxpcmljYVwiLFxuICAgIFwibGlzY2FcIixcbiAgICBcImxpdGVcIixcbiAgICBcImxpdGlnaW9cIixcbiAgICBcImxpdnJlYVwiLFxuICAgIFwibG9jYW5kYVwiLFxuICAgIFwibG9kZVwiLFxuICAgIFwibG9naWNhXCIsXG4gICAgXCJsb21iYXJlXCIsXG4gICAgXCJsb25kcmFcIixcbiAgICBcImxvbmdldm9cIixcbiAgICBcImxvcXVhY2VcIixcbiAgICBcImxvcmVuem9cIixcbiAgICBcImxvdG9cIixcbiAgICBcImxvdHRlcmlhXCIsXG4gICAgXCJsdWNlXCIsXG4gICAgXCJsdWNpZGF0b1wiLFxuICAgIFwibHVtYWNhXCIsXG4gICAgXCJsdW1pbm9zb1wiLFxuICAgIFwibHVuZ29cIixcbiAgICBcImx1cG9cIixcbiAgICBcImx1cHBvbG9cIixcbiAgICBcImx1c2luZ2FcIixcbiAgICBcImx1c3NvXCIsXG4gICAgXCJsdXR0b1wiLFxuICAgIFwibWFjYWJyb1wiLFxuICAgIFwibWFjY2hpbmFcIixcbiAgICBcIm1hY2Vyb1wiLFxuICAgIFwibWFjaW5hdG9cIixcbiAgICBcIm1hZGFtYVwiLFxuICAgIFwibWFnaWNvXCIsXG4gICAgXCJtYWdsaWFcIixcbiAgICBcIm1hZ25ldGVcIixcbiAgICBcIm1hZ3JvXCIsXG4gICAgXCJtYWlvbGljYVwiLFxuICAgIFwibWFsYWZlZGVcIixcbiAgICBcIm1hbGdyYWRvXCIsXG4gICAgXCJtYWxpbnRlc29cIixcbiAgICBcIm1hbHNhbm9cIixcbiAgICBcIm1hbHRvXCIsXG4gICAgXCJtYWx1bW9yZVwiLFxuICAgIFwibWFuYVwiLFxuICAgIFwibWFuY2lhXCIsXG4gICAgXCJtYW5kb3JsYVwiLFxuICAgIFwibWFuZ2lhcmVcIixcbiAgICBcIm1hbmlmZXN0b1wiLFxuICAgIFwibWFubmFyb1wiLFxuICAgIFwibWFub3ZyYVwiLFxuICAgIFwibWFuc2FyZGFcIixcbiAgICBcIm1hbnRpZGVcIixcbiAgICBcIm1hbnVicmlvXCIsXG4gICAgXCJtYXBwYVwiLFxuICAgIFwibWFyYXRvbmFcIixcbiAgICBcIm1hcmNpcmVcIixcbiAgICBcIm1hcmV0dGFcIixcbiAgICBcIm1hcm1vXCIsXG4gICAgXCJtYXJzdXBpb1wiLFxuICAgIFwibWFzY2hlcmFcIixcbiAgICBcIm1hc3NhaWFcIixcbiAgICBcIm1hc3Rpbm9cIixcbiAgICBcIm1hdGVyYXNzb1wiLFxuICAgIFwibWF0cmljb2xhXCIsXG4gICAgXCJtYXR0b25lXCIsXG4gICAgXCJtYXR1cm9cIixcbiAgICBcIm1henVyY2FcIixcbiAgICBcIm1lYW5kcm9cIixcbiAgICBcIm1lY2Nhbmljb1wiLFxuICAgIFwibWVjZW5hdGVcIixcbiAgICBcIm1lZGVzaW1vXCIsXG4gICAgXCJtZWRpdGFyZVwiLFxuICAgIFwibWVnYVwiLFxuICAgIFwibWVsYXNzYVwiLFxuICAgIFwibWVsaXNcIixcbiAgICBcIm1lbG9kaWFcIixcbiAgICBcIm1lbmluZ2VcIixcbiAgICBcIm1lbm9cIixcbiAgICBcIm1lbnNvbGFcIixcbiAgICBcIm1lcmN1cmlvXCIsXG4gICAgXCJtZXJlbmRhXCIsXG4gICAgXCJtZXJsb1wiLFxuICAgIFwibWVzY2hpbm9cIixcbiAgICBcIm1lc2VcIixcbiAgICBcIm1lc3NlcmVcIixcbiAgICBcIm1lc3RvbG9cIixcbiAgICBcIm1ldGFsbG9cIixcbiAgICBcIm1ldG9kb1wiLFxuICAgIFwibWV0dGVyZVwiLFxuICAgIFwibWlhZ29sYXJlXCIsXG4gICAgXCJtaWNhXCIsXG4gICAgXCJtaWNlbGlvXCIsXG4gICAgXCJtaWNoZWxlXCIsXG4gICAgXCJtaWNyb2JvXCIsXG4gICAgXCJtaWRvbGxvXCIsXG4gICAgXCJtaWVsZVwiLFxuICAgIFwibWlnbGlvcmVcIixcbiAgICBcIm1pbGFub1wiLFxuICAgIFwibWlsaXRlXCIsXG4gICAgXCJtaW1vc2FcIixcbiAgICBcIm1pbmVyYWxlXCIsXG4gICAgXCJtaW5pXCIsXG4gICAgXCJtaW5vcmVcIixcbiAgICBcIm1pcmlub1wiLFxuICAgIFwibWlydGlsbG9cIixcbiAgICBcIm1pc2NlbGFcIixcbiAgICBcIm1pc3NpdmFcIixcbiAgICBcIm1pc3RvXCIsXG4gICAgXCJtaXN1cmFyZVwiLFxuICAgIFwibWl0ZXp6YVwiLFxuICAgIFwibWl0aWdhcmVcIixcbiAgICBcIm1pdHJhXCIsXG4gICAgXCJtaXR0ZW50ZVwiLFxuICAgIFwibW5lbW9uaWNvXCIsXG4gICAgXCJtb2RlbGxvXCIsXG4gICAgXCJtb2RpZmljYVwiLFxuICAgIFwibW9kdWxvXCIsXG4gICAgXCJtb2dhbm9cIixcbiAgICBcIm1vZ2lvXCIsXG4gICAgXCJtb2xlXCIsXG4gICAgXCJtb2xvc3NvXCIsXG4gICAgXCJtb25hc3Rlcm9cIixcbiAgICBcIm1vbmNvXCIsXG4gICAgXCJtb25kaW5hXCIsXG4gICAgXCJtb25ldGFyaW9cIixcbiAgICBcIm1vbmlsZVwiLFxuICAgIFwibW9ub3Rvbm9cIixcbiAgICBcIm1vbnNvbmVcIixcbiAgICBcIm1vbnRhdG9cIixcbiAgICBcIm1vbnZpc29cIixcbiAgICBcIm1vcmFcIixcbiAgICBcIm1vcmRlcmVcIixcbiAgICBcIm1vcnNpY2F0b1wiLFxuICAgIFwibW9zdHJvXCIsXG4gICAgXCJtb3RpdmF0b1wiLFxuICAgIFwibW90b3NlZ2FcIixcbiAgICBcIm1vdHRvXCIsXG4gICAgXCJtb3ZlbnphXCIsXG4gICAgXCJtb3ZpbWVudG9cIixcbiAgICBcIm1venpvXCIsXG4gICAgXCJtdWNjYVwiLFxuICAgIFwibXVjb3NhXCIsXG4gICAgXCJtdWZmYVwiLFxuICAgIFwibXVnaGV0dG9cIixcbiAgICBcIm11Z25haW9cIixcbiAgICBcIm11bGF0dG9cIixcbiAgICBcIm11bGluZWxsb1wiLFxuICAgIFwibXVsdGlwbG9cIixcbiAgICBcIm11bW1pYVwiLFxuICAgIFwibXVudG9cIixcbiAgICBcIm11b3ZlcmVcIixcbiAgICBcIm11cmFsZVwiLFxuICAgIFwibXVzYVwiLFxuICAgIFwibXVzY29sb1wiLFxuICAgIFwibXVzaWNhXCIsXG4gICAgXCJtdXRldm9sZVwiLFxuICAgIFwibXV0b1wiLFxuICAgIFwibmFiYWJib1wiLFxuICAgIFwibmFmdGFcIixcbiAgICBcIm5hbm9tZXRyb1wiLFxuICAgIFwibmFyY2lzb1wiLFxuICAgIFwibmFyaWNlXCIsXG4gICAgXCJuYXJyYXRvXCIsXG4gICAgXCJuYXNjZXJlXCIsXG4gICAgXCJuYXN0cmFyZVwiLFxuICAgIFwibmF0dXJhbGVcIixcbiAgICBcIm5hdXRpY2FcIixcbiAgICBcIm5hdmlnbGlvXCIsXG4gICAgXCJuZWJ1bG9zYVwiLFxuICAgIFwibmVjcm9zaVwiLFxuICAgIFwibmVnYXRpdm9cIixcbiAgICBcIm5lZ296aW9cIixcbiAgICBcIm5lbW1lbm9cIixcbiAgICBcIm5lb2ZpdGFcIixcbiAgICBcIm5lcmV0dG9cIixcbiAgICBcIm5lcnZvXCIsXG4gICAgXCJuZXNzdW5vXCIsXG4gICAgXCJuZXR0dW5vXCIsXG4gICAgXCJuZXV0cmFsZVwiLFxuICAgIFwibmV2ZVwiLFxuICAgIFwibmV2cm90aWNvXCIsXG4gICAgXCJuaWNjaGlhXCIsXG4gICAgXCJuaW5mYVwiLFxuICAgIFwibml0aWRvXCIsXG4gICAgXCJub2JpbGVcIixcbiAgICBcIm5vY2l2b1wiLFxuICAgIFwibm9kb1wiLFxuICAgIFwibm9tZVwiLFxuICAgIFwibm9taW5hXCIsXG4gICAgXCJub3JkaWNvXCIsXG4gICAgXCJub3JtYWxlXCIsXG4gICAgXCJub3J2ZWdlc2VcIixcbiAgICBcIm5vc3RyYW5vXCIsXG4gICAgXCJub3RhcmVcIixcbiAgICBcIm5vdGl6aWFcIixcbiAgICBcIm5vdHR1cm5vXCIsXG4gICAgXCJub3ZlbGxhXCIsXG4gICAgXCJudWNsZW9cIixcbiAgICBcIm51bGxhXCIsXG4gICAgXCJudW1lcm9cIixcbiAgICBcIm51b3ZvXCIsXG4gICAgXCJudXRyaXJlXCIsXG4gICAgXCJudXZvbGFcIixcbiAgICBcIm51emlhbGVcIixcbiAgICBcIm9hc2lcIixcbiAgICBcIm9iYmVkaXJlXCIsXG4gICAgXCJvYmJsaWdvXCIsXG4gICAgXCJvYmVsaXNjb1wiLFxuICAgIFwib2JsaW9cIixcbiAgICBcIm9ib2xvXCIsXG4gICAgXCJvYnNvbGV0b1wiLFxuICAgIFwib2NjYXNpb25lXCIsXG4gICAgXCJvY2NoaW9cIixcbiAgICBcIm9jY2lkZW50ZVwiLFxuICAgIFwib2Njb3JyZXJlXCIsXG4gICAgXCJvY2N1bHRhcmVcIixcbiAgICBcIm9jcmFcIixcbiAgICBcIm9jdWxhdG9cIixcbiAgICBcIm9kaWVybm9cIixcbiAgICBcIm9kb3JhcmVcIixcbiAgICBcIm9mZmVydGFcIixcbiAgICBcIm9mZnJpcmVcIixcbiAgICBcIm9mZnVzY2F0b1wiLFxuICAgIFwib2dnZXR0b1wiLFxuICAgIFwib2dnaVwiLFxuICAgIFwib2dudW5vXCIsXG4gICAgXCJvbGFuZGVzZVwiLFxuICAgIFwib2xmYXR0b1wiLFxuICAgIFwib2xpYXRvXCIsXG4gICAgXCJvbGl2YVwiLFxuICAgIFwib2xvZ3JhbW1hXCIsXG4gICAgXCJvbHRyZVwiLFxuICAgIFwib21hZ2dpb1wiLFxuICAgIFwib21iZWxpY29cIixcbiAgICBcIm9tYnJhXCIsXG4gICAgXCJvbWVnYVwiLFxuICAgIFwib21pc3Npb25lXCIsXG4gICAgXCJvbmRvc29cIixcbiAgICBcIm9uZXJlXCIsXG4gICAgXCJvbmljZVwiLFxuICAgIFwib25uaXZvcm9cIixcbiAgICBcIm9ub3Jldm9sZVwiLFxuICAgIFwib250YVwiLFxuICAgIFwib3BlcmF0b1wiLFxuICAgIFwib3BpbmlvbmVcIixcbiAgICBcIm9wcG9zdG9cIixcbiAgICBcIm9yYWNvbG9cIixcbiAgICBcIm9yYWZvXCIsXG4gICAgXCJvcmRpbmVcIixcbiAgICBcIm9yZWNjaGlub1wiLFxuICAgIFwib3JlZmljZVwiLFxuICAgIFwib3JmYW5vXCIsXG4gICAgXCJvcmdhbmljb1wiLFxuICAgIFwib3JpZ2luZVwiLFxuICAgIFwib3JpenpvbnRlXCIsXG4gICAgXCJvcm1hXCIsXG4gICAgXCJvcm1lZ2dpb1wiLFxuICAgIFwib3JuYXRpdm9cIixcbiAgICBcIm9yb2xvZ2lvXCIsXG4gICAgXCJvcnJlbmRvXCIsXG4gICAgXCJvcnJpYmlsZVwiLFxuICAgIFwib3J0ZW5zaWFcIixcbiAgICBcIm9ydGljYVwiLFxuICAgIFwib3J6YXRhXCIsXG4gICAgXCJvcnpvXCIsXG4gICAgXCJvc2FyZVwiLFxuICAgIFwib3NjdXJhcmVcIixcbiAgICBcIm9zbW9zaVwiLFxuICAgIFwib3NwZWRhbGVcIixcbiAgICBcIm9zcGl0ZVwiLFxuICAgIFwib3NzYVwiLFxuICAgIFwib3NzaWRhcmVcIixcbiAgICBcIm9zdGFjb2xvXCIsXG4gICAgXCJvc3RlXCIsXG4gICAgXCJvdGl0ZVwiLFxuICAgIFwib3RyZVwiLFxuICAgIFwib3R0YWdvbm9cIixcbiAgICBcIm90dGltb1wiLFxuICAgIFwib3R0b2JyZVwiLFxuICAgIFwib3ZhbGVcIixcbiAgICBcIm92ZXN0XCIsXG4gICAgXCJvdmlub1wiLFxuICAgIFwib3ZpcGFyb1wiLFxuICAgIFwib3ZvY2l0b1wiLFxuICAgIFwib3Z1bnF1ZVwiLFxuICAgIFwib3Z2aWFyZVwiLFxuICAgIFwib3ppb1wiLFxuICAgIFwicGFjY2hldHRvXCIsXG4gICAgXCJwYWNlXCIsXG4gICAgXCJwYWNpZmljb1wiLFxuICAgIFwicGFkZWxsYVwiLFxuICAgIFwicGFkcm9uZVwiLFxuICAgIFwicGFlc2VcIixcbiAgICBcInBhZ2FcIixcbiAgICBcInBhZ2luYVwiLFxuICAgIFwicGFsYXp6aW5hXCIsXG4gICAgXCJwYWxlc2FyZVwiLFxuICAgIFwicGFsbGlkb1wiLFxuICAgIFwicGFsb1wiLFxuICAgIFwicGFsdWRlXCIsXG4gICAgXCJwYW5kb3JvXCIsXG4gICAgXCJwYW5uZWxsb1wiLFxuICAgIFwicGFvbG9cIixcbiAgICBcInBhb25henpvXCIsXG4gICAgXCJwYXByaWNhXCIsXG4gICAgXCJwYXJhYm9sYVwiLFxuICAgIFwicGFyY2VsbGFcIixcbiAgICBcInBhcmVyZVwiLFxuICAgIFwicGFyZ29sb1wiLFxuICAgIFwicGFyaVwiLFxuICAgIFwicGFybGF0b1wiLFxuICAgIFwicGFyb2xhXCIsXG4gICAgXCJwYXJ0aXJlXCIsXG4gICAgXCJwYXJ2ZW56YVwiLFxuICAgIFwicGFyemlhbGVcIixcbiAgICBcInBhc3Npdm9cIixcbiAgICBcInBhc3RpY2NhXCIsXG4gICAgXCJwYXRhY2NhXCIsXG4gICAgXCJwYXRvbG9naWFcIixcbiAgICBcInBhdHR1bWVcIixcbiAgICBcInBhdm9uZVwiLFxuICAgIFwicGVjY2F0b1wiLFxuICAgIFwicGVkYWxhcmVcIixcbiAgICBcInBlZG9uYWxlXCIsXG4gICAgXCJwZWdnaW9cIixcbiAgICBcInBlbG9zb1wiLFxuICAgIFwicGVuYXJlXCIsXG4gICAgXCJwZW5kaWNlXCIsXG4gICAgXCJwZW5pc29sYVwiLFxuICAgIFwicGVubnV0b1wiLFxuICAgIFwicGVub21icmFcIixcbiAgICBcInBlbnNhcmVcIixcbiAgICBcInBlbnRvbGFcIixcbiAgICBcInBlcGVcIixcbiAgICBcInBlcGl0YVwiLFxuICAgIFwicGVyYmVuZVwiLFxuICAgIFwicGVyY29yc29cIixcbiAgICBcInBlcmRvbmF0b1wiLFxuICAgIFwicGVyZm9yYXJlXCIsXG4gICAgXCJwZXJnYW1lbmFcIixcbiAgICBcInBlcmlvZG9cIixcbiAgICBcInBlcm1lc3NvXCIsXG4gICAgXCJwZXJub1wiLFxuICAgIFwicGVycGxlc3NvXCIsXG4gICAgXCJwZXJzdWFzb1wiLFxuICAgIFwicGVydHVnaW9cIixcbiAgICBcInBlcnZhc29cIixcbiAgICBcInBlc2F0b3JlXCIsXG4gICAgXCJwZXNpc3RhXCIsXG4gICAgXCJwZXNvXCIsXG4gICAgXCJwZXN0aWZlcm9cIixcbiAgICBcInBldGFsb1wiLFxuICAgIFwicGV0dGluZVwiLFxuICAgIFwicGV0dWxhbnRlXCIsXG4gICAgXCJwZXp6b1wiLFxuICAgIFwicGlhY2VyZVwiLFxuICAgIFwicGlhbnRhXCIsXG4gICAgXCJwaWF0dGlub1wiLFxuICAgIFwicGljY2lub1wiLFxuICAgIFwicGljb3p6YVwiLFxuICAgIFwicGllZ2FcIixcbiAgICBcInBpZXRyYVwiLFxuICAgIFwicGlmZmVyb1wiLFxuICAgIFwicGlnaWFtYVwiLFxuICAgIFwicGlnb2xpb1wiLFxuICAgIFwicGlncm9cIixcbiAgICBcInBpbGFcIixcbiAgICBcInBpbGlmZXJvXCIsXG4gICAgXCJwaWxsb2xhXCIsXG4gICAgXCJwaWxvdGFcIixcbiAgICBcInBpbXBhbnRlXCIsXG4gICAgXCJwaW5ldGFcIixcbiAgICBcInBpbm5hXCIsXG4gICAgXCJwaW5vbG9cIixcbiAgICBcInBpb2dnaWFcIixcbiAgICBcInBpb21ib1wiLFxuICAgIFwicGlyYW1pZGVcIixcbiAgICBcInBpcmV0aWNvXCIsXG4gICAgXCJwaXJpdGVcIixcbiAgICBcInBpcm9saXNpXCIsXG4gICAgXCJwaXRvbmVcIixcbiAgICBcInBpenppY29cIixcbiAgICBcInBsYWNlYm9cIixcbiAgICBcInBsYW5hcmVcIixcbiAgICBcInBsYXNtYVwiLFxuICAgIFwicGxhdGFub1wiLFxuICAgIFwicGxlbmFyaW9cIixcbiAgICBcInBvY2hlenphXCIsXG4gICAgXCJwb2Rlcm9zb1wiLFxuICAgIFwicG9kaXNtb1wiLFxuICAgIFwicG9lc2lhXCIsXG4gICAgXCJwb2dnaWFyZVwiLFxuICAgIFwicG9sZW50YVwiLFxuICAgIFwicG9saWdvbm9cIixcbiAgICBcInBvbGxpY2VcIixcbiAgICBcInBvbG1vbml0ZVwiLFxuICAgIFwicG9scGV0dGFcIixcbiAgICBcInBvbHNvXCIsXG4gICAgXCJwb2x0cm9uYVwiLFxuICAgIFwicG9sdmVyZVwiLFxuICAgIFwicG9taWNlXCIsXG4gICAgXCJwb21vZG9yb1wiLFxuICAgIFwicG9udGVcIixcbiAgICBcInBvcG9sb3NvXCIsXG4gICAgXCJwb3JmaWRvXCIsXG4gICAgXCJwb3Jvc29cIixcbiAgICBcInBvcnBvcmFcIixcbiAgICBcInBvcnJlXCIsXG4gICAgXCJwb3J0YXRhXCIsXG4gICAgXCJwb3NhXCIsXG4gICAgXCJwb3NpdGl2b1wiLFxuICAgIFwicG9zc2Vzc29cIixcbiAgICBcInBvc3R1bGF0b1wiLFxuICAgIFwicG90YXNzaW9cIixcbiAgICBcInBvdGVyZVwiLFxuICAgIFwicHJhbnpvXCIsXG4gICAgXCJwcmFzc2lcIixcbiAgICBcInByYXRpY2FcIixcbiAgICBcInByZWNsdXNvXCIsXG4gICAgXCJwcmVkaWNhXCIsXG4gICAgXCJwcmVmaXNzb1wiLFxuICAgIFwicHJlZ2lhdG9cIixcbiAgICBcInByZWxpZXZvXCIsXG4gICAgXCJwcmVtZXJlXCIsXG4gICAgXCJwcmVub3RhcmVcIixcbiAgICBcInByZXBhcmF0b1wiLFxuICAgIFwicHJlc2VuemFcIixcbiAgICBcInByZXRlc3RvXCIsXG4gICAgXCJwcmV2YWxzb1wiLFxuICAgIFwicHJpbWFcIixcbiAgICBcInByaW5jaXBlXCIsXG4gICAgXCJwcml2YXRvXCIsXG4gICAgXCJwcm9ibGVtYVwiLFxuICAgIFwicHJvY3VyYVwiLFxuICAgIFwicHJvZHVycmVcIixcbiAgICBcInByb2Z1bW9cIixcbiAgICBcInByb2dldHRvXCIsXG4gICAgXCJwcm9sdW5nYVwiLFxuICAgIFwicHJvbWVzc2FcIixcbiAgICBcInByb25vbWVcIixcbiAgICBcInByb3Bvc3RhXCIsXG4gICAgXCJwcm9yb2dhXCIsXG4gICAgXCJwcm90ZXNvXCIsXG4gICAgXCJwcm92YVwiLFxuICAgIFwicHJ1ZGVudGVcIixcbiAgICBcInBydWduYVwiLFxuICAgIFwicHJ1cml0b1wiLFxuICAgIFwicHNpY2hlXCIsXG4gICAgXCJwdWJibGljb1wiLFxuICAgIFwicHVkaWNhXCIsXG4gICAgXCJwdWdpbGF0b1wiLFxuICAgIFwicHVnbm9cIixcbiAgICBcInB1bGNlXCIsXG4gICAgXCJwdWxpdG9cIixcbiAgICBcInB1bHNhbnRlXCIsXG4gICAgXCJwdW50YXJlXCIsXG4gICAgXCJwdXBhenpvXCIsXG4gICAgXCJwdXBpbGxhXCIsXG4gICAgXCJwdXJvXCIsXG4gICAgXCJxdWFkcm9cIixcbiAgICBcInF1YWxjb3NhXCIsXG4gICAgXCJxdWFzaVwiLFxuICAgIFwicXVlcmVsYVwiLFxuICAgIFwicXVvdGFcIixcbiAgICBcInJhY2NvbHRvXCIsXG4gICAgXCJyYWRkb3BwaW9cIixcbiAgICBcInJhZGljYWxlXCIsXG4gICAgXCJyYWR1bmF0b1wiLFxuICAgIFwicmFmZmljYVwiLFxuICAgIFwicmFnYXp6b1wiLFxuICAgIFwicmFnaW9uZVwiLFxuICAgIFwicmFnbm9cIixcbiAgICBcInJhbWFycm9cIixcbiAgICBcInJhbWluZ29cIixcbiAgICBcInJhbW9cIixcbiAgICBcInJhbmRhZ2lvXCIsXG4gICAgXCJyYW50b2xhcmVcIixcbiAgICBcInJhcGF0b1wiLFxuICAgIFwicmFwaW5hXCIsXG4gICAgXCJyYXBwcmVzb1wiLFxuICAgIFwicmFzYXR1cmFcIixcbiAgICBcInJhc2NoaWF0b1wiLFxuICAgIFwicmFzZW50ZVwiLFxuICAgIFwicmFzc2VnbmFcIixcbiAgICBcInJhc3RyZWxsb1wiLFxuICAgIFwicmF0YVwiLFxuICAgIFwicmF2dmVkdXRvXCIsXG4gICAgXCJyZWFsZVwiLFxuICAgIFwicmVjZXBpcmVcIixcbiAgICBcInJlY2ludG9cIixcbiAgICBcInJlY2x1dGFcIixcbiAgICBcInJlY29uZGl0b1wiLFxuICAgIFwicmVjdXBlcm9cIixcbiAgICBcInJlZGRpdG9cIixcbiAgICBcInJlZGltZXJlXCIsXG4gICAgXCJyZWdhbGF0b1wiLFxuICAgIFwicmVnaXN0cm9cIixcbiAgICBcInJlZ29sYVwiLFxuICAgIFwicmVncmVzc29cIixcbiAgICBcInJlbGF6aW9uZVwiLFxuICAgIFwicmVtYXJlXCIsXG4gICAgXCJyZW1vdG9cIixcbiAgICBcInJlbm5hXCIsXG4gICAgXCJyZXBsaWNhXCIsXG4gICAgXCJyZXByaW1lcmVcIixcbiAgICBcInJlcHV0YXJlXCIsXG4gICAgXCJyZXNhXCIsXG4gICAgXCJyZXNpZGVudGVcIixcbiAgICBcInJlc3BvbnNvXCIsXG4gICAgXCJyZXN0YXVyb1wiLFxuICAgIFwicmV0ZVwiLFxuICAgIFwicmV0aW5hXCIsXG4gICAgXCJyZXRvcmljYVwiLFxuICAgIFwicmV0dGlmaWNhXCIsXG4gICAgXCJyZXZvY2F0b1wiLFxuICAgIFwicmlhc3N1bnRvXCIsXG4gICAgXCJyaWJhZGlyZVwiLFxuICAgIFwicmliZWxsZVwiLFxuICAgIFwicmlicmV6em9cIixcbiAgICBcInJpY2FyaWNhXCIsXG4gICAgXCJyaWNjb1wiLFxuICAgIFwicmljZXZlcmVcIixcbiAgICBcInJpY2ljbGF0b1wiLFxuICAgIFwicmljb3Jkb1wiLFxuICAgIFwicmljcmVkdXRvXCIsXG4gICAgXCJyaWRpY29sb1wiLFxuICAgIFwicmlkdXJyZVwiLFxuICAgIFwicmlmYXNhcmVcIixcbiAgICBcInJpZmxlc3NvXCIsXG4gICAgXCJyaWZvcm1hXCIsXG4gICAgXCJyaWZ1Z2lvXCIsXG4gICAgXCJyaWdhcmVcIixcbiAgICBcInJpZ2V0dGF0b1wiLFxuICAgIFwicmlnaGVsbG9cIixcbiAgICBcInJpbGFzc2F0b1wiLFxuICAgIFwicmlsZXZhdG9cIixcbiAgICBcInJpbWFuZXJlXCIsXG4gICAgXCJyaW1iYWx6b1wiLFxuICAgIFwicmltZWRpb1wiLFxuICAgIFwicmltb3JjaGlvXCIsXG4gICAgXCJyaW5hc2NpdGFcIixcbiAgICBcInJpbmNhcm9cIixcbiAgICBcInJpbmZvcnpvXCIsXG4gICAgXCJyaW5ub3ZvXCIsXG4gICAgXCJyaW5vbWF0b1wiLFxuICAgIFwicmluc2F2aXRvXCIsXG4gICAgXCJyaW50b2Njb1wiLFxuICAgIFwicmludW5jaWFcIixcbiAgICBcInJpbnZlbmlyZVwiLFxuICAgIFwicmlwYXJhdG9cIixcbiAgICBcInJpcGV0dXRvXCIsXG4gICAgXCJyaXBpZW5vXCIsXG4gICAgXCJyaXBvcnRhcmVcIixcbiAgICBcInJpcHJlc2FcIixcbiAgICBcInJpcHVsaXJlXCIsXG4gICAgXCJyaXNhdGFcIixcbiAgICBcInJpc2NoaW9cIixcbiAgICBcInJpc2VydmFcIixcbiAgICBcInJpc2liaWxlXCIsXG4gICAgXCJyaXNvXCIsXG4gICAgXCJyaXNwZXR0b1wiLFxuICAgIFwicmlzdG9yb1wiLFxuICAgIFwicmlzdWx0YXRvXCIsXG4gICAgXCJyaXN2b2x0b1wiLFxuICAgIFwicml0YXJkb1wiLFxuICAgIFwicml0ZWdub1wiLFxuICAgIFwicml0bWljb1wiLFxuICAgIFwicml0cm92b1wiLFxuICAgIFwicml1bmlvbmVcIixcbiAgICBcInJpdmFcIixcbiAgICBcInJpdmVyc29cIixcbiAgICBcInJpdmluY2l0YVwiLFxuICAgIFwicml2b2x0b1wiLFxuICAgIFwicml6b21hXCIsXG4gICAgXCJyb2JhXCIsXG4gICAgXCJyb2JvdGljb1wiLFxuICAgIFwicm9idXN0b1wiLFxuICAgIFwicm9jY2lhXCIsXG4gICAgXCJyb2NvXCIsXG4gICAgXCJyb2RhZ2dpb1wiLFxuICAgIFwicm9kZXJlXCIsXG4gICAgXCJyb2RpdG9yZVwiLFxuICAgIFwicm9naXRvXCIsXG4gICAgXCJyb2xsaW9cIixcbiAgICBcInJvbWFudGljb1wiLFxuICAgIFwicm9tcGVyZVwiLFxuICAgIFwicm9uemlvXCIsXG4gICAgXCJyb3NvbGFyZVwiLFxuICAgIFwicm9zcG9cIixcbiAgICBcInJvdGFudGVcIixcbiAgICBcInJvdG9uZG9cIixcbiAgICBcInJvdHVsYVwiLFxuICAgIFwicm92ZXNjaW9cIixcbiAgICBcInJ1Yml6em9cIixcbiAgICBcInJ1YnJpY2FcIixcbiAgICBcInJ1Z2FcIixcbiAgICBcInJ1bGxpbm9cIixcbiAgICBcInJ1bWluZVwiLFxuICAgIFwicnVtb3Jvc29cIixcbiAgICBcInJ1b2xvXCIsXG4gICAgXCJydXBlXCIsXG4gICAgXCJydXNzYXJlXCIsXG4gICAgXCJydXN0aWNvXCIsXG4gICAgXCJzYWJhdG9cIixcbiAgICBcInNhYmJpYXJlXCIsXG4gICAgXCJzYWJvdGF0b1wiLFxuICAgIFwic2Fnb21hXCIsXG4gICAgXCJzYWxhc3NvXCIsXG4gICAgXCJzYWxkYXR1cmFcIixcbiAgICBcInNhbGdlbW1hXCIsXG4gICAgXCJzYWxpdmFyZVwiLFxuICAgIFwic2FsbW9uZVwiLFxuICAgIFwic2Fsb25lXCIsXG4gICAgXCJzYWx0YXJlXCIsXG4gICAgXCJzYWx1dG9cIixcbiAgICBcInNhbHZvXCIsXG4gICAgXCJzYXBlcmVcIixcbiAgICBcInNhcGlkb1wiLFxuICAgIFwic2Fwb3JpdG9cIixcbiAgICBcInNhcmFjZW5vXCIsXG4gICAgXCJzYXJjYXNtb1wiLFxuICAgIFwic2FydG9cIixcbiAgICBcInNhc3Nvc29cIixcbiAgICBcInNhdGVsbGl0ZVwiLFxuICAgIFwic2F0aXJhXCIsXG4gICAgXCJzYXRvbGxvXCIsXG4gICAgXCJzYXR1cm5vXCIsXG4gICAgXCJzYXZhbmFcIixcbiAgICBcInNhdmlvXCIsXG4gICAgXCJzYXppYXRvXCIsXG4gICAgXCJzYmFkaWdsaW9cIixcbiAgICBcInNiYWx6b1wiLFxuICAgIFwic2JhbmNhdG9cIixcbiAgICBcInNiYXJyYVwiLFxuICAgIFwic2JhdHRlcmVcIixcbiAgICBcInNiYXZhcmVcIixcbiAgICBcInNiZW5kYXJlXCIsXG4gICAgXCJzYmlyY2lhcmVcIixcbiAgICBcInNibG9jY2F0b1wiLFxuICAgIFwic2JvY2NpYXRvXCIsXG4gICAgXCJzYnJpbmFyZVwiLFxuICAgIFwic2JydWZmb25lXCIsXG4gICAgXCJzYnVmZmFyZVwiLFxuICAgIFwic2NhYnJvc29cIixcbiAgICBcInNjYWRlbnphXCIsXG4gICAgXCJzY2FsYVwiLFxuICAgIFwic2NhbWJpYXJlXCIsXG4gICAgXCJzY2FuZGFsb1wiLFxuICAgIFwic2NhcG9sYVwiLFxuICAgIFwic2NhcnNvXCIsXG4gICAgXCJzY2F0ZW5hcmVcIixcbiAgICBcInNjYXZhdG9cIixcbiAgICBcInNjZWx0b1wiLFxuICAgIFwic2Nlbmljb1wiLFxuICAgIFwic2NldHRyb1wiLFxuICAgIFwic2NoZWRhXCIsXG4gICAgXCJzY2hpZW5hXCIsXG4gICAgXCJzY2lhcnBhXCIsXG4gICAgXCJzY2llbnphXCIsXG4gICAgXCJzY2luZGVyZVwiLFxuICAgIFwic2NpcHBvXCIsXG4gICAgXCJzY2lyb3Bwb1wiLFxuICAgIFwic2Npdm9sb1wiLFxuICAgIFwic2NsZXJhcmVcIixcbiAgICBcInNjb2RlbGxhXCIsXG4gICAgXCJzY29scGl0b1wiLFxuICAgIFwic2NvbXBhcnRvXCIsXG4gICAgXCJzY29uZm9ydG9cIixcbiAgICBcInNjb3ByaXJlXCIsXG4gICAgXCJzY29ydGFcIixcbiAgICBcInNjb3Nzb25lXCIsXG4gICAgXCJzY296emVzZVwiLFxuICAgIFwic2NyaWJhXCIsXG4gICAgXCJzY3JvbGxhcmVcIixcbiAgICBcInNjcnV0aW5pb1wiLFxuICAgIFwic2N1ZGVyaWFcIixcbiAgICBcInNjdWx0b3JlXCIsXG4gICAgXCJzY3VvbGFcIixcbiAgICBcInNjdXJvXCIsXG4gICAgXCJzY3VzYXJlXCIsXG4gICAgXCJzZGViaXRhcmVcIixcbiAgICBcInNkb2dhbmFyZVwiLFxuICAgIFwic2VjY2F0dXJhXCIsXG4gICAgXCJzZWNvbmRvXCIsXG4gICAgXCJzZWRhbm9cIixcbiAgICBcInNlZ2dpb2xhXCIsXG4gICAgXCJzZWduYWxhdG9cIixcbiAgICBcInNlZ3JlZ2F0b1wiLFxuICAgIFwic2VndWl0b1wiLFxuICAgIFwic2VsY2lhdG9cIixcbiAgICBcInNlbGV0dGl2b1wiLFxuICAgIFwic2VsbGFcIixcbiAgICBcInNlbHZhZ2dpb1wiLFxuICAgIFwic2VtYWZvcm9cIixcbiAgICBcInNlbWJyYXJlXCIsXG4gICAgXCJzZW1lXCIsXG4gICAgXCJzZW1pbmF0b1wiLFxuICAgIFwic2VtcHJlXCIsXG4gICAgXCJzZW5zb1wiLFxuICAgIFwic2VudGlyZVwiLFxuICAgIFwic2Vwb2x0b1wiLFxuICAgIFwic2VxdWVuemFcIixcbiAgICBcInNlcmF0YVwiLFxuICAgIFwic2VyYmF0b1wiLFxuICAgIFwic2VyZW5vXCIsXG4gICAgXCJzZXJpb1wiLFxuICAgIFwic2VycGVudGVcIixcbiAgICBcInNlcnJhZ2xpb1wiLFxuICAgIFwic2VydmlyZVwiLFxuICAgIFwic2VzdGluYVwiLFxuICAgIFwic2V0b2xhXCIsXG4gICAgXCJzZXR0aW1hbmFcIixcbiAgICBcInNmYWNlbG9cIixcbiAgICBcInNmYWxkYXJlXCIsXG4gICAgXCJzZmFtYXRvXCIsXG4gICAgXCJzZmFyem9zb1wiLFxuICAgIFwic2ZhdGljYXRvXCIsXG4gICAgXCJzZmVyYVwiLFxuICAgIFwic2ZpZGFcIixcbiAgICBcInNmaWxhdG9cIixcbiAgICBcInNmaW5nZVwiLFxuICAgIFwic2ZvY2F0b1wiLFxuICAgIFwic2ZvZGVyYXJlXCIsXG4gICAgXCJzZm9nb1wiLFxuICAgIFwic2ZvbHRpcmVcIixcbiAgICBcInNmb3J6YXRvXCIsXG4gICAgXCJzZnJhdHRvXCIsXG4gICAgXCJzZnJ1dHRhdG9cIixcbiAgICBcInNmdWdnaXRvXCIsXG4gICAgXCJzZnVtYXJlXCIsXG4gICAgXCJzZnVzb1wiLFxuICAgIFwic2dhYmVsbG9cIixcbiAgICBcInNnYXJiYXRvXCIsXG4gICAgXCJzZ29uZmlhcmVcIixcbiAgICBcInNnb3JiaW9cIixcbiAgICBcInNncmFzc2F0b1wiLFxuICAgIFwic2d1YXJkb1wiLFxuICAgIFwic2liaWxvXCIsXG4gICAgXCJzaWNjb21lXCIsXG4gICAgXCJzaWVycmFcIixcbiAgICBcInNpZ2xhXCIsXG4gICAgXCJzaWdub3JlXCIsXG4gICAgXCJzaWxlbnppb1wiLFxuICAgIFwic2lsbGFiYVwiLFxuICAgIFwic2ltYm9sb1wiLFxuICAgIFwic2ltcGF0aWNvXCIsXG4gICAgXCJzaW11bGF0b1wiLFxuICAgIFwic2luZm9uaWFcIixcbiAgICBcInNpbmdvbG9cIixcbiAgICBcInNpbmlzdHJvXCIsXG4gICAgXCJzaW5vXCIsXG4gICAgXCJzaW50ZXNpXCIsXG4gICAgXCJzaW51c29pZGVcIixcbiAgICBcInNpcGFyaW9cIixcbiAgICBcInNpc21hXCIsXG4gICAgXCJzaXN0b2xlXCIsXG4gICAgXCJzaXR1YXRvXCIsXG4gICAgXCJzbGl0dGFcIixcbiAgICBcInNsb2dhdHVyYVwiLFxuICAgIFwic2xvdmVub1wiLFxuICAgIFwic21hcnJpdG9cIixcbiAgICBcInNtZW1vcmF0b1wiLFxuICAgIFwic21lbnRpdG9cIixcbiAgICBcInNtZXJhbGRvXCIsXG4gICAgXCJzbWlsem9cIixcbiAgICBcInNtb250YXJlXCIsXG4gICAgXCJzbW90dGF0b1wiLFxuICAgIFwic211c3NhdG9cIixcbiAgICBcInNuZWxsaXJlXCIsXG4gICAgXCJzbmVydmF0b1wiLFxuICAgIFwic25vZG9cIixcbiAgICBcInNvYmJhbHpvXCIsXG4gICAgXCJzb2JyaW9cIixcbiAgICBcInNvY2NvcnNvXCIsXG4gICAgXCJzb2NpYWxlXCIsXG4gICAgXCJzb2RhbGVcIixcbiAgICBcInNvZmZpdHRvXCIsXG4gICAgXCJzb2dub1wiLFxuICAgIFwic29sZGF0b1wiLFxuICAgIFwic29sZW5uZVwiLFxuICAgIFwic29saWRvXCIsXG4gICAgXCJzb2xsYXp6b1wiLFxuICAgIFwic29sb1wiLFxuICAgIFwic29sdWJpbGVcIixcbiAgICBcInNvbHZlbnRlXCIsXG4gICAgXCJzb21hdGljb1wiLFxuICAgIFwic29tbWFcIixcbiAgICBcInNvbmRhXCIsXG4gICAgXCJzb25ldHRvXCIsXG4gICAgXCJzb25uaWZlcm9cIixcbiAgICBcInNvcGlyZVwiLFxuICAgIFwic29wcGVzb1wiLFxuICAgIFwic29wcmFcIixcbiAgICBcInNvcmdlcmVcIixcbiAgICBcInNvcnBhc3NvXCIsXG4gICAgXCJzb3JyaXNvXCIsXG4gICAgXCJzb3Jzb1wiLFxuICAgIFwic29ydGVnZ2lvXCIsXG4gICAgXCJzb3J2b2xhdG9cIixcbiAgICBcInNvc3Bpcm9cIixcbiAgICBcInNvc3RhXCIsXG4gICAgXCJzb3R0aWxlXCIsXG4gICAgXCJzcGFkYVwiLFxuICAgIFwic3BhbGxhXCIsXG4gICAgXCJzcGFyZ2VyZVwiLFxuICAgIFwic3BhdG9sYVwiLFxuICAgIFwic3BhdmVudG9cIixcbiAgICBcInNwYXp6b2xhXCIsXG4gICAgXCJzcGVjaWVcIixcbiAgICBcInNwZWRpcmVcIixcbiAgICBcInNwZWduZXJlXCIsXG4gICAgXCJzcGVsYXR1cmFcIixcbiAgICBcInNwZXJhbnphXCIsXG4gICAgXCJzcGVzc29yZVwiLFxuICAgIFwic3BldHRyYWxlXCIsXG4gICAgXCJzcGV6emF0b1wiLFxuICAgIFwic3BpYVwiLFxuICAgIFwic3BpZ29sb3NvXCIsXG4gICAgXCJzcGlsbGF0b1wiLFxuICAgIFwic3Bpbm9zb1wiLFxuICAgIFwic3BpcmFsZVwiLFxuICAgIFwic3BsZW5kaWRvXCIsXG4gICAgXCJzcG9ydGl2b1wiLFxuICAgIFwic3Bvc29cIixcbiAgICBcInNwcmFuZ2FcIixcbiAgICBcInNwcmVjYXJlXCIsXG4gICAgXCJzcHJvbmF0b1wiLFxuICAgIFwic3BydXp6b1wiLFxuICAgIFwic3B1bnRpbm9cIixcbiAgICBcInNxdWlsbG9cIixcbiAgICBcInNyYWRpY2FyZVwiLFxuICAgIFwic3JvdG9sYXRvXCIsXG4gICAgXCJzdGFiaWxlXCIsXG4gICAgXCJzdGFjY29cIixcbiAgICBcInN0YWZmYVwiLFxuICAgIFwic3RhZ25hcmVcIixcbiAgICBcInN0YW1wYXRvXCIsXG4gICAgXCJzdGFudGlvXCIsXG4gICAgXCJzdGFybnV0b1wiLFxuICAgIFwic3Rhc2VyYVwiLFxuICAgIFwic3RhdHV0b1wiLFxuICAgIFwic3RlbG9cIixcbiAgICBcInN0ZXBwYVwiLFxuICAgIFwic3RlcnpvXCIsXG4gICAgXCJzdGlsZXR0b1wiLFxuICAgIFwic3RpbWFcIixcbiAgICBcInN0aXJwZVwiLFxuICAgIFwic3RpdmFsZVwiLFxuICAgIFwic3Rpenpvc29cIixcbiAgICBcInN0b25hdG9cIixcbiAgICBcInN0b3JpY29cIixcbiAgICBcInN0cmFwcG9cIixcbiAgICBcInN0cmVnYXRvXCIsXG4gICAgXCJzdHJpZHVsb1wiLFxuICAgIFwic3Ryb3p6YXJlXCIsXG4gICAgXCJzdHJ1dHRvXCIsXG4gICAgXCJzdHVjY2FyZVwiLFxuICAgIFwic3R1Zm9cIixcbiAgICBcInN0dXBlbmRvXCIsXG4gICAgXCJzdWJlbnRyb1wiLFxuICAgIFwic3VjY29zb1wiLFxuICAgIFwic3Vkb3JlXCIsXG4gICAgXCJzdWdnZXJpdG9cIixcbiAgICBcInN1Z29cIixcbiAgICBcInN1bHRhbm9cIixcbiAgICBcInN1b25hcmVcIixcbiAgICBcInN1cGVyYm9cIixcbiAgICBcInN1cHBvcnRvXCIsXG4gICAgXCJzdXJnZWxhdG9cIixcbiAgICBcInN1cnJvZ2F0b1wiLFxuICAgIFwic3Vzc3Vycm9cIixcbiAgICBcInN1dHVyYVwiLFxuICAgIFwic3ZhZ2FyZVwiLFxuICAgIFwic3ZlZGVzZVwiLFxuICAgIFwic3ZlZ2xpb1wiLFxuICAgIFwic3ZlbGFyZVwiLFxuICAgIFwic3ZlbnV0b1wiLFxuICAgIFwic3ZlemlhXCIsXG4gICAgXCJzdmlsdXBwb1wiLFxuICAgIFwic3Zpc3RhXCIsXG4gICAgXCJzdml6emVyYVwiLFxuICAgIFwic3ZvbHRhXCIsXG4gICAgXCJzdnVvdGFyZVwiLFxuICAgIFwidGFiYWNjb1wiLFxuICAgIFwidGFidWxhdG9cIixcbiAgICBcInRhY2NpYXJlXCIsXG4gICAgXCJ0YWNpdHVybm9cIixcbiAgICBcInRhbGVcIixcbiAgICBcInRhbGlzbWFub1wiLFxuICAgIFwidGFtcG9uZVwiLFxuICAgIFwidGFubmlub1wiLFxuICAgIFwidGFyYVwiLFxuICAgIFwidGFyZGl2b1wiLFxuICAgIFwidGFyZ2F0b1wiLFxuICAgIFwidGFyaWZmYVwiLFxuICAgIFwidGFycGFyZVwiLFxuICAgIFwidGFydGFydWdhXCIsXG4gICAgXCJ0YXN0b1wiLFxuICAgIFwidGF0dGljb1wiLFxuICAgIFwidGF2ZXJuYVwiLFxuICAgIFwidGF2b2xhdGFcIixcbiAgICBcInRhenphXCIsXG4gICAgXCJ0ZWNhXCIsXG4gICAgXCJ0ZWNuaWNvXCIsXG4gICAgXCJ0ZWxlZm9ub1wiLFxuICAgIFwidGVtZXJhcmlvXCIsXG4gICAgXCJ0ZW1wb1wiLFxuICAgIFwidGVtdXRvXCIsXG4gICAgXCJ0ZW5kb25lXCIsXG4gICAgXCJ0ZW5lcm9cIixcbiAgICBcInRlbnNpb25lXCIsXG4gICAgXCJ0ZW50YWNvbG9cIixcbiAgICBcInRlb3JlbWFcIixcbiAgICBcInRlcm1lXCIsXG4gICAgXCJ0ZXJyYXp6b1wiLFxuICAgIFwidGVyemV0dG9cIixcbiAgICBcInRlc2lcIixcbiAgICBcInRlc3NlcmF0b1wiLFxuICAgIFwidGVzdGF0b1wiLFxuICAgIFwidGV0cm9cIixcbiAgICBcInRldHRvaWFcIixcbiAgICBcInRpZmFyZVwiLFxuICAgIFwidGlnZWxsYVwiLFxuICAgIFwidGltYnJvXCIsXG4gICAgXCJ0aW50b1wiLFxuICAgIFwidGlwaWNvXCIsXG4gICAgXCJ0aXBvZ3JhZm9cIixcbiAgICBcInRpcmFnZ2lvXCIsXG4gICAgXCJ0aXJvXCIsXG4gICAgXCJ0aXRhbmlvXCIsXG4gICAgXCJ0aXRvbG9cIixcbiAgICBcInRpdHViYW50ZVwiLFxuICAgIFwidGl6aW9cIixcbiAgICBcInRpenpvbmVcIixcbiAgICBcInRvY2NhcmVcIixcbiAgICBcInRvbGxlcmFyZVwiLFxuICAgIFwidG9sdG9cIixcbiAgICBcInRvbWJvbGFcIixcbiAgICBcInRvbW9cIixcbiAgICBcInRvbmZvXCIsXG4gICAgXCJ0b25zaWxsYVwiLFxuICAgIFwidG9wYXppb1wiLFxuICAgIFwidG9wb2xvZ2lhXCIsXG4gICAgXCJ0b3BwYVwiLFxuICAgIFwidG9yYmFcIixcbiAgICBcInRvcm5hcmVcIixcbiAgICBcInRvcnJvbmVcIixcbiAgICBcInRvcnRvcmFcIixcbiAgICBcInRvc2Nhbm9cIixcbiAgICBcInRvc3NpcmVcIixcbiAgICBcInRvc3RhdHVyYVwiLFxuICAgIFwidG90YW5vXCIsXG4gICAgXCJ0cmFib2Njb1wiLFxuICAgIFwidHJhY2hlYVwiLFxuICAgIFwidHJhZmlsYVwiLFxuICAgIFwidHJhZ2VkaWFcIixcbiAgICBcInRyYWxjaW9cIixcbiAgICBcInRyYW1vbnRvXCIsXG4gICAgXCJ0cmFuc2l0b1wiLFxuICAgIFwidHJhcGFub1wiLFxuICAgIFwidHJhcnJlXCIsXG4gICAgXCJ0cmFzbG9jb1wiLFxuICAgIFwidHJhdHRhdG9cIixcbiAgICBcInRyYXZlXCIsXG4gICAgXCJ0cmVjY2lhXCIsXG4gICAgXCJ0cmVtb2xpb1wiLFxuICAgIFwidHJlc3BvbG9cIixcbiAgICBcInRyaWJ1dG9cIixcbiAgICBcInRyaWNoZWNvXCIsXG4gICAgXCJ0cmlmb2dsaW9cIixcbiAgICBcInRyaWxsb1wiLFxuICAgIFwidHJpbmNlYVwiLFxuICAgIFwidHJpb1wiLFxuICAgIFwidHJpc3RlenphXCIsXG4gICAgXCJ0cml0dXJhdG9cIixcbiAgICBcInRyaXZlbGxhXCIsXG4gICAgXCJ0cm9tYmFcIixcbiAgICBcInRyb25vXCIsXG4gICAgXCJ0cm9wcG9cIixcbiAgICBcInRyb3R0b2xhXCIsXG4gICAgXCJ0cm92YXJlXCIsXG4gICAgXCJ0cnVjY2F0b1wiLFxuICAgIFwidHViYXR1cmFcIixcbiAgICBcInR1ZmZhdG9cIixcbiAgICBcInR1bGlwYW5vXCIsXG4gICAgXCJ0dW11bHRvXCIsXG4gICAgXCJ0dW5pc2lhXCIsXG4gICAgXCJ0dXJiYXJlXCIsXG4gICAgXCJ0dXJjaGlub1wiLFxuICAgIFwidHV0YVwiLFxuICAgIFwidHV0ZWxhXCIsXG4gICAgXCJ1YmljYXRvXCIsXG4gICAgXCJ1Y2NlbGxvXCIsXG4gICAgXCJ1Y2Npc29yZVwiLFxuICAgIFwidWRpcmVcIixcbiAgICBcInVkaXRpdm9cIixcbiAgICBcInVmZmFcIixcbiAgICBcInVmZmljaW9cIixcbiAgICBcInVndWFsZVwiLFxuICAgIFwidWxpc3NlXCIsXG4gICAgXCJ1bHRpbWF0b1wiLFxuICAgIFwidW1hbm9cIixcbiAgICBcInVtaWxlXCIsXG4gICAgXCJ1bW9yaXNtb1wiLFxuICAgIFwidW5jaW5ldHRvXCIsXG4gICAgXCJ1bmdlcmVcIixcbiAgICBcInVuZ2hlcmVzZVwiLFxuICAgIFwidW5pY29ybm9cIixcbiAgICBcInVuaWZpY2F0b1wiLFxuICAgIFwidW5pc29ub1wiLFxuICAgIFwidW5pdGFyaW9cIixcbiAgICBcInVudGVcIixcbiAgICBcInVvdm9cIixcbiAgICBcInVwdXBhXCIsXG4gICAgXCJ1cmFnYW5vXCIsXG4gICAgXCJ1cmdlbnphXCIsXG4gICAgXCJ1cmxvXCIsXG4gICAgXCJ1c2FuemFcIixcbiAgICBcInVzYXRvXCIsXG4gICAgXCJ1c2NpdG9cIixcbiAgICBcInVzaWdub2xvXCIsXG4gICAgXCJ1c3VyYWlvXCIsXG4gICAgXCJ1dGVuc2lsZVwiLFxuICAgIFwidXRpbGl6em9cIixcbiAgICBcInV0b3BpYVwiLFxuICAgIFwidmFjYW50ZVwiLFxuICAgIFwidmFjY2luYXRvXCIsXG4gICAgXCJ2YWdhYm9uZG9cIixcbiAgICBcInZhZ2xpYXRvXCIsXG4gICAgXCJ2YWxhbmdhXCIsXG4gICAgXCJ2YWxnb1wiLFxuICAgIFwidmFsaWNvXCIsXG4gICAgXCJ2YWxsZXR0YVwiLFxuICAgIFwidmFsb3Jvc29cIixcbiAgICBcInZhbHV0YXJlXCIsXG4gICAgXCJ2YWx2b2xhXCIsXG4gICAgXCJ2YW1wYXRhXCIsXG4gICAgXCJ2YW5nYXJlXCIsXG4gICAgXCJ2YW5pdG9zb1wiLFxuICAgIFwidmFub1wiLFxuICAgIFwidmFudGFnZ2lvXCIsXG4gICAgXCJ2YW52ZXJhXCIsXG4gICAgXCJ2YXBvcmVcIixcbiAgICBcInZhcmFub1wiLFxuICAgIFwidmFyY2F0b1wiLFxuICAgIFwidmFyaWFudGVcIixcbiAgICBcInZhc2NhXCIsXG4gICAgXCJ2ZWRldHRhXCIsXG4gICAgXCJ2ZWRvdmFcIixcbiAgICBcInZlZHV0b1wiLFxuICAgIFwidmVnZXRhbGVcIixcbiAgICBcInZlaWNvbG9cIixcbiAgICBcInZlbGNyb1wiLFxuICAgIFwidmVsaW5hXCIsXG4gICAgXCJ2ZWxsdXRvXCIsXG4gICAgXCJ2ZWxvY2VcIixcbiAgICBcInZlbmF0b1wiLFxuICAgIFwidmVuZGVtbWlhXCIsXG4gICAgXCJ2ZW50b1wiLFxuICAgIFwidmVyYWNlXCIsXG4gICAgXCJ2ZXJiYWxlXCIsXG4gICAgXCJ2ZXJnb2duYVwiLFxuICAgIFwidmVyaWZpY2FcIixcbiAgICBcInZlcm9cIixcbiAgICBcInZlcnJ1Y2FcIixcbiAgICBcInZlcnRpY2FsZVwiLFxuICAgIFwidmVzY2ljYVwiLFxuICAgIFwidmVzc2lsbG9cIixcbiAgICBcInZlc3RhbGVcIixcbiAgICBcInZldGVyYW5vXCIsXG4gICAgXCJ2ZXRyaW5hXCIsXG4gICAgXCJ2ZXR1c3RvXCIsXG4gICAgXCJ2aWFuZGFudGVcIixcbiAgICBcInZpYnJhbnRlXCIsXG4gICAgXCJ2aWNlbmRhXCIsXG4gICAgXCJ2aWNoaW5nb1wiLFxuICAgIFwidmljaW5hbnphXCIsXG4gICAgXCJ2aWRpbWFyZVwiLFxuICAgIFwidmlnaWxpYVwiLFxuICAgIFwidmlnbmV0b1wiLFxuICAgIFwidmlnb3JlXCIsXG4gICAgXCJ2aWxlXCIsXG4gICAgXCJ2aWxsYW5vXCIsXG4gICAgXCJ2aW1pbmlcIixcbiAgICBcInZpbmNpdG9yZVwiLFxuICAgIFwidmlvbGFcIixcbiAgICBcInZpcGVyYVwiLFxuICAgIFwidmlyZ29sYVwiLFxuICAgIFwidmlyb2xvZ29cIixcbiAgICBcInZpcnVsZW50b1wiLFxuICAgIFwidmlzY29zb1wiLFxuICAgIFwidmlzaW9uZVwiLFxuICAgIFwidmlzcG9cIixcbiAgICBcInZpc3N1dG9cIixcbiAgICBcInZpc3VyYVwiLFxuICAgIFwidml0YVwiLFxuICAgIFwidml0ZWxsb1wiLFxuICAgIFwidml0dGltYVwiLFxuICAgIFwidml2YW5kYVwiLFxuICAgIFwidml2aWRvXCIsXG4gICAgXCJ2aXppYXJlXCIsXG4gICAgXCJ2b2NlXCIsXG4gICAgXCJ2b2dhXCIsXG4gICAgXCJ2b2xhdGlsZVwiLFxuICAgIFwidm9sZXJlXCIsXG4gICAgXCJ2b2xwZVwiLFxuICAgIFwidm9yYWdpbmVcIixcbiAgICBcInZ1bGNhbm9cIixcbiAgICBcInphbXBvZ25hXCIsXG4gICAgXCJ6YW5uYVwiLFxuICAgIFwiemFwcGF0b1wiLFxuICAgIFwiemF0dGVyYVwiLFxuICAgIFwiemF2b3JyYVwiLFxuICAgIFwiemVmaXJvXCIsXG4gICAgXCJ6ZWxhbnRlXCIsXG4gICAgXCJ6ZWxvXCIsXG4gICAgXCJ6ZW56ZXJvXCIsXG4gICAgXCJ6ZXJiaW5vXCIsXG4gICAgXCJ6aWJldHRvXCIsXG4gICAgXCJ6aW5jb1wiLFxuICAgIFwiemlyY29uZVwiLFxuICAgIFwieml0dG9cIixcbiAgICBcInpvbGxhXCIsXG4gICAgXCJ6b3RpY29cIixcbiAgICBcInp1Y2NoZXJvXCIsXG4gICAgXCJ6dWZvbG9cIixcbiAgICBcInp1bHVcIixcbiAgICBcInp1cHBhXCJcbl1cbiIsIm1vZHVsZS5leHBvcnRzPVtcbiAgICBcIuGEgOGFoeGEgOGFp+GGqFwiLFxuICAgIFwi4YSA4YWh4YSB4YWz4Ya3XCIsXG4gICAgXCLhhIDhhaHhhILhhaHhhqtcIixcbiAgICBcIuGEgOGFoeGEguGFs+GGvFwiLFxuICAgIFwi4YSA4YWh4YSD4YWz4YaoXCIsXG4gICAgXCLhhIDhhaHhhIXhhbPhhI7hhbXhhrdcIixcbiAgICBcIuGEgOGFoeGEhuGFruGGt1wiLFxuICAgIFwi4YSA4YWh4YSH4YWh4Ya8XCIsXG4gICAgXCLhhIDhhaHhhInhhaHhhrxcIixcbiAgICBcIuGEgOGFoeGEieGFs+GGt1wiLFxuICAgIFwi4YSA4YWh4YSL4YWu4Yar4YSD4YWmXCIsXG4gICAgXCLhhIDhhaHhhIvhhbPhhq9cIixcbiAgICBcIuGEgOGFoeGEi+GFteGEg+GFs1wiLFxuICAgIFwi4YSA4YWh4YSL4YW14Ya4XCIsXG4gICAgXCLhhIDhhaHhhIzhhaHhhrxcIixcbiAgICBcIuGEgOGFoeGEjOGFpeGGvFwiLFxuICAgIFwi4YSA4YWh4YSM4YWp4YaoXCIsXG4gICAgXCLhhIDhhaHhhIzhha7hhqhcIixcbiAgICBcIuGEgOGFoeGGqOGEi+GFqVwiLFxuICAgIFwi4YSA4YWh4Yao4YSM4YWhXCIsXG4gICAgXCLhhIDhhaHhhqvhhIDhhafhhqhcIixcbiAgICBcIuGEgOGFoeGGq+GEh+GFrlwiLFxuICAgIFwi4YSA4YWh4Yar4YSJ4YWl4Ya4XCIsXG4gICAgXCLhhIDhhaHhhqvhhIzhhaHhhrxcIixcbiAgICBcIuGEgOGFoeGGq+GEjOGFpeGGuFwiLFxuICAgIFwi4YSA4YWh4Yar4YSR4YWh4YarXCIsXG4gICAgXCLhhIDhhaHhhq/hhIPhhbPhhrxcIixcbiAgICBcIuGEgOGFoeGGr+GEh+GFtVwiLFxuICAgIFwi4YSA4YWh4Yav4YSJ4YWi4YaoXCIsXG4gICAgXCLhhIDhhaHhhq/hhIzhhbPhhrxcIixcbiAgICBcIuGEgOGFoeGGt+GEgOGFoeGGqFwiLFxuICAgIFwi4YSA4YWh4Ya34YSA4YW1XCIsXG4gICAgXCLhhIDhhaHhhrfhhInhhalcIixcbiAgICBcIuGEgOGFoeGGt+GEieGFruGEieGFpeGGvFwiLFxuICAgIFwi4YSA4YWh4Ya34YSM4YWhXCIsXG4gICAgXCLhhIDhhaHhhrfhhIzhhaXhhrxcIixcbiAgICBcIuGEgOGFoeGGuOGEjOGFoeGEgOGFtVwiLFxuICAgIFwi4YSA4YWh4Ya84YSC4YWh4Ya3XCIsXG4gICAgXCLhhIDhhaHhhrzhhIPhhaHhhrxcIixcbiAgICBcIuGEgOGFoeGGvOGEg+GFqVwiLFxuICAgIFwi4YSA4YWh4Ya84YSF4YWn4Yao4YSS4YW1XCIsXG4gICAgXCLhhIDhhaHhhrzhhIfhhafhhqtcIixcbiAgICBcIuGEgOGFoeGGvOGEh+GFruGGqFwiLFxuICAgIFwi4YSA4YWh4Ya84YSJ4YWhXCIsXG4gICAgXCLhhIDhhaHhhrzhhInhha7hhIXhhaPhhrxcIixcbiAgICBcIuGEgOGFoeGGvOGEi+GFoeGEjOGFtVwiLFxuICAgIFwi4YSA4YWh4Ya84YSL4YWv4Yar4YSD4YWpXCIsXG4gICAgXCLhhIDhhaHhhrzhhIvhhbRcIixcbiAgICBcIuGEgOGFoeGGvOGEjOGFplwiLFxuICAgIFwi4YSA4YWh4Ya84YSM4YWpXCIsXG4gICAgXCLhhIDhhaHhh4DhhIvhhbVcIixcbiAgICBcIuGEgOGFouGEgOGFruGEheGFtVwiLFxuICAgIFwi4YSA4YWi4YSC4YWh4YSF4YW1XCIsXG4gICAgXCLhhIDhhaLhhIfhhaHhhrxcIixcbiAgICBcIuGEgOGFouGEh+GFp+GGr1wiLFxuICAgIFwi4YSA4YWi4YSJ4YWl4YarXCIsXG4gICAgXCLhhIDhhaLhhInhhaXhhrxcIixcbiAgICBcIuGEgOGFouGEi+GFteGGq1wiLFxuICAgIFwi4YSA4YWi4Yao4YSA4YWq4Yar4YSM4YWl4YaoXCIsXG4gICAgXCLhhIDhhaXhhInhhbXhhq9cIixcbiAgICBcIuGEgOGFpeGEi+GFouGGqFwiLFxuICAgIFwi4YSA4YWl4YSL4YWu4YavXCIsXG4gICAgXCLhhIDhhaXhhIzhhbXhhrpcIixcbiAgICBcIuGEgOGFpeGEkeGFruGGt1wiLFxuICAgIFwi4YSA4YWl4Yao4YSM4YWl4Ya8XCIsXG4gICAgXCLhhIDhhaXhhqvhhIDhhaHhhrxcIixcbiAgICBcIuGEgOGFpeGGq+GEhuGFruGGr1wiLFxuICAgIFwi4YSA4YWl4Yar4YSJ4YWl4YavXCIsXG4gICAgXCLhhIDhhaXhhqvhhIzhhalcIixcbiAgICBcIuGEgOGFpeGGq+GEjuGFruGGqFwiLFxuICAgIFwi4YSA4YWl4Yav4YSL4YWz4Ya3XCIsXG4gICAgXCLhhIDhhaXhhrfhhInhhaFcIixcbiAgICBcIuGEgOGFpeGGt+GEkOGFqVwiLFxuICAgIFwi4YSA4YWm4YSJ4YW14YSR4YWh4YarXCIsXG4gICAgXCLhhIDhhabhhIvhhbXhhrdcIixcbiAgICBcIuGEgOGFp+GEi+GFruGGr1wiLFxuICAgIFwi4YSA4YWn4Yar4YSS4YWiXCIsXG4gICAgXCLhhIDhhafhhq/hhIDhhapcIixcbiAgICBcIuGEgOGFp+GGr+GEgOGFruGGqFwiLFxuICAgIFwi4YSA4YWn4Yav4YSF4YWp4YarXCIsXG4gICAgXCLhhIDhhafhhq/hhInhhaXhhqhcIixcbiAgICBcIuGEgOGFp+GGr+GEieGFs+GGvFwiLFxuICAgIFwi4YSA4YWn4Yav4YSJ4YW14Ya3XCIsXG4gICAgXCLhhIDhhafhhq/hhIzhhaXhhrxcIixcbiAgICBcIuGEgOGFp+GGr+GEkuGFqeGGq1wiLFxuICAgIFwi4YSA4YWn4Ya84YSA4YWoXCIsXG4gICAgXCLhhIDhhafhhrzhhIDhhalcIixcbiAgICBcIuGEgOGFp+GGvOGEgOGFtVwiLFxuICAgIFwi4YSA4YWn4Ya84YSF4YWn4YaoXCIsXG4gICAgXCLhhIDhhafhhrzhhIfhhanhhqjhhIDhha7hhrxcIixcbiAgICBcIuGEgOGFp+GGvOGEh+GFtVwiLFxuICAgIFwi4YSA4YWn4Ya84YSJ4YWh4Ya84YSD4YWpXCIsXG4gICAgXCLhhIDhhafhhrzhhIvhhafhhrxcIixcbiAgICBcIuGEgOGFp+GGvOGEi+GFrlwiLFxuICAgIFwi4YSA4YWn4Ya84YSM4YWi4Ya8XCIsXG4gICAgXCLhhIDhhafhhrzhhIzhhaZcIixcbiAgICBcIuGEgOGFp+GGvOGEjOGFrlwiLFxuICAgIFwi4YSA4YWn4Ya84YSO4YWh4YavXCIsXG4gICAgXCLhhIDhhafhhrzhhI7hhbVcIixcbiAgICBcIuGEgOGFp+GGvOGEkuGFo+GGvFwiLFxuICAgIFwi4YSA4YWn4Ya84YSS4YWl4Ya3XCIsXG4gICAgXCLhhIDhhajhhIDhhanhhqhcIixcbiAgICBcIuGEgOGFqOGEg+GFoeGGq1wiLFxuICAgIFwi4YSA4YWo4YSF4YWh4YarXCIsXG4gICAgXCLhhIDhhajhhInhhaHhhqtcIixcbiAgICBcIuGEgOGFqOGEieGFqeGGqFwiLFxuICAgIFwi4YSA4YWo4YSL4YWj4YaoXCIsXG4gICAgXCLhhIDhhajhhIzhhaXhhq9cIixcbiAgICBcIuGEgOGFqOGEjuGFs+GGvFwiLFxuICAgIFwi4YSA4YWo4YSS4YWs4YaoXCIsXG4gICAgXCLhhIDhhanhhIDhhaLhhqhcIixcbiAgICBcIuGEgOGFqeGEgOGFruGEheGFp1wiLFxuICAgIFwi4YSA4YWp4YSA4YWu4Ya8XCIsXG4gICAgXCLhhIDhhanhhIDhhbPhhrhcIixcbiAgICBcIuGEgOGFqeGEg+GFs+GGvOGEkuGFoeGGqOGEieGFouGGvFwiLFxuICAgIFwi4YSA4YWp4YSG4YWu4YSJ4YW14YarXCIsXG4gICAgXCLhhIDhhanhhIbhhbXhhqtcIixcbiAgICBcIuGEgOGFqeGEi+GFo+GGvOGEi+GFtVwiLFxuICAgIFwi4YSA4YWp4YSM4YWh4Ya8XCIsXG4gICAgXCLhhIDhhanhhIzhhaXhhqtcIixcbiAgICBcIuGEgOGFqeGEjOGFteGGuFwiLFxuICAgIFwi4YSA4YWp4YSO4YWu4Ya64YSA4YWh4YSF4YWuXCIsXG4gICAgXCLhhIDhhanhhJDhhanhhrxcIixcbiAgICBcIuGEgOGFqeGEkuGFo+GGvFwiLFxuICAgIFwi4YSA4YWp4Yao4YSJ4YW14YaoXCIsXG4gICAgXCLhhIDhhanhhq/hhIbhhanhhqhcIixcbiAgICBcIuGEgOGFqeGGr+GEjeGFoeGEgOGFtVwiLFxuICAgIFwi4YSA4YWp4Yav4YSR4YWzXCIsXG4gICAgXCLhhIDhhanhhrzhhIDhhaHhhqtcIixcbiAgICBcIuGEgOGFqeGGvOGEgOGFolwiLFxuICAgIFwi4YSA4YWp4Ya84YSA4YWn4YaoXCIsXG4gICAgXCLhhIDhhanhhrzhhIDhha7hhqtcIixcbiAgICBcIuGEgOGFqeGGvOGEgOGFs+GGuFwiLFxuICAgIFwi4YSA4YWp4Ya84YSA4YW1XCIsXG4gICAgXCLhhIDhhanhhrzhhIPhhanhhrxcIixcbiAgICBcIuGEgOGFqeGGvOGEhuGFruGEi+GFr+GGq1wiLFxuICAgIFwi4YSA4YWp4Ya84YSH4YWuXCIsXG4gICAgXCLhhIDhhanhhrzhhInhhaFcIixcbiAgICBcIuGEgOGFqeGGvOGEieGFteGGqFwiLFxuICAgIFwi4YSA4YWp4Ya84YSL4YWl4Ya4XCIsXG4gICAgXCLhhIDhhanhhrzhhIvhhafhhqtcIixcbiAgICBcIuGEgOGFqeGGvOGEi+GFr+GGq1wiLFxuICAgIFwi4YSA4YWp4Ya84YSM4YWh4Ya8XCIsXG4gICAgXCLhhIDhhanhhrzhhI3hhaFcIixcbiAgICBcIuGEgOGFqeGGvOGEjuGFouGGqFwiLFxuICAgIFwi4YSA4YWp4Ya84YSQ4YWp4Ya8XCIsXG4gICAgXCLhhIDhhanhhrzhhJHhhalcIixcbiAgICBcIuGEgOGFqeGGvOGEkuGFoeGGvFwiLFxuICAgIFwi4YSA4YWp4Ya84YSS4YWy4YSL4YW14YavXCIsXG4gICAgXCLhhIDhharhhIbhhanhhqhcIixcbiAgICBcIuGEgOGFquGEi+GFteGGr1wiLFxuICAgIFwi4YSA4YWq4YSM4YWh4Ya8XCIsXG4gICAgXCLhhIDhharhhIzhhaXhhrxcIixcbiAgICBcIuGEgOGFquGEkuGFoeGGqFwiLFxuICAgIFwi4YSA4YWq4Yar4YSA4YWi4YaoXCIsXG4gICAgXCLhhIDhharhhqvhhIDhhahcIixcbiAgICBcIuGEgOGFquGGq+GEgOGFquGGvFwiLFxuICAgIFwi4YSA4YWq4Yar4YSC4YWn4Ya3XCIsXG4gICAgXCLhhIDhharhhqvhhIXhhaHhhrdcIixcbiAgICBcIuGEgOGFquGGq+GEheGFp+GGq1wiLFxuICAgIFwi4YSA4YWq4Yar4YSF4YW1XCIsXG4gICAgXCLhhIDhharhhqvhhInhhbPhhrhcIixcbiAgICBcIuGEgOGFquGGq+GEieGFteGGt1wiLFxuICAgIFwi4YSA4YWq4Yar4YSM4YWl4Ya3XCIsXG4gICAgXCLhhIDhharhhqvhhI7hhaHhhq9cIixcbiAgICBcIuGEgOGFquGGvOGEgOGFp+GGvFwiLFxuICAgIFwi4YSA4YWq4Ya84YSA4YWpXCIsXG4gICAgXCLhhIDhharhhrzhhIzhhaHhhrxcIixcbiAgICBcIuGEgOGFquGGvOGEjOGFrlwiLFxuICAgIFwi4YSA4YWs4YSF4YWp4YSL4YWu4Ya3XCIsXG4gICAgXCLhhIDhhazhhrzhhIzhhaHhhrzhhJLhhbVcIixcbiAgICBcIuGEgOGFreGEgOGFquGEieGFpVwiLFxuICAgIFwi4YSA4YWt4YSG4YWu4YarXCIsXG4gICAgXCLhhIDhha3hhIfhhanhhqhcIixcbiAgICBcIuGEgOGFreGEieGFteGGr1wiLFxuICAgIFwi4YSA4YWt4YSL4YWj4Ya8XCIsXG4gICAgXCLhhIDhha3hhIvhhbLhhqhcIixcbiAgICBcIuGEgOGFreGEjOGFoeGGvFwiLFxuICAgIFwi4YSA4YWt4YSM4YW14YaoXCIsXG4gICAgXCLhhIDhha3hhJDhhanhhrxcIixcbiAgICBcIuGEgOGFreGEkuGFquGGq1wiLFxuICAgIFwi4YSA4YWt4YSS4YWu4YarXCIsXG4gICAgXCLhhIDhha7hhIDhhafhhrxcIixcbiAgICBcIuGEgOGFruGEheGFs+GGt1wiLFxuICAgIFwi4YSA4YWu4YSG4YWl4Ya8XCIsXG4gICAgXCLhhIDhha7hhIfhhafhhq9cIixcbiAgICBcIuGEgOGFruGEh+GFruGGq1wiLFxuICAgIFwi4YSA4YWu4YSJ4YWl4YaoXCIsXG4gICAgXCLhhIDhha7hhInhhaXhhrxcIixcbiAgICBcIuGEgOGFruGEieGFqeGGqFwiLFxuICAgIFwi4YSA4YWu4YSL4YWn4YaoXCIsXG4gICAgXCLhhIDhha7hhIvhhbXhhrhcIixcbiAgICBcIuGEgOGFruGEjuGFpeGGvFwiLFxuICAgIFwi4YSA4YWu4YSO4YWm4YSM4YWl4YaoXCIsXG4gICAgXCLhhIDhha7hhqjhhIDhhaFcIixcbiAgICBcIuGEgOGFruGGqOGEgOGFtVwiLFxuICAgIFwi4YSA4YWu4Yao4YSC4YWiXCIsXG4gICAgXCLhhIDhha7hhqjhhIXhhbXhhrhcIixcbiAgICBcIuGEgOGFruGGqOGEhuGFruGGr1wiLFxuICAgIFwi4YSA4YWu4Yao4YSG4YW14YarXCIsXG4gICAgXCLhhIDhha7hhqjhhInhha5cIixcbiAgICBcIuGEgOGFruGGqOGEi+GFpVwiLFxuICAgIFwi4YSA4YWu4Yao4YSL4YWq4Ya8XCIsXG4gICAgXCLhhIDhha7hhqjhhIzhhaXhhqhcIixcbiAgICBcIuGEgOGFruGGqOGEjOGFplwiLFxuICAgIFwi4YSA4YWu4Yao4YSS4YWsXCIsXG4gICAgXCLhhIDhha7hhqvhhIPhhaJcIixcbiAgICBcIuGEgOGFruGGq+GEieGFoVwiLFxuICAgIFwi4YSA4YWu4Yar4YSL4YW14YarXCIsXG4gICAgXCLhhIDhha7hhrzhhIDhhbPhhqjhhIzhhaXhhqhcIixcbiAgICBcIuGEgOGFr+GGq+GEheGFtVwiLFxuICAgIFwi4YSA4YWv4Yar4YSL4YWxXCIsXG4gICAgXCLhhIDhha/hhqvhhJDhha5cIixcbiAgICBcIuGEgOGFseGEgOGFruGGqFwiLFxuICAgIFwi4YSA4YWx4YSJ4YW14YarXCIsXG4gICAgXCLhhIDhhbLhhIzhhaXhhrxcIixcbiAgICBcIuGEgOGFsuGEjuGFteGGqFwiLFxuICAgIFwi4YSA4YWy4Yar4YSS4YWn4Ya8XCIsXG4gICAgXCLhhIDhhbPhhILhhaHhhq9cIixcbiAgICBcIuGEgOGFs+GEguGFo+GGvFwiLFxuICAgIFwi4YSA4YWz4YSC4YWz4YavXCIsXG4gICAgXCLhhIDhhbPhhIXhhaXhhILhhaFcIixcbiAgICBcIuGEgOGFs+GEheGFruGGuFwiLFxuICAgIFwi4YSA4YWz4YSF4YWz4Ya6XCIsXG4gICAgXCLhhIDhhbPhhIXhhbXhhrdcIixcbiAgICBcIuGEgOGFs+GEjOGFpuGEieGFpeGEi+GFo1wiLFxuICAgIFwi4YSA4YWz4YSQ4YWp4YSF4YWp4YaoXCIsXG4gICAgXCLhhIDhhbPhhqjhhIfhhanhhqhcIixcbiAgICBcIuGEgOGFs+GGqOGEkuGFtVwiLFxuICAgIFwi4YSA4YWz4Yar4YSA4YWlXCIsXG4gICAgXCLhhIDhhbPhhqvhhIDhha1cIixcbiAgICBcIuGEgOGFs+GGq+GEheGFolwiLFxuICAgIFwi4YSA4YWz4Yar4YSF4YWpXCIsXG4gICAgXCLhhIDhhbPhhqvhhIbhha5cIixcbiAgICBcIuGEgOGFs+GGq+GEh+GFqeGGq1wiLFxuICAgIFwi4YSA4YWz4Yar4YSL4YWv4YarXCIsXG4gICAgXCLhhIDhhbPhhqvhhIvhhbLhhqhcIixcbiAgICBcIuGEgOGFs+GGq+GEjuGFpVwiLFxuICAgIFwi4YSA4YWz4Yav4YSK4YW1XCIsXG4gICAgXCLhhIDhhbPhhq/hhIzhhaFcIixcbiAgICBcIuGEgOGFs+GGt+GEgOGFoeGGvOGEieGFoeGGq1wiLFxuICAgIFwi4YSA4YWz4Ya34YSA4YWpXCIsXG4gICAgXCLhhIDhhbPhhrfhhILhhafhhqtcIixcbiAgICBcIuGEgOGFs+GGt+GEhuGFpuGEg+GFoeGGr1wiLFxuICAgIFwi4YSA4YWz4Ya34YSL4YWi4YaoXCIsXG4gICAgXCLhhIDhhbPhhrfhhIvhhafhhqtcIixcbiAgICBcIuGEgOGFs+GGt+GEi+GFreGEi+GFteGGr1wiLFxuICAgIFwi4YSA4YWz4Ya34YSM4YW1XCIsXG4gICAgXCLhhIDhhbPhhrzhhIzhhaXhhrzhhIzhhaXhhqhcIixcbiAgICBcIuGEgOGFteGEgOGFoeGGq1wiLFxuICAgIFwi4YSA4YW14YSA4YWq4YarXCIsXG4gICAgXCLhhIDhhbXhhILhhafhhrdcIixcbiAgICBcIuGEgOGFteGEguGFs+GGvFwiLFxuICAgIFwi4YSA4YW14YSD4YWp4Yao4YSA4YWtXCIsXG4gICAgXCLhhIDhhbXhhIPhha7hhrxcIixcbiAgICBcIuGEgOGFteGEheGFqeGGqFwiLFxuICAgIFwi4YSA4YW14YSF4YWz4Ya3XCIsXG4gICAgXCLhhIDhhbXhhIfhhaXhhrhcIixcbiAgICBcIuGEgOGFteGEh+GFqeGGq1wiLFxuICAgIFwi4YSA4YW14YSH4YWu4YarXCIsXG4gICAgXCLhhIDhhbXhhIjhhbPhhrdcIixcbiAgICBcIuGEgOGFteGEieGFruGGqOGEieGFoVwiLFxuICAgIFwi4YSA4YW14YSJ4YWu4YavXCIsXG4gICAgXCLhhIDhhbXhhIvhhaXhhqhcIixcbiAgICBcIuGEgOGFteGEi+GFpeGGuFwiLFxuICAgIFwi4YSA4YW14YSL4YWp4YarXCIsXG4gICAgXCLhhIDhhbXhhIvhha7hhqtcIixcbiAgICBcIuGEgOGFteGEi+GFr+GGq1wiLFxuICAgIFwi4YSA4YW14YSM4YWl4YaoXCIsXG4gICAgXCLhhIDhhbXhhIzhha7hhqtcIixcbiAgICBcIuGEgOGFteGEjuGFteGGt1wiLFxuICAgIFwi4YSA4YW14YSS4YWp4YarXCIsXG4gICAgXCLhhIDhhbXhhJLhhazhhqhcIixcbiAgICBcIuGEgOGFteGGq+GEgOGFs+GGuFwiLFxuICAgIFwi4YSA4YW14Yar4YSM4YWh4Ya8XCIsXG4gICAgXCLhhIDhhbXhhq/hhIvhhbVcIixcbiAgICBcIuGEgOGFteGGt+GEh+GFoeGGuFwiLFxuICAgIFwi4YSA4YW14Ya34YSO4YW1XCIsXG4gICAgXCLhhIDhhbXhhrfhhJHhhanhhIDhhanhhrzhhJLhhaHhhrxcIixcbiAgICBcIuGEgeGFoeGGqOGEg+GFruGEgOGFtVwiLFxuICAgIFwi4YSB4YWh4Ya34YSI4YWh4YaoXCIsXG4gICAgXCLhhIHhhaLhhIPhhaHhhq/hhIvhhbPhhrdcIixcbiAgICBcIuGEgeGFouGEieGFqeGEgOGFs+GGt1wiLFxuICAgIFwi4YSB4YWl4Ya44YSM4YW14YavXCIsXG4gICAgXCLhhIHhhanhhqjhhIPhhaLhhIDhhbVcIixcbiAgICBcIuGEgeGFqeGGvuGEi+GFteGHgVwiLFxuICAgIFwi4YSC4YWh4YSD4YWz4Yav4YSL4YW1XCIsXG4gICAgXCLhhILhhaHhhIXhhaHhhqvhhJLhhbVcIixcbiAgICBcIuGEguGFoeGEhuGFpeGEjOGFtVwiLFxuICAgIFwi4YSC4YWh4YSG4YWu4YavXCIsXG4gICAgXCLhhILhhaHhhI7hhbXhhrfhhIfhhaHhhqtcIixcbiAgICBcIuGEguGFoeGEkuGFs+GGr1wiLFxuICAgIFwi4YSC4YWh4Yao4YSL4YWn4Ya4XCIsXG4gICAgXCLhhILhhaHhhqvhhIfhhaHhhrxcIixcbiAgICBcIuGEguGFoeGGr+GEgOGFolwiLFxuICAgIFwi4YSC4YWh4Yav4YSK4YW1XCIsXG4gICAgXCLhhILhhaHhhq/hhI3hhaFcIixcbiAgICBcIuGEguGFoeGGt+GEguGFp1wiLFxuICAgIFwi4YSC4YWh4Ya34YSD4YWi4YSG4YWu4YarXCIsXG4gICAgXCLhhILhhaHhhrfhhIbhhaJcIixcbiAgICBcIuGEguGFoeGGt+GEieGFoeGGq1wiLFxuICAgIFwi4YSC4YWh4Ya34YSM4YWhXCIsXG4gICAgXCLhhILhhaHhhrfhhJHhhafhhqtcIixcbiAgICBcIuGEguGFoeGGt+GEkuGFoeGGqOGEieGFouGGvFwiLFxuICAgIFwi4YSC4YWh4Ya84YSH4YW1XCIsXG4gICAgXCLhhILhhaHhh4DhhIbhhaHhhq9cIixcbiAgICBcIuGEguGFouGEguGFp+GGq1wiLFxuICAgIFwi4YSC4YWi4YSL4YWt4Ya8XCIsXG4gICAgXCLhhILhhaLhhIvhhbXhhq9cIixcbiAgICBcIuGEguGFouGGt+GEh+GFtVwiLFxuICAgIFwi4YSC4YWi4Ya34YSJ4YWiXCIsXG4gICAgXCLhhILhhaLhhrrhhIbhha7hhq9cIixcbiAgICBcIuGEguGFouGGvOGEg+GFqeGGvFwiLFxuICAgIFwi4YSC4YWi4Ya84YSG4YWn4YarXCIsXG4gICAgXCLhhILhhaLhhrzhhIfhhaHhhrxcIixcbiAgICBcIuGEguGFouGGvOGEjOGFoeGGvOGEgOGFqVwiLFxuICAgIFwi4YSC4YWm4Yao4YSQ4YWh4YSL4YW1XCIsXG4gICAgXCLhhILhhabhhrrhhI3hhaJcIixcbiAgICBcIuGEguGFqeGEg+GFqeGGvFwiLFxuICAgIFwi4YSC4YWp4YSF4YWh4Yar4YSJ4YWi4YaoXCIsXG4gICAgXCLhhILhhanhhIXhhafhhqhcIixcbiAgICBcIuGEguGFqeGEi+GFteGGq1wiLFxuICAgIFwi4YSC4YWp4Yao4YSL4YWz4Ya3XCIsXG4gICAgXCLhhILhhanhhqjhhI7hhaFcIixcbiAgICBcIuGEguGFqeGGqOGEkuGFqlwiLFxuICAgIFwi4YSC4YWp4Yar4YSF4YW1XCIsXG4gICAgXCLhhILhhanhhqvhhIbhha7hhqtcIixcbiAgICBcIuGEguGFqeGGq+GEjOGFouGGvFwiLFxuICAgIFwi4YSC4YWp4Yav4YSL4YW1XCIsXG4gICAgXCLhhILhhanhhrzhhIDhha5cIixcbiAgICBcIuGEguGFqeGGvOGEg+GFoeGGt1wiLFxuICAgIFwi4YSC4YWp4Ya84YSG4YW14YarXCIsXG4gICAgXCLhhILhhanhhrzhhIfhha5cIixcbiAgICBcIuGEguGFqeGGvOGEi+GFpeGGuFwiLFxuICAgIFwi4YSC4YWp4Ya84YSM4YWh4Ya8XCIsXG4gICAgXCLhhILhhanhhrzhhI7hhanhhqtcIixcbiAgICBcIuGEguGFqeGHgeGEi+GFtVwiLFxuICAgIFwi4YSC4YWu4Yar4YSD4YWp4Ya84YSM4YWhXCIsXG4gICAgXCLhhILhha7hhqvhhIbhha7hhq9cIixcbiAgICBcIuGEguGFruGGq+GEiuGFpeGGuFwiLFxuICAgIFwi4YSC4YWy4YSL4YWt4YaoXCIsXG4gICAgXCLhhILhhbPhhIHhhbXhhrdcIixcbiAgICBcIuGEguGFs+GGqOGEg+GFolwiLFxuICAgIFwi4YSC4YWz4Ya84YSD4YWp4Ya84YSM4YWl4YaoXCIsXG4gICAgXCLhhILhhbPhhrzhhIXhhafhhqhcIixcbiAgICBcIuGEg+GFoeGEh+GFoeGGvFwiLFxuICAgIFwi4YSD4YWh4YSL4YWj4Ya84YSJ4YWl4Ya8XCIsXG4gICAgXCLhhIPhhaHhhIvhhbPhhrdcIixcbiAgICBcIuGEg+GFoeGEi+GFteGEi+GFpeGEkOGFs1wiLFxuICAgIFwi4YSD4YWh4YSS4YWi4Ya8XCIsXG4gICAgXCLhhIPhhaHhhqvhhIDhhahcIixcbiAgICBcIuGEg+GFoeGGq+GEgOGFqeGGr1wiLFxuICAgIFwi4YSD4YWh4Yar4YSD4YWp4YaoXCIsXG4gICAgXCLhhIPhhaHhhqvhhIbhhaHhhrpcIixcbiAgICBcIuGEg+GFoeGGq+GEieGFruGGq1wiLFxuICAgIFwi4YSD4YWh4Yar4YSL4YWlXCIsXG4gICAgXCLhhIPhhaHhhqvhhIvhhbFcIixcbiAgICBcIuGEg+GFoeGGq+GEjOGFpeGGt1wiLFxuICAgIFwi4YSD4YWh4Yar4YSO4YWmXCIsXG4gICAgXCLhhIPhhaHhhqvhhI7hha5cIixcbiAgICBcIuGEg+GFoeGGq+GEkeGFp+GGq1wiLFxuICAgIFwi4YSD4YWh4Yar4YSR4YWu4Ya8XCIsXG4gICAgXCLhhIPhhaHhhq/hhIDhhaPhhq9cIixcbiAgICBcIuGEg+GFoeGGr+GEheGFpVwiLFxuICAgIFwi4YSD4YWh4Yav4YSF4YWn4YaoXCIsXG4gICAgXCLhhIPhhaHhhq/hhIXhhbVcIixcbiAgICBcIuGEg+GFoeGGsOGEgOGFqeGEgOGFtVwiLFxuICAgIFwi4YSD4YWh4Ya34YSD4YWh4Ya8XCIsXG4gICAgXCLhhIPhhaHhhrfhhIfhhaJcIixcbiAgICBcIuGEg+GFoeGGt+GEi+GFrVwiLFxuICAgIFwi4YSD4YWh4Ya34YSL4YW14Ya3XCIsXG4gICAgXCLhhIPhhaHhhrjhhIfhhafhhqtcIixcbiAgICBcIuGEg+GFoeGGuOGEjOGFoeGGvFwiLFxuICAgIFwi4YSD4YWh4Ya84YSA4YWz4YarXCIsXG4gICAgXCLhhIPhhaHhhrzhhIfhha7hhqvhhIDhhaHhhqtcIixcbiAgICBcIuGEg+GFoeGGvOGEi+GFp+GGq+GEkuGFtVwiLFxuICAgIFwi4YSD4YWh4Ya84YSM4YWh4Ya8XCIsXG4gICAgXCLhhIPhhaLhhIDhhbLhhIbhhalcIixcbiAgICBcIuGEg+GFouGEguGFoeGGvVwiLFxuICAgIFwi4YSD4YWi4YSD4YWh4Yar4YSS4YW1XCIsXG4gICAgXCLhhIPhhaLhhIPhhaHhhrhcIixcbiAgICBcIuGEg+GFouGEg+GFqeGEieGFtVwiLFxuICAgIFwi4YSD4YWi4YSF4YWj4YaoXCIsXG4gICAgXCLhhIPhhaLhhIXhhaPhhrxcIixcbiAgICBcIuGEg+GFouGEheGFsuGGqFwiLFxuICAgIFwi4YSD4YWi4YSG4YWu4YarXCIsXG4gICAgXCLhhIPhhaLhhIfhha7hhIfhha7hhqtcIixcbiAgICBcIuGEg+GFouGEieGFteGGq1wiLFxuICAgIFwi4YSD4YWi4YSL4YWz4Ya8XCIsXG4gICAgXCLhhIPhhaLhhIzhhaHhhrxcIixcbiAgICBcIuGEg+GFouGEjOGFpeGGq1wiLFxuICAgIFwi4YSD4YWi4YSM4YWl4Ya4XCIsXG4gICAgXCLhhIPhhaLhhIzhha7hhrxcIixcbiAgICBcIuGEg+GFouGEjuGFouGGqFwiLFxuICAgIFwi4YSD4YWi4YSO4YWu4YavXCIsXG4gICAgXCLhhIPhhaLhhI7hha7hhrxcIixcbiAgICBcIuGEg+GFouGEkOGFqeGGvOGEheGFp+GGvFwiLFxuICAgIFwi4YSD4YWi4YSS4YWh4YaoXCIsXG4gICAgXCLhhIPhhaLhhJLhhaHhhqvhhIbhhbXhhqvhhIDhha7hhqhcIixcbiAgICBcIuGEg+GFouGEkuGFoeGGuOGEieGFteGGr1wiLFxuICAgIFwi4YSD4YWi4YSS4YWn4Ya8XCIsXG4gICAgXCLhhIPhhaXhhrzhhIvhhaXhhIXhhbVcIixcbiAgICBcIuGEg+GFpuGEi+GFteGEkOGFs1wiLFxuICAgIFwi4YSD4YWp4YSD4YWi4YSO4YWmXCIsXG4gICAgXCLhhIPhhanhhIPhhaXhhqhcIixcbiAgICBcIuGEg+GFqeGEg+GFruGGqFwiLFxuICAgIFwi4YSD4YWp4YSG4YWh4Ya8XCIsXG4gICAgXCLhhIPhhanhhInhhaXhhIDhharhhqtcIixcbiAgICBcIuGEg+GFqeGEieGFteGGt1wiLFxuICAgIFwi4YSD4YWp4YSL4YWu4Ya3XCIsXG4gICAgXCLhhIPhhanhhIvhhbXhhrhcIixcbiAgICBcIuGEg+GFqeGEjOGFoeGEgOGFtVwiLFxuICAgIFwi4YSD4YWp4YSM4YWl4YSS4YW1XCIsXG4gICAgXCLhhIPhhanhhIzhhaXhhqtcIixcbiAgICBcIuGEg+GFqeGEjOGFruGGvFwiLFxuICAgIFwi4YSD4YWp4YSO4YWh4YaoXCIsXG4gICAgXCLhhIPhhanhhqjhhIDhhaHhhrdcIixcbiAgICBcIuGEg+GFqeGGqOGEheGFteGGuFwiLFxuICAgIFwi4YSD4YWp4Yao4YSJ4YWlXCIsXG4gICAgXCLhhIPhhanhhqjhhIvhhbXhhq9cIixcbiAgICBcIuGEg+GFqeGGqOGEjuGFoeGGvOGEjOGFpeGGqFwiLFxuICAgIFwi4YSD4YWp4Ya84YSS4YWq4YSO4YWi4YaoXCIsXG4gICAgXCLhhIPhhbHhhrrhhIbhhanhhInhhbPhhrhcIixcbiAgICBcIuGEg+GFseGGuuGEieGFoeGGq1wiLFxuICAgIFwi4YSE4YWh4Yav4YSL4YWh4YSL4YW1XCIsXG4gICAgXCLhhIbhhaHhhILhha7hhIXhhaFcIixcbiAgICBcIuGEhuGFoeGEguGFs+GGr1wiLFxuICAgIFwi4YSG4YWh4YSD4YWh4Ya8XCIsXG4gICAgXCLhhIbhhaHhhIXhhaHhhJDhhanhhqtcIixcbiAgICBcIuGEhuGFoeGEheGFp+GGq1wiLFxuICAgIFwi4YSG4YWh4YSG4YWu4YSF4YW1XCIsXG4gICAgXCLhhIbhhaHhhInhhaHhhIzhhbVcIixcbiAgICBcIuGEhuGFoeGEi+GFo+GGqFwiLFxuICAgIFwi4YSG4YWh4YSL4YWt4YSC4YWm4YSM4YWzXCIsXG4gICAgXCLhhIbhhaHhhIvhhbPhhq9cIixcbiAgICBcIuGEhuGFoeGEi+GFs+GGt1wiLFxuICAgIFwi4YSG4YWh4YSL4YW14YSP4YWzXCIsXG4gICAgXCLhhIbhhaHhhIzhha7hhrxcIixcbiAgICBcIuGEhuGFoeGEjOGFteGEhuGFoeGGqFwiLFxuICAgIFwi4YSG4YWh4YSO4YWh4Yar4YSA4YWh4YSM4YW1XCIsXG4gICAgXCLhhIbhhaHhhI7hhaHhhq9cIixcbiAgICBcIuGEhuGFoeGEkuGFs+GGq1wiLFxuICAgIFwi4YSG4YWh4Yao4YSA4YWl4Yav4YSF4YW1XCIsXG4gICAgXCLhhIbhhaHhhqjhhILhhaJcIixcbiAgICBcIuGEhuGFoeGGqOGEieGFoeGGvFwiLFxuICAgIFwi4YSG4YWh4Yar4YSC4YWh4Ya3XCIsXG4gICAgXCLhhIbhhaHhhqvhhIPhha5cIixcbiAgICBcIuGEhuGFoeGGq+GEieGFplwiLFxuICAgIFwi4YSG4YWh4Yar4YSL4YWj4YaoXCIsXG4gICAgXCLhhIbhhaHhhqvhhIvhhbXhhq9cIixcbiAgICBcIuGEhuGFoeGGq+GEjOGFpeGGt1wiLFxuICAgIFwi4YSG4YWh4Yar4YSM4YWp4YaoXCIsXG4gICAgXCLhhIbhhaHhhqvhhJLhhapcIixcbiAgICBcIuGEhuGFoeGGreGEi+GFtVwiLFxuICAgIFwi4YSG4YWh4Yav4YSA4YW1XCIsXG4gICAgXCLhhIbhhaHhhq/hhIrhhbPhhrdcIixcbiAgICBcIuGEhuGFoeGGr+GEkOGFrlwiLFxuICAgIFwi4YSG4YWh4Ya34YSD4YWi4YSF4YWpXCIsXG4gICAgXCLhhIbhhaHhhrzhhIvhha/hhqvhhIDhhafhhrxcIixcbiAgICBcIuGEhuGFouGEguGFp+GGq1wiLFxuICAgIFwi4YSG4YWi4YSD4YWh4YavXCIsXG4gICAgXCLhhIbhhaLhhIXhhafhhqhcIixcbiAgICBcIuGEhuGFouGEh+GFpeGGq1wiLFxuICAgIFwi4YSG4YWi4YSJ4YWz4YSP4YWl4Ya3XCIsXG4gICAgXCLhhIbhhaLhhIvhhbXhhq9cIixcbiAgICBcIuGEhuGFouGEjOGFoeGGvFwiLFxuICAgIFwi4YSG4YWi4Yao4YSM4YWuXCIsXG4gICAgXCLhhIbhhaXhhqjhhIvhhbVcIixcbiAgICBcIuGEhuGFpeGGq+GEjOGFpVwiLFxuICAgIFwi4YSG4YWl4Yar4YSM4YW1XCIsXG4gICAgXCLhhIbhhaXhhq/hhIXhhbVcIixcbiAgICBcIuGEhuGFpuGEi+GFteGGr1wiLFxuICAgIFwi4YSG4YWn4YSC4YWz4YSF4YW1XCIsXG4gICAgXCLhhIbhhafhhI7hhbXhhq9cIixcbiAgICBcIuGEhuGFp+GGq+GEg+GFoeGGt1wiLFxuICAgIFwi4YSG4YWn4Yav4YSO4YW1XCIsXG4gICAgXCLhhIbhhafhhrzhhIPhhaHhhqtcIixcbiAgICBcIuGEhuGFp+GGvOGEheGFp+GGvFwiLFxuICAgIFwi4YSG4YWn4Ya84YSL4YWoXCIsXG4gICAgXCLhhIbhhafhhrzhhIvhhbRcIixcbiAgICBcIuGEhuGFp+GGvOGEjOGFpeGGr1wiLFxuICAgIFwi4YSG4YWn4Ya84YSO4YW14Ya8XCIsXG4gICAgXCLhhIbhhafhhrzhhJLhhaHhhrdcIixcbiAgICBcIuGEhuGFqeGEgOGFs+GGt1wiLFxuICAgIFwi4YSG4YWp4YSC4YW14YSQ4YWlXCIsXG4gICAgXCLhhIbhhanhhIPhhabhhq9cIixcbiAgICBcIuGEhuGFqeGEg+GFs+GGq1wiLFxuICAgIFwi4YSG4YWp4YSH4YWl4Ya3XCIsXG4gICAgXCLhhIbhhanhhInhhbPhhrhcIixcbiAgICBcIuGEhuGFqeGEi+GFo+GGvFwiLFxuICAgIFwi4YSG4YWp4YSL4YW14Ya3XCIsXG4gICAgXCLhhIbhhanhhIzhhanhhIXhhbVcIixcbiAgICBcIuGEhuGFqeGEjOGFteGGuFwiLFxuICAgIFwi4YSG4YWp4YSQ4YWu4Ya84YSL4YW1XCIsXG4gICAgXCLhhIbhhanhhqjhhIDhhaXhhq/hhIvhhbVcIixcbiAgICBcIuGEhuGFqeGGqOGEheGFqeGGqFwiLFxuICAgIFwi4YSG4YWp4Yao4YSJ4YWhXCIsXG4gICAgXCLhhIbhhanhhqjhhInhhanhhIXhhbVcIixcbiAgICBcIuGEhuGFqeGGqOGEieGFruGGt1wiLFxuICAgIFwi4YSG4YWp4Yao4YSM4YWl4YaoXCIsXG4gICAgXCLhhIbhhanhhqjhhJHhha1cIixcbiAgICBcIuGEhuGFqeGGr+GEheGFolwiLFxuICAgIFwi4YSG4YWp4Ya34YSG4YWiXCIsXG4gICAgXCLhhIbhhanhhrfhhIbhha7hhIDhhaZcIixcbiAgICBcIuGEhuGFqeGGt+GEieGFoeGGr1wiLFxuICAgIFwi4YSG4YWp4Ya34YSJ4YWp4YaoXCIsXG4gICAgXCLhhIbhhanhhrfhhIzhhbXhhrpcIixcbiAgICBcIuGEhuGFqeGGt+GEkOGFqeGGvFwiLFxuICAgIFwi4YSG4YWp4Ya44YSJ4YW1XCIsXG4gICAgXCLhhIbhha7hhIDhharhhqvhhInhhbXhhrdcIixcbiAgICBcIuGEhuGFruGEgOGFruGGvOGEkuGFqlwiLFxuICAgIFwi4YSG4YWu4YSD4YWl4YSL4YWxXCIsXG4gICAgXCLhhIbhha7hhIPhhaXhhrdcIixcbiAgICBcIuGEhuGFruGEheGFs+GHgVwiLFxuICAgIFwi4YSG4YWu4YSJ4YWz4YarXCIsXG4gICAgXCLhhIbhha7hhIvhhaXhhrpcIixcbiAgICBcIuGEhuGFruGEi+GFp+GGqFwiLFxuICAgIFwi4YSG4YWu4YSL4YWt4Ya8XCIsXG4gICAgXCLhhIbhha7hhIzhhanhhIDhhaXhhqtcIixcbiAgICBcIuGEhuGFruGEjOGFteGEgOGFolwiLFxuICAgIFwi4YSG4YWu4YSO4YWl4YaoXCIsXG4gICAgXCLhhIbhha7hhqvhhIDhha5cIixcbiAgICBcIuGEhuGFruGGq+GEg+GFs+GGqFwiLFxuICAgIFwi4YSG4YWu4Yar4YSH4YWl4Ya4XCIsXG4gICAgXCLhhIbhha7hhqvhhInhhaVcIixcbiAgICBcIuGEhuGFruGGq+GEjOGFplwiLFxuICAgIFwi4YSG4YWu4Yar4YSS4YWh4YaoXCIsXG4gICAgXCLhhIbhha7hhqvhhJLhhapcIixcbiAgICBcIuGEhuGFruGGr+GEgOGFoVwiLFxuICAgIFwi4YSG4YWu4Yav4YSA4YWl4YarXCIsXG4gICAgXCLhhIbhha7hhq/hhIDhhafhhq9cIixcbiAgICBcIuGEhuGFruGGr+GEgOGFqeGEgOGFtVwiLFxuICAgIFwi4YSG4YWu4Yav4YSF4YWp4YarXCIsXG4gICAgXCLhhIbhha7hhq/hhIXhhbXhhJLhhaHhhqhcIixcbiAgICBcIuGEhuGFruGGr+GEi+GFs+GGt1wiLFxuICAgIFwi4YSG4YWu4Yav4YSM4YW14YavXCIsXG4gICAgXCLhhIbhha7hhq/hhI7hhaZcIixcbiAgICBcIuGEhuGFteGEgOGFruGGqFwiLFxuICAgIFwi4YSG4YW14YSD4YW14YSL4YWlXCIsXG4gICAgXCLhhIbhhbXhhInhhaHhhIvhhbXhhq9cIixcbiAgICBcIuGEhuGFteGEieGFruGGr1wiLFxuICAgIFwi4YSG4YW14YSL4YWn4YaoXCIsXG4gICAgXCLhhIbhhbXhhIvhha3hhrzhhInhhbXhhq9cIixcbiAgICBcIuGEhuGFteGEi+GFruGGt1wiLFxuICAgIFwi4YSG4YW14YSL4YW14YarXCIsXG4gICAgXCLhhIbhhbXhhJDhhbXhhrxcIixcbiAgICBcIuGEhuGFteGEkuGFqeGGq1wiLFxuICAgIFwi4YSG4YW14Yar4YSA4YWh4YarXCIsXG4gICAgXCLhhIbhhbXhhqvhhIzhhanhhqhcIixcbiAgICBcIuGEhuGFteGGq+GEjOGFrlwiLFxuICAgIFwi4YSG4YW14Yau4YSL4YWz4Ya3XCIsXG4gICAgXCLhhIbhhbXhhq/hhIDhhaHhhIXhha5cIixcbiAgICBcIuGEhuGFteGGr+GEheGFteGEhuGFteGEkOGFpVwiLFxuICAgIFwi4YSG4YW14YeA4YSH4YWh4YSD4YWh4YaoXCIsXG4gICAgXCLhhIfhhaHhhIDhhaHhhIzhhbVcIixcbiAgICBcIuGEh+GFoeGEgOGFruGEguGFtVwiLFxuICAgIFwi4YSH4YWh4YSC4YWh4YSC4YWhXCIsXG4gICAgXCLhhIfhhaHhhILhhbPhhq9cIixcbiAgICBcIuGEh+GFoeGEg+GFoeGGqFwiLFxuICAgIFwi4YSH4YWh4YSD4YWh4Ya64YSA4YWhXCIsXG4gICAgXCLhhIfhhaHhhIXhhaHhhrdcIixcbiAgICBcIuGEh+GFoeGEi+GFteGEheGFpeGEieGFs1wiLFxuICAgIFwi4YSH4YWh4YSQ4YWh4Ya8XCIsXG4gICAgXCLhhIfhhaHhhqjhhIbhha7hhq/hhIDhharhhqtcIixcbiAgICBcIuGEh+GFoeGGqOGEieGFoVwiLFxuICAgIFwi4YSH4YWh4Yao4YSJ4YWuXCIsXG4gICAgXCLhhIfhhaHhhqvhhIPhhaJcIixcbiAgICBcIuGEh+GFoeGGq+GEg+GFs+GEieGFtVwiLFxuICAgIFwi4YSH4YWh4Yar4YSG4YWh4YavXCIsXG4gICAgXCLhhIfhhaHhhqvhhIfhhaHhhq9cIixcbiAgICBcIuGEh+GFoeGGq+GEieGFpeGGvFwiLFxuICAgIFwi4YSH4YWh4Yar4YSL4YWz4Ya8XCIsXG4gICAgXCLhhIfhhaHhhqvhhIzhhaHhhrxcIixcbiAgICBcIuGEh+GFoeGGq+GEjOGFruGGqFwiLFxuICAgIFwi4YSH4YWh4Yar4YSM4YW1XCIsXG4gICAgXCLhhIfhhaHhhqvhhI7hhaHhhqtcIixcbiAgICBcIuGEh+GFoeGGruGEjuGFteGGt1wiLFxuICAgIFwi4YSH4YWh4Yav4YSA4YWh4YSF4YWh4YaoXCIsXG4gICAgXCLhhIfhhaHhhq/hhIDhhaXhhq/hhIvhhbPhhrdcIixcbiAgICBcIuGEh+GFoeGGr+GEgOGFp+GGq1wiLFxuICAgIFwi4YSH4YWh4Yav4YSD4YWh4YavXCIsXG4gICAgXCLhhIfhhaHhhq/hhIXhhaZcIixcbiAgICBcIuGEh+GFoeGGr+GEhuGFqeGGqFwiLFxuICAgIFwi4YSH4YWh4Yav4YSH4YWh4YSD4YWh4YaoXCIsXG4gICAgXCLhhIfhhaHhhq/hhInhhaLhhrxcIixcbiAgICBcIuGEh+GFoeGGr+GEi+GFs+GGt1wiLFxuICAgIFwi4YSH4YWh4Yav4YSM4YWh4YSA4YWu4YaoXCIsXG4gICAgXCLhhIfhhaHhhq/hhIzhhaXhhqtcIixcbiAgICBcIuGEh+GFoeGGr+GEkOGFqeGGuFwiLFxuICAgIFwi4YSH4YWh4Yav4YSR4YWtXCIsXG4gICAgXCLhhIfhhaHhhrfhhJLhhaHhhILhhbPhhq9cIixcbiAgICBcIuGEh+GFoeGGuOGEgOGFs+GEheGFs+GGulwiLFxuICAgIFwi4YSH4YWh4Ya44YSG4YWh4Ya6XCIsXG4gICAgXCLhhIfhhaHhhrjhhInhhaHhhrxcIixcbiAgICBcIuGEh+GFoeGGuOGEieGFqeGHgFwiLFxuICAgIFwi4YSH4YWh4Ya84YSA4YWz4Ya3XCIsXG4gICAgXCLhhIfhhaHhhrzhhIbhhafhhqtcIixcbiAgICBcIuGEh+GFoeGGvOGEhuGFruGGq1wiLFxuICAgIFwi4YSH4YWh4Ya84YSH4YWh4YSD4YWh4YaoXCIsXG4gICAgXCLhhIfhhaHhhrzhhIfhhaXhhrhcIixcbiAgICBcIuGEh+GFoeGGvOGEieGFqeGGvFwiLFxuICAgIFwi4YSH4YWh4Ya84YSJ4YW14YaoXCIsXG4gICAgXCLhhIfhhaHhhrzhhIvhhaHhhqtcIixcbiAgICBcIuGEh+GFoeGGvOGEi+GFruGGr1wiLFxuICAgIFwi4YSH4YWh4Ya84YSM4YW1XCIsXG4gICAgXCLhhIfhhaHhhrzhhJLhhaHhhqhcIixcbiAgICBcIuGEh+GFoeGGvOGEkuGFolwiLFxuICAgIFwi4YSH4YWh4Ya84YSS4YWj4Ya8XCIsXG4gICAgXCLhhIfhhaLhhIDhhafhhrxcIixcbiAgICBcIuGEh+GFouGEgeGFqeGGuFwiLFxuICAgIFwi4YSH4YWi4YSD4YWh4YavXCIsXG4gICAgXCLhhIfhhaLhhIPhhbPhhIbhhbXhhqvhhJDhhaXhhqtcIixcbiAgICBcIuGEh+GFouGGqOGEg+GFruGEieGFoeGGq1wiLFxuICAgIFwi4YSH4YWi4Yao4YSJ4YWi4YaoXCIsXG4gICAgXCLhhIfhhaLhhqjhhInhhaXhhrxcIixcbiAgICBcIuGEh+GFouGGqOGEi+GFteGGq1wiLFxuICAgIFwi4YSH4YWi4Yao4YSM4YWmXCIsXG4gICAgXCLhhIfhhaLhhqjhhJLhharhhIzhhaXhhrdcIixcbiAgICBcIuGEh+GFpeGEheGFs+GGulwiLFxuICAgIFwi4YSH4YWl4YSJ4YWl4Ya6XCIsXG4gICAgXCLhhIfhhaXhhJDhhbPhhqtcIixcbiAgICBcIuGEh+GFpeGGq+GEgOGFolwiLFxuICAgIFwi4YSH4YWl4Yar4YSL4YWn4YaoXCIsXG4gICAgXCLhhIfhhaXhhqvhhIzhhbVcIixcbiAgICBcIuGEh+GFpeGGq+GEkuGFqVwiLFxuICAgIFwi4YSH4YWl4Yav4YSA4YWz4Ya3XCIsXG4gICAgXCLhhIfhhaXhhq/hhIXhhaZcIixcbiAgICBcIuGEh+GFpeGGr+GEiuGFpVwiLFxuICAgIFwi4YSH4YWl4Ya34YSL4YWxXCIsXG4gICAgXCLhhIfhhaXhhrfhhIvhhbXhhqtcIixcbiAgICBcIuGEh+GFpeGGt+GEjOGFrFwiLFxuICAgIFwi4YSH4YWl4Ya44YSF4YWy4YavXCIsXG4gICAgXCLhhIfhhaXhhrjhhIvhha/hhqtcIixcbiAgICBcIuGEh+GFpeGGuOGEjOGFpeGGqFwiLFxuICAgIFwi4YSH4YWl4Ya44YSO4YW14YaoXCIsXG4gICAgXCLhhIfhhabhhIvhhbXhhIzhhbXhhrxcIixcbiAgICBcIuGEh+GFpuGGr+GEkOGFs1wiLFxuICAgIFwi4YSH4YWn4Yar4YSA4YWn4Ya8XCIsXG4gICAgXCLhhIfhhafhhqvhhIPhhanhhrxcIixcbiAgICBcIuGEh+GFp+GGq+GEhuGFp+GGvFwiLFxuICAgIFwi4YSH4YWn4Yar4YSJ4YW14YarXCIsXG4gICAgXCLhhIfhhafhhqvhhJLhhanhhInhhaFcIixcbiAgICBcIuGEh+GFp+GGq+GEkuGFqlwiLFxuICAgIFwi4YSH4YWn4Yav4YSD4YWpXCIsXG4gICAgXCLhhIfhhafhhq/hhIbhhafhhrxcIixcbiAgICBcIuGEh+GFp+GGr+GEi+GFteGGr1wiLFxuICAgIFwi4YSH4YWn4Ya84YSJ4YW14YavXCIsXG4gICAgXCLhhIfhhafhhrzhhIvhhaHhhIXhhbVcIixcbiAgICBcIuGEh+GFp+GGvOGEi+GFr+GGq1wiLFxuICAgIFwi4YSH4YWp4YSA4YWq4YarXCIsXG4gICAgXCLhhIfhhanhhILhhaXhhInhhbNcIixcbiAgICBcIuGEh+GFqeGEheGFoeGEieGFouGGqFwiLFxuICAgIFwi4YSH4YWp4YSF4YWh4Ya3XCIsXG4gICAgXCLhhIfhhanhhIXhhbPhhrdcIixcbiAgICBcIuGEh+GFqeGEieGFoeGGvFwiLFxuICAgIFwi4YSH4YWp4YSL4YWh4YarXCIsXG4gICAgXCLhhIfhhanhhIzhhaHhhIDhhbVcIixcbiAgICBcIuGEh+GFqeGEjOGFoeGGvFwiLFxuICAgIFwi4YSH4YWp4YSM4YWl4YarXCIsXG4gICAgXCLhhIfhhanhhIzhhanhhqtcIixcbiAgICBcIuGEh+GFqeGEkOGFqeGGvFwiLFxuICAgIFwi4YSH4YWp4YSR4YWn4Yar4YSM4YWl4YaoXCIsXG4gICAgXCLhhIfhhanhhJLhhaXhhrdcIixcbiAgICBcIuGEh+GFqeGGqOGEg+GFqVwiLFxuICAgIFwi4YSH4YWp4Yao4YSJ4YWhXCIsXG4gICAgXCLhhIfhhanhhqjhhInhha7hhrzhhIvhhaFcIixcbiAgICBcIuGEh+GFqeGGqOGEieGFs+GGuFwiLFxuICAgIFwi4YSH4YWp4Yap4YSL4YWz4Ya3XCIsXG4gICAgXCLhhIfhhanhhqvhhIDhhafhhqjhhIzhhaXhhqhcIixcbiAgICBcIuGEh+GFqeGGq+GEheGFolwiLFxuICAgIFwi4YSH4YWp4Yar4YSH4YWuXCIsXG4gICAgXCLhhIfhhanhhqvhhInhhaFcIixcbiAgICBcIuGEh+GFqeGGq+GEieGFpeGGvFwiLFxuICAgIFwi4YSH4YWp4Yar4YSL4YW14YarXCIsXG4gICAgXCLhhIfhhanhhqvhhIzhhbXhhq9cIixcbiAgICBcIuGEh+GFqeGGr+GEkeGFpuGGq1wiLFxuICAgIFwi4YSH4YWp4Ya84YSJ4YWhXCIsXG4gICAgXCLhhIfhhanhhrzhhIzhhbVcIixcbiAgICBcIuGEh+GFqeGGvOGEkOGFrlwiLFxuICAgIFwi4YSH4YWu4YSA4YWz4YarXCIsXG4gICAgXCLhhIfhha7hhIHhhbPhhIXhhaXhhIvhha7hhrdcIixcbiAgICBcIuGEh+GFruGEg+GFoeGGt1wiLFxuICAgIFwi4YSH4YWu4YSD4YWp4Ya84YSJ4YWh4YarXCIsXG4gICAgXCLhhIfhha7hhIbhha7hhqtcIixcbiAgICBcIuGEh+GFruGEh+GFruGGq1wiLFxuICAgIFwi4YSH4YWu4YSJ4YWh4YarXCIsXG4gICAgXCLhhIfhha7hhInhhaHhhrxcIixcbiAgICBcIuGEh+GFruGEi+GFpeGGv1wiLFxuICAgIFwi4YSH4YWu4YSL4YW14YarXCIsXG4gICAgXCLhhIfhha7hhIzhhaHhhqjhhIvhha3hhrxcIixcbiAgICBcIuGEh+GFruGEjOGFoeGGvFwiLFxuICAgIFwi4YSH4YWu4YSM4YWl4Ya8XCIsXG4gICAgXCLhhIfhha7hhIzhhanhhqhcIixcbiAgICBcIuGEh+GFruGEjOGFteGEheGFpeGGq+GEkuGFtVwiLFxuICAgIFwi4YSH4YWu4YSO4YW14YarXCIsXG4gICAgXCLhhIfhha7hhJDhhaHhhqhcIixcbiAgICBcIuGEh+GFruGEkeGFruGGt1wiLFxuICAgIFwi4YSH4YWu4YSS4YWs4YSM4YWh4Ya8XCIsXG4gICAgXCLhhIfhha7hhqjhhIfhha5cIixcbiAgICBcIuGEh+GFruGGqOGEkuGFoeGGq1wiLFxuICAgIFwi4YSH4YWu4Yar4YSC4YWpXCIsXG4gICAgXCLhhIfhha7hhqvhhIXhhaPhhrxcIixcbiAgICBcIuGEh+GFruGGq+GEheGFtVwiLFxuICAgIFwi4YSH4YWu4Yar4YSG4YWn4Ya8XCIsXG4gICAgXCLhhIfhha7hhqvhhInhhaXhhqhcIixcbiAgICBcIuGEh+GFruGGq+GEi+GFo1wiLFxuICAgIFwi4YSH4YWu4Yar4YSL4YWx4YSA4YW1XCIsXG4gICAgXCLhhIfhha7hhqvhhJHhhbXhhq9cIixcbiAgICBcIuGEh+GFruGGq+GEkuGFqeGGvOGEieGFouGGqFwiLFxuICAgIFwi4YSH4YWu4Yav4YSA4YWp4YSA4YW1XCIsXG4gICAgXCLhhIfhha7hhq/hhIDhhapcIixcbiAgICBcIuGEh+GFruGGr+GEgOGFrVwiLFxuICAgIFwi4YSH4YWu4Yav4YSB4YWp4Ya+XCIsXG4gICAgXCLhhIfhha7hhq/hhIbhhaHhhqtcIixcbiAgICBcIuGEh+GFruGGr+GEh+GFpeGGuFwiLFxuICAgIFwi4YSH4YWu4Yav4YSH4YW14Ya+XCIsXG4gICAgXCLhhIfhha7hhq/hhIvhhaHhhqtcIixcbiAgICBcIuGEh+GFruGGr+GEi+GFteGEi+GFteGGqFwiLFxuICAgIFwi4YSH4YWu4Yav4YSS4YWi4Ya8XCIsXG4gICAgXCLhhIfhhbPhhIXhhaLhhqvhhIPhhbNcIixcbiAgICBcIuGEh+GFteGEgOGFs+GGqFwiLFxuICAgIFwi4YSH4YW14YSC4YWh4YarXCIsXG4gICAgXCLhhIfhhbXhhILhhbXhhq9cIixcbiAgICBcIuGEh+GFteGEg+GFruGGr+GEgOGFtVwiLFxuICAgIFwi4YSH4YW14YSD4YW14YSL4YWpXCIsXG4gICAgXCLhhIfhhbXhhIXhhanhhInhhalcIixcbiAgICBcIuGEh+GFteGEhuGFoeGGq1wiLFxuICAgIFwi4YSH4YW14YSG4YWn4Ya8XCIsXG4gICAgXCLhhIfhhbXhhIbhhbXhhq9cIixcbiAgICBcIuGEh+GFteGEh+GFoeGEheGFoeGGt1wiLFxuICAgIFwi4YSH4YW14YSH4YW14Ya34YSH4YWh4Ya4XCIsXG4gICAgXCLhhIfhhbXhhInhhaHhhrxcIixcbiAgICBcIuGEh+GFteGEi+GFreGGvFwiLFxuICAgIFwi4YSH4YW14YSL4YWy4YavXCIsXG4gICAgXCLhhIfhhbXhhIzhha7hhrxcIixcbiAgICBcIuGEh+GFteGEkOGFoeGEhuGFteGGq1wiLFxuICAgIFwi4YSH4YW14YSR4YWh4YarXCIsXG4gICAgXCLhhIfhhbXhhq/hhIPhhbXhhrxcIixcbiAgICBcIuGEh+GFteGGuuGEhuGFruGGr1wiLFxuICAgIFwi4YSH4YW14Ya64YSH4YWh4Ya84YSL4YWu4YavXCIsXG4gICAgXCLhhIfhhbXhhrrhhIzhha7hhq/hhIDhhbVcIixcbiAgICBcIuGEh+GFteGGvuGEgeGFoeGGr1wiLFxuICAgIFwi4YSI4YWh4Yav4YSA4YWh4Yar4YSJ4YWi4YaoXCIsXG4gICAgXCLhhIjhhaHhhq/hhIXhhaJcIixcbiAgICBcIuGEiOGFoeGGr+GEheGFtVwiLFxuICAgIFwi4YSJ4YWh4YSA4YWl4YarXCIsXG4gICAgXCLhhInhhaHhhIDhhajhhIzhhaXhhq9cIixcbiAgICBcIuGEieGFoeGEguGFoeGEi+GFtVwiLFxuICAgIFwi4YSJ4YWh4YSC4YWj4Ya8XCIsXG4gICAgXCLhhInhhaHhhIXhhaHhhrdcIixcbiAgICBcIuGEieGFoeGEheGFoeGGvFwiLFxuICAgIFwi4YSJ4YWh4YSF4YW14Ya4XCIsXG4gICAgXCLhhInhhaHhhIbhhanhhILhhbXhhrdcIixcbiAgICBcIuGEieGFoeGEhuGFruGGr1wiLFxuICAgIFwi4YSJ4YWh4YSH4YWh4Ya8XCIsXG4gICAgXCLhhInhhaHhhInhhaHhhrxcIixcbiAgICBcIuGEieGFoeGEieGFouGGvOGEkuGFquGGr1wiLFxuICAgIFwi4YSJ4YWh4YSJ4YWl4YavXCIsXG4gICAgXCLhhInhhaHhhInhhbPhhrdcIixcbiAgICBcIuGEieGFoeGEieGFteGGr1wiLFxuICAgIFwi4YSJ4YWh4YSL4YWl4Ya4XCIsXG4gICAgXCLhhInhhaHhhIvhha3hhrxcIixcbiAgICBcIuGEieGFoeGEi+GFr+GGr1wiLFxuICAgIFwi4YSJ4YWh4YSM4YWh4Ya8XCIsXG4gICAgXCLhhInhhaHhhIzhhaXhhqtcIixcbiAgICBcIuGEieGFoeGEjOGFteGGq1wiLFxuICAgIFwi4YSJ4YWh4YSO4YWp4YarXCIsXG4gICAgXCLhhInhhaHhhI7hha7hhqvhhIDhhbVcIixcbiAgICBcIuGEieGFoeGEkOGFoeGGvFwiLFxuICAgIFwi4YSJ4YWh4YSQ4YWu4YSF4YW1XCIsXG4gICAgXCLhhInhhaHhhJLhhbPhhq9cIixcbiAgICBcIuGEieGFoeGGq+GEgOGFteGGr1wiLFxuICAgIFwi4YSJ4YWh4Yar4YSH4YWu4YSL4YW14Yar4YSA4YWqXCIsXG4gICAgXCLhhInhhaHhhqvhhIvhhaXhhrhcIixcbiAgICBcIuGEieGFoeGGq+GEjuGFouGGqFwiLFxuICAgIFwi4YSJ4YWh4Yav4YSF4YW14Ya3XCIsXG4gICAgXCLhhInhhaHhhq/hhIvhhbXhhqtcIixcbiAgICBcIuGEieGFoeGGr+GEjeGFoeGGqFwiLFxuICAgIFwi4YSJ4YWh4Ya34YSA4YWo4YSQ4YWh4Ya8XCIsXG4gICAgXCLhhInhhaHhhrfhhIDhha7hhqhcIixcbiAgICBcIuGEieGFoeGGt+GEieGFteGGuFwiLFxuICAgIFwi4YSJ4YWh4Ya34YSL4YWv4YavXCIsXG4gICAgXCLhhInhhaHhhrfhhI7hhanhhqtcIixcbiAgICBcIuGEieGFoeGGvOGEgOGFquGGq1wiLFxuICAgIFwi4YSJ4YWh4Ya84YSA4YWz4Ya3XCIsXG4gICAgXCLhhInhhaHhhrzhhIPhhaJcIixcbiAgICBcIuGEieGFoeGGvOGEheGFslwiLFxuICAgIFwi4YSJ4YWh4Ya84YSH4YWh4Yar4YSA4YW1XCIsXG4gICAgXCLhhInhhaHhhrzhhInhhaHhhrxcIixcbiAgICBcIuGEieGFoeGGvOGEieGFteGGqFwiLFxuICAgIFwi4YSJ4YWh4Ya84YSL4YWl4Ya4XCIsXG4gICAgXCLhhInhhaHhhrzhhIvhhbXhhqtcIixcbiAgICBcIuGEieGFoeGGvOGEjOGFoVwiLFxuICAgIFwi4YSJ4YWh4Ya84YSM4YWl4Ya3XCIsXG4gICAgXCLhhInhhaHhhrzhhI7hhaVcIixcbiAgICBcIuGEieGFoeGGvOGEjuGFrlwiLFxuICAgIFwi4YSJ4YWh4Ya84YSQ4YWiXCIsXG4gICAgXCLhhInhhaHhhrzhhJHhha1cIixcbiAgICBcIuGEieGFoeGGvOGEkeGFruGGt1wiLFxuICAgIFwi4YSJ4YWh4Ya84YSS4YWq4Ya8XCIsXG4gICAgXCLhhInhhaLhhIfhhafhhqhcIixcbiAgICBcIuGEieGFouGGqOGEgeGFoeGGr1wiLFxuICAgIFwi4YSJ4YWi4Yao4YSL4YWn4Yar4YSR4YW14YavXCIsXG4gICAgXCLhhInhhaLhhrzhhIDhhaHhhqhcIixcbiAgICBcIuGEieGFouGGvOGEhuGFp+GGvFwiLFxuICAgIFwi4YSJ4YWi4Ya84YSG4YWu4YavXCIsXG4gICAgXCLhhInhhaLhhrzhhIfhhaHhhrzhhInhhanhhrxcIixcbiAgICBcIuGEieGFouGGvOGEieGFoeGGq1wiLFxuICAgIFwi4YSJ4YWi4Ya84YSJ4YWl4YarXCIsXG4gICAgXCLhhInhhaLhhrzhhInhhbXhhqtcIixcbiAgICBcIuGEieGFouGGvOGEi+GFteGGr1wiLFxuICAgIFwi4YSJ4YWi4Ya84YSS4YWq4YavXCIsXG4gICAgXCLhhInhhaXhhIXhhaHhhrhcIixcbiAgICBcIuGEieGFpeGEheGFs+GGq1wiLFxuICAgIFwi4YSJ4YWl4YSG4YWn4Ya8XCIsXG4gICAgXCLhhInhhaXhhIbhhbXhhqtcIixcbiAgICBcIuGEieGFpeGEh+GFteGEieGFs1wiLFxuICAgIFwi4YSJ4YWl4YSL4YWj4Ya8XCIsXG4gICAgXCLhhInhhaXhhIvhha7hhq9cIixcbiAgICBcIuGEieGFpeGEjOGFpeGGqFwiLFxuICAgIFwi4YSJ4YWl4YSM4YWl4Ya3XCIsXG4gICAgXCLhhInhhaXhhI3hhanhhqhcIixcbiAgICBcIuGEieGFpeGEj+GFs+GGr1wiLFxuICAgIFwi4YSJ4YWl4Yao4YSJ4YWhXCIsXG4gICAgXCLhhInhhaXhhqjhhIvhhbJcIixcbiAgICBcIuGEieGFpeGGq+GEgOGFpVwiLFxuICAgIFwi4YSJ4YWl4Yar4YSG4YWu4YavXCIsXG4gICAgXCLhhInhhaXhhqvhhIfhhaJcIixcbiAgICBcIuGEieGFpeGGq+GEieGFouGGvFwiLFxuICAgIFwi4YSJ4YWl4Yar4YSJ4YWuXCIsXG4gICAgXCLhhInhhaXhhqvhhIvhha/hhqtcIixcbiAgICBcIuGEieGFpeGGq+GEjOGFoeGGvFwiLFxuICAgIFwi4YSJ4YWl4Yar4YSM4YWl4YarXCIsXG4gICAgXCLhhInhhaXhhqvhhJDhhaLhhqhcIixcbiAgICBcIuGEieGFpeGGq+GEkeGFruGGvOGEgOGFtVwiLFxuICAgIFwi4YSJ4YWl4Yav4YSA4YWl4YSM4YW1XCIsXG4gICAgXCLhhInhhaXhhq/hhILhhaHhhq9cIixcbiAgICBcIuGEieGFpeGGr+GEheGFpeGGvOGEkOGFoeGGvFwiLFxuICAgIFwi4YSJ4YWl4Yav4YSG4YWn4Ya8XCIsXG4gICAgXCLhhInhhaXhhq/hhIbhha7hhqtcIixcbiAgICBcIuGEieGFpeGGr+GEieGFoVwiLFxuICAgIFwi4YSJ4YWl4Yav4YSL4YWh4Yao4YSJ4YWh4YarXCIsXG4gICAgXCLhhInhhaXhhq/hhI7hhbVcIixcbiAgICBcIuGEieGFpeGGr+GEkOGFoeGGvFwiLFxuICAgIFwi4YSJ4YWl4Ya44YSK4YW1XCIsXG4gICAgXCLhhInhhaXhhrzhhIDhhanhhrxcIixcbiAgICBcIuGEieGFpeGGvOGEg+GFoeGGvFwiLFxuICAgIFwi4YSJ4YWl4Ya84YSG4YWn4Ya8XCIsXG4gICAgXCLhhInhhaXhhrzhhIfhhafhhq9cIixcbiAgICBcIuGEieGFpeGGvOGEi+GFteGGq1wiLFxuICAgIFwi4YSJ4YWl4Ya84YSM4YWh4Ya8XCIsXG4gICAgXCLhhInhhaXhhrzhhIzhhaXhhqhcIixcbiAgICBcIuGEieGFpeGGvOGEjOGFteGGr1wiLFxuICAgIFwi4YSJ4YWl4Ya84YSS4YWh4Ya3XCIsXG4gICAgXCLhhInhhabhhIDhhbPhhrdcIixcbiAgICBcIuGEieGFpuGEhuGFteGEguGFoVwiLFxuICAgIFwi4YSJ4YWm4YSJ4YWh4Ya8XCIsXG4gICAgXCLhhInhhabhhIvhha/hhq9cIixcbiAgICBcIuGEieGFpuGEjOGFqeGGvOGEg+GFouGEi+GFquGGvFwiLFxuICAgIFwi4YSJ4YWm4YSQ4YWh4YaoXCIsXG4gICAgXCLhhInhhabhhqvhhJDhhaVcIixcbiAgICBcIuGEieGFpuGGq+GEkOGFteGEhuGFteGEkOGFpVwiLFxuICAgIFwi4YSJ4YWm4Ya64YSN4YWiXCIsXG4gICAgXCLhhInhhanhhIDhhbLhhIbhhalcIixcbiAgICBcIuGEieGFqeGEgOGFs+GGqOGEjOGFpeGGqFwiLFxuICAgIFwi4YSJ4YWp4YSA4YWz4Ya3XCIsXG4gICAgXCLhhInhhanhhILhhaHhhIDhhbVcIixcbiAgICBcIuGEieGFqeGEguGFp+GGq1wiLFxuICAgIFwi4YSJ4YWp4YSD4YWz4YaoXCIsXG4gICAgXCLhhInhhanhhIbhhaHhhrxcIixcbiAgICBcIuGEieGFqeGEhuGFruGGq1wiLFxuICAgIFwi4YSJ4YWp4YSJ4YWl4YavXCIsXG4gICAgXCLhhInhhanhhInhhanhhqhcIixcbiAgICBcIuGEieGFqeGEi+GFoeGEgOGFqlwiLFxuICAgIFwi4YSJ4YWp4YSL4YWt4Ya8XCIsXG4gICAgXCLhhInhhanhhIvhha/hhqtcIixcbiAgICBcIuGEieGFqeGEi+GFs+GGt1wiLFxuICAgIFwi4YSJ4YWp4YSM4YWu4Ya84YSS4YW1XCIsXG4gICAgXCLhhInhhanhhIzhhbXhhJHhha7hhrdcIixcbiAgICBcIuGEieGFqeGEjOGFteGGr1wiLFxuICAgIFwi4YSJ4YWp4YSR4YWu4Ya8XCIsXG4gICAgXCLhhInhhanhhJLhhafhhrxcIixcbiAgICBcIuGEieGFqeGGqOGEg+GFoeGGt1wiLFxuICAgIFwi4YSJ4YWp4Yao4YSD4YWpXCIsXG4gICAgXCLhhInhhanhhqjhhIvhhanhhrpcIixcbiAgICBcIuGEieGFqeGGq+GEgOGFoeGEheGFoeGGqFwiLFxuICAgIFwi4YSJ4YWp4Yar4YSA4YW14YavXCIsXG4gICAgXCLhhInhhanhhqvhhILhhadcIixcbiAgICBcIuGEieGFqeGGq+GEguGFteGGt1wiLFxuICAgIFwi4YSJ4YWp4Yar4YSD4YWz4Ya8XCIsXG4gICAgXCLhhInhhanhhqvhhIbhhanhhqhcIixcbiAgICBcIuGEieGFqeGGq+GEiOGFp+GGqFwiLFxuICAgIFwi4YSJ4YWp4Yar4YSJ4YW14YavXCIsXG4gICAgXCLhhInhhanhhqvhhIzhhbXhhq9cIixcbiAgICBcIuGEieGFqeGGq+GEkOGFqeGGuFwiLFxuICAgIFwi4YSJ4YWp4Yar4YSS4YWiXCIsXG4gICAgXCLhhInhhanhhq/hhIzhhbXhhqjhhJLhhbVcIixcbiAgICBcIuGEieGFqeGGt+GEiuGFtVwiLFxuICAgIFwi4YSJ4YWp4Ya84YSL4YWh4YSM4YW1XCIsXG4gICAgXCLhhInhhanhhrzhhIvhhbVcIixcbiAgICBcIuGEieGFqeGGvOGEkeGFp+GGq1wiLFxuICAgIFwi4YSJ4YWs4YSA4YWp4YSA4YW1XCIsXG4gICAgXCLhhInhha3hhJHhhbXhhrxcIixcbiAgICBcIuGEieGFruGEgOGFpeGGq1wiLFxuICAgIFwi4YSJ4YWu4YSC4YWn4YarXCIsXG4gICAgXCLhhInhha7hhIPhhaHhhqtcIixcbiAgICBcIuGEieGFruGEg+GFqeGGuuGEhuGFruGGr1wiLFxuICAgIFwi4YSJ4YWu4YSD4YWp4Ya84YSM4YWl4YaoXCIsXG4gICAgXCLhhInhha7hhIbhhafhhqtcIixcbiAgICBcIuGEieGFruGEhuGFp+GGvFwiLFxuICAgIFwi4YSJ4YWu4YSH4YWh4YaoXCIsXG4gICAgXCLhhInhha7hhInhhaHhhrxcIixcbiAgICBcIuGEieGFruGEieGFpeGGqFwiLFxuICAgIFwi4YSJ4YWu4YSJ4YWu4YavXCIsXG4gICAgXCLhhInhha7hhInhhbXhhIXhhalcIixcbiAgICBcIuGEieGFruGEi+GFpeGGuFwiLFxuICAgIFwi4YSJ4YWu4YSL4YWn4Ya3XCIsXG4gICAgXCLhhInhha7hhIvhhafhhrxcIixcbiAgICBcIuGEieGFruGEi+GFteGGuFwiLFxuICAgIFwi4YSJ4YWu4YSM4YWu4YarXCIsXG4gICAgXCLhhInhha7hhIzhhbXhhrhcIixcbiAgICBcIuGEieGFruGEjuGFruGGr1wiLFxuICAgIFwi4YSJ4YWu4YSP4YWl4Ya6XCIsXG4gICAgXCLhhInhha7hhJHhhbXhhq9cIixcbiAgICBcIuGEieGFruGEkuGFoeGGqFwiLFxuICAgIFwi4YSJ4YWu4YSS4YWl4Ya34YSJ4YWi4Ya8XCIsXG4gICAgXCLhhInhha7hhJLhharhhIDhhbVcIixcbiAgICBcIuGEieGFruGGqOGEguGFp1wiLFxuICAgIFwi4YSJ4YWu4Yao4YSJ4YWpXCIsXG4gICAgXCLhhInhha7hhqjhhIzhhaZcIixcbiAgICBcIuGEieGFruGGq+GEgOGFoeGGq1wiLFxuICAgIFwi4YSJ4YWu4Yar4YSJ4YWlXCIsXG4gICAgXCLhhInhha7hhqvhhInhha5cIixcbiAgICBcIuGEieGFruGGq+GEieGFteGGqOGEgOGFoeGGq1wiLFxuICAgIFwi4YSJ4YWu4Yar4YSL4YWxXCIsXG4gICAgXCLhhInhha7hhq7hhIDhhaHhhIXhhaHhhqhcIixcbiAgICBcIuGEieGFruGGr+GEh+GFp+GGvFwiLFxuICAgIFwi4YSJ4YWu4Yav4YSM4YW14Ya4XCIsXG4gICAgXCLhhInhha7hhrrhhIzhhaFcIixcbiAgICBcIuGEieGFs+GEguGFteGGt1wiLFxuICAgIFwi4YSJ4YWz4YSG4YWu4YavXCIsXG4gICAgXCLhhInhhbPhhInhhbPhhIXhhalcIixcbiAgICBcIuGEieGFs+GEieGFs+GGvFwiLFxuICAgIFwi4YSJ4YWz4YSL4YWw4YSQ4YWlXCIsXG4gICAgXCLhhInhhbPhhIvhhbHhhI7hhbVcIixcbiAgICBcIuGEieGFs+GEj+GFpuGEi+GFteGEkOGFs1wiLFxuICAgIFwi4YSJ4YWz4YSQ4YWy4YSD4YW14YSL4YWpXCIsXG4gICAgXCLhhInhhbPhhJDhhbPhhIXhhabhhInhhbNcIixcbiAgICBcIuGEieGFs+GEkeGFqeGEjuGFs1wiLFxuICAgIFwi4YSJ4YWz4Yav4YSN4YWl4YaoXCIsXG4gICAgXCLhhInhhbPhhq/hhJHhhbPhhrdcIixcbiAgICBcIuGEieGFs+GGuOGEgOGFquGGq1wiLFxuICAgIFwi4YSJ4YWz4Ya44YSA4YW1XCIsXG4gICAgXCLhhInhhbPhhrzhhIDhhaLhhqhcIixcbiAgICBcIuGEieGFs+GGvOGEheGFtVwiLFxuICAgIFwi4YSJ4YWz4Ya84YSH4YWuXCIsXG4gICAgXCLhhInhhbPhhrzhhIvhha3hhrzhhI7hhaFcIixcbiAgICBcIuGEieGFs+GGvOGEjOGFteGGq1wiLFxuICAgIFwi4YSJ4YW14YSA4YWh4YaoXCIsXG4gICAgXCLhhInhhbXhhIDhhaHhhqtcIixcbiAgICBcIuGEieGFteGEgOGFqeGGr1wiLFxuICAgIFwi4YSJ4YW14YSA4YWz4Ya34YSO4YW1XCIsXG4gICAgXCLhhInhhbXhhILhhaHhhIXhhbXhhIvhhalcIixcbiAgICBcIuGEieGFteGEg+GFouGGqFwiLFxuICAgIFwi4YSJ4YW14YSF4YW14YSM4YWzXCIsXG4gICAgXCLhhInhhbXhhIbhhabhhqvhhJDhhbNcIixcbiAgICBcIuGEieGFteGEhuGFteGGq1wiLFxuICAgIFwi4YSJ4YW14YSH4YWu4YSG4YWpXCIsXG4gICAgXCLhhInhhbXhhInhhaXhhqtcIixcbiAgICBcIuGEieGFteGEieGFpeGGr1wiLFxuICAgIFwi4YSJ4YW14YSJ4YWz4YSQ4YWm4Ya3XCIsXG4gICAgXCLhhInhhbXhhIvhhaHhhIfhhaXhhIzhhbVcIixcbiAgICBcIuGEieGFteGEi+GFpeGEhuGFpeGEguGFtVwiLFxuICAgIFwi4YSJ4YW14YSL4YWv4YavXCIsXG4gICAgXCLhhInhhbXhhIvhhbXhhqtcIixcbiAgICBcIuGEieGFteGEi+GFteGGr1wiLFxuICAgIFwi4YSJ4YW14YSM4YWh4YaoXCIsXG4gICAgXCLhhInhhbXhhIzhhaHhhrxcIixcbiAgICBcIuGEieGFteGEjOGFpeGGr1wiLFxuICAgIFwi4YSJ4YW14YSM4YWl4Ya3XCIsXG4gICAgXCLhhInhhbXhhIzhha7hhrxcIixcbiAgICBcIuGEieGFteGEjOGFs+GGq1wiLFxuICAgIFwi4YSJ4YW14YSM4YW14Ya4XCIsXG4gICAgXCLhhInhhbXhhI7hhaXhhrxcIixcbiAgICBcIuGEieGFteGEkuGFoeGGuFwiLFxuICAgIFwi4YSJ4YW14YSS4YWl4Ya3XCIsXG4gICAgXCLhhInhhbXhhqjhhIDhha5cIixcbiAgICBcIuGEieGFteGGqOGEgOGFtVwiLFxuICAgIFwi4YSJ4YW14Yao4YSD4YWh4Ya8XCIsXG4gICAgXCLhhInhhbXhhqjhhIXhhaPhhrxcIixcbiAgICBcIuGEieGFteGGqOGEheGFreGEkeGFruGGt1wiLFxuICAgIFwi4YSJ4YW14Yao4YSG4YWu4YavXCIsXG4gICAgXCLhhInhhbXhhqjhhIjhhaHhhrxcIixcbiAgICBcIuGEieGFteGGqOGEieGFoVwiLFxuICAgIFwi4YSJ4YW14Yao4YSJ4YWi4Ya84YSS4YWq4YavXCIsXG4gICAgXCLhhInhhbXhhqjhhI7hhalcIixcbiAgICBcIuGEieGFteGGqOGEkOGFoeGGqFwiLFxuICAgIFwi4YSJ4YW14Yao4YSR4YWu4Ya3XCIsXG4gICAgXCLhhInhhbXhhqvhhIDhhalcIixcbiAgICBcIuGEieGFteGGq+GEgOGFslwiLFxuICAgIFwi4YSJ4YW14Yar4YSC4YWn4Ya3XCIsXG4gICAgXCLhhInhhbXhhqvhhIbhha7hhqtcIixcbiAgICBcIuGEieGFteGGq+GEh+GFoeGGr1wiLFxuICAgIFwi4YSJ4YW14Yar4YSH4YW1XCIsXG4gICAgXCLhhInhhbXhhqvhhInhhaFcIixcbiAgICBcIuGEieGFteGGq+GEieGFplwiLFxuICAgIFwi4YSJ4YW14Yar4YSL4YWt4Ya8XCIsXG4gICAgXCLhhInhhbXhhqvhhIzhhabhhJHhha7hhrdcIixcbiAgICBcIuGEieGFteGGq+GEjuGFpeGGvFwiLFxuICAgIFwi4YSJ4YW14Yar4YSO4YWmXCIsXG4gICAgXCLhhInhhbXhhqvhhJLhhapcIixcbiAgICBcIuGEieGFteGGr+GEgOGFoeGGt1wiLFxuICAgIFwi4YSJ4YW14Yav4YSC4YWiXCIsXG4gICAgXCLhhInhhbXhhq/hhIXhhafhhqhcIixcbiAgICBcIuGEieGFteGGr+GEheGFqFwiLFxuICAgIFwi4YSJ4YW14Yav4YSG4YWh4Ya8XCIsXG4gICAgXCLhhInhhbXhhq/hhInhha5cIixcbiAgICBcIuGEieGFteGGr+GEieGFs+GGuFwiLFxuICAgIFwi4YSJ4YW14Yav4YSJ4YW1XCIsXG4gICAgXCLhhInhhbXhhq/hhIzhhaHhhrxcIixcbiAgICBcIuGEieGFteGGr+GEjOGFpeGGvFwiLFxuICAgIFwi4YSJ4YW14Yav4YSM4YW14Yav4YSM4YWl4YaoXCIsXG4gICAgXCLhhInhhbXhhq/hhI7hhaXhhqtcIixcbiAgICBcIuGEieGFteGGr+GEjuGFplwiLFxuICAgIFwi4YSJ4YW14Yav4YSP4YWl4Ya6XCIsXG4gICAgXCLhhInhhbXhhq/hhJDhhaJcIixcbiAgICBcIuGEieGFteGGr+GEkeGFolwiLFxuICAgIFwi4YSJ4YW14Yav4YSS4YWl4Ya3XCIsXG4gICAgXCLhhInhhbXhhq/hhJLhhafhhqtcIixcbiAgICBcIuGEieGFteGGt+GEheGFtVwiLFxuICAgIFwi4YSJ4YW14Ya34YSH4YWu4YSF4YWz4Ya3XCIsXG4gICAgXCLhhInhhbXhhrfhhInhhaFcIixcbiAgICBcIuGEieGFteGGt+GEjOGFoeGGvFwiLFxuICAgIFwi4YSJ4YW14Ya34YSM4YWl4Ya8XCIsXG4gICAgXCLhhInhhbXhhrfhhJHhhaHhhqtcIixcbiAgICBcIuGEiuGFoeGGvOGEg+GFruGGvOGEi+GFtVwiLFxuICAgIFwi4YSK4YW14YSF4YWz4Ya3XCIsXG4gICAgXCLhhIrhhbXhhIvhhaHhhrpcIixcbiAgICBcIuGEi+GFoeGEgOGFoeGEiuGFtVwiLFxuICAgIFwi4YSL4YWh4YSC4YWh4YSL4YWu4Yar4YSJ4YWlXCIsXG4gICAgXCLhhIvhhaHhhIPhhbPhhILhhbXhhrdcIixcbiAgICBcIuGEi+GFoeGEg+GFs+GGr1wiLFxuICAgIFwi4YSL4YWh4YSJ4YWx4YSL4YWu4Ya3XCIsXG4gICAgXCLhhIvhhaHhhInhhbPhhJHhhaHhhq/hhJDhhbNcIixcbiAgICBcIuGEi+GFoeGEieGFteGEi+GFoVwiLFxuICAgIFwi4YSL4YWh4YSL4YWu4Yav4YSF4YWlXCIsXG4gICAgXCLhhIvhhaHhhIzhhaXhhIrhhbVcIixcbiAgICBcIuGEi+GFoeGEjOGFruGGt+GEhuGFoVwiLFxuICAgIFwi4YSL4YWh4YSM4YW14YaoXCIsXG4gICAgXCLhhIvhhaHhhI7hhbXhhrdcIixcbiAgICBcIuGEi+GFoeGEkeGFoeGEkOGFs1wiLFxuICAgIFwi4YSL4YWh4YSR4YWz4YSF4YW14YSP4YWhXCIsXG4gICAgXCLhhIvhhaHhhJHhhbPhhrdcIixcbiAgICBcIuGEi+GFoeGEkuGFqeGGuFwiLFxuICAgIFwi4YSL4YWh4YSS4YWz4YarXCIsXG4gICAgXCLhhIvhhaHhhqjhhIDhhbVcIixcbiAgICBcIuGEi+GFoeGGqOGEhuGFqeGGvFwiLFxuICAgIFwi4YSL4YWh4Yao4YSJ4YWuXCIsXG4gICAgXCLhhIvhhaHhhqvhhIDhhaJcIixcbiAgICBcIuGEi+GFoeGGq+GEgOGFp+GGvFwiLFxuICAgIFwi4YSL4YWh4Yar4YSA4YWqXCIsXG4gICAgXCLhhIvhhaHhhqvhhILhhaJcIixcbiAgICBcIuGEi+GFoeGGq+GEguGFp+GGvFwiLFxuICAgIFwi4YSL4YWh4Yar4YSD4YWp4Ya8XCIsXG4gICAgXCLhhIvhhaHhhqvhhIfhhaHhhrxcIixcbiAgICBcIuGEi+GFoeGGq+GEh+GFrlwiLFxuICAgIFwi4YSL4YWh4Yar4YSM4YWuXCIsXG4gICAgXCLhhIvhhaHhhq/hhIXhha7hhIbhhbXhhILhhbLhhrdcIixcbiAgICBcIuGEi+GFoeGGr+GEj+GFqeGEi+GFqeGGr1wiLFxuICAgIFwi4YSL4YWh4Ya34YSJ4YW1XCIsXG4gICAgXCLhhIvhhaHhhrfhhI/hhaXhhrpcIixcbiAgICBcIuGEi+GFoeGGuOGEheGFp+GGqFwiLFxuICAgIFwi4YSL4YWh4YeB4YSC4YWh4YavXCIsXG4gICAgXCLhhIvhhaHhh4HhhIbhha7hhqtcIixcbiAgICBcIuGEi+GFouGEi+GFteGGq1wiLFxuICAgIFwi4YSL4YWi4YSM4YWl4Ya8XCIsXG4gICAgXCLhhIvhhaLhhqjhhInhha5cIixcbiAgICBcIuGEi+GFouGGr+GEh+GFpeGGt1wiLFxuICAgIFwi4YSL4YWj4YSA4YWh4YarXCIsXG4gICAgXCLhhIvhhaPhhIPhhaHhhqtcIixcbiAgICBcIuGEi+GFo+GEi+GFqeGGvFwiLFxuICAgIFwi4YSL4YWj4Yao4YSA4YWh4YarXCIsXG4gICAgXCLhhIvhhaPhhqjhhIDhha7hhqhcIixcbiAgICBcIuGEi+GFo+GGqOGEieGFqeGGqFwiLFxuICAgIFwi4YSL4YWj4Yao4YSJ4YWuXCIsXG4gICAgXCLhhIvhhaPhhqjhhIzhhaXhhrdcIixcbiAgICBcIuGEi+GFo+GGqOGEkeGFruGGt1wiLFxuICAgIFwi4YSL4YWj4Yao4YSS4YWp4Yar4YSC4YWnXCIsXG4gICAgXCLhhIvhhaPhhrzhhILhhafhhrdcIixcbiAgICBcIuGEi+GFo+GGvOGEheGFp+GGqFwiLFxuICAgIFwi4YSL4YWj4Ya84YSG4YWh4YavXCIsXG4gICAgXCLhhIvhhaPhhrzhhIfhhaLhhI7hha5cIixcbiAgICBcIuGEi+GFo+GGvOGEjOGFrlwiLFxuICAgIFwi4YSL4YWj4Ya84YSR4YWhXCIsXG4gICAgXCLhhIvhhaXhhIPhha7hhrdcIixcbiAgICBcIuGEi+GFpeGEheGFp+GEi+GFruGGt1wiLFxuICAgIFwi4YSL4YWl4YSF4YWz4YarXCIsXG4gICAgXCLhhIvhhaXhhIzhhabhhrrhhIfhhaHhhrdcIixcbiAgICBcIuGEi+GFpeGEjeGFouGGu+GEg+GFs+GGq1wiLFxuICAgIFwi4YSL4YWl4YSN4YWl4YSD4YWh4YSA4YWhXCIsXG4gICAgXCLhhIvhhaXhhI3hhaXhhqvhhIzhhbVcIixcbiAgICBcIuGEi+GFpeGGq+GEguGFtVwiLFxuICAgIFwi4YSL4YWl4Yar4YSD4YWl4YaoXCIsXG4gICAgXCLhhIvhhaXhhqvhhIXhhanhhqtcIixcbiAgICBcIuGEi+GFpeGGq+GEi+GFpVwiLFxuICAgIFwi4YSL4YWl4Yav4YSA4YWu4YavXCIsXG4gICAgXCLhhIvhhaXhhq/hhIXhhbPhhqtcIixcbiAgICBcIuGEi+GFpeGGr+GEi+GFs+GGt1wiLFxuICAgIFwi4YSL4YWl4Yav4YSR4YW14Ya6XCIsXG4gICAgXCLhhIvhhaXhhrfhhIbhhaFcIixcbiAgICBcIuGEi+GFpeGGuOGEhuGFrlwiLFxuICAgIFwi4YSL4YWl4Ya44YSM4YWp4Ya8XCIsXG4gICAgXCLhhIvhhaXhhrjhhI7hhaZcIixcbiAgICBcIuGEi+GFpeGGvOGEg+GFpeGGvOGEi+GFtVwiLFxuICAgIFwi4YSL4YWl4Ya84YSG4YWh4Ya8XCIsXG4gICAgXCLhhIvhhaXhhrzhhJDhhaXhhIXhhbVcIixcbiAgICBcIuGEi+GFpeGGveGEgOGFs+GEjOGFplwiLFxuICAgIFwi4YSL4YWm4YSC4YWl4YSM4YW1XCIsXG4gICAgXCLhhIvhhabhhIvhhaXhhI/hhaXhhqtcIixcbiAgICBcIuGEi+GFpuGGq+GEjOGFteGGq1wiLFxuICAgIFwi4YSL4YWn4YSA4YWl4YarXCIsXG4gICAgXCLhhIvhhafhhIDhhanhhInhhaLhhrxcIixcbiAgICBcIuGEi+GFp+GEgOGFquGGq1wiLFxuICAgIFwi4YSL4YWn4YSA4YWu4YarXCIsXG4gICAgXCLhhIvhhafhhIDhha/hhqtcIixcbiAgICBcIuGEi+GFp+GEg+GFouGEieGFouGGvFwiLFxuICAgIFwi4YSL4YWn4YSD4YWl4YayXCIsXG4gICAgXCLhhIvhhafhhIPhhanhhrzhhInhhaLhhrxcIixcbiAgICBcIuGEi+GFp+GEg+GFs+GGq1wiLFxuICAgIFwi4YSL4YWn4YSF4YWp4YarXCIsXG4gICAgXCLhhIvhhafhhIXhhbPhhrdcIixcbiAgICBcIuGEi+GFp+GEieGFpeGGulwiLFxuICAgIFwi4YSL4YWn4YSJ4YWl4Ya8XCIsXG4gICAgXCLhhIvhhafhhIvhharhhrxcIixcbiAgICBcIuGEi+GFp+GEi+GFteGGq1wiLFxuICAgIFwi4YSL4YWn4YSM4YWl4Yar4YSS4YW1XCIsXG4gICAgXCLhhIvhhafhhIzhhbXhhqjhhIvhha/hhqtcIixcbiAgICBcIuGEi+GFp+GEkuGFoeGGqOGEieGFouGGvFwiLFxuICAgIFwi4YSL4YWn4YSS4YWi4Ya8XCIsXG4gICAgXCLhhIvhhafhhqjhhInhhaFcIixcbiAgICBcIuGEi+GFp+GGqOGEieGFtVwiLFxuICAgIFwi4YSL4YWn4Yao4YSS4YWh4YavXCIsXG4gICAgXCLhhIvhhafhhqvhhIDhhafhhq9cIixcbiAgICBcIuGEi+GFp+GGq+GEgOGFrlwiLFxuICAgIFwi4YSL4YWn4Yar4YSA4YWz4YaoXCIsXG4gICAgXCLhhIvhhafhhqvhhIDhhbVcIixcbiAgICBcIuGEi+GFp+GGq+GEheGFoeGGqFwiLFxuICAgIFwi4YSL4YWn4Yar4YSJ4YWl4YavXCIsXG4gICAgXCLhhIvhhafhhqvhhInhhaZcIixcbiAgICBcIuGEi+GFp+GGq+GEieGFqeGGqFwiLFxuICAgIFwi4YSL4YWn4Yar4YSJ4YWz4Ya4XCIsXG4gICAgXCLhhIvhhafhhqvhhIvhhaJcIixcbiAgICBcIuGEi+GFp+GGq+GEi+GFqOGEi+GFteGGq1wiLFxuICAgIFwi4YSL4YWn4Yar4YSL4YW14YarXCIsXG4gICAgXCLhhIvhhafhhqvhhIzhhaHhhrxcIixcbiAgICBcIuGEi+GFp+GGq+GEjOGFrlwiLFxuICAgIFwi4YSL4YWn4Yar4YSO4YWu4YavXCIsXG4gICAgXCLhhIvhhafhhqvhhJHhhbXhhq9cIixcbiAgICBcIuGEi+GFp+GGq+GEkuGFoeGGuFwiLFxuICAgIFwi4YSL4YWn4Yar4YSS4YWyXCIsXG4gICAgXCLhhIvhhafhhq/hhIDhhbVcIixcbiAgICBcIuGEi+GFp+GGr+GEhuGFolwiLFxuICAgIFwi4YSL4YWn4Yav4YSJ4YWsXCIsXG4gICAgXCLhhIvhhafhhq/hhInhhbXhhrfhhJLhhbVcIixcbiAgICBcIuGEi+GFp+GGr+GEjOGFpeGGvFwiLFxuICAgIFwi4YSL4YWn4Yav4YSO4YWhXCIsXG4gICAgXCLhhIvhhafhhq/hhJLhhbPhhq9cIixcbiAgICBcIuGEi+GFp+GGt+GEheGFp1wiLFxuICAgIFwi4YSL4YWn4Ya44YSJ4YWlXCIsXG4gICAgXCLhhIvhhafhhrzhhIDhha7hhqhcIixcbiAgICBcIuGEi+GFp+GGvOGEguGFoeGGt1wiLFxuICAgIFwi4YSL4YWn4Ya84YSJ4YWh4Ya8XCIsXG4gICAgXCLhhIvhhafhhrzhhIvhhaPhhrxcIixcbiAgICBcIuGEi+GFp+GGvOGEi+GFp+GGqFwiLFxuICAgIFwi4YSL4YWn4Ya84YSL4YWu4Ya8XCIsXG4gICAgXCLhhIvhhafhhrzhhIvhha/hhqvhhJLhhbVcIixcbiAgICBcIuGEi+GFp+GGvOGEkuGFoVwiLFxuICAgIFwi4YSL4YWn4Ya84YSS4YWj4Ya8XCIsXG4gICAgXCLhhIvhhafhhrzhhJLhhanhhqtcIixcbiAgICBcIuGEi+GFp+GGvOGEkuGFqlwiLFxuICAgIFwi4YSL4YWn4YeB4YSA4YWu4YSF4YW1XCIsXG4gICAgXCLhhIvhhafhh4HhhIfhhaHhhrxcIixcbiAgICBcIuGEi+GFp+GHgeGEjOGFteGGuFwiLFxuICAgIFwi4YSL4YWo4YSA4YWh4Ya3XCIsXG4gICAgXCLhhIvhhajhhIDhhbPhhrdcIixcbiAgICBcIuGEi+GFqOGEh+GFoeGGvFwiLFxuICAgIFwi4YSL4YWo4YSJ4YWh4YarXCIsXG4gICAgXCLhhIvhhajhhInhhaHhhrxcIixcbiAgICBcIuGEi+GFqOGEieGFpeGGq1wiLFxuICAgIFwi4YSL4YWo4YSJ4YWu4YavXCIsXG4gICAgXCLhhIvhhajhhInhhbPhhrhcIixcbiAgICBcIuGEi+GFqOGEieGFteGGqOGEjOGFoeGGvFwiLFxuICAgIFwi4YSL4YWo4YSL4YWj4YaoXCIsXG4gICAgXCLhhIvhhajhhIzhhaXhhqtcIixcbiAgICBcIuGEi+GFqOGEjOGFpeGGr1wiLFxuICAgIFwi4YSL4YWo4YSM4YWl4Ya8XCIsXG4gICAgXCLhhIvhhajhhI/hhaXhhqvhhIPhhaJcIixcbiAgICBcIuGEi+GFqOGGuuGEguGFoeGGr1wiLFxuICAgIFwi4YSL4YWp4YSC4YWz4YavXCIsXG4gICAgXCLhhIvhhanhhIXhhaHhhqhcIixcbiAgICBcIuGEi+GFqeGEheGFouGGuuGEg+GFqeGGvOGEi+GFoeGGq1wiLFxuICAgIFwi4YSL4YWp4YSF4YWm4Yar4YSM4YW1XCIsXG4gICAgXCLhhIvhhanhhIXhhanhhIzhhbVcIixcbiAgICBcIuGEi+GFqeGEheGFs+GGq+GEh+GFoeGGr1wiLFxuICAgIFwi4YSL4YWp4YSH4YWz4YarXCIsXG4gICAgXCLhhIvhhanhhInhhbXhhrhcIixcbiAgICBcIuGEi+GFqeGEi+GFp+GGt1wiLFxuICAgIFwi4YSL4YWp4YSL4YWv4YavXCIsXG4gICAgXCLhhIvhhanhhIzhhaXhhqtcIixcbiAgICBcIuGEi+GFqeGEjOGFteGGqFwiLFxuICAgIFwi4YSL4YWp4YSM4YW14Ya84YSL4YWlXCIsXG4gICAgXCLhhIvhhanhhJHhhabhhIXhhaFcIixcbiAgICBcIuGEi+GFqeGEkeGFteGEieGFs+GEkOGFpuGGr1wiLFxuICAgIFwi4YSL4YWp4YSS4YW14YSF4YWnXCIsXG4gICAgXCLhhIvhhanhhqjhhInhhaHhhrxcIixcbiAgICBcIuGEi+GFqeGGqOGEieGFruGEieGFrlwiLFxuICAgIFwi4YSL4YWp4Yar4YSA4YWh4Ya9XCIsXG4gICAgXCLhhIvhhanhhqvhhIXhhaHhhIvhhbXhhqtcIixcbiAgICBcIuGEi+GFqeGGq+GEhuGFqeGGt1wiLFxuICAgIFwi4YSL4YWp4Yar4YSM4YWp4Ya84YSL4YW14YavXCIsXG4gICAgXCLhhIvhhanhhqvhhJDhhanhhrxcIixcbiAgICBcIuGEi+GFqeGGr+GEgOGFoeGEi+GFs+GGr1wiLFxuICAgIFwi4YSL4YWp4Yav4YSF4YW14Ya34YSR4YW14YaoXCIsXG4gICAgXCLhhIvhhanhhq/hhJLhhaJcIixcbiAgICBcIuGEi+GFqeGGuuGEjuGFoeGEheGFteGGt1wiLFxuICAgIFwi4YSL4YWq4YSL4YW14YSJ4YWn4YSO4YWzXCIsXG4gICAgXCLhhIvhharhhIvhhbXhhqtcIixcbiAgICBcIuGEi+GFquGGq+GEieGFpeGGvFwiLFxuICAgIFwi4YSL4YWq4Yar4YSM4YWl4YarXCIsXG4gICAgXCLhhIvhharhhrzhhIfhhbVcIixcbiAgICBcIuGEi+GFquGGvOGEjOGFoVwiLFxuICAgIFwi4YSL4YWr4YSC4YWj4YSS4YWh4YSG4YWn4YarXCIsXG4gICAgXCLhhIvhhavhhqvhhIzhhbVcIixcbiAgICBcIuGEi+GFrOGEgOGFoeGGuuGEjOGFteGGuFwiLFxuICAgIFwi4YSL4YWs4YSA4YWu4YaoXCIsXG4gICAgXCLhhIvhhazhhIXhhanhhIvhha7hhrdcIixcbiAgICBcIuGEi+GFrOGEieGFoeGGt+GEjuGFqeGGq1wiLFxuICAgIFwi4YSL4YWs4YSO4YWu4YavXCIsXG4gICAgXCLhhIvhhazhhI7hhbXhhrdcIixcbiAgICBcIuGEi+GFrOGEkuGFoeGGr+GEhuGFpeGEguGFtVwiLFxuICAgIFwi4YSL4YWs4Yar4YSH4YWh4YavXCIsXG4gICAgXCLhhIvhhazhhqvhhInhhanhhqtcIixcbiAgICBcIuGEi+GFrOGGq+GEjeGFqeGGqFwiLFxuICAgIFwi4YSL4YWt4YSA4YWz4Ya3XCIsXG4gICAgXCLhhIvhha3hhIvhhbXhhq9cIixcbiAgICBcIuGEi+GFreGEjOGFs+GGt1wiLFxuICAgIFwi4YSL4YWt4YSO4YWl4Ya8XCIsXG4gICAgXCLhhIvhha3hhrzhhIDhhbVcIixcbiAgICBcIuGEi+GFreGGvOGEieGFpVwiLFxuICAgIFwi4YSL4YWt4Ya84YSL4YWlXCIsXG4gICAgXCLhhIvhha7hhInhhaHhhqtcIixcbiAgICBcIuGEi+GFruGEieGFpeGGq1wiLFxuICAgIFwi4YSL4YWu4YSJ4YWz4Ya8XCIsXG4gICAgXCLhhIvhha7hhIvhhafhhqvhhJLhhbVcIixcbiAgICBcIuGEi+GFruGEjOGFpeGGvFwiLFxuICAgIFwi4YSL4YWu4YSO4YWm4YSA4YWu4YaoXCIsXG4gICAgXCLhhIvhha7hhJHhhafhhqtcIixcbiAgICBcIuGEi+GFruGGq+GEg+GFqeGGvFwiLFxuICAgIFwi4YSL4YWu4Yar4YSG4YWn4Ya8XCIsXG4gICAgXCLhhIvhha7hhqvhhIfhhaHhhqtcIixcbiAgICBcIuGEi+GFruGGq+GEjOGFpeGGq1wiLFxuICAgIFwi4YSL4YWu4Yar4YSS4YWi4Ya8XCIsXG4gICAgXCLhhIvhha7hhq/hhInhhaHhhqtcIixcbiAgICBcIuGEi+GFruGGr+GEi+GFs+GGt1wiLFxuICAgIFwi4YSL4YWu4Ya34YSM4YW14Yao4YSL4YW14Ya3XCIsXG4gICAgXCLhhIvhha7hhrrhhIvhhaXhhIXhhbPhhqtcIixcbiAgICBcIuGEi+GFruGGuuGEi+GFs+GGt1wiLFxuICAgIFwi4YSL4YWv4YSC4YWh4YaoXCIsXG4gICAgXCLhhIvhha/hhqvhhIDhhalcIixcbiAgICBcIuGEi+GFr+GGq+GEheGFolwiLFxuICAgIFwi4YSL4YWv4Yar4YSJ4YWlXCIsXG4gICAgXCLhhIvhha/hhqvhhInhha7hhrzhhIvhhbVcIixcbiAgICBcIuGEi+GFr+GGq+GEi+GFteGGq1wiLFxuICAgIFwi4YSL4YWv4Yar4YSM4YWh4Ya8XCIsXG4gICAgXCLhhIvhha/hhqvhhJHhhbXhhInhhbNcIixcbiAgICBcIuGEi+GFr+GGr+GEgOGFs+GGuFwiLFxuICAgIFwi4YSL4YWv4Yav4YSD4YWz4YSP4YWl4Ya4XCIsXG4gICAgXCLhhIvhha/hhq/hhInhhaZcIixcbiAgICBcIuGEi+GFr+GGr+GEi+GFreGEi+GFteGGr1wiLFxuICAgIFwi4YSL4YWw4YSL4YW14YSQ4YWlXCIsXG4gICAgXCLhhIvhhbHhhIfhhaHhhqtcIixcbiAgICBcIuGEi+GFseGEh+GFpeGGuFwiLFxuICAgIFwi4YSL4YWx4YSJ4YWl4Ya8XCIsXG4gICAgXCLhhIvhhbHhhIvhha/hhqtcIixcbiAgICBcIuGEi+GFseGEkuGFpeGGt1wiLFxuICAgIFwi4YSL4YWx4YSS4YWn4Ya4XCIsXG4gICAgXCLhhIvhhbHhhrrhhInhhaHhhIXhhaHhhrdcIixcbiAgICBcIuGEi+GFsuGEguGFoeGGq+GEkuGFtVwiLFxuICAgIFwi4YSL4YWy4YSF4YWl4Ya4XCIsXG4gICAgXCLhhIvhhbLhhIbhhafhhrxcIixcbiAgICBcIuGEi+GFsuGEhuGFruGGr1wiLFxuICAgIFwi4YSL4YWy4YSJ4YWh4YarXCIsXG4gICAgXCLhhIvhhbLhhIzhhaXhhqhcIixcbiAgICBcIuGEi+GFsuGEjuGFteGEi+GFr+GGq1wiLFxuICAgIFwi4YSL4YWy4YSS4YWh4YaoXCIsXG4gICAgXCLhhIvhhbLhhJLhhaLhhrxcIixcbiAgICBcIuGEi+GFsuGEkuGFp+GGvFwiLFxuICAgIFwi4YSL4YWy4Yao4YSA4YWu4YarXCIsXG4gICAgXCLhhIvhhbLhhqjhhInhhaHhhrxcIixcbiAgICBcIuGEi+GFsuGGqOGEieGFteGGuFwiLFxuICAgIFwi4YSL4YWy4Yao4YSO4YWmXCIsXG4gICAgXCLhhIvhhbPhhqvhhJLhhaLhhrxcIixcbiAgICBcIuGEi+GFs+GGt+GEheGFp+GGqFwiLFxuICAgIFwi4YSL4YWz4Ya34YSF4YWtXCIsXG4gICAgXCLhhIvhhbPhhrfhhIfhhaHhhqtcIixcbiAgICBcIuGEi+GFs+GGt+GEieGFpeGGvFwiLFxuICAgIFwi4YSL4YWz4Ya34YSJ4YW14YaoXCIsXG4gICAgXCLhhIvhhbPhhrfhhIvhhaHhhqhcIixcbiAgICBcIuGEi+GFs+GGt+GEjOGFrlwiLFxuICAgIFwi4YSL4YW04YSA4YWn4YarXCIsXG4gICAgXCLhhIvhhbThhILhhanhhqtcIixcbiAgICBcIuGEi+GFtOGEhuGFruGGq1wiLFxuICAgIFwi4YSL4YW04YSH4YWp4YaoXCIsXG4gICAgXCLhhIvhhbThhInhhbXhhqhcIixcbiAgICBcIuGEi+GFtOGEieGFteGGt1wiLFxuICAgIFwi4YSL4YW04YSL4YWs4YSF4YWpXCIsXG4gICAgXCLhhIvhhbThhIvhha3hhqhcIixcbiAgICBcIuGEi+GFtOGEi+GFr+GGq1wiLFxuICAgIFwi4YSL4YW04YSS4YWh4YaoXCIsXG4gICAgXCLhhIvhhbXhhIDhhaXhhrpcIixcbiAgICBcIuGEi+GFteGEgOGFqeGGulwiLFxuICAgIFwi4YSL4YW14YSC4YWn4Ya3XCIsXG4gICAgXCLhhIvhhbXhhILhhanhhrdcIixcbiAgICBcIuGEi+GFteGEg+GFoeGGr1wiLFxuICAgIFwi4YSL4YW14YSD4YWi4YSF4YWpXCIsXG4gICAgXCLhhIvhhbXhhIPhhanhhrxcIixcbiAgICBcIuGEi+GFteGEheGFpeGHguGEgOGFplwiLFxuICAgIFwi4YSL4YW14YSF4YWn4Yao4YSJ4YWlXCIsXG4gICAgXCLhhIvhhbXhhIXhhanhhqvhhIzhhaXhhqhcIixcbiAgICBcIuGEi+GFteGEheGFs+GGt1wiLFxuICAgIFwi4YSL4YW14YSG4YW14YarXCIsXG4gICAgXCLhhIvhhbXhhIfhhaHhhq/hhInhhalcIixcbiAgICBcIuGEi+GFteGEh+GFp+GGr1wiLFxuICAgIFwi4YSL4YW14YSH4YWu4YavXCIsXG4gICAgXCLhhIvhhbXhhIjhhaHhhq9cIixcbiAgICBcIuGEi+GFteGEieGFoeGGvFwiLFxuICAgIFwi4YSL4YW14YSJ4YWl4Ya8XCIsXG4gICAgXCLhhIvhhbXhhInhhbPhhq9cIixcbiAgICBcIuGEi+GFteGEi+GFo+GEgOGFtVwiLFxuICAgIFwi4YSL4YW14YSL4YWt4Ya8XCIsXG4gICAgXCLhhIvhhbXhhIvhha7hhrpcIixcbiAgICBcIuGEi+GFteGEi+GFr+GGr1wiLFxuICAgIFwi4YSL4YW14YSL4YWz4Yao4YSA4YWpXCIsXG4gICAgXCLhhIvhhbXhhIvhhbXhhqhcIixcbiAgICBcIuGEi+GFteGEjOGFpeGGq1wiLFxuICAgIFwi4YSL4YW14YSM4YWu4Ya8XCIsXG4gICAgXCLhhIvhhbXhhJDhhbPhhq7hhILhhaHhhq9cIixcbiAgICBcIuGEi+GFteGEkOGFs+GGr1wiLFxuICAgIFwi4YSL4YW14YSS4YWp4YarXCIsXG4gICAgXCLhhIvhhbXhhqvhhIDhhaHhhqtcIixcbiAgICBcIuGEi+GFteGGq+GEgOGFp+GGqFwiLFxuICAgIFwi4YSL4YW14Yar4YSA4YWp4Ya8XCIsXG4gICAgXCLhhIvhhbXhhqvhhIDhha5cIixcbiAgICBcIuGEi+GFteGGq+GEgOGFs+GGq1wiLFxuICAgIFwi4YSL4YW14Yar4YSA4YW1XCIsXG4gICAgXCLhhIvhhbXhhqvhhIPhhalcIixcbiAgICBcIuGEi+GFteGGq+GEheGFslwiLFxuICAgIFwi4YSL4YW14Yar4YSG4YWu4YavXCIsXG4gICAgXCLhhIvhhbXhhqvhhInhhaLhhrxcIixcbiAgICBcIuGEi+GFteGGq+GEieGFq1wiLFxuICAgIFwi4YSL4YW14Yar4YSL4YWn4YarXCIsXG4gICAgXCLhhIvhhbXhhqvhhIvhha/hhqtcIixcbiAgICBcIuGEi+GFteGGq+GEjOGFolwiLFxuICAgIFwi4YSL4YW14Yar4YSM4YWp4Ya8XCIsXG4gICAgXCLhhIvhhbXhhqvhhI7hhaXhhqtcIixcbiAgICBcIuGEi+GFteGGq+GEjuGFplwiLFxuICAgIFwi4YSL4YW14Yar4YSQ4YWl4YSC4YWm4Ya6XCIsXG4gICAgXCLhhIvhhbXhhqvhhJLhhaFcIixcbiAgICBcIuGEi+GFteGGq+GEkuGFp+GGvFwiLFxuICAgIFwi4YSL4YW14Yav4YSA4YWp4Ya4XCIsXG4gICAgXCLhhIvhhbXhhq/hhIDhhbVcIixcbiAgICBcIuGEi+GFteGGr+GEg+GFoeGGq1wiLFxuICAgIFwi4YSL4YW14Yav4YSD4YWiXCIsXG4gICAgXCLhhIvhhbXhhq/hhIPhhbPhhrxcIixcbiAgICBcIuGEi+GFteGGr+GEh+GFoeGGq1wiLFxuICAgIFwi4YSL4YW14Yav4YSH4YWp4YarXCIsXG4gICAgXCLhhIvhhbXhhq/hhIfhha5cIixcbiAgICBcIuGEi+GFteGGr+GEieGFoeGGvFwiLFxuICAgIFwi4YSL4YW14Yav4YSJ4YWi4Ya8XCIsXG4gICAgXCLhhIvhhbXhhq/hhInhhanhhqtcIixcbiAgICBcIuGEi+GFteGGr+GEi+GFreGEi+GFteGGr1wiLFxuICAgIFwi4YSL4YW14Yav4YSL4YWv4YavXCIsXG4gICAgXCLhhIvhhbXhhq/hhIzhhaXhhrxcIixcbiAgICBcIuGEi+GFteGGr+GEjOGFqeGGvFwiLFxuICAgIFwi4YSL4YW14Yav4YSM4YWu4YSL4YW14YavXCIsXG4gICAgXCLhhIvhhbXhhq/hhI3hhbXhhqhcIixcbiAgICBcIuGEi+GFteGGr+GEjuGFplwiLFxuICAgIFwi4YSL4YW14Yav4YSO4YW1XCIsXG4gICAgXCLhhIvhhbXhhq/hhJLhhaLhhrxcIixcbiAgICBcIuGEi+GFteGGr+GEkuGFrOGEi+GFreGGvFwiLFxuICAgIFwi4YSL4YW14Ya34YSA4YWz4Ya3XCIsXG4gICAgXCLhhIvhhbXhhrfhhIbhha5cIixcbiAgICBcIuGEi+GFteGGuOGEg+GFolwiLFxuICAgIFwi4YSL4YW14Ya44YSF4YWn4YaoXCIsXG4gICAgXCLhhIvhhbXhhrjhhIbhhaHhhrpcIixcbiAgICBcIuGEi+GFteGGuOGEieGFoVwiLFxuICAgIFwi4YSL4YW14Ya44YSJ4YWu4YavXCIsXG4gICAgXCLhhIvhhbXhhrjhhInhhbVcIixcbiAgICBcIuGEi+GFteGGuOGEi+GFr+GGq1wiLFxuICAgIFwi4YSL4YW14Ya44YSM4YWh4Ya8XCIsXG4gICAgXCLhhIvhhbXhhrjhhJLhhaHhhqhcIixcbiAgICBcIuGEjOGFoeGEgOGFoeGEi+GFreGGvFwiLFxuICAgIFwi4YSM4YWh4YSA4YWn4YaoXCIsXG4gICAgXCLhhIzhhaHhhIDhhbPhhqhcIixcbiAgICBcIuGEjOGFoeGEg+GFqeGGvFwiLFxuICAgIFwi4YSM4YWh4YSF4YWh4Ya8XCIsXG4gICAgXCLhhIzhhaHhhIfhha7hhInhhbXhhrdcIixcbiAgICBcIuGEjOGFoeGEieGFteGGqFwiLFxuICAgIFwi4YSM4YWh4YSJ4YW14YarXCIsXG4gICAgXCLhhIzhhaHhhIvhhafhhqtcIixcbiAgICBcIuGEjOGFoeGEi+GFr+GGq1wiLFxuICAgIFwi4YSM4YWh4YSL4YWy4YavXCIsXG4gICAgXCLhhIzhhaHhhIzhhaXhhqvhhIDhhaVcIixcbiAgICBcIuGEjOGFoeGEjOGFpeGGvFwiLFxuICAgIFwi4YSM4YWh4YSM4YWp4Yar4YSJ4YW14Ya3XCIsXG4gICAgXCLhhIzhhaHhhJHhhaHhhqtcIixcbiAgICBcIuGEjOGFoeGGqOGEgOGFoVwiLFxuICAgIFwi4YSM4YWh4Yao4YSC4YWn4YarXCIsXG4gICAgXCLhhIzhhaHhhqjhhInhhaXhhrxcIixcbiAgICBcIuGEjOGFoeGGqOGEi+GFpeGGuFwiLFxuICAgIFwi4YSM4YWh4Yao4YSL4YWt4Ya8XCIsXG4gICAgXCLhhIzhhaHhhqjhhIvhhbPhhqvhhIThhaHhhq9cIixcbiAgICBcIuGEjOGFoeGGqOGEkeGFruGGt1wiLFxuICAgIFwi4YSM4YWh4Yar4YSD4YW1XCIsXG4gICAgXCLhhIzhhaHhhqvhhIThhbPhhqhcIixcbiAgICBcIuGEjOGFoeGGq+GEjuGFtVwiLFxuICAgIFwi4YSM4YWh4Yav4YSG4YWp4Ya6XCIsXG4gICAgXCLhhIzhhaHhhrfhhIHhhaHhhqtcIixcbiAgICBcIuGEjOGFoeGGt+GEieGFruGEkuGFoeGGt1wiLFxuICAgIFwi4YSM4YWh4Ya34YSJ4YW1XCIsXG4gICAgXCLhhIzhhaHhhrfhhIvhhanhhrpcIixcbiAgICBcIuGEjOGFoeGGt+GEjOGFoeGEheGFtVwiLFxuICAgIFwi4YSM4YWh4Ya44YSM4YW1XCIsXG4gICAgXCLhhIzhhaHhhrzhhIDhharhhqtcIixcbiAgICBcIuGEjOGFoeGGvOGEgOGFruGGq1wiLFxuICAgIFwi4YSM4YWh4Ya84YSA4YW14YSA4YWh4YarXCIsXG4gICAgXCLhhIzhhaHhhrzhhIXhhaJcIixcbiAgICBcIuGEjOGFoeGGvOGEheGFqFwiLFxuICAgIFwi4YSM4YWh4Ya84YSF4YWzXCIsXG4gICAgXCLhhIzhhaHhhrzhhIbhhaFcIixcbiAgICBcIuGEjOGFoeGGvOGEhuGFp+GGq1wiLFxuICAgIFwi4YSM4YWh4Ya84YSG4YWpXCIsXG4gICAgXCLhhIzhhaHhhrzhhIbhhbVcIixcbiAgICBcIuGEjOGFoeGGvOGEh+GFtVwiLFxuICAgIFwi4YSM4YWh4Ya84YSJ4YWhXCIsXG4gICAgXCLhhIzhhaHhhrzhhInhhalcIixcbiAgICBcIuGEjOGFoeGGvOGEieGFteGGqFwiLFxuICAgIFwi4YSM4YWh4Ya84YSL4YWi4YSL4YW14YarXCIsXG4gICAgXCLhhIzhhaHhhrzhhIvhhbXhhqtcIixcbiAgICBcIuGEjOGFoeGGvOGEjOGFpeGGt1wiLFxuICAgIFwi4YSM4YWh4Ya84YSO4YWhXCIsXG4gICAgXCLhhIzhhaHhhrzhhJLhhaHhhqjhhIDhhbPhhrdcIixcbiAgICBcIuGEjOGFouGEguGFs+GGvFwiLFxuICAgIFwi4YSM4YWi4YSI4YWh4Yav4YSF4YW1XCIsXG4gICAgXCLhhIzhhaLhhInhhaHhhqtcIixcbiAgICBcIuGEjOGFouGEieGFouGGvFwiLFxuICAgIFwi4YSM4YWi4YSM4YWh4Yao4YSC4YWn4YarXCIsXG4gICAgXCLhhIzhhaLhhIzhhaXhhrxcIixcbiAgICBcIuGEjOGFouGEjuGFouGEgOGFtVwiLFxuICAgIFwi4YSM4YWi4YSR4YWh4YarXCIsXG4gICAgXCLhhIzhhaLhhJLhhaHhhqhcIixcbiAgICBcIuGEjOGFouGEkuGFquGGr+GEi+GFreGGvFwiLFxuICAgIFwi4YSM4YWl4YSA4YWl4Ya6XCIsXG4gICAgXCLhhIzhhaXhhIDhhanhhIXhhbVcIixcbiAgICBcIuGEjOGFpeGEgOGFqeGGulwiLFxuICAgIFwi4YSM4YWl4YSC4YWn4YaoXCIsXG4gICAgXCLhhIzhhaXhhIXhhaXhhqtcIixcbiAgICBcIuGEjOGFpeGEheGFpeGHguGEgOGFplwiLFxuICAgIFwi4YSM4YWl4YSH4YWl4YarXCIsXG4gICAgXCLhhIzhhaXhhIvhha7hhq9cIixcbiAgICBcIuGEjOGFpeGEjOGFpeGGr+GEheGFqVwiLFxuICAgIFwi4YSM4YWl4YSO4YWu4YaoXCIsXG4gICAgXCLhhIzhhaXhhqjhhIDhhbPhhqhcIixcbiAgICBcIuGEjOGFpeGGqOGEg+GFoeGGvOGEkuGFtVwiLFxuICAgIFwi4YSM4YWl4Yao4YSJ4YWl4Ya8XCIsXG4gICAgXCLhhIzhhaXhhqjhhIvhha3hhrxcIixcbiAgICBcIuGEjOGFpeGGqOGEi+GFs+GGvFwiLFxuICAgIFwi4YSM4YWl4Yar4YSA4YWiXCIsXG4gICAgXCLhhIzhhaXhhqvhhIDhhanhhrxcIixcbiAgICBcIuGEjOGFpeGGq+GEgOGFtVwiLFxuICAgIFwi4YSM4YWl4Yar4YSD4YWh4YavXCIsXG4gICAgXCLhhIzhhaXhhqvhhIXhhaHhhIPhhalcIixcbiAgICBcIuGEjOGFpeGGq+GEhuGFoeGGvFwiLFxuICAgIFwi4YSM4YWl4Yar4YSG4YWu4YarXCIsXG4gICAgXCLhhIzhhaXhhqvhhIfhhaHhhqtcIixcbiAgICBcIuGEjOGFpeGGq+GEh+GFrlwiLFxuICAgIFwi4YSM4YWl4Yar4YSJ4YWmXCIsXG4gICAgXCLhhIzhhaXhhqvhhInhhbVcIixcbiAgICBcIuGEjOGFpeGGq+GEi+GFreGGvFwiLFxuICAgIFwi4YSM4YWl4Yar4YSM4YWhXCIsXG4gICAgXCLhhIzhhaXhhqvhhIzhhaLhhrxcIixcbiAgICBcIuGEjOGFpeGGq+GEjOGFrlwiLFxuICAgIFwi4YSM4YWl4Yar4YSO4YWl4YavXCIsXG4gICAgXCLhhIzhhaXhhqvhhI7hhaZcIixcbiAgICBcIuGEjOGFpeGGq+GEkOGFqeGGvFwiLFxuICAgIFwi4YSM4YWl4Yar4YSS4YWnXCIsXG4gICAgXCLhhIzhhaXhhqvhhJLhha5cIixcbiAgICBcIuGEjOGFpeGGr+GEg+GFolwiLFxuICAgIFwi4YSM4YWl4Yav4YSG4YWh4Ya8XCIsXG4gICAgXCLhhIzhhaXhhq/hhIfhhaHhhqtcIixcbiAgICBcIuGEjOGFpeGGr+GEi+GFo+GGqFwiLFxuICAgIFwi4YSM4YWl4Yav4YSO4YWhXCIsXG4gICAgXCLhhIzhhaXhhrfhhIDhhaXhhrdcIixcbiAgICBcIuGEjOGFpeGGt+GEieGFrlwiLFxuICAgIFwi4YSM4YWl4Ya34YSJ4YW14Ya3XCIsXG4gICAgXCLhhIzhhaXhhrfhhIvhha/hhqtcIixcbiAgICBcIuGEjOGFpeGGt+GEjOGFpeGGt1wiLFxuICAgIFwi4YSM4YWl4Ya34YSO4YWhXCIsXG4gICAgXCLhhIzhhaXhhrjhhIDhhbPhhqtcIixcbiAgICBcIuGEjOGFpeGGuOGEieGFtVwiLFxuICAgIFwi4YSM4YWl4Ya44YSO4YWp4YaoXCIsXG4gICAgXCLhhIzhhaXhhrrhhIDhhaHhhIXhhaHhhqhcIixcbiAgICBcIuGEjOGFpeGGvOGEgOGFpeGEjOGFoeGGvFwiLFxuICAgIFwi4YSM4YWl4Ya84YSD4YWpXCIsXG4gICAgXCLhhIzhhaXhhrzhhIXhhbLhhIzhhaHhhrxcIixcbiAgICBcIuGEjOGFpeGGvOGEheGFtVwiLFxuICAgIFwi4YSM4YWl4Ya84YSG4YWh4YavXCIsXG4gICAgXCLhhIzhhaXhhrzhhIbhhafhhqtcIixcbiAgICBcIuGEjOGFpeGGvOGEhuGFruGGq1wiLFxuICAgIFwi4YSM4YWl4Ya84YSH4YWh4Yar4YSD4YWiXCIsXG4gICAgXCLhhIzhhaXhhrzhhIfhhalcIixcbiAgICBcIuGEjOGFpeGGvOGEh+GFrlwiLFxuICAgIFwi4YSM4YWl4Ya84YSH4YW1XCIsXG4gICAgXCLhhIzhhaXhhrzhhInhhaHhhrxcIixcbiAgICBcIuGEjOGFpeGGvOGEieGFpeGGvFwiLFxuICAgIFwi4YSM4YWl4Ya84YSL4YWpXCIsXG4gICAgXCLhhIzhhaXhhrzhhIvhha/hhqtcIixcbiAgICBcIuGEjOGFpeGGvOGEjOGFoeGGvFwiLFxuICAgIFwi4YSM4YWl4Ya84YSM4YW1XCIsXG4gICAgXCLhhIzhhaXhhrzhhI7hhbVcIixcbiAgICBcIuGEjOGFpeGGvOGEkuGFquGGqOGEkuGFtVwiLFxuICAgIFwi4YSM4YWm4YSA4YWp4Ya8XCIsXG4gICAgXCLhhIzhhabhhIDhharhhIzhhaXhhrdcIixcbiAgICBcIuGEjOGFpuGEg+GFouGEheGFqVwiLFxuICAgIFwi4YSM4YWm4YSG4YWp4YaoXCIsXG4gICAgXCLhhIzhhabhhIfhhaHhhq9cIixcbiAgICBcIuGEjOGFpuGEh+GFpeGGuFwiLFxuICAgIFwi4YSM4YWm4YSJ4YWh4Ya64YSC4YWh4YavXCIsXG4gICAgXCLhhIzhhabhhIvhhaHhhqtcIixcbiAgICBcIuGEjOGFpuGEi+GFteGGr1wiLFxuICAgIFwi4YSM4YWm4YSM4YWh4YaoXCIsXG4gICAgXCLhhIzhhabhhIzhha7hhIPhhalcIixcbiAgICBcIuGEjOGFpuGEjuGFruGGr1wiLFxuICAgIFwi4YSM4YWm4YSR4YWu4Ya3XCIsXG4gICAgXCLhhIzhhabhhJLhhaHhhqtcIixcbiAgICBcIuGEjOGFqeGEgOGFoeGGqFwiLFxuICAgIFwi4YSM4YWp4YSA4YWl4YarXCIsXG4gICAgXCLhhIzhhanhhIDhhbPhhrdcIixcbiAgICBcIuGEjOGFqeGEgOGFteGGvFwiLFxuICAgIFwi4YSM4YWp4YSG4YWn4Ya8XCIsXG4gICAgXCLhhIzhhanhhIbhhbXhhIXhha1cIixcbiAgICBcIuGEjOGFqeGEieGFoeGGvFwiLFxuICAgIFwi4YSM4YWp4YSJ4YWl4YarXCIsXG4gICAgXCLhhIzhhanhhIvhha3hhrzhhJLhhbVcIixcbiAgICBcIuGEjOGFqeGEjOGFpeGGr1wiLFxuICAgIFwi4YSM4YWp4YSM4YWl4Ya8XCIsXG4gICAgXCLhhIzhhanhhIzhhbXhhqhcIixcbiAgICBcIuGEjOGFqeGGq+GEg+GFouGGuuGEhuGFoeGGr1wiLFxuICAgIFwi4YSM4YWp4Yar4YSM4YWiXCIsXG4gICAgXCLhhIzhhanhhq/hhIvhhaXhhrhcIixcbiAgICBcIuGEjOGFqeGGr+GEi+GFs+GGt1wiLFxuICAgIFwi4YSM4YWp4Ya84YSA4YWtXCIsXG4gICAgXCLhhIzhhanhhrzhhIXhhalcIixcbiAgICBcIuGEjOGFqeGGvOGEheGFslwiLFxuICAgIFwi4YSM4YWp4Ya84YSJ4YWp4YSF4YW1XCIsXG4gICAgXCLhhIzhhanhhrzhhIvhhaXhhrjhhIvhha/hhqtcIixcbiAgICBcIuGEjOGFqeGGvOGEjOGFqeGGvFwiLFxuICAgIFwi4YSM4YWp4Ya84YSS4YWh4Ya4XCIsXG4gICAgXCLhhIzhharhhInhhaXhhqhcIixcbiAgICBcIuGEjOGFrOGEi+GFteGGq1wiLFxuICAgIFwi4YSM4YWu4YSA4YWq4Yar4YSM4YWl4YaoXCIsXG4gICAgXCLhhIzhha7hhIXhhbPhhrdcIixcbiAgICBcIuGEjOGFruGEhuGFoeGGr1wiLFxuICAgIFwi4YSM4YWu4YSG4YWl4YSC4YW1XCIsXG4gICAgXCLhhIzhha7hhIbhhaXhhqhcIixcbiAgICBcIuGEjOGFruGEhuGFruGGq1wiLFxuICAgIFwi4YSM4YWu4YSG4YW14YarXCIsXG4gICAgXCLhhIzhha7hhIfhhaHhhrxcIixcbiAgICBcIuGEjOGFruGEh+GFp+GGq1wiLFxuICAgIFwi4YSM4YWu4YSJ4YW14YaoXCIsXG4gICAgXCLhhIzhha7hhIvhhbXhhqtcIixcbiAgICBcIuGEjOGFruGEi+GFteGGr1wiLFxuICAgIFwi4YSM4YWu4YSM4YWh4Ya8XCIsXG4gICAgXCLhhIzhha7hhIzhhaXhhqvhhIzhhaFcIixcbiAgICBcIuGEjOGFruGEkOGFouGGqFwiLFxuICAgIFwi4YSM4YWu4Yar4YSH4YW1XCIsXG4gICAgXCLhhIzhha7hhq/hhIDhhaXhhIXhhbVcIixcbiAgICBcIuGEjOGFruGGr+GEgOGFtVwiLFxuICAgIFwi4YSM4YWu4Yav4YSG4YWu4YSC4YW0XCIsXG4gICAgXCLhhIzhha7hhrzhhIDhhaHhhqtcIixcbiAgICBcIuGEjOGFruGGvOGEgOGFqOGEh+GFoeGGvOGEieGFqeGGvFwiLFxuICAgIFwi4YSM4YWu4Ya84YSA4YWu4YaoXCIsXG4gICAgXCLhhIzhha7hhrzhhILhhafhhqtcIixcbiAgICBcIuGEjOGFruGGvOGEg+GFoeGGq1wiLFxuICAgIFwi4YSM4YWu4Ya84YSD4YWp4YaoXCIsXG4gICAgXCLhhIzhha7hhrzhhIfhhaHhhqtcIixcbiAgICBcIuGEjOGFruGGvOGEh+GFrlwiLFxuICAgIFwi4YSM4YWu4Ya84YSJ4YWmXCIsXG4gICAgXCLhhIzhha7hhrzhhInhhanhhIDhhbXhhIvhhaXhhrhcIixcbiAgICBcIuGEjOGFruGGvOGEieGFruGGq1wiLFxuICAgIFwi4YSM4YWu4Ya84YSL4YWh4Ya8XCIsXG4gICAgXCLhhIzhha7hhrzhhIvhha1cIixcbiAgICBcIuGEjOGFruGGvOGEkuGFoeGGqOGEgOGFrVwiLFxuICAgIFwi4YSM4YWz4Yao4YSJ4YWl4YaoXCIsXG4gICAgXCLhhIzhhbPhhqjhhInhhbVcIixcbiAgICBcIuGEjOGFs+GGr+GEgOGFpeGEi+GFruGGt1wiLFxuICAgIFwi4YSM4YWz4Ya84YSA4YWhXCIsXG4gICAgXCLhhIzhhbPhhrzhhIDhhaVcIixcbiAgICBcIuGEjOGFs+GGvOGEgOGFr+GGq1wiLFxuICAgIFwi4YSM4YWz4Ya84YSJ4YWh4Ya8XCIsXG4gICAgXCLhhIzhhbPhhrzhhInhhaZcIixcbiAgICBcIuGEjOGFteGEgOGFoeGGqFwiLFxuICAgIFwi4YSM4YW14YSA4YWh4Ya4XCIsXG4gICAgXCLhhIzhhbXhhIDhhafhhrxcIixcbiAgICBcIuGEjOGFteGEgOGFs+GGqOGEkuGFtVwiLFxuICAgIFwi4YSM4YW14YSA4YWz4Ya3XCIsXG4gICAgXCLhhIzhhbXhhIDhhbPhhrhcIixcbiAgICBcIuGEjOGFteGEguGFs+GGvFwiLFxuICAgIFwi4YSM4YW14YSF4YWz4Ya34YSA4YW14YavXCIsXG4gICAgXCLhhIzhhbXhhIXhhbXhhInhhaHhhqtcIixcbiAgICBcIuGEjOGFteGEh+GFoeGGvFwiLFxuICAgIFwi4YSM4YW14YSH4YWu4Ya8XCIsXG4gICAgXCLhhIzhhbXhhInhhbXhhqhcIixcbiAgICBcIuGEjOGFteGEi+GFp+GGqFwiLFxuICAgIFwi4YSM4YW14YSL4YWu4YSA4YWiXCIsXG4gICAgXCLhhIzhhbXhhIvhha/hhqtcIixcbiAgICBcIuGEjOGFteGEjOGFpeGGqFwiLFxuICAgIFwi4YSM4YW14YSM4YWl4Ya3XCIsXG4gICAgXCLhhIzhhbXhhIzhhbXhhqtcIixcbiAgICBcIuGEjOGFteGEjuGFruGGr1wiLFxuICAgIFwi4YSM4YW14Yao4YSJ4YWl4YarXCIsXG4gICAgXCLhhIzhhbXhhqjhhIvhhaXhhrhcIixcbiAgICBcIuGEjOGFteGGqOGEi+GFr+GGq1wiLFxuICAgIFwi4YSM4YW14Yao4YSM4YWh4Ya8XCIsXG4gICAgXCLhhIzhhbXhhqvhhIDhhbPhhrhcIixcbiAgICBcIuGEjOGFteGGq+GEg+GFqeGGvFwiLFxuICAgIFwi4YSM4YW14Yar4YSF4YWpXCIsXG4gICAgXCLhhIzhhbXhhqvhhIXhha1cIixcbiAgICBcIuGEjOGFteGGq+GEheGFtVwiLFxuICAgIFwi4YSM4YW14Yar4YSN4YWhXCIsXG4gICAgXCLhhIzhhbXhhqvhhI7hhaHhhq9cIixcbiAgICBcIuGEjOGFteGGq+GEjuGFruGGr1wiLFxuICAgIFwi4YSM4YW14Yar4YSQ4YWp4Ya8XCIsXG4gICAgXCLhhIzhhbXhhqvhhJLhhaLhhrxcIixcbiAgICBcIuGEjOGFteGGr+GEhuGFruGGq1wiLFxuICAgIFwi4YSM4YW14Yav4YSH4YWn4Ya8XCIsXG4gICAgXCLhhIzhhbXhhq/hhInhhaVcIixcbiAgICBcIuGEjOGFteGGt+GEjOGFoeGGqFwiLFxuICAgIFwi4YSM4YW14Ya44YSD4YWh4YarXCIsXG4gICAgXCLhhIzhhbXhhrjhhIvhhaHhhqtcIixcbiAgICBcIuGEjOGFteGGuOGEjOGFruGGvFwiLFxuICAgIFwi4YSN4YWh4YSM4YWz4Ya8XCIsXG4gICAgXCLhhI3hhbXhhIHhhaXhhIDhhbVcIixcbiAgICBcIuGEjuGFoeGEguGFoeGGt1wiLFxuICAgIFwi4YSO4YWh4YSF4YWh4YSF4YW1XCIsXG4gICAgXCLhhI7hhaHhhIXhhaPhhrxcIixcbiAgICBcIuGEjuGFoeGEheGFteGGt1wiLFxuICAgIFwi4YSO4YWh4YSH4YWn4YavXCIsXG4gICAgXCLhhI7hhaHhhInhhaXhhqtcIixcbiAgICBcIuGEjuGFoeGEjuGFs+GGt1wiLFxuICAgIFwi4YSO4YWh4Yao4YSA4YWh4YaoXCIsXG4gICAgXCLhhI7hhaHhhqvhhIbhha7hhq9cIixcbiAgICBcIuGEjuGFoeGGq+GEieGFpeGGvFwiLFxuICAgIFwi4YSO4YWh4Ya34YSA4YWhXCIsXG4gICAgXCLhhI7hhaHhhrfhhIDhhbXhhIXhhbPhhrdcIixcbiAgICBcIuGEjuGFoeGGt+GEieGFolwiLFxuICAgIFwi4YSO4YWh4Ya34YSJ4YWl4YaoXCIsXG4gICAgXCLhhI7hhaHhhrfhhIvhhadcIixcbiAgICBcIuGEjuGFoeGGt+GEi+GFrFwiLFxuICAgIFwi4YSO4YWh4Ya34YSM4YWpXCIsXG4gICAgXCLhhI7hhaHhhrrhhIzhhaHhhqtcIixcbiAgICBcIuGEjuGFoeGGvOGEgOGFoVwiLFxuICAgIFwi4YSO4YWh4Ya84YSA4YWpXCIsXG4gICAgXCLhhI7hhaHhhrzhhIDhha5cIixcbiAgICBcIuGEjuGFoeGGvOGEhuGFruGGq1wiLFxuICAgIFwi4YSO4YWh4Ya84YSH4YWh4YapXCIsXG4gICAgXCLhhI7hhaHhhrzhhIzhhaHhhqhcIixcbiAgICBcIuGEjuGFoeGGvOGEjOGFqVwiLFxuICAgIFwi4YSO4YWi4YSC4YWl4YavXCIsXG4gICAgXCLhhI7hhaLhhIzhhaXhhrdcIixcbiAgICBcIuGEjuGFouGGqOGEgOGFoeGEh+GFoeGGvFwiLFxuICAgIFwi4YSO4YWi4Yao4YSH4YWh4Ya8XCIsXG4gICAgXCLhhI7hhaLhhqjhhInhhaHhhrxcIixcbiAgICBcIuGEjuGFouGGqOGEi+GFteGGt1wiLFxuICAgIFwi4YSO4YWi4Ya34YSR4YW14YSL4YWl4YarXCIsXG4gICAgXCLhhI7hhaXhhIfhhaXhhq9cIixcbiAgICBcIuGEjuGFpeGEi+GFs+GGt1wiLFxuICAgIFwi4YSO4YWl4Yar4YSA4YWu4YaoXCIsXG4gICAgXCLhhI7hhaXhhqvhhIPhha7hhrxcIixcbiAgICBcIuGEjuGFpeGGq+GEjOGFoeGGvFwiLFxuICAgIFwi4YSO4YWl4Yar4YSM4YWiXCIsXG4gICAgXCLhhI7hhaXhhqvhhI7hhaXhhqvhhJLhhbVcIixcbiAgICBcIuGEjuGFpeGGr+GEg+GFqVwiLFxuICAgIFwi4YSO4YWl4Yav4YSM4YWl4YSS4YW1XCIsXG4gICAgXCLhhI7hhaXhhq/hhJLhhaHhhqhcIixcbiAgICBcIuGEjuGFpeGGuuGEguGFoeGGr1wiLFxuICAgIFwi4YSO4YWl4Ya64YSN4YWiXCIsXG4gICAgXCLhhI7hhaXhhrzhhILhhafhhqtcIixcbiAgICBcIuGEjuGFpeGGvOGEh+GFoeGEjOGFtVwiLFxuICAgIFwi4YSO4YWl4Ya84YSJ4YWpXCIsXG4gICAgXCLhhI7hhaXhhrzhhI7hha7hhqtcIixcbiAgICBcIuGEjuGFpuGEgOGFqFwiLFxuICAgIFwi4YSO4YWm4YSF4YWn4YaoXCIsXG4gICAgXCLhhI7hhabhhIvhhanhhqtcIixcbiAgICBcIuGEjuGFpuGEi+GFsuGGqFwiLFxuICAgIFwi4YSO4YWm4YSM4YWu4Ya8XCIsXG4gICAgXCLhhI7hhabhhJLhhaXhhrdcIixcbiAgICBcIuGEjuGFqeGEg+GFs+GGvOGEkuGFoeGGqOGEieGFouGGvFwiLFxuICAgIFwi4YSO4YWp4YSH4YWh4YarXCIsXG4gICAgXCLhhI7hhanhhIfhhaHhhrhcIixcbiAgICBcIuGEjuGFqeGEieGFoeGGvOGEkuGFqlwiLFxuICAgIFwi4YSO4YWp4YSJ4YWu4YarXCIsXG4gICAgXCLhhI7hhanhhIvhhafhhIXhhbPhhrdcIixcbiAgICBcIuGEjuGFqeGEi+GFr+GGq1wiLFxuICAgIFwi4YSO4YWp4YSM4YWl4YSC4YWn4YaoXCIsXG4gICAgXCLhhI7hhanhhIzhhaXhhrdcIixcbiAgICBcIuGEjuGFqeGEjuGFpeGGvFwiLFxuICAgIFwi4YSO4YWp4YSP4YWp4Yav4YSF4YW14Ya6XCIsXG4gICAgXCLhhI7hhanhhrrhhIfhha7hhq9cIixcbiAgICBcIuGEjuGFqeGGvOGEgOGFoeGGqFwiLFxuICAgIFwi4YSO4YWp4Ya84YSF4YW1XCIsXG4gICAgXCLhhI7hhanhhrzhhIzhhaHhhrxcIixcbiAgICBcIuGEjuGFquGGr+GEi+GFp+GGvFwiLFxuICAgIFwi4YSO4YWs4YSA4YWz4YarXCIsXG4gICAgXCLhhI7hhazhhInhhaHhhrxcIixcbiAgICBcIuGEjuGFrOGEieGFpeGGq1wiLFxuICAgIFwi4YSO4YWs4YSJ4YW14YarXCIsXG4gICAgXCLhhI7hhazhhIvhhaHhhqhcIixcbiAgICBcIuGEjuGFrOGEjOGFqeGGvFwiLFxuICAgIFwi4YSO4YWu4YSJ4YWl4YaoXCIsXG4gICAgXCLhhI7hha7hhIvhhaXhhqhcIixcbiAgICBcIuGEjuGFruGEjOGFteGGq1wiLFxuICAgIFwi4YSO4YWu4YSO4YWl4YarXCIsXG4gICAgXCLhhI7hha7hhI7hhbPhhqhcIixcbiAgICBcIuGEjuGFruGGqOGEgOGFrlwiLFxuICAgIFwi4YSO4YWu4Yao4YSJ4YWpXCIsXG4gICAgXCLhhI7hha7hhqjhhIzhhaZcIixcbiAgICBcIuGEjuGFruGGqOGEkuGFoVwiLFxuICAgIFwi4YSO4YWu4Yav4YSA4YWz4YarXCIsXG4gICAgXCLhhI7hha7hhq/hhIfhhaHhhq9cIixcbiAgICBcIuGEjuGFruGGr+GEieGFoeGGq1wiLFxuICAgIFwi4YSO4YWu4Yav4YSJ4YW14YarXCIsXG4gICAgXCLhhI7hha7hhq/hhIvhhafhhqtcIixcbiAgICBcIuGEjuGFruGGr+GEi+GFteGGuFwiLFxuICAgIFwi4YSO4YWu4Yav4YSM4YWh4Ya8XCIsXG4gICAgXCLhhI7hha7hhq/hhJHhhaHhhqtcIixcbiAgICBcIuGEjuGFruGGvOGEgOGFp+GGqFwiLFxuICAgIFwi4YSO4YWu4Ya84YSA4YWpXCIsXG4gICAgXCLhhI7hha7hhrzhhIPhhanhhq9cIixcbiAgICBcIuGEjuGFruGGvOGEh+GFruGGq+GEkuGFtVwiLFxuICAgIFwi4YSO4YWu4Ya84YSO4YWl4Ya84YSD4YWpXCIsXG4gICAgXCLhhI7hhbHhhIvhhaXhhrhcIixcbiAgICBcIuGEjuGFseGEjOGFteGGqFwiLFxuICAgIFwi4YSO4YWx4YSS4YWj4Ya8XCIsXG4gICAgXCLhhI7hhbXhhIvhhaPhhqhcIixcbiAgICBcIuGEjuGFteGGq+GEgOGFrlwiLFxuICAgIFwi4YSO4YW14Yar4YSO4YWl4YaoXCIsXG4gICAgXCLhhI7hhbXhhq/hhInhhbXhhrhcIixcbiAgICBcIuGEjuGFteGGr+GEi+GFr+GGr1wiLFxuICAgIFwi4YSO4YW14Yav4YSR4YWh4YarXCIsXG4gICAgXCLhhI7hhbXhhrfhhIPhhaJcIixcbiAgICBcIuGEjuGFteGGt+GEhuGFruGGqFwiLFxuICAgIFwi4YSO4YW14Ya34YSJ4YW14YavXCIsXG4gICAgXCLhhI7hhbXhhrrhhInhhanhhq9cIixcbiAgICBcIuGEjuGFteGGvOGEjuGFoeGGq1wiLFxuICAgIFwi4YSP4YWh4YSG4YWm4YSF4YWhXCIsXG4gICAgXCLhhI/hhaHhhIvhha7hhqvhhJDhhaVcIixcbiAgICBcIuGEj+GFoeGGr+GEgOGFruGGqOGEieGFrlwiLFxuICAgIFwi4YSP4YWi4YSF4YW14Yao4YSQ4YWlXCIsXG4gICAgXCLhhI/hhaLhhrfhhJHhhaXhhInhhbNcIixcbiAgICBcIuGEj+GFouGGt+GEkeGFpuGEi+GFteGGq1wiLFxuICAgIFwi4YSP4YWl4YSQ4YWz4YarXCIsXG4gICAgXCLhhI/hhaXhhqvhhIPhhbXhhInhhafhhqtcIixcbiAgICBcIuGEj+GFpeGGr+GEheGFpVwiLFxuICAgIFwi4YSP4YWl4Ya34YSR4YWy4YSQ4YWlXCIsXG4gICAgXCLhhI/hhanhhIHhhbXhhIXhhbVcIixcbiAgICBcIuGEj+GFqeGEhuGFteGEg+GFtVwiLFxuICAgIFwi4YSP4YWp4Yar4YSJ4YWl4YSQ4YWzXCIsXG4gICAgXCLhhI/hhanhhq/hhIXhhaFcIixcbiAgICBcIuGEj+GFqeGGt+GEkeGFs+GGr+GEheGFpuGGqOGEieGFs1wiLFxuICAgIFwi4YSP4YWp4Ya84YSC4YWh4YSG4YWu4YavXCIsXG4gICAgXCLhhI/hhavhhIDhhaHhhrdcIixcbiAgICBcIuGEj+GFruGEg+GFpuGEkOGFoVwiLFxuICAgIFwi4YSP4YWz4YSF4YW14Ya3XCIsXG4gICAgXCLhhI/hhbPhhqvhhIDhhbXhhq9cIixcbiAgICBcIuGEj+GFs+GGq+GEhOGFoeGGr1wiLFxuICAgIFwi4YSP4YWz4Yar4YSJ4YWp4YSF4YW1XCIsXG4gICAgXCLhhI/hhbPhhqvhhIvhhaHhhIPhhbPhhq9cIixcbiAgICBcIuGEj+GFs+GGq+GEi+GFpeGEhuGFpeGEguGFtVwiLFxuICAgIFwi4YSP4YWz4Yar4YSL4YW14YavXCIsXG4gICAgXCLhhI/hhbPhhqvhhIzhhaXhhq9cIixcbiAgICBcIuGEj+GFs+GGr+GEheGFouGEieGFteGGqFwiLFxuICAgIFwi4YSP4YWz4Yav4YSF4YWl4Ya4XCIsXG4gICAgXCLhhI/hhbXhhq/hhIXhhalcIixcbiAgICBcIuGEkOGFoeGEi+GFteGGuFwiLFxuICAgIFwi4YSQ4YWh4YSM4YWh4YSA4YW1XCIsXG4gICAgXCLhhJDhhaHhhqjhhIDhha5cIixcbiAgICBcIuGEkOGFoeGGqOGEjOGFoVwiLFxuICAgIFwi4YSQ4YWh4Yar4YSJ4YWi4Ya8XCIsXG4gICAgXCLhhJDhhaLhhIDhha/hhqvhhIPhhalcIixcbiAgICBcIuGEkOGFouGEi+GFo+GGvFwiLFxuICAgIFwi4YSQ4YWi4YSR4YWu4Ya8XCIsXG4gICAgXCLhhJDhhaLhhqjhhInhhbVcIixcbiAgICBcIuGEkOGFouGGr+GEheGFpeGGq+GEkOGFs1wiLFxuICAgIFwi4YSQ4YWl4YSC4YWl4YavXCIsXG4gICAgXCLhhJDhhaXhhIbhhbXhhILhhaXhhq9cIixcbiAgICBcIuGEkOGFpuGEguGFteGEieGFs1wiLFxuICAgIFwi4YSQ4YWm4YSJ4YWz4YSQ4YWzXCIsXG4gICAgXCLhhJDhhabhhIvhhbXhhIfhhbPhhq9cIixcbiAgICBcIuGEkOGFpuGGr+GEheGFpuGEh+GFteGEjOGFpeGGq1wiLFxuICAgIFwi4YSQ4YWp4YSF4YWp4YarXCIsXG4gICAgXCLhhJDhhanhhIbhhaHhhJDhhalcIixcbiAgICBcIuGEkOGFqeGEi+GFreGEi+GFteGGr1wiLFxuICAgIFwi4YSQ4YWp4Ya84YSA4YWoXCIsXG4gICAgXCLhhJDhhanhhrzhhIDhhapcIixcbiAgICBcIuGEkOGFqeGGvOGEheGFqVwiLFxuICAgIFwi4YSQ4YWp4Ya84YSJ4YW14YarXCIsXG4gICAgXCLhhJDhhanhhrzhhIvhhafhhqhcIixcbiAgICBcIuGEkOGFqeGGvOGEi+GFteGGr1wiLFxuICAgIFwi4YSQ4YWp4Ya84YSM4YWh4Ya8XCIsXG4gICAgXCLhhJDhhanhhrzhhIzhhaZcIixcbiAgICBcIuGEkOGFqeGGvOGEjOGFs+GGvFwiLFxuICAgIFwi4YSQ4YWp4Ya84YSS4YWh4Ya4XCIsXG4gICAgXCLhhJDhhanhhrzhhJLhhapcIixcbiAgICBcIuGEkOGFrOGEgOGFs+GGq1wiLFxuICAgIFwi4YSQ4YWs4YSL4YWv4YarXCIsXG4gICAgXCLhhJDhhazhhIzhhbXhhqjhhIDhhbPhhrdcIixcbiAgICBcIuGEkOGFseGEgOGFteGGt1wiLFxuICAgIFwi4YSQ4YWz4YSF4YWl4YaoXCIsXG4gICAgXCLhhJDhhbPhhqjhhIDhhbPhhrhcIixcbiAgICBcIuGEkOGFs+GGqOGEh+GFp+GGr1wiLFxuICAgIFwi4YSQ4YWz4Yao4YSJ4YWl4Ya8XCIsXG4gICAgXCLhhJDhhbPhhqjhhInhha5cIixcbiAgICBcIuGEkOGFs+GGqOGEjOGFteGGvFwiLFxuICAgIFwi4YSQ4YWz4Yao4YSS4YW1XCIsXG4gICAgXCLhhJDhhbPhhqvhhJDhhbPhhqvhhJLhhbVcIixcbiAgICBcIuGEkOGFteGEieGFp+GEjuGFs1wiLFxuICAgIFwi4YSR4YWh4YSF4YWh4Yar4YSJ4YWi4YaoXCIsXG4gICAgXCLhhJHhhaHhhIvhhbXhhq9cIixcbiAgICBcIuGEkeGFoeGEjuGFruGGr+GEieGFqVwiLFxuICAgIFwi4YSR4YWh4Yar4YSA4YWn4YavXCIsXG4gICAgXCLhhJHhhaHhhqvhhIPhhaHhhqtcIixcbiAgICBcIuGEkeGFoeGGq+GEhuGFolwiLFxuICAgIFwi4YSR4YWh4Yar4YSJ4YWhXCIsXG4gICAgXCLhhJHhhaHhhq/hhInhhbXhhrhcIixcbiAgICBcIuGEkeGFoeGGr+GEi+GFr+GGr1wiLFxuICAgIFwi4YSR4YWh4Ya44YSJ4YWp4Ya8XCIsXG4gICAgXCLhhJHhhaLhhInhhafhhqtcIixcbiAgICBcIuGEkeGFouGGqOGEieGFs1wiLFxuICAgIFwi4YSR4YWi4Yao4YSJ4YW14YSG4YW14Yav4YSF4YW1XCIsXG4gICAgXCLhhJHhhaLhhqvhhJDhhbVcIixcbiAgICBcIuGEkeGFpeGEieGFpuGGq+GEkOGFs1wiLFxuICAgIFwi4YSR4YWm4YSL4YW14Yar4YSQ4YWzXCIsXG4gICAgXCLhhJHhhafhhqvhhIDhhafhhqtcIixcbiAgICBcIuGEkeGFp+GGq+GEi+GFtFwiLFxuICAgIFwi4YSR4YWn4Yar4YSM4YW1XCIsXG4gICAgXCLhhJHhhafhhqvhhJLhhbVcIixcbiAgICBcIuGEkeGFp+GGvOGEgOGFoVwiLFxuICAgIFwi4YSR4YWn4Ya84YSA4YWy4YarXCIsXG4gICAgXCLhhJHhhafhhrzhhInhhaLhhrxcIixcbiAgICBcIuGEkeGFp+GGvOGEieGFqVwiLFxuICAgIFwi4YSR4YWn4Ya84YSL4YWj4Ya8XCIsXG4gICAgXCLhhJHhhafhhrzhhIvhhbXhhq9cIixcbiAgICBcIuGEkeGFp+GGvOGEkuGFqlwiLFxuICAgIFwi4YSR4YWp4YSJ4YWz4YSQ4YWlXCIsXG4gICAgXCLhhJHhhanhhIvhhbXhhqvhhJDhhbNcIixcbiAgICBcIuGEkeGFqeGEjOGFoeGGvFwiLFxuICAgIFwi4YSR4YWp4YSS4YWh4Ya3XCIsXG4gICAgXCLhhJHhha3hhIbhhafhhqtcIixcbiAgICBcIuGEkeGFreGEjOGFpeGGvFwiLFxuICAgIFwi4YSR4YWt4YSM4YWu4YarXCIsXG4gICAgXCLhhJHhha3hhJLhhafhhqtcIixcbiAgICBcIuGEkeGFruGGt+GEhuGFqeGGqFwiLFxuICAgIFwi4YSR4YWu4Ya34YSM4YW14YavXCIsXG4gICAgXCLhhJHhha7hhrzhhIDhhafhhrxcIixcbiAgICBcIuGEkeGFruGGvOGEieGFqeGGqFwiLFxuICAgIFwi4YSR4YWu4Ya84YSJ4YWz4Ya4XCIsXG4gICAgXCLhhJHhhbPhhIXhhaHhhrzhhInhhbNcIixcbiAgICBcIuGEkeGFs+GEheGFteGGq+GEkOGFpVwiLFxuICAgIFwi4YSR4YWz4Yav4YSF4YWh4YSJ4YWz4YSQ4YW14YaoXCIsXG4gICAgXCLhhJHhhbXhhIDhhanhhqtcIixcbiAgICBcIuGEkeGFteGEhuGFoeGGvFwiLFxuICAgIFwi4YSR4YW14YSL4YWh4YSC4YWpXCIsXG4gICAgXCLhhJHhhbXhhq/hhIXhhbPhhrdcIixcbiAgICBcIuGEkeGFteGGr+GEieGFrlwiLFxuICAgIFwi4YSR4YW14Yav4YSL4YWtXCIsXG4gICAgXCLhhJHhhbXhhq/hhIzhhaFcIixcbiAgICBcIuGEkeGFteGGr+GEkOGFqeGGvFwiLFxuICAgIFwi4YSR4YW14Ya84YSA4YWoXCIsXG4gICAgXCLhhJLhhaHhhILhhbPhhILhhbXhhrdcIixcbiAgICBcIuGEkuGFoeGEguGFs+GGr1wiLFxuICAgIFwi4YSS4YWh4YSD4YWz4YSL4YWw4YSL4YWlXCIsXG4gICAgXCLhhJLhhaHhhIXhha7hhrrhhIfhhaHhhrdcIixcbiAgICBcIuGEkuGFoeGEh+GFoeGGq+GEgOGFtVwiLFxuICAgIFwi4YSS4YWh4YSJ4YWu4Yao4YSM4YW14Ya4XCIsXG4gICAgXCLhhJLhhaHhhInhha7hhqtcIixcbiAgICBcIuGEkuGFoeGEi+GFp+GEkOGFs+GGq1wiLFxuICAgIFwi4YSS4YWh4YSM4YW14YSG4YWh4YarXCIsXG4gICAgXCLhhJLhhaHhhI7hhaXhhqtcIixcbiAgICBcIuGEkuGFoeGEkeGFruGGt1wiLFxuICAgIFwi4YSS4YWh4YSR4YW14YavXCIsXG4gICAgXCLhhJLhhaHhhqjhhIDhhapcIixcbiAgICBcIuGEkuGFoeGGqOGEgOGFrVwiLFxuICAgIFwi4YSS4YWh4Yao4YSA4YWz4Ya4XCIsXG4gICAgXCLhhJLhhaHhhqjhhIDhhbVcIixcbiAgICBcIuGEkuGFoeGGqOGEguGFp+GGq1wiLFxuICAgIFwi4YSS4YWh4Yao4YSF4YWn4YaoXCIsXG4gICAgXCLhhJLhhaHhhqjhhIfhhaXhhqtcIixcbiAgICBcIuGEkuGFoeGGqOGEh+GFruGEhuGFqVwiLFxuICAgIFwi4YSS4YWh4Yao4YSH4YW1XCIsXG4gICAgXCLhhJLhhaHhhqjhhInhhaLhhrxcIixcbiAgICBcIuGEkuGFoeGGqOGEieGFruGGr1wiLFxuICAgIFwi4YSS4YWh4Yao4YSJ4YWz4Ya4XCIsXG4gICAgXCLhhJLhhaHhhqjhhIvhha3hhrzhhJHhha7hhrdcIixcbiAgICBcIuGEkuGFoeGGqOGEi+GFr+GGq1wiLFxuICAgIFwi4YSS4YWh4Yao4YSL4YWxXCIsXG4gICAgXCLhhJLhhaHhhqjhhIzhhaFcIixcbiAgICBcIuGEkuGFoeGGqOGEjOGFpeGGt1wiLFxuICAgIFwi4YSS4YWh4Yar4YSA4YWoXCIsXG4gICAgXCLhhJLhhaHhhqvhhIDhhbPhhq9cIixcbiAgICBcIuGEkuGFoeGGq+GEgeGFpeGEh+GFpeGGq+GEi+GFplwiLFxuICAgIFwi4YSS4YWh4Yar4YSC4YWh4Ya9XCIsXG4gICAgXCLhhJLhhaHhhqvhhILhha7hhqtcIixcbiAgICBcIuGEkuGFoeGGq+GEg+GFqeGGvOGEi+GFoeGGq1wiLFxuICAgIFwi4YSS4YWh4Yar4YSE4YWiXCIsXG4gICAgXCLhhJLhhaHhhqvhhIXhhaHhhInhhaHhhqtcIixcbiAgICBcIuGEkuGFoeGGq+GEhuGFoeGEg+GFtVwiLFxuICAgIFwi4YSS4YWh4Yar4YSG4YWu4YarXCIsXG4gICAgXCLhhJLhhaHhhqvhhIfhhaXhhqtcIixcbiAgICBcIuGEkuGFoeGGq+GEh+GFqeGGqFwiLFxuICAgIFwi4YSS4YWh4Yar4YSJ4YW14YaoXCIsXG4gICAgXCLhhJLhhaHhhqvhhIvhhafhhIXhhbPhhrdcIixcbiAgICBcIuGEkuGFoeGGq+GEjeGFqeGGqFwiLFxuICAgIFwi4YSS4YWh4Yav4YSG4YWl4YSC4YW1XCIsXG4gICAgXCLhhJLhhaHhhq/hhIvhhaHhhIfhhaXhhIzhhbVcIixcbiAgICBcIuGEkuGFoeGGr+GEi+GFteGGq1wiLFxuICAgIFwi4YSS4YWh4Ya34YSB4YWmXCIsXG4gICAgXCLhhJLhhaHhhrfhhIfhha7hhIXhhalcIixcbiAgICBcIuGEkuGFoeGGuOGEgOGFp+GGqFwiLFxuICAgIFwi4YSS4YWh4Ya44YSF4YW14YSM4YWl4YaoXCIsXG4gICAgXCLhhJLhhaHhhrzhhIDhhanhhrxcIixcbiAgICBcIuGEkuGFoeGGvOGEgOGFrlwiLFxuICAgIFwi4YSS4YWh4Ya84YSJ4YWh4Ya8XCIsXG4gICAgXCLhhJLhhaHhhrzhhIvhhbRcIixcbiAgICBcIuGEkuGFouGEgOGFp+GGr1wiLFxuICAgIFwi4YSS4YWi4YSA4YWu4YarXCIsXG4gICAgXCLhhJLhhaLhhIPhhaHhhrhcIixcbiAgICBcIuGEkuGFouGEg+GFoeGGvFwiLFxuICAgIFwi4YSS4YWi4YSG4YWu4YavXCIsXG4gICAgXCLhhJLhhaLhhInhhaXhhqhcIixcbiAgICBcIuGEkuGFouGEieGFpeGGr1wiLFxuICAgIFwi4YSS4YWi4YSJ4YWu4YSL4YWt4Yao4YSM4YWh4Ya8XCIsXG4gICAgXCLhhJLhhaLhhIvhhaHhhqtcIixcbiAgICBcIuGEkuGFouGGqOGEieGFteGGt1wiLFxuICAgIFwi4YSS4YWi4Yar4YSD4YWz4YSH4YWi4YaoXCIsXG4gICAgXCLhhJLhhaLhhrfhhIfhhaXhhIDhhaVcIixcbiAgICBcIuGEkuGFouGGuuGEh+GFp+GHgFwiLFxuICAgIFwi4YSS4YWi4Ya64YSJ4YWh4YavXCIsXG4gICAgXCLhhJLhhaLhhrzhhIPhhanhhrxcIixcbiAgICBcIuGEkuGFouGGvOGEh+GFqeGGqFwiLFxuICAgIFwi4YSS4YWi4Ya84YSJ4YWhXCIsXG4gICAgXCLhhJLhhaLhhrzhhIvhha7hhqtcIixcbiAgICBcIuGEkuGFouGGvOGEi+GFsVwiLFxuICAgIFwi4YSS4YWj4Ya84YSA4YW1XCIsXG4gICAgXCLhhJLhhaPhhrzhhInhhaHhhrxcIixcbiAgICBcIuGEkuGFo+GGvOGEieGFrlwiLFxuICAgIFwi4YSS4YWl4YSF4YWh4YaoXCIsXG4gICAgXCLhhJLhhaXhhIvhha3hhrxcIixcbiAgICBcIuGEkuGFpuGGr+GEgOGFtVwiLFxuICAgIFwi4YSS4YWn4Yar4YSA4YWq4YarXCIsXG4gICAgXCLhhJLhhafhhqvhhIDhhbPhhrdcIixcbiAgICBcIuGEkuGFp+GGq+GEg+GFolwiLFxuICAgIFwi4YSS4YWn4Yar4YSJ4YWh4Ya8XCIsXG4gICAgXCLhhJLhhafhhqvhhInhhbXhhq9cIixcbiAgICBcIuGEkuGFp+GGq+GEjOGFoeGGvFwiLFxuICAgIFwi4YSS4YWn4Yar4YSM4YWiXCIsXG4gICAgXCLhhJLhhafhhqvhhIzhhbVcIixcbiAgICBcIuGEkuGFp+GGr+GEi+GFouGGqFwiLFxuICAgIFwi4YSS4YWn4Ya44YSF4YWn4YaoXCIsXG4gICAgXCLhhJLhhafhhrzhhIfhha5cIixcbiAgICBcIuGEkuGFp+GGvOGEieGFoVwiLFxuICAgIFwi4YSS4YWn4Ya84YSJ4YWuXCIsXG4gICAgXCLhhJLhhafhhrzhhInhhbXhhqhcIixcbiAgICBcIuGEkuGFp+GGvOGEjOGFplwiLFxuICAgIFwi4YSS4YWn4Ya84YSQ4YWiXCIsXG4gICAgXCLhhJLhhafhhrzhhJHhhafhhqtcIixcbiAgICBcIuGEkuGFqOGEkOGFouGGqFwiLFxuICAgIFwi4YSS4YWp4YSA4YW14YSJ4YW14Ya3XCIsXG4gICAgXCLhhJLhhanhhILhhaHhhrdcIixcbiAgICBcIuGEkuGFqeGEheGFoeGGvOGEi+GFtVwiLFxuICAgIFwi4YSS4YWp4YSH4YWh4YaoXCIsXG4gICAgXCLhhJLhhanhhJDhhabhhq9cIixcbiAgICBcIuGEkuGFqeGEkuGFs+GGuFwiLFxuICAgIFwi4YSS4YWp4Yao4YSJ4YW1XCIsXG4gICAgXCLhhJLhhanhhq/hhIXhhalcIixcbiAgICBcIuGEkuGFqeGGt+GEkeGFpuGEi+GFteGEjOGFtVwiLFxuICAgIFwi4YSS4YWp4Ya84YSH4YWpXCIsXG4gICAgXCLhhJLhhanhhrzhhInhha5cIixcbiAgICBcIuGEkuGFqeGGvOGEjuGFoVwiLFxuICAgIFwi4YSS4YWq4YSG4YWn4YarXCIsXG4gICAgXCLhhJLhharhhIfhha7hhqtcIixcbiAgICBcIuGEkuGFquGEieGFoeGGr1wiLFxuICAgIFwi4YSS4YWq4YSL4YWt4YSL4YW14YavXCIsXG4gICAgXCLhhJLhharhhIzhhaHhhrxcIixcbiAgICBcIuGEkuGFquGEkuGFoeGGqFwiLFxuICAgIFwi4YSS4YWq4Yao4YSH4YWpXCIsXG4gICAgXCLhhJLhharhhqjhhIvhhbXhhqtcIixcbiAgICBcIuGEkuGFquGGqOGEjOGFoeGGvFwiLFxuICAgIFwi4YSS4YWq4Yao4YSM4YWl4Ya8XCIsXG4gICAgXCLhhJLhharhhqvhhIDhhaHhhrhcIixcbiAgICBcIuGEkuGFquGGq+GEgOGFp+GGvFwiLFxuICAgIFwi4YSS4YWq4Yar4YSL4YWn4Ya8XCIsXG4gICAgXCLhhJLhharhhqvhhIvhhbLhhq9cIixcbiAgICBcIuGEkuGFquGGq+GEjOGFoVwiLFxuICAgIFwi4YSS4YWq4Yav4YSA4YW1XCIsXG4gICAgXCLhhJLhharhhq/hhIPhhanhhrxcIixcbiAgICBcIuGEkuGFquGGr+GEh+GFoeGGr+GEkuGFtVwiLFxuICAgIFwi4YSS4YWq4Yav4YSL4YWt4Ya8XCIsXG4gICAgXCLhhJLhharhhq/hhI3hhaHhhqhcIixcbiAgICBcIuGEkuGFrOGEgOGFp+GGq1wiLFxuICAgIFwi4YSS4YWs4YSA4YWq4YarXCIsXG4gICAgXCLhhJLhhazhhIfhhanhhqhcIixcbiAgICBcIuGEkuGFrOGEieGFouGGqFwiLFxuICAgIFwi4YSS4YWs4YSL4YWv4YarXCIsXG4gICAgXCLhhJLhhazhhIzhhaHhhrxcIixcbiAgICBcIuGEkuGFrOGEjOGFpeGGq1wiLFxuICAgIFwi4YSS4YWs4Ya64YSJ4YWuXCIsXG4gICAgXCLhhJLhhazhhrzhhIPhhaHhhqvhhIfhhanhhIPhhalcIixcbiAgICBcIuGEkuGFreGEi+GFsuGGr+GEjOGFpeGGqFwiLFxuICAgIFwi4YSS4YWu4YSH4YWh4YarXCIsXG4gICAgXCLhhJLhha7hhI7hha7hhrrhhIDhhaHhhIXhha5cIixcbiAgICBcIuGEkuGFruGGq+GEheGFp+GGq1wiLFxuICAgIFwi4YSS4YWv4Yav4YSK4YW14YarXCIsXG4gICAgXCLhhJLhhbLhhInhhbXhhqhcIixcbiAgICBcIuGEkuGFsuGEi+GFteGGr1wiLFxuICAgIFwi4YSS4YWy4Ya84YSC4YWiXCIsXG4gICAgXCLhhJLhhbPhhIXhhbPhhrdcIixcbiAgICBcIuGEkuGFs+GGqOGEh+GFouGGqFwiLFxuICAgIFwi4YSS4YWz4Yao4YSL4YW14YarXCIsXG4gICAgXCLhhJLhhbPhhqvhhIzhhaXhhqhcIixcbiAgICBcIuGEkuGFs+GGq+GEkuGFtVwiLFxuICAgIFwi4YSS4YWz4Ya84YSG4YW1XCIsXG4gICAgXCLhhJLhhbPhhrzhhIfhha7hhqtcIixcbiAgICBcIuGEkuGFtOGEgOGFqeGGqFwiLFxuICAgIFwi4YSS4YW04YSG4YWh4Ya8XCIsXG4gICAgXCLhhJLhhbThhInhhaLhhrxcIixcbiAgICBcIuGEkuGFtOGGq+GEieGFouGGqFwiLFxuICAgIFwi4YSS4YW14Ya34YSB4YWl4Ya6XCJcbl1cbiIsIm1vZHVsZS5leHBvcnRzPVtcbiAgICBcIuOBguOBhOOBk+OBj+OBl+OCk1wiLFxuICAgIFwi44GC44GE44GV44GkXCIsXG4gICAgXCLjgYLjgYTjgZ/jgplcIixcbiAgICBcIuOBguOBiuOBneOCmeOCiVwiLFxuICAgIFwi44GC44GL44Gh44KD44KTXCIsXG4gICAgXCLjgYLjgY3jgotcIixcbiAgICBcIuOBguOBkeOBi+OCmeOBn1wiLFxuICAgIFwi44GC44GR44KLXCIsXG4gICAgXCLjgYLjgZPjgYvjgpnjgozjgotcIixcbiAgICBcIuOBguOBleOBhFwiLFxuICAgIFwi44GC44GV44GyXCIsXG4gICAgXCLjgYLjgZfjgYLjgahcIixcbiAgICBcIuOBguOBl+OCmeOCj+OBhlwiLFxuICAgIFwi44GC44GZ44KZ44GL44KLXCIsXG4gICAgXCLjgYLjgZnjgpnjgY1cIixcbiAgICBcIuOBguOBneOBteOCmVwiLFxuICAgIFwi44GC44Gf44GI44KLXCIsXG4gICAgXCLjgYLjgZ/jgZ/jgoHjgotcIixcbiAgICBcIuOBguOBn+OCiuOBvuOBiFwiLFxuICAgIFwi44GC44Gf44KLXCIsXG4gICAgXCLjgYLjgaTjgYRcIixcbiAgICBcIuOBguOBpOOBi+OBhlwiLFxuICAgIFwi44GC44Gj44GX44KF44GPXCIsXG4gICAgXCLjgYLjgaTjgb7jgopcIixcbiAgICBcIuOBguOBpOOCgeOCi1wiLFxuICAgIFwi44GC44Gm44GqXCIsXG4gICAgXCLjgYLjgabjga/jgb7jgotcIixcbiAgICBcIuOBguOBsuOCi1wiLFxuICAgIFwi44GC44G144KZ44KJXCIsXG4gICAgXCLjgYLjgbXjgpnjgotcIixcbiAgICBcIuOBguOBteOCjOOCi1wiLFxuICAgIFwi44GC44G+44GEXCIsXG4gICAgXCLjgYLjgb7jgajjgplcIixcbiAgICBcIuOBguOBvuOChOOBi+OBmVwiLFxuICAgIFwi44GC44G+44KKXCIsXG4gICAgXCLjgYLjgb/jgoLjga5cIixcbiAgICBcIuOBguOCgeOCiuOBi1wiLFxuICAgIFwi44GC44KE44G+44KLXCIsXG4gICAgXCLjgYLjgobjgoBcIixcbiAgICBcIuOBguOCieOBhOOBj+OCmeOBvlwiLFxuICAgIFwi44GC44KJ44GXXCIsXG4gICAgXCLjgYLjgonjgZnjgZfjgplcIixcbiAgICBcIuOBguOCieOBn+OCgeOCi1wiLFxuICAgIFwi44GC44KJ44KG44KLXCIsXG4gICAgXCLjgYLjgonjgo/jgZlcIixcbiAgICBcIuOBguOCiuOBi+OCmeOBqOOBhlwiLFxuICAgIFwi44GC44KP44Gb44KLXCIsXG4gICAgXCLjgYLjgo/jgabjgotcIixcbiAgICBcIuOBguOCk+OBhFwiLFxuICAgIFwi44GC44KT44GL44KZ44GEXCIsXG4gICAgXCLjgYLjgpPjgZNcIixcbiAgICBcIuOBguOCk+OBm+OCmeOCk1wiLFxuICAgIFwi44GC44KT44Gm44GEXCIsXG4gICAgXCLjgYLjgpPjgarjgYRcIixcbiAgICBcIuOBguOCk+OBvuOCilwiLFxuICAgIFwi44GE44GE44Gf44KZ44GZXCIsXG4gICAgXCLjgYTjgYrjgpNcIixcbiAgICBcIuOBhOOBi+OCmeOBhFwiLFxuICAgIFwi44GE44GL44KZ44GPXCIsXG4gICAgXCLjgYTjgY3jgYrjgYRcIixcbiAgICBcIuOBhOOBjeOBquOCilwiLFxuICAgIFwi44GE44GN44KC44GuXCIsXG4gICAgXCLjgYTjgY3jgotcIixcbiAgICBcIuOBhOOBj+OBl+OCmVwiLFxuICAgIFwi44GE44GP44G144KZ44KTXCIsXG4gICAgXCLjgYTjgZHjga/jgpnjgapcIixcbiAgICBcIuOBhOOBkeOCk1wiLFxuICAgIFwi44GE44GT44GGXCIsXG4gICAgXCLjgYTjgZPjgY9cIixcbiAgICBcIuOBhOOBk+OBpFwiLFxuICAgIFwi44GE44GV44G+44GX44GEXCIsXG4gICAgXCLjgYTjgZXjgpNcIixcbiAgICBcIuOBhOOBl+OBjVwiLFxuICAgIFwi44GE44GX44KZ44KF44GGXCIsXG4gICAgXCLjgYTjgZfjgpnjgofjgYZcIixcbiAgICBcIuOBhOOBl+OCmeOCj+OCi1wiLFxuICAgIFwi44GE44GZ44KZ44G/XCIsXG4gICAgXCLjgYTjgZnjgpnjgoxcIixcbiAgICBcIuOBhOOBm+OBhFwiLFxuICAgIFwi44GE44Gb44GI44Gy44KZXCIsXG4gICAgXCLjgYTjgZvjgYvjgYRcIixcbiAgICBcIuOBhOOBm+OBjVwiLFxuICAgIFwi44GE44Gb44KZ44KTXCIsXG4gICAgXCLjgYTjgZ3jgYbjgo3jgYZcIixcbiAgICBcIuOBhOOBneOBi+OCmeOBl+OBhFwiLFxuICAgIFwi44GE44Gf44KZ44GEXCIsXG4gICAgXCLjgYTjgZ/jgpnjgY9cIixcbiAgICBcIuOBhOOBn+OBmeOCmeOCiVwiLFxuICAgIFwi44GE44Gf44G/XCIsXG4gICAgXCLjgYTjgZ/jgorjgYJcIixcbiAgICBcIuOBhOOBoeOBiuOBhlwiLFxuICAgIFwi44GE44Gh44GX44KZXCIsXG4gICAgXCLjgYTjgaHjgajjgplcIixcbiAgICBcIuOBhOOBoeOBr+OCmVwiLFxuICAgIFwi44GE44Gh44G144KZXCIsXG4gICAgXCLjgYTjgaHjgorjgoXjgYZcIixcbiAgICBcIuOBhOOBpOOBi1wiLFxuICAgIFwi44GE44Gj44GX44KF44KTXCIsXG4gICAgXCLjgYTjgaPjgZvjgYRcIixcbiAgICBcIuOBhOOBo+OBneOBhlwiLFxuICAgIFwi44GE44Gj44Gf44KTXCIsXG4gICAgXCLjgYTjgaPjgaFcIixcbiAgICBcIuOBhOOBo+OBpuOBhFwiLFxuICAgIFwi44GE44Gj44G744Ka44GGXCIsXG4gICAgXCLjgYTjgabjgZXjgplcIixcbiAgICBcIuOBhOOBpuOCk1wiLFxuICAgIFwi44GE44Go44KZ44GGXCIsXG4gICAgXCLjgYTjgajjgZNcIixcbiAgICBcIuOBhOOBquOBhFwiLFxuICAgIFwi44GE44Gq44GLXCIsXG4gICAgXCLjgYTjga3jgoDjgopcIixcbiAgICBcIuOBhOOBruOBoVwiLFxuICAgIFwi44GE44Gu44KLXCIsXG4gICAgXCLjgYTjga/jgaRcIixcbiAgICBcIuOBhOOBr+OCmeOCi1wiLFxuICAgIFwi44GE44Gv44KTXCIsXG4gICAgXCLjgYTjgbLjgpnjgY1cIixcbiAgICBcIuOBhOOBsuOCk1wiLFxuICAgIFwi44GE44G144GPXCIsXG4gICAgXCLjgYTjgbjjgpNcIixcbiAgICBcIuOBhOOBu+OBhlwiLFxuICAgIFwi44GE44G/44KTXCIsXG4gICAgXCLjgYTjgoLjgYbjgahcIixcbiAgICBcIuOBhOOCguOBn+OCjFwiLFxuICAgIFwi44GE44KC44KKXCIsXG4gICAgXCLjgYTjgoTjgYvjgpnjgotcIixcbiAgICBcIuOBhOOChOOBmVwiLFxuICAgIFwi44GE44KI44GL44KTXCIsXG4gICAgXCLjgYTjgojjgY9cIixcbiAgICBcIuOBhOOCieOBhFwiLFxuICAgIFwi44GE44KJ44GZ44GoXCIsXG4gICAgXCLjgYTjgorjgY/jgpnjgaFcIixcbiAgICBcIuOBhOOCiuOCh+OBhlwiLFxuICAgIFwi44GE44KM44GEXCIsXG4gICAgXCLjgYTjgozjgoLjga5cIixcbiAgICBcIuOBhOOCjOOCi1wiLFxuICAgIFwi44GE44KN44GI44KT44Gy44Ka44GkXCIsXG4gICAgXCLjgYTjgo/jgYRcIixcbiAgICBcIuOBhOOCj+OBhlwiLFxuICAgIFwi44GE44KP44GL44KTXCIsXG4gICAgXCLjgYTjgo/jga/jgplcIixcbiAgICBcIuOBhOOCj+OChuOCi1wiLFxuICAgIFwi44GE44KT44GR44KZ44KT44G+44KBXCIsXG4gICAgXCLjgYTjgpPjgZXjgaRcIixcbiAgICBcIuOBhOOCk+OBl+OCh+OBhlwiLFxuICAgIFwi44GE44KT44KI44GGXCIsXG4gICAgXCLjgYbjgYjjgY1cIixcbiAgICBcIuOBhuOBiOOCi1wiLFxuICAgIFwi44GG44GK44GV44KZXCIsXG4gICAgXCLjgYbjgYvjgpnjgYRcIixcbiAgICBcIuOBhuOBi+OBteOCmVwiLFxuICAgIFwi44GG44GL44G444KZ44KLXCIsXG4gICAgXCLjgYbjgY3jgo9cIixcbiAgICBcIuOBhuOBj+OCieOBhOOBqlwiLFxuICAgIFwi44GG44GP44KM44KMXCIsXG4gICAgXCLjgYbjgZHjgZ/jgb7jgo/jgotcIixcbiAgICBcIuOBhuOBkeOBpOOBkVwiLFxuICAgIFwi44GG44GR44Go44KLXCIsXG4gICAgXCLjgYbjgZHjgoLjgaRcIixcbiAgICBcIuOBhuOBkeOCi1wiLFxuICAgIFwi44GG44GT44KZ44GL44GZXCIsXG4gICAgXCLjgYbjgZPjgpnjgY9cIixcbiAgICBcIuOBhuOBk+OCk1wiLFxuICAgIFwi44GG44GV44GN44KZXCIsXG4gICAgXCLjgYbjgZfjgarjgYZcIixcbiAgICBcIuOBhuOBl+OCjeOBi+OCmeOBv1wiLFxuICAgIFwi44GG44GZ44GEXCIsXG4gICAgXCLjgYbjgZnjgY3jgplcIixcbiAgICBcIuOBhuOBmeOBj+OCmeOCieOBhFwiLFxuICAgIFwi44GG44GZ44KB44KLXCIsXG4gICAgXCLjgYbjgZvjgaRcIixcbiAgICBcIuOBhuOBoeOBguOCj+OBm1wiLFxuICAgIFwi44GG44Gh44GL44KZ44KPXCIsXG4gICAgXCLjgYbjgaHjgY1cIixcbiAgICBcIuOBhuOBoeOCheOBhlwiLFxuICAgIFwi44GG44Gj44GL44KKXCIsXG4gICAgXCLjgYbjgaTjgY/jgZfjgYRcIixcbiAgICBcIuOBhuOBo+OBn+OBiOOCi1wiLFxuICAgIFwi44GG44Gk44KLXCIsXG4gICAgXCLjgYbjgajjgpnjgpNcIixcbiAgICBcIuOBhuOBquOBjeOCmVwiLFxuICAgIFwi44GG44Gq44GX44KZXCIsXG4gICAgXCLjgYbjgarjgZnjgpnjgY9cIixcbiAgICBcIuOBhuOBquOCi1wiLFxuICAgIFwi44GG44Gt44KLXCIsXG4gICAgXCLjgYbjga7jgYZcIixcbiAgICBcIuOBhuOBteOCmeOBkeOCmVwiLFxuICAgIFwi44GG44G144KZ44GT44KZ44GIXCIsXG4gICAgXCLjgYbjgb7jgozjgotcIixcbiAgICBcIuOBhuOCgeOCi1wiLFxuICAgIFwi44GG44KC44GGXCIsXG4gICAgXCLjgYbjgoTjgb7jgYZcIixcbiAgICBcIuOBhuOCiOOBj1wiLFxuICAgIFwi44GG44KJ44GL44KZ44GI44GZXCIsXG4gICAgXCLjgYbjgonjgY/jgpnjgaFcIixcbiAgICBcIuOBhuOCieOBquOBhFwiLFxuICAgIFwi44GG44KK44GC44GR44KZXCIsXG4gICAgXCLjgYbjgorjgY3jgoxcIixcbiAgICBcIuOBhuOCi+OBleOBhFwiLFxuICAgIFwi44GG44KM44GX44GEXCIsXG4gICAgXCLjgYbjgozjgobjgY1cIixcbiAgICBcIuOBhuOCjOOCi1wiLFxuICAgIFwi44GG44KN44GTXCIsXG4gICAgXCLjgYbjgo/jgY1cIixcbiAgICBcIuOBhuOCj+OBlVwiLFxuICAgIFwi44GG44KT44GT44GGXCIsXG4gICAgXCLjgYbjgpPjgaHjgpNcIixcbiAgICBcIuOBhuOCk+OBpuOCk1wiLFxuICAgIFwi44GG44KT44Go44KZ44GGXCIsXG4gICAgXCLjgYjjgYTjgYjjgpNcIixcbiAgICBcIuOBiOOBhOOBi+OCmVwiLFxuICAgIFwi44GI44GE44GN44KH44GGXCIsXG4gICAgXCLjgYjjgYTjgZPjgplcIixcbiAgICBcIuOBiOOBhOOBm+OBhFwiLFxuICAgIFwi44GI44GE44G144KZ44KTXCIsXG4gICAgXCLjgYjjgYTjgojjgYZcIixcbiAgICBcIuOBiOOBhOOCj1wiLFxuICAgIFwi44GI44GK44KKXCIsXG4gICAgXCLjgYjjgYvjgpnjgYpcIixcbiAgICBcIuOBiOOBi+OCmeOBj1wiLFxuICAgIFwi44GI44GN44Gf44GEXCIsXG4gICAgXCLjgYjjgY/jgZvjgotcIixcbiAgICBcIuOBiOOBl+OCg+OBj1wiLFxuICAgIFwi44GI44GZ44GmXCIsXG4gICAgXCLjgYjjgaTjgonjgpNcIixcbiAgICBcIuOBiOOBruOBj+OCmVwiLFxuICAgIFwi44GI44G744GG44G+44GNXCIsXG4gICAgXCLjgYjjgbvjgpNcIixcbiAgICBcIuOBiOOBvuOBjVwiLFxuICAgIFwi44GI44KC44GX44KZXCIsXG4gICAgXCLjgYjjgoLjga5cIixcbiAgICBcIuOBiOOCieOBhFwiLFxuICAgIFwi44GI44KJ44G144KZXCIsXG4gICAgXCLjgYjjgorjgYJcIixcbiAgICBcIuOBiOOCk+OBiOOCk1wiLFxuICAgIFwi44GI44KT44GL44GEXCIsXG4gICAgXCLjgYjjgpPjgY3jgplcIixcbiAgICBcIuOBiOOCk+OBkeOCmeOBjVwiLFxuICAgIFwi44GI44KT44GX44KF44GGXCIsXG4gICAgXCLjgYjjgpPjgZvjgpnjgaRcIixcbiAgICBcIuOBiOOCk+OBneOBj1wiLFxuICAgIFwi44GI44KT44Gh44KH44GGXCIsXG4gICAgXCLjgYjjgpPjgajjgaRcIixcbiAgICBcIuOBiuOBhOOBi+OBkeOCi1wiLFxuICAgIFwi44GK44GE44GT44GZXCIsXG4gICAgXCLjgYrjgYTjgZfjgYRcIixcbiAgICBcIuOBiuOBhOOBpOOBj1wiLFxuICAgIFwi44GK44GG44GI44KTXCIsXG4gICAgXCLjgYrjgYbjgZXjgb5cIixcbiAgICBcIuOBiuOBhuOBl+OCmVwiLFxuICAgIFwi44GK44GG44Gb44GkXCIsXG4gICAgXCLjgYrjgYbjgZ/jgYRcIixcbiAgICBcIuOBiuOBhuOBteOBj1wiLFxuICAgIFwi44GK44GG44G444KZ44GEXCIsXG4gICAgXCLjgYrjgYbjgojjgYZcIixcbiAgICBcIuOBiuOBiOOCi1wiLFxuICAgIFwi44GK44GK44GEXCIsXG4gICAgXCLjgYrjgYrjgYZcIixcbiAgICBcIuOBiuOBiuOBqOOCmeOBiuOCilwiLFxuICAgIFwi44GK44GK44KEXCIsXG4gICAgXCLjgYrjgYrjgojjgZ1cIixcbiAgICBcIuOBiuOBi+OBiOOCilwiLFxuICAgIFwi44GK44GL44GZ44KZXCIsXG4gICAgXCLjgYrjgYvjgpnjgoBcIixcbiAgICBcIuOBiuOBi+OCj+OCilwiLFxuICAgIFwi44GK44GN44KZ44Gq44GGXCIsXG4gICAgXCLjgYrjgY3jgotcIixcbiAgICBcIuOBiuOBj+OBleOBvlwiLFxuICAgIFwi44GK44GP44GX44KZ44KH44GGXCIsXG4gICAgXCLjgYrjgY/jgorjgYvjgpnjgapcIixcbiAgICBcIuOBiuOBj+OCi1wiLFxuICAgIFwi44GK44GP44KM44KLXCIsXG4gICAgXCLjgYrjgZPjgZlcIixcbiAgICBcIuOBiuOBk+OBquOBhlwiLFxuICAgIFwi44GK44GT44KLXCIsXG4gICAgXCLjgYrjgZXjgYjjgotcIixcbiAgICBcIuOBiuOBleOBquOBhFwiLFxuICAgIFwi44GK44GV44KB44KLXCIsXG4gICAgXCLjgYrjgZfjgYTjgoxcIixcbiAgICBcIuOBiuOBl+OBiOOCi1wiLFxuICAgIFwi44GK44GX44KZ44GN44KZXCIsXG4gICAgXCLjgYrjgZfjgpnjgZXjgpNcIixcbiAgICBcIuOBiuOBl+OCg+OCjFwiLFxuICAgIFwi44GK44Gd44KJ44GPXCIsXG4gICAgXCLjgYrjgZ3jgo/jgotcIixcbiAgICBcIuOBiuOBn+OBi+OCmeOBhFwiLFxuICAgIFwi44GK44Gf44GPXCIsXG4gICAgXCLjgYrjgZ/jgpnjgoTjgYtcIixcbiAgICBcIuOBiuOBoeOBpOOBj1wiLFxuICAgIFwi44GK44Gj44GoXCIsXG4gICAgXCLjgYrjgaTjgopcIixcbiAgICBcIuOBiuOBpuOCmeOBi+OBkVwiLFxuICAgIFwi44GK44Go44GX44KC44GuXCIsXG4gICAgXCLjgYrjgajjgarjgZfjgYRcIixcbiAgICBcIuOBiuOBqOOCmeOCilwiLFxuICAgIFwi44GK44Go44KZ44KN44GL44GZXCIsXG4gICAgXCLjgYrjga/jgpnjgZXjgpNcIixcbiAgICBcIuOBiuOBvuOBhOOCilwiLFxuICAgIFwi44GK44KB44Gm44KZ44Go44GGXCIsXG4gICAgXCLjgYrjgoLjgYTjgabjgplcIixcbiAgICBcIuOBiuOCguOBhlwiLFxuICAgIFwi44GK44KC44Gf44GEXCIsXG4gICAgXCLjgYrjgoLjgaHjgoNcIixcbiAgICBcIuOBiuOChOOBpFwiLFxuICAgIFwi44GK44KE44KG44Gy44KZXCIsXG4gICAgXCLjgYrjgojjgbvjgpnjgZlcIixcbiAgICBcIuOBiuOCieOCk+OBn+OCmVwiLFxuICAgIFwi44GK44KN44GZXCIsXG4gICAgXCLjgYrjgpPjgYvjgpnjgY9cIixcbiAgICBcIuOBiuOCk+OBkeOBhFwiLFxuICAgIFwi44GK44KT44GX44KDXCIsXG4gICAgXCLjgYrjgpPjgZvjgpNcIixcbiAgICBcIuOBiuOCk+OBn+OCmeOCk1wiLFxuICAgIFwi44GK44KT44Gh44KF44GGXCIsXG4gICAgXCLjgYrjgpPjgajjgpnjgZHjgYRcIixcbiAgICBcIuOBi+OBguOBpFwiLFxuICAgIFwi44GL44GE44GL44KZXCIsXG4gICAgXCLjgYvjgpnjgYTjgY1cIixcbiAgICBcIuOBi+OCmeOBhOOBkeOCk1wiLFxuICAgIFwi44GL44KZ44GE44GT44GGXCIsXG4gICAgXCLjgYvjgYTjgZXjgaRcIixcbiAgICBcIuOBi+OBhOOBl+OCg1wiLFxuICAgIFwi44GL44GE44GZ44GE44KI44GPXCIsXG4gICAgXCLjgYvjgYTjgZvjgpnjgpNcIixcbiAgICBcIuOBi+OBhOOBneOCmeOBhuOBqOOCmVwiLFxuICAgIFwi44GL44GE44Gk44GGXCIsXG4gICAgXCLjgYvjgYTjgabjgpNcIixcbiAgICBcIuOBi+OBhOOBqOOBhlwiLFxuICAgIFwi44GL44GE44G144GPXCIsXG4gICAgXCLjgYvjgpnjgYTjgbjjgY1cIixcbiAgICBcIuOBi+OBhOOBu+OBhlwiLFxuICAgIFwi44GL44GE44KI44GGXCIsXG4gICAgXCLjgYvjgpnjgYTjgonjgYRcIixcbiAgICBcIuOBi+OBhOOCj1wiLFxuICAgIFwi44GL44GI44KLXCIsXG4gICAgXCLjgYvjgYrjgopcIixcbiAgICBcIuOBi+OBi+OBiOOCi1wiLFxuICAgIFwi44GL44GL44KZ44GPXCIsXG4gICAgXCLjgYvjgYvjgpnjgZdcIixcbiAgICBcIuOBi+OBi+OCmeOBv1wiLFxuICAgIFwi44GL44GP44GT44KZXCIsXG4gICAgXCLjgYvjgY/jgajjgY9cIixcbiAgICBcIuOBi+OBleOCmeOCi1wiLFxuICAgIFwi44GL44KZ44Gd44KZ44GGXCIsXG4gICAgXCLjgYvjgZ/jgYRcIixcbiAgICBcIuOBi+OBn+OBoVwiLFxuICAgIFwi44GL44KZ44Gh44KH44GGXCIsXG4gICAgXCLjgYvjgpnjgaPjgY3jgoXjgYZcIixcbiAgICBcIuOBi+OCmeOBo+OBk+OBhlwiLFxuICAgIFwi44GL44KZ44Gj44GV44KTXCIsXG4gICAgXCLjgYvjgpnjgaPjgZfjgofjgYZcIixcbiAgICBcIuOBi+OBquOBleOCmeOCj+OBl1wiLFxuICAgIFwi44GL44Gu44GGXCIsXG4gICAgXCLjgYvjgpnjga/jgY9cIixcbiAgICBcIuOBi+OBteOCmeOBi1wiLFxuICAgIFwi44GL44G744GGXCIsXG4gICAgXCLjgYvjgbvjgZPjgplcIixcbiAgICBcIuOBi+OBvuOBhlwiLFxuICAgIFwi44GL44G+44G744KZ44GTXCIsXG4gICAgXCLjgYvjgoHjgozjgYrjgpNcIixcbiAgICBcIuOBi+OChuOBhFwiLFxuICAgIFwi44GL44KI44GG44Gy44KZXCIsXG4gICAgXCLjgYvjgonjgYRcIixcbiAgICBcIuOBi+OCi+OBhFwiLFxuICAgIFwi44GL44KN44GGXCIsXG4gICAgXCLjgYvjgo/jgY9cIixcbiAgICBcIuOBi+OCj+OCiVwiLFxuICAgIFwi44GL44KZ44KT44GLXCIsXG4gICAgXCLjgYvjgpPjgZHjgYRcIixcbiAgICBcIuOBi+OCk+OBk+OBhlwiLFxuICAgIFwi44GL44KT44GX44KDXCIsXG4gICAgXCLjgYvjgpPjgZ3jgYZcIixcbiAgICBcIuOBi+OCk+OBn+OCk1wiLFxuICAgIFwi44GL44KT44GhXCIsXG4gICAgXCLjgYvjgpnjgpPjga/jgpnjgotcIixcbiAgICBcIuOBjeOBguOBhFwiLFxuICAgIFwi44GN44GC44GkXCIsXG4gICAgXCLjgY3jgYTjgo1cIixcbiAgICBcIuOBjeOCmeOBhOOCk1wiLFxuICAgIFwi44GN44GG44GEXCIsXG4gICAgXCLjgY3jgYbjgpNcIixcbiAgICBcIuOBjeOBiOOCi1wiLFxuICAgIFwi44GN44GK44GGXCIsXG4gICAgXCLjgY3jgYrjgY9cIixcbiAgICBcIuOBjeOBiuOBoVwiLFxuICAgIFwi44GN44GK44KTXCIsXG4gICAgXCLjgY3jgYvjgYRcIixcbiAgICBcIuOBjeOBi+OBj1wiLFxuICAgIFwi44GN44GL44KT44GX44KDXCIsXG4gICAgXCLjgY3jgY3jgaZcIixcbiAgICBcIuOBjeOBj+OBr+OCmeOCilwiLFxuICAgIFwi44GN44GP44KJ44GR44KZXCIsXG4gICAgXCLjgY3jgZHjgpPjgZvjgYRcIixcbiAgICBcIuOBjeOBk+OBhlwiLFxuICAgIFwi44GN44GT44GI44KLXCIsXG4gICAgXCLjgY3jgZPjgY9cIixcbiAgICBcIuOBjeOBleOBhFwiLFxuICAgIFwi44GN44GV44GPXCIsXG4gICAgXCLjgY3jgZXjgb5cIixcbiAgICBcIuOBjeOBleOCieOBjeOCmVwiLFxuICAgIFwi44GN44KZ44GX44KZ44GL44GL44KZ44GPXCIsXG4gICAgXCLjgY3jgpnjgZfjgY1cIixcbiAgICBcIuOBjeOCmeOBl+OCmeOBn+OBhOOBkeOCk1wiLFxuICAgIFwi44GN44KZ44GX44KZ44Gr44Gj44Gm44GEXCIsXG4gICAgXCLjgY3jgpnjgZfjgpnjgoXjgaTjgZfjgoNcIixcbiAgICBcIuOBjeOBmeOBhlwiLFxuICAgIFwi44GN44Gb44GEXCIsXG4gICAgXCLjgY3jgZvjgY1cIixcbiAgICBcIuOBjeOBm+OBpFwiLFxuICAgIFwi44GN44Gd44GGXCIsXG4gICAgXCLjgY3jgZ3jgpnjgY9cIixcbiAgICBcIuOBjeOBneOCmeOCk1wiLFxuICAgIFwi44GN44Gf44GI44KLXCIsXG4gICAgXCLjgY3jgaHjgofjgYZcIixcbiAgICBcIuOBjeOBpOOBiOOCk1wiLFxuICAgIFwi44GN44KZ44Gj44Gh44KKXCIsXG4gICAgXCLjgY3jgaTjgaTjgY1cIixcbiAgICBcIuOBjeOBpOOBrVwiLFxuICAgIFwi44GN44Gm44GEXCIsXG4gICAgXCLjgY3jgajjgpnjgYZcIixcbiAgICBcIuOBjeOBqOOCmeOBj1wiLFxuICAgIFwi44GN44Gq44GEXCIsXG4gICAgXCLjgY3jgarjgYvjgplcIixcbiAgICBcIuOBjeOBquOBk1wiLFxuICAgIFwi44GN44Gs44GT44KZ44GXXCIsXG4gICAgXCLjgY3jga3jgpNcIixcbiAgICBcIuOBjeOBruOBhlwiLFxuICAgIFwi44GN44Gu44GX44GfXCIsXG4gICAgXCLjgY3jga/jgY9cIixcbiAgICBcIuOBjeOBsuOCmeOBl+OBhFwiLFxuICAgIFwi44GN44Gy44KTXCIsXG4gICAgXCLjgY3jgbXjgY9cIixcbiAgICBcIuOBjeOBteOCmeOCk1wiLFxuICAgIFwi44GN44G744KZ44GGXCIsXG4gICAgXCLjgY3jgbvjgpNcIixcbiAgICBcIuOBjeOBvuOCi1wiLFxuICAgIFwi44GN44G/44GkXCIsXG4gICAgXCLjgY3jgoDjgZnjgpnjgYvjgZfjgYRcIixcbiAgICBcIuOBjeOCgeOCi1wiLFxuICAgIFwi44GN44KC44Gf44KZ44KB44GXXCIsXG4gICAgXCLjgY3jgoLjgaFcIixcbiAgICBcIuOBjeOCguOBrlwiLFxuICAgIFwi44GN44KD44GPXCIsXG4gICAgXCLjgY3jgoTjgY9cIixcbiAgICBcIuOBjeOCmeOCheOBhuOBq+OBj1wiLFxuICAgIFwi44GN44KI44GGXCIsXG4gICAgXCLjgY3jgofjgYbjgorjgoXjgYZcIixcbiAgICBcIuOBjeOCieOBhFwiLFxuICAgIFwi44GN44KJ44GPXCIsXG4gICAgXCLjgY3jgorjgpNcIixcbiAgICBcIuOBjeOCjOOBhFwiLFxuICAgIFwi44GN44KM44GkXCIsXG4gICAgXCLjgY3jgo3jgY9cIixcbiAgICBcIuOBjeOCmeOCjeOCk1wiLFxuICAgIFwi44GN44KP44KB44KLXCIsXG4gICAgXCLjgY3jgpnjgpPjgYTjgo1cIixcbiAgICBcIuOBjeOCk+OBi+OBj+OBl+OCmVwiLFxuICAgIFwi44GN44KT44GX44KZ44KHXCIsXG4gICAgXCLjgY3jgpPjgojjgYbjgbLjgplcIixcbiAgICBcIuOBj+OCmeOBguOBhFwiLFxuICAgIFwi44GP44GE44GZ44KZXCIsXG4gICAgXCLjgY/jgYbjgYvjgpNcIixcbiAgICBcIuOBj+OBhuOBjVwiLFxuICAgIFwi44GP44GG44GP44KZ44KTXCIsXG4gICAgXCLjgY/jgYbjgZPjgYZcIixcbiAgICBcIuOBj+OCmeOBhuOBm+OBhFwiLFxuICAgIFwi44GP44GG44Gd44GGXCIsXG4gICAgXCLjgY/jgpnjgYbjgZ/jgolcIixcbiAgICBcIuOBj+OBhuOBteOBj1wiLFxuICAgIFwi44GP44GG44G744KZXCIsXG4gICAgXCLjgY/jgYvjgpNcIixcbiAgICBcIuOBj+OBjeOCh+OBhlwiLFxuICAgIFwi44GP44GR44KZ44KTXCIsXG4gICAgXCLjgY/jgpnjgZPjgYZcIixcbiAgICBcIuOBj+OBleOBhFwiLFxuICAgIFwi44GP44GV44GNXCIsXG4gICAgXCLjgY/jgZXjga/jgpnjgapcIixcbiAgICBcIuOBj+OBleOCi1wiLFxuICAgIFwi44GP44GX44KD44G/XCIsXG4gICAgXCLjgY/jgZfjgofjgYZcIixcbiAgICBcIuOBj+OBmeOBruOBjVwiLFxuICAgIFwi44GP44GZ44KK44KG44Gy44KZXCIsXG4gICAgXCLjgY/jgZvjgZHjgplcIixcbiAgICBcIuOBj+OBm+OCk1wiLFxuICAgIFwi44GP44KZ44Gf44GE44Gm44GNXCIsXG4gICAgXCLjgY/jgZ/jgpnjgZXjgotcIixcbiAgICBcIuOBj+OBn+OBsuOCmeOCjOOCi1wiLFxuICAgIFwi44GP44Gh44GT44G/XCIsXG4gICAgXCLjgY/jgaHjgZXjgY1cIixcbiAgICBcIuOBj+OBpOOBl+OBn1wiLFxuICAgIFwi44GP44KZ44Gj44GZ44KKXCIsXG4gICAgXCLjgY/jgaTjgo3jgY/jgplcIixcbiAgICBcIuOBj+OBqOOBhuOBpuOCk1wiLFxuICAgIFwi44GP44Go44KZ44GPXCIsXG4gICAgXCLjgY/jgarjgpNcIixcbiAgICBcIuOBj+OBreOBj+OBrVwiLFxuICAgIFwi44GP44Gu44GGXCIsXG4gICAgXCLjgY/jgbXjgYZcIixcbiAgICBcIuOBj+OBv+OBguOCj+OBm1wiLFxuICAgIFwi44GP44G/44Gf44Gm44KLXCIsXG4gICAgXCLjgY/jgoHjgotcIixcbiAgICBcIuOBj+OChOOBj+OBl+OCh1wiLFxuICAgIFwi44GP44KJ44GZXCIsXG4gICAgXCLjgY/jgonjgbjjgpnjgotcIixcbiAgICBcIuOBj+OCi+OBvlwiLFxuICAgIFwi44GP44KM44KLXCIsXG4gICAgXCLjgY/jgo3jgYZcIixcbiAgICBcIuOBj+OCj+OBl+OBhFwiLFxuICAgIFwi44GP44KZ44KT44GL44KTXCIsXG4gICAgXCLjgY/jgpnjgpPjgZfjgofjgY9cIixcbiAgICBcIuOBj+OCmeOCk+OBn+OBhFwiLFxuICAgIFwi44GP44KZ44KT44GmXCIsXG4gICAgXCLjgZHjgYLjgapcIixcbiAgICBcIuOBkeOBhOOBi+OBj1wiLFxuICAgIFwi44GR44GE44GR44KTXCIsXG4gICAgXCLjgZHjgYTjgZNcIixcbiAgICBcIuOBkeOBhOOBleOBpFwiLFxuICAgIFwi44GR44KZ44GE44GX44KZ44KF44GkXCIsXG4gICAgXCLjgZHjgYTjgZ/jgYRcIixcbiAgICBcIuOBkeOCmeOBhOOBruOBhuOBl+OCmeOCk1wiLFxuICAgIFwi44GR44GE44KM44GNXCIsXG4gICAgXCLjgZHjgYTjgo1cIixcbiAgICBcIuOBkeOBiuOBqOOBmVwiLFxuICAgIFwi44GR44GK44KK44KC44GuXCIsXG4gICAgXCLjgZHjgpnjgY3jgYtcIixcbiAgICBcIuOBkeOCmeOBjeOBkeOCmeOCk1wiLFxuICAgIFwi44GR44KZ44GN44Gf44KZ44KTXCIsXG4gICAgXCLjgZHjgpnjgY3jgaHjgpNcIixcbiAgICBcIuOBkeOCmeOBjeOBqOOBpFwiLFxuICAgIFwi44GR44KZ44GN44GvXCIsXG4gICAgXCLjgZHjgpnjgY3jgoTjgY9cIixcbiAgICBcIuOBkeOCmeOBk+OBhlwiLFxuICAgIFwi44GR44KZ44GT44GP44GX44KZ44KH44GGXCIsXG4gICAgXCLjgZHjgpnjgZXjgpnjgYRcIixcbiAgICBcIuOBkeOBleOBjVwiLFxuICAgIFwi44GR44KZ44GV44KZ44KTXCIsXG4gICAgXCLjgZHjgZfjgY1cIixcbiAgICBcIuOBkeOBl+OBk+OCmeOCgFwiLFxuICAgIFwi44GR44GX44KH44GGXCIsXG4gICAgXCLjgZHjgpnjgZnjgahcIixcbiAgICBcIuOBkeOBn+OBr+OCmVwiLFxuICAgIFwi44GR44Gh44KD44Gj44G144KaXCIsXG4gICAgXCLjgZHjgaHjgonjgZlcIixcbiAgICBcIuOBkeOBpOOBguOBpFwiLFxuICAgIFwi44GR44Gk44GEXCIsXG4gICAgXCLjgZHjgaTjgYjjgY1cIixcbiAgICBcIuOBkeOBo+OBk+OCk1wiLFxuICAgIFwi44GR44Gk44GX44KZ44KHXCIsXG4gICAgXCLjgZHjgaPjgZvjgY1cIixcbiAgICBcIuOBkeOBo+OBpuOBhFwiLFxuICAgIFwi44GR44Gk44G+44GkXCIsXG4gICAgXCLjgZHjgpnjgaTjgojjgYbjgbLjgplcIixcbiAgICBcIuOBkeOCmeOBpOOCjOOBhFwiLFxuICAgIFwi44GR44Gk44KN44KTXCIsXG4gICAgXCLjgZHjgpnjgajjgpnjgY9cIixcbiAgICBcIuOBkeOBqOOBr+OCmeOBmVwiLFxuICAgIFwi44GR44Go44KLXCIsXG4gICAgXCLjgZHjgarjgZHjgplcIixcbiAgICBcIuOBkeOBquOBmVwiLFxuICAgIFwi44GR44Gq44G/XCIsXG4gICAgXCLjgZHjgazjgY1cIixcbiAgICBcIuOBkeOCmeOBreOBpFwiLFxuICAgIFwi44GR44Gt44KTXCIsXG4gICAgXCLjgZHjga/jgYRcIixcbiAgICBcIuOBkeOCmeOBsuOCk1wiLFxuICAgIFwi44GR44G144KZ44GL44GEXCIsXG4gICAgXCLjgZHjgpnjgbvjgpnjgY9cIixcbiAgICBcIuOBkeOBvuOCilwiLFxuICAgIFwi44GR44G/44GL44KLXCIsXG4gICAgXCLjgZHjgoDjgZdcIixcbiAgICBcIuOBkeOCgOOCilwiLFxuICAgIFwi44GR44KC44GuXCIsXG4gICAgXCLjgZHjgonjgYRcIixcbiAgICBcIuOBkeOCjeOBkeOCjVwiLFxuICAgIFwi44GR44KP44GX44GEXCIsXG4gICAgXCLjgZHjgpPjgYRcIixcbiAgICBcIuOBkeOCk+OBiOOBpFwiLFxuICAgIFwi44GR44KT44GKXCIsXG4gICAgXCLjgZHjgpPjgYtcIixcbiAgICBcIuOBkeOCmeOCk+OBjVwiLFxuICAgIFwi44GR44KT44GR44KZ44KTXCIsXG4gICAgXCLjgZHjgpPjgZPjgYZcIixcbiAgICBcIuOBkeOCk+OBleOBj1wiLFxuICAgIFwi44GR44KT44GX44KF44GGXCIsXG4gICAgXCLjgZHjgpPjgZnjgYZcIixcbiAgICBcIuOBkeOCmeOCk+OBneOBhlwiLFxuICAgIFwi44GR44KT44Gh44GPXCIsXG4gICAgXCLjgZHjgpPjgabjgYRcIixcbiAgICBcIuOBkeOCk+OBqOOBhlwiLFxuICAgIFwi44GR44KT44Gq44GEXCIsXG4gICAgXCLjgZHjgpPjgavjgpNcIixcbiAgICBcIuOBkeOCmeOCk+OBteOCmeOBpFwiLFxuICAgIFwi44GR44KT44G+XCIsXG4gICAgXCLjgZHjgpPjgb/jgpNcIixcbiAgICBcIuOBkeOCk+OCgeOBhFwiLFxuICAgIFwi44GR44KT44KJ44KTXCIsXG4gICAgXCLjgZHjgpPjgopcIixcbiAgICBcIuOBk+OBguOBj+OBvlwiLFxuICAgIFwi44GT44GE44GsXCIsXG4gICAgXCLjgZPjgYTjgbLjgpnjgahcIixcbiAgICBcIuOBk+OCmeOBhuOBhFwiLFxuICAgIFwi44GT44GG44GI44KTXCIsXG4gICAgXCLjgZPjgYbjgYrjgpNcIixcbiAgICBcIuOBk+OBhuOBi+OCk1wiLFxuICAgIFwi44GT44KZ44GG44GN44KF44GGXCIsXG4gICAgXCLjgZPjgpnjgYbjgZHjgYRcIixcbiAgICBcIuOBk+OBhuOBk+OBhlwiLFxuICAgIFwi44GT44GG44GV44GEXCIsXG4gICAgXCLjgZPjgYbjgZfjgplcIixcbiAgICBcIuOBk+OBhuOBmeOBhFwiLFxuICAgIFwi44GT44KZ44GG44Gb44GEXCIsXG4gICAgXCLjgZPjgYbjgZ3jgY9cIixcbiAgICBcIuOBk+OBhuOBn+OBhFwiLFxuICAgIFwi44GT44GG44Gh44KDXCIsXG4gICAgXCLjgZPjgYbjgaTjgYZcIixcbiAgICBcIuOBk+OBhuOBpuOBhFwiLFxuICAgIFwi44GT44GG44Go44KZ44GGXCIsXG4gICAgXCLjgZPjgYbjgarjgYRcIixcbiAgICBcIuOBk+OBhuOBr+OBhFwiLFxuICAgIFwi44GT44KZ44GG44G744GGXCIsXG4gICAgXCLjgZPjgpnjgYbjgb7jgpNcIixcbiAgICBcIuOBk+OBhuOCguOBj1wiLFxuICAgIFwi44GT44GG44KK44GkXCIsXG4gICAgXCLjgZPjgYjjgotcIixcbiAgICBcIuOBk+OBiuOCilwiLFxuICAgIFwi44GT44KZ44GL44GEXCIsXG4gICAgXCLjgZPjgpnjgYvjgpnjgaRcIixcbiAgICBcIuOBk+OCmeOBi+OCk1wiLFxuICAgIFwi44GT44GP44GT44KZXCIsXG4gICAgXCLjgZPjgY/jgZXjgYRcIixcbiAgICBcIuOBk+OBj+OBqOOBhlwiLFxuICAgIFwi44GT44GP44Gq44GEXCIsXG4gICAgXCLjgZPjgY/jga/jgY9cIixcbiAgICBcIuOBk+OBj+OCmeOBvlwiLFxuICAgIFwi44GT44GR44GEXCIsXG4gICAgXCLjgZPjgZHjgotcIixcbiAgICBcIuOBk+OBk+OBruOBi1wiLFxuICAgIFwi44GT44GT44KNXCIsXG4gICAgXCLjgZPjgZXjgoFcIixcbiAgICBcIuOBk+OBl+OBpFwiLFxuICAgIFwi44GT44GZ44GGXCIsXG4gICAgXCLjgZPjgZvjgYRcIixcbiAgICBcIuOBk+OBm+OBjVwiLFxuICAgIFwi44GT44Gb44KZ44KTXCIsXG4gICAgXCLjgZPjgZ3jgZ/jgpnjgaZcIixcbiAgICBcIuOBk+OBn+OBhFwiLFxuICAgIFwi44GT44Gf44GI44KLXCIsXG4gICAgXCLjgZPjgZ/jgaRcIixcbiAgICBcIuOBk+OBoeOCh+OBhlwiLFxuICAgIFwi44GT44Gj44GLXCIsXG4gICAgXCLjgZPjgaTjgZPjgaRcIixcbiAgICBcIuOBk+OBpOOBr+OCmeOCk1wiLFxuICAgIFwi44GT44Gk44G144KZXCIsXG4gICAgXCLjgZPjgabjgYRcIixcbiAgICBcIuOBk+OBpuOCk1wiLFxuICAgIFwi44GT44Go44GL44KZ44KJXCIsXG4gICAgXCLjgZPjgajjgZdcIixcbiAgICBcIuOBk+OBqOOBr+OCmVwiLFxuICAgIFwi44GT44Go44KKXCIsXG4gICAgXCLjgZPjgarjgZPjgpnjgapcIixcbiAgICBcIuOBk+OBreOBk+OBrVwiLFxuICAgIFwi44GT44Gu44G+44G+XCIsXG4gICAgXCLjgZPjga7jgb9cIixcbiAgICBcIuOBk+OBruOCiFwiLFxuICAgIFwi44GT44KZ44Gv44KTXCIsXG4gICAgXCLjgZPjgbLjgaTjgZfjgplcIixcbiAgICBcIuOBk+OBteOBhlwiLFxuICAgIFwi44GT44G144KTXCIsXG4gICAgXCLjgZPjgbvjgpnjgozjgotcIixcbiAgICBcIuOBk+OCmeOBvuOBguOBteOCmeOCiVwiLFxuICAgIFwi44GT44G+44GL44GEXCIsXG4gICAgXCLjgZPjgpnjgb7jgZnjgopcIixcbiAgICBcIuOBk+OBvuOBpOOBqlwiLFxuICAgIFwi44GT44G+44KLXCIsXG4gICAgXCLjgZPjgoDjgY3jgpnjgZNcIixcbiAgICBcIuOBk+OCguOBl+OCmVwiLFxuICAgIFwi44GT44KC44GhXCIsXG4gICAgXCLjgZPjgoLjga5cIixcbiAgICBcIuOBk+OCguOCk1wiLFxuICAgIFwi44GT44KE44GPXCIsXG4gICAgXCLjgZPjgoTjgb5cIixcbiAgICBcIuOBk+OChuOBhlwiLFxuICAgIFwi44GT44KG44Gy44KZXCIsXG4gICAgXCLjgZPjgojjgYRcIixcbiAgICBcIuOBk+OCiOOBhlwiLFxuICAgIFwi44GT44KK44KLXCIsXG4gICAgXCLjgZPjgozjgY/jgZfjgofjgpNcIixcbiAgICBcIuOBk+OCjeOBo+OBkVwiLFxuICAgIFwi44GT44KP44KC44GmXCIsXG4gICAgXCLjgZPjgo/jgozjgotcIixcbiAgICBcIuOBk+OCk+OBhOOCk1wiLFxuICAgIFwi44GT44KT44GL44GEXCIsXG4gICAgXCLjgZPjgpPjgY1cIixcbiAgICBcIuOBk+OCk+OBl+OCheOBhlwiLFxuICAgIFwi44GT44KT44GZ44GEXCIsXG4gICAgXCLjgZPjgpPjgZ/jgpnjgaZcIixcbiAgICBcIuOBk+OCk+OBqOOCk1wiLFxuICAgIFwi44GT44KT44Gq44KTXCIsXG4gICAgXCLjgZPjgpPjgbLjgpnjgatcIixcbiAgICBcIuOBk+OCk+OBu+OCmuOCk1wiLFxuICAgIFwi44GT44KT44G+44GRXCIsXG4gICAgXCLjgZPjgpPjgoRcIixcbiAgICBcIuOBk+OCk+OCjOOBhFwiLFxuICAgIFwi44GT44KT44KP44GPXCIsXG4gICAgXCLjgZXjgpnjgYTjgYjjgY1cIixcbiAgICBcIuOBleOBhOOBi+OBhFwiLFxuICAgIFwi44GV44GE44GN44KTXCIsXG4gICAgXCLjgZXjgpnjgYTjgZHjgpnjgpNcIixcbiAgICBcIuOBleOCmeOBhOOBk1wiLFxuICAgIFwi44GV44GE44GX44KHXCIsXG4gICAgXCLjgZXjgYTjgZvjgYRcIixcbiAgICBcIuOBleOCmeOBhOOBn+OBj1wiLFxuICAgIFwi44GV44KZ44GE44Gh44KF44GGXCIsXG4gICAgXCLjgZXjgYTjgabjgY1cIixcbiAgICBcIuOBleOCmeOBhOOCiuOCh+OBhlwiLFxuICAgIFwi44GV44GG44GqXCIsXG4gICAgXCLjgZXjgYvjgYTjgZdcIixcbiAgICBcIuOBleOBi+OCmeOBmVwiLFxuICAgIFwi44GV44GL44GqXCIsXG4gICAgXCLjgZXjgYvjgb/jgaFcIixcbiAgICBcIuOBleOBi+OCmeOCi1wiLFxuICAgIFwi44GV44GN44KZ44KH44GGXCIsXG4gICAgXCLjgZXjgY/jgZdcIixcbiAgICBcIuOBleOBj+OBsuOCk1wiLFxuICAgIFwi44GV44GP44KJXCIsXG4gICAgXCLjgZXjgZPjgY9cIixcbiAgICBcIuOBleOBk+OBpFwiLFxuICAgIFwi44GV44GZ44KZ44GL44KLXCIsXG4gICAgXCLjgZXjgpnjgZvjgY1cIixcbiAgICBcIuOBleOBn+OCk1wiLFxuICAgIFwi44GV44Gk44GI44GEXCIsXG4gICAgXCLjgZXjgpnjgaTjgYrjgpNcIixcbiAgICBcIuOBleOCmeOBo+OBi1wiLFxuICAgIFwi44GV44KZ44Gk44GL44KZ44GPXCIsXG4gICAgXCLjgZXjgaPjgY3jgofjgY9cIixcbiAgICBcIuOBleOCmeOBo+OBl1wiLFxuICAgIFwi44GV44Gk44GX44KZ44KTXCIsXG4gICAgXCLjgZXjgpnjgaPjgZ3jgYZcIixcbiAgICBcIuOBleOBpOOBn+OBr+OCmVwiLFxuICAgIFwi44GV44Gk44G+44GE44KCXCIsXG4gICAgXCLjgZXjgabjgYRcIixcbiAgICBcIuOBleOBqOOBhOOCglwiLFxuICAgIFwi44GV44Go44GGXCIsXG4gICAgXCLjgZXjgajjgYrjgoRcIixcbiAgICBcIuOBleOBqOOBl1wiLFxuICAgIFwi44GV44Go44KLXCIsXG4gICAgXCLjgZXjga7jgYZcIixcbiAgICBcIuOBleOBr+OCmeOBj1wiLFxuICAgIFwi44GV44Gy44KZ44GX44GEXCIsXG4gICAgXCLjgZXjgbjjgpnjgaRcIixcbiAgICBcIuOBleOBu+OBhlwiLFxuICAgIFwi44GV44G744Go44KZXCIsXG4gICAgXCLjgZXjgb7jgZlcIixcbiAgICBcIuOBleOBv+OBl+OBhFwiLFxuICAgIFwi44GV44G/44Gf44KZ44KMXCIsXG4gICAgXCLjgZXjgoDjgZFcIixcbiAgICBcIuOBleOCgeOCi1wiLFxuICAgIFwi44GV44KE44GI44KT44Go44KZ44GGXCIsXG4gICAgXCLjgZXjgobjgYZcIixcbiAgICBcIuOBleOCiOOBhlwiLFxuICAgIFwi44GV44KI44GPXCIsXG4gICAgXCLjgZXjgonjgZ/jgplcIixcbiAgICBcIuOBleOCmeOCi+OBneOBr+OCmVwiLFxuICAgIFwi44GV44KP44KE44GLXCIsXG4gICAgXCLjgZXjgo/jgotcIixcbiAgICBcIuOBleOCk+OBhOOCk1wiLFxuICAgIFwi44GV44KT44GLXCIsXG4gICAgXCLjgZXjgpPjgY3jgoPjgY9cIixcbiAgICBcIuOBleOCk+OBk+OBhlwiLFxuICAgIFwi44GV44KT44GV44GEXCIsXG4gICAgXCLjgZXjgpnjgpPjgZfjgodcIixcbiAgICBcIuOBleOCk+OBmeOBhlwiLFxuICAgIFwi44GV44KT44Gb44GEXCIsXG4gICAgXCLjgZXjgpPjgZ1cIixcbiAgICBcIuOBleOCk+OBoVwiLFxuICAgIFwi44GV44KT44G+XCIsXG4gICAgXCLjgZXjgpPjgb9cIixcbiAgICBcIuOBleOCk+OCieOCk1wiLFxuICAgIFwi44GX44GC44GEXCIsXG4gICAgXCLjgZfjgYLjgZHjgplcIixcbiAgICBcIuOBl+OBguOBleOBo+OBplwiLFxuICAgIFwi44GX44GC44KP44GbXCIsXG4gICAgXCLjgZfjgYTjgY9cIixcbiAgICBcIuOBl+OBhOOCk1wiLFxuICAgIFwi44GX44GG44GhXCIsXG4gICAgXCLjgZfjgYjjgYRcIixcbiAgICBcIuOBl+OBiuOBkVwiLFxuICAgIFwi44GX44GL44GEXCIsXG4gICAgXCLjgZfjgYvjgY9cIixcbiAgICBcIuOBl+OCmeOBi+OCk1wiLFxuICAgIFwi44GX44GT44KZ44GoXCIsXG4gICAgXCLjgZfjgZnjgYZcIixcbiAgICBcIuOBl+OCmeOBn+OCmeOBhFwiLFxuICAgIFwi44GX44Gf44GG44GRXCIsXG4gICAgXCLjgZfjgZ/jgY3jgplcIixcbiAgICBcIuOBl+OBn+OBplwiLFxuICAgIFwi44GX44Gf44G/XCIsXG4gICAgXCLjgZfjgaHjgofjgYZcIixcbiAgICBcIuOBl+OBoeOCiuOCk1wiLFxuICAgIFwi44GX44Gj44GL44KKXCIsXG4gICAgXCLjgZfjgaTjgZfjgplcIixcbiAgICBcIuOBl+OBpOOCguOCk1wiLFxuICAgIFwi44GX44Gm44GEXCIsXG4gICAgXCLjgZfjgabjgY1cIixcbiAgICBcIuOBl+OBpuOBpFwiLFxuICAgIFwi44GX44KZ44Gm44KTXCIsXG4gICAgXCLjgZfjgpnjgajjgpnjgYZcIixcbiAgICBcIuOBl+OBquOBjeOCmeOCjFwiLFxuICAgIFwi44GX44Gq44KC44GuXCIsXG4gICAgXCLjgZfjgarjgpNcIixcbiAgICBcIuOBl+OBreOBvlwiLFxuICAgIFwi44GX44Gt44KTXCIsXG4gICAgXCLjgZfjga7jgY/jgplcIixcbiAgICBcIuOBl+OBruOBteOCmVwiLFxuICAgIFwi44GX44Gv44GEXCIsXG4gICAgXCLjgZfjga/jgpnjgYvjgopcIixcbiAgICBcIuOBl+OBr+OBpFwiLFxuICAgIFwi44GX44Gv44KJ44GEXCIsXG4gICAgXCLjgZfjga/jgpNcIixcbiAgICBcIuOBl+OBsuOCh+OBhlwiLFxuICAgIFwi44GX44G144GPXCIsXG4gICAgXCLjgZfjgpnjgbXjgpnjgpNcIixcbiAgICBcIuOBl+OBuOOBhFwiLFxuICAgIFwi44GX44G744GGXCIsXG4gICAgXCLjgZfjgbvjgpNcIixcbiAgICBcIuOBl+OBvuOBhlwiLFxuICAgIFwi44GX44G+44KLXCIsXG4gICAgXCLjgZfjgb/jgpNcIixcbiAgICBcIuOBl+OCgOOBkeOCi1wiLFxuICAgIFwi44GX44KZ44KA44GX44KHXCIsXG4gICAgXCLjgZfjgoHjgYRcIixcbiAgICBcIuOBl+OCgeOCi1wiLFxuICAgIFwi44GX44KC44KTXCIsXG4gICAgXCLjgZfjgoPjgYTjgpNcIixcbiAgICBcIuOBl+OCg+OBhuOCk1wiLFxuICAgIFwi44GX44KD44GK44KTXCIsXG4gICAgXCLjgZfjgpnjgoPjgYvjgpnjgYTjgoJcIixcbiAgICBcIuOBl+OChOOBj+OBl+OCh1wiLFxuICAgIFwi44GX44KD44GP44G744GGXCIsXG4gICAgXCLjgZfjgoPjgZHjgpNcIixcbiAgICBcIuOBl+OCg+OBk1wiLFxuICAgIFwi44GX44KD44GV44KZ44GEXCIsXG4gICAgXCLjgZfjgoPjgZfjgpNcIixcbiAgICBcIuOBl+OCg+OBm+OCk1wiLFxuICAgIFwi44GX44KD44Gd44GGXCIsXG4gICAgXCLjgZfjgoPjgZ/jgYRcIixcbiAgICBcIuOBl+OCg+OBoeOCh+OBhlwiLFxuICAgIFwi44GX44KD44Gj44GN44KTXCIsXG4gICAgXCLjgZfjgpnjgoPjgb5cIixcbiAgICBcIuOBl+OCg+OCiuOCk1wiLFxuICAgIFwi44GX44KD44KM44GEXCIsXG4gICAgXCLjgZfjgpnjgobjgYZcIixcbiAgICBcIuOBl+OCmeOCheOBhuOBl+OCh1wiLFxuICAgIFwi44GX44KF44GP44Gv44GPXCIsXG4gICAgXCLjgZfjgpnjgoXjgZfjgpNcIixcbiAgICBcIuOBl+OCheOBo+OBm+OBjVwiLFxuICAgIFwi44GX44KF44G/XCIsXG4gICAgXCLjgZfjgoXjgonjga/jgplcIixcbiAgICBcIuOBl+OCmeOCheOCk+OBr+OCmeOCk1wiLFxuICAgIFwi44GX44KH44GG44GL44GEXCIsXG4gICAgXCLjgZfjgofjgY/jgZ/jgY9cIixcbiAgICBcIuOBl+OCh+OBo+OBkeOCk1wiLFxuICAgIFwi44GX44KH44Go44KZ44GGXCIsXG4gICAgXCLjgZfjgofjgoLjgaRcIixcbiAgICBcIuOBl+OCieOBm+OCi1wiLFxuICAgIFwi44GX44KJ44G444KZ44KLXCIsXG4gICAgXCLjgZfjgpPjgYtcIixcbiAgICBcIuOBl+OCk+OBk+OBhlwiLFxuICAgIFwi44GX44KZ44KT44GX44KZ44KDXCIsXG4gICAgXCLjgZfjgpPjgZvjgYTjgZfjgplcIixcbiAgICBcIuOBl+OCk+OBoeOBj1wiLFxuICAgIFwi44GX44KT44KK44KTXCIsXG4gICAgXCLjgZnjgYLjgZHjgplcIixcbiAgICBcIuOBmeOBguOBl1wiLFxuICAgIFwi44GZ44GC44GqXCIsXG4gICAgXCLjgZnjgpnjgYLjgpNcIixcbiAgICBcIuOBmeOBhOOBiOOBhFwiLFxuICAgIFwi44GZ44GE44GLXCIsXG4gICAgXCLjgZnjgYTjgajjgYZcIixcbiAgICBcIuOBmeOCmeOBhOOBteOCmeOCk1wiLFxuICAgIFwi44GZ44GE44KI44GG44Gy44KZXCIsXG4gICAgXCLjgZnjgYbjgYvjgpnjgY9cIixcbiAgICBcIuOBmeOBhuOBl+OCmeOBpFwiLFxuICAgIFwi44GZ44GG44Gb44KTXCIsXG4gICAgXCLjgZnjgYrjgajjgpnjgopcIixcbiAgICBcIuOBmeOBjeOBvlwiLFxuICAgIFwi44GZ44GP44GGXCIsXG4gICAgXCLjgZnjgY/jgarjgYRcIixcbiAgICBcIuOBmeOBkeOCi1wiLFxuICAgIFwi44GZ44GT44KZ44GEXCIsXG4gICAgXCLjgZnjgZPjgZdcIixcbiAgICBcIuOBmeOCmeOBleOCk1wiLFxuICAgIFwi44GZ44GZ44KZ44GX44GEXCIsXG4gICAgXCLjgZnjgZnjgoBcIixcbiAgICBcIuOBmeOBmeOCgeOCi1wiLFxuICAgIFwi44GZ44Gj44GL44KKXCIsXG4gICAgXCLjgZnjgpnjgaPjgZfjgopcIixcbiAgICBcIuOBmeOCmeOBo+OBqFwiLFxuICAgIFwi44GZ44Gm44GNXCIsXG4gICAgXCLjgZnjgabjgotcIixcbiAgICBcIuOBmeOBreOCi1wiLFxuICAgIFwi44GZ44Gu44GTXCIsXG4gICAgXCLjgZnjga/jgZ/jgplcIixcbiAgICBcIuOBmeOBr+OCmeOCieOBl+OBhFwiLFxuICAgIFwi44GZ44KZ44Gy44KH44GGXCIsXG4gICAgXCLjgZnjgpnjgbXjgpnjgazjgoxcIixcbiAgICBcIuOBmeOBteOCmeOCilwiLFxuICAgIFwi44GZ44G144KMXCIsXG4gICAgXCLjgZnjgbjjgpnjgaZcIixcbiAgICBcIuOBmeOBuOOCmeOCi1wiLFxuICAgIFwi44GZ44KZ44G744GGXCIsXG4gICAgXCLjgZnjgbvjgpnjgpNcIixcbiAgICBcIuOBmeOBvuOBhFwiLFxuICAgIFwi44GZ44KB44GXXCIsXG4gICAgXCLjgZnjgoLjgYZcIixcbiAgICBcIuOBmeOChOOBjVwiLFxuICAgIFwi44GZ44KJ44GZ44KJXCIsXG4gICAgXCLjgZnjgovjgoFcIixcbiAgICBcIuOBmeOCjOOBoeOBi+OCmeOBhlwiLFxuICAgIFwi44GZ44KN44Gj44GoXCIsXG4gICAgXCLjgZnjgo/jgotcIixcbiAgICBcIuOBmeOCk+OBm+OCmeOCk1wiLFxuICAgIFwi44GZ44KT44G744Ka44GGXCIsXG4gICAgXCLjgZvjgYLjgbXjgpnjgolcIixcbiAgICBcIuOBm+OBhOOBi+OBpFwiLFxuICAgIFwi44Gb44GE44GR44KZ44KTXCIsXG4gICAgXCLjgZvjgYTjgZfjgplcIixcbiAgICBcIuOBm+OBhOOCiOOBhlwiLFxuICAgIFwi44Gb44GK44GGXCIsXG4gICAgXCLjgZvjgYvjgYTjgYvjgpNcIixcbiAgICBcIuOBm+OBjeOBq+OCk1wiLFxuICAgIFwi44Gb44GN44KAXCIsXG4gICAgXCLjgZvjgY3jgoZcIixcbiAgICBcIuOBm+OBjeOCieOCk+OBhuOCk1wiLFxuICAgIFwi44Gb44GR44KTXCIsXG4gICAgXCLjgZvjgZPjgYZcIixcbiAgICBcIuOBm+OBmeOBl+OCmVwiLFxuICAgIFwi44Gb44Gf44GEXCIsXG4gICAgXCLjgZvjgZ/jgZFcIixcbiAgICBcIuOBm+OBo+OBi+OBj1wiLFxuICAgIFwi44Gb44Gj44GN44KD44GPXCIsXG4gICAgXCLjgZvjgpnjgaPjgY9cIixcbiAgICBcIuOBm+OBo+OBkeOCk1wiLFxuICAgIFwi44Gb44Gj44GT44GkXCIsXG4gICAgXCLjgZvjgaPjgZXjgZ/jgY/jgb5cIixcbiAgICBcIuOBm+OBpOOBneOCmeOBj1wiLFxuICAgIFwi44Gb44Gk44Gf44KZ44KTXCIsXG4gICAgXCLjgZvjgaTjgabjgpnjgpNcIixcbiAgICBcIuOBm+OBo+OBr+OCmuOCk1wiLFxuICAgIFwi44Gb44Gk44Gy44KZXCIsXG4gICAgXCLjgZvjgaTjgbXjgpnjgpNcIixcbiAgICBcIuOBm+OBpOOCgeOBhFwiLFxuICAgIFwi44Gb44Gk44KK44GkXCIsXG4gICAgXCLjgZvjgarjgYtcIixcbiAgICBcIuOBm+OBruOBsuOCmVwiLFxuICAgIFwi44Gb44Gv44Gv44KZXCIsXG4gICAgXCLjgZvjgbLjgpnjgo1cIixcbiAgICBcIuOBm+OBu+OCmeOBrVwiLFxuICAgIFwi44Gb44G+44GEXCIsXG4gICAgXCLjgZvjgb7jgotcIixcbiAgICBcIuOBm+OCgeOCi1wiLFxuICAgIFwi44Gb44KC44Gf44KMXCIsXG4gICAgXCLjgZvjgorjgbVcIixcbiAgICBcIuOBm+OCmeOCk+OBguOBj1wiLFxuICAgIFwi44Gb44KT44GEXCIsXG4gICAgXCLjgZvjgpPjgYjjgYRcIixcbiAgICBcIuOBm+OCk+OBi1wiLFxuICAgIFwi44Gb44KT44GN44KHXCIsXG4gICAgXCLjgZvjgpPjgY9cIixcbiAgICBcIuOBm+OCk+OBkeOCmeOCk1wiLFxuICAgIFwi44Gb44KZ44KT44GT44KZXCIsXG4gICAgXCLjgZvjgpPjgZXjgYRcIixcbiAgICBcIuOBm+OCk+OBl+OChVwiLFxuICAgIFwi44Gb44KT44GZ44GEXCIsXG4gICAgXCLjgZvjgpPjgZvjgYRcIixcbiAgICBcIuOBm+OCk+OBneOCmVwiLFxuICAgIFwi44Gb44KT44Gf44GPXCIsXG4gICAgXCLjgZvjgpPjgaHjgofjgYZcIixcbiAgICBcIuOBm+OCk+OBpuOBhFwiLFxuICAgIFwi44Gb44KT44Go44GGXCIsXG4gICAgXCLjgZvjgpPjgazjgY1cIixcbiAgICBcIuOBm+OCk+OBreOCk1wiLFxuICAgIFwi44Gb44KT44Gv44Ka44GEXCIsXG4gICAgXCLjgZvjgpnjgpPjgbXjgplcIixcbiAgICBcIuOBm+OCmeOCk+OBu+OCmuOBhlwiLFxuICAgIFwi44Gb44KT44KAXCIsXG4gICAgXCLjgZvjgpPjgoHjgpPjgZfjgpnjgodcIixcbiAgICBcIuOBm+OCk+OCguOCk1wiLFxuICAgIFwi44Gb44KT44KE44GPXCIsXG4gICAgXCLjgZvjgpPjgobjgYZcIixcbiAgICBcIuOBm+OCk+OCiOOBhlwiLFxuICAgIFwi44Gb44KZ44KT44KJXCIsXG4gICAgXCLjgZvjgpnjgpPjgorjgoPjgY9cIixcbiAgICBcIuOBm+OCk+OCjOOBhFwiLFxuICAgIFwi44Gb44KT44KNXCIsXG4gICAgXCLjgZ3jgYLjgY9cIixcbiAgICBcIuOBneOBhOOBqOOBkeOCmeOCi1wiLFxuICAgIFwi44Gd44GE44GtXCIsXG4gICAgXCLjgZ3jgYbjgYvjgpnjgpPjgY3jgofjgYZcIixcbiAgICBcIuOBneOBhuOBjVwiLFxuICAgIFwi44Gd44GG44GT44KZXCIsXG4gICAgXCLjgZ3jgYbjgZfjgpNcIixcbiAgICBcIuOBneOBhuOBn+OCmeOCk1wiLFxuICAgIFwi44Gd44GG44Gq44KTXCIsXG4gICAgXCLjgZ3jgYbjgbLjgplcIixcbiAgICBcIuOBneOBhuOCgeOCk1wiLFxuICAgIFwi44Gd44GG44KKXCIsXG4gICAgXCLjgZ3jgYjjgoLjga5cIixcbiAgICBcIuOBneOBiOOCk1wiLFxuICAgIFwi44Gd44GL44KZ44GEXCIsXG4gICAgXCLjgZ3jgZHjgpnjgY1cIixcbiAgICBcIuOBneOBk+OBhlwiLFxuICAgIFwi44Gd44GT44Gd44GTXCIsXG4gICAgXCLjgZ3jgZXjgpnjgYRcIixcbiAgICBcIuOBneOBl+OBqlwiLFxuICAgIFwi44Gd44Gb44GEXCIsXG4gICAgXCLjgZ3jgZvjgpNcIixcbiAgICBcIuOBneOBneOBj+OCmVwiLFxuICAgIFwi44Gd44Gf44KZ44Gm44KLXCIsXG4gICAgXCLjgZ3jgaTjgYZcIixcbiAgICBcIuOBneOBpOOBiOOCk1wiLFxuICAgIFwi44Gd44Gj44GL44KTXCIsXG4gICAgXCLjgZ3jgaTjgY3jgpnjgofjgYZcIixcbiAgICBcIuOBneOBo+OBkeOBpFwiLFxuICAgIFwi44Gd44Gj44GT44GGXCIsXG4gICAgXCLjgZ3jgaPjgZvjgpNcIixcbiAgICBcIuOBneOBo+OBqFwiLFxuICAgIFwi44Gd44Go44GL44KZ44KPXCIsXG4gICAgXCLjgZ3jgajjgaTjgpnjgolcIixcbiAgICBcIuOBneOBquOBiOOCi1wiLFxuICAgIFwi44Gd44Gq44GfXCIsXG4gICAgXCLjgZ3jgbXjgbvjgplcIixcbiAgICBcIuOBneOBu+OCmeOBj1wiLFxuICAgIFwi44Gd44G744KZ44KNXCIsXG4gICAgXCLjgZ3jgb7jgaRcIixcbiAgICBcIuOBneOBvuOCi1wiLFxuICAgIFwi44Gd44KA44GPXCIsXG4gICAgXCLjgZ3jgoDjgorjgYhcIixcbiAgICBcIuOBneOCgeOCi1wiLFxuICAgIFwi44Gd44KC44Gd44KCXCIsXG4gICAgXCLjgZ3jgojjgYvjgZvjgplcIixcbiAgICBcIuOBneOCieOBvuOCgVwiLFxuICAgIFwi44Gd44KN44GGXCIsXG4gICAgXCLjgZ3jgpPjgYvjgYRcIixcbiAgICBcIuOBneOCk+OBkeOBhFwiLFxuICAgIFwi44Gd44KT44GV44KZ44GEXCIsXG4gICAgXCLjgZ3jgpPjgZfjgaRcIixcbiAgICBcIuOBneOCk+OBneOCmeOBj1wiLFxuICAgIFwi44Gd44KT44Gh44KH44GGXCIsXG4gICAgXCLjgZ3jgpnjgpPjgbLjgplcIixcbiAgICBcIuOBneOCmeOCk+OBteOCmeOCk1wiLFxuICAgIFwi44Gd44KT44G/44KTXCIsXG4gICAgXCLjgZ/jgYLjgYRcIixcbiAgICBcIuOBn+OBhOOBhOOCk1wiLFxuICAgIFwi44Gf44GE44GG44KTXCIsXG4gICAgXCLjgZ/jgYTjgYjjgY1cIixcbiAgICBcIuOBn+OBhOOBiuOBhlwiLFxuICAgIFwi44Gf44KZ44GE44GL44KZ44GPXCIsXG4gICAgXCLjgZ/jgYTjgY1cIixcbiAgICBcIuOBn+OBhOOBj+OCmeOBhlwiLFxuICAgIFwi44Gf44GE44GR44KTXCIsXG4gICAgXCLjgZ/jgYTjgZNcIixcbiAgICBcIuOBn+OBhOOBleOCmeOBhFwiLFxuICAgIFwi44Gf44KZ44GE44GX44KZ44KH44GG44G144KZXCIsXG4gICAgXCLjgZ/jgpnjgYTjgZnjgY1cIixcbiAgICBcIuOBn+OBhOOBm+OBpFwiLFxuICAgIFwi44Gf44GE44Gd44GGXCIsXG4gICAgXCLjgZ/jgpnjgYTjgZ/jgYRcIixcbiAgICBcIuOBn+OBhOOBoeOCh+OBhlwiLFxuICAgIFwi44Gf44GE44Gm44GEXCIsXG4gICAgXCLjgZ/jgpnjgYTjgajjgpnjgZPjgo1cIixcbiAgICBcIuOBn+OBhOOBquOBhFwiLFxuICAgIFwi44Gf44GE44Gt44GkXCIsXG4gICAgXCLjgZ/jgYTjga7jgYZcIixcbiAgICBcIuOBn+OBhOOBr+OCk1wiLFxuICAgIFwi44Gf44KZ44GE44Gy44KH44GGXCIsXG4gICAgXCLjgZ/jgYTjgbXjgYZcIixcbiAgICBcIuOBn+OBhOOBuOOCk1wiLFxuICAgIFwi44Gf44GE44G7XCIsXG4gICAgXCLjgZ/jgYTjgb7jgaTjga/jgpnjgapcIixcbiAgICBcIuOBn+OBhOOBv+OCk+OBj+OCmVwiLFxuICAgIFwi44Gf44GE44KAXCIsXG4gICAgXCLjgZ/jgYTjgoHjgpNcIixcbiAgICBcIuOBn+OBhOOChOOBjVwiLFxuICAgIFwi44Gf44GE44KI44GGXCIsXG4gICAgXCLjgZ/jgYTjgolcIixcbiAgICBcIuOBn+OBhOOCiuOCh+OBj1wiLFxuICAgIFwi44Gf44GE44KLXCIsXG4gICAgXCLjgZ/jgYTjgo/jgpNcIixcbiAgICBcIuOBn+OBhuOBiFwiLFxuICAgIFwi44Gf44GI44KLXCIsXG4gICAgXCLjgZ/jgYrjgZlcIixcbiAgICBcIuOBn+OBiuOCi1wiLFxuICAgIFwi44Gf44GK44KM44KLXCIsXG4gICAgXCLjgZ/jgYvjgYRcIixcbiAgICBcIuOBn+OBi+OBrVwiLFxuICAgIFwi44Gf44GN44Gy44KZXCIsXG4gICAgXCLjgZ/jgY/jgZXjgpNcIixcbiAgICBcIuOBn+OBk+OBj1wiLFxuICAgIFwi44Gf44GT44KE44GNXCIsXG4gICAgXCLjgZ/jgZXjgYRcIixcbiAgICBcIuOBn+OBl+OBleOCmeOCk1wiLFxuICAgIFwi44Gf44KZ44GX44KZ44KD44KMXCIsXG4gICAgXCLjgZ/jgZnjgZHjgotcIixcbiAgICBcIuOBn+OBmeOCmeOBleOCj+OCi1wiLFxuICAgIFwi44Gf44Gd44GL44KZ44KMXCIsXG4gICAgXCLjgZ/jgZ/jgYvjgYZcIixcbiAgICBcIuOBn+OBn+OBj1wiLFxuICAgIFwi44Gf44Gf44KZ44GX44GEXCIsXG4gICAgXCLjgZ/jgZ/jgb9cIixcbiAgICBcIuOBn+OBoeOBr+OCmeOBqlwiLFxuICAgIFwi44Gf44KZ44Gj44GL44GEXCIsXG4gICAgXCLjgZ/jgpnjgaPjgY3jgoPjgY9cIixcbiAgICBcIuOBn+OCmeOBo+OBk1wiLFxuICAgIFwi44Gf44KZ44Gj44GX44KF44GkXCIsXG4gICAgXCLjgZ/jgpnjgaPjgZ/jgYRcIixcbiAgICBcIuOBn+OBpuOCi1wiLFxuICAgIFwi44Gf44Go44GI44KLXCIsXG4gICAgXCLjgZ/jgarjga/jgpnjgZ9cIixcbiAgICBcIuOBn+OBq+OCk1wiLFxuICAgIFwi44Gf44Gs44GNXCIsXG4gICAgXCLjgZ/jga7jgZfjgb9cIixcbiAgICBcIuOBn+OBr+OBpFwiLFxuICAgIFwi44Gf44G144KZ44KTXCIsXG4gICAgXCLjgZ/jgbjjgpnjgotcIixcbiAgICBcIuOBn+OBu+OCmeOBhlwiLFxuICAgIFwi44Gf44G+44GT44KZXCIsXG4gICAgXCLjgZ/jgb7jgotcIixcbiAgICBcIuOBn+OCmeOCgOOCi1wiLFxuICAgIFwi44Gf44KB44GE44GNXCIsXG4gICAgXCLjgZ/jgoHjgZlcIixcbiAgICBcIuOBn+OCgeOCi1wiLFxuICAgIFwi44Gf44KC44GkXCIsXG4gICAgXCLjgZ/jgoTjgZnjgYRcIixcbiAgICBcIuOBn+OCiOOCi1wiLFxuICAgIFwi44Gf44KJ44GZXCIsXG4gICAgXCLjgZ/jgorjgY3jgbvjgpPjgYvjgpnjgpNcIixcbiAgICBcIuOBn+OCiuOCh+OBhlwiLFxuICAgIFwi44Gf44KK44KLXCIsXG4gICAgXCLjgZ/jgovjgahcIixcbiAgICBcIuOBn+OCjOOCi1wiLFxuICAgIFwi44Gf44KM44KT44GoXCIsXG4gICAgXCLjgZ/jgo3jgaPjgahcIixcbiAgICBcIuOBn+OCj+OCgOOCjOOCi1wiLFxuICAgIFwi44Gf44KZ44KT44GC44GkXCIsXG4gICAgXCLjgZ/jgpPjgYRcIixcbiAgICBcIuOBn+OCk+OBiuOCk1wiLFxuICAgIFwi44Gf44KT44GLXCIsXG4gICAgXCLjgZ/jgpPjgY1cIixcbiAgICBcIuOBn+OCk+OBkeOCk1wiLFxuICAgIFwi44Gf44KT44GT44KZXCIsXG4gICAgXCLjgZ/jgpPjgZXjgpNcIixcbiAgICBcIuOBn+OCk+OBl+OCmeOCh+OBhuOBsuOCmVwiLFxuICAgIFwi44Gf44KZ44KT44Gb44GEXCIsXG4gICAgXCLjgZ/jgpPjgZ3jgY9cIixcbiAgICBcIuOBn+OCk+OBn+OBhFwiLFxuICAgIFwi44Gf44KZ44KT44GhXCIsXG4gICAgXCLjgZ/jgpPjgabjgYRcIixcbiAgICBcIuOBn+OCk+OBqOOBhlwiLFxuICAgIFwi44Gf44KZ44KT44GqXCIsXG4gICAgXCLjgZ/jgpPjgavjgpNcIixcbiAgICBcIuOBn+OCmeOCk+OBreOBpFwiLFxuICAgIFwi44Gf44KT44Gu44GGXCIsXG4gICAgXCLjgZ/jgpPjgbLjgprjgpNcIixcbiAgICBcIuOBn+OCmeOCk+OBu+OCmeOBhlwiLFxuICAgIFwi44Gf44KT44G+44GkXCIsXG4gICAgXCLjgZ/jgpPjgoHjgYRcIixcbiAgICBcIuOBn+OCmeOCk+OCjOOBpFwiLFxuICAgIFwi44Gf44KZ44KT44KNXCIsXG4gICAgXCLjgZ/jgpnjgpPjgo9cIixcbiAgICBcIuOBoeOBguOBhFwiLFxuICAgIFwi44Gh44GC44KTXCIsXG4gICAgXCLjgaHjgYTjgY1cIixcbiAgICBcIuOBoeOBhOOBleOBhFwiLFxuICAgIFwi44Gh44GI44KTXCIsXG4gICAgXCLjgaHjgYvjgYRcIixcbiAgICBcIuOBoeOBi+OCiVwiLFxuICAgIFwi44Gh44GN44KF44GGXCIsXG4gICAgXCLjgaHjgY3jgpNcIixcbiAgICBcIuOBoeOBkeOBhOOBmeOCmVwiLFxuICAgIFwi44Gh44GR44KTXCIsXG4gICAgXCLjgaHjgZPjgY9cIixcbiAgICBcIuOBoeOBleOBhFwiLFxuICAgIFwi44Gh44GX44GNXCIsXG4gICAgXCLjgaHjgZfjgorjgofjgYZcIixcbiAgICBcIuOBoeOBm+OBhFwiLFxuICAgIFwi44Gh44Gd44GGXCIsXG4gICAgXCLjgaHjgZ/jgYRcIixcbiAgICBcIuOBoeOBn+OCk1wiLFxuICAgIFwi44Gh44Gh44GK44KEXCIsXG4gICAgXCLjgaHjgaTjgZfjgpnjgodcIixcbiAgICBcIuOBoeOBpuOBjVwiLFxuICAgIFwi44Gh44Gm44KTXCIsXG4gICAgXCLjgaHjgazjgY1cIixcbiAgICBcIuOBoeOBrOOCilwiLFxuICAgIFwi44Gh44Gu44GGXCIsXG4gICAgXCLjgaHjgbLjgofjgYZcIixcbiAgICBcIuOBoeOBuOOBhOOBm+OCk1wiLFxuICAgIFwi44Gh44G744GGXCIsXG4gICAgXCLjgaHjgb7jgZ9cIixcbiAgICBcIuOBoeOBv+OBpFwiLFxuICAgIFwi44Gh44G/44Go44KZ44KNXCIsXG4gICAgXCLjgaHjgoHjgYTjgajjgplcIixcbiAgICBcIuOBoeOCg+OCk+OBk+OBquOBuOOCmVwiLFxuICAgIFwi44Gh44KF44GG44GEXCIsXG4gICAgXCLjgaHjgobjgorjgofjgY9cIixcbiAgICBcIuOBoeOCh+OBhuOBl1wiLFxuICAgIFwi44Gh44KH44GV44GP44GR44KTXCIsXG4gICAgXCLjgaHjgonjgZdcIixcbiAgICBcIuOBoeOCieOBv1wiLFxuICAgIFwi44Gh44KK44GL44KZ44G/XCIsXG4gICAgXCLjgaHjgorjgofjgYZcIixcbiAgICBcIuOBoeOCi+OBqOOCmVwiLFxuICAgIFwi44Gh44KP44KPXCIsXG4gICAgXCLjgaHjgpPjgZ/jgYRcIixcbiAgICBcIuOBoeOCk+OCguOBj1wiLFxuICAgIFwi44Gk44GE44GLXCIsXG4gICAgXCLjgaTjgYTjgZ/jgaFcIixcbiAgICBcIuOBpOOBhuOBi1wiLFxuICAgIFwi44Gk44GG44GX44KZ44KH44GGXCIsXG4gICAgXCLjgaTjgYbjga/jgpNcIixcbiAgICBcIuOBpOOBhuOCj1wiLFxuICAgIFwi44Gk44GL44GGXCIsXG4gICAgXCLjgaTjgYvjgozjgotcIixcbiAgICBcIuOBpOOBj+OBrVwiLFxuICAgIFwi44Gk44GP44KLXCIsXG4gICAgXCLjgaTjgZHjga1cIixcbiAgICBcIuOBpOOBkeOCi1wiLFxuICAgIFwi44Gk44GT44KZ44GGXCIsXG4gICAgXCLjgaTjgZ/jgYjjgotcIixcbiAgICBcIuOBpOOBpOOCmeOBj1wiLFxuICAgIFwi44Gk44Gk44GX44KZXCIsXG4gICAgXCLjgaTjgaTjgoBcIixcbiAgICBcIuOBpOOBqOOCgeOCi1wiLFxuICAgIFwi44Gk44Gq44GL44KZ44KLXCIsXG4gICAgXCLjgaTjgarjgb9cIixcbiAgICBcIuOBpOOBreOBpOOCmeOBrVwiLFxuICAgIFwi44Gk44Gu44KLXCIsXG4gICAgXCLjgaTjgbXjgpnjgZlcIixcbiAgICBcIuOBpOOBvuOCieOBquOBhFwiLFxuICAgIFwi44Gk44G+44KLXCIsXG4gICAgXCLjgaTjgb/jgY1cIixcbiAgICBcIuOBpOOCgeOBn+OBhFwiLFxuICAgIFwi44Gk44KC44KKXCIsXG4gICAgXCLjgaTjgoLjgotcIixcbiAgICBcIuOBpOOCiOOBhFwiLFxuICAgIFwi44Gk44KL44G744KZXCIsXG4gICAgXCLjgaTjgovjgb/jgY9cIixcbiAgICBcIuOBpOOCj+OCguOBrlwiLFxuICAgIFwi44Gk44KP44KKXCIsXG4gICAgXCLjgabjgYLjgZdcIixcbiAgICBcIuOBpuOBguOBplwiLFxuICAgIFwi44Gm44GC44G/XCIsXG4gICAgXCLjgabjgYTjgYrjgpNcIixcbiAgICBcIuOBpuOBhOOBi1wiLFxuICAgIFwi44Gm44GE44GNXCIsXG4gICAgXCLjgabjgYTjgZHjgYRcIixcbiAgICBcIuOBpuOBhOOBk+OBj1wiLFxuICAgIFwi44Gm44GE44GV44GkXCIsXG4gICAgXCLjgabjgYTjgZdcIixcbiAgICBcIuOBpuOBhOOBm+OBhFwiLFxuICAgIFwi44Gm44GE44Gf44GEXCIsXG4gICAgXCLjgabjgYTjgajjgplcIixcbiAgICBcIuOBpuOBhOOBreOBhFwiLFxuICAgIFwi44Gm44GE44Gy44KH44GGXCIsXG4gICAgXCLjgabjgYTjgbjjgpNcIixcbiAgICBcIuOBpuOBhOOBu+OCmeOBhlwiLFxuICAgIFwi44Gm44GG44GhXCIsXG4gICAgXCLjgabjgYrjgY/jgoxcIixcbiAgICBcIuOBpuOBjeOBqOOBhlwiLFxuICAgIFwi44Gm44GP44Gy44KZXCIsXG4gICAgXCLjgabjgpnjgZPjgbvjgpnjgZNcIixcbiAgICBcIuOBpuOBleOBjeOCmeOCh+OBhlwiLFxuICAgIFwi44Gm44GV44GR44KZXCIsXG4gICAgXCLjgabjgZnjgopcIixcbiAgICBcIuOBpuOBneOBhlwiLFxuICAgIFwi44Gm44Gh44GL44KZ44GEXCIsXG4gICAgXCLjgabjgaHjgofjgYZcIixcbiAgICBcIuOBpuOBpOOBi+OCmeOBj1wiLFxuICAgIFwi44Gm44Gk44Gk44KZ44GNXCIsXG4gICAgXCLjgabjgpnjgaPjga/jgppcIixcbiAgICBcIuOBpuOBpOOBu+OCmeOBhlwiLFxuICAgIFwi44Gm44Gk44KEXCIsXG4gICAgXCLjgabjgpnjgazjgYvjgYhcIixcbiAgICBcIuOBpuOBrOOBjVwiLFxuICAgIFwi44Gm44Gs44GP44KZ44GEXCIsXG4gICAgXCLjgabjga7jgbLjgolcIixcbiAgICBcIuOBpuOBr+OBhFwiLFxuICAgIFwi44Gm44G144KZ44GP44KNXCIsXG4gICAgXCLjgabjgbXjgZ/jgplcIixcbiAgICBcIuOBpuOBu+OBqOOCmeOBjVwiLFxuICAgIFwi44Gm44G744KTXCIsXG4gICAgXCLjgabjgb7jgYhcIixcbiAgICBcIuOBpuOBvuOBjeOBmeOCmeOBl1wiLFxuICAgIFwi44Gm44G/44GX44KZ44GLXCIsXG4gICAgXCLjgabjgb/jgoTjgZHjgplcIixcbiAgICBcIuOBpuOCieOBmVwiLFxuICAgIFwi44Gm44KM44Gy44KZXCIsXG4gICAgXCLjgabjgo/jgZFcIixcbiAgICBcIuOBpuOCj+OBn+OBl1wiLFxuICAgIFwi44Gm44KZ44KT44GC44GkXCIsXG4gICAgXCLjgabjgpPjgYTjgpNcIixcbiAgICBcIuOBpuOCk+OBi+OBhFwiLFxuICAgIFwi44Gm44KT44GNXCIsXG4gICAgXCLjgabjgpPjgY/jgplcIixcbiAgICBcIuOBpuOCk+OBkeOCk1wiLFxuICAgIFwi44Gm44KT44GT44KZ44GPXCIsXG4gICAgXCLjgabjgpPjgZXjgYRcIixcbiAgICBcIuOBpuOCk+OBl1wiLFxuICAgIFwi44Gm44KT44GZ44GGXCIsXG4gICAgXCLjgabjgpnjgpPjgaFcIixcbiAgICBcIuOBpuOCk+OBpuOBjVwiLFxuICAgIFwi44Gm44KT44Go44GGXCIsXG4gICAgXCLjgabjgpPjgarjgYRcIixcbiAgICBcIuOBpuOCk+OBteOCmuOCiVwiLFxuICAgIFwi44Gm44KT44G744KZ44GG44Gf44KZ44GEXCIsXG4gICAgXCLjgabjgpPjgoHjgaRcIixcbiAgICBcIuOBpuOCk+OCieOCk+OBi+OBhFwiLFxuICAgIFwi44Gm44KZ44KT44KK44KH44GPXCIsXG4gICAgXCLjgabjgpnjgpPjgo9cIixcbiAgICBcIuOBqOOCmeOBguOBhFwiLFxuICAgIFwi44Go44GE44KMXCIsXG4gICAgXCLjgajjgpnjgYbjgYvjgpNcIixcbiAgICBcIuOBqOOBhuOBjeOCheOBhlwiLFxuICAgIFwi44Go44KZ44GG44GP44KZXCIsXG4gICAgXCLjgajjgYbjgZdcIixcbiAgICBcIuOBqOOBhuOCgOOBjeOCmVwiLFxuICAgIFwi44Go44GK44GEXCIsXG4gICAgXCLjgajjgYrjgYtcIixcbiAgICBcIuOBqOOBiuOBj1wiLFxuICAgIFwi44Go44GK44GZXCIsXG4gICAgXCLjgajjgYrjgotcIixcbiAgICBcIuOBqOOBi+OBhFwiLFxuICAgIFwi44Go44GL44GZXCIsXG4gICAgXCLjgajjgY3jgYrjgopcIixcbiAgICBcIuOBqOOBjeOBqOOCmeOBjVwiLFxuICAgIFwi44Go44GP44GEXCIsXG4gICAgXCLjgajjgY/jgZfjgoXjgYZcIixcbiAgICBcIuOBqOOBj+OBpuOCk1wiLFxuICAgIFwi44Go44GP44GrXCIsXG4gICAgXCLjgajjgY/jgbjjgpnjgaRcIixcbiAgICBcIuOBqOOBkeOBhFwiLFxuICAgIFwi44Go44GR44KLXCIsXG4gICAgXCLjgajjgZPjgoRcIixcbiAgICBcIuOBqOOBleOBi1wiLFxuICAgIFwi44Go44GX44KH44GL44KTXCIsXG4gICAgXCLjgajjgZ3jgYZcIixcbiAgICBcIuOBqOOBn+OCk1wiLFxuICAgIFwi44Go44Gh44KF44GGXCIsXG4gICAgXCLjgajjgaPjgY3jgoXjgYZcIixcbiAgICBcIuOBqOOBo+OBj+OCk1wiLFxuICAgIFwi44Go44Gk44Gb44KZ44KTXCIsXG4gICAgXCLjgajjgaTjgavjgoXjgYZcIixcbiAgICBcIuOBqOOBqOOCmeOBkeOCi1wiLFxuICAgIFwi44Go44Go44Gu44GI44KLXCIsXG4gICAgXCLjgajjgarjgYRcIixcbiAgICBcIuOBqOOBquOBiOOCi1wiLFxuICAgIFwi44Go44Gq44KKXCIsXG4gICAgXCLjgajjga7jgZXjgb5cIixcbiAgICBcIuOBqOOBr+OCmeOBmVwiLFxuICAgIFwi44Go44KZ44G144KZ44GL44KZ44KPXCIsXG4gICAgXCLjgajjgbvjgYZcIixcbiAgICBcIuOBqOOBvuOCi1wiLFxuICAgIFwi44Go44KB44KLXCIsXG4gICAgXCLjgajjgoLjgZ/jgpnjgaFcIixcbiAgICBcIuOBqOOCguOCi1wiLFxuICAgIFwi44Go44KZ44KI44GG44Gy44KZXCIsXG4gICAgXCLjgajjgonjgYjjgotcIixcbiAgICBcIuOBqOOCk+OBi+OBpFwiLFxuICAgIFwi44Go44KZ44KT44G144KZ44KKXCIsXG4gICAgXCLjgarjgYTjgYvjgY9cIixcbiAgICBcIuOBquOBhOOBk+OBhlwiLFxuICAgIFwi44Gq44GE44GX44KHXCIsXG4gICAgXCLjgarjgYTjgZlcIixcbiAgICBcIuOBquOBhOOBm+OCk1wiLFxuICAgIFwi44Gq44GE44Gd44GGXCIsXG4gICAgXCLjgarjgYrjgZlcIixcbiAgICBcIuOBquOBi+OCmeOBhFwiLFxuICAgIFwi44Gq44GP44GZXCIsXG4gICAgXCLjgarjgZHjgpnjgotcIixcbiAgICBcIuOBquOBk+OBhuOBqOOCmVwiLFxuICAgIFwi44Gq44GV44GRXCIsXG4gICAgXCLjgarjgZ/jgabjgpnjgZPjgZNcIixcbiAgICBcIuOBquOBo+OBqOOBhlwiLFxuICAgIFwi44Gq44Gk44KE44GZ44G/XCIsXG4gICAgXCLjgarjgarjgYrjgZdcIixcbiAgICBcIuOBquOBq+OBk+OCmeOBqFwiLFxuICAgIFwi44Gq44Gr44KC44GuXCIsXG4gICAgXCLjgarjgavjgo9cIixcbiAgICBcIuOBquOBruOBi1wiLFxuICAgIFwi44Gq44G144Gf44KZXCIsXG4gICAgXCLjgarjgb7jgYTjgY1cIixcbiAgICBcIuOBquOBvuOBiFwiLFxuICAgIFwi44Gq44G+44G/XCIsXG4gICAgXCLjgarjgb/jgZ/jgplcIixcbiAgICBcIuOBquOCgeOCieOBi1wiLFxuICAgIFwi44Gq44KB44KLXCIsXG4gICAgXCLjgarjgoTjgoBcIixcbiAgICBcIuOBquOCieOBhlwiLFxuICAgIFwi44Gq44KJ44Gy44KZXCIsXG4gICAgXCLjgarjgonjgbXjgplcIixcbiAgICBcIuOBquOCjOOCi1wiLFxuICAgIFwi44Gq44KP44Go44Gy44KZXCIsXG4gICAgXCLjgarjgo/jga/jgpnjgopcIixcbiAgICBcIuOBq+OBguOBhlwiLFxuICAgIFwi44Gr44GE44GL44KZ44GfXCIsXG4gICAgXCLjgavjgYbjgZFcIixcbiAgICBcIuOBq+OBiuOBhFwiLFxuICAgIFwi44Gr44GL44GEXCIsXG4gICAgXCLjgavjgYvjgpnjgaZcIixcbiAgICBcIuOBq+OBjeOBsuOCmVwiLFxuICAgIFwi44Gr44GP44GX44G/XCIsXG4gICAgXCLjgavjgY/jgb7jgpNcIixcbiAgICBcIuOBq+OBkeOCmeOCi1wiLFxuICAgIFwi44Gr44GV44KT44GL44Gf44KT44GdXCIsXG4gICAgXCLjgavjgZfjgY1cIixcbiAgICBcIuOBq+OBm+OCguOBrlwiLFxuICAgIFwi44Gr44Gh44GX44KZ44KH44GGXCIsXG4gICAgXCLjgavjgaHjgojjgYbjgbLjgplcIixcbiAgICBcIuOBq+OBo+OBi1wiLFxuICAgIFwi44Gr44Gj44GNXCIsXG4gICAgXCLjgavjgaPjgZHjgYRcIixcbiAgICBcIuOBq+OBo+OBk+OBhlwiLFxuICAgIFwi44Gr44Gj44GV44KTXCIsXG4gICAgXCLjgavjgaPjgZfjgofjgY9cIixcbiAgICBcIuOBq+OBo+OBmeOBhlwiLFxuICAgIFwi44Gr44Gj44Gb44GNXCIsXG4gICAgXCLjgavjgaPjgabjgYRcIixcbiAgICBcIuOBq+OBquOBhlwiLFxuICAgIFwi44Gr44G744KTXCIsXG4gICAgXCLjgavjgb7jgoFcIixcbiAgICBcIuOBq+OCguOBpFwiLFxuICAgIFwi44Gr44KE44KKXCIsXG4gICAgXCLjgavjgoXjgYbjgYTjgpNcIixcbiAgICBcIuOBq+OCiuOCk+OBl+OCg1wiLFxuICAgIFwi44Gr44KP44Go44KKXCIsXG4gICAgXCLjgavjgpPjgYRcIixcbiAgICBcIuOBq+OCk+OBi1wiLFxuICAgIFwi44Gr44KT44GNXCIsXG4gICAgXCLjgavjgpPjgZHjgpnjgpNcIixcbiAgICBcIuOBq+OCk+OBl+OBjVwiLFxuICAgIFwi44Gr44KT44GZ44KZ44GGXCIsXG4gICAgXCLjgavjgpPjgZ3jgYZcIixcbiAgICBcIuOBq+OCk+OBn+OBhFwiLFxuICAgIFwi44Gr44KT44GhXCIsXG4gICAgXCLjgavjgpPjgabjgYRcIixcbiAgICBcIuOBq+OCk+OBq+OBj1wiLFxuICAgIFwi44Gr44KT44G144KaXCIsXG4gICAgXCLjgavjgpPjgb7jgopcIixcbiAgICBcIuOBq+OCk+OCgFwiLFxuICAgIFwi44Gr44KT44KB44GEXCIsXG4gICAgXCLjgavjgpPjgojjgYZcIixcbiAgICBcIuOBrOOBhOOBj+OBjeOCmVwiLFxuICAgIFwi44Gs44GL44GZXCIsXG4gICAgXCLjgazjgY/jgpnjgYTjgajjgotcIixcbiAgICBcIuOBrOOBj+OCmeOBhlwiLFxuICAgIFwi44Gs44GP44KC44KKXCIsXG4gICAgXCLjgazjgZnjgoBcIixcbiAgICBcIuOBrOOBvuOBiOOBsuOCmVwiLFxuICAgIFwi44Gs44KB44KKXCIsXG4gICAgXCLjgazjgonjgZlcIixcbiAgICBcIuOBrOOCk+OBoeOCg+OBj1wiLFxuICAgIFwi44Gt44GC44GR44KZXCIsXG4gICAgXCLjga3jgYTjgY1cIixcbiAgICBcIuOBreOBhOOCi1wiLFxuICAgIFwi44Gt44GE44KNXCIsXG4gICAgXCLjga3jgY/jgpnjgZtcIixcbiAgICBcIuOBreOBj+OBn+OBhFwiLFxuICAgIFwi44Gt44GP44KJXCIsXG4gICAgXCLjga3jgZPjgZvjgplcIixcbiAgICBcIuOBreOBk+OCgFwiLFxuICAgIFwi44Gt44GV44GR44KZXCIsXG4gICAgXCLjga3jgZnjgZPjgpnjgZlcIixcbiAgICBcIuOBreOBneOBuOOCmeOCi1wiLFxuICAgIFwi44Gt44Gf44KZ44KTXCIsXG4gICAgXCLjga3jgaTjgYRcIixcbiAgICBcIuOBreOBo+OBl+OCk1wiLFxuICAgIFwi44Gt44Gk44Gd44KZ44GGXCIsXG4gICAgXCLjga3jgaPjgZ/jgYTjgY3jgpnjgodcIixcbiAgICBcIuOBreOBteOCmeOBneOBj1wiLFxuICAgIFwi44Gt44G144Gf44KZXCIsXG4gICAgXCLjga3jgbvjgpnjgYZcIixcbiAgICBcIuOBreOBu+OCiuOBr+OBu+OCilwiLFxuICAgIFwi44Gt44G+44GNXCIsXG4gICAgXCLjga3jgb7jgo/jgZdcIixcbiAgICBcIuOBreOBv+OBv1wiLFxuICAgIFwi44Gt44KA44GEXCIsXG4gICAgXCLjga3jgoDjgZ/jgYRcIixcbiAgICBcIuOBreOCguOBqFwiLFxuICAgIFwi44Gt44KJ44GGXCIsXG4gICAgXCLjga3jgo/jgZXjgplcIixcbiAgICBcIuOBreOCk+OBhOOCilwiLFxuICAgIFwi44Gt44KT44GK44GXXCIsXG4gICAgXCLjga3jgpPjgYvjgpNcIixcbiAgICBcIuOBreOCk+OBjeOCk1wiLFxuICAgIFwi44Gt44KT44GP44KZXCIsXG4gICAgXCLjga3jgpPjgZXjgplcIixcbiAgICBcIuOBreOCk+OBl1wiLFxuICAgIFwi44Gt44KT44Gh44KD44GPXCIsXG4gICAgXCLjga3jgpPjgajjgplcIixcbiAgICBcIuOBreOCk+OBsuOCmlwiLFxuICAgIFwi44Gt44KT44G144KZ44GkXCIsXG4gICAgXCLjga3jgpPjgb7jgaRcIixcbiAgICBcIuOBreOCk+OCiuOCh+OBhlwiLFxuICAgIFwi44Gt44KT44KM44GEXCIsXG4gICAgXCLjga7jgYTjgZnjgplcIixcbiAgICBcIuOBruOBiuOBpOOCmeOBvlwiLFxuICAgIFwi44Gu44GL44KZ44GZXCIsXG4gICAgXCLjga7jgY3jgarjgb9cIixcbiAgICBcIuOBruOBk+OBjeOCmeOCilwiLFxuICAgIFwi44Gu44GT44GZXCIsXG4gICAgXCLjga7jgZPjgotcIixcbiAgICBcIuOBruOBm+OCi1wiLFxuICAgIFwi44Gu44Gd44KZ44GPXCIsXG4gICAgXCLjga7jgZ3jgpnjgoBcIixcbiAgICBcIuOBruOBn+OBvuOBhlwiLFxuICAgIFwi44Gu44Gh44G744Go44KZXCIsXG4gICAgXCLjga7jgaPjgY9cIixcbiAgICBcIuOBruOBr+OCmeOBmVwiLFxuICAgIFwi44Gu44Gv44KJXCIsXG4gICAgXCLjga7jgbjjgpnjgotcIixcbiAgICBcIuOBruOBu+OCmeOCi1wiLFxuICAgIFwi44Gu44G/44KC44GuXCIsXG4gICAgXCLjga7jgoTjgb5cIixcbiAgICBcIuOBruOCieOBhOOBrFwiLFxuICAgIFwi44Gu44KJ44Gt44GTXCIsXG4gICAgXCLjga7jgorjgoLjga5cIixcbiAgICBcIuOBruOCiuOChuOBjVwiLFxuICAgIFwi44Gu44KM44KTXCIsXG4gICAgXCLjga7jgpPjgY1cIixcbiAgICBcIuOBr+OCmeOBguOBhFwiLFxuICAgIFwi44Gv44GC44GPXCIsXG4gICAgXCLjga/jgpnjgYLjgZXjgpNcIixcbiAgICBcIuOBr+OCmeOBhOOBi1wiLFxuICAgIFwi44Gv44KZ44GE44GPXCIsXG4gICAgXCLjga/jgYTjgZHjgpNcIixcbiAgICBcIuOBr+OBhOOBk+OCmVwiLFxuICAgIFwi44Gv44GE44GX44KTXCIsXG4gICAgXCLjga/jgYTjgZnjgYRcIixcbiAgICBcIuOBr+OBhOOBm+OCk1wiLFxuICAgIFwi44Gv44GE44Gd44GGXCIsXG4gICAgXCLjga/jgYTjgaFcIixcbiAgICBcIuOBr+OCmeOBhOOBr+OCmeOBhFwiLFxuICAgIFwi44Gv44GE44KM44GkXCIsXG4gICAgXCLjga/jgYjjgotcIixcbiAgICBcIuOBr+OBiuOCi1wiLFxuICAgIFwi44Gv44GL44GEXCIsXG4gICAgXCLjga/jgpnjgYvjgopcIixcbiAgICBcIuOBr+OBi+OCi1wiLFxuICAgIFwi44Gv44GP44GX44KFXCIsXG4gICAgXCLjga/jgZHjgpNcIixcbiAgICBcIuOBr+OBk+OBteOCmVwiLFxuICAgIFwi44Gv44GV44G/XCIsXG4gICAgXCLjga/jgZXjgpNcIixcbiAgICBcIuOBr+OBl+OBk+OCmVwiLFxuICAgIFwi44Gv44KZ44GX44KHXCIsXG4gICAgXCLjga/jgZfjgotcIixcbiAgICBcIuOBr+OBm+OCi1wiLFxuICAgIFwi44Gv44Ka44Gd44GT44KTXCIsXG4gICAgXCLjga/jgZ3jgpNcIixcbiAgICBcIuOBr+OBn+OCk1wiLFxuICAgIFwi44Gv44Gh44G/44GkXCIsXG4gICAgXCLjga/jgaTjgYrjgpNcIixcbiAgICBcIuOBr+OBo+OBi+OBj1wiLFxuICAgIFwi44Gv44Gk44KZ44GNXCIsXG4gICAgXCLjga/jgaPjgY3jgopcIixcbiAgICBcIuOBr+OBo+OBj+OBpFwiLFxuICAgIFwi44Gv44Gj44GR44KTXCIsXG4gICAgXCLjga/jgaPjgZPjgYZcIixcbiAgICBcIuOBr+OBo+OBleOCk1wiLFxuICAgIFwi44Gv44Gj44GX44KTXCIsXG4gICAgXCLjga/jgaPjgZ/jgaRcIixcbiAgICBcIuOBr+OBo+OBoeOCheOBhlwiLFxuICAgIFwi44Gv44Gj44Gm44KTXCIsXG4gICAgXCLjga/jgaPjgbLjgprjgofjgYZcIixcbiAgICBcIuOBr+OBo+OBu+OCmuOBhlwiLFxuICAgIFwi44Gv44Gq44GZXCIsXG4gICAgXCLjga/jgarjgbLjgplcIixcbiAgICBcIuOBr+OBq+OBi+OCgFwiLFxuICAgIFwi44Gv44G144KZ44KJ44GXXCIsXG4gICAgXCLjga/jgb/jgYvjgpnjgY1cIixcbiAgICBcIuOBr+OCgOOBi+OBhlwiLFxuICAgIFwi44Gv44KB44GkXCIsXG4gICAgXCLjga/jgoTjgYRcIixcbiAgICBcIuOBr+OChOOBl1wiLFxuICAgIFwi44Gv44KJ44GGXCIsXG4gICAgXCLjga/jgo3jgYbjgYPjgpNcIixcbiAgICBcIuOBr+OCj+OBhFwiLFxuICAgIFwi44Gv44KT44GEXCIsXG4gICAgXCLjga/jgpPjgYjjgYRcIixcbiAgICBcIuOBr+OCk+OBiuOCk1wiLFxuICAgIFwi44Gv44KT44GL44GPXCIsXG4gICAgXCLjga/jgpPjgY3jgofjgYZcIixcbiAgICBcIuOBr+OCmeOCk+OBj+OCmeOBv1wiLFxuICAgIFwi44Gv44KT44GTXCIsXG4gICAgXCLjga/jgpPjgZfjgoNcIixcbiAgICBcIuOBr+OCk+OBmeOBhlwiLFxuICAgIFwi44Gv44KT44Gf44KZ44KTXCIsXG4gICAgXCLjga/jgprjgpPjgaFcIixcbiAgICBcIuOBr+OCmuOCk+OBpFwiLFxuICAgIFwi44Gv44KT44Gm44GEXCIsXG4gICAgXCLjga/jgpPjgajjgZdcIixcbiAgICBcIuOBr+OCk+OBruOBhlwiLFxuICAgIFwi44Gv44KT44Gv44KaXCIsXG4gICAgXCLjga/jgpPjgbXjgpnjgpNcIixcbiAgICBcIuOBr+OCk+OBuOOCmuOCk1wiLFxuICAgIFwi44Gv44KT44G744KZ44GG44GNXCIsXG4gICAgXCLjga/jgpPjgoHjgYRcIixcbiAgICBcIuOBr+OCk+OCieOCk1wiLFxuICAgIFwi44Gv44KT44KN44KTXCIsXG4gICAgXCLjgbLjgYTjgY1cIixcbiAgICBcIuOBsuOBhuOCk1wiLFxuICAgIFwi44Gy44GI44KLXCIsXG4gICAgXCLjgbLjgYvjgY9cIixcbiAgICBcIuOBsuOBi+OCilwiLFxuICAgIFwi44Gy44GL44KLXCIsXG4gICAgXCLjgbLjgYvjgpNcIixcbiAgICBcIuOBsuOBj+OBhFwiLFxuICAgIFwi44Gy44GR44GkXCIsXG4gICAgXCLjgbLjgZPjgYbjgY1cIixcbiAgICBcIuOBsuOBk+OBj1wiLFxuICAgIFwi44Gy44GV44GEXCIsXG4gICAgXCLjgbLjgZXjgZfjgbXjgpnjgopcIixcbiAgICBcIuOBsuOBleOCk1wiLFxuICAgIFwi44Gy44KZ44GX44KZ44KF44Gk44GL44KTXCIsXG4gICAgXCLjgbLjgZfjgodcIixcbiAgICBcIuOBsuOBneOBi1wiLFxuICAgIFwi44Gy44Gd44KAXCIsXG4gICAgXCLjgbLjgZ/jgoDjgY1cIixcbiAgICBcIuOBsuOBn+OCmeOCilwiLFxuICAgIFwi44Gy44Gf44KLXCIsXG4gICAgXCLjgbLjgaTjgY3jgplcIixcbiAgICBcIuOBsuOBo+OBk+OBl1wiLFxuICAgIFwi44Gy44Gj44GXXCIsXG4gICAgXCLjgbLjgaTjgZfjgpnjgoXjgbLjgpNcIixcbiAgICBcIuOBsuOBo+OBmVwiLFxuICAgIFwi44Gy44Gk44Gb44KZ44KTXCIsXG4gICAgXCLjgbLjgprjgaPjgZ/jgopcIixcbiAgICBcIuOBsuOCmuOBo+OBoeOCilwiLFxuICAgIFwi44Gy44Gk44KI44GGXCIsXG4gICAgXCLjgbLjgabjgYRcIixcbiAgICBcIuOBsuOBqOOBk+OCmeOBv1wiLFxuICAgIFwi44Gy44Gq44G+44Gk44KKXCIsXG4gICAgXCLjgbLjgarjgpNcIixcbiAgICBcIuOBsuOBreOCi1wiLFxuICAgIFwi44Gy44Gv44KTXCIsXG4gICAgXCLjgbLjgbLjgpnjgY9cIixcbiAgICBcIuOBsuOBsuOCh+OBhlwiLFxuICAgIFwi44Gy44G744GGXCIsXG4gICAgXCLjgbLjgb7jgo/jgopcIixcbiAgICBcIuOBsuOBvuOCk1wiLFxuICAgIFwi44Gy44G/44GkXCIsXG4gICAgXCLjgbLjgoHjgYRcIixcbiAgICBcIuOBsuOCgeOBl+OCmeOBl1wiLFxuICAgIFwi44Gy44KE44GRXCIsXG4gICAgXCLjgbLjgoTjgZlcIixcbiAgICBcIuOBsuOCiOOBhlwiLFxuICAgIFwi44Gy44KZ44KH44GG44GNXCIsXG4gICAgXCLjgbLjgonjgYvjgpnjgapcIixcbiAgICBcIuOBsuOCieOBj1wiLFxuICAgIFwi44Gy44KK44GkXCIsXG4gICAgXCLjgbLjgorjgofjgYZcIixcbiAgICBcIuOBsuOCi+OBvlwiLFxuICAgIFwi44Gy44KL44KE44GZ44G/XCIsXG4gICAgXCLjgbLjgozjgYRcIixcbiAgICBcIuOBsuOCjeOBhFwiLFxuICAgIFwi44Gy44KN44GGXCIsXG4gICAgXCLjgbLjgo3jgY1cIixcbiAgICBcIuOBsuOCjeOChuOBjVwiLFxuICAgIFwi44Gy44KT44GL44GPXCIsXG4gICAgXCLjgbLjgpPjgZHjgaRcIixcbiAgICBcIuOBsuOCk+OBk+OCk1wiLFxuICAgIFwi44Gy44KT44GX44KFXCIsXG4gICAgXCLjgbLjgpPjgZ3jgYZcIixcbiAgICBcIuOBsuOCmuOCk+OBoVwiLFxuICAgIFwi44Gy44KT44Gv44Ka44KTXCIsXG4gICAgXCLjgbLjgpnjgpPjgbvjgpnjgYZcIixcbiAgICBcIuOBteOBguOCk1wiLFxuICAgIFwi44G144GE44GG44GhXCIsXG4gICAgXCLjgbXjgYbjgZHjgYRcIixcbiAgICBcIuOBteOBhuOBm+OCk1wiLFxuICAgIFwi44G144Ka44GG44Gf44KN44GGXCIsXG4gICAgXCLjgbXjgYbjgajjgYZcIixcbiAgICBcIuOBteOBhuOBtVwiLFxuICAgIFwi44G144GI44KLXCIsXG4gICAgXCLjgbXjgYrjgpNcIixcbiAgICBcIuOBteOBi+OBhFwiLFxuICAgIFwi44G144GN44KTXCIsXG4gICAgXCLjgbXjgY/jgZXjgpnjgaRcIixcbiAgICBcIuOBteOBj+OBteOCmeOBj+OCjVwiLFxuICAgIFwi44G144GT44GGXCIsXG4gICAgXCLjgbXjgZXjgYRcIixcbiAgICBcIuOBteOBl+OBjeOCmVwiLFxuICAgIFwi44G144GX44KZ44G/XCIsXG4gICAgXCLjgbXjgZnjgb5cIixcbiAgICBcIuOBteOBm+OBhFwiLFxuICAgIFwi44G144Gb44GP44KZXCIsXG4gICAgXCLjgbXjgZ3jgY9cIixcbiAgICBcIuOBteOCmeOBn+OBq+OBj1wiLFxuICAgIFwi44G144Gf44KTXCIsXG4gICAgXCLjgbXjgaHjgofjgYZcIixcbiAgICBcIuOBteOBpOOBhlwiLFxuICAgIFwi44G144Gk44GLXCIsXG4gICAgXCLjgbXjgaPjgYvjgaRcIixcbiAgICBcIuOBteOBo+OBjVwiLFxuICAgIFwi44G144Gj44GT44GPXCIsXG4gICAgXCLjgbXjgpnjgajjgpnjgYZcIixcbiAgICBcIuOBteOBqOOCi1wiLFxuICAgIFwi44G144Go44KTXCIsXG4gICAgXCLjgbXjga7jgYZcIixcbiAgICBcIuOBteOBr+OBhFwiLFxuICAgIFwi44G144Gy44KH44GGXCIsXG4gICAgXCLjgbXjgbjjgpNcIixcbiAgICBcIuOBteOBvuOCk1wiLFxuICAgIFwi44G144G/44KTXCIsXG4gICAgXCLjgbXjgoHjgaRcIixcbiAgICBcIuOBteOCgeOCk1wiLFxuICAgIFwi44G144KI44GGXCIsXG4gICAgXCLjgbXjgorjgZNcIixcbiAgICBcIuOBteOCiuOCi1wiLFxuICAgIFwi44G144KL44GEXCIsXG4gICAgXCLjgbXjgpPjgYTjgY1cIixcbiAgICBcIuOBteOCmeOCk+OBi+OCmeOBj1wiLFxuICAgIFwi44G144KZ44KT44GP44KZXCIsXG4gICAgXCLjgbXjgpPjgZfjgaRcIixcbiAgICBcIuOBteOCmeOCk+OBm+OBjVwiLFxuICAgIFwi44G144KT44Gd44GGXCIsXG4gICAgXCLjgbXjgpnjgpPjgbvjgprjgYZcIixcbiAgICBcIuOBuOOBhOOBguOCk1wiLFxuICAgIFwi44G444GE44GK44KTXCIsXG4gICAgXCLjgbjjgYTjgYvjgpnjgYRcIixcbiAgICBcIuOBuOOBhOOBjVwiLFxuICAgIFwi44G444GE44GR44KZ44KTXCIsXG4gICAgXCLjgbjjgYTjgZPjgYZcIixcbiAgICBcIuOBuOOBhOOBlVwiLFxuICAgIFwi44G444GE44GX44KDXCIsXG4gICAgXCLjgbjjgYTjgZvjgaRcIixcbiAgICBcIuOBuOOBhOOBnVwiLFxuICAgIFwi44G444GE44Gf44GPXCIsXG4gICAgXCLjgbjjgYTjgabjgpNcIixcbiAgICBcIuOBuOOBhOOBreOBpFwiLFxuICAgIFwi44G444GE44KPXCIsXG4gICAgXCLjgbjjgY3jgYvjgplcIixcbiAgICBcIuOBuOOBk+OCgFwiLFxuICAgIFwi44G444KZ44Gr44GE44KNXCIsXG4gICAgXCLjgbjjgpnjgavjgZfjgofjgYbjgYvjgplcIixcbiAgICBcIuOBuOOCieOBmVwiLFxuICAgIFwi44G444KT44GL44KTXCIsXG4gICAgXCLjgbjjgpnjgpPjgY3jgofjgYZcIixcbiAgICBcIuOBuOOCmeOCk+OBk+OCmeOBl1wiLFxuICAgIFwi44G444KT44GV44GEXCIsXG4gICAgXCLjgbjjgpPjgZ/jgYRcIixcbiAgICBcIuOBuOOCmeOCk+OCilwiLFxuICAgIFwi44G744GC44KTXCIsXG4gICAgXCLjgbvjgYTjgY9cIixcbiAgICBcIuOBu+OCmeOBhuOBjeOCmeOCh1wiLFxuICAgIFwi44G744GG44GT44GPXCIsXG4gICAgXCLjgbvjgYbjgZ3jgYZcIixcbiAgICBcIuOBu+OBhuOBu+OBhlwiLFxuICAgIFwi44G744GG44KC44KTXCIsXG4gICAgXCLjgbvjgYbjgorjgaRcIixcbiAgICBcIuOBu+OBiOOCi1wiLFxuICAgIFwi44G744GK44KTXCIsXG4gICAgXCLjgbvjgYvjgpNcIixcbiAgICBcIuOBu+OBjeOCh+OBhlwiLFxuICAgIFwi44G744KZ44GN44KTXCIsXG4gICAgXCLjgbvjgY/jgo1cIixcbiAgICBcIuOBu+OBkeOBpFwiLFxuICAgIFwi44G744GR44KTXCIsXG4gICAgXCLjgbvjgZPjgYZcIixcbiAgICBcIuOBu+OBk+OCi1wiLFxuICAgIFwi44G744GX44GEXCIsXG4gICAgXCLjgbvjgZfjgaRcIixcbiAgICBcIuOBu+OBl+OChVwiLFxuICAgIFwi44G744GX44KH44GGXCIsXG4gICAgXCLjgbvjgZvjgYRcIixcbiAgICBcIuOBu+OBneOBhFwiLFxuICAgIFwi44G744Gd44GPXCIsXG4gICAgXCLjgbvjgZ/jgaZcIixcbiAgICBcIuOBu+OBn+OCi1wiLFxuICAgIFwi44G744Ka44Gh44G144KZ44GP44KNXCIsXG4gICAgXCLjgbvjgaPjgY3jgofjgY9cIixcbiAgICBcIuOBu+OBo+OBlVwiLFxuICAgIFwi44G744Gj44Gf44KTXCIsXG4gICAgXCLjgbvjgajjgpPjgajjgplcIixcbiAgICBcIuOBu+OCgeOCi1wiLFxuICAgIFwi44G744KT44GEXCIsXG4gICAgXCLjgbvjgpPjgY1cIixcbiAgICBcIuOBu+OCk+OBkVwiLFxuICAgIFwi44G744KT44GX44GkXCIsXG4gICAgXCLjgbvjgpPjgoTjgY9cIixcbiAgICBcIuOBvuOBhOOBq+OBoVwiLFxuICAgIFwi44G+44GL44GEXCIsXG4gICAgXCLjgb7jgYvjgZvjgotcIixcbiAgICBcIuOBvuOBi+OCmeOCi1wiLFxuICAgIFwi44G+44GR44KLXCIsXG4gICAgXCLjgb7jgZPjgahcIixcbiAgICBcIuOBvuOBleOBpFwiLFxuICAgIFwi44G+44GX44KZ44KBXCIsXG4gICAgXCLjgb7jgZnjgY9cIixcbiAgICBcIuOBvuOBm+OCmeOCi1wiLFxuICAgIFwi44G+44Gk44KKXCIsXG4gICAgXCLjgb7jgajjgoFcIixcbiAgICBcIuOBvuOBquOBteOCmVwiLFxuICAgIFwi44G+44Gs44GRXCIsXG4gICAgXCLjgb7jga3jgY9cIixcbiAgICBcIuOBvuOBu+OBhlwiLFxuICAgIFwi44G+44KC44KLXCIsXG4gICAgXCLjgb7jgobjgZHjgplcIixcbiAgICBcIuOBvuOCiOOBhlwiLFxuICAgIFwi44G+44KN44KE44GLXCIsXG4gICAgXCLjgb7jgo/jgZlcIixcbiAgICBcIuOBvuOCj+OCilwiLFxuICAgIFwi44G+44KP44KLXCIsXG4gICAgXCLjgb7jgpPjgYvjgplcIixcbiAgICBcIuOBvuOCk+OBjeOBpFwiLFxuICAgIFwi44G+44KT44Gd44KZ44GPXCIsXG4gICAgXCLjgb7jgpPjgarjgYtcIixcbiAgICBcIuOBv+OBhOOCiVwiLFxuICAgIFwi44G/44GG44GhXCIsXG4gICAgXCLjgb/jgYjjgotcIixcbiAgICBcIuOBv+OBi+OCmeOBj1wiLFxuICAgIFwi44G/44GL44GfXCIsXG4gICAgXCLjgb/jgYvjgpNcIixcbiAgICBcIuOBv+OBkeOCk1wiLFxuICAgIFwi44G/44GT44KTXCIsXG4gICAgXCLjgb/jgZfjgpnjgYvjgYRcIixcbiAgICBcIuOBv+OBmeOBhFwiLFxuICAgIFwi44G/44GZ44GI44KLXCIsXG4gICAgXCLjgb/jgZvjgotcIixcbiAgICBcIuOBv+OBo+OBi1wiLFxuICAgIFwi44G/44Gk44GL44KLXCIsXG4gICAgXCLjgb/jgaTjgZHjgotcIixcbiAgICBcIuOBv+OBpuOBhFwiLFxuICAgIFwi44G/44Go44KB44KLXCIsXG4gICAgXCLjgb/jgarjgahcIixcbiAgICBcIuOBv+OBquOBv+OBi+OBleOBhFwiLFxuICAgIFwi44G/44Gt44KJ44KLXCIsXG4gICAgXCLjgb/jga7jgYZcIixcbiAgICBcIuOBv+OBruOBi+OCmeOBmVwiLFxuICAgIFwi44G/44G744KTXCIsXG4gICAgXCLjgb/jgoLjgahcIixcbiAgICBcIuOBv+OChOOBkeOCmVwiLFxuICAgIFwi44G/44KJ44GEXCIsXG4gICAgXCLjgb/jgorjgofjgY9cIixcbiAgICBcIuOBv+OCj+OBj1wiLFxuICAgIFwi44G/44KT44GLXCIsXG4gICAgXCLjgb/jgpPjgZ3jgpnjgY9cIixcbiAgICBcIuOCgOOBhOOBi1wiLFxuICAgIFwi44KA44GI44GNXCIsXG4gICAgXCLjgoDjgYjjgpNcIixcbiAgICBcIuOCgOOBi+OBhFwiLFxuICAgIFwi44KA44GL44GGXCIsXG4gICAgXCLjgoDjgYvjgYhcIixcbiAgICBcIuOCgOOBi+OBl1wiLFxuICAgIFwi44KA44GN44KZ44Gh44KDXCIsXG4gICAgXCLjgoDjgZHjgotcIixcbiAgICBcIuOCgOOBkeOCmeOCk1wiLFxuICAgIFwi44KA44GV44G744KZ44KLXCIsXG4gICAgXCLjgoDjgZfjgYLjgaTjgYRcIixcbiAgICBcIuOCgOOBl+OBr+OCmVwiLFxuICAgIFwi44KA44GX44KZ44KF44KTXCIsXG4gICAgXCLjgoDjgZfjgo1cIixcbiAgICBcIuOCgOOBmeOBhlwiLFxuICAgIFwi44KA44GZ44GTXCIsXG4gICAgXCLjgoDjgZnjgbXjgplcIixcbiAgICBcIuOCgOOBmeOCgVwiLFxuICAgIFwi44KA44Gb44KLXCIsXG4gICAgXCLjgoDjgZvjgpNcIixcbiAgICBcIuOCgOOBoeOCheOBhlwiLFxuICAgIFwi44KA44Gq44GX44GEXCIsXG4gICAgXCLjgoDjga7jgYZcIixcbiAgICBcIuOCgOOChOOBv1wiLFxuICAgIFwi44KA44KI44GGXCIsXG4gICAgXCLjgoDjgonjgZXjgY1cIixcbiAgICBcIuOCgOOCiuOCh+OBhlwiLFxuICAgIFwi44KA44KN44KTXCIsXG4gICAgXCLjgoHjgYTjgYLjgpNcIixcbiAgICBcIuOCgeOBhOOBhuOCk1wiLFxuICAgIFwi44KB44GE44GI44KTXCIsXG4gICAgXCLjgoHjgYTjgYvjgY9cIixcbiAgICBcIuOCgeOBhOOBjeOCh+OBj1wiLFxuICAgIFwi44KB44GE44GV44GEXCIsXG4gICAgXCLjgoHjgYTjgZdcIixcbiAgICBcIuOCgeOBhOOBneOBhlwiLFxuICAgIFwi44KB44GE44G144KZ44GkXCIsXG4gICAgXCLjgoHjgYTjgozjgYRcIixcbiAgICBcIuOCgeOBhOOCj+OBj1wiLFxuICAgIFwi44KB44GP44KZ44G+44KM44KLXCIsXG4gICAgXCLjgoHjgZXjgpnjgZlcIixcbiAgICBcIuOCgeOBl+OBn1wiLFxuICAgIFwi44KB44GZ44KZ44KJ44GX44GEXCIsXG4gICAgXCLjgoHjgZ/jgpnjgaRcIixcbiAgICBcIuOCgeOBvuOBhFwiLFxuICAgIFwi44KB44KE44GZXCIsXG4gICAgXCLjgoHjgpPjgY3jgodcIixcbiAgICBcIuOCgeOCk+OBm+OBjVwiLFxuICAgIFwi44KB44KT44Go44KZ44GGXCIsXG4gICAgXCLjgoLjgYbjgZfjgYLjgZHjgpnjgotcIixcbiAgICBcIuOCguOBhuOBqOOCmeOBhuOBkeOCk1wiLFxuICAgIFwi44KC44GI44KLXCIsXG4gICAgXCLjgoLjgY/jgZdcIixcbiAgICBcIuOCguOBj+OBpuOBjVwiLFxuICAgIFwi44KC44GP44KI44GG44Gy44KZXCIsXG4gICAgXCLjgoLjgaHjgo3jgpNcIixcbiAgICBcIuOCguOBqOOCmeOCi1wiLFxuICAgIFwi44KC44KJ44GGXCIsXG4gICAgXCLjgoLjgpPjgY9cIixcbiAgICBcIuOCguOCk+OBn+OCmeOBhFwiLFxuICAgIFwi44KE44GK44KEXCIsXG4gICAgXCLjgoTjgZHjgotcIixcbiAgICBcIuOChOOBleOBhFwiLFxuICAgIFwi44KE44GV44GX44GEXCIsXG4gICAgXCLjgoTjgZnjgYRcIixcbiAgICBcIuOChOOBmeOBn+OCjeOBhlwiLFxuICAgIFwi44KE44GZ44G/XCIsXG4gICAgXCLjgoTjgZvjgotcIixcbiAgICBcIuOChOOBneOBhlwiLFxuICAgIFwi44KE44Gf44GEXCIsXG4gICAgXCLjgoTjgaHjgpNcIixcbiAgICBcIuOChOOBo+OBqFwiLFxuICAgIFwi44KE44Gj44Gv44Ka44KKXCIsXG4gICAgXCLjgoTjgbXjgpnjgotcIixcbiAgICBcIuOChOOCgeOCi1wiLFxuICAgIFwi44KE44KE44GT44GX44GEXCIsXG4gICAgXCLjgoTjgojjgYRcIixcbiAgICBcIuOChOOCj+OCieOBi+OBhFwiLFxuICAgIFwi44KG44GG44GNXCIsXG4gICAgXCLjgobjgYbjgbLjgpnjgpPjgY3jgofjgY9cIixcbiAgICBcIuOChuOBhuOBuOOCmVwiLFxuICAgIFwi44KG44GG44KB44GEXCIsXG4gICAgXCLjgobjgZHjgaRcIixcbiAgICBcIuOChuOBl+OCheOBpFwiLFxuICAgIFwi44KG44Gb44KTXCIsXG4gICAgXCLjgobjgZ3jgYZcIixcbiAgICBcIuOChuOBn+OBi1wiLFxuICAgIFwi44KG44Gh44KD44GPXCIsXG4gICAgXCLjgobjgabjgpnjgotcIixcbiAgICBcIuOChuOBq+OCheOBhlwiLFxuICAgIFwi44KG44Gy44KZ44KPXCIsXG4gICAgXCLjgobjgonjgYRcIixcbiAgICBcIuOChuOCjOOCi1wiLFxuICAgIFwi44KI44GG44GEXCIsXG4gICAgXCLjgojjgYbjgYtcIixcbiAgICBcIuOCiOOBhuOBjeOCheOBhlwiLFxuICAgIFwi44KI44GG44GX44KZXCIsXG4gICAgXCLjgojjgYbjgZlcIixcbiAgICBcIuOCiOOBhuOBoeOBiOOCk1wiLFxuICAgIFwi44KI44GL44Gb44KZXCIsXG4gICAgXCLjgojjgYvjgpNcIixcbiAgICBcIuOCiOOBjeOCk1wiLFxuICAgIFwi44KI44GP44Gb44GEXCIsXG4gICAgXCLjgojjgY/jgbvjgpnjgYZcIixcbiAgICBcIuOCiOOBkeOBhFwiLFxuICAgIFwi44KI44GT44KZ44KM44KLXCIsXG4gICAgXCLjgojjgZXjgpNcIixcbiAgICBcIuOCiOOBl+OCheOBhlwiLFxuICAgIFwi44KI44Gd44GGXCIsXG4gICAgXCLjgojjgZ3jgY9cIixcbiAgICBcIuOCiOOBo+OBi1wiLFxuICAgIFwi44KI44Gm44GEXCIsXG4gICAgXCLjgojjgajjgpnjgYvjgpnjgo/jgY9cIixcbiAgICBcIuOCiOOBreOBpFwiLFxuICAgIFwi44KI44KE44GPXCIsXG4gICAgXCLjgojjgobjgYZcIixcbiAgICBcIuOCiOOCjeOBk+OBteOCmVwiLFxuICAgIFwi44KI44KN44GX44GEXCIsXG4gICAgXCLjgonjgYTjgYZcIixcbiAgICBcIuOCieOBj+OBi+OCmeOBjVwiLFxuICAgIFwi44KJ44GP44GT44KZXCIsXG4gICAgXCLjgonjgY/jgZXjgaRcIixcbiAgICBcIuOCieOBj+OBn+OCmVwiLFxuICAgIFwi44KJ44GX44KT44Gv44KZ44KTXCIsXG4gICAgXCLjgonjgZvjgpNcIixcbiAgICBcIuOCieOBneOCmeOBj1wiLFxuICAgIFwi44KJ44Gf44GEXCIsXG4gICAgXCLjgonjgaPjgYtcIixcbiAgICBcIuOCieOCjOOBpFwiLFxuICAgIFwi44KK44GI44GNXCIsXG4gICAgXCLjgorjgYvjgYRcIixcbiAgICBcIuOCiuOBjeOBleOBj1wiLFxuICAgIFwi44KK44GN44Gb44GkXCIsXG4gICAgXCLjgorjgY/jgY/jgpnjgpNcIixcbiAgICBcIuOCiuOBj+OBpFwiLFxuICAgIFwi44KK44GR44KTXCIsXG4gICAgXCLjgorjgZPjgYZcIixcbiAgICBcIuOCiuOBm+OBhFwiLFxuICAgIFwi44KK44Gd44GGXCIsXG4gICAgXCLjgorjgZ3jgY9cIixcbiAgICBcIuOCiuOBpuOCk1wiLFxuICAgIFwi44KK44Gt44KTXCIsXG4gICAgXCLjgorjgobjgYZcIixcbiAgICBcIuOCiuOCheOBhuOBi+OCmeOBj1wiLFxuICAgIFwi44KK44KI44GGXCIsXG4gICAgXCLjgorjgofjgYbjgopcIixcbiAgICBcIuOCiuOCh+OBi+OCk1wiLFxuICAgIFwi44KK44KH44GP44Gh44KDXCIsXG4gICAgXCLjgorjgofjgZPjgYZcIixcbiAgICBcIuOCiuOCiuOBj1wiLFxuICAgIFwi44KK44KM44GNXCIsXG4gICAgXCLjgorjgo3jgpNcIixcbiAgICBcIuOCiuOCk+OBk+OCmVwiLFxuICAgIFwi44KL44GE44GR44GEXCIsXG4gICAgXCLjgovjgYTjgZXjgYRcIixcbiAgICBcIuOCi+OBhOOBl+OCmVwiLFxuICAgIFwi44KL44GE44Gb44GNXCIsXG4gICAgXCLjgovjgZnjga/jgpnjgpNcIixcbiAgICBcIuOCi+OCiuOBi+OCmeOCj+OCiVwiLFxuICAgIFwi44KM44GE44GL44KTXCIsXG4gICAgXCLjgozjgYTjgY3jgplcIixcbiAgICBcIuOCjOOBhOOBm+OBhFwiLFxuICAgIFwi44KM44GE44Gd44KZ44GG44GTXCIsXG4gICAgXCLjgozjgYTjgajjgYZcIixcbiAgICBcIuOCjOOBhOOBu+OCmeOBhlwiLFxuICAgIFwi44KM44GN44GXXCIsXG4gICAgXCLjgozjgY3jgZ/jgpnjgYRcIixcbiAgICBcIuOCjOOCk+OBguOBhFwiLFxuICAgIFwi44KM44KT44GR44GEXCIsXG4gICAgXCLjgozjgpPjgZPjgpNcIixcbiAgICBcIuOCjOOCk+OBleOBhFwiLFxuICAgIFwi44KM44KT44GX44KF44GGXCIsXG4gICAgXCLjgozjgpPjgZ3jgpnjgY9cIixcbiAgICBcIuOCjOOCk+OCieOBj1wiLFxuICAgIFwi44KN44GG44GLXCIsXG4gICAgXCLjgo3jgYbjgZPjgplcIixcbiAgICBcIuOCjeOBhuOBl+OCmeOCk1wiLFxuICAgIFwi44KN44GG44Gd44GPXCIsXG4gICAgXCLjgo3jgY/jgYvjgplcIixcbiAgICBcIuOCjeOBk+OBpFwiLFxuICAgIFwi44KN44GX44KZ44GG44KJXCIsXG4gICAgXCLjgo3jgZfjgoXjgaRcIixcbiAgICBcIuOCjeOBm+OCk1wiLFxuICAgIFwi44KN44Gm44KTXCIsXG4gICAgXCLjgo3jgoHjgpNcIixcbiAgICBcIuOCjeOCjOOBpFwiLFxuICAgIFwi44KN44KT44GN44KZXCIsXG4gICAgXCLjgo3jgpPjga/jgppcIixcbiAgICBcIuOCjeOCk+OBteOCmeOCk1wiLFxuICAgIFwi44KN44KT44KKXCIsXG4gICAgXCLjgo/jgYvjgZlcIixcbiAgICBcIuOCj+OBi+OCgVwiLFxuICAgIFwi44KP44GL44KE44G+XCIsXG4gICAgXCLjgo/jgYvjgozjgotcIixcbiAgICBcIuOCj+OBl+OBpFwiLFxuICAgIFwi44KP44GX44KZ44G+44GXXCIsXG4gICAgXCLjgo/jgZnjgozjgoLjga5cIixcbiAgICBcIuOCj+OCieOBhlwiLFxuICAgIFwi44KP44KM44KLXCJcbl1cbiIsIm1vZHVsZS5leHBvcnRzPVtcbiAgICBcIueahFwiLFxuICAgIFwi5LiAXCIsXG4gICAgXCLmmK9cIixcbiAgICBcIuWcqFwiLFxuICAgIFwi5LiNXCIsXG4gICAgXCLkuoZcIixcbiAgICBcIuaciVwiLFxuICAgIFwi5ZKMXCIsXG4gICAgXCLkurpcIixcbiAgICBcIumAmVwiLFxuICAgIFwi5LitXCIsXG4gICAgXCLlpKdcIixcbiAgICBcIueCulwiLFxuICAgIFwi5LiKXCIsXG4gICAgXCLlgItcIixcbiAgICBcIuWci1wiLFxuICAgIFwi5oiRXCIsXG4gICAgXCLku6VcIixcbiAgICBcIuimgVwiLFxuICAgIFwi5LuWXCIsXG4gICAgXCLmmYJcIixcbiAgICBcIuS+hlwiLFxuICAgIFwi55SoXCIsXG4gICAgXCLlgJFcIixcbiAgICBcIueUn1wiLFxuICAgIFwi5YiwXCIsXG4gICAgXCLkvZxcIixcbiAgICBcIuWcsFwiLFxuICAgIFwi5pa8XCIsXG4gICAgXCLlh7pcIixcbiAgICBcIuWwsVwiLFxuICAgIFwi5YiGXCIsXG4gICAgXCLlsI1cIixcbiAgICBcIuaIkFwiLFxuICAgIFwi5pyDXCIsXG4gICAgXCLlj69cIixcbiAgICBcIuS4u1wiLFxuICAgIFwi55m8XCIsXG4gICAgXCLlubRcIixcbiAgICBcIuWLlVwiLFxuICAgIFwi5ZCMXCIsXG4gICAgXCLlt6VcIixcbiAgICBcIuS5n1wiLFxuICAgIFwi6IO9XCIsXG4gICAgXCLkuItcIixcbiAgICBcIumBjlwiLFxuICAgIFwi5a2QXCIsXG4gICAgXCLoqqpcIixcbiAgICBcIueUolwiLFxuICAgIFwi56iuXCIsXG4gICAgXCLpnaJcIixcbiAgICBcIuiAjFwiLFxuICAgIFwi5pa5XCIsXG4gICAgXCLlvoxcIixcbiAgICBcIuWkmlwiLFxuICAgIFwi5a6aXCIsXG4gICAgXCLooYxcIixcbiAgICBcIuWtuFwiLFxuICAgIFwi5rOVXCIsXG4gICAgXCLmiYBcIixcbiAgICBcIuawkVwiLFxuICAgIFwi5b6XXCIsXG4gICAgXCLntpNcIixcbiAgICBcIuWNgVwiLFxuICAgIFwi5LiJXCIsXG4gICAgXCLkuYtcIixcbiAgICBcIumAslwiLFxuICAgIFwi6JGXXCIsXG4gICAgXCLnrYlcIixcbiAgICBcIumDqFwiLFxuICAgIFwi5bqmXCIsXG4gICAgXCLlrrZcIixcbiAgICBcIumbu1wiLFxuICAgIFwi5YqbXCIsXG4gICAgXCLoo6FcIixcbiAgICBcIuWmglwiLFxuICAgIFwi5rC0XCIsXG4gICAgXCLljJZcIixcbiAgICBcIumrmFwiLFxuICAgIFwi6IeqXCIsXG4gICAgXCLkuoxcIixcbiAgICBcIueQhlwiLFxuICAgIFwi6LW3XCIsXG4gICAgXCLlsI9cIixcbiAgICBcIueJqVwiLFxuICAgIFwi54++XCIsXG4gICAgXCLlr6ZcIixcbiAgICBcIuWKoFwiLFxuICAgIFwi6YePXCIsXG4gICAgXCLpg71cIixcbiAgICBcIuWFqVwiLFxuICAgIFwi6auUXCIsXG4gICAgXCLliLZcIixcbiAgICBcIuapn1wiLFxuICAgIFwi55W2XCIsXG4gICAgXCLkvb9cIixcbiAgICBcIum7nlwiLFxuICAgIFwi5b6eXCIsXG4gICAgXCLmpa1cIixcbiAgICBcIuacrFwiLFxuICAgIFwi5Y67XCIsXG4gICAgXCLmiopcIixcbiAgICBcIuaAp1wiLFxuICAgIFwi5aW9XCIsXG4gICAgXCLmh4lcIixcbiAgICBcIumWi1wiLFxuICAgIFwi5a6DXCIsXG4gICAgXCLlkIhcIixcbiAgICBcIumChFwiLFxuICAgIFwi5ZugXCIsXG4gICAgXCLnlLFcIixcbiAgICBcIuWFtlwiLFxuICAgIFwi5LqbXCIsXG4gICAgXCLnhLZcIixcbiAgICBcIuWJjVwiLFxuICAgIFwi5aSWXCIsXG4gICAgXCLlpKlcIixcbiAgICBcIuaUv1wiLFxuICAgIFwi5ZubXCIsXG4gICAgXCLml6VcIixcbiAgICBcIumCo1wiLFxuICAgIFwi56S+XCIsXG4gICAgXCLnvqlcIixcbiAgICBcIuS6i1wiLFxuICAgIFwi5bmzXCIsXG4gICAgXCLlvaJcIixcbiAgICBcIuebuFwiLFxuICAgIFwi5YWoXCIsXG4gICAgXCLooahcIixcbiAgICBcIumWk1wiLFxuICAgIFwi5qijXCIsXG4gICAgXCLoiIdcIixcbiAgICBcIumXnFwiLFxuICAgIFwi5ZCEXCIsXG4gICAgXCLph41cIixcbiAgICBcIuaWsFwiLFxuICAgIFwi57eaXCIsXG4gICAgXCLlhadcIixcbiAgICBcIuaVuFwiLFxuICAgIFwi5q2jXCIsXG4gICAgXCLlv4NcIixcbiAgICBcIuWPjVwiLFxuICAgIFwi5L2gXCIsXG4gICAgXCLmmI5cIixcbiAgICBcIueci1wiLFxuICAgIFwi5Y6fXCIsXG4gICAgXCLlj4hcIixcbiAgICBcIum6vFwiLFxuICAgIFwi5YipXCIsXG4gICAgXCLmr5RcIixcbiAgICBcIuaIllwiLFxuICAgIFwi5L2GXCIsXG4gICAgXCLos6pcIixcbiAgICBcIuawo1wiLFxuICAgIFwi56ysXCIsXG4gICAgXCLlkJFcIixcbiAgICBcIumBk1wiLFxuICAgIFwi5ZG9XCIsXG4gICAgXCLmraRcIixcbiAgICBcIuiuilwiLFxuICAgIFwi5qKdXCIsXG4gICAgXCLlj6pcIixcbiAgICBcIuayklwiLFxuICAgIFwi57WQXCIsXG4gICAgXCLop6NcIixcbiAgICBcIuWVj1wiLFxuICAgIFwi5oSPXCIsXG4gICAgXCLlu7pcIixcbiAgICBcIuaciFwiLFxuICAgIFwi5YWsXCIsXG4gICAgXCLnhKFcIixcbiAgICBcIuezu1wiLFxuICAgIFwi6LuNXCIsXG4gICAgXCLlvohcIixcbiAgICBcIuaDhVwiLFxuICAgIFwi6ICFXCIsXG4gICAgXCLmnIBcIixcbiAgICBcIueri1wiLFxuICAgIFwi5LujXCIsXG4gICAgXCLmg7NcIixcbiAgICBcIuW3slwiLFxuICAgIFwi6YCaXCIsXG4gICAgXCLkuKZcIixcbiAgICBcIuaPkFwiLFxuICAgIFwi55u0XCIsXG4gICAgXCLpoYxcIixcbiAgICBcIum7qFwiLFxuICAgIFwi56iLXCIsXG4gICAgXCLlsZVcIixcbiAgICBcIuS6lFwiLFxuICAgIFwi5p6cXCIsXG4gICAgXCLmlplcIixcbiAgICBcIuixoVwiLFxuICAgIFwi5ZOhXCIsXG4gICAgXCLpnalcIixcbiAgICBcIuS9jVwiLFxuICAgIFwi5YWlXCIsXG4gICAgXCLluLhcIixcbiAgICBcIuaWh1wiLFxuICAgIFwi57i9XCIsXG4gICAgXCLmrKFcIixcbiAgICBcIuWTgVwiLFxuICAgIFwi5byPXCIsXG4gICAgXCLmtLtcIixcbiAgICBcIuiorVwiLFxuICAgIFwi5Y+KXCIsXG4gICAgXCLnrqFcIixcbiAgICBcIueJuVwiLFxuICAgIFwi5Lu2XCIsXG4gICAgXCLplbdcIixcbiAgICBcIuaxglwiLFxuICAgIFwi6ICBXCIsXG4gICAgXCLpoK1cIixcbiAgICBcIuWfulwiLFxuICAgIFwi6LOHXCIsXG4gICAgXCLpgopcIixcbiAgICBcIua1gVwiLFxuICAgIFwi6LevXCIsXG4gICAgXCLntJpcIixcbiAgICBcIuWwkVwiLFxuICAgIFwi5ZyWXCIsXG4gICAgXCLlsbFcIixcbiAgICBcIue1sVwiLFxuICAgIFwi5o6lXCIsXG4gICAgXCLnn6VcIixcbiAgICBcIui8g1wiLFxuICAgIFwi5bCHXCIsXG4gICAgXCLntYRcIixcbiAgICBcIuimi1wiLFxuICAgIFwi6KiIXCIsXG4gICAgXCLliKVcIixcbiAgICBcIuWluVwiLFxuICAgIFwi5omLXCIsXG4gICAgXCLop5JcIixcbiAgICBcIuacn1wiLFxuICAgIFwi5qC5XCIsXG4gICAgXCLoq5ZcIixcbiAgICBcIumBi1wiLFxuICAgIFwi6L6yXCIsXG4gICAgXCLmjIdcIixcbiAgICBcIuW5vlwiLFxuICAgIFwi5LmdXCIsXG4gICAgXCLljYBcIixcbiAgICBcIuW8t1wiLFxuICAgIFwi5pS+XCIsXG4gICAgXCLmsbpcIixcbiAgICBcIuilv1wiLFxuICAgIFwi6KKrXCIsXG4gICAgXCLlublcIixcbiAgICBcIuWBmlwiLFxuICAgIFwi5b+FXCIsXG4gICAgXCLmiLBcIixcbiAgICBcIuWFiFwiLFxuICAgIFwi5ZueXCIsXG4gICAgXCLliYdcIixcbiAgICBcIuS7u1wiLFxuICAgIFwi5Y+WXCIsXG4gICAgXCLmk5pcIixcbiAgICBcIuiZlVwiLFxuICAgIFwi6ZqKXCIsXG4gICAgXCLljZdcIixcbiAgICBcIue1plwiLFxuICAgIFwi6ImyXCIsXG4gICAgXCLlhYlcIixcbiAgICBcIumWgFwiLFxuICAgIFwi5Y2zXCIsXG4gICAgXCLkv51cIixcbiAgICBcIuayu1wiLFxuICAgIFwi5YyXXCIsXG4gICAgXCLpgKBcIixcbiAgICBcIueZvlwiLFxuICAgIFwi6KaPXCIsXG4gICAgXCLnhrFcIixcbiAgICBcIumgmFwiLFxuICAgIFwi5LiDXCIsXG4gICAgXCLmtbdcIixcbiAgICBcIuWPo1wiLFxuICAgIFwi5p2xXCIsXG4gICAgXCLlsI5cIixcbiAgICBcIuWZqFwiLFxuICAgIFwi5aOTXCIsXG4gICAgXCLlv5dcIixcbiAgICBcIuS4llwiLFxuICAgIFwi6YeRXCIsXG4gICAgXCLlop5cIixcbiAgICBcIueIrVwiLFxuICAgIFwi5r+fXCIsXG4gICAgXCLpmo5cIixcbiAgICBcIuayuVwiLFxuICAgIFwi5oCdXCIsXG4gICAgXCLooZNcIixcbiAgICBcIualtVwiLFxuICAgIFwi5LqkXCIsXG4gICAgXCLlj5dcIixcbiAgICBcIuiBr1wiLFxuICAgIFwi5LuAXCIsXG4gICAgXCLoqo1cIixcbiAgICBcIuWFrVwiLFxuICAgIFwi5YWxXCIsXG4gICAgXCLmrIpcIixcbiAgICBcIuaUtlwiLFxuICAgIFwi6K2JXCIsXG4gICAgXCLmlLlcIixcbiAgICBcIua4hVwiLFxuICAgIFwi576OXCIsXG4gICAgXCLlho1cIixcbiAgICBcIuaOoVwiLFxuICAgIFwi6L2JXCIsXG4gICAgXCLmm7RcIixcbiAgICBcIuWWrlwiLFxuICAgIFwi6aKoXCIsXG4gICAgXCLliIdcIixcbiAgICBcIuaJk1wiLFxuICAgIFwi55m9XCIsXG4gICAgXCLmlZlcIixcbiAgICBcIumAn1wiLFxuICAgIFwi6IqxXCIsXG4gICAgXCLluLZcIixcbiAgICBcIuWuiVwiLFxuICAgIFwi5aC0XCIsXG4gICAgXCLouqtcIixcbiAgICBcIui7ilwiLFxuICAgIFwi5L6LXCIsXG4gICAgXCLnnJ9cIixcbiAgICBcIuWLmVwiLFxuICAgIFwi5YW3XCIsXG4gICAgXCLokKxcIixcbiAgICBcIuavj1wiLFxuICAgIFwi55uuXCIsXG4gICAgXCLoh7NcIixcbiAgICBcIumBlFwiLFxuICAgIFwi6LWwXCIsXG4gICAgXCLnqY1cIixcbiAgICBcIuekulwiLFxuICAgIFwi6K2wXCIsXG4gICAgXCLogbJcIixcbiAgICBcIuWgsVwiLFxuICAgIFwi6aylXCIsXG4gICAgXCLlroxcIixcbiAgICBcIumhnlwiLFxuICAgIFwi5YWrXCIsXG4gICAgXCLpm6JcIixcbiAgICBcIuiPr1wiLFxuICAgIFwi5ZCNXCIsXG4gICAgXCLnorpcIixcbiAgICBcIuaJjVwiLFxuICAgIFwi56eRXCIsXG4gICAgXCLlvLVcIixcbiAgICBcIuS/oVwiLFxuICAgIFwi6aasXCIsXG4gICAgXCLnr4BcIixcbiAgICBcIuipsVwiLFxuICAgIFwi57GzXCIsXG4gICAgXCLmlbRcIixcbiAgICBcIuepulwiLFxuICAgIFwi5YWDXCIsXG4gICAgXCLms4FcIixcbiAgICBcIuS7ilwiLFxuICAgIFwi6ZuGXCIsXG4gICAgXCLmuqtcIixcbiAgICBcIuWCs1wiLFxuICAgIFwi5ZyfXCIsXG4gICAgXCLoqLFcIixcbiAgICBcIuatpVwiLFxuICAgIFwi576kXCIsXG4gICAgXCLlu6NcIixcbiAgICBcIuefs1wiLFxuICAgIFwi6KiYXCIsXG4gICAgXCLpnIBcIixcbiAgICBcIuautVwiLFxuICAgIFwi56CUXCIsXG4gICAgXCLnlYxcIixcbiAgICBcIuaLiVwiLFxuICAgIFwi5p6XXCIsXG4gICAgXCLlvotcIixcbiAgICBcIuWPq1wiLFxuICAgIFwi5LiUXCIsXG4gICAgXCLnqbZcIixcbiAgICBcIuingFwiLFxuICAgIFwi6LaKXCIsXG4gICAgXCLnuZRcIixcbiAgICBcIuijnVwiLFxuICAgIFwi5b2xXCIsXG4gICAgXCLnrpdcIixcbiAgICBcIuS9jlwiLFxuICAgIFwi5oyBXCIsXG4gICAgXCLpn7NcIixcbiAgICBcIuecvlwiLFxuICAgIFwi5pu4XCIsXG4gICAgXCLluINcIixcbiAgICBcIuWkjVwiLFxuICAgIFwi5a65XCIsXG4gICAgXCLlhZJcIixcbiAgICBcIumgiFwiLFxuICAgIFwi6ZqbXCIsXG4gICAgXCLllYZcIixcbiAgICBcIumdnlwiLFxuICAgIFwi6amXXCIsXG4gICAgXCLpgKNcIixcbiAgICBcIuaWt1wiLFxuICAgIFwi5rexXCIsXG4gICAgXCLpm6NcIixcbiAgICBcIui/kVwiLFxuICAgIFwi56SmXCIsXG4gICAgXCLljYNcIixcbiAgICBcIumAsVwiLFxuICAgIFwi5aeUXCIsXG4gICAgXCLntKBcIixcbiAgICBcIuaKgFwiLFxuICAgIFwi5YKZXCIsXG4gICAgXCLljYpcIixcbiAgICBcIui+plwiLFxuICAgIFwi6Z2SXCIsXG4gICAgXCLnnIFcIixcbiAgICBcIuWIl1wiLFxuICAgIFwi57+SXCIsXG4gICAgXCLpn79cIixcbiAgICBcIue0hFwiLFxuICAgIFwi5pSvXCIsXG4gICAgXCLoiKxcIixcbiAgICBcIuWPslwiLFxuICAgIFwi5oSfXCIsXG4gICAgXCLli55cIixcbiAgICBcIuS+v1wiLFxuICAgIFwi5ZyYXCIsXG4gICAgXCLlvoBcIixcbiAgICBcIumFuFwiLFxuICAgIFwi5q23XCIsXG4gICAgXCLluIJcIixcbiAgICBcIuWFi1wiLFxuICAgIFwi5L2VXCIsXG4gICAgXCLpmaRcIixcbiAgICBcIua2iFwiLFxuICAgIFwi5qeLXCIsXG4gICAgXCLlupxcIixcbiAgICBcIueosVwiLFxuICAgIFwi5aSqXCIsXG4gICAgXCLmupZcIixcbiAgICBcIueyvlwiLFxuICAgIFwi5YC8XCIsXG4gICAgXCLomZ9cIixcbiAgICBcIueOh1wiLFxuICAgIFwi5pePXCIsXG4gICAgXCLntq1cIixcbiAgICBcIuWKg1wiLFxuICAgIFwi6YG4XCIsXG4gICAgXCLmqJlcIixcbiAgICBcIuWvq1wiLFxuICAgIFwi5a2YXCIsXG4gICAgXCLlgJlcIixcbiAgICBcIuavm1wiLFxuICAgIFwi6KaqXCIsXG4gICAgXCLlv6tcIixcbiAgICBcIuaViFwiLFxuICAgIFwi5pavXCIsXG4gICAgXCLpmaJcIixcbiAgICBcIuafpVwiLFxuICAgIFwi5rGfXCIsXG4gICAgXCLlnotcIixcbiAgICBcIuecvFwiLFxuICAgIFwi546LXCIsXG4gICAgXCLmjIlcIixcbiAgICBcIuagvFwiLFxuICAgIFwi6aSKXCIsXG4gICAgXCLmmJNcIixcbiAgICBcIue9rlwiLFxuICAgIFwi5rS+XCIsXG4gICAgXCLlsaRcIixcbiAgICBcIueJh1wiLFxuICAgIFwi5aeLXCIsXG4gICAgXCLljbtcIixcbiAgICBcIuWwiFwiLFxuICAgIFwi54uAXCIsXG4gICAgXCLogrJcIixcbiAgICBcIuW7oFwiLFxuICAgIFwi5LqsXCIsXG4gICAgXCLorZhcIixcbiAgICBcIumBqVwiLFxuICAgIFwi5bGsXCIsXG4gICAgXCLlnJNcIixcbiAgICBcIuWMhVwiLFxuICAgIFwi54GrXCIsXG4gICAgXCLkvY9cIixcbiAgICBcIuiqv1wiLFxuICAgIFwi5ru/XCIsXG4gICAgXCLnuKNcIixcbiAgICBcIuWxgFwiLFxuICAgIFwi54WnXCIsXG4gICAgXCLlj4NcIixcbiAgICBcIue0hVwiLFxuICAgIFwi57SwXCIsXG4gICAgXCLlvJVcIixcbiAgICBcIuiBvVwiLFxuICAgIFwi6KmyXCIsXG4gICAgXCLpkLVcIixcbiAgICBcIuWDuVwiLFxuICAgIFwi5Zq0XCIsXG4gICAgXCLpppZcIixcbiAgICBcIuW6lVwiLFxuICAgIFwi5rayXCIsXG4gICAgXCLlrphcIixcbiAgICBcIuW+t1wiLFxuICAgIFwi6ZqoXCIsXG4gICAgXCLnl4VcIixcbiAgICBcIuiYh1wiLFxuICAgIFwi5aSxXCIsXG4gICAgXCLniL5cIixcbiAgICBcIuatu1wiLFxuICAgIFwi6KybXCIsXG4gICAgXCLphY1cIixcbiAgICBcIuWls1wiLFxuICAgIFwi6buDXCIsXG4gICAgXCLmjqhcIixcbiAgICBcIumhr1wiLFxuICAgIFwi6KuHXCIsXG4gICAgXCLnvapcIixcbiAgICBcIuelnlwiLFxuICAgIFwi6JedXCIsXG4gICAgXCLlkaJcIixcbiAgICBcIuW4rVwiLFxuICAgIFwi5ZCrXCIsXG4gICAgXCLkvIFcIixcbiAgICBcIuacm1wiLFxuICAgIFwi5a+GXCIsXG4gICAgXCLmiblcIixcbiAgICBcIueHn1wiLFxuICAgIFwi6aCFXCIsXG4gICAgXCLpmLJcIixcbiAgICBcIuiIiVwiLFxuICAgIFwi55CDXCIsXG4gICAgXCLoi7FcIixcbiAgICBcIuawp1wiLFxuICAgIFwi5YuiXCIsXG4gICAgXCLlkYpcIixcbiAgICBcIuadjlwiLFxuICAgIFwi5Y+wXCIsXG4gICAgXCLokL1cIixcbiAgICBcIuacqFwiLFxuICAgIFwi5bmrXCIsXG4gICAgXCLovKpcIixcbiAgICBcIuegtFwiLFxuICAgIFwi5LqeXCIsXG4gICAgXCLluKtcIixcbiAgICBcIuWcjVwiLFxuICAgIFwi5rOoXCIsXG4gICAgXCLpgaBcIixcbiAgICBcIuWtl1wiLFxuICAgIFwi5p2QXCIsXG4gICAgXCLmjpJcIixcbiAgICBcIuS+m1wiLFxuICAgIFwi5rKzXCIsXG4gICAgXCLmhYtcIixcbiAgICBcIuWwgVwiLFxuICAgIFwi5Y+mXCIsXG4gICAgXCLmlr1cIixcbiAgICBcIua4m1wiLFxuICAgIFwi5qi5XCIsXG4gICAgXCLmurZcIixcbiAgICBcIuaAjlwiLFxuICAgIFwi5q2iXCIsXG4gICAgXCLmoYhcIixcbiAgICBcIuiogFwiLFxuICAgIFwi5aOrXCIsXG4gICAgXCLlnYdcIixcbiAgICBcIuatplwiLFxuICAgIFwi5Zu6XCIsXG4gICAgXCLokYlcIixcbiAgICBcIumtmlwiLFxuICAgIFwi5rOiXCIsXG4gICAgXCLoppZcIixcbiAgICBcIuWDhVwiLFxuICAgIFwi6LK7XCIsXG4gICAgXCLnt4pcIixcbiAgICBcIuaEm1wiLFxuICAgIFwi5bemXCIsXG4gICAgXCLnq6BcIixcbiAgICBcIuaXqVwiLFxuICAgIFwi5pydXCIsXG4gICAgXCLlrrNcIixcbiAgICBcIue6jFwiLFxuICAgIFwi6LyVXCIsXG4gICAgXCLmnI1cIixcbiAgICBcIuipplwiLFxuICAgIFwi6aOfXCIsXG4gICAgXCLlhYVcIixcbiAgICBcIuWFtVwiLFxuICAgIFwi5rqQXCIsXG4gICAgXCLliKRcIixcbiAgICBcIuitt1wiLFxuICAgIFwi5Y+4XCIsXG4gICAgXCLotrNcIixcbiAgICBcIuafkFwiLFxuICAgIFwi57e0XCIsXG4gICAgXCLlt65cIixcbiAgICBcIuiHtFwiLFxuICAgIFwi5p2/XCIsXG4gICAgXCLnlLBcIixcbiAgICBcIumZjVwiLFxuICAgIFwi6buRXCIsXG4gICAgXCLniq9cIixcbiAgICBcIuiyoFwiLFxuICAgIFwi5pOKXCIsXG4gICAgXCLojINcIixcbiAgICBcIue5vFwiLFxuICAgIFwi6IiIXCIsXG4gICAgXCLkvLxcIixcbiAgICBcIumkmFwiLFxuICAgIFwi5aCFXCIsXG4gICAgXCLmm7JcIixcbiAgICBcIui8uFwiLFxuICAgIFwi5L+uXCIsXG4gICAgXCLmlYVcIixcbiAgICBcIuWfjlwiLFxuICAgIFwi5aSrXCIsXG4gICAgXCLlpKBcIixcbiAgICBcIumAgVwiLFxuICAgIFwi562GXCIsXG4gICAgXCLoiLlcIixcbiAgICBcIuS9lFwiLFxuICAgIFwi5Y+zXCIsXG4gICAgXCLosqFcIixcbiAgICBcIuWQg1wiLFxuICAgIFwi5a+MXCIsXG4gICAgXCLmmKVcIixcbiAgICBcIuiBt1wiLFxuICAgIFwi6Ka6XCIsXG4gICAgXCLmvKJcIixcbiAgICBcIueVq1wiLFxuICAgIFwi5YqfXCIsXG4gICAgXCLlt7RcIixcbiAgICBcIui3n1wiLFxuICAgIFwi6ZuWXCIsXG4gICAgXCLpm5xcIixcbiAgICBcIumjm1wiLFxuICAgIFwi5qqiXCIsXG4gICAgXCLlkLhcIixcbiAgICBcIuWKqVwiLFxuICAgIFwi5piHXCIsXG4gICAgXCLpmb1cIixcbiAgICBcIuS6klwiLFxuICAgIFwi5YidXCIsXG4gICAgXCLlibVcIixcbiAgICBcIuaKl1wiLFxuICAgIFwi6ICDXCIsXG4gICAgXCLmipVcIixcbiAgICBcIuWjnlwiLFxuICAgIFwi562WXCIsXG4gICAgXCLlj6RcIixcbiAgICBcIuW+kVwiLFxuICAgIFwi5o+bXCIsXG4gICAgXCLmnKpcIixcbiAgICBcIui3kVwiLFxuICAgIFwi55WZXCIsXG4gICAgXCLpi7xcIixcbiAgICBcIuabvlwiLFxuICAgIFwi56uvXCIsXG4gICAgXCLosqxcIixcbiAgICBcIuermVwiLFxuICAgIFwi57ChXCIsXG4gICAgXCLov7BcIixcbiAgICBcIumMolwiLFxuICAgIFwi5YmvXCIsXG4gICAgXCLnm6FcIixcbiAgICBcIuW4nVwiLFxuICAgIFwi5bCEXCIsXG4gICAgXCLojYlcIixcbiAgICBcIuihnVwiLFxuICAgIFwi5om/XCIsXG4gICAgXCLnjahcIixcbiAgICBcIuS7pFwiLFxuICAgIFwi6ZmQXCIsXG4gICAgXCLpmL9cIixcbiAgICBcIuWuo1wiLFxuICAgIFwi55KwXCIsXG4gICAgXCLpm5lcIixcbiAgICBcIuiri1wiLFxuICAgIFwi6LaFXCIsXG4gICAgXCLlvq5cIixcbiAgICBcIuiuk1wiLFxuICAgIFwi5o6nXCIsXG4gICAgXCLlt55cIixcbiAgICBcIuiJr1wiLFxuICAgIFwi6Lu4XCIsXG4gICAgXCLmib5cIixcbiAgICBcIuWQplwiLFxuICAgIFwi57SAXCIsXG4gICAgXCLnm4pcIixcbiAgICBcIuS+nVwiLFxuICAgIFwi5YSqXCIsXG4gICAgXCLpoIJcIixcbiAgICBcIuekjlwiLFxuICAgIFwi6LyJXCIsXG4gICAgXCLlgJJcIixcbiAgICBcIuaIv1wiLFxuICAgIFwi56qBXCIsXG4gICAgXCLlnZBcIixcbiAgICBcIueyiVwiLFxuICAgIFwi5pW1XCIsXG4gICAgXCLnlaVcIixcbiAgICBcIuWuolwiLFxuICAgIFwi6KKBXCIsXG4gICAgXCLlhrdcIixcbiAgICBcIuWLnVwiLFxuICAgIFwi57WVXCIsXG4gICAgXCLmnpBcIixcbiAgICBcIuWhilwiLFxuICAgIFwi5YqRXCIsXG4gICAgXCLmuKxcIixcbiAgICBcIue1slwiLFxuICAgIFwi5Y2UXCIsXG4gICAgXCLoqLRcIixcbiAgICBcIuW/tVwiLFxuICAgIFwi6ZmzXCIsXG4gICAgXCLku41cIixcbiAgICBcIue+hVwiLFxuICAgIFwi6bm9XCIsXG4gICAgXCLlj4tcIixcbiAgICBcIua0i1wiLFxuICAgIFwi6YyvXCIsXG4gICAgXCLoi6ZcIixcbiAgICBcIuWknFwiLFxuICAgIFwi5YiRXCIsXG4gICAgXCLnp7tcIixcbiAgICBcIumgu1wiLFxuICAgIFwi6YCQXCIsXG4gICAgXCLpnaBcIixcbiAgICBcIua3t1wiLFxuICAgIFwi5q+NXCIsXG4gICAgXCLnn61cIixcbiAgICBcIuearlwiLFxuICAgIFwi57WCXCIsXG4gICAgXCLogZpcIixcbiAgICBcIuaxvVwiLFxuICAgIFwi5p2RXCIsXG4gICAgXCLpm7JcIixcbiAgICBcIuWTqlwiLFxuICAgIFwi5peiXCIsXG4gICAgXCLot51cIixcbiAgICBcIuihm1wiLFxuICAgIFwi5YGcXCIsXG4gICAgXCLng4hcIixcbiAgICBcIuWkrlwiLFxuICAgIFwi5a+fXCIsXG4gICAgXCLnh5JcIixcbiAgICBcIui/hVwiLFxuICAgIFwi5aKDXCIsXG4gICAgXCLoi6VcIixcbiAgICBcIuWNsFwiLFxuICAgIFwi5rSyXCIsXG4gICAgXCLliLtcIixcbiAgICBcIuaLrFwiLFxuICAgIFwi5r+AXCIsXG4gICAgXCLlrZRcIixcbiAgICBcIuaQnlwiLFxuICAgIFwi55SaXCIsXG4gICAgXCLlrqRcIixcbiAgICBcIuW+hVwiLFxuICAgIFwi5qC4XCIsXG4gICAgXCLmoKFcIixcbiAgICBcIuaVo1wiLFxuICAgIFwi5L61XCIsXG4gICAgXCLlkKdcIixcbiAgICBcIueUslwiLFxuICAgIFwi6YGKXCIsXG4gICAgXCLkuYVcIixcbiAgICBcIuiPnFwiLFxuICAgIFwi5ZGzXCIsXG4gICAgXCLoiIpcIixcbiAgICBcIuaooVwiLFxuICAgIFwi5rmWXCIsXG4gICAgXCLosqhcIixcbiAgICBcIuaQjVwiLFxuICAgIFwi6aCQXCIsXG4gICAgXCLpmLtcIixcbiAgICBcIuavq1wiLFxuICAgIFwi5pmuXCIsXG4gICAgXCLnqalcIixcbiAgICBcIuS5mVwiLFxuICAgIFwi5aq9XCIsXG4gICAgXCLmpI1cIixcbiAgICBcIuaBr1wiLFxuICAgIFwi5pO0XCIsXG4gICAgXCLpioBcIixcbiAgICBcIuiqnlwiLFxuICAgIFwi5o+uXCIsXG4gICAgXCLphZJcIixcbiAgICBcIuWuiFwiLFxuICAgIFwi5ou/XCIsXG4gICAgXCLluo9cIixcbiAgICBcIue0mVwiLFxuICAgIFwi6YarXCIsXG4gICAgXCLnvLpcIixcbiAgICBcIumbqFwiLFxuICAgIFwi5ZeOXCIsXG4gICAgXCLph51cIixcbiAgICBcIuWKiVwiLFxuICAgIFwi5ZWKXCIsXG4gICAgXCLmgKVcIixcbiAgICBcIuWUsVwiLFxuICAgIFwi6KqkXCIsXG4gICAgXCLoqJNcIixcbiAgICBcIumhmFwiLFxuICAgIFwi5a+pXCIsXG4gICAgXCLpmYRcIixcbiAgICBcIueNslwiLFxuICAgIFwi6Iy2XCIsXG4gICAgXCLprq5cIixcbiAgICBcIuezp1wiLFxuICAgIFwi5pakXCIsXG4gICAgXCLlralcIixcbiAgICBcIuiEq1wiLFxuICAgIFwi56GrXCIsXG4gICAgXCLogqVcIixcbiAgICBcIuWWhFwiLFxuICAgIFwi6b6NXCIsXG4gICAgXCLmvJRcIixcbiAgICBcIueItlwiLFxuICAgIFwi5ry4XCIsXG4gICAgXCLooYBcIixcbiAgICBcIuatoVwiLFxuICAgIFwi5qKwXCIsXG4gICAgXCLmjoxcIixcbiAgICBcIuatjFwiLFxuICAgIFwi5rKZXCIsXG4gICAgXCLliZtcIixcbiAgICBcIuaUu1wiLFxuICAgIFwi6KyCXCIsXG4gICAgXCLnm75cIixcbiAgICBcIuiojlwiLFxuICAgIFwi5pmaXCIsXG4gICAgXCLnspJcIixcbiAgICBcIuS6glwiLFxuICAgIFwi54eDXCIsXG4gICAgXCLnn5tcIixcbiAgICBcIuS5jlwiLFxuICAgIFwi5q66XCIsXG4gICAgXCLol6VcIixcbiAgICBcIuWvp1wiLFxuICAgIFwi6a2vXCIsXG4gICAgXCLosrRcIixcbiAgICBcIumQmFwiLFxuICAgIFwi54WkXCIsXG4gICAgXCLoroBcIixcbiAgICBcIuePrVwiLFxuICAgIFwi5LyvXCIsXG4gICAgXCLppplcIixcbiAgICBcIuS7i1wiLFxuICAgIFwi6L+rXCIsXG4gICAgXCLlj6VcIixcbiAgICBcIuixkFwiLFxuICAgIFwi5Z+5XCIsXG4gICAgXCLmj6FcIixcbiAgICBcIuiYrVwiLFxuICAgIFwi5pOUXCIsXG4gICAgXCLlvKZcIixcbiAgICBcIuibi1wiLFxuICAgIFwi5rKJXCIsXG4gICAgXCLlgYdcIixcbiAgICBcIuepv1wiLFxuICAgIFwi5Z+3XCIsXG4gICAgXCLnrZRcIixcbiAgICBcIuaoglwiLFxuICAgIFwi6KqwXCIsXG4gICAgXCLpoIZcIixcbiAgICBcIueFmVwiLFxuICAgIFwi57iuXCIsXG4gICAgXCLlvrVcIixcbiAgICBcIuiHiVwiLFxuICAgIFwi5ZacXCIsXG4gICAgXCLmnb5cIixcbiAgICBcIuiFs1wiLFxuICAgIFwi5ZuwXCIsXG4gICAgXCLnlbBcIixcbiAgICBcIuWFjVwiLFxuICAgIFwi6IOMXCIsXG4gICAgXCLmmJ9cIixcbiAgICBcIuemj1wiLFxuICAgIFwi6LK3XCIsXG4gICAgXCLmn5NcIixcbiAgICBcIuS6lVwiLFxuICAgIFwi5qaCXCIsXG4gICAgXCLmhaJcIixcbiAgICBcIuaAlVwiLFxuICAgIFwi56OBXCIsXG4gICAgXCLlgI1cIixcbiAgICBcIuelllwiLFxuICAgIFwi55qHXCIsXG4gICAgXCLkv4NcIixcbiAgICBcIumdnFwiLFxuICAgIFwi6KOcXCIsXG4gICAgXCLoqZVcIixcbiAgICBcIue/u1wiLFxuICAgIFwi6IKJXCIsXG4gICAgXCLouJBcIixcbiAgICBcIuWwvFwiLFxuICAgIFwi6KGjXCIsXG4gICAgXCLlr6xcIixcbiAgICBcIuaPmlwiLFxuICAgIFwi5qOJXCIsXG4gICAgXCLluIxcIixcbiAgICBcIuWCt1wiLFxuICAgIFwi5pONXCIsXG4gICAgXCLlnoJcIixcbiAgICBcIueni1wiLFxuICAgIFwi5a6cXCIsXG4gICAgXCLmsKtcIixcbiAgICBcIuWll1wiLFxuICAgIFwi552jXCIsXG4gICAgXCLmjK9cIixcbiAgICBcIuaetlwiLFxuICAgIFwi5LquXCIsXG4gICAgXCLmnKtcIixcbiAgICBcIuaGslwiLFxuICAgIFwi5oW2XCIsXG4gICAgXCLnt6hcIixcbiAgICBcIueJm1wiLFxuICAgIFwi6Ke4XCIsXG4gICAgXCLmmKBcIixcbiAgICBcIumbt1wiLFxuICAgIFwi6Yq3XCIsXG4gICAgXCLoqalcIixcbiAgICBcIuW6p1wiLFxuICAgIFwi5bGFXCIsXG4gICAgXCLmipNcIixcbiAgICBcIuijglwiLFxuICAgIFwi6IOeXCIsXG4gICAgXCLlkbxcIixcbiAgICBcIuWomFwiLFxuICAgIFwi5pmvXCIsXG4gICAgXCLlqIFcIixcbiAgICBcIue2oFwiLFxuICAgIFwi5pm2XCIsXG4gICAgXCLljppcIixcbiAgICBcIuebn1wiLFxuICAgIFwi6KGhXCIsXG4gICAgXCLpm55cIixcbiAgICBcIuWtq1wiLFxuICAgIFwi5bu2XCIsXG4gICAgXCLljbFcIixcbiAgICBcIuiGoFwiLFxuICAgIFwi5bGLXCIsXG4gICAgXCLphIlcIixcbiAgICBcIuiHqFwiLFxuICAgIFwi6Zm4XCIsXG4gICAgXCLpoadcIixcbiAgICBcIuaOiVwiLFxuICAgIFwi5ZGAXCIsXG4gICAgXCLnh4hcIixcbiAgICBcIuatslwiLFxuICAgIFwi5o6qXCIsXG4gICAgXCLmnZ9cIixcbiAgICBcIuiAkFwiLFxuICAgIFwi5YqHXCIsXG4gICAgXCLnjolcIixcbiAgICBcIui2mVwiLFxuICAgIFwi6LezXCIsXG4gICAgXCLlk6VcIixcbiAgICBcIuWto1wiLFxuICAgIFwi6KqyXCIsXG4gICAgXCLlh7FcIixcbiAgICBcIuiDoVwiLFxuICAgIFwi6aGNXCIsXG4gICAgXCLmrL5cIixcbiAgICBcIue0uVwiLFxuICAgIFwi5Y23XCIsXG4gICAgXCLpvYpcIixcbiAgICBcIuWBiVwiLFxuICAgIFwi6JK4XCIsXG4gICAgXCLmrpZcIixcbiAgICBcIuawuFwiLFxuICAgIFwi5a6XXCIsXG4gICAgXCLoi5dcIixcbiAgICBcIuW3nVwiLFxuICAgIFwi54iQXCIsXG4gICAgXCLlsqlcIixcbiAgICBcIuW8sVwiLFxuICAgIFwi6Zu2XCIsXG4gICAgXCLmpYpcIixcbiAgICBcIuWlj1wiLFxuICAgIFwi5rK/XCIsXG4gICAgXCLpnLJcIixcbiAgICBcIuahv1wiLFxuICAgIFwi5o6iXCIsXG4gICAgXCLmu5FcIixcbiAgICBcIumOrlwiLFxuICAgIFwi6aOvXCIsXG4gICAgXCLmv4NcIixcbiAgICBcIuiIqlwiLFxuICAgIFwi5oe3XCIsXG4gICAgXCLotpVcIixcbiAgICBcIuW6q1wiLFxuICAgIFwi5aWqXCIsXG4gICAgXCLkvIpcIixcbiAgICBcIumdiFwiLFxuICAgIFwi56iFXCIsXG4gICAgXCLpgJRcIixcbiAgICBcIua7hVwiLFxuICAgIFwi6LO9XCIsXG4gICAgXCLmrbhcIixcbiAgICBcIuWPrFwiLFxuICAgIFwi6byTXCIsXG4gICAgXCLmkq1cIixcbiAgICBcIuebpFwiLFxuICAgIFwi6KOBXCIsXG4gICAgXCLpmqpcIixcbiAgICBcIuW6t1wiLFxuICAgIFwi5ZSvXCIsXG4gICAgXCLpjIRcIixcbiAgICBcIuiPjFwiLFxuICAgIFwi57SUXCIsXG4gICAgXCLlgJ9cIixcbiAgICBcIuezllwiLFxuICAgIFwi6JOLXCIsXG4gICAgXCLmqatcIixcbiAgICBcIuesplwiLFxuICAgIFwi56eBXCIsXG4gICAgXCLliqpcIixcbiAgICBcIuWgglwiLFxuICAgIFwi5Z+fXCIsXG4gICAgXCLmp41cIixcbiAgICBcIua9pFwiLFxuICAgIFwi5bmFXCIsXG4gICAgXCLlk4hcIixcbiAgICBcIuern1wiLFxuICAgIFwi54afXCIsXG4gICAgXCLon7JcIixcbiAgICBcIua+pFwiLFxuICAgIFwi6IWmXCIsXG4gICAgXCLlo6RcIixcbiAgICBcIueis1wiLFxuICAgIFwi5q2QXCIsXG4gICAgXCLpgY1cIixcbiAgICBcIuWBtFwiLFxuICAgIFwi5a+oXCIsXG4gICAgXCLmlaJcIixcbiAgICBcIuW+uVwiLFxuICAgIFwi5oWuXCIsXG4gICAgXCLmlpxcIixcbiAgICBcIuiWhFwiLFxuICAgIFwi5bqtXCIsXG4gICAgXCLntI1cIixcbiAgICBcIuW9iFwiLFxuICAgIFwi6aO8XCIsXG4gICAgXCLkvLhcIixcbiAgICBcIuaKmFwiLFxuICAgIFwi6bqlXCIsXG4gICAgXCLmv5VcIixcbiAgICBcIuaal1wiLFxuICAgIFwi6I23XCIsXG4gICAgXCLnk6ZcIixcbiAgICBcIuWhnlwiLFxuICAgIFwi5bqKXCIsXG4gICAgXCLnr4lcIixcbiAgICBcIuaDoVwiLFxuICAgIFwi5oi2XCIsXG4gICAgXCLoqKpcIixcbiAgICBcIuWhlFwiLFxuICAgIFwi5aWHXCIsXG4gICAgXCLpgI9cIixcbiAgICBcIuaigVwiLFxuICAgIFwi5YiAXCIsXG4gICAgXCLml4tcIixcbiAgICBcIui3oVwiLFxuICAgIFwi5Y2hXCIsXG4gICAgXCLmsK9cIixcbiAgICBcIumBh1wiLFxuICAgIFwi5Lu9XCIsXG4gICAgXCLmr5JcIixcbiAgICBcIuazpVwiLFxuICAgIFwi6YCAXCIsXG4gICAgXCLmtJdcIixcbiAgICBcIuaTulwiLFxuICAgIFwi54GwXCIsXG4gICAgXCLlvalcIixcbiAgICBcIuizo1wiLFxuICAgIFwi6ICXXCIsXG4gICAgXCLlpI9cIixcbiAgICBcIuaTh1wiLFxuICAgIFwi5b+ZXCIsXG4gICAgXCLpioVcIixcbiAgICBcIueNu1wiLFxuICAgIFwi56GsXCIsXG4gICAgXCLkuohcIixcbiAgICBcIue5gVwiLFxuICAgIFwi5ZyIXCIsXG4gICAgXCLpm6pcIixcbiAgICBcIuWHvVwiLFxuICAgIFwi5LqmXCIsXG4gICAgXCLmir1cIixcbiAgICBcIuevh1wiLFxuICAgIFwi6ZmjXCIsXG4gICAgXCLpmbBcIixcbiAgICBcIuS4gVwiLFxuICAgIFwi5bC6XCIsXG4gICAgXCLov71cIixcbiAgICBcIuWghlwiLFxuICAgIFwi6ZuEXCIsXG4gICAgXCLov45cIixcbiAgICBcIuazm1wiLFxuICAgIFwi54i4XCIsXG4gICAgXCLmqJNcIixcbiAgICBcIumBv1wiLFxuICAgIFwi6KyAXCIsXG4gICAgXCLlmbhcIixcbiAgICBcIumHjlwiLFxuICAgIFwi6LGsXCIsXG4gICAgXCLml5dcIixcbiAgICBcIue0r1wiLFxuICAgIFwi5YGPXCIsXG4gICAgXCLlhbhcIixcbiAgICBcIumkqFwiLFxuICAgIFwi57SiXCIsXG4gICAgXCLnp6ZcIixcbiAgICBcIuiEglwiLFxuICAgIFwi5r2uXCIsXG4gICAgXCLniLpcIixcbiAgICBcIuixhlwiLFxuICAgIFwi5b+9XCIsXG4gICAgXCLmiZhcIixcbiAgICBcIumpmlwiLFxuICAgIFwi5aGRXCIsXG4gICAgXCLpgbpcIixcbiAgICBcIuaEiFwiLFxuICAgIFwi5pyxXCIsXG4gICAgXCLmm79cIixcbiAgICBcIue6llwiLFxuICAgIFwi57KXXCIsXG4gICAgXCLlgr5cIixcbiAgICBcIuWwmlwiLFxuICAgIFwi55ebXCIsXG4gICAgXCLmpZpcIixcbiAgICBcIuisnVwiLFxuICAgIFwi5aWuXCIsXG4gICAgXCLos7xcIixcbiAgICBcIuejqFwiLFxuICAgIFwi5ZCbXCIsXG4gICAgXCLmsaBcIixcbiAgICBcIuaXgVwiLFxuICAgIFwi56KOXCIsXG4gICAgXCLpqqhcIixcbiAgICBcIuebo1wiLFxuICAgIFwi5o2VXCIsXG4gICAgXCLlvJ9cIixcbiAgICBcIuaatFwiLFxuICAgIFwi5YmyXCIsXG4gICAgXCLosqtcIixcbiAgICBcIuauilwiLFxuICAgIFwi6YeLXCIsXG4gICAgXCLoqZ5cIixcbiAgICBcIuS6oVwiLFxuICAgIFwi5aOBXCIsXG4gICAgXCLpoJNcIixcbiAgICBcIuWvtlwiLFxuICAgIFwi5Y2IXCIsXG4gICAgXCLlobVcIixcbiAgICBcIuiBnlwiLFxuICAgIFwi5o+tXCIsXG4gICAgXCLngq5cIixcbiAgICBcIuaumFwiLFxuICAgIFwi5YasXCIsXG4gICAgXCLmqYtcIixcbiAgICBcIuWpplwiLFxuICAgIFwi6K2mXCIsXG4gICAgXCLntpxcIixcbiAgICBcIuaLm1wiLFxuICAgIFwi5ZCzXCIsXG4gICAgXCLku5hcIixcbiAgICBcIua1rlwiLFxuICAgIFwi6YGtXCIsXG4gICAgXCLlvpBcIixcbiAgICBcIuaCqFwiLFxuICAgIFwi5pCWXCIsXG4gICAgXCLosLdcIixcbiAgICBcIui0ilwiLFxuICAgIFwi566xXCIsXG4gICAgXCLpmpRcIixcbiAgICBcIuioglwiLFxuICAgIFwi55S3XCIsXG4gICAgXCLlkLlcIixcbiAgICBcIuWcklwiLFxuICAgIFwi57SbXCIsXG4gICAgXCLllJBcIixcbiAgICBcIuaVl1wiLFxuICAgIFwi5a6LXCIsXG4gICAgXCLnjrtcIixcbiAgICBcIuW3qFwiLFxuICAgIFwi6ICVXCIsXG4gICAgXCLlnaZcIixcbiAgICBcIuamrlwiLFxuICAgIFwi6ZaJXCIsXG4gICAgXCLngaNcIixcbiAgICBcIumNtVwiLFxuICAgIFwi5YehXCIsXG4gICAgXCLpp5BcIixcbiAgICBcIumNi1wiLFxuICAgIFwi5pWRXCIsXG4gICAgXCLmgalcIixcbiAgICBcIuWJnVwiLFxuICAgIFwi5YedXCIsXG4gICAgXCLpubxcIixcbiAgICBcIum9klwiLFxuICAgIFwi5oiqXCIsXG4gICAgXCLnhYlcIixcbiAgICBcIum6u1wiLFxuICAgIFwi57ShXCIsXG4gICAgXCLnpoFcIixcbiAgICBcIuW7olwiLFxuICAgIFwi55ubXCIsXG4gICAgXCLniYhcIixcbiAgICBcIue3qVwiLFxuICAgIFwi5reoXCIsXG4gICAgXCLnnZtcIixcbiAgICBcIuaYjFwiLFxuICAgIFwi5amaXCIsXG4gICAgXCLmtolcIixcbiAgICBcIuetklwiLFxuICAgIFwi5Zi0XCIsXG4gICAgXCLmj5JcIixcbiAgICBcIuWyuFwiLFxuICAgIFwi5pyXXCIsXG4gICAgXCLojopcIixcbiAgICBcIuihl1wiLFxuICAgIFwi6JePXCIsXG4gICAgXCLlp5FcIixcbiAgICBcIuiyv1wiLFxuICAgIFwi6IWQXCIsXG4gICAgXCLlpbRcIixcbiAgICBcIuWVplwiLFxuICAgIFwi5oWjXCIsXG4gICAgXCLkuZhcIixcbiAgICBcIuWkpVwiLFxuICAgIFwi5oGiXCIsXG4gICAgXCLli7tcIixcbiAgICBcIue0l1wiLFxuICAgIFwi5omOXCIsXG4gICAgXCLovq9cIixcbiAgICBcIuiAs1wiLFxuICAgIFwi5b2qXCIsXG4gICAgXCLoh6NcIixcbiAgICBcIuWEhFwiLFxuICAgIFwi55KDXCIsXG4gICAgXCLmirVcIixcbiAgICBcIuiEiFwiLFxuICAgIFwi56eAXCIsXG4gICAgXCLolqlcIixcbiAgICBcIuS/hFwiLFxuICAgIFwi57ayXCIsXG4gICAgXCLoiJ5cIixcbiAgICBcIuW6l1wiLFxuICAgIFwi5Zm0XCIsXG4gICAgXCLnuLFcIixcbiAgICBcIuWvuFwiLFxuICAgIFwi5rGXXCIsXG4gICAgXCLmjptcIixcbiAgICBcIua0qlwiLFxuICAgIFwi6LOAXCIsXG4gICAgXCLploNcIixcbiAgICBcIuafrFwiLFxuICAgIFwi54iGXCIsXG4gICAgXCLng69cIixcbiAgICBcIua0pVwiLFxuICAgIFwi56i7XCIsXG4gICAgXCLniYZcIixcbiAgICBcIui7n1wiLFxuICAgIFwi5YuHXCIsXG4gICAgXCLlg49cIixcbiAgICBcIua7vlwiLFxuICAgIFwi5Y6YXCIsXG4gICAgXCLokplcIixcbiAgICBcIuiKs1wiLFxuICAgIFwi6IKvXCIsXG4gICAgXCLlnaFcIixcbiAgICBcIuafsVwiLFxuICAgIFwi55uqXCIsXG4gICAgXCLohb9cIixcbiAgICBcIuWEgFwiLFxuICAgIFwi5peFXCIsXG4gICAgXCLlsL5cIixcbiAgICBcIui7i1wiLFxuICAgIFwi5YawXCIsXG4gICAgXCLosqJcIixcbiAgICBcIueZu1wiLFxuICAgIFwi6buOXCIsXG4gICAgXCLliYpcIixcbiAgICBcIumRvVwiLFxuICAgIFwi5YuSXCIsXG4gICAgXCLpgINcIixcbiAgICBcIumanFwiLFxuICAgIFwi5rCoXCIsXG4gICAgXCLpg61cIixcbiAgICBcIuWzsFwiLFxuICAgIFwi5bmjXCIsXG4gICAgXCLmuK9cIixcbiAgICBcIuS8j1wiLFxuICAgIFwi6LuMXCIsXG4gICAgXCLnlZ1cIixcbiAgICBcIueVolwiLFxuICAgIFwi5pOmXCIsXG4gICAgXCLojqtcIixcbiAgICBcIuWIulwiLFxuICAgIFwi5rWqXCIsXG4gICAgXCLnp5hcIixcbiAgICBcIuaPtFwiLFxuICAgIFwi5qCqXCIsXG4gICAgXCLlgaVcIixcbiAgICBcIuWUrlwiLFxuICAgIFwi6IKhXCIsXG4gICAgXCLls7ZcIixcbiAgICBcIueUmFwiLFxuICAgIFwi5rOhXCIsXG4gICAgXCLnnaFcIixcbiAgICBcIuerpVwiLFxuICAgIFwi6ZGEXCIsXG4gICAgXCLmua9cIixcbiAgICBcIumWpVwiLFxuICAgIFwi5LyRXCIsXG4gICAgXCLljK9cIixcbiAgICBcIuiIjVwiLFxuICAgIFwi54mnXCIsXG4gICAgXCLnuZ5cIixcbiAgICBcIueCuFwiLFxuICAgIFwi5ZOyXCIsXG4gICAgXCLno7dcIixcbiAgICBcIue4vlwiLFxuICAgIFwi5pyLXCIsXG4gICAgXCLmt6FcIixcbiAgICBcIuWwllwiLFxuICAgIFwi5ZWfXCIsXG4gICAgXCLpmbdcIixcbiAgICBcIuaftFwiLFxuICAgIFwi5ZGIXCIsXG4gICAgXCLlvpJcIixcbiAgICBcIumhj1wiLFxuICAgIFwi5reaXCIsXG4gICAgXCLnqI1cIixcbiAgICBcIuW/mFwiLFxuICAgIFwi5rO1XCIsXG4gICAgXCLol41cIixcbiAgICBcIuaLllwiLFxuICAgIFwi5rSeXCIsXG4gICAgXCLmjohcIixcbiAgICBcIumPoVwiLFxuICAgIFwi6L6bXCIsXG4gICAgXCLlo69cIixcbiAgICBcIumLklwiLFxuICAgIFwi6LKnXCIsXG4gICAgXCLomZtcIixcbiAgICBcIuW9jlwiLFxuICAgIFwi5pGpXCIsXG4gICAgXCLms7BcIixcbiAgICBcIuW5vFwiLFxuICAgIFwi5bu3XCIsXG4gICAgXCLlsIpcIixcbiAgICBcIueql1wiLFxuICAgIFwi57axXCIsXG4gICAgXCLlvIRcIixcbiAgICBcIumauFwiLFxuICAgIFwi55aRXCIsXG4gICAgXCLmsI9cIixcbiAgICBcIuWurlwiLFxuICAgIFwi5aeQXCIsXG4gICAgXCLpnIdcIixcbiAgICBcIueRnlwiLFxuICAgIFwi5oCqXCIsXG4gICAgXCLlsKRcIixcbiAgICBcIueQtFwiLFxuICAgIFwi5b6qXCIsXG4gICAgXCLmj49cIixcbiAgICBcIuiGnFwiLFxuICAgIFwi6YGVXCIsXG4gICAgXCLlpL5cIixcbiAgICBcIuiFsFwiLFxuICAgIFwi57ejXCIsXG4gICAgXCLnj6BcIixcbiAgICBcIueqrlwiLFxuICAgIFwi5qOuXCIsXG4gICAgXCLmnp1cIixcbiAgICBcIueruVwiLFxuICAgIFwi5rqdXCIsXG4gICAgXCLlgqxcIixcbiAgICBcIue5qVwiLFxuICAgIFwi5oa2XCIsXG4gICAgXCLpgqZcIixcbiAgICBcIuWJqVwiLFxuICAgIFwi5bm4XCIsXG4gICAgXCLmvL9cIixcbiAgICBcIuashFwiLFxuICAgIFwi5pOBXCIsXG4gICAgXCLniZlcIixcbiAgICBcIuiyr1wiLFxuICAgIFwi56auXCIsXG4gICAgXCLmv75cIixcbiAgICBcIumIiVwiLFxuICAgIFwi57SLXCIsXG4gICAgXCLnvbdcIixcbiAgICBcIuaLjVwiLFxuICAgIFwi5ZKxXCIsXG4gICAgXCLllopcIixcbiAgICBcIuiillwiLFxuICAgIFwi5Z+DXCIsXG4gICAgXCLli6RcIixcbiAgICBcIue9sFwiLFxuICAgIFwi54SmXCIsXG4gICAgXCLmvZtcIixcbiAgICBcIuS8jVwiLFxuICAgIFwi5aKoXCIsXG4gICAgXCLmrLJcIixcbiAgICBcIue4q1wiLFxuICAgIFwi5aeTXCIsXG4gICAgXCLliIpcIixcbiAgICBcIumjvVwiLFxuICAgIFwi5Lu/XCIsXG4gICAgXCLnjY5cIixcbiAgICBcIumLgVwiLFxuICAgIFwi6ay8XCIsXG4gICAgXCLpupdcIixcbiAgICBcIui3qFwiLFxuICAgIFwi6buYXCIsXG4gICAgXCLmjJZcIixcbiAgICBcIumPiFwiLFxuICAgIFwi5o6DXCIsXG4gICAgXCLllp1cIixcbiAgICBcIuiii1wiLFxuICAgIFwi54KtXCIsXG4gICAgXCLmsaFcIixcbiAgICBcIuW5lVwiLFxuICAgIFwi6Ku4XCIsXG4gICAgXCLlvKdcIixcbiAgICBcIuWLtVwiLFxuICAgIFwi5qKFXCIsXG4gICAgXCLlpbZcIixcbiAgICBcIua9lFwiLFxuICAgIFwi54G9XCIsXG4gICAgXCLoiJ9cIixcbiAgICBcIumRkVwiLFxuICAgIFwi6IuvXCIsXG4gICAgXCLoqJ9cIixcbiAgICBcIuaKsVwiLFxuICAgIFwi5q+AXCIsXG4gICAgXCLmh4JcIixcbiAgICBcIuWvklwiLFxuICAgIFwi5pm6XCIsXG4gICAgXCLln5RcIixcbiAgICBcIuWvhFwiLFxuICAgIFwi5bGGXCIsXG4gICAgXCLouo1cIixcbiAgICBcIua4oVwiLFxuICAgIFwi5oyRXCIsXG4gICAgXCLkuLlcIixcbiAgICBcIuiJsVwiLFxuICAgIFwi6LKdXCIsXG4gICAgXCLnorBcIixcbiAgICBcIuaLlFwiLFxuICAgIFwi54i5XCIsXG4gICAgXCLmiLRcIixcbiAgICBcIueivFwiLFxuICAgIFwi5aSiXCIsXG4gICAgXCLoir1cIixcbiAgICBcIueGlFwiLFxuICAgIFwi6LWkXCIsXG4gICAgXCLmvIFcIixcbiAgICBcIuWTrVwiLFxuICAgIFwi5pWsXCIsXG4gICAgXCLpoYZcIixcbiAgICBcIuWllFwiLFxuICAgIFwi6YmbXCIsXG4gICAgXCLku7JcIixcbiAgICBcIuiZjlwiLFxuICAgIFwi56iAXCIsXG4gICAgXCLlprlcIixcbiAgICBcIuS5j1wiLFxuICAgIFwi54+NXCIsXG4gICAgXCLnlLNcIixcbiAgICBcIuahjFwiLFxuICAgIFwi6YG1XCIsXG4gICAgXCLlhYFcIixcbiAgICBcIumahlwiLFxuICAgIFwi6J66XCIsXG4gICAgXCLlgIlcIixcbiAgICBcIumtj1wiLFxuICAgIFwi6YqzXCIsXG4gICAgXCLmm4lcIixcbiAgICBcIuawrlwiLFxuICAgIFwi5YW8XCIsXG4gICAgXCLpmrFcIixcbiAgICBcIuekmVwiLFxuICAgIFwi6LWrXCIsXG4gICAgXCLmkqVcIixcbiAgICBcIuW/oFwiLFxuICAgIFwi6IKFXCIsXG4gICAgXCLnvLhcIixcbiAgICBcIueJvVwiLFxuICAgIFwi5pC2XCIsXG4gICAgXCLljZpcIixcbiAgICBcIuW3p1wiLFxuICAgIFwi5q68XCIsXG4gICAgXCLlhYRcIixcbiAgICBcIuadnFwiLFxuICAgIFwi6KiKXCIsXG4gICAgXCLoqqBcIixcbiAgICBcIueip1wiLFxuICAgIFwi56WlXCIsXG4gICAgXCLmn69cIixcbiAgICBcIumggVwiLFxuICAgIFwi5behXCIsXG4gICAgXCLnn6lcIixcbiAgICBcIuaCslwiLFxuICAgIFwi54GMXCIsXG4gICAgXCLpvaFcIixcbiAgICBcIuWAq1wiLFxuICAgIFwi56WoXCIsXG4gICAgXCLlsItcIixcbiAgICBcIuahglwiLFxuICAgIFwi6YuqXCIsXG4gICAgXCLogZZcIixcbiAgICBcIuaBkFwiLFxuICAgIFwi5oGwXCIsXG4gICAgXCLphK1cIixcbiAgICBcIui2o1wiLFxuICAgIFwi5oqsXCIsXG4gICAgXCLojZJcIixcbiAgICBcIumosFwiLFxuICAgIFwi6LK8XCIsXG4gICAgXCLmn5RcIixcbiAgICBcIua7tFwiLFxuICAgIFwi54ybXCIsXG4gICAgXCLpl4pcIixcbiAgICBcIui8m1wiLFxuICAgIFwi5aa7XCIsXG4gICAgXCLloatcIixcbiAgICBcIuaSpFwiLFxuICAgIFwi5YSyXCIsXG4gICAgXCLnsL1cIixcbiAgICBcIumsp1wiLFxuICAgIFwi5pO+XCIsXG4gICAgXCLntKtcIixcbiAgICBcIuegglwiLFxuICAgIFwi6YGeXCIsXG4gICAgXCLmiLJcIixcbiAgICBcIuWQilwiLFxuICAgIFwi6Zm2XCIsXG4gICAgXCLkvJBcIixcbiAgICBcIumktVwiLFxuICAgIFwi55mCXCIsXG4gICAgXCLnk7ZcIixcbiAgICBcIuWphlwiLFxuICAgIFwi5pKrXCIsXG4gICAgXCLoh4JcIixcbiAgICBcIuaRuFwiLFxuICAgIFwi5b+NXCIsXG4gICAgXCLonaZcIixcbiAgICBcIuign1wiLFxuICAgIFwi6YSwXCIsXG4gICAgXCLog7hcIixcbiAgICBcIumej1wiLFxuICAgIFwi5pOgXCIsXG4gICAgXCLlgbZcIixcbiAgICBcIuajhFwiLFxuICAgIFwi5qe9XCIsXG4gICAgXCLli4FcIixcbiAgICBcIuS5s1wiLFxuICAgIFwi6YSnXCIsXG4gICAgXCLlkIlcIixcbiAgICBcIuS7gVwiLFxuICAgIFwi54ibXCIsXG4gICAgXCLno5pcIixcbiAgICBcIuenn1wiLFxuICAgIFwi54OPXCIsXG4gICAgXCLoiaZcIixcbiAgICBcIuS8tFwiLFxuICAgIFwi55OcXCIsXG4gICAgXCLmt7pcIixcbiAgICBcIuS4mVwiLFxuICAgIFwi5pqrXCIsXG4gICAgXCLnh6VcIixcbiAgICBcIuapoVwiLFxuICAgIFwi5p+zXCIsXG4gICAgXCLov7dcIixcbiAgICBcIuaallwiLFxuICAgIFwi54mMXCIsXG4gICAgXCLnp6dcIixcbiAgICBcIuiGvVwiLFxuICAgIFwi6KmzXCIsXG4gICAgXCLnsKdcIixcbiAgICBcIui4j1wiLFxuICAgIFwi55O3XCIsXG4gICAgXCLorZxcIixcbiAgICBcIuWRhlwiLFxuICAgIFwi6LOTXCIsXG4gICAgXCLns4pcIixcbiAgICBcIua0m1wiLFxuICAgIFwi6LydXCIsXG4gICAgXCLmhqRcIixcbiAgICBcIuertlwiLFxuICAgIFwi6ZqZXCIsXG4gICAgXCLmgJJcIixcbiAgICBcIueymFwiLFxuICAgIFwi5LmDXCIsXG4gICAgXCLnt5JcIixcbiAgICBcIuiCqVwiLFxuICAgIFwi57GNXCIsXG4gICAgXCLmlY9cIixcbiAgICBcIuWhl1wiLFxuICAgIFwi54aZXCIsXG4gICAgXCLnmoZcIixcbiAgICBcIuWBtVwiLFxuICAgIFwi5oe4XCIsXG4gICAgXCLmjphcIixcbiAgICBcIuS6q1wiLFxuICAgIFwi57O+XCIsXG4gICAgXCLphpJcIixcbiAgICBcIueLglwiLFxuICAgIFwi6Y6WXCIsXG4gICAgXCLmt4BcIixcbiAgICBcIuaBqFwiLFxuICAgIFwi54myXCIsXG4gICAgXCLpnLhcIixcbiAgICBcIueIrFwiLFxuICAgIFwi6LOeXCIsXG4gICAgXCLpgIZcIixcbiAgICBcIueOqVwiLFxuICAgIFwi6Zm1XCIsXG4gICAgXCLnpZ1cIixcbiAgICBcIuenklwiLFxuICAgIFwi5rWZXCIsXG4gICAgXCLosoxcIixcbiAgICBcIuW9uVwiLFxuICAgIFwi5b28XCIsXG4gICAgXCLmgolcIixcbiAgICBcIum0qFwiLFxuICAgIFwi6LaoXCIsXG4gICAgXCLps7NcIixcbiAgICBcIuaZqFwiLFxuICAgIFwi55WcXCIsXG4gICAgXCLovKlcIixcbiAgICBcIuenqVwiLFxuICAgIFwi5Y21XCIsXG4gICAgXCLnvbJcIixcbiAgICBcIuair1wiLFxuICAgIFwi54KOXCIsXG4gICAgXCLngZhcIixcbiAgICBcIuaji1wiLFxuICAgIFwi6amFXCIsXG4gICAgXCLnr6lcIixcbiAgICBcIuWzvVwiLFxuICAgIFwi5YaSXCIsXG4gICAgXCLllaVcIixcbiAgICBcIuWjvVwiLFxuICAgIFwi6K2vXCIsXG4gICAgXCLmtbhcIixcbiAgICBcIuaziVwiLFxuICAgIFwi5bi9XCIsXG4gICAgXCLpgbJcIixcbiAgICBcIuefvVwiLFxuICAgIFwi55aGXCIsXG4gICAgXCLosrhcIixcbiAgICBcIua8j1wiLFxuICAgIFwi56i/XCIsXG4gICAgXCLlhqBcIixcbiAgICBcIuWrqVwiLFxuICAgIFwi6ISFXCIsXG4gICAgXCLoiq9cIixcbiAgICBcIueJolwiLFxuICAgIFwi5Y+bXCIsXG4gICAgXCLonZVcIixcbiAgICBcIuWlp1wiLFxuICAgIFwi6bO0XCIsXG4gICAgXCLltrpcIixcbiAgICBcIue+ilwiLFxuICAgIFwi5oaRXCIsXG4gICAgXCLkuLJcIixcbiAgICBcIuWhmFwiLFxuICAgIFwi57mqXCIsXG4gICAgXCLphbVcIixcbiAgICBcIuiejVwiLFxuICAgIFwi55uGXCIsXG4gICAgXCLpjKtcIixcbiAgICBcIuW7n1wiLFxuICAgIFwi57GMXCIsXG4gICAgXCLlh41cIixcbiAgICBcIui8lFwiLFxuICAgIFwi5pSdXCIsXG4gICAgXCLopbJcIixcbiAgICBcIueti1wiLFxuICAgIFwi5ouSXCIsXG4gICAgXCLlg5pcIixcbiAgICBcIuaXsVwiLFxuICAgIFwi6YmAXCIsXG4gICAgXCLps6VcIixcbiAgICBcIua8hlwiLFxuICAgIFwi5rKIXCIsXG4gICAgXCLnnIlcIixcbiAgICBcIueWj1wiLFxuICAgIFwi5re7XCIsXG4gICAgXCLmo5JcIixcbiAgICBcIuepl1wiLFxuICAgIFwi56GdXCIsXG4gICAgXCLpn5NcIixcbiAgICBcIumAvFwiLFxuICAgIFwi5omtXCIsXG4gICAgXCLlg5FcIixcbiAgICBcIua2vFwiLFxuICAgIFwi5oy6XCIsXG4gICAgXCLnopdcIixcbiAgICBcIuagvVwiLFxuICAgIFwi54KSXCIsXG4gICAgXCLmna9cIixcbiAgICBcIuaCo1wiLFxuICAgIFwi6aS+XCIsXG4gICAgXCLli7hcIixcbiAgICBcIuixqlwiLFxuICAgIFwi6YG8XCIsXG4gICAgXCLli4NcIixcbiAgICBcIum0u1wiLFxuICAgIFwi5pemXCIsXG4gICAgXCLlkI9cIixcbiAgICBcIuaLnFwiLFxuICAgIFwi54uXXCIsXG4gICAgXCLln4tcIixcbiAgICBcIui8pVwiLFxuICAgIFwi5o6pXCIsXG4gICAgXCLpo7JcIixcbiAgICBcIuaQrFwiLFxuICAgIFwi5721XCIsXG4gICAgXCLovq1cIixcbiAgICBcIuWLvlwiLFxuICAgIFwi5omjXCIsXG4gICAgXCLkvLBcIixcbiAgICBcIuiUo1wiLFxuICAgIFwi57WoXCIsXG4gICAgXCLpnKdcIixcbiAgICBcIuS4iFwiLFxuICAgIFwi5py1XCIsXG4gICAgXCLlp4ZcIixcbiAgICBcIuaTrFwiLFxuICAgIFwi5a6HXCIsXG4gICAgXCLovK9cIixcbiAgICBcIumZnVwiLFxuICAgIFwi6ZuVXCIsXG4gICAgXCLlhJ9cIixcbiAgICBcIuiThFwiLFxuICAgIFwi5bSHXCIsXG4gICAgXCLliapcIixcbiAgICBcIuWAoVwiLFxuICAgIFwi5buzXCIsXG4gICAgXCLlkqxcIixcbiAgICBcIumnm1wiLFxuICAgIFwi6JavXCIsXG4gICAgXCLliLdcIixcbiAgICBcIuaWpVwiLFxuICAgIFwi55WqXCIsXG4gICAgXCLos6ZcIixcbiAgICBcIuWliVwiLFxuICAgIFwi5L2bXCIsXG4gICAgXCLmvoZcIixcbiAgICBcIua8q1wiLFxuICAgIFwi5pu8XCIsXG4gICAgXCLmiYdcIixcbiAgICBcIumIo1wiLFxuICAgIFwi5qGDXCIsXG4gICAgXCLmibZcIixcbiAgICBcIuS7lFwiLFxuICAgIFwi6L+UXCIsXG4gICAgXCLkv5dcIixcbiAgICBcIuiZp1wiLFxuICAgIFwi6IWUXCIsXG4gICAgXCLpnotcIixcbiAgICBcIuajsVwiLFxuICAgIFwi6KaGXCIsXG4gICAgXCLmoYZcIixcbiAgICBcIuaChFwiLFxuICAgIFwi5Y+UXCIsXG4gICAgXCLmkp5cIixcbiAgICBcIumomVwiLFxuICAgIFwi5YuYXCIsXG4gICAgXCLml7pcIixcbiAgICBcIuayuFwiLFxuICAgIFwi5a2kXCIsXG4gICAgXCLlkJBcIixcbiAgICBcIuWtn1wiLFxuICAgIFwi5rigXCIsXG4gICAgXCLlsYhcIixcbiAgICBcIueWvlwiLFxuICAgIFwi5aaZXCIsXG4gICAgXCLmg5xcIixcbiAgICBcIuS7sFwiLFxuICAgIFwi54ugXCIsXG4gICAgXCLohLlcIixcbiAgICBcIuirp1wiLFxuICAgIFwi5ouLXCIsXG4gICAgXCLpu7RcIixcbiAgICBcIuahkVwiLFxuICAgIFwi5bSXXCIsXG4gICAgXCLlmJtcIixcbiAgICBcIuihsFwiLFxuICAgIFwi55ucXCIsXG4gICAgXCLmu7JcIixcbiAgICBcIuiHn1wiLFxuICAgIFwi6LO0XCIsXG4gICAgXCLmuadcIixcbiAgICBcIueUnFwiLFxuICAgIFwi5pu5XCIsXG4gICAgXCLplrFcIixcbiAgICBcIuiCjFwiLFxuICAgIFwi5ZOpXCIsXG4gICAgXCLljrJcIixcbiAgICBcIueDtFwiLFxuICAgIFwi57evXCIsXG4gICAgXCLmr4VcIixcbiAgICBcIuaYqFwiLFxuICAgIFwi5YG9XCIsXG4gICAgXCLnl4dcIixcbiAgICBcIueFrlwiLFxuICAgIFwi5ZiGXCIsXG4gICAgXCLph5hcIixcbiAgICBcIuaQrVwiLFxuICAgIFwi6I6WXCIsXG4gICAgXCLnsaBcIixcbiAgICBcIumFt1wiLFxuICAgIFwi5YG3XCIsXG4gICAgXCLlvJNcIixcbiAgICBcIumMkFwiLFxuICAgIFwi5oGGXCIsXG4gICAgXCLlgpFcIixcbiAgICBcIuWdkVwiLFxuICAgIFwi6by7XCIsXG4gICAgXCLnv7xcIixcbiAgICBcIue2uFwiLFxuICAgIFwi5pWYXCIsXG4gICAgXCLnjYRcIixcbiAgICBcIumArlwiLFxuICAgIFwi572QXCIsXG4gICAgXCLntaFcIixcbiAgICBcIuajmlwiLFxuICAgIFwi5oqRXCIsXG4gICAgXCLohqhcIixcbiAgICBcIuiUrFwiLFxuICAgIFwi5a+6XCIsXG4gICAgXCLpqZ9cIixcbiAgICBcIuephlwiLFxuICAgIFwi5Ya2XCIsXG4gICAgXCLmnq9cIixcbiAgICBcIuWGilwiLFxuICAgIFwi5bGNXCIsXG4gICAgXCLlh7hcIixcbiAgICBcIue0s1wiLFxuICAgIFwi5Z2vXCIsXG4gICAgXCLniqdcIixcbiAgICBcIueEsFwiLFxuICAgIFwi6L2fXCIsXG4gICAgXCLmrKNcIixcbiAgICBcIuaZiVwiLFxuICAgIFwi55imXCIsXG4gICAgXCLnpqZcIixcbiAgICBcIumMoFwiLFxuICAgIFwi6YymXCIsXG4gICAgXCLllqpcIixcbiAgICBcIuaXrFwiLFxuICAgIFwi6Y2bXCIsXG4gICAgXCLlo59cIixcbiAgICBcIuaQnFwiLFxuICAgIFwi5pKyXCIsXG4gICAgXCLpgoBcIixcbiAgICBcIuS6rVwiLFxuICAgIFwi6YWvXCIsXG4gICAgXCLpgoFcIixcbiAgICBcIuiIklwiLFxuICAgIFwi6ISGXCIsXG4gICAgXCLphbZcIixcbiAgICBcIumWklwiLFxuICAgIFwi5oaCXCIsXG4gICAgXCLphZpcIixcbiAgICBcIumgkVwiLFxuICAgIFwi5769XCIsXG4gICAgXCLmvLJcIixcbiAgICBcIuWNuFwiLFxuICAgIFwi5LuXXCIsXG4gICAgXCLpmapcIixcbiAgICBcIumXolwiLFxuICAgIFwi5oeyXCIsXG4gICAgXCLmna1cIixcbiAgICBcIuWnmlwiLFxuICAgIFwi6IKaXCIsXG4gICAgXCLmjYlcIixcbiAgICBcIumjhFwiLFxuICAgIFwi5ryCXCIsXG4gICAgXCLmmIZcIixcbiAgICBcIuasulwiLFxuICAgIFwi5ZC+XCIsXG4gICAgXCLpg45cIixcbiAgICBcIueDt1wiLFxuICAgIFwi5rGBXCIsXG4gICAgXCLlkbVcIixcbiAgICBcIumjvlwiLFxuICAgIFwi6JWtXCIsXG4gICAgXCLpm4VcIixcbiAgICBcIumDtVwiLFxuICAgIFwi6YG3XCIsXG4gICAgXCLnh5VcIixcbiAgICBcIuaSklwiLFxuICAgIFwi5ae7XCIsXG4gICAgXCLotbRcIixcbiAgICBcIuWutFwiLFxuICAgIFwi54WpXCIsXG4gICAgXCLlgrVcIixcbiAgICBcIuW4s1wiLFxuICAgIFwi5paRXCIsXG4gICAgXCLpiLRcIixcbiAgICBcIuaXqFwiLFxuICAgIFwi6YaHXCIsXG4gICAgXCLokaNcIixcbiAgICBcIumkhVwiLFxuICAgIFwi6ZubXCIsXG4gICAgXCLlp79cIixcbiAgICBcIuaLjFwiLFxuICAgIFwi5YKFXCIsXG4gICAgXCLohblcIixcbiAgICBcIuWmpVwiLFxuICAgIFwi5o+JXCIsXG4gICAgXCLos6JcIixcbiAgICBcIuaLhlwiLFxuICAgIFwi5q2qXCIsXG4gICAgXCLokaFcIixcbiAgICBcIuiDulwiLFxuICAgIFwi5LifXCIsXG4gICAgXCLmtalcIixcbiAgICBcIuW+vVwiLFxuICAgIFwi5piCXCIsXG4gICAgXCLloopcIixcbiAgICBcIuaTi1wiLFxuICAgIFwi6Ka9XCIsXG4gICAgXCLosqpcIixcbiAgICBcIuaFsFwiLFxuICAgIFwi57mzXCIsXG4gICAgXCLmsapcIixcbiAgICBcIuaFjFwiLFxuICAgIFwi6aauXCIsXG4gICAgXCLoq75cIixcbiAgICBcIuWnnFwiLFxuICAgIFwi6Kq8XCIsXG4gICAgXCLlhYdcIixcbiAgICBcIuWKo1wiLFxuICAgIFwi6KqjXCIsXG4gICAgXCLogIBcIixcbiAgICBcIuaYj1wiLFxuICAgIFwi6Lq6XCIsXG4gICAgXCLnm4hcIixcbiAgICBcIumojlwiLFxuICAgIFwi5ZasXCIsXG4gICAgXCLmuqpcIixcbiAgICBcIuWPolwiLFxuICAgIFwi55unXCIsXG4gICAgXCLmirlcIixcbiAgICBcIuaCtlwiLFxuICAgIFwi6KuuXCIsXG4gICAgXCLliK5cIixcbiAgICBcIumnlVwiLFxuICAgIFwi57qcXCIsXG4gICAgXCLmgp9cIixcbiAgICBcIuaRmFwiLFxuICAgIFwi6Ym6XCIsXG4gICAgXCLmk7JcIixcbiAgICBcIumgl1wiLFxuICAgIFwi5bm7XCIsXG4gICAgXCLmn4RcIixcbiAgICBcIuaDoFwiLFxuICAgIFwi5oWYXCIsXG4gICAgXCLkvbNcIixcbiAgICBcIuS7h1wiLFxuICAgIFwi6IeYXCIsXG4gICAgXCLnqqlcIixcbiAgICBcIua7jFwiLFxuICAgIFwi5YqNXCIsXG4gICAgXCLnnqdcIixcbiAgICBcIuWgoVwiLFxuICAgIFwi5r2RXCIsXG4gICAgXCLolKVcIixcbiAgICBcIue9qVwiLFxuICAgIFwi6ZyNXCIsXG4gICAgXCLmkohcIixcbiAgICBcIuiDjlwiLFxuICAgIFwi6JK8XCIsXG4gICAgXCLmv7FcIixcbiAgICBcIuWAhlwiLFxuICAgIFwi5o2FXCIsXG4gICAgXCLmuZhcIixcbiAgICBcIuegjVwiLFxuICAgIFwi6ZyeXCIsXG4gICAgXCLpgrVcIixcbiAgICBcIuiQhFwiLFxuICAgIFwi55iLXCIsXG4gICAgXCLmt65cIixcbiAgICBcIumBglwiLFxuICAgIFwi54aKXCIsXG4gICAgXCLns55cIixcbiAgICBcIueDmFwiLFxuICAgIFwi5a6/XCIsXG4gICAgXCLmqpRcIixcbiAgICBcIuaIiFwiLFxuICAgIFwi6aeBXCIsXG4gICAgXCLlq4JcIixcbiAgICBcIuijlVwiLFxuICAgIFwi5b6ZXCIsXG4gICAgXCLnrq1cIixcbiAgICBcIuaNkFwiLFxuICAgIFwi6IW4XCIsXG4gICAgXCLmkpBcIixcbiAgICBcIuabrFwiLFxuICAgIFwi6L6oXCIsXG4gICAgXCLmrr9cIixcbiAgICBcIuiTrlwiLFxuICAgIFwi5pSkXCIsXG4gICAgXCLmlKpcIixcbiAgICBcIumGrFwiLFxuICAgIFwi5bGPXCIsXG4gICAgXCLnlqtcIixcbiAgICBcIuWTgFwiLFxuICAgIFwi6JShXCIsXG4gICAgXCLloLVcIixcbiAgICBcIuayq1wiLFxuICAgIFwi55q6XCIsXG4gICAgXCLmmqJcIixcbiAgICBcIueWilwiLFxuICAgIFwi6ZajXCIsXG4gICAgXCLokIpcIixcbiAgICBcIuaVslwiLFxuICAgIFwi6L2EXCIsXG4gICAgXCLpiaRcIixcbiAgICBcIueXlVwiLFxuICAgIFwi5aOpXCIsXG4gICAgXCLlt7dcIixcbiAgICBcIumkk1wiLFxuICAgIFwi56aNXCIsXG4gICAgXCLkuJhcIixcbiAgICBcIueOhFwiLFxuICAgIFwi5rqcXCIsXG4gICAgXCLmm7BcIixcbiAgICBcIumCj1wiLFxuICAgIFwi5b2tXCIsXG4gICAgXCLlmJdcIixcbiAgICBcIuWNv1wiLFxuICAgIFwi5aaoXCIsXG4gICAgXCLoiYdcIixcbiAgICBcIuWQnlwiLFxuICAgIFwi6Z+LXCIsXG4gICAgXCLmgKhcIixcbiAgICBcIuefrlwiLFxuICAgIFwi5q2HXCJcbl1cbiIsIm1vZHVsZS5leHBvcnRzPVtcbiAgICBcImHMgWJhY29cIixcbiAgICBcImFiZG9tZW5cIixcbiAgICBcImFiZWphXCIsXG4gICAgXCJhYmllcnRvXCIsXG4gICAgXCJhYm9nYWRvXCIsXG4gICAgXCJhYm9ub1wiLFxuICAgIFwiYWJvcnRvXCIsXG4gICAgXCJhYnJhem9cIixcbiAgICBcImFicmlyXCIsXG4gICAgXCJhYnVlbG9cIixcbiAgICBcImFidXNvXCIsXG4gICAgXCJhY2FiYXJcIixcbiAgICBcImFjYWRlbWlhXCIsXG4gICAgXCJhY2Nlc29cIixcbiAgICBcImFjY2lvzIFuXCIsXG4gICAgXCJhY2VpdGVcIixcbiAgICBcImFjZWxnYVwiLFxuICAgIFwiYWNlbnRvXCIsXG4gICAgXCJhY2VwdGFyXCIsXG4gICAgXCJhzIFjaWRvXCIsXG4gICAgXCJhY2xhcmFyXCIsXG4gICAgXCJhY25lzIFcIixcbiAgICBcImFjb2dlclwiLFxuICAgIFwiYWNvc29cIixcbiAgICBcImFjdGl2b1wiLFxuICAgIFwiYWN0b1wiLFxuICAgIFwiYWN0cml6XCIsXG4gICAgXCJhY3R1YXJcIixcbiAgICBcImFjdWRpclwiLFxuICAgIFwiYWN1ZXJkb1wiLFxuICAgIFwiYWN1c2FyXCIsXG4gICAgXCJhZGljdG9cIixcbiAgICBcImFkbWl0aXJcIixcbiAgICBcImFkb3B0YXJcIixcbiAgICBcImFkb3Jub1wiLFxuICAgIFwiYWR1YW5hXCIsXG4gICAgXCJhZHVsdG9cIixcbiAgICBcImFlzIFyZW9cIixcbiAgICBcImFmZWN0YXJcIixcbiAgICBcImFmaWNpb8yBblwiLFxuICAgIFwiYWZpbmFyXCIsXG4gICAgXCJhZmlybWFyXCIsXG4gICAgXCJhzIFnaWxcIixcbiAgICBcImFnaXRhclwiLFxuICAgIFwiYWdvbmnMgWFcIixcbiAgICBcImFnb3N0b1wiLFxuICAgIFwiYWdvdGFyXCIsXG4gICAgXCJhZ3JlZ2FyXCIsXG4gICAgXCJhZ3Jpb1wiLFxuICAgIFwiYWd1YVwiLFxuICAgIFwiYWd1ZG9cIixcbiAgICBcImHMgWd1aWxhXCIsXG4gICAgXCJhZ3VqYVwiLFxuICAgIFwiYWhvZ29cIixcbiAgICBcImFob3Jyb1wiLFxuICAgIFwiYWlyZVwiLFxuICAgIFwiYWlzbGFyXCIsXG4gICAgXCJhamVkcmV6XCIsXG4gICAgXCJhamVub1wiLFxuICAgIFwiYWp1c3RlXCIsXG4gICAgXCJhbGFjcmHMgW5cIixcbiAgICBcImFsYW1icmVcIixcbiAgICBcImFsYXJtYVwiLFxuICAgIFwiYWxiYVwiLFxuICAgIFwiYcyBbGJ1bVwiLFxuICAgIFwiYWxjYWxkZVwiLFxuICAgIFwiYWxkZWFcIixcbiAgICBcImFsZWdyZVwiLFxuICAgIFwiYWxlamFyXCIsXG4gICAgXCJhbGVydGFcIixcbiAgICBcImFsZXRhXCIsXG4gICAgXCJhbGZpbGVyXCIsXG4gICAgXCJhbGdhXCIsXG4gICAgXCJhbGdvZG/MgW5cIixcbiAgICBcImFsaWFkb1wiLFxuICAgIFwiYWxpZW50b1wiLFxuICAgIFwiYWxpdmlvXCIsXG4gICAgXCJhbG1hXCIsXG4gICAgXCJhbG1lamFcIixcbiAgICBcImFsbWnMgWJhclwiLFxuICAgIFwiYWx0YXJcIixcbiAgICBcImFsdGV6YVwiLFxuICAgIFwiYWx0aXZvXCIsXG4gICAgXCJhbHRvXCIsXG4gICAgXCJhbHR1cmFcIixcbiAgICBcImFsdW1ub1wiLFxuICAgIFwiYWx6YXJcIixcbiAgICBcImFtYWJsZVwiLFxuICAgIFwiYW1hbnRlXCIsXG4gICAgXCJhbWFwb2xhXCIsXG4gICAgXCJhbWFyZ29cIixcbiAgICBcImFtYXNhclwiLFxuICAgIFwiYcyBbWJhclwiLFxuICAgIFwiYcyBbWJpdG9cIixcbiAgICBcImFtZW5vXCIsXG4gICAgXCJhbWlnb1wiLFxuICAgIFwiYW1pc3RhZFwiLFxuICAgIFwiYW1vclwiLFxuICAgIFwiYW1wYXJvXCIsXG4gICAgXCJhbXBsaW9cIixcbiAgICBcImFuY2hvXCIsXG4gICAgXCJhbmNpYW5vXCIsXG4gICAgXCJhbmNsYVwiLFxuICAgIFwiYW5kYXJcIixcbiAgICBcImFuZGXMgW5cIixcbiAgICBcImFuZW1pYVwiLFxuICAgIFwiYcyBbmd1bG9cIixcbiAgICBcImFuaWxsb1wiLFxuICAgIFwiYcyBbmltb1wiLFxuICAgIFwiYW5pzIFzXCIsXG4gICAgXCJhbm90YXJcIixcbiAgICBcImFudGVuYVwiLFxuICAgIFwiYW50aWd1b1wiLFxuICAgIFwiYW50b2pvXCIsXG4gICAgXCJhbnVhbFwiLFxuICAgIFwiYW51bGFyXCIsXG4gICAgXCJhbnVuY2lvXCIsXG4gICAgXCJhbsyDYWRpclwiLFxuICAgIFwiYW7Mg2Vqb1wiLFxuICAgIFwiYW7Mg29cIixcbiAgICBcImFwYWdhclwiLFxuICAgIFwiYXBhcmF0b1wiLFxuICAgIFwiYXBldGl0b1wiLFxuICAgIFwiYXBpb1wiLFxuICAgIFwiYXBsaWNhclwiLFxuICAgIFwiYXBvZG9cIixcbiAgICBcImFwb3J0ZVwiLFxuICAgIFwiYXBveW9cIixcbiAgICBcImFwcmVuZGVyXCIsXG4gICAgXCJhcHJvYmFyXCIsXG4gICAgXCJhcHVlc3RhXCIsXG4gICAgXCJhcHVyb1wiLFxuICAgIFwiYXJhZG9cIixcbiAgICBcImFyYW7Mg2FcIixcbiAgICBcImFyYXJcIixcbiAgICBcImHMgXJiaXRyb1wiLFxuICAgIFwiYcyBcmJvbFwiLFxuICAgIFwiYXJidXN0b1wiLFxuICAgIFwiYXJjaGl2b1wiLFxuICAgIFwiYXJjb1wiLFxuICAgIFwiYXJkZXJcIixcbiAgICBcImFyZGlsbGFcIixcbiAgICBcImFyZHVvXCIsXG4gICAgXCJhzIFyZWFcIixcbiAgICBcImHMgXJpZG9cIixcbiAgICBcImFyaWVzXCIsXG4gICAgXCJhcm1vbmnMgWFcIixcbiAgICBcImFybmXMgXNcIixcbiAgICBcImFyb21hXCIsXG4gICAgXCJhcnBhXCIsXG4gICAgXCJhcnBvzIFuXCIsXG4gICAgXCJhcnJlZ2xvXCIsXG4gICAgXCJhcnJvelwiLFxuICAgIFwiYXJydWdhXCIsXG4gICAgXCJhcnRlXCIsXG4gICAgXCJhcnRpc3RhXCIsXG4gICAgXCJhc2FcIixcbiAgICBcImFzYWRvXCIsXG4gICAgXCJhc2FsdG9cIixcbiAgICBcImFzY2Vuc29cIixcbiAgICBcImFzZWd1cmFyXCIsXG4gICAgXCJhc2VvXCIsXG4gICAgXCJhc2Vzb3JcIixcbiAgICBcImFzaWVudG9cIixcbiAgICBcImFzaWxvXCIsXG4gICAgXCJhc2lzdGlyXCIsXG4gICAgXCJhc25vXCIsXG4gICAgXCJhc29tYnJvXCIsXG4gICAgXCJhzIFzcGVyb1wiLFxuICAgIFwiYXN0aWxsYVwiLFxuICAgIFwiYXN0cm9cIixcbiAgICBcImFzdHV0b1wiLFxuICAgIFwiYXN1bWlyXCIsXG4gICAgXCJhc3VudG9cIixcbiAgICBcImF0YWpvXCIsXG4gICAgXCJhdGFxdWVcIixcbiAgICBcImF0YXJcIixcbiAgICBcImF0ZW50b1wiLFxuICAgIFwiYXRlb1wiLFxuICAgIFwiYcyBdGljb1wiLFxuICAgIFwiYXRsZXRhXCIsXG4gICAgXCJhzIF0b21vXCIsXG4gICAgXCJhdHJhZXJcIixcbiAgICBcImF0cm96XCIsXG4gICAgXCJhdHXMgW5cIixcbiAgICBcImF1ZGF6XCIsXG4gICAgXCJhdWRpb1wiLFxuICAgIFwiYXVnZVwiLFxuICAgIFwiYXVsYVwiLFxuICAgIFwiYXVtZW50b1wiLFxuICAgIFwiYXVzZW50ZVwiLFxuICAgIFwiYXV0b3JcIixcbiAgICBcImF2YWxcIixcbiAgICBcImF2YW5jZVwiLFxuICAgIFwiYXZhcm9cIixcbiAgICBcImF2ZVwiLFxuICAgIFwiYXZlbGxhbmFcIixcbiAgICBcImF2ZW5hXCIsXG4gICAgXCJhdmVzdHJ1elwiLFxuICAgIFwiYXZpb8yBblwiLFxuICAgIFwiYXZpc29cIixcbiAgICBcImF5ZXJcIixcbiAgICBcImF5dWRhXCIsXG4gICAgXCJheXVub1wiLFxuICAgIFwiYXphZnJhzIFuXCIsXG4gICAgXCJhemFyXCIsXG4gICAgXCJhem90ZVwiLFxuICAgIFwiYXp1zIFjYXJcIixcbiAgICBcImF6dWZyZVwiLFxuICAgIFwiYXp1bFwiLFxuICAgIFwiYmFiYVwiLFxuICAgIFwiYmFib3JcIixcbiAgICBcImJhY2hlXCIsXG4gICAgXCJiYWhpzIFhXCIsXG4gICAgXCJiYWlsZVwiLFxuICAgIFwiYmFqYXJcIixcbiAgICBcImJhbGFuemFcIixcbiAgICBcImJhbGNvzIFuXCIsXG4gICAgXCJiYWxkZVwiLFxuICAgIFwiYmFtYnXMgVwiLFxuICAgIFwiYmFuY29cIixcbiAgICBcImJhbmRhXCIsXG4gICAgXCJiYW7Mg29cIixcbiAgICBcImJhcmJhXCIsXG4gICAgXCJiYXJjb1wiLFxuICAgIFwiYmFybml6XCIsXG4gICAgXCJiYXJyb1wiLFxuICAgIFwiYmHMgXNjdWxhXCIsXG4gICAgXCJiYXN0b8yBblwiLFxuICAgIFwiYmFzdXJhXCIsXG4gICAgXCJiYXRhbGxhXCIsXG4gICAgXCJiYXRlcmnMgWFcIixcbiAgICBcImJhdGlyXCIsXG4gICAgXCJiYXR1dGFcIixcbiAgICBcImJhdcyBbFwiLFxuICAgIFwiYmF6YXJcIixcbiAgICBcImJlYmXMgVwiLFxuICAgIFwiYmViaWRhXCIsXG4gICAgXCJiZWxsb1wiLFxuICAgIFwiYmVzYXJcIixcbiAgICBcImJlc29cIixcbiAgICBcImJlc3RpYVwiLFxuICAgIFwiYmljaG9cIixcbiAgICBcImJpZW5cIixcbiAgICBcImJpbmdvXCIsXG4gICAgXCJibGFuY29cIixcbiAgICBcImJsb3F1ZVwiLFxuICAgIFwiYmx1c2FcIixcbiAgICBcImJvYVwiLFxuICAgIFwiYm9iaW5hXCIsXG4gICAgXCJib2JvXCIsXG4gICAgXCJib2NhXCIsXG4gICAgXCJib2NpbmFcIixcbiAgICBcImJvZGFcIixcbiAgICBcImJvZGVnYVwiLFxuICAgIFwiYm9pbmFcIixcbiAgICBcImJvbGFcIixcbiAgICBcImJvbGVyb1wiLFxuICAgIFwiYm9sc2FcIixcbiAgICBcImJvbWJhXCIsXG4gICAgXCJib25kYWRcIixcbiAgICBcImJvbml0b1wiLFxuICAgIFwiYm9ub1wiLFxuICAgIFwiYm9uc2HMgWlcIixcbiAgICBcImJvcmRlXCIsXG4gICAgXCJib3JyYXJcIixcbiAgICBcImJvc3F1ZVwiLFxuICAgIFwiYm90ZVwiLFxuICAgIFwiYm90acyBblwiLFxuICAgIFwiYm/MgXZlZGFcIixcbiAgICBcImJvemFsXCIsXG4gICAgXCJicmF2b1wiLFxuICAgIFwiYnJhem9cIixcbiAgICBcImJyZWNoYVwiLFxuICAgIFwiYnJldmVcIixcbiAgICBcImJyaWxsb1wiLFxuICAgIFwiYnJpbmNvXCIsXG4gICAgXCJicmlzYVwiLFxuICAgIFwiYnJvY2FcIixcbiAgICBcImJyb21hXCIsXG4gICAgXCJicm9uY2VcIixcbiAgICBcImJyb3RlXCIsXG4gICAgXCJicnVqYVwiLFxuICAgIFwiYnJ1c2NvXCIsXG4gICAgXCJicnV0b1wiLFxuICAgIFwiYnVjZW9cIixcbiAgICBcImJ1Y2xlXCIsXG4gICAgXCJidWVub1wiLFxuICAgIFwiYnVleVwiLFxuICAgIFwiYnVmYW5kYVwiLFxuICAgIFwiYnVmb8yBblwiLFxuICAgIFwiYnXMgWhvXCIsXG4gICAgXCJidWl0cmVcIixcbiAgICBcImJ1bHRvXCIsXG4gICAgXCJidXJidWphXCIsXG4gICAgXCJidXJsYVwiLFxuICAgIFwiYnVycm9cIixcbiAgICBcImJ1c2NhclwiLFxuICAgIFwiYnV0YWNhXCIsXG4gICAgXCJidXpvzIFuXCIsXG4gICAgXCJjYWJhbGxvXCIsXG4gICAgXCJjYWJlemFcIixcbiAgICBcImNhYmluYVwiLFxuICAgIFwiY2FicmFcIixcbiAgICBcImNhY2FvXCIsXG4gICAgXCJjYWRhzIF2ZXJcIixcbiAgICBcImNhZGVuYVwiLFxuICAgIFwiY2FlclwiLFxuICAgIFwiY2FmZcyBXCIsXG4gICAgXCJjYWnMgWRhXCIsXG4gICAgXCJjYWltYcyBblwiLFxuICAgIFwiY2FqYVwiLFxuICAgIFwiY2Fqb8yBblwiLFxuICAgIFwiY2FsXCIsXG4gICAgXCJjYWxhbWFyXCIsXG4gICAgXCJjYWxjaW9cIixcbiAgICBcImNhbGRvXCIsXG4gICAgXCJjYWxpZGFkXCIsXG4gICAgXCJjYWxsZVwiLFxuICAgIFwiY2FsbWFcIixcbiAgICBcImNhbG9yXCIsXG4gICAgXCJjYWx2b1wiLFxuICAgIFwiY2FtYVwiLFxuICAgIFwiY2FtYmlvXCIsXG4gICAgXCJjYW1lbGxvXCIsXG4gICAgXCJjYW1pbm9cIixcbiAgICBcImNhbXBvXCIsXG4gICAgXCJjYcyBbmNlclwiLFxuICAgIFwiY2FuZGlsXCIsXG4gICAgXCJjYW5lbGFcIixcbiAgICBcImNhbmd1cm9cIixcbiAgICBcImNhbmljYVwiLFxuICAgIFwiY2FudG9cIixcbiAgICBcImNhbsyDYVwiLFxuICAgIFwiY2FuzINvzIFuXCIsXG4gICAgXCJjYW9iYVwiLFxuICAgIFwiY2Fvc1wiLFxuICAgIFwiY2FwYXpcIixcbiAgICBcImNhcGl0YcyBblwiLFxuICAgIFwiY2Fwb3RlXCIsXG4gICAgXCJjYXB0YXJcIixcbiAgICBcImNhcHVjaGFcIixcbiAgICBcImNhcmFcIixcbiAgICBcImNhcmJvzIFuXCIsXG4gICAgXCJjYcyBcmNlbFwiLFxuICAgIFwiY2FyZXRhXCIsXG4gICAgXCJjYXJnYVwiLFxuICAgIFwiY2FyaW7Mg29cIixcbiAgICBcImNhcm5lXCIsXG4gICAgXCJjYXJwZXRhXCIsXG4gICAgXCJjYXJyb1wiLFxuICAgIFwiY2FydGFcIixcbiAgICBcImNhc2FcIixcbiAgICBcImNhc2NvXCIsXG4gICAgXCJjYXNlcm9cIixcbiAgICBcImNhc3BhXCIsXG4gICAgXCJjYXN0b3JcIixcbiAgICBcImNhdG9yY2VcIixcbiAgICBcImNhdHJlXCIsXG4gICAgXCJjYXVkYWxcIixcbiAgICBcImNhdXNhXCIsXG4gICAgXCJjYXpvXCIsXG4gICAgXCJjZWJvbGxhXCIsXG4gICAgXCJjZWRlclwiLFxuICAgIFwiY2Vkcm9cIixcbiAgICBcImNlbGRhXCIsXG4gICAgXCJjZcyBbGVicmVcIixcbiAgICBcImNlbG9zb1wiLFxuICAgIFwiY2XMgWx1bGFcIixcbiAgICBcImNlbWVudG9cIixcbiAgICBcImNlbml6YVwiLFxuICAgIFwiY2VudHJvXCIsXG4gICAgXCJjZXJjYVwiLFxuICAgIFwiY2VyZG9cIixcbiAgICBcImNlcmV6YVwiLFxuICAgIFwiY2Vyb1wiLFxuICAgIFwiY2VycmFyXCIsXG4gICAgXCJjZXJ0ZXphXCIsXG4gICAgXCJjZcyBc3BlZFwiLFxuICAgIFwiY2V0cm9cIixcbiAgICBcImNoYWNhbFwiLFxuICAgIFwiY2hhbGVjb1wiLFxuICAgIFwiY2hhbXB1zIFcIixcbiAgICBcImNoYW5jbGFcIixcbiAgICBcImNoYXBhXCIsXG4gICAgXCJjaGFybGFcIixcbiAgICBcImNoaWNvXCIsXG4gICAgXCJjaGlzdGVcIixcbiAgICBcImNoaXZvXCIsXG4gICAgXCJjaG9xdWVcIixcbiAgICBcImNob3phXCIsXG4gICAgXCJjaHVsZXRhXCIsXG4gICAgXCJjaHVwYXJcIixcbiAgICBcImNpY2xvzIFuXCIsXG4gICAgXCJjaWVnb1wiLFxuICAgIFwiY2llbG9cIixcbiAgICBcImNpZW5cIixcbiAgICBcImNpZXJ0b1wiLFxuICAgIFwiY2lmcmFcIixcbiAgICBcImNpZ2Fycm9cIixcbiAgICBcImNpbWFcIixcbiAgICBcImNpbmNvXCIsXG4gICAgXCJjaW5lXCIsXG4gICAgXCJjaW50YVwiLFxuICAgIFwiY2lwcmXMgXNcIixcbiAgICBcImNpcmNvXCIsXG4gICAgXCJjaXJ1ZWxhXCIsXG4gICAgXCJjaXNuZVwiLFxuICAgIFwiY2l0YVwiLFxuICAgIFwiY2l1ZGFkXCIsXG4gICAgXCJjbGFtb3JcIixcbiAgICBcImNsYW5cIixcbiAgICBcImNsYXJvXCIsXG4gICAgXCJjbGFzZVwiLFxuICAgIFwiY2xhdmVcIixcbiAgICBcImNsaWVudGVcIixcbiAgICBcImNsaW1hXCIsXG4gICAgXCJjbGnMgW5pY2FcIixcbiAgICBcImNvYnJlXCIsXG4gICAgXCJjb2NjaW/MgW5cIixcbiAgICBcImNvY2hpbm9cIixcbiAgICBcImNvY2luYVwiLFxuICAgIFwiY29jb1wiLFxuICAgIFwiY2/MgWRpZ29cIixcbiAgICBcImNvZG9cIixcbiAgICBcImNvZnJlXCIsXG4gICAgXCJjb2dlclwiLFxuICAgIFwiY29oZXRlXCIsXG4gICAgXCJjb2ppzIFuXCIsXG4gICAgXCJjb2pvXCIsXG4gICAgXCJjb2xhXCIsXG4gICAgXCJjb2xjaGFcIixcbiAgICBcImNvbGVnaW9cIixcbiAgICBcImNvbGdhclwiLFxuICAgIFwiY29saW5hXCIsXG4gICAgXCJjb2xsYXJcIixcbiAgICBcImNvbG1vXCIsXG4gICAgXCJjb2x1bW5hXCIsXG4gICAgXCJjb21iYXRlXCIsXG4gICAgXCJjb21lclwiLFxuICAgIFwiY29taWRhXCIsXG4gICAgXCJjb8yBbW9kb1wiLFxuICAgIFwiY29tcHJhXCIsXG4gICAgXCJjb25kZVwiLFxuICAgIFwiY29uZWpvXCIsXG4gICAgXCJjb25nYVwiLFxuICAgIFwiY29ub2NlclwiLFxuICAgIFwiY29uc2Vqb1wiLFxuICAgIFwiY29udGFyXCIsXG4gICAgXCJjb3BhXCIsXG4gICAgXCJjb3BpYVwiLFxuICAgIFwiY29yYXpvzIFuXCIsXG4gICAgXCJjb3JiYXRhXCIsXG4gICAgXCJjb3JjaG9cIixcbiAgICBcImNvcmRvzIFuXCIsXG4gICAgXCJjb3JvbmFcIixcbiAgICBcImNvcnJlclwiLFxuICAgIFwiY29zZXJcIixcbiAgICBcImNvc21vc1wiLFxuICAgIFwiY29zdGFcIixcbiAgICBcImNyYcyBbmVvXCIsXG4gICAgXCJjcmHMgXRlclwiLFxuICAgIFwiY3JlYXJcIixcbiAgICBcImNyZWNlclwiLFxuICAgIFwiY3JlacyBZG9cIixcbiAgICBcImNyZW1hXCIsXG4gICAgXCJjcmnMgWFcIixcbiAgICBcImNyaW1lblwiLFxuICAgIFwiY3JpcHRhXCIsXG4gICAgXCJjcmlzaXNcIixcbiAgICBcImNyb21vXCIsXG4gICAgXCJjcm/MgW5pY2FcIixcbiAgICBcImNyb3F1ZXRhXCIsXG4gICAgXCJjcnVkb1wiLFxuICAgIFwiY3J1elwiLFxuICAgIFwiY3VhZHJvXCIsXG4gICAgXCJjdWFydG9cIixcbiAgICBcImN1YXRyb1wiLFxuICAgIFwiY3Vib1wiLFxuICAgIFwiY3VicmlyXCIsXG4gICAgXCJjdWNoYXJhXCIsXG4gICAgXCJjdWVsbG9cIixcbiAgICBcImN1ZW50b1wiLFxuICAgIFwiY3VlcmRhXCIsXG4gICAgXCJjdWVzdGFcIixcbiAgICBcImN1ZXZhXCIsXG4gICAgXCJjdWlkYXJcIixcbiAgICBcImN1bGVicmFcIixcbiAgICBcImN1bHBhXCIsXG4gICAgXCJjdWx0b1wiLFxuICAgIFwiY3VtYnJlXCIsXG4gICAgXCJjdW1wbGlyXCIsXG4gICAgXCJjdW5hXCIsXG4gICAgXCJjdW5ldGFcIixcbiAgICBcImN1b3RhXCIsXG4gICAgXCJjdXBvzIFuXCIsXG4gICAgXCJjdcyBcHVsYVwiLFxuICAgIFwiY3VyYXJcIixcbiAgICBcImN1cmlvc29cIixcbiAgICBcImN1cnNvXCIsXG4gICAgXCJjdXJ2YVwiLFxuICAgIFwiY3V0aXNcIixcbiAgICBcImRhbWFcIixcbiAgICBcImRhbnphXCIsXG4gICAgXCJkYXJcIixcbiAgICBcImRhcmRvXCIsXG4gICAgXCJkYcyBdGlsXCIsXG4gICAgXCJkZWJlclwiLFxuICAgIFwiZGXMgWJpbFwiLFxuICAgIFwiZGXMgWNhZGFcIixcbiAgICBcImRlY2lyXCIsXG4gICAgXCJkZWRvXCIsXG4gICAgXCJkZWZlbnNhXCIsXG4gICAgXCJkZWZpbmlyXCIsXG4gICAgXCJkZWphclwiLFxuICAgIFwiZGVsZmnMgW5cIixcbiAgICBcImRlbGdhZG9cIixcbiAgICBcImRlbGl0b1wiLFxuICAgIFwiZGVtb3JhXCIsXG4gICAgXCJkZW5zb1wiLFxuICAgIFwiZGVudGFsXCIsXG4gICAgXCJkZXBvcnRlXCIsXG4gICAgXCJkZXJlY2hvXCIsXG4gICAgXCJkZXJyb3RhXCIsXG4gICAgXCJkZXNheXVub1wiLFxuICAgIFwiZGVzZW9cIixcbiAgICBcImRlc2ZpbGVcIixcbiAgICBcImRlc251ZG9cIixcbiAgICBcImRlc3Rpbm9cIixcbiAgICBcImRlc3ZpzIFvXCIsXG4gICAgXCJkZXRhbGxlXCIsXG4gICAgXCJkZXRlbmVyXCIsXG4gICAgXCJkZXVkYVwiLFxuICAgIFwiZGnMgWFcIixcbiAgICBcImRpYWJsb1wiLFxuICAgIFwiZGlhZGVtYVwiLFxuICAgIFwiZGlhbWFudGVcIixcbiAgICBcImRpYW5hXCIsXG4gICAgXCJkaWFyaW9cIixcbiAgICBcImRpYnVqb1wiLFxuICAgIFwiZGljdGFyXCIsXG4gICAgXCJkaWVudGVcIixcbiAgICBcImRpZXRhXCIsXG4gICAgXCJkaWV6XCIsXG4gICAgXCJkaWZpzIFjaWxcIixcbiAgICBcImRpZ25vXCIsXG4gICAgXCJkaWxlbWFcIixcbiAgICBcImRpbHVpclwiLFxuICAgIFwiZGluZXJvXCIsXG4gICAgXCJkaXJlY3RvXCIsXG4gICAgXCJkaXJpZ2lyXCIsXG4gICAgXCJkaXNjb1wiLFxuICAgIFwiZGlzZW7Mg29cIixcbiAgICBcImRpc2ZyYXpcIixcbiAgICBcImRpdmFcIixcbiAgICBcImRpdmlub1wiLFxuICAgIFwiZG9ibGVcIixcbiAgICBcImRvY2VcIixcbiAgICBcImRvbG9yXCIsXG4gICAgXCJkb21pbmdvXCIsXG4gICAgXCJkb25cIixcbiAgICBcImRvbmFyXCIsXG4gICAgXCJkb3JhZG9cIixcbiAgICBcImRvcm1pclwiLFxuICAgIFwiZG9yc29cIixcbiAgICBcImRvc1wiLFxuICAgIFwiZG9zaXNcIixcbiAgICBcImRyYWdvzIFuXCIsXG4gICAgXCJkcm9nYVwiLFxuICAgIFwiZHVjaGFcIixcbiAgICBcImR1ZGFcIixcbiAgICBcImR1ZWxvXCIsXG4gICAgXCJkdWVuzINvXCIsXG4gICAgXCJkdWxjZVwiLFxuICAgIFwiZHXMgW9cIixcbiAgICBcImR1cXVlXCIsXG4gICAgXCJkdXJhclwiLFxuICAgIFwiZHVyZXphXCIsXG4gICAgXCJkdXJvXCIsXG4gICAgXCJlzIFiYW5vXCIsXG4gICAgXCJlYnJpb1wiLFxuICAgIFwiZWNoYXJcIixcbiAgICBcImVjb1wiLFxuICAgIFwiZWN1YWRvclwiLFxuICAgIFwiZWRhZFwiLFxuICAgIFwiZWRpY2lvzIFuXCIsXG4gICAgXCJlZGlmaWNpb1wiLFxuICAgIFwiZWRpdG9yXCIsXG4gICAgXCJlZHVjYXJcIixcbiAgICBcImVmZWN0b1wiLFxuICAgIFwiZWZpY2F6XCIsXG4gICAgXCJlamVcIixcbiAgICBcImVqZW1wbG9cIixcbiAgICBcImVsZWZhbnRlXCIsXG4gICAgXCJlbGVnaXJcIixcbiAgICBcImVsZW1lbnRvXCIsXG4gICAgXCJlbGV2YXJcIixcbiAgICBcImVsaXBzZVwiLFxuICAgIFwiZcyBbGl0ZVwiLFxuICAgIFwiZWxpeGlyXCIsXG4gICAgXCJlbG9naW9cIixcbiAgICBcImVsdWRpclwiLFxuICAgIFwiZW1idWRvXCIsXG4gICAgXCJlbWl0aXJcIixcbiAgICBcImVtb2Npb8yBblwiLFxuICAgIFwiZW1wYXRlXCIsXG4gICAgXCJlbXBlbsyDb1wiLFxuICAgIFwiZW1wbGVvXCIsXG4gICAgXCJlbXByZXNhXCIsXG4gICAgXCJlbmFub1wiLFxuICAgIFwiZW5jYXJnb1wiLFxuICAgIFwiZW5jaHVmZVwiLFxuICAgIFwiZW5jacyBYVwiLFxuICAgIFwiZW5lbWlnb1wiLFxuICAgIFwiZW5lcm9cIixcbiAgICBcImVuZmFkb1wiLFxuICAgIFwiZW5mZXJtb1wiLFxuICAgIFwiZW5nYW7Mg29cIixcbiAgICBcImVuaWdtYVwiLFxuICAgIFwiZW5sYWNlXCIsXG4gICAgXCJlbm9ybWVcIixcbiAgICBcImVucmVkb1wiLFxuICAgIFwiZW5zYXlvXCIsXG4gICAgXCJlbnNlbsyDYXJcIixcbiAgICBcImVudGVyb1wiLFxuICAgIFwiZW50cmFyXCIsXG4gICAgXCJlbnZhc2VcIixcbiAgICBcImVudmnMgW9cIixcbiAgICBcImXMgXBvY2FcIixcbiAgICBcImVxdWlwb1wiLFxuICAgIFwiZXJpem9cIixcbiAgICBcImVzY2FsYVwiLFxuICAgIFwiZXNjZW5hXCIsXG4gICAgXCJlc2NvbGFyXCIsXG4gICAgXCJlc2NyaWJpclwiLFxuICAgIFwiZXNjdWRvXCIsXG4gICAgXCJlc2VuY2lhXCIsXG4gICAgXCJlc2ZlcmFcIixcbiAgICBcImVzZnVlcnpvXCIsXG4gICAgXCJlc3BhZGFcIixcbiAgICBcImVzcGVqb1wiLFxuICAgIFwiZXNwacyBYVwiLFxuICAgIFwiZXNwb3NhXCIsXG4gICAgXCJlc3B1bWFcIixcbiAgICBcImVzcXVpzIFcIixcbiAgICBcImVzdGFyXCIsXG4gICAgXCJlc3RlXCIsXG4gICAgXCJlc3RpbG9cIixcbiAgICBcImVzdHVmYVwiLFxuICAgIFwiZXRhcGFcIixcbiAgICBcImV0ZXJub1wiLFxuICAgIFwiZcyBdGljYVwiLFxuICAgIFwiZXRuaWFcIixcbiAgICBcImV2YWRpclwiLFxuICAgIFwiZXZhbHVhclwiLFxuICAgIFwiZXZlbnRvXCIsXG4gICAgXCJldml0YXJcIixcbiAgICBcImV4YWN0b1wiLFxuICAgIFwiZXhhbWVuXCIsXG4gICAgXCJleGNlc29cIixcbiAgICBcImV4Y3VzYVwiLFxuICAgIFwiZXhlbnRvXCIsXG4gICAgXCJleGlnaXJcIixcbiAgICBcImV4aWxpb1wiLFxuICAgIFwiZXhpc3RpclwiLFxuICAgIFwiZcyBeGl0b1wiLFxuICAgIFwiZXhwZXJ0b1wiLFxuICAgIFwiZXhwbGljYXJcIixcbiAgICBcImV4cG9uZXJcIixcbiAgICBcImV4dHJlbW9cIixcbiAgICBcImZhzIFicmljYVwiLFxuICAgIFwiZmHMgWJ1bGFcIixcbiAgICBcImZhY2hhZGFcIixcbiAgICBcImZhzIFjaWxcIixcbiAgICBcImZhY3RvclwiLFxuICAgIFwiZmFlbmFcIixcbiAgICBcImZhamFcIixcbiAgICBcImZhbGRhXCIsXG4gICAgXCJmYWxsb1wiLFxuICAgIFwiZmFsc29cIixcbiAgICBcImZhbHRhclwiLFxuICAgIFwiZmFtYVwiLFxuICAgIFwiZmFtaWxpYVwiLFxuICAgIFwiZmFtb3NvXCIsXG4gICAgXCJmYXJhb8yBblwiLFxuICAgIFwiZmFybWFjaWFcIixcbiAgICBcImZhcm9sXCIsXG4gICAgXCJmYXJzYVwiLFxuICAgIFwiZmFzZVwiLFxuICAgIFwiZmF0aWdhXCIsXG4gICAgXCJmYXVuYVwiLFxuICAgIFwiZmF2b3JcIixcbiAgICBcImZheFwiLFxuICAgIFwiZmVicmVyb1wiLFxuICAgIFwiZmVjaGFcIixcbiAgICBcImZlbGl6XCIsXG4gICAgXCJmZW9cIixcbiAgICBcImZlcmlhXCIsXG4gICAgXCJmZXJvelwiLFxuICAgIFwiZmXMgXJ0aWxcIixcbiAgICBcImZlcnZvclwiLFxuICAgIFwiZmVzdGnMgW5cIixcbiAgICBcImZpYWJsZVwiLFxuICAgIFwiZmlhbnphXCIsXG4gICAgXCJmaWFyXCIsXG4gICAgXCJmaWJyYVwiLFxuICAgIFwiZmljY2lvzIFuXCIsXG4gICAgXCJmaWNoYVwiLFxuICAgIFwiZmlkZW9cIixcbiAgICBcImZpZWJyZVwiLFxuICAgIFwiZmllbFwiLFxuICAgIFwiZmllcmFcIixcbiAgICBcImZpZXN0YVwiLFxuICAgIFwiZmlndXJhXCIsXG4gICAgXCJmaWphclwiLFxuICAgIFwiZmlqb1wiLFxuICAgIFwiZmlsYVwiLFxuICAgIFwiZmlsZXRlXCIsXG4gICAgXCJmaWxpYWxcIixcbiAgICBcImZpbHRyb1wiLFxuICAgIFwiZmluXCIsXG4gICAgXCJmaW5jYVwiLFxuICAgIFwiZmluZ2lyXCIsXG4gICAgXCJmaW5pdG9cIixcbiAgICBcImZpcm1hXCIsXG4gICAgXCJmbGFjb1wiLFxuICAgIFwiZmxhdXRhXCIsXG4gICAgXCJmbGVjaGFcIixcbiAgICBcImZsb3JcIixcbiAgICBcImZsb3RhXCIsXG4gICAgXCJmbHVpclwiLFxuICAgIFwiZmx1am9cIixcbiAgICBcImZsdcyBb3JcIixcbiAgICBcImZvYmlhXCIsXG4gICAgXCJmb2NhXCIsXG4gICAgXCJmb2dhdGFcIixcbiAgICBcImZvZ2/MgW5cIixcbiAgICBcImZvbGlvXCIsXG4gICAgXCJmb2xsZXRvXCIsXG4gICAgXCJmb25kb1wiLFxuICAgIFwiZm9ybWFcIixcbiAgICBcImZvcnJvXCIsXG4gICAgXCJmb3J0dW5hXCIsXG4gICAgXCJmb3J6YXJcIixcbiAgICBcImZvc2FcIixcbiAgICBcImZvdG9cIixcbiAgICBcImZyYWNhc29cIixcbiAgICBcImZyYcyBZ2lsXCIsXG4gICAgXCJmcmFuamFcIixcbiAgICBcImZyYXNlXCIsXG4gICAgXCJmcmF1ZGVcIixcbiAgICBcImZyZWnMgXJcIixcbiAgICBcImZyZW5vXCIsXG4gICAgXCJmcmVzYVwiLFxuICAgIFwiZnJpzIFvXCIsXG4gICAgXCJmcml0b1wiLFxuICAgIFwiZnJ1dGFcIixcbiAgICBcImZ1ZWdvXCIsXG4gICAgXCJmdWVudGVcIixcbiAgICBcImZ1ZXJ6YVwiLFxuICAgIFwiZnVnYVwiLFxuICAgIFwiZnVtYXJcIixcbiAgICBcImZ1bmNpb8yBblwiLFxuICAgIFwiZnVuZGFcIixcbiAgICBcImZ1cmdvzIFuXCIsXG4gICAgXCJmdXJpYVwiLFxuICAgIFwiZnVzaWxcIixcbiAgICBcImZ1zIF0Ym9sXCIsXG4gICAgXCJmdXR1cm9cIixcbiAgICBcImdhY2VsYVwiLFxuICAgIFwiZ2FmYXNcIixcbiAgICBcImdhaXRhXCIsXG4gICAgXCJnYWpvXCIsXG4gICAgXCJnYWxhXCIsXG4gICAgXCJnYWxlcmnMgWFcIixcbiAgICBcImdhbGxvXCIsXG4gICAgXCJnYW1iYVwiLFxuICAgIFwiZ2FuYXJcIixcbiAgICBcImdhbmNob1wiLFxuICAgIFwiZ2FuZ2FcIixcbiAgICBcImdhbnNvXCIsXG4gICAgXCJnYXJhamVcIixcbiAgICBcImdhcnphXCIsXG4gICAgXCJnYXNvbGluYVwiLFxuICAgIFwiZ2FzdGFyXCIsXG4gICAgXCJnYXRvXCIsXG4gICAgXCJnYXZpbGHMgW5cIixcbiAgICBcImdlbWVsb1wiLFxuICAgIFwiZ2VtaXJcIixcbiAgICBcImdlblwiLFxuICAgIFwiZ2XMgW5lcm9cIixcbiAgICBcImdlbmlvXCIsXG4gICAgXCJnZW50ZVwiLFxuICAgIFwiZ2VyYW5pb1wiLFxuICAgIFwiZ2VyZW50ZVwiLFxuICAgIFwiZ2VybWVuXCIsXG4gICAgXCJnZXN0b1wiLFxuICAgIFwiZ2lnYW50ZVwiLFxuICAgIFwiZ2ltbmFzaW9cIixcbiAgICBcImdpcmFyXCIsXG4gICAgXCJnaXJvXCIsXG4gICAgXCJnbGFjaWFyXCIsXG4gICAgXCJnbG9ib1wiLFxuICAgIFwiZ2xvcmlhXCIsXG4gICAgXCJnb2xcIixcbiAgICBcImdvbGZvXCIsXG4gICAgXCJnb2xvc29cIixcbiAgICBcImdvbHBlXCIsXG4gICAgXCJnb21hXCIsXG4gICAgXCJnb3Jkb1wiLFxuICAgIFwiZ29yaWxhXCIsXG4gICAgXCJnb3JyYVwiLFxuICAgIFwiZ290YVwiLFxuICAgIFwiZ290ZW9cIixcbiAgICBcImdvemFyXCIsXG4gICAgXCJncmFkYVwiLFxuICAgIFwiZ3JhzIFmaWNvXCIsXG4gICAgXCJncmFub1wiLFxuICAgIFwiZ3Jhc2FcIixcbiAgICBcImdyYXRpc1wiLFxuICAgIFwiZ3JhdmVcIixcbiAgICBcImdyaWV0YVwiLFxuICAgIFwiZ3JpbGxvXCIsXG4gICAgXCJncmlwZVwiLFxuICAgIFwiZ3Jpc1wiLFxuICAgIFwiZ3JpdG9cIixcbiAgICBcImdyb3NvclwiLFxuICAgIFwiZ3J1zIFhXCIsXG4gICAgXCJncnVlc29cIixcbiAgICBcImdydW1vXCIsXG4gICAgXCJncnVwb1wiLFxuICAgIFwiZ3VhbnRlXCIsXG4gICAgXCJndWFwb1wiLFxuICAgIFwiZ3VhcmRpYVwiLFxuICAgIFwiZ3VlcnJhXCIsXG4gICAgXCJndWnMgWFcIixcbiAgICBcImd1aW7Mg29cIixcbiAgICBcImd1aW9uXCIsXG4gICAgXCJndWlzb1wiLFxuICAgIFwiZ3VpdGFycmFcIixcbiAgICBcImd1c2Fub1wiLFxuICAgIFwiZ3VzdGFyXCIsXG4gICAgXCJoYWJlclwiLFxuICAgIFwiaGHMgWJpbFwiLFxuICAgIFwiaGFibGFyXCIsXG4gICAgXCJoYWNlclwiLFxuICAgIFwiaGFjaGFcIixcbiAgICBcImhhZGFcIixcbiAgICBcImhhbGxhclwiLFxuICAgIFwiaGFtYWNhXCIsXG4gICAgXCJoYXJpbmFcIixcbiAgICBcImhhelwiLFxuICAgIFwiaGF6YW7Mg2FcIixcbiAgICBcImhlYmlsbGFcIixcbiAgICBcImhlYnJhXCIsXG4gICAgXCJoZWNob1wiLFxuICAgIFwiaGVsYWRvXCIsXG4gICAgXCJoZWxpb1wiLFxuICAgIFwiaGVtYnJhXCIsXG4gICAgXCJoZXJpclwiLFxuICAgIFwiaGVybWFub1wiLFxuICAgIFwiaGXMgXJvZVwiLFxuICAgIFwiaGVydmlyXCIsXG4gICAgXCJoaWVsb1wiLFxuICAgIFwiaGllcnJvXCIsXG4gICAgXCJoacyBZ2Fkb1wiLFxuICAgIFwiaGlnaWVuZVwiLFxuICAgIFwiaGlqb1wiLFxuICAgIFwiaGltbm9cIixcbiAgICBcImhpc3RvcmlhXCIsXG4gICAgXCJob2NpY29cIixcbiAgICBcImhvZ2FyXCIsXG4gICAgXCJob2d1ZXJhXCIsXG4gICAgXCJob2phXCIsXG4gICAgXCJob21icmVcIixcbiAgICBcImhvbmdvXCIsXG4gICAgXCJob25vclwiLFxuICAgIFwiaG9ucmFcIixcbiAgICBcImhvcmFcIixcbiAgICBcImhvcm1pZ2FcIixcbiAgICBcImhvcm5vXCIsXG4gICAgXCJob3N0aWxcIixcbiAgICBcImhveW9cIixcbiAgICBcImh1ZWNvXCIsXG4gICAgXCJodWVsZ2FcIixcbiAgICBcImh1ZXJ0YVwiLFxuICAgIFwiaHVlc29cIixcbiAgICBcImh1ZXZvXCIsXG4gICAgXCJodWlkYVwiLFxuICAgIFwiaHVpclwiLFxuICAgIFwiaHVtYW5vXCIsXG4gICAgXCJodcyBbWVkb1wiLFxuICAgIFwiaHVtaWxkZVwiLFxuICAgIFwiaHVtb1wiLFxuICAgIFwiaHVuZGlyXCIsXG4gICAgXCJodXJhY2HMgW5cIixcbiAgICBcImh1cnRvXCIsXG4gICAgXCJpY29ub1wiLFxuICAgIFwiaWRlYWxcIixcbiAgICBcImlkaW9tYVwiLFxuICAgIFwiacyBZG9sb1wiLFxuICAgIFwiaWdsZXNpYVwiLFxuICAgIFwiaWdsdcyBXCIsXG4gICAgXCJpZ3VhbFwiLFxuICAgIFwiaWxlZ2FsXCIsXG4gICAgXCJpbHVzaW/MgW5cIixcbiAgICBcImltYWdlblwiLFxuICAgIFwiaW1hzIFuXCIsXG4gICAgXCJpbWl0YXJcIixcbiAgICBcImltcGFyXCIsXG4gICAgXCJpbXBlcmlvXCIsXG4gICAgXCJpbXBvbmVyXCIsXG4gICAgXCJpbXB1bHNvXCIsXG4gICAgXCJpbmNhcGF6XCIsXG4gICAgXCJpzIFuZGljZVwiLFxuICAgIFwiaW5lcnRlXCIsXG4gICAgXCJpbmZpZWxcIixcbiAgICBcImluZm9ybWVcIixcbiAgICBcImluZ2VuaW9cIixcbiAgICBcImluaWNpb1wiLFxuICAgIFwiaW5tZW5zb1wiLFxuICAgIFwiaW5tdW5lXCIsXG4gICAgXCJpbm5hdG9cIixcbiAgICBcImluc2VjdG9cIixcbiAgICBcImluc3RhbnRlXCIsXG4gICAgXCJpbnRlcmXMgXNcIixcbiAgICBcImnMgW50aW1vXCIsXG4gICAgXCJpbnR1aXJcIixcbiAgICBcImludcyBdGlsXCIsXG4gICAgXCJpbnZpZXJub1wiLFxuICAgIFwiaXJhXCIsXG4gICAgXCJpcmlzXCIsXG4gICAgXCJpcm9uacyBYVwiLFxuICAgIFwiaXNsYVwiLFxuICAgIFwiaXNsb3RlXCIsXG4gICAgXCJqYWJhbGnMgVwiLFxuICAgIFwiamFib8yBblwiLFxuICAgIFwiamFtb8yBblwiLFxuICAgIFwiamFyYWJlXCIsXG4gICAgXCJqYXJkacyBblwiLFxuICAgIFwiamFycmFcIixcbiAgICBcImphdWxhXCIsXG4gICAgXCJqYXptacyBblwiLFxuICAgIFwiamVmZVwiLFxuICAgIFwiamVyaW5nYVwiLFxuICAgIFwiamluZXRlXCIsXG4gICAgXCJqb3JuYWRhXCIsXG4gICAgXCJqb3JvYmFcIixcbiAgICBcImpvdmVuXCIsXG4gICAgXCJqb3lhXCIsXG4gICAgXCJqdWVyZ2FcIixcbiAgICBcImp1ZXZlc1wiLFxuICAgIFwianVlelwiLFxuICAgIFwianVnYWRvclwiLFxuICAgIFwianVnb1wiLFxuICAgIFwianVndWV0ZVwiLFxuICAgIFwianVpY2lvXCIsXG4gICAgXCJqdW5jb1wiLFxuICAgIFwianVuZ2xhXCIsXG4gICAgXCJqdW5pb1wiLFxuICAgIFwianVudGFyXCIsXG4gICAgXCJqdcyBcGl0ZXJcIixcbiAgICBcImp1cmFyXCIsXG4gICAgXCJqdXN0b1wiLFxuICAgIFwianV2ZW5pbFwiLFxuICAgIFwianV6Z2FyXCIsXG4gICAgXCJraWxvXCIsXG4gICAgXCJrb2FsYVwiLFxuICAgIFwibGFiaW9cIixcbiAgICBcImxhY2lvXCIsXG4gICAgXCJsYWNyYVwiLFxuICAgIFwibGFkb1wiLFxuICAgIFwibGFkcm/MgW5cIixcbiAgICBcImxhZ2FydG9cIixcbiAgICBcImxhzIFncmltYVwiLFxuICAgIFwibGFndW5hXCIsXG4gICAgXCJsYWljb1wiLFxuICAgIFwibGFtZXJcIixcbiAgICBcImxhzIFtaW5hXCIsXG4gICAgXCJsYcyBbXBhcmFcIixcbiAgICBcImxhbmFcIixcbiAgICBcImxhbmNoYVwiLFxuICAgIFwibGFuZ29zdGFcIixcbiAgICBcImxhbnphXCIsXG4gICAgXCJsYcyBcGl6XCIsXG4gICAgXCJsYXJnb1wiLFxuICAgIFwibGFydmFcIixcbiAgICBcImxhzIFzdGltYVwiLFxuICAgIFwibGF0YVwiLFxuICAgIFwibGHMgXRleFwiLFxuICAgIFwibGF0aXJcIixcbiAgICBcImxhdXJlbFwiLFxuICAgIFwibGF2YXJcIixcbiAgICBcImxhem9cIixcbiAgICBcImxlYWxcIixcbiAgICBcImxlY2Npb8yBblwiLFxuICAgIFwibGVjaGVcIixcbiAgICBcImxlY3RvclwiLFxuICAgIFwibGVlclwiLFxuICAgIFwibGVnaW/MgW5cIixcbiAgICBcImxlZ3VtYnJlXCIsXG4gICAgXCJsZWphbm9cIixcbiAgICBcImxlbmd1YVwiLFxuICAgIFwibGVudG9cIixcbiAgICBcImxlbsyDYVwiLFxuICAgIFwibGVvzIFuXCIsXG4gICAgXCJsZW9wYXJkb1wiLFxuICAgIFwibGVzaW/MgW5cIixcbiAgICBcImxldGFsXCIsXG4gICAgXCJsZXRyYVwiLFxuICAgIFwibGV2ZVwiLFxuICAgIFwibGV5ZW5kYVwiLFxuICAgIFwibGliZXJ0YWRcIixcbiAgICBcImxpYnJvXCIsXG4gICAgXCJsaWNvclwiLFxuICAgIFwibGnMgWRlclwiLFxuICAgIFwibGlkaWFyXCIsXG4gICAgXCJsaWVuem9cIixcbiAgICBcImxpZ2FcIixcbiAgICBcImxpZ2Vyb1wiLFxuICAgIFwibGltYVwiLFxuICAgIFwibGnMgW1pdGVcIixcbiAgICBcImxpbW/MgW5cIixcbiAgICBcImxpbXBpb1wiLFxuICAgIFwibGluY2VcIixcbiAgICBcImxpbmRvXCIsXG4gICAgXCJsacyBbmVhXCIsXG4gICAgXCJsaW5nb3RlXCIsXG4gICAgXCJsaW5vXCIsXG4gICAgXCJsaW50ZXJuYVwiLFxuICAgIFwibGnMgXF1aWRvXCIsXG4gICAgXCJsaXNvXCIsXG4gICAgXCJsaXN0YVwiLFxuICAgIFwibGl0ZXJhXCIsXG4gICAgXCJsaXRpb1wiLFxuICAgIFwibGl0cm9cIixcbiAgICBcImxsYWdhXCIsXG4gICAgXCJsbGFtYVwiLFxuICAgIFwibGxhbnRvXCIsXG4gICAgXCJsbGF2ZVwiLFxuICAgIFwibGxlZ2FyXCIsXG4gICAgXCJsbGVuYXJcIixcbiAgICBcImxsZXZhclwiLFxuICAgIFwibGxvcmFyXCIsXG4gICAgXCJsbG92ZXJcIixcbiAgICBcImxsdXZpYVwiLFxuICAgIFwibG9ib1wiLFxuICAgIFwibG9jaW/MgW5cIixcbiAgICBcImxvY29cIixcbiAgICBcImxvY3VyYVwiLFxuICAgIFwibG/MgWdpY2FcIixcbiAgICBcImxvZ3JvXCIsXG4gICAgXCJsb21icml6XCIsXG4gICAgXCJsb21vXCIsXG4gICAgXCJsb25qYVwiLFxuICAgIFwibG90ZVwiLFxuICAgIFwibHVjaGFcIixcbiAgICBcImx1Y2lyXCIsXG4gICAgXCJsdWdhclwiLFxuICAgIFwibHVqb1wiLFxuICAgIFwibHVuYVwiLFxuICAgIFwibHVuZXNcIixcbiAgICBcImx1cGFcIixcbiAgICBcImx1c3Ryb1wiLFxuICAgIFwibHV0b1wiLFxuICAgIFwibHV6XCIsXG4gICAgXCJtYWNldGFcIixcbiAgICBcIm1hY2hvXCIsXG4gICAgXCJtYWRlcmFcIixcbiAgICBcIm1hZHJlXCIsXG4gICAgXCJtYWR1cm9cIixcbiAgICBcIm1hZXN0cm9cIixcbiAgICBcIm1hZmlhXCIsXG4gICAgXCJtYWdpYVwiLFxuICAgIFwibWFnb1wiLFxuICAgIFwibWFpzIF6XCIsXG4gICAgXCJtYWxkYWRcIixcbiAgICBcIm1hbGV0YVwiLFxuICAgIFwibWFsbGFcIixcbiAgICBcIm1hbG9cIixcbiAgICBcIm1hbWHMgVwiLFxuICAgIFwibWFtYm9cIixcbiAgICBcIm1hbXV0XCIsXG4gICAgXCJtYW5jb1wiLFxuICAgIFwibWFuZG9cIixcbiAgICBcIm1hbmVqYXJcIixcbiAgICBcIm1hbmdhXCIsXG4gICAgXCJtYW5pcXVpzIFcIixcbiAgICBcIm1hbmphclwiLFxuICAgIFwibWFub1wiLFxuICAgIFwibWFuc29cIixcbiAgICBcIm1hbnRhXCIsXG4gICAgXCJtYW7Mg2FuYVwiLFxuICAgIFwibWFwYVwiLFxuICAgIFwibWHMgXF1aW5hXCIsXG4gICAgXCJtYXJcIixcbiAgICBcIm1hcmNvXCIsXG4gICAgXCJtYXJlYVwiLFxuICAgIFwibWFyZmlsXCIsXG4gICAgXCJtYXJnZW5cIixcbiAgICBcIm1hcmlkb1wiLFxuICAgIFwibWHMgXJtb2xcIixcbiAgICBcIm1hcnJvzIFuXCIsXG4gICAgXCJtYXJ0ZXNcIixcbiAgICBcIm1hcnpvXCIsXG4gICAgXCJtYXNhXCIsXG4gICAgXCJtYcyBc2NhcmFcIixcbiAgICBcIm1hc2l2b1wiLFxuICAgIFwibWF0YXJcIixcbiAgICBcIm1hdGVyaWFcIixcbiAgICBcIm1hdGl6XCIsXG4gICAgXCJtYXRyaXpcIixcbiAgICBcIm1hzIF4aW1vXCIsXG4gICAgXCJtYXlvclwiLFxuICAgIFwibWF6b3JjYVwiLFxuICAgIFwibWVjaGFcIixcbiAgICBcIm1lZGFsbGFcIixcbiAgICBcIm1lZGlvXCIsXG4gICAgXCJtZcyBZHVsYVwiLFxuICAgIFwibWVqaWxsYVwiLFxuICAgIFwibWVqb3JcIixcbiAgICBcIm1lbGVuYVwiLFxuICAgIFwibWVsb8yBblwiLFxuICAgIFwibWVtb3JpYVwiLFxuICAgIFwibWVub3JcIixcbiAgICBcIm1lbnNhamVcIixcbiAgICBcIm1lbnRlXCIsXG4gICAgXCJtZW51zIFcIixcbiAgICBcIm1lcmNhZG9cIixcbiAgICBcIm1lcmVuZ3VlXCIsXG4gICAgXCJtZcyBcml0b1wiLFxuICAgIFwibWVzXCIsXG4gICAgXCJtZXNvzIFuXCIsXG4gICAgXCJtZXRhXCIsXG4gICAgXCJtZXRlclwiLFxuICAgIFwibWXMgXRvZG9cIixcbiAgICBcIm1ldHJvXCIsXG4gICAgXCJtZXpjbGFcIixcbiAgICBcIm1pZWRvXCIsXG4gICAgXCJtaWVsXCIsXG4gICAgXCJtaWVtYnJvXCIsXG4gICAgXCJtaWdhXCIsXG4gICAgXCJtaWxcIixcbiAgICBcIm1pbGFncm9cIixcbiAgICBcIm1pbGl0YXJcIixcbiAgICBcIm1pbGxvzIFuXCIsXG4gICAgXCJtaW1vXCIsXG4gICAgXCJtaW5hXCIsXG4gICAgXCJtaW5lcm9cIixcbiAgICBcIm1pzIFuaW1vXCIsXG4gICAgXCJtaW51dG9cIixcbiAgICBcIm1pb3BlXCIsXG4gICAgXCJtaXJhclwiLFxuICAgIFwibWlzYVwiLFxuICAgIFwibWlzZXJpYVwiLFxuICAgIFwibWlzaWxcIixcbiAgICBcIm1pc21vXCIsXG4gICAgXCJtaXRhZFwiLFxuICAgIFwibWl0b1wiLFxuICAgIFwibW9jaGlsYVwiLFxuICAgIFwibW9jaW/MgW5cIixcbiAgICBcIm1vZGFcIixcbiAgICBcIm1vZGVsb1wiLFxuICAgIFwibW9ob1wiLFxuICAgIFwibW9qYXJcIixcbiAgICBcIm1vbGRlXCIsXG4gICAgXCJtb2xlclwiLFxuICAgIFwibW9saW5vXCIsXG4gICAgXCJtb21lbnRvXCIsXG4gICAgXCJtb21pYVwiLFxuICAgIFwibW9uYXJjYVwiLFxuICAgIFwibW9uZWRhXCIsXG4gICAgXCJtb25qYVwiLFxuICAgIFwibW9udG9cIixcbiAgICBcIm1vbsyDb1wiLFxuICAgIFwibW9yYWRhXCIsXG4gICAgXCJtb3JkZXJcIixcbiAgICBcIm1vcmVub1wiLFxuICAgIFwibW9yaXJcIixcbiAgICBcIm1vcnJvXCIsXG4gICAgXCJtb3JzYVwiLFxuICAgIFwibW9ydGFsXCIsXG4gICAgXCJtb3NjYVwiLFxuICAgIFwibW9zdHJhclwiLFxuICAgIFwibW90aXZvXCIsXG4gICAgXCJtb3ZlclwiLFxuICAgIFwibW/MgXZpbFwiLFxuICAgIFwibW96b1wiLFxuICAgIFwibXVjaG9cIixcbiAgICBcIm11ZGFyXCIsXG4gICAgXCJtdWVibGVcIixcbiAgICBcIm11ZWxhXCIsXG4gICAgXCJtdWVydGVcIixcbiAgICBcIm11ZXN0cmFcIixcbiAgICBcIm11Z3JlXCIsXG4gICAgXCJtdWplclwiLFxuICAgIFwibXVsYVwiLFxuICAgIFwibXVsZXRhXCIsXG4gICAgXCJtdWx0YVwiLFxuICAgIFwibXVuZG9cIixcbiAgICBcIm11bsyDZWNhXCIsXG4gICAgXCJtdXJhbFwiLFxuICAgIFwibXVyb1wiLFxuICAgIFwibXXMgXNjdWxvXCIsXG4gICAgXCJtdXNlb1wiLFxuICAgIFwibXVzZ29cIixcbiAgICBcIm11zIFzaWNhXCIsXG4gICAgXCJtdXNsb1wiLFxuICAgIFwibmHMgWNhclwiLFxuICAgIFwibmFjaW/MgW5cIixcbiAgICBcIm5hZGFyXCIsXG4gICAgXCJuYWlwZVwiLFxuICAgIFwibmFyYW5qYVwiLFxuICAgIFwibmFyaXpcIixcbiAgICBcIm5hcnJhclwiLFxuICAgIFwibmFzYWxcIixcbiAgICBcIm5hdGFsXCIsXG4gICAgXCJuYXRpdm9cIixcbiAgICBcIm5hdHVyYWxcIixcbiAgICBcIm5hzIF1c2VhXCIsXG4gICAgXCJuYXZhbFwiLFxuICAgIFwibmF2ZVwiLFxuICAgIFwibmF2aWRhZFwiLFxuICAgIFwibmVjaW9cIixcbiAgICBcIm5lzIFjdGFyXCIsXG4gICAgXCJuZWdhclwiLFxuICAgIFwibmVnb2Npb1wiLFxuICAgIFwibmVncm9cIixcbiAgICBcIm5lb8yBblwiLFxuICAgIFwibmVydmlvXCIsXG4gICAgXCJuZXRvXCIsXG4gICAgXCJuZXV0cm9cIixcbiAgICBcIm5ldmFyXCIsXG4gICAgXCJuZXZlcmFcIixcbiAgICBcIm5pY2hvXCIsXG4gICAgXCJuaWRvXCIsXG4gICAgXCJuaWVibGFcIixcbiAgICBcIm5pZXRvXCIsXG4gICAgXCJuaW7Mg2V6XCIsXG4gICAgXCJuaW7Mg29cIixcbiAgICBcIm5pzIF0aWRvXCIsXG4gICAgXCJuaXZlbFwiLFxuICAgIFwibm9ibGV6YVwiLFxuICAgIFwibm9jaGVcIixcbiAgICBcIm5vzIFtaW5hXCIsXG4gICAgXCJub3JpYVwiLFxuICAgIFwibm9ybWFcIixcbiAgICBcIm5vcnRlXCIsXG4gICAgXCJub3RhXCIsXG4gICAgXCJub3RpY2lhXCIsXG4gICAgXCJub3ZhdG9cIixcbiAgICBcIm5vdmVsYVwiLFxuICAgIFwibm92aW9cIixcbiAgICBcIm51YmVcIixcbiAgICBcIm51Y2FcIixcbiAgICBcIm51zIFjbGVvXCIsXG4gICAgXCJudWRpbGxvXCIsXG4gICAgXCJudWRvXCIsXG4gICAgXCJudWVyYVwiLFxuICAgIFwibnVldmVcIixcbiAgICBcIm51ZXpcIixcbiAgICBcIm51bG9cIixcbiAgICBcIm51zIFtZXJvXCIsXG4gICAgXCJudXRyaWFcIixcbiAgICBcIm9hc2lzXCIsXG4gICAgXCJvYmVzb1wiLFxuICAgIFwib2Jpc3BvXCIsXG4gICAgXCJvYmpldG9cIixcbiAgICBcIm9icmFcIixcbiAgICBcIm9icmVyb1wiLFxuICAgIFwib2JzZXJ2YXJcIixcbiAgICBcIm9idGVuZXJcIixcbiAgICBcIm9idmlvXCIsXG4gICAgXCJvY2FcIixcbiAgICBcIm9jYXNvXCIsXG4gICAgXCJvY2XMgWFub1wiLFxuICAgIFwib2NoZW50YVwiLFxuICAgIFwib2Nob1wiLFxuICAgIFwib2Npb1wiLFxuICAgIFwib2NyZVwiLFxuICAgIFwib2N0YXZvXCIsXG4gICAgXCJvY3R1YnJlXCIsXG4gICAgXCJvY3VsdG9cIixcbiAgICBcIm9jdXBhclwiLFxuICAgIFwib2N1cnJpclwiLFxuICAgIFwib2RpYXJcIixcbiAgICBcIm9kaW9cIixcbiAgICBcIm9kaXNlYVwiLFxuICAgIFwib2VzdGVcIixcbiAgICBcIm9mZW5zYVwiLFxuICAgIFwib2ZlcnRhXCIsXG4gICAgXCJvZmljaW9cIixcbiAgICBcIm9mcmVjZXJcIixcbiAgICBcIm9ncm9cIixcbiAgICBcIm9pzIFkb1wiLFxuICAgIFwib2nMgXJcIixcbiAgICBcIm9qb1wiLFxuICAgIFwib2xhXCIsXG4gICAgXCJvbGVhZGFcIixcbiAgICBcIm9sZmF0b1wiLFxuICAgIFwib2xpdm9cIixcbiAgICBcIm9sbGFcIixcbiAgICBcIm9sbW9cIixcbiAgICBcIm9sb3JcIixcbiAgICBcIm9sdmlkb1wiLFxuICAgIFwib21ibGlnb1wiLFxuICAgIFwib25kYVwiLFxuICAgIFwib256YVwiLFxuICAgIFwib3BhY29cIixcbiAgICBcIm9wY2lvzIFuXCIsXG4gICAgXCJvzIFwZXJhXCIsXG4gICAgXCJvcGluYXJcIixcbiAgICBcIm9wb25lclwiLFxuICAgIFwib3B0YXJcIixcbiAgICBcIm/MgXB0aWNhXCIsXG4gICAgXCJvcHVlc3RvXCIsXG4gICAgXCJvcmFjaW/MgW5cIixcbiAgICBcIm9yYWRvclwiLFxuICAgIFwib3JhbFwiLFxuICAgIFwib8yBcmJpdGFcIixcbiAgICBcIm9yY2FcIixcbiAgICBcIm9yZGVuXCIsXG4gICAgXCJvcmVqYVwiLFxuICAgIFwib8yBcmdhbm9cIixcbiAgICBcIm9yZ2nMgWFcIixcbiAgICBcIm9yZ3VsbG9cIixcbiAgICBcIm9yaWVudGVcIixcbiAgICBcIm9yaWdlblwiLFxuICAgIFwib3JpbGxhXCIsXG4gICAgXCJvcm9cIixcbiAgICBcIm9ycXVlc3RhXCIsXG4gICAgXCJvcnVnYVwiLFxuICAgIFwib3NhZGnMgWFcIixcbiAgICBcIm9zY3Vyb1wiLFxuICAgIFwib3Nlem5vXCIsXG4gICAgXCJvc29cIixcbiAgICBcIm9zdHJhXCIsXG4gICAgXCJvdG9uzINvXCIsXG4gICAgXCJvdHJvXCIsXG4gICAgXCJvdmVqYVwiLFxuICAgIFwib8yBdnVsb1wiLFxuICAgIFwib8yBeGlkb1wiLFxuICAgIFwib3hpzIFnZW5vXCIsXG4gICAgXCJveWVudGVcIixcbiAgICBcIm96b25vXCIsXG4gICAgXCJwYWN0b1wiLFxuICAgIFwicGFkcmVcIixcbiAgICBcInBhZWxsYVwiLFxuICAgIFwicGHMgWdpbmFcIixcbiAgICBcInBhZ29cIixcbiAgICBcInBhacyBc1wiLFxuICAgIFwicGHMgWphcm9cIixcbiAgICBcInBhbGFicmFcIixcbiAgICBcInBhbGNvXCIsXG4gICAgXCJwYWxldGFcIixcbiAgICBcInBhzIFsaWRvXCIsXG4gICAgXCJwYWxtYVwiLFxuICAgIFwicGFsb21hXCIsXG4gICAgXCJwYWxwYXJcIixcbiAgICBcInBhblwiLFxuICAgIFwicGFuYWxcIixcbiAgICBcInBhzIFuaWNvXCIsXG4gICAgXCJwYW50ZXJhXCIsXG4gICAgXCJwYW7Mg3VlbG9cIixcbiAgICBcInBhcGHMgVwiLFxuICAgIFwicGFwZWxcIixcbiAgICBcInBhcGlsbGFcIixcbiAgICBcInBhcXVldGVcIixcbiAgICBcInBhcmFyXCIsXG4gICAgXCJwYXJjZWxhXCIsXG4gICAgXCJwYXJlZFwiLFxuICAgIFwicGFyaXJcIixcbiAgICBcInBhcm9cIixcbiAgICBcInBhzIFycGFkb1wiLFxuICAgIFwicGFycXVlXCIsXG4gICAgXCJwYcyBcnJhZm9cIixcbiAgICBcInBhcnRlXCIsXG4gICAgXCJwYXNhclwiLFxuICAgIFwicGFzZW9cIixcbiAgICBcInBhc2lvzIFuXCIsXG4gICAgXCJwYXNvXCIsXG4gICAgXCJwYXN0YVwiLFxuICAgIFwicGF0YVwiLFxuICAgIFwicGF0aW9cIixcbiAgICBcInBhdHJpYVwiLFxuICAgIFwicGF1c2FcIixcbiAgICBcInBhdXRhXCIsXG4gICAgXCJwYXZvXCIsXG4gICAgXCJwYXlhc29cIixcbiAgICBcInBlYXRvzIFuXCIsXG4gICAgXCJwZWNhZG9cIixcbiAgICBcInBlY2VyYVwiLFxuICAgIFwicGVjaG9cIixcbiAgICBcInBlZGFsXCIsXG4gICAgXCJwZWRpclwiLFxuICAgIFwicGVnYXJcIixcbiAgICBcInBlaW5lXCIsXG4gICAgXCJwZWxhclwiLFxuICAgIFwicGVsZGFuzINvXCIsXG4gICAgXCJwZWxlYVwiLFxuICAgIFwicGVsaWdyb1wiLFxuICAgIFwicGVsbGVqb1wiLFxuICAgIFwicGVsb1wiLFxuICAgIFwicGVsdWNhXCIsXG4gICAgXCJwZW5hXCIsXG4gICAgXCJwZW5zYXJcIixcbiAgICBcInBlbsyDb8yBblwiLFxuICAgIFwicGVvzIFuXCIsXG4gICAgXCJwZW9yXCIsXG4gICAgXCJwZXBpbm9cIixcbiAgICBcInBlcXVlbsyDb1wiLFxuICAgIFwicGVyYVwiLFxuICAgIFwicGVyY2hhXCIsXG4gICAgXCJwZXJkZXJcIixcbiAgICBcInBlcmV6YVwiLFxuICAgIFwicGVyZmlsXCIsXG4gICAgXCJwZXJpY29cIixcbiAgICBcInBlcmxhXCIsXG4gICAgXCJwZXJtaXNvXCIsXG4gICAgXCJwZXJyb1wiLFxuICAgIFwicGVyc29uYVwiLFxuICAgIFwicGVzYVwiLFxuICAgIFwicGVzY2FcIixcbiAgICBcInBlzIFzaW1vXCIsXG4gICAgXCJwZXN0YW7Mg2FcIixcbiAgICBcInBlzIF0YWxvXCIsXG4gICAgXCJwZXRyb8yBbGVvXCIsXG4gICAgXCJwZXpcIixcbiAgICBcInBlenVuzINhXCIsXG4gICAgXCJwaWNhclwiLFxuICAgIFwicGljaG/MgW5cIixcbiAgICBcInBpZVwiLFxuICAgIFwicGllZHJhXCIsXG4gICAgXCJwaWVybmFcIixcbiAgICBcInBpZXphXCIsXG4gICAgXCJwaWphbWFcIixcbiAgICBcInBpbGFyXCIsXG4gICAgXCJwaWxvdG9cIixcbiAgICBcInBpbWllbnRhXCIsXG4gICAgXCJwaW5vXCIsXG4gICAgXCJwaW50b3JcIixcbiAgICBcInBpbnphXCIsXG4gICAgXCJwaW7Mg2FcIixcbiAgICBcInBpb2pvXCIsXG4gICAgXCJwaXBhXCIsXG4gICAgXCJwaXJhdGFcIixcbiAgICBcInBpc2FyXCIsXG4gICAgXCJwaXNjaW5hXCIsXG4gICAgXCJwaXNvXCIsXG4gICAgXCJwaXN0YVwiLFxuICAgIFwicGl0b8yBblwiLFxuICAgIFwicGl6Y2FcIixcbiAgICBcInBsYWNhXCIsXG4gICAgXCJwbGFuXCIsXG4gICAgXCJwbGF0YVwiLFxuICAgIFwicGxheWFcIixcbiAgICBcInBsYXphXCIsXG4gICAgXCJwbGVpdG9cIixcbiAgICBcInBsZW5vXCIsXG4gICAgXCJwbG9tb1wiLFxuICAgIFwicGx1bWFcIixcbiAgICBcInBsdXJhbFwiLFxuICAgIFwicG9icmVcIixcbiAgICBcInBvY29cIixcbiAgICBcInBvZGVyXCIsXG4gICAgXCJwb2Rpb1wiLFxuICAgIFwicG9lbWFcIixcbiAgICBcInBvZXNpzIFhXCIsXG4gICAgXCJwb2V0YVwiLFxuICAgIFwicG9sZW5cIixcbiAgICBcInBvbGljacyBYVwiLFxuICAgIFwicG9sbG9cIixcbiAgICBcInBvbHZvXCIsXG4gICAgXCJwb21hZGFcIixcbiAgICBcInBvbWVsb1wiLFxuICAgIFwicG9tb1wiLFxuICAgIFwicG9tcGFcIixcbiAgICBcInBvbmVyXCIsXG4gICAgXCJwb3JjaW/MgW5cIixcbiAgICBcInBvcnRhbFwiLFxuICAgIFwicG9zYWRhXCIsXG4gICAgXCJwb3NlZXJcIixcbiAgICBcInBvc2libGVcIixcbiAgICBcInBvc3RlXCIsXG4gICAgXCJwb3RlbmNpYVwiLFxuICAgIFwicG90cm9cIixcbiAgICBcInBvem9cIixcbiAgICBcInByYWRvXCIsXG4gICAgXCJwcmVjb3pcIixcbiAgICBcInByZWd1bnRhXCIsXG4gICAgXCJwcmVtaW9cIixcbiAgICBcInByZW5zYVwiLFxuICAgIFwicHJlc29cIixcbiAgICBcInByZXZpb1wiLFxuICAgIFwicHJpbW9cIixcbiAgICBcInByacyBbmNpcGVcIixcbiAgICBcInByaXNpb8yBblwiLFxuICAgIFwicHJpdmFyXCIsXG4gICAgXCJwcm9hXCIsXG4gICAgXCJwcm9iYXJcIixcbiAgICBcInByb2Nlc29cIixcbiAgICBcInByb2R1Y3RvXCIsXG4gICAgXCJwcm9lemFcIixcbiAgICBcInByb2Zlc29yXCIsXG4gICAgXCJwcm9ncmFtYVwiLFxuICAgIFwicHJvbGVcIixcbiAgICBcInByb21lc2FcIixcbiAgICBcInByb250b1wiLFxuICAgIFwicHJvcGlvXCIsXG4gICAgXCJwcm/MgXhpbW9cIixcbiAgICBcInBydWViYVwiLFxuICAgIFwicHXMgWJsaWNvXCIsXG4gICAgXCJwdWNoZXJvXCIsXG4gICAgXCJwdWRvclwiLFxuICAgIFwicHVlYmxvXCIsXG4gICAgXCJwdWVydGFcIixcbiAgICBcInB1ZXN0b1wiLFxuICAgIFwicHVsZ2FcIixcbiAgICBcInB1bGlyXCIsXG4gICAgXCJwdWxtb8yBblwiLFxuICAgIFwicHVscG9cIixcbiAgICBcInB1bHNvXCIsXG4gICAgXCJwdW1hXCIsXG4gICAgXCJwdW50b1wiLFxuICAgIFwicHVuzINhbFwiLFxuICAgIFwicHVuzINvXCIsXG4gICAgXCJwdXBhXCIsXG4gICAgXCJwdXBpbGFcIixcbiAgICBcInB1cmXMgVwiLFxuICAgIFwicXVlZGFyXCIsXG4gICAgXCJxdWVqYVwiLFxuICAgIFwicXVlbWFyXCIsXG4gICAgXCJxdWVyZXJcIixcbiAgICBcInF1ZXNvXCIsXG4gICAgXCJxdWlldG9cIixcbiAgICBcInF1acyBbWljYVwiLFxuICAgIFwicXVpbmNlXCIsXG4gICAgXCJxdWl0YXJcIixcbiAgICBcInJhzIFiYW5vXCIsXG4gICAgXCJyYWJpYVwiLFxuICAgIFwicmFib1wiLFxuICAgIFwicmFjaW/MgW5cIixcbiAgICBcInJhZGljYWxcIixcbiAgICBcInJhacyBelwiLFxuICAgIFwicmFtYVwiLFxuICAgIFwicmFtcGFcIixcbiAgICBcInJhbmNob1wiLFxuICAgIFwicmFuZ29cIixcbiAgICBcInJhcGF6XCIsXG4gICAgXCJyYcyBcGlkb1wiLFxuICAgIFwicmFwdG9cIixcbiAgICBcInJhc2dvXCIsXG4gICAgXCJyYXNwYVwiLFxuICAgIFwicmF0b1wiLFxuICAgIFwicmF5b1wiLFxuICAgIFwicmF6YVwiLFxuICAgIFwicmF6b8yBblwiLFxuICAgIFwicmVhY2Npb8yBblwiLFxuICAgIFwicmVhbGlkYWRcIixcbiAgICBcInJlYmFuzINvXCIsXG4gICAgXCJyZWJvdGVcIixcbiAgICBcInJlY2FlclwiLFxuICAgIFwicmVjZXRhXCIsXG4gICAgXCJyZWNoYXpvXCIsXG4gICAgXCJyZWNvZ2VyXCIsXG4gICAgXCJyZWNyZW9cIixcbiAgICBcInJlY3RvXCIsXG4gICAgXCJyZWN1cnNvXCIsXG4gICAgXCJyZWRcIixcbiAgICBcInJlZG9uZG9cIixcbiAgICBcInJlZHVjaXJcIixcbiAgICBcInJlZmxlam9cIixcbiAgICBcInJlZm9ybWFcIixcbiAgICBcInJlZnJhzIFuXCIsXG4gICAgXCJyZWZ1Z2lvXCIsXG4gICAgXCJyZWdhbG9cIixcbiAgICBcInJlZ2lyXCIsXG4gICAgXCJyZWdsYVwiLFxuICAgIFwicmVncmVzb1wiLFxuICAgIFwicmVoZcyBblwiLFxuICAgIFwicmVpbm9cIixcbiAgICBcInJlacyBclwiLFxuICAgIFwicmVqYVwiLFxuICAgIFwicmVsYXRvXCIsXG4gICAgXCJyZWxldm9cIixcbiAgICBcInJlbGlldmVcIixcbiAgICBcInJlbGxlbm9cIixcbiAgICBcInJlbG9qXCIsXG4gICAgXCJyZW1hclwiLFxuICAgIFwicmVtZWRpb1wiLFxuICAgIFwicmVtb1wiLFxuICAgIFwicmVuY29yXCIsXG4gICAgXCJyZW5kaXJcIixcbiAgICBcInJlbnRhXCIsXG4gICAgXCJyZXBhcnRvXCIsXG4gICAgXCJyZXBldGlyXCIsXG4gICAgXCJyZXBvc29cIixcbiAgICBcInJlcHRpbFwiLFxuICAgIFwicmVzXCIsXG4gICAgXCJyZXNjYXRlXCIsXG4gICAgXCJyZXNpbmFcIixcbiAgICBcInJlc3BldG9cIixcbiAgICBcInJlc3RvXCIsXG4gICAgXCJyZXN1bWVuXCIsXG4gICAgXCJyZXRpcm9cIixcbiAgICBcInJldG9ybm9cIixcbiAgICBcInJldHJhdG9cIixcbiAgICBcInJldW5pclwiLFxuICAgIFwicmV2ZcyBc1wiLFxuICAgIFwicmV2aXN0YVwiLFxuICAgIFwicmV5XCIsXG4gICAgXCJyZXphclwiLFxuICAgIFwicmljb1wiLFxuICAgIFwicmllZ29cIixcbiAgICBcInJpZW5kYVwiLFxuICAgIFwicmllc2dvXCIsXG4gICAgXCJyaWZhXCIsXG4gICAgXCJyacyBZ2lkb1wiLFxuICAgIFwicmlnb3JcIixcbiAgICBcInJpbmNvzIFuXCIsXG4gICAgXCJyaW7Mg2/MgW5cIixcbiAgICBcInJpzIFvXCIsXG4gICAgXCJyaXF1ZXphXCIsXG4gICAgXCJyaXNhXCIsXG4gICAgXCJyaXRtb1wiLFxuICAgIFwicml0b1wiLFxuICAgIFwicml6b1wiLFxuICAgIFwicm9ibGVcIixcbiAgICBcInJvY2VcIixcbiAgICBcInJvY2lhclwiLFxuICAgIFwicm9kYXJcIixcbiAgICBcInJvZGVvXCIsXG4gICAgXCJyb2RpbGxhXCIsXG4gICAgXCJyb2VyXCIsXG4gICAgXCJyb2ppem9cIixcbiAgICBcInJvam9cIixcbiAgICBcInJvbWVyb1wiLFxuICAgIFwicm9tcGVyXCIsXG4gICAgXCJyb25cIixcbiAgICBcInJvbmNvXCIsXG4gICAgXCJyb25kYVwiLFxuICAgIFwicm9wYVwiLFxuICAgIFwicm9wZXJvXCIsXG4gICAgXCJyb3NhXCIsXG4gICAgXCJyb3NjYVwiLFxuICAgIFwicm9zdHJvXCIsXG4gICAgXCJyb3RhclwiLFxuICAgIFwicnViacyBXCIsXG4gICAgXCJydWJvclwiLFxuICAgIFwicnVkb1wiLFxuICAgIFwicnVlZGFcIixcbiAgICBcInJ1Z2lyXCIsXG4gICAgXCJydWlkb1wiLFxuICAgIFwicnVpbmFcIixcbiAgICBcInJ1bGV0YVwiLFxuICAgIFwicnVsb1wiLFxuICAgIFwicnVtYm9cIixcbiAgICBcInJ1bW9yXCIsXG4gICAgXCJydXB0dXJhXCIsXG4gICAgXCJydXRhXCIsXG4gICAgXCJydXRpbmFcIixcbiAgICBcInNhzIFiYWRvXCIsXG4gICAgXCJzYWJlclwiLFxuICAgIFwic2FiaW9cIixcbiAgICBcInNhYmxlXCIsXG4gICAgXCJzYWNhclwiLFxuICAgIFwic2FnYXpcIixcbiAgICBcInNhZ3JhZG9cIixcbiAgICBcInNhbGFcIixcbiAgICBcInNhbGRvXCIsXG4gICAgXCJzYWxlcm9cIixcbiAgICBcInNhbGlyXCIsXG4gICAgXCJzYWxtb8yBblwiLFxuICAgIFwic2Fsb8yBblwiLFxuICAgIFwic2Fsc2FcIixcbiAgICBcInNhbHRvXCIsXG4gICAgXCJzYWx1ZFwiLFxuICAgIFwic2FsdmFyXCIsXG4gICAgXCJzYW1iYVwiLFxuICAgIFwic2FuY2lvzIFuXCIsXG4gICAgXCJzYW5kacyBYVwiLFxuICAgIFwic2FuZWFyXCIsXG4gICAgXCJzYW5ncmVcIixcbiAgICBcInNhbmlkYWRcIixcbiAgICBcInNhbm9cIixcbiAgICBcInNhbnRvXCIsXG4gICAgXCJzYXBvXCIsXG4gICAgXCJzYXF1ZVwiLFxuICAgIFwic2FyZGluYVwiLFxuICAgIFwic2FydGXMgW5cIixcbiAgICBcInNhc3RyZVwiLFxuICAgIFwic2F0YcyBblwiLFxuICAgIFwic2F1bmFcIixcbiAgICBcInNheG9mb8yBblwiLFxuICAgIFwic2VjY2lvzIFuXCIsXG4gICAgXCJzZWNvXCIsXG4gICAgXCJzZWNyZXRvXCIsXG4gICAgXCJzZWN0YVwiLFxuICAgIFwic2VkXCIsXG4gICAgXCJzZWd1aXJcIixcbiAgICBcInNlaXNcIixcbiAgICBcInNlbGxvXCIsXG4gICAgXCJzZWx2YVwiLFxuICAgIFwic2VtYW5hXCIsXG4gICAgXCJzZW1pbGxhXCIsXG4gICAgXCJzZW5kYVwiLFxuICAgIFwic2Vuc29yXCIsXG4gICAgXCJzZW7Mg2FsXCIsXG4gICAgXCJzZW7Mg29yXCIsXG4gICAgXCJzZXBhcmFyXCIsXG4gICAgXCJzZXBpYVwiLFxuICAgIFwic2VxdWnMgWFcIixcbiAgICBcInNlclwiLFxuICAgIFwic2VyaWVcIixcbiAgICBcInNlcm1vzIFuXCIsXG4gICAgXCJzZXJ2aXJcIixcbiAgICBcInNlc2VudGFcIixcbiAgICBcInNlc2lvzIFuXCIsXG4gICAgXCJzZXRhXCIsXG4gICAgXCJzZXRlbnRhXCIsXG4gICAgXCJzZXZlcm9cIixcbiAgICBcInNleG9cIixcbiAgICBcInNleHRvXCIsXG4gICAgXCJzaWRyYVwiLFxuICAgIFwic2llc3RhXCIsXG4gICAgXCJzaWV0ZVwiLFxuICAgIFwic2lnbG9cIixcbiAgICBcInNpZ25vXCIsXG4gICAgXCJzacyBbGFiYVwiLFxuICAgIFwic2lsYmFyXCIsXG4gICAgXCJzaWxlbmNpb1wiLFxuICAgIFwic2lsbGFcIixcbiAgICBcInNpzIFtYm9sb1wiLFxuICAgIFwic2ltaW9cIixcbiAgICBcInNpcmVuYVwiLFxuICAgIFwic2lzdGVtYVwiLFxuICAgIFwic2l0aW9cIixcbiAgICBcInNpdHVhclwiLFxuICAgIFwic29icmVcIixcbiAgICBcInNvY2lvXCIsXG4gICAgXCJzb2Rpb1wiLFxuICAgIFwic29sXCIsXG4gICAgXCJzb2xhcGFcIixcbiAgICBcInNvbGRhZG9cIixcbiAgICBcInNvbGVkYWRcIixcbiAgICBcInNvzIFsaWRvXCIsXG4gICAgXCJzb2x0YXJcIixcbiAgICBcInNvbHVjaW/MgW5cIixcbiAgICBcInNvbWJyYVwiLFxuICAgIFwic29uZGVvXCIsXG4gICAgXCJzb25pZG9cIixcbiAgICBcInNvbm9yb1wiLFxuICAgIFwic29ucmlzYVwiLFxuICAgIFwic29wYVwiLFxuICAgIFwic29wbGFyXCIsXG4gICAgXCJzb3BvcnRlXCIsXG4gICAgXCJzb3Jkb1wiLFxuICAgIFwic29ycHJlc2FcIixcbiAgICBcInNvcnRlb1wiLFxuICAgIFwic29zdGXMgW5cIixcbiAgICBcInNvzIF0YW5vXCIsXG4gICAgXCJzdWF2ZVwiLFxuICAgIFwic3ViaXJcIixcbiAgICBcInN1Y2Vzb1wiLFxuICAgIFwic3Vkb3JcIixcbiAgICBcInN1ZWdyYVwiLFxuICAgIFwic3VlbG9cIixcbiAgICBcInN1ZW7Mg29cIixcbiAgICBcInN1ZXJ0ZVwiLFxuICAgIFwic3VmcmlyXCIsXG4gICAgXCJzdWpldG9cIixcbiAgICBcInN1bHRhzIFuXCIsXG4gICAgXCJzdW1hclwiLFxuICAgIFwic3VwZXJhclwiLFxuICAgIFwic3VwbGlyXCIsXG4gICAgXCJzdXBvbmVyXCIsXG4gICAgXCJzdXByZW1vXCIsXG4gICAgXCJzdXJcIixcbiAgICBcInN1cmNvXCIsXG4gICAgXCJzdXJlbsyDb1wiLFxuICAgIFwic3VyZ2lyXCIsXG4gICAgXCJzdXN0b1wiLFxuICAgIFwic3V0aWxcIixcbiAgICBcInRhYmFjb1wiLFxuICAgIFwidGFiaXF1ZVwiLFxuICAgIFwidGFibGFcIixcbiAgICBcInRhYnXMgVwiLFxuICAgIFwidGFjb1wiLFxuICAgIFwidGFjdG9cIixcbiAgICBcInRham9cIixcbiAgICBcInRhbGFyXCIsXG4gICAgXCJ0YWxjb1wiLFxuICAgIFwidGFsZW50b1wiLFxuICAgIFwidGFsbGFcIixcbiAgICBcInRhbG/MgW5cIixcbiAgICBcInRhbWFuzINvXCIsXG4gICAgXCJ0YW1ib3JcIixcbiAgICBcInRhbmdvXCIsXG4gICAgXCJ0YW5xdWVcIixcbiAgICBcInRhcGFcIixcbiAgICBcInRhcGV0ZVwiLFxuICAgIFwidGFwaWFcIixcbiAgICBcInRhcG/MgW5cIixcbiAgICBcInRhcXVpbGxhXCIsXG4gICAgXCJ0YXJkZVwiLFxuICAgIFwidGFyZWFcIixcbiAgICBcInRhcmlmYVwiLFxuICAgIFwidGFyamV0YVwiLFxuICAgIFwidGFyb3RcIixcbiAgICBcInRhcnJvXCIsXG4gICAgXCJ0YXJ0YVwiLFxuICAgIFwidGF0dWFqZVwiLFxuICAgIFwidGF1cm9cIixcbiAgICBcInRhemFcIixcbiAgICBcInRhem/MgW5cIixcbiAgICBcInRlYXRyb1wiLFxuICAgIFwidGVjaG9cIixcbiAgICBcInRlY2xhXCIsXG4gICAgXCJ0ZcyBY25pY2FcIixcbiAgICBcInRlamFkb1wiLFxuICAgIFwidGVqZXJcIixcbiAgICBcInRlamlkb1wiLFxuICAgIFwidGVsYVwiLFxuICAgIFwidGVsZcyBZm9ub1wiLFxuICAgIFwidGVtYVwiLFxuICAgIFwidGVtb3JcIixcbiAgICBcInRlbXBsb1wiLFxuICAgIFwidGVuYXpcIixcbiAgICBcInRlbmRlclwiLFxuICAgIFwidGVuZXJcIixcbiAgICBcInRlbmlzXCIsXG4gICAgXCJ0ZW5zb1wiLFxuICAgIFwidGVvcmnMgWFcIixcbiAgICBcInRlcmFwaWFcIixcbiAgICBcInRlcmNvXCIsXG4gICAgXCJ0ZcyBcm1pbm9cIixcbiAgICBcInRlcm51cmFcIixcbiAgICBcInRlcnJvclwiLFxuICAgIFwidGVzaXNcIixcbiAgICBcInRlc29yb1wiLFxuICAgIFwidGVzdGlnb1wiLFxuICAgIFwidGV0ZXJhXCIsXG4gICAgXCJ0ZXh0b1wiLFxuICAgIFwidGV6XCIsXG4gICAgXCJ0aWJpb1wiLFxuICAgIFwidGlidXJvzIFuXCIsXG4gICAgXCJ0aWVtcG9cIixcbiAgICBcInRpZW5kYVwiLFxuICAgIFwidGllcnJhXCIsXG4gICAgXCJ0aWVzb1wiLFxuICAgIFwidGlncmVcIixcbiAgICBcInRpamVyYVwiLFxuICAgIFwidGlsZGVcIixcbiAgICBcInRpbWJyZVwiLFxuICAgIFwidGnMgW1pZG9cIixcbiAgICBcInRpbW9cIixcbiAgICBcInRpbnRhXCIsXG4gICAgXCJ0acyBb1wiLFxuICAgIFwidGnMgXBpY29cIixcbiAgICBcInRpcG9cIixcbiAgICBcInRpcmFcIixcbiAgICBcInRpcm/MgW5cIixcbiAgICBcInRpdGHMgW5cIixcbiAgICBcInRpzIF0ZXJlXCIsXG4gICAgXCJ0acyBdHVsb1wiLFxuICAgIFwidGl6YVwiLFxuICAgIFwidG9hbGxhXCIsXG4gICAgXCJ0b2JpbGxvXCIsXG4gICAgXCJ0b2NhclwiLFxuICAgIFwidG9jaW5vXCIsXG4gICAgXCJ0b2RvXCIsXG4gICAgXCJ0b2dhXCIsXG4gICAgXCJ0b2xkb1wiLFxuICAgIFwidG9tYXJcIixcbiAgICBcInRvbm9cIixcbiAgICBcInRvbnRvXCIsXG4gICAgXCJ0b3BhclwiLFxuICAgIFwidG9wZVwiLFxuICAgIFwidG9xdWVcIixcbiAgICBcInRvzIFyYXhcIixcbiAgICBcInRvcmVyb1wiLFxuICAgIFwidG9ybWVudGFcIixcbiAgICBcInRvcm5lb1wiLFxuICAgIFwidG9yb1wiLFxuICAgIFwidG9ycGVkb1wiLFxuICAgIFwidG9ycmVcIixcbiAgICBcInRvcnNvXCIsXG4gICAgXCJ0b3J0dWdhXCIsXG4gICAgXCJ0b3NcIixcbiAgICBcInRvc2NvXCIsXG4gICAgXCJ0b3NlclwiLFxuICAgIFwidG/MgXhpY29cIixcbiAgICBcInRyYWJham9cIixcbiAgICBcInRyYWN0b3JcIixcbiAgICBcInRyYWVyXCIsXG4gICAgXCJ0cmHMgWZpY29cIixcbiAgICBcInRyYWdvXCIsXG4gICAgXCJ0cmFqZVwiLFxuICAgIFwidHJhbW9cIixcbiAgICBcInRyYW5jZVwiLFxuICAgIFwidHJhdG9cIixcbiAgICBcInRyYXVtYVwiLFxuICAgIFwidHJhemFyXCIsXG4gICAgXCJ0cmXMgWJvbFwiLFxuICAgIFwidHJlZ3VhXCIsXG4gICAgXCJ0cmVpbnRhXCIsXG4gICAgXCJ0cmVuXCIsXG4gICAgXCJ0cmVwYXJcIixcbiAgICBcInRyZXNcIixcbiAgICBcInRyaWJ1XCIsXG4gICAgXCJ0cmlnb1wiLFxuICAgIFwidHJpcGFcIixcbiAgICBcInRyaXN0ZVwiLFxuICAgIFwidHJpdW5mb1wiLFxuICAgIFwidHJvZmVvXCIsXG4gICAgXCJ0cm9tcGFcIixcbiAgICBcInRyb25jb1wiLFxuICAgIFwidHJvcGFcIixcbiAgICBcInRyb3RlXCIsXG4gICAgXCJ0cm96b1wiLFxuICAgIFwidHJ1Y29cIixcbiAgICBcInRydWVub1wiLFxuICAgIFwidHJ1ZmFcIixcbiAgICBcInR1YmVyacyBYVwiLFxuICAgIFwidHVib1wiLFxuICAgIFwidHVlcnRvXCIsXG4gICAgXCJ0dW1iYVwiLFxuICAgIFwidHVtb3JcIixcbiAgICBcInR1zIFuZWxcIixcbiAgICBcInR1zIFuaWNhXCIsXG4gICAgXCJ0dXJiaW5hXCIsXG4gICAgXCJ0dXJpc21vXCIsXG4gICAgXCJ0dXJub1wiLFxuICAgIFwidHV0b3JcIixcbiAgICBcInViaWNhclwiLFxuICAgIFwidcyBbGNlcmFcIixcbiAgICBcInVtYnJhbFwiLFxuICAgIFwidW5pZGFkXCIsXG4gICAgXCJ1bmlyXCIsXG4gICAgXCJ1bml2ZXJzb1wiLFxuICAgIFwidW5vXCIsXG4gICAgXCJ1bnRhclwiLFxuICAgIFwidW7Mg2FcIixcbiAgICBcInVyYmFub1wiLFxuICAgIFwidXJiZVwiLFxuICAgIFwidXJnZW50ZVwiLFxuICAgIFwidXJuYVwiLFxuICAgIFwidXNhclwiLFxuICAgIFwidXN1YXJpb1wiLFxuICAgIFwidcyBdGlsXCIsXG4gICAgXCJ1dG9wacyBYVwiLFxuICAgIFwidXZhXCIsXG4gICAgXCJ2YWNhXCIsXG4gICAgXCJ2YWNpzIFvXCIsXG4gICAgXCJ2YWN1bmFcIixcbiAgICBcInZhZ2FyXCIsXG4gICAgXCJ2YWdvXCIsXG4gICAgXCJ2YWluYVwiLFxuICAgIFwidmFqaWxsYVwiLFxuICAgIFwidmFsZVwiLFxuICAgIFwidmHMgWxpZG9cIixcbiAgICBcInZhbGxlXCIsXG4gICAgXCJ2YWxvclwiLFxuICAgIFwidmHMgWx2dWxhXCIsXG4gICAgXCJ2YW1waXJvXCIsXG4gICAgXCJ2YXJhXCIsXG4gICAgXCJ2YXJpYXJcIixcbiAgICBcInZhcm/MgW5cIixcbiAgICBcInZhc29cIixcbiAgICBcInZlY2lub1wiLFxuICAgIFwidmVjdG9yXCIsXG4gICAgXCJ2ZWhpzIFjdWxvXCIsXG4gICAgXCJ2ZWludGVcIixcbiAgICBcInZlamV6XCIsXG4gICAgXCJ2ZWxhXCIsXG4gICAgXCJ2ZWxlcm9cIixcbiAgICBcInZlbG96XCIsXG4gICAgXCJ2ZW5hXCIsXG4gICAgXCJ2ZW5jZXJcIixcbiAgICBcInZlbmRhXCIsXG4gICAgXCJ2ZW5lbm9cIixcbiAgICBcInZlbmdhclwiLFxuICAgIFwidmVuaXJcIixcbiAgICBcInZlbnRhXCIsXG4gICAgXCJ2ZW51c1wiLFxuICAgIFwidmVyXCIsXG4gICAgXCJ2ZXJhbm9cIixcbiAgICBcInZlcmJvXCIsXG4gICAgXCJ2ZXJkZVwiLFxuICAgIFwidmVyZWRhXCIsXG4gICAgXCJ2ZXJqYVwiLFxuICAgIFwidmVyc29cIixcbiAgICBcInZlcnRlclwiLFxuICAgIFwidmnMgWFcIixcbiAgICBcInZpYWplXCIsXG4gICAgXCJ2aWJyYXJcIixcbiAgICBcInZpY2lvXCIsXG4gICAgXCJ2acyBY3RpbWFcIixcbiAgICBcInZpZGFcIixcbiAgICBcInZpzIFkZW9cIixcbiAgICBcInZpZHJpb1wiLFxuICAgIFwidmllam9cIixcbiAgICBcInZpZXJuZXNcIixcbiAgICBcInZpZ29yXCIsXG4gICAgXCJ2aWxcIixcbiAgICBcInZpbGxhXCIsXG4gICAgXCJ2aW5hZ3JlXCIsXG4gICAgXCJ2aW5vXCIsXG4gICAgXCJ2aW7Mg2Vkb1wiLFxuICAgIFwidmlvbGnMgW5cIixcbiAgICBcInZpcmFsXCIsXG4gICAgXCJ2aXJnb1wiLFxuICAgIFwidmlydHVkXCIsXG4gICAgXCJ2aXNvclwiLFxuICAgIFwidmnMgXNwZXJhXCIsXG4gICAgXCJ2aXN0YVwiLFxuICAgIFwidml0YW1pbmFcIixcbiAgICBcInZpdWRvXCIsXG4gICAgXCJ2aXZhelwiLFxuICAgIFwidml2ZXJvXCIsXG4gICAgXCJ2aXZpclwiLFxuICAgIFwidml2b1wiLFxuICAgIFwidm9sY2HMgW5cIixcbiAgICBcInZvbHVtZW5cIixcbiAgICBcInZvbHZlclwiLFxuICAgIFwidm9yYXpcIixcbiAgICBcInZvdGFyXCIsXG4gICAgXCJ2b3RvXCIsXG4gICAgXCJ2b3pcIixcbiAgICBcInZ1ZWxvXCIsXG4gICAgXCJ2dWxnYXJcIixcbiAgICBcInlhY2VyXCIsXG4gICAgXCJ5YXRlXCIsXG4gICAgXCJ5ZWd1YVwiLFxuICAgIFwieWVtYVwiLFxuICAgIFwieWVybm9cIixcbiAgICBcInllc29cIixcbiAgICBcInlvZG9cIixcbiAgICBcInlvZ2FcIixcbiAgICBcInlvZ3VyXCIsXG4gICAgXCJ6YWZpcm9cIixcbiAgICBcInphbmphXCIsXG4gICAgXCJ6YXBhdG9cIixcbiAgICBcInphcnphXCIsXG4gICAgXCJ6b25hXCIsXG4gICAgXCJ6b3Jyb1wiLFxuICAgIFwienVtb1wiLFxuICAgIFwienVyZG9cIlxuXVxuIiwibW9kdWxlLmV4cG9ydHM9W1xuICAgIFwiYWJhY2F0ZVwiLFxuICAgIFwiYWJhaXhvXCIsXG4gICAgXCJhYmFsYXJcIixcbiAgICBcImFiYXRlclwiLFxuICAgIFwiYWJkdXppclwiLFxuICAgIFwiYWJlbGhhXCIsXG4gICAgXCJhYmVydG9cIixcbiAgICBcImFiaXNtb1wiLFxuICAgIFwiYWJvdG9hclwiLFxuICAgIFwiYWJyYW5nZXJcIixcbiAgICBcImFicmV2aWFyXCIsXG4gICAgXCJhYnJpZ2FyXCIsXG4gICAgXCJhYnJ1cHRvXCIsXG4gICAgXCJhYnNpbnRvXCIsXG4gICAgXCJhYnNvbHV0b1wiLFxuICAgIFwiYWJzdXJkb1wiLFxuICAgIFwiYWJ1dHJlXCIsXG4gICAgXCJhY2FiYWRvXCIsXG4gICAgXCJhY2FsbWFyXCIsXG4gICAgXCJhY2FtcGFyXCIsXG4gICAgXCJhY2FuaGFyXCIsXG4gICAgXCJhY2Fzb1wiLFxuICAgIFwiYWNlaXRhclwiLFxuICAgIFwiYWNlbGVyYXJcIixcbiAgICBcImFjZW5hclwiLFxuICAgIFwiYWNlcnZvXCIsXG4gICAgXCJhY2Vzc2FyXCIsXG4gICAgXCJhY2V0b25hXCIsXG4gICAgXCJhY2hhdGFyXCIsXG4gICAgXCJhY2lkZXpcIixcbiAgICBcImFjaW1hXCIsXG4gICAgXCJhY2lvbmFkb1wiLFxuICAgIFwiYWNpcnJhclwiLFxuICAgIFwiYWNsYW1hclwiLFxuICAgIFwiYWNsaXZlXCIsXG4gICAgXCJhY29saGlkYVwiLFxuICAgIFwiYWNvbW9kYXJcIixcbiAgICBcImFjb3BsYXJcIixcbiAgICBcImFjb3JkYXJcIixcbiAgICBcImFjdW11bGFyXCIsXG4gICAgXCJhY3VzYWRvclwiLFxuICAgIFwiYWRhcHRhclwiLFxuICAgIFwiYWRlZ2FcIixcbiAgICBcImFkZW50cm9cIixcbiAgICBcImFkZXB0b1wiLFxuICAgIFwiYWRlcXVhclwiLFxuICAgIFwiYWRlcmVudGVcIixcbiAgICBcImFkZXNpdm9cIixcbiAgICBcImFkZXVzXCIsXG4gICAgXCJhZGlhbnRlXCIsXG4gICAgXCJhZGl0aXZvXCIsXG4gICAgXCJhZGpldGl2b1wiLFxuICAgIFwiYWRqdW50b1wiLFxuICAgIFwiYWRtaXJhclwiLFxuICAgIFwiYWRvcmFyXCIsXG4gICAgXCJhZHF1aXJpclwiLFxuICAgIFwiYWR1Ym9cIixcbiAgICBcImFkdmVyc29cIixcbiAgICBcImFkdm9nYWRvXCIsXG4gICAgXCJhZXJvbmF2ZVwiLFxuICAgIFwiYWZhc3RhclwiLFxuICAgIFwiYWZlcmlyXCIsXG4gICAgXCJhZmV0aXZvXCIsXG4gICAgXCJhZmluYWRvclwiLFxuICAgIFwiYWZpdmVsYXJcIixcbiAgICBcImFmbGl0b1wiLFxuICAgIFwiYWZsdWVudGVcIixcbiAgICBcImFmcm9udGFyXCIsXG4gICAgXCJhZ2FjaGFyXCIsXG4gICAgXCJhZ2FycmFyXCIsXG4gICAgXCJhZ2FzYWxob1wiLFxuICAgIFwiYWdlbmNpYXJcIixcbiAgICBcImFnaWxpemFyXCIsXG4gICAgXCJhZ2lvdGFcIixcbiAgICBcImFnaXRhZG9cIixcbiAgICBcImFnb3JhXCIsXG4gICAgXCJhZ3JhZGFyXCIsXG4gICAgXCJhZ3Jlc3RlXCIsXG4gICAgXCJhZ3J1cGFyXCIsXG4gICAgXCJhZ3VhcmRhclwiLFxuICAgIFwiYWd1bGhhXCIsXG4gICAgXCJham9lbGhhclwiLFxuICAgIFwiYWp1ZGFyXCIsXG4gICAgXCJhanVzdGFyXCIsXG4gICAgXCJhbGFtZWRhXCIsXG4gICAgXCJhbGFybWVcIixcbiAgICBcImFsYXN0cmFyXCIsXG4gICAgXCJhbGF2YW5jYVwiLFxuICAgIFwiYWxiZXJndWVcIixcbiAgICBcImFsYmlub1wiLFxuICAgIFwiYWxjYXRyYVwiLFxuICAgIFwiYWxkZWlhXCIsXG4gICAgXCJhbGVjcmltXCIsXG4gICAgXCJhbGVncmlhXCIsXG4gICAgXCJhbGVydGFyXCIsXG4gICAgXCJhbGZhY2VcIixcbiAgICBcImFsZmluZXRlXCIsXG4gICAgXCJhbGd1bVwiLFxuICAgIFwiYWxoZWlvXCIsXG4gICAgXCJhbGlhclwiLFxuICAgIFwiYWxpY2F0ZVwiLFxuICAgIFwiYWxpZW5hclwiLFxuICAgIFwiYWxpbmhhclwiLFxuICAgIFwiYWxpdmlhclwiLFxuICAgIFwiYWxtb2ZhZGFcIixcbiAgICBcImFsb2NhclwiLFxuICAgIFwiYWxwaXN0ZVwiLFxuICAgIFwiYWx0ZXJhclwiLFxuICAgIFwiYWx0aXR1ZGVcIixcbiAgICBcImFsdWNpbmFyXCIsXG4gICAgXCJhbHVnYXJcIixcbiAgICBcImFsdW5vXCIsXG4gICAgXCJhbHVzaXZvXCIsXG4gICAgXCJhbHZvXCIsXG4gICAgXCJhbWFjaWFyXCIsXG4gICAgXCJhbWFkb3JcIixcbiAgICBcImFtYXJlbG9cIixcbiAgICBcImFtYXNzYXJcIixcbiAgICBcImFtYmFzXCIsXG4gICAgXCJhbWJpZW50ZVwiLFxuICAgIFwiYW1laXhhXCIsXG4gICAgXCJhbWVuaXphclwiLFxuICAgIFwiYW1pZG9cIixcbiAgICBcImFtaXN0b3NvXCIsXG4gICAgXCJhbWl6YWRlXCIsXG4gICAgXCJhbW9sYWRvclwiLFxuICAgIFwiYW1vbnRvYXJcIixcbiAgICBcImFtb3Jvc29cIixcbiAgICBcImFtb3N0cmFcIixcbiAgICBcImFtcGFyYXJcIixcbiAgICBcImFtcGxpYXJcIixcbiAgICBcImFtcG9sYVwiLFxuICAgIFwiYW5hZ3JhbWFcIixcbiAgICBcImFuYWxpc2FyXCIsXG4gICAgXCJhbmFycXVpYVwiLFxuICAgIFwiYW5hdG9taWFcIixcbiAgICBcImFuZGFpbWVcIixcbiAgICBcImFuZWxcIixcbiAgICBcImFuZXhvXCIsXG4gICAgXCJhbmd1bGFyXCIsXG4gICAgXCJhbmltYXJcIixcbiAgICBcImFuam9cIixcbiAgICBcImFub21hbGlhXCIsXG4gICAgXCJhbm90YWRvXCIsXG4gICAgXCJhbnNpb3NvXCIsXG4gICAgXCJhbnRlcmlvclwiLFxuICAgIFwiYW51aWRhZGVcIixcbiAgICBcImFudW5jaWFyXCIsXG4gICAgXCJhbnpvbFwiLFxuICAgIFwiYXBhZ2Fkb3JcIixcbiAgICBcImFwYWxwYXJcIixcbiAgICBcImFwYW5oYWRvXCIsXG4gICAgXCJhcGVnb1wiLFxuICAgIFwiYXBlbGlkb1wiLFxuICAgIFwiYXBlcnRhZGFcIixcbiAgICBcImFwZXNhclwiLFxuICAgIFwiYXBldGl0ZVwiLFxuICAgIFwiYXBpdG9cIixcbiAgICBcImFwbGF1c29cIixcbiAgICBcImFwbGljYWRhXCIsXG4gICAgXCJhcG9pb1wiLFxuICAgIFwiYXBvbnRhclwiLFxuICAgIFwiYXBvc3RhXCIsXG4gICAgXCJhcHJlbmRpelwiLFxuICAgIFwiYXByb3ZhclwiLFxuICAgIFwiYXF1ZWNlclwiLFxuICAgIFwiYXJhbWVcIixcbiAgICBcImFyYW5oYVwiLFxuICAgIFwiYXJhcmFcIixcbiAgICBcImFyY2FkYVwiLFxuICAgIFwiYXJkZW50ZVwiLFxuICAgIFwiYXJlaWFcIixcbiAgICBcImFyZWphclwiLFxuICAgIFwiYXJlbml0b1wiLFxuICAgIFwiYXJlc3RhXCIsXG4gICAgXCJhcmdpbG9zb1wiLFxuICAgIFwiYXJnb2xhXCIsXG4gICAgXCJhcm1hXCIsXG4gICAgXCJhcnF1aXZvXCIsXG4gICAgXCJhcnJhaWFsXCIsXG4gICAgXCJhcnJlYmF0ZVwiLFxuICAgIFwiYXJyaXNjYXJcIixcbiAgICBcImFycm9iYVwiLFxuICAgIFwiYXJydW1hclwiLFxuICAgIFwiYXJzZW5hbFwiLFxuICAgIFwiYXJ0ZXJpYWxcIixcbiAgICBcImFydGlnb1wiLFxuICAgIFwiYXJ2b3JlZG9cIixcbiAgICBcImFzZmFsdGFyXCIsXG4gICAgXCJhc2lsYWRvXCIsXG4gICAgXCJhc3BpcmFyXCIsXG4gICAgXCJhc3NhZG9yXCIsXG4gICAgXCJhc3NpbmFyXCIsXG4gICAgXCJhc3NvYWxob1wiLFxuICAgIFwiYXNzdW50b1wiLFxuICAgIFwiYXN0cmFsXCIsXG4gICAgXCJhdGFjYWRvXCIsXG4gICAgXCJhdGFkdXJhXCIsXG4gICAgXCJhdGFsaG9cIixcbiAgICBcImF0YXJlZmFyXCIsXG4gICAgXCJhdGVhclwiLFxuICAgIFwiYXRlbmRlclwiLFxuICAgIFwiYXRlcnJvXCIsXG4gICAgXCJhdGV1XCIsXG4gICAgXCJhdGluZ2lyXCIsXG4gICAgXCJhdGlyYWRvclwiLFxuICAgIFwiYXRpdm9cIixcbiAgICBcImF0b2xlaXJvXCIsXG4gICAgXCJhdHJhY2FyXCIsXG4gICAgXCJhdHJldmlkb1wiLFxuICAgIFwiYXRyaXpcIixcbiAgICBcImF0dWFsXCIsXG4gICAgXCJhdHVtXCIsXG4gICAgXCJhdWRpdG9yXCIsXG4gICAgXCJhdW1lbnRhclwiLFxuICAgIFwiYXVyYVwiLFxuICAgIFwiYXVyb3JhXCIsXG4gICAgXCJhdXRpc21vXCIsXG4gICAgXCJhdXRvcmlhXCIsXG4gICAgXCJhdXR1YXJcIixcbiAgICBcImF2YWxpYXJcIixcbiAgICBcImF2YW50ZVwiLFxuICAgIFwiYXZhcmlhXCIsXG4gICAgXCJhdmVudGFsXCIsXG4gICAgXCJhdmVzc29cIixcbiAgICBcImF2aWFkb3JcIixcbiAgICBcImF2aXNhclwiLFxuICAgIFwiYXZ1bHNvXCIsXG4gICAgXCJheGlsYVwiLFxuICAgIFwiYXphcmFyXCIsXG4gICAgXCJhemVkb1wiLFxuICAgIFwiYXplaXRlXCIsXG4gICAgXCJhenVsZWpvXCIsXG4gICAgXCJiYWJhclwiLFxuICAgIFwiYmFib3NhXCIsXG4gICAgXCJiYWNhbGhhdVwiLFxuICAgIFwiYmFjaGFyZWxcIixcbiAgICBcImJhY2lhXCIsXG4gICAgXCJiYWdhZ2VtXCIsXG4gICAgXCJiYWlhbm9cIixcbiAgICBcImJhaWxhclwiLFxuICAgIFwiYmFpb25ldGFcIixcbiAgICBcImJhaXJyb1wiLFxuICAgIFwiYmFpeGlzdGFcIixcbiAgICBcImJhanVsYXJcIixcbiAgICBcImJhbGVpYVwiLFxuICAgIFwiYmFsaXphXCIsXG4gICAgXCJiYWxzYVwiLFxuICAgIFwiYmFuYWxcIixcbiAgICBcImJhbmRlaXJhXCIsXG4gICAgXCJiYW5ob1wiLFxuICAgIFwiYmFuaXJcIixcbiAgICBcImJhbnF1ZXRlXCIsXG4gICAgXCJiYXJhdG9cIixcbiAgICBcImJhcmJhZG9cIixcbiAgICBcImJhcm9uZXNhXCIsXG4gICAgXCJiYXJyYWNhXCIsXG4gICAgXCJiYXJ1bGhvXCIsXG4gICAgXCJiYXNlYWRvXCIsXG4gICAgXCJiYXN0YW50ZVwiLFxuICAgIFwiYmF0YXRhXCIsXG4gICAgXCJiYXRlZG9yXCIsXG4gICAgXCJiYXRpZGFcIixcbiAgICBcImJhdG9tXCIsXG4gICAgXCJiYXR1Y2FyXCIsXG4gICAgXCJiYXVuaWxoYVwiLFxuICAgIFwiYmViZXJcIixcbiAgICBcImJlaWpvXCIsXG4gICAgXCJiZWlyYWRhXCIsXG4gICAgXCJiZWlzZWJvbFwiLFxuICAgIFwiYmVsZGFkZVwiLFxuICAgIFwiYmVsZXphXCIsXG4gICAgXCJiZWxnYVwiLFxuICAgIFwiYmVsaXNjYXJcIixcbiAgICBcImJlbmRpdG9cIixcbiAgICBcImJlbmdhbGFcIixcbiAgICBcImJlbnplclwiLFxuICAgIFwiYmVyaW1iYXVcIixcbiAgICBcImJlcmxpbmRhXCIsXG4gICAgXCJiZXJyb1wiLFxuICAgIFwiYmVzb3Vyb1wiLFxuICAgIFwiYmV4aWdhXCIsXG4gICAgXCJiZXplcnJvXCIsXG4gICAgXCJiaWNvXCIsXG4gICAgXCJiaWN1ZG9cIixcbiAgICBcImJpZW5hbFwiLFxuICAgIFwiYmlmb2NhbFwiLFxuICAgIFwiYmlmdXJjYXJcIixcbiAgICBcImJpZ29ybmFcIixcbiAgICBcImJpbGhldGVcIixcbiAgICBcImJpbWVzdHJlXCIsXG4gICAgXCJiaW1vdG9yXCIsXG4gICAgXCJiaW9sb2dpYVwiLFxuICAgIFwiYmlvbWJvXCIsXG4gICAgXCJiaW9zZmVyYVwiLFxuICAgIFwiYmlwb2xhclwiLFxuICAgIFwiYmlycmVudG9cIixcbiAgICBcImJpc2NvaXRvXCIsXG4gICAgXCJiaXNuZXRvXCIsXG4gICAgXCJiaXNwb1wiLFxuICAgIFwiYmlzc2V4dG9cIixcbiAgICBcImJpdG9sYVwiLFxuICAgIFwiYml6YXJyb1wiLFxuICAgIFwiYmxpbmRhZG9cIixcbiAgICBcImJsb2NvXCIsXG4gICAgXCJibG9xdWVhclwiLFxuICAgIFwiYm9hdG9cIixcbiAgICBcImJvYmFnZW1cIixcbiAgICBcImJvY2Fkb1wiLFxuICAgIFwiYm9jZWpvXCIsXG4gICAgXCJib2NoZWNoYVwiLFxuICAgIFwiYm9pY290YXJcIixcbiAgICBcImJvbGFkYVwiLFxuICAgIFwiYm9sZXRpbVwiLFxuICAgIFwiYm9saGFcIixcbiAgICBcImJvbG9cIixcbiAgICBcImJvbWJlaXJvXCIsXG4gICAgXCJib25kZVwiLFxuICAgIFwiYm9uZWNvXCIsXG4gICAgXCJib25pdGFcIixcbiAgICBcImJvcmJ1bGhhXCIsXG4gICAgXCJib3JkYVwiLFxuICAgIFwiYm9yZWFsXCIsXG4gICAgXCJib3JyYWNoYVwiLFxuICAgIFwiYm92aW5vXCIsXG4gICAgXCJib3hlYWRvclwiLFxuICAgIFwiYnJhbmNvXCIsXG4gICAgXCJicmFzYVwiLFxuICAgIFwiYnJhdmV6YVwiLFxuICAgIFwiYnJldVwiLFxuICAgIFwiYnJpZ2FcIixcbiAgICBcImJyaWxob1wiLFxuICAgIFwiYnJpbmNhclwiLFxuICAgIFwiYnJvYVwiLFxuICAgIFwiYnJvY2h1cmFcIixcbiAgICBcImJyb256ZWFyXCIsXG4gICAgXCJicm90b1wiLFxuICAgIFwiYnJ1eG9cIixcbiAgICBcImJ1Y2hhXCIsXG4gICAgXCJidWRpc21vXCIsXG4gICAgXCJidWZhclwiLFxuICAgIFwiYnVsZVwiLFxuICAgIFwiYnVyYWNvXCIsXG4gICAgXCJidXNjYVwiLFxuICAgIFwiYnVzdG9cIixcbiAgICBcImJ1emluYVwiLFxuICAgIFwiY2FiYW5hXCIsXG4gICAgXCJjYWJlbG9cIixcbiAgICBcImNhYmlkZVwiLFxuICAgIFwiY2Fib1wiLFxuICAgIFwiY2Ficml0b1wiLFxuICAgIFwiY2FjYXVcIixcbiAgICBcImNhY2V0YWRhXCIsXG4gICAgXCJjYWNob3Jyb1wiLFxuICAgIFwiY2FjaXF1ZVwiLFxuICAgIFwiY2FkYXN0cm9cIixcbiAgICBcImNhZGVhZG9cIixcbiAgICBcImNhZmV6YWxcIixcbiAgICBcImNhaWFxdWVcIixcbiAgICBcImNhaXBpcmFcIixcbiAgICBcImNhaXhvdGVcIixcbiAgICBcImNhamFkb1wiLFxuICAgIFwiY2FqdVwiLFxuICAgIFwiY2FsYWZyaW9cIixcbiAgICBcImNhbGN1bGFyXCIsXG4gICAgXCJjYWxkZWlyYVwiLFxuICAgIFwiY2FsaWJyYXJcIixcbiAgICBcImNhbG1hbnRlXCIsXG4gICAgXCJjYWxvdGFcIixcbiAgICBcImNhbWFkYVwiLFxuICAgIFwiY2FtYmlzdGFcIixcbiAgICBcImNhbWlzYVwiLFxuICAgIFwiY2Ftb21pbGFcIixcbiAgICBcImNhbXBhbmhhXCIsXG4gICAgXCJjYW11ZmxhclwiLFxuICAgIFwiY2FuYXZpYWxcIixcbiAgICBcImNhbmNlbGFyXCIsXG4gICAgXCJjYW5ldGFcIixcbiAgICBcImNhbmd1cnVcIixcbiAgICBcImNhbmhvdG9cIixcbiAgICBcImNhbml2ZXRlXCIsXG4gICAgXCJjYW5vYVwiLFxuICAgIFwiY2Fuc2Fkb1wiLFxuICAgIFwiY2FudGFyXCIsXG4gICAgXCJjYW51ZG9cIixcbiAgICBcImNhcGFjaG9cIixcbiAgICBcImNhcGVsYVwiLFxuICAgIFwiY2FwaW5hclwiLFxuICAgIFwiY2Fwb3RhclwiLFxuICAgIFwiY2FwcmljaG9cIixcbiAgICBcImNhcHRhZG9yXCIsXG4gICAgXCJjYXB1elwiLFxuICAgIFwiY2FyYWNvbFwiLFxuICAgIFwiY2FyYm9ub1wiLFxuICAgIFwiY2FyZGVhbFwiLFxuICAgIFwiY2FyZWNhXCIsXG4gICAgXCJjYXJpbWJhclwiLFxuICAgIFwiY2FybmVpcm9cIixcbiAgICBcImNhcnBldGVcIixcbiAgICBcImNhcnJlaXJhXCIsXG4gICAgXCJjYXJ0YXpcIixcbiAgICBcImNhcnZhbGhvXCIsXG4gICAgXCJjYXNhY29cIixcbiAgICBcImNhc2NhXCIsXG4gICAgXCJjYXNlYnJlXCIsXG4gICAgXCJjYXN0ZWxvXCIsXG4gICAgXCJjYXN1bG9cIixcbiAgICBcImNhdGFyYXRhXCIsXG4gICAgXCJjYXRpdmFyXCIsXG4gICAgXCJjYXVsZVwiLFxuICAgIFwiY2F1c2Fkb3JcIixcbiAgICBcImNhdXRlbGFyXCIsXG4gICAgXCJjYXZhbG9cIixcbiAgICBcImNhdmVybmFcIixcbiAgICBcImNlYm9sYVwiLFxuICAgIFwiY2VkaWxoYVwiLFxuICAgIFwiY2Vnb25oYVwiLFxuICAgIFwiY2VsZWJyYXJcIixcbiAgICBcImNlbHVsYXJcIixcbiAgICBcImNlbm91cmFcIixcbiAgICBcImNlbnNvXCIsXG4gICAgXCJjZW50ZWlvXCIsXG4gICAgXCJjZXJjYXJcIixcbiAgICBcImNlcnJhZG9cIixcbiAgICBcImNlcnRlaXJvXCIsXG4gICAgXCJjZXJ2ZWphXCIsXG4gICAgXCJjZXRpbVwiLFxuICAgIFwiY2V2YWRhXCIsXG4gICAgXCJjaGFjb3RhXCIsXG4gICAgXCJjaGFsZWlyYVwiLFxuICAgIFwiY2hhbWFkb1wiLFxuICAgIFwiY2hhcGFkYVwiLFxuICAgIFwiY2hhcm1lXCIsXG4gICAgXCJjaGF0aWNlXCIsXG4gICAgXCJjaGF2ZVwiLFxuICAgIFwiY2hlZmVcIixcbiAgICBcImNoZWdhZGFcIixcbiAgICBcImNoZWlyb1wiLFxuICAgIFwiY2hlcXVlXCIsXG4gICAgXCJjaGljb3RlXCIsXG4gICAgXCJjaGlmcmVcIixcbiAgICBcImNoaW5lbG9cIixcbiAgICBcImNob2NhbGhvXCIsXG4gICAgXCJjaG92ZXJcIixcbiAgICBcImNodW1ib1wiLFxuICAgIFwiY2h1dGFyXCIsXG4gICAgXCJjaHV2YVwiLFxuICAgIFwiY2ljYXRyaXpcIixcbiAgICBcImNpY2xvbmVcIixcbiAgICBcImNpZGFkZVwiLFxuICAgIFwiY2lkcmVpcmFcIixcbiAgICBcImNpZW50ZVwiLFxuICAgIFwiY2lnYW5hXCIsXG4gICAgXCJjaW1lbnRvXCIsXG4gICAgXCJjaW50b1wiLFxuICAgIFwiY2luemFcIixcbiAgICBcImNpcmFuZGFcIixcbiAgICBcImNpcmN1aXRvXCIsXG4gICAgXCJjaXJ1cmdpYVwiLFxuICAgIFwiY2l0YXJcIixcbiAgICBcImNsYXJlemFcIixcbiAgICBcImNsZXJvXCIsXG4gICAgXCJjbGljYXJcIixcbiAgICBcImNsb25lXCIsXG4gICAgXCJjbHViZVwiLFxuICAgIFwiY29hZG9cIixcbiAgICBcImNvYWdpclwiLFxuICAgIFwiY29iYWlhXCIsXG4gICAgXCJjb2JlcnRvclwiLFxuICAgIFwiY29icmFyXCIsXG4gICAgXCJjb2NhZGFcIixcbiAgICBcImNvZWxob1wiLFxuICAgIFwiY29lbnRyb1wiLFxuICAgIFwiY29lc29cIixcbiAgICBcImNvZ3VtZWxvXCIsXG4gICAgXCJjb2liaXJcIixcbiAgICBcImNvaWZhXCIsXG4gICAgXCJjb2lvdGVcIixcbiAgICBcImNvbGFyXCIsXG4gICAgXCJjb2xlaXJhXCIsXG4gICAgXCJjb2xoZXJcIixcbiAgICBcImNvbGlkaXJcIixcbiAgICBcImNvbG1laWFcIixcbiAgICBcImNvbG9ub1wiLFxuICAgIFwiY29sdW5hXCIsXG4gICAgXCJjb21hbmRvXCIsXG4gICAgXCJjb21iaW5hclwiLFxuICAgIFwiY29tZW50YXJcIixcbiAgICBcImNvbWl0aXZhXCIsXG4gICAgXCJjb21vdmVyXCIsXG4gICAgXCJjb21wbGV4b1wiLFxuICAgIFwiY29tdW1cIixcbiAgICBcImNvbmNoYVwiLFxuICAgIFwiY29uZG9yXCIsXG4gICAgXCJjb25lY3RhclwiLFxuICAgIFwiY29uZnVzb1wiLFxuICAgIFwiY29uZ2VsYXJcIixcbiAgICBcImNvbmhlY2VyXCIsXG4gICAgXCJjb25qdWdhclwiLFxuICAgIFwiY29uc3VtaXJcIixcbiAgICBcImNvbnRyYXRvXCIsXG4gICAgXCJjb252aXRlXCIsXG4gICAgXCJjb29wZXJhclwiLFxuICAgIFwiY29wZWlyb1wiLFxuICAgIFwiY29waWFkb3JcIixcbiAgICBcImNvcG9cIixcbiAgICBcImNvcXVldGVsXCIsXG4gICAgXCJjb3JhZ2VtXCIsXG4gICAgXCJjb3JkaWFsXCIsXG4gICAgXCJjb3JuZXRhXCIsXG4gICAgXCJjb3JvbmhhXCIsXG4gICAgXCJjb3Jwb3JhbFwiLFxuICAgIFwiY29ycmVpb1wiLFxuICAgIFwiY29ydGVqb1wiLFxuICAgIFwiY29ydWphXCIsXG4gICAgXCJjb3J2b1wiLFxuICAgIFwiY29zc2Vub1wiLFxuICAgIFwiY29zdGVsYVwiLFxuICAgIFwiY290b25ldGVcIixcbiAgICBcImNvdXJvXCIsXG4gICAgXCJjb3V2ZVwiLFxuICAgIFwiY292aWxcIixcbiAgICBcImNvemluaGFcIixcbiAgICBcImNyYXRlcmFcIixcbiAgICBcImNyYXZvXCIsXG4gICAgXCJjcmVjaGVcIixcbiAgICBcImNyZWRvclwiLFxuICAgIFwiY3JlbWVcIixcbiAgICBcImNyZXJcIixcbiAgICBcImNyZXNwb1wiLFxuICAgIFwiY3JpYWRhXCIsXG4gICAgXCJjcmltaW5hbFwiLFxuICAgIFwiY3Jpb3Vsb1wiLFxuICAgIFwiY3Jpc2VcIixcbiAgICBcImNyaXRpY2FyXCIsXG4gICAgXCJjcm9zdGFcIixcbiAgICBcImNydWFcIixcbiAgICBcImNydXplaXJvXCIsXG4gICAgXCJjdWJhbm9cIixcbiAgICBcImN1ZWNhXCIsXG4gICAgXCJjdWlkYWRvXCIsXG4gICAgXCJjdWpvXCIsXG4gICAgXCJjdWxhdHJhXCIsXG4gICAgXCJjdWxtaW5hclwiLFxuICAgIFwiY3VscGFyXCIsXG4gICAgXCJjdWx0dXJhXCIsXG4gICAgXCJjdW1wcmlyXCIsXG4gICAgXCJjdW5oYWRvXCIsXG4gICAgXCJjdXBpZG9cIixcbiAgICBcImN1cmF0aXZvXCIsXG4gICAgXCJjdXJyYWxcIixcbiAgICBcImN1cnNhclwiLFxuICAgIFwiY3VydG9cIixcbiAgICBcImN1c3BpclwiLFxuICAgIFwiY3VzdGVhclwiLFxuICAgIFwiY3V0ZWxvXCIsXG4gICAgXCJkYW1hc2NvXCIsXG4gICAgXCJkYXRhclwiLFxuICAgIFwiZGViYXRlclwiLFxuICAgIFwiZGViaXRhclwiLFxuICAgIFwiZGVib2NoZVwiLFxuICAgIFwiZGVidWxoYXJcIixcbiAgICBcImRlY2FscXVlXCIsXG4gICAgXCJkZWNpbWFsXCIsXG4gICAgXCJkZWNsaXZlXCIsXG4gICAgXCJkZWNvdGVcIixcbiAgICBcImRlY3JldGFyXCIsXG4gICAgXCJkZWRhbFwiLFxuICAgIFwiZGVkaWNhZG9cIixcbiAgICBcImRlZHV6aXJcIixcbiAgICBcImRlZmVzYVwiLFxuICAgIFwiZGVmdW1hclwiLFxuICAgIFwiZGVnZWxvXCIsXG4gICAgXCJkZWdyYXVcIixcbiAgICBcImRlZ3VzdGFyXCIsXG4gICAgXCJkZWl0YWRvXCIsXG4gICAgXCJkZWl4YXJcIixcbiAgICBcImRlbGF0b3JcIixcbiAgICBcImRlbGVnYWRvXCIsXG4gICAgXCJkZWxpbmVhclwiLFxuICAgIFwiZGVsb25nYVwiLFxuICAgIFwiZGVtYW5kYVwiLFxuICAgIFwiZGVtaXRpclwiLFxuICAgIFwiZGVtb2xpZG9cIixcbiAgICBcImRlbnRpc3RhXCIsXG4gICAgXCJkZXBlbmFkb1wiLFxuICAgIFwiZGVwaWxhclwiLFxuICAgIFwiZGVwb2lzXCIsXG4gICAgXCJkZXByZXNzYVwiLFxuICAgIFwiZGVwdXJhclwiLFxuICAgIFwiZGVyaXZhXCIsXG4gICAgXCJkZXJyYW1hclwiLFxuICAgIFwiZGVzYWZpb1wiLFxuICAgIFwiZGVzYm90YXJcIixcbiAgICBcImRlc2NhbnNvXCIsXG4gICAgXCJkZXNlbmhvXCIsXG4gICAgXCJkZXNmaWFkb1wiLFxuICAgIFwiZGVzZ2FzdGVcIixcbiAgICBcImRlc2lndWFsXCIsXG4gICAgXCJkZXNsaXplXCIsXG4gICAgXCJkZXNtYW1hclwiLFxuICAgIFwiZGVzb3ZhXCIsXG4gICAgXCJkZXNwZXNhXCIsXG4gICAgXCJkZXN0YXF1ZVwiLFxuICAgIFwiZGVzdmlhclwiLFxuICAgIFwiZGV0YWxoYXJcIixcbiAgICBcImRldGVudG9yXCIsXG4gICAgXCJkZXRvbmFyXCIsXG4gICAgXCJkZXRyaXRvXCIsXG4gICAgXCJkZXVzYVwiLFxuICAgIFwiZGV2ZXJcIixcbiAgICBcImRldmlkb1wiLFxuICAgIFwiZGV2b3RhZG9cIixcbiAgICBcImRlemVuYVwiLFxuICAgIFwiZGlhZ3JhbWFcIixcbiAgICBcImRpYWxldG9cIixcbiAgICBcImRpZGF0YVwiLFxuICAgIFwiZGlmdXNvXCIsXG4gICAgXCJkaWdpdGFyXCIsXG4gICAgXCJkaWxhdGFkb1wiLFxuICAgIFwiZGlsdWVudGVcIixcbiAgICBcImRpbWludWlyXCIsXG4gICAgXCJkaW5hc3RpYVwiLFxuICAgIFwiZGluaGVpcm9cIixcbiAgICBcImRpb2Nlc2VcIixcbiAgICBcImRpcmV0b1wiLFxuICAgIFwiZGlzY3JldGFcIixcbiAgICBcImRpc2ZhcmNlXCIsXG4gICAgXCJkaXNwYXJvXCIsXG4gICAgXCJkaXNxdWV0ZVwiLFxuICAgIFwiZGlzc2lwYXJcIixcbiAgICBcImRpc3RhbnRlXCIsXG4gICAgXCJkaXRhZG9yXCIsXG4gICAgXCJkaXVybm9cIixcbiAgICBcImRpdmVyc29cIixcbiAgICBcImRpdmlzb3JcIixcbiAgICBcImRpdnVsZ2FyXCIsXG4gICAgXCJkaXplclwiLFxuICAgIFwiZG9icmFkb3JcIixcbiAgICBcImRvbG9yaWRvXCIsXG4gICAgXCJkb21hZG9yXCIsXG4gICAgXCJkb21pbmFkb1wiLFxuICAgIFwiZG9uYXRpdm9cIixcbiAgICBcImRvbnplbGFcIixcbiAgICBcImRvcm1lbnRlXCIsXG4gICAgXCJkb3JzYWxcIixcbiAgICBcImRvc2FnZW1cIixcbiAgICBcImRvdXJhZG9cIixcbiAgICBcImRvdXRvclwiLFxuICAgIFwiZHJlbmFnZW1cIixcbiAgICBcImRyaWJsZVwiLFxuICAgIFwiZHJvZ2FyaWFcIixcbiAgICBcImR1ZWxhclwiLFxuICAgIFwiZHVlbmRlXCIsXG4gICAgXCJkdWV0b1wiLFxuICAgIFwiZHVwbG9cIixcbiAgICBcImR1cXVlc2FcIixcbiAgICBcImR1cmFudGVcIixcbiAgICBcImR1dmlkb3NvXCIsXG4gICAgXCJlY2xvZGlyXCIsXG4gICAgXCJlY29hclwiLFxuICAgIFwiZWNvbG9naWFcIixcbiAgICBcImVkaWZpY2FyXCIsXG4gICAgXCJlZGl0YWxcIixcbiAgICBcImVkdWNhZG9cIixcbiAgICBcImVmZWl0b1wiLFxuICAgIFwiZWZldGl2YXJcIixcbiAgICBcImVqZXRhclwiLFxuICAgIFwiZWxhYm9yYXJcIixcbiAgICBcImVsZWdlclwiLFxuICAgIFwiZWxlaXRvclwiLFxuICAgIFwiZWxlbmNvXCIsXG4gICAgXCJlbGV2YWRvclwiLFxuICAgIFwiZWxpbWluYXJcIixcbiAgICBcImVsb2dpYXJcIixcbiAgICBcImVtYmFyZ29cIixcbiAgICBcImVtYm9sYWRvXCIsXG4gICAgXCJlbWJydWxob1wiLFxuICAgIFwiZW1idXRpZG9cIixcbiAgICBcImVtZW5kYVwiLFxuICAgIFwiZW1lcmdpclwiLFxuICAgIFwiZW1pc3NvclwiLFxuICAgIFwiZW1wYXRpYVwiLFxuICAgIFwiZW1wZW5ob1wiLFxuICAgIFwiZW1waW5hZG9cIixcbiAgICBcImVtcG9sZ2FyXCIsXG4gICAgXCJlbXByZWdvXCIsXG4gICAgXCJlbXB1cnJhclwiLFxuICAgIFwiZW11bGFkb3JcIixcbiAgICBcImVuY2FpeGVcIixcbiAgICBcImVuY2VuYWRvXCIsXG4gICAgXCJlbmNoZW50ZVwiLFxuICAgIFwiZW5jb250cm9cIixcbiAgICBcImVuZGV1c2FyXCIsXG4gICAgXCJlbmRvc3NhclwiLFxuICAgIFwiZW5mYWl4YXJcIixcbiAgICBcImVuZmVpdGVcIixcbiAgICBcImVuZmltXCIsXG4gICAgXCJlbmdhamFkb1wiLFxuICAgIFwiZW5nZW5ob1wiLFxuICAgIFwiZW5nbG9iYXJcIixcbiAgICBcImVuZ29tYWRvXCIsXG4gICAgXCJlbmdyYXhhclwiLFxuICAgIFwiZW5ndWlhXCIsXG4gICAgXCJlbmpvYXJcIixcbiAgICBcImVubGF0YXJcIixcbiAgICBcImVucXVhbnRvXCIsXG4gICAgXCJlbnJhaXphclwiLFxuICAgIFwiZW5yb2xhZG9cIixcbiAgICBcImVucnVnYXJcIixcbiAgICBcImVuc2Fpb1wiLFxuICAgIFwiZW5zZWFkYVwiLFxuICAgIFwiZW5zaW5vXCIsXG4gICAgXCJlbnNvcGFkb1wiLFxuICAgIFwiZW50YW50b1wiLFxuICAgIFwiZW50ZWFkb1wiLFxuICAgIFwiZW50aWRhZGVcIixcbiAgICBcImVudG9ydGFyXCIsXG4gICAgXCJlbnRyYWRhXCIsXG4gICAgXCJlbnR1bGhvXCIsXG4gICAgXCJlbnZlcmdhclwiLFxuICAgIFwiZW52aWFkb1wiLFxuICAgIFwiZW52b2x2ZXJcIixcbiAgICBcImVueGFtZVwiLFxuICAgIFwiZW54ZXJ0b1wiLFxuICAgIFwiZW54b2ZyZVwiLFxuICAgIFwiZW54dXRvXCIsXG4gICAgXCJlcGlkZXJtZVwiLFxuICAgIFwiZXF1aXBhclwiLFxuICAgIFwiZXJldG9cIixcbiAgICBcImVyZ3VpZG9cIixcbiAgICBcImVycmF0YVwiLFxuICAgIFwiZXJ2YVwiLFxuICAgIFwiZXJ2aWxoYVwiLFxuICAgIFwiZXNiYW5qYXJcIixcbiAgICBcImVzYmVsdG9cIixcbiAgICBcImVzY2FtYVwiLFxuICAgIFwiZXNjb2xhXCIsXG4gICAgXCJlc2NyaXRhXCIsXG4gICAgXCJlc2N1dGFcIixcbiAgICBcImVzZmluZ2VcIixcbiAgICBcImVzZm9sYXJcIixcbiAgICBcImVzZnJlZ2FyXCIsXG4gICAgXCJlc2Z1bWFkb1wiLFxuICAgIFwiZXNncmltYVwiLFxuICAgIFwiZXNtYWx0ZVwiLFxuICAgIFwiZXNwYW50b1wiLFxuICAgIFwiZXNwZWxob1wiLFxuICAgIFwiZXNwaWdhXCIsXG4gICAgXCJlc3BvbmphXCIsXG4gICAgXCJlc3ByZWl0YVwiLFxuICAgIFwiZXNwdW1hclwiLFxuICAgIFwiZXNxdWVyZGFcIixcbiAgICBcImVzdGFjYVwiLFxuICAgIFwiZXN0ZWlyYVwiLFxuICAgIFwiZXN0aWNhclwiLFxuICAgIFwiZXN0b2ZhZG9cIixcbiAgICBcImVzdHJlbGFcIixcbiAgICBcImVzdHVkb1wiLFxuICAgIFwiZXN2YXppYXJcIixcbiAgICBcImV0YW5vbFwiLFxuICAgIFwiZXRpcXVldGFcIixcbiAgICBcImV1Zm9yaWFcIixcbiAgICBcImV1cm9wZXVcIixcbiAgICBcImV2YWN1YXJcIixcbiAgICBcImV2YXBvcmFyXCIsXG4gICAgXCJldmFzaXZvXCIsXG4gICAgXCJldmVudHVhbFwiLFxuICAgIFwiZXZpZGVudGVcIixcbiAgICBcImV2b2x1aXJcIixcbiAgICBcImV4YWdlcm9cIixcbiAgICBcImV4YWxhclwiLFxuICAgIFwiZXhhbWluYXJcIixcbiAgICBcImV4YXRvXCIsXG4gICAgXCJleGF1c3RvXCIsXG4gICAgXCJleGNlc3NvXCIsXG4gICAgXCJleGNpdGFyXCIsXG4gICAgXCJleGNsYW1hclwiLFxuICAgIFwiZXhlY3V0YXJcIixcbiAgICBcImV4ZW1wbG9cIixcbiAgICBcImV4aWJpclwiLFxuICAgIFwiZXhpZ2VudGVcIixcbiAgICBcImV4b25lcmFyXCIsXG4gICAgXCJleHBhbmRpclwiLFxuICAgIFwiZXhwZWxpclwiLFxuICAgIFwiZXhwaXJhclwiLFxuICAgIFwiZXhwbGFuYXJcIixcbiAgICBcImV4cG9zdG9cIixcbiAgICBcImV4cHJlc3NvXCIsXG4gICAgXCJleHB1bHNhclwiLFxuICAgIFwiZXh0ZXJub1wiLFxuICAgIFwiZXh0aW50b1wiLFxuICAgIFwiZXh0cmF0b1wiLFxuICAgIFwiZmFicmljYXJcIixcbiAgICBcImZhYnVsb3NvXCIsXG4gICAgXCJmYWNldGFcIixcbiAgICBcImZhY2lhbFwiLFxuICAgIFwiZmFkYVwiLFxuICAgIFwiZmFkaWdhXCIsXG4gICAgXCJmYWl4YVwiLFxuICAgIFwiZmFsYXJcIixcbiAgICBcImZhbHRhXCIsXG4gICAgXCJmYW1pbGlhclwiLFxuICAgIFwiZmFuZGFuZ29cIixcbiAgICBcImZhbmZhcnJhXCIsXG4gICAgXCJmYW50b2NoZVwiLFxuICAgIFwiZmFyZGFkb1wiLFxuICAgIFwiZmFyZWxvXCIsXG4gICAgXCJmYXJpbmhhXCIsXG4gICAgXCJmYXJvZmFcIixcbiAgICBcImZhcnBhXCIsXG4gICAgXCJmYXJ0dXJhXCIsXG4gICAgXCJmYXRpYVwiLFxuICAgIFwiZmF0b3JcIixcbiAgICBcImZhdm9yaXRhXCIsXG4gICAgXCJmYXhpbmFcIixcbiAgICBcImZhemVuZGFcIixcbiAgICBcImZlY2hhZG9cIixcbiAgICBcImZlaWpvYWRhXCIsXG4gICAgXCJmZWlyYW50ZVwiLFxuICAgIFwiZmVsaW5vXCIsXG4gICAgXCJmZW1pbmlub1wiLFxuICAgIFwiZmVuZGFcIixcbiAgICBcImZlbm9cIixcbiAgICBcImZlcmFcIixcbiAgICBcImZlcmlhZG9cIixcbiAgICBcImZlcnJ1Z2VtXCIsXG4gICAgXCJmZXJ2ZXJcIixcbiAgICBcImZlc3RlamFyXCIsXG4gICAgXCJmZXRhbFwiLFxuICAgIFwiZmV1ZGFsXCIsXG4gICAgXCJmaWFwb1wiLFxuICAgIFwiZmlicm9zZVwiLFxuICAgIFwiZmljYXJcIixcbiAgICBcImZpY2hlaXJvXCIsXG4gICAgXCJmaWd1cmFkb1wiLFxuICAgIFwiZmlsZWlyYVwiLFxuICAgIFwiZmlsaG9cIixcbiAgICBcImZpbG1lXCIsXG4gICAgXCJmaWx0cmFyXCIsXG4gICAgXCJmaXJtZXphXCIsXG4gICAgXCJmaXNnYWRhXCIsXG4gICAgXCJmaXNzdXJhXCIsXG4gICAgXCJmaXRhXCIsXG4gICAgXCJmaXZlbGFcIixcbiAgICBcImZpeGFkb3JcIixcbiAgICBcImZpeG9cIixcbiAgICBcImZsYWNpZGV6XCIsXG4gICAgXCJmbGFtaW5nb1wiLFxuICAgIFwiZmxhbmVsYVwiLFxuICAgIFwiZmxlY2hhZGFcIixcbiAgICBcImZsb3JhXCIsXG4gICAgXCJmbHV0dWFyXCIsXG4gICAgXCJmbHV4b1wiLFxuICAgIFwiZm9jYWxcIixcbiAgICBcImZvY2luaG9cIixcbiAgICBcImZvZm9jYXJcIixcbiAgICBcImZvZ29cIixcbiAgICBcImZvZ3VldGVcIixcbiAgICBcImZvaWNlXCIsXG4gICAgXCJmb2xnYWRvXCIsXG4gICAgXCJmb2xoZXRvXCIsXG4gICAgXCJmb3JqYXJcIixcbiAgICBcImZvcm1pZ2FcIixcbiAgICBcImZvcm5vXCIsXG4gICAgXCJmb3J0ZVwiLFxuICAgIFwiZm9zY29cIixcbiAgICBcImZvc3NhXCIsXG4gICAgXCJmcmFnYXRhXCIsXG4gICAgXCJmcmFsZGFcIixcbiAgICBcImZyYW5nb1wiLFxuICAgIFwiZnJhc2NvXCIsXG4gICAgXCJmcmF0ZXJub1wiLFxuICAgIFwiZnJlaXJhXCIsXG4gICAgXCJmcmVudGVcIixcbiAgICBcImZyZXRhclwiLFxuICAgIFwiZnJpZXphXCIsXG4gICAgXCJmcmlzb1wiLFxuICAgIFwiZnJpdHVyYVwiLFxuICAgIFwiZnJvbmhhXCIsXG4gICAgXCJmcnVzdHJhclwiLFxuICAgIFwiZnJ1dGVpcmFcIixcbiAgICBcImZ1Z2lyXCIsXG4gICAgXCJmdWxhbm9cIixcbiAgICBcImZ1bGlnZW1cIixcbiAgICBcImZ1bmRhclwiLFxuICAgIFwiZnVuZ29cIixcbiAgICBcImZ1bmlsXCIsXG4gICAgXCJmdXJhZG9yXCIsXG4gICAgXCJmdXJpb3NvXCIsXG4gICAgXCJmdXRlYm9sXCIsXG4gICAgXCJnYWJhcml0b1wiLFxuICAgIFwiZ2FiaW5ldGVcIixcbiAgICBcImdhZG9cIixcbiAgICBcImdhaWF0b1wiLFxuICAgIFwiZ2Fpb2xhXCIsXG4gICAgXCJnYWl2b3RhXCIsXG4gICAgXCJnYWxlZ2FcIixcbiAgICBcImdhbGhvXCIsXG4gICAgXCJnYWxpbmhhXCIsXG4gICAgXCJnYWxvY2hhXCIsXG4gICAgXCJnYW5oYXJcIixcbiAgICBcImdhcmFnZW1cIixcbiAgICBcImdhcmZvXCIsXG4gICAgXCJnYXJnYWxvXCIsXG4gICAgXCJnYXJpbXBvXCIsXG4gICAgXCJnYXJvdXBhXCIsXG4gICAgXCJnYXJyYWZhXCIsXG4gICAgXCJnYXNvZHV0b1wiLFxuICAgIFwiZ2FzdG9cIixcbiAgICBcImdhdGFcIixcbiAgICBcImdhdGlsaG9cIixcbiAgICBcImdhdmV0YVwiLFxuICAgIFwiZ2F6ZWxhXCIsXG4gICAgXCJnZWxhZG9cIixcbiAgICBcImdlbGVpYVwiLFxuICAgIFwiZ2Vsb1wiLFxuICAgIFwiZ2VtYWRhXCIsXG4gICAgXCJnZW1lclwiLFxuICAgIFwiZ2VtaWRvXCIsXG4gICAgXCJnZW5lcm9zb1wiLFxuICAgIFwiZ2VuZ2l2YVwiLFxuICAgIFwiZ2VuaWFsXCIsXG4gICAgXCJnZW5vbWFcIixcbiAgICBcImdlbnJvXCIsXG4gICAgXCJnZW9sb2dpYVwiLFxuICAgIFwiZ2VyYWRvclwiLFxuICAgIFwiZ2VybWluYXJcIixcbiAgICBcImdlc3NvXCIsXG4gICAgXCJnZXN0b3JcIixcbiAgICBcImdpbmFzdGFcIixcbiAgICBcImdpbmNhbmFcIixcbiAgICBcImdpbmdhZG9cIixcbiAgICBcImdpcmFmYVwiLFxuICAgIFwiZ2lyaW5vXCIsXG4gICAgXCJnbGFjaWFsXCIsXG4gICAgXCJnbGljb3NlXCIsXG4gICAgXCJnbG9iYWxcIixcbiAgICBcImdsb3Jpb3NvXCIsXG4gICAgXCJnb2VsYVwiLFxuICAgIFwiZ29pYWJhXCIsXG4gICAgXCJnb2xmZVwiLFxuICAgIFwiZ29scGVhclwiLFxuICAgIFwiZ29yZHVyYVwiLFxuICAgIFwiZ29yamV0YVwiLFxuICAgIFwiZ29ycm9cIixcbiAgICBcImdvc3Rvc29cIixcbiAgICBcImdvdGVpcmFcIixcbiAgICBcImdvdmVybmFyXCIsXG4gICAgXCJncmFjZWpvXCIsXG4gICAgXCJncmFkdWFsXCIsXG4gICAgXCJncmFmaXRlXCIsXG4gICAgXCJncmFsaGFcIixcbiAgICBcImdyYW1wb1wiLFxuICAgIFwiZ3JhbmFkYVwiLFxuICAgIFwiZ3JhdHVpdG9cIixcbiAgICBcImdyYXZldG9cIixcbiAgICBcImdyYXhhXCIsXG4gICAgXCJncmVnb1wiLFxuICAgIFwiZ3JlbGhhclwiLFxuICAgIFwiZ3JldmVcIixcbiAgICBcImdyaWxvXCIsXG4gICAgXCJncmlzYWxob1wiLFxuICAgIFwiZ3JpdGFyaWFcIixcbiAgICBcImdyb3Nzb1wiLFxuICAgIFwiZ3JvdGVzY29cIixcbiAgICBcImdydWRhZG9cIixcbiAgICBcImdydW5oaWRvXCIsXG4gICAgXCJncnV0YVwiLFxuICAgIFwiZ3VhY2hlXCIsXG4gICAgXCJndWFyYW5pXCIsXG4gICAgXCJndWF4aW5pbVwiLFxuICAgIFwiZ3VlcnJlYXJcIixcbiAgICBcImd1aWFyXCIsXG4gICAgXCJndWluY2hvXCIsXG4gICAgXCJndWlzYWRvXCIsXG4gICAgXCJndWxhXCIsXG4gICAgXCJndWxvc29cIixcbiAgICBcImd1cnVcIixcbiAgICBcImhhYml0YXJcIixcbiAgICBcImhhcm1vbmlhXCIsXG4gICAgXCJoYXN0ZVwiLFxuICAgIFwiaGF2ZXJcIixcbiAgICBcImhlY3RhcmVcIixcbiAgICBcImhlcmRhclwiLFxuICAgIFwiaGVyZXNpYVwiLFxuICAgIFwiaGVzaXRhclwiLFxuICAgIFwiaGlhdG9cIixcbiAgICBcImhpYmVybmFyXCIsXG4gICAgXCJoaWRyYXRhclwiLFxuICAgIFwiaGllbmFcIixcbiAgICBcImhpbm9cIixcbiAgICBcImhpcGlzbW9cIixcbiAgICBcImhpcG5vc2VcIixcbiAgICBcImhpcG90ZWNhXCIsXG4gICAgXCJob2plXCIsXG4gICAgXCJob2xvZm90ZVwiLFxuICAgIFwiaG9tZW1cIixcbiAgICBcImhvbmVzdG9cIixcbiAgICBcImhvbnJhZG9cIixcbiAgICBcImhvcm1vbmFsXCIsXG4gICAgXCJob3NwZWRhclwiLFxuICAgIFwiaHVtb3JhZG9cIixcbiAgICBcImlhdGVcIixcbiAgICBcImlkZWlhXCIsXG4gICAgXCJpZG9zb1wiLFxuICAgIFwiaWdub3JhZG9cIixcbiAgICBcImlncmVqYVwiLFxuICAgIFwiaWd1YW5hXCIsXG4gICAgXCJpbGVzb1wiLFxuICAgIFwiaWxoYVwiLFxuICAgIFwiaWx1ZGlkb1wiLFxuICAgIFwiaWx1bWluYXJcIixcbiAgICBcImlsdXN0cmFyXCIsXG4gICAgXCJpbWFnZW1cIixcbiAgICBcImltZWRpYXRvXCIsXG4gICAgXCJpbWVuc29cIixcbiAgICBcImltZXJzaXZvXCIsXG4gICAgXCJpbWluZW50ZVwiLFxuICAgIFwiaW1pdGFkb3JcIixcbiAgICBcImltb3J0YWxcIixcbiAgICBcImltcGFjdG9cIixcbiAgICBcImltcGVkaXJcIixcbiAgICBcImltcGxhbnRlXCIsXG4gICAgXCJpbXBvclwiLFxuICAgIFwiaW1wcmVuc2FcIixcbiAgICBcImltcHVuZVwiLFxuICAgIFwiaW11bml6YXJcIixcbiAgICBcImluYWxhZG9yXCIsXG4gICAgXCJpbmFwdG9cIixcbiAgICBcImluYXRpdm9cIixcbiAgICBcImluY2Vuc29cIixcbiAgICBcImluY2hhclwiLFxuICAgIFwiaW5jaWRpclwiLFxuICAgIFwiaW5jbHVpclwiLFxuICAgIFwiaW5jb2xvclwiLFxuICAgIFwiaW5kZWNpc29cIixcbiAgICBcImluZGlyZXRvXCIsXG4gICAgXCJpbmR1dG9yXCIsXG4gICAgXCJpbmVmaWNhelwiLFxuICAgIFwiaW5lcmVudGVcIixcbiAgICBcImluZmFudGlsXCIsXG4gICAgXCJpbmZlc3RhclwiLFxuICAgIFwiaW5maW5pdG9cIixcbiAgICBcImluZmxhbWFyXCIsXG4gICAgXCJpbmZvcm1hbFwiLFxuICAgIFwiaW5mcmF0b3JcIixcbiAgICBcImluZ2VyaXJcIixcbiAgICBcImluaWJpZG9cIixcbiAgICBcImluaWNpYWxcIixcbiAgICBcImluaW1pZ29cIixcbiAgICBcImluamV0YXJcIixcbiAgICBcImlub2NlbnRlXCIsXG4gICAgXCJpbm9kb3JvXCIsXG4gICAgXCJpbm92YWRvclwiLFxuICAgIFwiaW5veFwiLFxuICAgIFwiaW5xdWlldG9cIixcbiAgICBcImluc2NyaXRvXCIsXG4gICAgXCJpbnNldG9cIixcbiAgICBcImluc2lzdGlyXCIsXG4gICAgXCJpbnNwZXRvclwiLFxuICAgIFwiaW5zdGFsYXJcIixcbiAgICBcImluc3VsdG9cIixcbiAgICBcImludGFjdG9cIixcbiAgICBcImludGVncmFsXCIsXG4gICAgXCJpbnRpbWFyXCIsXG4gICAgXCJpbnRvY2Fkb1wiLFxuICAgIFwiaW50cmlnYVwiLFxuICAgIFwiaW52YXNvclwiLFxuICAgIFwiaW52ZXJub1wiLFxuICAgIFwiaW52aWN0b1wiLFxuICAgIFwiaW52b2NhclwiLFxuICAgIFwiaW9ndXJ0ZVwiLFxuICAgIFwiaXJhbmlhbm9cIixcbiAgICBcImlyb25pemFyXCIsXG4gICAgXCJpcnJlYWxcIixcbiAgICBcImlycml0YWRvXCIsXG4gICAgXCJpc2NhXCIsXG4gICAgXCJpc2VudG9cIixcbiAgICBcImlzb2xhZG9cIixcbiAgICBcImlzcXVlaXJvXCIsXG4gICAgXCJpdGFsaWFub1wiLFxuICAgIFwiamFuZWlyb1wiLFxuICAgIFwiamFuZ2FkYVwiLFxuICAgIFwiamFudGFcIixcbiAgICBcImphcmFyYWNhXCIsXG4gICAgXCJqYXJkaW1cIixcbiAgICBcImphcnJvXCIsXG4gICAgXCJqYXNtaW1cIixcbiAgICBcImphdG9cIixcbiAgICBcImphdmFsaVwiLFxuICAgIFwiamF6aWRhXCIsXG4gICAgXCJqZWp1bVwiLFxuICAgIFwiam9hbmluaGFcIixcbiAgICBcImpvZWxoYWRhXCIsXG4gICAgXCJqb2dhZG9yXCIsXG4gICAgXCJqb2lhXCIsXG4gICAgXCJqb3JuYWxcIixcbiAgICBcImpvcnJhclwiLFxuICAgIFwiam92ZW1cIixcbiAgICBcImp1YmFcIixcbiAgICBcImp1ZGV1XCIsXG4gICAgXCJqdWRvY2FcIixcbiAgICBcImp1aXpcIixcbiAgICBcImp1bGdhZG9yXCIsXG4gICAgXCJqdWxob1wiLFxuICAgIFwianVyYWRvXCIsXG4gICAgXCJqdXJpc3RhXCIsXG4gICAgXCJqdXJvXCIsXG4gICAgXCJqdXN0YVwiLFxuICAgIFwibGFiYXJlZGFcIixcbiAgICBcImxhYm9yYWxcIixcbiAgICBcImxhY3JlXCIsXG4gICAgXCJsYWN0YW50ZVwiLFxuICAgIFwibGFkcmlsaG9cIixcbiAgICBcImxhZ2FydGFcIixcbiAgICBcImxhZ29hXCIsXG4gICAgXCJsYWplXCIsXG4gICAgXCJsYW1iZXJcIixcbiAgICBcImxhbWVudGFyXCIsXG4gICAgXCJsYW1pbmFyXCIsXG4gICAgXCJsYW1wZWpvXCIsXG4gICAgXCJsYW5jaGVcIixcbiAgICBcImxhcGlkYXJcIixcbiAgICBcImxhcHNvXCIsXG4gICAgXCJsYXJhbmphXCIsXG4gICAgXCJsYXJlaXJhXCIsXG4gICAgXCJsYXJndXJhXCIsXG4gICAgXCJsYXNhbmhhXCIsXG4gICAgXCJsYXN0cm9cIixcbiAgICBcImxhdGVyYWxcIixcbiAgICBcImxhdGlkb1wiLFxuICAgIFwibGF2YW5kYVwiLFxuICAgIFwibGF2b3VyYVwiLFxuICAgIFwibGF2cmFkb3JcIixcbiAgICBcImxheGFudGVcIixcbiAgICBcImxhemVyXCIsXG4gICAgXCJsZWFsZGFkZVwiLFxuICAgIFwibGVicmVcIixcbiAgICBcImxlZ2Fkb1wiLFxuICAgIFwibGVnZW5kYXJcIixcbiAgICBcImxlZ2lzdGFcIixcbiAgICBcImxlaWdvXCIsXG4gICAgXCJsZWlsb2FyXCIsXG4gICAgXCJsZWl0dXJhXCIsXG4gICAgXCJsZW1icmV0ZVwiLFxuICAgIFwibGVtZVwiLFxuICAgIFwibGVuaGFkb3JcIixcbiAgICBcImxlbnRpbGhhXCIsXG4gICAgXCJsZW9hXCIsXG4gICAgXCJsZXNtYVwiLFxuICAgIFwibGVzdGVcIixcbiAgICBcImxldGl2b1wiLFxuICAgIFwibGV0cmVpcm9cIixcbiAgICBcImxldmFyXCIsXG4gICAgXCJsZXZlemFcIixcbiAgICBcImxldml0YXJcIixcbiAgICBcImxpYmVyYWxcIixcbiAgICBcImxpYmlkb1wiLFxuICAgIFwibGlkZXJhclwiLFxuICAgIFwibGlnYXJcIixcbiAgICBcImxpZ2Vpcm9cIixcbiAgICBcImxpbWl0YXJcIixcbiAgICBcImxpbW9laXJvXCIsXG4gICAgXCJsaW1wYWRvclwiLFxuICAgIFwibGluZGFcIixcbiAgICBcImxpbmVhclwiLFxuICAgIFwibGluaGFnZW1cIixcbiAgICBcImxpcXVpZGV6XCIsXG4gICAgXCJsaXN0YWdlbVwiLFxuICAgIFwibGlzdXJhXCIsXG4gICAgXCJsaXRvcmFsXCIsXG4gICAgXCJsaXZyb1wiLFxuICAgIFwibGl4YVwiLFxuICAgIFwibGl4ZWlyYVwiLFxuICAgIFwibG9jYWRvclwiLFxuICAgIFwibG9jdXRvclwiLFxuICAgIFwibG9qaXN0YVwiLFxuICAgIFwibG9tYm9cIixcbiAgICBcImxvbmFcIixcbiAgICBcImxvbmdlXCIsXG4gICAgXCJsb250cmFcIixcbiAgICBcImxvcmRlXCIsXG4gICAgXCJsb3RhZG9cIixcbiAgICBcImxvdGVyaWFcIixcbiAgICBcImxvdWN1cmFcIixcbiAgICBcImxvdXNhXCIsXG4gICAgXCJsb3V2YXJcIixcbiAgICBcImx1YXJcIixcbiAgICBcImx1Y2lkZXpcIixcbiAgICBcImx1Y3JvXCIsXG4gICAgXCJsdW5ldGFcIixcbiAgICBcImx1c3RyZVwiLFxuICAgIFwibHV0YWRvclwiLFxuICAgIFwibHV2YVwiLFxuICAgIFwibWFjYWNvXCIsXG4gICAgXCJtYWNldGVcIixcbiAgICBcIm1hY2hhZG9cIixcbiAgICBcIm1hY2lvXCIsXG4gICAgXCJtYWRlaXJhXCIsXG4gICAgXCJtYWRyaW5oYVwiLFxuICAgIFwibWFnbmF0YVwiLFxuICAgIFwibWFncmV6YVwiLFxuICAgIFwibWFpb3JcIixcbiAgICBcIm1haXNcIixcbiAgICBcIm1hbGFuZHJvXCIsXG4gICAgXCJtYWxoYVwiLFxuICAgIFwibWFsb3RlXCIsXG4gICAgXCJtYWx1Y29cIixcbiAgICBcIm1hbWlsb1wiLFxuICAgIFwibWFtb2Vpcm9cIixcbiAgICBcIm1hbXV0ZVwiLFxuICAgIFwibWFuYWRhXCIsXG4gICAgXCJtYW5jaGFcIixcbiAgICBcIm1hbmRhdG9cIixcbiAgICBcIm1hbmVxdWltXCIsXG4gICAgXCJtYW5ob3NvXCIsXG4gICAgXCJtYW5pdmVsYVwiLFxuICAgIFwibWFub2JyYXJcIixcbiAgICBcIm1hbnNhXCIsXG4gICAgXCJtYW50ZXJcIixcbiAgICBcIm1hbnVzZWFyXCIsXG4gICAgXCJtYXBlYWRvXCIsXG4gICAgXCJtYXF1aW5hclwiLFxuICAgIFwibWFyY2Fkb3JcIixcbiAgICBcIm1hcmVzaWFcIixcbiAgICBcIm1hcmZpbVwiLFxuICAgIFwibWFyZ2VtXCIsXG4gICAgXCJtYXJpbmhvXCIsXG4gICAgXCJtYXJtaXRhXCIsXG4gICAgXCJtYXJvdG9cIixcbiAgICBcIm1hcnF1aXNlXCIsXG4gICAgXCJtYXJyZWNvXCIsXG4gICAgXCJtYXJ0ZWxvXCIsXG4gICAgXCJtYXJ1am9cIixcbiAgICBcIm1hc2NvdGVcIixcbiAgICBcIm1hc21vcnJhXCIsXG4gICAgXCJtYXNzYWdlbVwiLFxuICAgIFwibWFzdGlnYXJcIixcbiAgICBcIm1hdGFnYWxcIixcbiAgICBcIm1hdGVybm9cIixcbiAgICBcIm1hdGluYWxcIixcbiAgICBcIm1hdHV0YXJcIixcbiAgICBcIm1heGlsYXJcIixcbiAgICBcIm1lZGFsaGFcIixcbiAgICBcIm1lZGlkYVwiLFxuICAgIFwibWVkdXNhXCIsXG4gICAgXCJtZWdhZm9uZVwiLFxuICAgIFwibWVpZ2FcIixcbiAgICBcIm1lbGFuY2lhXCIsXG4gICAgXCJtZWxob3JcIixcbiAgICBcIm1lbWJyb1wiLFxuICAgIFwibWVtb3JpYWxcIixcbiAgICBcIm1lbmlub1wiLFxuICAgIFwibWVub3NcIixcbiAgICBcIm1lbnNhZ2VtXCIsXG4gICAgXCJtZW50YWxcIixcbiAgICBcIm1lcmVjZXJcIixcbiAgICBcIm1lcmd1bGhvXCIsXG4gICAgXCJtZXNhZGFcIixcbiAgICBcIm1lc2NsYXJcIixcbiAgICBcIm1lc21vXCIsXG4gICAgXCJtZXNxdWl0YVwiLFxuICAgIFwibWVzdHJlXCIsXG4gICAgXCJtZXRhZGVcIixcbiAgICBcIm1ldGVvcm9cIixcbiAgICBcIm1ldHJhZ2VtXCIsXG4gICAgXCJtZXhlclwiLFxuICAgIFwibWV4aWNhbm9cIixcbiAgICBcIm1pY3JvXCIsXG4gICAgXCJtaWdhbGhhXCIsXG4gICAgXCJtaWdyYXJcIixcbiAgICBcIm1pbGFncmVcIixcbiAgICBcIm1pbGVuYXJcIixcbiAgICBcIm1pbGhhclwiLFxuICAgIFwibWltYWRvXCIsXG4gICAgXCJtaW5lcmFyXCIsXG4gICAgXCJtaW5ob2NhXCIsXG4gICAgXCJtaW5pc3Ryb1wiLFxuICAgIFwibWlub3JpYVwiLFxuICAgIFwibWlvbG9cIixcbiAgICBcIm1pcmFudGVcIixcbiAgICBcIm1pcnRpbG9cIixcbiAgICBcIm1pc3R1cmFyXCIsXG4gICAgXCJtb2NpZGFkZVwiLFxuICAgIFwibW9kZXJub1wiLFxuICAgIFwibW9kdWxhclwiLFxuICAgIFwibW9lZGFcIixcbiAgICBcIm1vZXJcIixcbiAgICBcIm1vaW5ob1wiLFxuICAgIFwibW9pdGFcIixcbiAgICBcIm1vbGR1cmFcIixcbiAgICBcIm1vbGV6YVwiLFxuICAgIFwibW9saG9cIixcbiAgICBcIm1vbGluZXRlXCIsXG4gICAgXCJtb2x1c2NvXCIsXG4gICAgXCJtb250YW5oYVwiLFxuICAgIFwibW9xdWVjYVwiLFxuICAgIFwibW9yYW5nb1wiLFxuICAgIFwibW9yY2Vnb1wiLFxuICAgIFwibW9yZG9tb1wiLFxuICAgIFwibW9yZW5hXCIsXG4gICAgXCJtb3NhaWNvXCIsXG4gICAgXCJtb3NxdWV0ZVwiLFxuICAgIFwibW9zdGFyZGFcIixcbiAgICBcIm1vdGVsXCIsXG4gICAgXCJtb3RpbVwiLFxuICAgIFwibW90b1wiLFxuICAgIFwibW90cml6XCIsXG4gICAgXCJtdWRhXCIsXG4gICAgXCJtdWl0b1wiLFxuICAgIFwibXVsYXRhXCIsXG4gICAgXCJtdWxoZXJcIixcbiAgICBcIm11bHRhclwiLFxuICAgIFwibXVuZGlhbFwiLFxuICAgIFwibXVuaWRvXCIsXG4gICAgXCJtdXJhbGhhXCIsXG4gICAgXCJtdXJjaG9cIixcbiAgICBcIm11c2N1bGFyXCIsXG4gICAgXCJtdXNldVwiLFxuICAgIFwibXVzaWNhbFwiLFxuICAgIFwibmFjaW9uYWxcIixcbiAgICBcIm5hZGFkb3JcIixcbiAgICBcIm5hamFcIixcbiAgICBcIm5hbW9yb1wiLFxuICAgIFwibmFyaW5hXCIsXG4gICAgXCJuYXJyYWRvXCIsXG4gICAgXCJuYXNjZXJcIixcbiAgICBcIm5hdGl2YVwiLFxuICAgIFwibmF0dXJlemFcIixcbiAgICBcIm5hdmFsaGFcIixcbiAgICBcIm5hdmVnYXJcIixcbiAgICBcIm5hdmlvXCIsXG4gICAgXCJuZWJsaW5hXCIsXG4gICAgXCJuZWJ1bG9zb1wiLFxuICAgIFwibmVnYXRpdmFcIixcbiAgICBcIm5lZ29jaWFyXCIsXG4gICAgXCJuZWdyaXRvXCIsXG4gICAgXCJuZXJ2b3NvXCIsXG4gICAgXCJuZXRhXCIsXG4gICAgXCJuZXVyYWxcIixcbiAgICBcIm5ldmFzY2FcIixcbiAgICBcIm5ldm9laXJvXCIsXG4gICAgXCJuaW5hclwiLFxuICAgIFwibmluaG9cIixcbiAgICBcIm5pdGlkZXpcIixcbiAgICBcIm5pdmVsYXJcIixcbiAgICBcIm5vYnJlemFcIixcbiAgICBcIm5vaXRlXCIsXG4gICAgXCJub2l2YVwiLFxuICAgIFwibm9tZWFyXCIsXG4gICAgXCJub21pbmFsXCIsXG4gICAgXCJub3JkZXN0ZVwiLFxuICAgIFwibm9ydGVhclwiLFxuICAgIFwibm90YXJcIixcbiAgICBcIm5vdGljaWFyXCIsXG4gICAgXCJub3R1cm5vXCIsXG4gICAgXCJub3ZlbG9cIixcbiAgICBcIm5vdmlsaG9cIixcbiAgICBcIm5vdm9cIixcbiAgICBcIm51YmxhZG9cIixcbiAgICBcIm51ZGV6XCIsXG4gICAgXCJudW1lcmFsXCIsXG4gICAgXCJudXBjaWFsXCIsXG4gICAgXCJudXRyaXJcIixcbiAgICBcIm51dmVtXCIsXG4gICAgXCJvYmNlY2Fkb1wiLFxuICAgIFwib2JlZGVjZXJcIixcbiAgICBcIm9iamV0aXZvXCIsXG4gICAgXCJvYnJpZ2Fkb1wiLFxuICAgIFwib2JzY3Vyb1wiLFxuICAgIFwib2JzdGV0cmFcIixcbiAgICBcIm9idGVyXCIsXG4gICAgXCJvYnR1cmFyXCIsXG4gICAgXCJvY2lkZW50ZVwiLFxuICAgIFwib2Npb3NvXCIsXG4gICAgXCJvY29ycmVyXCIsXG4gICAgXCJvY3VsaXN0YVwiLFxuICAgIFwib2N1cGFkb1wiLFxuICAgIFwib2ZlZ2FudGVcIixcbiAgICBcIm9mZW5zaXZhXCIsXG4gICAgXCJvZmVyZW5kYVwiLFxuICAgIFwib2ZpY2luYVwiLFxuICAgIFwib2Z1c2NhZG9cIixcbiAgICBcIm9naXZhXCIsXG4gICAgXCJvbGFyaWFcIixcbiAgICBcIm9sZW9zb1wiLFxuICAgIFwib2xoYXJcIixcbiAgICBcIm9saXZlaXJhXCIsXG4gICAgXCJvbWJyb1wiLFxuICAgIFwib21lbGV0ZVwiLFxuICAgIFwib21pc3NvXCIsXG4gICAgXCJvbWl0aXJcIixcbiAgICBcIm9uZHVsYWRvXCIsXG4gICAgXCJvbmVyb3NvXCIsXG4gICAgXCJvbnRlbVwiLFxuICAgIFwib3BjaW9uYWxcIixcbiAgICBcIm9wZXJhZG9yXCIsXG4gICAgXCJvcG9uZW50ZVwiLFxuICAgIFwib3BvcnR1bm9cIixcbiAgICBcIm9wb3N0b1wiLFxuICAgIFwib3JhclwiLFxuICAgIFwib3JiaXRhclwiLFxuICAgIFwib3JkZW1cIixcbiAgICBcIm9yZGluYWxcIixcbiAgICBcIm9yZmFuYXRvXCIsXG4gICAgXCJvcmdhc21vXCIsXG4gICAgXCJvcmd1bGhvXCIsXG4gICAgXCJvcmllbnRhbFwiLFxuICAgIFwib3JpZ2VtXCIsXG4gICAgXCJvcml1bmRvXCIsXG4gICAgXCJvcmxhXCIsXG4gICAgXCJvcnRvZG94b1wiLFxuICAgIFwib3J2YWxob1wiLFxuICAgIFwib3NjaWxhclwiLFxuICAgIFwib3NzYWRhXCIsXG4gICAgXCJvc3NvXCIsXG4gICAgXCJvc3RlbnRhclwiLFxuICAgIFwib3RpbWlzbW9cIixcbiAgICBcIm91c2FkaWFcIixcbiAgICBcIm91dG9ub1wiLFxuICAgIFwib3V0dWJyb1wiLFxuICAgIFwib3V2aWRvXCIsXG4gICAgXCJvdmVsaGFcIixcbiAgICBcIm92dWxhclwiLFxuICAgIFwib3hpZGFyXCIsXG4gICAgXCJveGlnZW5hclwiLFxuICAgIFwicGFjYXRvXCIsXG4gICAgXCJwYWNpZW50ZVwiLFxuICAgIFwicGFjb3RlXCIsXG4gICAgXCJwYWN0dWFyXCIsXG4gICAgXCJwYWRhcmlhXCIsXG4gICAgXCJwYWRyaW5ob1wiLFxuICAgIFwicGFnYXJcIixcbiAgICBcInBhZ29kZVwiLFxuICAgIFwicGFpbmVsXCIsXG4gICAgXCJwYWlyYXJcIixcbiAgICBcInBhaXNhZ2VtXCIsXG4gICAgXCJwYWxhdnJhXCIsXG4gICAgXCJwYWxlc3RyYVwiLFxuICAgIFwicGFsaGV0YVwiLFxuICAgIFwicGFsaXRvXCIsXG4gICAgXCJwYWxtYWRhXCIsXG4gICAgXCJwYWxwaXRhclwiLFxuICAgIFwicGFuY2FkYVwiLFxuICAgIFwicGFuZWxhXCIsXG4gICAgXCJwYW5mbGV0b1wiLFxuICAgIFwicGFucXVlY2FcIixcbiAgICBcInBhbnRhbmFsXCIsXG4gICAgXCJwYXBhZ2Fpb1wiLFxuICAgIFwicGFwZWxhZGFcIixcbiAgICBcInBhcGlyb1wiLFxuICAgIFwicGFyYWZpbmFcIixcbiAgICBcInBhcmNpYWxcIixcbiAgICBcInBhcmRhbFwiLFxuICAgIFwicGFyZWRlXCIsXG4gICAgXCJwYXJ0aWRhXCIsXG4gICAgXCJwYXNtb1wiLFxuICAgIFwicGFzc2Fkb1wiLFxuICAgIFwicGFzdGVsXCIsXG4gICAgXCJwYXRhbWFyXCIsXG4gICAgXCJwYXRlbnRlXCIsXG4gICAgXCJwYXRpbmFyXCIsXG4gICAgXCJwYXRyb25vXCIsXG4gICAgXCJwYXVsYWRhXCIsXG4gICAgXCJwYXVzYXJcIixcbiAgICBcInBlY3VsaWFyXCIsXG4gICAgXCJwZWRhbGFyXCIsXG4gICAgXCJwZWRlc3RyZVwiLFxuICAgIFwicGVkaWF0cmFcIixcbiAgICBcInBlZHJhXCIsXG4gICAgXCJwZWdhZGFcIixcbiAgICBcInBlaXRvcmFsXCIsXG4gICAgXCJwZWl4ZVwiLFxuICAgIFwicGVsZVwiLFxuICAgIFwicGVsaWNhbm9cIixcbiAgICBcInBlbmNhXCIsXG4gICAgXCJwZW5kdXJhclwiLFxuICAgIFwicGVuZWlyYVwiLFxuICAgIFwicGVuaGFzY29cIixcbiAgICBcInBlbnNhZG9yXCIsXG4gICAgXCJwZW50ZVwiLFxuICAgIFwicGVyY2ViZXJcIixcbiAgICBcInBlcmZlaXRvXCIsXG4gICAgXCJwZXJndW50YVwiLFxuICAgIFwicGVyaXRvXCIsXG4gICAgXCJwZXJtaXRpclwiLFxuICAgIFwicGVybmFcIixcbiAgICBcInBlcnBsZXhvXCIsXG4gICAgXCJwZXJzaWFuYVwiLFxuICAgIFwicGVydGVuY2VcIixcbiAgICBcInBlcnVjYVwiLFxuICAgIFwicGVzY2Fkb1wiLFxuICAgIFwicGVzcXVpc2FcIixcbiAgICBcInBlc3NvYVwiLFxuICAgIFwicGV0aXNjYXJcIixcbiAgICBcInBpYWRhXCIsXG4gICAgXCJwaWNhZG9cIixcbiAgICBcInBpZWRhZGVcIixcbiAgICBcInBpZ21lbnRvXCIsXG4gICAgXCJwaWxhc3RyYVwiLFxuICAgIFwicGlsaGFkb1wiLFxuICAgIFwicGlsb3RhclwiLFxuICAgIFwicGltZW50YVwiLFxuICAgIFwicGluY2VsXCIsXG4gICAgXCJwaW5ndWltXCIsXG4gICAgXCJwaW5oYVwiLFxuICAgIFwicGlub3RlXCIsXG4gICAgXCJwaW50YXJcIixcbiAgICBcInBpb25laXJvXCIsXG4gICAgXCJwaXBvY2FcIixcbiAgICBcInBpcXVldGVcIixcbiAgICBcInBpcmFuaGFcIixcbiAgICBcInBpcmVzXCIsXG4gICAgXCJwaXJ1ZXRhXCIsXG4gICAgXCJwaXNjYXJcIixcbiAgICBcInBpc3RvbGFcIixcbiAgICBcInBpdGFuZ2FcIixcbiAgICBcInBpdmV0ZVwiLFxuICAgIFwicGxhbnRhXCIsXG4gICAgXCJwbGFxdWV0YVwiLFxuICAgIFwicGxhdGluYVwiLFxuICAgIFwicGxlYmV1XCIsXG4gICAgXCJwbHVtYWdlbVwiLFxuICAgIFwicGx1dmlhbFwiLFxuICAgIFwicG5ldVwiLFxuICAgIFwicG9kYVwiLFxuICAgIFwicG9laXJhXCIsXG4gICAgXCJwb2V0aXNhXCIsXG4gICAgXCJwb2xlZ2FkYVwiLFxuICAgIFwicG9saWNpYXJcIixcbiAgICBcInBvbHVlbnRlXCIsXG4gICAgXCJwb2x2aWxob1wiLFxuICAgIFwicG9tYXJcIixcbiAgICBcInBvbWJhXCIsXG4gICAgXCJwb25kZXJhclwiLFxuICAgIFwicG9udGFyaWFcIixcbiAgICBcInBvcHVsb3NvXCIsXG4gICAgXCJwb3J0YVwiLFxuICAgIFwicG9zc3VpclwiLFxuICAgIFwicG9zdGFsXCIsXG4gICAgXCJwb3RlXCIsXG4gICAgXCJwb3VwYXJcIixcbiAgICBcInBvdXNvXCIsXG4gICAgXCJwb3ZvYXJcIixcbiAgICBcInByYWlhXCIsXG4gICAgXCJwcmFuY2hhXCIsXG4gICAgXCJwcmF0b1wiLFxuICAgIFwicHJheGVcIixcbiAgICBcInByZWNlXCIsXG4gICAgXCJwcmVkYWRvclwiLFxuICAgIFwicHJlZmVpdG9cIixcbiAgICBcInByZW1pYXJcIixcbiAgICBcInByZW5zYXJcIixcbiAgICBcInByZXBhcmFyXCIsXG4gICAgXCJwcmVzaWxoYVwiLFxuICAgIFwicHJldGV4dG9cIixcbiAgICBcInByZXZlbmlyXCIsXG4gICAgXCJwcmV6YXJcIixcbiAgICBcInByaW1hdGFcIixcbiAgICBcInByaW5jZXNhXCIsXG4gICAgXCJwcmlzbWFcIixcbiAgICBcInByaXZhZG9cIixcbiAgICBcInByb2Nlc3NvXCIsXG4gICAgXCJwcm9kdXRvXCIsXG4gICAgXCJwcm9mZXRhXCIsXG4gICAgXCJwcm9pYmlkb1wiLFxuICAgIFwicHJvamV0b1wiLFxuICAgIFwicHJvbWV0ZXJcIixcbiAgICBcInByb3BhZ2FyXCIsXG4gICAgXCJwcm9zYVwiLFxuICAgIFwicHJvdGV0b3JcIixcbiAgICBcInByb3ZhZG9yXCIsXG4gICAgXCJwdWJsaWNhclwiLFxuICAgIFwicHVkaW1cIixcbiAgICBcInB1bGFyXCIsXG4gICAgXCJwdWxtb25hclwiLFxuICAgIFwicHVsc2VpcmFcIixcbiAgICBcInB1bmhhbFwiLFxuICAgIFwicHVuaXJcIixcbiAgICBcInB1cGlsb1wiLFxuICAgIFwicHVyZXphXCIsXG4gICAgXCJwdXhhZG9yXCIsXG4gICAgXCJxdWFkcmFcIixcbiAgICBcInF1YW50aWFcIixcbiAgICBcInF1YXJ0b1wiLFxuICAgIFwicXVhc2VcIixcbiAgICBcInF1ZWJyYXJcIixcbiAgICBcInF1ZWRhXCIsXG4gICAgXCJxdWVpam9cIixcbiAgICBcInF1ZW50ZVwiLFxuICAgIFwicXVlcmlkb1wiLFxuICAgIFwicXVpbW9ub1wiLFxuICAgIFwicXVpbmFcIixcbiAgICBcInF1aW9zcXVlXCIsXG4gICAgXCJyYWJhbmFkYVwiLFxuICAgIFwicmFiaXNjb1wiLFxuICAgIFwicmFjaGFyXCIsXG4gICAgXCJyYWNpb25hclwiLFxuICAgIFwicmFkaWFsXCIsXG4gICAgXCJyYWlhclwiLFxuICAgIFwicmFpbmhhXCIsXG4gICAgXCJyYWlvXCIsXG4gICAgXCJyYWl2YVwiLFxuICAgIFwicmFqYWRhXCIsXG4gICAgXCJyYWxhZG9cIixcbiAgICBcInJhbWFsXCIsXG4gICAgXCJyYW5nZXJcIixcbiAgICBcInJhbmh1cmFcIixcbiAgICBcInJhcGFkdXJhXCIsXG4gICAgXCJyYXBlbFwiLFxuICAgIFwicmFwaWRlelwiLFxuICAgIFwicmFwb3NhXCIsXG4gICAgXCJyYXF1ZXRlXCIsXG4gICAgXCJyYXJpZGFkZVwiLFxuICAgIFwicmFzYW50ZVwiLFxuICAgIFwicmFzY3VuaG9cIixcbiAgICBcInJhc2dhclwiLFxuICAgIFwicmFzcGFkb3JcIixcbiAgICBcInJhc3RlaXJhXCIsXG4gICAgXCJyYXN1cmFyXCIsXG4gICAgXCJyYXRhemFuYVwiLFxuICAgIFwicmF0b2VpcmFcIixcbiAgICBcInJlYWxlemFcIixcbiAgICBcInJlYW5pbWFyXCIsXG4gICAgXCJyZWF2ZXJcIixcbiAgICBcInJlYmFpeGFyXCIsXG4gICAgXCJyZWJlbGRlXCIsXG4gICAgXCJyZWJvbGFyXCIsXG4gICAgXCJyZWNhZG9cIixcbiAgICBcInJlY2VudGVcIixcbiAgICBcInJlY2hlaW9cIixcbiAgICBcInJlY2lib1wiLFxuICAgIFwicmVjb3JkYXJcIixcbiAgICBcInJlY3J1dGFyXCIsXG4gICAgXCJyZWN1YXJcIixcbiAgICBcInJlZGVcIixcbiAgICBcInJlZGltaXJcIixcbiAgICBcInJlZG9uZGFcIixcbiAgICBcInJlZHV6aWRhXCIsXG4gICAgXCJyZWVudmlvXCIsXG4gICAgXCJyZWZpbmFyXCIsXG4gICAgXCJyZWZsZXRpclwiLFxuICAgIFwicmVmb2dhclwiLFxuICAgIFwicmVmcmVzY29cIixcbiAgICBcInJlZnVnaWFyXCIsXG4gICAgXCJyZWdhbGlhXCIsXG4gICAgXCJyZWdpbWVcIixcbiAgICBcInJlZ3JhXCIsXG4gICAgXCJyZWluYWRvXCIsXG4gICAgXCJyZWl0b3JcIixcbiAgICBcInJlamVpdGFyXCIsXG4gICAgXCJyZWxhdGl2b1wiLFxuICAgIFwicmVtYWRvclwiLFxuICAgIFwicmVtZW5kb1wiLFxuICAgIFwicmVtb3Jzb1wiLFxuICAgIFwicmVub3ZhZG9cIixcbiAgICBcInJlcGFyb1wiLFxuICAgIFwicmVwZWxpclwiLFxuICAgIFwicmVwbGV0b1wiLFxuICAgIFwicmVwb2xob1wiLFxuICAgIFwicmVwcmVzYVwiLFxuICAgIFwicmVwdWRpYXJcIixcbiAgICBcInJlcXVlcmVyXCIsXG4gICAgXCJyZXNlbmhhXCIsXG4gICAgXCJyZXNmcmlhclwiLFxuICAgIFwicmVzZ2F0YXJcIixcbiAgICBcInJlc2lkaXJcIixcbiAgICBcInJlc29sdmVyXCIsXG4gICAgXCJyZXNwZWl0b1wiLFxuICAgIFwicmVzc2FjYVwiLFxuICAgIFwicmVzdGFudGVcIixcbiAgICBcInJlc3VtaXJcIixcbiAgICBcInJldGFsaG9cIixcbiAgICBcInJldGVyXCIsXG4gICAgXCJyZXRpcmFyXCIsXG4gICAgXCJyZXRvbWFkYVwiLFxuICAgIFwicmV0cmF0YXJcIixcbiAgICBcInJldmVsYXJcIixcbiAgICBcInJldmlzb3JcIixcbiAgICBcInJldm9sdGFcIixcbiAgICBcInJpYWNob1wiLFxuICAgIFwicmljYVwiLFxuICAgIFwicmlnaWRlelwiLFxuICAgIFwicmlnb3Jvc29cIixcbiAgICBcInJpbWFyXCIsXG4gICAgXCJyaW5ndWVcIixcbiAgICBcInJpc2FkYVwiLFxuICAgIFwicmlzY29cIixcbiAgICBcInJpc29uaG9cIixcbiAgICBcInJvYmFsb1wiLFxuICAgIFwicm9jaGVkb1wiLFxuICAgIFwicm9kYWRhXCIsXG4gICAgXCJyb2RlaW9cIixcbiAgICBcInJvZG92aWFcIixcbiAgICBcInJvZWRvclwiLFxuICAgIFwicm9sZXRhXCIsXG4gICAgXCJyb21hbm9cIixcbiAgICBcInJvbmNhclwiLFxuICAgIFwicm9zYWRvXCIsXG4gICAgXCJyb3NlaXJhXCIsXG4gICAgXCJyb3N0b1wiLFxuICAgIFwicm90YVwiLFxuICAgIFwicm90ZWlyb1wiLFxuICAgIFwicm90aW5hXCIsXG4gICAgXCJyb3R1bGFyXCIsXG4gICAgXCJyb3Vjb1wiLFxuICAgIFwicm91cGFcIixcbiAgICBcInJveG9cIixcbiAgICBcInJ1YnJvXCIsXG4gICAgXCJydWdpZG9cIixcbiAgICBcInJ1Z29zb1wiLFxuICAgIFwicnVpdm9cIixcbiAgICBcInJ1bW9cIixcbiAgICBcInJ1cGVzdHJlXCIsXG4gICAgXCJydXNzb1wiLFxuICAgIFwic2Fib3JcIixcbiAgICBcInNhY2lhclwiLFxuICAgIFwic2Fjb2xhXCIsXG4gICAgXCJzYWN1ZGlyXCIsXG4gICAgXCJzYWRpb1wiLFxuICAgIFwic2FmaXJhXCIsXG4gICAgXCJzYWdhXCIsXG4gICAgXCJzYWdyYWRhXCIsXG4gICAgXCJzYWlicm9cIixcbiAgICBcInNhbGFkYVwiLFxuICAgIFwic2FsZWlyb1wiLFxuICAgIFwic2FsZ2Fkb1wiLFxuICAgIFwic2FsaXZhXCIsXG4gICAgXCJzYWxwaWNhclwiLFxuICAgIFwic2Fsc2ljaGFcIixcbiAgICBcInNhbHRhclwiLFxuICAgIFwic2FsdmFkb3JcIixcbiAgICBcInNhbWJhclwiLFxuICAgIFwic2FtdXJhaVwiLFxuICAgIFwic2FuYXJcIixcbiAgICBcInNhbmZvbmFcIixcbiAgICBcInNhbmd1ZVwiLFxuICAgIFwic2FuaWRhZGVcIixcbiAgICBcInNhcGF0b1wiLFxuICAgIFwic2FyZGFcIixcbiAgICBcInNhcmdlbnRvXCIsXG4gICAgXCJzYXJqZXRhXCIsXG4gICAgXCJzYXR1cmFyXCIsXG4gICAgXCJzYXVkYWRlXCIsXG4gICAgXCJzYXhvZm9uZVwiLFxuICAgIFwic2F6b25hbFwiLFxuICAgIFwic2VjYXJcIixcbiAgICBcInNlY3VsYXJcIixcbiAgICBcInNlZGFcIixcbiAgICBcInNlZGVudG9cIixcbiAgICBcInNlZGlhZG9cIixcbiAgICBcInNlZG9zb1wiLFxuICAgIFwic2VkdXRvclwiLFxuICAgIFwic2VnbWVudG9cIixcbiAgICBcInNlZ3JlZG9cIixcbiAgICBcInNlZ3VuZG9cIixcbiAgICBcInNlaXZhXCIsXG4gICAgXCJzZWxldG9cIixcbiAgICBcInNlbHZhZ2VtXCIsXG4gICAgXCJzZW1hbmFsXCIsXG4gICAgXCJzZW1lbnRlXCIsXG4gICAgXCJzZW5hZG9yXCIsXG4gICAgXCJzZW5ob3JcIixcbiAgICBcInNlbnN1YWxcIixcbiAgICBcInNlbnRhZG9cIixcbiAgICBcInNlcGFyYWRvXCIsXG4gICAgXCJzZXJlaWFcIixcbiAgICBcInNlcmluZ2FcIixcbiAgICBcInNlcnJhXCIsXG4gICAgXCJzZXJ2b1wiLFxuICAgIFwic2V0ZW1icm9cIixcbiAgICBcInNldG9yXCIsXG4gICAgXCJzaWdpbG9cIixcbiAgICBcInNpbGh1ZXRhXCIsXG4gICAgXCJzaWxpY29uZVwiLFxuICAgIFwic2ltZXRyaWFcIixcbiAgICBcInNpbXBhdGlhXCIsXG4gICAgXCJzaW11bGFyXCIsXG4gICAgXCJzaW5hbFwiLFxuICAgIFwic2luY2Vyb1wiLFxuICAgIFwic2luZ3VsYXJcIixcbiAgICBcInNpbm9wc2VcIixcbiAgICBcInNpbnRvbmlhXCIsXG4gICAgXCJzaXJlbmVcIixcbiAgICBcInNpcmlcIixcbiAgICBcInNpdHVhZG9cIixcbiAgICBcInNvYmVyYW5vXCIsXG4gICAgXCJzb2JyYVwiLFxuICAgIFwic29jb3Jyb1wiLFxuICAgIFwic29ncm9cIixcbiAgICBcInNvamFcIixcbiAgICBcInNvbGRhXCIsXG4gICAgXCJzb2xldHJhclwiLFxuICAgIFwic29sdGVpcm9cIixcbiAgICBcInNvbWJyaW9cIixcbiAgICBcInNvbmF0YVwiLFxuICAgIFwic29uZGFyXCIsXG4gICAgXCJzb25lZ2FyXCIsXG4gICAgXCJzb25oYWRvclwiLFxuICAgIFwic29ub1wiLFxuICAgIFwic29wcmFub1wiLFxuICAgIFwic29xdWV0ZVwiLFxuICAgIFwic29ycmlyXCIsXG4gICAgXCJzb3J0ZWlvXCIsXG4gICAgXCJzb3NzZWdvXCIsXG4gICAgXCJzb3RhcXVlXCIsXG4gICAgXCJzb3RlcnJhclwiLFxuICAgIFwic292YWRvXCIsXG4gICAgXCJzb3ppbmhvXCIsXG4gICAgXCJzdWF2aXphclwiLFxuICAgIFwic3ViaWRhXCIsXG4gICAgXCJzdWJtZXJzb1wiLFxuICAgIFwic3Vic29sb1wiLFxuICAgIFwic3VidHJhaXJcIixcbiAgICBcInN1Y2F0YVwiLFxuICAgIFwic3VjZXNzb1wiLFxuICAgIFwic3Vjb1wiLFxuICAgIFwic3VkZXN0ZVwiLFxuICAgIFwic3VmaXhvXCIsXG4gICAgXCJzdWdhZG9yXCIsXG4gICAgXCJzdWdlcmlyXCIsXG4gICAgXCJzdWplaXRvXCIsXG4gICAgXCJzdWxmYXRvXCIsXG4gICAgXCJzdW1pclwiLFxuICAgIFwic3VvclwiLFxuICAgIFwic3VwZXJpb3JcIixcbiAgICBcInN1cGxpY2FyXCIsXG4gICAgXCJzdXBvc3RvXCIsXG4gICAgXCJzdXByaW1pclwiLFxuICAgIFwic3VyZGluYVwiLFxuICAgIFwic3VyZmlzdGFcIixcbiAgICBcInN1cnByZXNhXCIsXG4gICAgXCJzdXJyZWFsXCIsXG4gICAgXCJzdXJ0aXJcIixcbiAgICBcInN1c3Bpcm9cIixcbiAgICBcInN1c3RlbnRvXCIsXG4gICAgXCJ0YWJlbGFcIixcbiAgICBcInRhYmxldGVcIixcbiAgICBcInRhYnVhZGFcIixcbiAgICBcInRhY2hvXCIsXG4gICAgXCJ0YWdhcmVsYVwiLFxuICAgIFwidGFsaGVyXCIsXG4gICAgXCJ0YWxvXCIsXG4gICAgXCJ0YWx2ZXpcIixcbiAgICBcInRhbWFuaG9cIixcbiAgICBcInRhbWJvcmltXCIsXG4gICAgXCJ0YW1wYVwiLFxuICAgIFwidGFuZ2VudGVcIixcbiAgICBcInRhbnRvXCIsXG4gICAgXCJ0YXBhclwiLFxuICAgIFwidGFwaW9jYVwiLFxuICAgIFwidGFyZGlvXCIsXG4gICAgXCJ0YXJlZmFcIixcbiAgICBcInRhcmphXCIsXG4gICAgXCJ0YXJyYXhhXCIsXG4gICAgXCJ0YXR1YWdlbVwiLFxuICAgIFwidGF1cmlub1wiLFxuICAgIFwidGF4YXRpdm9cIixcbiAgICBcInRheGlzdGFcIixcbiAgICBcInRlYXRyYWxcIixcbiAgICBcInRlY2VyXCIsXG4gICAgXCJ0ZWNpZG9cIixcbiAgICBcInRlY2xhZG9cIixcbiAgICBcInRlZGlvc29cIixcbiAgICBcInRlaWFcIixcbiAgICBcInRlaW1hclwiLFxuICAgIFwidGVsZWZvbmVcIixcbiAgICBcInRlbGhhZG9cIixcbiAgICBcInRlbXBlcm9cIixcbiAgICBcInRlbmVudGVcIixcbiAgICBcInRlbnNvclwiLFxuICAgIFwidGVudGFyXCIsXG4gICAgXCJ0ZXJtYWxcIixcbiAgICBcInRlcm5vXCIsXG4gICAgXCJ0ZXJyZW5vXCIsXG4gICAgXCJ0ZXNlXCIsXG4gICAgXCJ0ZXNvdXJhXCIsXG4gICAgXCJ0ZXN0YWRvXCIsXG4gICAgXCJ0ZXRvXCIsXG4gICAgXCJ0ZXh0dXJhXCIsXG4gICAgXCJ0ZXh1Z29cIixcbiAgICBcInRpYXJhXCIsXG4gICAgXCJ0aWdlbGFcIixcbiAgICBcInRpam9sb1wiLFxuICAgIFwidGltYnJhclwiLFxuICAgIFwidGltaWRlelwiLFxuICAgIFwidGluZ2lkb1wiLFxuICAgIFwidGludGVpcm9cIixcbiAgICBcInRpcmFnZW1cIixcbiAgICBcInRpdHVsYXJcIixcbiAgICBcInRvYWxoYVwiLFxuICAgIFwidG9jaGFcIixcbiAgICBcInRvbGVyYXJcIixcbiAgICBcInRvbGljZVwiLFxuICAgIFwidG9tYWRhXCIsXG4gICAgXCJ0b21pbGhvXCIsXG4gICAgXCJ0b25lbFwiLFxuICAgIFwidG9udHVyYVwiLFxuICAgIFwidG9wZXRlXCIsXG4gICAgXCJ0b3JhXCIsXG4gICAgXCJ0b3JjaWRvXCIsXG4gICAgXCJ0b3JuZWlvXCIsXG4gICAgXCJ0b3JxdWVcIixcbiAgICBcInRvcnJhZGFcIixcbiAgICBcInRvcnRvXCIsXG4gICAgXCJ0b3N0YXJcIixcbiAgICBcInRvdWNhXCIsXG4gICAgXCJ0b3VwZWlyYVwiLFxuICAgIFwidG94aW5hXCIsXG4gICAgXCJ0cmFiYWxob1wiLFxuICAgIFwidHJhY2VqYXJcIixcbiAgICBcInRyYWR1dG9yXCIsXG4gICAgXCJ0cmFmZWdhclwiLFxuICAgIFwidHJhamV0b1wiLFxuICAgIFwidHJhbWFcIixcbiAgICBcInRyYW5jYXJcIixcbiAgICBcInRyYXBvXCIsXG4gICAgXCJ0cmFzZWlyb1wiLFxuICAgIFwidHJhdGFkb3JcIixcbiAgICBcInRyYXZhclwiLFxuICAgIFwidHJlaW5vXCIsXG4gICAgXCJ0cmVtZXJcIixcbiAgICBcInRyZXBpZGFyXCIsXG4gICAgXCJ0cmV2b1wiLFxuICAgIFwidHJpYWdlbVwiLFxuICAgIFwidHJpYm9cIixcbiAgICBcInRyaWNpY2xvXCIsXG4gICAgXCJ0cmlkZW50ZVwiLFxuICAgIFwidHJpbG9naWFcIixcbiAgICBcInRyaW5kYWRlXCIsXG4gICAgXCJ0cmlwbG9cIixcbiAgICBcInRyaXR1cmFyXCIsXG4gICAgXCJ0cml1bmZhbFwiLFxuICAgIFwidHJvY2FyXCIsXG4gICAgXCJ0cm9tYmV0YVwiLFxuICAgIFwidHJvdmFcIixcbiAgICBcInRydW5mb1wiLFxuICAgIFwidHJ1cXVlXCIsXG4gICAgXCJ0dWJ1bGFyXCIsXG4gICAgXCJ0dWNhbm9cIixcbiAgICBcInR1ZG9cIixcbiAgICBcInR1bGlwYVwiLFxuICAgIFwidHVwaVwiLFxuICAgIFwidHVyYm9cIixcbiAgICBcInR1cm1hXCIsXG4gICAgXCJ0dXJxdWVzYVwiLFxuICAgIFwidHV0ZWxhclwiLFxuICAgIFwidHV0b3JpYWxcIixcbiAgICBcInVpdmFyXCIsXG4gICAgXCJ1bWJpZ29cIixcbiAgICBcInVuaGFcIixcbiAgICBcInVuaWRhZGVcIixcbiAgICBcInVuaWZvcm1lXCIsXG4gICAgXCJ1cm9sb2dpYVwiLFxuICAgIFwidXJzb1wiLFxuICAgIFwidXJ0aWdhXCIsXG4gICAgXCJ1cnVidVwiLFxuICAgIFwidXNhZG9cIixcbiAgICBcInVzaW5hXCIsXG4gICAgXCJ1c3VmcnVpclwiLFxuICAgIFwidmFjaW5hXCIsXG4gICAgXCJ2YWRpYXJcIixcbiAgICBcInZhZ2Fyb3NvXCIsXG4gICAgXCJ2YWlkb3NvXCIsXG4gICAgXCJ2YWxhXCIsXG4gICAgXCJ2YWxlbnRlXCIsXG4gICAgXCJ2YWxpZGFkZVwiLFxuICAgIFwidmFsb3Jlc1wiLFxuICAgIFwidmFudGFnZW1cIixcbiAgICBcInZhcXVlaXJvXCIsXG4gICAgXCJ2YXJhbmRhXCIsXG4gICAgXCJ2YXJldGFcIixcbiAgICBcInZhcnJlclwiLFxuICAgIFwidmFzY3VsYXJcIixcbiAgICBcInZhc2lsaGFcIixcbiAgICBcInZhc3NvdXJhXCIsXG4gICAgXCJ2YXphclwiLFxuICAgIFwidmF6aW9cIixcbiAgICBcInZlYWRvXCIsXG4gICAgXCJ2ZWRhclwiLFxuICAgIFwidmVnZXRhclwiLFxuICAgIFwidmVpY3VsYXJcIixcbiAgICBcInZlbGVpcm9cIixcbiAgICBcInZlbGhpY2VcIixcbiAgICBcInZlbHVkb1wiLFxuICAgIFwidmVuY2Vkb3JcIixcbiAgICBcInZlbmRhdmFsXCIsXG4gICAgXCJ2ZW5lcmFyXCIsXG4gICAgXCJ2ZW50cmVcIixcbiAgICBcInZlcmJhbFwiLFxuICAgIFwidmVyZGFkZVwiLFxuICAgIFwidmVyZWFkb3JcIixcbiAgICBcInZlcmdvbmhhXCIsXG4gICAgXCJ2ZXJtZWxob1wiLFxuICAgIFwidmVybml6XCIsXG4gICAgXCJ2ZXJzYXJcIixcbiAgICBcInZlcnRlbnRlXCIsXG4gICAgXCJ2ZXNwYVwiLFxuICAgIFwidmVzdGlkb1wiLFxuICAgIFwidmV0b3JpYWxcIixcbiAgICBcInZpYWR1dG9cIixcbiAgICBcInZpYWdlbVwiLFxuICAgIFwidmlhamFyXCIsXG4gICAgXCJ2aWF0dXJhXCIsXG4gICAgXCJ2aWJyYWRvclwiLFxuICAgIFwidmlkZWlyYVwiLFxuICAgIFwidmlkcmFyaWFcIixcbiAgICBcInZpZWxhXCIsXG4gICAgXCJ2aWdhXCIsXG4gICAgXCJ2aWdlbnRlXCIsXG4gICAgXCJ2aWdpYXJcIixcbiAgICBcInZpZ29yYXJcIixcbiAgICBcInZpbGFyZWpvXCIsXG4gICAgXCJ2aW5jb1wiLFxuICAgIFwidmluaGV0YVwiLFxuICAgIFwidmluaWxcIixcbiAgICBcInZpb2xldGFcIixcbiAgICBcInZpcmFkYVwiLFxuICAgIFwidmlydHVkZVwiLFxuICAgIFwidmlzaXRhclwiLFxuICAgIFwidmlzdG9cIixcbiAgICBcInZpdHJhbFwiLFxuICAgIFwidml2ZWlyb1wiLFxuICAgIFwidml6aW5ob1wiLFxuICAgIFwidm9hZG9yXCIsXG4gICAgXCJ2b2FyXCIsXG4gICAgXCJ2b2dhbFwiLFxuICAgIFwidm9sYW50ZVwiLFxuICAgIFwidm9sZWlib2xcIixcbiAgICBcInZvbHRhZ2VtXCIsXG4gICAgXCJ2b2x1bW9zb1wiLFxuICAgIFwidm9udGFkZVwiLFxuICAgIFwidnVsdG9cIixcbiAgICBcInZ1dnV6ZWxhXCIsXG4gICAgXCJ4YWRyZXpcIixcbiAgICBcInhhcm9wZVwiLFxuICAgIFwieGVxdWVcIixcbiAgICBcInhlcmV0YXJcIixcbiAgICBcInhlcmlmZVwiLFxuICAgIFwieGluZ2FyXCIsXG4gICAgXCJ6YW5nYWRvXCIsXG4gICAgXCJ6YXJwYXJcIixcbiAgICBcInplYnVcIixcbiAgICBcInplbGFkb3JcIixcbiAgICBcInpvbWJhclwiLFxuICAgIFwiem9vbG9naWFcIixcbiAgICBcInp1bWJpZG9cIlxuXVxuIiwibW9kdWxlLmV4cG9ydHM9W1xuICAgIFwiYWJhbmRvblwiLFxuICAgIFwiYWJpbGl0eVwiLFxuICAgIFwiYWJsZVwiLFxuICAgIFwiYWJvdXRcIixcbiAgICBcImFib3ZlXCIsXG4gICAgXCJhYnNlbnRcIixcbiAgICBcImFic29yYlwiLFxuICAgIFwiYWJzdHJhY3RcIixcbiAgICBcImFic3VyZFwiLFxuICAgIFwiYWJ1c2VcIixcbiAgICBcImFjY2Vzc1wiLFxuICAgIFwiYWNjaWRlbnRcIixcbiAgICBcImFjY291bnRcIixcbiAgICBcImFjY3VzZVwiLFxuICAgIFwiYWNoaWV2ZVwiLFxuICAgIFwiYWNpZFwiLFxuICAgIFwiYWNvdXN0aWNcIixcbiAgICBcImFjcXVpcmVcIixcbiAgICBcImFjcm9zc1wiLFxuICAgIFwiYWN0XCIsXG4gICAgXCJhY3Rpb25cIixcbiAgICBcImFjdG9yXCIsXG4gICAgXCJhY3RyZXNzXCIsXG4gICAgXCJhY3R1YWxcIixcbiAgICBcImFkYXB0XCIsXG4gICAgXCJhZGRcIixcbiAgICBcImFkZGljdFwiLFxuICAgIFwiYWRkcmVzc1wiLFxuICAgIFwiYWRqdXN0XCIsXG4gICAgXCJhZG1pdFwiLFxuICAgIFwiYWR1bHRcIixcbiAgICBcImFkdmFuY2VcIixcbiAgICBcImFkdmljZVwiLFxuICAgIFwiYWVyb2JpY1wiLFxuICAgIFwiYWZmYWlyXCIsXG4gICAgXCJhZmZvcmRcIixcbiAgICBcImFmcmFpZFwiLFxuICAgIFwiYWdhaW5cIixcbiAgICBcImFnZVwiLFxuICAgIFwiYWdlbnRcIixcbiAgICBcImFncmVlXCIsXG4gICAgXCJhaGVhZFwiLFxuICAgIFwiYWltXCIsXG4gICAgXCJhaXJcIixcbiAgICBcImFpcnBvcnRcIixcbiAgICBcImFpc2xlXCIsXG4gICAgXCJhbGFybVwiLFxuICAgIFwiYWxidW1cIixcbiAgICBcImFsY29ob2xcIixcbiAgICBcImFsZXJ0XCIsXG4gICAgXCJhbGllblwiLFxuICAgIFwiYWxsXCIsXG4gICAgXCJhbGxleVwiLFxuICAgIFwiYWxsb3dcIixcbiAgICBcImFsbW9zdFwiLFxuICAgIFwiYWxvbmVcIixcbiAgICBcImFscGhhXCIsXG4gICAgXCJhbHJlYWR5XCIsXG4gICAgXCJhbHNvXCIsXG4gICAgXCJhbHRlclwiLFxuICAgIFwiYWx3YXlzXCIsXG4gICAgXCJhbWF0ZXVyXCIsXG4gICAgXCJhbWF6aW5nXCIsXG4gICAgXCJhbW9uZ1wiLFxuICAgIFwiYW1vdW50XCIsXG4gICAgXCJhbXVzZWRcIixcbiAgICBcImFuYWx5c3RcIixcbiAgICBcImFuY2hvclwiLFxuICAgIFwiYW5jaWVudFwiLFxuICAgIFwiYW5nZXJcIixcbiAgICBcImFuZ2xlXCIsXG4gICAgXCJhbmdyeVwiLFxuICAgIFwiYW5pbWFsXCIsXG4gICAgXCJhbmtsZVwiLFxuICAgIFwiYW5ub3VuY2VcIixcbiAgICBcImFubnVhbFwiLFxuICAgIFwiYW5vdGhlclwiLFxuICAgIFwiYW5zd2VyXCIsXG4gICAgXCJhbnRlbm5hXCIsXG4gICAgXCJhbnRpcXVlXCIsXG4gICAgXCJhbnhpZXR5XCIsXG4gICAgXCJhbnlcIixcbiAgICBcImFwYXJ0XCIsXG4gICAgXCJhcG9sb2d5XCIsXG4gICAgXCJhcHBlYXJcIixcbiAgICBcImFwcGxlXCIsXG4gICAgXCJhcHByb3ZlXCIsXG4gICAgXCJhcHJpbFwiLFxuICAgIFwiYXJjaFwiLFxuICAgIFwiYXJjdGljXCIsXG4gICAgXCJhcmVhXCIsXG4gICAgXCJhcmVuYVwiLFxuICAgIFwiYXJndWVcIixcbiAgICBcImFybVwiLFxuICAgIFwiYXJtZWRcIixcbiAgICBcImFybW9yXCIsXG4gICAgXCJhcm15XCIsXG4gICAgXCJhcm91bmRcIixcbiAgICBcImFycmFuZ2VcIixcbiAgICBcImFycmVzdFwiLFxuICAgIFwiYXJyaXZlXCIsXG4gICAgXCJhcnJvd1wiLFxuICAgIFwiYXJ0XCIsXG4gICAgXCJhcnRlZmFjdFwiLFxuICAgIFwiYXJ0aXN0XCIsXG4gICAgXCJhcnR3b3JrXCIsXG4gICAgXCJhc2tcIixcbiAgICBcImFzcGVjdFwiLFxuICAgIFwiYXNzYXVsdFwiLFxuICAgIFwiYXNzZXRcIixcbiAgICBcImFzc2lzdFwiLFxuICAgIFwiYXNzdW1lXCIsXG4gICAgXCJhc3RobWFcIixcbiAgICBcImF0aGxldGVcIixcbiAgICBcImF0b21cIixcbiAgICBcImF0dGFja1wiLFxuICAgIFwiYXR0ZW5kXCIsXG4gICAgXCJhdHRpdHVkZVwiLFxuICAgIFwiYXR0cmFjdFwiLFxuICAgIFwiYXVjdGlvblwiLFxuICAgIFwiYXVkaXRcIixcbiAgICBcImF1Z3VzdFwiLFxuICAgIFwiYXVudFwiLFxuICAgIFwiYXV0aG9yXCIsXG4gICAgXCJhdXRvXCIsXG4gICAgXCJhdXR1bW5cIixcbiAgICBcImF2ZXJhZ2VcIixcbiAgICBcImF2b2NhZG9cIixcbiAgICBcImF2b2lkXCIsXG4gICAgXCJhd2FrZVwiLFxuICAgIFwiYXdhcmVcIixcbiAgICBcImF3YXlcIixcbiAgICBcImF3ZXNvbWVcIixcbiAgICBcImF3ZnVsXCIsXG4gICAgXCJhd2t3YXJkXCIsXG4gICAgXCJheGlzXCIsXG4gICAgXCJiYWJ5XCIsXG4gICAgXCJiYWNoZWxvclwiLFxuICAgIFwiYmFjb25cIixcbiAgICBcImJhZGdlXCIsXG4gICAgXCJiYWdcIixcbiAgICBcImJhbGFuY2VcIixcbiAgICBcImJhbGNvbnlcIixcbiAgICBcImJhbGxcIixcbiAgICBcImJhbWJvb1wiLFxuICAgIFwiYmFuYW5hXCIsXG4gICAgXCJiYW5uZXJcIixcbiAgICBcImJhclwiLFxuICAgIFwiYmFyZWx5XCIsXG4gICAgXCJiYXJnYWluXCIsXG4gICAgXCJiYXJyZWxcIixcbiAgICBcImJhc2VcIixcbiAgICBcImJhc2ljXCIsXG4gICAgXCJiYXNrZXRcIixcbiAgICBcImJhdHRsZVwiLFxuICAgIFwiYmVhY2hcIixcbiAgICBcImJlYW5cIixcbiAgICBcImJlYXV0eVwiLFxuICAgIFwiYmVjYXVzZVwiLFxuICAgIFwiYmVjb21lXCIsXG4gICAgXCJiZWVmXCIsXG4gICAgXCJiZWZvcmVcIixcbiAgICBcImJlZ2luXCIsXG4gICAgXCJiZWhhdmVcIixcbiAgICBcImJlaGluZFwiLFxuICAgIFwiYmVsaWV2ZVwiLFxuICAgIFwiYmVsb3dcIixcbiAgICBcImJlbHRcIixcbiAgICBcImJlbmNoXCIsXG4gICAgXCJiZW5lZml0XCIsXG4gICAgXCJiZXN0XCIsXG4gICAgXCJiZXRyYXlcIixcbiAgICBcImJldHRlclwiLFxuICAgIFwiYmV0d2VlblwiLFxuICAgIFwiYmV5b25kXCIsXG4gICAgXCJiaWN5Y2xlXCIsXG4gICAgXCJiaWRcIixcbiAgICBcImJpa2VcIixcbiAgICBcImJpbmRcIixcbiAgICBcImJpb2xvZ3lcIixcbiAgICBcImJpcmRcIixcbiAgICBcImJpcnRoXCIsXG4gICAgXCJiaXR0ZXJcIixcbiAgICBcImJsYWNrXCIsXG4gICAgXCJibGFkZVwiLFxuICAgIFwiYmxhbWVcIixcbiAgICBcImJsYW5rZXRcIixcbiAgICBcImJsYXN0XCIsXG4gICAgXCJibGVha1wiLFxuICAgIFwiYmxlc3NcIixcbiAgICBcImJsaW5kXCIsXG4gICAgXCJibG9vZFwiLFxuICAgIFwiYmxvc3NvbVwiLFxuICAgIFwiYmxvdXNlXCIsXG4gICAgXCJibHVlXCIsXG4gICAgXCJibHVyXCIsXG4gICAgXCJibHVzaFwiLFxuICAgIFwiYm9hcmRcIixcbiAgICBcImJvYXRcIixcbiAgICBcImJvZHlcIixcbiAgICBcImJvaWxcIixcbiAgICBcImJvbWJcIixcbiAgICBcImJvbmVcIixcbiAgICBcImJvbnVzXCIsXG4gICAgXCJib29rXCIsXG4gICAgXCJib29zdFwiLFxuICAgIFwiYm9yZGVyXCIsXG4gICAgXCJib3JpbmdcIixcbiAgICBcImJvcnJvd1wiLFxuICAgIFwiYm9zc1wiLFxuICAgIFwiYm90dG9tXCIsXG4gICAgXCJib3VuY2VcIixcbiAgICBcImJveFwiLFxuICAgIFwiYm95XCIsXG4gICAgXCJicmFja2V0XCIsXG4gICAgXCJicmFpblwiLFxuICAgIFwiYnJhbmRcIixcbiAgICBcImJyYXNzXCIsXG4gICAgXCJicmF2ZVwiLFxuICAgIFwiYnJlYWRcIixcbiAgICBcImJyZWV6ZVwiLFxuICAgIFwiYnJpY2tcIixcbiAgICBcImJyaWRnZVwiLFxuICAgIFwiYnJpZWZcIixcbiAgICBcImJyaWdodFwiLFxuICAgIFwiYnJpbmdcIixcbiAgICBcImJyaXNrXCIsXG4gICAgXCJicm9jY29saVwiLFxuICAgIFwiYnJva2VuXCIsXG4gICAgXCJicm9uemVcIixcbiAgICBcImJyb29tXCIsXG4gICAgXCJicm90aGVyXCIsXG4gICAgXCJicm93blwiLFxuICAgIFwiYnJ1c2hcIixcbiAgICBcImJ1YmJsZVwiLFxuICAgIFwiYnVkZHlcIixcbiAgICBcImJ1ZGdldFwiLFxuICAgIFwiYnVmZmFsb1wiLFxuICAgIFwiYnVpbGRcIixcbiAgICBcImJ1bGJcIixcbiAgICBcImJ1bGtcIixcbiAgICBcImJ1bGxldFwiLFxuICAgIFwiYnVuZGxlXCIsXG4gICAgXCJidW5rZXJcIixcbiAgICBcImJ1cmRlblwiLFxuICAgIFwiYnVyZ2VyXCIsXG4gICAgXCJidXJzdFwiLFxuICAgIFwiYnVzXCIsXG4gICAgXCJidXNpbmVzc1wiLFxuICAgIFwiYnVzeVwiLFxuICAgIFwiYnV0dGVyXCIsXG4gICAgXCJidXllclwiLFxuICAgIFwiYnV6elwiLFxuICAgIFwiY2FiYmFnZVwiLFxuICAgIFwiY2FiaW5cIixcbiAgICBcImNhYmxlXCIsXG4gICAgXCJjYWN0dXNcIixcbiAgICBcImNhZ2VcIixcbiAgICBcImNha2VcIixcbiAgICBcImNhbGxcIixcbiAgICBcImNhbG1cIixcbiAgICBcImNhbWVyYVwiLFxuICAgIFwiY2FtcFwiLFxuICAgIFwiY2FuXCIsXG4gICAgXCJjYW5hbFwiLFxuICAgIFwiY2FuY2VsXCIsXG4gICAgXCJjYW5keVwiLFxuICAgIFwiY2Fubm9uXCIsXG4gICAgXCJjYW5vZVwiLFxuICAgIFwiY2FudmFzXCIsXG4gICAgXCJjYW55b25cIixcbiAgICBcImNhcGFibGVcIixcbiAgICBcImNhcGl0YWxcIixcbiAgICBcImNhcHRhaW5cIixcbiAgICBcImNhclwiLFxuICAgIFwiY2FyYm9uXCIsXG4gICAgXCJjYXJkXCIsXG4gICAgXCJjYXJnb1wiLFxuICAgIFwiY2FycGV0XCIsXG4gICAgXCJjYXJyeVwiLFxuICAgIFwiY2FydFwiLFxuICAgIFwiY2FzZVwiLFxuICAgIFwiY2FzaFwiLFxuICAgIFwiY2FzaW5vXCIsXG4gICAgXCJjYXN0bGVcIixcbiAgICBcImNhc3VhbFwiLFxuICAgIFwiY2F0XCIsXG4gICAgXCJjYXRhbG9nXCIsXG4gICAgXCJjYXRjaFwiLFxuICAgIFwiY2F0ZWdvcnlcIixcbiAgICBcImNhdHRsZVwiLFxuICAgIFwiY2F1Z2h0XCIsXG4gICAgXCJjYXVzZVwiLFxuICAgIFwiY2F1dGlvblwiLFxuICAgIFwiY2F2ZVwiLFxuICAgIFwiY2VpbGluZ1wiLFxuICAgIFwiY2VsZXJ5XCIsXG4gICAgXCJjZW1lbnRcIixcbiAgICBcImNlbnN1c1wiLFxuICAgIFwiY2VudHVyeVwiLFxuICAgIFwiY2VyZWFsXCIsXG4gICAgXCJjZXJ0YWluXCIsXG4gICAgXCJjaGFpclwiLFxuICAgIFwiY2hhbGtcIixcbiAgICBcImNoYW1waW9uXCIsXG4gICAgXCJjaGFuZ2VcIixcbiAgICBcImNoYW9zXCIsXG4gICAgXCJjaGFwdGVyXCIsXG4gICAgXCJjaGFyZ2VcIixcbiAgICBcImNoYXNlXCIsXG4gICAgXCJjaGF0XCIsXG4gICAgXCJjaGVhcFwiLFxuICAgIFwiY2hlY2tcIixcbiAgICBcImNoZWVzZVwiLFxuICAgIFwiY2hlZlwiLFxuICAgIFwiY2hlcnJ5XCIsXG4gICAgXCJjaGVzdFwiLFxuICAgIFwiY2hpY2tlblwiLFxuICAgIFwiY2hpZWZcIixcbiAgICBcImNoaWxkXCIsXG4gICAgXCJjaGltbmV5XCIsXG4gICAgXCJjaG9pY2VcIixcbiAgICBcImNob29zZVwiLFxuICAgIFwiY2hyb25pY1wiLFxuICAgIFwiY2h1Y2tsZVwiLFxuICAgIFwiY2h1bmtcIixcbiAgICBcImNodXJuXCIsXG4gICAgXCJjaWdhclwiLFxuICAgIFwiY2lubmFtb25cIixcbiAgICBcImNpcmNsZVwiLFxuICAgIFwiY2l0aXplblwiLFxuICAgIFwiY2l0eVwiLFxuICAgIFwiY2l2aWxcIixcbiAgICBcImNsYWltXCIsXG4gICAgXCJjbGFwXCIsXG4gICAgXCJjbGFyaWZ5XCIsXG4gICAgXCJjbGF3XCIsXG4gICAgXCJjbGF5XCIsXG4gICAgXCJjbGVhblwiLFxuICAgIFwiY2xlcmtcIixcbiAgICBcImNsZXZlclwiLFxuICAgIFwiY2xpY2tcIixcbiAgICBcImNsaWVudFwiLFxuICAgIFwiY2xpZmZcIixcbiAgICBcImNsaW1iXCIsXG4gICAgXCJjbGluaWNcIixcbiAgICBcImNsaXBcIixcbiAgICBcImNsb2NrXCIsXG4gICAgXCJjbG9nXCIsXG4gICAgXCJjbG9zZVwiLFxuICAgIFwiY2xvdGhcIixcbiAgICBcImNsb3VkXCIsXG4gICAgXCJjbG93blwiLFxuICAgIFwiY2x1YlwiLFxuICAgIFwiY2x1bXBcIixcbiAgICBcImNsdXN0ZXJcIixcbiAgICBcImNsdXRjaFwiLFxuICAgIFwiY29hY2hcIixcbiAgICBcImNvYXN0XCIsXG4gICAgXCJjb2NvbnV0XCIsXG4gICAgXCJjb2RlXCIsXG4gICAgXCJjb2ZmZWVcIixcbiAgICBcImNvaWxcIixcbiAgICBcImNvaW5cIixcbiAgICBcImNvbGxlY3RcIixcbiAgICBcImNvbG9yXCIsXG4gICAgXCJjb2x1bW5cIixcbiAgICBcImNvbWJpbmVcIixcbiAgICBcImNvbWVcIixcbiAgICBcImNvbWZvcnRcIixcbiAgICBcImNvbWljXCIsXG4gICAgXCJjb21tb25cIixcbiAgICBcImNvbXBhbnlcIixcbiAgICBcImNvbmNlcnRcIixcbiAgICBcImNvbmR1Y3RcIixcbiAgICBcImNvbmZpcm1cIixcbiAgICBcImNvbmdyZXNzXCIsXG4gICAgXCJjb25uZWN0XCIsXG4gICAgXCJjb25zaWRlclwiLFxuICAgIFwiY29udHJvbFwiLFxuICAgIFwiY29udmluY2VcIixcbiAgICBcImNvb2tcIixcbiAgICBcImNvb2xcIixcbiAgICBcImNvcHBlclwiLFxuICAgIFwiY29weVwiLFxuICAgIFwiY29yYWxcIixcbiAgICBcImNvcmVcIixcbiAgICBcImNvcm5cIixcbiAgICBcImNvcnJlY3RcIixcbiAgICBcImNvc3RcIixcbiAgICBcImNvdHRvblwiLFxuICAgIFwiY291Y2hcIixcbiAgICBcImNvdW50cnlcIixcbiAgICBcImNvdXBsZVwiLFxuICAgIFwiY291cnNlXCIsXG4gICAgXCJjb3VzaW5cIixcbiAgICBcImNvdmVyXCIsXG4gICAgXCJjb3lvdGVcIixcbiAgICBcImNyYWNrXCIsXG4gICAgXCJjcmFkbGVcIixcbiAgICBcImNyYWZ0XCIsXG4gICAgXCJjcmFtXCIsXG4gICAgXCJjcmFuZVwiLFxuICAgIFwiY3Jhc2hcIixcbiAgICBcImNyYXRlclwiLFxuICAgIFwiY3Jhd2xcIixcbiAgICBcImNyYXp5XCIsXG4gICAgXCJjcmVhbVwiLFxuICAgIFwiY3JlZGl0XCIsXG4gICAgXCJjcmVla1wiLFxuICAgIFwiY3Jld1wiLFxuICAgIFwiY3JpY2tldFwiLFxuICAgIFwiY3JpbWVcIixcbiAgICBcImNyaXNwXCIsXG4gICAgXCJjcml0aWNcIixcbiAgICBcImNyb3BcIixcbiAgICBcImNyb3NzXCIsXG4gICAgXCJjcm91Y2hcIixcbiAgICBcImNyb3dkXCIsXG4gICAgXCJjcnVjaWFsXCIsXG4gICAgXCJjcnVlbFwiLFxuICAgIFwiY3J1aXNlXCIsXG4gICAgXCJjcnVtYmxlXCIsXG4gICAgXCJjcnVuY2hcIixcbiAgICBcImNydXNoXCIsXG4gICAgXCJjcnlcIixcbiAgICBcImNyeXN0YWxcIixcbiAgICBcImN1YmVcIixcbiAgICBcImN1bHR1cmVcIixcbiAgICBcImN1cFwiLFxuICAgIFwiY3VwYm9hcmRcIixcbiAgICBcImN1cmlvdXNcIixcbiAgICBcImN1cnJlbnRcIixcbiAgICBcImN1cnRhaW5cIixcbiAgICBcImN1cnZlXCIsXG4gICAgXCJjdXNoaW9uXCIsXG4gICAgXCJjdXN0b21cIixcbiAgICBcImN1dGVcIixcbiAgICBcImN5Y2xlXCIsXG4gICAgXCJkYWRcIixcbiAgICBcImRhbWFnZVwiLFxuICAgIFwiZGFtcFwiLFxuICAgIFwiZGFuY2VcIixcbiAgICBcImRhbmdlclwiLFxuICAgIFwiZGFyaW5nXCIsXG4gICAgXCJkYXNoXCIsXG4gICAgXCJkYXVnaHRlclwiLFxuICAgIFwiZGF3blwiLFxuICAgIFwiZGF5XCIsXG4gICAgXCJkZWFsXCIsXG4gICAgXCJkZWJhdGVcIixcbiAgICBcImRlYnJpc1wiLFxuICAgIFwiZGVjYWRlXCIsXG4gICAgXCJkZWNlbWJlclwiLFxuICAgIFwiZGVjaWRlXCIsXG4gICAgXCJkZWNsaW5lXCIsXG4gICAgXCJkZWNvcmF0ZVwiLFxuICAgIFwiZGVjcmVhc2VcIixcbiAgICBcImRlZXJcIixcbiAgICBcImRlZmVuc2VcIixcbiAgICBcImRlZmluZVwiLFxuICAgIFwiZGVmeVwiLFxuICAgIFwiZGVncmVlXCIsXG4gICAgXCJkZWxheVwiLFxuICAgIFwiZGVsaXZlclwiLFxuICAgIFwiZGVtYW5kXCIsXG4gICAgXCJkZW1pc2VcIixcbiAgICBcImRlbmlhbFwiLFxuICAgIFwiZGVudGlzdFwiLFxuICAgIFwiZGVueVwiLFxuICAgIFwiZGVwYXJ0XCIsXG4gICAgXCJkZXBlbmRcIixcbiAgICBcImRlcG9zaXRcIixcbiAgICBcImRlcHRoXCIsXG4gICAgXCJkZXB1dHlcIixcbiAgICBcImRlcml2ZVwiLFxuICAgIFwiZGVzY3JpYmVcIixcbiAgICBcImRlc2VydFwiLFxuICAgIFwiZGVzaWduXCIsXG4gICAgXCJkZXNrXCIsXG4gICAgXCJkZXNwYWlyXCIsXG4gICAgXCJkZXN0cm95XCIsXG4gICAgXCJkZXRhaWxcIixcbiAgICBcImRldGVjdFwiLFxuICAgIFwiZGV2ZWxvcFwiLFxuICAgIFwiZGV2aWNlXCIsXG4gICAgXCJkZXZvdGVcIixcbiAgICBcImRpYWdyYW1cIixcbiAgICBcImRpYWxcIixcbiAgICBcImRpYW1vbmRcIixcbiAgICBcImRpYXJ5XCIsXG4gICAgXCJkaWNlXCIsXG4gICAgXCJkaWVzZWxcIixcbiAgICBcImRpZXRcIixcbiAgICBcImRpZmZlclwiLFxuICAgIFwiZGlnaXRhbFwiLFxuICAgIFwiZGlnbml0eVwiLFxuICAgIFwiZGlsZW1tYVwiLFxuICAgIFwiZGlubmVyXCIsXG4gICAgXCJkaW5vc2F1clwiLFxuICAgIFwiZGlyZWN0XCIsXG4gICAgXCJkaXJ0XCIsXG4gICAgXCJkaXNhZ3JlZVwiLFxuICAgIFwiZGlzY292ZXJcIixcbiAgICBcImRpc2Vhc2VcIixcbiAgICBcImRpc2hcIixcbiAgICBcImRpc21pc3NcIixcbiAgICBcImRpc29yZGVyXCIsXG4gICAgXCJkaXNwbGF5XCIsXG4gICAgXCJkaXN0YW5jZVwiLFxuICAgIFwiZGl2ZXJ0XCIsXG4gICAgXCJkaXZpZGVcIixcbiAgICBcImRpdm9yY2VcIixcbiAgICBcImRpenp5XCIsXG4gICAgXCJkb2N0b3JcIixcbiAgICBcImRvY3VtZW50XCIsXG4gICAgXCJkb2dcIixcbiAgICBcImRvbGxcIixcbiAgICBcImRvbHBoaW5cIixcbiAgICBcImRvbWFpblwiLFxuICAgIFwiZG9uYXRlXCIsXG4gICAgXCJkb25rZXlcIixcbiAgICBcImRvbm9yXCIsXG4gICAgXCJkb29yXCIsXG4gICAgXCJkb3NlXCIsXG4gICAgXCJkb3VibGVcIixcbiAgICBcImRvdmVcIixcbiAgICBcImRyYWZ0XCIsXG4gICAgXCJkcmFnb25cIixcbiAgICBcImRyYW1hXCIsXG4gICAgXCJkcmFzdGljXCIsXG4gICAgXCJkcmF3XCIsXG4gICAgXCJkcmVhbVwiLFxuICAgIFwiZHJlc3NcIixcbiAgICBcImRyaWZ0XCIsXG4gICAgXCJkcmlsbFwiLFxuICAgIFwiZHJpbmtcIixcbiAgICBcImRyaXBcIixcbiAgICBcImRyaXZlXCIsXG4gICAgXCJkcm9wXCIsXG4gICAgXCJkcnVtXCIsXG4gICAgXCJkcnlcIixcbiAgICBcImR1Y2tcIixcbiAgICBcImR1bWJcIixcbiAgICBcImR1bmVcIixcbiAgICBcImR1cmluZ1wiLFxuICAgIFwiZHVzdFwiLFxuICAgIFwiZHV0Y2hcIixcbiAgICBcImR1dHlcIixcbiAgICBcImR3YXJmXCIsXG4gICAgXCJkeW5hbWljXCIsXG4gICAgXCJlYWdlclwiLFxuICAgIFwiZWFnbGVcIixcbiAgICBcImVhcmx5XCIsXG4gICAgXCJlYXJuXCIsXG4gICAgXCJlYXJ0aFwiLFxuICAgIFwiZWFzaWx5XCIsXG4gICAgXCJlYXN0XCIsXG4gICAgXCJlYXN5XCIsXG4gICAgXCJlY2hvXCIsXG4gICAgXCJlY29sb2d5XCIsXG4gICAgXCJlY29ub215XCIsXG4gICAgXCJlZGdlXCIsXG4gICAgXCJlZGl0XCIsXG4gICAgXCJlZHVjYXRlXCIsXG4gICAgXCJlZmZvcnRcIixcbiAgICBcImVnZ1wiLFxuICAgIFwiZWlnaHRcIixcbiAgICBcImVpdGhlclwiLFxuICAgIFwiZWxib3dcIixcbiAgICBcImVsZGVyXCIsXG4gICAgXCJlbGVjdHJpY1wiLFxuICAgIFwiZWxlZ2FudFwiLFxuICAgIFwiZWxlbWVudFwiLFxuICAgIFwiZWxlcGhhbnRcIixcbiAgICBcImVsZXZhdG9yXCIsXG4gICAgXCJlbGl0ZVwiLFxuICAgIFwiZWxzZVwiLFxuICAgIFwiZW1iYXJrXCIsXG4gICAgXCJlbWJvZHlcIixcbiAgICBcImVtYnJhY2VcIixcbiAgICBcImVtZXJnZVwiLFxuICAgIFwiZW1vdGlvblwiLFxuICAgIFwiZW1wbG95XCIsXG4gICAgXCJlbXBvd2VyXCIsXG4gICAgXCJlbXB0eVwiLFxuICAgIFwiZW5hYmxlXCIsXG4gICAgXCJlbmFjdFwiLFxuICAgIFwiZW5kXCIsXG4gICAgXCJlbmRsZXNzXCIsXG4gICAgXCJlbmRvcnNlXCIsXG4gICAgXCJlbmVteVwiLFxuICAgIFwiZW5lcmd5XCIsXG4gICAgXCJlbmZvcmNlXCIsXG4gICAgXCJlbmdhZ2VcIixcbiAgICBcImVuZ2luZVwiLFxuICAgIFwiZW5oYW5jZVwiLFxuICAgIFwiZW5qb3lcIixcbiAgICBcImVubGlzdFwiLFxuICAgIFwiZW5vdWdoXCIsXG4gICAgXCJlbnJpY2hcIixcbiAgICBcImVucm9sbFwiLFxuICAgIFwiZW5zdXJlXCIsXG4gICAgXCJlbnRlclwiLFxuICAgIFwiZW50aXJlXCIsXG4gICAgXCJlbnRyeVwiLFxuICAgIFwiZW52ZWxvcGVcIixcbiAgICBcImVwaXNvZGVcIixcbiAgICBcImVxdWFsXCIsXG4gICAgXCJlcXVpcFwiLFxuICAgIFwiZXJhXCIsXG4gICAgXCJlcmFzZVwiLFxuICAgIFwiZXJvZGVcIixcbiAgICBcImVyb3Npb25cIixcbiAgICBcImVycm9yXCIsXG4gICAgXCJlcnVwdFwiLFxuICAgIFwiZXNjYXBlXCIsXG4gICAgXCJlc3NheVwiLFxuICAgIFwiZXNzZW5jZVwiLFxuICAgIFwiZXN0YXRlXCIsXG4gICAgXCJldGVybmFsXCIsXG4gICAgXCJldGhpY3NcIixcbiAgICBcImV2aWRlbmNlXCIsXG4gICAgXCJldmlsXCIsXG4gICAgXCJldm9rZVwiLFxuICAgIFwiZXZvbHZlXCIsXG4gICAgXCJleGFjdFwiLFxuICAgIFwiZXhhbXBsZVwiLFxuICAgIFwiZXhjZXNzXCIsXG4gICAgXCJleGNoYW5nZVwiLFxuICAgIFwiZXhjaXRlXCIsXG4gICAgXCJleGNsdWRlXCIsXG4gICAgXCJleGN1c2VcIixcbiAgICBcImV4ZWN1dGVcIixcbiAgICBcImV4ZXJjaXNlXCIsXG4gICAgXCJleGhhdXN0XCIsXG4gICAgXCJleGhpYml0XCIsXG4gICAgXCJleGlsZVwiLFxuICAgIFwiZXhpc3RcIixcbiAgICBcImV4aXRcIixcbiAgICBcImV4b3RpY1wiLFxuICAgIFwiZXhwYW5kXCIsXG4gICAgXCJleHBlY3RcIixcbiAgICBcImV4cGlyZVwiLFxuICAgIFwiZXhwbGFpblwiLFxuICAgIFwiZXhwb3NlXCIsXG4gICAgXCJleHByZXNzXCIsXG4gICAgXCJleHRlbmRcIixcbiAgICBcImV4dHJhXCIsXG4gICAgXCJleWVcIixcbiAgICBcImV5ZWJyb3dcIixcbiAgICBcImZhYnJpY1wiLFxuICAgIFwiZmFjZVwiLFxuICAgIFwiZmFjdWx0eVwiLFxuICAgIFwiZmFkZVwiLFxuICAgIFwiZmFpbnRcIixcbiAgICBcImZhaXRoXCIsXG4gICAgXCJmYWxsXCIsXG4gICAgXCJmYWxzZVwiLFxuICAgIFwiZmFtZVwiLFxuICAgIFwiZmFtaWx5XCIsXG4gICAgXCJmYW1vdXNcIixcbiAgICBcImZhblwiLFxuICAgIFwiZmFuY3lcIixcbiAgICBcImZhbnRhc3lcIixcbiAgICBcImZhcm1cIixcbiAgICBcImZhc2hpb25cIixcbiAgICBcImZhdFwiLFxuICAgIFwiZmF0YWxcIixcbiAgICBcImZhdGhlclwiLFxuICAgIFwiZmF0aWd1ZVwiLFxuICAgIFwiZmF1bHRcIixcbiAgICBcImZhdm9yaXRlXCIsXG4gICAgXCJmZWF0dXJlXCIsXG4gICAgXCJmZWJydWFyeVwiLFxuICAgIFwiZmVkZXJhbFwiLFxuICAgIFwiZmVlXCIsXG4gICAgXCJmZWVkXCIsXG4gICAgXCJmZWVsXCIsXG4gICAgXCJmZW1hbGVcIixcbiAgICBcImZlbmNlXCIsXG4gICAgXCJmZXN0aXZhbFwiLFxuICAgIFwiZmV0Y2hcIixcbiAgICBcImZldmVyXCIsXG4gICAgXCJmZXdcIixcbiAgICBcImZpYmVyXCIsXG4gICAgXCJmaWN0aW9uXCIsXG4gICAgXCJmaWVsZFwiLFxuICAgIFwiZmlndXJlXCIsXG4gICAgXCJmaWxlXCIsXG4gICAgXCJmaWxtXCIsXG4gICAgXCJmaWx0ZXJcIixcbiAgICBcImZpbmFsXCIsXG4gICAgXCJmaW5kXCIsXG4gICAgXCJmaW5lXCIsXG4gICAgXCJmaW5nZXJcIixcbiAgICBcImZpbmlzaFwiLFxuICAgIFwiZmlyZVwiLFxuICAgIFwiZmlybVwiLFxuICAgIFwiZmlyc3RcIixcbiAgICBcImZpc2NhbFwiLFxuICAgIFwiZmlzaFwiLFxuICAgIFwiZml0XCIsXG4gICAgXCJmaXRuZXNzXCIsXG4gICAgXCJmaXhcIixcbiAgICBcImZsYWdcIixcbiAgICBcImZsYW1lXCIsXG4gICAgXCJmbGFzaFwiLFxuICAgIFwiZmxhdFwiLFxuICAgIFwiZmxhdm9yXCIsXG4gICAgXCJmbGVlXCIsXG4gICAgXCJmbGlnaHRcIixcbiAgICBcImZsaXBcIixcbiAgICBcImZsb2F0XCIsXG4gICAgXCJmbG9ja1wiLFxuICAgIFwiZmxvb3JcIixcbiAgICBcImZsb3dlclwiLFxuICAgIFwiZmx1aWRcIixcbiAgICBcImZsdXNoXCIsXG4gICAgXCJmbHlcIixcbiAgICBcImZvYW1cIixcbiAgICBcImZvY3VzXCIsXG4gICAgXCJmb2dcIixcbiAgICBcImZvaWxcIixcbiAgICBcImZvbGRcIixcbiAgICBcImZvbGxvd1wiLFxuICAgIFwiZm9vZFwiLFxuICAgIFwiZm9vdFwiLFxuICAgIFwiZm9yY2VcIixcbiAgICBcImZvcmVzdFwiLFxuICAgIFwiZm9yZ2V0XCIsXG4gICAgXCJmb3JrXCIsXG4gICAgXCJmb3J0dW5lXCIsXG4gICAgXCJmb3J1bVwiLFxuICAgIFwiZm9yd2FyZFwiLFxuICAgIFwiZm9zc2lsXCIsXG4gICAgXCJmb3N0ZXJcIixcbiAgICBcImZvdW5kXCIsXG4gICAgXCJmb3hcIixcbiAgICBcImZyYWdpbGVcIixcbiAgICBcImZyYW1lXCIsXG4gICAgXCJmcmVxdWVudFwiLFxuICAgIFwiZnJlc2hcIixcbiAgICBcImZyaWVuZFwiLFxuICAgIFwiZnJpbmdlXCIsXG4gICAgXCJmcm9nXCIsXG4gICAgXCJmcm9udFwiLFxuICAgIFwiZnJvc3RcIixcbiAgICBcImZyb3duXCIsXG4gICAgXCJmcm96ZW5cIixcbiAgICBcImZydWl0XCIsXG4gICAgXCJmdWVsXCIsXG4gICAgXCJmdW5cIixcbiAgICBcImZ1bm55XCIsXG4gICAgXCJmdXJuYWNlXCIsXG4gICAgXCJmdXJ5XCIsXG4gICAgXCJmdXR1cmVcIixcbiAgICBcImdhZGdldFwiLFxuICAgIFwiZ2FpblwiLFxuICAgIFwiZ2FsYXh5XCIsXG4gICAgXCJnYWxsZXJ5XCIsXG4gICAgXCJnYW1lXCIsXG4gICAgXCJnYXBcIixcbiAgICBcImdhcmFnZVwiLFxuICAgIFwiZ2FyYmFnZVwiLFxuICAgIFwiZ2FyZGVuXCIsXG4gICAgXCJnYXJsaWNcIixcbiAgICBcImdhcm1lbnRcIixcbiAgICBcImdhc1wiLFxuICAgIFwiZ2FzcFwiLFxuICAgIFwiZ2F0ZVwiLFxuICAgIFwiZ2F0aGVyXCIsXG4gICAgXCJnYXVnZVwiLFxuICAgIFwiZ2F6ZVwiLFxuICAgIFwiZ2VuZXJhbFwiLFxuICAgIFwiZ2VuaXVzXCIsXG4gICAgXCJnZW5yZVwiLFxuICAgIFwiZ2VudGxlXCIsXG4gICAgXCJnZW51aW5lXCIsXG4gICAgXCJnZXN0dXJlXCIsXG4gICAgXCJnaG9zdFwiLFxuICAgIFwiZ2lhbnRcIixcbiAgICBcImdpZnRcIixcbiAgICBcImdpZ2dsZVwiLFxuICAgIFwiZ2luZ2VyXCIsXG4gICAgXCJnaXJhZmZlXCIsXG4gICAgXCJnaXJsXCIsXG4gICAgXCJnaXZlXCIsXG4gICAgXCJnbGFkXCIsXG4gICAgXCJnbGFuY2VcIixcbiAgICBcImdsYXJlXCIsXG4gICAgXCJnbGFzc1wiLFxuICAgIFwiZ2xpZGVcIixcbiAgICBcImdsaW1wc2VcIixcbiAgICBcImdsb2JlXCIsXG4gICAgXCJnbG9vbVwiLFxuICAgIFwiZ2xvcnlcIixcbiAgICBcImdsb3ZlXCIsXG4gICAgXCJnbG93XCIsXG4gICAgXCJnbHVlXCIsXG4gICAgXCJnb2F0XCIsXG4gICAgXCJnb2RkZXNzXCIsXG4gICAgXCJnb2xkXCIsXG4gICAgXCJnb29kXCIsXG4gICAgXCJnb29zZVwiLFxuICAgIFwiZ29yaWxsYVwiLFxuICAgIFwiZ29zcGVsXCIsXG4gICAgXCJnb3NzaXBcIixcbiAgICBcImdvdmVyblwiLFxuICAgIFwiZ293blwiLFxuICAgIFwiZ3JhYlwiLFxuICAgIFwiZ3JhY2VcIixcbiAgICBcImdyYWluXCIsXG4gICAgXCJncmFudFwiLFxuICAgIFwiZ3JhcGVcIixcbiAgICBcImdyYXNzXCIsXG4gICAgXCJncmF2aXR5XCIsXG4gICAgXCJncmVhdFwiLFxuICAgIFwiZ3JlZW5cIixcbiAgICBcImdyaWRcIixcbiAgICBcImdyaWVmXCIsXG4gICAgXCJncml0XCIsXG4gICAgXCJncm9jZXJ5XCIsXG4gICAgXCJncm91cFwiLFxuICAgIFwiZ3Jvd1wiLFxuICAgIFwiZ3J1bnRcIixcbiAgICBcImd1YXJkXCIsXG4gICAgXCJndWVzc1wiLFxuICAgIFwiZ3VpZGVcIixcbiAgICBcImd1aWx0XCIsXG4gICAgXCJndWl0YXJcIixcbiAgICBcImd1blwiLFxuICAgIFwiZ3ltXCIsXG4gICAgXCJoYWJpdFwiLFxuICAgIFwiaGFpclwiLFxuICAgIFwiaGFsZlwiLFxuICAgIFwiaGFtbWVyXCIsXG4gICAgXCJoYW1zdGVyXCIsXG4gICAgXCJoYW5kXCIsXG4gICAgXCJoYXBweVwiLFxuICAgIFwiaGFyYm9yXCIsXG4gICAgXCJoYXJkXCIsXG4gICAgXCJoYXJzaFwiLFxuICAgIFwiaGFydmVzdFwiLFxuICAgIFwiaGF0XCIsXG4gICAgXCJoYXZlXCIsXG4gICAgXCJoYXdrXCIsXG4gICAgXCJoYXphcmRcIixcbiAgICBcImhlYWRcIixcbiAgICBcImhlYWx0aFwiLFxuICAgIFwiaGVhcnRcIixcbiAgICBcImhlYXZ5XCIsXG4gICAgXCJoZWRnZWhvZ1wiLFxuICAgIFwiaGVpZ2h0XCIsXG4gICAgXCJoZWxsb1wiLFxuICAgIFwiaGVsbWV0XCIsXG4gICAgXCJoZWxwXCIsXG4gICAgXCJoZW5cIixcbiAgICBcImhlcm9cIixcbiAgICBcImhpZGRlblwiLFxuICAgIFwiaGlnaFwiLFxuICAgIFwiaGlsbFwiLFxuICAgIFwiaGludFwiLFxuICAgIFwiaGlwXCIsXG4gICAgXCJoaXJlXCIsXG4gICAgXCJoaXN0b3J5XCIsXG4gICAgXCJob2JieVwiLFxuICAgIFwiaG9ja2V5XCIsXG4gICAgXCJob2xkXCIsXG4gICAgXCJob2xlXCIsXG4gICAgXCJob2xpZGF5XCIsXG4gICAgXCJob2xsb3dcIixcbiAgICBcImhvbWVcIixcbiAgICBcImhvbmV5XCIsXG4gICAgXCJob29kXCIsXG4gICAgXCJob3BlXCIsXG4gICAgXCJob3JuXCIsXG4gICAgXCJob3Jyb3JcIixcbiAgICBcImhvcnNlXCIsXG4gICAgXCJob3NwaXRhbFwiLFxuICAgIFwiaG9zdFwiLFxuICAgIFwiaG90ZWxcIixcbiAgICBcImhvdXJcIixcbiAgICBcImhvdmVyXCIsXG4gICAgXCJodWJcIixcbiAgICBcImh1Z2VcIixcbiAgICBcImh1bWFuXCIsXG4gICAgXCJodW1ibGVcIixcbiAgICBcImh1bW9yXCIsXG4gICAgXCJodW5kcmVkXCIsXG4gICAgXCJodW5ncnlcIixcbiAgICBcImh1bnRcIixcbiAgICBcImh1cmRsZVwiLFxuICAgIFwiaHVycnlcIixcbiAgICBcImh1cnRcIixcbiAgICBcImh1c2JhbmRcIixcbiAgICBcImh5YnJpZFwiLFxuICAgIFwiaWNlXCIsXG4gICAgXCJpY29uXCIsXG4gICAgXCJpZGVhXCIsXG4gICAgXCJpZGVudGlmeVwiLFxuICAgIFwiaWRsZVwiLFxuICAgIFwiaWdub3JlXCIsXG4gICAgXCJpbGxcIixcbiAgICBcImlsbGVnYWxcIixcbiAgICBcImlsbG5lc3NcIixcbiAgICBcImltYWdlXCIsXG4gICAgXCJpbWl0YXRlXCIsXG4gICAgXCJpbW1lbnNlXCIsXG4gICAgXCJpbW11bmVcIixcbiAgICBcImltcGFjdFwiLFxuICAgIFwiaW1wb3NlXCIsXG4gICAgXCJpbXByb3ZlXCIsXG4gICAgXCJpbXB1bHNlXCIsXG4gICAgXCJpbmNoXCIsXG4gICAgXCJpbmNsdWRlXCIsXG4gICAgXCJpbmNvbWVcIixcbiAgICBcImluY3JlYXNlXCIsXG4gICAgXCJpbmRleFwiLFxuICAgIFwiaW5kaWNhdGVcIixcbiAgICBcImluZG9vclwiLFxuICAgIFwiaW5kdXN0cnlcIixcbiAgICBcImluZmFudFwiLFxuICAgIFwiaW5mbGljdFwiLFxuICAgIFwiaW5mb3JtXCIsXG4gICAgXCJpbmhhbGVcIixcbiAgICBcImluaGVyaXRcIixcbiAgICBcImluaXRpYWxcIixcbiAgICBcImluamVjdFwiLFxuICAgIFwiaW5qdXJ5XCIsXG4gICAgXCJpbm1hdGVcIixcbiAgICBcImlubmVyXCIsXG4gICAgXCJpbm5vY2VudFwiLFxuICAgIFwiaW5wdXRcIixcbiAgICBcImlucXVpcnlcIixcbiAgICBcImluc2FuZVwiLFxuICAgIFwiaW5zZWN0XCIsXG4gICAgXCJpbnNpZGVcIixcbiAgICBcImluc3BpcmVcIixcbiAgICBcImluc3RhbGxcIixcbiAgICBcImludGFjdFwiLFxuICAgIFwiaW50ZXJlc3RcIixcbiAgICBcImludG9cIixcbiAgICBcImludmVzdFwiLFxuICAgIFwiaW52aXRlXCIsXG4gICAgXCJpbnZvbHZlXCIsXG4gICAgXCJpcm9uXCIsXG4gICAgXCJpc2xhbmRcIixcbiAgICBcImlzb2xhdGVcIixcbiAgICBcImlzc3VlXCIsXG4gICAgXCJpdGVtXCIsXG4gICAgXCJpdm9yeVwiLFxuICAgIFwiamFja2V0XCIsXG4gICAgXCJqYWd1YXJcIixcbiAgICBcImphclwiLFxuICAgIFwiamF6elwiLFxuICAgIFwiamVhbG91c1wiLFxuICAgIFwiamVhbnNcIixcbiAgICBcImplbGx5XCIsXG4gICAgXCJqZXdlbFwiLFxuICAgIFwiam9iXCIsXG4gICAgXCJqb2luXCIsXG4gICAgXCJqb2tlXCIsXG4gICAgXCJqb3VybmV5XCIsXG4gICAgXCJqb3lcIixcbiAgICBcImp1ZGdlXCIsXG4gICAgXCJqdWljZVwiLFxuICAgIFwianVtcFwiLFxuICAgIFwianVuZ2xlXCIsXG4gICAgXCJqdW5pb3JcIixcbiAgICBcImp1bmtcIixcbiAgICBcImp1c3RcIixcbiAgICBcImthbmdhcm9vXCIsXG4gICAgXCJrZWVuXCIsXG4gICAgXCJrZWVwXCIsXG4gICAgXCJrZXRjaHVwXCIsXG4gICAgXCJrZXlcIixcbiAgICBcImtpY2tcIixcbiAgICBcImtpZFwiLFxuICAgIFwia2lkbmV5XCIsXG4gICAgXCJraW5kXCIsXG4gICAgXCJraW5nZG9tXCIsXG4gICAgXCJraXNzXCIsXG4gICAgXCJraXRcIixcbiAgICBcImtpdGNoZW5cIixcbiAgICBcImtpdGVcIixcbiAgICBcImtpdHRlblwiLFxuICAgIFwia2l3aVwiLFxuICAgIFwia25lZVwiLFxuICAgIFwia25pZmVcIixcbiAgICBcImtub2NrXCIsXG4gICAgXCJrbm93XCIsXG4gICAgXCJsYWJcIixcbiAgICBcImxhYmVsXCIsXG4gICAgXCJsYWJvclwiLFxuICAgIFwibGFkZGVyXCIsXG4gICAgXCJsYWR5XCIsXG4gICAgXCJsYWtlXCIsXG4gICAgXCJsYW1wXCIsXG4gICAgXCJsYW5ndWFnZVwiLFxuICAgIFwibGFwdG9wXCIsXG4gICAgXCJsYXJnZVwiLFxuICAgIFwibGF0ZXJcIixcbiAgICBcImxhdGluXCIsXG4gICAgXCJsYXVnaFwiLFxuICAgIFwibGF1bmRyeVwiLFxuICAgIFwibGF2YVwiLFxuICAgIFwibGF3XCIsXG4gICAgXCJsYXduXCIsXG4gICAgXCJsYXdzdWl0XCIsXG4gICAgXCJsYXllclwiLFxuICAgIFwibGF6eVwiLFxuICAgIFwibGVhZGVyXCIsXG4gICAgXCJsZWFmXCIsXG4gICAgXCJsZWFyblwiLFxuICAgIFwibGVhdmVcIixcbiAgICBcImxlY3R1cmVcIixcbiAgICBcImxlZnRcIixcbiAgICBcImxlZ1wiLFxuICAgIFwibGVnYWxcIixcbiAgICBcImxlZ2VuZFwiLFxuICAgIFwibGVpc3VyZVwiLFxuICAgIFwibGVtb25cIixcbiAgICBcImxlbmRcIixcbiAgICBcImxlbmd0aFwiLFxuICAgIFwibGVuc1wiLFxuICAgIFwibGVvcGFyZFwiLFxuICAgIFwibGVzc29uXCIsXG4gICAgXCJsZXR0ZXJcIixcbiAgICBcImxldmVsXCIsXG4gICAgXCJsaWFyXCIsXG4gICAgXCJsaWJlcnR5XCIsXG4gICAgXCJsaWJyYXJ5XCIsXG4gICAgXCJsaWNlbnNlXCIsXG4gICAgXCJsaWZlXCIsXG4gICAgXCJsaWZ0XCIsXG4gICAgXCJsaWdodFwiLFxuICAgIFwibGlrZVwiLFxuICAgIFwibGltYlwiLFxuICAgIFwibGltaXRcIixcbiAgICBcImxpbmtcIixcbiAgICBcImxpb25cIixcbiAgICBcImxpcXVpZFwiLFxuICAgIFwibGlzdFwiLFxuICAgIFwibGl0dGxlXCIsXG4gICAgXCJsaXZlXCIsXG4gICAgXCJsaXphcmRcIixcbiAgICBcImxvYWRcIixcbiAgICBcImxvYW5cIixcbiAgICBcImxvYnN0ZXJcIixcbiAgICBcImxvY2FsXCIsXG4gICAgXCJsb2NrXCIsXG4gICAgXCJsb2dpY1wiLFxuICAgIFwibG9uZWx5XCIsXG4gICAgXCJsb25nXCIsXG4gICAgXCJsb29wXCIsXG4gICAgXCJsb3R0ZXJ5XCIsXG4gICAgXCJsb3VkXCIsXG4gICAgXCJsb3VuZ2VcIixcbiAgICBcImxvdmVcIixcbiAgICBcImxveWFsXCIsXG4gICAgXCJsdWNreVwiLFxuICAgIFwibHVnZ2FnZVwiLFxuICAgIFwibHVtYmVyXCIsXG4gICAgXCJsdW5hclwiLFxuICAgIFwibHVuY2hcIixcbiAgICBcImx1eHVyeVwiLFxuICAgIFwibHlyaWNzXCIsXG4gICAgXCJtYWNoaW5lXCIsXG4gICAgXCJtYWRcIixcbiAgICBcIm1hZ2ljXCIsXG4gICAgXCJtYWduZXRcIixcbiAgICBcIm1haWRcIixcbiAgICBcIm1haWxcIixcbiAgICBcIm1haW5cIixcbiAgICBcIm1ham9yXCIsXG4gICAgXCJtYWtlXCIsXG4gICAgXCJtYW1tYWxcIixcbiAgICBcIm1hblwiLFxuICAgIFwibWFuYWdlXCIsXG4gICAgXCJtYW5kYXRlXCIsXG4gICAgXCJtYW5nb1wiLFxuICAgIFwibWFuc2lvblwiLFxuICAgIFwibWFudWFsXCIsXG4gICAgXCJtYXBsZVwiLFxuICAgIFwibWFyYmxlXCIsXG4gICAgXCJtYXJjaFwiLFxuICAgIFwibWFyZ2luXCIsXG4gICAgXCJtYXJpbmVcIixcbiAgICBcIm1hcmtldFwiLFxuICAgIFwibWFycmlhZ2VcIixcbiAgICBcIm1hc2tcIixcbiAgICBcIm1hc3NcIixcbiAgICBcIm1hc3RlclwiLFxuICAgIFwibWF0Y2hcIixcbiAgICBcIm1hdGVyaWFsXCIsXG4gICAgXCJtYXRoXCIsXG4gICAgXCJtYXRyaXhcIixcbiAgICBcIm1hdHRlclwiLFxuICAgIFwibWF4aW11bVwiLFxuICAgIFwibWF6ZVwiLFxuICAgIFwibWVhZG93XCIsXG4gICAgXCJtZWFuXCIsXG4gICAgXCJtZWFzdXJlXCIsXG4gICAgXCJtZWF0XCIsXG4gICAgXCJtZWNoYW5pY1wiLFxuICAgIFwibWVkYWxcIixcbiAgICBcIm1lZGlhXCIsXG4gICAgXCJtZWxvZHlcIixcbiAgICBcIm1lbHRcIixcbiAgICBcIm1lbWJlclwiLFxuICAgIFwibWVtb3J5XCIsXG4gICAgXCJtZW50aW9uXCIsXG4gICAgXCJtZW51XCIsXG4gICAgXCJtZXJjeVwiLFxuICAgIFwibWVyZ2VcIixcbiAgICBcIm1lcml0XCIsXG4gICAgXCJtZXJyeVwiLFxuICAgIFwibWVzaFwiLFxuICAgIFwibWVzc2FnZVwiLFxuICAgIFwibWV0YWxcIixcbiAgICBcIm1ldGhvZFwiLFxuICAgIFwibWlkZGxlXCIsXG4gICAgXCJtaWRuaWdodFwiLFxuICAgIFwibWlsa1wiLFxuICAgIFwibWlsbGlvblwiLFxuICAgIFwibWltaWNcIixcbiAgICBcIm1pbmRcIixcbiAgICBcIm1pbmltdW1cIixcbiAgICBcIm1pbm9yXCIsXG4gICAgXCJtaW51dGVcIixcbiAgICBcIm1pcmFjbGVcIixcbiAgICBcIm1pcnJvclwiLFxuICAgIFwibWlzZXJ5XCIsXG4gICAgXCJtaXNzXCIsXG4gICAgXCJtaXN0YWtlXCIsXG4gICAgXCJtaXhcIixcbiAgICBcIm1peGVkXCIsXG4gICAgXCJtaXh0dXJlXCIsXG4gICAgXCJtb2JpbGVcIixcbiAgICBcIm1vZGVsXCIsXG4gICAgXCJtb2RpZnlcIixcbiAgICBcIm1vbVwiLFxuICAgIFwibW9tZW50XCIsXG4gICAgXCJtb25pdG9yXCIsXG4gICAgXCJtb25rZXlcIixcbiAgICBcIm1vbnN0ZXJcIixcbiAgICBcIm1vbnRoXCIsXG4gICAgXCJtb29uXCIsXG4gICAgXCJtb3JhbFwiLFxuICAgIFwibW9yZVwiLFxuICAgIFwibW9ybmluZ1wiLFxuICAgIFwibW9zcXVpdG9cIixcbiAgICBcIm1vdGhlclwiLFxuICAgIFwibW90aW9uXCIsXG4gICAgXCJtb3RvclwiLFxuICAgIFwibW91bnRhaW5cIixcbiAgICBcIm1vdXNlXCIsXG4gICAgXCJtb3ZlXCIsXG4gICAgXCJtb3ZpZVwiLFxuICAgIFwibXVjaFwiLFxuICAgIFwibXVmZmluXCIsXG4gICAgXCJtdWxlXCIsXG4gICAgXCJtdWx0aXBseVwiLFxuICAgIFwibXVzY2xlXCIsXG4gICAgXCJtdXNldW1cIixcbiAgICBcIm11c2hyb29tXCIsXG4gICAgXCJtdXNpY1wiLFxuICAgIFwibXVzdFwiLFxuICAgIFwibXV0dWFsXCIsXG4gICAgXCJteXNlbGZcIixcbiAgICBcIm15c3RlcnlcIixcbiAgICBcIm15dGhcIixcbiAgICBcIm5haXZlXCIsXG4gICAgXCJuYW1lXCIsXG4gICAgXCJuYXBraW5cIixcbiAgICBcIm5hcnJvd1wiLFxuICAgIFwibmFzdHlcIixcbiAgICBcIm5hdGlvblwiLFxuICAgIFwibmF0dXJlXCIsXG4gICAgXCJuZWFyXCIsXG4gICAgXCJuZWNrXCIsXG4gICAgXCJuZWVkXCIsXG4gICAgXCJuZWdhdGl2ZVwiLFxuICAgIFwibmVnbGVjdFwiLFxuICAgIFwibmVpdGhlclwiLFxuICAgIFwibmVwaGV3XCIsXG4gICAgXCJuZXJ2ZVwiLFxuICAgIFwibmVzdFwiLFxuICAgIFwibmV0XCIsXG4gICAgXCJuZXR3b3JrXCIsXG4gICAgXCJuZXV0cmFsXCIsXG4gICAgXCJuZXZlclwiLFxuICAgIFwibmV3c1wiLFxuICAgIFwibmV4dFwiLFxuICAgIFwibmljZVwiLFxuICAgIFwibmlnaHRcIixcbiAgICBcIm5vYmxlXCIsXG4gICAgXCJub2lzZVwiLFxuICAgIFwibm9taW5lZVwiLFxuICAgIFwibm9vZGxlXCIsXG4gICAgXCJub3JtYWxcIixcbiAgICBcIm5vcnRoXCIsXG4gICAgXCJub3NlXCIsXG4gICAgXCJub3RhYmxlXCIsXG4gICAgXCJub3RlXCIsXG4gICAgXCJub3RoaW5nXCIsXG4gICAgXCJub3RpY2VcIixcbiAgICBcIm5vdmVsXCIsXG4gICAgXCJub3dcIixcbiAgICBcIm51Y2xlYXJcIixcbiAgICBcIm51bWJlclwiLFxuICAgIFwibnVyc2VcIixcbiAgICBcIm51dFwiLFxuICAgIFwib2FrXCIsXG4gICAgXCJvYmV5XCIsXG4gICAgXCJvYmplY3RcIixcbiAgICBcIm9ibGlnZVwiLFxuICAgIFwib2JzY3VyZVwiLFxuICAgIFwib2JzZXJ2ZVwiLFxuICAgIFwib2J0YWluXCIsXG4gICAgXCJvYnZpb3VzXCIsXG4gICAgXCJvY2N1clwiLFxuICAgIFwib2NlYW5cIixcbiAgICBcIm9jdG9iZXJcIixcbiAgICBcIm9kb3JcIixcbiAgICBcIm9mZlwiLFxuICAgIFwib2ZmZXJcIixcbiAgICBcIm9mZmljZVwiLFxuICAgIFwib2Z0ZW5cIixcbiAgICBcIm9pbFwiLFxuICAgIFwib2theVwiLFxuICAgIFwib2xkXCIsXG4gICAgXCJvbGl2ZVwiLFxuICAgIFwib2x5bXBpY1wiLFxuICAgIFwib21pdFwiLFxuICAgIFwib25jZVwiLFxuICAgIFwib25lXCIsXG4gICAgXCJvbmlvblwiLFxuICAgIFwib25saW5lXCIsXG4gICAgXCJvbmx5XCIsXG4gICAgXCJvcGVuXCIsXG4gICAgXCJvcGVyYVwiLFxuICAgIFwib3BpbmlvblwiLFxuICAgIFwib3Bwb3NlXCIsXG4gICAgXCJvcHRpb25cIixcbiAgICBcIm9yYW5nZVwiLFxuICAgIFwib3JiaXRcIixcbiAgICBcIm9yY2hhcmRcIixcbiAgICBcIm9yZGVyXCIsXG4gICAgXCJvcmRpbmFyeVwiLFxuICAgIFwib3JnYW5cIixcbiAgICBcIm9yaWVudFwiLFxuICAgIFwib3JpZ2luYWxcIixcbiAgICBcIm9ycGhhblwiLFxuICAgIFwib3N0cmljaFwiLFxuICAgIFwib3RoZXJcIixcbiAgICBcIm91dGRvb3JcIixcbiAgICBcIm91dGVyXCIsXG4gICAgXCJvdXRwdXRcIixcbiAgICBcIm91dHNpZGVcIixcbiAgICBcIm92YWxcIixcbiAgICBcIm92ZW5cIixcbiAgICBcIm92ZXJcIixcbiAgICBcIm93blwiLFxuICAgIFwib3duZXJcIixcbiAgICBcIm94eWdlblwiLFxuICAgIFwib3lzdGVyXCIsXG4gICAgXCJvem9uZVwiLFxuICAgIFwicGFjdFwiLFxuICAgIFwicGFkZGxlXCIsXG4gICAgXCJwYWdlXCIsXG4gICAgXCJwYWlyXCIsXG4gICAgXCJwYWxhY2VcIixcbiAgICBcInBhbG1cIixcbiAgICBcInBhbmRhXCIsXG4gICAgXCJwYW5lbFwiLFxuICAgIFwicGFuaWNcIixcbiAgICBcInBhbnRoZXJcIixcbiAgICBcInBhcGVyXCIsXG4gICAgXCJwYXJhZGVcIixcbiAgICBcInBhcmVudFwiLFxuICAgIFwicGFya1wiLFxuICAgIFwicGFycm90XCIsXG4gICAgXCJwYXJ0eVwiLFxuICAgIFwicGFzc1wiLFxuICAgIFwicGF0Y2hcIixcbiAgICBcInBhdGhcIixcbiAgICBcInBhdGllbnRcIixcbiAgICBcInBhdHJvbFwiLFxuICAgIFwicGF0dGVyblwiLFxuICAgIFwicGF1c2VcIixcbiAgICBcInBhdmVcIixcbiAgICBcInBheW1lbnRcIixcbiAgICBcInBlYWNlXCIsXG4gICAgXCJwZWFudXRcIixcbiAgICBcInBlYXJcIixcbiAgICBcInBlYXNhbnRcIixcbiAgICBcInBlbGljYW5cIixcbiAgICBcInBlblwiLFxuICAgIFwicGVuYWx0eVwiLFxuICAgIFwicGVuY2lsXCIsXG4gICAgXCJwZW9wbGVcIixcbiAgICBcInBlcHBlclwiLFxuICAgIFwicGVyZmVjdFwiLFxuICAgIFwicGVybWl0XCIsXG4gICAgXCJwZXJzb25cIixcbiAgICBcInBldFwiLFxuICAgIFwicGhvbmVcIixcbiAgICBcInBob3RvXCIsXG4gICAgXCJwaHJhc2VcIixcbiAgICBcInBoeXNpY2FsXCIsXG4gICAgXCJwaWFub1wiLFxuICAgIFwicGljbmljXCIsXG4gICAgXCJwaWN0dXJlXCIsXG4gICAgXCJwaWVjZVwiLFxuICAgIFwicGlnXCIsXG4gICAgXCJwaWdlb25cIixcbiAgICBcInBpbGxcIixcbiAgICBcInBpbG90XCIsXG4gICAgXCJwaW5rXCIsXG4gICAgXCJwaW9uZWVyXCIsXG4gICAgXCJwaXBlXCIsXG4gICAgXCJwaXN0b2xcIixcbiAgICBcInBpdGNoXCIsXG4gICAgXCJwaXp6YVwiLFxuICAgIFwicGxhY2VcIixcbiAgICBcInBsYW5ldFwiLFxuICAgIFwicGxhc3RpY1wiLFxuICAgIFwicGxhdGVcIixcbiAgICBcInBsYXlcIixcbiAgICBcInBsZWFzZVwiLFxuICAgIFwicGxlZGdlXCIsXG4gICAgXCJwbHVja1wiLFxuICAgIFwicGx1Z1wiLFxuICAgIFwicGx1bmdlXCIsXG4gICAgXCJwb2VtXCIsXG4gICAgXCJwb2V0XCIsXG4gICAgXCJwb2ludFwiLFxuICAgIFwicG9sYXJcIixcbiAgICBcInBvbGVcIixcbiAgICBcInBvbGljZVwiLFxuICAgIFwicG9uZFwiLFxuICAgIFwicG9ueVwiLFxuICAgIFwicG9vbFwiLFxuICAgIFwicG9wdWxhclwiLFxuICAgIFwicG9ydGlvblwiLFxuICAgIFwicG9zaXRpb25cIixcbiAgICBcInBvc3NpYmxlXCIsXG4gICAgXCJwb3N0XCIsXG4gICAgXCJwb3RhdG9cIixcbiAgICBcInBvdHRlcnlcIixcbiAgICBcInBvdmVydHlcIixcbiAgICBcInBvd2RlclwiLFxuICAgIFwicG93ZXJcIixcbiAgICBcInByYWN0aWNlXCIsXG4gICAgXCJwcmFpc2VcIixcbiAgICBcInByZWRpY3RcIixcbiAgICBcInByZWZlclwiLFxuICAgIFwicHJlcGFyZVwiLFxuICAgIFwicHJlc2VudFwiLFxuICAgIFwicHJldHR5XCIsXG4gICAgXCJwcmV2ZW50XCIsXG4gICAgXCJwcmljZVwiLFxuICAgIFwicHJpZGVcIixcbiAgICBcInByaW1hcnlcIixcbiAgICBcInByaW50XCIsXG4gICAgXCJwcmlvcml0eVwiLFxuICAgIFwicHJpc29uXCIsXG4gICAgXCJwcml2YXRlXCIsXG4gICAgXCJwcml6ZVwiLFxuICAgIFwicHJvYmxlbVwiLFxuICAgIFwicHJvY2Vzc1wiLFxuICAgIFwicHJvZHVjZVwiLFxuICAgIFwicHJvZml0XCIsXG4gICAgXCJwcm9ncmFtXCIsXG4gICAgXCJwcm9qZWN0XCIsXG4gICAgXCJwcm9tb3RlXCIsXG4gICAgXCJwcm9vZlwiLFxuICAgIFwicHJvcGVydHlcIixcbiAgICBcInByb3NwZXJcIixcbiAgICBcInByb3RlY3RcIixcbiAgICBcInByb3VkXCIsXG4gICAgXCJwcm92aWRlXCIsXG4gICAgXCJwdWJsaWNcIixcbiAgICBcInB1ZGRpbmdcIixcbiAgICBcInB1bGxcIixcbiAgICBcInB1bHBcIixcbiAgICBcInB1bHNlXCIsXG4gICAgXCJwdW1wa2luXCIsXG4gICAgXCJwdW5jaFwiLFxuICAgIFwicHVwaWxcIixcbiAgICBcInB1cHB5XCIsXG4gICAgXCJwdXJjaGFzZVwiLFxuICAgIFwicHVyaXR5XCIsXG4gICAgXCJwdXJwb3NlXCIsXG4gICAgXCJwdXJzZVwiLFxuICAgIFwicHVzaFwiLFxuICAgIFwicHV0XCIsXG4gICAgXCJwdXp6bGVcIixcbiAgICBcInB5cmFtaWRcIixcbiAgICBcInF1YWxpdHlcIixcbiAgICBcInF1YW50dW1cIixcbiAgICBcInF1YXJ0ZXJcIixcbiAgICBcInF1ZXN0aW9uXCIsXG4gICAgXCJxdWlja1wiLFxuICAgIFwicXVpdFwiLFxuICAgIFwicXVpelwiLFxuICAgIFwicXVvdGVcIixcbiAgICBcInJhYmJpdFwiLFxuICAgIFwicmFjY29vblwiLFxuICAgIFwicmFjZVwiLFxuICAgIFwicmFja1wiLFxuICAgIFwicmFkYXJcIixcbiAgICBcInJhZGlvXCIsXG4gICAgXCJyYWlsXCIsXG4gICAgXCJyYWluXCIsXG4gICAgXCJyYWlzZVwiLFxuICAgIFwicmFsbHlcIixcbiAgICBcInJhbXBcIixcbiAgICBcInJhbmNoXCIsXG4gICAgXCJyYW5kb21cIixcbiAgICBcInJhbmdlXCIsXG4gICAgXCJyYXBpZFwiLFxuICAgIFwicmFyZVwiLFxuICAgIFwicmF0ZVwiLFxuICAgIFwicmF0aGVyXCIsXG4gICAgXCJyYXZlblwiLFxuICAgIFwicmF3XCIsXG4gICAgXCJyYXpvclwiLFxuICAgIFwicmVhZHlcIixcbiAgICBcInJlYWxcIixcbiAgICBcInJlYXNvblwiLFxuICAgIFwicmViZWxcIixcbiAgICBcInJlYnVpbGRcIixcbiAgICBcInJlY2FsbFwiLFxuICAgIFwicmVjZWl2ZVwiLFxuICAgIFwicmVjaXBlXCIsXG4gICAgXCJyZWNvcmRcIixcbiAgICBcInJlY3ljbGVcIixcbiAgICBcInJlZHVjZVwiLFxuICAgIFwicmVmbGVjdFwiLFxuICAgIFwicmVmb3JtXCIsXG4gICAgXCJyZWZ1c2VcIixcbiAgICBcInJlZ2lvblwiLFxuICAgIFwicmVncmV0XCIsXG4gICAgXCJyZWd1bGFyXCIsXG4gICAgXCJyZWplY3RcIixcbiAgICBcInJlbGF4XCIsXG4gICAgXCJyZWxlYXNlXCIsXG4gICAgXCJyZWxpZWZcIixcbiAgICBcInJlbHlcIixcbiAgICBcInJlbWFpblwiLFxuICAgIFwicmVtZW1iZXJcIixcbiAgICBcInJlbWluZFwiLFxuICAgIFwicmVtb3ZlXCIsXG4gICAgXCJyZW5kZXJcIixcbiAgICBcInJlbmV3XCIsXG4gICAgXCJyZW50XCIsXG4gICAgXCJyZW9wZW5cIixcbiAgICBcInJlcGFpclwiLFxuICAgIFwicmVwZWF0XCIsXG4gICAgXCJyZXBsYWNlXCIsXG4gICAgXCJyZXBvcnRcIixcbiAgICBcInJlcXVpcmVcIixcbiAgICBcInJlc2N1ZVwiLFxuICAgIFwicmVzZW1ibGVcIixcbiAgICBcInJlc2lzdFwiLFxuICAgIFwicmVzb3VyY2VcIixcbiAgICBcInJlc3BvbnNlXCIsXG4gICAgXCJyZXN1bHRcIixcbiAgICBcInJldGlyZVwiLFxuICAgIFwicmV0cmVhdFwiLFxuICAgIFwicmV0dXJuXCIsXG4gICAgXCJyZXVuaW9uXCIsXG4gICAgXCJyZXZlYWxcIixcbiAgICBcInJldmlld1wiLFxuICAgIFwicmV3YXJkXCIsXG4gICAgXCJyaHl0aG1cIixcbiAgICBcInJpYlwiLFxuICAgIFwicmliYm9uXCIsXG4gICAgXCJyaWNlXCIsXG4gICAgXCJyaWNoXCIsXG4gICAgXCJyaWRlXCIsXG4gICAgXCJyaWRnZVwiLFxuICAgIFwicmlmbGVcIixcbiAgICBcInJpZ2h0XCIsXG4gICAgXCJyaWdpZFwiLFxuICAgIFwicmluZ1wiLFxuICAgIFwicmlvdFwiLFxuICAgIFwicmlwcGxlXCIsXG4gICAgXCJyaXNrXCIsXG4gICAgXCJyaXR1YWxcIixcbiAgICBcInJpdmFsXCIsXG4gICAgXCJyaXZlclwiLFxuICAgIFwicm9hZFwiLFxuICAgIFwicm9hc3RcIixcbiAgICBcInJvYm90XCIsXG4gICAgXCJyb2J1c3RcIixcbiAgICBcInJvY2tldFwiLFxuICAgIFwicm9tYW5jZVwiLFxuICAgIFwicm9vZlwiLFxuICAgIFwicm9va2llXCIsXG4gICAgXCJyb29tXCIsXG4gICAgXCJyb3NlXCIsXG4gICAgXCJyb3RhdGVcIixcbiAgICBcInJvdWdoXCIsXG4gICAgXCJyb3VuZFwiLFxuICAgIFwicm91dGVcIixcbiAgICBcInJveWFsXCIsXG4gICAgXCJydWJiZXJcIixcbiAgICBcInJ1ZGVcIixcbiAgICBcInJ1Z1wiLFxuICAgIFwicnVsZVwiLFxuICAgIFwicnVuXCIsXG4gICAgXCJydW53YXlcIixcbiAgICBcInJ1cmFsXCIsXG4gICAgXCJzYWRcIixcbiAgICBcInNhZGRsZVwiLFxuICAgIFwic2FkbmVzc1wiLFxuICAgIFwic2FmZVwiLFxuICAgIFwic2FpbFwiLFxuICAgIFwic2FsYWRcIixcbiAgICBcInNhbG1vblwiLFxuICAgIFwic2Fsb25cIixcbiAgICBcInNhbHRcIixcbiAgICBcInNhbHV0ZVwiLFxuICAgIFwic2FtZVwiLFxuICAgIFwic2FtcGxlXCIsXG4gICAgXCJzYW5kXCIsXG4gICAgXCJzYXRpc2Z5XCIsXG4gICAgXCJzYXRvc2hpXCIsXG4gICAgXCJzYXVjZVwiLFxuICAgIFwic2F1c2FnZVwiLFxuICAgIFwic2F2ZVwiLFxuICAgIFwic2F5XCIsXG4gICAgXCJzY2FsZVwiLFxuICAgIFwic2NhblwiLFxuICAgIFwic2NhcmVcIixcbiAgICBcInNjYXR0ZXJcIixcbiAgICBcInNjZW5lXCIsXG4gICAgXCJzY2hlbWVcIixcbiAgICBcInNjaG9vbFwiLFxuICAgIFwic2NpZW5jZVwiLFxuICAgIFwic2Npc3NvcnNcIixcbiAgICBcInNjb3JwaW9uXCIsXG4gICAgXCJzY291dFwiLFxuICAgIFwic2NyYXBcIixcbiAgICBcInNjcmVlblwiLFxuICAgIFwic2NyaXB0XCIsXG4gICAgXCJzY3J1YlwiLFxuICAgIFwic2VhXCIsXG4gICAgXCJzZWFyY2hcIixcbiAgICBcInNlYXNvblwiLFxuICAgIFwic2VhdFwiLFxuICAgIFwic2Vjb25kXCIsXG4gICAgXCJzZWNyZXRcIixcbiAgICBcInNlY3Rpb25cIixcbiAgICBcInNlY3VyaXR5XCIsXG4gICAgXCJzZWVkXCIsXG4gICAgXCJzZWVrXCIsXG4gICAgXCJzZWdtZW50XCIsXG4gICAgXCJzZWxlY3RcIixcbiAgICBcInNlbGxcIixcbiAgICBcInNlbWluYXJcIixcbiAgICBcInNlbmlvclwiLFxuICAgIFwic2Vuc2VcIixcbiAgICBcInNlbnRlbmNlXCIsXG4gICAgXCJzZXJpZXNcIixcbiAgICBcInNlcnZpY2VcIixcbiAgICBcInNlc3Npb25cIixcbiAgICBcInNldHRsZVwiLFxuICAgIFwic2V0dXBcIixcbiAgICBcInNldmVuXCIsXG4gICAgXCJzaGFkb3dcIixcbiAgICBcInNoYWZ0XCIsXG4gICAgXCJzaGFsbG93XCIsXG4gICAgXCJzaGFyZVwiLFxuICAgIFwic2hlZFwiLFxuICAgIFwic2hlbGxcIixcbiAgICBcInNoZXJpZmZcIixcbiAgICBcInNoaWVsZFwiLFxuICAgIFwic2hpZnRcIixcbiAgICBcInNoaW5lXCIsXG4gICAgXCJzaGlwXCIsXG4gICAgXCJzaGl2ZXJcIixcbiAgICBcInNob2NrXCIsXG4gICAgXCJzaG9lXCIsXG4gICAgXCJzaG9vdFwiLFxuICAgIFwic2hvcFwiLFxuICAgIFwic2hvcnRcIixcbiAgICBcInNob3VsZGVyXCIsXG4gICAgXCJzaG92ZVwiLFxuICAgIFwic2hyaW1wXCIsXG4gICAgXCJzaHJ1Z1wiLFxuICAgIFwic2h1ZmZsZVwiLFxuICAgIFwic2h5XCIsXG4gICAgXCJzaWJsaW5nXCIsXG4gICAgXCJzaWNrXCIsXG4gICAgXCJzaWRlXCIsXG4gICAgXCJzaWVnZVwiLFxuICAgIFwic2lnaHRcIixcbiAgICBcInNpZ25cIixcbiAgICBcInNpbGVudFwiLFxuICAgIFwic2lsa1wiLFxuICAgIFwic2lsbHlcIixcbiAgICBcInNpbHZlclwiLFxuICAgIFwic2ltaWxhclwiLFxuICAgIFwic2ltcGxlXCIsXG4gICAgXCJzaW5jZVwiLFxuICAgIFwic2luZ1wiLFxuICAgIFwic2lyZW5cIixcbiAgICBcInNpc3RlclwiLFxuICAgIFwic2l0dWF0ZVwiLFxuICAgIFwic2l4XCIsXG4gICAgXCJzaXplXCIsXG4gICAgXCJza2F0ZVwiLFxuICAgIFwic2tldGNoXCIsXG4gICAgXCJza2lcIixcbiAgICBcInNraWxsXCIsXG4gICAgXCJza2luXCIsXG4gICAgXCJza2lydFwiLFxuICAgIFwic2t1bGxcIixcbiAgICBcInNsYWJcIixcbiAgICBcInNsYW1cIixcbiAgICBcInNsZWVwXCIsXG4gICAgXCJzbGVuZGVyXCIsXG4gICAgXCJzbGljZVwiLFxuICAgIFwic2xpZGVcIixcbiAgICBcInNsaWdodFwiLFxuICAgIFwic2xpbVwiLFxuICAgIFwic2xvZ2FuXCIsXG4gICAgXCJzbG90XCIsXG4gICAgXCJzbG93XCIsXG4gICAgXCJzbHVzaFwiLFxuICAgIFwic21hbGxcIixcbiAgICBcInNtYXJ0XCIsXG4gICAgXCJzbWlsZVwiLFxuICAgIFwic21va2VcIixcbiAgICBcInNtb290aFwiLFxuICAgIFwic25hY2tcIixcbiAgICBcInNuYWtlXCIsXG4gICAgXCJzbmFwXCIsXG4gICAgXCJzbmlmZlwiLFxuICAgIFwic25vd1wiLFxuICAgIFwic29hcFwiLFxuICAgIFwic29jY2VyXCIsXG4gICAgXCJzb2NpYWxcIixcbiAgICBcInNvY2tcIixcbiAgICBcInNvZGFcIixcbiAgICBcInNvZnRcIixcbiAgICBcInNvbGFyXCIsXG4gICAgXCJzb2xkaWVyXCIsXG4gICAgXCJzb2xpZFwiLFxuICAgIFwic29sdXRpb25cIixcbiAgICBcInNvbHZlXCIsXG4gICAgXCJzb21lb25lXCIsXG4gICAgXCJzb25nXCIsXG4gICAgXCJzb29uXCIsXG4gICAgXCJzb3JyeVwiLFxuICAgIFwic29ydFwiLFxuICAgIFwic291bFwiLFxuICAgIFwic291bmRcIixcbiAgICBcInNvdXBcIixcbiAgICBcInNvdXJjZVwiLFxuICAgIFwic291dGhcIixcbiAgICBcInNwYWNlXCIsXG4gICAgXCJzcGFyZVwiLFxuICAgIFwic3BhdGlhbFwiLFxuICAgIFwic3Bhd25cIixcbiAgICBcInNwZWFrXCIsXG4gICAgXCJzcGVjaWFsXCIsXG4gICAgXCJzcGVlZFwiLFxuICAgIFwic3BlbGxcIixcbiAgICBcInNwZW5kXCIsXG4gICAgXCJzcGhlcmVcIixcbiAgICBcInNwaWNlXCIsXG4gICAgXCJzcGlkZXJcIixcbiAgICBcInNwaWtlXCIsXG4gICAgXCJzcGluXCIsXG4gICAgXCJzcGlyaXRcIixcbiAgICBcInNwbGl0XCIsXG4gICAgXCJzcG9pbFwiLFxuICAgIFwic3BvbnNvclwiLFxuICAgIFwic3Bvb25cIixcbiAgICBcInNwb3J0XCIsXG4gICAgXCJzcG90XCIsXG4gICAgXCJzcHJheVwiLFxuICAgIFwic3ByZWFkXCIsXG4gICAgXCJzcHJpbmdcIixcbiAgICBcInNweVwiLFxuICAgIFwic3F1YXJlXCIsXG4gICAgXCJzcXVlZXplXCIsXG4gICAgXCJzcXVpcnJlbFwiLFxuICAgIFwic3RhYmxlXCIsXG4gICAgXCJzdGFkaXVtXCIsXG4gICAgXCJzdGFmZlwiLFxuICAgIFwic3RhZ2VcIixcbiAgICBcInN0YWlyc1wiLFxuICAgIFwic3RhbXBcIixcbiAgICBcInN0YW5kXCIsXG4gICAgXCJzdGFydFwiLFxuICAgIFwic3RhdGVcIixcbiAgICBcInN0YXlcIixcbiAgICBcInN0ZWFrXCIsXG4gICAgXCJzdGVlbFwiLFxuICAgIFwic3RlbVwiLFxuICAgIFwic3RlcFwiLFxuICAgIFwic3RlcmVvXCIsXG4gICAgXCJzdGlja1wiLFxuICAgIFwic3RpbGxcIixcbiAgICBcInN0aW5nXCIsXG4gICAgXCJzdG9ja1wiLFxuICAgIFwic3RvbWFjaFwiLFxuICAgIFwic3RvbmVcIixcbiAgICBcInN0b29sXCIsXG4gICAgXCJzdG9yeVwiLFxuICAgIFwic3RvdmVcIixcbiAgICBcInN0cmF0ZWd5XCIsXG4gICAgXCJzdHJlZXRcIixcbiAgICBcInN0cmlrZVwiLFxuICAgIFwic3Ryb25nXCIsXG4gICAgXCJzdHJ1Z2dsZVwiLFxuICAgIFwic3R1ZGVudFwiLFxuICAgIFwic3R1ZmZcIixcbiAgICBcInN0dW1ibGVcIixcbiAgICBcInN0eWxlXCIsXG4gICAgXCJzdWJqZWN0XCIsXG4gICAgXCJzdWJtaXRcIixcbiAgICBcInN1YndheVwiLFxuICAgIFwic3VjY2Vzc1wiLFxuICAgIFwic3VjaFwiLFxuICAgIFwic3VkZGVuXCIsXG4gICAgXCJzdWZmZXJcIixcbiAgICBcInN1Z2FyXCIsXG4gICAgXCJzdWdnZXN0XCIsXG4gICAgXCJzdWl0XCIsXG4gICAgXCJzdW1tZXJcIixcbiAgICBcInN1blwiLFxuICAgIFwic3VubnlcIixcbiAgICBcInN1bnNldFwiLFxuICAgIFwic3VwZXJcIixcbiAgICBcInN1cHBseVwiLFxuICAgIFwic3VwcmVtZVwiLFxuICAgIFwic3VyZVwiLFxuICAgIFwic3VyZmFjZVwiLFxuICAgIFwic3VyZ2VcIixcbiAgICBcInN1cnByaXNlXCIsXG4gICAgXCJzdXJyb3VuZFwiLFxuICAgIFwic3VydmV5XCIsXG4gICAgXCJzdXNwZWN0XCIsXG4gICAgXCJzdXN0YWluXCIsXG4gICAgXCJzd2FsbG93XCIsXG4gICAgXCJzd2FtcFwiLFxuICAgIFwic3dhcFwiLFxuICAgIFwic3dhcm1cIixcbiAgICBcInN3ZWFyXCIsXG4gICAgXCJzd2VldFwiLFxuICAgIFwic3dpZnRcIixcbiAgICBcInN3aW1cIixcbiAgICBcInN3aW5nXCIsXG4gICAgXCJzd2l0Y2hcIixcbiAgICBcInN3b3JkXCIsXG4gICAgXCJzeW1ib2xcIixcbiAgICBcInN5bXB0b21cIixcbiAgICBcInN5cnVwXCIsXG4gICAgXCJzeXN0ZW1cIixcbiAgICBcInRhYmxlXCIsXG4gICAgXCJ0YWNrbGVcIixcbiAgICBcInRhZ1wiLFxuICAgIFwidGFpbFwiLFxuICAgIFwidGFsZW50XCIsXG4gICAgXCJ0YWxrXCIsXG4gICAgXCJ0YW5rXCIsXG4gICAgXCJ0YXBlXCIsXG4gICAgXCJ0YXJnZXRcIixcbiAgICBcInRhc2tcIixcbiAgICBcInRhc3RlXCIsXG4gICAgXCJ0YXR0b29cIixcbiAgICBcInRheGlcIixcbiAgICBcInRlYWNoXCIsXG4gICAgXCJ0ZWFtXCIsXG4gICAgXCJ0ZWxsXCIsXG4gICAgXCJ0ZW5cIixcbiAgICBcInRlbmFudFwiLFxuICAgIFwidGVubmlzXCIsXG4gICAgXCJ0ZW50XCIsXG4gICAgXCJ0ZXJtXCIsXG4gICAgXCJ0ZXN0XCIsXG4gICAgXCJ0ZXh0XCIsXG4gICAgXCJ0aGFua1wiLFxuICAgIFwidGhhdFwiLFxuICAgIFwidGhlbWVcIixcbiAgICBcInRoZW5cIixcbiAgICBcInRoZW9yeVwiLFxuICAgIFwidGhlcmVcIixcbiAgICBcInRoZXlcIixcbiAgICBcInRoaW5nXCIsXG4gICAgXCJ0aGlzXCIsXG4gICAgXCJ0aG91Z2h0XCIsXG4gICAgXCJ0aHJlZVwiLFxuICAgIFwidGhyaXZlXCIsXG4gICAgXCJ0aHJvd1wiLFxuICAgIFwidGh1bWJcIixcbiAgICBcInRodW5kZXJcIixcbiAgICBcInRpY2tldFwiLFxuICAgIFwidGlkZVwiLFxuICAgIFwidGlnZXJcIixcbiAgICBcInRpbHRcIixcbiAgICBcInRpbWJlclwiLFxuICAgIFwidGltZVwiLFxuICAgIFwidGlueVwiLFxuICAgIFwidGlwXCIsXG4gICAgXCJ0aXJlZFwiLFxuICAgIFwidGlzc3VlXCIsXG4gICAgXCJ0aXRsZVwiLFxuICAgIFwidG9hc3RcIixcbiAgICBcInRvYmFjY29cIixcbiAgICBcInRvZGF5XCIsXG4gICAgXCJ0b2RkbGVyXCIsXG4gICAgXCJ0b2VcIixcbiAgICBcInRvZ2V0aGVyXCIsXG4gICAgXCJ0b2lsZXRcIixcbiAgICBcInRva2VuXCIsXG4gICAgXCJ0b21hdG9cIixcbiAgICBcInRvbW9ycm93XCIsXG4gICAgXCJ0b25lXCIsXG4gICAgXCJ0b25ndWVcIixcbiAgICBcInRvbmlnaHRcIixcbiAgICBcInRvb2xcIixcbiAgICBcInRvb3RoXCIsXG4gICAgXCJ0b3BcIixcbiAgICBcInRvcGljXCIsXG4gICAgXCJ0b3BwbGVcIixcbiAgICBcInRvcmNoXCIsXG4gICAgXCJ0b3JuYWRvXCIsXG4gICAgXCJ0b3J0b2lzZVwiLFxuICAgIFwidG9zc1wiLFxuICAgIFwidG90YWxcIixcbiAgICBcInRvdXJpc3RcIixcbiAgICBcInRvd2FyZFwiLFxuICAgIFwidG93ZXJcIixcbiAgICBcInRvd25cIixcbiAgICBcInRveVwiLFxuICAgIFwidHJhY2tcIixcbiAgICBcInRyYWRlXCIsXG4gICAgXCJ0cmFmZmljXCIsXG4gICAgXCJ0cmFnaWNcIixcbiAgICBcInRyYWluXCIsXG4gICAgXCJ0cmFuc2ZlclwiLFxuICAgIFwidHJhcFwiLFxuICAgIFwidHJhc2hcIixcbiAgICBcInRyYXZlbFwiLFxuICAgIFwidHJheVwiLFxuICAgIFwidHJlYXRcIixcbiAgICBcInRyZWVcIixcbiAgICBcInRyZW5kXCIsXG4gICAgXCJ0cmlhbFwiLFxuICAgIFwidHJpYmVcIixcbiAgICBcInRyaWNrXCIsXG4gICAgXCJ0cmlnZ2VyXCIsXG4gICAgXCJ0cmltXCIsXG4gICAgXCJ0cmlwXCIsXG4gICAgXCJ0cm9waHlcIixcbiAgICBcInRyb3VibGVcIixcbiAgICBcInRydWNrXCIsXG4gICAgXCJ0cnVlXCIsXG4gICAgXCJ0cnVseVwiLFxuICAgIFwidHJ1bXBldFwiLFxuICAgIFwidHJ1c3RcIixcbiAgICBcInRydXRoXCIsXG4gICAgXCJ0cnlcIixcbiAgICBcInR1YmVcIixcbiAgICBcInR1aXRpb25cIixcbiAgICBcInR1bWJsZVwiLFxuICAgIFwidHVuYVwiLFxuICAgIFwidHVubmVsXCIsXG4gICAgXCJ0dXJrZXlcIixcbiAgICBcInR1cm5cIixcbiAgICBcInR1cnRsZVwiLFxuICAgIFwidHdlbHZlXCIsXG4gICAgXCJ0d2VudHlcIixcbiAgICBcInR3aWNlXCIsXG4gICAgXCJ0d2luXCIsXG4gICAgXCJ0d2lzdFwiLFxuICAgIFwidHdvXCIsXG4gICAgXCJ0eXBlXCIsXG4gICAgXCJ0eXBpY2FsXCIsXG4gICAgXCJ1Z2x5XCIsXG4gICAgXCJ1bWJyZWxsYVwiLFxuICAgIFwidW5hYmxlXCIsXG4gICAgXCJ1bmF3YXJlXCIsXG4gICAgXCJ1bmNsZVwiLFxuICAgIFwidW5jb3ZlclwiLFxuICAgIFwidW5kZXJcIixcbiAgICBcInVuZG9cIixcbiAgICBcInVuZmFpclwiLFxuICAgIFwidW5mb2xkXCIsXG4gICAgXCJ1bmhhcHB5XCIsXG4gICAgXCJ1bmlmb3JtXCIsXG4gICAgXCJ1bmlxdWVcIixcbiAgICBcInVuaXRcIixcbiAgICBcInVuaXZlcnNlXCIsXG4gICAgXCJ1bmtub3duXCIsXG4gICAgXCJ1bmxvY2tcIixcbiAgICBcInVudGlsXCIsXG4gICAgXCJ1bnVzdWFsXCIsXG4gICAgXCJ1bnZlaWxcIixcbiAgICBcInVwZGF0ZVwiLFxuICAgIFwidXBncmFkZVwiLFxuICAgIFwidXBob2xkXCIsXG4gICAgXCJ1cG9uXCIsXG4gICAgXCJ1cHBlclwiLFxuICAgIFwidXBzZXRcIixcbiAgICBcInVyYmFuXCIsXG4gICAgXCJ1cmdlXCIsXG4gICAgXCJ1c2FnZVwiLFxuICAgIFwidXNlXCIsXG4gICAgXCJ1c2VkXCIsXG4gICAgXCJ1c2VmdWxcIixcbiAgICBcInVzZWxlc3NcIixcbiAgICBcInVzdWFsXCIsXG4gICAgXCJ1dGlsaXR5XCIsXG4gICAgXCJ2YWNhbnRcIixcbiAgICBcInZhY3V1bVwiLFxuICAgIFwidmFndWVcIixcbiAgICBcInZhbGlkXCIsXG4gICAgXCJ2YWxsZXlcIixcbiAgICBcInZhbHZlXCIsXG4gICAgXCJ2YW5cIixcbiAgICBcInZhbmlzaFwiLFxuICAgIFwidmFwb3JcIixcbiAgICBcInZhcmlvdXNcIixcbiAgICBcInZhc3RcIixcbiAgICBcInZhdWx0XCIsXG4gICAgXCJ2ZWhpY2xlXCIsXG4gICAgXCJ2ZWx2ZXRcIixcbiAgICBcInZlbmRvclwiLFxuICAgIFwidmVudHVyZVwiLFxuICAgIFwidmVudWVcIixcbiAgICBcInZlcmJcIixcbiAgICBcInZlcmlmeVwiLFxuICAgIFwidmVyc2lvblwiLFxuICAgIFwidmVyeVwiLFxuICAgIFwidmVzc2VsXCIsXG4gICAgXCJ2ZXRlcmFuXCIsXG4gICAgXCJ2aWFibGVcIixcbiAgICBcInZpYnJhbnRcIixcbiAgICBcInZpY2lvdXNcIixcbiAgICBcInZpY3RvcnlcIixcbiAgICBcInZpZGVvXCIsXG4gICAgXCJ2aWV3XCIsXG4gICAgXCJ2aWxsYWdlXCIsXG4gICAgXCJ2aW50YWdlXCIsXG4gICAgXCJ2aW9saW5cIixcbiAgICBcInZpcnR1YWxcIixcbiAgICBcInZpcnVzXCIsXG4gICAgXCJ2aXNhXCIsXG4gICAgXCJ2aXNpdFwiLFxuICAgIFwidmlzdWFsXCIsXG4gICAgXCJ2aXRhbFwiLFxuICAgIFwidml2aWRcIixcbiAgICBcInZvY2FsXCIsXG4gICAgXCJ2b2ljZVwiLFxuICAgIFwidm9pZFwiLFxuICAgIFwidm9sY2Fub1wiLFxuICAgIFwidm9sdW1lXCIsXG4gICAgXCJ2b3RlXCIsXG4gICAgXCJ2b3lhZ2VcIixcbiAgICBcIndhZ2VcIixcbiAgICBcIndhZ29uXCIsXG4gICAgXCJ3YWl0XCIsXG4gICAgXCJ3YWxrXCIsXG4gICAgXCJ3YWxsXCIsXG4gICAgXCJ3YWxudXRcIixcbiAgICBcIndhbnRcIixcbiAgICBcIndhcmZhcmVcIixcbiAgICBcIndhcm1cIixcbiAgICBcIndhcnJpb3JcIixcbiAgICBcIndhc2hcIixcbiAgICBcIndhc3BcIixcbiAgICBcIndhc3RlXCIsXG4gICAgXCJ3YXRlclwiLFxuICAgIFwid2F2ZVwiLFxuICAgIFwid2F5XCIsXG4gICAgXCJ3ZWFsdGhcIixcbiAgICBcIndlYXBvblwiLFxuICAgIFwid2VhclwiLFxuICAgIFwid2Vhc2VsXCIsXG4gICAgXCJ3ZWF0aGVyXCIsXG4gICAgXCJ3ZWJcIixcbiAgICBcIndlZGRpbmdcIixcbiAgICBcIndlZWtlbmRcIixcbiAgICBcIndlaXJkXCIsXG4gICAgXCJ3ZWxjb21lXCIsXG4gICAgXCJ3ZXN0XCIsXG4gICAgXCJ3ZXRcIixcbiAgICBcIndoYWxlXCIsXG4gICAgXCJ3aGF0XCIsXG4gICAgXCJ3aGVhdFwiLFxuICAgIFwid2hlZWxcIixcbiAgICBcIndoZW5cIixcbiAgICBcIndoZXJlXCIsXG4gICAgXCJ3aGlwXCIsXG4gICAgXCJ3aGlzcGVyXCIsXG4gICAgXCJ3aWRlXCIsXG4gICAgXCJ3aWR0aFwiLFxuICAgIFwid2lmZVwiLFxuICAgIFwid2lsZFwiLFxuICAgIFwid2lsbFwiLFxuICAgIFwid2luXCIsXG4gICAgXCJ3aW5kb3dcIixcbiAgICBcIndpbmVcIixcbiAgICBcIndpbmdcIixcbiAgICBcIndpbmtcIixcbiAgICBcIndpbm5lclwiLFxuICAgIFwid2ludGVyXCIsXG4gICAgXCJ3aXJlXCIsXG4gICAgXCJ3aXNkb21cIixcbiAgICBcIndpc2VcIixcbiAgICBcIndpc2hcIixcbiAgICBcIndpdG5lc3NcIixcbiAgICBcIndvbGZcIixcbiAgICBcIndvbWFuXCIsXG4gICAgXCJ3b25kZXJcIixcbiAgICBcIndvb2RcIixcbiAgICBcIndvb2xcIixcbiAgICBcIndvcmRcIixcbiAgICBcIndvcmtcIixcbiAgICBcIndvcmxkXCIsXG4gICAgXCJ3b3JyeVwiLFxuICAgIFwid29ydGhcIixcbiAgICBcIndyYXBcIixcbiAgICBcIndyZWNrXCIsXG4gICAgXCJ3cmVzdGxlXCIsXG4gICAgXCJ3cmlzdFwiLFxuICAgIFwid3JpdGVcIixcbiAgICBcIndyb25nXCIsXG4gICAgXCJ5YXJkXCIsXG4gICAgXCJ5ZWFyXCIsXG4gICAgXCJ5ZWxsb3dcIixcbiAgICBcInlvdVwiLFxuICAgIFwieW91bmdcIixcbiAgICBcInlvdXRoXCIsXG4gICAgXCJ6ZWJyYVwiLFxuICAgIFwiemVyb1wiLFxuICAgIFwiem9uZVwiLFxuICAgIFwiem9vXCJcbl1cbiIsIm1vZHVsZS5leHBvcnRzPVtcbiAgICBcImFiYWlzc2VyXCIsXG4gICAgXCJhYmFuZG9uXCIsXG4gICAgXCJhYmRpcXVlclwiLFxuICAgIFwiYWJlaWxsZVwiLFxuICAgIFwiYWJvbGlyXCIsXG4gICAgXCJhYm9yZGVyXCIsXG4gICAgXCJhYm91dGlyXCIsXG4gICAgXCJhYm95ZXJcIixcbiAgICBcImFicmFzaWZcIixcbiAgICBcImFicmV1dmVyXCIsXG4gICAgXCJhYnJpdGVyXCIsXG4gICAgXCJhYnJvZ2VyXCIsXG4gICAgXCJhYnJ1cHRcIixcbiAgICBcImFic2VuY2VcIixcbiAgICBcImFic29sdVwiLFxuICAgIFwiYWJzdXJkZVwiLFxuICAgIFwiYWJ1c2lmXCIsXG4gICAgXCJhYnlzc2FsXCIsXG4gICAgXCJhY2FkZcyBbWllXCIsXG4gICAgXCJhY2Fqb3VcIixcbiAgICBcImFjYXJpZW5cIixcbiAgICBcImFjY2FibGVyXCIsXG4gICAgXCJhY2NlcHRlclwiLFxuICAgIFwiYWNjbGFtZXJcIixcbiAgICBcImFjY29sYWRlXCIsXG4gICAgXCJhY2Nyb2NoZVwiLFxuICAgIFwiYWNjdXNlclwiLFxuICAgIFwiYWNlcmJlXCIsXG4gICAgXCJhY2hhdFwiLFxuICAgIFwiYWNoZXRlclwiLFxuICAgIFwiYWNpZHVsZXJcIixcbiAgICBcImFjaWVyXCIsXG4gICAgXCJhY29tcHRlXCIsXG4gICAgXCJhY3F1ZcyBcmlyXCIsXG4gICAgXCJhY3JvbnltZVwiLFxuICAgIFwiYWN0ZXVyXCIsXG4gICAgXCJhY3RpZlwiLFxuICAgIFwiYWN0dWVsXCIsXG4gICAgXCJhZGVwdGVcIixcbiAgICBcImFkZcyBcXVhdFwiLFxuICAgIFwiYWRoZcyBc2lmXCIsXG4gICAgXCJhZGplY3RpZlwiLFxuICAgIFwiYWRqdWdlclwiLFxuICAgIFwiYWRtZXR0cmVcIixcbiAgICBcImFkbWlyZXJcIixcbiAgICBcImFkb3B0ZXJcIixcbiAgICBcImFkb3JlclwiLFxuICAgIFwiYWRvdWNpclwiLFxuICAgIFwiYWRyZXNzZVwiLFxuICAgIFwiYWRyb2l0XCIsXG4gICAgXCJhZHVsdGVcIixcbiAgICBcImFkdmVyYmVcIixcbiAgICBcImFlzIFyZXJcIixcbiAgICBcImFlzIFyb25lZlwiLFxuICAgIFwiYWZmYWlyZVwiLFxuICAgIFwiYWZmZWN0ZXJcIixcbiAgICBcImFmZmljaGVcIixcbiAgICBcImFmZnJldXhcIixcbiAgICBcImFmZnVibGVyXCIsXG4gICAgXCJhZ2FjZXJcIixcbiAgICBcImFnZW5jZXJcIixcbiAgICBcImFnaWxlXCIsXG4gICAgXCJhZ2l0ZXJcIixcbiAgICBcImFncmFmZXJcIixcbiAgICBcImFncmXMgWFibGVcIixcbiAgICBcImFncnVtZVwiLFxuICAgIFwiYWlkZXJcIixcbiAgICBcImFpZ3VpbGxlXCIsXG4gICAgXCJhaWxpZXJcIixcbiAgICBcImFpbWFibGVcIixcbiAgICBcImFpc2FuY2VcIixcbiAgICBcImFqb3V0ZXJcIixcbiAgICBcImFqdXN0ZXJcIixcbiAgICBcImFsYXJtZXJcIixcbiAgICBcImFsY2hpbWllXCIsXG4gICAgXCJhbGVydGVcIixcbiAgICBcImFsZ2XMgGJyZVwiLFxuICAgIFwiYWxndWVcIixcbiAgICBcImFsaWXMgW5lclwiLFxuICAgIFwiYWxpbWVudFwiLFxuICAgIFwiYWxsZcyBZ2VyXCIsXG4gICAgXCJhbGxpYWdlXCIsXG4gICAgXCJhbGxvdWVyXCIsXG4gICAgXCJhbGx1bWVyXCIsXG4gICAgXCJhbG91cmRpclwiLFxuICAgIFwiYWxwYWdhXCIsXG4gICAgXCJhbHRlc3NlXCIsXG4gICAgXCJhbHZlzIFvbGVcIixcbiAgICBcImFtYXRldXJcIixcbiAgICBcImFtYmlndVwiLFxuICAgIFwiYW1icmVcIixcbiAgICBcImFtZcyBbmFnZXJcIixcbiAgICBcImFtZXJ0dW1lXCIsXG4gICAgXCJhbWlkb25cIixcbiAgICBcImFtaXJhbFwiLFxuICAgIFwiYW1vcmNlclwiLFxuICAgIFwiYW1vdXJcIixcbiAgICBcImFtb3ZpYmxlXCIsXG4gICAgXCJhbXBoaWJpZVwiLFxuICAgIFwiYW1wbGV1clwiLFxuICAgIFwiYW11c2FudFwiLFxuICAgIFwiYW5hbHlzZVwiLFxuICAgIFwiYW5hcGhvcmVcIixcbiAgICBcImFuYXJjaGllXCIsXG4gICAgXCJhbmF0b21pZVwiLFxuICAgIFwiYW5jaWVuXCIsXG4gICAgXCJhbmXMgWFudGlyXCIsXG4gICAgXCJhbmdsZVwiLFxuICAgIFwiYW5nb2lzc2VcIixcbiAgICBcImFuZ3VsZXV4XCIsXG4gICAgXCJhbmltYWxcIixcbiAgICBcImFubmV4ZXJcIixcbiAgICBcImFubm9uY2VcIixcbiAgICBcImFubnVlbFwiLFxuICAgIFwiYW5vZGluXCIsXG4gICAgXCJhbm9tYWxpZVwiLFxuICAgIFwiYW5vbnltZVwiLFxuICAgIFwiYW5vcm1hbFwiLFxuICAgIFwiYW50ZW5uZVwiLFxuICAgIFwiYW50aWRvdGVcIixcbiAgICBcImFueGlldXhcIixcbiAgICBcImFwYWlzZXJcIixcbiAgICBcImFwZcyBcml0aWZcIixcbiAgICBcImFwbGFuaXJcIixcbiAgICBcImFwb2xvZ2llXCIsXG4gICAgXCJhcHBhcmVpbFwiLFxuICAgIFwiYXBwZWxlclwiLFxuICAgIFwiYXBwb3J0ZXJcIixcbiAgICBcImFwcHV5ZXJcIixcbiAgICBcImFxdWFyaXVtXCIsXG4gICAgXCJhcXVlZHVjXCIsXG4gICAgXCJhcmJpdHJlXCIsXG4gICAgXCJhcmJ1c3RlXCIsXG4gICAgXCJhcmRldXJcIixcbiAgICBcImFyZG9pc2VcIixcbiAgICBcImFyZ2VudFwiLFxuICAgIFwiYXJsZXF1aW5cIixcbiAgICBcImFybWF0dXJlXCIsXG4gICAgXCJhcm1lbWVudFwiLFxuICAgIFwiYXJtb2lyZVwiLFxuICAgIFwiYXJtdXJlXCIsXG4gICAgXCJhcnBlbnRlclwiLFxuICAgIFwiYXJyYWNoZXJcIixcbiAgICBcImFycml2ZXJcIixcbiAgICBcImFycm9zZXJcIixcbiAgICBcImFyc2VuaWNcIixcbiAgICBcImFydGXMgXJpZWxcIixcbiAgICBcImFydGljbGVcIixcbiAgICBcImFzcGVjdFwiLFxuICAgIFwiYXNwaGFsdGVcIixcbiAgICBcImFzcGlyZXJcIixcbiAgICBcImFzc2F1dFwiLFxuICAgIFwiYXNzZXJ2aXJcIixcbiAgICBcImFzc2lldHRlXCIsXG4gICAgXCJhc3NvY2llclwiLFxuICAgIFwiYXNzdXJlclwiLFxuICAgIFwiYXN0aWNvdFwiLFxuICAgIFwiYXN0cmVcIixcbiAgICBcImFzdHVjZVwiLFxuICAgIFwiYXRlbGllclwiLFxuICAgIFwiYXRvbWVcIixcbiAgICBcImF0cml1bVwiLFxuICAgIFwiYXRyb2NlXCIsXG4gICAgXCJhdHRhcXVlXCIsXG4gICAgXCJhdHRlbnRpZlwiLFxuICAgIFwiYXR0aXJlclwiLFxuICAgIFwiYXR0cmFwZXJcIixcbiAgICBcImF1YmFpbmVcIixcbiAgICBcImF1YmVyZ2VcIixcbiAgICBcImF1ZGFjZVwiLFxuICAgIFwiYXVkaWJsZVwiLFxuICAgIFwiYXVndXJlclwiLFxuICAgIFwiYXVyb3JlXCIsXG4gICAgXCJhdXRvbW5lXCIsXG4gICAgXCJhdXRydWNoZVwiLFxuICAgIFwiYXZhbGVyXCIsXG4gICAgXCJhdmFuY2VyXCIsXG4gICAgXCJhdmFyaWNlXCIsXG4gICAgXCJhdmVuaXJcIixcbiAgICBcImF2ZXJzZVwiLFxuICAgIFwiYXZldWdsZVwiLFxuICAgIFwiYXZpYXRldXJcIixcbiAgICBcImF2aWRlXCIsXG4gICAgXCJhdmlvblwiLFxuICAgIFwiYXZpc2VyXCIsXG4gICAgXCJhdm9pbmVcIixcbiAgICBcImF2b3VlclwiLFxuICAgIFwiYXZyaWxcIixcbiAgICBcImF4aWFsXCIsXG4gICAgXCJheGlvbWVcIixcbiAgICBcImJhZGdlXCIsXG4gICAgXCJiYWZvdWVyXCIsXG4gICAgXCJiYWdhZ2VcIixcbiAgICBcImJhZ3VldHRlXCIsXG4gICAgXCJiYWlnbmFkZVwiLFxuICAgIFwiYmFsYW5jZXJcIixcbiAgICBcImJhbGNvblwiLFxuICAgIFwiYmFsZWluZVwiLFxuICAgIFwiYmFsaXNhZ2VcIixcbiAgICBcImJhbWJpblwiLFxuICAgIFwiYmFuY2FpcmVcIixcbiAgICBcImJhbmRhZ2VcIixcbiAgICBcImJhbmxpZXVlXCIsXG4gICAgXCJiYW5uaWXMgHJlXCIsXG4gICAgXCJiYW5xdWllclwiLFxuICAgIFwiYmFyYmllclwiLFxuICAgIFwiYmFyaWxcIixcbiAgICBcImJhcm9uXCIsXG4gICAgXCJiYXJxdWVcIixcbiAgICBcImJhcnJhZ2VcIixcbiAgICBcImJhc3NpblwiLFxuICAgIFwiYmFzdGlvblwiLFxuICAgIFwiYmF0YWlsbGVcIixcbiAgICBcImJhdGVhdVwiLFxuICAgIFwiYmF0dGVyaWVcIixcbiAgICBcImJhdWRyaWVyXCIsXG4gICAgXCJiYXZhcmRlclwiLFxuICAgIFwiYmVsZXR0ZVwiLFxuICAgIFwiYmXMgWxpZXJcIixcbiAgICBcImJlbG90ZVwiLFxuICAgIFwiYmXMgW5lzIFmaWNlXCIsXG4gICAgXCJiZXJjZWF1XCIsXG4gICAgXCJiZXJnZXJcIixcbiAgICBcImJlcmxpbmVcIixcbiAgICBcImJlcm11ZGFcIixcbiAgICBcImJlc2FjZVwiLFxuICAgIFwiYmVzb2duZVwiLFxuICAgIFwiYmXMgXRhaWxcIixcbiAgICBcImJldXJyZVwiLFxuICAgIFwiYmliZXJvblwiLFxuICAgIFwiYmljeWNsZVwiLFxuICAgIFwiYmlkdWxlXCIsXG4gICAgXCJiaWpvdVwiLFxuICAgIFwiYmlsYW5cIixcbiAgICBcImJpbGluZ3VlXCIsXG4gICAgXCJiaWxsYXJkXCIsXG4gICAgXCJiaW5haXJlXCIsXG4gICAgXCJiaW9sb2dpZVwiLFxuICAgIFwiYmlvcHNpZVwiLFxuICAgIFwiYmlvdHlwZVwiLFxuICAgIFwiYmlzY3VpdFwiLFxuICAgIFwiYmlzb25cIixcbiAgICBcImJpc3RvdXJpXCIsXG4gICAgXCJiaXR1bWVcIixcbiAgICBcImJpemFycmVcIixcbiAgICBcImJsYWZhcmRcIixcbiAgICBcImJsYWd1ZVwiLFxuICAgIFwiYmxhbmNoaXJcIixcbiAgICBcImJsZXNzYW50XCIsXG4gICAgXCJibGluZGVyXCIsXG4gICAgXCJibG9uZFwiLFxuICAgIFwiYmxvcXVlclwiLFxuICAgIFwiYmxvdXNvblwiLFxuICAgIFwiYm9iYXJkXCIsXG4gICAgXCJib2JpbmVcIixcbiAgICBcImJvaXJlXCIsXG4gICAgXCJib2lzZXJcIixcbiAgICBcImJvbGlkZVwiLFxuICAgIFwiYm9uYm9uXCIsXG4gICAgXCJib25kaXJcIixcbiAgICBcImJvbmhldXJcIixcbiAgICBcImJvbmlmaWVyXCIsXG4gICAgXCJib251c1wiLFxuICAgIFwiYm9yZHVyZVwiLFxuICAgIFwiYm9ybmVcIixcbiAgICBcImJvdHRlXCIsXG4gICAgXCJib3VjbGVcIixcbiAgICBcImJvdWV1eFwiLFxuICAgIFwiYm91Z2llXCIsXG4gICAgXCJib3Vsb25cIixcbiAgICBcImJvdXF1aW5cIixcbiAgICBcImJvdXJzZVwiLFxuICAgIFwiYm91c3NvbGVcIixcbiAgICBcImJvdXRpcXVlXCIsXG4gICAgXCJib3hldXJcIixcbiAgICBcImJyYW5jaGVcIixcbiAgICBcImJyYXNpZXJcIixcbiAgICBcImJyYXZlXCIsXG4gICAgXCJicmViaXNcIixcbiAgICBcImJyZcyAY2hlXCIsXG4gICAgXCJicmV1dmFnZVwiLFxuICAgIFwiYnJpY29sZXJcIixcbiAgICBcImJyaWdhZGVcIixcbiAgICBcImJyaWxsYW50XCIsXG4gICAgXCJicmlvY2hlXCIsXG4gICAgXCJicmlxdWVcIixcbiAgICBcImJyb2NodXJlXCIsXG4gICAgXCJicm9kZXJcIixcbiAgICBcImJyb256ZXJcIixcbiAgICBcImJyb3Vzc2VcIixcbiAgICBcImJyb3lldXJcIixcbiAgICBcImJydW1lXCIsXG4gICAgXCJicnVzcXVlXCIsXG4gICAgXCJicnV0YWxcIixcbiAgICBcImJydXlhbnRcIixcbiAgICBcImJ1ZmZsZVwiLFxuICAgIFwiYnVpc3NvblwiLFxuICAgIFwiYnVsbGV0aW5cIixcbiAgICBcImJ1cmVhdVwiLFxuICAgIFwiYnVyaW5cIixcbiAgICBcImJ1c3RpZXJcIixcbiAgICBcImJ1dGluZXJcIixcbiAgICBcImJ1dG9pclwiLFxuICAgIFwiYnV2YWJsZVwiLFxuICAgIFwiYnV2ZXR0ZVwiLFxuICAgIFwiY2FiYW5vblwiLFxuICAgIFwiY2FiaW5lXCIsXG4gICAgXCJjYWNoZXR0ZVwiLFxuICAgIFwiY2FkZWF1XCIsXG4gICAgXCJjYWRyZVwiLFxuICAgIFwiY2FmZcyBaW5lXCIsXG4gICAgXCJjYWlsbG91XCIsXG4gICAgXCJjYWlzc29uXCIsXG4gICAgXCJjYWxjdWxlclwiLFxuICAgIFwiY2FsZXBpblwiLFxuICAgIFwiY2FsaWJyZVwiLFxuICAgIFwiY2FsbWVyXCIsXG4gICAgXCJjYWxvbW5pZVwiLFxuICAgIFwiY2FsdmFpcmVcIixcbiAgICBcImNhbWFyYWRlXCIsXG4gICAgXCJjYW1lzIFyYVwiLFxuICAgIFwiY2FtaW9uXCIsXG4gICAgXCJjYW1wYWduZVwiLFxuICAgIFwiY2FuYWxcIixcbiAgICBcImNhbmV0b25cIixcbiAgICBcImNhbm9uXCIsXG4gICAgXCJjYW50aW5lXCIsXG4gICAgXCJjYW51bGFyXCIsXG4gICAgXCJjYXBhYmxlXCIsXG4gICAgXCJjYXBvcmFsXCIsXG4gICAgXCJjYXByaWNlXCIsXG4gICAgXCJjYXBzdWxlXCIsXG4gICAgXCJjYXB0ZXJcIixcbiAgICBcImNhcHVjaGVcIixcbiAgICBcImNhcmFiaW5lXCIsXG4gICAgXCJjYXJib25lXCIsXG4gICAgXCJjYXJlc3NlclwiLFxuICAgIFwiY2FyaWJvdVwiLFxuICAgIFwiY2FybmFnZVwiLFxuICAgIFwiY2Fyb3R0ZVwiLFxuICAgIFwiY2FycmVhdVwiLFxuICAgIFwiY2FydG9uXCIsXG4gICAgXCJjYXNjYWRlXCIsXG4gICAgXCJjYXNpZXJcIixcbiAgICBcImNhc3F1ZVwiLFxuICAgIFwiY2Fzc3VyZVwiLFxuICAgIFwiY2F1c2VyXCIsXG4gICAgXCJjYXV0aW9uXCIsXG4gICAgXCJjYXZhbGllclwiLFxuICAgIFwiY2F2ZXJuZVwiLFxuICAgIFwiY2F2aWFyXCIsXG4gICAgXCJjZcyBZGlsbGVcIixcbiAgICBcImNlaW50dXJlXCIsXG4gICAgXCJjZcyBbGVzdGVcIixcbiAgICBcImNlbGx1bGVcIixcbiAgICBcImNlbmRyaWVyXCIsXG4gICAgXCJjZW5zdXJlclwiLFxuICAgIFwiY2VudHJhbFwiLFxuICAgIFwiY2VyY2xlXCIsXG4gICAgXCJjZcyBcmXMgWJyYWxcIixcbiAgICBcImNlcmlzZVwiLFxuICAgIFwiY2VybmVyXCIsXG4gICAgXCJjZXJ2ZWF1XCIsXG4gICAgXCJjZXNzZXJcIixcbiAgICBcImNoYWdyaW5cIixcbiAgICBcImNoYWlzZVwiLFxuICAgIFwiY2hhbGV1clwiLFxuICAgIFwiY2hhbWJyZVwiLFxuICAgIFwiY2hhbmNlXCIsXG4gICAgXCJjaGFwaXRyZVwiLFxuICAgIFwiY2hhcmJvblwiLFxuICAgIFwiY2hhc3NldXJcIixcbiAgICBcImNoYXRvblwiLFxuICAgIFwiY2hhdXNzb25cIixcbiAgICBcImNoYXZpcmVyXCIsXG4gICAgXCJjaGVtaXNlXCIsXG4gICAgXCJjaGVuaWxsZVwiLFxuICAgIFwiY2hlzIFxdWllclwiLFxuICAgIFwiY2hlcmNoZXJcIixcbiAgICBcImNoZXZhbFwiLFxuICAgIFwiY2hpZW5cIixcbiAgICBcImNoaWZmcmVcIixcbiAgICBcImNoaWdub25cIixcbiAgICBcImNoaW1lzIByZVwiLFxuICAgIFwiY2hpb3RcIixcbiAgICBcImNobG9ydXJlXCIsXG4gICAgXCJjaG9jb2xhdFwiLFxuICAgIFwiY2hvaXNpclwiLFxuICAgIFwiY2hvc2VcIixcbiAgICBcImNob3VldHRlXCIsXG4gICAgXCJjaHJvbWVcIixcbiAgICBcImNodXRlXCIsXG4gICAgXCJjaWdhcmVcIixcbiAgICBcImNpZ29nbmVcIixcbiAgICBcImNpbWVudGVyXCIsXG4gICAgXCJjaW5lzIFtYVwiLFxuICAgIFwiY2ludHJlclwiLFxuICAgIFwiY2lyY3VsZXJcIixcbiAgICBcImNpcmVyXCIsXG4gICAgXCJjaXJxdWVcIixcbiAgICBcImNpdGVybmVcIixcbiAgICBcImNpdG95ZW5cIixcbiAgICBcImNpdHJvblwiLFxuICAgIFwiY2l2aWxcIixcbiAgICBcImNsYWlyb25cIixcbiAgICBcImNsYW1ldXJcIixcbiAgICBcImNsYXF1ZXJcIixcbiAgICBcImNsYXNzZVwiLFxuICAgIFwiY2xhdmllclwiLFxuICAgIFwiY2xpZW50XCIsXG4gICAgXCJjbGlnbmVyXCIsXG4gICAgXCJjbGltYXRcIixcbiAgICBcImNsaXZhZ2VcIixcbiAgICBcImNsb2NoZVwiLFxuICAgIFwiY2xvbmFnZVwiLFxuICAgIFwiY2xvcG9ydGVcIixcbiAgICBcImNvYmFsdFwiLFxuICAgIFwiY29icmFcIixcbiAgICBcImNvY2Fzc2VcIixcbiAgICBcImNvY290aWVyXCIsXG4gICAgXCJjb2RlclwiLFxuICAgIFwiY29kaWZpZXJcIixcbiAgICBcImNvZmZyZVwiLFxuICAgIFwiY29nbmVyXCIsXG4gICAgXCJjb2hlzIFzaW9uXCIsXG4gICAgXCJjb2lmZmVyXCIsXG4gICAgXCJjb2luY2VyXCIsXG4gICAgXCJjb2xlzIByZVwiLFxuICAgIFwiY29saWJyaVwiLFxuICAgIFwiY29sbGluZVwiLFxuICAgIFwiY29sbWF0ZXJcIixcbiAgICBcImNvbG9uZWxcIixcbiAgICBcImNvbWJhdFwiLFxuICAgIFwiY29tZcyBZGllXCIsXG4gICAgXCJjb21tYW5kZVwiLFxuICAgIFwiY29tcGFjdFwiLFxuICAgIFwiY29uY2VydFwiLFxuICAgIFwiY29uZHVpcmVcIixcbiAgICBcImNvbmZpZXJcIixcbiAgICBcImNvbmdlbGVyXCIsXG4gICAgXCJjb25ub3RlclwiLFxuICAgIFwiY29uc29ubmVcIixcbiAgICBcImNvbnRhY3RcIixcbiAgICBcImNvbnZleGVcIixcbiAgICBcImNvcGFpblwiLFxuICAgIFwiY29waWVcIixcbiAgICBcImNvcmFpbFwiLFxuICAgIFwiY29yYmVhdVwiLFxuICAgIFwiY29yZGFnZVwiLFxuICAgIFwiY29ybmljaGVcIixcbiAgICBcImNvcnB1c1wiLFxuICAgIFwiY29ycmVjdFwiLFxuICAgIFwiY29ydGXMgGdlXCIsXG4gICAgXCJjb3NtaXF1ZVwiLFxuICAgIFwiY29zdHVtZVwiLFxuICAgIFwiY290b25cIixcbiAgICBcImNvdWRlXCIsXG4gICAgXCJjb3VwdXJlXCIsXG4gICAgXCJjb3VyYWdlXCIsXG4gICAgXCJjb3V0ZWF1XCIsXG4gICAgXCJjb3V2cmlyXCIsXG4gICAgXCJjb3lvdGVcIixcbiAgICBcImNyYWJlXCIsXG4gICAgXCJjcmFpbnRlXCIsXG4gICAgXCJjcmF2YXRlXCIsXG4gICAgXCJjcmF5b25cIixcbiAgICBcImNyZcyBYXR1cmVcIixcbiAgICBcImNyZcyBZGl0ZXJcIixcbiAgICBcImNyZcyBbWV1eFwiLFxuICAgIFwiY3JldXNlclwiLFxuICAgIFwiY3JldmV0dGVcIixcbiAgICBcImNyaWJsZXJcIixcbiAgICBcImNyaWVyXCIsXG4gICAgXCJjcmlzdGFsXCIsXG4gICAgXCJjcml0ZcyAcmVcIixcbiAgICBcImNyb2lyZVwiLFxuICAgIFwiY3JvcXVlclwiLFxuICAgIFwiY3JvdGFsZVwiLFxuICAgIFwiY3J1Y2lhbFwiLFxuICAgIFwiY3J1ZWxcIixcbiAgICBcImNyeXB0ZXJcIixcbiAgICBcImN1YmlxdWVcIixcbiAgICBcImN1ZWlsbGlyXCIsXG4gICAgXCJjdWlsbGXMgHJlXCIsXG4gICAgXCJjdWlzaW5lXCIsXG4gICAgXCJjdWl2cmVcIixcbiAgICBcImN1bG1pbmVyXCIsXG4gICAgXCJjdWx0aXZlclwiLFxuICAgIFwiY3VtdWxlclwiLFxuICAgIFwiY3VwaWRlXCIsXG4gICAgXCJjdXJhdGlmXCIsXG4gICAgXCJjdXJzZXVyXCIsXG4gICAgXCJjeWFudXJlXCIsXG4gICAgXCJjeWNsZVwiLFxuICAgIFwiY3lsaW5kcmVcIixcbiAgICBcImN5bmlxdWVcIixcbiAgICBcImRhaWduZXJcIixcbiAgICBcImRhbWllclwiLFxuICAgIFwiZGFuZ2VyXCIsXG4gICAgXCJkYW5zZXVyXCIsXG4gICAgXCJkYXVwaGluXCIsXG4gICAgXCJkZcyBYmF0dHJlXCIsXG4gICAgXCJkZcyBYml0ZXJcIixcbiAgICBcImRlzIFib3JkZXJcIixcbiAgICBcImRlzIFicmlkZXJcIixcbiAgICBcImRlzIFidXRhbnRcIixcbiAgICBcImRlzIFjYWxlclwiLFxuICAgIFwiZGXMgWNlbWJyZVwiLFxuICAgIFwiZGXMgWNoaXJlclwiLFxuICAgIFwiZGXMgWNpZGVyXCIsXG4gICAgXCJkZcyBY2xhcmVyXCIsXG4gICAgXCJkZcyBY29yZXJcIixcbiAgICBcImRlzIFjcmlyZVwiLFxuICAgIFwiZGXMgWN1cGxlclwiLFxuICAgIFwiZGXMgWRhbGVcIixcbiAgICBcImRlzIFkdWN0aWZcIixcbiAgICBcImRlzIFlc3NlXCIsXG4gICAgXCJkZcyBZmVuc2lmXCIsXG4gICAgXCJkZcyBZmlsZXJcIixcbiAgICBcImRlzIFmcmF5ZXJcIixcbiAgICBcImRlzIFnYWdlclwiLFxuICAgIFwiZGXMgWdpdnJlclwiLFxuICAgIFwiZGXMgWdsdXRpclwiLFxuICAgIFwiZGXMgWdyYWZlclwiLFxuICAgIFwiZGXMgWpldW5lclwiLFxuICAgIFwiZGXMgWxpY2VcIixcbiAgICBcImRlzIFsb2dlclwiLFxuICAgIFwiZGVtYW5kZXJcIixcbiAgICBcImRlbWV1cmVyXCIsXG4gICAgXCJkZcyBbW9saXJcIixcbiAgICBcImRlzIFuaWNoZXJcIixcbiAgICBcImRlzIFub3VlclwiLFxuICAgIFwiZGVudGVsbGVcIixcbiAgICBcImRlzIFudWRlclwiLFxuICAgIFwiZGXMgXBhcnRcIixcbiAgICBcImRlzIFwZW5zZXJcIixcbiAgICBcImRlzIFwaGFzZXJcIixcbiAgICBcImRlzIFwbGFjZXJcIixcbiAgICBcImRlzIFwb3NlclwiLFxuICAgIFwiZGXMgXJhbmdlclwiLFxuICAgIFwiZGXMgXJvYmVyXCIsXG4gICAgXCJkZcyBc2FzdHJlXCIsXG4gICAgXCJkZXNjZW50ZVwiLFxuICAgIFwiZGXMgXNlcnRcIixcbiAgICBcImRlzIFzaWduZXJcIixcbiAgICBcImRlzIFzb2JlzIFpclwiLFxuICAgIFwiZGVzc2luZXJcIixcbiAgICBcImRlc3RyaWVyXCIsXG4gICAgXCJkZcyBdGFjaGVyXCIsXG4gICAgXCJkZcyBdGVzdGVyXCIsXG4gICAgXCJkZcyBdG91cmVyXCIsXG4gICAgXCJkZcyBdHJlc3NlXCIsXG4gICAgXCJkZXZhbmNlclwiLFxuICAgIFwiZGV2ZW5pclwiLFxuICAgIFwiZGV2aW5lclwiLFxuICAgIFwiZGV2b2lyXCIsXG4gICAgXCJkaWFibGVcIixcbiAgICBcImRpYWxvZ3VlXCIsXG4gICAgXCJkaWFtYW50XCIsXG4gICAgXCJkaWN0ZXJcIixcbiAgICBcImRpZmZlzIFyZXJcIixcbiAgICBcImRpZ2XMgXJlclwiLFxuICAgIFwiZGlnaXRhbFwiLFxuICAgIFwiZGlnbmVcIixcbiAgICBcImRpbHVlclwiLFxuICAgIFwiZGltYW5jaGVcIixcbiAgICBcImRpbWludWVyXCIsXG4gICAgXCJkaW94eWRlXCIsXG4gICAgXCJkaXJlY3RpZlwiLFxuICAgIFwiZGlyaWdlclwiLFxuICAgIFwiZGlzY3V0ZXJcIixcbiAgICBcImRpc3Bvc2VyXCIsXG4gICAgXCJkaXNzaXBlclwiLFxuICAgIFwiZGlzdGFuY2VcIixcbiAgICBcImRpdmVydGlyXCIsXG4gICAgXCJkaXZpc2VyXCIsXG4gICAgXCJkb2NpbGVcIixcbiAgICBcImRvY3RldXJcIixcbiAgICBcImRvZ21lXCIsXG4gICAgXCJkb2lndFwiLFxuICAgIFwiZG9tYWluZVwiLFxuICAgIFwiZG9taWNpbGVcIixcbiAgICBcImRvbXB0ZXJcIixcbiAgICBcImRvbmF0ZXVyXCIsXG4gICAgXCJkb25qb25cIixcbiAgICBcImRvbm5lclwiLFxuICAgIFwiZG9wYW1pbmVcIixcbiAgICBcImRvcnRvaXJcIixcbiAgICBcImRvcnVyZVwiLFxuICAgIFwiZG9zYWdlXCIsXG4gICAgXCJkb3NldXJcIixcbiAgICBcImRvc3NpZXJcIixcbiAgICBcImRvdGF0aW9uXCIsXG4gICAgXCJkb3VhbmllclwiLFxuICAgIFwiZG91YmxlXCIsXG4gICAgXCJkb3VjZXVyXCIsXG4gICAgXCJkb3V0ZXJcIixcbiAgICBcImRveWVuXCIsXG4gICAgXCJkcmFnb25cIixcbiAgICBcImRyYXBlclwiLFxuICAgIFwiZHJlc3NlclwiLFxuICAgIFwiZHJpYmJsZXJcIixcbiAgICBcImRyb2l0dXJlXCIsXG4gICAgXCJkdXBlcmllXCIsXG4gICAgXCJkdXBsZXhlXCIsXG4gICAgXCJkdXJhYmxlXCIsXG4gICAgXCJkdXJjaXJcIixcbiAgICBcImR5bmFzdGllXCIsXG4gICAgXCJlzIFibG91aXJcIixcbiAgICBcImXMgWNhcnRlclwiLFxuICAgIFwiZcyBY2hhcnBlXCIsXG4gICAgXCJlzIFjaGVsbGVcIixcbiAgICBcImXMgWNsYWlyZXJcIixcbiAgICBcImXMgWNsaXBzZVwiLFxuICAgIFwiZcyBY2xvcmVcIixcbiAgICBcImXMgWNsdXNlXCIsXG4gICAgXCJlzIFjb2xlXCIsXG4gICAgXCJlzIFjb25vbWllXCIsXG4gICAgXCJlzIFjb3JjZVwiLFxuICAgIFwiZcyBY291dGVyXCIsXG4gICAgXCJlzIFjcmFzZXJcIixcbiAgICBcImXMgWNyZcyBbWVyXCIsXG4gICAgXCJlzIFjcml2YWluXCIsXG4gICAgXCJlzIFjcm91XCIsXG4gICAgXCJlzIFjdW1lXCIsXG4gICAgXCJlzIFjdXJldWlsXCIsXG4gICAgXCJlzIFkaWZpZXJcIixcbiAgICBcImXMgWR1cXVlclwiLFxuICAgIFwiZWZmYWNlclwiLFxuICAgIFwiZWZmZWN0aWZcIixcbiAgICBcImVmZmlnaWVcIixcbiAgICBcImVmZm9ydFwiLFxuICAgIFwiZWZmcmF5ZXJcIixcbiAgICBcImVmZnVzaW9uXCIsXG4gICAgXCJlzIFnYWxpc2VyXCIsXG4gICAgXCJlzIFnYXJlclwiLFxuICAgIFwiZcyBamVjdGVyXCIsXG4gICAgXCJlzIFsYWJvcmVyXCIsXG4gICAgXCJlzIFsYXJnaXJcIixcbiAgICBcImXMgWxlY3Ryb25cIixcbiAgICBcImXMgWxlzIFnYW50XCIsXG4gICAgXCJlzIFsZcyBcGhhbnRcIixcbiAgICBcImXMgWxlzIB2ZVwiLFxuICAgIFwiZcyBbGlnaWJsZVwiLFxuICAgIFwiZcyBbGl0aXNtZVwiLFxuICAgIFwiZcyBbG9nZVwiLFxuICAgIFwiZcyBbHVjaWRlclwiLFxuICAgIFwiZcyBbHVkZXJcIixcbiAgICBcImVtYmFsbGVyXCIsXG4gICAgXCJlbWJlbGxpclwiLFxuICAgIFwiZW1icnlvblwiLFxuICAgIFwiZcyBbWVyYXVkZVwiLFxuICAgIFwiZcyBbWlzc2lvblwiLFxuICAgIFwiZW1tZW5lclwiLFxuICAgIFwiZcyBbW90aW9uXCIsXG4gICAgXCJlzIFtb3V2b2lyXCIsXG4gICAgXCJlbXBlcmV1clwiLFxuICAgIFwiZW1wbG95ZXJcIixcbiAgICBcImVtcG9ydGVyXCIsXG4gICAgXCJlbXByaXNlXCIsXG4gICAgXCJlzIFtdWxzaW9uXCIsXG4gICAgXCJlbmNhZHJlclwiLFxuICAgIFwiZW5jaGXMgHJlXCIsXG4gICAgXCJlbmNsYXZlXCIsXG4gICAgXCJlbmNvY2hlXCIsXG4gICAgXCJlbmRpZ3VlclwiLFxuICAgIFwiZW5kb3NzZXJcIixcbiAgICBcImVuZHJvaXRcIixcbiAgICBcImVuZHVpcmVcIixcbiAgICBcImXMgW5lcmdpZVwiLFxuICAgIFwiZW5mYW5jZVwiLFxuICAgIFwiZW5mZXJtZXJcIixcbiAgICBcImVuZm91aXJcIixcbiAgICBcImVuZ2FnZXJcIixcbiAgICBcImVuZ2luXCIsXG4gICAgXCJlbmdsb2JlclwiLFxuICAgIFwiZcyBbmlnbWVcIixcbiAgICBcImVuamFtYmVyXCIsXG4gICAgXCJlbmpldVwiLFxuICAgIFwiZW5sZXZlclwiLFxuICAgIFwiZW5uZW1pXCIsXG4gICAgXCJlbm51eWV1eFwiLFxuICAgIFwiZW5yaWNoaXJcIixcbiAgICBcImVucm9iYWdlXCIsXG4gICAgXCJlbnNlaWduZVwiLFxuICAgIFwiZW50YXNzZXJcIixcbiAgICBcImVudGVuZHJlXCIsXG4gICAgXCJlbnRpZXJcIixcbiAgICBcImVudG91cmVyXCIsXG4gICAgXCJlbnRyYXZlclwiLFxuICAgIFwiZcyBbnVtZcyBcmVyXCIsXG4gICAgXCJlbnZhaGlyXCIsXG4gICAgXCJlbnZpYWJsZVwiLFxuICAgIFwiZW52b3llclwiLFxuICAgIFwiZW56eW1lXCIsXG4gICAgXCJlzIFvbGllblwiLFxuICAgIFwiZcyBcGFpc3NpclwiLFxuICAgIFwiZcyBcGFyZ25lXCIsXG4gICAgXCJlzIFwYXRhbnRcIixcbiAgICBcImXMgXBhdWxlXCIsXG4gICAgXCJlzIFwaWNlcmllXCIsXG4gICAgXCJlzIFwaWRlzIFtaWVcIixcbiAgICBcImXMgXBpZXJcIixcbiAgICBcImXMgXBpbG9ndWVcIixcbiAgICBcImXMgXBpbmVcIixcbiAgICBcImXMgXBpc29kZVwiLFxuICAgIFwiZcyBcGl0YXBoZVwiLFxuICAgIFwiZcyBcG9xdWVcIixcbiAgICBcImXMgXByZXV2ZVwiLFxuICAgIFwiZcyBcHJvdXZlclwiLFxuICAgIFwiZcyBcHVpc2FudFwiLFxuICAgIFwiZcyBcXVlcnJlXCIsXG4gICAgXCJlzIFxdWlwZVwiLFxuICAgIFwiZcyBcmlnZXJcIixcbiAgICBcImXMgXJvc2lvblwiLFxuICAgIFwiZXJyZXVyXCIsXG4gICAgXCJlzIFydXB0aW9uXCIsXG4gICAgXCJlc2NhbGllclwiLFxuICAgIFwiZXNwYWRvblwiLFxuICAgIFwiZXNwZcyAY2VcIixcbiAgICBcImVzcGllzIBnbGVcIixcbiAgICBcImVzcG9pclwiLFxuICAgIFwiZXNwcml0XCIsXG4gICAgXCJlc3F1aXZlclwiLFxuICAgIFwiZXNzYXllclwiLFxuICAgIFwiZXNzZW5jZVwiLFxuICAgIFwiZXNzaWV1XCIsXG4gICAgXCJlc3NvcmVyXCIsXG4gICAgXCJlc3RpbWVcIixcbiAgICBcImVzdG9tYWNcIixcbiAgICBcImVzdHJhZGVcIixcbiAgICBcImXMgXRhZ2XMgHJlXCIsXG4gICAgXCJlzIF0YWxlclwiLFxuICAgIFwiZcyBdGFuY2hlXCIsXG4gICAgXCJlzIF0YXRpcXVlXCIsXG4gICAgXCJlzIF0ZWluZHJlXCIsXG4gICAgXCJlzIF0ZW5kb2lyXCIsXG4gICAgXCJlzIF0ZXJuZWxcIixcbiAgICBcImXMgXRoYW5vbFwiLFxuICAgIFwiZcyBdGhpcXVlXCIsXG4gICAgXCJldGhuaWVcIixcbiAgICBcImXMgXRpcmVyXCIsXG4gICAgXCJlzIF0b2ZmZXJcIixcbiAgICBcImXMgXRvaWxlXCIsXG4gICAgXCJlzIF0b25uYW50XCIsXG4gICAgXCJlzIF0b3VyZGlyXCIsXG4gICAgXCJlzIF0cmFuZ2VcIixcbiAgICBcImXMgXRyb2l0XCIsXG4gICAgXCJlzIF0dWRlXCIsXG4gICAgXCJldXBob3JpZVwiLFxuICAgIFwiZcyBdmFsdWVyXCIsXG4gICAgXCJlzIF2YXNpb25cIixcbiAgICBcImXMgXZlbnRhaWxcIixcbiAgICBcImXMgXZpZGVuY2VcIixcbiAgICBcImXMgXZpdGVyXCIsXG4gICAgXCJlzIF2b2x1dGlmXCIsXG4gICAgXCJlzIF2b3F1ZXJcIixcbiAgICBcImV4YWN0XCIsXG4gICAgXCJleGFnZcyBcmVyXCIsXG4gICAgXCJleGF1Y2VyXCIsXG4gICAgXCJleGNlbGxlclwiLFxuICAgIFwiZXhjaXRhbnRcIixcbiAgICBcImV4Y2x1c2lmXCIsXG4gICAgXCJleGN1c2VcIixcbiAgICBcImV4ZcyBY3V0ZXJcIixcbiAgICBcImV4ZW1wbGVcIixcbiAgICBcImV4ZXJjZXJcIixcbiAgICBcImV4aGFsZXJcIixcbiAgICBcImV4aG9ydGVyXCIsXG4gICAgXCJleGlnZW5jZVwiLFxuICAgIFwiZXhpbGVyXCIsXG4gICAgXCJleGlzdGVyXCIsXG4gICAgXCJleG90aXF1ZVwiLFxuICAgIFwiZXhwZcyBZGllclwiLFxuICAgIFwiZXhwbG9yZXJcIixcbiAgICBcImV4cG9zZXJcIixcbiAgICBcImV4cHJpbWVyXCIsXG4gICAgXCJleHF1aXNcIixcbiAgICBcImV4dGVuc2lmXCIsXG4gICAgXCJleHRyYWlyZVwiLFxuICAgIFwiZXh1bHRlclwiLFxuICAgIFwiZmFibGVcIixcbiAgICBcImZhYnVsZXV4XCIsXG4gICAgXCJmYWNldHRlXCIsXG4gICAgXCJmYWNpbGVcIixcbiAgICBcImZhY3R1cmVcIixcbiAgICBcImZhaWJsaXJcIixcbiAgICBcImZhbGFpc2VcIixcbiAgICBcImZhbWV1eFwiLFxuICAgIFwiZmFtaWxsZVwiLFxuICAgIFwiZmFyY2V1clwiLFxuICAgIFwiZmFyZmVsdVwiLFxuICAgIFwiZmFyaW5lXCIsXG4gICAgXCJmYXJvdWNoZVwiLFxuICAgIFwiZmFzY2luZXJcIixcbiAgICBcImZhdGFsXCIsXG4gICAgXCJmYXRpZ3VlXCIsXG4gICAgXCJmYXVjb25cIixcbiAgICBcImZhdXRpZlwiLFxuICAgIFwiZmF2ZXVyXCIsXG4gICAgXCJmYXZvcmlcIixcbiAgICBcImZlzIFicmlsZVwiLFxuICAgIFwiZmXMgWNvbmRlclwiLFxuICAgIFwiZmXMgWRlzIFyZXJcIixcbiAgICBcImZlzIFsaW5cIixcbiAgICBcImZlbW1lXCIsXG4gICAgXCJmZcyBbXVyXCIsXG4gICAgXCJmZW5kb2lyXCIsXG4gICAgXCJmZcyBb2RhbFwiLFxuICAgIFwiZmVybWVyXCIsXG4gICAgXCJmZcyBcm9jZVwiLFxuICAgIFwiZmVydmV1clwiLFxuICAgIFwiZmVzdGl2YWxcIixcbiAgICBcImZldWlsbGVcIixcbiAgICBcImZldXRyZVwiLFxuICAgIFwiZmXMgXZyaWVyXCIsXG4gICAgXCJmaWFzY29cIixcbiAgICBcImZpY2VsZXJcIixcbiAgICBcImZpY3RpZlwiLFxuICAgIFwiZmlkZcyAbGVcIixcbiAgICBcImZpZ3VyZVwiLFxuICAgIFwiZmlsYXR1cmVcIixcbiAgICBcImZpbGV0YWdlXCIsXG4gICAgXCJmaWxpZcyAcmVcIixcbiAgICBcImZpbGxldWxcIixcbiAgICBcImZpbG1lclwiLFxuICAgIFwiZmlsb3VcIixcbiAgICBcImZpbHRyZXJcIixcbiAgICBcImZpbmFuY2VyXCIsXG4gICAgXCJmaW5pclwiLFxuICAgIFwiZmlvbGVcIixcbiAgICBcImZpcm1lXCIsXG4gICAgXCJmaXNzdXJlXCIsXG4gICAgXCJmaXhlclwiLFxuICAgIFwiZmxhaXJlclwiLFxuICAgIFwiZmxhbW1lXCIsXG4gICAgXCJmbGFzcXVlXCIsXG4gICAgXCJmbGF0dGV1clwiLFxuICAgIFwiZmxlzIFhdVwiLFxuICAgIFwiZmxlzIBjaGVcIixcbiAgICBcImZsZXVyXCIsXG4gICAgXCJmbGV4aW9uXCIsXG4gICAgXCJmbG9jb25cIixcbiAgICBcImZsb3JlXCIsXG4gICAgXCJmbHVjdHVlclwiLFxuICAgIFwiZmx1aWRlXCIsXG4gICAgXCJmbHV2aWFsXCIsXG4gICAgXCJmb2xpZVwiLFxuICAgIFwiZm9uZGVyaWVcIixcbiAgICBcImZvbmdpYmxlXCIsXG4gICAgXCJmb250YWluZVwiLFxuICAgIFwiZm9yY2VyXCIsXG4gICAgXCJmb3JnZXJvblwiLFxuICAgIFwiZm9ybXVsZXJcIixcbiAgICBcImZvcnR1bmVcIixcbiAgICBcImZvc3NpbGVcIixcbiAgICBcImZvdWRyZVwiLFxuICAgIFwiZm91Z2XMgHJlXCIsXG4gICAgXCJmb3VpbGxlclwiLFxuICAgIFwiZm91bHVyZVwiLFxuICAgIFwiZm91cm1pXCIsXG4gICAgXCJmcmFnaWxlXCIsXG4gICAgXCJmcmFpc2VcIixcbiAgICBcImZyYW5jaGlyXCIsXG4gICAgXCJmcmFwcGVyXCIsXG4gICAgXCJmcmF5ZXVyXCIsXG4gICAgXCJmcmXMgWdhdGVcIixcbiAgICBcImZyZWluZXJcIixcbiAgICBcImZyZWxvblwiLFxuICAgIFwiZnJlzIFtaXJcIixcbiAgICBcImZyZcyBbmXMgXNpZVwiLFxuICAgIFwiZnJlzIByZVwiLFxuICAgIFwiZnJpYWJsZVwiLFxuICAgIFwiZnJpY3Rpb25cIixcbiAgICBcImZyaXNzb25cIixcbiAgICBcImZyaXZvbGVcIixcbiAgICBcImZyb2lkXCIsXG4gICAgXCJmcm9tYWdlXCIsXG4gICAgXCJmcm9udGFsXCIsXG4gICAgXCJmcm90dGVyXCIsXG4gICAgXCJmcnVpdFwiLFxuICAgIFwiZnVnaXRpZlwiLFxuICAgIFwiZnVpdGVcIixcbiAgICBcImZ1cmV1clwiLFxuICAgIFwiZnVyaWV1eFwiLFxuICAgIFwiZnVydGlmXCIsXG4gICAgXCJmdXNpb25cIixcbiAgICBcImZ1dHVyXCIsXG4gICAgXCJnYWduZXJcIixcbiAgICBcImdhbGF4aWVcIixcbiAgICBcImdhbGVyaWVcIixcbiAgICBcImdhbWJhZGVyXCIsXG4gICAgXCJnYXJhbnRpclwiLFxuICAgIFwiZ2FyZGllblwiLFxuICAgIFwiZ2FybmlyXCIsXG4gICAgXCJnYXJyaWd1ZVwiLFxuICAgIFwiZ2F6ZWxsZVwiLFxuICAgIFwiZ2F6b25cIixcbiAgICBcImdlzIFhbnRcIixcbiAgICBcImdlzIFsYXRpbmVcIixcbiAgICBcImdlzIFsdWxlXCIsXG4gICAgXCJnZW5kYXJtZVwiLFxuICAgIFwiZ2XMgW5lzIFyYWxcIixcbiAgICBcImdlzIFuaWVcIixcbiAgICBcImdlbm91XCIsXG4gICAgXCJnZW50aWxcIixcbiAgICBcImdlzIFvbG9naWVcIixcbiAgICBcImdlzIFvbWXMgHRyZVwiLFxuICAgIFwiZ2XMgXJhbml1bVwiLFxuICAgIFwiZ2VybWVcIixcbiAgICBcImdlc3R1ZWxcIixcbiAgICBcImdleXNlclwiLFxuICAgIFwiZ2liaWVyXCIsXG4gICAgXCJnaWNsZXJcIixcbiAgICBcImdpcmFmZVwiLFxuICAgIFwiZ2l2cmVcIixcbiAgICBcImdsYWNlXCIsXG4gICAgXCJnbGFpdmVcIixcbiAgICBcImdsaXNzZXJcIixcbiAgICBcImdsb2JlXCIsXG4gICAgXCJnbG9pcmVcIixcbiAgICBcImdsb3JpZXV4XCIsXG4gICAgXCJnb2xmZXVyXCIsXG4gICAgXCJnb21tZVwiLFxuICAgIFwiZ29uZmxlclwiLFxuICAgIFwiZ29yZ2VcIixcbiAgICBcImdvcmlsbGVcIixcbiAgICBcImdvdWRyb25cIixcbiAgICBcImdvdWZmcmVcIixcbiAgICBcImdvdWxvdFwiLFxuICAgIFwiZ291cGlsbGVcIixcbiAgICBcImdvdXJtYW5kXCIsXG4gICAgXCJnb3V0dGVcIixcbiAgICBcImdyYWR1ZWxcIixcbiAgICBcImdyYWZmaXRpXCIsXG4gICAgXCJncmFpbmVcIixcbiAgICBcImdyYW5kXCIsXG4gICAgXCJncmFwcGluXCIsXG4gICAgXCJncmF0dWl0XCIsXG4gICAgXCJncmF2aXJcIixcbiAgICBcImdyZW5hdFwiLFxuICAgIFwiZ3JpZmZ1cmVcIixcbiAgICBcImdyaWxsZXJcIixcbiAgICBcImdyaW1wZXJcIixcbiAgICBcImdyb2duZXJcIixcbiAgICBcImdyb25kZXJcIixcbiAgICBcImdyb3R0ZVwiLFxuICAgIFwiZ3JvdXBlXCIsXG4gICAgXCJncnVnZXJcIixcbiAgICBcImdydXRpZXJcIixcbiAgICBcImdydXllzIByZVwiLFxuICAgIFwiZ3VlzIFwYXJkXCIsXG4gICAgXCJndWVycmllclwiLFxuICAgIFwiZ3VpZGVcIixcbiAgICBcImd1aW1hdXZlXCIsXG4gICAgXCJndWl0YXJlXCIsXG4gICAgXCJndXN0YXRpZlwiLFxuICAgIFwiZ3ltbmFzdGVcIixcbiAgICBcImd5cm9zdGF0XCIsXG4gICAgXCJoYWJpdHVkZVwiLFxuICAgIFwiaGFjaG9pclwiLFxuICAgIFwiaGFsdGVcIixcbiAgICBcImhhbWVhdVwiLFxuICAgIFwiaGFuZ2FyXCIsXG4gICAgXCJoYW5uZXRvblwiLFxuICAgIFwiaGFyaWNvdFwiLFxuICAgIFwiaGFybW9uaWVcIixcbiAgICBcImhhcnBvblwiLFxuICAgIFwiaGFzYXJkXCIsXG4gICAgXCJoZcyBbGl1bVwiLFxuICAgIFwiaGXMgW1hdG9tZVwiLFxuICAgIFwiaGVyYmVcIixcbiAgICBcImhlzIFyaXNzb25cIixcbiAgICBcImhlcm1pbmVcIixcbiAgICBcImhlzIFyb25cIixcbiAgICBcImhlzIFzaXRlclwiLFxuICAgIFwiaGV1cmV1eFwiLFxuICAgIFwiaGliZXJuZXJcIixcbiAgICBcImhpYm91XCIsXG4gICAgXCJoaWxhcmFudFwiLFxuICAgIFwiaGlzdG9pcmVcIixcbiAgICBcImhpdmVyXCIsXG4gICAgXCJob21hcmRcIixcbiAgICBcImhvbW1hZ2VcIixcbiAgICBcImhvbW9nZcyAbmVcIixcbiAgICBcImhvbm5ldXJcIixcbiAgICBcImhvbm9yZXJcIixcbiAgICBcImhvbnRldXhcIixcbiAgICBcImhvcmRlXCIsXG4gICAgXCJob3Jpem9uXCIsXG4gICAgXCJob3Jsb2dlXCIsXG4gICAgXCJob3Jtb25lXCIsXG4gICAgXCJob3JyaWJsZVwiLFxuICAgIFwiaG91bGV1eFwiLFxuICAgIFwiaG91c3NlXCIsXG4gICAgXCJodWJsb3RcIixcbiAgICBcImh1aWxldXhcIixcbiAgICBcImh1bWFpblwiLFxuICAgIFwiaHVtYmxlXCIsXG4gICAgXCJodW1pZGVcIixcbiAgICBcImh1bW91clwiLFxuICAgIFwiaHVybGVyXCIsXG4gICAgXCJoeWRyb21lbFwiLFxuICAgIFwiaHlnaWXMgG5lXCIsXG4gICAgXCJoeW1uZVwiLFxuICAgIFwiaHlwbm9zZVwiLFxuICAgIFwiaWR5bGxlXCIsXG4gICAgXCJpZ25vcmVyXCIsXG4gICAgXCJpZ3VhbmVcIixcbiAgICBcImlsbGljaXRlXCIsXG4gICAgXCJpbGx1c2lvblwiLFxuICAgIFwiaW1hZ2VcIixcbiAgICBcImltYmliZXJcIixcbiAgICBcImltaXRlclwiLFxuICAgIFwiaW1tZW5zZVwiLFxuICAgIFwiaW1tb2JpbGVcIixcbiAgICBcImltbXVhYmxlXCIsXG4gICAgXCJpbXBhY3RcIixcbiAgICBcImltcGXMgXJpYWxcIixcbiAgICBcImltcGxvcmVyXCIsXG4gICAgXCJpbXBvc2VyXCIsXG4gICAgXCJpbXByaW1lclwiLFxuICAgIFwiaW1wdXRlclwiLFxuICAgIFwiaW5jYXJuZXJcIixcbiAgICBcImluY2VuZGllXCIsXG4gICAgXCJpbmNpZGVudFwiLFxuICAgIFwiaW5jbGluZXJcIixcbiAgICBcImluY29sb3JlXCIsXG4gICAgXCJpbmRleGVyXCIsXG4gICAgXCJpbmRpY2VcIixcbiAgICBcImluZHVjdGlmXCIsXG4gICAgXCJpbmXMgWRpdFwiLFxuICAgIFwiaW5lcHRpZVwiLFxuICAgIFwiaW5leGFjdFwiLFxuICAgIFwiaW5maW5pXCIsXG4gICAgXCJpbmZsaWdlclwiLFxuICAgIFwiaW5mb3JtZXJcIixcbiAgICBcImluZnVzaW9uXCIsXG4gICAgXCJpbmdlzIFyZXJcIixcbiAgICBcImluaGFsZXJcIixcbiAgICBcImluaGliZXJcIixcbiAgICBcImluamVjdGVyXCIsXG4gICAgXCJpbmp1cmVcIixcbiAgICBcImlubm9jZW50XCIsXG4gICAgXCJpbm9jdWxlclwiLFxuICAgIFwiaW5vbmRlclwiLFxuICAgIFwiaW5zY3JpcmVcIixcbiAgICBcImluc2VjdGVcIixcbiAgICBcImluc2lnbmVcIixcbiAgICBcImluc29saXRlXCIsXG4gICAgXCJpbnNwaXJlclwiLFxuICAgIFwiaW5zdGluY3RcIixcbiAgICBcImluc3VsdGVyXCIsXG4gICAgXCJpbnRhY3RcIixcbiAgICBcImludGVuc2VcIixcbiAgICBcImludGltZVwiLFxuICAgIFwiaW50cmlndWVcIixcbiAgICBcImludHVpdGlmXCIsXG4gICAgXCJpbnV0aWxlXCIsXG4gICAgXCJpbnZhc2lvblwiLFxuICAgIFwiaW52ZW50ZXJcIixcbiAgICBcImludml0ZXJcIixcbiAgICBcImludm9xdWVyXCIsXG4gICAgXCJpcm9uaXF1ZVwiLFxuICAgIFwiaXJyYWRpZXJcIixcbiAgICBcImlycmXMgWVsXCIsXG4gICAgXCJpcnJpdGVyXCIsXG4gICAgXCJpc29sZXJcIixcbiAgICBcIml2b2lyZVwiLFxuICAgIFwiaXZyZXNzZVwiLFxuICAgIFwiamFndWFyXCIsXG4gICAgXCJqYWlsbGlyXCIsXG4gICAgXCJqYW1iZVwiLFxuICAgIFwiamFudmllclwiLFxuICAgIFwiamFyZGluXCIsXG4gICAgXCJqYXVnZXJcIixcbiAgICBcImphdW5lXCIsXG4gICAgXCJqYXZlbG90XCIsXG4gICAgXCJqZXRhYmxlXCIsXG4gICAgXCJqZXRvblwiLFxuICAgIFwiamV1ZGlcIixcbiAgICBcImpldW5lc3NlXCIsXG4gICAgXCJqb2luZHJlXCIsXG4gICAgXCJqb25jaGVyXCIsXG4gICAgXCJqb25nbGVyXCIsXG4gICAgXCJqb3VldXJcIixcbiAgICBcImpvdWlzc2lmXCIsXG4gICAgXCJqb3VybmFsXCIsXG4gICAgXCJqb3ZpYWxcIixcbiAgICBcImpveWF1XCIsXG4gICAgXCJqb3lldXhcIixcbiAgICBcImp1YmlsZXJcIixcbiAgICBcImp1Z2VtZW50XCIsXG4gICAgXCJqdW5pb3JcIixcbiAgICBcImp1cG9uXCIsXG4gICAgXCJqdXJpc3RlXCIsXG4gICAgXCJqdXN0aWNlXCIsXG4gICAgXCJqdXRldXhcIixcbiAgICBcImp1dmXMgW5pbGVcIixcbiAgICBcImtheWFrXCIsXG4gICAgXCJraW1vbm9cIixcbiAgICBcImtpb3NxdWVcIixcbiAgICBcImxhYmVsXCIsXG4gICAgXCJsYWJpYWxcIixcbiAgICBcImxhYm91cmVyXCIsXG4gICAgXCJsYWNlzIFyZXJcIixcbiAgICBcImxhY3Rvc2VcIixcbiAgICBcImxhZ3VuZVwiLFxuICAgIFwibGFpbmVcIixcbiAgICBcImxhaXNzZXJcIixcbiAgICBcImxhaXRpZXJcIixcbiAgICBcImxhbWJlYXVcIixcbiAgICBcImxhbWVsbGVcIixcbiAgICBcImxhbXBlXCIsXG4gICAgXCJsYW5jZXVyXCIsXG4gICAgXCJsYW5nYWdlXCIsXG4gICAgXCJsYW50ZXJuZVwiLFxuICAgIFwibGFwaW5cIixcbiAgICBcImxhcmdldXJcIixcbiAgICBcImxhcm1lXCIsXG4gICAgXCJsYXVyaWVyXCIsXG4gICAgXCJsYXZhYm9cIixcbiAgICBcImxhdm9pclwiLFxuICAgIFwibGVjdHVyZVwiLFxuICAgIFwibGXMgWdhbFwiLFxuICAgIFwibGXMgWdlclwiLFxuICAgIFwibGXMgWd1bWVcIixcbiAgICBcImxlc3NpdmVcIixcbiAgICBcImxldHRyZVwiLFxuICAgIFwibGV2aWVyXCIsXG4gICAgXCJsZXhpcXVlXCIsXG4gICAgXCJsZcyBemFyZFwiLFxuICAgIFwibGlhc3NlXCIsXG4gICAgXCJsaWJlzIFyZXJcIixcbiAgICBcImxpYnJlXCIsXG4gICAgXCJsaWNlbmNlXCIsXG4gICAgXCJsaWNvcm5lXCIsXG4gICAgXCJsaWXMgGdlXCIsXG4gICAgXCJsaWXMgHZyZVwiLFxuICAgIFwibGlnYXR1cmVcIixcbiAgICBcImxpZ290ZXJcIixcbiAgICBcImxpZ3VlXCIsXG4gICAgXCJsaW1lclwiLFxuICAgIFwibGltaXRlXCIsXG4gICAgXCJsaW1vbmFkZVwiLFxuICAgIFwibGltcGlkZVwiLFxuICAgIFwibGluZcyBYWlyZVwiLFxuICAgIFwibGluZ290XCIsXG4gICAgXCJsaW9uY2VhdVwiLFxuICAgIFwibGlxdWlkZVwiLFxuICAgIFwibGlzaWXMgHJlXCIsXG4gICAgXCJsaXN0ZXJcIixcbiAgICBcImxpdGhpdW1cIixcbiAgICBcImxpdGlnZVwiLFxuICAgIFwibGl0dG9yYWxcIixcbiAgICBcImxpdnJldXJcIixcbiAgICBcImxvZ2lxdWVcIixcbiAgICBcImxvaW50YWluXCIsXG4gICAgXCJsb2lzaXJcIixcbiAgICBcImxvbWJyaWNcIixcbiAgICBcImxvdGVyaWVcIixcbiAgICBcImxvdWVyXCIsXG4gICAgXCJsb3VyZFwiLFxuICAgIFwibG91dHJlXCIsXG4gICAgXCJsb3V2ZVwiLFxuICAgIFwibG95YWxcIixcbiAgICBcImx1YmllXCIsXG4gICAgXCJsdWNpZGVcIixcbiAgICBcImx1Y3JhdGlmXCIsXG4gICAgXCJsdWV1clwiLFxuICAgIFwibHVndWJyZVwiLFxuICAgIFwibHVpc2FudFwiLFxuICAgIFwibHVtaWXMgHJlXCIsXG4gICAgXCJsdW5haXJlXCIsXG4gICAgXCJsdW5kaVwiLFxuICAgIFwibHVyb25cIixcbiAgICBcImx1dHRlclwiLFxuICAgIFwibHV4dWV1eFwiLFxuICAgIFwibWFjaGluZVwiLFxuICAgIFwibWFnYXNpblwiLFxuICAgIFwibWFnZW50YVwiLFxuICAgIFwibWFnaXF1ZVwiLFxuICAgIFwibWFpZ3JlXCIsXG4gICAgXCJtYWlsbG9uXCIsXG4gICAgXCJtYWludGllblwiLFxuICAgIFwibWFpcmllXCIsXG4gICAgXCJtYWlzb25cIixcbiAgICBcIm1ham9yZXJcIixcbiAgICBcIm1hbGF4ZXJcIixcbiAgICBcIm1hbGXMgWZpY2VcIixcbiAgICBcIm1hbGhldXJcIixcbiAgICBcIm1hbGljZVwiLFxuICAgIFwibWFsbGV0dGVcIixcbiAgICBcIm1hbW1vdXRoXCIsXG4gICAgXCJtYW5kYXRlclwiLFxuICAgIFwibWFuaWFibGVcIixcbiAgICBcIm1hbnF1YW50XCIsXG4gICAgXCJtYW50ZWF1XCIsXG4gICAgXCJtYW51ZWxcIixcbiAgICBcIm1hcmF0aG9uXCIsXG4gICAgXCJtYXJicmVcIixcbiAgICBcIm1hcmNoYW5kXCIsXG4gICAgXCJtYXJkaVwiLFxuICAgIFwibWFyaXRpbWVcIixcbiAgICBcIm1hcnF1ZXVyXCIsXG4gICAgXCJtYXJyb25cIixcbiAgICBcIm1hcnRlbGVyXCIsXG4gICAgXCJtYXNjb3R0ZVwiLFxuICAgIFwibWFzc2lmXCIsXG4gICAgXCJtYXRlzIFyaWVsXCIsXG4gICAgXCJtYXRpZcyAcmVcIixcbiAgICBcIm1hdHJhcXVlXCIsXG4gICAgXCJtYXVkaXJlXCIsXG4gICAgXCJtYXVzc2FkZVwiLFxuICAgIFwibWF1dmVcIixcbiAgICBcIm1heGltYWxcIixcbiAgICBcIm1lzIFjaGFudFwiLFxuICAgIFwibWXMgWNvbm51XCIsXG4gICAgXCJtZcyBZGFpbGxlXCIsXG4gICAgXCJtZcyBZGVjaW5cIixcbiAgICBcIm1lzIFkaXRlclwiLFxuICAgIFwibWXMgWR1c2VcIixcbiAgICBcIm1laWxsZXVyXCIsXG4gICAgXCJtZcyBbGFuZ2VcIixcbiAgICBcIm1lzIFsb2RpZVwiLFxuICAgIFwibWVtYnJlXCIsXG4gICAgXCJtZcyBbW9pcmVcIixcbiAgICBcIm1lbmFjZXJcIixcbiAgICBcIm1lbmVyXCIsXG4gICAgXCJtZW5oaXJcIixcbiAgICBcIm1lbnNvbmdlXCIsXG4gICAgXCJtZW50b3JcIixcbiAgICBcIm1lcmNyZWRpXCIsXG4gICAgXCJtZcyBcml0ZVwiLFxuICAgIFwibWVybGVcIixcbiAgICBcIm1lc3NhZ2VyXCIsXG4gICAgXCJtZXN1cmVcIixcbiAgICBcIm1lzIF0YWxcIixcbiAgICBcIm1lzIF0ZcyBb3JlXCIsXG4gICAgXCJtZcyBdGhvZGVcIixcbiAgICBcIm1lzIF0aWVyXCIsXG4gICAgXCJtZXVibGVcIixcbiAgICBcIm1pYXVsZXJcIixcbiAgICBcIm1pY3JvYmVcIixcbiAgICBcIm1pZXR0ZVwiLFxuICAgIFwibWlnbm9uXCIsXG4gICAgXCJtaWdyZXJcIixcbiAgICBcIm1pbGlldVwiLFxuICAgIFwibWlsbGlvblwiLFxuICAgIFwibWltaXF1ZVwiLFxuICAgIFwibWluY2VcIixcbiAgICBcIm1pbmXMgXJhbFwiLFxuICAgIFwibWluaW1hbFwiLFxuICAgIFwibWlub3JlclwiLFxuICAgIFwibWludXRlXCIsXG4gICAgXCJtaXJhY2xlXCIsXG4gICAgXCJtaXJvaXRlclwiLFxuICAgIFwibWlzc2lsZVwiLFxuICAgIFwibWl4dGVcIixcbiAgICBcIm1vYmlsZVwiLFxuICAgIFwibW9kZXJuZVwiLFxuICAgIFwibW9lbGxldXhcIixcbiAgICBcIm1vbmRpYWxcIixcbiAgICBcIm1vbml0ZXVyXCIsXG4gICAgXCJtb25uYWllXCIsXG4gICAgXCJtb25vdG9uZVwiLFxuICAgIFwibW9uc3RyZVwiLFxuICAgIFwibW9udGFnbmVcIixcbiAgICBcIm1vbnVtZW50XCIsXG4gICAgXCJtb3F1ZXVyXCIsXG4gICAgXCJtb3JjZWF1XCIsXG4gICAgXCJtb3JzdXJlXCIsXG4gICAgXCJtb3J0aWVyXCIsXG4gICAgXCJtb3RldXJcIixcbiAgICBcIm1vdGlmXCIsXG4gICAgXCJtb3VjaGVcIixcbiAgICBcIm1vdWZsZVwiLFxuICAgIFwibW91bGluXCIsXG4gICAgXCJtb3Vzc29uXCIsXG4gICAgXCJtb3V0b25cIixcbiAgICBcIm1vdXZhbnRcIixcbiAgICBcIm11bHRpcGxlXCIsXG4gICAgXCJtdW5pdGlvblwiLFxuICAgIFwibXVyYWlsbGVcIixcbiAgICBcIm11cmXMgG5lXCIsXG4gICAgXCJtdXJtdXJlXCIsXG4gICAgXCJtdXNjbGVcIixcbiAgICBcIm11c2XMgXVtXCIsXG4gICAgXCJtdXNpY2llblwiLFxuICAgIFwibXV0YXRpb25cIixcbiAgICBcIm11dGVyXCIsXG4gICAgXCJtdXR1ZWxcIixcbiAgICBcIm15cmlhZGVcIixcbiAgICBcIm15cnRpbGxlXCIsXG4gICAgXCJteXN0ZcyAcmVcIixcbiAgICBcIm15dGhpcXVlXCIsXG4gICAgXCJuYWdldXJcIixcbiAgICBcIm5hcHBlXCIsXG4gICAgXCJuYXJxdW9pc1wiLFxuICAgIFwibmFycmVyXCIsXG4gICAgXCJuYXRhdGlvblwiLFxuICAgIFwibmF0aW9uXCIsXG4gICAgXCJuYXR1cmVcIixcbiAgICBcIm5hdWZyYWdlXCIsXG4gICAgXCJuYXV0aXF1ZVwiLFxuICAgIFwibmF2aXJlXCIsXG4gICAgXCJuZcyBYnVsZXV4XCIsXG4gICAgXCJuZWN0YXJcIixcbiAgICBcIm5lzIFmYXN0ZVwiLFxuICAgIFwibmXMgWdhdGlvblwiLFxuICAgIFwibmXMgWdsaWdlclwiLFxuICAgIFwibmXMgWdvY2llclwiLFxuICAgIFwibmVpZ2VcIixcbiAgICBcIm5lcnZldXhcIixcbiAgICBcIm5ldHRveWVyXCIsXG4gICAgXCJuZXVyb25lXCIsXG4gICAgXCJuZXV0cm9uXCIsXG4gICAgXCJuZXZldVwiLFxuICAgIFwibmljaGVcIixcbiAgICBcIm5pY2tlbFwiLFxuICAgIFwibml0cmF0ZVwiLFxuICAgIFwibml2ZWF1XCIsXG4gICAgXCJub2JsZVwiLFxuICAgIFwibm9jaWZcIixcbiAgICBcIm5vY3R1cm5lXCIsXG4gICAgXCJub2lyY2V1clwiLFxuICAgIFwibm9pc2V0dGVcIixcbiAgICBcIm5vbWFkZVwiLFxuICAgIFwibm9tYnJldXhcIixcbiAgICBcIm5vbW1lclwiLFxuICAgIFwibm9ybWF0aWZcIixcbiAgICBcIm5vdGFibGVcIixcbiAgICBcIm5vdGlmaWVyXCIsXG4gICAgXCJub3RvaXJlXCIsXG4gICAgXCJub3VycmlyXCIsXG4gICAgXCJub3V2ZWF1XCIsXG4gICAgXCJub3ZhdGV1clwiLFxuICAgIFwibm92ZW1icmVcIixcbiAgICBcIm5vdmljZVwiLFxuICAgIFwibnVhZ2VcIixcbiAgICBcIm51YW5jZXJcIixcbiAgICBcIm51aXJlXCIsXG4gICAgXCJudWlzaWJsZVwiLFxuICAgIFwibnVtZcyBcm9cIixcbiAgICBcIm51cHRpYWxcIixcbiAgICBcIm51cXVlXCIsXG4gICAgXCJudXRyaXRpZlwiLFxuICAgIFwib2JlzIFpclwiLFxuICAgIFwib2JqZWN0aWZcIixcbiAgICBcIm9ibGlnZXJcIixcbiAgICBcIm9ic2N1clwiLFxuICAgIFwib2JzZXJ2ZXJcIixcbiAgICBcIm9ic3RhY2xlXCIsXG4gICAgXCJvYnRlbmlyXCIsXG4gICAgXCJvYnR1cmVyXCIsXG4gICAgXCJvY2Nhc2lvblwiLFxuICAgIFwib2NjdXBlclwiLFxuICAgIFwib2NlzIFhblwiLFxuICAgIFwib2N0b2JyZVwiLFxuICAgIFwib2N0cm95ZXJcIixcbiAgICBcIm9jdHVwbGVyXCIsXG4gICAgXCJvY3VsYWlyZVwiLFxuICAgIFwib2RldXJcIixcbiAgICBcIm9kb3JhbnRcIixcbiAgICBcIm9mZmVuc2VyXCIsXG4gICAgXCJvZmZpY2llclwiLFxuICAgIFwib2ZmcmlyXCIsXG4gICAgXCJvZ2l2ZVwiLFxuICAgIFwib2lzZWF1XCIsXG4gICAgXCJvaXNpbGxvblwiLFxuICAgIFwib2xmYWN0aWZcIixcbiAgICBcIm9saXZpZXJcIixcbiAgICBcIm9tYnJhZ2VcIixcbiAgICBcIm9tZXR0cmVcIixcbiAgICBcIm9uY3R1ZXV4XCIsXG4gICAgXCJvbmR1bGVyXCIsXG4gICAgXCJvbmXMgXJldXhcIixcbiAgICBcIm9uaXJpcXVlXCIsXG4gICAgXCJvcGFsZVwiLFxuICAgIFwib3BhcXVlXCIsXG4gICAgXCJvcGXMgXJlclwiLFxuICAgIFwib3BpbmlvblwiLFxuICAgIFwib3Bwb3J0dW5cIixcbiAgICBcIm9wcHJpbWVyXCIsXG4gICAgXCJvcHRlclwiLFxuICAgIFwib3B0aXF1ZVwiLFxuICAgIFwib3JhZ2V1eFwiLFxuICAgIFwib3JhbmdlXCIsXG4gICAgXCJvcmJpdGVcIixcbiAgICBcIm9yZG9ubmVyXCIsXG4gICAgXCJvcmVpbGxlXCIsXG4gICAgXCJvcmdhbmVcIixcbiAgICBcIm9yZ3VlaWxcIixcbiAgICBcIm9yaWZpY2VcIixcbiAgICBcIm9ybmVtZW50XCIsXG4gICAgXCJvcnF1ZVwiLFxuICAgIFwib3J0aWVcIixcbiAgICBcIm9zY2lsbGVyXCIsXG4gICAgXCJvc21vc2VcIixcbiAgICBcIm9zc2F0dXJlXCIsXG4gICAgXCJvdGFyaWVcIixcbiAgICBcIm91cmFnYW5cIixcbiAgICBcIm91cnNvblwiLFxuICAgIFwib3V0aWxcIixcbiAgICBcIm91dHJhZ2VyXCIsXG4gICAgXCJvdXZyYWdlXCIsXG4gICAgXCJvdmF0aW9uXCIsXG4gICAgXCJveHlkZVwiLFxuICAgIFwib3h5Z2XMgG5lXCIsXG4gICAgXCJvem9uZVwiLFxuICAgIFwicGFpc2libGVcIixcbiAgICBcInBhbGFjZVwiLFxuICAgIFwicGFsbWFyZcyAc1wiLFxuICAgIFwicGFsb3VyZGVcIixcbiAgICBcInBhbHBlclwiLFxuICAgIFwicGFuYWNoZVwiLFxuICAgIFwicGFuZGFcIixcbiAgICBcInBhbmdvbGluXCIsXG4gICAgXCJwYW5pcXVlclwiLFxuICAgIFwicGFubmVhdVwiLFxuICAgIFwicGFub3JhbWFcIixcbiAgICBcInBhbnRhbG9uXCIsXG4gICAgXCJwYXBheWVcIixcbiAgICBcInBhcGllclwiLFxuICAgIFwicGFwb3RlclwiLFxuICAgIFwicGFweXJ1c1wiLFxuICAgIFwicGFyYWRveGVcIixcbiAgICBcInBhcmNlbGxlXCIsXG4gICAgXCJwYXJlc3NlXCIsXG4gICAgXCJwYXJmdW1lclwiLFxuICAgIFwicGFybGVyXCIsXG4gICAgXCJwYXJvbGVcIixcbiAgICBcInBhcnJhaW5cIixcbiAgICBcInBhcnNlbWVyXCIsXG4gICAgXCJwYXJ0YWdlclwiLFxuICAgIFwicGFydXJlXCIsXG4gICAgXCJwYXJ2ZW5pclwiLFxuICAgIFwicGFzc2lvblwiLFxuICAgIFwicGFzdGXMgHF1ZVwiLFxuICAgIFwicGF0ZXJuZWxcIixcbiAgICBcInBhdGllbmNlXCIsXG4gICAgXCJwYXRyb25cIixcbiAgICBcInBhdmlsbG9uXCIsXG4gICAgXCJwYXZvaXNlclwiLFxuICAgIFwicGF5ZXJcIixcbiAgICBcInBheXNhZ2VcIixcbiAgICBcInBlaWduZVwiLFxuICAgIFwicGVpbnRyZVwiLFxuICAgIFwicGVsYWdlXCIsXG4gICAgXCJwZcyBbGljYW5cIixcbiAgICBcInBlbGxlXCIsXG4gICAgXCJwZWxvdXNlXCIsXG4gICAgXCJwZWx1Y2hlXCIsXG4gICAgXCJwZW5kdWxlXCIsXG4gICAgXCJwZcyBbmXMgXRyZXJcIixcbiAgICBcInBlzIFuaWJsZVwiLFxuICAgIFwicGVuc2lmXCIsXG4gICAgXCJwZcyBbnVyaWVcIixcbiAgICBcInBlzIFwaXRlXCIsXG4gICAgXCJwZcyBcGx1bVwiLFxuICAgIFwicGVyZHJpeFwiLFxuICAgIFwicGVyZm9yZXJcIixcbiAgICBcInBlzIFyaW9kZVwiLFxuICAgIFwicGVybXV0ZXJcIixcbiAgICBcInBlcnBsZXhlXCIsXG4gICAgXCJwZXJzaWxcIixcbiAgICBcInBlcnRlXCIsXG4gICAgXCJwZXNlclwiLFxuICAgIFwicGXMgXRhbGVcIixcbiAgICBcInBldGl0XCIsXG4gICAgXCJwZcyBdHJpclwiLFxuICAgIFwicGV1cGxlXCIsXG4gICAgXCJwaGFyYW9uXCIsXG4gICAgXCJwaG9iaWVcIixcbiAgICBcInBob3F1ZVwiLFxuICAgIFwicGhvdG9uXCIsXG4gICAgXCJwaHJhc2VcIixcbiAgICBcInBoeXNpcXVlXCIsXG4gICAgXCJwaWFub1wiLFxuICAgIFwicGljdHVyYWxcIixcbiAgICBcInBpZcyAY2VcIixcbiAgICBcInBpZXJyZVwiLFxuICAgIFwicGlldXZyZVwiLFxuICAgIFwicGlsb3RlXCIsXG4gICAgXCJwaW5jZWF1XCIsXG4gICAgXCJwaXBldHRlXCIsXG4gICAgXCJwaXF1ZXJcIixcbiAgICBcInBpcm9ndWVcIixcbiAgICBcInBpc2NpbmVcIixcbiAgICBcInBpc3RvblwiLFxuICAgIFwicGl2b3RlclwiLFxuICAgIFwicGl4ZWxcIixcbiAgICBcInBpenphXCIsXG4gICAgXCJwbGFjYXJkXCIsXG4gICAgXCJwbGFmb25kXCIsXG4gICAgXCJwbGFpc2lyXCIsXG4gICAgXCJwbGFuZXJcIixcbiAgICBcInBsYXF1ZVwiLFxuICAgIFwicGxhc3Ryb25cIixcbiAgICBcInBsYXRlYXVcIixcbiAgICBcInBsZXVyZXJcIixcbiAgICBcInBsZXh1c1wiLFxuICAgIFwicGxpYWdlXCIsXG4gICAgXCJwbG9tYlwiLFxuICAgIFwicGxvbmdlclwiLFxuICAgIFwicGx1aWVcIixcbiAgICBcInBsdW1hZ2VcIixcbiAgICBcInBvY2hldHRlXCIsXG4gICAgXCJwb2XMgXNpZVwiLFxuICAgIFwicG9lzIB0ZVwiLFxuICAgIFwicG9pbnRlXCIsXG4gICAgXCJwb2lyaWVyXCIsXG4gICAgXCJwb2lzc29uXCIsXG4gICAgXCJwb2l2cmVcIixcbiAgICBcInBvbGFpcmVcIixcbiAgICBcInBvbGljaWVyXCIsXG4gICAgXCJwb2xsZW5cIixcbiAgICBcInBvbHlnb25lXCIsXG4gICAgXCJwb21tYWRlXCIsXG4gICAgXCJwb21waWVyXCIsXG4gICAgXCJwb25jdHVlbFwiLFxuICAgIFwicG9uZGXMgXJlclwiLFxuICAgIFwicG9uZXlcIixcbiAgICBcInBvcnRpcXVlXCIsXG4gICAgXCJwb3NpdGlvblwiLFxuICAgIFwicG9zc2XMgWRlclwiLFxuICAgIFwicG9zdHVyZVwiLFxuICAgIFwicG90YWdlclwiLFxuICAgIFwicG90ZWF1XCIsXG4gICAgXCJwb3Rpb25cIixcbiAgICBcInBvdWNlXCIsXG4gICAgXCJwb3VsYWluXCIsXG4gICAgXCJwb3Vtb25cIixcbiAgICBcInBvdXJwcmVcIixcbiAgICBcInBvdXNzaW5cIixcbiAgICBcInBvdXZvaXJcIixcbiAgICBcInByYWlyaWVcIixcbiAgICBcInByYXRpcXVlXCIsXG4gICAgXCJwcmXMgWNpZXV4XCIsXG4gICAgXCJwcmXMgWRpcmVcIixcbiAgICBcInByZcyBZml4ZVwiLFxuICAgIFwicHJlzIFsdWRlXCIsXG4gICAgXCJwcmXMgW5vbVwiLFxuICAgIFwicHJlzIFzZW5jZVwiLFxuICAgIFwicHJlzIF0ZXh0ZVwiLFxuICAgIFwicHJlzIF2b2lyXCIsXG4gICAgXCJwcmltaXRpZlwiLFxuICAgIFwicHJpbmNlXCIsXG4gICAgXCJwcmlzb25cIixcbiAgICBcInByaXZlclwiLFxuICAgIFwicHJvYmxlzIBtZVwiLFxuICAgIFwicHJvY2XMgWRlclwiLFxuICAgIFwicHJvZGlnZVwiLFxuICAgIFwicHJvZm9uZFwiLFxuICAgIFwicHJvZ3JlzIBzXCIsXG4gICAgXCJwcm9pZVwiLFxuICAgIFwicHJvamV0ZXJcIixcbiAgICBcInByb2xvZ3VlXCIsXG4gICAgXCJwcm9tZW5lclwiLFxuICAgIFwicHJvcHJlXCIsXG4gICAgXCJwcm9zcGXMgHJlXCIsXG4gICAgXCJwcm90ZcyBZ2VyXCIsXG4gICAgXCJwcm91ZXNzZVwiLFxuICAgIFwicHJvdmVyYmVcIixcbiAgICBcInBydWRlbmNlXCIsXG4gICAgXCJwcnVuZWF1XCIsXG4gICAgXCJwc3ljaG9zZVwiLFxuICAgIFwicHVibGljXCIsXG4gICAgXCJwdWNlcm9uXCIsXG4gICAgXCJwdWlzZXJcIixcbiAgICBcInB1bHBlXCIsXG4gICAgXCJwdWxzYXJcIixcbiAgICBcInB1bmFpc2VcIixcbiAgICBcInB1bml0aWZcIixcbiAgICBcInB1cGl0cmVcIixcbiAgICBcInB1cmlmaWVyXCIsXG4gICAgXCJwdXp6bGVcIixcbiAgICBcInB5cmFtaWRlXCIsXG4gICAgXCJxdWFzYXJcIixcbiAgICBcInF1ZXJlbGxlXCIsXG4gICAgXCJxdWVzdGlvblwiLFxuICAgIFwicXVpZcyBdHVkZVwiLFxuICAgIFwicXVpdHRlclwiLFxuICAgIFwicXVvdGllbnRcIixcbiAgICBcInJhY2luZVwiLFxuICAgIFwicmFjb250ZXJcIixcbiAgICBcInJhZGlldXhcIixcbiAgICBcInJhZ29uZGluXCIsXG4gICAgXCJyYWlkZXVyXCIsXG4gICAgXCJyYWlzaW5cIixcbiAgICBcInJhbGVudGlyXCIsXG4gICAgXCJyYWxsb25nZVwiLFxuICAgIFwicmFtYXNzZXJcIixcbiAgICBcInJhcGlkZVwiLFxuICAgIFwicmFzYWdlXCIsXG4gICAgXCJyYXRpc3NlclwiLFxuICAgIFwicmF2YWdlclwiLFxuICAgIFwicmF2aW5cIixcbiAgICBcInJheW9ubmVyXCIsXG4gICAgXCJyZcyBYWN0aWZcIixcbiAgICBcInJlzIFhZ2lyXCIsXG4gICAgXCJyZcyBYWxpc2VyXCIsXG4gICAgXCJyZcyBYW5pbWVyXCIsXG4gICAgXCJyZWNldm9pclwiLFxuICAgIFwicmXMgWNpdGVyXCIsXG4gICAgXCJyZcyBY2xhbWVyXCIsXG4gICAgXCJyZcyBY29sdGVyXCIsXG4gICAgXCJyZWNydXRlclwiLFxuICAgIFwicmVjdWxlclwiLFxuICAgIFwicmVjeWNsZXJcIixcbiAgICBcInJlzIFkaWdlclwiLFxuICAgIFwicmVkb3V0ZXJcIixcbiAgICBcInJlZmFpcmVcIixcbiAgICBcInJlzIFmbGV4ZVwiLFxuICAgIFwicmXMgWZvcm1lclwiLFxuICAgIFwicmVmcmFpblwiLFxuICAgIFwicmVmdWdlXCIsXG4gICAgXCJyZcyBZ2FsaWVuXCIsXG4gICAgXCJyZcyBZ2lvblwiLFxuICAgIFwicmXMgWdsYWdlXCIsXG4gICAgXCJyZcyBZ3VsaWVyXCIsXG4gICAgXCJyZcyBaXRlzIFyZXJcIixcbiAgICBcInJlamV0ZXJcIixcbiAgICBcInJlam91ZXJcIixcbiAgICBcInJlbGF0aWZcIixcbiAgICBcInJlbGV2ZXJcIixcbiAgICBcInJlbGllZlwiLFxuICAgIFwicmVtYXJxdWVcIixcbiAgICBcInJlbWXMgGRlXCIsXG4gICAgXCJyZW1pc2VcIixcbiAgICBcInJlbW9udGVyXCIsXG4gICAgXCJyZW1wbGlyXCIsXG4gICAgXCJyZW11ZXJcIixcbiAgICBcInJlbmFyZFwiLFxuICAgIFwicmVuZm9ydFwiLFxuICAgIFwicmVuaWZsZXJcIixcbiAgICBcInJlbm9uY2VyXCIsXG4gICAgXCJyZW50cmVyXCIsXG4gICAgXCJyZW52b2lcIixcbiAgICBcInJlcGxpZXJcIixcbiAgICBcInJlcG9ydGVyXCIsXG4gICAgXCJyZXByaXNlXCIsXG4gICAgXCJyZXB0aWxlXCIsXG4gICAgXCJyZXF1aW5cIixcbiAgICBcInJlzIFzZXJ2ZVwiLFxuICAgIFwicmXMgXNpbmV1eFwiLFxuICAgIFwicmXMgXNvdWRyZVwiLFxuICAgIFwicmVzcGVjdFwiLFxuICAgIFwicmVzdGVyXCIsXG4gICAgXCJyZcyBc3VsdGF0XCIsXG4gICAgXCJyZcyBdGFibGlyXCIsXG4gICAgXCJyZXRlbmlyXCIsXG4gICAgXCJyZcyBdGljdWxlXCIsXG4gICAgXCJyZXRvbWJlclwiLFxuICAgIFwicmV0cmFjZXJcIixcbiAgICBcInJlzIF1bmlvblwiLFxuICAgIFwicmXMgXVzc2lyXCIsXG4gICAgXCJyZXZhbmNoZVwiLFxuICAgIFwicmV2aXZyZVwiLFxuICAgIFwicmXMgXZvbHRlXCIsXG4gICAgXCJyZcyBdnVsc2lmXCIsXG4gICAgXCJyaWNoZXNzZVwiLFxuICAgIFwicmlkZWF1XCIsXG4gICAgXCJyaWV1clwiLFxuICAgIFwicmlnaWRlXCIsXG4gICAgXCJyaWdvbGVyXCIsXG4gICAgXCJyaW5jZXJcIixcbiAgICBcInJpcG9zdGVyXCIsXG4gICAgXCJyaXNpYmxlXCIsXG4gICAgXCJyaXNxdWVcIixcbiAgICBcInJpdHVlbFwiLFxuICAgIFwicml2YWxcIixcbiAgICBcInJpdmllzIByZVwiLFxuICAgIFwicm9jaGV1eFwiLFxuICAgIFwicm9tYW5jZVwiLFxuICAgIFwicm9tcHJlXCIsXG4gICAgXCJyb25jZVwiLFxuICAgIFwicm9uZGluXCIsXG4gICAgXCJyb3NlYXVcIixcbiAgICBcInJvc2llclwiLFxuICAgIFwicm90YXRpZlwiLFxuICAgIFwicm90b3JcIixcbiAgICBcInJvdHVsZVwiLFxuICAgIFwicm91Z2VcIixcbiAgICBcInJvdWlsbGVcIixcbiAgICBcInJvdWxlYXVcIixcbiAgICBcInJvdXRpbmVcIixcbiAgICBcInJveWF1bWVcIixcbiAgICBcInJ1YmFuXCIsXG4gICAgXCJydWJpc1wiLFxuICAgIFwicnVjaGVcIixcbiAgICBcInJ1ZWxsZVwiLFxuICAgIFwicnVndWV1eFwiLFxuICAgIFwicnVpbmVyXCIsXG4gICAgXCJydWlzc2VhdVwiLFxuICAgIFwicnVzZXJcIixcbiAgICBcInJ1c3RpcXVlXCIsXG4gICAgXCJyeXRobWVcIixcbiAgICBcInNhYmxlclwiLFxuICAgIFwic2Fib3RlclwiLFxuICAgIFwic2FicmVcIixcbiAgICBcInNhY29jaGVcIixcbiAgICBcInNhZmFyaVwiLFxuICAgIFwic2FnZXNzZVwiLFxuICAgIFwic2Fpc2lyXCIsXG4gICAgXCJzYWxhZGVcIixcbiAgICBcInNhbGl2ZVwiLFxuICAgIFwic2Fsb25cIixcbiAgICBcInNhbHVlclwiLFxuICAgIFwic2FtZWRpXCIsXG4gICAgXCJzYW5jdGlvblwiLFxuICAgIFwic2FuZ2xpZXJcIixcbiAgICBcInNhcmNhc21lXCIsXG4gICAgXCJzYXJkaW5lXCIsXG4gICAgXCJzYXR1cmVyXCIsXG4gICAgXCJzYXVncmVudVwiLFxuICAgIFwic2F1bW9uXCIsXG4gICAgXCJzYXV0ZXJcIixcbiAgICBcInNhdXZhZ2VcIixcbiAgICBcInNhdmFudFwiLFxuICAgIFwic2F2b25uZXJcIixcbiAgICBcInNjYWxwZWxcIixcbiAgICBcInNjYW5kYWxlXCIsXG4gICAgXCJzY2XMgWxlzIFyYXRcIixcbiAgICBcInNjZcyBbmFyaW9cIixcbiAgICBcInNjZXB0cmVcIixcbiAgICBcInNjaGXMgW1hXCIsXG4gICAgXCJzY2llbmNlXCIsXG4gICAgXCJzY2luZGVyXCIsXG4gICAgXCJzY29yZVwiLFxuICAgIFwic2NydXRpblwiLFxuICAgIFwic2N1bHB0ZXJcIixcbiAgICBcInNlzIFhbmNlXCIsXG4gICAgXCJzZcyBY2FibGVcIixcbiAgICBcInNlzIFjaGVyXCIsXG4gICAgXCJzZWNvdWVyXCIsXG4gICAgXCJzZcyBY3JlzIF0ZXJcIixcbiAgICBcInNlzIFkYXRpZlwiLFxuICAgIFwic2XMgWR1aXJlXCIsXG4gICAgXCJzZWlnbmV1clwiLFxuICAgIFwic2XMgWpvdXJcIixcbiAgICBcInNlzIFsZWN0aWZcIixcbiAgICBcInNlbWFpbmVcIixcbiAgICBcInNlbWJsZXJcIixcbiAgICBcInNlbWVuY2VcIixcbiAgICBcInNlzIFtaW5hbFwiLFxuICAgIFwic2XMgW5hdGV1clwiLFxuICAgIFwic2Vuc2libGVcIixcbiAgICBcInNlbnRlbmNlXCIsXG4gICAgXCJzZcyBcGFyZXJcIixcbiAgICBcInNlzIFxdWVuY2VcIixcbiAgICBcInNlcmVpblwiLFxuICAgIFwic2VyZ2VudFwiLFxuICAgIFwic2XMgXJpZXV4XCIsXG4gICAgXCJzZXJydXJlXCIsXG4gICAgXCJzZcyBcnVtXCIsXG4gICAgXCJzZXJ2aWNlXCIsXG4gICAgXCJzZcyBc2FtZVwiLFxuICAgIFwic2XMgXZpclwiLFxuICAgIFwic2V2cmFnZVwiLFxuICAgIFwic2V4dHVwbGVcIixcbiAgICBcInNpZGXMgXJhbFwiLFxuICAgIFwic2llzIBjbGVcIixcbiAgICBcInNpZcyBZ2VyXCIsXG4gICAgXCJzaWZmbGVyXCIsXG4gICAgXCJzaWdsZVwiLFxuICAgIFwic2lnbmFsXCIsXG4gICAgXCJzaWxlbmNlXCIsXG4gICAgXCJzaWxpY2l1bVwiLFxuICAgIFwic2ltcGxlXCIsXG4gICAgXCJzaW5jZcyAcmVcIixcbiAgICBcInNpbmlzdHJlXCIsXG4gICAgXCJzaXBob25cIixcbiAgICBcInNpcm9wXCIsXG4gICAgXCJzaXNtaXF1ZVwiLFxuICAgIFwic2l0dWVyXCIsXG4gICAgXCJza2llclwiLFxuICAgIFwic29jaWFsXCIsXG4gICAgXCJzb2NsZVwiLFxuICAgIFwic29kaXVtXCIsXG4gICAgXCJzb2lnbmV1eFwiLFxuICAgIFwic29sZGF0XCIsXG4gICAgXCJzb2xlaWxcIixcbiAgICBcInNvbGl0dWRlXCIsXG4gICAgXCJzb2x1YmxlXCIsXG4gICAgXCJzb21icmVcIixcbiAgICBcInNvbW1laWxcIixcbiAgICBcInNvbW5vbGVyXCIsXG4gICAgXCJzb25kZVwiLFxuICAgIFwic29uZ2V1clwiLFxuICAgIFwic29ubmV0dGVcIixcbiAgICBcInNvbm9yZVwiLFxuICAgIFwic29yY2llclwiLFxuICAgIFwic29ydGlyXCIsXG4gICAgXCJzb3NpZVwiLFxuICAgIFwic290dGlzZVwiLFxuICAgIFwic291Y2lldXhcIixcbiAgICBcInNvdWR1cmVcIixcbiAgICBcInNvdWZmbGVcIixcbiAgICBcInNvdWxldmVyXCIsXG4gICAgXCJzb3VwYXBlXCIsXG4gICAgXCJzb3VyY2VcIixcbiAgICBcInNvdXRpcmVyXCIsXG4gICAgXCJzb3V2ZW5pclwiLFxuICAgIFwic3BhY2lldXhcIixcbiAgICBcInNwYXRpYWxcIixcbiAgICBcInNwZcyBY2lhbFwiLFxuICAgIFwic3BoZcyAcmVcIixcbiAgICBcInNwaXJhbFwiLFxuICAgIFwic3RhYmxlXCIsXG4gICAgXCJzdGF0aW9uXCIsXG4gICAgXCJzdGVybnVtXCIsXG4gICAgXCJzdGltdWx1c1wiLFxuICAgIFwic3RpcHVsZXJcIixcbiAgICBcInN0cmljdFwiLFxuICAgIFwic3R1ZGlldXhcIixcbiAgICBcInN0dXBldXJcIixcbiAgICBcInN0eWxpc3RlXCIsXG4gICAgXCJzdWJsaW1lXCIsXG4gICAgXCJzdWJzdHJhdFwiLFxuICAgIFwic3VidGlsXCIsXG4gICAgXCJzdWJ2ZW5pclwiLFxuICAgIFwic3VjY2XMgHNcIixcbiAgICBcInN1Y3JlXCIsXG4gICAgXCJzdWZmaXhlXCIsXG4gICAgXCJzdWdnZcyBcmVyXCIsXG4gICAgXCJzdWl2ZXVyXCIsXG4gICAgXCJzdWxmYXRlXCIsXG4gICAgXCJzdXBlcmJlXCIsXG4gICAgXCJzdXBwbGllclwiLFxuICAgIFwic3VyZmFjZVwiLFxuICAgIFwic3VyaWNhdGVcIixcbiAgICBcInN1cm1lbmVyXCIsXG4gICAgXCJzdXJwcmlzZVwiLFxuICAgIFwic3Vyc2F1dFwiLFxuICAgIFwic3VydmllXCIsXG4gICAgXCJzdXNwZWN0XCIsXG4gICAgXCJzeWxsYWJlXCIsXG4gICAgXCJzeW1ib2xlXCIsXG4gICAgXCJzeW1lzIF0cmllXCIsXG4gICAgXCJzeW5hcHNlXCIsXG4gICAgXCJzeW50YXhlXCIsXG4gICAgXCJzeXN0ZcyAbWVcIixcbiAgICBcInRhYmFjXCIsXG4gICAgXCJ0YWJsaWVyXCIsXG4gICAgXCJ0YWN0aWxlXCIsXG4gICAgXCJ0YWlsbGVyXCIsXG4gICAgXCJ0YWxlbnRcIixcbiAgICBcInRhbGlzbWFuXCIsXG4gICAgXCJ0YWxvbm5lclwiLFxuICAgIFwidGFtYm91clwiLFxuICAgIFwidGFtaXNlclwiLFxuICAgIFwidGFuZ2libGVcIixcbiAgICBcInRhcGlzXCIsXG4gICAgXCJ0YXF1aW5lclwiLFxuICAgIFwidGFyZGVyXCIsXG4gICAgXCJ0YXJpZlwiLFxuICAgIFwidGFydGluZVwiLFxuICAgIFwidGFzc2VcIixcbiAgICBcInRhdGFtaVwiLFxuICAgIFwidGF0b3VhZ2VcIixcbiAgICBcInRhdXBlXCIsXG4gICAgXCJ0YXVyZWF1XCIsXG4gICAgXCJ0YXhlclwiLFxuICAgIFwidGXMgW1vaW5cIixcbiAgICBcInRlbXBvcmVsXCIsXG4gICAgXCJ0ZW5haWxsZVwiLFxuICAgIFwidGVuZHJlXCIsXG4gICAgXCJ0ZW5ldXJcIixcbiAgICBcInRlbmlyXCIsXG4gICAgXCJ0ZW5zaW9uXCIsXG4gICAgXCJ0ZXJtaW5lclwiLFxuICAgIFwidGVybmVcIixcbiAgICBcInRlcnJpYmxlXCIsXG4gICAgXCJ0ZcyBdGluZVwiLFxuICAgIFwidGV4dGVcIixcbiAgICBcInRoZcyAbWVcIixcbiAgICBcInRoZcyBb3JpZVwiLFxuICAgIFwidGhlzIFyYXBpZVwiLFxuICAgIFwidGhvcmF4XCIsXG4gICAgXCJ0aWJpYVwiLFxuICAgIFwidGllzIBkZVwiLFxuICAgIFwidGltaWRlXCIsXG4gICAgXCJ0aXJlbGlyZVwiLFxuICAgIFwidGlyb2lyXCIsXG4gICAgXCJ0aXNzdVwiLFxuICAgIFwidGl0YW5lXCIsXG4gICAgXCJ0aXRyZVwiLFxuICAgIFwidGl0dWJlclwiLFxuICAgIFwidG9ib2dnYW5cIixcbiAgICBcInRvbGXMgXJhbnRcIixcbiAgICBcInRvbWF0ZVwiLFxuICAgIFwidG9uaXF1ZVwiLFxuICAgIFwidG9ubmVhdVwiLFxuICAgIFwidG9wb255bWVcIixcbiAgICBcInRvcmNoZVwiLFxuICAgIFwidG9yZHJlXCIsXG4gICAgXCJ0b3JuYWRlXCIsXG4gICAgXCJ0b3JwaWxsZVwiLFxuICAgIFwidG9ycmVudFwiLFxuICAgIFwidG9yc2VcIixcbiAgICBcInRvcnR1ZVwiLFxuICAgIFwidG90ZW1cIixcbiAgICBcInRvdWNoZXJcIixcbiAgICBcInRvdXJuYWdlXCIsXG4gICAgXCJ0b3Vzc2VyXCIsXG4gICAgXCJ0b3hpbmVcIixcbiAgICBcInRyYWN0aW9uXCIsXG4gICAgXCJ0cmFmaWNcIixcbiAgICBcInRyYWdpcXVlXCIsXG4gICAgXCJ0cmFoaXJcIixcbiAgICBcInRyYWluXCIsXG4gICAgXCJ0cmFuY2hlclwiLFxuICAgIFwidHJhdmFpbFwiLFxuICAgIFwidHJlzIBmbGVcIixcbiAgICBcInRyZW1wZXJcIixcbiAgICBcInRyZcyBc29yXCIsXG4gICAgXCJ0cmV1aWxcIixcbiAgICBcInRyaWFnZVwiLFxuICAgIFwidHJpYnVuYWxcIixcbiAgICBcInRyaWNvdGVyXCIsXG4gICAgXCJ0cmlsb2dpZVwiLFxuICAgIFwidHJpb21waGVcIixcbiAgICBcInRyaXBsZXJcIixcbiAgICBcInRyaXR1cmVyXCIsXG4gICAgXCJ0cml2aWFsXCIsXG4gICAgXCJ0cm9tYm9uZVwiLFxuICAgIFwidHJvbmNcIixcbiAgICBcInRyb3BpY2FsXCIsXG4gICAgXCJ0cm91cGVhdVwiLFxuICAgIFwidHVpbGVcIixcbiAgICBcInR1bGlwZVwiLFxuICAgIFwidHVtdWx0ZVwiLFxuICAgIFwidHVubmVsXCIsXG4gICAgXCJ0dXJiaW5lXCIsXG4gICAgXCJ0dXRldXJcIixcbiAgICBcInR1dG95ZXJcIixcbiAgICBcInR1eWF1XCIsXG4gICAgXCJ0eW1wYW5cIixcbiAgICBcInR5cGhvblwiLFxuICAgIFwidHlwaXF1ZVwiLFxuICAgIFwidHlyYW5cIixcbiAgICBcInVidWVzcXVlXCIsXG4gICAgXCJ1bHRpbWVcIixcbiAgICBcInVsdHJhc29uXCIsXG4gICAgXCJ1bmFuaW1lXCIsXG4gICAgXCJ1bmlmaWVyXCIsXG4gICAgXCJ1bmlvblwiLFxuICAgIFwidW5pcXVlXCIsXG4gICAgXCJ1bml0YWlyZVwiLFxuICAgIFwidW5pdmVyc1wiLFxuICAgIFwidXJhbml1bVwiLFxuICAgIFwidXJiYWluXCIsXG4gICAgXCJ1cnRpY2FudFwiLFxuICAgIFwidXNhZ2VcIixcbiAgICBcInVzaW5lXCIsXG4gICAgXCJ1c3VlbFwiLFxuICAgIFwidXN1cmVcIixcbiAgICBcInV0aWxlXCIsXG4gICAgXCJ1dG9waWVcIixcbiAgICBcInZhY2FybWVcIixcbiAgICBcInZhY2NpblwiLFxuICAgIFwidmFnYWJvbmRcIixcbiAgICBcInZhZ3VlXCIsXG4gICAgXCJ2YWlsbGFudFwiLFxuICAgIFwidmFpbmNyZVwiLFxuICAgIFwidmFpc3NlYXVcIixcbiAgICBcInZhbGFibGVcIixcbiAgICBcInZhbGlzZVwiLFxuICAgIFwidmFsbG9uXCIsXG4gICAgXCJ2YWx2ZVwiLFxuICAgIFwidmFtcGlyZVwiLFxuICAgIFwidmFuaWxsZVwiLFxuICAgIFwidmFwZXVyXCIsXG4gICAgXCJ2YXJpZXJcIixcbiAgICBcInZhc2V1eFwiLFxuICAgIFwidmFzc2FsXCIsXG4gICAgXCJ2YXN0ZVwiLFxuICAgIFwidmVjdGV1clwiLFxuICAgIFwidmVkZXR0ZVwiLFxuICAgIFwidmXMgWdlzIF0YWxcIixcbiAgICBcInZlzIFoaWN1bGVcIixcbiAgICBcInZlaW5hcmRcIixcbiAgICBcInZlzIFsb2NlXCIsXG4gICAgXCJ2ZW5kcmVkaVwiLFxuICAgIFwidmXMgW5lzIFyZXJcIixcbiAgICBcInZlbmdlclwiLFxuICAgIFwidmVuaW1ldXhcIixcbiAgICBcInZlbnRvdXNlXCIsXG4gICAgXCJ2ZXJkdXJlXCIsXG4gICAgXCJ2ZcyBcmluXCIsXG4gICAgXCJ2ZXJuaXJcIixcbiAgICBcInZlcnJvdVwiLFxuICAgIFwidmVyc2VyXCIsXG4gICAgXCJ2ZXJ0dVwiLFxuICAgIFwidmVzdG9uXCIsXG4gICAgXCJ2ZcyBdGXMgXJhblwiLFxuICAgIFwidmXMgXR1c3RlXCIsXG4gICAgXCJ2ZXhhbnRcIixcbiAgICBcInZleGVyXCIsXG4gICAgXCJ2aWFkdWNcIixcbiAgICBcInZpYW5kZVwiLFxuICAgIFwidmljdG9pcmVcIixcbiAgICBcInZpZGFuZ2VcIixcbiAgICBcInZpZGXMgW9cIixcbiAgICBcInZpZ25ldHRlXCIsXG4gICAgXCJ2aWd1ZXVyXCIsXG4gICAgXCJ2aWxhaW5cIixcbiAgICBcInZpbGxhZ2VcIixcbiAgICBcInZpbmFpZ3JlXCIsXG4gICAgXCJ2aW9sb25cIixcbiAgICBcInZpcGXMgHJlXCIsXG4gICAgXCJ2aXJlbWVudFwiLFxuICAgIFwidmlydHVvc2VcIixcbiAgICBcInZpcnVzXCIsXG4gICAgXCJ2aXNhZ2VcIixcbiAgICBcInZpc2V1clwiLFxuICAgIFwidmlzaW9uXCIsXG4gICAgXCJ2aXNxdWV1eFwiLFxuICAgIFwidmlzdWVsXCIsXG4gICAgXCJ2aXRhbFwiLFxuICAgIFwidml0ZXNzZVwiLFxuICAgIFwidml0aWNvbGVcIixcbiAgICBcInZpdHJpbmVcIixcbiAgICBcInZpdmFjZVwiLFxuICAgIFwidml2aXBhcmVcIixcbiAgICBcInZvY2F0aW9uXCIsXG4gICAgXCJ2b2d1ZXJcIixcbiAgICBcInZvaWxlXCIsXG4gICAgXCJ2b2lzaW5cIixcbiAgICBcInZvaXR1cmVcIixcbiAgICBcInZvbGFpbGxlXCIsXG4gICAgXCJ2b2xjYW5cIixcbiAgICBcInZvbHRpZ2VyXCIsXG4gICAgXCJ2b2x1bWVcIixcbiAgICBcInZvcmFjZVwiLFxuICAgIFwidm9ydGV4XCIsXG4gICAgXCJ2b3RlclwiLFxuICAgIFwidm91bG9pclwiLFxuICAgIFwidm95YWdlXCIsXG4gICAgXCJ2b3llbGxlXCIsXG4gICAgXCJ3YWdvblwiLFxuICAgIFwieGXMgW5vblwiLFxuICAgIFwieWFjaHRcIixcbiAgICBcInplzIBicmVcIixcbiAgICBcInplzIFuaXRoXCIsXG4gICAgXCJ6ZXN0ZVwiLFxuICAgIFwiem9vbG9naWVcIlxuXVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMudG9DYWxsYmFjayA9IChkb1dvcmspID0+IHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpbnB1dCwgY2FsbGJhY2spIHtcbiAgICBsZXQgcmVzXG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IGRvV29yayhpbnB1dClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIGVycilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIG51bGwsIHJlcylcbiAgfVxufVxuXG5leHBvcnRzLnRvQnVmID0gKGRvV29yaywgb3RoZXIpID0+IChpbnB1dCkgPT4ge1xuICBsZXQgcmVzdWx0ID0gZG9Xb3JrKGlucHV0LCBvdGhlcilcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHJlc3VsdCwgJ2hleCcpXG59XG5cbmV4cG9ydHMuZnJvbVN0cmluZyA9IChkb1dvcmssIG90aGVyKSA9PiAoX2lucHV0KSA9PiB7XG4gIGNvbnN0IGlucHV0ID0gQnVmZmVyLmlzQnVmZmVyKF9pbnB1dCkgPyBfaW5wdXQudG9TdHJpbmcoKSA6IF9pbnB1dFxuICByZXR1cm4gZG9Xb3JrKGlucHV0LCBvdGhlcilcbn1cblxuZXhwb3J0cy5mcm9tTnVtYmVyVG8zMkJpdEJ1ZiA9IChkb1dvcmssIG90aGVyKSA9PiAoaW5wdXQpID0+IHtcbiAgbGV0IG51bWJlciA9IGRvV29yayhpbnB1dCwgb3RoZXIpXG4gIGNvbnN0IGJ5dGVzID0gbmV3IEFycmF5KDQpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBieXRlc1tpXSA9IG51bWJlciAmIDB4ZmZcbiAgICBudW1iZXIgPSBudW1iZXIgPj4gOFxuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ5dGVzKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJsYWtlID0gcmVxdWlyZSgnYmxha2VqcycpXG5cbmNvbnN0IHRvQ2FsbGJhY2sgPSByZXF1aXJlKCcuL3V0aWxzJykudG9DYWxsYmFja1xuXG5jb25zdCBtaW5CID0gMHhiMjAxXG5jb25zdCBtaW5TID0gMHhiMjQxXG5cbmNvbnN0IGJsYWtlMmIgPSB7XG4gIGluaXQ6IGJsYWtlLmJsYWtlMmJJbml0LFxuICB1cGRhdGU6IGJsYWtlLmJsYWtlMmJVcGRhdGUsXG4gIGRpZ2VzdDogYmxha2UuYmxha2UyYkZpbmFsXG59XG5cbmNvbnN0IGJsYWtlMnMgPSB7XG4gIGluaXQ6IGJsYWtlLmJsYWtlMnNJbml0LFxuICB1cGRhdGU6IGJsYWtlLmJsYWtlMnNVcGRhdGUsXG4gIGRpZ2VzdDogYmxha2UuYmxha2Uyc0ZpbmFsXG59XG5cbmNvbnN0IG1ha2VCMkhhc2ggPSAoc2l6ZSwgaGYpID0+IHRvQ2FsbGJhY2soKGJ1ZikgPT4ge1xuICBjb25zdCBjdHggPSBoZi5pbml0KHNpemUsIG51bGwpXG4gIGhmLnVwZGF0ZShjdHgsIGJ1ZilcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhmLmRpZ2VzdChjdHgpKVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSAodGFibGUpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgdGFibGVbbWluQiArIGldID0gbWFrZUIySGFzaChpICsgMSwgYmxha2UyYilcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICB0YWJsZVttaW5TICsgaV0gPSBtYWtlQjJIYXNoKGkgKyAxLCBibGFrZTJzKVxuICB9XG59XG4iLCIvKiBnbG9iYWwgc2VsZiAqL1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3Qgbm9kZWlmeSA9IHJlcXVpcmUoJ25vZGVpZnknKVxuXG5jb25zdCB3ZWJDcnlwdG8gPSBnZXRXZWJDcnlwdG8oKVxuXG5mdW5jdGlvbiBnZXRXZWJDcnlwdG8gKCkge1xuICBpZiAoc2VsZi5jcnlwdG8pIHtcbiAgICByZXR1cm4gc2VsZi5jcnlwdG8uc3VidGxlIHx8IHNlbGYuY3J5cHRvLndlYmtpdFN1YnRsZVxuICB9XG5cbiAgaWYgKHNlbGYubXNDcnlwdG8pIHtcbiAgICByZXR1cm4gc2VsZi5tc0NyeXB0by5zdWJ0bGVcbiAgfVxufVxuXG5mdW5jdGlvbiB3ZWJDcnlwdG9IYXNoICh0eXBlKSB7XG4gIGlmICghd2ViQ3J5cHRvKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgdXNlIGEgYnJvd3NlciB3aXRoIHdlYmNyeXB0byBzdXBwb3J0IGFuZCBlbnN1cmUgdGhlIGNvZGUgaGFzIGJlZW4gZGVsaXZlcmVkIHNlY3VyZWx5IHZpYSBIVFRQUy9UTFMgYW5kIHJ1biB3aXRoaW4gYSBTZWN1cmUgQ29udGV4dCcpXG4gIH1cblxuICByZXR1cm4gKGRhdGEsIGNhbGxiYWNrKSA9PiB7XG4gICAgY29uc3QgcmVzID0gd2ViQ3J5cHRvLmRpZ2VzdCh7IG5hbWU6IHR5cGUgfSwgZGF0YSlcblxuICAgIGlmICh0eXBlb2YgcmVzLnRoZW4gIT09ICdmdW5jdGlvbicpIHsgLy8gSUUxMVxuICAgICAgcmVzLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihgaGFzaGluZyBkYXRhIHVzaW5nICR7dHlwZX1gKSlcbiAgICAgIH1cbiAgICAgIHJlcy5vbmNvbXBsZXRlID0gKGUpID0+IHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZS50YXJnZXQucmVzdWx0KVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbm9kZWlmeShcbiAgICAgIHJlcy50aGVuKChyYXcpID0+IEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KHJhdykpKSxcbiAgICAgIGNhbGxiYWNrXG4gICAgKVxuICB9XG59XG5cbmZ1bmN0aW9uIHNoYTEgKGJ1ZiwgY2FsbGJhY2spIHtcbiAgd2ViQ3J5cHRvSGFzaCgnU0hBLTEnKShidWYsIGNhbGxiYWNrKVxufVxuXG5mdW5jdGlvbiBzaGEyMjU2IChidWYsIGNhbGxiYWNrKSB7XG4gIHdlYkNyeXB0b0hhc2goJ1NIQS0yNTYnKShidWYsIGNhbGxiYWNrKVxufVxuXG5mdW5jdGlvbiBzaGEyNTEyIChidWYsIGNhbGxiYWNrKSB7XG4gIHdlYkNyeXB0b0hhc2goJ1NIQS01MTInKShidWYsIGNhbGxiYWNrKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2hhMTogc2hhMSxcbiAgc2hhMjI1Njogc2hhMjI1NixcbiAgc2hhMjUxMjogc2hhMjUxMlxufVxuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjguMFxuKGZ1bmN0aW9uKCkge1xuICB2YXIgSGVhcCwgZGVmYXVsdENtcCwgZmxvb3IsIGhlYXBpZnksIGhlYXBwb3AsIGhlYXBwdXNoLCBoZWFwcHVzaHBvcCwgaGVhcHJlcGxhY2UsIGluc29ydCwgbWluLCBubGFyZ2VzdCwgbnNtYWxsZXN0LCB1cGRhdGVJdGVtLCBfc2lmdGRvd24sIF9zaWZ0dXA7XG5cbiAgZmxvb3IgPSBNYXRoLmZsb29yLCBtaW4gPSBNYXRoLm1pbjtcblxuXG4gIC8qXG4gIERlZmF1bHQgY29tcGFyaXNvbiBmdW5jdGlvbiB0byBiZSB1c2VkXG4gICAqL1xuXG4gIGRlZmF1bHRDbXAgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgaWYgKHggPCB5KSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmICh4ID4geSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xuXG5cbiAgLypcbiAgSW5zZXJ0IGl0ZW0geCBpbiBsaXN0IGEsIGFuZCBrZWVwIGl0IHNvcnRlZCBhc3N1bWluZyBhIGlzIHNvcnRlZC5cbiAgXG4gIElmIHggaXMgYWxyZWFkeSBpbiBhLCBpbnNlcnQgaXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSByaWdodG1vc3QgeC5cbiAgXG4gIE9wdGlvbmFsIGFyZ3MgbG8gKGRlZmF1bHQgMCkgYW5kIGhpIChkZWZhdWx0IGEubGVuZ3RoKSBib3VuZCB0aGUgc2xpY2VcbiAgb2YgYSB0byBiZSBzZWFyY2hlZC5cbiAgICovXG5cbiAgaW5zb3J0ID0gZnVuY3Rpb24oYSwgeCwgbG8sIGhpLCBjbXApIHtcbiAgICB2YXIgbWlkO1xuICAgIGlmIChsbyA9PSBudWxsKSB7XG4gICAgICBsbyA9IDA7XG4gICAgfVxuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgaWYgKGxvIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsbyBtdXN0IGJlIG5vbi1uZWdhdGl2ZScpO1xuICAgIH1cbiAgICBpZiAoaGkgPT0gbnVsbCkge1xuICAgICAgaGkgPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgIG1pZCA9IGZsb29yKChsbyArIGhpKSAvIDIpO1xuICAgICAgaWYgKGNtcCh4LCBhW21pZF0pIDwgMCkge1xuICAgICAgICBoaSA9IG1pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvID0gbWlkICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChbXS5zcGxpY2UuYXBwbHkoYSwgW2xvLCBsbyAtIGxvXS5jb25jYXQoeCkpLCB4KTtcbiAgfTtcblxuXG4gIC8qXG4gIFB1c2ggaXRlbSBvbnRvIGhlYXAsIG1haW50YWluaW5nIHRoZSBoZWFwIGludmFyaWFudC5cbiAgICovXG5cbiAgaGVhcHB1c2ggPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBhcnJheS5wdXNoKGl0ZW0pO1xuICAgIHJldHVybiBfc2lmdGRvd24oYXJyYXksIDAsIGFycmF5Lmxlbmd0aCAtIDEsIGNtcCk7XG4gIH07XG5cblxuICAvKlxuICBQb3AgdGhlIHNtYWxsZXN0IGl0ZW0gb2ZmIHRoZSBoZWFwLCBtYWludGFpbmluZyB0aGUgaGVhcCBpbnZhcmlhbnQuXG4gICAqL1xuXG4gIGhlYXBwb3AgPSBmdW5jdGlvbihhcnJheSwgY21wKSB7XG4gICAgdmFyIGxhc3RlbHQsIHJldHVybml0ZW07XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBsYXN0ZWx0ID0gYXJyYXkucG9wKCk7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuaXRlbSA9IGFycmF5WzBdO1xuICAgICAgYXJyYXlbMF0gPSBsYXN0ZWx0O1xuICAgICAgX3NpZnR1cChhcnJheSwgMCwgY21wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuaXRlbSA9IGxhc3RlbHQ7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5pdGVtO1xuICB9O1xuXG5cbiAgLypcbiAgUG9wIGFuZCByZXR1cm4gdGhlIGN1cnJlbnQgc21hbGxlc3QgdmFsdWUsIGFuZCBhZGQgdGhlIG5ldyBpdGVtLlxuICBcbiAgVGhpcyBpcyBtb3JlIGVmZmljaWVudCB0aGFuIGhlYXBwb3AoKSBmb2xsb3dlZCBieSBoZWFwcHVzaCgpLCBhbmQgY2FuIGJlXG4gIG1vcmUgYXBwcm9wcmlhdGUgd2hlbiB1c2luZyBhIGZpeGVkIHNpemUgaGVhcC4gTm90ZSB0aGF0IHRoZSB2YWx1ZVxuICByZXR1cm5lZCBtYXkgYmUgbGFyZ2VyIHRoYW4gaXRlbSEgVGhhdCBjb25zdHJhaW5zIHJlYXNvbmFibGUgdXNlIG9mXG4gIHRoaXMgcm91dGluZSB1bmxlc3Mgd3JpdHRlbiBhcyBwYXJ0IG9mIGEgY29uZGl0aW9uYWwgcmVwbGFjZW1lbnQ6XG4gICAgICBpZiBpdGVtID4gYXJyYXlbMF1cbiAgICAgICAgaXRlbSA9IGhlYXByZXBsYWNlKGFycmF5LCBpdGVtKVxuICAgKi9cblxuICBoZWFwcmVwbGFjZSA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICB2YXIgcmV0dXJuaXRlbTtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIHJldHVybml0ZW0gPSBhcnJheVswXTtcbiAgICBhcnJheVswXSA9IGl0ZW07XG4gICAgX3NpZnR1cChhcnJheSwgMCwgY21wKTtcbiAgICByZXR1cm4gcmV0dXJuaXRlbTtcbiAgfTtcblxuXG4gIC8qXG4gIEZhc3QgdmVyc2lvbiBvZiBhIGhlYXBwdXNoIGZvbGxvd2VkIGJ5IGEgaGVhcHBvcC5cbiAgICovXG5cbiAgaGVhcHB1c2hwb3AgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgdmFyIF9yZWY7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBpZiAoYXJyYXkubGVuZ3RoICYmIGNtcChhcnJheVswXSwgaXRlbSkgPCAwKSB7XG4gICAgICBfcmVmID0gW2FycmF5WzBdLCBpdGVtXSwgaXRlbSA9IF9yZWZbMF0sIGFycmF5WzBdID0gX3JlZlsxXTtcbiAgICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xuICB9O1xuXG5cbiAgLypcbiAgVHJhbnNmb3JtIGxpc3QgaW50byBhIGhlYXAsIGluLXBsYWNlLCBpbiBPKGFycmF5Lmxlbmd0aCkgdGltZS5cbiAgICovXG5cbiAgaGVhcGlmeSA9IGZ1bmN0aW9uKGFycmF5LCBjbXApIHtcbiAgICB2YXIgaSwgX2ksIF9qLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHMsIF9yZXN1bHRzMTtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIF9yZWYxID0gKGZ1bmN0aW9uKCkge1xuICAgICAgX3Jlc3VsdHMxID0gW107XG4gICAgICBmb3IgKHZhciBfaiA9IDAsIF9yZWYgPSBmbG9vcihhcnJheS5sZW5ndGggLyAyKTsgMCA8PSBfcmVmID8gX2ogPCBfcmVmIDogX2ogPiBfcmVmOyAwIDw9IF9yZWYgPyBfaisrIDogX2otLSl7IF9yZXN1bHRzMS5wdXNoKF9qKTsgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzMTtcbiAgICB9KS5hcHBseSh0aGlzKS5yZXZlcnNlKCk7XG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBpID0gX3JlZjFbX2ldO1xuICAgICAgX3Jlc3VsdHMucHVzaChfc2lmdHVwKGFycmF5LCBpLCBjbXApKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZXN1bHRzO1xuICB9O1xuXG5cbiAgLypcbiAgVXBkYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZ2l2ZW4gaXRlbSBpbiB0aGUgaGVhcC5cbiAgVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIGl0ZW0gaXMgYmVpbmcgbW9kaWZpZWQuXG4gICAqL1xuXG4gIHVwZGF0ZUl0ZW0gPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgdmFyIHBvcztcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIHBvcyA9IGFycmF5LmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX3NpZnRkb3duKGFycmF5LCAwLCBwb3MsIGNtcCk7XG4gICAgcmV0dXJuIF9zaWZ0dXAoYXJyYXksIHBvcywgY21wKTtcbiAgfTtcblxuXG4gIC8qXG4gIEZpbmQgdGhlIG4gbGFyZ2VzdCBlbGVtZW50cyBpbiBhIGRhdGFzZXQuXG4gICAqL1xuXG4gIG5sYXJnZXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGNtcCkge1xuICAgIHZhciBlbGVtLCByZXN1bHQsIF9pLCBfbGVuLCBfcmVmO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgcmVzdWx0ID0gYXJyYXkuc2xpY2UoMCwgbik7XG4gICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBoZWFwaWZ5KHJlc3VsdCwgY21wKTtcbiAgICBfcmVmID0gYXJyYXkuc2xpY2Uobik7XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBlbGVtID0gX3JlZltfaV07XG4gICAgICBoZWFwcHVzaHBvcChyZXN1bHQsIGVsZW0sIGNtcCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuc29ydChjbXApLnJldmVyc2UoKTtcbiAgfTtcblxuXG4gIC8qXG4gIEZpbmQgdGhlIG4gc21hbGxlc3QgZWxlbWVudHMgaW4gYSBkYXRhc2V0LlxuICAgKi9cblxuICBuc21hbGxlc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgY21wKSB7XG4gICAgdmFyIGVsZW0sIGksIGxvcywgcmVzdWx0LCBfaSwgX2osIF9sZW4sIF9yZWYsIF9yZWYxLCBfcmVzdWx0cztcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGlmIChuICogMTAgPD0gYXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXN1bHQgPSBhcnJheS5zbGljZSgwLCBuKS5zb3J0KGNtcCk7XG4gICAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGxvcyA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICBfcmVmID0gYXJyYXkuc2xpY2Uobik7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgZWxlbSA9IF9yZWZbX2ldO1xuICAgICAgICBpZiAoY21wKGVsZW0sIGxvcykgPCAwKSB7XG4gICAgICAgICAgaW5zb3J0KHJlc3VsdCwgZWxlbSwgMCwgbnVsbCwgY21wKTtcbiAgICAgICAgICByZXN1bHQucG9wKCk7XG4gICAgICAgICAgbG9zID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaGVhcGlmeShhcnJheSwgY21wKTtcbiAgICBfcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoaSA9IF9qID0gMCwgX3JlZjEgPSBtaW4obiwgYXJyYXkubGVuZ3RoKTsgMCA8PSBfcmVmMSA/IF9qIDwgX3JlZjEgOiBfaiA+IF9yZWYxOyBpID0gMCA8PSBfcmVmMSA/ICsrX2ogOiAtLV9qKSB7XG4gICAgICBfcmVzdWx0cy5wdXNoKGhlYXBwb3AoYXJyYXksIGNtcCkpO1xuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH07XG5cbiAgX3NpZnRkb3duID0gZnVuY3Rpb24oYXJyYXksIHN0YXJ0cG9zLCBwb3MsIGNtcCkge1xuICAgIHZhciBuZXdpdGVtLCBwYXJlbnQsIHBhcmVudHBvcztcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIG5ld2l0ZW0gPSBhcnJheVtwb3NdO1xuICAgIHdoaWxlIChwb3MgPiBzdGFydHBvcykge1xuICAgICAgcGFyZW50cG9zID0gKHBvcyAtIDEpID4+IDE7XG4gICAgICBwYXJlbnQgPSBhcnJheVtwYXJlbnRwb3NdO1xuICAgICAgaWYgKGNtcChuZXdpdGVtLCBwYXJlbnQpIDwgMCkge1xuICAgICAgICBhcnJheVtwb3NdID0gcGFyZW50O1xuICAgICAgICBwb3MgPSBwYXJlbnRwb3M7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBhcnJheVtwb3NdID0gbmV3aXRlbTtcbiAgfTtcblxuICBfc2lmdHVwID0gZnVuY3Rpb24oYXJyYXksIHBvcywgY21wKSB7XG4gICAgdmFyIGNoaWxkcG9zLCBlbmRwb3MsIG5ld2l0ZW0sIHJpZ2h0cG9zLCBzdGFydHBvcztcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGVuZHBvcyA9IGFycmF5Lmxlbmd0aDtcbiAgICBzdGFydHBvcyA9IHBvcztcbiAgICBuZXdpdGVtID0gYXJyYXlbcG9zXTtcbiAgICBjaGlsZHBvcyA9IDIgKiBwb3MgKyAxO1xuICAgIHdoaWxlIChjaGlsZHBvcyA8IGVuZHBvcykge1xuICAgICAgcmlnaHRwb3MgPSBjaGlsZHBvcyArIDE7XG4gICAgICBpZiAocmlnaHRwb3MgPCBlbmRwb3MgJiYgIShjbXAoYXJyYXlbY2hpbGRwb3NdLCBhcnJheVtyaWdodHBvc10pIDwgMCkpIHtcbiAgICAgICAgY2hpbGRwb3MgPSByaWdodHBvcztcbiAgICAgIH1cbiAgICAgIGFycmF5W3Bvc10gPSBhcnJheVtjaGlsZHBvc107XG4gICAgICBwb3MgPSBjaGlsZHBvcztcbiAgICAgIGNoaWxkcG9zID0gMiAqIHBvcyArIDE7XG4gICAgfVxuICAgIGFycmF5W3Bvc10gPSBuZXdpdGVtO1xuICAgIHJldHVybiBfc2lmdGRvd24oYXJyYXksIHN0YXJ0cG9zLCBwb3MsIGNtcCk7XG4gIH07XG5cbiAgSGVhcCA9IChmdW5jdGlvbigpIHtcbiAgICBIZWFwLnB1c2ggPSBoZWFwcHVzaDtcblxuICAgIEhlYXAucG9wID0gaGVhcHBvcDtcblxuICAgIEhlYXAucmVwbGFjZSA9IGhlYXByZXBsYWNlO1xuXG4gICAgSGVhcC5wdXNocG9wID0gaGVhcHB1c2hwb3A7XG5cbiAgICBIZWFwLmhlYXBpZnkgPSBoZWFwaWZ5O1xuXG4gICAgSGVhcC51cGRhdGVJdGVtID0gdXBkYXRlSXRlbTtcblxuICAgIEhlYXAubmxhcmdlc3QgPSBubGFyZ2VzdDtcblxuICAgIEhlYXAubnNtYWxsZXN0ID0gbnNtYWxsZXN0O1xuXG4gICAgZnVuY3Rpb24gSGVhcChjbXApIHtcbiAgICAgIHRoaXMuY21wID0gY21wICE9IG51bGwgPyBjbXAgOiBkZWZhdWx0Q21wO1xuICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgIH1cblxuICAgIEhlYXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gaGVhcHB1c2godGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBoZWFwcG9wKHRoaXMubm9kZXMsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXNbMF07XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMuaW5kZXhPZih4KSAhPT0gLTE7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gaGVhcHJlcGxhY2UodGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5wdXNocG9wID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGhlYXBwdXNocG9wKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuaGVhcGlmeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGhlYXBpZnkodGhpcy5ub2RlcywgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS51cGRhdGVJdGVtID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHVwZGF0ZUl0ZW0odGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMgPSBbXTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMubGVuZ3RoO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhlYXA7XG4gICAgICBoZWFwID0gbmV3IEhlYXAoKTtcbiAgICAgIGhlYXAubm9kZXMgPSB0aGlzLm5vZGVzLnNsaWNlKDApO1xuICAgICAgcmV0dXJuIGhlYXA7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLnNsaWNlKDApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5pbnNlcnQgPSBIZWFwLnByb3RvdHlwZS5wdXNoO1xuXG4gICAgSGVhcC5wcm90b3R5cGUudG9wID0gSGVhcC5wcm90b3R5cGUucGVlaztcblxuICAgIEhlYXAucHJvdG90eXBlLmZyb250ID0gSGVhcC5wcm90b3R5cGUucGVlaztcblxuICAgIEhlYXAucHJvdG90eXBlLmhhcyA9IEhlYXAucHJvdG90eXBlLmNvbnRhaW5zO1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY29weSA9IEhlYXAucHJvdG90eXBlLmNsb25lO1xuXG4gICAgcmV0dXJuIEhlYXA7XG5cbiAgfSkoKTtcblxuICAoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgIHJldHVybiBkZWZpbmUoW10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByb290LkhlYXAgPSBmYWN0b3J5KCk7XG4gICAgfVxuICB9KSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gSGVhcDtcbiAgfSk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cbnZhciBieXRlVG9IZXggPSBbXTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4W2ldID0gKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtcbn1cblxuZnVuY3Rpb24gYnl0ZXNUb1V1aWQoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGJ0aCA9IGJ5dGVUb0hleDtcbiAgLy8gam9pbiB1c2VkIHRvIGZpeCBtZW1vcnkgaXNzdWUgY2F1c2VkIGJ5IGNvbmNhdGVuYXRpb246IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMxNzUjYzRcbiAgcmV0dXJuIChbXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV1cbiAgXSkuam9pbignJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnl0ZXNUb1V1aWQ7XG4iLCIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgSW4gdGhlXG4vLyBicm93c2VyIHRoaXMgaXMgYSBsaXR0bGUgY29tcGxpY2F0ZWQgZHVlIHRvIHVua25vd24gcXVhbGl0eSBvZiBNYXRoLnJhbmRvbSgpXG4vLyBhbmQgaW5jb25zaXN0ZW50IHN1cHBvcnQgZm9yIHRoZSBgY3J5cHRvYCBBUEkuICBXZSBkbyB0aGUgYmVzdCB3ZSBjYW4gdmlhXG4vLyBmZWF0dXJlLWRldGVjdGlvblxuXG4vLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG9cbi8vIGltcGxlbWVudGF0aW9uLiBBbHNvLCBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gb24gSUUxMS5cbnZhciBnZXRSYW5kb21WYWx1ZXMgPSAodHlwZW9mKGNyeXB0bykgIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mKG1zQ3J5cHRvKSAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93Lm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKSk7XG5cbmlmIChnZXRSYW5kb21WYWx1ZXMpIHtcbiAgLy8gV0hBVFdHIGNyeXB0byBSTkcgLSBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvQ3J5cHRvXG4gIHZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hhdHdnUk5HKCkge1xuICAgIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG4gICAgcmV0dXJuIHJuZHM4O1xuICB9O1xufSBlbHNlIHtcbiAgLy8gTWF0aC5yYW5kb20oKS1iYXNlZCAoUk5HKVxuICAvL1xuICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdXNlIE1hdGgucmFuZG9tKCkuICBJdCdzIGZhc3QsIGJ1dCBpcyBvZiB1bnNwZWNpZmllZFxuICAvLyBxdWFsaXR5LlxuICB2YXIgcm5kcyA9IG5ldyBBcnJheSgxNik7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYXRoUk5HKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgMTY7IGkrKykge1xuICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICBybmRzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgIH1cblxuICAgIHJldHVybiBybmRzO1xuICB9O1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMudG9DYWxsYmFjayA9IChkb1dvcmspID0+IHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpbnB1dCwgY2FsbGJhY2spIHtcbiAgICBsZXQgcmVzXG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IGRvV29yayhpbnB1dClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIGVycilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIG51bGwsIHJlcylcbiAgfVxufVxuXG5leHBvcnRzLnRvQnVmID0gKGRvV29yaywgb3RoZXIpID0+IChpbnB1dCkgPT4ge1xuICBsZXQgcmVzdWx0ID0gZG9Xb3JrKGlucHV0LCBvdGhlcilcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHJlc3VsdCwgJ2hleCcpXG59XG5cbmV4cG9ydHMuZnJvbVN0cmluZyA9IChkb1dvcmssIG90aGVyKSA9PiAoX2lucHV0KSA9PiB7XG4gIGNvbnN0IGlucHV0ID0gQnVmZmVyLmlzQnVmZmVyKF9pbnB1dCkgPyBfaW5wdXQudG9TdHJpbmcoKSA6IF9pbnB1dFxuICByZXR1cm4gZG9Xb3JrKGlucHV0LCBvdGhlcilcbn1cblxuZXhwb3J0cy5mcm9tTnVtYmVyVG8zMkJpdEJ1ZiA9IChkb1dvcmssIG90aGVyKSA9PiAoaW5wdXQpID0+IHtcbiAgbGV0IG51bWJlciA9IGRvV29yayhpbnB1dCwgb3RoZXIpXG4gIGNvbnN0IGJ5dGVzID0gbmV3IEFycmF5KDQpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBieXRlc1tpXSA9IG51bWJlciAmIDB4ZmZcbiAgICBudW1iZXIgPSBudW1iZXIgPj4gOFxuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ5dGVzKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJsYWtlID0gcmVxdWlyZSgnYmxha2VqcycpXG5cbmNvbnN0IHRvQ2FsbGJhY2sgPSByZXF1aXJlKCcuL3V0aWxzJykudG9DYWxsYmFja1xuXG5jb25zdCBtaW5CID0gMHhiMjAxXG5jb25zdCBtaW5TID0gMHhiMjQxXG5cbmNvbnN0IGJsYWtlMmIgPSB7XG4gIGluaXQ6IGJsYWtlLmJsYWtlMmJJbml0LFxuICB1cGRhdGU6IGJsYWtlLmJsYWtlMmJVcGRhdGUsXG4gIGRpZ2VzdDogYmxha2UuYmxha2UyYkZpbmFsXG59XG5cbmNvbnN0IGJsYWtlMnMgPSB7XG4gIGluaXQ6IGJsYWtlLmJsYWtlMnNJbml0LFxuICB1cGRhdGU6IGJsYWtlLmJsYWtlMnNVcGRhdGUsXG4gIGRpZ2VzdDogYmxha2UuYmxha2Uyc0ZpbmFsXG59XG5cbmNvbnN0IG1ha2VCMkhhc2ggPSAoc2l6ZSwgaGYpID0+IHRvQ2FsbGJhY2soKGJ1ZikgPT4ge1xuICBjb25zdCBjdHggPSBoZi5pbml0KHNpemUsIG51bGwpXG4gIGhmLnVwZGF0ZShjdHgsIGJ1ZilcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhmLmRpZ2VzdChjdHgpKVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSAodGFibGUpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgdGFibGVbbWluQiArIGldID0gbWFrZUIySGFzaChpICsgMSwgYmxha2UyYilcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICB0YWJsZVttaW5TICsgaV0gPSBtYWtlQjJIYXNoKGkgKyAxLCBibGFrZTJzKVxuICB9XG59XG4iLCIvKiBnbG9iYWwgc2VsZiAqL1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3Qgbm9kZWlmeSA9IHJlcXVpcmUoJ25vZGVpZnknKVxuXG5jb25zdCB3ZWJDcnlwdG8gPSBnZXRXZWJDcnlwdG8oKVxuXG5mdW5jdGlvbiBnZXRXZWJDcnlwdG8gKCkge1xuICBpZiAoc2VsZi5jcnlwdG8pIHtcbiAgICByZXR1cm4gc2VsZi5jcnlwdG8uc3VidGxlIHx8IHNlbGYuY3J5cHRvLndlYmtpdFN1YnRsZVxuICB9XG5cbiAgaWYgKHNlbGYubXNDcnlwdG8pIHtcbiAgICByZXR1cm4gc2VsZi5tc0NyeXB0by5zdWJ0bGVcbiAgfVxufVxuXG5mdW5jdGlvbiB3ZWJDcnlwdG9IYXNoICh0eXBlKSB7XG4gIGlmICghd2ViQ3J5cHRvKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgdXNlIGEgYnJvd3NlciB3aXRoIHdlYmNyeXB0byBzdXBwb3J0IGFuZCBlbnN1cmUgdGhlIGNvZGUgaGFzIGJlZW4gZGVsaXZlcmVkIHNlY3VyZWx5IHZpYSBIVFRQUy9UTFMgYW5kIHJ1biB3aXRoaW4gYSBTZWN1cmUgQ29udGV4dCcpXG4gIH1cblxuICByZXR1cm4gKGRhdGEsIGNhbGxiYWNrKSA9PiB7XG4gICAgY29uc3QgcmVzID0gd2ViQ3J5cHRvLmRpZ2VzdCh7IG5hbWU6IHR5cGUgfSwgZGF0YSlcblxuICAgIGlmICh0eXBlb2YgcmVzLnRoZW4gIT09ICdmdW5jdGlvbicpIHsgLy8gSUUxMVxuICAgICAgcmVzLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihgaGFzaGluZyBkYXRhIHVzaW5nICR7dHlwZX1gKSlcbiAgICAgIH1cbiAgICAgIHJlcy5vbmNvbXBsZXRlID0gKGUpID0+IHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZS50YXJnZXQucmVzdWx0KVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbm9kZWlmeShcbiAgICAgIHJlcy50aGVuKChyYXcpID0+IEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KHJhdykpKSxcbiAgICAgIGNhbGxiYWNrXG4gICAgKVxuICB9XG59XG5cbmZ1bmN0aW9uIHNoYTEgKGJ1ZiwgY2FsbGJhY2spIHtcbiAgd2ViQ3J5cHRvSGFzaCgnU0hBLTEnKShidWYsIGNhbGxiYWNrKVxufVxuXG5mdW5jdGlvbiBzaGEyMjU2IChidWYsIGNhbGxiYWNrKSB7XG4gIHdlYkNyeXB0b0hhc2goJ1NIQS0yNTYnKShidWYsIGNhbGxiYWNrKVxufVxuXG5mdW5jdGlvbiBzaGEyNTEyIChidWYsIGNhbGxiYWNrKSB7XG4gIHdlYkNyeXB0b0hhc2goJ1NIQS01MTInKShidWYsIGNhbGxiYWNrKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2hhMTogc2hhMSxcbiAgc2hhMjI1Njogc2hhMjI1NixcbiAgc2hhMjUxMjogc2hhMjUxMlxufVxuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICovXG5leHBvcnRzLmluc3RhbmNlcyA9IFtdO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gIHZhciBoYXNoID0gMCwgaTtcblxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICB2YXIgcHJldlRpbWU7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG4gIGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG4gIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XG4gICAgZXhwb3J0cy5pbml0KGRlYnVnKTtcbiAgfVxuXG4gIGV4cG9ydHMuaW5zdGFuY2VzLnB1c2goZGVidWcpO1xuXG4gIHJldHVybiBkZWJ1Zztcbn1cblxuZnVuY3Rpb24gZGVzdHJveSAoKSB7XG4gIHZhciBpbmRleCA9IGV4cG9ydHMuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBleHBvcnRzLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBpO1xuICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwb3J0cy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBleHBvcnRzLmluc3RhbmNlc1tpXTtcbiAgICBpbnN0YW5jZS5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuIiwiLy8gYnJvd3NlciBzaGltIGZvciB4bWxodHRwcmVxdWVzdCBtb2R1bGVcblxudmFyIGhhc0NPUlMgPSByZXF1aXJlKCdoYXMtY29ycycpO1xudmFyIGdsb2JhbFRoaXMgPSByZXF1aXJlKCcuL2dsb2JhbFRoaXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgeGRvbWFpbiA9IG9wdHMueGRvbWFpbjtcblxuICAvLyBzY2hlbWUgbXVzdCBiZSBzYW1lIHdoZW4gdXNpZ24gWERvbWFpblJlcXVlc3RcbiAgLy8gaHR0cDovL2Jsb2dzLm1zZG4uY29tL2IvaWVpbnRlcm5hbHMvYXJjaGl2ZS8yMDEwLzA1LzEzL3hkb21haW5yZXF1ZXN0LXJlc3RyaWN0aW9ucy1saW1pdGF0aW9ucy1hbmQtd29ya2Fyb3VuZHMuYXNweFxuICB2YXIgeHNjaGVtZSA9IG9wdHMueHNjaGVtZTtcblxuICAvLyBYRG9tYWluUmVxdWVzdCBoYXMgYSBmbG93IG9mIG5vdCBzZW5kaW5nIGNvb2tpZSwgdGhlcmVmb3JlIGl0IHNob3VsZCBiZSBkaXNhYmxlZCBhcyBhIGRlZmF1bHQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2VuZ2luZS5pby1jbGllbnQvcHVsbC8yMTdcbiAgdmFyIGVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gWE1MSHR0cFJlcXVlc3QgY2FuIGJlIGRpc2FibGVkIG9uIElFXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgJiYgKCF4ZG9tYWluIHx8IGhhc0NPUlMpKSB7XG4gICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7IH1cblxuICAvLyBVc2UgWERvbWFpblJlcXVlc3QgZm9yIElFOCBpZiBlbmFibGVzWERSIGlzIHRydWVcbiAgLy8gYmVjYXVzZSBsb2FkaW5nIGJhciBrZWVwcyBmbGFzaGluZyB3aGVuIHVzaW5nIGpzb25wLXBvbGxpbmdcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3l1amlvc2FrYS9zb2NrZS5pby1pZTgtbG9hZGluZy1leGFtcGxlXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgWERvbWFpblJlcXVlc3QgJiYgIXhzY2hlbWUgJiYgZW5hYmxlc1hEUikge1xuICAgICAgcmV0dXJuIG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgaWYgKCF4ZG9tYWluKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgZ2xvYmFsVGhpc1tbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpXSgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9IGNhdGNoIChlKSB7IH1cbiAgfVxufTtcbiIsIi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIGdsb2JhbFRoaXMgPSByZXF1aXJlKCcuLi9nbG9iYWxUaGlzJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBKU09OUFBvbGxpbmc7XG5cbi8qKlxuICogQ2FjaGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gKi9cblxudmFyIHJOZXdsaW5lID0gL1xcbi9nO1xudmFyIHJFc2NhcGVkTmV3bGluZSA9IC9cXFxcbi9nO1xuXG4vKipcbiAqIEdsb2JhbCBKU09OUCBjYWxsYmFja3MuXG4gKi9cblxudmFyIGNhbGxiYWNrcztcblxuLyoqXG4gKiBOb29wLlxuICovXG5cbmZ1bmN0aW9uIGVtcHR5ICgpIHsgfVxuXG4vKipcbiAqIEpTT05QIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEpTT05QUG9sbGluZyAob3B0cykge1xuICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgdGhpcy5xdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG5cbiAgLy8gZGVmaW5lIGdsb2JhbCBjYWxsYmFja3MgYXJyYXkgaWYgbm90IHByZXNlbnRcbiAgLy8gd2UgZG8gdGhpcyBoZXJlIChsYXppbHkpIHRvIGF2b2lkIHVubmVlZGVkIGdsb2JhbCBwb2xsdXRpb25cbiAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAvLyB3ZSBuZWVkIHRvIGNvbnNpZGVyIG11bHRpcGxlIGVuZ2luZXMgaW4gdGhlIHNhbWUgcGFnZVxuICAgIGNhbGxiYWNrcyA9IGdsb2JhbFRoaXMuX19fZWlvID0gKGdsb2JhbFRoaXMuX19fZWlvIHx8IFtdKTtcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGlkZW50aWZpZXJcbiAgdGhpcy5pbmRleCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cbiAgLy8gYWRkIGNhbGxiYWNrIHRvIGpzb25wIGdsb2JhbFxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIChtc2cpIHtcbiAgICBzZWxmLm9uRGF0YShtc2cpO1xuICB9KTtcblxuICAvLyBhcHBlbmQgdG8gcXVlcnkgc3RyaW5nXG4gIHRoaXMucXVlcnkuaiA9IHRoaXMuaW5kZXg7XG5cbiAgLy8gcHJldmVudCBzcHVyaW91cyBlcnJvcnMgZnJvbSBiZWluZyBlbWl0dGVkIHdoZW4gdGhlIHdpbmRvdyBpcyB1bmxvYWRlZFxuICBpZiAodHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBhZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5zY3JpcHQpIHNlbGYuc2NyaXB0Lm9uZXJyb3IgPSBlbXB0eTtcbiAgICB9LCBmYWxzZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChKU09OUFBvbGxpbmcsIFBvbGxpbmcpO1xuXG4vKlxuICogSlNPTlAgb25seSBzdXBwb3J0cyBiaW5hcnkgYXMgYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0aGlzLmZvcm0pIHtcbiAgICB0aGlzLmZvcm0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZvcm0pO1xuICAgIHRoaXMuZm9ybSA9IG51bGw7XG4gICAgdGhpcy5pZnJhbWUgPSBudWxsO1xuICB9XG5cbiAgUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cblxuICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICBzY3JpcHQuc3JjID0gdGhpcy51cmkoKTtcbiAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbCBlcnJvcicsIGUpO1xuICB9O1xuXG4gIHZhciBpbnNlcnRBdCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXTtcbiAgaWYgKGluc2VydEF0KSB7XG4gICAgaW5zZXJ0QXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2NyaXB0LCBpbnNlcnRBdCk7XG4gIH0gZWxzZSB7XG4gICAgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keSkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgfVxuICB0aGlzLnNjcmlwdCA9IHNjcmlwdDtcblxuICB2YXIgaXNVQWdlY2tvID0gJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBuYXZpZ2F0b3IgJiYgL2dlY2tvL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuICBpZiAoaXNVQWdlY2tvKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgfSwgMTAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgd2l0aCBhIGhpZGRlbiBpZnJhbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghdGhpcy5mb3JtKSB7XG4gICAgdmFyIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gICAgdmFyIGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIHZhciBpZCA9IHRoaXMuaWZyYW1lSWQgPSAnZWlvX2lmcmFtZV8nICsgdGhpcy5pbmRleDtcbiAgICB2YXIgaWZyYW1lO1xuXG4gICAgZm9ybS5jbGFzc05hbWUgPSAnc29ja2V0aW8nO1xuICAgIGZvcm0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGZvcm0uc3R5bGUudG9wID0gJy0xMDAwcHgnO1xuICAgIGZvcm0uc3R5bGUubGVmdCA9ICctMTAwMHB4JztcbiAgICBmb3JtLnRhcmdldCA9IGlkO1xuICAgIGZvcm0ubWV0aG9kID0gJ1BPU1QnO1xuICAgIGZvcm0uc2V0QXR0cmlidXRlKCdhY2NlcHQtY2hhcnNldCcsICd1dGYtOCcpO1xuICAgIGFyZWEubmFtZSA9ICdkJztcbiAgICBmb3JtLmFwcGVuZENoaWxkKGFyZWEpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG5cbiAgICB0aGlzLmZvcm0gPSBmb3JtO1xuICAgIHRoaXMuYXJlYSA9IGFyZWE7XG4gIH1cblxuICB0aGlzLmZvcm0uYWN0aW9uID0gdGhpcy51cmkoKTtcblxuICBmdW5jdGlvbiBjb21wbGV0ZSAoKSB7XG4gICAgaW5pdElmcmFtZSgpO1xuICAgIGZuKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0SWZyYW1lICgpIHtcbiAgICBpZiAoc2VsZi5pZnJhbWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNlbGYuZm9ybS5yZW1vdmVDaGlsZChzZWxmLmlmcmFtZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbGluZyBpZnJhbWUgcmVtb3ZhbCBlcnJvcicsIGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBpZTYgZHluYW1pYyBpZnJhbWVzIHdpdGggdGFyZ2V0PVwiXCIgc3VwcG9ydCAodGhhbmtzIENocmlzIExhbWJhY2hlcilcbiAgICAgIHZhciBodG1sID0gJzxpZnJhbWUgc3JjPVwiamF2YXNjcmlwdDowXCIgbmFtZT1cIicgKyBzZWxmLmlmcmFtZUlkICsgJ1wiPic7XG4gICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGh0bWwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgaWZyYW1lLm5hbWUgPSBzZWxmLmlmcmFtZUlkO1xuICAgICAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0OjAnO1xuICAgIH1cblxuICAgIGlmcmFtZS5pZCA9IHNlbGYuaWZyYW1lSWQ7XG5cbiAgICBzZWxmLmZvcm0uYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBzZWxmLmlmcmFtZSA9IGlmcmFtZTtcbiAgfVxuXG4gIGluaXRJZnJhbWUoKTtcblxuICAvLyBlc2NhcGUgXFxuIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyBjb252ZXJ0ZWQgaW50byBcXHJcXG4gYnkgc29tZSBVQXNcbiAgLy8gZG91YmxlIGVzY2FwaW5nIGlzIHJlcXVpcmVkIGZvciBlc2NhcGVkIG5ldyBsaW5lcyBiZWNhdXNlIHVuZXNjYXBpbmcgb2YgbmV3IGxpbmVzIGNhbiBiZSBkb25lIHNhZmVseSBvbiBzZXJ2ZXItc2lkZVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKHJFc2NhcGVkTmV3bGluZSwgJ1xcXFxcXG4nKTtcbiAgdGhpcy5hcmVhLnZhbHVlID0gZGF0YS5yZXBsYWNlKHJOZXdsaW5lLCAnXFxcXG4nKTtcblxuICB0cnkge1xuICAgIHRoaXMuZm9ybS5zdWJtaXQoKTtcbiAgfSBjYXRjaCAoZSkge31cblxuICBpZiAodGhpcy5pZnJhbWUuYXR0YWNoRXZlbnQpIHtcbiAgICB0aGlzLmlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5pZnJhbWUucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pZnJhbWUub25sb2FkID0gY29tcGxldGU7XG4gIH1cbn07XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIHllYXN0ID0gcmVxdWlyZSgneWVhc3QnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6d2Vic29ja2V0Jyk7XG5cbnZhciBCcm93c2VyV2ViU29ja2V0LCBOb2RlV2ViU29ja2V0O1xuXG5pZiAodHlwZW9mIFdlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgQnJvd3NlcldlYlNvY2tldCA9IFdlYlNvY2tldDtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIEJyb3dzZXJXZWJTb2NrZXQgPSBzZWxmLldlYlNvY2tldCB8fCBzZWxmLk1veldlYlNvY2tldDtcbn1cblxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gIHRyeSB7XG4gICAgTm9kZVdlYlNvY2tldCA9IHJlcXVpcmUoJ3dzJyk7XG4gIH0gY2F0Y2ggKGUpIHsgfVxufVxuXG4vKipcbiAqIEdldCBlaXRoZXIgdGhlIGBXZWJTb2NrZXRgIG9yIGBNb3pXZWJTb2NrZXRgIGdsb2JhbHNcbiAqIGluIHRoZSBicm93c2VyIG9yIHRyeSB0byByZXNvbHZlIFdlYlNvY2tldC1jb21wYXRpYmxlXG4gKiBpbnRlcmZhY2UgZXhwb3NlZCBieSBgd3NgIGZvciBOb2RlLWxpa2UgZW52aXJvbm1lbnQuXG4gKi9cblxudmFyIFdlYlNvY2tldEltcGwgPSBCcm93c2VyV2ViU29ja2V0IHx8IE5vZGVXZWJTb2NrZXQ7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBXUztcblxuLyoqXG4gKiBXZWJTb2NrZXQgdHJhbnNwb3J0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkge09iamVjdH0gY29ubmVjdGlvbiBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFdTIChvcHRzKSB7XG4gIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuICBpZiAoZm9yY2VCYXNlNjQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IG9wdHMucGVyTWVzc2FnZURlZmxhdGU7XG4gIHRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0ID0gQnJvd3NlcldlYlNvY2tldCAmJiAhb3B0cy5mb3JjZU5vZGU7XG4gIHRoaXMucHJvdG9jb2xzID0gb3B0cy5wcm90b2NvbHM7XG4gIGlmICghdGhpcy51c2luZ0Jyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICBXZWJTb2NrZXRJbXBsID0gTm9kZVdlYlNvY2tldDtcbiAgfVxuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFdTLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLm5hbWUgPSAnd2Vic29ja2V0JztcblxuLypcbiAqIFdlYlNvY2tldHMgc3VwcG9ydCBiaW5hcnlcbiAqL1xuXG5XUy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIE9wZW5zIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuY2hlY2soKSkge1xuICAgIC8vIGxldCBwcm9iZSB0aW1lb3V0XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHVyaSA9IHRoaXMudXJpKCk7XG4gIHZhciBwcm90b2NvbHMgPSB0aGlzLnByb3RvY29scztcblxuICB2YXIgb3B0cyA9IHt9O1xuXG4gIGlmICghdGhpcy5pc1JlYWN0TmF0aXZlKSB7XG4gICAgb3B0cy5hZ2VudCA9IHRoaXMuYWdlbnQ7XG4gICAgb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMucGVyTWVzc2FnZURlZmxhdGU7XG5cbiAgICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICAgIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gICAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICAgIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gICAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgfVxuXG4gIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuICAgIG9wdHMuaGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuICB9XG4gIGlmICh0aGlzLmxvY2FsQWRkcmVzcykge1xuICAgIG9wdHMubG9jYWxBZGRyZXNzID0gdGhpcy5sb2NhbEFkZHJlc3M7XG4gIH1cblxuICB0cnkge1xuICAgIHRoaXMud3MgPVxuICAgICAgdGhpcy51c2luZ0Jyb3dzZXJXZWJTb2NrZXQgJiYgIXRoaXMuaXNSZWFjdE5hdGl2ZVxuICAgICAgICA/IHByb3RvY29sc1xuICAgICAgICAgID8gbmV3IFdlYlNvY2tldEltcGwodXJpLCBwcm90b2NvbHMpXG4gICAgICAgICAgOiBuZXcgV2ViU29ja2V0SW1wbCh1cmkpXG4gICAgICAgIDogbmV3IFdlYlNvY2tldEltcGwodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICBpZiAodGhpcy53cy5iaW5hcnlUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy53cy5zdXBwb3J0cyAmJiB0aGlzLndzLnN1cHBvcnRzLmJpbmFyeSkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdub2RlYnVmZmVyJztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICB9XG5cbiAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xufTtcblxuLyoqXG4gKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgc29ja2V0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy53cy5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbk9wZW4oKTtcbiAgfTtcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25DbG9zZSgpO1xuICB9O1xuICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldikge1xuICAgIHNlbGYub25EYXRhKGV2LmRhdGEpO1xuICB9O1xuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYub25FcnJvcignd2Vic29ja2V0IGVycm9yJywgZSk7XG4gIH07XG59O1xuXG4vKipcbiAqIFdyaXRlcyBkYXRhIHRvIHNvY2tldC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiBwYWNrZXRzLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgLy8gZW5jb2RlUGFja2V0IGVmZmljaWVudCBhcyBpdCB1c2VzIFdTIGZyYW1pbmdcbiAgLy8gbm8gbmVlZCBmb3IgZW5jb2RlUGF5bG9hZFxuICB2YXIgdG90YWwgPSBwYWNrZXRzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB0b3RhbDsgaSA8IGw7IGkrKykge1xuICAgIChmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgICBwYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldCwgc2VsZi5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCFzZWxmLnVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgIC8vIGFsd2F5cyBjcmVhdGUgYSBuZXcgb2JqZWN0IChHSC00MzcpXG4gICAgICAgICAgdmFyIG9wdHMgPSB7fTtcbiAgICAgICAgICBpZiAocGFja2V0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9ICdzdHJpbmcnID09PSB0eXBlb2YgZGF0YSA/IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuIDwgc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgb3B0cy5jb21wcmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvbWV0aW1lcyB0aGUgd2Vic29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ1dCB0aGUgYnJvd3NlciBkaWRuJ3RcbiAgICAgICAgLy8gaGF2ZSBhIGNoYW5jZSBvZiBpbmZvcm1pbmcgdXMgYWJvdXQgaXQgeWV0LCBpbiB0aGF0IGNhc2Ugc2VuZCB3aWxsXG4gICAgICAgIC8vIHRocm93IGFuIGVycm9yXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHNlbGYudXNpbmdCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgICAgICAgICAvLyBUeXBlRXJyb3IgaXMgdGhyb3duIHdoZW4gcGFzc2luZyB0aGUgc2Vjb25kIGFyZ3VtZW50IG9uIFNhZmFyaVxuICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLndzLnNlbmQoZGF0YSwgb3B0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcoJ3dlYnNvY2tldCBjbG9zZWQgYmVmb3JlIG9uY2xvc2UgZXZlbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC0tdG90YWwgfHwgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfSkocGFja2V0c1tpXSk7XG4gIH1cblxuICBmdW5jdGlvbiBkb25lICgpIHtcbiAgICBzZWxmLmVtaXQoJ2ZsdXNoJyk7XG5cbiAgICAvLyBmYWtlIGRyYWluXG4gICAgLy8gZGVmZXIgdG8gbmV4dCB0aWNrIHRvIGFsbG93IFNvY2tldCB0byBjbGVhciB3cml0ZUJ1ZmZlclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gICAgfSwgMCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gY2xvc2VcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIENsb3NlcyBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgdGhpcy53cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLndzLmNsb3NlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnd3NzJyA6ICd3cyc7XG4gIHZhciBwb3J0ID0gJyc7XG5cbiAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcbiAgaWYgKHRoaXMucG9ydCAmJiAoKCd3c3MnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDQ0MykgfHxcbiAgICAoJ3dzJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA4MCkpKSB7XG4gICAgcG9ydCA9ICc6JyArIHRoaXMucG9ydDtcbiAgfVxuXG4gIC8vIGFwcGVuZCB0aW1lc3RhbXAgdG8gVVJJXG4gIGlmICh0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuICB9XG5cbiAgLy8gY29tbXVuaWNhdGUgYmluYXJ5IHN1cHBvcnQgY2FwYWJpbGl0aWVzXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgIHF1ZXJ5LmI2NCA9IDE7XG4gIH1cblxuICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcbiAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gIH1cblxuICB2YXIgaXB2NiA9IHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMTtcbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgKGlwdjYgPyAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nIDogdGhpcy5ob3N0bmFtZSkgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG59O1xuXG4vKipcbiAqIEZlYXR1cmUgZGV0ZWN0aW9uIGZvciBXZWJTb2NrZXQuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciB0aGlzIHRyYW5zcG9ydCBpcyBhdmFpbGFibGUuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbldTLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEhV2ViU29ja2V0SW1wbCAmJiAhKCdfX2luaXRpYWxpemUnIGluIFdlYlNvY2tldEltcGwgJiYgdGhpcy5uYW1lID09PSBXUy5wcm90b3R5cGUubmFtZSk7XG59O1xuIiwiLyogZ2xvYmFsIGF0dGFjaEV2ZW50ICovXG5cbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbnZhciBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcteGhyJyk7XG52YXIgZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJy4uL2dsb2JhbFRoaXMnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUjtcbm1vZHVsZS5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuXG4vKipcbiAqIEVtcHR5IGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkgKCkge31cblxuLyoqXG4gKiBYSFIgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBYSFIgKG9wdHMpIHtcbiAgUG9sbGluZy5jYWxsKHRoaXMsIG9wdHMpO1xuICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gb3B0cy5yZXF1ZXN0VGltZW91dDtcbiAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcblxuICBpZiAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cbiAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICB0aGlzLnhkID0gKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0cy5ob3N0bmFtZSAhPT0gbG9jYXRpb24uaG9zdG5hbWUpIHx8XG4gICAgICBwb3J0ICE9PSBvcHRzLnBvcnQ7XG4gICAgdGhpcy54cyA9IG9wdHMuc2VjdXJlICE9PSBpc1NTTDtcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KFhIUiwgUG9sbGluZyk7XG5cbi8qKlxuICogWEhSIHN1cHBvcnRzIGJpbmFyeVxuICovXG5cblhIUi5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBvcHRzLnVyaSA9IHRoaXMudXJpKCk7XG4gIG9wdHMueGQgPSB0aGlzLnhkO1xuICBvcHRzLnhzID0gdGhpcy54cztcbiAgb3B0cy5hZ2VudCA9IHRoaXMuYWdlbnQgfHwgZmFsc2U7XG4gIG9wdHMuc3VwcG9ydHNCaW5hcnkgPSB0aGlzLnN1cHBvcnRzQmluYXJ5O1xuICBvcHRzLmVuYWJsZXNYRFIgPSB0aGlzLmVuYWJsZXNYRFI7XG4gIG9wdHMud2l0aENyZWRlbnRpYWxzID0gdGhpcy53aXRoQ3JlZGVudGlhbHM7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuICBvcHRzLnJlcXVlc3RUaW1lb3V0ID0gdGhpcy5yZXF1ZXN0VGltZW91dDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLmV4dHJhSGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuXG4gIHJldHVybiBuZXcgUmVxdWVzdChvcHRzKTtcbn07XG5cbi8qKlxuICogU2VuZHMgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcbiAgdmFyIGlzQmluYXJ5ID0gdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnICYmIGRhdGEgIT09IHVuZGVmaW5lZDtcbiAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCh7IG1ldGhvZDogJ1BPU1QnLCBkYXRhOiBkYXRhLCBpc0JpbmFyeTogaXNCaW5hcnkgfSk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdzdWNjZXNzJywgZm4pO1xuICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvc3QgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5zZW5kWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygneGhyIHBvbGwnKTtcbiAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCgpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlcS5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgc2VsZi5vbkRhdGEoZGF0YSk7XG4gIH0pO1xuICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvbGwgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5wb2xsWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0IGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdCAob3B0cykge1xuICB0aGlzLm1ldGhvZCA9IG9wdHMubWV0aG9kIHx8ICdHRVQnO1xuICB0aGlzLnVyaSA9IG9wdHMudXJpO1xuICB0aGlzLnhkID0gISFvcHRzLnhkO1xuICB0aGlzLnhzID0gISFvcHRzLnhzO1xuICB0aGlzLmFzeW5jID0gZmFsc2UgIT09IG9wdHMuYXN5bmM7XG4gIHRoaXMuZGF0YSA9IHVuZGVmaW5lZCAhPT0gb3B0cy5kYXRhID8gb3B0cy5kYXRhIDogbnVsbDtcbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQ7XG4gIHRoaXMuaXNCaW5hcnkgPSBvcHRzLmlzQmluYXJ5O1xuICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gb3B0cy5zdXBwb3J0c0JpbmFyeTtcbiAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuICB0aGlzLndpdGhDcmVkZW50aWFscyA9IG9wdHMud2l0aENyZWRlbnRpYWxzO1xuICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gb3B0cy5yZXF1ZXN0VGltZW91dDtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleTtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG4gIHRoaXMuY2EgPSBvcHRzLmNhO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnM7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcblxuICB0aGlzLmNyZWF0ZSgpO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgWEhSIG9iamVjdCBhbmQgc2VuZHMgdGhlIHJlcXVlc3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0cyA9IHsgYWdlbnQ6IHRoaXMuYWdlbnQsIHhkb21haW46IHRoaXMueGQsIHhzY2hlbWU6IHRoaXMueHMsIGVuYWJsZXNYRFI6IHRoaXMuZW5hYmxlc1hEUiB9O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICB2YXIgeGhyID0gdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0cnkge1xuICAgIGRlYnVnKCd4aHIgb3BlbiAlczogJXMnLCB0aGlzLm1ldGhvZCwgdGhpcy51cmkpO1xuICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVyaSwgdGhpcy5hc3luYyk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuICAgICAgICB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrICYmIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sodHJ1ZSk7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgICBpZiAodGhpcy5leHRyYUhlYWRlcnMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGksIHRoaXMuZXh0cmFIZWFkZXJzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgaWYgKCdQT1NUJyA9PT0gdGhpcy5tZXRob2QpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLmlzQmluYXJ5KSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJyovKicpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAvLyBpZTYgY2hlY2tcbiAgICBpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdGhpcy53aXRoQ3JlZGVudGlhbHM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVxdWVzdFRpbWVvdXQpIHtcbiAgICAgIHhoci50aW1lb3V0ID0gdGhpcy5yZXF1ZXN0VGltZW91dDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNYRFIoKSkge1xuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5vbkxvYWQoKTtcbiAgICAgIH07XG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5vbkVycm9yKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSAyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBjb250ZW50VHlwZSA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJyk7XG4gICAgICAgICAgICBpZiAoc2VsZi5zdXBwb3J0c0JpbmFyeSAmJiBjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScgfHwgY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07IGNoYXJzZXQ9VVRGLTgnKSB7XG4gICAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDQgIT09IHhoci5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgIGlmICgyMDAgPT09IHhoci5zdGF0dXMgfHwgMTIyMyA9PT0geGhyLnN0YXR1cykge1xuICAgICAgICAgIHNlbGYub25Mb2FkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBgZXJyb3JgIGV2ZW50IGhhbmRsZXIgdGhhdCdzIHVzZXItc2V0XG4gICAgICAgICAgLy8gZG9lcyBub3QgdGhyb3cgaW4gdGhlIHNhbWUgdGljayBhbmQgZ2V0cyBjYXVnaHQgaGVyZVxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5vbkVycm9yKHR5cGVvZiB4aHIuc3RhdHVzID09PSAnbnVtYmVyJyA/IHhoci5zdGF0dXMgOiAwKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBkZWJ1ZygneGhyIGRhdGEgJXMnLCB0aGlzLmRhdGEpO1xuICAgIHhoci5zZW5kKHRoaXMuZGF0YSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBOZWVkIHRvIGRlZmVyIHNpbmNlIC5jcmVhdGUoKSBpcyBjYWxsZWQgZGlyZWN0bHkgZmhyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAgLy8gYW5kIHRodXMgdGhlICdlcnJvcicgZXZlbnQgY2FuIG9ubHkgYmUgb25seSBib3VuZCAqYWZ0ZXIqIHRoaXMgZXhjZXB0aW9uXG4gICAgLy8gb2NjdXJzLiAgVGhlcmVmb3JlLCBhbHNvLCB3ZSBjYW5ub3QgdGhyb3cgaGVyZSBhdCBhbGwuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLm9uRXJyb3IoZSk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLmluZGV4ID0gUmVxdWVzdC5yZXF1ZXN0c0NvdW50Kys7XG4gICAgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLmluZGV4XSA9IHRoaXM7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc3VjY2Vzc2Z1bCByZXNwb25zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vblN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnc3VjY2VzcycpO1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGlmIHdlIGhhdmUgZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKTtcbiAgdGhpcy5vblN1Y2Nlc3MoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHRoaXMuY2xlYW51cCh0cnVlKTtcbn07XG5cbi8qKlxuICogQ2xlYW5zIHVwIGhvdXNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoZnJvbUVycm9yKSB7XG4gIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHRoaXMueGhyIHx8IG51bGwgPT09IHRoaXMueGhyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHhtbGh0dHByZXF1ZXN0XG4gIGlmICh0aGlzLmhhc1hEUigpKSB7XG4gICAgdGhpcy54aHIub25sb2FkID0gdGhpcy54aHIub25lcnJvciA9IGVtcHR5O1xuICB9IGVsc2Uge1xuICAgIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVtcHR5O1xuICB9XG5cbiAgaWYgKGZyb21FcnJvcikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnhoci5hYm9ydCgpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cblxuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGRlbGV0ZSBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdO1xuICB9XG5cbiAgdGhpcy54aHIgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBsb2FkLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uTG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRhdGE7XG4gIHRyeSB7XG4gICAgdmFyIGNvbnRlbnRUeXBlO1xuICAgIHRyeSB7XG4gICAgICBjb250ZW50VHlwZSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScgfHwgY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07IGNoYXJzZXQ9VVRGLTgnKSB7XG4gICAgICBkYXRhID0gdGhpcy54aHIucmVzcG9uc2UgfHwgdGhpcy54aHIucmVzcG9uc2VUZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gdGhpcy54aHIucmVzcG9uc2VUZXh0O1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMub25FcnJvcihlKTtcbiAgfVxuICBpZiAobnVsbCAhPSBkYXRhKSB7XG4gICAgdGhpcy5vbkRhdGEoZGF0YSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgaXQgaGFzIFhEb21haW5SZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmhhc1hEUiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHR5cGVvZiBYRG9tYWluUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcgJiYgIXRoaXMueHMgJiYgdGhpcy5lbmFibGVzWERSO1xufTtcblxuLyoqXG4gKiBBYm9ydHMgdGhlIHJlcXVlc3QuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jbGVhbnVwKCk7XG59O1xuXG4vKipcbiAqIEFib3J0cyBwZW5kaW5nIHJlcXVlc3RzIHdoZW4gdW5sb2FkaW5nIHRoZSB3aW5kb3cuIFRoaXMgaXMgbmVlZGVkIHRvIHByZXZlbnRcbiAqIG1lbW9yeSBsZWFrcyAoZS5nLiB3aGVuIHVzaW5nIElFKSBhbmQgdG8gZW5zdXJlIHRoYXQgbm8gc3B1cmlvdXMgZXJyb3IgaXNcbiAqIGVtaXR0ZWQuXG4gKi9cblxuUmVxdWVzdC5yZXF1ZXN0c0NvdW50ID0gMDtcblJlcXVlc3QucmVxdWVzdHMgPSB7fTtcblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgaWYgKHR5cGVvZiBhdHRhY2hFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGF0dGFjaEV2ZW50KCdvbnVubG9hZCcsIHVubG9hZEhhbmRsZXIpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHRlcm1pbmF0aW9uRXZlbnQgPSAnb25wYWdlaGlkZScgaW4gZ2xvYmFsVGhpcyA/ICdwYWdlaGlkZScgOiAndW5sb2FkJztcbiAgICBhZGRFdmVudExpc3RlbmVyKHRlcm1pbmF0aW9uRXZlbnQsIHVubG9hZEhhbmRsZXIsIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bmxvYWRIYW5kbGVyICgpIHtcbiAgZm9yICh2YXIgaSBpbiBSZXF1ZXN0LnJlcXVlc3RzKSB7XG4gICAgaWYgKFJlcXVlc3QucmVxdWVzdHMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIFJlcXVlc3QucmVxdWVzdHNbaV0uYWJvcnQoKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtcyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JykgfHxcbiAgICBwbHVyYWwobXMsIGgsICdob3VyJykgfHxcbiAgICBwbHVyYWwobXMsIG0sICdtaW51dGUnKSB8fFxuICAgIHBsdXJhbChtcywgcywgJ3NlY29uZCcpIHx8XG4gICAgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobXMgPCBuICogMS41KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIH1cbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVUZXN0ZXIgPSByZXF1aXJlKCcuL2ludGVybmFsL2NyZWF0ZVRlc3RlcicpO1xuXG52YXIgX2NyZWF0ZVRlc3RlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUZXN0ZXIpO1xuXG52YXIgX2RvUGFyYWxsZWwgPSByZXF1aXJlKCcuL2ludGVybmFsL2RvUGFyYWxsZWwnKTtcblxudmFyIF9kb1BhcmFsbGVsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RvUGFyYWxsZWwpO1xuXG52YXIgX2lkZW50aXR5ID0gcmVxdWlyZSgnbG9kYXNoL2lkZW50aXR5Jyk7XG5cbnZhciBfaWRlbnRpdHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaWRlbnRpdHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBgY29sbGAgc2F0aXNmaWVzIGFuIGFzeW5jIHRlc3QuXG4gKiBJZiBhbnkgaXRlcmF0ZWUgY2FsbCByZXR1cm5zIGB0cnVlYCwgdGhlIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseVxuICogY2FsbGVkLlxuICpcbiAqIEBuYW1lIHNvbWVcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBhbGlhcyBhbnlcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW1cbiAqIGluIHRoZSBjb2xsZWN0aW9ucyBpbiBwYXJhbGxlbC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gYHJlc3VsdGAgdmFsdWUuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhcyBzb29uIGFzIGFueVxuICogaXRlcmF0ZWUgcmV0dXJucyBgdHJ1ZWAsIG9yIGFmdGVyIGFsbCB0aGUgaXRlcmF0ZWUgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuXG4gKiBSZXN1bHQgd2lsbCBiZSBlaXRoZXIgYHRydWVgIG9yIGBmYWxzZWAgZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jXG4gKiB0ZXN0cy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLnNvbWUoWydmaWxlMScsJ2ZpbGUyJywnZmlsZTMnXSwgZnVuY3Rpb24oZmlsZVBhdGgsIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuYWNjZXNzKGZpbGVQYXRoLCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycilcbiAqICAgICB9KTtcbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gaWYgcmVzdWx0IGlzIHRydWUgdGhlbiBhdCBsZWFzdCBvbmUgb2YgdGhlIGZpbGVzIGV4aXN0c1xuICogfSk7XG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCBfZG9QYXJhbGxlbDIuZGVmYXVsdCkoKDAsIF9jcmVhdGVUZXN0ZXIyLmRlZmF1bHQpKEJvb2xlYW4sIF9pZGVudGl0eTIuZGVmYXVsdCkpO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFNUQVJUX01BU0tTID0gW1xuICAwYjExMTExMTExLFxuICAwYjExMTExMTEwLFxuICAwYjExMTExMTAwLFxuICAwYjExMTExMDAwLFxuICAwYjExMTEwMDAwLFxuICAwYjExMTAwMDAwLFxuICAwYjExMDAwMDAwLFxuICAwYjEwMDAwMDAwXG5dXG5cbmNvbnN0IFNUT1BfTUFTS1MgPSBbXG4gIDBiMDAwMDAwMDEsXG4gIDBiMDAwMDAwMTEsXG4gIDBiMDAwMDAxMTEsXG4gIDBiMDAwMDExMTEsXG4gIDBiMDAwMTExMTEsXG4gIDBiMDAxMTExMTEsXG4gIDBiMDExMTExMTEsXG4gIDBiMTExMTExMTFcbl1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBDb25zdW1hYmxlQnVmZmVyIHtcbiAgY29uc3RydWN0b3IgKHZhbHVlKSB7XG4gICAgdGhpcy5fdmFsdWUgPSB2YWx1ZVxuICAgIHRoaXMuX2N1cnJlbnRCeXRlUG9zID0gdmFsdWUubGVuZ3RoIC0gMVxuICAgIHRoaXMuX2N1cnJlbnRCaXRQb3MgPSA3XG4gIH1cblxuICBhdmFpbGFibGVCaXRzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEJpdFBvcyArIDEgKyB0aGlzLl9jdXJyZW50Qnl0ZVBvcyAqIDhcbiAgfVxuXG4gIHRvdGFsQml0cyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlLmxlbmd0aCAqIDhcbiAgfVxuXG4gIHRha2UgKGJpdHMpIHtcbiAgICBsZXQgcGVuZGluZ0JpdHMgPSBiaXRzXG4gICAgbGV0IHJlc3VsdCA9IDBcbiAgICB3aGlsZSAocGVuZGluZ0JpdHMgJiYgdGhpcy5faGF2ZUJpdHMoKSkge1xuICAgICAgY29uc3QgYnl0ZSA9IHRoaXMuX3ZhbHVlW3RoaXMuX2N1cnJlbnRCeXRlUG9zXVxuICAgICAgY29uc3QgYXZhaWxhYmxlQml0cyA9IHRoaXMuX2N1cnJlbnRCaXRQb3MgKyAxXG4gICAgICBjb25zdCB0YWtpbmcgPSBNYXRoLm1pbihhdmFpbGFibGVCaXRzLCBwZW5kaW5nQml0cylcbiAgICAgIGNvbnN0IHZhbHVlID0gYnl0ZUJpdHNUb0ludChieXRlLCBhdmFpbGFibGVCaXRzIC0gdGFraW5nLCB0YWtpbmcpXG4gICAgICByZXN1bHQgPSAocmVzdWx0IDw8IHRha2luZykgKyB2YWx1ZVxuXG4gICAgICBwZW5kaW5nQml0cyAtPSB0YWtpbmdcblxuICAgICAgdGhpcy5fY3VycmVudEJpdFBvcyAtPSB0YWtpbmdcbiAgICAgIGlmICh0aGlzLl9jdXJyZW50Qml0UG9zIDwgMCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50Qml0UG9zID0gN1xuICAgICAgICB0aGlzLl9jdXJyZW50Qnl0ZVBvcy0tXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgdW50YWtlIChiaXRzKSB7XG4gICAgdGhpcy5fY3VycmVudEJpdFBvcyArPSBiaXRzXG4gICAgd2hpbGUgKHRoaXMuX2N1cnJlbnRCaXRQb3MgPiA3KSB7XG4gICAgICB0aGlzLl9jdXJyZW50Qml0UG9zIC09IDhcbiAgICAgIHRoaXMuX2N1cnJlbnRCeXRlUG9zICs9IDFcbiAgICB9XG4gIH1cblxuICBfaGF2ZUJpdHMgKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50Qnl0ZVBvcyA+PSAwXG4gIH1cbn1cblxuZnVuY3Rpb24gYnl0ZUJpdHNUb0ludCAoYnl0ZSwgc3RhcnQsIGxlbmd0aCkge1xuICBjb25zdCBtYXNrID0gbWFza0ZvcihzdGFydCwgbGVuZ3RoKVxuICByZXR1cm4gKGJ5dGUgJiBtYXNrKSA+Pj4gc3RhcnRcbn1cblxuZnVuY3Rpb24gbWFza0ZvciAoc3RhcnQsIGxlbmd0aCkge1xuICByZXR1cm4gU1RBUlRfTUFTS1Nbc3RhcnRdICYgU1RPUF9NQVNLU1tNYXRoLm1pbihsZW5ndGggKyBzdGFydCAtIDEsIDcpXVxufVxuIiwiLy8gUG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9lbmQtb2Ytc3RyZWFtIHdpdGhcbi8vIHBlcm1pc3Npb24gZnJvbSB0aGUgYXV0aG9yLCBNYXRoaWFzIEJ1dXMgKEBtYWZpbnRvc2gpLlxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2Rlcy5FUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRTtcblxuZnVuY3Rpb24gb25jZShjYWxsYmFjaykge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuICAgIGNhbGxlZCA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBpc1JlcXVlc3Qoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGVvcyhzdHJlYW0sIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVvcyhzdHJlYW0sIG51bGwsIG9wdHMpO1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICB2YXIgcmVhZGFibGUgPSBvcHRzLnJlYWRhYmxlIHx8IG9wdHMucmVhZGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS5yZWFkYWJsZTtcbiAgdmFyIHdyaXRhYmxlID0gb3B0cy53cml0YWJsZSB8fCBvcHRzLndyaXRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ud3JpdGFibGU7XG5cbiAgdmFyIG9ubGVnYWN5ZmluaXNoID0gZnVuY3Rpb24gb25sZWdhY3lmaW5pc2goKSB7XG4gICAgaWYgKCFzdHJlYW0ud3JpdGFibGUpIG9uZmluaXNoKCk7XG4gIH07XG5cbiAgdmFyIHdyaXRhYmxlRW5kZWQgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGUgJiYgc3RyZWFtLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkO1xuXG4gIHZhciBvbmZpbmlzaCA9IGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIHdyaXRhYmxlID0gZmFsc2U7XG4gICAgd3JpdGFibGVFbmRlZCA9IHRydWU7XG4gICAgaWYgKCFyZWFkYWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuICB9O1xuXG4gIHZhciByZWFkYWJsZUVuZGVkID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlICYmIHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkO1xuXG4gIHZhciBvbmVuZCA9IGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIHJlYWRhYmxlID0gZmFsc2U7XG4gICAgcmVhZGFibGVFbmRlZCA9IHRydWU7XG4gICAgaWYgKCF3cml0YWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuICB9O1xuXG4gIHZhciBvbmVycm9yID0gZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgfTtcblxuICB2YXIgb25jbG9zZSA9IGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgdmFyIGVycjtcblxuICAgIGlmIChyZWFkYWJsZSAmJiAhcmVhZGFibGVFbmRlZCkge1xuICAgICAgaWYgKCFzdHJlYW0uX3JlYWRhYmxlU3RhdGUgfHwgIXN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRlZCkgZXJyID0gbmV3IEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gICAgfVxuXG4gICAgaWYgKHdyaXRhYmxlICYmICF3cml0YWJsZUVuZGVkKSB7XG4gICAgICBpZiAoIXN0cmVhbS5fd3JpdGFibGVTdGF0ZSB8fCAhc3RyZWFtLl93cml0YWJsZVN0YXRlLmVuZGVkKSBlcnIgPSBuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIG9ucmVxdWVzdCA9IGZ1bmN0aW9uIG9ucmVxdWVzdCgpIHtcbiAgICBzdHJlYW0ucmVxLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gIH07XG5cbiAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSB7XG4gICAgc3RyZWFtLm9uKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ub24oJ2Fib3J0Jywgb25jbG9zZSk7XG4gICAgaWYgKHN0cmVhbS5yZXEpIG9ucmVxdWVzdCgpO2Vsc2Ugc3RyZWFtLm9uKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcbiAgfSBlbHNlIGlmICh3cml0YWJsZSAmJiAhc3RyZWFtLl93cml0YWJsZVN0YXRlKSB7XG4gICAgLy8gbGVnYWN5IHN0cmVhbXNcbiAgICBzdHJlYW0ub24oJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ub24oJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuICB9XG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBvbmVuZCk7XG4gIHN0cmVhbS5vbignZmluaXNoJywgb25maW5pc2gpO1xuICBpZiAob3B0cy5lcnJvciAhPT0gZmFsc2UpIHN0cmVhbS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgc3RyZWFtLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY29tcGxldGUnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdhYm9ydCcsIG9uY2xvc2UpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcigncmVxdWVzdCcsIG9ucmVxdWVzdCk7XG4gICAgaWYgKHN0cmVhbS5yZXEpIHN0cmVhbS5yZXEucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW9zOyIsIi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvcHVtcCB3aXRoXG4vLyBwZXJtaXNzaW9uIGZyb20gdGhlIGF1dGhvciwgTWF0aGlhcyBCdXVzIChAbWFmaW50b3NoKS5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVvcztcblxuZnVuY3Rpb24gb25jZShjYWxsYmFjaykge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgY2FsbGJhY2suYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfTUlTU0lOR19BUkdTID0gX3JlcXVpcmUkY29kZXMuRVJSX01JU1NJTkdfQVJHUyxcbiAgICBFUlJfU1RSRUFNX0RFU1RST1lFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fREVTVFJPWUVEO1xuXG5mdW5jdGlvbiBub29wKGVycikge1xuICAvLyBSZXRocm93IHRoZSBlcnJvciBpZiBpdCBleGlzdHMgdG8gYXZvaWQgc3dhbGxvd2luZyBpdFxuICBpZiAoZXJyKSB0aHJvdyBlcnI7XG59XG5cbmZ1bmN0aW9uIGlzUmVxdWVzdChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrKTtcbiAgdmFyIGNsb3NlZCA9IGZhbHNlO1xuICBzdHJlYW0ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGNsb3NlZCA9IHRydWU7XG4gIH0pO1xuICBpZiAoZW9zID09PSB1bmRlZmluZWQpIGVvcyA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpO1xuICBlb3Moc3RyZWFtLCB7XG4gICAgcmVhZGFibGU6IHJlYWRpbmcsXG4gICAgd3JpdGFibGU6IHdyaXRpbmdcbiAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgIGNsb3NlZCA9IHRydWU7XG4gICAgY2FsbGJhY2soKTtcbiAgfSk7XG4gIHZhciBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoY2xvc2VkKSByZXR1cm47XG4gICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgIGRlc3Ryb3llZCA9IHRydWU7IC8vIHJlcXVlc3QuZGVzdHJveSBqdXN0IGRvIC5lbmQgLSAuYWJvcnQgaXMgd2hhdCB3ZSB3YW50XG5cbiAgICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHJldHVybiBzdHJlYW0uYWJvcnQoKTtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSByZXR1cm4gc3RyZWFtLmRlc3Ryb3koKTtcbiAgICBjYWxsYmFjayhlcnIgfHwgbmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCdwaXBlJykpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjYWxsKGZuKSB7XG4gIGZuKCk7XG59XG5cbmZ1bmN0aW9uIHBpcGUoZnJvbSwgdG8pIHtcbiAgcmV0dXJuIGZyb20ucGlwZSh0byk7XG59XG5cbmZ1bmN0aW9uIHBvcENhbGxiYWNrKHN0cmVhbXMpIHtcbiAgaWYgKCFzdHJlYW1zLmxlbmd0aCkgcmV0dXJuIG5vb3A7XG4gIGlmICh0eXBlb2Ygc3RyZWFtc1tzdHJlYW1zLmxlbmd0aCAtIDFdICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gbm9vcDtcbiAgcmV0dXJuIHN0cmVhbXMucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHBpcGVsaW5lKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3RyZWFtcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzdHJlYW1zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIGNhbGxiYWNrID0gcG9wQ2FsbGJhY2soc3RyZWFtcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHN0cmVhbXNbMF0pKSBzdHJlYW1zID0gc3RyZWFtc1swXTtcblxuICBpZiAoc3RyZWFtcy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ3N0cmVhbXMnKTtcbiAgfVxuXG4gIHZhciBlcnJvcjtcbiAgdmFyIGRlc3Ryb3lzID0gc3RyZWFtcy5tYXAoZnVuY3Rpb24gKHN0cmVhbSwgaSkge1xuICAgIHZhciByZWFkaW5nID0gaSA8IHN0cmVhbXMubGVuZ3RoIC0gMTtcbiAgICB2YXIgd3JpdGluZyA9IGkgPiAwO1xuICAgIHJldHVybiBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoIWVycm9yKSBlcnJvciA9IGVycjtcbiAgICAgIGlmIChlcnIpIGRlc3Ryb3lzLmZvckVhY2goY2FsbCk7XG4gICAgICBpZiAocmVhZGluZykgcmV0dXJuO1xuICAgICAgZGVzdHJveXMuZm9yRWFjaChjYWxsKTtcbiAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBzdHJlYW1zLnJlZHVjZShwaXBlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwaXBlbGluZTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuJ3VzZSBzdHJpY3QnO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xuXG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShEdXBsZXgsIFJlYWRhYmxlKTtcblxue1xuICAvLyBBbGxvdyB0aGUga2V5cyBhcnJheSB0byBiZSBHQydlZC5cbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG5cbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuICAgICAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG4gICAgfVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKCk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTsgLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gSWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47IC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG5cbiAgcHJvY2Vzcy5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX01VTFRJUExFX0NBTExCQUNLID0gX3JlcXVpcmUkY29kZXMuRVJSX01VTFRJUExFX0NBTExCQUNLLFxuICAgIEVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HLFxuICAgIEVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMDtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoY2IgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcbiAgY2IoZXIpO1xuICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07IC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH0gLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuXG5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicgJiYgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkKSB7XG4gICAgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59OyAvLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuXG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3RyYW5zZm9ybSgpJykpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcblxuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07IC8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG5cbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2IoZXJyMik7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7IC8vIFRPRE8oQnJpZGdlQVIpOiBXcml0ZSBhIHRlc3QgZm9yIHRoZXNlIHR3byBlcnJvciBjYXNlc1xuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuXG4gIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wKCk7XG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcoKTtcbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuLyogPHJlcGxhY2VtZW50PiAqL1xuXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59IC8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5cblxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuXG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5cbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cblxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpLFxuICAgIGdldEhpZ2hXYXRlck1hcmsgPSBfcmVxdWlyZS5nZXRIaWdoV2F0ZXJNYXJrO1xuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX01VTFRJUExFX0NBTExCQUNLID0gX3JlcXVpcmUkY29kZXMuRVJSX01VTFRJUExFX0NBTExCQUNLLFxuICAgIEVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0NBTk5PVF9QSVBFLFxuICAgIEVSUl9TVFJFQU1fREVTVFJPWUVEID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9ERVNUUk9ZRUQsXG4gICAgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fTlVMTF9WQUxVRVMsXG4gICAgRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCxcbiAgICBFUlJfVU5LTk9XTl9FTkNPRElORyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9VTktOT1dOX0VOQ09ESU5HO1xuXG52YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbSxcbiAgLy8gZS5nLiBvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZSB2cy4gb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGUsIGV0Yy5cblxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4OyAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlOyAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcblxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCBpc0R1cGxleCk7IC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcblxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7IC8vIGRyYWluIGV2ZW50IGZsYWcuXG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTsgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcblxuICB0aGlzLmVuZGluZyA9IGZhbHNlOyAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG5cbiAgdGhpcy5lbmRlZCA9IGZhbHNlOyAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcblxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7IC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7IC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cblxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7IC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7IC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG5cbiAgdGhpcy5sZW5ndGggPSAwOyAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlOyAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG5cbiAgdGhpcy5jb3JrZWQgPSAwOyAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cblxuICB0aGlzLnN5bmMgPSB0cnVlOyAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlOyAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG5cbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTsgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG5cblxuICB0aGlzLndyaXRlY2IgPSBudWxsOyAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDsgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG5cbiAgdGhpcy5wZW5kaW5nY2IgPSAwOyAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG5cbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlOyAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7IC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG5cbiAgdGhpcy5lbWl0Q2xvc2UgPSBvcHRpb25zLmVtaXRDbG9zZSAhPT0gZmFsc2U7IC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZmluaXNoJyAoYW5kIHBvdGVudGlhbGx5ICdlbmQnKVxuXG4gIHRoaXMuYXV0b0Rlc3Ryb3kgPSAhIW9wdGlvbnMuYXV0b0Rlc3Ryb3k7IC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7IC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuXG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiB3cml0YWJsZVN0YXRlQnVmZmVyR2V0dGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTsgLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG5cblxudmFyIHJlYWxIYXNJbnN0YW5jZTtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gcmVhbEhhc0luc3RhbmNlKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7IC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgV3JpdGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjVcblxuICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuICBpZiAoIWlzRHVwbGV4ICYmICFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykpIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzLCBpc0R1cGxleCk7IC8vIGxlZ2FjeS5cblxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59IC8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cblxuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUoKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EKCk7IC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG5cbiAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTtcbn0gLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuXG5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciBlcjtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBFUlJfU1RSRUFNX05VTExfVkFMVUVTKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdjaHVuaycsIFsnc3RyaW5nJywgJ0J1ZmZlciddLCBjaHVuayk7XG4gIH1cblxuICBpZiAoZXIpIHtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcblxuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuICBpZiAoc3RhdGUuZW5kaW5nKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgRVJSX1VOS05PV05fRU5DT0RJTkcoZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cblxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pOyAvLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcblxuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7IC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG5cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHN0YXRlLmRlc3Ryb3llZCkgc3RhdGUub253cml0ZShuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoJ3dyaXRlJykpO2Vsc2UgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7IC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgZXJyb3JcblxuICAgIHByb2Nlc3MubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpOyAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKTtcbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpIHx8IHN0cmVhbS5kZXN0cm95ZWQ7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufSAvLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cblxuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59IC8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5cblxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cblxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7IC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG5cbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07IC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfd3JpdGUoKScpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7IC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfSAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG5cblxuICBpZiAoIXN0YXRlLmVuZGluZykgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cblxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycik7XG4gICAgfVxuXG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nICYmICFzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcblxuICAgICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAgIC8vIEluIGNhc2Ugb2YgZHVwbGV4IHN0cmVhbXMgd2UgbmVlZCBhIHdheSB0byBkZXRlY3RcbiAgICAgICAgLy8gaWYgdGhlIHJlYWRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGxcbiAgICAgICAgdmFyIHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAgICAgICBpZiAoIXJTdGF0ZSB8fCByU3RhdGUuYXV0b0Rlc3Ryb3kgJiYgclN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuXG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcHJvY2Vzcy5uZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG5cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcblxuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfSAvLyByZXVzZSB0aGUgZnJlZSBjb3JrUmVxLlxuXG5cbiAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblxuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gRUVsaXN0ZW5lckNvdW50KGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuXG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIGRlYnVnO1xuXG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uIGRlYnVnKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9idWZmZXJfbGlzdCcpO1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RhdGUnKSxcbiAgICBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyaztcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRixcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICAgIEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UOyAvLyBMYXp5IGxvYWRlZCB0byBpbXByb3ZlIHRoZSBzdGFydHVwIHBlcmZvcm1hbmNlLlxuXG5cbnZhciBTdHJpbmdEZWNvZGVyO1xudmFyIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjtcbnZhciBmcm9tO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTtcbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pOyAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKEFycmF5LmlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDsgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcblxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTsgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KTsgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7IC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cblxuICB0aGlzLnN5bmMgPSB0cnVlOyAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cblxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHRoaXMucGF1c2VkID0gdHJ1ZTsgLy8gU2hvdWxkIGNsb3NlIGJlIGVtaXR0ZWQgb24gZGVzdHJveS4gRGVmYXVsdHMgdG8gdHJ1ZS5cblxuICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTsgLy8gU2hvdWxkIC5kZXN0cm95KCkgYmUgY2FsbGVkIGFmdGVyICdlbmQnIChhbmQgcG90ZW50aWFsbHkgJ2ZpbmlzaCcpXG5cbiAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTsgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cblxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JzsgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcblxuICB0aGlzLmF3YWl0RHJhaW4gPSAwOyAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG5cbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcblxuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpOyAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBSZWFkYWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxuXG4gIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzLCBpc0R1cGxleCk7IC8vIGxlZ2FjeVxuXG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5cblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIGNiKGVycik7XG59OyAvLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuXG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07IC8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIGRlYnVnKCdyZWFkYWJsZUFkZENodW5rJywgY2h1bmspO1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG5cbiAgICBpZiAoZXIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UKCkpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GKCkpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gLy8gV2UgY2FuIHB1c2ggbW9yZSBkYXRhIGlmIHdlIGFyZSBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyay5cbiAgLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWUgbW9yZSBieXRlcy5cbiAgLy8gVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCwgc3VjaCBhcyB0aGUgcmVwbC5cblxuXG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuXG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuXG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJywgJ1VpbnQ4QXJyYXknXSwgY2h1bmspO1xuICB9XG5cbiAgcmV0dXJuIGVyO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB2YXIgZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IGRlY29kZXI7IC8vIElmIHNldEVuY29kaW5nKG51bGwpLCBkZWNvZGVyLmVuY29kaW5nIGVxdWFscyB1dGY4XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2Rlci5lbmNvZGluZzsgLy8gSXRlcmF0ZSBvdmVyIGN1cnJlbnQgYnVmZmVyIHRvIGNvbnZlcnQgYWxyZWFkeSBzdG9yZWQgQnVmZmVyczpcblxuICB2YXIgcCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmhlYWQ7XG4gIHZhciBjb250ZW50ID0gJyc7XG5cbiAgd2hpbGUgKHAgIT09IG51bGwpIHtcbiAgICBjb250ZW50ICs9IGRlY29kZXIud3JpdGUocC5kYXRhKTtcbiAgICBwID0gcC5uZXh0O1xuICB9XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuY2xlYXIoKTtcblxuICBpZiAoY29udGVudCAhPT0gJycpIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLnB1c2goY29udGVudCk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoID0gY29udGVudC5sZW5ndGg7XG4gIHJldHVybiB0aGlzO1xufTsgLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDFHQlxuXG5cbnZhciBNQVhfSFdNID0gMHg0MDAwMDAwMDtcblxuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgLy8gVE9ETyhyb25hZyk6IFRocm93IEVSUl9WQUxVRV9PVVRfT0ZfUkFOR0UuXG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuXG4gIHJldHVybiBuO1xufSAvLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cblxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuXG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9IC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuXG5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47IC8vIERvbid0IGhhdmUgZW5vdWdoXG5cbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufSAvLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlOyAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmICgoc3RhdGUuaGlnaFdhdGVyTWFyayAhPT0gMCA/IHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIDogc3RhdGUubGVuZ3RoID4gMCkgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpOyAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG5cblxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7IC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH0gLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuXG5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTsgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cblxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcblxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG5cbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7IC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ29uRW9mQ2h1bmsnKTtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuXG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUuc3luYykge1xuICAgIC8vIGlmIHdlIGFyZSBzeW5jLCB3YWl0IHVudGlsIG5leHQgdGljayB0byBlbWl0IHRoZSBkYXRhLlxuICAgIC8vIE90aGVyd2lzZSB3ZSByaXNrIGVtaXR0aW5nIGRhdGEgaW4gdGhlIGZsb3coKVxuICAgIC8vIHRoZSByZWFkYWJsZSBjb2RlIHRyaWdnZXJzIGR1cmluZyBhIHJlYWQoKSBjYWxsXG4gICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICB9XG4gIH1cbn0gLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cblxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLm5lZWRSZWFkYWJsZSwgc3RhdGUuZW1pdHRlZFJlYWRhYmxlKTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW1pdFJlYWRhYmxlXycsIHN0YXRlLmRlc3Ryb3llZCwgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG5cbiAgaWYgKCFzdGF0ZS5kZXN0cm95ZWQgJiYgKHN0YXRlLmxlbmd0aCB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgfSAvLyBUaGUgc3RyZWFtIG5lZWRzIGFub3RoZXIgcmVhZGFibGUgZXZlbnQgaWZcbiAgLy8gMS4gSXQgaXMgbm90IGZsb3dpbmcsIGFzIHRoZSBmbG93IG1lY2hhbmlzbSB3aWxsIHRha2VcbiAgLy8gICAgY2FyZSBvZiBpdC5cbiAgLy8gMi4gSXQgaXMgbm90IGVuZGVkLlxuICAvLyAzLiBJdCBpcyBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyaywgc28gd2UgY2FuIHNjaGVkdWxlXG4gIC8vICAgIGFub3RoZXIgcmVhZGFibGUgbGF0ZXIuXG5cblxuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIGZsb3coc3RyZWFtKTtcbn0gLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICAvLyBBdHRlbXB0IHRvIHJlYWQgbW9yZSBkYXRhIGlmIHdlIHNob3VsZC5cbiAgLy9cbiAgLy8gVGhlIGNvbmRpdGlvbnMgZm9yIHJlYWRpbmcgbW9yZSBkYXRhIGFyZSAob25lIG9mKTpcbiAgLy8gLSBOb3QgZW5vdWdoIGRhdGEgYnVmZmVyZWQgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspLiBUaGUgbG9vcFxuICAvLyAgIGlzIHJlc3BvbnNpYmxlIGZvciBmaWxsaW5nIHRoZSBidWZmZXIgd2l0aCBlbm91Z2ggZGF0YSBpZiBzdWNoIGRhdGFcbiAgLy8gICBpcyBhdmFpbGFibGUuIElmIGhpZ2hXYXRlck1hcmsgaXMgMCBhbmQgd2UgYXJlIG5vdCBpbiB0aGUgZmxvd2luZyBtb2RlXG4gIC8vICAgd2Ugc2hvdWxkIF9ub3RfIGF0dGVtcHQgdG8gYnVmZmVyIGFueSBleHRyYSBkYXRhLiBXZSdsbCBnZXQgbW9yZSBkYXRhXG4gIC8vICAgd2hlbiB0aGUgc3RyZWFtIGNvbnN1bWVyIGNhbGxzIHJlYWQoKSBpbnN0ZWFkLlxuICAvLyAtIE5vIGRhdGEgaW4gdGhlIGJ1ZmZlciwgYW5kIHRoZSBzdHJlYW0gaXMgaW4gZmxvd2luZyBtb2RlLiBJbiB0aGlzIG1vZGVcbiAgLy8gICB0aGUgbG9vcCBiZWxvdyBpcyByZXNwb25zaWJsZSBmb3IgZW5zdXJpbmcgcmVhZCgpIGlzIGNhbGxlZC4gRmFpbGluZyB0b1xuICAvLyAgIGNhbGwgcmVhZCBoZXJlIHdvdWxkIGFib3J0IHRoZSBmbG93IGFuZCB0aGVyZSdzIG5vIG90aGVyIG1lY2hhbmlzbSBmb3JcbiAgLy8gICBjb250aW51aW5nIHRoZSBmbG93IGlmIHRoZSBzdHJlYW0gY29uc3VtZXIgaGFzIGp1c3Qgc3Vic2NyaWJlZCB0byB0aGVcbiAgLy8gICAnZGF0YScgZXZlbnQuXG4gIC8vXG4gIC8vIEluIGFkZGl0aW9uIHRvIHRoZSBhYm92ZSBjb25kaXRpb25zIHRvIGtlZXAgcmVhZGluZyBkYXRhLCB0aGUgZm9sbG93aW5nXG4gIC8vIGNvbmRpdGlvbnMgcHJldmVudCB0aGUgZGF0YSBmcm9tIGJlaW5nIHJlYWQ6XG4gIC8vIC0gVGhlIHN0cmVhbSBoYXMgZW5kZWQgKHN0YXRlLmVuZGVkKS5cbiAgLy8gLSBUaGVyZSBpcyBhbHJlYWR5IGEgcGVuZGluZyAncmVhZCcgb3BlcmF0aW9uIChzdGF0ZS5yZWFkaW5nKS4gVGhpcyBpcyBhXG4gIC8vICAgY2FzZSB3aGVyZSB0aGUgdGhlIHN0cmVhbSBoYXMgY2FsbGVkIHRoZSBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIF9yZWFkKClcbiAgLy8gICBtZXRob2QsIGJ1dCB0aGV5IGFyZSBwcm9jZXNzaW5nIHRoZSBjYWxsIGFzeW5jaHJvbm91c2x5IGFuZCBoYXZlIF9ub3RfXG4gIC8vICAgY2FsbGVkIHB1c2goKSB3aXRoIG5ldyBkYXRhLiBJbiB0aGlzIGNhc2Ugd2Ugc2tpcCBwZXJmb3JtaW5nIG1vcmVcbiAgLy8gICByZWFkKClzLiBUaGUgZXhlY3V0aW9uIGVuZHMgaW4gdGhpcyBtZXRob2QgYWdhaW4gYWZ0ZXIgdGhlIF9yZWFkKCkgZW5kc1xuICAvLyAgIHVwIGNhbGxpbmcgcHVzaCgpIHdpdGggbW9yZSBkYXRhLlxuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwKSkge1xuICAgIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKSAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gIH1cblxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufSAvLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ19yZWFkKCknKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuXG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG5cbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfSAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cblxuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTsgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBjbGVhbmVkVXAgPSB0cnVlOyAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGRlYnVnKCdkZXN0LndyaXRlJywgcmV0KTtcblxuICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgfVxuXG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH0gLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cblxuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGVycm9yT3JEZXN0cm95KGRlc3QsIGVyKTtcbiAgfSAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG5cblxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7IC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cblxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuXG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfSAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuXG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTsgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwaXBlT25EcmFpbkZ1bmN0aW9uUmVzdWx0KCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7XG4gICAgaGFzVW5waXBlZDogZmFsc2VcbiAgfTsgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpczsgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzOyAvLyBnb3QgYSBtYXRjaC5cblxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHtcbiAgICAgICAgaGFzVW5waXBlZDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG5cblxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gIHJldHVybiB0aGlzO1xufTsgLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblxuXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIHVwZGF0ZSByZWFkYWJsZUxpc3RlbmluZyBzbyB0aGF0IHJlc3VtZSgpIG1heSBiZSBhIG5vLW9wXG4gICAgLy8gYSBmZXcgbGluZXMgZG93bi4gVGhpcyBpcyBuZWVkZWQgdG8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScpLlxuICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdGhpcy5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMDsgLy8gVHJ5IHN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBkZWJ1Zygnb24gcmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLnJlYWRpbmcpO1xuXG4gICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIHNvbWVvbmUgc3RpbGwgbGlzdGVuaW5nIHRvXG4gICAgLy8gcmVhZGFibGUgYW5kIHJlc2V0IHRoZSBzdGF0ZS4gSG93ZXZlciB0aGlzIG5lZWRzIHRvIGhhcHBlblxuICAgIC8vIGFmdGVyIHJlYWRhYmxlIGhhcyBiZWVuIGVtaXR0ZWQgYnV0IGJlZm9yZSBJL08gKG5leHRUaWNrKSB0b1xuICAgIC8vIHN1cHBvcnQgb25jZSgncmVhZGFibGUnLCBmbikgY3ljbGVzLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZ1xuICAgIC8vIHJlc3VtZSB3aXRoaW4gdGhlIHNhbWUgdGljayB3aWxsIGhhdmUgbm9cbiAgICAvLyBlZmZlY3QuXG4gICAgcHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIChldikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScgfHwgZXYgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgc29tZW9uZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZWFkYWJsZSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBIb3dldmVyIHRoaXMgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgcmVhZGFibGUgaGFzIGJlZW4gZW1pdHRlZCBidXQgYmVmb3JlIEkvTyAobmV4dFRpY2spIHRvXG4gICAgLy8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScsIGZuKSBjeWNsZXMuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nXG4gICAgLy8gcmVzdW1lIHdpdGhpbiB0aGUgc2FtZSB0aWNrIHdpbGwgaGF2ZSBub1xuICAgIC8vIGVmZmVjdC5cbiAgICBwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVSZWFkYWJsZUxpc3RlbmluZyhzZWxmKSB7XG4gIHZhciBzdGF0ZSA9IHNlbGYuX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc2VsZi5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMDtcblxuICBpZiAoc3RhdGUucmVzdW1lU2NoZWR1bGVkICYmICFzdGF0ZS5wYXVzZWQpIHtcbiAgICAvLyBmbG93aW5nIG5lZWRzIHRvIGJlIHNldCB0byB0cnVlIG5vdywgb3RoZXJ3aXNlXG4gICAgLy8gdGhlIHVwY29taW5nIHJlc3VtZSB3aWxsIG5vdCBmbG93LlxuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlOyAvLyBjcnVkZSB3YXkgdG8gY2hlY2sgaWYgd2Ugc2hvdWxkIHJlc3VtZVxuICB9IGVsc2UgaWYgKHNlbGYubGlzdGVuZXJDb3VudCgnZGF0YScpID4gMCkge1xuICAgIHNlbGYucmVzdW1lKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufSAvLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7IC8vIHdlIGZsb3cgb25seSBpZiB0aGVyZSBpcyBubyBvbmUgbGlzdGVuaW5nXG4gICAgLy8gZm9yIHJlYWRhYmxlLCBidXQgd2Ugc3RpbGwgaGF2ZSB0byBjYWxsXG4gICAgLy8gcmVzdW1lKClcblxuICAgIHN0YXRlLmZsb3dpbmcgPSAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmc7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuXG4gIHN0YXRlLnBhdXNlZCA9IGZhbHNlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBkZWJ1ZygncmVzdW1lJywgc3RhdGUucmVhZGluZyk7XG5cbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUucGF1c2VkID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG5cbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge1xuICAgIDtcbiAgfVxufSAvLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcblxuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7IC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pOyAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gbWV0aG9kV3JhcChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1ldGhvZFdyYXBSZXR1cm5GdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH0gLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuXG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfSAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuXG5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcblxuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3InKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHRoaXMpO1xuICB9O1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlRmxvd2luZycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gc3RhdGU7XG4gICAgfVxuICB9XG59KTsgLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTsgLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5maXJzdCgpO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbnN1bWUobiwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VuZFJlYWRhYmxlJywgc3RhdGUuZW5kRW1pdHRlZCk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIGRlYnVnKCdlbmRSZWFkYWJsZU5UJywgc3RhdGUuZW5kRW1pdHRlZCwgc3RhdGUubGVuZ3RoKTsgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcblxuICAgIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgICAgLy8gaWYgdGhlIHdyaXRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGxcbiAgICAgIHZhciB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG5cbiAgICAgIGlmICghd1N0YXRlIHx8IHdTdGF0ZS5hdXRvRGVzdHJveSAmJiB3U3RhdGUuZmluaXNoZWQpIHtcbiAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVhZGFibGUuZnJvbSA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgb3B0cykge1xuICAgIGlmIChmcm9tID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZyb20gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZnJvbScpO1xuICAgIH1cblxuICAgIHJldHVybiBmcm9tKFJlYWRhYmxlLCBpdGVyYWJsZSwgb3B0cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBoYXNCaWdJbnQ2NCA9IHR5cGVvZiBCaWdVaW50NjRBcnJheSAhPT0gXCJ1bmRlZmluZWRcIjtcbmNvbnN0IHRoaXNQdHIgPSBTeW1ib2woKTtcblxuLyoqIEdldHMgYSBzdHJpbmcgZnJvbSBhbiBVMzIgYW5kIGFuIFUxNiB2aWV3IG9uIGEgbWVtb3J5LiAqL1xuZnVuY3Rpb24gZ2V0U3RyaW5nSW1wbChVMzIsIFUxNiwgcHRyKSB7XG4gIHZhciBkYXRhTGVuZ3RoID0gVTMyW3B0ciA+Pj4gMl07XG4gIHZhciBkYXRhT2Zmc2V0ID0gKHB0ciArIDQpID4+PiAxO1xuICB2YXIgZGF0YVJlbWFpbiA9IGRhdGFMZW5ndGg7XG4gIHZhciBwYXJ0cyA9IFtdO1xuICBjb25zdCBjaHVua1NpemUgPSAxMDI0O1xuICB3aGlsZSAoZGF0YVJlbWFpbiA+IGNodW5rU2l6ZSkge1xuICAgIGxldCBsYXN0ID0gVTE2W2RhdGFPZmZzZXQgKyBjaHVua1NpemUgLSAxXTtcbiAgICBsZXQgc2l6ZSA9IGxhc3QgPj0gMHhEODAwICYmIGxhc3QgPCAweERDMDAgPyBjaHVua1NpemUgLSAxIDogY2h1bmtTaXplO1xuICAgIGxldCBwYXJ0ID0gVTE2LnN1YmFycmF5KGRhdGFPZmZzZXQsIGRhdGFPZmZzZXQgKz0gc2l6ZSk7XG4gICAgcGFydHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgcGFydCkpO1xuICAgIGRhdGFSZW1haW4gLT0gc2l6ZTtcbiAgfVxuICByZXR1cm4gcGFydHMuam9pbihcIlwiKSArIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBVMTYuc3ViYXJyYXkoZGF0YU9mZnNldCwgZGF0YU9mZnNldCArIGRhdGFSZW1haW4pKTtcbn1cblxuLyoqIFByZXBhcmVzIHRoZSBiYXNlIG1vZHVsZSBwcmlvciB0byBpbnN0YW50aWF0aW9uLiAqL1xuZnVuY3Rpb24gcHJlSW5zdGFudGlhdGUoaW1wb3J0cykge1xuICB2YXIgYmFzZU1vZHVsZSA9IHt9O1xuXG4gIGZ1bmN0aW9uIGdldFN0cmluZyhtZW1vcnksIHB0cikge1xuICAgIGlmICghbWVtb3J5KSByZXR1cm4gXCI8eWV0IHVua25vd24+XCI7XG4gICAgdmFyIGJ1ZmZlciA9IG1lbW9yeS5idWZmZXI7XG4gICAgcmV0dXJuIGdldFN0cmluZ0ltcGwobmV3IFVpbnQzMkFycmF5KGJ1ZmZlciksIG5ldyBVaW50MTZBcnJheShidWZmZXIpLCBwdHIpO1xuICB9XG5cbiAgLy8gYWRkIGNvbW1vbiBpbXBvcnRzIHVzZWQgYnkgc3RkbGliIGZvciBjb252ZW5pZW5jZVxuICB2YXIgZW52ID0gKGltcG9ydHMuZW52ID0gaW1wb3J0cy5lbnYgfHwge30pO1xuICBlbnYuYWJvcnQgPSBlbnYuYWJvcnQgfHwgZnVuY3Rpb24gYWJvcnQobWVzZywgZmlsZSwgbGluZSwgY29sbSkge1xuICAgIHZhciBtZW1vcnkgPSBiYXNlTW9kdWxlLm1lbW9yeSB8fCBlbnYubWVtb3J5OyAvLyBwcmVmZXIgZXhwb3J0ZWQsIG90aGVyd2lzZSB0cnkgaW1wb3J0ZWRcbiAgICB0aHJvdyBFcnJvcihcImFib3J0OiBcIiArIGdldFN0cmluZyhtZW1vcnksIG1lc2cpICsgXCIgYXQgXCIgKyBnZXRTdHJpbmcobWVtb3J5LCBmaWxlKSArIFwiOlwiICsgbGluZSArIFwiOlwiICsgY29sbSk7XG4gIH1cbiAgZW52LnRyYWNlID0gZW52LnRyYWNlIHx8IGZ1bmN0aW9uIHRyYWNlKG1lc2csIG4pIHtcbiAgICB2YXIgbWVtb3J5ID0gYmFzZU1vZHVsZS5tZW1vcnkgfHwgZW52Lm1lbW9yeTtcbiAgICBjb25zb2xlLmxvZyhcInRyYWNlOiBcIiArIGdldFN0cmluZyhtZW1vcnksIG1lc2cpICsgKG4gPyBcIiBcIiA6IFwiXCIpICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyLCAyICsgbikuam9pbihcIiwgXCIpKTtcbiAgfVxuICBpbXBvcnRzLk1hdGggPSBpbXBvcnRzLk1hdGggfHwgTWF0aDtcbiAgaW1wb3J0cy5EYXRlID0gaW1wb3J0cy5EYXRlIHx8IERhdGU7XG5cbiAgcmV0dXJuIGJhc2VNb2R1bGU7XG59XG5cbi8qKiBQcmVwYXJlcyB0aGUgZmluYWwgbW9kdWxlIG9uY2UgaW5zdGFudGlhdGlvbiBpcyBjb21wbGV0ZS4gKi9cbmZ1bmN0aW9uIHBvc3RJbnN0YW50aWF0ZShiYXNlTW9kdWxlLCBpbnN0YW5jZSkge1xuICB2YXIgcmF3RXhwb3J0cyA9IGluc3RhbmNlLmV4cG9ydHM7XG4gIHZhciBtZW1vcnkgPSByYXdFeHBvcnRzLm1lbW9yeTtcbiAgdmFyIG1lbW9yeV9hbGxvY2F0ZSA9IHJhd0V4cG9ydHNbXCJtZW1vcnkuYWxsb2NhdGVcIl07XG4gIHZhciBtZW1vcnlfZmlsbCA9IHJhd0V4cG9ydHNbXCJtZW1vcnkuZmlsbFwiXTtcbiAgdmFyIG1lbW9yeV9mcmVlID0gcmF3RXhwb3J0c1tcIm1lbW9yeS5mcmVlXCJdO1xuICB2YXIgdGFibGUgPSByYXdFeHBvcnRzLnRhYmxlO1xuICB2YXIgc2V0YXJnYyA9IHJhd0V4cG9ydHMuX3NldGFyZ2MgfHwgZnVuY3Rpb24oKSB7fTtcblxuICAvLyBQcm92aWRlIHZpZXdzIGZvciBhbGwgc29ydHMgb2YgYmFzaWMgdmFsdWVzXG4gIHZhciBidWZmZXIsIEk4LCBVOCwgSTE2LCBVMTYsIEkzMiwgVTMyLCBGMzIsIEY2NCwgSTY0LCBVNjQ7XG5cbiAgLyoqIFVwZGF0ZXMgbWVtb3J5IHZpZXdzIGlmIG1lbW9yeSBoYXMgZ3Jvd24gbWVhbndoaWxlLiAqL1xuICBmdW5jdGlvbiBjaGVja01lbSgpIHtcbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9XZWJBc3NlbWJseS9kZXNpZ24vaXNzdWVzLzEyMTBcbiAgICBpZiAoYnVmZmVyICE9PSBtZW1vcnkuYnVmZmVyKSB7XG4gICAgICBidWZmZXIgPSBtZW1vcnkuYnVmZmVyO1xuICAgICAgSTggID0gbmV3IEludDhBcnJheShidWZmZXIpO1xuICAgICAgVTggID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgIEkxNiA9IG5ldyBJbnQxNkFycmF5KGJ1ZmZlcik7XG4gICAgICBVMTYgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyKTtcbiAgICAgIEkzMiA9IG5ldyBJbnQzMkFycmF5KGJ1ZmZlcik7XG4gICAgICBVMzIgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgICAgIGlmIChoYXNCaWdJbnQ2NCkge1xuICAgICAgICBJNjQgPSBuZXcgQmlnSW50NjRBcnJheShidWZmZXIpO1xuICAgICAgICBVNjQgPSBuZXcgQmlnVWludDY0QXJyYXkoYnVmZmVyKTtcbiAgICAgIH1cbiAgICAgIEYzMiA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcbiAgICAgIEY2NCA9IG5ldyBGbG9hdDY0QXJyYXkoYnVmZmVyKTtcbiAgICB9XG4gIH1cbiAgY2hlY2tNZW0oKTtcblxuICAvKiogQWxsb2NhdGVzIGEgbmV3IHN0cmluZyBpbiB0aGUgbW9kdWxlJ3MgbWVtb3J5IGFuZCByZXR1cm5zIGl0cyBwb2ludGVyLiAqL1xuICBmdW5jdGlvbiBuZXdTdHJpbmcoc3RyKSB7XG4gICAgdmFyIGRhdGFMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciBwdHIgPSBtZW1vcnlfYWxsb2NhdGUoNCArIChkYXRhTGVuZ3RoIDw8IDEpKTtcbiAgICB2YXIgZGF0YU9mZnNldCA9ICg0ICsgcHRyKSA+Pj4gMTtcbiAgICBjaGVja01lbSgpO1xuICAgIFUzMltwdHIgPj4+IDJdID0gZGF0YUxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFMZW5ndGg7ICsraSkgVTE2W2RhdGFPZmZzZXQgKyBpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBwdHI7XG4gIH1cblxuICBiYXNlTW9kdWxlLm5ld1N0cmluZyA9IG5ld1N0cmluZztcblxuICAvKiogR2V0cyBhIHN0cmluZyBmcm9tIHRoZSBtb2R1bGUncyBtZW1vcnkgYnkgaXRzIHBvaW50ZXIuICovXG4gIGZ1bmN0aW9uIGdldFN0cmluZyhwdHIpIHtcbiAgICBjaGVja01lbSgpO1xuICAgIHJldHVybiBnZXRTdHJpbmdJbXBsKFUzMiwgVTE2LCBwdHIpO1xuICB9XG5cbiAgYmFzZU1vZHVsZS5nZXRTdHJpbmcgPSBnZXRTdHJpbmc7XG5cbiAgZnVuY3Rpb24gY29tcHV0ZUJ1ZmZlclNpemUoYnl0ZUxlbmd0aCkge1xuICAgIGNvbnN0IEhFQURFUl9TSVpFID0gODtcbiAgICByZXR1cm4gMSA8PCAoMzIgLSBNYXRoLmNsejMyKGJ5dGVMZW5ndGggKyBIRUFERVJfU0laRSAtIDEpKTtcbiAgfVxuXG4gIC8qKiBDcmVhdGVzIGEgbmV3IHR5cGVkIGFycmF5IGluIHRoZSBtb2R1bGUncyBtZW1vcnkgYW5kIHJldHVybnMgaXRzIHBvaW50ZXIuICovXG4gIGZ1bmN0aW9uIG5ld0FycmF5KHZpZXcsIGxlbmd0aCwgdW5zYWZlKSB7XG4gICAgdmFyIGN0b3IgPSB2aWV3LmNvbnN0cnVjdG9yO1xuICAgIGlmIChjdG9yID09PSBGdW5jdGlvbikgeyAvLyBUeXBlZEFycmF5IGNvbnN0cnVjdG9yIGNyZWF0ZWQgaW4gbWVtb3J5XG4gICAgICBjdG9yID0gdmlldztcbiAgICAgIHZpZXcgPSBudWxsO1xuICAgIH0gZWxzZSB7IC8vIFR5cGVkQXJyYXkgaW5zdGFuY2UgY29waWVkIGludG8gbWVtb3J5XG4gICAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIGxlbmd0aCA9IHZpZXcubGVuZ3RoO1xuICAgIH1cbiAgICB2YXIgZWxlbWVudFNpemUgPSBjdG9yLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgIGlmICghZWxlbWVudFNpemUpIHRocm93IEVycm9yKFwibm90IGEgdHlwZWQgYXJyYXlcIik7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSBlbGVtZW50U2l6ZSAqIGxlbmd0aDtcbiAgICB2YXIgcHRyID0gbWVtb3J5X2FsbG9jYXRlKDEyKTsgLy8gVHlwZWRBcnJheSBoZWFkZXJcbiAgICB2YXIgYnVmID0gbWVtb3J5X2FsbG9jYXRlKGNvbXB1dGVCdWZmZXJTaXplKGJ5dGVMZW5ndGgpKTsgLy8gQXJyYXlCdWZmZXJcbiAgICBjaGVja01lbSgpO1xuICAgIFUzMlsgcHRyICAgICAgPj4+IDJdID0gYnVmOyAgICAgICAgLy8gLmJ1ZmZlclxuICAgIFUzMlsocHRyICsgNCkgPj4+IDJdID0gMDsgICAgICAgICAgLy8gLmJ5dGVPZmZzZXRcbiAgICBVMzJbKHB0ciArIDgpID4+PiAyXSA9IGJ5dGVMZW5ndGg7IC8vIC5ieXRlTGVuZ3RoXG4gICAgVTMyWyBidWYgICAgICA+Pj4gMl0gPSBieXRlTGVuZ3RoOyAvLyAuYnl0ZUxlbmd0aFxuICAgIFUzMlsoYnVmICsgNCkgPj4+IDJdID0gMDsgICAgICAgICAgLy8gMFxuICAgIGlmICh2aWV3KSB7XG4gICAgICBuZXcgY3RvcihidWZmZXIsIGJ1ZiArIDgsIGxlbmd0aCkuc2V0KHZpZXcpO1xuICAgICAgaWYgKHZpZXcubGVuZ3RoIDwgbGVuZ3RoICYmICF1bnNhZmUpIHtcbiAgICAgICAgbGV0IHNldExlbmd0aCA9IGVsZW1lbnRTaXplICogdmlldy5sZW5ndGg7XG4gICAgICAgIG1lbW9yeV9maWxsKGJ1ZiArIDggKyBzZXRMZW5ndGgsIDAsIGJ5dGVMZW5ndGggLSBzZXRMZW5ndGgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXVuc2FmZSkge1xuICAgICAgbWVtb3J5X2ZpbGwoYnVmICsgOCwgMCwgYnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBwdHI7XG4gIH1cblxuICBiYXNlTW9kdWxlLm5ld0FycmF5ID0gbmV3QXJyYXk7XG5cbiAgLyoqIEdldHMgYSB2aWV3IG9uIGEgdHlwZWQgYXJyYXkgaW4gdGhlIG1vZHVsZSdzIG1lbW9yeSBieSBpdHMgcG9pbnRlci4gKi9cbiAgZnVuY3Rpb24gZ2V0QXJyYXkoY3RvciwgcHRyKSB7XG4gICAgdmFyIGVsZW1lbnRTaXplID0gY3Rvci5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICBpZiAoIWVsZW1lbnRTaXplKSB0aHJvdyBFcnJvcihcIm5vdCBhIHR5cGVkIGFycmF5XCIpO1xuICAgIGNoZWNrTWVtKCk7XG4gICAgdmFyIGJ1ZiAgICAgICAgPSBVMzJbIHB0ciAgICAgID4+PiAyXTtcbiAgICB2YXIgYnl0ZU9mZnNldCA9IFUzMlsocHRyICsgNCkgPj4+IDJdO1xuICAgIHZhciBieXRlTGVuZ3RoID0gVTMyWyhwdHIgKyA4KSA+Pj4gMl07XG4gICAgcmV0dXJuIG5ldyBjdG9yKGJ1ZmZlciwgYnVmICsgOCArIGJ5dGVPZmZzZXQsIChieXRlTGVuZ3RoIC0gYnl0ZU9mZnNldCkgLyBlbGVtZW50U2l6ZSk7XG4gIH1cblxuICBiYXNlTW9kdWxlLmdldEFycmF5ID0gZ2V0QXJyYXk7XG5cbiAgLyoqIEZyZWVzIGEgdHlwZWQgYXJyYXkgaW4gdGhlIG1vZHVsZSdzIG1lbW9yeS4gTXVzdCBub3QgYmUgYWNjZXNzZWQgYW55bW9yZSBhZnRlcndhcmRzLiAqL1xuICBmdW5jdGlvbiBmcmVlQXJyYXkocHRyKSB7XG4gICAgY2hlY2tNZW0oKTtcbiAgICB2YXIgYnVmID0gVTMyW3B0ciA+Pj4gMl07XG4gICAgbWVtb3J5X2ZyZWUoYnVmKTtcbiAgICBtZW1vcnlfZnJlZShwdHIpO1xuICB9XG5cbiAgYmFzZU1vZHVsZS5mcmVlQXJyYXkgPSBmcmVlQXJyYXk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgZnVuY3Rpb24gaW4gdGhlIG1vZHVsZSdzIHRhYmxlIGFuZCByZXR1cm5zIGl0cyBwb2ludGVyLiBOb3RlIHRoYXQgb25seSBhY3R1YWxcbiAgICogV2ViQXNzZW1ibHkgZnVuY3Rpb25zLCBpLmUuIGFzIGV4cG9ydGVkIGJ5IHRoZSBtb2R1bGUsIGFyZSBzdXBwb3J0ZWQuXG4gICAqL1xuICBmdW5jdGlvbiBuZXdGdW5jdGlvbihmbikge1xuICAgIGlmICh0eXBlb2YgZm4ub3JpZ2luYWwgPT09IFwiZnVuY3Rpb25cIikgZm4gPSBmbi5vcmlnaW5hbDtcbiAgICB2YXIgaW5kZXggPSB0YWJsZS5sZW5ndGg7XG4gICAgdGFibGUuZ3JvdygxKTtcbiAgICB0YWJsZS5zZXQoaW5kZXgsIGZuKTtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICBiYXNlTW9kdWxlLm5ld0Z1bmN0aW9uID0gbmV3RnVuY3Rpb247XG5cbiAgLyoqIEdldHMgYSBmdW5jdGlvbiBieSBpdHMgcG9pbnRlci4gKi9cbiAgZnVuY3Rpb24gZ2V0RnVuY3Rpb24ocHRyKSB7XG4gICAgcmV0dXJuIHdyYXBGdW5jdGlvbih0YWJsZS5nZXQocHRyKSwgc2V0YXJnYyk7XG4gIH1cblxuICBiYXNlTW9kdWxlLmdldEZ1bmN0aW9uID0gZ2V0RnVuY3Rpb247XG5cbiAgLy8gUHVsbCBiYXNpYyBleHBvcnRzIHRvIGJhc2VNb2R1bGUgc28gY29kZSBpbiBwcmVJbnN0YW50aWF0ZSBjYW4gdXNlIHRoZW1cbiAgYmFzZU1vZHVsZS5tZW1vcnkgPSBiYXNlTW9kdWxlLm1lbW9yeSB8fCBtZW1vcnk7XG4gIGJhc2VNb2R1bGUudGFibGUgPSBiYXNlTW9kdWxlLnRhYmxlIHx8IHRhYmxlO1xuXG4gIC8vIERlbWFuZ2xlIGV4cG9ydHMgYW5kIHByb3ZpZGUgdGhlIHVzdWFsIHV0aWxpdHkgb24gdGhlIHByb3RvdHlwZVxuICByZXR1cm4gZGVtYW5nbGUocmF3RXhwb3J0cywgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoYmFzZU1vZHVsZSwge1xuICAgIEk4OiB7IGdldDogZnVuY3Rpb24oKSB7IGNoZWNrTWVtKCk7IHJldHVybiBJODsgfSB9LFxuICAgIFU4OiB7IGdldDogZnVuY3Rpb24oKSB7IGNoZWNrTWVtKCk7IHJldHVybiBVODsgfSB9LFxuICAgIEkxNjogeyBnZXQ6IGZ1bmN0aW9uKCkgeyBjaGVja01lbSgpOyByZXR1cm4gSTE2OyB9IH0sXG4gICAgVTE2OiB7IGdldDogZnVuY3Rpb24oKSB7IGNoZWNrTWVtKCk7IHJldHVybiBVMTY7IH0gfSxcbiAgICBJMzI6IHsgZ2V0OiBmdW5jdGlvbigpIHsgY2hlY2tNZW0oKTsgcmV0dXJuIEkzMjsgfSB9LFxuICAgIFUzMjogeyBnZXQ6IGZ1bmN0aW9uKCkgeyBjaGVja01lbSgpOyByZXR1cm4gVTMyOyB9IH0sXG4gICAgSTY0OiB7IGdldDogZnVuY3Rpb24oKSB7IGNoZWNrTWVtKCk7IHJldHVybiBJNjQ7IH0gfSxcbiAgICBVNjQ6IHsgZ2V0OiBmdW5jdGlvbigpIHsgY2hlY2tNZW0oKTsgcmV0dXJuIFU2NDsgfSB9LFxuICAgIEYzMjogeyBnZXQ6IGZ1bmN0aW9uKCkgeyBjaGVja01lbSgpOyByZXR1cm4gRjMyOyB9IH0sXG4gICAgRjY0OiB7IGdldDogZnVuY3Rpb24oKSB7IGNoZWNrTWVtKCk7IHJldHVybiBGNjQ7IH0gfVxuICB9KSk7XG59XG5cbi8qKiBXcmFwcyBhIFdlYkFzc2VtYmx5IGZ1bmN0aW9uIHdoaWxlIGFsc28gdGFraW5nIGNhcmUgb2YgdmFyaWFibGUgYXJndW1lbnRzLiAqL1xuZnVuY3Rpb24gd3JhcEZ1bmN0aW9uKGZuLCBzZXRhcmdjKSB7XG4gIHZhciB3cmFwID0gKC4uLmFyZ3MpID0+IHtcbiAgICBzZXRhcmdjKGFyZ3MubGVuZ3RoKTtcbiAgICByZXR1cm4gZm4oLi4uYXJncyk7XG4gIH1cbiAgLy8gYWRkaW5nIGEgZnVuY3Rpb24gdG8gdGhlIHRhYmxlIHdpdGggYG5ld0Z1bmN0aW9uYCBpcyBsaW1pdGVkIHRvIGFjdHVhbCBXZWJBc3NlbWJseSBmdW5jdGlvbnMsXG4gIC8vIGhlbmNlIHdlIGNhbid0IHVzZSB0aGUgd3JhcHBlciBhbmQgaW5zdGVhZCBuZWVkIHRvIHByb3ZpZGUgYSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmFsXG4gIHdyYXAub3JpZ2luYWwgPSBmbjtcbiAgcmV0dXJuIHdyYXA7XG59XG5cbi8qKiBJbnN0YW50aWF0ZXMgYW4gQXNzZW1ibHlTY3JpcHQgbW9kdWxlIHVzaW5nIHRoZSBzcGVjaWZpZWQgaW1wb3J0cy4gKi9cbmZ1bmN0aW9uIGluc3RhbnRpYXRlKG1vZHVsZSwgaW1wb3J0cykge1xuICByZXR1cm4gcG9zdEluc3RhbnRpYXRlKFxuICAgIHByZUluc3RhbnRpYXRlKGltcG9ydHMgfHwgKGltcG9ydHMgPSB7fSkpLFxuICAgIG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShtb2R1bGUsIGltcG9ydHMpXG4gICk7XG59XG5cbmV4cG9ydHMuaW5zdGFudGlhdGUgPSBpbnN0YW50aWF0ZTtcblxuLyoqIEluc3RhbnRpYXRlcyBhbiBBc3NlbWJseVNjcmlwdCBtb2R1bGUgZnJvbSBhIGJ1ZmZlciB1c2luZyB0aGUgc3BlY2lmaWVkIGltcG9ydHMuICovXG5mdW5jdGlvbiBpbnN0YW50aWF0ZUJ1ZmZlcihidWZmZXIsIGltcG9ydHMpIHtcbiAgcmV0dXJuIGluc3RhbnRpYXRlKG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUoYnVmZmVyKSwgaW1wb3J0cyk7XG59XG5cbmV4cG9ydHMuaW5zdGFudGlhdGVCdWZmZXIgPSBpbnN0YW50aWF0ZUJ1ZmZlcjtcblxuLyoqIEluc3RhbnRpYXRlcyBhbiBBc3NlbWJseVNjcmlwdCBtb2R1bGUgZnJvbSBhIHJlc3BvbnNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgaW1wb3J0cy4gKi9cbmFzeW5jIGZ1bmN0aW9uIGluc3RhbnRpYXRlU3RyZWFtaW5nKHJlc3BvbnNlLCBpbXBvcnRzKSB7XG4gIHJldHVybiBwb3N0SW5zdGFudGlhdGUoXG4gICAgcHJlSW5zdGFudGlhdGUoaW1wb3J0cyB8fCAoaW1wb3J0cyA9IHt9KSksXG4gICAgKGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHJlc3BvbnNlLCBpbXBvcnRzKSkuaW5zdGFuY2VcbiAgKTtcbn1cblxuZXhwb3J0cy5pbnN0YW50aWF0ZVN0cmVhbWluZyA9IGluc3RhbnRpYXRlU3RyZWFtaW5nO1xuXG4vKiogRGVtYW5nbGVzIGFuIEFzc2VtYmx5U2NyaXB0IG1vZHVsZSdzIGV4cG9ydHMgdG8gYSBmcmllbmRseSBvYmplY3Qgc3RydWN0dXJlLiAqL1xuZnVuY3Rpb24gZGVtYW5nbGUoZXhwb3J0cywgYmFzZU1vZHVsZSkge1xuICB2YXIgbW9kdWxlID0gYmFzZU1vZHVsZSA/IE9iamVjdC5jcmVhdGUoYmFzZU1vZHVsZSkgOiB7fTtcbiAgdmFyIHNldGFyZ2MgPSBleHBvcnRzLl9zZXRhcmdjIHx8IGZ1bmN0aW9uKCkge307XG4gIGZ1bmN0aW9uIGhhc093blByb3BlcnR5KGVsZW0sIHByb3ApIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVsZW0sIHByb3ApO1xuICB9XG4gIGZvciAobGV0IGludGVybmFsTmFtZSBpbiBleHBvcnRzKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShleHBvcnRzLCBpbnRlcm5hbE5hbWUpKSBjb250aW51ZTtcbiAgICBsZXQgZWxlbSA9IGV4cG9ydHNbaW50ZXJuYWxOYW1lXTtcbiAgICBsZXQgcGFydHMgPSBpbnRlcm5hbE5hbWUuc3BsaXQoXCIuXCIpO1xuICAgIGxldCBjdXJyID0gbW9kdWxlO1xuICAgIHdoaWxlIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICBsZXQgcGFydCA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICBpZiAoIWhhc093blByb3BlcnR5KGN1cnIsIHBhcnQpKSBjdXJyW3BhcnRdID0ge307XG4gICAgICBjdXJyID0gY3VycltwYXJ0XTtcbiAgICB9XG4gICAgbGV0IG5hbWUgPSBwYXJ0c1swXTtcbiAgICBsZXQgaGFzaCA9IG5hbWUuaW5kZXhPZihcIiNcIik7XG4gICAgaWYgKGhhc2ggPj0gMCkge1xuICAgICAgbGV0IGNsYXNzTmFtZSA9IG5hbWUuc3Vic3RyaW5nKDAsIGhhc2gpO1xuICAgICAgbGV0IGNsYXNzRWxlbSA9IGN1cnJbY2xhc3NOYW1lXTtcbiAgICAgIGlmICh0eXBlb2YgY2xhc3NFbGVtID09PSBcInVuZGVmaW5lZFwiIHx8ICFjbGFzc0VsZW0ucHJvdG90eXBlKSB7XG4gICAgICAgIGxldCBjdG9yID0gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICAgIHJldHVybiBjdG9yLndyYXAoY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IoMCwgLi4uYXJncykpO1xuICAgICAgICB9O1xuICAgICAgICBjdG9yLnByb3RvdHlwZSA9IHt9O1xuICAgICAgICBjdG9yLndyYXAgPSBmdW5jdGlvbih0aGlzVmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShjdG9yLnByb3RvdHlwZSwgeyBbdGhpc1B0cl06IHsgdmFsdWU6IHRoaXNWYWx1ZSwgd3JpdGFibGU6IGZhbHNlIH0gfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjbGFzc0VsZW0pIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNsYXNzRWxlbSkuZm9yRWFjaChuYW1lID0+XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IsIG5hbWUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY2xhc3NFbGVtLCBuYW1lKSlcbiAgICAgICAgKTtcbiAgICAgICAgY3VycltjbGFzc05hbWVdID0gY3RvcjtcbiAgICAgIH1cbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZyhoYXNoICsgMSk7XG4gICAgICBjdXJyID0gY3VycltjbGFzc05hbWVdLnByb3RvdHlwZTtcbiAgICAgIGlmICgvXihnZXR8c2V0KTovLnRlc3QobmFtZSkpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShjdXJyLCBuYW1lID0gbmFtZS5zdWJzdHJpbmcoNCkpKSB7XG4gICAgICAgICAgbGV0IGdldHRlciA9IGV4cG9ydHNbaW50ZXJuYWxOYW1lLnJlcGxhY2UoXCJzZXQ6XCIsIFwiZ2V0OlwiKV07XG4gICAgICAgICAgbGV0IHNldHRlciA9IGV4cG9ydHNbaW50ZXJuYWxOYW1lLnJlcGxhY2UoXCJnZXQ6XCIsIFwic2V0OlwiKV07XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1cnIsIG5hbWUsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBnZXR0ZXIodGhpc1t0aGlzUHRyXSk7IH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7IHNldHRlcih0aGlzW3RoaXNQdHJdLCB2YWx1ZSk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChuYW1lID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgY3VycltuYW1lXSA9IHdyYXBGdW5jdGlvbihlbGVtLCBzZXRhcmdjKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gZm9yIG1ldGhvZHNcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VyciwgbmFtZSwge1xuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgIHNldGFyZ2MoYXJncy5sZW5ndGgpO1xuICAgICAgICAgICAgICByZXR1cm4gZWxlbSh0aGlzW3RoaXNQdHJdLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoL14oZ2V0fHNldCk6Ly50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkoY3VyciwgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDQpKSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdXJyLCBuYW1lLCB7XG4gICAgICAgICAgICBnZXQ6IGV4cG9ydHNbaW50ZXJuYWxOYW1lLnJlcGxhY2UoXCJzZXQ6XCIsIFwiZ2V0OlwiKV0sXG4gICAgICAgICAgICBzZXQ6IGV4cG9ydHNbaW50ZXJuYWxOYW1lLnJlcGxhY2UoXCJnZXQ6XCIsIFwic2V0OlwiKV0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjdXJyW25hbWVdID0gd3JhcEZ1bmN0aW9uKGVsZW0sIHNldGFyZ2MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycltuYW1lXSA9IGVsZW07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1vZHVsZTtcbn1cblxuZXhwb3J0cy5kZW1hbmdsZSA9IGRlbWFuZ2xlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IDA7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYWxwaGFiZXQgPSByZXF1aXJlKCcuL2FscGhhYmV0Jyk7XG5cbmZ1bmN0aW9uIGlzU2hvcnRJZChpZCkge1xuICAgIGlmICghaWQgfHwgdHlwZW9mIGlkICE9PSAnc3RyaW5nJyB8fCBpZC5sZW5ndGggPCA2ICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIG5vbkFscGhhYmV0aWMgPSBuZXcgUmVnRXhwKCdbXicgK1xuICAgICAgYWxwaGFiZXQuZ2V0KCkucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCsqPy4tXS9nLCAnXFxcXCQmJykgK1xuICAgICddJyk7XG4gICAgcmV0dXJuICFub25BbHBoYWJldGljLnRlc3QoaWQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU2hvcnRJZDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJhbmRvbUZyb21TZWVkID0gcmVxdWlyZSgnLi9yYW5kb20vcmFuZG9tLWZyb20tc2VlZCcpO1xuXG52YXIgT1JJR0lOQUwgPSAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpfLSc7XG52YXIgYWxwaGFiZXQ7XG52YXIgcHJldmlvdXNTZWVkO1xuXG52YXIgc2h1ZmZsZWQ7XG5cbmZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHNodWZmbGVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNldENoYXJhY3RlcnMoX2FscGhhYmV0Xykge1xuICAgIGlmICghX2FscGhhYmV0Xykge1xuICAgICAgICBpZiAoYWxwaGFiZXQgIT09IE9SSUdJTkFMKSB7XG4gICAgICAgICAgICBhbHBoYWJldCA9IE9SSUdJTkFMO1xuICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKF9hbHBoYWJldF8gPT09IGFscGhhYmV0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoX2FscGhhYmV0Xy5sZW5ndGggIT09IE9SSUdJTkFMLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N1c3RvbSBhbHBoYWJldCBmb3Igc2hvcnRpZCBtdXN0IGJlICcgKyBPUklHSU5BTC5sZW5ndGggKyAnIHVuaXF1ZSBjaGFyYWN0ZXJzLiBZb3Ugc3VibWl0dGVkICcgKyBfYWxwaGFiZXRfLmxlbmd0aCArICcgY2hhcmFjdGVyczogJyArIF9hbHBoYWJldF8pO1xuICAgIH1cblxuICAgIHZhciB1bmlxdWUgPSBfYWxwaGFiZXRfLnNwbGl0KCcnKS5maWx0ZXIoZnVuY3Rpb24oaXRlbSwgaW5kLCBhcnIpe1xuICAgICAgIHJldHVybiBpbmQgIT09IGFyci5sYXN0SW5kZXhPZihpdGVtKTtcbiAgICB9KTtcblxuICAgIGlmICh1bmlxdWUubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VzdG9tIGFscGhhYmV0IGZvciBzaG9ydGlkIG11c3QgYmUgJyArIE9SSUdJTkFMLmxlbmd0aCArICcgdW5pcXVlIGNoYXJhY3RlcnMuIFRoZXNlIGNoYXJhY3RlcnMgd2VyZSBub3QgdW5pcXVlOiAnICsgdW5pcXVlLmpvaW4oJywgJykpO1xuICAgIH1cblxuICAgIGFscGhhYmV0ID0gX2FscGhhYmV0XztcbiAgICByZXNldCgpO1xufVxuXG5mdW5jdGlvbiBjaGFyYWN0ZXJzKF9hbHBoYWJldF8pIHtcbiAgICBzZXRDaGFyYWN0ZXJzKF9hbHBoYWJldF8pO1xuICAgIHJldHVybiBhbHBoYWJldDtcbn1cblxuZnVuY3Rpb24gc2V0U2VlZChzZWVkKSB7XG4gICAgcmFuZG9tRnJvbVNlZWQuc2VlZChzZWVkKTtcbiAgICBpZiAocHJldmlvdXNTZWVkICE9PSBzZWVkKSB7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHByZXZpb3VzU2VlZCA9IHNlZWQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzaHVmZmxlKCkge1xuICAgIGlmICghYWxwaGFiZXQpIHtcbiAgICAgICAgc2V0Q2hhcmFjdGVycyhPUklHSU5BTCk7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUFycmF5ID0gYWxwaGFiZXQuc3BsaXQoJycpO1xuICAgIHZhciB0YXJnZXRBcnJheSA9IFtdO1xuICAgIHZhciByID0gcmFuZG9tRnJvbVNlZWQubmV4dFZhbHVlKCk7XG4gICAgdmFyIGNoYXJhY3RlckluZGV4O1xuXG4gICAgd2hpbGUgKHNvdXJjZUFycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgciA9IHJhbmRvbUZyb21TZWVkLm5leHRWYWx1ZSgpO1xuICAgICAgICBjaGFyYWN0ZXJJbmRleCA9IE1hdGguZmxvb3IociAqIHNvdXJjZUFycmF5Lmxlbmd0aCk7XG4gICAgICAgIHRhcmdldEFycmF5LnB1c2goc291cmNlQXJyYXkuc3BsaWNlKGNoYXJhY3RlckluZGV4LCAxKVswXSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRBcnJheS5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2h1ZmZsZWQoKSB7XG4gICAgaWYgKHNodWZmbGVkKSB7XG4gICAgICAgIHJldHVybiBzaHVmZmxlZDtcbiAgICB9XG4gICAgc2h1ZmZsZWQgPSBzaHVmZmxlKCk7XG4gICAgcmV0dXJuIHNodWZmbGVkO1xufVxuXG4vKipcbiAqIGxvb2t1cCBzaHVmZmxlZCBsZXR0ZXJcbiAqIEBwYXJhbSBpbmRleFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gbG9va3VwKGluZGV4KSB7XG4gICAgdmFyIGFscGhhYmV0U2h1ZmZsZWQgPSBnZXRTaHVmZmxlZCgpO1xuICAgIHJldHVybiBhbHBoYWJldFNodWZmbGVkW2luZGV4XTtcbn1cblxuZnVuY3Rpb24gZ2V0ICgpIHtcbiAgcmV0dXJuIGFscGhhYmV0IHx8IE9SSUdJTkFMO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnZXQ6IGdldCxcbiAgICBjaGFyYWN0ZXJzOiBjaGFyYWN0ZXJzLFxuICAgIHNlZWQ6IHNldFNlZWQsXG4gICAgbG9va3VwOiBsb29rdXAsXG4gICAgc2h1ZmZsZWQ6IGdldFNodWZmbGVkXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2VuZXJhdGUgPSByZXF1aXJlKCcuL2dlbmVyYXRlJyk7XG52YXIgYWxwaGFiZXQgPSByZXF1aXJlKCcuL2FscGhhYmV0Jyk7XG5cbi8vIElnbm9yZSBhbGwgbWlsbGlzZWNvbmRzIGJlZm9yZSBhIGNlcnRhaW4gdGltZSB0byByZWR1Y2UgdGhlIHNpemUgb2YgdGhlIGRhdGUgZW50cm9weSB3aXRob3V0IHNhY3JpZmljaW5nIHVuaXF1ZW5lc3MuXG4vLyBUaGlzIG51bWJlciBzaG91bGQgYmUgdXBkYXRlZCBldmVyeSB5ZWFyIG9yIHNvIHRvIGtlZXAgdGhlIGdlbmVyYXRlZCBpZCBzaG9ydC5cbi8vIFRvIHJlZ2VuZXJhdGUgYG5ldyBEYXRlKCkgLSAwYCBhbmQgYnVtcCB0aGUgdmVyc2lvbi4gQWx3YXlzIGJ1bXAgdGhlIHZlcnNpb24hXG52YXIgUkVEVUNFX1RJTUUgPSAxNDU5NzA3NjA2NTE4O1xuXG4vLyBkb24ndCBjaGFuZ2UgdW5sZXNzIHdlIGNoYW5nZSB0aGUgYWxnb3Mgb3IgUkVEVUNFX1RJTUVcbi8vIG11c3QgYmUgYW4gaW50ZWdlciBhbmQgbGVzcyB0aGFuIDE2XG52YXIgdmVyc2lvbiA9IDY7XG5cbi8vIENvdW50ZXIgaXMgdXNlZCB3aGVuIHNob3J0aWQgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGluIG9uZSBzZWNvbmQuXG52YXIgY291bnRlcjtcblxuLy8gUmVtZW1iZXIgdGhlIGxhc3QgdGltZSBzaG9ydGlkIHdhcyBjYWxsZWQgaW4gY2FzZSBjb3VudGVyIGlzIG5lZWRlZC5cbnZhciBwcmV2aW91c1NlY29uZHM7XG5cbi8qKlxuICogR2VuZXJhdGUgdW5pcXVlIGlkXG4gKiBSZXR1cm5zIHN0cmluZyBpZFxuICovXG5mdW5jdGlvbiBidWlsZChjbHVzdGVyV29ya2VySWQpIHtcbiAgICB2YXIgc3RyID0gJyc7XG5cbiAgICB2YXIgc2Vjb25kcyA9IE1hdGguZmxvb3IoKERhdGUubm93KCkgLSBSRURVQ0VfVElNRSkgKiAwLjAwMSk7XG5cbiAgICBpZiAoc2Vjb25kcyA9PT0gcHJldmlvdXNTZWNvbmRzKSB7XG4gICAgICAgIGNvdW50ZXIrKztcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb3VudGVyID0gMDtcbiAgICAgICAgcHJldmlvdXNTZWNvbmRzID0gc2Vjb25kcztcbiAgICB9XG5cbiAgICBzdHIgPSBzdHIgKyBnZW5lcmF0ZSh2ZXJzaW9uKTtcbiAgICBzdHIgPSBzdHIgKyBnZW5lcmF0ZShjbHVzdGVyV29ya2VySWQpO1xuICAgIGlmIChjb3VudGVyID4gMCkge1xuICAgICAgICBzdHIgPSBzdHIgKyBnZW5lcmF0ZShjb3VudGVyKTtcbiAgICB9XG4gICAgc3RyID0gc3RyICsgZ2VuZXJhdGUoc2Vjb25kcyk7XG4gICAgcmV0dXJuIHN0cjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBidWlsZDtcbiIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtcyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JykgfHxcbiAgICBwbHVyYWwobXMsIGgsICdob3VyJykgfHxcbiAgICBwbHVyYWwobXMsIG0sICdtaW51dGUnKSB8fFxuICAgIHBsdXJhbChtcywgcywgJ3NlY29uZCcpIHx8XG4gICAgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobXMgPCBuICogMS41KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIH1cbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBzZWxmO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctZnVuY1xuICB9XG59KSgpO1xuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICpcbiAqIExvZ2ljIGJvcnJvd2VkIGZyb20gTW9kZXJuaXpyOlxuICpcbiAqICAgLSBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvY29ycy5qc1xuICovXG5cbnRyeSB7XG4gIG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xufSBjYXRjaCAoZXJyKSB7XG4gIC8vIGlmIFhNTEh0dHAgc3VwcG9ydCBpcyBkaXNhYmxlZCBpbiBJRSB0aGVuIGl0IHdpbGwgdGhyb3dcbiAgLy8gd2hlbiB0cnlpbmcgdG8gY3JlYXRlXG4gIG1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG59XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIHllYXN0ID0gcmVxdWlyZSgneWVhc3QnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUG9sbGluZztcblxuLyoqXG4gKiBJcyBYSFIyIHN1cHBvcnRlZD9cbiAqL1xuXG52YXIgaGFzWEhSMiA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xuICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KHsgeGRvbWFpbjogZmFsc2UgfSk7XG4gIHJldHVybiBudWxsICE9IHhoci5yZXNwb25zZVR5cGU7XG59KSgpO1xuXG4vKipcbiAqIFBvbGxpbmcgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBQb2xsaW5nIChvcHRzKSB7XG4gIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuICBpZiAoIWhhc1hIUjIgfHwgZm9yY2VCYXNlNjQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cbiAgVHJhbnNwb3J0LmNhbGwodGhpcywgb3B0cyk7XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBUcmFuc3BvcnQuXG4gKi9cblxuaW5oZXJpdChQb2xsaW5nLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm5hbWUgPSAncG9sbGluZyc7XG5cbi8qKlxuICogT3BlbnMgdGhlIHNvY2tldCAodHJpZ2dlcnMgcG9sbGluZykuIFdlIHdyaXRlIGEgUElORyBtZXNzYWdlIHRvIGRldGVybWluZVxuICogd2hlbiB0aGUgdHJhbnNwb3J0IGlzIG9wZW4uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnBvbGwoKTtcbn07XG5cbi8qKlxuICogUGF1c2VzIHBvbGxpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdXBvbiBidWZmZXJzIGFyZSBmbHVzaGVkIGFuZCB0cmFuc3BvcnQgaXMgcGF1c2VkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIChvblBhdXNlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLnJlYWR5U3RhdGUgPSAncGF1c2luZyc7XG5cbiAgZnVuY3Rpb24gcGF1c2UgKCkge1xuICAgIGRlYnVnKCdwYXVzZWQnKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAncGF1c2VkJztcbiAgICBvblBhdXNlKCk7XG4gIH1cblxuICBpZiAodGhpcy5wb2xsaW5nIHx8ICF0aGlzLndyaXRhYmxlKSB7XG4gICAgdmFyIHRvdGFsID0gMDtcblxuICAgIGlmICh0aGlzLnBvbGxpbmcpIHtcbiAgICAgIGRlYnVnKCd3ZSBhcmUgY3VycmVudGx5IHBvbGxpbmcgLSB3YWl0aW5nIHRvIHBhdXNlJyk7XG4gICAgICB0b3RhbCsrO1xuICAgICAgdGhpcy5vbmNlKCdwb2xsQ29tcGxldGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlYnVnKCdwcmUtcGF1c2UgcG9sbGluZyBjb21wbGV0ZScpO1xuICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMud3JpdGFibGUpIHtcbiAgICAgIGRlYnVnKCd3ZSBhcmUgY3VycmVudGx5IHdyaXRpbmcgLSB3YWl0aW5nIHRvIHBhdXNlJyk7XG4gICAgICB0b3RhbCsrO1xuICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVidWcoJ3ByZS1wYXVzZSB3cml0aW5nIGNvbXBsZXRlJyk7XG4gICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXVzZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBwb2xsaW5nIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUucG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3BvbGxpbmcnKTtcbiAgdGhpcy5wb2xsaW5nID0gdHJ1ZTtcbiAgdGhpcy5kb1BvbGwoKTtcbiAgdGhpcy5lbWl0KCdwb2xsJyk7XG59O1xuXG4vKipcbiAqIE92ZXJsb2FkcyBvbkRhdGEgdG8gZGV0ZWN0IHBheWxvYWRzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZGVidWcoJ3BvbGxpbmcgZ290IGRhdGEgJXMnLCBkYXRhKTtcbiAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKHBhY2tldCwgaW5kZXgsIHRvdGFsKSB7XG4gICAgLy8gaWYgaXRzIHRoZSBmaXJzdCBtZXNzYWdlIHdlIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgb3BlblxuICAgIGlmICgnb3BlbmluZycgPT09IHNlbGYucmVhZHlTdGF0ZSAmJiBwYWNrZXQudHlwZSA9PT0gJ29wZW4nKSB7XG4gICAgICBzZWxmLm9uT3BlbigpO1xuICAgIH1cblxuICAgIC8vIGlmIGl0cyBhIGNsb3NlIHBhY2tldCwgd2UgY2xvc2UgdGhlIG9uZ29pbmcgcmVxdWVzdHNcbiAgICBpZiAoJ2Nsb3NlJyA9PT0gcGFja2V0LnR5cGUpIHtcbiAgICAgIHNlbGYub25DbG9zZSgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSBieXBhc3Mgb25EYXRhIGFuZCBoYW5kbGUgdGhlIG1lc3NhZ2VcbiAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gIH07XG5cbiAgLy8gZGVjb2RlIHBheWxvYWRcbiAgcGFyc2VyLmRlY29kZVBheWxvYWQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuXG4gIC8vIGlmIGFuIGV2ZW50IGRpZCBub3QgdHJpZ2dlciBjbG9zaW5nXG4gIGlmICgnY2xvc2VkJyAhPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgLy8gaWYgd2UgZ290IGRhdGEgd2UncmUgbm90IHBvbGxpbmdcbiAgICB0aGlzLnBvbGxpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BvbGxDb21wbGV0ZScpO1xuXG4gICAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICB0aGlzLnBvbGwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ2lnbm9yaW5nIHBvbGwgLSB0cmFuc3BvcnQgc3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRm9yIHBvbGxpbmcsIHNlbmQgYSBjbG9zZSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIGNsb3NlICgpIHtcbiAgICBkZWJ1Zygnd3JpdGluZyBjbG9zZSBwYWNrZXQnKTtcbiAgICBzZWxmLndyaXRlKFt7IHR5cGU6ICdjbG9zZScgfV0pO1xuICB9XG5cbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3RyYW5zcG9ydCBvcGVuIC0gY2xvc2luZycpO1xuICAgIGNsb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaW4gY2FzZSB3ZSdyZSB0cnlpbmcgdG8gY2xvc2Ugd2hpbGVcbiAgICAvLyBoYW5kc2hha2luZyBpcyBpbiBwcm9ncmVzcyAoR0gtMTY0KVxuICAgIGRlYnVnKCd0cmFuc3BvcnQgbm90IG9wZW4gLSBkZWZlcnJpbmcgY2xvc2UnKTtcbiAgICB0aGlzLm9uY2UoJ29wZW4nLCBjbG9zZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0cyBwYXlsb2FkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgcGFja2V0c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZHJhaW4gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gIHZhciBjYWxsYmFja2ZuID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgIHNlbGYuZW1pdCgnZHJhaW4nKTtcbiAgfTtcblxuICBwYXJzZXIuZW5jb2RlUGF5bG9hZChwYWNrZXRzLCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHNlbGYuZG9Xcml0ZShkYXRhLCBjYWxsYmFja2ZuKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnaHR0cHMnIDogJ2h0dHAnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGNhY2hlIGJ1c3RpbmcgaXMgZm9yY2VkXG4gIGlmIChmYWxzZSAhPT0gdGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcbiAgfVxuXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiAhcXVlcnkuc2lkKSB7XG4gICAgcXVlcnkuYjY0ID0gMTtcbiAgfVxuXG4gIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnaHR0cHMnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDQ0MykgfHxcbiAgICAgKCdodHRwJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA4MCkpKSB7XG4gICAgcG9ydCA9ICc6JyArIHRoaXMucG9ydDtcbiAgfVxuXG4gIC8vIHByZXBlbmQgPyB0byBxdWVyeVxuICBpZiAocXVlcnkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcbiAgfVxuXG4gIHZhciBpcHY2ID0gdGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xO1xuICByZXR1cm4gc2NoZW1hICsgJzovLycgKyAoaXB2NiA/ICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScgOiB0aGlzLmhvc3RuYW1lKSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcbn07XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYSwgYil7XG4gIHZhciBmbiA9IGZ1bmN0aW9uKCl7fTtcbiAgZm4ucHJvdG90eXBlID0gYi5wcm90b3R5cGU7XG4gIGEucHJvdG90eXBlID0gbmV3IGZuO1xuICBhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGE7XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6LV8nLnNwbGl0KCcnKVxuICAsIGxlbmd0aCA9IDY0XG4gICwgbWFwID0ge31cbiAgLCBzZWVkID0gMFxuICAsIGkgPSAwXG4gICwgcHJldjtcblxuLyoqXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gVGhlIG51bWJlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZW5jb2RlKG51bSkge1xuICB2YXIgZW5jb2RlZCA9ICcnO1xuXG4gIGRvIHtcbiAgICBlbmNvZGVkID0gYWxwaGFiZXRbbnVtICUgbGVuZ3RoXSArIGVuY29kZWQ7XG4gICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBsZW5ndGgpO1xuICB9IHdoaWxlIChudW0gPiAwKTtcblxuICByZXR1cm4gZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGludGVnZXIgdmFsdWUgc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgaW50ZWdlciB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGUgc3RyaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICB2YXIgZGVjb2RlZCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGRlY29kZWQgPSBkZWNvZGVkICogbGVuZ3RoICsgbWFwW3N0ci5jaGFyQXQoaSldO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZWQ7XG59XG5cbi8qKlxuICogWWVhc3Q6IEEgdGlueSBncm93aW5nIGlkIGdlbmVyYXRvci5cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIHVuaXF1ZSBpZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHllYXN0KCkge1xuICB2YXIgbm93ID0gZW5jb2RlKCtuZXcgRGF0ZSgpKTtcblxuICBpZiAobm93ICE9PSBwcmV2KSByZXR1cm4gc2VlZCA9IDAsIHByZXYgPSBub3c7XG4gIHJldHVybiBub3cgKycuJysgZW5jb2RlKHNlZWQrKyk7XG59XG5cbi8vXG4vLyBNYXAgZWFjaCBjaGFyYWN0ZXIgdG8gaXRzIGluZGV4LlxuLy9cbmZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIG1hcFthbHBoYWJldFtpXV0gPSBpO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBgeWVhc3RgLCBgZW5jb2RlYCBhbmQgYGRlY29kZWAgZnVuY3Rpb25zLlxuLy9cbnllYXN0LmVuY29kZSA9IGVuY29kZTtcbnllYXN0LmRlY29kZSA9IGRlY29kZTtcbm1vZHVsZS5leHBvcnRzID0geWVhc3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgY29kZXMgPSB7fTtcblxuZnVuY3Rpb24gY3JlYXRlRXJyb3JUeXBlKGNvZGUsIG1lc3NhZ2UsIEJhc2UpIHtcbiAgaWYgKCFCYXNlKSB7XG4gICAgQmFzZSA9IEVycm9yO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBOb2RlRXJyb3IgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfQmFzZSkge1xuICAgIF9pbmhlcml0c0xvb3NlKE5vZGVFcnJvciwgX0Jhc2UpO1xuXG4gICAgZnVuY3Rpb24gTm9kZUVycm9yKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIHJldHVybiBfQmFzZS5jYWxsKHRoaXMsIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykpIHx8IHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5vZGVFcnJvcjtcbiAgfShCYXNlKTtcblxuICBOb2RlRXJyb3IucHJvdG90eXBlLm5hbWUgPSBCYXNlLm5hbWU7XG4gIE5vZGVFcnJvci5wcm90b3R5cGUuY29kZSA9IGNvZGU7XG4gIGNvZGVzW2NvZGVdID0gTm9kZUVycm9yO1xufSAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92MTAuOC4wL2xpYi9pbnRlcm5hbC9lcnJvcnMuanNcblxuXG5mdW5jdGlvbiBvbmVPZihleHBlY3RlZCwgdGhpbmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0ZWQpKSB7XG4gICAgdmFyIGxlbiA9IGV4cGVjdGVkLmxlbmd0aDtcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpKTtcbiAgICB9KTtcblxuICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICByZXR1cm4gXCJvbmUgb2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyksIFwiLCBvciBcIikgKyBleHBlY3RlZFtsZW4gLSAxXTtcbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSwgXCIgb3IgXCIpLmNvbmNhdChleHBlY3RlZFsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIm9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIm9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChTdHJpbmcoZXhwZWN0ZWQpKTtcbiAgfVxufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3RhcnRzV2l0aFxuXG5cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCBzZWFyY2gsIHBvcykge1xuICByZXR1cm4gc3RyLnN1YnN0cighcG9zIHx8IHBvcyA8IDAgPyAwIDogK3Bvcywgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2VuZHNXaXRoXG5cblxuZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzZWFyY2gsIHRoaXNfbGVuKSB7XG4gIGlmICh0aGlzX2xlbiA9PT0gdW5kZWZpbmVkIHx8IHRoaXNfbGVuID4gc3RyLmxlbmd0aCkge1xuICAgIHRoaXNfbGVuID0gc3RyLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKHRoaXNfbGVuIC0gc2VhcmNoLmxlbmd0aCwgdGhpc19sZW4pID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9pbmNsdWRlc1xuXG5cbmZ1bmN0aW9uIGluY2x1ZGVzKHN0ciwgc2VhcmNoLCBzdGFydCkge1xuICBpZiAodHlwZW9mIHN0YXJ0ICE9PSAnbnVtYmVyJykge1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuXG4gIGlmIChzdGFydCArIHNlYXJjaC5sZW5ndGggPiBzdHIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZihzZWFyY2gsIHN0YXJ0KSAhPT0gLTE7XG4gIH1cbn1cblxuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9PUFRfVkFMVUUnLCBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuICdUaGUgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwiJyArIG5hbWUgKyAnXCInO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLCBmdW5jdGlvbiAobmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCkge1xuICAvLyBkZXRlcm1pbmVyOiAnbXVzdCBiZScgb3IgJ211c3Qgbm90IGJlJ1xuICB2YXIgZGV0ZXJtaW5lcjtcblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJyAmJiBzdGFydHNXaXRoKGV4cGVjdGVkLCAnbm90ICcpKSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IG5vdCBiZSc7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5yZXBsYWNlKC9ebm90IC8sICcnKTtcbiAgfSBlbHNlIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3QgYmUnO1xuICB9XG5cbiAgdmFyIG1zZztcblxuICBpZiAoZW5kc1dpdGgobmFtZSwgJyBhcmd1bWVudCcpKSB7XG4gICAgLy8gRm9yIGNhc2VzIGxpa2UgJ2ZpcnN0IGFyZ3VtZW50J1xuICAgIG1zZyA9IFwiVGhlIFwiLmNvbmNhdChuYW1lLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0eXBlID0gaW5jbHVkZXMobmFtZSwgJy4nKSA/ICdwcm9wZXJ0eScgOiAnYXJndW1lbnQnO1xuICAgIG1zZyA9IFwiVGhlIFxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiIFwiKS5jb25jYXQodHlwZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfVxuXG4gIG1zZyArPSBcIi4gUmVjZWl2ZWQgdHlwZSBcIi5jb25jYXQodHlwZW9mIGFjdHVhbCk7XG4gIHJldHVybiBtc2c7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GJywgJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEJywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuICdUaGUgJyArIG5hbWUgKyAnIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQnO1xufSk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJywgJ1ByZW1hdHVyZSBjbG9zZScpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX0RFU1RST1lFRCcsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiAnQ2Fubm90IGNhbGwgJyArIG5hbWUgKyAnIGFmdGVyIGEgc3RyZWFtIHdhcyBkZXN0cm95ZWQnO1xufSk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9NVUxUSVBMRV9DQUxMQkFDSycsICdDYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9DQU5OT1RfUElQRScsICdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EJywgJ3dyaXRlIGFmdGVyIGVuZCcpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX05VTExfVkFMVUVTJywgJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJywgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1VOS05PV05fRU5DT0RJTkcnLCBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiAnVW5rbm93biBlbmNvZGluZzogJyArIGFyZztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQnLCAnc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbm1vZHVsZS5leHBvcnRzLmNvZGVzID0gY29kZXM7XG4iLCIndXNlIHN0cmljdCc7IC8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcblxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9IC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcblxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBpZiAoIV90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycik7XG4gICAgICB9IGVsc2UgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZU5ULCBfdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yQW5kQ2xvc2VOVChzZWxmLCBlcnIpIHtcbiAgZW1pdEVycm9yTlQoc2VsZiwgZXJyKTtcbiAgZW1pdENsb3NlTlQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIGVtaXRDbG9zZU5UKHNlbGYpIHtcbiAgaWYgKHNlbGYuX3dyaXRhYmxlU3RhdGUgJiYgIXNlbGYuX3dyaXRhYmxlU3RhdGUuZW1pdENsb3NlKSByZXR1cm47XG4gIGlmIChzZWxmLl9yZWFkYWJsZVN0YXRlICYmICFzZWxmLl9yZWFkYWJsZVN0YXRlLmVtaXRDbG9zZSkgcmV0dXJuO1xuICBzZWxmLmVtaXQoJ2Nsb3NlJyk7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxuZnVuY3Rpb24gZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpIHtcbiAgLy8gV2UgaGF2ZSB0ZXN0cyB0aGF0IHJlbHkgb24gZXJyb3JzIGJlaW5nIGVtaXR0ZWRcbiAgLy8gaW4gdGhlIHNhbWUgdGljaywgc28gY2hhbmdpbmcgdGhpcyBpcyBzZW12ZXIgbWFqb3IuXG4gIC8vIEZvciBub3cgd2hlbiB5b3Ugb3B0LWluIHRvIGF1dG9EZXN0cm95IHdlIGFsbG93XG4gIC8vIHRoZSBlcnJvciB0byBiZSBlbWl0dGVkIG5leHRUaWNrLiBJbiBhIGZ1dHVyZVxuICAvLyBzZW12ZXIgbWFqb3IgdXBkYXRlIHdlIHNob3VsZCBjaGFuZ2UgdGhlIGRlZmF1bHQgdG8gdGhpcy5cbiAgdmFyIHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgaWYgKHJTdGF0ZSAmJiByU3RhdGUuYXV0b0Rlc3Ryb3kgfHwgd1N0YXRlICYmIHdTdGF0ZS5hdXRvRGVzdHJveSkgc3RyZWFtLmRlc3Ryb3koZXJyKTtlbHNlIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveSxcbiAgZXJyb3JPckRlc3Ryb3k6IGVycm9yT3JEZXN0cm95XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVJSX0lOVkFMSURfT1BUX1ZBTFVFID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMuRVJSX0lOVkFMSURfT1BUX1ZBTFVFO1xuXG5mdW5jdGlvbiBoaWdoV2F0ZXJNYXJrRnJvbShvcHRpb25zLCBpc0R1cGxleCwgZHVwbGV4S2V5KSB7XG4gIHJldHVybiBvcHRpb25zLmhpZ2hXYXRlck1hcmsgIT0gbnVsbCA/IG9wdGlvbnMuaGlnaFdhdGVyTWFyayA6IGlzRHVwbGV4ID8gb3B0aW9uc1tkdXBsZXhLZXldIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0SGlnaFdhdGVyTWFyayhzdGF0ZSwgb3B0aW9ucywgZHVwbGV4S2V5LCBpc0R1cGxleCkge1xuICB2YXIgaHdtID0gaGlnaFdhdGVyTWFya0Zyb20ob3B0aW9ucywgaXNEdXBsZXgsIGR1cGxleEtleSk7XG5cbiAgaWYgKGh3bSAhPSBudWxsKSB7XG4gICAgaWYgKCEoaXNGaW5pdGUoaHdtKSAmJiBNYXRoLmZsb29yKGh3bSkgPT09IGh3bSkgfHwgaHdtIDwgMCkge1xuICAgICAgdmFyIG5hbWUgPSBpc0R1cGxleCA/IGR1cGxleEtleSA6ICdoaWdoV2F0ZXJNYXJrJztcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9PUFRfVkFMVUUobmFtZSwgaHdtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5mbG9vcihod20pO1xuICB9IC8vIERlZmF1bHQgdmFsdWVcblxuXG4gIHJldHVybiBzdGF0ZS5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRIaWdoV2F0ZXJNYXJrOiBnZXRIaWdoV2F0ZXJNYXJrXG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWRhYmxlLmZyb20gaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgYnJvd3NlcicpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdidWZmZXInKSxcbiAgICBCdWZmZXIgPSBfcmVxdWlyZS5CdWZmZXI7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCd1dGlsJyksXG4gICAgaW5zcGVjdCA9IF9yZXF1aXJlMi5pbnNwZWN0O1xuXG52YXIgY3VzdG9tID0gaW5zcGVjdCAmJiBpbnNwZWN0LmN1c3RvbSB8fCAnaW5zcGVjdCc7XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBCdWZmZXIucHJvdG90eXBlLmNvcHkuY2FsbChzcmMsIHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcblxuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQnVmZmVyTGlzdCwgW3tcbiAgICBrZXk6IFwicHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgZGF0YTogdixcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgKyt0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5zaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgZGF0YTogdixcbiAgICAgICAgbmV4dDogdGhpcy5oZWFkXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICAgKyt0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgICAgLS10aGlzLmxlbmd0aDtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiam9pblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG5cbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb25jYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBvciBjaGFyYWN0ZXJzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG5cbiAgfSwge1xuICAgIGtleTogXCJjb25zdW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnN1bWUobiwgaGFzU3RyaW5ncykge1xuICAgICAgdmFyIHJldDtcblxuICAgICAgaWYgKG4gPCB0aGlzLmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgLy8gYHNsaWNlYCBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5ncy5cbiAgICAgICAgcmV0ID0gdGhpcy5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgICAgIHRoaXMuaGVhZC5kYXRhID0gdGhpcy5oZWFkLmRhdGEuc2xpY2Uobik7XG4gICAgICB9IGVsc2UgaWYgKG4gPT09IHRoaXMuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAvLyBGaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2guXG4gICAgICAgIHJldCA9IHRoaXMuc2hpZnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlci5cbiAgICAgICAgcmV0ID0gaGFzU3RyaW5ncyA/IHRoaXMuX2dldFN0cmluZyhuKSA6IHRoaXMuX2dldEJ1ZmZlcihuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmlyc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlyc3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgfSAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U3RyaW5nKG4pIHtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGMgPSAxO1xuICAgICAgdmFyIHJldCA9IHAuZGF0YTtcbiAgICAgIG4gLT0gcmV0Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICAgICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICAgICAgbiAtPSBuYjtcblxuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgKytjO1xuICAgICAgICAgICAgaWYgKHAubmV4dCkgdGhpcy5oZWFkID0gcC5uZXh0O2Vsc2UgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gcDtcbiAgICAgICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICArK2M7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoIC09IGM7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0QnVmZmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRCdWZmZXIobikge1xuICAgICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGMgPSAxO1xuICAgICAgcC5kYXRhLmNvcHkocmV0KTtcbiAgICAgIG4gLT0gcC5kYXRhLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICAgICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICAgICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgICAgICBuIC09IG5iO1xuXG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICAgICArK2M7XG4gICAgICAgICAgICBpZiAocC5uZXh0KSB0aGlzLmhlYWQgPSBwLm5leHQ7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBwO1xuICAgICAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgICsrYztcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggLT0gYztcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSAvLyBNYWtlIHN1cmUgdGhlIGxpbmtlZCBsaXN0IG9ubHkgc2hvd3MgdGhlIG1pbmltYWwgbmVjZXNzYXJ5IGluZm9ybWF0aW9uLlxuXG4gIH0sIHtcbiAgICBrZXk6IGN1c3RvbSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoXywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGluc3BlY3QodGhpcywgX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucywge1xuICAgICAgICAvLyBPbmx5IGluc3BlY3Qgb25lIGxldmVsLlxuICAgICAgICBkZXB0aDogMCxcbiAgICAgICAgLy8gSXQgc2hvdWxkIG5vdCByZWN1cnNlLlxuICAgICAgICBjdXN0b21JbnNwZWN0OiBmYWxzZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9PYmplY3Qkc2V0UHJvdG90eXBlTztcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIGZpbmlzaGVkID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJyk7XG5cbnZhciBrTGFzdFJlc29sdmUgPSBTeW1ib2woJ2xhc3RSZXNvbHZlJyk7XG52YXIga0xhc3RSZWplY3QgPSBTeW1ib2woJ2xhc3RSZWplY3QnKTtcbnZhciBrRXJyb3IgPSBTeW1ib2woJ2Vycm9yJyk7XG52YXIga0VuZGVkID0gU3ltYm9sKCdlbmRlZCcpO1xudmFyIGtMYXN0UHJvbWlzZSA9IFN5bWJvbCgnbGFzdFByb21pc2UnKTtcbnZhciBrSGFuZGxlUHJvbWlzZSA9IFN5bWJvbCgnaGFuZGxlUHJvbWlzZScpO1xudmFyIGtTdHJlYW0gPSBTeW1ib2woJ3N0cmVhbScpO1xuXG5mdW5jdGlvbiBjcmVhdGVJdGVyUmVzdWx0KHZhbHVlLCBkb25lKSB7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGRvbmU6IGRvbmVcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVhZEFuZFJlc29sdmUoaXRlcikge1xuICB2YXIgcmVzb2x2ZSA9IGl0ZXJba0xhc3RSZXNvbHZlXTtcblxuICBpZiAocmVzb2x2ZSAhPT0gbnVsbCkge1xuICAgIHZhciBkYXRhID0gaXRlcltrU3RyZWFtXS5yZWFkKCk7IC8vIHdlIGRlZmVyIGlmIGRhdGEgaXMgbnVsbFxuICAgIC8vIHdlIGNhbiBiZSBleHBlY3RpbmcgZWl0aGVyICdlbmQnIG9yXG4gICAgLy8gJ2Vycm9yJ1xuXG4gICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgIGl0ZXJba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICBpdGVyW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgaXRlcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uUmVhZGFibGUoaXRlcikge1xuICAvLyB3ZSB3YWl0IGZvciB0aGUgbmV4dCB0aWNrLCBiZWNhdXNlIGl0IG1pZ2h0XG4gIC8vIGVtaXQgYW4gZXJyb3Igd2l0aCBwcm9jZXNzLm5leHRUaWNrXG4gIHByb2Nlc3MubmV4dFRpY2socmVhZEFuZFJlc29sdmUsIGl0ZXIpO1xufVxuXG5mdW5jdGlvbiB3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgaXRlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGxhc3RQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGl0ZXJba0VuZGVkXSkge1xuICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaXRlcltrSGFuZGxlUHJvbWlzZV0ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9LCByZWplY3QpO1xuICB9O1xufVxuXG52YXIgQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihmdW5jdGlvbiAoKSB7fSk7XG52YXIgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LnNldFByb3RvdHlwZU9mKChfT2JqZWN0JHNldFByb3RvdHlwZU8gPSB7XG4gIGdldCBzdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXNba1N0cmVhbV07XG4gIH0sXG5cbiAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gaWYgd2UgaGF2ZSBkZXRlY3RlZCBhbiBlcnJvciBpbiB0aGUgbWVhbndoaWxlXG4gICAgLy8gcmVqZWN0IHN0cmFpZ2h0IGF3YXlcbiAgICB2YXIgZXJyb3IgPSB0aGlzW2tFcnJvcl07XG5cbiAgICBpZiAoZXJyb3IgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXNba0VuZGVkXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzW2tTdHJlYW1dLmRlc3Ryb3llZCkge1xuICAgICAgLy8gV2UgbmVlZCB0byBkZWZlciB2aWEgbmV4dFRpY2sgYmVjYXVzZSBpZiAuZGVzdHJveShlcnIpIGlzXG4gICAgICAvLyBjYWxsZWQsIHRoZSBlcnJvciB3aWxsIGJlIGVtaXR0ZWQgdmlhIG5leHRUaWNrLCBhbmRcbiAgICAgIC8vIHdlIGNhbm5vdCBndWFyYW50ZWUgdGhhdCB0aGVyZSBpcyBubyBlcnJvciBsaW5nZXJpbmcgYXJvdW5kXG4gICAgICAvLyB3YWl0aW5nIHRvIGJlIGVtaXR0ZWQuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXNba0Vycm9yXSkge1xuICAgICAgICAgICAgcmVqZWN0KF90aGlzW2tFcnJvcl0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gLy8gaWYgd2UgaGF2ZSBtdWx0aXBsZSBuZXh0KCkgY2FsbHNcbiAgICAvLyB3ZSB3aWxsIHdhaXQgZm9yIHRoZSBwcmV2aW91cyBQcm9taXNlIHRvIGZpbmlzaFxuICAgIC8vIHRoaXMgbG9naWMgaXMgb3B0aW1pemVkIHRvIHN1cHBvcnQgZm9yIGF3YWl0IGxvb3BzLFxuICAgIC8vIHdoZXJlIG5leHQoKSBpcyBvbmx5IGNhbGxlZCBvbmNlIGF0IGEgdGltZVxuXG5cbiAgICB2YXIgbGFzdFByb21pc2UgPSB0aGlzW2tMYXN0UHJvbWlzZV07XG4gICAgdmFyIHByb21pc2U7XG5cbiAgICBpZiAobGFzdFByb21pc2UpIHtcbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgdGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmYXN0IHBhdGggbmVlZGVkIHRvIHN1cHBvcnQgbXVsdGlwbGUgdGhpcy5wdXNoKClcbiAgICAgIC8vIHdpdGhvdXQgdHJpZ2dlcmluZyB0aGUgbmV4dCgpIHF1ZXVlXG4gICAgICB2YXIgZGF0YSA9IHRoaXNba1N0cmVhbV0ucmVhZCgpO1xuXG4gICAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICAgIH1cblxuICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHRoaXNba0hhbmRsZVByb21pc2VdKTtcbiAgICB9XG5cbiAgICB0aGlzW2tMYXN0UHJvbWlzZV0gPSBwcm9taXNlO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG59LCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRzZXRQcm90b3R5cGVPLCBTeW1ib2wuYXN5bmNJdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRzZXRQcm90b3R5cGVPLCBcInJldHVyblwiLCBmdW5jdGlvbiBfcmV0dXJuKCkge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAvLyBkZXN0cm95KGVyciwgY2IpIGlzIGEgcHJpdmF0ZSBBUElcbiAgLy8gd2UgY2FuIGd1YXJhbnRlZSB3ZSBoYXZlIHRoYXQgaGVyZSwgYmVjYXVzZSB3ZSBjb250cm9sIHRoZVxuICAvLyBSZWFkYWJsZSBjbGFzcyB0aGlzIGlzIGF0dGFjaGVkIHRvXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgX3RoaXMyW2tTdHJlYW1dLmRlc3Ryb3kobnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfSk7XG4gIH0pO1xufSksIF9PYmplY3Qkc2V0UHJvdG90eXBlTyksIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUpO1xuXG52YXIgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID0gZnVuY3Rpb24gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHN0cmVhbSkge1xuICB2YXIgX09iamVjdCRjcmVhdGU7XG5cbiAgdmFyIGl0ZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUsIChfT2JqZWN0JGNyZWF0ZSA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtTdHJlYW0sIHtcbiAgICB2YWx1ZTogc3RyZWFtLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtMYXN0UmVzb2x2ZSwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtMYXN0UmVqZWN0LCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0Vycm9yLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0VuZGVkLCB7XG4gICAgdmFsdWU6IHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtIYW5kbGVQcm9taXNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGRhdGEgPSBpdGVyYXRvcltrU3RyZWFtXS5yZWFkKCk7XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gcmVzb2x2ZTtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gcmVqZWN0O1xuICAgICAgfVxuICAgIH0sXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9PYmplY3QkY3JlYXRlKSk7XG4gIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICBmaW5pc2hlZChzdHJlYW0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyICYmIGVyci5jb2RlICE9PSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnKSB7XG4gICAgICB2YXIgcmVqZWN0ID0gaXRlcmF0b3Jba0xhc3RSZWplY3RdOyAvLyByZWplY3QgaWYgd2UgYXJlIHdhaXRpbmcgZm9yIGRhdGEgaW4gdGhlIFByb21pc2VcbiAgICAgIC8vIHJldHVybmVkIGJ5IG5leHQoKSBhbmQgc3RvcmUgdGhlIGVycm9yXG5cbiAgICAgIGlmIChyZWplY3QgIT09IG51bGwpIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0b3Jba0Vycm9yXSA9IGVycjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVzb2x2ZSA9IGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV07XG5cbiAgICBpZiAocmVzb2x2ZSAhPT0gbnVsbCkge1xuICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgaXRlcmF0b3Jba0VuZGVkXSA9IHRydWU7XG4gIH0pO1xuICBzdHJlYW0ub24oJ3JlYWRhYmxlJywgb25SZWFkYWJsZS5iaW5kKG51bGwsIGl0ZXJhdG9yKSk7XG4gIHJldHVybiBpdGVyYXRvcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yOyIsIid1c2Ugc3RyaWN0JztcblxuLy8gRm91bmQgdGhpcyBzZWVkLWJhc2VkIHJhbmRvbSBnZW5lcmF0b3Igc29tZXdoZXJlXG4vLyBCYXNlZCBvbiBUaGUgQ2VudHJhbCBSYW5kb21pemVyIDEuMyAoQykgMTk5NyBieSBQYXVsIEhvdWxlIChob3VsZUBtc2MuY29ybmVsbC5lZHUpXG5cbnZhciBzZWVkID0gMTtcblxuLyoqXG4gKiByZXR1cm4gYSByYW5kb20gbnVtYmVyIGJhc2VkIG9uIGEgc2VlZFxuICogQHBhcmFtIHNlZWRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldE5leHRWYWx1ZSgpIHtcbiAgICBzZWVkID0gKHNlZWQgKiA5MzAxICsgNDkyOTcpICUgMjMzMjgwO1xuICAgIHJldHVybiBzZWVkLygyMzMyODAuMCk7XG59XG5cbmZ1bmN0aW9uIHNldFNlZWQoX3NlZWRfKSB7XG4gICAgc2VlZCA9IF9zZWVkXztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbmV4dFZhbHVlOiBnZXROZXh0VmFsdWUsXG4gICAgc2VlZDogc2V0U2VlZFxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFscGhhYmV0ID0gcmVxdWlyZSgnLi9hbHBoYWJldCcpO1xudmFyIHJhbmRvbSA9IHJlcXVpcmUoJy4vcmFuZG9tL3JhbmRvbS1ieXRlJyk7XG52YXIgZm9ybWF0ID0gcmVxdWlyZSgnbmFub2lkL2Zvcm1hdCcpO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZShudW1iZXIpIHtcbiAgICB2YXIgbG9vcENvdW50ZXIgPSAwO1xuICAgIHZhciBkb25lO1xuXG4gICAgdmFyIHN0ciA9ICcnO1xuXG4gICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgIHN0ciA9IHN0ciArIGZvcm1hdChyYW5kb20sIGFscGhhYmV0LmdldCgpLCAxKTtcbiAgICAgICAgZG9uZSA9IG51bWJlciA8IChNYXRoLnBvdygxNiwgbG9vcENvdW50ZXIgKyAxICkgKTtcbiAgICAgICAgbG9vcENvdW50ZXIrKztcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmF0ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNyeXB0byA9IHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmICh3aW5kb3cuY3J5cHRvIHx8IHdpbmRvdy5tc0NyeXB0byk7IC8vIElFIDExIHVzZXMgd2luZG93Lm1zQ3J5cHRvXG5cbnZhciByYW5kb21CeXRlO1xuXG5pZiAoIWNyeXB0byB8fCAhY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIHJhbmRvbUJ5dGUgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIHZhciBieXRlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgYnl0ZXMucHVzaChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgcmFuZG9tQnl0ZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoc2l6ZSkpO1xuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmFuZG9tQnl0ZTtcbiIsIi8vIFRoaXMgZmlsZSByZXBsYWNlcyBgZm9ybWF0LmpzYCBpbiBidW5kbGVycyBsaWtlIHdlYnBhY2sgb3IgUm9sbHVwLFxuLy8gYWNjb3JkaW5nIHRvIGBicm93c2VyYCBjb25maWcgaW4gYHBhY2thZ2UuanNvbmAuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJhbmRvbSwgYWxwaGFiZXQsIHNpemUpIHtcbiAgLy8gV2UgY2Fu4oCZdCB1c2UgYnl0ZXMgYmlnZ2VyIHRoYW4gdGhlIGFscGhhYmV0LiBUbyBtYWtlIGJ5dGVzIHZhbHVlcyBjbG9zZXJcbiAgLy8gdG8gdGhlIGFscGhhYmV0LCB3ZSBhcHBseSBiaXRtYXNrIG9uIHRoZW0uIFdlIGxvb2sgZm9yIHRoZSBjbG9zZXN0XG4gIC8vIGAyICoqIHggLSAxYCBudW1iZXIsIHdoaWNoIHdpbGwgYmUgYmlnZ2VyIHRoYW4gYWxwaGFiZXQgc2l6ZS4gSWYgd2UgaGF2ZVxuICAvLyAzMCBzeW1ib2xzIGluIHRoZSBhbHBoYWJldCwgd2Ugd2lsbCB0YWtlIDMxICgwMDAxMTExMSkuXG4gIC8vIFdlIGRvIG5vdCB1c2UgZmFzdGVyIE1hdGguY2x6MzIsIGJlY2F1c2UgaXQgaXMgbm90IGF2YWlsYWJsZSBpbiBicm93c2Vycy5cbiAgdmFyIG1hc2sgPSAoMiA8PCBNYXRoLmxvZyhhbHBoYWJldC5sZW5ndGggLSAxKSAvIE1hdGguTE4yKSAtIDFcbiAgLy8gQml0bWFzayBpcyBub3QgYSBwZXJmZWN0IHNvbHV0aW9uIChpbiBvdXIgZXhhbXBsZSBpdCB3aWxsIHBhc3MgMzEgYnl0ZXMsXG4gIC8vIHdoaWNoIGlzIGJpZ2dlciB0aGFuIHRoZSBhbHBoYWJldCkuIEFzIGEgcmVzdWx0LCB3ZSB3aWxsIG5lZWQgbW9yZSBieXRlcyxcbiAgLy8gdGhhbiBJRCBzaXplLCBiZWNhdXNlIHdlIHdpbGwgcmVmdXNlIGJ5dGVzIGJpZ2dlciB0aGFuIHRoZSBhbHBoYWJldC5cblxuICAvLyBFdmVyeSBoYXJkd2FyZSByYW5kb20gZ2VuZXJhdG9yIGNhbGwgaXMgY29zdGx5LFxuICAvLyBiZWNhdXNlIHdlIG5lZWQgdG8gd2FpdCBmb3IgZW50cm9weSBjb2xsZWN0aW9uLiBUaGlzIGlzIHdoeSBvZnRlbiBpdCB3aWxsXG4gIC8vIGJlIGZhc3RlciB0byBhc2sgZm9yIGZldyBleHRyYSBieXRlcyBpbiBhZHZhbmNlLCB0byBhdm9pZCBhZGRpdGlvbmFsIGNhbGxzLlxuXG4gIC8vIEhlcmUgd2UgY2FsY3VsYXRlIGhvdyBtYW55IHJhbmRvbSBieXRlcyBzaG91bGQgd2UgY2FsbCBpbiBhZHZhbmNlLlxuICAvLyBJdCBkZXBlbmRzIG9uIElEIGxlbmd0aCwgbWFzayAvIGFscGhhYmV0IHNpemUgYW5kIG1hZ2ljIG51bWJlciAxLjZcbiAgLy8gKHdoaWNoIHdhcyBzZWxlY3RlZCBhY2NvcmRpbmcgYmVuY2htYXJrcykuXG5cbiAgLy8gLX5mID0+IE1hdGguY2VpbChmKSBpZiBuIGlzIGZsb2F0IG51bWJlclxuICAvLyAtfmkgPT4gaSArIDEgaWYgbiBpcyBpbnRlZ2VyIG51bWJlclxuICB2YXIgc3RlcCA9IC1+KDEuNiAqIG1hc2sgKiBzaXplIC8gYWxwaGFiZXQubGVuZ3RoKVxuICB2YXIgaWQgPSAnJ1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIGJ5dGVzID0gcmFuZG9tKHN0ZXApXG4gICAgLy8gQ29tcGFjdCBhbHRlcm5hdGl2ZSBmb3IgYGZvciAodmFyIGkgPSAwOyBpIDwgc3RlcDsgaSsrKWBcbiAgICB2YXIgaSA9IHN0ZXBcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAvLyBJZiByYW5kb20gYnl0ZSBpcyBiaWdnZXIgdGhhbiBhbHBoYWJldCBldmVuIGFmdGVyIGJpdG1hc2ssXG4gICAgICAvLyB3ZSByZWZ1c2UgaXQgYnkgYHx8ICcnYC5cbiAgICAgIGlkICs9IGFscGhhYmV0W2J5dGVzW2ldICYgbWFza10gfHwgJydcbiAgICAgIC8vIE1vcmUgY29tcGFjdCB0aGFuIGBpZC5sZW5ndGggKyAxID09PSBzaXplYFxuICAgICAgaWYgKGlkLmxlbmd0aCA9PT0gK3NpemUpIHJldHVybiBpZFxuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAZmlsZSBUaGUgZW50cnkgcG9pbnQgZm9yIHRoZSB3ZWIgZXh0ZW5zaW9uIHNpbmdsZXRvbiBwcm9jZXNzLlxuICovXG5cbmltcG9ydCBlbmRPZlN0cmVhbSBmcm9tICdlbmQtb2Ytc3RyZWFtJztcbmltcG9ydCBwdW1wIGZyb20gJ3B1bXAnO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gJ2RlYm91bmNlLXN0cmVhbSc7XG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBleHRlbnNpb24gZnJvbSAnZXh0ZW5zaW9uaXplcic7XG5pbXBvcnQgeyBzdG9yZUFzU3RyZWFtLCBzdG9yZVRyYW5zZm9ybVN0cmVhbSB9IGZyb20gJ0BtZXRhbWFzay9vYnMtc3RvcmUnO1xuaW1wb3J0IFBvcnRTdHJlYW0gZnJvbSAnZXh0ZW5zaW9uLXBvcnQtc3RyZWFtJztcbmltcG9ydCB7IGNhcHR1cmVFeGNlcHRpb24gfSBmcm9tICdAc2VudHJ5L2Jyb3dzZXInO1xuXG5pbXBvcnQgeyBldGhFcnJvcnMgfSBmcm9tICdldGgtcnBjLWVycm9ycyc7XG5pbXBvcnQge1xuICBFTlZJUk9OTUVOVF9UWVBFX1BPUFVQLFxuICBFTlZJUk9OTUVOVF9UWVBFX05PVElGSUNBVElPTixcbiAgRU5WSVJPTk1FTlRfVFlQRV9GVUxMU0NSRUVOLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvY29uc3RhbnRzL2FwcCc7XG5pbXBvcnQgeyBTRUNPTkQgfSBmcm9tICcuLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RpbWUnO1xuaW1wb3J0IHtcbiAgUkVKRUNUX05PVEZJQ0lBVElPTl9DTE9TRSxcbiAgUkVKRUNUX05PVEZJQ0lBVElPTl9DTE9TRV9TSUcsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbWV0YW1ldHJpY3MnO1xuaW1wb3J0IG1pZ3JhdGlvbnMgZnJvbSAnLi9taWdyYXRpb25zJztcbmltcG9ydCBNaWdyYXRvciBmcm9tICcuL2xpYi9taWdyYXRvcic7XG5pbXBvcnQgRXh0ZW5zaW9uUGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybXMvZXh0ZW5zaW9uJztcbmltcG9ydCBMb2NhbFN0b3JlIGZyb20gJy4vbGliL2xvY2FsLXN0b3JlJztcbmltcG9ydCBSZWFkT25seU5ldHdvcmtTdG9yZSBmcm9tICcuL2xpYi9uZXR3b3JrLXN0b3JlJztcbmltcG9ydCBjcmVhdGVTdHJlYW1TaW5rIGZyb20gJy4vbGliL2NyZWF0ZVN0cmVhbVNpbmsnO1xuaW1wb3J0IE5vdGlmaWNhdGlvbk1hbmFnZXIsIHtcbiAgTk9USUZJQ0FUSU9OX01BTkFHRVJfRVZFTlRTLFxufSBmcm9tICcuL2xpYi9ub3RpZmljYXRpb24tbWFuYWdlcic7XG5pbXBvcnQgTWV0YW1hc2tDb250cm9sbGVyLCB7XG4gIE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTLFxufSBmcm9tICcuL21ldGFtYXNrLWNvbnRyb2xsZXInO1xuaW1wb3J0IHJhd0ZpcnN0VGltZVN0YXRlIGZyb20gJy4vZmlyc3QtdGltZS1zdGF0ZSc7XG5pbXBvcnQgZ2V0Rmlyc3RQcmVmZXJyZWRMYW5nQ29kZSBmcm9tICcuL2xpYi9nZXQtZmlyc3QtcHJlZmVycmVkLWxhbmctY29kZSc7XG5pbXBvcnQgZ2V0T2JqU3RydWN0dXJlIGZyb20gJy4vbGliL2dldE9ialN0cnVjdHVyZSc7XG5pbXBvcnQgc2V0dXBFbnNJcGZzUmVzb2x2ZXIgZnJvbSAnLi9saWIvZW5zLWlwZnMvc2V0dXAnO1xuLyogZXNsaW50LWVuYWJsZSBpbXBvcnQvZmlyc3QgKi9cblxuY29uc3QgeyBzZW50cnkgfSA9IGdsb2JhbDtcbmNvbnN0IGZpcnN0VGltZVN0YXRlID0geyAuLi5yYXdGaXJzdFRpbWVTdGF0ZSB9O1xuXG5sb2cuc2V0RGVmYXVsdExldmVsKHByb2Nlc3MuZW52Lk1FVEFNQVNLX0RFQlVHID8gJ2RlYnVnJyA6ICdpbmZvJyk7XG5cbmNvbnN0IHBsYXRmb3JtID0gbmV3IEV4dGVuc2lvblBsYXRmb3JtKCk7XG5cbmNvbnN0IG5vdGlmaWNhdGlvbk1hbmFnZXIgPSBuZXcgTm90aWZpY2F0aW9uTWFuYWdlcigpO1xuZ2xvYmFsLk1FVEFNQVNLX05PVElGSUVSID0gbm90aWZpY2F0aW9uTWFuYWdlcjtcblxubGV0IHBvcHVwSXNPcGVuID0gZmFsc2U7XG5sZXQgbm90aWZpY2F0aW9uSXNPcGVuID0gZmFsc2U7XG5sZXQgdWlJc1RyaWdnZXJpbmcgPSBmYWxzZTtcbmNvbnN0IG9wZW5NZXRhbWFza1RhYnNJRHMgPSB7fTtcbmNvbnN0IHJlcXVlc3RBY2NvdW50VGFiSWRzID0ge307XG5cbi8vIHN0YXRlIHBlcnNpc3RlbmNlXG5jb25zdCBpblRlc3QgPSBwcm9jZXNzLmVudi5JTl9URVNUO1xuY29uc3QgbG9jYWxTdG9yZSA9IGluVGVzdCA/IG5ldyBSZWFkT25seU5ldHdvcmtTdG9yZSgpIDogbmV3IExvY2FsU3RvcmUoKTtcbmxldCB2ZXJzaW9uZWREYXRhO1xuXG5pZiAoaW5UZXN0IHx8IHByb2Nlc3MuZW52Lk1FVEFNQVNLX0RFQlVHKSB7XG4gIGdsb2JhbC5tZXRhbWFza0dldFN0YXRlID0gbG9jYWxTdG9yZS5nZXQuYmluZChsb2NhbFN0b3JlKTtcbn1cblxuLy8gaW5pdGlhbGl6YXRpb24gZmxvd1xuaW5pdGlhbGl6ZSgpLmNhdGNoKGxvZy5lcnJvcik7XG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbicpLlRyYW5zYWN0aW9uTWV0YX0gVHJhbnNhY3Rpb25NZXRhXG4gKi9cblxuLyoqXG4gKiBUaGUgZGF0YSBlbWl0dGVkIGZyb20gdGhlIE1ldGFNYXNrQ29udHJvbGxlci5zdG9yZSBFdmVudEVtaXR0ZXIsIGFsc28gdXNlZCB0byBpbml0aWFsaXplIHRoZSBNZXRhTWFza0NvbnRyb2xsZXIuIEF2YWlsYWJsZSBpbiBVSSBvbiBSZWFjdCBzdGF0ZSBhcyBzdGF0ZS5tZXRhbWFzay5cbiAqXG4gKiBAdHlwZWRlZiBNZXRhTWFza1N0YXRlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzSW5pdGlhbGl6ZWQgLSBXaGV0aGVyIHRoZSBmaXJzdCB2YXVsdCBoYXMgYmVlbiBjcmVhdGVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBpc1VubG9ja2VkIC0gV2hldGhlciB0aGUgdmF1bHQgaXMgY3VycmVudGx5IGRlY3J5cHRlZCBhbmQgYWNjb3VudHMgYXJlIGF2YWlsYWJsZSBmb3Igc2VsZWN0aW9uLlxuICogQHByb3BlcnR5IHtib29sZWFufSBpc0FjY291bnRNZW51T3BlbiAtIFJlcHJlc2VudHMgd2hldGhlciB0aGUgbWFpbiBhY2NvdW50IHNlbGVjdGlvbiBVSSBpcyBjdXJyZW50bHkgZGlzcGxheWVkLlxuICogQHByb3BlcnR5IHtPYmplY3R9IGlkZW50aXRpZXMgLSBBbiBvYmplY3QgbWF0Y2hpbmcgbG93ZXItY2FzZSBoZXggYWRkcmVzc2VzIHRvIElkZW50aXR5IG9iamVjdHMgd2l0aCBcImFkZHJlc3NcIiBhbmQgXCJuYW1lXCIgKG5pY2tuYW1lKSBrZXlzLlxuICogQHByb3BlcnR5IHtPYmplY3R9IHVuYXBwcm92ZWRUeHMgLSBBbiBvYmplY3QgbWFwcGluZyB0cmFuc2FjdGlvbiBoYXNoZXMgdG8gdW5hcHByb3ZlZCB0cmFuc2FjdGlvbnMuXG4gKiBAcHJvcGVydHkge0FycmF5fSBmcmVxdWVudFJwY0xpc3QgLSBBIGxpc3Qgb2YgZnJlcXVlbnRseSB1c2VkIFJQQ3MsIGluY2x1ZGluZyBjdXN0b20gdXNlci1wcm92aWRlZCBvbmVzLlxuICogQHByb3BlcnR5IHtBcnJheX0gYWRkcmVzc0Jvb2sgLSBBIGxpc3Qgb2YgcHJldmlvdXNseSBzZW50IHRvIGFkZHJlc3Nlcy5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBjb250cmFjdEV4Y2hhbmdlUmF0ZXMgLSBJbmZvIGFib3V0IGN1cnJlbnQgdG9rZW4gcHJpY2VzLlxuICogQHByb3BlcnR5IHtBcnJheX0gdG9rZW5zIC0gVG9rZW5zIGhlbGQgYnkgdGhlIGN1cnJlbnQgdXNlciwgaW5jbHVkaW5nIHRoZWlyIGJhbGFuY2VzLlxuICogQHByb3BlcnR5IHtPYmplY3R9IHNlbmQgLSBUT0RPOiBEb2N1bWVudFxuICogQHByb3BlcnR5IHtib29sZWFufSB1c2VCbG9ja2llIC0gSW5kaWNhdGVzIHByZWZlcnJlZCB1c2VyIGlkZW50aWNvbiBmb3JtYXQuIFRydWUgZm9yIGJsb2NraWUsIGZhbHNlIGZvciBKYXp6aWNvbi5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBmZWF0dXJlRmxhZ3MgLSBBbiBvYmplY3QgZm9yIG9wdGlvbmFsIGZlYXR1cmUgZmxhZ3MuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHdlbGNvbWVTY3JlZW4gLSBUcnVlIGlmIHdlbGNvbWUgc2NyZWVuIHNob3VsZCBiZSBzaG93bi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjdXJyZW50TG9jYWxlIC0gQSBsb2NhbGUgc3RyaW5nIG1hdGNoaW5nIHRoZSB1c2VyJ3MgcHJlZmVycmVkIGRpc3BsYXkgbGFuZ3VhZ2UuXG4gKiBAcHJvcGVydHkge09iamVjdH0gcHJvdmlkZXIgLSBUaGUgY3VycmVudCBzZWxlY3RlZCBuZXR3b3JrIHByb3ZpZGVyLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHByb3ZpZGVyLnJwY1VybCAtIFRoZSBhZGRyZXNzIGZvciB0aGUgUlBDIEFQSSwgaWYgdXNpbmcgYW4gUlBDIEFQSS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwcm92aWRlci50eXBlIC0gQW4gaWRlbnRpZmllciBmb3IgdGhlIHR5cGUgb2YgbmV0d29yayBzZWxlY3RlZCwgYWxsb3dzIE1ldGFNYXNrIHRvIHVzZSBjdXN0b20gcHJvdmlkZXIgc3RyYXRlZ2llcyBmb3Iga25vd24gbmV0d29ya3MuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmV0d29yayAtIEEgc3RyaW5naWZpZWQgbnVtYmVyIG9mIHRoZSBjdXJyZW50IG5ldHdvcmsgSUQuXG4gKiBAcHJvcGVydHkge09iamVjdH0gYWNjb3VudHMgLSBBbiBvYmplY3QgbWFwcGluZyBsb3dlci1jYXNlIGhleCBhZGRyZXNzZXMgdG8gb2JqZWN0cyB3aXRoIFwiYmFsYW5jZVwiIGFuZCBcImFkZHJlc3NcIiBrZXlzLCBib3RoIHN0b3JpbmcgaGV4IHN0cmluZyB2YWx1ZXMuXG4gKiBAcHJvcGVydHkge2hleH0gY3VycmVudEJsb2NrR2FzTGltaXQgLSBUaGUgbW9zdCByZWNlbnRseSBzZWVuIGJsb2NrIGdhcyBsaW1pdCwgaW4gYSBsb3dlciBjYXNlIGhleCBwcmVmaXhlZCBzdHJpbmcuXG4gKiBAcHJvcGVydHkge1RyYW5zYWN0aW9uTWV0YVtdfSBjdXJyZW50TmV0d29ya1R4TGlzdCAtIEFuIGFycmF5IG9mIHRyYW5zYWN0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBuZXR3b3JrLlxuICogQHByb3BlcnR5IHtPYmplY3R9IHVuYXBwcm92ZWRNc2dzIC0gQW4gb2JqZWN0IG9mIG1lc3NhZ2VzIHBlbmRpbmcgYXBwcm92YWwsIG1hcHBpbmcgYSB1bmlxdWUgSUQgdG8gdGhlIG9wdGlvbnMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gdW5hcHByb3ZlZE1zZ0NvdW50IC0gVGhlIG51bWJlciBvZiBtZXNzYWdlcyBpbiB1bmFwcHJvdmVkTXNncy5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSB1bmFwcHJvdmVkUGVyc29uYWxNc2dzIC0gQW4gb2JqZWN0IG9mIG1lc3NhZ2VzIHBlbmRpbmcgYXBwcm92YWwsIG1hcHBpbmcgYSB1bmlxdWUgSUQgdG8gdGhlIG9wdGlvbnMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gdW5hcHByb3ZlZFBlcnNvbmFsTXNnQ291bnQgLSBUaGUgbnVtYmVyIG9mIG1lc3NhZ2VzIGluIHVuYXBwcm92ZWRQZXJzb25hbE1zZ3MuXG4gKiBAcHJvcGVydHkge09iamVjdH0gdW5hcHByb3ZlZEVuY3J5cHRpb25QdWJsaWNLZXlNc2dzIC0gQW4gb2JqZWN0IG9mIG1lc3NhZ2VzIHBlbmRpbmcgYXBwcm92YWwsIG1hcHBpbmcgYSB1bmlxdWUgSUQgdG8gdGhlIG9wdGlvbnMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gdW5hcHByb3ZlZEVuY3J5cHRpb25QdWJsaWNLZXlNc2dDb3VudCAtIFRoZSBudW1iZXIgb2YgbWVzc2FnZXMgaW4gRW5jcnlwdGlvblB1YmxpY0tleU1zZ3MuXG4gKiBAcHJvcGVydHkge09iamVjdH0gdW5hcHByb3ZlZERlY3J5cHRNc2dzIC0gQW4gb2JqZWN0IG9mIG1lc3NhZ2VzIHBlbmRpbmcgYXBwcm92YWwsIG1hcHBpbmcgYSB1bmlxdWUgSUQgdG8gdGhlIG9wdGlvbnMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gdW5hcHByb3ZlZERlY3J5cHRNc2dDb3VudCAtIFRoZSBudW1iZXIgb2YgbWVzc2FnZXMgaW4gdW5hcHByb3ZlZERlY3J5cHRNc2dzLlxuICogQHByb3BlcnR5IHtPYmplY3R9IHVuYXBwcm92ZWRUeXBlZE1zZ3MgLSBBbiBvYmplY3Qgb2YgbWVzc2FnZXMgcGVuZGluZyBhcHByb3ZhbCwgbWFwcGluZyBhIHVuaXF1ZSBJRCB0byB0aGUgb3B0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1bmFwcHJvdmVkVHlwZWRNc2dDb3VudCAtIFRoZSBudW1iZXIgb2YgbWVzc2FnZXMgaW4gdW5hcHByb3ZlZFR5cGVkTXNncy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwZW5kaW5nQXBwcm92YWxDb3VudCAtIFRoZSBudW1iZXIgb2YgcGVuZGluZyByZXF1ZXN0IGluIHRoZSBhcHByb3ZhbCBjb250cm9sbGVyLlxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0ga2V5cmluZ1R5cGVzIC0gQW4gYXJyYXkgb2YgdW5pcXVlIGtleXJpbmcgaWRlbnRpZnlpbmcgc3RyaW5ncywgcmVwcmVzZW50aW5nIGF2YWlsYWJsZSBzdHJhdGVnaWVzIGZvciBjcmVhdGluZyBhY2NvdW50cy5cbiAqIEBwcm9wZXJ0eSB7S2V5cmluZ1tdfSBrZXlyaW5ncyAtIEFuIGFycmF5IG9mIGtleXJpbmcgZGVzY3JpcHRpb25zLCBzdW1tYXJpemluZyB0aGUgYWNjb3VudHMgdGhhdCBhcmUgYXZhaWxhYmxlIGZvciB1c2UsIGFuZCB3aGF0IGtleXJpbmdzIHRoZXkgYmVsb25nIHRvLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNlbGVjdGVkQWRkcmVzcyAtIEEgbG93ZXIgY2FzZSBoZXggc3RyaW5nIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgYWRkcmVzcy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjdXJyZW50Q3VycmVuY3kgLSBBIHN0cmluZyBpZGVudGlmeWluZyB0aGUgdXNlcidzIHByZWZlcnJlZCBkaXNwbGF5IGN1cnJlbmN5LCBmb3IgdXNlIGluIHNob3dpbmcgY29udmVyc2lvbiByYXRlcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb252ZXJzaW9uUmF0ZSAtIEEgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBleGNoYW5nZSByYXRlIGZyb20gdGhlIHVzZXIncyBwcmVmZXJyZWQgY3VycmVuY3kgdG8gRXRoZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29udmVyc2lvbkRhdGUgLSBBIHVuaXggZXBvY2ggZGF0ZSAobXMpIGZvciB0aGUgdGltZSB0aGUgY3VycmVudCBjb252ZXJzaW9uIHJhdGUgd2FzIGxhc3QgcmV0cmlldmVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBmb3Jnb3R0ZW5QYXNzd29yZCAtIFJldHVybnMgdHJ1ZSBpZiB0aGUgdXNlciBoYXMgaW5pdGlhdGVkIHRoZSBwYXNzd29yZCByZWNvdmVyeSBzY3JlZW4sIGlzIHJlY292ZXJpbmcgZnJvbSBzZWVkIHBocmFzZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIFZlcnNpb25lZERhdGFcbiAqIEBwcm9wZXJ0eSB7TWV0YU1hc2tTdGF0ZX0gZGF0YSAtIFRoZSBkYXRhIGVtaXR0ZWQgZnJvbSBNZXRhTWFzayBjb250cm9sbGVyLCBvciB1c2VkIHRvIGluaXRpYWxpemUgaXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gdmVyc2lvbiAtIFRoZSBsYXRlc3QgbWlncmF0aW9uIHZlcnNpb24gdGhhdCBoYXMgYmVlbiBydW4uXG4gKi9cblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgTWV0YU1hc2sgY29udHJvbGxlciwgYW5kIHNldHMgdXAgYWxsIHBsYXRmb3JtIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQHJldHVybnMge1Byb21pc2V9IFNldHVwIGNvbXBsZXRlLlxuICovXG5hc3luYyBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICBjb25zdCBpbml0U3RhdGUgPSBhd2FpdCBsb2FkU3RhdGVGcm9tUGVyc2lzdGVuY2UoKTtcbiAgY29uc3QgaW5pdExhbmdDb2RlID0gYXdhaXQgZ2V0Rmlyc3RQcmVmZXJyZWRMYW5nQ29kZSgpO1xuICBhd2FpdCBzZXR1cENvbnRyb2xsZXIoaW5pdFN0YXRlLCBpbml0TGFuZ0NvZGUpO1xuICBsb2cuaW5mbygnTWV0YU1hc2sgaW5pdGlhbGl6YXRpb24gY29tcGxldGUuJyk7XG59XG5cbi8vXG4vLyBTdGF0ZSBhbmQgUGVyc2lzdGVuY2Vcbi8vXG5cbi8qKlxuICogTG9hZHMgYW55IHN0b3JlZCBkYXRhLCBwcmlvcml0aXppbmcgdGhlIGxhdGVzdCBzdG9yYWdlIHN0cmF0ZWd5LlxuICogTWlncmF0ZXMgdGhhdCBkYXRhIHNjaGVtYSBpbiBjYXNlIGl0IHdhcyBsYXN0IGxvYWRlZCBvbiBhbiBvbGRlciB2ZXJzaW9uLlxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGFNYXNrU3RhdGU+fSBMYXN0IGRhdGEgZW1pdHRlZCBmcm9tIHByZXZpb3VzIGluc3RhbmNlIG9mIE1ldGFNYXNrLlxuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkU3RhdGVGcm9tUGVyc2lzdGVuY2UoKSB7XG4gIC8vIG1pZ3JhdGlvbnNcbiAgY29uc3QgbWlncmF0b3IgPSBuZXcgTWlncmF0b3IoeyBtaWdyYXRpb25zIH0pO1xuICBtaWdyYXRvci5vbignZXJyb3InLCBjb25zb2xlLndhcm4pO1xuXG4gIC8vIHJlYWQgZnJvbSBkaXNrXG4gIC8vIGZpcnN0IGZyb20gcHJlZmVycmVkLCBhc3luYyBBUEk6XG4gIHZlcnNpb25lZERhdGEgPVxuICAgIChhd2FpdCBsb2NhbFN0b3JlLmdldCgpKSB8fCBtaWdyYXRvci5nZW5lcmF0ZUluaXRpYWxTdGF0ZShmaXJzdFRpbWVTdGF0ZSk7XG5cbiAgLy8gY2hlY2sgaWYgc29tZWhvdyBzdGF0ZSBpcyBlbXB0eVxuICAvLyB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW4gYnV0IG5ldyBlcnJvciByZXBvcnRpbmcgc3VnZ2VzdHMgdGhhdCBpdCBoYXNcbiAgLy8gZm9yIGEgc21hbGwgbnVtYmVyIG9mIHVzZXJzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tZXRhbWFzay9tZXRhbWFzay1leHRlbnNpb24vaXNzdWVzLzM5MTlcbiAgaWYgKHZlcnNpb25lZERhdGEgJiYgIXZlcnNpb25lZERhdGEuZGF0YSkge1xuICAgIC8vIHVuYWJsZSB0byByZWNvdmVyLCBjbGVhciBzdGF0ZVxuICAgIHZlcnNpb25lZERhdGEgPSBtaWdyYXRvci5nZW5lcmF0ZUluaXRpYWxTdGF0ZShmaXJzdFRpbWVTdGF0ZSk7XG4gICAgc2VudHJ5LmNhcHR1cmVNZXNzYWdlKCdNZXRhTWFzayAtIEVtcHR5IHZhdWx0IGZvdW5kIC0gdW5hYmxlIHRvIHJlY292ZXInKTtcbiAgfVxuXG4gIC8vIHJlcG9ydCBtaWdyYXRpb24gZXJyb3JzIHRvIHNlbnRyeVxuICBtaWdyYXRvci5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgLy8gZ2V0IHZhdWx0IHN0cnVjdHVyZSB3aXRob3V0IHNlY3JldHNcbiAgICBjb25zdCB2YXVsdFN0cnVjdHVyZSA9IGdldE9ialN0cnVjdHVyZSh2ZXJzaW9uZWREYXRhKTtcbiAgICBzZW50cnkuY2FwdHVyZUV4Y2VwdGlvbihlcnIsIHtcbiAgICAgIC8vIFwiZXh0cmFcIiBrZXkgaXMgcmVxdWlyZWQgYnkgU2VudHJ5XG4gICAgICBleHRyYTogeyB2YXVsdFN0cnVjdHVyZSB9LFxuICAgIH0pO1xuICB9KTtcblxuICAvLyBtaWdyYXRlIGRhdGFcbiAgdmVyc2lvbmVkRGF0YSA9IGF3YWl0IG1pZ3JhdG9yLm1pZ3JhdGVEYXRhKHZlcnNpb25lZERhdGEpO1xuICBpZiAoIXZlcnNpb25lZERhdGEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFNYXNrIC0gbWlncmF0b3IgcmV0dXJuZWQgdW5kZWZpbmVkJyk7XG4gIH1cblxuICAvLyB3cml0ZSB0byBkaXNrXG4gIGlmIChsb2NhbFN0b3JlLmlzU3VwcG9ydGVkKSB7XG4gICAgbG9jYWxTdG9yZS5zZXQodmVyc2lvbmVkRGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhyb3cgaW4gc2V0VGltZW91dCBzbyBhcyB0byBub3QgYmxvY2sgYm9vdFxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhTWFzayAtIExvY2Fsc3RvcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gcmV0dXJuIGp1c3QgdGhlIGRhdGFcbiAgcmV0dXJuIHZlcnNpb25lZERhdGEuZGF0YTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgTWV0YU1hc2sgQ29udHJvbGxlciB3aXRoIGFueSBpbml0aWFsIHN0YXRlIGFuZCBkZWZhdWx0IGxhbmd1YWdlLlxuICogQ29uZmlndXJlcyBwbGF0Zm9ybS1zcGVjaWZpYyBlcnJvciByZXBvcnRpbmcgc3RyYXRlZ3kuXG4gKiBTdHJlYW1zIGVtaXR0ZWQgc3RhdGUgdXBkYXRlcyB0byBwbGF0Zm9ybS1zcGVjaWZpYyBzdG9yYWdlIHN0cmF0ZWd5LlxuICogQ3JlYXRlcyBwbGF0Zm9ybSBsaXN0ZW5lcnMgZm9yIG5ldyBEYXBwcy9Db250ZXh0cywgYW5kIHNldHMgdXAgdGhlaXIgZGF0YSBjb25uZWN0aW9ucyB0byB0aGUgY29udHJvbGxlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5pdFN0YXRlIC0gVGhlIGluaXRpYWwgc3RhdGUgdG8gc3RhcnQgdGhlIGNvbnRyb2xsZXIgd2l0aCwgbWF0Y2hlcyB0aGUgc3RhdGUgdGhhdCBpcyBlbWl0dGVkIGZyb20gdGhlIGNvbnRyb2xsZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5pdExhbmdDb2RlIC0gVGhlIHJlZ2lvbiBjb2RlIGZvciB0aGUgbGFuZ3VhZ2UgcHJlZmVycmVkIGJ5IHRoZSBjdXJyZW50IHVzZXIuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gQWZ0ZXIgc2V0dXAgaXMgY29tcGxldGUuXG4gKi9cbmZ1bmN0aW9uIHNldHVwQ29udHJvbGxlcihpbml0U3RhdGUsIGluaXRMYW5nQ29kZSkge1xuICAvL1xuICAvLyBNZXRhTWFzayBDb250cm9sbGVyXG4gIC8vXG5cbiAgY29uc3QgY29udHJvbGxlciA9IG5ldyBNZXRhbWFza0NvbnRyb2xsZXIoe1xuICAgIGluZnVyYVByb2plY3RJZDogcHJvY2Vzcy5lbnYuSU5GVVJBX1BST0pFQ1RfSUQsXG4gICAgLy8gVXNlciBjb25maXJtYXRpb24gY2FsbGJhY2tzOlxuICAgIHNob3dVc2VyQ29uZmlybWF0aW9uOiB0cmlnZ2VyVWksXG4gICAgb3BlblBvcHVwLFxuICAgIC8vIGluaXRpYWwgc3RhdGVcbiAgICBpbml0U3RhdGUsXG4gICAgLy8gaW5pdGlhbCBsb2NhbGUgY29kZVxuICAgIGluaXRMYW5nQ29kZSxcbiAgICAvLyBwbGF0Zm9ybSBzcGVjaWZpYyBhcGlcbiAgICBwbGF0Zm9ybSxcbiAgICBub3RpZmljYXRpb25NYW5hZ2VyLFxuICAgIGV4dGVuc2lvbixcbiAgICBnZXRSZXF1ZXN0QWNjb3VudFRhYklkczogKCkgPT4ge1xuICAgICAgcmV0dXJuIHJlcXVlc3RBY2NvdW50VGFiSWRzO1xuICAgIH0sXG4gICAgZ2V0T3Blbk1ldGFtYXNrVGFic0lkczogKCkgPT4ge1xuICAgICAgcmV0dXJuIG9wZW5NZXRhbWFza1RhYnNJRHM7XG4gICAgfSxcbiAgfSk7XG5cbiAgc2V0dXBFbnNJcGZzUmVzb2x2ZXIoe1xuICAgIGdldEN1cnJlbnRDaGFpbklkOiBjb250cm9sbGVyLm5ldHdvcmtDb250cm9sbGVyLmdldEN1cnJlbnRDaGFpbklkLmJpbmQoXG4gICAgICBjb250cm9sbGVyLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICksXG4gICAgZ2V0SXBmc0dhdGV3YXk6IGNvbnRyb2xsZXIucHJlZmVyZW5jZXNDb250cm9sbGVyLmdldElwZnNHYXRld2F5LmJpbmQoXG4gICAgICBjb250cm9sbGVyLnByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICApLFxuICAgIHByb3ZpZGVyOiBjb250cm9sbGVyLnByb3ZpZGVyLFxuICB9KTtcblxuICAvLyBzZXR1cCBzdGF0ZSBwZXJzaXN0ZW5jZVxuICBwdW1wKFxuICAgIHN0b3JlQXNTdHJlYW0oY29udHJvbGxlci5zdG9yZSksXG4gICAgZGVib3VuY2UoMTAwMCksXG4gICAgc3RvcmVUcmFuc2Zvcm1TdHJlYW0odmVyc2lvbmlmeURhdGEpLFxuICAgIGNyZWF0ZVN0cmVhbVNpbmsocGVyc2lzdERhdGEpLFxuICAgIChlcnJvcikgPT4ge1xuICAgICAgbG9nLmVycm9yKCdNZXRhTWFzayAtIFBlcnNpc3RlbmNlIHBpcGVsaW5lIGZhaWxlZCcsIGVycm9yKTtcbiAgICB9LFxuICApO1xuXG4gIC8qKlxuICAgKiBBc3NpZ25zIHRoZSBnaXZlbiBzdGF0ZSB0byB0aGUgdmVyc2lvbmVkIG9iamVjdCAod2l0aCBtZXRhZGF0YSksIGFuZCByZXR1cm5zIHRoYXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSAtIFRoZSBzdGF0ZSBvYmplY3QgYXMgZW1pdHRlZCBieSB0aGUgTWV0YU1hc2tDb250cm9sbGVyLlxuICAgKiBAcmV0dXJucyB7VmVyc2lvbmVkRGF0YX0gVGhlIHN0YXRlIG9iamVjdCB3cmFwcGVkIGluIGFuIG9iamVjdCB0aGF0IGluY2x1ZGVzIGEgbWV0YWRhdGEga2V5LlxuICAgKi9cbiAgZnVuY3Rpb24gdmVyc2lvbmlmeURhdGEoc3RhdGUpIHtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBzdGF0ZTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfVxuXG4gIGxldCBkYXRhUGVyc2lzdGVuY2VGYWlsaW5nID0gZmFsc2U7XG5cbiAgYXN5bmMgZnVuY3Rpb24gcGVyc2lzdERhdGEoc3RhdGUpIHtcbiAgICBpZiAoIXN0YXRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFNYXNrIC0gdXBkYXRlZCBzdGF0ZSBpcyBtaXNzaW5nJyk7XG4gICAgfVxuICAgIGlmICghc3RhdGUuZGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhTWFzayAtIHVwZGF0ZWQgc3RhdGUgZG9lcyBub3QgaGF2ZSBkYXRhJyk7XG4gICAgfVxuICAgIGlmIChsb2NhbFN0b3JlLmlzU3VwcG9ydGVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBsb2NhbFN0b3JlLnNldChzdGF0ZSk7XG4gICAgICAgIGlmIChkYXRhUGVyc2lzdGVuY2VGYWlsaW5nKSB7XG4gICAgICAgICAgZGF0YVBlcnNpc3RlbmNlRmFpbGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gbG9nIGVycm9yIHNvIHdlIGRvbnQgYnJlYWsgdGhlIHBpcGVsaW5lXG4gICAgICAgIGlmICghZGF0YVBlcnNpc3RlbmNlRmFpbGluZykge1xuICAgICAgICAgIGRhdGFQZXJzaXN0ZW5jZUZhaWxpbmcgPSB0cnVlO1xuICAgICAgICAgIGNhcHR1cmVFeGNlcHRpb24oZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBsb2cuZXJyb3IoJ2Vycm9yIHNldHRpbmcgc3RhdGUgaW4gbG9jYWwgc3RvcmU6JywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvL1xuICAvLyBjb25uZWN0IHRvIG90aGVyIGNvbnRleHRzXG4gIC8vXG4gIGV4dGVuc2lvbi5ydW50aW1lLm9uQ29ubmVjdC5hZGRMaXN0ZW5lcihjb25uZWN0UmVtb3RlKTtcbiAgZXh0ZW5zaW9uLnJ1bnRpbWUub25Db25uZWN0RXh0ZXJuYWwuYWRkTGlzdGVuZXIoY29ubmVjdEV4dGVybmFsKTtcblxuICBjb25zdCBtZXRhbWFza0ludGVybmFsUHJvY2Vzc0hhc2ggPSB7XG4gICAgW0VOVklST05NRU5UX1RZUEVfUE9QVVBdOiB0cnVlLFxuICAgIFtFTlZJUk9OTUVOVF9UWVBFX05PVElGSUNBVElPTl06IHRydWUsXG4gICAgW0VOVklST05NRU5UX1RZUEVfRlVMTFNDUkVFTl06IHRydWUsXG4gIH07XG5cbiAgY29uc3QgbWV0YW1hc2tCbG9ja2VkUG9ydHMgPSBbJ3RyZXpvci1jb25uZWN0J107XG5cbiAgY29uc3QgaXNDbGllbnRPcGVuU3RhdHVzID0gKCkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICBwb3B1cElzT3BlbiB8fFxuICAgICAgQm9vbGVhbihPYmplY3Qua2V5cyhvcGVuTWV0YW1hc2tUYWJzSURzKS5sZW5ndGgpIHx8XG4gICAgICBub3RpZmljYXRpb25Jc09wZW5cbiAgICApO1xuICB9O1xuXG4gIGNvbnN0IG9uQ2xvc2VFbnZpcm9ubWVudEluc3RhbmNlcyA9IChpc0NsaWVudE9wZW4sIGVudmlyb25tZW50VHlwZSkgPT4ge1xuICAgIC8vIGlmIGFsbCBpbnN0YW5jZXMgb2YgbWV0YW1hc2sgYXJlIGNsb3NlZCB3ZSBjYWxsIGEgbWV0aG9kIG9uIHRoZSBjb250cm9sbGVyIHRvIHN0b3AgZ2FzRmVlQ29udHJvbGxlciBwb2xsaW5nXG4gICAgaWYgKGlzQ2xpZW50T3BlbiA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnRyb2xsZXIub25DbGllbnRDbG9zZWQoKTtcbiAgICAgIC8vIG90aGVyd2lzZSB3ZSB3YW50IHRvIG9ubHkgcmVtb3ZlIHRoZSBwb2xsaW5nIHRva2VucyBmb3IgdGhlIGVudmlyb25tZW50IHR5cGUgdGhhdCBoYXMgY2xvc2VkXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluIHRoZSBjYXNlIG9mIGZ1bGxzY3JlZW4gZW52aXJvbm1lbnQgYSB1c2VyIG1pZ2h0IGhhdmUgbXVsdGlwbGUgdGFicyBvcGVuIHNvIHdlIGRvbid0IHdhbnQgdG8gZGlzY29ubmVjdCBhbGwgb2ZcbiAgICAgIC8vIGl0cyBjb3JyZXNwb25kaW5nIHBvbGxpbmcgdG9rZW5zIHVubGVzcyBhbGwgdGFicyBhcmUgY2xvc2VkLlxuICAgICAgaWYgKFxuICAgICAgICBlbnZpcm9ubWVudFR5cGUgPT09IEVOVklST05NRU5UX1RZUEVfRlVMTFNDUkVFTiAmJlxuICAgICAgICBCb29sZWFuKE9iamVjdC5rZXlzKG9wZW5NZXRhbWFza1RhYnNJRHMpLmxlbmd0aClcbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb250cm9sbGVyLm9uRW52aXJvbm1lbnRUeXBlQ2xvc2VkKGVudmlyb25tZW50VHlwZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBIHJ1bnRpbWUuUG9ydCBvYmplY3QsIGFzIHByb3ZpZGVkIGJ5IHRoZSBicm93c2VyOlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL0FkZC1vbnMvV2ViRXh0ZW5zaW9ucy9BUEkvcnVudGltZS9Qb3J0XG4gICAqIEB0eXBlZGVmIFBvcnRcbiAgICogQHR5cGUgT2JqZWN0XG4gICAqL1xuXG4gIC8qKlxuICAgKiBDb25uZWN0cyBhIFBvcnQgdG8gdGhlIE1ldGFNYXNrIGNvbnRyb2xsZXIgdmlhIGEgbXVsdGlwbGV4ZWQgZHVwbGV4IHN0cmVhbS5cbiAgICogVGhpcyBtZXRob2QgaWRlbnRpZmllcyB0cnVzdGVkIChNZXRhTWFzaykgaW50ZXJmYWNlcywgYW5kIGNvbm5lY3RzIHRoZW0gZGlmZmVyZW50bHkgZnJvbSB1bnRydXN0ZWQgKHdlYiBwYWdlcykuXG4gICAqXG4gICAqIEBwYXJhbSB7UG9ydH0gcmVtb3RlUG9ydCAtIFRoZSBwb3J0IHByb3ZpZGVkIGJ5IGEgbmV3IGNvbnRleHQuXG4gICAqL1xuICBmdW5jdGlvbiBjb25uZWN0UmVtb3RlKHJlbW90ZVBvcnQpIHtcbiAgICBjb25zdCBwcm9jZXNzTmFtZSA9IHJlbW90ZVBvcnQubmFtZTtcbiAgICBjb25zdCBpc01ldGFNYXNrSW50ZXJuYWxQcm9jZXNzID0gbWV0YW1hc2tJbnRlcm5hbFByb2Nlc3NIYXNoW3Byb2Nlc3NOYW1lXTtcblxuICAgIGlmIChtZXRhbWFza0Jsb2NrZWRQb3J0cy5pbmNsdWRlcyhyZW1vdGVQb3J0Lm5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzTWV0YU1hc2tJbnRlcm5hbFByb2Nlc3MpIHtcbiAgICAgIGNvbnN0IHBvcnRTdHJlYW0gPSBuZXcgUG9ydFN0cmVhbShyZW1vdGVQb3J0KTtcbiAgICAgIC8vIGNvbW11bmljYXRpb24gd2l0aCBwb3B1cFxuICAgICAgY29udHJvbGxlci5pc0NsaWVudE9wZW4gPSB0cnVlO1xuICAgICAgY29udHJvbGxlci5zZXR1cFRydXN0ZWRDb21tdW5pY2F0aW9uKHBvcnRTdHJlYW0sIHJlbW90ZVBvcnQuc2VuZGVyKTtcblxuICAgICAgaWYgKHByb2Nlc3NOYW1lID09PSBFTlZJUk9OTUVOVF9UWVBFX1BPUFVQKSB7XG4gICAgICAgIHBvcHVwSXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgZW5kT2ZTdHJlYW0ocG9ydFN0cmVhbSwgKCkgPT4ge1xuICAgICAgICAgIHBvcHVwSXNPcGVuID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgaXNDbGllbnRPcGVuID0gaXNDbGllbnRPcGVuU3RhdHVzKCk7XG4gICAgICAgICAgY29udHJvbGxlci5pc0NsaWVudE9wZW4gPSBpc0NsaWVudE9wZW47XG4gICAgICAgICAgb25DbG9zZUVudmlyb25tZW50SW5zdGFuY2VzKGlzQ2xpZW50T3BlbiwgRU5WSVJPTk1FTlRfVFlQRV9QT1BVUCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzc05hbWUgPT09IEVOVklST05NRU5UX1RZUEVfTk9USUZJQ0FUSU9OKSB7XG4gICAgICAgIG5vdGlmaWNhdGlvbklzT3BlbiA9IHRydWU7XG5cbiAgICAgICAgZW5kT2ZTdHJlYW0ocG9ydFN0cmVhbSwgKCkgPT4ge1xuICAgICAgICAgIG5vdGlmaWNhdGlvbklzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IGlzQ2xpZW50T3BlbiA9IGlzQ2xpZW50T3BlblN0YXR1cygpO1xuICAgICAgICAgIGNvbnRyb2xsZXIuaXNDbGllbnRPcGVuID0gaXNDbGllbnRPcGVuO1xuICAgICAgICAgIG9uQ2xvc2VFbnZpcm9ubWVudEluc3RhbmNlcyhcbiAgICAgICAgICAgIGlzQ2xpZW50T3BlbixcbiAgICAgICAgICAgIEVOVklST05NRU5UX1RZUEVfTk9USUZJQ0FUSU9OLFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzc05hbWUgPT09IEVOVklST05NRU5UX1RZUEVfRlVMTFNDUkVFTikge1xuICAgICAgICBjb25zdCB0YWJJZCA9IHJlbW90ZVBvcnQuc2VuZGVyLnRhYi5pZDtcbiAgICAgICAgb3Blbk1ldGFtYXNrVGFic0lEc1t0YWJJZF0gPSB0cnVlO1xuXG4gICAgICAgIGVuZE9mU3RyZWFtKHBvcnRTdHJlYW0sICgpID0+IHtcbiAgICAgICAgICBkZWxldGUgb3Blbk1ldGFtYXNrVGFic0lEc1t0YWJJZF07XG4gICAgICAgICAgY29uc3QgaXNDbGllbnRPcGVuID0gaXNDbGllbnRPcGVuU3RhdHVzKCk7XG4gICAgICAgICAgY29udHJvbGxlci5pc0NsaWVudE9wZW4gPSBpc0NsaWVudE9wZW47XG4gICAgICAgICAgb25DbG9zZUVudmlyb25tZW50SW5zdGFuY2VzKFxuICAgICAgICAgICAgaXNDbGllbnRPcGVuLFxuICAgICAgICAgICAgRU5WSVJPTk1FTlRfVFlQRV9GVUxMU0NSRUVOLFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVtb3RlUG9ydC5zZW5kZXIgJiYgcmVtb3RlUG9ydC5zZW5kZXIudGFiICYmIHJlbW90ZVBvcnQuc2VuZGVyLnVybCkge1xuICAgICAgICBjb25zdCB0YWJJZCA9IHJlbW90ZVBvcnQuc2VuZGVyLnRhYi5pZDtcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChyZW1vdGVQb3J0LnNlbmRlci51cmwpO1xuICAgICAgICBjb25zdCB7IG9yaWdpbiB9ID0gdXJsO1xuXG4gICAgICAgIHJlbW90ZVBvcnQub25NZXNzYWdlLmFkZExpc3RlbmVyKChtc2cpID0+IHtcbiAgICAgICAgICBpZiAobXNnLmRhdGEgJiYgbXNnLmRhdGEubWV0aG9kID09PSAnZXRoX3JlcXVlc3RBY2NvdW50cycpIHtcbiAgICAgICAgICAgIHJlcXVlc3RBY2NvdW50VGFiSWRzW29yaWdpbl0gPSB0YWJJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29ubmVjdEV4dGVybmFsKHJlbW90ZVBvcnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNvbW11bmljYXRpb24gd2l0aCBwYWdlIG9yIG90aGVyIGV4dGVuc2lvblxuICBmdW5jdGlvbiBjb25uZWN0RXh0ZXJuYWwocmVtb3RlUG9ydCkge1xuICAgIGNvbnN0IHBvcnRTdHJlYW0gPSBuZXcgUG9ydFN0cmVhbShyZW1vdGVQb3J0KTtcbiAgICBjb250cm9sbGVyLnNldHVwVW50cnVzdGVkQ29tbXVuaWNhdGlvbih7XG4gICAgICBjb25uZWN0aW9uU3RyZWFtOiBwb3J0U3RyZWFtLFxuICAgICAgc2VuZGVyOiByZW1vdGVQb3J0LnNlbmRlcixcbiAgICB9KTtcbiAgfVxuXG4gIC8vXG4gIC8vIFVzZXIgSW50ZXJmYWNlIHNldHVwXG4gIC8vXG5cbiAgdXBkYXRlQmFkZ2UoKTtcbiAgY29udHJvbGxlci50eENvbnRyb2xsZXIub24oXG4gICAgTUVUQU1BU0tfQ09OVFJPTExFUl9FVkVOVFMuVVBEQVRFX0JBREdFLFxuICAgIHVwZGF0ZUJhZGdlLFxuICApO1xuICBjb250cm9sbGVyLm1lc3NhZ2VNYW5hZ2VyLm9uKFxuICAgIE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTLlVQREFURV9CQURHRSxcbiAgICB1cGRhdGVCYWRnZSxcbiAgKTtcbiAgY29udHJvbGxlci5wZXJzb25hbE1lc3NhZ2VNYW5hZ2VyLm9uKFxuICAgIE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTLlVQREFURV9CQURHRSxcbiAgICB1cGRhdGVCYWRnZSxcbiAgKTtcbiAgY29udHJvbGxlci5kZWNyeXB0TWVzc2FnZU1hbmFnZXIub24oXG4gICAgTUVUQU1BU0tfQ09OVFJPTExFUl9FVkVOVFMuVVBEQVRFX0JBREdFLFxuICAgIHVwZGF0ZUJhZGdlLFxuICApO1xuICBjb250cm9sbGVyLmVuY3J5cHRpb25QdWJsaWNLZXlNYW5hZ2VyLm9uKFxuICAgIE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTLlVQREFURV9CQURHRSxcbiAgICB1cGRhdGVCYWRnZSxcbiAgKTtcbiAgY29udHJvbGxlci50eXBlZE1lc3NhZ2VNYW5hZ2VyLm9uKFxuICAgIE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTLlVQREFURV9CQURHRSxcbiAgICB1cGRhdGVCYWRnZSxcbiAgKTtcbiAgY29udHJvbGxlci5hcHBTdGF0ZUNvbnRyb2xsZXIub24oXG4gICAgTUVUQU1BU0tfQ09OVFJPTExFUl9FVkVOVFMuVVBEQVRFX0JBREdFLFxuICAgIHVwZGF0ZUJhZGdlLFxuICApO1xuXG4gIGNvbnRyb2xsZXIuY29udHJvbGxlck1lc3Nlbmdlci5zdWJzY3JpYmUoXG4gICAgTUVUQU1BU0tfQ09OVFJPTExFUl9FVkVOVFMuQVBQUk9WQUxfU1RBVEVfQ0hBTkdFLFxuICAgIHVwZGF0ZUJhZGdlLFxuICApO1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBXZWIgRXh0ZW5zaW9uJ3MgXCJiYWRnZVwiIG51bWJlciwgb24gdGhlIGxpdHRsZSBmb3ggaW4gdGhlIHRvb2xiYXIuXG4gICAqIFRoZSBudW1iZXIgcmVmbGVjdHMgdGhlIGN1cnJlbnQgbnVtYmVyIG9mIHBlbmRpbmcgdHJhbnNhY3Rpb25zIG9yIG1lc3NhZ2Ugc2lnbmF0dXJlcyBuZWVkaW5nIHVzZXIgYXBwcm92YWwuXG4gICAqL1xuICBmdW5jdGlvbiB1cGRhdGVCYWRnZSgpIHtcbiAgICBsZXQgbGFiZWwgPSAnJztcbiAgICBjb25zdCBjb3VudCA9IGdldFVuYXBwcm92ZWRUcmFuc2FjdGlvbkNvdW50KCk7XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBsYWJlbCA9IFN0cmluZyhjb3VudCk7XG4gICAgfVxuICAgIGV4dGVuc2lvbi5icm93c2VyQWN0aW9uLnNldEJhZGdlVGV4dCh7IHRleHQ6IGxhYmVsIH0pO1xuICAgIGV4dGVuc2lvbi5icm93c2VyQWN0aW9uLnNldEJhZGdlQmFja2dyb3VuZENvbG9yKHsgY29sb3I6ICcjMDM3REQ2JyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFVuYXBwcm92ZWRUcmFuc2FjdGlvbkNvdW50KCkge1xuICAgIGNvbnN0IHVuYXBwcm92ZWRUeENvdW50ID0gY29udHJvbGxlci50eENvbnRyb2xsZXIuZ2V0VW5hcHByb3ZlZFR4Q291bnQoKTtcbiAgICBjb25zdCB7IHVuYXBwcm92ZWRNc2dDb3VudCB9ID0gY29udHJvbGxlci5tZXNzYWdlTWFuYWdlcjtcbiAgICBjb25zdCB7IHVuYXBwcm92ZWRQZXJzb25hbE1zZ0NvdW50IH0gPSBjb250cm9sbGVyLnBlcnNvbmFsTWVzc2FnZU1hbmFnZXI7XG4gICAgY29uc3QgeyB1bmFwcHJvdmVkRGVjcnlwdE1zZ0NvdW50IH0gPSBjb250cm9sbGVyLmRlY3J5cHRNZXNzYWdlTWFuYWdlcjtcbiAgICBjb25zdCB7XG4gICAgICB1bmFwcHJvdmVkRW5jcnlwdGlvblB1YmxpY0tleU1zZ0NvdW50LFxuICAgIH0gPSBjb250cm9sbGVyLmVuY3J5cHRpb25QdWJsaWNLZXlNYW5hZ2VyO1xuICAgIGNvbnN0IHsgdW5hcHByb3ZlZFR5cGVkTWVzc2FnZXNDb3VudCB9ID0gY29udHJvbGxlci50eXBlZE1lc3NhZ2VNYW5hZ2VyO1xuICAgIGNvbnN0IHBlbmRpbmdBcHByb3ZhbENvdW50ID0gY29udHJvbGxlci5hcHByb3ZhbENvbnRyb2xsZXIuZ2V0VG90YWxBcHByb3ZhbENvdW50KCk7XG4gICAgY29uc3Qgd2FpdGluZ0ZvclVubG9ja0NvdW50ID1cbiAgICAgIGNvbnRyb2xsZXIuYXBwU3RhdGVDb250cm9sbGVyLndhaXRpbmdGb3JVbmxvY2subGVuZ3RoO1xuICAgIHJldHVybiAoXG4gICAgICB1bmFwcHJvdmVkVHhDb3VudCArXG4gICAgICB1bmFwcHJvdmVkTXNnQ291bnQgK1xuICAgICAgdW5hcHByb3ZlZFBlcnNvbmFsTXNnQ291bnQgK1xuICAgICAgdW5hcHByb3ZlZERlY3J5cHRNc2dDb3VudCArXG4gICAgICB1bmFwcHJvdmVkRW5jcnlwdGlvblB1YmxpY0tleU1zZ0NvdW50ICtcbiAgICAgIHVuYXBwcm92ZWRUeXBlZE1lc3NhZ2VzQ291bnQgK1xuICAgICAgcGVuZGluZ0FwcHJvdmFsQ291bnQgK1xuICAgICAgd2FpdGluZ0ZvclVubG9ja0NvdW50XG4gICAgKTtcbiAgfVxuXG4gIG5vdGlmaWNhdGlvbk1hbmFnZXIub24oXG4gICAgTk9USUZJQ0FUSU9OX01BTkFHRVJfRVZFTlRTLlBPUFVQX0NMT1NFRCxcbiAgICAoeyBhdXRvbWF0aWNhbGx5Q2xvc2VkIH0pID0+IHtcbiAgICAgIGlmICghYXV0b21hdGljYWxseUNsb3NlZCkge1xuICAgICAgICByZWplY3RVbmFwcHJvdmVkTm90aWZpY2F0aW9ucygpO1xuICAgICAgfSBlbHNlIGlmIChnZXRVbmFwcHJvdmVkVHJhbnNhY3Rpb25Db3VudCgpID4gMCkge1xuICAgICAgICB0cmlnZ2VyVWkoKTtcbiAgICAgIH1cbiAgICB9LFxuICApO1xuXG4gIGZ1bmN0aW9uIHJlamVjdFVuYXBwcm92ZWROb3RpZmljYXRpb25zKCkge1xuICAgIE9iamVjdC5rZXlzKFxuICAgICAgY29udHJvbGxlci50eENvbnRyb2xsZXIudHhTdGF0ZU1hbmFnZXIuZ2V0VW5hcHByb3ZlZFR4TGlzdCgpLFxuICAgICkuZm9yRWFjaCgodHhJZCkgPT5cbiAgICAgIGNvbnRyb2xsZXIudHhDb250cm9sbGVyLnR4U3RhdGVNYW5hZ2VyLnNldFR4U3RhdHVzUmVqZWN0ZWQodHhJZCksXG4gICAgKTtcbiAgICBjb250cm9sbGVyLm1lc3NhZ2VNYW5hZ2VyLm1lc3NhZ2VzXG4gICAgICAuZmlsdGVyKChtc2cpID0+IG1zZy5zdGF0dXMgPT09ICd1bmFwcHJvdmVkJylcbiAgICAgIC5mb3JFYWNoKCh0eCkgPT5cbiAgICAgICAgY29udHJvbGxlci5tZXNzYWdlTWFuYWdlci5yZWplY3RNc2coXG4gICAgICAgICAgdHguaWQsXG4gICAgICAgICAgUkVKRUNUX05PVEZJQ0lBVElPTl9DTE9TRV9TSUcsXG4gICAgICAgICksXG4gICAgICApO1xuICAgIGNvbnRyb2xsZXIucGVyc29uYWxNZXNzYWdlTWFuYWdlci5tZXNzYWdlc1xuICAgICAgLmZpbHRlcigobXNnKSA9PiBtc2cuc3RhdHVzID09PSAndW5hcHByb3ZlZCcpXG4gICAgICAuZm9yRWFjaCgodHgpID0+XG4gICAgICAgIGNvbnRyb2xsZXIucGVyc29uYWxNZXNzYWdlTWFuYWdlci5yZWplY3RNc2coXG4gICAgICAgICAgdHguaWQsXG4gICAgICAgICAgUkVKRUNUX05PVEZJQ0lBVElPTl9DTE9TRV9TSUcsXG4gICAgICAgICksXG4gICAgICApO1xuICAgIGNvbnRyb2xsZXIudHlwZWRNZXNzYWdlTWFuYWdlci5tZXNzYWdlc1xuICAgICAgLmZpbHRlcigobXNnKSA9PiBtc2cuc3RhdHVzID09PSAndW5hcHByb3ZlZCcpXG4gICAgICAuZm9yRWFjaCgodHgpID0+XG4gICAgICAgIGNvbnRyb2xsZXIudHlwZWRNZXNzYWdlTWFuYWdlci5yZWplY3RNc2coXG4gICAgICAgICAgdHguaWQsXG4gICAgICAgICAgUkVKRUNUX05PVEZJQ0lBVElPTl9DTE9TRV9TSUcsXG4gICAgICAgICksXG4gICAgICApO1xuICAgIGNvbnRyb2xsZXIuZGVjcnlwdE1lc3NhZ2VNYW5hZ2VyLm1lc3NhZ2VzXG4gICAgICAuZmlsdGVyKChtc2cpID0+IG1zZy5zdGF0dXMgPT09ICd1bmFwcHJvdmVkJylcbiAgICAgIC5mb3JFYWNoKCh0eCkgPT5cbiAgICAgICAgY29udHJvbGxlci5kZWNyeXB0TWVzc2FnZU1hbmFnZXIucmVqZWN0TXNnKFxuICAgICAgICAgIHR4LmlkLFxuICAgICAgICAgIFJFSkVDVF9OT1RGSUNJQVRJT05fQ0xPU0UsXG4gICAgICAgICksXG4gICAgICApO1xuICAgIGNvbnRyb2xsZXIuZW5jcnlwdGlvblB1YmxpY0tleU1hbmFnZXIubWVzc2FnZXNcbiAgICAgIC5maWx0ZXIoKG1zZykgPT4gbXNnLnN0YXR1cyA9PT0gJ3VuYXBwcm92ZWQnKVxuICAgICAgLmZvckVhY2goKHR4KSA9PlxuICAgICAgICBjb250cm9sbGVyLmVuY3J5cHRpb25QdWJsaWNLZXlNYW5hZ2VyLnJlamVjdE1zZyhcbiAgICAgICAgICB0eC5pZCxcbiAgICAgICAgICBSRUpFQ1RfTk9URklDSUFUSU9OX0NMT1NFLFxuICAgICAgICApLFxuICAgICAgKTtcblxuICAgIC8vIEZpbmFsbHksIHJlamVjdCBhbGwgYXBwcm92YWxzIG1hbmFnZWQgYnkgdGhlIEFwcHJvdmFsQ29udHJvbGxlclxuICAgIGNvbnRyb2xsZXIuYXBwcm92YWxDb250cm9sbGVyLmNsZWFyKFxuICAgICAgZXRoRXJyb3JzLnByb3ZpZGVyLnVzZXJSZWplY3RlZFJlcXVlc3QoKSxcbiAgICApO1xuXG4gICAgdXBkYXRlQmFkZ2UoKTtcbiAgfVxuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbn1cblxuLy9cbi8vIEV0Yy4uLlxuLy9cblxuLyoqXG4gKiBPcGVucyB0aGUgYnJvd3NlciBwb3B1cCBmb3IgdXNlciBjb25maXJtYXRpb25cbiAqL1xuYXN5bmMgZnVuY3Rpb24gdHJpZ2dlclVpKCkge1xuICBjb25zdCB0YWJzID0gYXdhaXQgcGxhdGZvcm0uZ2V0QWN0aXZlVGFicygpO1xuICBjb25zdCBjdXJyZW50bHlBY3RpdmVNZXRhbWFza1RhYiA9IEJvb2xlYW4oXG4gICAgdGFicy5maW5kKCh0YWIpID0+IG9wZW5NZXRhbWFza1RhYnNJRHNbdGFiLmlkXSksXG4gICk7XG4gIC8vIFZpdmFsZGkgaXMgbm90IGNsb3NpbmcgcG9ydCBjb25uZWN0aW9uIG9uIHBvcHVwIGNsb3NlLCBzbyBwb3B1cElzT3BlbiBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseVxuICAvLyBUbyBiZSByZXZpZXdlZCBpbiB0aGUgZnV0dXJlIGlmIHRoaXMgYmVoYXZpb3VyIGlzIGZpeGVkIC0gYWxzbyB0aGUgd2F5IHdlIGRldGVybWluZSBpc1ZpdmFsZGkgdmFyaWFibGUgbWlnaHQgY2hhbmdlIGF0IHNvbWUgcG9pbnRcbiAgY29uc3QgaXNWaXZhbGRpID1cbiAgICB0YWJzLmxlbmd0aCA+IDAgJiZcbiAgICB0YWJzWzBdLmV4dERhdGEgJiZcbiAgICB0YWJzWzBdLmV4dERhdGEuaW5kZXhPZigndml2YWxkaV90YWInKSA+IC0xO1xuICBpZiAoXG4gICAgIXVpSXNUcmlnZ2VyaW5nICYmXG4gICAgKGlzVml2YWxkaSB8fCAhcG9wdXBJc09wZW4pICYmXG4gICAgIWN1cnJlbnRseUFjdGl2ZU1ldGFtYXNrVGFiXG4gICkge1xuICAgIHVpSXNUcmlnZ2VyaW5nID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgbm90aWZpY2F0aW9uTWFuYWdlci5zaG93UG9wdXAoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdWlJc1RyaWdnZXJpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBPcGVucyB0aGUgYnJvd3NlciBwb3B1cCBmb3IgdXNlciBjb25maXJtYXRpb24gb2Ygd2F0Y2hBc3NldFxuICogdGhlbiBpdCB3YWl0cyB1bnRpbCB1c2VyIGludGVyYWN0IHdpdGggdGhlIFVJXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG9wZW5Qb3B1cCgpIHtcbiAgYXdhaXQgdHJpZ2dlclVpKCk7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAoIW5vdGlmaWNhdGlvbklzT3Blbikge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0sIFNFQ09ORCk7XG4gIH0pO1xufVxuXG4vLyBPbiBmaXJzdCBpbnN0YWxsLCBvcGVuIGEgbmV3IHRhYiB3aXRoIE1ldGFNYXNrXG5leHRlbnNpb24ucnVudGltZS5vbkluc3RhbGxlZC5hZGRMaXN0ZW5lcigoeyByZWFzb24gfSkgPT4ge1xuICBpZiAoXG4gICAgcmVhc29uID09PSAnaW5zdGFsbCcgJiZcbiAgICAhKHByb2Nlc3MuZW52Lk1FVEFNQVNLX0RFQlVHIHx8IHByb2Nlc3MuZW52LklOX1RFU1QpXG4gICkge1xuICAgIHBsYXRmb3JtLm9wZW5FeHRlbnNpb25JbkJyb3dzZXIoKTtcbiAgfVxufSk7XG4iXSwicHJlRXhpc3RpbmdDb21tZW50IjoiLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmlzaWJpbGl0eUNoYW5nZUVtaXR0ZXIuanMubWFwIn0=
