LavaPack.loadBundle([
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\luxon\\build\\cjs-browser\\luxon.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\luxon\build\cjs-browser\luxon.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o) {
  var i = 0;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  i = o[Symbol.iterator]();
  return i.next.bind(i);
}

// these aren't really private, but nor are they really useful to document

/**
 * @private
 */
var LuxonError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(LuxonError, _Error);

  function LuxonError() {
    return _Error.apply(this, arguments) || this;
  }

  return LuxonError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * @private
 */


var InvalidDateTimeError = /*#__PURE__*/function (_LuxonError) {
  _inheritsLoose(InvalidDateTimeError, _LuxonError);

  function InvalidDateTimeError(reason) {
    return _LuxonError.call(this, "Invalid DateTime: " + reason.toMessage()) || this;
  }

  return InvalidDateTimeError;
}(LuxonError);
/**
 * @private
 */

var InvalidIntervalError = /*#__PURE__*/function (_LuxonError2) {
  _inheritsLoose(InvalidIntervalError, _LuxonError2);

  function InvalidIntervalError(reason) {
    return _LuxonError2.call(this, "Invalid Interval: " + reason.toMessage()) || this;
  }

  return InvalidIntervalError;
}(LuxonError);
/**
 * @private
 */

var InvalidDurationError = /*#__PURE__*/function (_LuxonError3) {
  _inheritsLoose(InvalidDurationError, _LuxonError3);

  function InvalidDurationError(reason) {
    return _LuxonError3.call(this, "Invalid Duration: " + reason.toMessage()) || this;
  }

  return InvalidDurationError;
}(LuxonError);
/**
 * @private
 */

var ConflictingSpecificationError = /*#__PURE__*/function (_LuxonError4) {
  _inheritsLoose(ConflictingSpecificationError, _LuxonError4);

  function ConflictingSpecificationError() {
    return _LuxonError4.apply(this, arguments) || this;
  }

  return ConflictingSpecificationError;
}(LuxonError);
/**
 * @private
 */

var InvalidUnitError = /*#__PURE__*/function (_LuxonError5) {
  _inheritsLoose(InvalidUnitError, _LuxonError5);

  function InvalidUnitError(unit) {
    return _LuxonError5.call(this, "Invalid unit " + unit) || this;
  }

  return InvalidUnitError;
}(LuxonError);
/**
 * @private
 */

var InvalidArgumentError = /*#__PURE__*/function (_LuxonError6) {
  _inheritsLoose(InvalidArgumentError, _LuxonError6);

  function InvalidArgumentError() {
    return _LuxonError6.apply(this, arguments) || this;
  }

  return InvalidArgumentError;
}(LuxonError);
/**
 * @private
 */

var ZoneIsAbstractError = /*#__PURE__*/function (_LuxonError7) {
  _inheritsLoose(ZoneIsAbstractError, _LuxonError7);

  function ZoneIsAbstractError() {
    return _LuxonError7.call(this, "Zone is an abstract class") || this;
  }

  return ZoneIsAbstractError;
}(LuxonError);

/**
 * @private
 */
var n = "numeric",
    s = "short",
    l = "long";
var DATE_SHORT = {
  year: n,
  month: n,
  day: n
};
var DATE_MED = {
  year: n,
  month: s,
  day: n
};
var DATE_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s
};
var DATE_FULL = {
  year: n,
  month: l,
  day: n
};
var DATE_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l
};
var TIME_SIMPLE = {
  hour: n,
  minute: n
};
var TIME_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n
};
var TIME_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
var TIME_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};
var TIME_24_SIMPLE = {
  hour: n,
  minute: n,
  hour12: false
};
/**
 * {@link toLocaleString}; format like '09:30:23', always 24-hour.
 */

var TIME_24_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
  hour12: false
};
/**
 * {@link toLocaleString}; format like '09:30:23 EDT', always 24-hour.
 */

var TIME_24_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hour12: false,
  timeZoneName: s
};
/**
 * {@link toLocaleString}; format like '09:30:23 Eastern Daylight Time', always 24-hour.
 */

var TIME_24_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hour12: false,
  timeZoneName: l
};
/**
 * {@link toLocaleString}; format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
 */

var DATETIME_SHORT = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n
};
/**
 * {@link toLocaleString}; format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
 */

var DATETIME_SHORT_WITH_SECONDS = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n
};
var DATETIME_MED_WITH_SECONDS = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
  hour: n,
  minute: n
};
var DATETIME_FULL = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  timeZoneName: s
};
var DATETIME_FULL_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
var DATETIME_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  timeZoneName: l
};
var DATETIME_HUGE_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};

/*
  This is just a junk drawer, containing anything used across multiple classes.
  Because Luxon is small(ish), this should stay small and we won't worry about splitting
  it up into, say, parsingUtil.js and basicUtil.js and so on. But they are divided up by feature area.
*/
/**
 * @private
 */
// TYPES

function isUndefined(o) {
  return typeof o === "undefined";
}
function isNumber(o) {
  return typeof o === "number";
}
function isInteger(o) {
  return typeof o === "number" && o % 1 === 0;
}
function isString(o) {
  return typeof o === "string";
}
function isDate(o) {
  return Object.prototype.toString.call(o) === "[object Date]";
} // CAPABILITIES

function hasIntl() {
  try {
    return typeof Intl !== "undefined" && Intl.DateTimeFormat;
  } catch (e) {
    return false;
  }
}
function hasFormatToParts() {
  return !isUndefined(Intl.DateTimeFormat.prototype.formatToParts);
}
function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e) {
    return false;
  }
} // OBJECTS AND ARRAYS

function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return undefined;
  }

  return arr.reduce(function (best, next) {
    var pair = [by(next), next];

    if (!best) {
      return pair;
    } else if (compare(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}
function pick(obj, keys) {
  return keys.reduce(function (a, k) {
    a[k] = obj[k];
    return a;
  }, {});
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
} // NUMBERS AND STRINGS

function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
} // x % n but takes the sign of n instead of x

function floorMod(x, n) {
  return x - n * Math.floor(x / n);
}
function padStart(input, n) {
  if (n === void 0) {
    n = 2;
  }

  var minus = input < 0 ? "-" : "";
  var target = minus ? input * -1 : input;
  var result;

  if (target.toString().length < n) {
    result = ("0".repeat(n) + target).slice(-n);
  } else {
    result = target.toString();
  }

  return "" + minus + result;
}
function parseInteger(string) {
  if (isUndefined(string) || string === null || string === "") {
    return undefined;
  } else {
    return parseInt(string, 10);
  }
}
function parseMillis(fraction) {
  // Return undefined (instead of 0) in these cases, where fraction is not set
  if (isUndefined(fraction) || fraction === null || fraction === "") {
    return undefined;
  } else {
    var f = parseFloat("0." + fraction) * 1000;
    return Math.floor(f);
  }
}
function roundTo(number, digits, towardZero) {
  if (towardZero === void 0) {
    towardZero = false;
  }

  var factor = Math.pow(10, digits),
      rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number * factor) / factor;
} // DATE BASICS

function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function daysInMonth(year, month) {
  var modMonth = floorMod(month - 1, 12) + 1,
      modYear = year + (month - modMonth) / 12;

  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
} // covert a calendar object to a local timestamp (epoch, but with the offset baked in)

function objToLocalTS(obj) {
  var d = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond); // for legacy reasons, years between 0 and 99 are interpreted as 19XX; revert that

  if (obj.year < 100 && obj.year >= 0) {
    d = new Date(d);
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }

  return +d;
}
function weeksInWeekYear(weekYear) {
  var p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7,
      last = weekYear - 1,
      p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
  return p1 === 4 || p2 === 3 ? 53 : 52;
}
function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else return year > 60 ? 1900 + year : 2000 + year;
} // PARSING

function parseZoneInfo(ts, offsetFormat, locale, timeZone) {
  if (timeZone === void 0) {
    timeZone = null;
  }

  var date = new Date(ts),
      intlOpts = {
    hour12: false,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };

  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }

  var modified = Object.assign({
    timeZoneName: offsetFormat
  }, intlOpts),
      intl = hasIntl();

  if (intl && hasFormatToParts()) {
    var parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find(function (m) {
      return m.type.toLowerCase() === "timezonename";
    });
    return parsed ? parsed.value : null;
  } else if (intl) {
    // this probably doesn't work for all locales
    var without = new Intl.DateTimeFormat(locale, intlOpts).format(date),
        included = new Intl.DateTimeFormat(locale, modified).format(date),
        diffed = included.substring(without.length),
        trimmed = diffed.replace(/^[, \u200e]+/, "");
    return trimmed;
  } else {
    return null;
  }
} // signedOffset('-5', '30') -> -330

function signedOffset(offHourStr, offMinuteStr) {
  var offHour = parseInt(offHourStr, 10); // don't || this because we want to preserve -0

  if (Number.isNaN(offHour)) {
    offHour = 0;
  }

  var offMin = parseInt(offMinuteStr, 10) || 0,
      offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
} // COERCION

function asNumber(value) {
  var numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue)) throw new InvalidArgumentError("Invalid unit value " + value);
  return numericValue;
}
function normalizeObject(obj, normalizer, nonUnitKeys) {
  var normalized = {};

  for (var u in obj) {
    if (hasOwnProperty(obj, u)) {
      if (nonUnitKeys.indexOf(u) >= 0) continue;
      var v = obj[u];
      if (v === undefined || v === null) continue;
      normalized[normalizer(u)] = asNumber(v);
    }
  }

  return normalized;
}
function formatOffset(offset, format) {
  var hours = Math.trunc(Math.abs(offset / 60)),
      minutes = Math.trunc(Math.abs(offset % 60)),
      sign = offset >= 0 ? "+" : "-";

  switch (format) {
    case "short":
      return "" + sign + padStart(hours, 2) + ":" + padStart(minutes, 2);

    case "narrow":
      return "" + sign + hours + (minutes > 0 ? ":" + minutes : "");

    case "techie":
      return "" + sign + padStart(hours, 2) + padStart(minutes, 2);

    default:
      throw new RangeError("Value format " + format + " is out of range for property format");
  }
}
function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}
var ianaRegex = /[A-Za-z_+-]{1,256}(:?\/[A-Za-z_+-]{1,256}(\/[A-Za-z_+-]{1,256})?)?/;

function stringify(obj) {
  return JSON.stringify(obj, Object.keys(obj).sort());
}
/**
 * @private
 */


var monthsLong = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
var monthsShort = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(length) {
  switch (length) {
    case "narrow":
      return monthsNarrow;

    case "short":
      return monthsShort;

    case "long":
      return monthsLong;

    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];

    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];

    default:
      return null;
  }
}
var weekdaysLong = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length) {
  switch (length) {
    case "narrow":
      return weekdaysNarrow;

    case "short":
      return weekdaysShort;

    case "long":
      return weekdaysLong;

    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];

    default:
      return null;
  }
}
var meridiems = ["AM", "PM"];
var erasLong = ["Before Christ", "Anno Domini"];
var erasShort = ["BC", "AD"];
var erasNarrow = ["B", "A"];
function eras(length) {
  switch (length) {
    case "narrow":
      return erasNarrow;

    case "short":
      return erasShort;

    case "long":
      return erasLong;

    default:
      return null;
  }
}
function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length) {
  return weekdays(length)[dt.weekday - 1];
}
function monthForDateTime(dt, length) {
  return months(length)[dt.month - 1];
}
function eraForDateTime(dt, length) {
  return eras(length)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit, count, numeric, narrow) {
  if (numeric === void 0) {
    numeric = "always";
  }

  if (narrow === void 0) {
    narrow = false;
  }

  var units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  };
  var lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;

  if (numeric === "auto" && lastable) {
    var isDay = unit === "days";

    switch (count) {
      case 1:
        return isDay ? "tomorrow" : "next " + units[unit][0];

      case -1:
        return isDay ? "yesterday" : "last " + units[unit][0];

      case 0:
        return isDay ? "today" : "this " + units[unit][0];

    }
  }

  var isInPast = Object.is(count, -0) || count < 0,
      fmtValue = Math.abs(count),
      singular = fmtValue === 1,
      lilUnits = units[unit],
      fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
  return isInPast ? fmtValue + " " + fmtUnit + " ago" : "in " + fmtValue + " " + fmtUnit;
}
function formatString(knownFormat) {
  // these all have the offsets removed because we don't have access to them
  // without all the intl stuff this is backfilling
  var filtered = pick(knownFormat, ["weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "hour12"]),
      key = stringify(filtered),
      dateTimeHuge = "EEEE, LLLL d, yyyy, h:mm a";

  switch (key) {
    case stringify(DATE_SHORT):
      return "M/d/yyyy";

    case stringify(DATE_MED):
      return "LLL d, yyyy";

    case stringify(DATE_MED_WITH_WEEKDAY):
      return "EEE, LLL d, yyyy";

    case stringify(DATE_FULL):
      return "LLLL d, yyyy";

    case stringify(DATE_HUGE):
      return "EEEE, LLLL d, yyyy";

    case stringify(TIME_SIMPLE):
      return "h:mm a";

    case stringify(TIME_WITH_SECONDS):
      return "h:mm:ss a";

    case stringify(TIME_WITH_SHORT_OFFSET):
      return "h:mm a";

    case stringify(TIME_WITH_LONG_OFFSET):
      return "h:mm a";

    case stringify(TIME_24_SIMPLE):
      return "HH:mm";

    case stringify(TIME_24_WITH_SECONDS):
      return "HH:mm:ss";

    case stringify(TIME_24_WITH_SHORT_OFFSET):
      return "HH:mm";

    case stringify(TIME_24_WITH_LONG_OFFSET):
      return "HH:mm";

    case stringify(DATETIME_SHORT):
      return "M/d/yyyy, h:mm a";

    case stringify(DATETIME_MED):
      return "LLL d, yyyy, h:mm a";

    case stringify(DATETIME_FULL):
      return "LLLL d, yyyy, h:mm a";

    case stringify(DATETIME_HUGE):
      return dateTimeHuge;

    case stringify(DATETIME_SHORT_WITH_SECONDS):
      return "M/d/yyyy, h:mm:ss a";

    case stringify(DATETIME_MED_WITH_SECONDS):
      return "LLL d, yyyy, h:mm:ss a";

    case stringify(DATETIME_MED_WITH_WEEKDAY):
      return "EEE, d LLL yyyy, h:mm a";

    case stringify(DATETIME_FULL_WITH_SECONDS):
      return "LLLL d, yyyy, h:mm:ss a";

    case stringify(DATETIME_HUGE_WITH_SECONDS):
      return "EEEE, LLLL d, yyyy, h:mm:ss a";

    default:
      return dateTimeHuge;
  }
}

function stringifyTokens(splits, tokenToString) {
  var s = "";

  for (var _iterator = _createForOfIteratorHelperLoose(splits), _step; !(_step = _iterator()).done;) {
    var token = _step.value;

    if (token.literal) {
      s += token.val;
    } else {
      s += tokenToString(token.val);
    }
  }

  return s;
}

var _macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};
/**
 * @private
 */

var Formatter = /*#__PURE__*/function () {
  Formatter.create = function create(locale, opts) {
    if (opts === void 0) {
      opts = {};
    }

    return new Formatter(locale, opts);
  };

  Formatter.parseFormat = function parseFormat(fmt) {
    var current = null,
        currentFull = "",
        bracketed = false;
    var splits = [];

    for (var i = 0; i < fmt.length; i++) {
      var c = fmt.charAt(i);

      if (c === "'") {
        if (currentFull.length > 0) {
          splits.push({
            literal: bracketed,
            val: currentFull
          });
        }

        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c;
      } else if (c === current) {
        currentFull += c;
      } else {
        if (currentFull.length > 0) {
          splits.push({
            literal: false,
            val: currentFull
          });
        }

        currentFull = c;
        current = c;
      }
    }

    if (currentFull.length > 0) {
      splits.push({
        literal: bracketed,
        val: currentFull
      });
    }

    return splits;
  };

  Formatter.macroTokenToFormatOpts = function macroTokenToFormatOpts(token) {
    return _macroTokenToFormatOpts[token];
  };

  function Formatter(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }

  var _proto = Formatter.prototype;

  _proto.formatWithSystemDefault = function formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }

    var df = this.systemLoc.dtFormatter(dt, Object.assign({}, this.opts, opts));
    return df.format();
  };

  _proto.formatDateTime = function formatDateTime(dt, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var df = this.loc.dtFormatter(dt, Object.assign({}, this.opts, opts));
    return df.format();
  };

  _proto.formatDateTimeParts = function formatDateTimeParts(dt, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var df = this.loc.dtFormatter(dt, Object.assign({}, this.opts, opts));
    return df.formatToParts();
  };

  _proto.resolvedOptions = function resolvedOptions(dt, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var df = this.loc.dtFormatter(dt, Object.assign({}, this.opts, opts));
    return df.resolvedOptions();
  };

  _proto.num = function num(n, p) {
    if (p === void 0) {
      p = 0;
    }

    // we get some perf out of doing this here, annoyingly
    if (this.opts.forceSimple) {
      return padStart(n, p);
    }

    var opts = Object.assign({}, this.opts);

    if (p > 0) {
      opts.padTo = p;
    }

    return this.loc.numberFormatter(opts).format(n);
  };

  _proto.formatDateTimeFromString = function formatDateTimeFromString(dt, fmt) {
    var _this = this;

    var knownEnglish = this.loc.listingMode() === "en",
        useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory" && hasFormatToParts(),
        string = function string(opts, extract) {
      return _this.loc.extract(dt, opts, extract);
    },
        formatOffset = function formatOffset(opts) {
      if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
        return "Z";
      }

      return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
    },
        meridiem = function meridiem() {
      return knownEnglish ? meridiemForDateTime(dt) : string({
        hour: "numeric",
        hour12: true
      }, "dayperiod");
    },
        month = function month(length, standalone) {
      return knownEnglish ? monthForDateTime(dt, length) : string(standalone ? {
        month: length
      } : {
        month: length,
        day: "numeric"
      }, "month");
    },
        weekday = function weekday(length, standalone) {
      return knownEnglish ? weekdayForDateTime(dt, length) : string(standalone ? {
        weekday: length
      } : {
        weekday: length,
        month: "long",
        day: "numeric"
      }, "weekday");
    },
        maybeMacro = function maybeMacro(token) {
      var formatOpts = Formatter.macroTokenToFormatOpts(token);

      if (formatOpts) {
        return _this.formatWithSystemDefault(dt, formatOpts);
      } else {
        return token;
      }
    },
        era = function era(length) {
      return knownEnglish ? eraForDateTime(dt, length) : string({
        era: length
      }, "era");
    },
        tokenToString = function tokenToString(token) {
      // Where possible: http://cldr.unicode.org/translation/date-time-1/date-time#TOC-Standalone-vs.-Format-Styles
      switch (token) {
        // ms
        case "S":
          return _this.num(dt.millisecond);

        case "u": // falls through

        case "SSS":
          return _this.num(dt.millisecond, 3);
        // seconds

        case "s":
          return _this.num(dt.second);

        case "ss":
          return _this.num(dt.second, 2);
        // minutes

        case "m":
          return _this.num(dt.minute);

        case "mm":
          return _this.num(dt.minute, 2);
        // hours

        case "h":
          return _this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);

        case "hh":
          return _this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);

        case "H":
          return _this.num(dt.hour);

        case "HH":
          return _this.num(dt.hour, 2);
        // offset

        case "Z":
          // like +6
          return formatOffset({
            format: "narrow",
            allowZ: _this.opts.allowZ
          });

        case "ZZ":
          // like +06:00
          return formatOffset({
            format: "short",
            allowZ: _this.opts.allowZ
          });

        case "ZZZ":
          // like +0600
          return formatOffset({
            format: "techie",
            allowZ: _this.opts.allowZ
          });

        case "ZZZZ":
          // like EST
          return dt.zone.offsetName(dt.ts, {
            format: "short",
            locale: _this.loc.locale
          });

        case "ZZZZZ":
          // like Eastern Standard Time
          return dt.zone.offsetName(dt.ts, {
            format: "long",
            locale: _this.loc.locale
          });
        // zone

        case "z":
          // like America/New_York
          return dt.zoneName;
        // meridiems

        case "a":
          return meridiem();
        // dates

        case "d":
          return useDateTimeFormatter ? string({
            day: "numeric"
          }, "day") : _this.num(dt.day);

        case "dd":
          return useDateTimeFormatter ? string({
            day: "2-digit"
          }, "day") : _this.num(dt.day, 2);
        // weekdays - standalone

        case "c":
          // like 1
          return _this.num(dt.weekday);

        case "ccc":
          // like 'Tues'
          return weekday("short", true);

        case "cccc":
          // like 'Tuesday'
          return weekday("long", true);

        case "ccccc":
          // like 'T'
          return weekday("narrow", true);
        // weekdays - format

        case "E":
          // like 1
          return _this.num(dt.weekday);

        case "EEE":
          // like 'Tues'
          return weekday("short", false);

        case "EEEE":
          // like 'Tuesday'
          return weekday("long", false);

        case "EEEEE":
          // like 'T'
          return weekday("narrow", false);
        // months - standalone

        case "L":
          // like 1
          return useDateTimeFormatter ? string({
            month: "numeric",
            day: "numeric"
          }, "month") : _this.num(dt.month);

        case "LL":
          // like 01, doesn't seem to work
          return useDateTimeFormatter ? string({
            month: "2-digit",
            day: "numeric"
          }, "month") : _this.num(dt.month, 2);

        case "LLL":
          // like Jan
          return month("short", true);

        case "LLLL":
          // like January
          return month("long", true);

        case "LLLLL":
          // like J
          return month("narrow", true);
        // months - format

        case "M":
          // like 1
          return useDateTimeFormatter ? string({
            month: "numeric"
          }, "month") : _this.num(dt.month);

        case "MM":
          // like 01
          return useDateTimeFormatter ? string({
            month: "2-digit"
          }, "month") : _this.num(dt.month, 2);

        case "MMM":
          // like Jan
          return month("short", false);

        case "MMMM":
          // like January
          return month("long", false);

        case "MMMMM":
          // like J
          return month("narrow", false);
        // years

        case "y":
          // like 2014
          return useDateTimeFormatter ? string({
            year: "numeric"
          }, "year") : _this.num(dt.year);

        case "yy":
          // like 14
          return useDateTimeFormatter ? string({
            year: "2-digit"
          }, "year") : _this.num(dt.year.toString().slice(-2), 2);

        case "yyyy":
          // like 0012
          return useDateTimeFormatter ? string({
            year: "numeric"
          }, "year") : _this.num(dt.year, 4);

        case "yyyyyy":
          // like 000012
          return useDateTimeFormatter ? string({
            year: "numeric"
          }, "year") : _this.num(dt.year, 6);
        // eras

        case "G":
          // like AD
          return era("short");

        case "GG":
          // like Anno Domini
          return era("long");

        case "GGGGG":
          return era("narrow");

        case "kk":
          return _this.num(dt.weekYear.toString().slice(-2), 2);

        case "kkkk":
          return _this.num(dt.weekYear, 4);

        case "W":
          return _this.num(dt.weekNumber);

        case "WW":
          return _this.num(dt.weekNumber, 2);

        case "o":
          return _this.num(dt.ordinal);

        case "ooo":
          return _this.num(dt.ordinal, 3);

        case "q":
          // like 1
          return _this.num(dt.quarter);

        case "qq":
          // like 01
          return _this.num(dt.quarter, 2);

        case "X":
          return _this.num(Math.floor(dt.ts / 1000));

        case "x":
          return _this.num(dt.ts);

        default:
          return maybeMacro(token);
      }
    };

    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
  };

  _proto.formatDurationFromString = function formatDurationFromString(dur, fmt) {
    var _this2 = this;

    var tokenToField = function tokenToField(token) {
      switch (token[0]) {
        case "S":
          return "millisecond";

        case "s":
          return "second";

        case "m":
          return "minute";

        case "h":
          return "hour";

        case "d":
          return "day";

        case "M":
          return "month";

        case "y":
          return "year";

        default:
          return null;
      }
    },
        tokenToString = function tokenToString(lildur) {
      return function (token) {
        var mapped = tokenToField(token);

        if (mapped) {
          return _this2.num(lildur.get(mapped), token.length);
        } else {
          return token;
        }
      };
    },
        tokens = Formatter.parseFormat(fmt),
        realTokens = tokens.reduce(function (found, _ref) {
      var literal = _ref.literal,
          val = _ref.val;
      return literal ? found : found.concat(val);
    }, []),
        collapsed = dur.shiftTo.apply(dur, realTokens.map(tokenToField).filter(function (t) {
      return t;
    }));

    return stringifyTokens(tokens, tokenToString(collapsed));
  };

  return Formatter;
}();

var Invalid = /*#__PURE__*/function () {
  function Invalid(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }

  var _proto = Invalid.prototype;

  _proto.toMessage = function toMessage() {
    if (this.explanation) {
      return this.reason + ": " + this.explanation;
    } else {
      return this.reason;
    }
  };

  return Invalid;
}();

/**
 * @interface
 */

var Zone = /*#__PURE__*/function () {
  function Zone() {}

  var _proto = Zone.prototype;

  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  _proto.offsetName = function offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  ;

  _proto.formatOffset = function formatOffset(ts, format) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  ;

  _proto.offset = function offset(ts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  ;

  _proto.equals = function equals(otherZone) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  ;

  _createClass(Zone, [{
    key: "type",

    /**
     * The type of zone
     * @abstract
     * @type {string}
     */
    get: function get() {
      throw new ZoneIsAbstractError();
    }
    /**
     * The name of this zone.
     * @abstract
     * @type {string}
     */

  }, {
    key: "name",
    get: function get() {
      throw new ZoneIsAbstractError();
    }
    /**
     * Returns whether the offset is known to be fixed for the whole year.
     * @abstract
     * @type {boolean}
     */

  }, {
    key: "universal",
    get: function get() {
      throw new ZoneIsAbstractError();
    }
  }, {
    key: "isValid",
    get: function get() {
      throw new ZoneIsAbstractError();
    }
  }]);

  return Zone;
}();

var singleton = null;
/**
 * Represents the local zone for this JavaScript environment.
 * @implements {Zone}
 */

var LocalZone = /*#__PURE__*/function (_Zone) {
  _inheritsLoose(LocalZone, _Zone);

  function LocalZone() {
    return _Zone.apply(this, arguments) || this;
  }

  var _proto = LocalZone.prototype;

  /** @override **/
  _proto.offsetName = function offsetName(ts, _ref) {
    var format = _ref.format,
        locale = _ref.locale;
    return parseZoneInfo(ts, format, locale);
  }
  /** @override **/
  ;

  _proto.formatOffset = function formatOffset$1(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /** @override **/
  ;

  _proto.offset = function offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }
  /** @override **/
  ;

  _proto.equals = function equals(otherZone) {
    return otherZone.type === "local";
  }
  /** @override **/
  ;

  _createClass(LocalZone, [{
    key: "type",

    /** @override **/
    get: function get() {
      return "local";
    }
    /** @override **/

  }, {
    key: "name",
    get: function get() {
      if (hasIntl()) {
        return new Intl.DateTimeFormat().resolvedOptions().timeZone;
      } else return "local";
    }
    /** @override **/

  }, {
    key: "universal",
    get: function get() {
      return false;
    }
  }, {
    key: "isValid",
    get: function get() {
      return true;
    }
  }], [{
    key: "instance",

    /**
     * Get a singleton instance of the local zone
     * @return {LocalZone}
     */
    get: function get() {
      if (singleton === null) {
        singleton = new LocalZone();
      }

      return singleton;
    }
  }]);

  return LocalZone;
}(Zone);

var matchingRegex = RegExp("^" + ianaRegex.source + "$");
var dtfCache = {};

function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
  }

  return dtfCache[zone];
}

var typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5
};

function hackyOffset(dtf, date) {
  var formatted = dtf.format(date).replace(/\u200E/g, ""),
      parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted),
      fMonth = parsed[1],
      fDay = parsed[2],
      fYear = parsed[3],
      fHour = parsed[4],
      fMinute = parsed[5],
      fSecond = parsed[6];
  return [fYear, fMonth, fDay, fHour, fMinute, fSecond];
}

function partsOffset(dtf, date) {
  var formatted = dtf.formatToParts(date),
      filled = [];

  for (var i = 0; i < formatted.length; i++) {
    var _formatted$i = formatted[i],
        type = _formatted$i.type,
        value = _formatted$i.value,
        pos = typeToPos[type];

    if (!isUndefined(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }

  return filled;
}

var ianaZoneCache = {};
/**
 * A zone identified by an IANA identifier, like America/New_York
 * @implements {Zone}
 */

var IANAZone = /*#__PURE__*/function (_Zone) {
  _inheritsLoose(IANAZone, _Zone);

  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  IANAZone.create = function create(name) {
    if (!ianaZoneCache[name]) {
      ianaZoneCache[name] = new IANAZone(name);
    }

    return ianaZoneCache[name];
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  ;

  IANAZone.resetCache = function resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Fantasia/Castle") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @return {boolean}
   */
  ;

  IANAZone.isValidSpecifier = function isValidSpecifier(s) {
    return !!(s && s.match(matchingRegex));
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  ;

  IANAZone.isValidZone = function isValidZone(zone) {
    try {
      new Intl.DateTimeFormat("en-US", {
        timeZone: zone
      }).format();
      return true;
    } catch (e) {
      return false;
    }
  } // Etc/GMT+8 -> -480

  /** @ignore */
  ;

  IANAZone.parseGMTOffset = function parseGMTOffset(specifier) {
    if (specifier) {
      var match = specifier.match(/^Etc\/GMT([+-]\d{1,2})$/i);

      if (match) {
        return -60 * parseInt(match[1]);
      }
    }

    return null;
  };

  function IANAZone(name) {
    var _this;

    _this = _Zone.call(this) || this;
    /** @private **/

    _this.zoneName = name;
    /** @private **/

    _this.valid = IANAZone.isValidZone(name);
    return _this;
  }
  /** @override **/


  var _proto = IANAZone.prototype;

  /** @override **/
  _proto.offsetName = function offsetName(ts, _ref) {
    var format = _ref.format,
        locale = _ref.locale;
    return parseZoneInfo(ts, format, locale, this.name);
  }
  /** @override **/
  ;

  _proto.formatOffset = function formatOffset$1(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /** @override **/
  ;

  _proto.offset = function offset(ts) {
    var date = new Date(ts),
        dtf = makeDTF(this.name),
        _ref2 = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date),
        year = _ref2[0],
        month = _ref2[1],
        day = _ref2[2],
        hour = _ref2[3],
        minute = _ref2[4],
        second = _ref2[5],
        adjustedHour = hour === 24 ? 0 : hour;

    var asUTC = objToLocalTS({
      year: year,
      month: month,
      day: day,
      hour: adjustedHour,
      minute: minute,
      second: second,
      millisecond: 0
    });
    var asTS = +date;
    var over = asTS % 1000;
    asTS -= over >= 0 ? over : 1000 + over;
    return (asUTC - asTS) / (60 * 1000);
  }
  /** @override **/
  ;

  _proto.equals = function equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }
  /** @override **/
  ;

  _createClass(IANAZone, [{
    key: "type",
    get: function get() {
      return "iana";
    }
    /** @override **/

  }, {
    key: "name",
    get: function get() {
      return this.zoneName;
    }
    /** @override **/

  }, {
    key: "universal",
    get: function get() {
      return false;
    }
  }, {
    key: "isValid",
    get: function get() {
      return this.valid;
    }
  }]);

  return IANAZone;
}(Zone);

var singleton$1 = null;
/**
 * A zone with a fixed offset (meaning no DST)
 * @implements {Zone}
 */

var FixedOffsetZone = /*#__PURE__*/function (_Zone) {
  _inheritsLoose(FixedOffsetZone, _Zone);

  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  FixedOffsetZone.instance = function instance(offset) {
    return offset === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  ;

  FixedOffsetZone.parseSpecifier = function parseSpecifier(s) {
    if (s) {
      var r = s.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);

      if (r) {
        return new FixedOffsetZone(signedOffset(r[1], r[2]));
      }
    }

    return null;
  };

  _createClass(FixedOffsetZone, null, [{
    key: "utcInstance",

    /**
     * Get a singleton instance of UTC
     * @return {FixedOffsetZone}
     */
    get: function get() {
      if (singleton$1 === null) {
        singleton$1 = new FixedOffsetZone(0);
      }

      return singleton$1;
    }
  }]);

  function FixedOffsetZone(offset) {
    var _this;

    _this = _Zone.call(this) || this;
    /** @private **/

    _this.fixed = offset;
    return _this;
  }
  /** @override **/


  var _proto = FixedOffsetZone.prototype;

  /** @override **/
  _proto.offsetName = function offsetName() {
    return this.name;
  }
  /** @override **/
  ;

  _proto.formatOffset = function formatOffset$1(ts, format) {
    return formatOffset(this.fixed, format);
  }
  /** @override **/
  ;

  /** @override **/
  _proto.offset = function offset() {
    return this.fixed;
  }
  /** @override **/
  ;

  _proto.equals = function equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }
  /** @override **/
  ;

  _createClass(FixedOffsetZone, [{
    key: "type",
    get: function get() {
      return "fixed";
    }
    /** @override **/

  }, {
    key: "name",
    get: function get() {
      return this.fixed === 0 ? "UTC" : "UTC" + formatOffset(this.fixed, "narrow");
    }
  }, {
    key: "universal",
    get: function get() {
      return true;
    }
  }, {
    key: "isValid",
    get: function get() {
      return true;
    }
  }]);

  return FixedOffsetZone;
}(Zone);

/**
 * A zone that failed to parse. You should never need to instantiate this.
 * @implements {Zone}
 */

var InvalidZone = /*#__PURE__*/function (_Zone) {
  _inheritsLoose(InvalidZone, _Zone);

  function InvalidZone(zoneName) {
    var _this;

    _this = _Zone.call(this) || this;
    /**  @private */

    _this.zoneName = zoneName;
    return _this;
  }
  /** @override **/


  var _proto = InvalidZone.prototype;

  /** @override **/
  _proto.offsetName = function offsetName() {
    return null;
  }
  /** @override **/
  ;

  _proto.formatOffset = function formatOffset() {
    return "";
  }
  /** @override **/
  ;

  _proto.offset = function offset() {
    return NaN;
  }
  /** @override **/
  ;

  _proto.equals = function equals() {
    return false;
  }
  /** @override **/
  ;

  _createClass(InvalidZone, [{
    key: "type",
    get: function get() {
      return "invalid";
    }
    /** @override **/

  }, {
    key: "name",
    get: function get() {
      return this.zoneName;
    }
    /** @override **/

  }, {
    key: "universal",
    get: function get() {
      return false;
    }
  }, {
    key: "isValid",
    get: function get() {
      return false;
    }
  }]);

  return InvalidZone;
}(Zone);

/**
 * @private
 */
function normalizeZone(input, defaultZone) {
  var offset;

  if (isUndefined(input) || input === null) {
    return defaultZone;
  } else if (input instanceof Zone) {
    return input;
  } else if (isString(input)) {
    var lowered = input.toLowerCase();
    if (lowered === "local") return defaultZone;else if (lowered === "utc" || lowered === "gmt") return FixedOffsetZone.utcInstance;else if ((offset = IANAZone.parseGMTOffset(input)) != null) {
      // handle Etc/GMT-4, which V8 chokes on
      return FixedOffsetZone.instance(offset);
    } else if (IANAZone.isValidSpecifier(lowered)) return IANAZone.create(input);else return FixedOffsetZone.parseSpecifier(lowered) || new InvalidZone(input);
  } else if (isNumber(input)) {
    return FixedOffsetZone.instance(input);
  } else if (typeof input === "object" && input.offset && typeof input.offset === "number") {
    // This is dumb, but the instanceof check above doesn't seem to really work
    // so we're duck checking it
    return input;
  } else {
    return new InvalidZone(input);
  }
}

var now = function now() {
  return Date.now();
},
    defaultZone = null,
    // not setting this directly to LocalZone.instance bc loading order issues
defaultLocale = null,
    defaultNumberingSystem = null,
    defaultOutputCalendar = null,
    throwOnInvalid = false;
/**
 * Settings contains static getters and setters that control Luxon's overall behavior. Luxon is a simple library with few options, but the ones it does have live here.
 */


var Settings = /*#__PURE__*/function () {
  function Settings() {}

  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  Settings.resetCaches = function resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
  };

  _createClass(Settings, null, [{
    key: "now",

    /**
     * Get the callback for returning the current timestamp.
     * @type {function}
     */
    get: function get() {
      return now;
    }
    /**
     * Set the callback for returning the current timestamp.
     * The function should return a number, which will be interpreted as an Epoch millisecond count
     * @type {function}
     * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
     * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
     */
    ,
    set: function set(n) {
      now = n;
    }
    /**
     * Get the default time zone to create DateTimes in.
     * @type {string}
     */

  }, {
    key: "defaultZoneName",
    get: function get() {
      return Settings.defaultZone.name;
    }
    /**
     * Set the default time zone to create DateTimes in. Does not affect existing instances.
     * @type {string}
     */
    ,
    set: function set(z) {
      if (!z) {
        defaultZone = null;
      } else {
        defaultZone = normalizeZone(z);
      }
    }
    /**
     * Get the default time zone object to create DateTimes in. Does not affect existing instances.
     * @type {Zone}
     */

  }, {
    key: "defaultZone",
    get: function get() {
      return defaultZone || LocalZone.instance;
    }
    /**
     * Get the default locale to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */

  }, {
    key: "defaultLocale",
    get: function get() {
      return defaultLocale;
    }
    /**
     * Set the default locale to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    ,
    set: function set(locale) {
      defaultLocale = locale;
    }
    /**
     * Get the default numbering system to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */

  }, {
    key: "defaultNumberingSystem",
    get: function get() {
      return defaultNumberingSystem;
    }
    /**
     * Set the default numbering system to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    ,
    set: function set(numberingSystem) {
      defaultNumberingSystem = numberingSystem;
    }
    /**
     * Get the default output calendar to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */

  }, {
    key: "defaultOutputCalendar",
    get: function get() {
      return defaultOutputCalendar;
    }
    /**
     * Set the default output calendar to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    ,
    set: function set(outputCalendar) {
      defaultOutputCalendar = outputCalendar;
    }
    /**
     * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
     * @type {boolean}
     */

  }, {
    key: "throwOnInvalid",
    get: function get() {
      return throwOnInvalid;
    }
    /**
     * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
     * @type {boolean}
     */
    ,
    set: function set(t) {
      throwOnInvalid = t;
    }
  }]);

  return Settings;
}();

var intlDTCache = {};

function getCachedDTF(locString, opts) {
  if (opts === void 0) {
    opts = {};
  }

  var key = JSON.stringify([locString, opts]);
  var dtf = intlDTCache[key];

  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }

  return dtf;
}

var intlNumCache = {};

function getCachedINF(locString, opts) {
  if (opts === void 0) {
    opts = {};
  }

  var key = JSON.stringify([locString, opts]);
  var inf = intlNumCache[key];

  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }

  return inf;
}

var intlRelCache = {};

function getCachedRTF(locString, opts) {
  if (opts === void 0) {
    opts = {};
  }

  var _opts = opts,
      base = _opts.base,
      cacheKeyOpts = _objectWithoutPropertiesLoose(_opts, ["base"]); // exclude `base` from the options


  var key = JSON.stringify([locString, cacheKeyOpts]);
  var inf = intlRelCache[key];

  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }

  return inf;
}

var sysLocaleCache = null;

function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else if (hasIntl()) {
    var computedSys = new Intl.DateTimeFormat().resolvedOptions().locale; // node sometimes defaults to "und". Override that because that is dumb

    sysLocaleCache = !computedSys || computedSys === "und" ? "en-US" : computedSys;
    return sysLocaleCache;
  } else {
    sysLocaleCache = "en-US";
    return sysLocaleCache;
  }
}

function parseLocaleString(localeStr) {
  // I really want to avoid writing a BCP 47 parser
  // see, e.g. https://github.com/wooorm/bcp-47
  // Instead, we'll do this:
  // a) if the string has no -u extensions, just leave it alone
  // b) if it does, use Intl to resolve everything
  // c) if Intl fails, try again without the -u
  var uIndex = localeStr.indexOf("-u-");

  if (uIndex === -1) {
    return [localeStr];
  } else {
    var options;
    var smaller = localeStr.substring(0, uIndex);

    try {
      options = getCachedDTF(localeStr).resolvedOptions();
    } catch (e) {
      options = getCachedDTF(smaller).resolvedOptions();
    }

    var _options = options,
        numberingSystem = _options.numberingSystem,
        calendar = _options.calendar; // return the smaller one so that we can append the calendar and numbering overrides to it

    return [smaller, numberingSystem, calendar];
  }
}

function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (hasIntl()) {
    if (outputCalendar || numberingSystem) {
      localeStr += "-u";

      if (outputCalendar) {
        localeStr += "-ca-" + outputCalendar;
      }

      if (numberingSystem) {
        localeStr += "-nu-" + numberingSystem;
      }

      return localeStr;
    } else {
      return localeStr;
    }
  } else {
    return [];
  }
}

function mapMonths(f) {
  var ms = [];

  for (var i = 1; i <= 12; i++) {
    var dt = DateTime.utc(2016, i, 1);
    ms.push(f(dt));
  }

  return ms;
}

function mapWeekdays(f) {
  var ms = [];

  for (var i = 1; i <= 7; i++) {
    var dt = DateTime.utc(2016, 11, 13 + i);
    ms.push(f(dt));
  }

  return ms;
}

function listStuff(loc, length, defaultOK, englishFn, intlFn) {
  var mode = loc.listingMode(defaultOK);

  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
}

function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || hasIntl() && new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
  }
}
/**
 * @private
 */


var PolyNumberFormatter = /*#__PURE__*/function () {
  function PolyNumberFormatter(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;

    if (!forceSimple && hasIntl()) {
      var intlOpts = {
        useGrouping: false
      };
      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }

  var _proto = PolyNumberFormatter.prototype;

  _proto.format = function format(i) {
    if (this.inf) {
      var fixed = this.floor ? Math.floor(i) : i;
      return this.inf.format(fixed);
    } else {
      // to match the browser's numberformatter defaults
      var _fixed = this.floor ? Math.floor(i) : roundTo(i, 3);

      return padStart(_fixed, this.padTo);
    }
  };

  return PolyNumberFormatter;
}();
/**
 * @private
 */


var PolyDateFormatter = /*#__PURE__*/function () {
  function PolyDateFormatter(dt, intl, opts) {
    this.opts = opts;
    this.hasIntl = hasIntl();
    var z;

    if (dt.zone.universal && this.hasIntl) {
      // UTC-8 or Etc/UTC-8 are not part of tzdata, only Etc/GMT+8 and the like.
      // That is why fixed-offset TZ is set to that unless it is:
      // 1. Outside of the supported range Etc/GMT-14 to Etc/GMT+12.
      // 2. Not a whole hour, e.g. UTC+4:30.
      var gmtOffset = -1 * (dt.offset / 60);

      if (gmtOffset >= -14 && gmtOffset <= 12 && gmtOffset % 1 === 0) {
        z = gmtOffset >= 0 ? "Etc/GMT+" + gmtOffset : "Etc/GMT" + gmtOffset;
        this.dt = dt;
      } else {
        // Not all fixed-offset zones like Etc/+4:30 are present in tzdata.
        // So we have to make do. Two cases:
        // 1. The format options tell us to show the zone. We can't do that, so the best
        // we can do is format the date in UTC.
        // 2. The format options don't tell us to show the zone. Then we can adjust them
        // the time and tell the formatter to show it to us in UTC, so that the time is right
        // and the bad zone doesn't show up.
        z = "UTC";

        if (opts.timeZoneName) {
          this.dt = dt;
        } else {
          this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1000);
        }
      }
    } else if (dt.zone.type === "local") {
      this.dt = dt;
    } else {
      this.dt = dt;
      z = dt.zone.name;
    }

    if (this.hasIntl) {
      var intlOpts = Object.assign({}, this.opts);

      if (z) {
        intlOpts.timeZone = z;
      }

      this.dtf = getCachedDTF(intl, intlOpts);
    }
  }

  var _proto2 = PolyDateFormatter.prototype;

  _proto2.format = function format() {
    if (this.hasIntl) {
      return this.dtf.format(this.dt.toJSDate());
    } else {
      var tokenFormat = formatString(this.opts),
          loc = Locale.create("en-US");
      return Formatter.create(loc).formatDateTimeFromString(this.dt, tokenFormat);
    }
  };

  _proto2.formatToParts = function formatToParts() {
    if (this.hasIntl && hasFormatToParts()) {
      return this.dtf.formatToParts(this.dt.toJSDate());
    } else {
      // This is kind of a cop out. We actually could do this for English. However, we couldn't do it for intl strings
      // and IMO it's too weird to have an uncanny valley like that
      return [];
    }
  };

  _proto2.resolvedOptions = function resolvedOptions() {
    if (this.hasIntl) {
      return this.dtf.resolvedOptions();
    } else {
      return {
        locale: "en-US",
        numberingSystem: "latn",
        outputCalendar: "gregory"
      };
    }
  };

  return PolyDateFormatter;
}();
/**
 * @private
 */


var PolyRelFormatter = /*#__PURE__*/function () {
  function PolyRelFormatter(intl, isEnglish, opts) {
    this.opts = Object.assign({
      style: "long"
    }, opts);

    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }

  var _proto3 = PolyRelFormatter.prototype;

  _proto3.format = function format(count, unit) {
    if (this.rtf) {
      return this.rtf.format(count, unit);
    } else {
      return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
    }
  };

  _proto3.formatToParts = function formatToParts(count, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  };

  return PolyRelFormatter;
}();
/**
 * @private
 */


var Locale = /*#__PURE__*/function () {
  Locale.fromOpts = function fromOpts(opts) {
    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
  };

  Locale.create = function create(locale, numberingSystem, outputCalendar, defaultToEN) {
    if (defaultToEN === void 0) {
      defaultToEN = false;
    }

    var specifiedLocale = locale || Settings.defaultLocale,
        // the system locale is useful for human readable strings but annoying for parsing/formatting known formats
    localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale()),
        numberingSystemR = numberingSystem || Settings.defaultNumberingSystem,
        outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
  };

  Locale.resetCache = function resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  };

  Locale.fromObject = function fromObject(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        locale = _ref.locale,
        numberingSystem = _ref.numberingSystem,
        outputCalendar = _ref.outputCalendar;

    return Locale.create(locale, numberingSystem, outputCalendar);
  };

  function Locale(locale, numbering, outputCalendar, specifiedLocale) {
    var _parseLocaleString = parseLocaleString(locale),
        parsedLocale = _parseLocaleString[0],
        parsedNumberingSystem = _parseLocaleString[1],
        parsedOutputCalendar = _parseLocaleString[2];

    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = {
      format: {},
      standalone: {}
    };
    this.monthsCache = {
      format: {},
      standalone: {}
    };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }

  var _proto4 = Locale.prototype;

  _proto4.listingMode = function listingMode(defaultOK) {
    if (defaultOK === void 0) {
      defaultOK = true;
    }

    var intl = hasIntl(),
        hasFTP = intl && hasFormatToParts(),
        isActuallyEn = this.isEnglish(),
        hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");

    if (!hasFTP && !(isActuallyEn && hasNoWeirdness) && !defaultOK) {
      return "error";
    } else if (!hasFTP || isActuallyEn && hasNoWeirdness) {
      return "en";
    } else {
      return "intl";
    }
  };

  _proto4.clone = function clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return Locale.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, alts.defaultToEN || false);
    }
  };

  _proto4.redefaultToEN = function redefaultToEN(alts) {
    if (alts === void 0) {
      alts = {};
    }

    return this.clone(Object.assign({}, alts, {
      defaultToEN: true
    }));
  };

  _proto4.redefaultToSystem = function redefaultToSystem(alts) {
    if (alts === void 0) {
      alts = {};
    }

    return this.clone(Object.assign({}, alts, {
      defaultToEN: false
    }));
  };

  _proto4.months = function months$1(length, format, defaultOK) {
    var _this = this;

    if (format === void 0) {
      format = false;
    }

    if (defaultOK === void 0) {
      defaultOK = true;
    }

    return listStuff(this, length, defaultOK, months, function () {
      var intl = format ? {
        month: length,
        day: "numeric"
      } : {
        month: length
      },
          formatStr = format ? "format" : "standalone";

      if (!_this.monthsCache[formatStr][length]) {
        _this.monthsCache[formatStr][length] = mapMonths(function (dt) {
          return _this.extract(dt, intl, "month");
        });
      }

      return _this.monthsCache[formatStr][length];
    });
  };

  _proto4.weekdays = function weekdays$1(length, format, defaultOK) {
    var _this2 = this;

    if (format === void 0) {
      format = false;
    }

    if (defaultOK === void 0) {
      defaultOK = true;
    }

    return listStuff(this, length, defaultOK, weekdays, function () {
      var intl = format ? {
        weekday: length,
        year: "numeric",
        month: "long",
        day: "numeric"
      } : {
        weekday: length
      },
          formatStr = format ? "format" : "standalone";

      if (!_this2.weekdaysCache[formatStr][length]) {
        _this2.weekdaysCache[formatStr][length] = mapWeekdays(function (dt) {
          return _this2.extract(dt, intl, "weekday");
        });
      }

      return _this2.weekdaysCache[formatStr][length];
    });
  };

  _proto4.meridiems = function meridiems$1(defaultOK) {
    var _this3 = this;

    if (defaultOK === void 0) {
      defaultOK = true;
    }

    return listStuff(this, undefined, defaultOK, function () {
      return meridiems;
    }, function () {
      // In theory there could be aribitrary day periods. We're gonna assume there are exactly two
      // for AM and PM. This is probably wrong, but it's makes parsing way easier.
      if (!_this3.meridiemCache) {
        var intl = {
          hour: "numeric",
          hour12: true
        };
        _this3.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(function (dt) {
          return _this3.extract(dt, intl, "dayperiod");
        });
      }

      return _this3.meridiemCache;
    });
  };

  _proto4.eras = function eras$1(length, defaultOK) {
    var _this4 = this;

    if (defaultOK === void 0) {
      defaultOK = true;
    }

    return listStuff(this, length, defaultOK, eras, function () {
      var intl = {
        era: length
      }; // This is problematic. Different calendars are going to define eras totally differently. What I need is the minimum set of dates
      // to definitely enumerate them.

      if (!_this4.eraCache[length]) {
        _this4.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(function (dt) {
          return _this4.extract(dt, intl, "era");
        });
      }

      return _this4.eraCache[length];
    });
  };

  _proto4.extract = function extract(dt, intlOpts, field) {
    var df = this.dtFormatter(dt, intlOpts),
        results = df.formatToParts(),
        matching = results.find(function (m) {
      return m.type.toLowerCase() === field;
    });
    return matching ? matching.value : null;
  };

  _proto4.numberFormatter = function numberFormatter(opts) {
    if (opts === void 0) {
      opts = {};
    }

    // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)
    // (in contrast, the rest of the condition is used heavily)
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  };

  _proto4.dtFormatter = function dtFormatter(dt, intlOpts) {
    if (intlOpts === void 0) {
      intlOpts = {};
    }

    return new PolyDateFormatter(dt, this.intl, intlOpts);
  };

  _proto4.relFormatter = function relFormatter(opts) {
    if (opts === void 0) {
      opts = {};
    }

    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  };

  _proto4.isEnglish = function isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || hasIntl() && new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  };

  _proto4.equals = function equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  };

  _createClass(Locale, [{
    key: "fastNumbers",
    get: function get() {
      if (this.fastNumbersCached == null) {
        this.fastNumbersCached = supportsFastNumbers(this);
      }

      return this.fastNumbersCached;
    }
  }]);

  return Locale;
}();

/*
 * This file handles parsing for well-specified formats. Here's how it works:
 * Two things go into parsing: a regex to match with and an extractor to take apart the groups in the match.
 * An extractor is just a function that takes a regex match array and returns a { year: ..., month: ... } object
 * parse() does the work of executing the regex and applying the extractor. It takes multiple regex/extractor pairs to try in sequence.
 * Extractors can take a "cursor" representing the offset in the match to look at. This makes it easy to combine extractors.
 * combineExtractors() does the work of combining them, keeping track of the cursor through multiple extractions.
 * Some extractions are super dumb and simpleParse and fromStrings help DRY them.
 */

function combineRegexes() {
  for (var _len = arguments.length, regexes = new Array(_len), _key = 0; _key < _len; _key++) {
    regexes[_key] = arguments[_key];
  }

  var full = regexes.reduce(function (f, r) {
    return f + r.source;
  }, "");
  return RegExp("^" + full + "$");
}

function combineExtractors() {
  for (var _len2 = arguments.length, extractors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    extractors[_key2] = arguments[_key2];
  }

  return function (m) {
    return extractors.reduce(function (_ref, ex) {
      var mergedVals = _ref[0],
          mergedZone = _ref[1],
          cursor = _ref[2];

      var _ex = ex(m, cursor),
          val = _ex[0],
          zone = _ex[1],
          next = _ex[2];

      return [Object.assign(mergedVals, val), mergedZone || zone, next];
    }, [{}, null, 1]).slice(0, 2);
  };
}

function parse(s) {
  if (s == null) {
    return [null, null];
  }

  for (var _len3 = arguments.length, patterns = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    patterns[_key3 - 1] = arguments[_key3];
  }

  for (var _i = 0, _patterns = patterns; _i < _patterns.length; _i++) {
    var _patterns$_i = _patterns[_i],
        regex = _patterns$_i[0],
        extractor = _patterns$_i[1];
    var m = regex.exec(s);

    if (m) {
      return extractor(m);
    }
  }

  return [null, null];
}

function simpleParse() {
  for (var _len4 = arguments.length, keys = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    keys[_key4] = arguments[_key4];
  }

  return function (match, cursor) {
    var ret = {};
    var i;

    for (i = 0; i < keys.length; i++) {
      ret[keys[i]] = parseInteger(match[cursor + i]);
    }

    return [ret, null, cursor + i];
  };
} // ISO and SQL parsing


var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/,
    isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/,
    isoTimeRegex = RegExp("" + isoTimeBaseRegex.source + offsetRegex.source + "?"),
    isoTimeExtensionRegex = RegExp("(?:T" + isoTimeRegex.source + ")?"),
    isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/,
    isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/,
    isoOrdinalRegex = /(\d{4})-?(\d{3})/,
    extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay"),
    extractISOOrdinalData = simpleParse("year", "ordinal"),
    sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/,
    // dumbed-down version of the ISO one
sqlTimeRegex = RegExp(isoTimeBaseRegex.source + " ?(?:" + offsetRegex.source + "|(" + ianaRegex.source + "))?"),
    sqlTimeExtensionRegex = RegExp("(?: " + sqlTimeRegex.source + ")?");

function int(match, pos, fallback) {
  var m = match[pos];
  return isUndefined(m) ? fallback : parseInteger(m);
}

function extractISOYmd(match, cursor) {
  var item = {
    year: int(match, cursor),
    month: int(match, cursor + 1, 1),
    day: int(match, cursor + 2, 1)
  };
  return [item, null, cursor + 3];
}

function extractISOTime(match, cursor) {
  var item = {
    hours: int(match, cursor, 0),
    minutes: int(match, cursor + 1, 0),
    seconds: int(match, cursor + 2, 0),
    milliseconds: parseMillis(match[cursor + 3])
  };
  return [item, null, cursor + 4];
}

function extractISOOffset(match, cursor) {
  var local = !match[cursor] && !match[cursor + 1],
      fullOffset = signedOffset(match[cursor + 1], match[cursor + 2]),
      zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor + 3];
}

function extractIANAZone(match, cursor) {
  var zone = match[cursor] ? IANAZone.create(match[cursor]) : null;
  return [{}, zone, cursor + 1];
} // ISO time parsing


var isoTimeOnly = RegExp("^T?" + isoTimeBaseRegex.source + "$"); // ISO duration parsing

var isoDuration = /^-?P(?:(?:(-?\d{1,9})Y)?(?:(-?\d{1,9})M)?(?:(-?\d{1,9})W)?(?:(-?\d{1,9})D)?(?:T(?:(-?\d{1,9})H)?(?:(-?\d{1,9})M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,9}))?S)?)?)$/;

function extractISODuration(match) {
  var s = match[0],
      yearStr = match[1],
      monthStr = match[2],
      weekStr = match[3],
      dayStr = match[4],
      hourStr = match[5],
      minuteStr = match[6],
      secondStr = match[7],
      millisecondsStr = match[8];
  var hasNegativePrefix = s[0] === "-";

  var maybeNegate = function maybeNegate(num) {
    return num && hasNegativePrefix ? -num : num;
  };

  return [{
    years: maybeNegate(parseInteger(yearStr)),
    months: maybeNegate(parseInteger(monthStr)),
    weeks: maybeNegate(parseInteger(weekStr)),
    days: maybeNegate(parseInteger(dayStr)),
    hours: maybeNegate(parseInteger(hourStr)),
    minutes: maybeNegate(parseInteger(minuteStr)),
    seconds: maybeNegate(parseInteger(secondStr)),
    milliseconds: maybeNegate(parseMillis(millisecondsStr))
  }];
} // These are a little braindead. EDT *should* tell us that we're in, say, America/New_York
// and not just that we're in -240 *right now*. But since I don't think these are used that often
// I'm just going to ignore that


var obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};

function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  var result = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr)
  };
  if (secondStr) result.second = parseInteger(secondStr);

  if (weekdayStr) {
    result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
  }

  return result;
} // RFC 2822/5322


var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;

function extractRFC2822(match) {
  var weekdayStr = match[1],
      dayStr = match[2],
      monthStr = match[3],
      yearStr = match[4],
      hourStr = match[5],
      minuteStr = match[6],
      secondStr = match[7],
      obsOffset = match[8],
      milOffset = match[9],
      offHourStr = match[10],
      offMinuteStr = match[11],
      result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  var offset;

  if (obsOffset) {
    offset = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset = 0;
  } else {
    offset = signedOffset(offHourStr, offMinuteStr);
  }

  return [result, new FixedOffsetZone(offset)];
}

function preprocessRFC2822(s) {
  // Remove comments and folding whitespace and replace multiple-spaces with a single space
  return s.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
} // http date


var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/,
    rfc850 = /^(Monday|Tuesday|Wedsday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/,
    ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;

function extractRFC1123Or850(match) {
  var weekdayStr = match[1],
      dayStr = match[2],
      monthStr = match[3],
      yearStr = match[4],
      hourStr = match[5],
      minuteStr = match[6],
      secondStr = match[7],
      result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}

function extractASCII(match) {
  var weekdayStr = match[1],
      monthStr = match[2],
      dayStr = match[3],
      hourStr = match[4],
      minuteStr = match[5],
      secondStr = match[6],
      yearStr = match[7],
      result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}

var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
var extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset);
var extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset);
var extractISOOrdinalDataAndTime = combineExtractors(extractISOOrdinalData, extractISOTime);
var extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset);
/**
 * @private
 */

function parseISODate(s) {
  return parse(s, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDataAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset]);
}
function parseRFC2822Date(s) {
  return parse(preprocessRFC2822(s), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s) {
  return parse(s, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII]);
}
function parseISODuration(s) {
  return parse(s, [isoDuration, extractISODuration]);
}
var extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(s) {
  return parse(s, [isoTimeOnly, extractISOTimeOnly]);
}
var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
var extractISOYmdTimeOffsetAndIANAZone = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);
var extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
function parseSQL(s) {
  return parse(s, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeOffsetAndIANAZone], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]);
}

var INVALID = "Invalid Duration"; // unit conversion constants

var lowOrderMatrix = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1000
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1000
  },
  hours: {
    minutes: 60,
    seconds: 60 * 60,
    milliseconds: 60 * 60 * 1000
  },
  minutes: {
    seconds: 60,
    milliseconds: 60 * 1000
  },
  seconds: {
    milliseconds: 1000
  }
},
    casualMatrix = Object.assign({
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1000
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1000
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1000
  }
}, lowOrderMatrix),
    daysInYearAccurate = 146097.0 / 400,
    daysInMonthAccurate = 146097.0 / 4800,
    accurateMatrix = Object.assign({
  years: {
    quarters: 4,
    months: 12,
    weeks: daysInYearAccurate / 7,
    days: daysInYearAccurate,
    hours: daysInYearAccurate * 24,
    minutes: daysInYearAccurate * 24 * 60,
    seconds: daysInYearAccurate * 24 * 60 * 60,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000
  },
  quarters: {
    months: 3,
    weeks: daysInYearAccurate / 28,
    days: daysInYearAccurate / 4,
    hours: daysInYearAccurate * 24 / 4,
    minutes: daysInYearAccurate * 24 * 60 / 4,
    seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000 / 4
  },
  months: {
    weeks: daysInMonthAccurate / 7,
    days: daysInMonthAccurate,
    hours: daysInMonthAccurate * 24,
    minutes: daysInMonthAccurate * 24 * 60,
    seconds: daysInMonthAccurate * 24 * 60 * 60,
    milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000
  }
}, lowOrderMatrix); // units ordered by size

var orderedUnits = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"];
var reverseUnits = orderedUnits.slice(0).reverse(); // clone really means "create another instance just like this one, but with these changes"

function clone(dur, alts, clear) {
  if (clear === void 0) {
    clear = false;
  }

  // deep merge for vals
  var conf = {
    values: clear ? alts.values : Object.assign({}, dur.values, alts.values || {}),
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy
  };
  return new Duration(conf);
}

function antiTrunc(n) {
  return n < 0 ? Math.floor(n) : Math.ceil(n);
} // NB: mutates parameters


function convert(matrix, fromMap, fromUnit, toMap, toUnit) {
  var conv = matrix[toUnit][fromUnit],
      raw = fromMap[fromUnit] / conv,
      sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]),
      // ok, so this is wild, but see the matrix in the tests
  added = !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);
  toMap[toUnit] += added;
  fromMap[fromUnit] -= added * conv;
} // NB: mutates parameters


function normalizeValues(matrix, vals) {
  reverseUnits.reduce(function (previous, current) {
    if (!isUndefined(vals[current])) {
      if (previous) {
        convert(matrix, vals, previous, vals, current);
      }

      return current;
    } else {
      return previous;
    }
  }, null);
}
/**
 * A Duration object represents a period of time, like "2 months" or "1 day, 1 hour". Conceptually, it's just a map of units to their quantities, accompanied by some additional configuration and methods for creating, parsing, interrogating, transforming, and formatting them. They can be used on their own or in conjunction with other Luxon types; for example, you can use {@link DateTime.plus} to add a Duration object to a DateTime, producing another DateTime.
 *
 * Here is a brief overview of commonly used methods and getters in Duration:
 *
 * * **Creation** To create a Duration, use {@link Duration.fromMillis}, {@link Duration.fromObject}, or {@link Duration.fromISO}.
 * * **Unit values** See the {@link Duration.years}, {@link Duration.months}, {@link Duration.weeks}, {@link Duration.days}, {@link Duration.hours}, {@link Duration.minutes}, {@link Duration.seconds}, {@link Duration.milliseconds} accessors.
 * * **Configuration** See  {@link Duration.locale} and {@link Duration.numberingSystem} accessors.
 * * **Transformation** To create new Durations out of old ones use {@link Duration.plus}, {@link Duration.minus}, {@link Duration.normalize}, {@link Duration.set}, {@link Duration.reconfigure}, {@link Duration.shiftTo}, and {@link Duration.negate}.
 * * **Output** To convert the Duration into other representations, see {@link Duration.as}, {@link Duration.toISO}, {@link Duration.toFormat}, and {@link Duration.toJSON}
 *
 * There's are more methods documented below. In addition, for more information on subtler topics like internationalization and validity, see the external documentation.
 */


var Duration = /*#__PURE__*/function () {
  /**
   * @private
   */
  function Duration(config) {
    var accurate = config.conversionAccuracy === "longterm" || false;
    /**
     * @access private
     */

    this.values = config.values;
    /**
     * @access private
     */

    this.loc = config.loc || Locale.create();
    /**
     * @access private
     */

    this.conversionAccuracy = accurate ? "longterm" : "casual";
    /**
     * @access private
     */

    this.invalid = config.invalid || null;
    /**
     * @access private
     */

    this.matrix = accurate ? accurateMatrix : casualMatrix;
    /**
     * @access private
     */

    this.isLuxonDuration = true;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */


  Duration.fromMillis = function fromMillis(count, opts) {
    return Duration.fromObject(Object.assign({
      milliseconds: count
    }, opts));
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {string} [obj.locale='en-US'] - the locale to use
   * @param {string} obj.numberingSystem - the numbering system to use
   * @param {string} [obj.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  ;

  Duration.fromObject = function fromObject(obj) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError("Duration.fromObject: argument expected to be an object, got " + (obj === null ? "null" : typeof obj));
    }

    return new Duration({
      values: normalizeObject(obj, Duration.normalizeUnit, ["locale", "numberingSystem", "conversionAccuracy", "zone" // a bit of debt; it's super inconvenient internally not to be able to blindly pass this
      ]),
      loc: Locale.fromObject(obj),
      conversionAccuracy: obj.conversionAccuracy
    });
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  ;

  Duration.fromISO = function fromISO(text, opts) {
    var _parseISODuration = parseISODuration(text),
        parsed = _parseISODuration[0];

    if (parsed) {
      var obj = Object.assign(parsed, opts);
      return Duration.fromObject(obj);
    } else {
      return Duration.invalid("unparsable", "the input \"" + text + "\" can't be parsed as ISO 8601");
    }
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  ;

  Duration.fromISOTime = function fromISOTime(text, opts) {
    var _parseISOTimeOnly = parseISOTimeOnly(text),
        parsed = _parseISOTimeOnly[0];

    if (parsed) {
      var obj = Object.assign(parsed, opts);
      return Duration.fromObject(obj);
    } else {
      return Duration.invalid("unparsable", "the input \"" + text + "\" can't be parsed as ISO 8601");
    }
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  ;

  Duration.invalid = function invalid(reason, explanation) {
    if (explanation === void 0) {
      explanation = null;
    }

    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }

    var invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);

    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new Duration({
        invalid: invalid
      });
    }
  }
  /**
   * @private
   */
  ;

  Duration.normalizeUnit = function normalizeUnit(unit) {
    var normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit ? unit.toLowerCase() : unit];
    if (!normalized) throw new InvalidUnitError(unit);
    return normalized;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  ;

  Duration.isDuration = function isDuration(o) {
    return o && o.isLuxonDuration || false;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  ;

  var _proto = Duration.prototype;

  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * The duration will be converted to the set of units in the format string using {@link Duration.shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  _proto.toFormat = function toFormat(fmt, opts) {
    if (opts === void 0) {
      opts = {};
    }

    // reverse-compat since 1.2; we always round down now, never up, and we do it by default
    var fmtOpts = Object.assign({}, opts, {
      floor: opts.round !== false && opts.floor !== false
    });
    return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID;
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  ;

  _proto.toObject = function toObject(opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (!this.isValid) return {};
    var base = Object.assign({}, this.values);

    if (opts.includeConfig) {
      base.conversionAccuracy = this.conversionAccuracy;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }

    return base;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  ;

  _proto.toISO = function toISO() {
    // we could use the formatter, but this is an easier way to get the minimum string
    if (!this.isValid) return null;
    var s = "P";
    if (this.years !== 0) s += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0) s += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0) s += this.weeks + "W";
    if (this.days !== 0) s += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) s += "T";
    if (this.hours !== 0) s += this.hours + "H";
    if (this.minutes !== 0) s += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0) // this will handle "floating point madness" by removing extra decimal places
      // https://stackoverflow.com/questions/588004/is-floating-point-math-broken
      s += roundTo(this.seconds + this.milliseconds / 1000, 3) + "S";
    if (s === "P") s += "T0S";
    return s;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  ;

  _proto.toISOTime = function toISOTime(opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (!this.isValid) return null;
    var millis = this.toMillis();
    if (millis < 0 || millis >= 86400000) return null;
    opts = Object.assign({
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended"
    }, opts);
    var value = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
    var fmt = opts.format === "basic" ? "hhmm" : "hh:mm";

    if (!opts.suppressSeconds || value.seconds !== 0 || value.milliseconds !== 0) {
      fmt += opts.format === "basic" ? "ss" : ":ss";

      if (!opts.suppressMilliseconds || value.milliseconds !== 0) {
        fmt += ".SSS";
      }
    }

    var str = value.toFormat(fmt);

    if (opts.includePrefix) {
      str = "T" + str;
    }

    return str;
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  ;

  _proto.toJSON = function toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  ;

  _proto.toString = function toString() {
    return this.toISO();
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  ;

  _proto.toMillis = function toMillis() {
    return this.as("milliseconds");
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  ;

  _proto.valueOf = function valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  ;

  _proto.plus = function plus(duration) {
    if (!this.isValid) return this;
    var dur = friendlyDuration(duration),
        result = {};

    for (var _iterator = _createForOfIteratorHelperLoose(orderedUnits), _step; !(_step = _iterator()).done;) {
      var k = _step.value;

      if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
        result[k] = dur.get(k) + this.get(k);
      }
    }

    return clone(this, {
      values: result
    }, true);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  ;

  _proto.minus = function minus(duration) {
    if (!this.isValid) return this;
    var dur = friendlyDuration(duration);
    return this.plus(dur.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnit(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnit((x, u) => u === "hour" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  ;

  _proto.mapUnits = function mapUnits(fn) {
    if (!this.isValid) return this;
    var result = {};

    for (var _i = 0, _Object$keys = Object.keys(this.values); _i < _Object$keys.length; _i++) {
      var k = _Object$keys[_i];
      result[k] = asNumber(fn(this.values[k], k));
    }

    return clone(this, {
      values: result
    }, true);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).years //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).months //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).days //=> 3
   * @return {number}
   */
  ;

  _proto.get = function get(unit) {
    return this[Duration.normalizeUnit(unit)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  ;

  _proto.set = function set(values) {
    if (!this.isValid) return this;
    var mixed = Object.assign(this.values, normalizeObject(values, Duration.normalizeUnit, []));
    return clone(this, {
      values: mixed
    });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  ;

  _proto.reconfigure = function reconfigure(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        locale = _ref.locale,
        numberingSystem = _ref.numberingSystem,
        conversionAccuracy = _ref.conversionAccuracy;

    var loc = this.loc.clone({
      locale: locale,
      numberingSystem: numberingSystem
    }),
        opts = {
      loc: loc
    };

    if (conversionAccuracy) {
      opts.conversionAccuracy = conversionAccuracy;
    }

    return clone(this, opts);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  ;

  _proto.as = function as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @return {Duration}
   */
  ;

  _proto.normalize = function normalize() {
    if (!this.isValid) return this;
    var vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone(this, {
      values: vals
    }, true);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  ;

  _proto.shiftTo = function shiftTo() {
    for (var _len = arguments.length, units = new Array(_len), _key = 0; _key < _len; _key++) {
      units[_key] = arguments[_key];
    }

    if (!this.isValid) return this;

    if (units.length === 0) {
      return this;
    }

    units = units.map(function (u) {
      return Duration.normalizeUnit(u);
    });
    var built = {},
        accumulated = {},
        vals = this.toObject();
    var lastUnit;

    for (var _iterator2 = _createForOfIteratorHelperLoose(orderedUnits), _step2; !(_step2 = _iterator2()).done;) {
      var k = _step2.value;

      if (units.indexOf(k) >= 0) {
        lastUnit = k;
        var own = 0; // anything we haven't boiled down yet should get boiled to this unit

        for (var ak in accumulated) {
          own += this.matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        } // plus anything that's already in this unit


        if (isNumber(vals[k])) {
          own += vals[k];
        }

        var i = Math.trunc(own);
        built[k] = i;
        accumulated[k] = own - i; // we'd like to absorb these fractions in another unit
        // plus anything further down the chain that should be rolled up in to this

        for (var down in vals) {
          if (orderedUnits.indexOf(down) > orderedUnits.indexOf(k)) {
            convert(this.matrix, vals, down, built, k);
          }
        } // otherwise, keep it in the wings to boil it later

      } else if (isNumber(vals[k])) {
        accumulated[k] = vals[k];
      }
    } // anything leftover becomes the decimal for the last unit
    // lastUnit must be defined since units is not empty


    for (var key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }

    return clone(this, {
      values: built
    }, true).normalize();
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  ;

  _proto.negate = function negate() {
    if (!this.isValid) return this;
    var negated = {};

    for (var _i2 = 0, _Object$keys2 = Object.keys(this.values); _i2 < _Object$keys2.length; _i2++) {
      var k = _Object$keys2[_i2];
      negated[k] = -this.values[k];
    }

    return clone(this, {
      values: negated
    }, true);
  }
  /**
   * Get the years.
   * @type {number}
   */
  ;

  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  _proto.equals = function equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }

    if (!this.loc.equals(other.loc)) {
      return false;
    }

    function eq(v1, v2) {
      // Consider 0 and undefined as equal
      if (v1 === undefined || v1 === 0) return v2 === undefined || v2 === 0;
      return v1 === v2;
    }

    for (var _iterator3 = _createForOfIteratorHelperLoose(orderedUnits), _step3; !(_step3 = _iterator3()).done;) {
      var u = _step3.value;

      if (!eq(this.values[u], other.values[u])) {
        return false;
      }
    }

    return true;
  };

  _createClass(Duration, [{
    key: "locale",
    get: function get() {
      return this.isValid ? this.loc.locale : null;
    }
    /**
     * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
     *
     * @type {string}
     */

  }, {
    key: "numberingSystem",
    get: function get() {
      return this.isValid ? this.loc.numberingSystem : null;
    }
  }, {
    key: "years",
    get: function get() {
      return this.isValid ? this.values.years || 0 : NaN;
    }
    /**
     * Get the quarters.
     * @type {number}
     */

  }, {
    key: "quarters",
    get: function get() {
      return this.isValid ? this.values.quarters || 0 : NaN;
    }
    /**
     * Get the months.
     * @type {number}
     */

  }, {
    key: "months",
    get: function get() {
      return this.isValid ? this.values.months || 0 : NaN;
    }
    /**
     * Get the weeks
     * @type {number}
     */

  }, {
    key: "weeks",
    get: function get() {
      return this.isValid ? this.values.weeks || 0 : NaN;
    }
    /**
     * Get the days.
     * @type {number}
     */

  }, {
    key: "days",
    get: function get() {
      return this.isValid ? this.values.days || 0 : NaN;
    }
    /**
     * Get the hours.
     * @type {number}
     */

  }, {
    key: "hours",
    get: function get() {
      return this.isValid ? this.values.hours || 0 : NaN;
    }
    /**
     * Get the minutes.
     * @type {number}
     */

  }, {
    key: "minutes",
    get: function get() {
      return this.isValid ? this.values.minutes || 0 : NaN;
    }
    /**
     * Get the seconds.
     * @return {number}
     */

  }, {
    key: "seconds",
    get: function get() {
      return this.isValid ? this.values.seconds || 0 : NaN;
    }
    /**
     * Get the milliseconds.
     * @return {number}
     */

  }, {
    key: "milliseconds",
    get: function get() {
      return this.isValid ? this.values.milliseconds || 0 : NaN;
    }
    /**
     * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
     * on invalid DateTimes or Intervals.
     * @return {boolean}
     */

  }, {
    key: "isValid",
    get: function get() {
      return this.invalid === null;
    }
    /**
     * Returns an error code if this Duration became invalid, or null if the Duration is valid
     * @return {string}
     */

  }, {
    key: "invalidReason",
    get: function get() {
      return this.invalid ? this.invalid.reason : null;
    }
    /**
     * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
     * @type {string}
     */

  }, {
    key: "invalidExplanation",
    get: function get() {
      return this.invalid ? this.invalid.explanation : null;
    }
  }]);

  return Duration;
}();
function friendlyDuration(durationish) {
  if (isNumber(durationish)) {
    return Duration.fromMillis(durationish);
  } else if (Duration.isDuration(durationish)) {
    return durationish;
  } else if (typeof durationish === "object") {
    return Duration.fromObject(durationish);
  } else {
    throw new InvalidArgumentError("Unknown duration argument " + durationish + " of type " + typeof durationish);
  }
}

var INVALID$1 = "Invalid Interval"; // checks if the start is equal to or before the end

function validateStartEnd(start, end) {
  if (!start || !start.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end || !end.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end < start) {
    return Interval.invalid("end before start", "The end of an interval must be after its start, but you had start=" + start.toISO() + " and end=" + end.toISO());
  } else {
    return null;
  }
}
/**
 * An Interval object represents a half-open interval of time, where each endpoint is a {@link DateTime}. Conceptually, it's a container for those two endpoints, accompanied by methods for creating, parsing, interrogating, comparing, transforming, and formatting them.
 *
 * Here is a brief overview of the most commonly used methods and getters in Interval:
 *
 * * **Creation** To create an Interval, use {@link fromDateTimes}, {@link after}, {@link before}, or {@link fromISO}.
 * * **Accessors** Use {@link start} and {@link end} to get the start and end.
 * * **Interrogation** To analyze the Interval, use {@link count}, {@link length}, {@link hasSame}, {@link contains}, {@link isAfter}, or {@link isBefore}.
 * * **Transformation** To create other Intervals out of this one, use {@link set}, {@link splitAt}, {@link splitBy}, {@link divideEqually}, {@link merge}, {@link xor}, {@link union}, {@link intersection}, or {@link difference}.
 * * **Comparison** To compare this Interval to another one, use {@link equals}, {@link overlaps}, {@link abutsStart}, {@link abutsEnd}, {@link engulfs}.
 * * **Output** To convert the Interval into other representations, see {@link toString}, {@link toISO}, {@link toISODate}, {@link toISOTime}, {@link toFormat}, and {@link toDuration}.
 */


var Interval = /*#__PURE__*/function () {
  /**
   * @private
   */
  function Interval(config) {
    /**
     * @access private
     */
    this.s = config.start;
    /**
     * @access private
     */

    this.e = config.end;
    /**
     * @access private
     */

    this.invalid = config.invalid || null;
    /**
     * @access private
     */

    this.isLuxonInterval = true;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */


  Interval.invalid = function invalid(reason, explanation) {
    if (explanation === void 0) {
      explanation = null;
    }

    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }

    var invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);

    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new Interval({
        invalid: invalid
      });
    }
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  ;

  Interval.fromDateTimes = function fromDateTimes(start, end) {
    var builtStart = friendlyDateTime(start),
        builtEnd = friendlyDateTime(end);
    var validateError = validateStartEnd(builtStart, builtEnd);

    if (validateError == null) {
      return new Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  ;

  Interval.after = function after(start, duration) {
    var dur = friendlyDuration(duration),
        dt = friendlyDateTime(start);
    return Interval.fromDateTimes(dt, dt.plus(dur));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  ;

  Interval.before = function before(end, duration) {
    var dur = friendlyDuration(duration),
        dt = friendlyDateTime(end);
    return Interval.fromDateTimes(dt.minus(dur), dt);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime.fromISO} and optionally {@link Duration.fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  ;

  Interval.fromISO = function fromISO(text, opts) {
    var _split = (text || "").split("/", 2),
        s = _split[0],
        e = _split[1];

    if (s && e) {
      var start, startIsValid;

      try {
        start = DateTime.fromISO(s, opts);
        startIsValid = start.isValid;
      } catch (e) {
        startIsValid = false;
      }

      var end, endIsValid;

      try {
        end = DateTime.fromISO(e, opts);
        endIsValid = end.isValid;
      } catch (e) {
        endIsValid = false;
      }

      if (startIsValid && endIsValid) {
        return Interval.fromDateTimes(start, end);
      }

      if (startIsValid) {
        var dur = Duration.fromISO(e, opts);

        if (dur.isValid) {
          return Interval.after(start, dur);
        }
      } else if (endIsValid) {
        var _dur = Duration.fromISO(s, opts);

        if (_dur.isValid) {
          return Interval.before(end, _dur);
        }
      }
    }

    return Interval.invalid("unparsable", "the input \"" + text + "\" can't be parsed as ISO 8601");
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  ;

  Interval.isInterval = function isInterval(o) {
    return o && o.isLuxonInterval || false;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  ;

  var _proto = Interval.prototype;

  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  _proto.length = function length(unit) {
    if (unit === void 0) {
      unit = "milliseconds";
    }

    return this.isValid ? this.toDuration.apply(this, [unit]).get(unit) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @return {number}
   */
  ;

  _proto.count = function count(unit) {
    if (unit === void 0) {
      unit = "milliseconds";
    }

    if (!this.isValid) return NaN;
    var start = this.start.startOf(unit),
        end = this.end.startOf(unit);
    return Math.floor(end.diff(start, unit).get(unit)) + 1;
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  ;

  _proto.hasSame = function hasSame(unit) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  ;

  _proto.isEmpty = function isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  ;

  _proto.isAfter = function isAfter(dateTime) {
    if (!this.isValid) return false;
    return this.s > dateTime;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  ;

  _proto.isBefore = function isBefore(dateTime) {
    if (!this.isValid) return false;
    return this.e <= dateTime;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  ;

  _proto.contains = function contains(dateTime) {
    if (!this.isValid) return false;
    return this.s <= dateTime && this.e > dateTime;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  ;

  _proto.set = function set(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        start = _ref.start,
        end = _ref.end;

    if (!this.isValid) return this;
    return Interval.fromDateTimes(start || this.s, end || this.e);
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...[DateTime]} dateTimes - the unit of time to count.
   * @return {[Interval]}
   */
  ;

  _proto.splitAt = function splitAt() {
    var _this = this;

    if (!this.isValid) return [];

    for (var _len = arguments.length, dateTimes = new Array(_len), _key = 0; _key < _len; _key++) {
      dateTimes[_key] = arguments[_key];
    }

    var sorted = dateTimes.map(friendlyDateTime).filter(function (d) {
      return _this.contains(d);
    }).sort(),
        results = [];
    var s = this.s,
        i = 0;

    while (s < this.e) {
      var added = sorted[i] || this.e,
          next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s, next));
      s = next;
      i += 1;
    }

    return results;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {[Interval]}
   */
  ;

  _proto.splitBy = function splitBy(duration) {
    var dur = friendlyDuration(duration);

    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }

    var s = this.s,
        added,
        next;
    var results = [];

    while (s < this.e) {
      added = s.plus(dur);
      next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s, next));
      s = next;
    }

    return results;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {[Interval]}
   */
  ;

  _proto.divideEqually = function divideEqually(numberOfParts) {
    if (!this.isValid) return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  ;

  _proto.overlaps = function overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  ;

  _proto.abutsStart = function abutsStart(other) {
    if (!this.isValid) return false;
    return +this.e === +other.s;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  ;

  _proto.abutsEnd = function abutsEnd(other) {
    if (!this.isValid) return false;
    return +other.e === +this.s;
  }
  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  ;

  _proto.engulfs = function engulfs(other) {
    if (!this.isValid) return false;
    return this.s <= other.s && this.e >= other.e;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  ;

  _proto.equals = function equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }

    return this.s.equals(other.s) && this.e.equals(other.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  ;

  _proto.intersection = function intersection(other) {
    if (!this.isValid) return this;
    var s = this.s > other.s ? this.s : other.s,
        e = this.e < other.e ? this.e : other.e;

    if (s > e) {
      return null;
    } else {
      return Interval.fromDateTimes(s, e);
    }
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  ;

  _proto.union = function union(other) {
    if (!this.isValid) return this;
    var s = this.s < other.s ? this.s : other.s,
        e = this.e > other.e ? this.e : other.e;
    return Interval.fromDateTimes(s, e);
  }
  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {[Interval]} intervals
   * @return {[Interval]}
   */
  ;

  Interval.merge = function merge(intervals) {
    var _intervals$sort$reduc = intervals.sort(function (a, b) {
      return a.s - b.s;
    }).reduce(function (_ref2, item) {
      var sofar = _ref2[0],
          current = _ref2[1];

      if (!current) {
        return [sofar, item];
      } else if (current.overlaps(item) || current.abutsStart(item)) {
        return [sofar, current.union(item)];
      } else {
        return [sofar.concat([current]), item];
      }
    }, [[], null]),
        found = _intervals$sort$reduc[0],
        final = _intervals$sort$reduc[1];

    if (final) {
      found.push(final);
    }

    return found;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {[Interval]} intervals
   * @return {[Interval]}
   */
  ;

  Interval.xor = function xor(intervals) {
    var _Array$prototype;

    var start = null,
        currentCount = 0;

    var results = [],
        ends = intervals.map(function (i) {
      return [{
        time: i.s,
        type: "s"
      }, {
        time: i.e,
        type: "e"
      }];
    }),
        flattened = (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, ends),
        arr = flattened.sort(function (a, b) {
      return a.time - b.time;
    });

    for (var _iterator = _createForOfIteratorHelperLoose(arr), _step; !(_step = _iterator()).done;) {
      var i = _step.value;
      currentCount += i.type === "s" ? 1 : -1;

      if (currentCount === 1) {
        start = i.time;
      } else {
        if (start && +start !== +i.time) {
          results.push(Interval.fromDateTimes(start, i.time));
        }

        start = null;
      }
    }

    return Interval.merge(results);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {[Interval]}
   */
  ;

  _proto.difference = function difference() {
    var _this2 = this;

    for (var _len2 = arguments.length, intervals = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      intervals[_key2] = arguments[_key2];
    }

    return Interval.xor([this].concat(intervals)).map(function (i) {
      return _this2.intersection(i);
    }).filter(function (i) {
      return i && !i.isEmpty();
    });
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  ;

  _proto.toString = function toString() {
    if (!this.isValid) return INVALID$1;
    return "[" + this.s.toISO() + " \u2013 " + this.e.toISO() + ")";
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime.toISO}
   * @return {string}
   */
  ;

  _proto.toISO = function toISO(opts) {
    if (!this.isValid) return INVALID$1;
    return this.s.toISO(opts) + "/" + this.e.toISO(opts);
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  ;

  _proto.toISODate = function toISODate() {
    if (!this.isValid) return INVALID$1;
    return this.s.toISODate() + "/" + this.e.toISODate();
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime.toISO}
   * @return {string}
   */
  ;

  _proto.toISOTime = function toISOTime(opts) {
    if (!this.isValid) return INVALID$1;
    return this.s.toISOTime(opts) + "/" + this.e.toISOTime(opts);
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format string.
   * @param {string} dateFormat - the format string. This string formats the start and end time. See {@link DateTime.toFormat} for details.
   * @param {Object} opts - options
   * @param {string} [opts.separator =  ' – '] - a separator to place between the start and end representations
   * @return {string}
   */
  ;

  _proto.toFormat = function toFormat(dateFormat, _temp2) {
    var _ref3 = _temp2 === void 0 ? {} : _temp2,
        _ref3$separator = _ref3.separator,
        separator = _ref3$separator === void 0 ? " – " : _ref3$separator;

    if (!this.isValid) return INVALID$1;
    return "" + this.s.toFormat(dateFormat) + separator + this.e.toFormat(dateFormat);
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  ;

  _proto.toDuration = function toDuration(unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }

    return this.e.diff(this.s, unit, opts);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  ;

  _proto.mapEndpoints = function mapEndpoints(mapFn) {
    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  };

  _createClass(Interval, [{
    key: "start",
    get: function get() {
      return this.isValid ? this.s : null;
    }
    /**
     * Returns the end of the Interval
     * @type {DateTime}
     */

  }, {
    key: "end",
    get: function get() {
      return this.isValid ? this.e : null;
    }
    /**
     * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
     * @type {boolean}
     */

  }, {
    key: "isValid",
    get: function get() {
      return this.invalidReason === null;
    }
    /**
     * Returns an error code if this Interval is invalid, or null if the Interval is valid
     * @type {string}
     */

  }, {
    key: "invalidReason",
    get: function get() {
      return this.invalid ? this.invalid.reason : null;
    }
    /**
     * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
     * @type {string}
     */

  }, {
    key: "invalidExplanation",
    get: function get() {
      return this.invalid ? this.invalid.explanation : null;
    }
  }]);

  return Interval;
}();

/**
 * The Info class contains static methods for retrieving general time and date related data. For example, it has methods for finding out if a time zone has a DST, for listing the months in any supported locale, and for discovering which of Luxon features are available in the current environment.
 */

var Info = /*#__PURE__*/function () {
  function Info() {}

  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  Info.hasDST = function hasDST(zone) {
    if (zone === void 0) {
      zone = Settings.defaultZone;
    }

    var proto = DateTime.now().setZone(zone).set({
      month: 12
    });
    return !zone.universal && proto.offset !== proto.set({
      month: 6
    }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  ;

  Info.isValidIANAZone = function isValidIANAZone(zone) {
    return IANAZone.isValidSpecifier(zone) && IANAZone.isValidZone(zone);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone.isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  ;

  Info.normalizeZone = function normalizeZone$1(input) {
    return normalizeZone(input, Settings.defaultZone);
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
   * @return {[string]}
   */
  ;

  Info.months = function months(length, _temp) {
    if (length === void 0) {
      length = "long";
    }

    var _ref = _temp === void 0 ? {} : _temp,
        _ref$locale = _ref.locale,
        locale = _ref$locale === void 0 ? null : _ref$locale,
        _ref$numberingSystem = _ref.numberingSystem,
        numberingSystem = _ref$numberingSystem === void 0 ? null : _ref$numberingSystem,
        _ref$outputCalendar = _ref.outputCalendar,
        outputCalendar = _ref$outputCalendar === void 0 ? "gregory" : _ref$outputCalendar;

    return Locale.create(locale, numberingSystem, outputCalendar).months(length);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {[string]}
   */
  ;

  Info.monthsFormat = function monthsFormat(length, _temp2) {
    if (length === void 0) {
      length = "long";
    }

    var _ref2 = _temp2 === void 0 ? {} : _temp2,
        _ref2$locale = _ref2.locale,
        locale = _ref2$locale === void 0 ? null : _ref2$locale,
        _ref2$numberingSystem = _ref2.numberingSystem,
        numberingSystem = _ref2$numberingSystem === void 0 ? null : _ref2$numberingSystem,
        _ref2$outputCalendar = _ref2.outputCalendar,
        outputCalendar = _ref2$outputCalendar === void 0 ? "gregory" : _ref2$outputCalendar;

    return Locale.create(locale, numberingSystem, outputCalendar).months(length, true);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
   * @return {[string]}
   */
  ;

  Info.weekdays = function weekdays(length, _temp3) {
    if (length === void 0) {
      length = "long";
    }

    var _ref3 = _temp3 === void 0 ? {} : _temp3,
        _ref3$locale = _ref3.locale,
        locale = _ref3$locale === void 0 ? null : _ref3$locale,
        _ref3$numberingSystem = _ref3.numberingSystem,
        numberingSystem = _ref3$numberingSystem === void 0 ? null : _ref3$numberingSystem;

    return Locale.create(locale, numberingSystem, null).weekdays(length);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link weekdays}
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @return {[string]}
   */
  ;

  Info.weekdaysFormat = function weekdaysFormat(length, _temp4) {
    if (length === void 0) {
      length = "long";
    }

    var _ref4 = _temp4 === void 0 ? {} : _temp4,
        _ref4$locale = _ref4.locale,
        locale = _ref4$locale === void 0 ? null : _ref4$locale,
        _ref4$numberingSystem = _ref4.numberingSystem,
        numberingSystem = _ref4$numberingSystem === void 0 ? null : _ref4$numberingSystem;

    return Locale.create(locale, numberingSystem, null).weekdays(length, true);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
   * @return {[string]}
   */
  ;

  Info.meridiems = function meridiems(_temp5) {
    var _ref5 = _temp5 === void 0 ? {} : _temp5,
        _ref5$locale = _ref5.locale,
        locale = _ref5$locale === void 0 ? null : _ref5$locale;

    return Locale.create(locale).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
   * @return {[string]}
   */
  ;

  Info.eras = function eras(length, _temp6) {
    if (length === void 0) {
      length = "short";
    }

    var _ref6 = _temp6 === void 0 ? {} : _temp6,
        _ref6$locale = _ref6.locale,
        locale = _ref6$locale === void 0 ? null : _ref6$locale;

    return Locale.create(locale, null, "gregory").eras(length);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, timezone support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `zones`: whether this environment supports IANA timezones
   * * `intlTokens`: whether this environment supports internationalized token-based formatting/parsing
   * * `intl`: whether this environment supports general internationalization
   * * `relative`: whether this environment supports relative time formatting
   * @example Info.features() //=> { intl: true, intlTokens: false, zones: true, relative: false }
   * @return {Object}
   */
  ;

  Info.features = function features() {
    var intl = false,
        intlTokens = false,
        zones = false,
        relative = false;

    if (hasIntl()) {
      intl = true;
      intlTokens = hasFormatToParts();
      relative = hasRelative();

      try {
        zones = new Intl.DateTimeFormat("en", {
          timeZone: "America/New_York"
        }).resolvedOptions().timeZone === "America/New_York";
      } catch (e) {
        zones = false;
      }
    }

    return {
      intl: intl,
      intlTokens: intlTokens,
      zones: zones,
      relative: relative
    };
  };

  return Info;
}();

function dayDiff(earlier, later) {
  var utcDayStart = function utcDayStart(dt) {
    return dt.toUTC(0, {
      keepLocalTime: true
    }).startOf("day").valueOf();
  },
      ms = utcDayStart(later) - utcDayStart(earlier);

  return Math.floor(Duration.fromMillis(ms).as("days"));
}

function highOrderDiffs(cursor, later, units) {
  var differs = [["years", function (a, b) {
    return b.year - a.year;
  }], ["quarters", function (a, b) {
    return b.quarter - a.quarter;
  }], ["months", function (a, b) {
    return b.month - a.month + (b.year - a.year) * 12;
  }], ["weeks", function (a, b) {
    var days = dayDiff(a, b);
    return (days - days % 7) / 7;
  }], ["days", dayDiff]];
  var results = {};
  var lowestOrder, highWater;

  for (var _i = 0, _differs = differs; _i < _differs.length; _i++) {
    var _differs$_i = _differs[_i],
        unit = _differs$_i[0],
        differ = _differs$_i[1];

    if (units.indexOf(unit) >= 0) {
      var _cursor$plus;

      lowestOrder = unit;
      var delta = differ(cursor, later);
      highWater = cursor.plus((_cursor$plus = {}, _cursor$plus[unit] = delta, _cursor$plus));

      if (highWater > later) {
        var _cursor$plus2;

        cursor = cursor.plus((_cursor$plus2 = {}, _cursor$plus2[unit] = delta - 1, _cursor$plus2));
        delta -= 1;
      } else {
        cursor = highWater;
      }

      results[unit] = delta;
    }
  }

  return [cursor, results, highWater, lowestOrder];
}

function _diff (earlier, later, units, opts) {
  var _highOrderDiffs = highOrderDiffs(earlier, later, units),
      cursor = _highOrderDiffs[0],
      results = _highOrderDiffs[1],
      highWater = _highOrderDiffs[2],
      lowestOrder = _highOrderDiffs[3];

  var remainingMillis = later - cursor;
  var lowerOrderUnits = units.filter(function (u) {
    return ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0;
  });

  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      var _cursor$plus3;

      highWater = cursor.plus((_cursor$plus3 = {}, _cursor$plus3[lowestOrder] = 1, _cursor$plus3));
    }

    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }

  var duration = Duration.fromObject(Object.assign(results, opts));

  if (lowerOrderUnits.length > 0) {
    var _Duration$fromMillis;

    return (_Duration$fromMillis = Duration.fromMillis(remainingMillis, opts)).shiftTo.apply(_Duration$fromMillis, lowerOrderUnits).plus(duration);
  } else {
    return duration;
  }
}

var numberingSystems = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[〇|一|二|三|四|五|六|七|八|九]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d"
};
var numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
}; // eslint-disable-next-line

var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str) {
  var value = parseInt(str, 10);

  if (isNaN(value)) {
    value = "";

    for (var i = 0; i < str.length; i++) {
      var code = str.charCodeAt(i);

      if (str[i].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i]);
      } else {
        for (var key in numberingSystemsUTF16) {
          var _numberingSystemsUTF = numberingSystemsUTF16[key],
              min = _numberingSystemsUTF[0],
              max = _numberingSystemsUTF[1];

          if (code >= min && code <= max) {
            value += code - min;
          }
        }
      }
    }

    return parseInt(value, 10);
  } else {
    return value;
  }
}
function digitRegex(_ref, append) {
  var numberingSystem = _ref.numberingSystem;

  if (append === void 0) {
    append = "";
  }

  return new RegExp("" + numberingSystems[numberingSystem || "latn"] + append);
}

var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";

function intUnit(regex, post) {
  if (post === void 0) {
    post = function post(i) {
      return i;
    };
  }

  return {
    regex: regex,
    deser: function deser(_ref) {
      var s = _ref[0];
      return post(parseDigits(s));
    }
  };
}

var NBSP = String.fromCharCode(160);
var spaceOrNBSP = "( |" + NBSP + ")";
var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");

function fixListRegex(s) {
  // make dots optional and also make them literal
  // make space and non breakable space characters interchangeable
  return s.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}

function stripInsensitivities(s) {
  return s.replace(/\./g, "") // ignore dots that were made optional
  .replace(spaceOrNBSPRegExp, " ") // interchange space and nbsp
  .toLowerCase();
}

function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: function deser(_ref2) {
        var s = _ref2[0];
        return strings.findIndex(function (i) {
          return stripInsensitivities(s) === stripInsensitivities(i);
        }) + startIndex;
      }
    };
  }
}

function offset(regex, groups) {
  return {
    regex: regex,
    deser: function deser(_ref3) {
      var h = _ref3[1],
          m = _ref3[2];
      return signedOffset(h, m);
    },
    groups: groups
  };
}

function simple(regex) {
  return {
    regex: regex,
    deser: function deser(_ref4) {
      var s = _ref4[0];
      return s;
    }
  };
}

function escapeToken(value) {
  // eslint-disable-next-line no-useless-escape
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}

function unitForToken(token, loc) {
  var one = digitRegex(loc),
      two = digitRegex(loc, "{2}"),
      three = digitRegex(loc, "{3}"),
      four = digitRegex(loc, "{4}"),
      six = digitRegex(loc, "{6}"),
      oneOrTwo = digitRegex(loc, "{1,2}"),
      oneToThree = digitRegex(loc, "{1,3}"),
      oneToSix = digitRegex(loc, "{1,6}"),
      oneToNine = digitRegex(loc, "{1,9}"),
      twoToFour = digitRegex(loc, "{2,4}"),
      fourToSix = digitRegex(loc, "{4,6}"),
      literal = function literal(t) {
    return {
      regex: RegExp(escapeToken(t.val)),
      deser: function deser(_ref5) {
        var s = _ref5[0];
        return s;
      },
      literal: true
    };
  },
      unitate = function unitate(t) {
    if (token.literal) {
      return literal(t);
    }

    switch (t.val) {
      // era
      case "G":
        return oneOf(loc.eras("short", false), 0);

      case "GG":
        return oneOf(loc.eras("long", false), 0);
      // years

      case "y":
        return intUnit(oneToSix);

      case "yy":
        return intUnit(twoToFour, untruncateYear);

      case "yyyy":
        return intUnit(four);

      case "yyyyy":
        return intUnit(fourToSix);

      case "yyyyyy":
        return intUnit(six);
      // months

      case "M":
        return intUnit(oneOrTwo);

      case "MM":
        return intUnit(two);

      case "MMM":
        return oneOf(loc.months("short", true, false), 1);

      case "MMMM":
        return oneOf(loc.months("long", true, false), 1);

      case "L":
        return intUnit(oneOrTwo);

      case "LL":
        return intUnit(two);

      case "LLL":
        return oneOf(loc.months("short", false, false), 1);

      case "LLLL":
        return oneOf(loc.months("long", false, false), 1);
      // dates

      case "d":
        return intUnit(oneOrTwo);

      case "dd":
        return intUnit(two);
      // ordinals

      case "o":
        return intUnit(oneToThree);

      case "ooo":
        return intUnit(three);
      // time

      case "HH":
        return intUnit(two);

      case "H":
        return intUnit(oneOrTwo);

      case "hh":
        return intUnit(two);

      case "h":
        return intUnit(oneOrTwo);

      case "mm":
        return intUnit(two);

      case "m":
        return intUnit(oneOrTwo);

      case "q":
        return intUnit(oneOrTwo);

      case "qq":
        return intUnit(two);

      case "s":
        return intUnit(oneOrTwo);

      case "ss":
        return intUnit(two);

      case "S":
        return intUnit(oneToThree);

      case "SSS":
        return intUnit(three);

      case "u":
        return simple(oneToNine);
      // meridiem

      case "a":
        return oneOf(loc.meridiems(), 0);
      // weekYear (k)

      case "kkkk":
        return intUnit(four);

      case "kk":
        return intUnit(twoToFour, untruncateYear);
      // weekNumber (W)

      case "W":
        return intUnit(oneOrTwo);

      case "WW":
        return intUnit(two);
      // weekdays

      case "E":
      case "c":
        return intUnit(one);

      case "EEE":
        return oneOf(loc.weekdays("short", false, false), 1);

      case "EEEE":
        return oneOf(loc.weekdays("long", false, false), 1);

      case "ccc":
        return oneOf(loc.weekdays("short", true, false), 1);

      case "cccc":
        return oneOf(loc.weekdays("long", true, false), 1);
      // offset/zone

      case "Z":
      case "ZZ":
        return offset(new RegExp("([+-]" + oneOrTwo.source + ")(?::(" + two.source + "))?"), 2);

      case "ZZZ":
        return offset(new RegExp("([+-]" + oneOrTwo.source + ")(" + two.source + ")?"), 2);
      // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing
      // because we don't have any way to figure out what they are

      case "z":
        return simple(/[a-z_+-/]{1,256}?/i);

      default:
        return literal(t);
    }
  };

  var unit = unitate(token) || {
    invalidReason: MISSING_FTP
  };
  unit.token = token;
  return unit;
}

var partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour: {
    numeric: "h",
    "2-digit": "hh"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  }
};

function tokenForPart(part, locale, formatOpts) {
  var type = part.type,
      value = part.value;

  if (type === "literal") {
    return {
      literal: true,
      val: value
    };
  }

  var style = formatOpts[type];
  var val = partTypeStyleToTokenVal[type];

  if (typeof val === "object") {
    val = val[style];
  }

  if (val) {
    return {
      literal: false,
      val: val
    };
  }

  return undefined;
}

function buildRegex(units) {
  var re = units.map(function (u) {
    return u.regex;
  }).reduce(function (f, r) {
    return f + "(" + r.source + ")";
  }, "");
  return ["^" + re + "$", units];
}

function match(input, regex, handlers) {
  var matches = input.match(regex);

  if (matches) {
    var all = {};
    var matchIndex = 1;

    for (var i in handlers) {
      if (hasOwnProperty(handlers, i)) {
        var h = handlers[i],
            groups = h.groups ? h.groups + 1 : 1;

        if (!h.literal && h.token) {
          all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
        }

        matchIndex += groups;
      }
    }

    return [matches, all];
  } else {
    return [matches, {}];
  }
}

function dateTimeFromMatches(matches) {
  var toField = function toField(token) {
    switch (token) {
      case "S":
        return "millisecond";

      case "s":
        return "second";

      case "m":
        return "minute";

      case "h":
      case "H":
        return "hour";

      case "d":
        return "day";

      case "o":
        return "ordinal";

      case "L":
      case "M":
        return "month";

      case "y":
        return "year";

      case "E":
      case "c":
        return "weekday";

      case "W":
        return "weekNumber";

      case "k":
        return "weekYear";

      case "q":
        return "quarter";

      default:
        return null;
    }
  };

  var zone;

  if (!isUndefined(matches.Z)) {
    zone = new FixedOffsetZone(matches.Z);
  } else if (!isUndefined(matches.z)) {
    zone = IANAZone.create(matches.z);
  } else {
    zone = null;
  }

  if (!isUndefined(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }

  if (!isUndefined(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }

  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }

  if (!isUndefined(matches.u)) {
    matches.S = parseMillis(matches.u);
  }

  var vals = Object.keys(matches).reduce(function (r, k) {
    var f = toField(k);

    if (f) {
      r[f] = matches[k];
    }

    return r;
  }, {});
  return [vals, zone];
}

var dummyDateTimeCache = null;

function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }

  return dummyDateTimeCache;
}

function maybeExpandMacroToken(token, locale) {
  if (token.literal) {
    return token;
  }

  var formatOpts = Formatter.macroTokenToFormatOpts(token.val);

  if (!formatOpts) {
    return token;
  }

  var formatter = Formatter.create(locale, formatOpts);
  var parts = formatter.formatDateTimeParts(getDummyDateTime());
  var tokens = parts.map(function (p) {
    return tokenForPart(p, locale, formatOpts);
  });

  if (tokens.includes(undefined)) {
    return token;
  }

  return tokens;
}

function expandMacroTokens(tokens, locale) {
  var _Array$prototype;

  return (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, tokens.map(function (t) {
    return maybeExpandMacroToken(t, locale);
  }));
}
/**
 * @private
 */


function explainFromTokens(locale, input, format) {
  var tokens = expandMacroTokens(Formatter.parseFormat(format), locale),
      units = tokens.map(function (t) {
    return unitForToken(t, locale);
  }),
      disqualifyingUnit = units.find(function (t) {
    return t.invalidReason;
  });

  if (disqualifyingUnit) {
    return {
      input: input,
      tokens: tokens,
      invalidReason: disqualifyingUnit.invalidReason
    };
  } else {
    var _buildRegex = buildRegex(units),
        regexString = _buildRegex[0],
        handlers = _buildRegex[1],
        regex = RegExp(regexString, "i"),
        _match = match(input, regex, handlers),
        rawMatches = _match[0],
        matches = _match[1],
        _ref6 = matches ? dateTimeFromMatches(matches) : [null, null],
        result = _ref6[0],
        zone = _ref6[1];

    if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
      throw new ConflictingSpecificationError("Can't include meridiem when specifying 24-hour format");
    }

    return {
      input: input,
      tokens: tokens,
      regex: regex,
      rawMatches: rawMatches,
      matches: matches,
      result: result,
      zone: zone
    };
  }
}
function parseFromTokens(locale, input, format) {
  var _explainFromTokens = explainFromTokens(locale, input, format),
      result = _explainFromTokens.result,
      zone = _explainFromTokens.zone,
      invalidReason = _explainFromTokens.invalidReason;

  return [result, zone, invalidReason];
}

var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],
    leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];

function unitOutOfRange(unit, value) {
  return new Invalid("unit out of range", "you specified " + value + " (of type " + typeof value + ") as a " + unit + ", which is invalid");
}

function dayOfWeek(year, month, day) {
  var js = new Date(Date.UTC(year, month - 1, day)).getUTCDay();
  return js === 0 ? 7 : js;
}

function computeOrdinal(year, month, day) {
  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
}

function uncomputeOrdinal(year, ordinal) {
  var table = isLeapYear(year) ? leapLadder : nonLeapLadder,
      month0 = table.findIndex(function (i) {
    return i < ordinal;
  }),
      day = ordinal - table[month0];
  return {
    month: month0 + 1,
    day: day
  };
}
/**
 * @private
 */


function gregorianToWeek(gregObj) {
  var year = gregObj.year,
      month = gregObj.month,
      day = gregObj.day,
      ordinal = computeOrdinal(year, month, day),
      weekday = dayOfWeek(year, month, day);
  var weekNumber = Math.floor((ordinal - weekday + 10) / 7),
      weekYear;

  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear);
  } else if (weekNumber > weeksInWeekYear(year)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }

  return Object.assign({
    weekYear: weekYear,
    weekNumber: weekNumber,
    weekday: weekday
  }, timeObject(gregObj));
}
function weekToGregorian(weekData) {
  var weekYear = weekData.weekYear,
      weekNumber = weekData.weekNumber,
      weekday = weekData.weekday,
      weekdayOfJan4 = dayOfWeek(weekYear, 1, 4),
      yearInDays = daysInYear(weekYear);
  var ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3,
      year;

  if (ordinal < 1) {
    year = weekYear - 1;
    ordinal += daysInYear(year);
  } else if (ordinal > yearInDays) {
    year = weekYear + 1;
    ordinal -= daysInYear(weekYear);
  } else {
    year = weekYear;
  }

  var _uncomputeOrdinal = uncomputeOrdinal(year, ordinal),
      month = _uncomputeOrdinal.month,
      day = _uncomputeOrdinal.day;

  return Object.assign({
    year: year,
    month: month,
    day: day
  }, timeObject(weekData));
}
function gregorianToOrdinal(gregData) {
  var year = gregData.year,
      month = gregData.month,
      day = gregData.day,
      ordinal = computeOrdinal(year, month, day);
  return Object.assign({
    year: year,
    ordinal: ordinal
  }, timeObject(gregData));
}
function ordinalToGregorian(ordinalData) {
  var year = ordinalData.year,
      ordinal = ordinalData.ordinal,
      _uncomputeOrdinal2 = uncomputeOrdinal(year, ordinal),
      month = _uncomputeOrdinal2.month,
      day = _uncomputeOrdinal2.day;

  return Object.assign({
    year: year,
    month: month,
    day: day
  }, timeObject(ordinalData));
}
function hasInvalidWeekData(obj) {
  var validYear = isInteger(obj.weekYear),
      validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)),
      validWeekday = integerBetween(obj.weekday, 1, 7);

  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.week);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else return false;
}
function hasInvalidOrdinalData(obj) {
  var validYear = isInteger(obj.year),
      validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));

  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else return false;
}
function hasInvalidGregorianData(obj) {
  var validYear = isInteger(obj.year),
      validMonth = integerBetween(obj.month, 1, 12),
      validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));

  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else return false;
}
function hasInvalidTimeData(obj) {
  var hour = obj.hour,
      minute = obj.minute,
      second = obj.second,
      millisecond = obj.millisecond;
  var validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0,
      validMinute = integerBetween(minute, 0, 59),
      validSecond = integerBetween(second, 0, 59),
      validMillisecond = integerBetween(millisecond, 0, 999);

  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else return false;
}

var INVALID$2 = "Invalid DateTime";
var MAX_DATE = 8.64e15;

function unsupportedZone(zone) {
  return new Invalid("unsupported zone", "the zone \"" + zone.name + "\" is not supported");
} // we cache week data on the DT object and this intermediates the cache


function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }

  return dt.weekData;
} // clone really means, "make a new object with these modifications". all "setters" really use this
// to create a new object while only changing some of the properties


function clone$1(inst, alts) {
  var current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid
  };
  return new DateTime(Object.assign({}, current, alts, {
    old: current
  }));
} // find the right offset a given local time. The o input is our guess, which determines which
// offset we'll pick in ambiguous cases (e.g. there are two 3 AMs b/c Fallback DST)


function fixOffset(localTS, o, tz) {
  // Our UTC time is just a guess because our offset is just a guess
  var utcGuess = localTS - o * 60 * 1000; // Test whether the zone matches the offset for this ts

  var o2 = tz.offset(utcGuess); // If so, offset didn't change and we're done

  if (o === o2) {
    return [utcGuess, o];
  } // If not, change the ts by the difference in the offset


  utcGuess -= (o2 - o) * 60 * 1000; // If that gives us the local time we want, we're done

  var o3 = tz.offset(utcGuess);

  if (o2 === o3) {
    return [utcGuess, o2];
  } // If it's different, we're in a hole time. The offset has changed, but the we don't adjust the time


  return [localTS - Math.min(o2, o3) * 60 * 1000, Math.max(o2, o3)];
} // convert an epoch timestamp into a calendar object with the given offset


function tsToObj(ts, offset) {
  ts += offset * 60 * 1000;
  var d = new Date(ts);
  return {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth() + 1,
    day: d.getUTCDate(),
    hour: d.getUTCHours(),
    minute: d.getUTCMinutes(),
    second: d.getUTCSeconds(),
    millisecond: d.getUTCMilliseconds()
  };
} // convert a calendar object to a epoch timestamp


function objToTS(obj, offset, zone) {
  return fixOffset(objToLocalTS(obj), offset, zone);
} // create a new DT instance by adding a duration, adjusting for DSTs


function adjustTime(inst, dur) {
  var oPre = inst.o,
      year = inst.c.year + Math.trunc(dur.years),
      month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3,
      c = Object.assign({}, inst.c, {
    year: year,
    month: month,
    day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
  }),
      millisToAdd = Duration.fromObject({
    years: dur.years - Math.trunc(dur.years),
    quarters: dur.quarters - Math.trunc(dur.quarters),
    months: dur.months - Math.trunc(dur.months),
    weeks: dur.weeks - Math.trunc(dur.weeks),
    days: dur.days - Math.trunc(dur.days),
    hours: dur.hours,
    minutes: dur.minutes,
    seconds: dur.seconds,
    milliseconds: dur.milliseconds
  }).as("milliseconds"),
      localTS = objToLocalTS(c);

  var _fixOffset = fixOffset(localTS, oPre, inst.zone),
      ts = _fixOffset[0],
      o = _fixOffset[1];

  if (millisToAdd !== 0) {
    ts += millisToAdd; // that could have changed the offset by going over a DST, but we want to keep the ts the same

    o = inst.zone.offset(ts);
  }

  return {
    ts: ts,
    o: o
  };
} // helper useful in turning the results of parsing into real dates
// by handling the zone options


function parseDataToDateTime(parsed, parsedZone, opts, format, text) {
  var setZone = opts.setZone,
      zone = opts.zone;

  if (parsed && Object.keys(parsed).length !== 0) {
    var interpretationZone = parsedZone || zone,
        inst = DateTime.fromObject(Object.assign(parsed, opts, {
      zone: interpretationZone,
      // setZone is a valid option in the calling methods, but not in fromObject
      setZone: undefined
    }));
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(new Invalid("unparsable", "the input \"" + text + "\" can't be parsed as " + format));
  }
} // if you want to output a technical format (e.g. RFC 2822), this helper
// helps handle the details


function toTechFormat(dt, format, allowZ) {
  if (allowZ === void 0) {
    allowZ = true;
  }

  return dt.isValid ? Formatter.create(Locale.create("en-US"), {
    allowZ: allowZ,
    forceSimple: true
  }).formatDateTimeFromString(dt, format) : null;
} // technical time formats (e.g. the time part of ISO 8601), take some options
// and this commonizes their handling


function toTechTimeFormat(dt, _ref) {
  var _ref$suppressSeconds = _ref.suppressSeconds,
      suppressSeconds = _ref$suppressSeconds === void 0 ? false : _ref$suppressSeconds,
      _ref$suppressMillisec = _ref.suppressMilliseconds,
      suppressMilliseconds = _ref$suppressMillisec === void 0 ? false : _ref$suppressMillisec,
      includeOffset = _ref.includeOffset,
      _ref$includePrefix = _ref.includePrefix,
      includePrefix = _ref$includePrefix === void 0 ? false : _ref$includePrefix,
      _ref$includeZone = _ref.includeZone,
      includeZone = _ref$includeZone === void 0 ? false : _ref$includeZone,
      _ref$spaceZone = _ref.spaceZone,
      spaceZone = _ref$spaceZone === void 0 ? false : _ref$spaceZone,
      _ref$format = _ref.format,
      format = _ref$format === void 0 ? "extended" : _ref$format;
  var fmt = format === "basic" ? "HHmm" : "HH:mm";

  if (!suppressSeconds || dt.second !== 0 || dt.millisecond !== 0) {
    fmt += format === "basic" ? "ss" : ":ss";

    if (!suppressMilliseconds || dt.millisecond !== 0) {
      fmt += ".SSS";
    }
  }

  if ((includeZone || includeOffset) && spaceZone) {
    fmt += " ";
  }

  if (includeZone) {
    fmt += "z";
  } else if (includeOffset) {
    fmt += format === "basic" ? "ZZZ" : "ZZ";
  }

  var str = toTechFormat(dt, fmt);

  if (includePrefix) {
    str = "T" + str;
  }

  return str;
} // defaults for unspecified units in the supported calendars


var defaultUnitValues = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
},
    defaultWeekUnitValues = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
},
    defaultOrdinalUnitValues = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}; // Units in the supported calendars, sorted by bigness

var orderedUnits$1 = ["year", "month", "day", "hour", "minute", "second", "millisecond"],
    orderedWeekUnits = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"],
    orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"]; // standardize case and plurality in units

function normalizeUnit(unit) {
  var normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[unit.toLowerCase()];
  if (!normalized) throw new InvalidUnitError(unit);
  return normalized;
} // this is a dumbed down version of fromObject() that runs about 60% faster
// but doesn't do any validation, makes a bunch of assumptions about what units
// are present, and so on.


function quickDT(obj, zone) {
  // assume we have the higher-order units
  for (var _iterator = _createForOfIteratorHelperLoose(orderedUnits$1), _step; !(_step = _iterator()).done;) {
    var u = _step.value;

    if (isUndefined(obj[u])) {
      obj[u] = defaultUnitValues[u];
    }
  }

  var invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);

  if (invalid) {
    return DateTime.invalid(invalid);
  }

  var tsNow = Settings.now(),
      offsetProvis = zone.offset(tsNow),
      _objToTS = objToTS(obj, offsetProvis, zone),
      ts = _objToTS[0],
      o = _objToTS[1];

  return new DateTime({
    ts: ts,
    zone: zone,
    o: o
  });
}

function diffRelative(start, end, opts) {
  var round = isUndefined(opts.round) ? true : opts.round,
      format = function format(c, unit) {
    c = roundTo(c, round || opts.calendary ? 0 : 2, true);
    var formatter = end.loc.clone(opts).relFormatter(opts);
    return formatter.format(c, unit);
  },
      differ = function differ(unit) {
    if (opts.calendary) {
      if (!end.hasSame(start, unit)) {
        return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
      } else return 0;
    } else {
      return end.diff(start, unit).get(unit);
    }
  };

  if (opts.unit) {
    return format(differ(opts.unit), opts.unit);
  }

  for (var _iterator2 = _createForOfIteratorHelperLoose(opts.units), _step2; !(_step2 = _iterator2()).done;) {
    var unit = _step2.value;
    var count = differ(unit);

    if (Math.abs(count) >= 1) {
      return format(count, unit);
    }
  }

  return format(0, opts.units[opts.units.length - 1]);
}
/**
 * A DateTime is an immutable data structure representing a specific date and time and accompanying methods. It contains class and instance methods for creating, parsing, interrogating, transforming, and formatting them.
 *
 * A DateTime comprises of:
 * * A timestamp. Each DateTime instance refers to a specific millisecond of the Unix epoch.
 * * A time zone. Each instance is considered in the context of a specific zone (by default the local system's zone).
 * * Configuration properties that effect how output strings are formatted, such as `locale`, `numberingSystem`, and `outputCalendar`.
 *
 * Here is a brief overview of the most commonly used functionality it provides:
 *
 * * **Creation**: To create a DateTime from its components, use one of its factory class methods: {@link local}, {@link utc}, and (most flexibly) {@link fromObject}. To create one from a standard string format, use {@link fromISO}, {@link fromHTTP}, and {@link fromRFC2822}. To create one from a custom string format, use {@link fromFormat}. To create one from a native JS date, use {@link fromJSDate}.
 * * **Gregorian calendar and time**: To examine the Gregorian properties of a DateTime individually (i.e as opposed to collectively through {@link toObject}), use the {@link year}, {@link month},
 * {@link day}, {@link hour}, {@link minute}, {@link second}, {@link millisecond} accessors.
 * * **Week calendar**: For ISO week calendar attributes, see the {@link weekYear}, {@link weekNumber}, and {@link weekday} accessors.
 * * **Configuration** See the {@link locale} and {@link numberingSystem} accessors.
 * * **Transformation**: To transform the DateTime into other DateTimes, use {@link set}, {@link reconfigure}, {@link setZone}, {@link setLocale}, {@link plus}, {@link minus}, {@link endOf}, {@link startOf}, {@link toUTC}, and {@link toLocal}.
 * * **Output**: To convert the DateTime to other representations, use the {@link toRelative}, {@link toRelativeCalendar}, {@link toJSON}, {@link toISO}, {@link toHTTP}, {@link toObject}, {@link toRFC2822}, {@link toString}, {@link toLocaleString}, {@link toFormat}, {@link toMillis} and {@link toJSDate}.
 *
 * There's plenty others documented below. In addition, for more information on subtler topics like internationalization, time zones, alternative calendars, validity, and so on, see the external documentation.
 */


var DateTime = /*#__PURE__*/function () {
  /**
   * @access private
   */
  function DateTime(config) {
    var zone = config.zone || Settings.defaultZone;
    var invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
    /**
     * @access private
     */

    this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
    var c = null,
        o = null;

    if (!invalid) {
      var unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);

      if (unchanged) {
        var _ref2 = [config.old.c, config.old.o];
        c = _ref2[0];
        o = _ref2[1];
      } else {
        var ot = zone.offset(this.ts);
        c = tsToObj(this.ts, ot);
        invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
        c = invalid ? null : c;
        o = invalid ? null : ot;
      }
    }
    /**
     * @access private
     */


    this._zone = zone;
    /**
     * @access private
     */

    this.loc = config.loc || Locale.create();
    /**
     * @access private
     */

    this.invalid = invalid;
    /**
     * @access private
     */

    this.weekData = null;
    /**
     * @access private
     */

    this.c = c;
    /**
     * @access private
     */

    this.o = o;
    /**
     * @access private
     */

    this.isLuxonDateTime = true;
  } // CONSTRUCT

  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */


  DateTime.now = function now() {
    return new DateTime({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                            //~> now
   * @example DateTime.local(2017)                        //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                     //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12)                 //~> 2017-03-12T00:00:00
   * @example DateTime.local(2017, 3, 12, 5)              //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, 45)          //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)      //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765) //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  ;

  DateTime.local = function local(year, month, day, hour, minute, second, millisecond) {
    if (isUndefined(year)) {
      return new DateTime({});
    } else {
      return quickDT({
        year: year,
        month: month,
        day: day,
        hour: hour,
        minute: minute,
        second: second,
        millisecond: millisecond
      }, Settings.defaultZone);
    }
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.utc()                            //~> now
   * @example DateTime.utc(2017)                        //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                     //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                 //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)              //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)          //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)      //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765) //~> 2017-03-12T05:45:10.765Z
   * @return {DateTime}
   */
  ;

  DateTime.utc = function utc(year, month, day, hour, minute, second, millisecond) {
    if (isUndefined(year)) {
      return new DateTime({
        ts: Settings.now(),
        zone: FixedOffsetZone.utcInstance
      });
    } else {
      return quickDT({
        year: year,
        month: month,
        day: day,
        hour: hour,
        minute: minute,
        second: second,
        millisecond: millisecond
      }, FixedOffsetZone.utcInstance);
    }
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  ;

  DateTime.fromJSDate = function fromJSDate(date, options) {
    if (options === void 0) {
      options = {};
    }

    var ts = isDate(date) ? date.valueOf() : NaN;

    if (Number.isNaN(ts)) {
      return DateTime.invalid("invalid input");
    }

    var zoneToUse = normalizeZone(options.zone, Settings.defaultZone);

    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }

    return new DateTime({
      ts: ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options)
    });
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  ;

  DateTime.fromMillis = function fromMillis(milliseconds, options) {
    if (options === void 0) {
      options = {};
    }

    if (!isNumber(milliseconds)) {
      throw new InvalidArgumentError("fromMillis requires a numerical input, but received a " + typeof milliseconds + " with value " + milliseconds);
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      // this isn't perfect because because we can still end up out of range because of additional shifting, but it's a start
      return DateTime.invalid("Timestamp out of range");
    } else {
      return new DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  ;

  DateTime.fromSeconds = function fromSeconds(seconds, options) {
    if (options === void 0) {
      options = {};
    }

    if (!isNumber(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new DateTime({
        ts: seconds * 1000,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {string|Zone} [obj.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [obj.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} obj.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} obj.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6, zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6, zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6, zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @return {DateTime}
   */
  ;

  DateTime.fromObject = function fromObject(obj) {
    var zoneToUse = normalizeZone(obj.zone, Settings.defaultZone);

    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }

    var tsNow = Settings.now(),
        offsetProvis = zoneToUse.offset(tsNow),
        normalized = normalizeObject(obj, normalizeUnit, ["zone", "locale", "outputCalendar", "numberingSystem"]),
        containsOrdinal = !isUndefined(normalized.ordinal),
        containsGregorYear = !isUndefined(normalized.year),
        containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day),
        containsGregor = containsGregorYear || containsGregorMD,
        definiteWeekDef = normalized.weekYear || normalized.weekNumber,
        loc = Locale.fromObject(obj); // cases:
    // just a weekday -> this week's instance of that weekday, no worries
    // (gregorian data or ordinal) + (weekYear or weekNumber) -> error
    // (gregorian month or day) + ordinal -> error
    // otherwise just use weeks or ordinals or gregorian, depending on what's specified

    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    }

    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }

    var useWeekData = definiteWeekDef || normalized.weekday && !containsGregor; // configure ourselves to deal with gregorian dates or week stuff

    var units,
        defaultValues,
        objNow = tsToObj(tsNow, offsetProvis);

    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits$1;
      defaultValues = defaultUnitValues;
    } // set default values for missing stuff


    var foundFirst = false;

    for (var _iterator3 = _createForOfIteratorHelperLoose(units), _step3; !(_step3 = _iterator3()).done;) {
      var u = _step3.value;
      var v = normalized[u];

      if (!isUndefined(v)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u] = defaultValues[u];
      } else {
        normalized[u] = objNow[u];
      }
    } // make sure the values we have are in range


    var higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized),
        invalid = higherOrderInvalid || hasInvalidTimeData(normalized);

    if (invalid) {
      return DateTime.invalid(invalid);
    } // compute the actual time


    var gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized,
        _objToTS2 = objToTS(gregorian, offsetProvis, zoneToUse),
        tsFinal = _objToTS2[0],
        offsetFinal = _objToTS2[1],
        inst = new DateTime({
      ts: tsFinal,
      zone: zoneToUse,
      o: offsetFinal,
      loc: loc
    }); // gregorian data + weekday serves only to validate


    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return DateTime.invalid("mismatched weekday", "you can't specify both a weekday of " + normalized.weekday + " and a date of " + inst.toISO());
    }

    return inst;
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  ;

  DateTime.fromISO = function fromISO(text, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var _parseISODate = parseISODate(text),
        vals = _parseISODate[0],
        parsedZone = _parseISODate[1];

    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  ;

  DateTime.fromRFC2822 = function fromRFC2822(text, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var _parseRFC2822Date = parseRFC2822Date(text),
        vals = _parseRFC2822Date[0],
        parsedZone = _parseRFC2822Date[1];

    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  ;

  DateTime.fromHTTP = function fromHTTP(text, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var _parseHTTPDate = parseHTTPDate(text),
        vals = _parseHTTPDate[0],
        parsedZone = _parseHTTPDate[1];

    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @see https://moment.github.io/luxon/docs/manual/parsing.html#table-of-tokens
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  ;

  DateTime.fromFormat = function fromFormat(text, fmt, opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (isUndefined(text) || isUndefined(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }

    var _opts = opts,
        _opts$locale = _opts.locale,
        locale = _opts$locale === void 0 ? null : _opts$locale,
        _opts$numberingSystem = _opts.numberingSystem,
        numberingSystem = _opts$numberingSystem === void 0 ? null : _opts$numberingSystem,
        localeToUse = Locale.fromOpts({
      locale: locale,
      numberingSystem: numberingSystem,
      defaultToEN: true
    }),
        _parseFromTokens = parseFromTokens(localeToUse, text, fmt),
        vals = _parseFromTokens[0],
        parsedZone = _parseFromTokens[1],
        invalid = _parseFromTokens[2];

    if (invalid) {
      return DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, "format " + fmt, text);
    }
  }
  /**
   * @deprecated use fromFormat instead
   */
  ;

  DateTime.fromString = function fromString(text, fmt, opts) {
    if (opts === void 0) {
      opts = {};
    }

    return DateTime.fromFormat(text, fmt, opts);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  ;

  DateTime.fromSQL = function fromSQL(text, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var _parseSQL = parseSQL(text),
        vals = _parseSQL[0],
        parsedZone = _parseSQL[1];

    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  ;

  DateTime.invalid = function invalid(reason, explanation) {
    if (explanation === void 0) {
      explanation = null;
    }

    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }

    var invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);

    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new DateTime({
        invalid: invalid
      });
    }
  }
  /**
   * Check if an object is a DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  ;

  DateTime.isDateTime = function isDateTime(o) {
    return o && o.isLuxonDateTime || false;
  } // INFO

  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  ;

  var _proto = DateTime.prototype;

  _proto.get = function get(unit) {
    return this[unit];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  ;

  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  _proto.resolvedLocaleOpts = function resolvedLocaleOpts(opts) {
    if (opts === void 0) {
      opts = {};
    }

    var _Formatter$create$res = Formatter.create(this.loc.clone(opts), opts).resolvedOptions(this),
        locale = _Formatter$create$res.locale,
        numberingSystem = _Formatter$create$res.numberingSystem,
        calendar = _Formatter$create$res.calendar;

    return {
      locale: locale,
      numberingSystem: numberingSystem,
      outputCalendar: calendar
    };
  } // TRANSFORM

  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  ;

  _proto.toUTC = function toUTC(offset, opts) {
    if (offset === void 0) {
      offset = 0;
    }

    if (opts === void 0) {
      opts = {};
    }

    return this.setZone(FixedOffsetZone.instance(offset), opts);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  ;

  _proto.toLocal = function toLocal() {
    return this.setZone(Settings.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link plus}. You may wish to use {@link toLocal} and {@link toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  ;

  _proto.setZone = function setZone(zone, _temp) {
    var _ref3 = _temp === void 0 ? {} : _temp,
        _ref3$keepLocalTime = _ref3.keepLocalTime,
        keepLocalTime = _ref3$keepLocalTime === void 0 ? false : _ref3$keepLocalTime,
        _ref3$keepCalendarTim = _ref3.keepCalendarTime,
        keepCalendarTime = _ref3$keepCalendarTim === void 0 ? false : _ref3$keepCalendarTim;

    zone = normalizeZone(zone, Settings.defaultZone);

    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    } else {
      var newTS = this.ts;

      if (keepLocalTime || keepCalendarTime) {
        var offsetGuess = zone.offset(this.ts);
        var asObj = this.toObject();

        var _objToTS3 = objToTS(asObj, offsetGuess, zone);

        newTS = _objToTS3[0];
      }

      return clone$1(this, {
        ts: newTS,
        zone: zone
      });
    }
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  ;

  _proto.reconfigure = function reconfigure(_temp2) {
    var _ref4 = _temp2 === void 0 ? {} : _temp2,
        locale = _ref4.locale,
        numberingSystem = _ref4.numberingSystem,
        outputCalendar = _ref4.outputCalendar;

    var loc = this.loc.clone({
      locale: locale,
      numberingSystem: numberingSystem,
      outputCalendar: outputCalendar
    });
    return clone$1(this, {
      loc: loc
    });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  ;

  _proto.setLocale = function setLocale(locale) {
    return this.reconfigure({
      locale: locale
    });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link reconfigure} and {@link setZone}.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  ;

  _proto.set = function set(values) {
    if (!this.isValid) return this;
    var normalized = normalizeObject(values, normalizeUnit, []),
        settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday);
    var mixed;

    if (settingWeekStuff) {
      mixed = weekToGregorian(Object.assign(gregorianToWeek(this.c), normalized));
    } else if (!isUndefined(normalized.ordinal)) {
      mixed = ordinalToGregorian(Object.assign(gregorianToOrdinal(this.c), normalized));
    } else {
      mixed = Object.assign(this.toObject(), normalized); // if we didn't set the day but we ended up on an overflow date,
      // use the last day of the right month

      if (isUndefined(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }

    var _objToTS4 = objToTS(mixed, this.o, this.zone),
        ts = _objToTS4[0],
        o = _objToTS4[1];

    return clone$1(this, {
      ts: ts,
      o: o
    });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  ;

  _proto.plus = function plus(duration) {
    if (!this.isValid) return this;
    var dur = friendlyDuration(duration);
    return clone$1(this, adjustTime(this, dur));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
  */
  ;

  _proto.minus = function minus(duration) {
    if (!this.isValid) return this;
    var dur = friendlyDuration(duration).negate();
    return clone$1(this, adjustTime(this, dur));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  ;

  _proto.startOf = function startOf(unit) {
    if (!this.isValid) return this;
    var o = {},
        normalizedUnit = Duration.normalizeUnit(unit);

    switch (normalizedUnit) {
      case "years":
        o.month = 1;
      // falls through

      case "quarters":
      case "months":
        o.day = 1;
      // falls through

      case "weeks":
      case "days":
        o.hour = 0;
      // falls through

      case "hours":
        o.minute = 0;
      // falls through

      case "minutes":
        o.second = 0;
      // falls through

      case "seconds":
        o.millisecond = 0;
        break;
      // no default, invalid units throw in normalizeUnit()
    }

    if (normalizedUnit === "weeks") {
      o.weekday = 1;
    }

    if (normalizedUnit === "quarters") {
      var q = Math.ceil(this.month / 3);
      o.month = (q - 1) * 3 + 1;
    }

    return this.set(o);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  ;

  _proto.endOf = function endOf(unit) {
    var _this$plus;

    return this.isValid ? this.plus((_this$plus = {}, _this$plus[unit] = 1, _this$plus)).startOf(unit).minus(1) : this;
  } // OUTPUT

  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/docs/manual/formatting.html#table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @see https://moment.github.io/luxon/docs/manual/formatting.html#table-of-tokens
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  ;

  _proto.toFormat = function toFormat(fmt, opts) {
    if (opts === void 0) {
      opts = {};
    }

    return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID$2;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param opts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString({ locale: 'en-gb' }); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hour12: false }); //=> '11:32'
   * @return {string}
   */
  ;

  Reflect.defineProperty(_proto, 'toLocaleString', { value: function toLocaleString(opts) {
    if (opts === void 0) {
      opts = DATE_SHORT;
    }

    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTime(this) : INVALID$2;
  }})
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  ;

  _proto.toLocaleParts = function toLocaleParts(opts) {
    if (opts === void 0) {
      opts = {};
    }

    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  ;

  _proto.toISO = function toISO(opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (!this.isValid) {
      return null;
    }

    return this.toISODate(opts) + "T" + this.toISOTime(opts);
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  ;

  _proto.toISODate = function toISODate(_temp3) {
    var _ref5 = _temp3 === void 0 ? {} : _temp3,
        _ref5$format = _ref5.format,
        format = _ref5$format === void 0 ? "extended" : _ref5$format;

    var fmt = format === "basic" ? "yyyyMMdd" : "yyyy-MM-dd";

    if (this.year > 9999) {
      fmt = "+" + fmt;
    }

    return toTechFormat(this, fmt);
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  ;

  _proto.toISOWeekDate = function toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  ;

  _proto.toISOTime = function toISOTime(_temp4) {
    var _ref6 = _temp4 === void 0 ? {} : _temp4,
        _ref6$suppressMillise = _ref6.suppressMilliseconds,
        suppressMilliseconds = _ref6$suppressMillise === void 0 ? false : _ref6$suppressMillise,
        _ref6$suppressSeconds = _ref6.suppressSeconds,
        suppressSeconds = _ref6$suppressSeconds === void 0 ? false : _ref6$suppressSeconds,
        _ref6$includeOffset = _ref6.includeOffset,
        includeOffset = _ref6$includeOffset === void 0 ? true : _ref6$includeOffset,
        _ref6$includePrefix = _ref6.includePrefix,
        includePrefix = _ref6$includePrefix === void 0 ? false : _ref6$includePrefix,
        _ref6$format = _ref6.format,
        format = _ref6$format === void 0 ? "extended" : _ref6$format;

    return toTechTimeFormat(this, {
      suppressSeconds: suppressSeconds,
      suppressMilliseconds: suppressMilliseconds,
      includeOffset: includeOffset,
      includePrefix: includePrefix,
      format: format
    });
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime, always in UTC
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  ;

  _proto.toRFC2822 = function toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  ;

  _proto.toHTTP = function toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  ;

  _proto.toSQLDate = function toSQLDate() {
    return toTechFormat(this, "yyyy-MM-dd");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  ;

  _proto.toSQLTime = function toSQLTime(_temp5) {
    var _ref7 = _temp5 === void 0 ? {} : _temp5,
        _ref7$includeOffset = _ref7.includeOffset,
        includeOffset = _ref7$includeOffset === void 0 ? true : _ref7$includeOffset,
        _ref7$includeZone = _ref7.includeZone,
        includeZone = _ref7$includeZone === void 0 ? false : _ref7$includeZone;

    return toTechTimeFormat(this, {
      includeOffset: includeOffset,
      includeZone: includeZone,
      spaceZone: true
    });
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  ;

  _proto.toSQL = function toSQL(opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (!this.isValid) {
      return null;
    }

    return this.toSQLDate() + " " + this.toSQLTime(opts);
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  ;

  _proto.toString = function toString() {
    return this.isValid ? this.toISO() : INVALID$2;
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link toMillis}
   * @return {number}
   */
  ;

  _proto.valueOf = function valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  ;

  _proto.toMillis = function toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  ;

  _proto.toSeconds = function toSeconds() {
    return this.isValid ? this.ts / 1000 : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  ;

  _proto.toJSON = function toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  ;

  _proto.toBSON = function toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  ;

  _proto.toObject = function toObject(opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (!this.isValid) return {};
    var base = Object.assign({}, this.c);

    if (opts.includeConfig) {
      base.outputCalendar = this.outputCalendar;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }

    return base;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  ;

  _proto.toJSDate = function toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  } // COMPARE

  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  ;

  _proto.diff = function diff(otherDateTime, unit, opts) {
    if (unit === void 0) {
      unit = "milliseconds";
    }

    if (opts === void 0) {
      opts = {};
    }

    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid(this.invalid || otherDateTime.invalid, "created by diffing an invalid DateTime");
    }

    var durOpts = Object.assign({
      locale: this.locale,
      numberingSystem: this.numberingSystem
    }, opts);

    var units = maybeArray(unit).map(Duration.normalizeUnit),
        otherIsLater = otherDateTime.valueOf() > this.valueOf(),
        earlier = otherIsLater ? this : otherDateTime,
        later = otherIsLater ? otherDateTime : this,
        diffed = _diff(earlier, later, units, durOpts);

    return otherIsLater ? diffed.negate() : diffed;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  ;

  _proto.diffNow = function diffNow(unit, opts) {
    if (unit === void 0) {
      unit = "milliseconds";
    }

    if (opts === void 0) {
      opts = {};
    }

    return this.diff(DateTime.now(), unit, opts);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  ;

  _proto.until = function until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  ;

  _proto.hasSame = function hasSame(otherDateTime, unit) {
    if (!this.isValid) return false;
    var inputMs = otherDateTime.valueOf();
    var otherZoneDateTime = this.setZone(otherDateTime.zone, {
      keepLocalTime: true
    });
    return otherZoneDateTime.startOf(unit) <= inputMs && inputMs <= otherZoneDateTime.endOf(unit);
  }
  /**
   * Equality check
   * Two DateTimes are equal iff they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  ;

  _proto.equals = function equals(other) {
    return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  ;

  _proto.toRelative = function toRelative(options) {
    if (options === void 0) {
      options = {};
    }

    if (!this.isValid) return null;
    var base = options.base || DateTime.fromObject({
      zone: this.zone
    }),
        padding = options.padding ? this < base ? -options.padding : options.padding : 0;
    return diffRelative(base, this.plus(padding), Object.assign(options, {
      numeric: "always",
      units: ["years", "months", "days", "hours", "minutes", "seconds"]
    }));
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  ;

  _proto.toRelativeCalendar = function toRelativeCalendar(options) {
    if (options === void 0) {
      options = {};
    }

    if (!this.isValid) return null;
    return diffRelative(options.base || DateTime.fromObject({
      zone: this.zone
    }), this, Object.assign(options, {
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true
    }));
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  ;

  DateTime.min = function min() {
    for (var _len = arguments.length, dateTimes = new Array(_len), _key = 0; _key < _len; _key++) {
      dateTimes[_key] = arguments[_key];
    }

    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }

    return bestBy(dateTimes, function (i) {
      return i.valueOf();
    }, Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  ;

  DateTime.max = function max() {
    for (var _len2 = arguments.length, dateTimes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      dateTimes[_key2] = arguments[_key2];
    }

    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }

    return bestBy(dateTimes, function (i) {
      return i.valueOf();
    }, Math.max);
  } // MISC

  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  ;

  DateTime.fromFormatExplain = function fromFormatExplain(text, fmt, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        _options$locale = _options.locale,
        locale = _options$locale === void 0 ? null : _options$locale,
        _options$numberingSys = _options.numberingSystem,
        numberingSystem = _options$numberingSys === void 0 ? null : _options$numberingSys,
        localeToUse = Locale.fromOpts({
      locale: locale,
      numberingSystem: numberingSystem,
      defaultToEN: true
    });
    return explainFromTokens(localeToUse, text, fmt);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  ;

  DateTime.fromStringExplain = function fromStringExplain(text, fmt, options) {
    if (options === void 0) {
      options = {};
    }

    return DateTime.fromFormatExplain(text, fmt, options);
  } // FORMAT PRESETS

  /**
   * {@link toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  ;

  _createClass(DateTime, [{
    key: "isValid",
    get: function get() {
      return this.invalid === null;
    }
    /**
     * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
     * @type {string}
     */

  }, {
    key: "invalidReason",
    get: function get() {
      return this.invalid ? this.invalid.reason : null;
    }
    /**
     * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
     * @type {string}
     */

  }, {
    key: "invalidExplanation",
    get: function get() {
      return this.invalid ? this.invalid.explanation : null;
    }
    /**
     * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
     *
     * @type {string}
     */

  }, {
    key: "locale",
    get: function get() {
      return this.isValid ? this.loc.locale : null;
    }
    /**
     * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
     *
     * @type {string}
     */

  }, {
    key: "numberingSystem",
    get: function get() {
      return this.isValid ? this.loc.numberingSystem : null;
    }
    /**
     * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
     *
     * @type {string}
     */

  }, {
    key: "outputCalendar",
    get: function get() {
      return this.isValid ? this.loc.outputCalendar : null;
    }
    /**
     * Get the time zone associated with this DateTime.
     * @type {Zone}
     */

  }, {
    key: "zone",
    get: function get() {
      return this._zone;
    }
    /**
     * Get the name of the time zone.
     * @type {string}
     */

  }, {
    key: "zoneName",
    get: function get() {
      return this.isValid ? this.zone.name : null;
    }
    /**
     * Get the year
     * @example DateTime.local(2017, 5, 25).year //=> 2017
     * @type {number}
     */

  }, {
    key: "year",
    get: function get() {
      return this.isValid ? this.c.year : NaN;
    }
    /**
     * Get the quarter
     * @example DateTime.local(2017, 5, 25).quarter //=> 2
     * @type {number}
     */

  }, {
    key: "quarter",
    get: function get() {
      return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
    }
    /**
     * Get the month (1-12).
     * @example DateTime.local(2017, 5, 25).month //=> 5
     * @type {number}
     */

  }, {
    key: "month",
    get: function get() {
      return this.isValid ? this.c.month : NaN;
    }
    /**
     * Get the day of the month (1-30ish).
     * @example DateTime.local(2017, 5, 25).day //=> 25
     * @type {number}
     */

  }, {
    key: "day",
    get: function get() {
      return this.isValid ? this.c.day : NaN;
    }
    /**
     * Get the hour of the day (0-23).
     * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
     * @type {number}
     */

  }, {
    key: "hour",
    get: function get() {
      return this.isValid ? this.c.hour : NaN;
    }
    /**
     * Get the minute of the hour (0-59).
     * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
     * @type {number}
     */

  }, {
    key: "minute",
    get: function get() {
      return this.isValid ? this.c.minute : NaN;
    }
    /**
     * Get the second of the minute (0-59).
     * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
     * @type {number}
     */

  }, {
    key: "second",
    get: function get() {
      return this.isValid ? this.c.second : NaN;
    }
    /**
     * Get the millisecond of the second (0-999).
     * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
     * @type {number}
     */

  }, {
    key: "millisecond",
    get: function get() {
      return this.isValid ? this.c.millisecond : NaN;
    }
    /**
     * Get the week year
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2014, 11, 31).weekYear //=> 2015
     * @type {number}
     */

  }, {
    key: "weekYear",
    get: function get() {
      return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
    }
    /**
     * Get the week number of the week year (1-52ish).
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
     * @type {number}
     */

  }, {
    key: "weekNumber",
    get: function get() {
      return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
    }
    /**
     * Get the day of the week.
     * 1 is Monday and 7 is Sunday
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2014, 11, 31).weekday //=> 4
     * @type {number}
     */

  }, {
    key: "weekday",
    get: function get() {
      return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
    }
    /**
     * Get the ordinal (meaning the day of the year)
     * @example DateTime.local(2017, 5, 25).ordinal //=> 145
     * @type {number|DateTime}
     */

  }, {
    key: "ordinal",
    get: function get() {
      return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
    }
    /**
     * Get the human readable short month name, such as 'Oct'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
     * @type {string}
     */

  }, {
    key: "monthShort",
    get: function get() {
      return this.isValid ? Info.months("short", {
        locale: this.locale
      })[this.month - 1] : null;
    }
    /**
     * Get the human readable long month name, such as 'October'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).monthLong //=> October
     * @type {string}
     */

  }, {
    key: "monthLong",
    get: function get() {
      return this.isValid ? Info.months("long", {
        locale: this.locale
      })[this.month - 1] : null;
    }
    /**
     * Get the human readable short weekday, such as 'Mon'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
     * @type {string}
     */

  }, {
    key: "weekdayShort",
    get: function get() {
      return this.isValid ? Info.weekdays("short", {
        locale: this.locale
      })[this.weekday - 1] : null;
    }
    /**
     * Get the human readable long weekday, such as 'Monday'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
     * @type {string}
     */

  }, {
    key: "weekdayLong",
    get: function get() {
      return this.isValid ? Info.weekdays("long", {
        locale: this.locale
      })[this.weekday - 1] : null;
    }
    /**
     * Get the UTC offset of this DateTime in minutes
     * @example DateTime.now().offset //=> -240
     * @example DateTime.utc().offset //=> 0
     * @type {number}
     */

  }, {
    key: "offset",
    get: function get() {
      return this.isValid ? +this.o : NaN;
    }
    /**
     * Get the short human name for the zone's current offset, for example "EST" or "EDT".
     * Defaults to the system's locale if no locale has been specified
     * @type {string}
     */

  }, {
    key: "offsetNameShort",
    get: function get() {
      if (this.isValid) {
        return this.zone.offsetName(this.ts, {
          format: "short",
          locale: this.locale
        });
      } else {
        return null;
      }
    }
    /**
     * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
     * Defaults to the system's locale if no locale has been specified
     * @type {string}
     */

  }, {
    key: "offsetNameLong",
    get: function get() {
      if (this.isValid) {
        return this.zone.offsetName(this.ts, {
          format: "long",
          locale: this.locale
        });
      } else {
        return null;
      }
    }
    /**
     * Get whether this zone's offset ever changes, as in a DST.
     * @type {boolean}
     */

  }, {
    key: "isOffsetFixed",
    get: function get() {
      return this.isValid ? this.zone.universal : null;
    }
    /**
     * Get whether the DateTime is in a DST.
     * @type {boolean}
     */

  }, {
    key: "isInDST",
    get: function get() {
      if (this.isOffsetFixed) {
        return false;
      } else {
        return this.offset > this.set({
          month: 1
        }).offset || this.offset > this.set({
          month: 5
        }).offset;
      }
    }
    /**
     * Returns true if this DateTime is in a leap year, false otherwise
     * @example DateTime.local(2016).isInLeapYear //=> true
     * @example DateTime.local(2013).isInLeapYear //=> false
     * @type {boolean}
     */

  }, {
    key: "isInLeapYear",
    get: function get() {
      return isLeapYear(this.year);
    }
    /**
     * Returns the number of days in this DateTime's month
     * @example DateTime.local(2016, 2).daysInMonth //=> 29
     * @example DateTime.local(2016, 3).daysInMonth //=> 31
     * @type {number}
     */

  }, {
    key: "daysInMonth",
    get: function get() {
      return daysInMonth(this.year, this.month);
    }
    /**
     * Returns the number of days in this DateTime's year
     * @example DateTime.local(2016).daysInYear //=> 366
     * @example DateTime.local(2013).daysInYear //=> 365
     * @type {number}
     */

  }, {
    key: "daysInYear",
    get: function get() {
      return this.isValid ? daysInYear(this.year) : NaN;
    }
    /**
     * Returns the number of weeks in this DateTime's year
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2004).weeksInWeekYear //=> 53
     * @example DateTime.local(2013).weeksInWeekYear //=> 52
     * @type {number}
     */

  }, {
    key: "weeksInWeekYear",
    get: function get() {
      return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
    }
  }], [{
    key: "DATE_SHORT",
    get: function get() {
      return DATE_SHORT;
    }
    /**
     * {@link toLocaleString} format like 'Oct 14, 1983'
     * @type {Object}
     */

  }, {
    key: "DATE_MED",
    get: function get() {
      return DATE_MED;
    }
    /**
     * {@link toLocaleString} format like 'Fri, Oct 14, 1983'
     * @type {Object}
     */

  }, {
    key: "DATE_MED_WITH_WEEKDAY",
    get: function get() {
      return DATE_MED_WITH_WEEKDAY;
    }
    /**
     * {@link toLocaleString} format like 'October 14, 1983'
     * @type {Object}
     */

  }, {
    key: "DATE_FULL",
    get: function get() {
      return DATE_FULL;
    }
    /**
     * {@link toLocaleString} format like 'Tuesday, October 14, 1983'
     * @type {Object}
     */

  }, {
    key: "DATE_HUGE",
    get: function get() {
      return DATE_HUGE;
    }
    /**
     * {@link toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */

  }, {
    key: "TIME_SIMPLE",
    get: function get() {
      return TIME_SIMPLE;
    }
    /**
     * {@link toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */

  }, {
    key: "TIME_WITH_SECONDS",
    get: function get() {
      return TIME_WITH_SECONDS;
    }
    /**
     * {@link toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */

  }, {
    key: "TIME_WITH_SHORT_OFFSET",
    get: function get() {
      return TIME_WITH_SHORT_OFFSET;
    }
    /**
     * {@link toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */

  }, {
    key: "TIME_WITH_LONG_OFFSET",
    get: function get() {
      return TIME_WITH_LONG_OFFSET;
    }
    /**
     * {@link toLocaleString} format like '09:30', always 24-hour.
     * @type {Object}
     */

  }, {
    key: "TIME_24_SIMPLE",
    get: function get() {
      return TIME_24_SIMPLE;
    }
    /**
     * {@link toLocaleString} format like '09:30:23', always 24-hour.
     * @type {Object}
     */

  }, {
    key: "TIME_24_WITH_SECONDS",
    get: function get() {
      return TIME_24_WITH_SECONDS;
    }
    /**
     * {@link toLocaleString} format like '09:30:23 EDT', always 24-hour.
     * @type {Object}
     */

  }, {
    key: "TIME_24_WITH_SHORT_OFFSET",
    get: function get() {
      return TIME_24_WITH_SHORT_OFFSET;
    }
    /**
     * {@link toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
     * @type {Object}
     */

  }, {
    key: "TIME_24_WITH_LONG_OFFSET",
    get: function get() {
      return TIME_24_WITH_LONG_OFFSET;
    }
    /**
     * {@link toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */

  }, {
    key: "DATETIME_SHORT",
    get: function get() {
      return DATETIME_SHORT;
    }
    /**
     * {@link toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */

  }, {
    key: "DATETIME_SHORT_WITH_SECONDS",
    get: function get() {
      return DATETIME_SHORT_WITH_SECONDS;
    }
    /**
     * {@link toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */

  }, {
    key: "DATETIME_MED",
    get: function get() {
      return DATETIME_MED;
    }
    /**
     * {@link toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */

  }, {
    key: "DATETIME_MED_WITH_SECONDS",
    get: function get() {
      return DATETIME_MED_WITH_SECONDS;
    }
    /**
     * {@link toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */

  }, {
    key: "DATETIME_MED_WITH_WEEKDAY",
    get: function get() {
      return DATETIME_MED_WITH_WEEKDAY;
    }
    /**
     * {@link toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */

  }, {
    key: "DATETIME_FULL",
    get: function get() {
      return DATETIME_FULL;
    }
    /**
     * {@link toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */

  }, {
    key: "DATETIME_FULL_WITH_SECONDS",
    get: function get() {
      return DATETIME_FULL_WITH_SECONDS;
    }
    /**
     * {@link toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */

  }, {
    key: "DATETIME_HUGE",
    get: function get() {
      return DATETIME_HUGE;
    }
    /**
     * {@link toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */

  }, {
    key: "DATETIME_HUGE_WITH_SECONDS",
    get: function get() {
      return DATETIME_HUGE_WITH_SECONDS;
    }
  }]);

  return DateTime;
}();
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError("Unknown datetime argument: " + dateTimeish + ", of type " + typeof dateTimeish);
  }
}

var VERSION = "1.26.0";

exports.DateTime = DateTime;
exports.Duration = Duration;
exports.FixedOffsetZone = FixedOffsetZone;
exports.IANAZone = IANAZone;
exports.Info = Info;
exports.Interval = Interval;
exports.InvalidZone = InvalidZone;
exports.LocalZone = LocalZone;
exports.Settings = Settings;
exports.VERSION = VERSION;
exports.Zone = Zone;
//# sourceMappingURL=luxon.js.map

      };
    };
  }
}, {package:"luxon",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\luxon\\build\\cjs-browser\\luxon.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\punycode\\punycode.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\punycode\punycode.js
      return function (require, module, exports) {
'use strict';

/** Highest positive signed 32-bit float value */
const maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
const base = 36;
const tMin = 1;
const tMax = 26;
const skew = 38;
const damp = 700;
const initialBias = 72;
const initialN = 128; // 0x80
const delimiter = '-'; // '\x2D'

/** Regular expressions */
const regexPunycode = /^xn--/;
const regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
const errors = {
	'overflow': 'Overflow: input needs wider integers to process',
	'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
	'invalid-input': 'Invalid input'
};

/** Convenience shortcuts */
const baseMinusTMin = base - tMin;
const floor = Math.floor;
const stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error(type) {
	throw new RangeError(errors[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, fn) {
	const result = [];
	let length = array.length;
	while (length--) {
		result[length] = fn(array[length]);
	}
	return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */
function mapDomain(string, fn) {
	const parts = string.split('@');
	let result = '';
	if (parts.length > 1) {
		// In email addresses, only the domain name should be punycoded. Leave
		// the local part (i.e. everything up to `@`) intact.
		result = parts[0] + '@';
		string = parts[1];
	}
	// Avoid `split(regex)` for IE8 compatibility. See #17.
	string = string.replace(regexSeparators, '\x2E');
	const labels = string.split('.');
	const encoded = map(labels, fn).join('.');
	return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
	const output = [];
	let counter = 0;
	const length = string.length;
	while (counter < length) {
		const value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// It's a high surrogate, and there is a next character.
			const extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// It's an unmatched surrogate; only append this code unit, in case the
				// next code unit is the high surrogate of a surrogate pair.
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
const ucs2encode = array => String.fromCodePoint(...array);

/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */
const basicToDigit = function(codePoint) {
	if (codePoint - 0x30 < 0x0A) {
		return codePoint - 0x16;
	}
	if (codePoint - 0x41 < 0x1A) {
		return codePoint - 0x41;
	}
	if (codePoint - 0x61 < 0x1A) {
		return codePoint - 0x61;
	}
	return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
const digitToBasic = function(digit, flag) {
	//  0..25 map to ASCII a..z or A..Z
	// 26..35 map to ASCII 0..9
	return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
const adapt = function(delta, numPoints, firstTime) {
	let k = 0;
	delta = firstTime ? floor(delta / damp) : delta >> 1;
	delta += floor(delta / numPoints);
	for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
		delta = floor(delta / baseMinusTMin);
	}
	return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
const decode = function(input) {
	// Don't use UCS-2.
	const output = [];
	const inputLength = input.length;
	let i = 0;
	let n = initialN;
	let bias = initialBias;

	// Handle the basic code points: let `basic` be the number of input code
	// points before the last delimiter, or `0` if there is none, then copy
	// the first basic code points to the output.

	let basic = input.lastIndexOf(delimiter);
	if (basic < 0) {
		basic = 0;
	}

	for (let j = 0; j < basic; ++j) {
		// if it's not a basic code point
		if (input.charCodeAt(j) >= 0x80) {
			error('not-basic');
		}
		output.push(input.charCodeAt(j));
	}

	// Main decoding loop: start just after the last delimiter if any basic code
	// points were copied; start at the beginning otherwise.

	for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

		// `index` is the index of the next character to be consumed.
		// Decode a generalized variable-length integer into `delta`,
		// which gets added to `i`. The overflow checking is easier
		// if we increase `i` as we go, then subtract off its starting
		// value at the end to obtain `delta`.
		let oldi = i;
		for (let w = 1, k = base; /* no condition */; k += base) {

			if (index >= inputLength) {
				error('invalid-input');
			}

			const digit = basicToDigit(input.charCodeAt(index++));

			if (digit >= base || digit > floor((maxInt - i) / w)) {
				error('overflow');
			}

			i += digit * w;
			const t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

			if (digit < t) {
				break;
			}

			const baseMinusT = base - t;
			if (w > floor(maxInt / baseMinusT)) {
				error('overflow');
			}

			w *= baseMinusT;

		}

		const out = output.length + 1;
		bias = adapt(i - oldi, out, oldi == 0);

		// `i` was supposed to wrap around from `out` to `0`,
		// incrementing `n` each time, so we'll fix that now:
		if (floor(i / out) > maxInt - n) {
			error('overflow');
		}

		n += floor(i / out);
		i %= out;

		// Insert `n` at position `i` of the output.
		output.splice(i++, 0, n);

	}

	return String.fromCodePoint(...output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
const encode = function(input) {
	const output = [];

	// Convert the input in UCS-2 to an array of Unicode code points.
	input = ucs2decode(input);

	// Cache the length.
	let inputLength = input.length;

	// Initialize the state.
	let n = initialN;
	let delta = 0;
	let bias = initialBias;

	// Handle the basic code points.
	for (const currentValue of input) {
		if (currentValue < 0x80) {
			output.push(stringFromCharCode(currentValue));
		}
	}

	let basicLength = output.length;
	let handledCPCount = basicLength;

	// `handledCPCount` is the number of code points that have been handled;
	// `basicLength` is the number of basic code points.

	// Finish the basic string with a delimiter unless it's empty.
	if (basicLength) {
		output.push(delimiter);
	}

	// Main encoding loop:
	while (handledCPCount < inputLength) {

		// All non-basic code points < n have been handled already. Find the next
		// larger one:
		let m = maxInt;
		for (const currentValue of input) {
			if (currentValue >= n && currentValue < m) {
				m = currentValue;
			}
		}

		// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
		// but guard against overflow.
		const handledCPCountPlusOne = handledCPCount + 1;
		if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
			error('overflow');
		}

		delta += (m - n) * handledCPCountPlusOne;
		n = m;

		for (const currentValue of input) {
			if (currentValue < n && ++delta > maxInt) {
				error('overflow');
			}
			if (currentValue == n) {
				// Represent delta as a generalized variable-length integer.
				let q = delta;
				for (let k = base; /* no condition */; k += base) {
					const t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
					if (q < t) {
						break;
					}
					const qMinusT = q - t;
					const baseMinusT = base - t;
					output.push(
						stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
					);
					q = floor(qMinusT / baseMinusT);
				}

				output.push(stringFromCharCode(digitToBasic(q, 0)));
				bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
				delta = 0;
				++handledCPCount;
			}
		}

		++delta;
		++n;

	}
	return output.join('');
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
const toUnicode = function(input) {
	return mapDomain(input, function(string) {
		return regexPunycode.test(string)
			? decode(string.slice(4).toLowerCase())
			: string;
	});
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
const toASCII = function(input) {
	return mapDomain(input, function(string) {
		return regexNonASCII.test(string)
			? 'xn--' + encode(string)
			: string;
	});
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
const punycode = {
	/**
	 * A string representing the current Punycode.js version number.
	 * @memberOf punycode
	 * @type String
	 */
	'version': '2.1.0',
	/**
	 * An object of methods to convert from JavaScript's internal character
	 * representation (UCS-2) to Unicode code points, and back.
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode
	 * @type Object
	 */
	'ucs2': {
		'decode': ucs2decode,
		'encode': ucs2encode
	},
	'decode': decode,
	'encode': encode,
	'toASCII': toASCII,
	'toUnicode': toUnicode
};

module.exports = punycode;

      };
    };
  }
}, {package:"punycode",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\punycode\\punycode.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\slip44\\slip44.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\slip44\slip44.json
      return function (require, module, exports) {
module.exports={
  "0": {
    "index": "0",
    "hex": "0x80000000",
    "symbol": "BTC",
    "name": "Bitcoin",
    "link": "https://bitcoin.org"
  },
  "1": {
    "index": "1",
    "hex": "0x80000001",
    "symbol": "",
    "name": "Testnet (all coins)"
  },
  "2": {
    "index": "2",
    "hex": "0x80000002",
    "symbol": "LTC",
    "name": "Litecoin",
    "link": "https://litecoin.org"
  },
  "3": {
    "index": "3",
    "hex": "0x80000003",
    "symbol": "DOGE",
    "name": "Dogecoin",
    "link": "https://github.com/dogecoin/dogecoin"
  },
  "4": {
    "index": "4",
    "hex": "0x80000004",
    "symbol": "RDD",
    "name": "Reddcoin"
  },
  "5": {
    "index": "5",
    "hex": "0x80000005",
    "symbol": "DASH",
    "name": "Dash",
    "link": "https://github.com/dashpay/dash"
  },
  "6": {
    "index": "6",
    "hex": "0x80000006",
    "symbol": "PPC",
    "name": "Peercoin",
    "link": "https://peercoin.net"
  },
  "7": {
    "index": "7",
    "hex": "0x80000007",
    "symbol": "NMC",
    "name": "Namecoin",
    "link": "https://www.namecoin.org"
  },
  "8": {
    "index": "8",
    "hex": "0x80000008",
    "symbol": "FTC",
    "name": "Feathercoin",
    "link": "https://www.feathercoin.com"
  },
  "9": {
    "index": "9",
    "hex": "0x80000009",
    "symbol": "XCP",
    "name": "Counterparty",
    "link": "https://counterparty.io"
  },
  "10": {
    "index": "10",
    "hex": "0x8000000a",
    "symbol": "BLK",
    "name": "Blackcoin",
    "link": "https://blackcoin.org"
  },
  "11": {
    "index": "11",
    "hex": "0x8000000b",
    "symbol": "NSR",
    "name": "NuShares",
    "link": "https://nubits.com/nushares/introduction"
  },
  "12": {
    "index": "12",
    "hex": "0x8000000c",
    "symbol": "NBT",
    "name": "NuBits"
  },
  "13": {
    "index": "13",
    "hex": "0x8000000d",
    "symbol": "MZC",
    "name": "Mazacoin"
  },
  "14": {
    "index": "14",
    "hex": "0x8000000e",
    "symbol": "VIA",
    "name": "Viacoin"
  },
  "15": {
    "index": "15",
    "hex": "0x8000000f",
    "symbol": "XCH",
    "name": "ClearingHouse"
  },
  "16": {
    "index": "16",
    "hex": "0x80000010",
    "symbol": "RBY",
    "name": "Rubycoin"
  },
  "17": {
    "index": "17",
    "hex": "0x80000011",
    "symbol": "GRS",
    "name": "Groestlcoin"
  },
  "18": {
    "index": "18",
    "hex": "0x80000012",
    "symbol": "DGC",
    "name": "Digitalcoin"
  },
  "19": {
    "index": "19",
    "hex": "0x80000013",
    "symbol": "CCN",
    "name": "Cannacoin"
  },
  "20": {
    "index": "20",
    "hex": "0x80000014",
    "symbol": "DGB",
    "name": "DigiByte"
  },
  "21": {
    "index": "21",
    "hex": "0x80000015",
    "symbol": "",
    "name": "Open Assets",
    "link": "https://github.com/OpenAssets/open-assets-protocol"
  },
  "22": {
    "index": "22",
    "hex": "0x80000016",
    "symbol": "MONA",
    "name": "Monacoin"
  },
  "23": {
    "index": "23",
    "hex": "0x80000017",
    "symbol": "CLAM",
    "name": "Clams"
  },
  "24": {
    "index": "24",
    "hex": "0x80000018",
    "symbol": "XPM",
    "name": "Primecoin"
  },
  "25": {
    "index": "25",
    "hex": "0x80000019",
    "symbol": "NEOS",
    "name": "Neoscoin"
  },
  "26": {
    "index": "26",
    "hex": "0x8000001a",
    "symbol": "JBS",
    "name": "Jumbucks"
  },
  "27": {
    "index": "27",
    "hex": "0x8000001b",
    "symbol": "ZRC",
    "name": "ziftrCOIN"
  },
  "28": {
    "index": "28",
    "hex": "0x8000001c",
    "symbol": "VTC",
    "name": "Vertcoin"
  },
  "29": {
    "index": "29",
    "hex": "0x8000001d",
    "symbol": "NXT",
    "name": "NXT"
  },
  "30": {
    "index": "30",
    "hex": "0x8000001e",
    "symbol": "BURST",
    "name": "Burst"
  },
  "31": {
    "index": "31",
    "hex": "0x8000001f",
    "symbol": "MUE",
    "name": "MonetaryUnit"
  },
  "32": {
    "index": "32",
    "hex": "0x80000020",
    "symbol": "ZOOM",
    "name": "Zoom"
  },
  "33": {
    "index": "33",
    "hex": "0x80000021",
    "symbol": "VASH",
    "name": "Virtual Cash",
    "link": "http://www.bitnet.cc"
  },
  "34": {
    "index": "34",
    "hex": "0x80000022",
    "symbol": "CDN",
    "name": "Canada eCoin",
    "link": "https://github.com/Canada-eCoin"
  },
  "35": {
    "index": "35",
    "hex": "0x80000023",
    "symbol": "SDC",
    "name": "ShadowCash"
  },
  "36": {
    "index": "36",
    "hex": "0x80000024",
    "symbol": "PKB",
    "name": "ParkByte",
    "link": "https://github.com/parkbyte"
  },
  "37": {
    "index": "37",
    "hex": "0x80000025",
    "symbol": "PND",
    "name": "Pandacoin"
  },
  "38": {
    "index": "38",
    "hex": "0x80000026",
    "symbol": "START",
    "name": "StartCOIN"
  },
  "39": {
    "index": "39",
    "hex": "0x80000027",
    "symbol": "MOIN",
    "name": "MOIN",
    "link": "https://discovermoin.com"
  },
  "40": {
    "index": "40",
    "hex": "0x80000028",
    "symbol": "EXP",
    "name": "Expanse",
    "link": "https://expanse.tech"
  },
  "41": {
    "index": "41",
    "hex": "0x80000029",
    "symbol": "EMC2",
    "name": "Einsteinium",
    "link": "https://www.emc2.foundation"
  },
  "42": {
    "index": "42",
    "hex": "0x8000002a",
    "symbol": "DCR",
    "name": "Decred",
    "link": "https://decred.org"
  },
  "43": {
    "index": "43",
    "hex": "0x8000002b",
    "symbol": "XEM",
    "name": "NEM",
    "link": "https://github.com/NemProject"
  },
  "44": {
    "index": "44",
    "hex": "0x8000002c",
    "symbol": "PART",
    "name": "Particl",
    "link": "https://particl.io"
  },
  "45": {
    "index": "45",
    "hex": "0x8000002d",
    "symbol": "ARG",
    "name": "Argentum (dead)"
  },
  "46": {
    "index": "46",
    "hex": "0x8000002e",
    "symbol": "",
    "name": "Libertas",
    "link": "https://github.com/dangershony/Libertas"
  },
  "47": {
    "index": "47",
    "hex": "0x8000002f",
    "symbol": "",
    "name": "Posw coin",
    "link": "https://poswallet.com"
  },
  "48": {
    "index": "48",
    "hex": "0x80000030",
    "symbol": "SHR",
    "name": "Shreeji",
    "link": "https://github.com/SMJBIT/SHREEJI"
  },
  "49": {
    "index": "49",
    "hex": "0x80000031",
    "symbol": "GCR",
    "name": "Global Currency Reserve (GCRcoin)"
  },
  "50": {
    "index": "50",
    "hex": "0x80000032",
    "symbol": "NVC",
    "name": "Novacoin",
    "link": "https://github.com/novacoin-project/novacoin"
  },
  "51": {
    "index": "51",
    "hex": "0x80000033",
    "symbol": "AC",
    "name": "Asiacoin",
    "link": "https://github.com/AsiaCoin/AsiaCoinFix"
  },
  "52": {
    "index": "52",
    "hex": "0x80000034",
    "symbol": "BTCD",
    "name": "BitcoinDark",
    "link": "https://github.com/jl777/btcd"
  },
  "53": {
    "index": "53",
    "hex": "0x80000035",
    "symbol": "DOPE",
    "name": "Dopecoin",
    "link": "https://github.com/dopecoin-dev/DopeCoinV3"
  },
  "54": {
    "index": "54",
    "hex": "0x80000036",
    "symbol": "TPC",
    "name": "Templecoin",
    "link": "https://github.com/9cat/templecoin"
  },
  "55": {
    "index": "55",
    "hex": "0x80000037",
    "symbol": "AIB",
    "name": "AIB",
    "link": "https://github.com/iobond/aib"
  },
  "56": {
    "index": "56",
    "hex": "0x80000038",
    "symbol": "EDRC",
    "name": "EDRCoin",
    "link": "https://github.com/EDRCoin/EDRcoin-src"
  },
  "57": {
    "index": "57",
    "hex": "0x80000039",
    "symbol": "SYS",
    "name": "Syscoin",
    "link": "https://github.com/syscoin/syscoin2"
  },
  "58": {
    "index": "58",
    "hex": "0x8000003a",
    "symbol": "SLR",
    "name": "Solarcoin",
    "link": "https://github.com/onsightit/solarcoin"
  },
  "59": {
    "index": "59",
    "hex": "0x8000003b",
    "symbol": "SMLY",
    "name": "Smileycoin",
    "link": "https://github.com/tutor-web/smileyCoin"
  },
  "60": {
    "index": "60",
    "hex": "0x8000003c",
    "symbol": "ETH",
    "name": "Ethereum",
    "link": "https://ethereum.org"
  },
  "61": {
    "index": "61",
    "hex": "0x8000003d",
    "symbol": "ETC",
    "name": "Ether Classic",
    "link": "https://ethereumclassic.github.io"
  },
  "62": {
    "index": "62",
    "hex": "0x8000003e",
    "symbol": "PSB",
    "name": "Pesobit",
    "link": "https://github.com/pesobitph/pesobit-source"
  },
  "63": {
    "index": "63",
    "hex": "0x8000003f",
    "symbol": "LDCN",
    "name": "Landcoin (dead)"
  },
  "64": {
    "index": "64",
    "hex": "0x80000040",
    "symbol": "",
    "name": "Open Chain",
    "link": "https://github.com/openchain"
  },
  "65": {
    "index": "65",
    "hex": "0x80000041",
    "symbol": "XBC",
    "name": "Bitcoinplus",
    "link": "https://bitcoinplus.org"
  },
  "66": {
    "index": "66",
    "hex": "0x80000042",
    "symbol": "IOP",
    "name": "Internet of People",
    "link": "https://iop.global"
  },
  "67": {
    "index": "67",
    "hex": "0x80000043",
    "symbol": "NXS",
    "name": "Nexus",
    "link": "https://nexus.io"
  },
  "68": {
    "index": "68",
    "hex": "0x80000044",
    "symbol": "INSN",
    "name": "InsaneCoin",
    "link": "https://insane.network"
  },
  "69": {
    "index": "69",
    "hex": "0x80000045",
    "symbol": "OK",
    "name": "OKCash",
    "link": "https://github.com/okcashpro"
  },
  "70": {
    "index": "70",
    "hex": "0x80000046",
    "symbol": "BRIT",
    "name": "BritCoin",
    "link": "https://britcoin.com"
  },
  "71": {
    "index": "71",
    "hex": "0x80000047",
    "symbol": "CMP",
    "name": "Compcoin",
    "link": "https://compcoin.com"
  },
  "72": {
    "index": "72",
    "hex": "0x80000048",
    "symbol": "CRW",
    "name": "Crown",
    "link": "https://www.crownplatform.com"
  },
  "73": {
    "index": "73",
    "hex": "0x80000049",
    "symbol": "BELA",
    "name": "BelaCoin",
    "link": "http://belacoin.org"
  },
  "74": {
    "index": "74",
    "hex": "0x8000004a",
    "symbol": "ICX",
    "name": "ICON",
    "link": "https://icon.foundation"
  },
  "75": {
    "index": "75",
    "hex": "0x8000004b",
    "symbol": "FJC",
    "name": "FujiCoin",
    "link": "https://fujicoin.org"
  },
  "76": {
    "index": "76",
    "hex": "0x8000004c",
    "symbol": "MIX",
    "name": "MIX",
    "link": "https://www.mix-blockchain.org"
  },
  "77": {
    "index": "77",
    "hex": "0x8000004d",
    "symbol": "XVG",
    "name": "Verge Currency",
    "link": "https://vergecurrency.com"
  },
  "78": {
    "index": "78",
    "hex": "0x8000004e",
    "symbol": "EFL",
    "name": "Electronic Gulden",
    "link": "https://egulden.org"
  },
  "79": {
    "index": "79",
    "hex": "0x8000004f",
    "symbol": "CLUB",
    "name": "ClubCoin",
    "link": "https://clubcoin.co"
  },
  "80": {
    "index": "80",
    "hex": "0x80000050",
    "symbol": "RICHX",
    "name": "RichCoin",
    "link": "https://richcoin.us"
  },
  "81": {
    "index": "81",
    "hex": "0x80000051",
    "symbol": "POT",
    "name": "Potcoin",
    "link": "https://www.potcoin.com"
  },
  "82": {
    "index": "82",
    "hex": "0x80000052",
    "symbol": "QRK",
    "name": "Quarkcoin"
  },
  "83": {
    "index": "83",
    "hex": "0x80000053",
    "symbol": "TRC",
    "name": "Terracoin",
    "link": "https://terracoin.io"
  },
  "84": {
    "index": "84",
    "hex": "0x80000054",
    "symbol": "GRC",
    "name": "Gridcoin"
  },
  "85": {
    "index": "85",
    "hex": "0x80000055",
    "symbol": "AUR",
    "name": "Auroracoin",
    "link": "http://auroracoin.is"
  },
  "86": {
    "index": "86",
    "hex": "0x80000056",
    "symbol": "IXC",
    "name": "IXCoin"
  },
  "87": {
    "index": "87",
    "hex": "0x80000057",
    "symbol": "NLG",
    "name": "Gulden",
    "link": "https://Gulden.com"
  },
  "88": {
    "index": "88",
    "hex": "0x80000058",
    "symbol": "BITB",
    "name": "BitBean",
    "link": "http://bitbean.org"
  },
  "89": {
    "index": "89",
    "hex": "0x80000059",
    "symbol": "BTA",
    "name": "Bata",
    "link": "http://bata.io"
  },
  "90": {
    "index": "90",
    "hex": "0x8000005a",
    "symbol": "XMY",
    "name": "Myriadcoin",
    "link": "http://myriadcoin.org"
  },
  "91": {
    "index": "91",
    "hex": "0x8000005b",
    "symbol": "BSD",
    "name": "BitSend",
    "link": "http://bitsend.info"
  },
  "92": {
    "index": "92",
    "hex": "0x8000005c",
    "symbol": "UNO",
    "name": "Unobtanium",
    "link": "http://http://unobtanium.uno"
  },
  "93": {
    "index": "93",
    "hex": "0x8000005d",
    "symbol": "MTR",
    "name": "MasterTrader",
    "link": "https://github.com/CrypticApplications/MTR-Update"
  },
  "94": {
    "index": "94",
    "hex": "0x8000005e",
    "symbol": "GB",
    "name": "GoldBlocks",
    "link": "https://github.com/goldblockscoin/goldblocks"
  },
  "95": {
    "index": "95",
    "hex": "0x8000005f",
    "symbol": "SHM",
    "name": "Saham",
    "link": "https://github.com/SahamDev/SahamDev"
  },
  "96": {
    "index": "96",
    "hex": "0x80000060",
    "symbol": "CRX",
    "name": "Chronos",
    "link": "https://github.com/chronoscoin/Chronoscoin"
  },
  "97": {
    "index": "97",
    "hex": "0x80000061",
    "symbol": "BIQ",
    "name": "Ubiquoin",
    "link": "https://github.com/ubiquoin/ubiq"
  },
  "98": {
    "index": "98",
    "hex": "0x80000062",
    "symbol": "EVO",
    "name": "Evotion",
    "link": "https://github.com/evoshiun/Evotion"
  },
  "99": {
    "index": "99",
    "hex": "0x80000063",
    "symbol": "STO",
    "name": "SaveTheOcean",
    "link": "https://github.com/SaveTheOceanMovement/SaveTheOceanCoin"
  },
  "100": {
    "index": "100",
    "hex": "0x80000064",
    "symbol": "BIGUP",
    "name": "BigUp",
    "link": "https://github.com/BigUps"
  },
  "101": {
    "index": "101",
    "hex": "0x80000065",
    "symbol": "GAME",
    "name": "GameCredits",
    "link": "https://github.com/gamecredits-project"
  },
  "102": {
    "index": "102",
    "hex": "0x80000066",
    "symbol": "DLC",
    "name": "Dollarcoins",
    "link": "https://github.com/dollarcoins/source"
  },
  "103": {
    "index": "103",
    "hex": "0x80000067",
    "symbol": "ZYD",
    "name": "Zayedcoin",
    "link": "https://github.com/ZayedCoin/Zayedcoin"
  },
  "104": {
    "index": "104",
    "hex": "0x80000068",
    "symbol": "DBIC",
    "name": "Dubaicoin",
    "link": "https://github.com/DubaiCoinDev/DubaiCoin"
  },
  "105": {
    "index": "105",
    "hex": "0x80000069",
    "symbol": "STRAT",
    "name": "Stratis",
    "link": "http://www.stratisplatform.com"
  },
  "106": {
    "index": "106",
    "hex": "0x8000006a",
    "symbol": "SH",
    "name": "Shilling",
    "link": "https://github.com/yavwa/Shilling"
  },
  "107": {
    "index": "107",
    "hex": "0x8000006b",
    "symbol": "MARS",
    "name": "MarsCoin",
    "link": "http://www.marscoin.org"
  },
  "108": {
    "index": "108",
    "hex": "0x8000006c",
    "symbol": "UBQ",
    "name": "Ubiq",
    "link": "https://github.com/Ubiq"
  },
  "109": {
    "index": "109",
    "hex": "0x8000006d",
    "symbol": "PTC",
    "name": "Pesetacoin",
    "link": "http://pesetacoin.info"
  },
  "110": {
    "index": "110",
    "hex": "0x8000006e",
    "symbol": "NRO",
    "name": "Neurocoin",
    "link": "https://neurocoin.org"
  },
  "111": {
    "index": "111",
    "hex": "0x8000006f",
    "symbol": "ARK",
    "name": "ARK",
    "link": "https://ark.io"
  },
  "112": {
    "index": "112",
    "hex": "0x80000070",
    "symbol": "USC",
    "name": "UltimateSecureCashMain",
    "link": "http://ultimatesecurecash.info"
  },
  "113": {
    "index": "113",
    "hex": "0x80000071",
    "symbol": "THC",
    "name": "Hempcoin",
    "link": "http://hempcoin.org"
  },
  "114": {
    "index": "114",
    "hex": "0x80000072",
    "symbol": "LINX",
    "name": "Linx",
    "link": "https://mylinx.io"
  },
  "115": {
    "index": "115",
    "hex": "0x80000073",
    "symbol": "ECN",
    "name": "Ecoin",
    "link": "https://www.ecoinsource.com"
  },
  "116": {
    "index": "116",
    "hex": "0x80000074",
    "symbol": "DNR",
    "name": "Denarius",
    "link": "https://denarius.io"
  },
  "117": {
    "index": "117",
    "hex": "0x80000075",
    "symbol": "PINK",
    "name": "Pinkcoin",
    "link": "http://getstarted.with.pink"
  },
  "118": {
    "index": "118",
    "hex": "0x80000076",
    "symbol": "ATOM",
    "name": "Atom",
    "link": "https://cosmos.network"
  },
  "119": {
    "index": "119",
    "hex": "0x80000077",
    "symbol": "PIVX",
    "name": "Pivx",
    "link": "https://github.com/PIVX-Project/PIVX"
  },
  "120": {
    "index": "120",
    "hex": "0x80000078",
    "symbol": "FLASH",
    "name": "Flashcoin",
    "link": "https://flashcoin.io"
  },
  "121": {
    "index": "121",
    "hex": "0x80000079",
    "symbol": "ZEN",
    "name": "Zencash",
    "link": "https://zensystem.io"
  },
  "122": {
    "index": "122",
    "hex": "0x8000007a",
    "symbol": "PUT",
    "name": "Putincoin",
    "link": "https://putincoin.info"
  },
  "123": {
    "index": "123",
    "hex": "0x8000007b",
    "symbol": "ZNY",
    "name": "BitZeny",
    "link": "https://bitzeny.tech"
  },
  "124": {
    "index": "124",
    "hex": "0x8000007c",
    "symbol": "UNIFY",
    "name": "Unify",
    "link": "http://unifycryptocurrency.com"
  },
  "125": {
    "index": "125",
    "hex": "0x8000007d",
    "symbol": "XST",
    "name": "StealthCoin",
    "link": "http://www.stealthcoin.com"
  },
  "126": {
    "index": "126",
    "hex": "0x8000007e",
    "symbol": "BRK",
    "name": "Breakout Coin",
    "link": "http://www.breakoutcoin.com"
  },
  "127": {
    "index": "127",
    "hex": "0x8000007f",
    "symbol": "VC",
    "name": "Vcash",
    "link": "https://vcash.info"
  },
  "128": {
    "index": "128",
    "hex": "0x80000080",
    "symbol": "XMR",
    "name": "Monero",
    "link": "https://getmonero.org"
  },
  "129": {
    "index": "129",
    "hex": "0x80000081",
    "symbol": "VOX",
    "name": "Voxels",
    "link": "https://www.voxelus.com"
  },
  "130": {
    "index": "130",
    "hex": "0x80000082",
    "symbol": "NAV",
    "name": "NavCoin",
    "link": "https://github.com/navcoindev/navcoin2"
  },
  "131": {
    "index": "131",
    "hex": "0x80000083",
    "symbol": "FCT",
    "name": "Factom Factoids",
    "link": "https://github.com/FactomProject/FactomDocs/blob/master/wallet_info/wallet_test_vectors.md"
  },
  "132": {
    "index": "132",
    "hex": "0x80000084",
    "symbol": "EC",
    "name": "Factom Entry Credits",
    "link": "https://github.com/FactomProject"
  },
  "133": {
    "index": "133",
    "hex": "0x80000085",
    "symbol": "ZEC",
    "name": "Zcash",
    "link": "https://z.cash"
  },
  "134": {
    "index": "134",
    "hex": "0x80000086",
    "symbol": "LSK",
    "name": "Lisk",
    "link": "https://lisk.io"
  },
  "135": {
    "index": "135",
    "hex": "0x80000087",
    "symbol": "STEEM",
    "name": "Steem",
    "link": "http://steem.io"
  },
  "136": {
    "index": "136",
    "hex": "0x80000088",
    "symbol": "XZC",
    "name": "ZCoin",
    "link": "https://zcoin.io"
  },
  "137": {
    "index": "137",
    "hex": "0x80000089",
    "symbol": "RBTC",
    "name": "RSK",
    "link": "http://www.rsk.co"
  },
  "138": {
    "index": "138",
    "hex": "0x8000008a",
    "symbol": "",
    "name": "Giftblock",
    "link": "https://github.com/gyft/giftblock"
  },
  "139": {
    "index": "139",
    "hex": "0x8000008b",
    "symbol": "RPT",
    "name": "RealPointCoin",
    "link": "https://github.com/MaxSmile/RealPointCoinQt"
  },
  "140": {
    "index": "140",
    "hex": "0x8000008c",
    "symbol": "LBC",
    "name": "LBRY Credits",
    "link": "https://lbry.io"
  },
  "141": {
    "index": "141",
    "hex": "0x8000008d",
    "symbol": "KMD",
    "name": "Komodo",
    "link": "https://komodoplatform.com"
  },
  "142": {
    "index": "142",
    "hex": "0x8000008e",
    "symbol": "BSQ",
    "name": "bisq Token",
    "link": "http://bisq.io"
  },
  "143": {
    "index": "143",
    "hex": "0x8000008f",
    "symbol": "RIC",
    "name": "Riecoin",
    "link": "https://github.com/riecoin/riecoin"
  },
  "144": {
    "index": "144",
    "hex": "0x80000090",
    "symbol": "XRP",
    "name": "Ripple",
    "link": "https://ripple.com"
  },
  "145": {
    "index": "145",
    "hex": "0x80000091",
    "symbol": "BCH",
    "name": "Bitcoin Cash",
    "link": "https://www.bitcoincash.org"
  },
  "146": {
    "index": "146",
    "hex": "0x80000092",
    "symbol": "NEBL",
    "name": "Neblio",
    "link": "https://nebl.io"
  },
  "147": {
    "index": "147",
    "hex": "0x80000093",
    "symbol": "ZCL",
    "name": "ZClassic",
    "link": "http://zclassic.org"
  },
  "148": {
    "index": "148",
    "hex": "0x80000094",
    "symbol": "XLM",
    "name": "Stellar Lumens",
    "link": "https://www.stellar.org"
  },
  "149": {
    "index": "149",
    "hex": "0x80000095",
    "symbol": "NLC2",
    "name": "NoLimitCoin2",
    "link": "http://www.nolimitcoin.org"
  },
  "150": {
    "index": "150",
    "hex": "0x80000096",
    "symbol": "WHL",
    "name": "WhaleCoin",
    "link": "https://whalecoin.org"
  },
  "151": {
    "index": "151",
    "hex": "0x80000097",
    "symbol": "ERC",
    "name": "EuropeCoin",
    "link": "https://www.europecoin.eu.org"
  },
  "152": {
    "index": "152",
    "hex": "0x80000098",
    "symbol": "DMD",
    "name": "Diamond",
    "link": "http://bit.diamonds"
  },
  "153": {
    "index": "153",
    "hex": "0x80000099",
    "symbol": "BTM",
    "name": "Bytom",
    "link": "https://bytom.io"
  },
  "154": {
    "index": "154",
    "hex": "0x8000009a",
    "symbol": "BIO",
    "name": "Biocoin",
    "link": "https://biocoin.bio"
  },
  "155": {
    "index": "155",
    "hex": "0x8000009b",
    "symbol": "XWCC",
    "name": "Whitecoin Classic",
    "link": "https://old.whitecoin.info"
  },
  "156": {
    "index": "156",
    "hex": "0x8000009c",
    "symbol": "BTG",
    "name": "Bitcoin Gold",
    "link": "http://www.btcgpu.org"
  },
  "157": {
    "index": "157",
    "hex": "0x8000009d",
    "symbol": "BTC2X",
    "name": "Bitcoin 2x",
    "link": "https://medium.com/@DCGco/bitcoin-scaling-agreement-at-consensus-2017-133521fe9a77"
  },
  "158": {
    "index": "158",
    "hex": "0x8000009e",
    "symbol": "SSN",
    "name": "SuperSkynet",
    "link": "http://wwww.superskynet.org"
  },
  "159": {
    "index": "159",
    "hex": "0x8000009f",
    "symbol": "TOA",
    "name": "TOACoin",
    "link": "http://www.toacoin.com"
  },
  "160": {
    "index": "160",
    "hex": "0x800000a0",
    "symbol": "BTX",
    "name": "Bitcore",
    "link": "https://bitcore.cc"
  },
  "161": {
    "index": "161",
    "hex": "0x800000a1",
    "symbol": "ACC",
    "name": "Adcoin",
    "link": "https://www.getadcoin.com"
  },
  "162": {
    "index": "162",
    "hex": "0x800000a2",
    "symbol": "BCO",
    "name": "Bridgecoin",
    "link": "https://bridgecoin.org"
  },
  "163": {
    "index": "163",
    "hex": "0x800000a3",
    "symbol": "ELLA",
    "name": "Ellaism",
    "link": "https://ellaism.org"
  },
  "164": {
    "index": "164",
    "hex": "0x800000a4",
    "symbol": "PIRL",
    "name": "Pirl",
    "link": "https://pirl.io"
  },
  "165": {
    "index": "165",
    "hex": "0x800000a5",
    "symbol": "XNO",
    "name": "Nano",
    "link": "https://nano.org"
  },
  "166": {
    "index": "166",
    "hex": "0x800000a6",
    "symbol": "VIVO",
    "name": "Vivo",
    "link": "https://www.vivocrypto.com"
  },
  "167": {
    "index": "167",
    "hex": "0x800000a7",
    "symbol": "FRST",
    "name": "Firstcoin",
    "link": "http://firstcoinproject.com"
  },
  "168": {
    "index": "168",
    "hex": "0x800000a8",
    "symbol": "HNC",
    "name": "Helleniccoin",
    "link": "http://www.helleniccoin.gr"
  },
  "169": {
    "index": "169",
    "hex": "0x800000a9",
    "symbol": "BUZZ",
    "name": "BUZZ",
    "link": "http://www.buzzcoin.info"
  },
  "170": {
    "index": "170",
    "hex": "0x800000aa",
    "symbol": "MBRS",
    "name": "Ember",
    "link": "https://www.embercoin.io"
  },
  "171": {
    "index": "171",
    "hex": "0x800000ab",
    "symbol": "HC",
    "name": "Hcash",
    "link": "https://h.cash"
  },
  "172": {
    "index": "172",
    "hex": "0x800000ac",
    "symbol": "HTML",
    "name": "HTMLCOIN",
    "link": "https://htmlcoin.com"
  },
  "173": {
    "index": "173",
    "hex": "0x800000ad",
    "symbol": "ODN",
    "name": "Obsidian",
    "link": "https://obsidianplatform.com"
  },
  "174": {
    "index": "174",
    "hex": "0x800000ae",
    "symbol": "ONX",
    "name": "OnixCoin",
    "link": "https://www.onixcoin.com"
  },
  "175": {
    "index": "175",
    "hex": "0x800000af",
    "symbol": "RVN",
    "name": "Ravencoin",
    "link": "https://ravencoin.org"
  },
  "176": {
    "index": "176",
    "hex": "0x800000b0",
    "symbol": "GBX",
    "name": "GoByte",
    "link": "https://gobyte.network"
  },
  "177": {
    "index": "177",
    "hex": "0x800000b1",
    "symbol": "BTCZ",
    "name": "BitcoinZ",
    "link": "https://btcz.rocks/en"
  },
  "178": {
    "index": "178",
    "hex": "0x800000b2",
    "symbol": "POA",
    "name": "Poa",
    "link": "https://poa.network"
  },
  "179": {
    "index": "179",
    "hex": "0x800000b3",
    "symbol": "NYC",
    "name": "NewYorkCoin",
    "link": "http://nycoin.net"
  },
  "180": {
    "index": "180",
    "hex": "0x800000b4",
    "symbol": "MXT",
    "name": "MarteXcoin",
    "link": "http://martexcoin.org"
  },
  "181": {
    "index": "181",
    "hex": "0x800000b5",
    "symbol": "WC",
    "name": "Wincoin",
    "link": "https://wincoin.co"
  },
  "182": {
    "index": "182",
    "hex": "0x800000b6",
    "symbol": "MNX",
    "name": "Minexcoin",
    "link": "https://minexcoin.com"
  },
  "183": {
    "index": "183",
    "hex": "0x800000b7",
    "symbol": "BTCP",
    "name": "Bitcoin Private",
    "link": "https://btcprivate.org"
  },
  "184": {
    "index": "184",
    "hex": "0x800000b8",
    "symbol": "MUSIC",
    "name": "Musicoin",
    "link": "https://www.musicoin.org"
  },
  "185": {
    "index": "185",
    "hex": "0x800000b9",
    "symbol": "BCA",
    "name": "Bitcoin Atom",
    "link": "https://bitcoinatom.io"
  },
  "186": {
    "index": "186",
    "hex": "0x800000ba",
    "symbol": "CRAVE",
    "name": "Crave",
    "link": "https://craveproject.net"
  },
  "187": {
    "index": "187",
    "hex": "0x800000bb",
    "symbol": "STAK",
    "name": "STRAKS",
    "link": "https://straks.io"
  },
  "188": {
    "index": "188",
    "hex": "0x800000bc",
    "symbol": "WBTC",
    "name": "World Bitcoin",
    "link": "http://www.wbtcteam.org"
  },
  "189": {
    "index": "189",
    "hex": "0x800000bd",
    "symbol": "LCH",
    "name": "LiteCash",
    "link": "http://www.litecash.info"
  },
  "190": {
    "index": "190",
    "hex": "0x800000be",
    "symbol": "EXCL",
    "name": "ExclusiveCoin",
    "link": "https://exclusivecoin.pw"
  },
  "191": {
    "index": "191",
    "hex": "0x800000bf",
    "symbol": "",
    "name": "Lynx",
    "link": "https://getlynx.io"
  },
  "192": {
    "index": "192",
    "hex": "0x800000c0",
    "symbol": "LCC",
    "name": "LitecoinCash",
    "link": "https://litecoinca.sh"
  },
  "193": {
    "index": "193",
    "hex": "0x800000c1",
    "symbol": "XFE",
    "name": "Feirm",
    "link": "https://www.feirm.com"
  },
  "194": {
    "index": "194",
    "hex": "0x800000c2",
    "symbol": "EOS",
    "name": "EOS",
    "link": "https://eos.io"
  },
  "195": {
    "index": "195",
    "hex": "0x800000c3",
    "symbol": "TRX",
    "name": "Tron",
    "link": "https://tron.network/enindex.html"
  },
  "196": {
    "index": "196",
    "hex": "0x800000c4",
    "symbol": "KOBO",
    "name": "Kobocoin",
    "link": "https://kobocoin.com"
  },
  "197": {
    "index": "197",
    "hex": "0x800000c5",
    "symbol": "HUSH",
    "name": "HUSH",
    "link": "https://myhush.org"
  },
  "198": {
    "index": "198",
    "hex": "0x800000c6",
    "symbol": "BANANO",
    "name": "Bananos",
    "link": "https://banano.co.in"
  },
  "199": {
    "index": "199",
    "hex": "0x800000c7",
    "symbol": "ETF",
    "name": "ETF",
    "link": "http://ethereumfog.org"
  },
  "200": {
    "index": "200",
    "hex": "0x800000c8",
    "symbol": "OMNI",
    "name": "Omni",
    "link": "http://www.omnilayer.org"
  },
  "201": {
    "index": "201",
    "hex": "0x800000c9",
    "symbol": "BIFI",
    "name": "BitcoinFile",
    "link": "https://www.bitcoinfile.org"
  },
  "202": {
    "index": "202",
    "hex": "0x800000ca",
    "symbol": "UFO",
    "name": "Uniform Fiscal Object",
    "link": "https://ufobject.com"
  },
  "203": {
    "index": "203",
    "hex": "0x800000cb",
    "symbol": "CNMC",
    "name": "Cryptonodes",
    "link": "https://www.cryptonodes.ch"
  },
  "204": {
    "index": "204",
    "hex": "0x800000cc",
    "symbol": "BCN",
    "name": "Bytecoin",
    "link": "http://bytecoin.org"
  },
  "205": {
    "index": "205",
    "hex": "0x800000cd",
    "symbol": "RIN",
    "name": "Ringo",
    "link": "http://dkwzjw.github.io/ringo"
  },
  "206": {
    "index": "206",
    "hex": "0x800000ce",
    "symbol": "ATP",
    "name": "PlatON",
    "link": "https://www.platon.network"
  },
  "207": {
    "index": "207",
    "hex": "0x800000cf",
    "symbol": "EVT",
    "name": "everiToken",
    "link": "https://everiToken.io"
  },
  "208": {
    "index": "208",
    "hex": "0x800000d0",
    "symbol": "ATN",
    "name": "ATN",
    "link": "https://atn.io"
  },
  "209": {
    "index": "209",
    "hex": "0x800000d1",
    "symbol": "BIS",
    "name": "Bismuth",
    "link": "http://www.bismuth.cz"
  },
  "210": {
    "index": "210",
    "hex": "0x800000d2",
    "symbol": "NEET",
    "name": "NEETCOIN",
    "link": "https://neetcoin.jp"
  },
  "211": {
    "index": "211",
    "hex": "0x800000d3",
    "symbol": "BOPO",
    "name": "BopoChain",
    "link": "http://www.bopochain.org"
  },
  "212": {
    "index": "212",
    "hex": "0x800000d4",
    "symbol": "OOT",
    "name": "Utrum",
    "link": "https://utrum.io/ootcoin"
  },
  "213": {
    "index": "213",
    "hex": "0x800000d5",
    "symbol": "ALIAS",
    "name": "Alias",
    "link": "https://alias.cash"
  },
  "214": {
    "index": "214",
    "hex": "0x800000d6",
    "symbol": "MONK",
    "name": "Monkey Project",
    "link": "https://www.monkey.vision"
  },
  "215": {
    "index": "215",
    "hex": "0x800000d7",
    "symbol": "BOXY",
    "name": "BoxyCoin",
    "link": "http://www.boxycoin.org"
  },
  "216": {
    "index": "216",
    "hex": "0x800000d8",
    "symbol": "FLO",
    "name": "Flo",
    "link": "https://www.flo.cash"
  },
  "217": {
    "index": "217",
    "hex": "0x800000d9",
    "symbol": "MEC",
    "name": "Megacoin",
    "link": "https://www.megacoin.eu"
  },
  "218": {
    "index": "218",
    "hex": "0x800000da",
    "symbol": "BTDX",
    "name": "BitCloud",
    "link": "https://bit-cloud.info"
  },
  "219": {
    "index": "219",
    "hex": "0x800000db",
    "symbol": "XAX",
    "name": "Artax",
    "link": "https://www.artaxcoin.org"
  },
  "220": {
    "index": "220",
    "hex": "0x800000dc",
    "symbol": "ANON",
    "name": "ANON",
    "link": "https://www.anonfork.io"
  },
  "221": {
    "index": "221",
    "hex": "0x800000dd",
    "symbol": "LTZ",
    "name": "LitecoinZ",
    "link": "https://litecoinz.org"
  },
  "222": {
    "index": "222",
    "hex": "0x800000de",
    "symbol": "BITG",
    "name": "Bitcoin Green",
    "link": "https://savebitcoin.io"
  },
  "223": {
    "index": "223",
    "hex": "0x800000df",
    "symbol": "ICP",
    "name": "Internet Computer (DFINITY)",
    "link": "DFINITY"
  },
  "224": {
    "index": "224",
    "hex": "0x800000e0",
    "symbol": "SMART",
    "name": "Smartcash",
    "link": "https://smartcash.cc"
  },
  "225": {
    "index": "225",
    "hex": "0x800000e1",
    "symbol": "XUEZ",
    "name": "XUEZ",
    "link": "https://xuezcoin.com"
  },
  "226": {
    "index": "226",
    "hex": "0x800000e2",
    "symbol": "HLM",
    "name": "Helium",
    "link": "https://www.heliumlabs.org"
  },
  "227": {
    "index": "227",
    "hex": "0x800000e3",
    "symbol": "WEB",
    "name": "Webchain",
    "link": "https://webchain.network"
  },
  "228": {
    "index": "228",
    "hex": "0x800000e4",
    "symbol": "ACM",
    "name": "Actinium",
    "link": "https://actinium.org"
  },
  "229": {
    "index": "229",
    "hex": "0x800000e5",
    "symbol": "NOS",
    "name": "NOS Stable Coins",
    "link": "https://nos.cash"
  },
  "230": {
    "index": "230",
    "hex": "0x800000e6",
    "symbol": "BITC",
    "name": "BitCash",
    "link": "https://www.choosebitcash.com"
  },
  "231": {
    "index": "231",
    "hex": "0x800000e7",
    "symbol": "HTH",
    "name": "Help The Homeless Coin",
    "link": "https://hthcoin.world"
  },
  "232": {
    "index": "232",
    "hex": "0x800000e8",
    "symbol": "TZC",
    "name": "Trezarcoin",
    "link": "https://trezarcoin.com"
  },
  "233": {
    "index": "233",
    "hex": "0x800000e9",
    "symbol": "VAR",
    "name": "Varda",
    "link": "https://varda.io"
  },
  "234": {
    "index": "234",
    "hex": "0x800000ea",
    "symbol": "IOV",
    "name": "IOV",
    "link": "https://www.iov.one"
  },
  "235": {
    "index": "235",
    "hex": "0x800000eb",
    "symbol": "FIO",
    "name": "FIO",
    "link": "https://fioprotocol.io"
  },
  "236": {
    "index": "236",
    "hex": "0x800000ec",
    "symbol": "BSV",
    "name": "BitcoinSV",
    "link": "https://bitcoinsv.io"
  },
  "237": {
    "index": "237",
    "hex": "0x800000ed",
    "symbol": "DXN",
    "name": "DEXON",
    "link": "https://dexon.org"
  },
  "238": {
    "index": "238",
    "hex": "0x800000ee",
    "symbol": "QRL",
    "name": "Quantum Resistant Ledger",
    "link": "https://www.theqrl.org"
  },
  "239": {
    "index": "239",
    "hex": "0x800000ef",
    "symbol": "PCX",
    "name": "ChainX",
    "link": "https://github.com/chainx-org/ChainX"
  },
  "240": {
    "index": "240",
    "hex": "0x800000f0",
    "symbol": "LOKI",
    "name": "Loki",
    "link": "https://github.com/loki-project/loki"
  },
  "241": {
    "index": "241",
    "hex": "0x800000f1",
    "symbol": "",
    "name": "Imagewallet",
    "link": "https://imagewallet.io"
  },
  "242": {
    "index": "242",
    "hex": "0x800000f2",
    "symbol": "NIM",
    "name": "Nimiq",
    "link": "https://nimiq.com"
  },
  "243": {
    "index": "243",
    "hex": "0x800000f3",
    "symbol": "SOV",
    "name": "Sovereign Coin",
    "link": "http://www.sovcore.org"
  },
  "244": {
    "index": "244",
    "hex": "0x800000f4",
    "symbol": "JCT",
    "name": "Jibital Coin",
    "link": "https://jibital.ir"
  },
  "245": {
    "index": "245",
    "hex": "0x800000f5",
    "symbol": "SLP",
    "name": "Simple Ledger Protocol",
    "link": "https://simpleledger.cash"
  },
  "246": {
    "index": "246",
    "hex": "0x800000f6",
    "symbol": "EWT",
    "name": "Energy Web",
    "link": "https://energyweb.org"
  },
  "247": {
    "index": "247",
    "hex": "0x800000f7",
    "symbol": "UC",
    "name": "Ulord",
    "link": "http://ulord.one"
  },
  "248": {
    "index": "248",
    "hex": "0x800000f8",
    "symbol": "EXOS",
    "name": "EXOS",
    "link": "https://economy.openexo.com"
  },
  "249": {
    "index": "249",
    "hex": "0x800000f9",
    "symbol": "ECA",
    "name": "Electra",
    "link": "https://www.electraproject.org"
  },
  "250": {
    "index": "250",
    "hex": "0x800000fa",
    "symbol": "SOOM",
    "name": "Soom",
    "link": "http://www.fourthblockchain.org"
  },
  "251": {
    "index": "251",
    "hex": "0x800000fb",
    "symbol": "XRD",
    "name": "Redstone",
    "link": "https://www.redstoneplatform.com"
  },
  "252": {
    "index": "252",
    "hex": "0x800000fc",
    "symbol": "FREE",
    "name": "FreeCoin",
    "link": "https://web.freepay.biz"
  },
  "253": {
    "index": "253",
    "hex": "0x800000fd",
    "symbol": "NPW",
    "name": "NewPowerCoin",
    "link": "https://npw.live"
  },
  "254": {
    "index": "254",
    "hex": "0x800000fe",
    "symbol": "BST",
    "name": "BlockStamp",
    "link": "https://blockstamp.info"
  },
  "255": {
    "index": "255",
    "hex": "0x800000ff",
    "symbol": "",
    "name": "SmartHoldem",
    "link": "https://smartholdem.io"
  },
  "256": {
    "index": "256",
    "hex": "0x80000100",
    "symbol": "NANO",
    "name": "Bitcoin Nano",
    "link": "https://www.btcnano.org"
  },
  "257": {
    "index": "257",
    "hex": "0x80000101",
    "symbol": "BTCC",
    "name": "Bitcoin Core",
    "link": "https://thebitcoincore.org"
  },
  "258": {
    "index": "258",
    "hex": "0x80000102",
    "symbol": "",
    "name": "Zen Protocol",
    "link": "https://www.zenprotocol.com"
  },
  "259": {
    "index": "259",
    "hex": "0x80000103",
    "symbol": "ZEST",
    "name": "Zest",
    "link": "https://www.zestcoin.io"
  },
  "260": {
    "index": "260",
    "hex": "0x80000104",
    "symbol": "ABT",
    "name": "ArcBlock",
    "link": "https://arcblock.io"
  },
  "261": {
    "index": "261",
    "hex": "0x80000105",
    "symbol": "PION",
    "name": "Pion",
    "link": "https://pioncoin.org"
  },
  "262": {
    "index": "262",
    "hex": "0x80000106",
    "symbol": "DT3",
    "name": "DreamTeam3",
    "link": "https://crypto-dreamteam.com"
  },
  "263": {
    "index": "263",
    "hex": "0x80000107",
    "symbol": "ZBUX",
    "name": "Zbux",
    "link": "https://z-bux.org"
  },
  "264": {
    "index": "264",
    "hex": "0x80000108",
    "symbol": "KPL",
    "name": "Kepler",
    "link": "https://kepler.cash"
  },
  "265": {
    "index": "265",
    "hex": "0x80000109",
    "symbol": "TPAY",
    "name": "TokenPay",
    "link": "https://tokenpay.com"
  },
  "266": {
    "index": "266",
    "hex": "0x8000010a",
    "symbol": "ZILLA",
    "name": "ChainZilla",
    "link": "https://www.chainzilla.io"
  },
  "267": {
    "index": "267",
    "hex": "0x8000010b",
    "symbol": "ANK",
    "name": "Anker",
    "link": "https://ankerid.com"
  },
  "268": {
    "index": "268",
    "hex": "0x8000010c",
    "symbol": "BCC",
    "name": "BCChain",
    "link": "https://github.com/bc-chain/BCC"
  },
  "269": {
    "index": "269",
    "hex": "0x8000010d",
    "symbol": "HPB",
    "name": "HPB",
    "link": "https://hpb.io"
  },
  "270": {
    "index": "270",
    "hex": "0x8000010e",
    "symbol": "ONE",
    "name": "ONE",
    "link": "http://www.onechain.one"
  },
  "271": {
    "index": "271",
    "hex": "0x8000010f",
    "symbol": "SBC",
    "name": "SBC",
    "link": "http://www.smartbitcoin.one"
  },
  "272": {
    "index": "272",
    "hex": "0x80000110",
    "symbol": "IPC",
    "name": "IPChain",
    "link": "https://www.ipcchain.org"
  },
  "273": {
    "index": "273",
    "hex": "0x80000111",
    "symbol": "DMTC",
    "name": "Dominantchain",
    "link": "https://dominantchain.com"
  },
  "274": {
    "index": "274",
    "hex": "0x80000112",
    "symbol": "OGC",
    "name": "Onegram",
    "link": "https://onegram.org"
  },
  "275": {
    "index": "275",
    "hex": "0x80000113",
    "symbol": "SHIT",
    "name": "Shitcoin",
    "link": "https://shitcoin.org"
  },
  "276": {
    "index": "276",
    "hex": "0x80000114",
    "symbol": "ANDES",
    "name": "Andescoin",
    "link": "https://andes-coin.com"
  },
  "277": {
    "index": "277",
    "hex": "0x80000115",
    "symbol": "AREPA",
    "name": "Arepacoin",
    "link": "https://arepacoinve.info"
  },
  "278": {
    "index": "278",
    "hex": "0x80000116",
    "symbol": "BOLI",
    "name": "Bolivarcoin",
    "link": "https://bolis.info"
  },
  "279": {
    "index": "279",
    "hex": "0x80000117",
    "symbol": "RIL",
    "name": "Rilcoin",
    "link": "https://www.rilcoincrypto.org"
  },
  "280": {
    "index": "280",
    "hex": "0x80000118",
    "symbol": "HTR",
    "name": "Hathor Network",
    "link": "https://hathor.network"
  },
  "281": {
    "index": "281",
    "hex": "0x80000119",
    "symbol": "FCTID",
    "name": "Factom ID",
    "link": "https://github.com/FactomProject"
  },
  "282": {
    "index": "282",
    "hex": "0x8000011a",
    "symbol": "BRAVO",
    "name": "BRAVO",
    "link": "https://bravocoin.com"
  },
  "283": {
    "index": "283",
    "hex": "0x8000011b",
    "symbol": "ALGO",
    "name": "Algorand",
    "link": "https://www.algorand.com"
  },
  "284": {
    "index": "284",
    "hex": "0x8000011c",
    "symbol": "BZX",
    "name": "Bitcoinzero",
    "link": "https://bitcoinzerox.net"
  },
  "285": {
    "index": "285",
    "hex": "0x8000011d",
    "symbol": "GXX",
    "name": "GravityCoin",
    "link": "https://www.gravitycoin.io"
  },
  "286": {
    "index": "286",
    "hex": "0x8000011e",
    "symbol": "HEAT",
    "name": "HEAT",
    "link": "https://heatledger.com"
  },
  "287": {
    "index": "287",
    "hex": "0x8000011f",
    "symbol": "XDN",
    "name": "DigitalNote",
    "link": "https://digitalnote.biz"
  },
  "288": {
    "index": "288",
    "hex": "0x80000120",
    "symbol": "FSN",
    "name": "FUSION",
    "link": "https://www.fusion.org"
  },
  "289": {
    "index": "289",
    "hex": "0x80000121",
    "symbol": "CPC",
    "name": "Capricoin",
    "link": "https://capricoin.org"
  },
  "290": {
    "index": "290",
    "hex": "0x80000122",
    "symbol": "BOLD",
    "name": "Bold",
    "link": "https://boldprivate.network"
  },
  "291": {
    "index": "291",
    "hex": "0x80000123",
    "symbol": "IOST",
    "name": "IOST",
    "link": "https://iost.io"
  },
  "292": {
    "index": "292",
    "hex": "0x80000124",
    "symbol": "TKEY",
    "name": "Tkeycoin",
    "link": "https://tkeycoin.com"
  },
  "293": {
    "index": "293",
    "hex": "0x80000125",
    "symbol": "USE",
    "name": "Usechain",
    "link": "https://usechain.net"
  },
  "294": {
    "index": "294",
    "hex": "0x80000126",
    "symbol": "BCZ",
    "name": "BitcoinCZ",
    "link": "https://www.bitcoincz.org"
  },
  "295": {
    "index": "295",
    "hex": "0x80000127",
    "symbol": "IOC",
    "name": "Iocoin",
    "link": "https://iocoin.io"
  },
  "296": {
    "index": "296",
    "hex": "0x80000128",
    "symbol": "ASF",
    "name": "Asofe",
    "link": "https://github.com/TheLightSide/asofe"
  },
  "297": {
    "index": "297",
    "hex": "0x80000129",
    "symbol": "MASS",
    "name": "MASS",
    "link": "https://www.massnet.org"
  },
  "298": {
    "index": "298",
    "hex": "0x8000012a",
    "symbol": "FAIR",
    "name": "FairCoin",
    "link": "https://faircoin.world"
  },
  "299": {
    "index": "299",
    "hex": "0x8000012b",
    "symbol": "NUKO",
    "name": "Nekonium",
    "link": "https://nekonium.github.io"
  },
  "300": {
    "index": "300",
    "hex": "0x8000012c",
    "symbol": "GNX",
    "name": "Genaro Network",
    "link": "https://genaro.network"
  },
  "301": {
    "index": "301",
    "hex": "0x8000012d",
    "symbol": "DIVI",
    "name": "Divi Project",
    "link": "https://diviproject.org"
  },
  "302": {
    "index": "302",
    "hex": "0x8000012e",
    "symbol": "CMT",
    "name": "Community",
    "link": "https://thecriptocommunity.com"
  },
  "303": {
    "index": "303",
    "hex": "0x8000012f",
    "symbol": "EUNO",
    "name": "EUNO",
    "link": "https://euno.co"
  },
  "304": {
    "index": "304",
    "hex": "0x80000130",
    "symbol": "IOTX",
    "name": "IoTeX",
    "link": "https://iotex.io"
  },
  "305": {
    "index": "305",
    "hex": "0x80000131",
    "symbol": "ONION",
    "name": "DeepOnion",
    "link": "https://deeponion.org"
  },
  "306": {
    "index": "306",
    "hex": "0x80000132",
    "symbol": "8BIT",
    "name": "8Bit",
    "link": "https://8bit.cash"
  },
  "307": {
    "index": "307",
    "hex": "0x80000133",
    "symbol": "ATC",
    "name": "AToken Coin",
    "link": "https://www.atoken.com"
  },
  "308": {
    "index": "308",
    "hex": "0x80000134",
    "symbol": "BTS",
    "name": "Bitshares",
    "link": "https://bitshares.org"
  },
  "309": {
    "index": "309",
    "hex": "0x80000135",
    "symbol": "CKB",
    "name": "Nervos CKB",
    "link": "https://www.nervos.org"
  },
  "310": {
    "index": "310",
    "hex": "0x80000136",
    "symbol": "UGAS",
    "name": "Ultrain",
    "link": "https://www.ultrain.io"
  },
  "311": {
    "index": "311",
    "hex": "0x80000137",
    "symbol": "ADS",
    "name": "Adshares",
    "link": "https://adshares.net"
  },
  "312": {
    "index": "312",
    "hex": "0x80000138",
    "symbol": "ARA",
    "name": "Aura",
    "link": "https://auraledger.com"
  },
  "313": {
    "index": "313",
    "hex": "0x80000139",
    "symbol": "ZIL",
    "name": "Zilliqa",
    "link": "https://zilliqa.com"
  },
  "314": {
    "index": "314",
    "hex": "0x8000013a",
    "symbol": "MOAC",
    "name": "MOAC",
    "link": "https://moac.io"
  },
  "315": {
    "index": "315",
    "hex": "0x8000013b",
    "symbol": "SWTC",
    "name": "SWTC",
    "link": "http://swtc.top"
  },
  "316": {
    "index": "316",
    "hex": "0x8000013c",
    "symbol": "VNSC",
    "name": "vnscoin",
    "link": "http://www.vnscoin.org"
  },
  "317": {
    "index": "317",
    "hex": "0x8000013d",
    "symbol": "PLUG",
    "name": "Pl^g",
    "link": "https://www.poweredbyplug.com"
  },
  "318": {
    "index": "318",
    "hex": "0x8000013e",
    "symbol": "MAN",
    "name": "Matrix AI Network",
    "link": "https://www.matrix.io"
  },
  "319": {
    "index": "319",
    "hex": "0x8000013f",
    "symbol": "ECC",
    "name": "ECCoin",
    "link": "https://ecc.network"
  },
  "320": {
    "index": "320",
    "hex": "0x80000140",
    "symbol": "RPD",
    "name": "Rapids",
    "link": "https://www.rapidsnetwork.io"
  },
  "321": {
    "index": "321",
    "hex": "0x80000141",
    "symbol": "RAP",
    "name": "Rapture",
    "link": "https://our-rapture.com"
  },
  "322": {
    "index": "322",
    "hex": "0x80000142",
    "symbol": "GARD",
    "name": "Hashgard",
    "link": "https://www.hashgard.io"
  },
  "323": {
    "index": "323",
    "hex": "0x80000143",
    "symbol": "ZER",
    "name": "Zero",
    "link": "https://www.zerocurrency.io"
  },
  "324": {
    "index": "324",
    "hex": "0x80000144",
    "symbol": "EBST",
    "name": "eBoost",
    "link": "https://eboost.fun"
  },
  "325": {
    "index": "325",
    "hex": "0x80000145",
    "symbol": "SHARD",
    "name": "Shard",
    "link": "https://shardcoin.io"
  },
  "326": {
    "index": "326",
    "hex": "0x80000146",
    "symbol": "LINDA",
    "name": "Linda Coin",
    "link": "https://lindacoin.com"
  },
  "327": {
    "index": "327",
    "hex": "0x80000147",
    "symbol": "CMM",
    "name": "Commercium",
    "link": "https://www.commercium.net"
  },
  "328": {
    "index": "328",
    "hex": "0x80000148",
    "symbol": "BLOCK",
    "name": "Blocknet",
    "link": "https://blocknet.co"
  },
  "329": {
    "index": "329",
    "hex": "0x80000149",
    "symbol": "AUDAX",
    "name": "AUDAX",
    "link": "https://www.audaxproject.io"
  },
  "330": {
    "index": "330",
    "hex": "0x8000014a",
    "symbol": "LUNA",
    "name": "Terra",
    "link": "https://terra.money"
  },
  "331": {
    "index": "331",
    "hex": "0x8000014b",
    "symbol": "ZPM",
    "name": "zPrime",
    "link": "https://github.com/zprimecoin/zprime"
  },
  "332": {
    "index": "332",
    "hex": "0x8000014c",
    "symbol": "KUVA",
    "name": "Kuva Utility Note",
    "link": "https://www.kuvacash.com"
  },
  "333": {
    "index": "333",
    "hex": "0x8000014d",
    "symbol": "MEM",
    "name": "MemCoin",
    "link": "https://memcoin.org"
  },
  "334": {
    "index": "334",
    "hex": "0x8000014e",
    "symbol": "CS",
    "name": "Credits",
    "link": "https://credits.com"
  },
  "335": {
    "index": "335",
    "hex": "0x8000014f",
    "symbol": "SWIFT",
    "name": "SwiftCash",
    "link": "https://swiftcash.cc"
  },
  "336": {
    "index": "336",
    "hex": "0x80000150",
    "symbol": "FIX",
    "name": "FIX",
    "link": "https://fix.network"
  },
  "337": {
    "index": "337",
    "hex": "0x80000151",
    "symbol": "CPC",
    "name": "CPChain",
    "link": "https://cpchain.io"
  },
  "338": {
    "index": "338",
    "hex": "0x80000152",
    "symbol": "VGO",
    "name": "VirtualGoodsToken",
    "link": "http://vgo.life"
  },
  "339": {
    "index": "339",
    "hex": "0x80000153",
    "symbol": "DVT",
    "name": "DeVault",
    "link": "https://devault.cc"
  },
  "340": {
    "index": "340",
    "hex": "0x80000154",
    "symbol": "N8V",
    "name": "N8VCoin",
    "link": "https://n8vcoin.io"
  },
  "341": {
    "index": "341",
    "hex": "0x80000155",
    "symbol": "MTNS",
    "name": "OmotenashiCoin",
    "link": "http://omotenashicoin.site"
  },
  "342": {
    "index": "342",
    "hex": "0x80000156",
    "symbol": "BLAST",
    "name": "BLAST",
    "link": "https://blastblastblast.com"
  },
  "343": {
    "index": "343",
    "hex": "0x80000157",
    "symbol": "DCT",
    "name": "DECENT",
    "link": "https://decent.ch"
  },
  "344": {
    "index": "344",
    "hex": "0x80000158",
    "symbol": "AUX",
    "name": "Auxilium",
    "link": "https://auxilium.global"
  },
  "345": {
    "index": "345",
    "hex": "0x80000159",
    "symbol": "USDP",
    "name": "USDP",
    "link": "http://www.usdp.pro"
  },
  "346": {
    "index": "346",
    "hex": "0x8000015a",
    "symbol": "HTDF",
    "name": "HTDF",
    "link": "https://www.orientwalt.com"
  },
  "347": {
    "index": "347",
    "hex": "0x8000015b",
    "symbol": "YEC",
    "name": "Ycash",
    "link": "https://www.ycash.xyz"
  },
  "348": {
    "index": "348",
    "hex": "0x8000015c",
    "symbol": "QLC",
    "name": "QLC Chain",
    "link": "https://qlcchain.org"
  },
  "349": {
    "index": "349",
    "hex": "0x8000015d",
    "symbol": "TEA",
    "name": "Icetea Blockchain",
    "link": "https://icetea.io"
  },
  "350": {
    "index": "350",
    "hex": "0x8000015e",
    "symbol": "ARW",
    "name": "ArrowChain",
    "link": "https://www.arrowchain.io"
  },
  "351": {
    "index": "351",
    "hex": "0x8000015f",
    "symbol": "MDM",
    "name": "Medium",
    "link": "https://www.themedium.io"
  },
  "352": {
    "index": "352",
    "hex": "0x80000160",
    "symbol": "CYB",
    "name": "Cybex",
    "link": "https://dex.cybex.io"
  },
  "353": {
    "index": "353",
    "hex": "0x80000161",
    "symbol": "LTO",
    "name": "LTO Network",
    "link": "https://lto.network"
  },
  "354": {
    "index": "354",
    "hex": "0x80000162",
    "symbol": "DOT",
    "name": "Polkadot",
    "link": "https://polkadot.network"
  },
  "355": {
    "index": "355",
    "hex": "0x80000163",
    "symbol": "AEON",
    "name": "Aeon",
    "link": "https://www.aeon.cash"
  },
  "356": {
    "index": "356",
    "hex": "0x80000164",
    "symbol": "RES",
    "name": "Resistance",
    "link": "https://www.resistance.io"
  },
  "357": {
    "index": "357",
    "hex": "0x80000165",
    "symbol": "AYA",
    "name": "Aryacoin",
    "link": "https://aryacoin.io"
  },
  "358": {
    "index": "358",
    "hex": "0x80000166",
    "symbol": "DAPS",
    "name": "Dapscoin",
    "link": "https://officialdapscoin.com"
  },
  "359": {
    "index": "359",
    "hex": "0x80000167",
    "symbol": "CSC",
    "name": "CasinoCoin",
    "link": "https://casinocoin.org"
  },
  "360": {
    "index": "360",
    "hex": "0x80000168",
    "symbol": "VSYS",
    "name": "V Systems",
    "link": "https://www.v.systems"
  },
  "361": {
    "index": "361",
    "hex": "0x80000169",
    "symbol": "NOLLAR",
    "name": "Nollar",
    "link": "https://nollar.org"
  },
  "362": {
    "index": "362",
    "hex": "0x8000016a",
    "symbol": "XNOS",
    "name": "NOS",
    "link": "https://nos.cash"
  },
  "363": {
    "index": "363",
    "hex": "0x8000016b",
    "symbol": "CPU",
    "name": "CPUchain",
    "link": "https://cpuchain.org"
  },
  "364": {
    "index": "364",
    "hex": "0x8000016c",
    "symbol": "LAMB",
    "name": "Lambda Storage Chain",
    "link": "https://lambda.im"
  },
  "365": {
    "index": "365",
    "hex": "0x8000016d",
    "symbol": "VCT",
    "name": "ValueCyber",
    "link": "https://valuecyber.org"
  },
  "366": {
    "index": "366",
    "hex": "0x8000016e",
    "symbol": "CZR",
    "name": "Canonchain",
    "link": "http://www.canonchain.com"
  },
  "367": {
    "index": "367",
    "hex": "0x8000016f",
    "symbol": "ABBC",
    "name": "ABBC",
    "link": "https://www.abbcfoundation.com"
  },
  "368": {
    "index": "368",
    "hex": "0x80000170",
    "symbol": "HET",
    "name": "HET",
    "link": "http://www.hetcoin.info"
  },
  "369": {
    "index": "369",
    "hex": "0x80000171",
    "symbol": "XAS",
    "name": "Asch",
    "link": "https://asch.io"
  },
  "370": {
    "index": "370",
    "hex": "0x80000172",
    "symbol": "VDL",
    "name": "Vidulum",
    "link": "https://vidulum.app"
  },
  "371": {
    "index": "371",
    "hex": "0x80000173",
    "symbol": "MED",
    "name": "MediBloc",
    "link": "https://medibloc.org"
  },
  "372": {
    "index": "372",
    "hex": "0x80000174",
    "symbol": "ZVC",
    "name": "ZVChain",
    "link": "https://www.zvchain.io"
  },
  "373": {
    "index": "373",
    "hex": "0x80000175",
    "symbol": "VESTX",
    "name": "Vestx",
    "link": "https://www.vestxcoin.com"
  },
  "374": {
    "index": "374",
    "hex": "0x80000176",
    "symbol": "DBT",
    "name": "DarkBit",
    "link": "https://www.DarkBitPay.com"
  },
  "375": {
    "index": "375",
    "hex": "0x80000177",
    "symbol": "SEOS",
    "name": "SuperEOS",
    "link": "https://github.com/supereos"
  },
  "376": {
    "index": "376",
    "hex": "0x80000178",
    "symbol": "MXW",
    "name": "Maxonrow",
    "link": "https://maxonrow.com"
  },
  "377": {
    "index": "377",
    "hex": "0x80000179",
    "symbol": "ZNZ",
    "name": "ZENZO",
    "link": "https://zenzo.io"
  },
  "378": {
    "index": "378",
    "hex": "0x8000017a",
    "symbol": "XCX",
    "name": "XChain",
    "link": "https://github.com/xchainxchain"
  },
  "379": {
    "index": "379",
    "hex": "0x8000017b",
    "symbol": "SOX",
    "name": "SonicX",
    "link": "https://sonicx.org"
  },
  "380": {
    "index": "380",
    "hex": "0x8000017c",
    "symbol": "NYZO",
    "name": "Nyzo",
    "link": "https://nyzo.co"
  },
  "381": {
    "index": "381",
    "hex": "0x8000017d",
    "symbol": "ULC",
    "name": "ULCoin",
    "link": "http://www.ulwallet.io"
  },
  "382": {
    "index": "382",
    "hex": "0x8000017e",
    "symbol": "RYO",
    "name": "Ryo Currency",
    "link": "https://ryo-currency.com"
  },
  "383": {
    "index": "383",
    "hex": "0x8000017f",
    "symbol": "KAL",
    "name": "Kaleidochain",
    "link": "https://kaleidochain.io"
  },
  "384": {
    "index": "384",
    "hex": "0x80000180",
    "symbol": "XSN",
    "name": "Stakenet",
    "link": "https://xsncoin.io"
  },
  "385": {
    "index": "385",
    "hex": "0x80000181",
    "symbol": "DOGEC",
    "name": "DogeCash",
    "link": "https://dogec.io"
  },
  "386": {
    "index": "386",
    "hex": "0x80000182",
    "symbol": "BMV",
    "name": "Bitcoin Matteo's Vision",
    "link": "https://btcmv.org"
  },
  "387": {
    "index": "387",
    "hex": "0x80000183",
    "symbol": "QBC",
    "name": "Quebecoin",
    "link": "https://github.com/QuebecoinQBC/quebecoin"
  },
  "388": {
    "index": "388",
    "hex": "0x80000184",
    "symbol": "IMG",
    "name": "ImageCoin",
    "link": "https://imagecoin.imagehosty.com"
  },
  "389": {
    "index": "389",
    "hex": "0x80000185",
    "symbol": "QOS",
    "name": "QOS",
    "link": "https://github.com/QOSGroup/qos"
  },
  "390": {
    "index": "390",
    "hex": "0x80000186",
    "symbol": "PKT",
    "name": "PKT",
    "link": "https://github.com/pkt-cash/pktd"
  },
  "391": {
    "index": "391",
    "hex": "0x80000187",
    "symbol": "LHD",
    "name": "LitecoinHD",
    "link": "https://ltchd.io"
  },
  "392": {
    "index": "392",
    "hex": "0x80000188",
    "symbol": "CENNZ",
    "name": "CENNZnet",
    "link": "https://centrality.ai"
  },
  "393": {
    "index": "393",
    "hex": "0x80000189",
    "symbol": "HSN",
    "name": "Hyper Speed Network",
    "link": "https://www.hsn.link"
  },
  "394": {
    "index": "394",
    "hex": "0x8000018a",
    "symbol": "CRO",
    "name": "Crypto.org Chain",
    "link": "https://crypto.org"
  },
  "395": {
    "index": "395",
    "hex": "0x8000018b",
    "symbol": "UMBRU",
    "name": "Umbru",
    "link": "https://umbru.io"
  },
  "396": {
    "index": "396",
    "hex": "0x8000018c",
    "symbol": "TON",
    "name": "Free TON",
    "link": "https://freeton.org"
  },
  "397": {
    "index": "397",
    "hex": "0x8000018d",
    "symbol": "NEAR",
    "name": "NEAR Protocol",
    "link": "https://nearprotocol.com"
  },
  "398": {
    "index": "398",
    "hex": "0x8000018e",
    "symbol": "XPC",
    "name": "XPChain",
    "link": "https://www.xpchain.io"
  },
  "399": {
    "index": "399",
    "hex": "0x8000018f",
    "symbol": "ZOC",
    "name": "01coin",
    "link": "https://01coin.io"
  },
  "400": {
    "index": "400",
    "hex": "0x80000190",
    "symbol": "NIX",
    "name": "NIX",
    "link": "https://nixplatform.io"
  },
  "401": {
    "index": "401",
    "hex": "0x80000191",
    "symbol": "UC",
    "name": "Utopiacoin",
    "link": "https://utopiacoin.org"
  },
  "402": {
    "index": "402",
    "hex": "0x80000192",
    "symbol": "GALI",
    "name": "Galilel",
    "link": "https://galilel.org"
  },
  "403": {
    "index": "403",
    "hex": "0x80000193",
    "symbol": "OLT",
    "name": "Oneledger",
    "link": "https://www.oneledger.io"
  },
  "404": {
    "index": "404",
    "hex": "0x80000194",
    "symbol": "XBI",
    "name": "XBI",
    "link": "https://bitcoinincognito.org"
  },
  "405": {
    "index": "405",
    "hex": "0x80000195",
    "symbol": "DONU",
    "name": "DONU",
    "link": "https://donu.io"
  },
  "406": {
    "index": "406",
    "hex": "0x80000196",
    "symbol": "EARTHS",
    "name": "Earths",
    "link": "https://earths.ga"
  },
  "407": {
    "index": "407",
    "hex": "0x80000197",
    "symbol": "HDD",
    "name": "HDDCash",
    "link": "https://hdd.cash"
  },
  "408": {
    "index": "408",
    "hex": "0x80000198",
    "symbol": "SUGAR",
    "name": "Sugarchain",
    "link": "https://sugarchain.org"
  },
  "409": {
    "index": "409",
    "hex": "0x80000199",
    "symbol": "AILE",
    "name": "AileCoin",
    "link": "https://ailecoin.com"
  },
  "410": {
    "index": "410",
    "hex": "0x8000019a",
    "symbol": "TENT",
    "name": "TENT",
    "link": "https://tent.app"
  },
  "411": {
    "index": "411",
    "hex": "0x8000019b",
    "symbol": "TAN",
    "name": "Tangerine Network",
    "link": "https://tangerine-network.io"
  },
  "412": {
    "index": "412",
    "hex": "0x8000019c",
    "symbol": "AIN",
    "name": "AIN",
    "link": "https://www.ainetwork.ai"
  },
  "413": {
    "index": "413",
    "hex": "0x8000019d",
    "symbol": "MSR",
    "name": "Masari",
    "link": "https://getmasari.org"
  },
  "414": {
    "index": "414",
    "hex": "0x8000019e",
    "symbol": "SUMO",
    "name": "Sumokoin",
    "link": "https://www.sumokoin.org"
  },
  "415": {
    "index": "415",
    "hex": "0x8000019f",
    "symbol": "ETN",
    "name": "Electroneum",
    "link": "https://electroneum.com"
  },
  "416": {
    "index": "416",
    "hex": "0x800001a0",
    "symbol": "BYTZ",
    "name": "BYTZ",
    "link": "https://bytz.gg"
  },
  "417": {
    "index": "417",
    "hex": "0x800001a1",
    "symbol": "WOW",
    "name": "Wownero",
    "link": "http://wownero.org"
  },
  "418": {
    "index": "418",
    "hex": "0x800001a2",
    "symbol": "XTNC",
    "name": "XtendCash",
    "link": "https://xtendcash.com"
  },
  "419": {
    "index": "419",
    "hex": "0x800001a3",
    "symbol": "LTHN",
    "name": "Lethean",
    "link": "https://lethean.io"
  },
  "420": {
    "index": "420",
    "hex": "0x800001a4",
    "symbol": "NODE",
    "name": "NodeHost",
    "link": "https://nodehost.online"
  },
  "421": {
    "index": "421",
    "hex": "0x800001a5",
    "symbol": "AGM",
    "name": "Argoneum",
    "link": "https://argoneum.net"
  },
  "422": {
    "index": "422",
    "hex": "0x800001a6",
    "symbol": "CCX",
    "name": "Conceal Network",
    "link": "https://conceal.network"
  },
  "423": {
    "index": "423",
    "hex": "0x800001a7",
    "symbol": "TNET",
    "name": "Title Network",
    "link": "https://title.network"
  },
  "424": {
    "index": "424",
    "hex": "0x800001a8",
    "symbol": "TELOS",
    "name": "TelosCoin",
    "link": "https://teloscoin.org"
  },
  "425": {
    "index": "425",
    "hex": "0x800001a9",
    "symbol": "AION",
    "name": "Aion",
    "link": "https://aion.network"
  },
  "426": {
    "index": "426",
    "hex": "0x800001aa",
    "symbol": "BC",
    "name": "Bitcoin Confidential",
    "link": "https://www.bitcoinconfidential.cc"
  },
  "427": {
    "index": "427",
    "hex": "0x800001ab",
    "symbol": "KTV",
    "name": "KmushiCoin",
    "link": "https://tierravivaplanet.com"
  },
  "428": {
    "index": "428",
    "hex": "0x800001ac",
    "symbol": "ZCR",
    "name": "ZCore",
    "link": "https://zcore.cash"
  },
  "429": {
    "index": "429",
    "hex": "0x800001ad",
    "symbol": "ERG",
    "name": "Ergo",
    "link": "https://ergoplatform.org"
  },
  "430": {
    "index": "430",
    "hex": "0x800001ae",
    "symbol": "PESO",
    "name": "Criptopeso",
    "link": "https://criptopeso.io"
  },
  "431": {
    "index": "431",
    "hex": "0x800001af",
    "symbol": "BTC2",
    "name": "Bitcoin 2",
    "link": "https://www.bitc2.org"
  },
  "432": {
    "index": "432",
    "hex": "0x800001b0",
    "symbol": "XRPHD",
    "name": "XRPHD",
    "link": "https://xrphd.org"
  },
  "433": {
    "index": "433",
    "hex": "0x800001b1",
    "symbol": "WE",
    "name": "WE Coin",
    "link": "https://we-corp.io"
  },
  "434": {
    "index": "434",
    "hex": "0x800001b2",
    "symbol": "KSM",
    "name": "Kusama",
    "link": "https://kusama.network"
  },
  "435": {
    "index": "435",
    "hex": "0x800001b3",
    "symbol": "PCN",
    "name": "Peepcoin",
    "link": "https://pxn.foundation/peepcoin"
  },
  "436": {
    "index": "436",
    "hex": "0x800001b4",
    "symbol": "NCH",
    "name": "NetCloth",
    "link": "https://www.netcloth.org"
  },
  "437": {
    "index": "437",
    "hex": "0x800001b5",
    "symbol": "ICU",
    "name": "CHIPO",
    "link": "http://www.chipo.icu"
  },
  "438": {
    "index": "438",
    "hex": "0x800001b6",
    "symbol": "LN",
    "name": "LINK",
    "link": "https://link.network"
  },
  "439": {
    "index": "439",
    "hex": "0x800001b7",
    "symbol": "DTP",
    "name": "DeVault Token Protocol",
    "link": "https://devault.cc/token-protocol.html"
  },
  "440": {
    "index": "440",
    "hex": "0x800001b8",
    "symbol": "BTCR",
    "name": "Bitcoin Royale",
    "link": "https://bitcoinroyale.org"
  },
  "441": {
    "index": "441",
    "hex": "0x800001b9",
    "symbol": "AERGO",
    "name": "AERGO",
    "link": "https://www.aergo.io"
  },
  "442": {
    "index": "442",
    "hex": "0x800001ba",
    "symbol": "XTH",
    "name": "Dothereum",
    "link": "https://dothereum.net"
  },
  "443": {
    "index": "443",
    "hex": "0x800001bb",
    "symbol": "LV",
    "name": "Lava",
    "link": "https://www.lavatech.org"
  },
  "444": {
    "index": "444",
    "hex": "0x800001bc",
    "symbol": "PHR",
    "name": "Phore",
    "link": "https://phore.io"
  },
  "445": {
    "index": "445",
    "hex": "0x800001bd",
    "symbol": "VITAE",
    "name": "Vitae",
    "link": "https://www.vitaetoken.io"
  },
  "446": {
    "index": "446",
    "hex": "0x800001be",
    "symbol": "COCOS",
    "name": "Cocos-BCX",
    "link": "https://www.cocosbcx.io"
  },
  "447": {
    "index": "447",
    "hex": "0x800001bf",
    "symbol": "DIN",
    "name": "Dinero",
    "link": "https://dinerocoin.org"
  },
  "448": {
    "index": "448",
    "hex": "0x800001c0",
    "symbol": "SPL",
    "name": "Simplicity",
    "link": "https://simplicity-coin.com"
  },
  "449": {
    "index": "449",
    "hex": "0x800001c1",
    "symbol": "YCE",
    "name": "MYCE",
    "link": "https://myce.world"
  },
  "450": {
    "index": "450",
    "hex": "0x800001c2",
    "symbol": "XLR",
    "name": "Solaris",
    "link": "https://solarisplatform.com"
  },
  "451": {
    "index": "451",
    "hex": "0x800001c3",
    "symbol": "KTS",
    "name": "Klimatas",
    "link": "https://www.klimatas.com"
  },
  "452": {
    "index": "452",
    "hex": "0x800001c4",
    "symbol": "DGLD",
    "name": "DGLD",
    "link": "http://dgld.ch"
  },
  "453": {
    "index": "453",
    "hex": "0x800001c5",
    "symbol": "XNS",
    "name": "Insolar",
    "link": "https://insolar.io"
  },
  "454": {
    "index": "454",
    "hex": "0x800001c6",
    "symbol": "EM",
    "name": "EMPOW",
    "link": "https://empow.io"
  },
  "455": {
    "index": "455",
    "hex": "0x800001c7",
    "symbol": "SHN",
    "name": "ShineBlocks",
    "link": "https://www.shineblocks.com"
  },
  "456": {
    "index": "456",
    "hex": "0x800001c8",
    "symbol": "SEELE",
    "name": "Seele",
    "link": "https://seelenet.com"
  },
  "457": {
    "index": "457",
    "hex": "0x800001c9",
    "symbol": "AE",
    "name": "æternity",
    "link": "https://aeternity.com"
  },
  "458": {
    "index": "458",
    "hex": "0x800001ca",
    "symbol": "ODX",
    "name": "ObsidianX",
    "link": "https://obsidianproject.org"
  },
  "459": {
    "index": "459",
    "hex": "0x800001cb",
    "symbol": "KAVA",
    "name": "Kava",
    "link": "https://kava.io"
  },
  "460": {
    "index": "460",
    "hex": "0x800001cc",
    "symbol": "GLEEC",
    "name": "GLEEC",
    "link": "https://gleecoin.com"
  },
  "461": {
    "index": "461",
    "hex": "0x800001cd",
    "symbol": "FIL",
    "name": "Filecoin",
    "link": "https://filecoin.io"
  },
  "462": {
    "index": "462",
    "hex": "0x800001ce",
    "symbol": "RUTA",
    "name": "Rutanio",
    "link": "https://rutanio.com"
  },
  "463": {
    "index": "463",
    "hex": "0x800001cf",
    "symbol": "CSDT",
    "name": "CSDT",
    "link": "https://xar.network"
  },
  "464": {
    "index": "464",
    "hex": "0x800001d0",
    "symbol": "ETI",
    "name": "EtherInc",
    "link": "https://einc.io"
  },
  "465": {
    "index": "465",
    "hex": "0x800001d1",
    "symbol": "ZSLP",
    "name": "Zclassic Simple Ledger Protocol",
    "link": "https://zslp.org"
  },
  "466": {
    "index": "466",
    "hex": "0x800001d2",
    "symbol": "ERE",
    "name": "EtherCore",
    "link": "https://ethercore.org"
  },
  "467": {
    "index": "467",
    "hex": "0x800001d3",
    "symbol": "DX",
    "name": "DxChain Token",
    "link": "https://dxchain.com"
  },
  "468": {
    "index": "468",
    "hex": "0x800001d4",
    "symbol": "CPS",
    "name": "Capricoin+",
    "link": "https://capricoin.org"
  },
  "469": {
    "index": "469",
    "hex": "0x800001d5",
    "symbol": "BTH",
    "name": "Bithereum",
    "link": "https://bithereum.network"
  },
  "470": {
    "index": "470",
    "hex": "0x800001d6",
    "symbol": "MESG",
    "name": "MESG",
    "link": "https://mesg.com"
  },
  "471": {
    "index": "471",
    "hex": "0x800001d7",
    "symbol": "FIMK",
    "name": "FIMK",
    "link": "https://wallet.fimk.fi"
  },
  "472": {
    "index": "472",
    "hex": "0x800001d8",
    "symbol": "AR",
    "name": "Arweave",
    "link": "https://arweave.org"
  },
  "473": {
    "index": "473",
    "hex": "0x800001d9",
    "symbol": "OGO",
    "name": "Origo",
    "link": "https://origo.network"
  },
  "474": {
    "index": "474",
    "hex": "0x800001da",
    "symbol": "ROSE",
    "name": "Oasis Network",
    "link": "https://www.oasis-protocol.org"
  },
  "475": {
    "index": "475",
    "hex": "0x800001db",
    "symbol": "BARE",
    "name": "BARE Network",
    "link": "https://bare.network"
  },
  "476": {
    "index": "476",
    "hex": "0x800001dc",
    "symbol": "GLEEC",
    "name": "GleecBTC",
    "link": "https://gleecbtc.com"
  },
  "477": {
    "index": "477",
    "hex": "0x800001dd",
    "symbol": "CLR",
    "name": "Color Coin",
    "link": "https://color-platform.org"
  },
  "478": {
    "index": "478",
    "hex": "0x800001de",
    "symbol": "RNG",
    "name": "Ring",
    "link": "https://ringcoin.tech"
  },
  "479": {
    "index": "479",
    "hex": "0x800001df",
    "symbol": "OLO",
    "name": "Tool Global",
    "link": "https://ibdt.io"
  },
  "480": {
    "index": "480",
    "hex": "0x800001e0",
    "symbol": "PEXA",
    "name": "Pexa",
    "link": "https://pexaproject.com"
  },
  "481": {
    "index": "481",
    "hex": "0x800001e1",
    "symbol": "MOON",
    "name": "Mooncoin",
    "link": "https://mooncoin.eco"
  },
  "482": {
    "index": "482",
    "hex": "0x800001e2",
    "symbol": "OCEAN",
    "name": "Ocean Protocol",
    "link": "https://oceanprotocol.com"
  },
  "483": {
    "index": "483",
    "hex": "0x800001e3",
    "symbol": "BNT",
    "name": "Bluzelle Native",
    "link": "https://bluzelle.com"
  },
  "484": {
    "index": "484",
    "hex": "0x800001e4",
    "symbol": "AMO",
    "name": "AMO Blockchain",
    "link": "https://amo.foundation"
  },
  "485": {
    "index": "485",
    "hex": "0x800001e5",
    "symbol": "FCH",
    "name": "FreeCash",
    "link": "https://www.freecash.org"
  },
  "486": {
    "index": "486",
    "hex": "0x800001e6",
    "symbol": "LAT",
    "name": "LatticeX",
    "link": "https://latticex.foundation"
  },
  "487": {
    "index": "487",
    "hex": "0x800001e7",
    "symbol": "COIN",
    "name": "Bitcoin Bank",
    "link": "https://github.com/coin-core/coin"
  },
  "488": {
    "index": "488",
    "hex": "0x800001e8",
    "symbol": "VEO",
    "name": "Amoveo",
    "link": "https://github.com/zack-bitcoin/amoveo"
  },
  "489": {
    "index": "489",
    "hex": "0x800001e9",
    "symbol": "CCA",
    "name": "Counos Coin",
    "link": "https://counos.io/cousnocoin"
  },
  "490": {
    "index": "490",
    "hex": "0x800001ea",
    "symbol": "GFN",
    "name": "Graphene",
    "link": "https://getgraphene.io"
  },
  "491": {
    "index": "491",
    "hex": "0x800001eb",
    "symbol": "BIP",
    "name": "Minter Network",
    "link": "https://minter.network"
  },
  "492": {
    "index": "492",
    "hex": "0x800001ec",
    "symbol": "KPG",
    "name": "Kunpeng Network",
    "link": "https://kunpeng.network"
  },
  "493": {
    "index": "493",
    "hex": "0x800001ed",
    "symbol": "FIN",
    "name": "FINL Chain",
    "link": "http://finl.network"
  },
  "494": {
    "index": "494",
    "hex": "0x800001ee",
    "symbol": "BAND",
    "name": "Band",
    "link": "https://bandprotocol.com"
  },
  "495": {
    "index": "495",
    "hex": "0x800001ef",
    "symbol": "DROP",
    "name": "Dropil",
    "link": "https://dropilchain.com"
  },
  "496": {
    "index": "496",
    "hex": "0x800001f0",
    "symbol": "BHT",
    "name": "Bluehelix Chain",
    "link": "https://bluehelix.network"
  },
  "497": {
    "index": "497",
    "hex": "0x800001f1",
    "symbol": "LYRA",
    "name": "Scrypta",
    "link": "https://scryptachain.org"
  },
  "498": {
    "index": "498",
    "hex": "0x800001f2",
    "symbol": "CS",
    "name": "Credits",
    "link": "https://credits.com"
  },
  "499": {
    "index": "499",
    "hex": "0x800001f3",
    "symbol": "RUPX",
    "name": "Rupaya",
    "link": "https://rupx.io"
  },
  "500": {
    "index": "500",
    "hex": "0x800001f4",
    "symbol": "THETA",
    "name": "Theta",
    "link": "https://www.thetatoken.org"
  },
  "501": {
    "index": "501",
    "hex": "0x800001f5",
    "symbol": "SOL",
    "name": "Solana",
    "link": "https://solana.com"
  },
  "502": {
    "index": "502",
    "hex": "0x800001f6",
    "symbol": "THT",
    "name": "ThoughtAI",
    "link": "https://github.com/thoughtnetwork/thought"
  },
  "503": {
    "index": "503",
    "hex": "0x800001f7",
    "symbol": "CFX",
    "name": "Conflux",
    "link": "https://confluxnetwork.org"
  },
  "504": {
    "index": "504",
    "hex": "0x800001f8",
    "symbol": "KUMA",
    "name": "Kumacoin",
    "link": "https://www.kumacoin.dev"
  },
  "505": {
    "index": "505",
    "hex": "0x800001f9",
    "symbol": "HASH",
    "name": "Provenance",
    "link": "https://provenance.io"
  },
  "506": {
    "index": "506",
    "hex": "0x800001fa",
    "symbol": "CSPR",
    "name": "Casper",
    "link": "https://casper.network"
  },
  "507": {
    "index": "507",
    "hex": "0x800001fb",
    "symbol": "EARTH",
    "name": "EARTH",
    "link": "https://www.earth.engineering"
  },
  "508": {
    "index": "508",
    "hex": "0x800001fc",
    "symbol": "ERD",
    "name": "Elrond",
    "link": "https://elrond.com"
  },
  "509": {
    "index": "509",
    "hex": "0x800001fd",
    "symbol": "CHI",
    "name": "Xaya",
    "link": "https://xaya.io"
  },
  "510": {
    "index": "510",
    "hex": "0x800001fe",
    "symbol": "KOTO",
    "name": "Koto",
    "link": "https://ko-to.org"
  },
  "511": {
    "index": "511",
    "hex": "0x800001ff",
    "symbol": "OTC",
    "name": "θ",
    "link": "https://otc.network"
  },
  "512": {
    "index": "512",
    "hex": "0x80000200",
    "symbol": "XRD",
    "name": "Radiant",
    "link": "https://radiant.cash"
  },
  "513": {
    "index": "513",
    "hex": "0x80000201",
    "symbol": "SEELEN",
    "name": "Seele-N",
    "link": "https://seelen.pro"
  },
  "514": {
    "index": "514",
    "hex": "0x80000202",
    "symbol": "AETH",
    "name": "AETH",
    "link": "https://aeth.io"
  },
  "515": {
    "index": "515",
    "hex": "0x80000203",
    "symbol": "DNA",
    "name": "Idena",
    "link": "https://idena.io"
  },
  "516": {
    "index": "516",
    "hex": "0x80000204",
    "symbol": "VEE",
    "name": "Virtual Economy Era",
    "link": "https://www.vee.tech"
  },
  "517": {
    "index": "517",
    "hex": "0x80000205",
    "symbol": "SIERRA",
    "name": "SierraCoin",
    "link": "https://sierracoin.org"
  },
  "518": {
    "index": "518",
    "hex": "0x80000206",
    "symbol": "LET",
    "name": "Linkeye",
    "link": "https://www.linkeye.com"
  },
  "519": {
    "index": "519",
    "hex": "0x80000207",
    "symbol": "BSC",
    "name": "Bitcoin Smart Contract",
    "link": "https://bsc.net"
  },
  "520": {
    "index": "520",
    "hex": "0x80000208",
    "symbol": "BTCV",
    "name": "BitcoinVIP",
    "link": "https://www.bitvip.org"
  },
  "521": {
    "index": "521",
    "hex": "0x80000209",
    "symbol": "ABA",
    "name": "Dabacus",
    "link": "https://www.dabacus.org"
  },
  "522": {
    "index": "522",
    "hex": "0x8000020a",
    "symbol": "SCC",
    "name": "StakeCubeCoin",
    "link": "https://stakecube.net"
  },
  "523": {
    "index": "523",
    "hex": "0x8000020b",
    "symbol": "EDG",
    "name": "Edgeware",
    "link": "https://edgewa.re"
  },
  "524": {
    "index": "524",
    "hex": "0x8000020c",
    "symbol": "AMS",
    "name": "AmsterdamCoin",
    "link": "https://www.amsterdamcoin.com"
  },
  "525": {
    "index": "525",
    "hex": "0x8000020d",
    "symbol": "GOSS",
    "name": "GOSSIP Coin",
    "link": "https://gossipcoin.net"
  },
  "526": {
    "index": "526",
    "hex": "0x8000020e",
    "symbol": "BU",
    "name": "BUMO",
    "link": "https://www.bumo.io"
  },
  "527": {
    "index": "527",
    "hex": "0x8000020f",
    "symbol": "GRAM",
    "name": "GRAM",
    "link": "https://github.com/tongram"
  },
  "528": {
    "index": "528",
    "hex": "0x80000210",
    "symbol": "YAP",
    "name": "Yapstone",
    "link": "https://yapstone.pro"
  },
  "529": {
    "index": "529",
    "hex": "0x80000211",
    "symbol": "SCRT",
    "name": "Secret Network",
    "link": "https://scrt.network"
  },
  "530": {
    "index": "530",
    "hex": "0x80000212",
    "symbol": "NOVO",
    "name": "Novo",
    "link": "https://novocurrency.com"
  },
  "531": {
    "index": "531",
    "hex": "0x80000213",
    "symbol": "GHOST",
    "name": "Ghost",
    "link": "https://ghostbymcafee.com"
  },
  "532": {
    "index": "532",
    "hex": "0x80000214",
    "symbol": "HST",
    "name": "HST",
    "link": "https://www.hschain.io"
  },
  "533": {
    "index": "533",
    "hex": "0x80000215",
    "symbol": "PRJ",
    "name": "ProjectCoin",
    "link": "https://projectcoin.net"
  },
  "534": {
    "index": "534",
    "hex": "0x80000216",
    "symbol": "YOU",
    "name": "YOUChain",
    "link": "https://youchain.cc"
  },
  "535": {
    "index": "535",
    "hex": "0x80000217",
    "symbol": "XHV",
    "name": "Haven Protocol",
    "link": "https://havenprotocol.org"
  },
  "536": {
    "index": "536",
    "hex": "0x80000218",
    "symbol": "BYND",
    "name": "Beyondcoin",
    "link": "https://beyondcoin.io"
  },
  "537": {
    "index": "537",
    "hex": "0x80000219",
    "symbol": "JOYS",
    "name": "Joys Digital",
    "link": "https://joys.digital"
  },
  "538": {
    "index": "538",
    "hex": "0x8000021a",
    "symbol": "VAL",
    "name": "Valorbit",
    "link": "https://valorbit.com"
  },
  "539": {
    "index": "539",
    "hex": "0x8000021b",
    "symbol": "FLOW",
    "name": "Flow",
    "link": "https://www.onflow.org"
  },
  "540": {
    "index": "540",
    "hex": "0x8000021c",
    "symbol": "SMESH",
    "name": "Spacemesh Coin",
    "link": "https://spacemesh.io"
  },
  "541": {
    "index": "541",
    "hex": "0x8000021d",
    "symbol": "SCDO",
    "name": "SCDO",
    "link": "https://scdoproject.org"
  },
  "542": {
    "index": "542",
    "hex": "0x8000021e",
    "symbol": "IQS",
    "name": "IQ-Cash",
    "link": "https://iq.cash"
  },
  "543": {
    "index": "543",
    "hex": "0x8000021f",
    "symbol": "BIND",
    "name": "Compendia",
    "link": "https://compendia.org"
  },
  "544": {
    "index": "544",
    "hex": "0x80000220",
    "symbol": "COINEVO",
    "name": "Coinevo",
    "link": "https://coinevo.tech"
  },
  "545": {
    "index": "545",
    "hex": "0x80000221",
    "symbol": "SCRIBE",
    "name": "Scribe",
    "link": "https://scribe.network"
  },
  "546": {
    "index": "546",
    "hex": "0x80000222",
    "symbol": "HYN",
    "name": "Hyperion",
    "link": "https://www.hyn.space"
  },
  "547": {
    "index": "547",
    "hex": "0x80000223",
    "symbol": "BHP",
    "name": "BHP",
    "link": "https://www.bhpa.io"
  },
  "548": {
    "index": "548",
    "hex": "0x80000224",
    "symbol": "BBC",
    "name": "BigBang Core",
    "link": "https://github.com/bigbangcore"
  },
  "549": {
    "index": "549",
    "hex": "0x80000225",
    "symbol": "MKF",
    "name": "MarketFinance",
    "link": "https://mkf.io"
  },
  "550": {
    "index": "550",
    "hex": "0x80000226",
    "symbol": "XDC",
    "name": "XinFin.Network",
    "link": "https://xinfin.network"
  },
  "551": {
    "index": "551",
    "hex": "0x80000227",
    "symbol": "STR",
    "name": "Straightedge",
    "link": "https://straighted.ge"
  },
  "552": {
    "index": "552",
    "hex": "0x80000228",
    "symbol": "SUM",
    "name": "Sumcoin",
    "link": "https://sumcoin.org"
  },
  "553": {
    "index": "553",
    "hex": "0x80000229",
    "symbol": "HBC",
    "name": "HuobiChain",
    "link": "https://www.huobichain.com"
  },
  "554": {
    "index": "554",
    "hex": "0x8000022a",
    "symbol": "---",
    "name": "reserved"
  },
  "555": {
    "index": "555",
    "hex": "0x8000022b",
    "symbol": "BCS",
    "name": "Bitcoin Smart",
    "link": "http://bcs.info"
  },
  "556": {
    "index": "556",
    "hex": "0x8000022c",
    "symbol": "KTS",
    "name": "Kratos",
    "link": "https://github.com/KuChainNetwork/kratos"
  },
  "557": {
    "index": "557",
    "hex": "0x8000022d",
    "symbol": "LKR",
    "name": "Lkrcoin",
    "link": "https://lkrcoin.io"
  },
  "558": {
    "index": "558",
    "hex": "0x8000022e",
    "symbol": "TAO",
    "name": "Tao",
    "link": "https://tao.network"
  },
  "559": {
    "index": "559",
    "hex": "0x8000022f",
    "symbol": "XWC",
    "name": "Whitecoin",
    "link": "https://www.whitecoin.info"
  },
  "560": {
    "index": "560",
    "hex": "0x80000230",
    "symbol": "DEAL",
    "name": "DEAL",
    "link": "https://idealcash.io"
  },
  "561": {
    "index": "561",
    "hex": "0x80000231",
    "symbol": "NTY",
    "name": "Nexty",
    "link": "https://nexty.io"
  },
  "562": {
    "index": "562",
    "hex": "0x80000232",
    "symbol": "TOP",
    "name": "TOP NetWork",
    "link": "https://www.topnetwork.org"
  },
  "563": {
    "index": "563",
    "hex": "0x80000233",
    "symbol": "STARS",
    "name": "Stargaze",
    "link": "https://www.stargaze.fi"
  },
  "564": {
    "index": "564",
    "hex": "0x80000234",
    "symbol": "AG",
    "name": "Agoric",
    "link": "https://agoric.com"
  },
  "565": {
    "index": "565",
    "hex": "0x80000235",
    "symbol": "CICO",
    "name": "Coinicles",
    "link": "https://github.com/coinicles/cico"
  },
  "566": {
    "index": "566",
    "hex": "0x80000236",
    "symbol": "IRIS",
    "name": "Irisnet",
    "link": "https://www.irisnet.org"
  },
  "567": {
    "index": "567",
    "hex": "0x80000237",
    "symbol": "NCG",
    "name": "Nine Chronicles",
    "link": "https://nine-chronicles.com"
  },
  "568": {
    "index": "568",
    "hex": "0x80000238",
    "symbol": "LRG",
    "name": "Large Coin",
    "link": "https://www.largocoin.io"
  },
  "569": {
    "index": "569",
    "hex": "0x80000239",
    "symbol": "SERO",
    "name": "Super Zero Protocol",
    "link": "https://sero.cash"
  },
  "570": {
    "index": "570",
    "hex": "0x8000023a",
    "symbol": "BDX",
    "name": "Beldex",
    "link": "https://www.beldex.io"
  },
  "571": {
    "index": "571",
    "hex": "0x8000023b",
    "symbol": "CCXX",
    "name": "Counos X",
    "link": "https://www.counos.io/CounosX"
  },
  "572": {
    "index": "572",
    "hex": "0x8000023c",
    "symbol": "SLS",
    "name": "Saluscoin",
    "link": "https://saluscoin.info"
  },
  "573": {
    "index": "573",
    "hex": "0x8000023d",
    "symbol": "SRM",
    "name": "Serum",
    "link": "https://projectserum.com"
  },
  "574": {
    "index": "574",
    "hex": "0x8000023e",
    "symbol": "VLX",
    "name": "Velas",
    "link": "https://velas.com"
  },
  "575": {
    "index": "575",
    "hex": "0x8000023f",
    "symbol": "VIVT",
    "name": "VIDT Datalink",
    "link": "https://about.v-id.org"
  },
  "576": {
    "index": "576",
    "hex": "0x80000240",
    "symbol": "BPS",
    "name": "BitcoinPoS",
    "link": "https://bitcoinpos.net"
  },
  "577": {
    "index": "577",
    "hex": "0x80000241",
    "symbol": "NKN",
    "name": "NKN",
    "link": "https://www.nkn.org"
  },
  "578": {
    "index": "578",
    "hex": "0x80000242",
    "symbol": "ICL",
    "name": "ILCOIN",
    "link": "https://ilcoincrypto.com"
  },
  "579": {
    "index": "579",
    "hex": "0x80000243",
    "symbol": "BONO",
    "name": "Bonorum",
    "link": "https://www.bonorum.io"
  },
  "580": {
    "index": "580",
    "hex": "0x80000244",
    "symbol": "PLC",
    "name": "PLATINCOIN",
    "link": "https://platincoin.com/en"
  },
  "581": {
    "index": "581",
    "hex": "0x80000245",
    "symbol": "DUN",
    "name": "Dune",
    "link": "https://dune.network"
  },
  "582": {
    "index": "582",
    "hex": "0x80000246",
    "symbol": "DMCH",
    "name": "Darmacash",
    "link": "https://www.darmacash.com"
  },
  "583": {
    "index": "583",
    "hex": "0x80000247",
    "symbol": "CTC",
    "name": "Creditcoin",
    "link": "https://www.creditcoin.org"
  },
  "584": {
    "index": "584",
    "hex": "0x80000248",
    "symbol": "KELP",
    "name": "Haidai Network",
    "link": "https://haidai.one"
  },
  "585": {
    "index": "585",
    "hex": "0x80000249",
    "symbol": "GBCR",
    "name": "GoldBCR",
    "link": "https://goldbcr.io"
  },
  "586": {
    "index": "586",
    "hex": "0x8000024a",
    "symbol": "XDAG",
    "name": "XDAG",
    "link": "https://xdag.io"
  },
  "587": {
    "index": "587",
    "hex": "0x8000024b",
    "symbol": "PRV",
    "name": "Incognito Privacy",
    "link": "https://incognito.org"
  },
  "588": {
    "index": "588",
    "hex": "0x8000024c",
    "symbol": "SCAP",
    "name": "SafeCapital",
    "link": "https://www.safecapital.io"
  },
  "589": {
    "index": "589",
    "hex": "0x8000024d",
    "symbol": "TFUEL",
    "name": "Theta Fuel",
    "link": "https://community.theta.tv/tfuel-on-sliver-faq"
  },
  "590": {
    "index": "590",
    "hex": "0x8000024e",
    "symbol": "GTM",
    "name": "Gentarium",
    "link": "https://gtmcoin.io"
  },
  "591": {
    "index": "591",
    "hex": "0x8000024f",
    "symbol": "RNL",
    "name": "RentalChain",
    "link": "https://rentalchain.net"
  },
  "592": {
    "index": "592",
    "hex": "0x80000250",
    "symbol": "GRIN",
    "name": "Grin",
    "link": "https://grin.mw"
  },
  "593": {
    "index": "593",
    "hex": "0x80000251",
    "symbol": "MWC",
    "name": "MimbleWimbleCoin",
    "link": "https://www.mwc.mw"
  },
  "594": {
    "index": "594",
    "hex": "0x80000252",
    "symbol": "DOCK",
    "name": "Dock",
    "link": "https://dock.io"
  },
  "595": {
    "index": "595",
    "hex": "0x80000253",
    "symbol": "POLYX",
    "name": "Polymesh",
    "link": "https://polymath.network"
  },
  "596": {
    "index": "596",
    "hex": "0x80000254",
    "symbol": "DIVER",
    "name": "Divergenti",
    "link": "https://www.divergenti.cl"
  },
  "597": {
    "index": "597",
    "hex": "0x80000255",
    "symbol": "XEP",
    "name": "Electra Protocol",
    "link": "https://www.electraprotocol.com"
  },
  "598": {
    "index": "598",
    "hex": "0x80000256",
    "symbol": "APN",
    "name": "Apron",
    "link": "https://apron.network"
  },
  "599": {
    "index": "599",
    "hex": "0x80000257",
    "symbol": "TFC",
    "name": "Turbo File Coin",
    "link": "http://turbofil.cc"
  },
  "600": {
    "index": "600",
    "hex": "0x80000258",
    "symbol": "UTE",
    "name": "Unit-e",
    "link": "https://dtr.org/unit-e"
  },
  "601": {
    "index": "601",
    "hex": "0x80000259",
    "symbol": "MTC",
    "name": "Metacoin",
    "link": "https://metacoin.network"
  },
  "602": {
    "index": "602",
    "hex": "0x8000025a",
    "symbol": "NC",
    "name": "NobodyCash",
    "link": "https://nobodycash.world"
  },
  "603": {
    "index": "603",
    "hex": "0x8000025b",
    "symbol": "XINY",
    "name": "Xinyuehu",
    "link": "https://xinyuehu.xyz"
  },
  "604": {
    "index": "604",
    "hex": "0x8000025c",
    "symbol": "DYN",
    "name": "Dynamo",
    "link": "https://www.dynamocoin.org"
  },
  "605": {
    "index": "605",
    "hex": "0x8000025d",
    "symbol": "BUFS",
    "name": "Buffer",
    "link": "https://bufferbufs.com"
  },
  "606": {
    "index": "606",
    "hex": "0x8000025e",
    "symbol": "STOS",
    "name": "Stratos",
    "link": "https://thestratos.org"
  },
  "607": {
    "index": "607",
    "hex": "0x8000025f",
    "symbol": "TON",
    "name": "TON",
    "link": "https://toncoin.org"
  },
  "608": {
    "index": "608",
    "hex": "0x80000260",
    "symbol": "TAFT",
    "name": "TAFT",
    "link": "https://www.tafchain.com"
  },
  "609": {
    "index": "609",
    "hex": "0x80000261",
    "symbol": "HYDRA",
    "name": "HYDRA",
    "link": "https://hydrachain.org"
  },
  "610": {
    "index": "610",
    "hex": "0x80000262",
    "symbol": "NOR",
    "name": "Noir",
    "link": "http://www.noirofficial.org"
  },
  "611": {
    "index": "611",
    "hex": "0x80000263",
    "symbol": "",
    "name": "Manta Network Private Asset",
    "link": "https://manta.network"
  },
  "612": {
    "index": "612",
    "hex": "0x80000264",
    "symbol": "",
    "name": "Calamari Network Private Asset",
    "link": "https://calamari.manta.network"
  },
  "613": {
    "index": "613",
    "hex": "0x80000265",
    "symbol": "WCN",
    "name": "Widecoin",
    "link": "https://Widecoin.org"
  },
  "614": {
    "index": "614",
    "hex": "0x80000266",
    "symbol": "OPT",
    "name": "Optimistic Ethereum",
    "link": "https://www.optimism.io"
  },
  "615": {
    "index": "615",
    "hex": "0x80000267",
    "symbol": "PSWAP",
    "name": "PolkaSwap",
    "link": "https://polkaswap.io"
  },
  "616": {
    "index": "616",
    "hex": "0x80000268",
    "symbol": "VAL",
    "name": "Validator",
    "link": "https://sora.org/soratokens"
  },
  "617": {
    "index": "617",
    "hex": "0x80000269",
    "symbol": "XOR",
    "name": "Sora",
    "link": "https://sora.org/soratokens"
  },
  "618": {
    "index": "618",
    "hex": "0x8000026a",
    "symbol": "SSP",
    "name": "SmartShare",
    "link": "http://www.smartshare.vip"
  },
  "619": {
    "index": "619",
    "hex": "0x8000026b",
    "symbol": "DEI",
    "name": "DeimosX",
    "link": "https://deimosx.org"
  },
  "620": {
    "index": "620",
    "hex": "0x8000026c",
    "symbol": "AXL",
    "name": "Axelar",
    "link": "https://axelar.network"
  },
  "621": {
    "index": "621",
    "hex": "0x8000026d",
    "symbol": "ZERO",
    "name": "Singularity",
    "link": "https://www.singularity.gold"
  },
  "622": {
    "index": "622",
    "hex": "0x8000026e",
    "symbol": "",
    "name": ""
  },
  "623": {
    "index": "623",
    "hex": "0x8000026f",
    "symbol": "BDCASH",
    "name": "BDCash Protocol",
    "link": "https://bdcashprotocol.com"
  },
  "624": {
    "index": "624",
    "hex": "0x80000270",
    "symbol": "NOBL",
    "name": "Nobility",
    "link": "https://github.com/nobilitysociety"
  },
  "625": {
    "index": "625",
    "hex": "0x80000271",
    "symbol": "EAST",
    "name": "Eastcoin",
    "link": "http://easthub.io"
  },
  "626": {
    "index": "626",
    "hex": "0x80000272",
    "symbol": "KDA",
    "name": "Kadena",
    "link": "https://kadena.io"
  },
  "627": {
    "index": "627",
    "hex": "0x80000273",
    "symbol": "",
    "name": ""
  },
  "628": {
    "index": "628",
    "hex": "0x80000274",
    "symbol": "LORE",
    "name": "Gitopia",
    "link": "https://gitopia.com"
  },
  "629": {
    "index": "629",
    "hex": "0x80000275",
    "symbol": "FNR",
    "name": "Fincor",
    "link": "https://fincor.io"
  },
  "630": {
    "index": "630",
    "hex": "0x80000276",
    "symbol": "NEXUS",
    "name": "Nexus",
    "link": "http://www.thenexus.game"
  },
  "631": {
    "index": "631",
    "hex": "0x80000277",
    "symbol": "",
    "name": ""
  },
  "632": {
    "index": "632",
    "hex": "0x80000278",
    "symbol": "",
    "name": ""
  },
  "633": {
    "index": "633",
    "hex": "0x80000279",
    "symbol": "",
    "name": ""
  },
  "634": {
    "index": "634",
    "hex": "0x8000027a",
    "symbol": "",
    "name": ""
  },
  "635": {
    "index": "635",
    "hex": "0x8000027b",
    "symbol": "",
    "name": ""
  },
  "636": {
    "index": "636",
    "hex": "0x8000027c",
    "symbol": "",
    "name": ""
  },
  "637": {
    "index": "637",
    "hex": "0x8000027d",
    "symbol": "",
    "name": ""
  },
  "638": {
    "index": "638",
    "hex": "0x8000027e",
    "symbol": "",
    "name": ""
  },
  "639": {
    "index": "639",
    "hex": "0x8000027f",
    "symbol": "BTSG",
    "name": "BitSong",
    "link": "https://bitsong.io"
  },
  "640": {
    "index": "640",
    "hex": "0x80000280",
    "symbol": "LFC",
    "name": "Leofcoin",
    "link": "https://leofcoin.org"
  },
  "641": {
    "index": "641",
    "hex": "0x80000281",
    "symbol": "",
    "name": ""
  },
  "642": {
    "index": "642",
    "hex": "0x80000282",
    "symbol": "",
    "name": ""
  },
  "643": {
    "index": "643",
    "hex": "0x80000283",
    "symbol": "AZERO",
    "name": "Aleph Zero",
    "link": "https://alephzero.org"
  },
  "644": {
    "index": "644",
    "hex": "0x80000284",
    "symbol": "",
    "name": ""
  },
  "645": {
    "index": "645",
    "hex": "0x80000285",
    "symbol": "",
    "name": ""
  },
  "646": {
    "index": "646",
    "hex": "0x80000286",
    "symbol": "XLN",
    "name": "Lunarium",
    "link": "https://www.lunariumcoin.com"
  },
  "647": {
    "index": "647",
    "hex": "0x80000287",
    "symbol": "",
    "name": ""
  },
  "648": {
    "index": "648",
    "hex": "0x80000288",
    "symbol": "ZRB",
    "name": "Zarb",
    "link": "https://zarb.network"
  },
  "649": {
    "index": "649",
    "hex": "0x80000289",
    "symbol": "",
    "name": ""
  },
  "650": {
    "index": "650",
    "hex": "0x8000028a",
    "symbol": "UCO",
    "name": "ARCHEthic",
    "link": "https://archethic.net"
  },
  "651": {
    "index": "651",
    "hex": "0x8000028b",
    "symbol": "",
    "name": ""
  },
  "652": {
    "index": "652",
    "hex": "0x8000028c",
    "symbol": "",
    "name": ""
  },
  "653": {
    "index": "653",
    "hex": "0x8000028d",
    "symbol": "",
    "name": ""
  },
  "654": {
    "index": "654",
    "hex": "0x8000028e",
    "symbol": "",
    "name": ""
  },
  "655": {
    "index": "655",
    "hex": "0x8000028f",
    "symbol": "",
    "name": ""
  },
  "656": {
    "index": "656",
    "hex": "0x80000290",
    "symbol": "",
    "name": ""
  },
  "657": {
    "index": "657",
    "hex": "0x80000291",
    "symbol": "",
    "name": ""
  },
  "658": {
    "index": "658",
    "hex": "0x80000292",
    "symbol": "",
    "name": ""
  },
  "659": {
    "index": "659",
    "hex": "0x80000293",
    "symbol": "",
    "name": ""
  },
  "660": {
    "index": "660",
    "hex": "0x80000294",
    "symbol": "PIRATE",
    "name": "PirateCash",
    "link": "https://piratecash.net"
  },
  "661": {
    "index": "661",
    "hex": "0x80000295",
    "symbol": "",
    "name": ""
  },
  "662": {
    "index": "662",
    "hex": "0x80000296",
    "symbol": "",
    "name": ""
  },
  "663": {
    "index": "663",
    "hex": "0x80000297",
    "symbol": "SFRX",
    "name": "EtherGem Sapphire",
    "link": "https://egem.io"
  },
  "664": {
    "index": "664",
    "hex": "0x80000298",
    "symbol": "",
    "name": ""
  },
  "665": {
    "index": "665",
    "hex": "0x80000299",
    "symbol": "",
    "name": ""
  },
  "666": {
    "index": "666",
    "hex": "0x8000029a",
    "symbol": "ACT",
    "name": "Achain",
    "link": "https://www.achain.com"
  },
  "667": {
    "index": "667",
    "hex": "0x8000029b",
    "symbol": "PRKL",
    "name": "Perkle",
    "link": "https://esprezzo.io"
  },
  "668": {
    "index": "668",
    "hex": "0x8000029c",
    "symbol": "SSC",
    "name": "SelfSell",
    "link": "https://www.selfsell.com"
  },
  "669": {
    "index": "669",
    "hex": "0x8000029d",
    "symbol": "GC",
    "name": "GateChain",
    "link": "https://www.gatechain.io"
  },
  "670": {
    "index": "670",
    "hex": "0x8000029e",
    "symbol": "",
    "name": ""
  },
  "671": {
    "index": "671",
    "hex": "0x8000029f",
    "symbol": "",
    "name": ""
  },
  "672": {
    "index": "672",
    "hex": "0x800002a0",
    "symbol": "",
    "name": ""
  },
  "673": {
    "index": "673",
    "hex": "0x800002a1",
    "symbol": "",
    "name": ""
  },
  "674": {
    "index": "674",
    "hex": "0x800002a2",
    "symbol": "",
    "name": ""
  },
  "675": {
    "index": "675",
    "hex": "0x800002a3",
    "symbol": "",
    "name": ""
  },
  "676": {
    "index": "676",
    "hex": "0x800002a4",
    "symbol": "",
    "name": ""
  },
  "677": {
    "index": "677",
    "hex": "0x800002a5",
    "symbol": "YUNGE",
    "name": "Yunge",
    "link": "https://yunge.one"
  },
  "678": {
    "index": "678",
    "hex": "0x800002a6",
    "symbol": "Voken",
    "name": "Voken",
    "link": "https://voken.io"
  },
  "679": {
    "index": "679",
    "hex": "0x800002a7",
    "symbol": "",
    "name": ""
  },
  "680": {
    "index": "680",
    "hex": "0x800002a8",
    "symbol": "Evrynet",
    "name": "Evrynet",
    "link": "https://evrynet.io"
  },
  "681": {
    "index": "681",
    "hex": "0x800002a9",
    "symbol": "",
    "name": ""
  },
  "682": {
    "index": "682",
    "hex": "0x800002aa",
    "symbol": "",
    "name": ""
  },
  "683": {
    "index": "683",
    "hex": "0x800002ab",
    "symbol": "",
    "name": ""
  },
  "684": {
    "index": "684",
    "hex": "0x800002ac",
    "symbol": "",
    "name": ""
  },
  "685": {
    "index": "685",
    "hex": "0x800002ad",
    "symbol": "",
    "name": ""
  },
  "686": {
    "index": "686",
    "hex": "0x800002ae",
    "symbol": "KAR",
    "name": "Karura Network",
    "link": "https://karura.network"
  },
  "687": {
    "index": "687",
    "hex": "0x800002af",
    "symbol": "",
    "name": ""
  },
  "688": {
    "index": "688",
    "hex": "0x800002b0",
    "symbol": "CET",
    "name": "CoinEx Chain",
    "link": "https://www.coinex.org"
  },
  "689": {
    "index": "689",
    "hex": "0x800002b1",
    "symbol": "",
    "name": ""
  },
  "690": {
    "index": "690",
    "hex": "0x800002b2",
    "symbol": "",
    "name": ""
  },
  "691": {
    "index": "691",
    "hex": "0x800002b3",
    "symbol": "",
    "name": ""
  },
  "692": {
    "index": "692",
    "hex": "0x800002b4",
    "symbol": "",
    "name": ""
  },
  "693": {
    "index": "693",
    "hex": "0x800002b5",
    "symbol": "",
    "name": ""
  },
  "694": {
    "index": "694",
    "hex": "0x800002b6",
    "symbol": "",
    "name": ""
  },
  "695": {
    "index": "695",
    "hex": "0x800002b7",
    "symbol": "",
    "name": ""
  },
  "696": {
    "index": "696",
    "hex": "0x800002b8",
    "symbol": "",
    "name": ""
  },
  "697": {
    "index": "697",
    "hex": "0x800002b9",
    "symbol": "",
    "name": ""
  },
  "698": {
    "index": "698",
    "hex": "0x800002ba",
    "symbol": "VEIL",
    "name": "Veil",
    "link": "https://www.veil-project.com"
  },
  "699": {
    "index": "699",
    "hex": "0x800002bb",
    "symbol": "GIO",
    "name": "Gio",
    "link": "https://github.com/qGio"
  },
  "700": {
    "index": "700",
    "hex": "0x800002bc",
    "symbol": "XDAI",
    "name": "xDai",
    "link": "https://blockscout.com/poa/dai"
  },
  "701": {
    "index": "701",
    "hex": "0x800002bd",
    "symbol": "",
    "name": ""
  },
  "702": {
    "index": "702",
    "hex": "0x800002be",
    "symbol": "",
    "name": ""
  },
  "703": {
    "index": "703",
    "hex": "0x800002bf",
    "symbol": "",
    "name": ""
  },
  "704": {
    "index": "704",
    "hex": "0x800002c0",
    "symbol": "",
    "name": ""
  },
  "705": {
    "index": "705",
    "hex": "0x800002c1",
    "symbol": "",
    "name": ""
  },
  "706": {
    "index": "706",
    "hex": "0x800002c2",
    "symbol": "",
    "name": ""
  },
  "707": {
    "index": "707",
    "hex": "0x800002c3",
    "symbol": "MCOIN",
    "name": "Moneta Coin",
    "link": "https://moneta.today/monetacoin"
  },
  "708": {
    "index": "708",
    "hex": "0x800002c4",
    "symbol": "",
    "name": ""
  },
  "709": {
    "index": "709",
    "hex": "0x800002c5",
    "symbol": "",
    "name": ""
  },
  "710": {
    "index": "710",
    "hex": "0x800002c6",
    "symbol": "",
    "name": ""
  },
  "711": {
    "index": "711",
    "hex": "0x800002c7",
    "symbol": "CHC",
    "name": "Chaincoin",
    "link": "https://www.chaincoin.org"
  },
  "712": {
    "index": "712",
    "hex": "0x800002c8",
    "symbol": "",
    "name": ""
  },
  "713": {
    "index": "713",
    "hex": "0x800002c9",
    "symbol": "XTL",
    "name": "Katal Chain",
    "link": "https://katalchain.com"
  },
  "714": {
    "index": "714",
    "hex": "0x800002ca",
    "symbol": "BNB",
    "name": "Binance",
    "link": "https://www.binance.org"
  },
  "715": {
    "index": "715",
    "hex": "0x800002cb",
    "symbol": "SIN",
    "name": "Sinovate",
    "link": "https://sinovate.io"
  },
  "716": {
    "index": "716",
    "hex": "0x800002cc",
    "symbol": "DLN",
    "name": "Delion",
    "link": "https://delion.online"
  },
  "717": {
    "index": "717",
    "hex": "0x800002cd",
    "symbol": "",
    "name": ""
  },
  "718": {
    "index": "718",
    "hex": "0x800002ce",
    "symbol": "",
    "name": ""
  },
  "719": {
    "index": "719",
    "hex": "0x800002cf",
    "symbol": "",
    "name": ""
  },
  "720": {
    "index": "720",
    "hex": "0x800002d0",
    "symbol": "",
    "name": ""
  },
  "721": {
    "index": "721",
    "hex": "0x800002d1",
    "symbol": "",
    "name": ""
  },
  "722": {
    "index": "722",
    "hex": "0x800002d2",
    "symbol": "",
    "name": ""
  },
  "723": {
    "index": "723",
    "hex": "0x800002d3",
    "symbol": "",
    "name": ""
  },
  "724": {
    "index": "724",
    "hex": "0x800002d4",
    "symbol": "",
    "name": ""
  },
  "725": {
    "index": "725",
    "hex": "0x800002d5",
    "symbol": "MCX",
    "name": "MultiCash",
    "link": "https://multicash.io"
  },
  "726": {
    "index": "726",
    "hex": "0x800002d6",
    "symbol": "",
    "name": ""
  },
  "727": {
    "index": "727",
    "hex": "0x800002d7",
    "symbol": "",
    "name": ""
  },
  "728": {
    "index": "728",
    "hex": "0x800002d8",
    "symbol": "",
    "name": ""
  },
  "729": {
    "index": "729",
    "hex": "0x800002d9",
    "symbol": "",
    "name": ""
  },
  "730": {
    "index": "730",
    "hex": "0x800002da",
    "symbol": "",
    "name": ""
  },
  "731": {
    "index": "731",
    "hex": "0x800002db",
    "symbol": "BMK",
    "name": "Bitmark",
    "link": "https://bitmark.com"
  },
  "732": {
    "index": "732",
    "hex": "0x800002dc",
    "symbol": "",
    "name": ""
  },
  "733": {
    "index": "733",
    "hex": "0x800002dd",
    "symbol": "",
    "name": ""
  },
  "734": {
    "index": "734",
    "hex": "0x800002de",
    "symbol": "DENTX",
    "name": "DENTNet",
    "link": "https://www.dentnet.io"
  },
  "735": {
    "index": "735",
    "hex": "0x800002df",
    "symbol": "",
    "name": ""
  },
  "736": {
    "index": "736",
    "hex": "0x800002e0",
    "symbol": "",
    "name": ""
  },
  "737": {
    "index": "737",
    "hex": "0x800002e1",
    "symbol": "ATOP",
    "name": "Financial Blockchain"
  },
  "738": {
    "index": "738",
    "hex": "0x800002e2",
    "symbol": "",
    "name": ""
  },
  "739": {
    "index": "739",
    "hex": "0x800002e3",
    "symbol": "",
    "name": ""
  },
  "740": {
    "index": "740",
    "hex": "0x800002e4",
    "symbol": "",
    "name": ""
  },
  "741": {
    "index": "741",
    "hex": "0x800002e5",
    "symbol": "",
    "name": ""
  },
  "742": {
    "index": "742",
    "hex": "0x800002e6",
    "symbol": "",
    "name": ""
  },
  "743": {
    "index": "743",
    "hex": "0x800002e7",
    "symbol": "",
    "name": ""
  },
  "744": {
    "index": "744",
    "hex": "0x800002e8",
    "symbol": "",
    "name": ""
  },
  "745": {
    "index": "745",
    "hex": "0x800002e9",
    "symbol": "",
    "name": ""
  },
  "746": {
    "index": "746",
    "hex": "0x800002ea",
    "symbol": "",
    "name": ""
  },
  "747": {
    "index": "747",
    "hex": "0x800002eb",
    "symbol": "RAD",
    "name": "Centrifuge",
    "link": "https://centrifuge.io"
  },
  "748": {
    "index": "748",
    "hex": "0x800002ec",
    "symbol": "",
    "name": ""
  },
  "749": {
    "index": "749",
    "hex": "0x800002ed",
    "symbol": "",
    "name": ""
  },
  "750": {
    "index": "750",
    "hex": "0x800002ee",
    "symbol": "XPRT",
    "name": "Persistence",
    "link": "https://persistence.one"
  },
  "751": {
    "index": "751",
    "hex": "0x800002ef",
    "symbol": "",
    "name": ""
  },
  "752": {
    "index": "752",
    "hex": "0x800002f0",
    "symbol": "",
    "name": ""
  },
  "753": {
    "index": "753",
    "hex": "0x800002f1",
    "symbol": "",
    "name": ""
  },
  "754": {
    "index": "754",
    "hex": "0x800002f2",
    "symbol": "",
    "name": ""
  },
  "755": {
    "index": "755",
    "hex": "0x800002f3",
    "symbol": "",
    "name": ""
  },
  "756": {
    "index": "756",
    "hex": "0x800002f4",
    "symbol": "",
    "name": ""
  },
  "757": {
    "index": "757",
    "hex": "0x800002f5",
    "symbol": "",
    "name": ""
  },
  "758": {
    "index": "758",
    "hex": "0x800002f6",
    "symbol": "",
    "name": ""
  },
  "759": {
    "index": "759",
    "hex": "0x800002f7",
    "symbol": "",
    "name": ""
  },
  "760": {
    "index": "760",
    "hex": "0x800002f8",
    "symbol": "",
    "name": ""
  },
  "761": {
    "index": "761",
    "hex": "0x800002f9",
    "symbol": "",
    "name": ""
  },
  "762": {
    "index": "762",
    "hex": "0x800002fa",
    "symbol": "",
    "name": ""
  },
  "763": {
    "index": "763",
    "hex": "0x800002fb",
    "symbol": "",
    "name": ""
  },
  "764": {
    "index": "764",
    "hex": "0x800002fc",
    "symbol": "",
    "name": ""
  },
  "765": {
    "index": "765",
    "hex": "0x800002fd",
    "symbol": "",
    "name": ""
  },
  "766": {
    "index": "766",
    "hex": "0x800002fe",
    "symbol": "",
    "name": ""
  },
  "767": {
    "index": "767",
    "hex": "0x800002ff",
    "symbol": "",
    "name": ""
  },
  "768": {
    "index": "768",
    "hex": "0x80000300",
    "symbol": "BALLZ",
    "name": "Ballzcoin",
    "link": "https://ballzcoin.org"
  },
  "769": {
    "index": "769",
    "hex": "0x80000301",
    "symbol": "",
    "name": ""
  },
  "770": {
    "index": "770",
    "hex": "0x80000302",
    "symbol": "COSA",
    "name": "Cosanta",
    "link": "https://github.com/cosanta"
  },
  "771": {
    "index": "771",
    "hex": "0x80000303",
    "symbol": "BR",
    "name": "BR",
    "link": "https://bolsadigital.com.br"
  },
  "772": {
    "index": "772",
    "hex": "0x80000304",
    "symbol": "",
    "name": ""
  },
  "773": {
    "index": "773",
    "hex": "0x80000305",
    "symbol": "",
    "name": ""
  },
  "774": {
    "index": "774",
    "hex": "0x80000306",
    "symbol": "",
    "name": ""
  },
  "775": {
    "index": "775",
    "hex": "0x80000307",
    "symbol": "",
    "name": ""
  },
  "776": {
    "index": "776",
    "hex": "0x80000308",
    "symbol": "",
    "name": ""
  },
  "777": {
    "index": "777",
    "hex": "0x80000309",
    "symbol": "BTW",
    "name": "Bitcoin World",
    "link": "http://btw.one"
  },
  "778": {
    "index": "778",
    "hex": "0x8000030a",
    "symbol": "",
    "name": ""
  },
  "779": {
    "index": "779",
    "hex": "0x8000030b",
    "symbol": "",
    "name": ""
  },
  "780": {
    "index": "780",
    "hex": "0x8000030c",
    "symbol": "",
    "name": ""
  },
  "781": {
    "index": "781",
    "hex": "0x8000030d",
    "symbol": "",
    "name": ""
  },
  "782": {
    "index": "782",
    "hex": "0x8000030e",
    "symbol": "",
    "name": ""
  },
  "783": {
    "index": "783",
    "hex": "0x8000030f",
    "symbol": "",
    "name": ""
  },
  "784": {
    "index": "784",
    "hex": "0x80000310",
    "symbol": "",
    "name": ""
  },
  "785": {
    "index": "785",
    "hex": "0x80000311",
    "symbol": "",
    "name": ""
  },
  "786": {
    "index": "786",
    "hex": "0x80000312",
    "symbol": "UIDD",
    "name": "UIDD",
    "link": "https://github.com/UIDD/UIDD"
  },
  "787": {
    "index": "787",
    "hex": "0x80000313",
    "symbol": "ACA",
    "name": "Acala",
    "link": "https://acala.network"
  },
  "788": {
    "index": "788",
    "hex": "0x80000314",
    "symbol": "BNC",
    "name": "Bifrost",
    "link": "https://bifrost.finance"
  },
  "789": {
    "index": "789",
    "hex": "0x80000315",
    "symbol": "TAU",
    "name": "Lamden",
    "link": "https://lamden.io"
  },
  "790": {
    "index": "790",
    "hex": "0x80000316",
    "symbol": "",
    "name": ""
  },
  "791": {
    "index": "791",
    "hex": "0x80000317",
    "symbol": "",
    "name": ""
  },
  "792": {
    "index": "792",
    "hex": "0x80000318",
    "symbol": "",
    "name": ""
  },
  "793": {
    "index": "793",
    "hex": "0x80000319",
    "symbol": "",
    "name": ""
  },
  "794": {
    "index": "794",
    "hex": "0x8000031a",
    "symbol": "",
    "name": ""
  },
  "795": {
    "index": "795",
    "hex": "0x8000031b",
    "symbol": "",
    "name": ""
  },
  "796": {
    "index": "796",
    "hex": "0x8000031c",
    "symbol": "",
    "name": ""
  },
  "797": {
    "index": "797",
    "hex": "0x8000031d",
    "symbol": "",
    "name": ""
  },
  "798": {
    "index": "798",
    "hex": "0x8000031e",
    "symbol": "",
    "name": ""
  },
  "799": {
    "index": "799",
    "hex": "0x8000031f",
    "symbol": "",
    "name": ""
  },
  "800": {
    "index": "800",
    "hex": "0x80000320",
    "symbol": "BEET",
    "name": "Beetle Coin",
    "link": "https://beetlecoin.io"
  },
  "801": {
    "index": "801",
    "hex": "0x80000321",
    "symbol": "DST",
    "name": "DSTRA",
    "link": "https://dstra.io"
  },
  "802": {
    "index": "802",
    "hex": "0x80000322",
    "symbol": "",
    "name": ""
  },
  "803": {
    "index": "803",
    "hex": "0x80000323",
    "symbol": "",
    "name": ""
  },
  "804": {
    "index": "804",
    "hex": "0x80000324",
    "symbol": "",
    "name": ""
  },
  "805": {
    "index": "805",
    "hex": "0x80000325",
    "symbol": "",
    "name": ""
  },
  "806": {
    "index": "806",
    "hex": "0x80000326",
    "symbol": "",
    "name": ""
  },
  "807": {
    "index": "807",
    "hex": "0x80000327",
    "symbol": "",
    "name": ""
  },
  "808": {
    "index": "808",
    "hex": "0x80000328",
    "symbol": "QVT",
    "name": "Qvolta",
    "link": "https://qvolta.com"
  },
  "809": {
    "index": "809",
    "hex": "0x80000329",
    "symbol": "",
    "name": ""
  },
  "810": {
    "index": "810",
    "hex": "0x8000032a",
    "symbol": "",
    "name": ""
  },
  "811": {
    "index": "811",
    "hex": "0x8000032b",
    "symbol": "DVPN",
    "name": "Sentinel",
    "link": "https://sentinel.co"
  },
  "812": {
    "index": "812",
    "hex": "0x8000032c",
    "symbol": "",
    "name": ""
  },
  "813": {
    "index": "813",
    "hex": "0x8000032d",
    "symbol": "",
    "name": ""
  },
  "814": {
    "index": "814",
    "hex": "0x8000032e",
    "symbol": "",
    "name": ""
  },
  "815": {
    "index": "815",
    "hex": "0x8000032f",
    "symbol": "",
    "name": ""
  },
  "816": {
    "index": "816",
    "hex": "0x80000330",
    "symbol": "",
    "name": ""
  },
  "817": {
    "index": "817",
    "hex": "0x80000331",
    "symbol": "",
    "name": ""
  },
  "818": {
    "index": "818",
    "hex": "0x80000332",
    "symbol": "VET",
    "name": "VeChain Token",
    "link": "https://vechain.com"
  },
  "819": {
    "index": "819",
    "hex": "0x80000333",
    "symbol": "REEF",
    "name": "Reef",
    "link": "https://reef.io/"
  },
  "820": {
    "index": "820",
    "hex": "0x80000334",
    "symbol": "CLO",
    "name": "Callisto",
    "link": "http://callisto.network"
  },
  "821": {
    "index": "821",
    "hex": "0x80000335",
    "symbol": "",
    "name": ""
  },
  "822": {
    "index": "822",
    "hex": "0x80000336",
    "symbol": "BDB",
    "name": "BigchainDB",
    "link": "https://github.com/bigchaindb"
  },
  "823": {
    "index": "823",
    "hex": "0x80000337",
    "symbol": "",
    "name": ""
  },
  "824": {
    "index": "824",
    "hex": "0x80000338",
    "symbol": "",
    "name": ""
  },
  "825": {
    "index": "825",
    "hex": "0x80000339",
    "symbol": "",
    "name": ""
  },
  "826": {
    "index": "826",
    "hex": "0x8000033a",
    "symbol": "",
    "name": ""
  },
  "827": {
    "index": "827",
    "hex": "0x8000033b",
    "symbol": "",
    "name": ""
  },
  "828": {
    "index": "828",
    "hex": "0x8000033c",
    "symbol": "CCN",
    "name": "ComputeCoin",
    "link": "https://computecoin.network"
  },
  "829": {
    "index": "829",
    "hex": "0x8000033d",
    "symbol": "",
    "name": ""
  },
  "830": {
    "index": "830",
    "hex": "0x8000033e",
    "symbol": "",
    "name": ""
  },
  "831": {
    "index": "831",
    "hex": "0x8000033f",
    "symbol": "CRUZ",
    "name": "cruzbit",
    "link": "https://github.com/cruzbit/cruzbit"
  },
  "832": {
    "index": "832",
    "hex": "0x80000340",
    "symbol": "SAPP",
    "name": "Sapphire",
    "link": "https://sappcoin.com"
  },
  "833": {
    "index": "833",
    "hex": "0x80000341",
    "symbol": "777",
    "name": "Jackpot",
    "link": "https://777coin.win"
  },
  "834": {
    "index": "834",
    "hex": "0x80000342",
    "symbol": "KYAN",
    "name": "Kyanite",
    "link": "https://kyancoin.net"
  },
  "835": {
    "index": "835",
    "hex": "0x80000343",
    "symbol": "AZR",
    "name": "Azzure",
    "link": "https://azzurecoin.net"
  },
  "836": {
    "index": "836",
    "hex": "0x80000344",
    "symbol": "CFL",
    "name": "CryptoFlow",
    "link": "https://cryptoflow.eu"
  },
  "837": {
    "index": "837",
    "hex": "0x80000345",
    "symbol": "DASHD",
    "name": "Dash Diamond",
    "link": "https://dashdiamond.net"
  },
  "838": {
    "index": "838",
    "hex": "0x80000346",
    "symbol": "TRTT",
    "name": "Trittium",
    "link": "https://github.com/Trittium/trittium"
  },
  "839": {
    "index": "839",
    "hex": "0x80000347",
    "symbol": "UCR",
    "name": "Ultra Clear",
    "link": "https://ucrcoin.net"
  },
  "840": {
    "index": "840",
    "hex": "0x80000348",
    "symbol": "PNY",
    "name": "Peony",
    "link": "https://github.com/PeonyTeam/peony"
  },
  "841": {
    "index": "841",
    "hex": "0x80000349",
    "symbol": "BECN",
    "name": "Beacon",
    "link": "https://github.com/beaconcrypto/beacon"
  },
  "842": {
    "index": "842",
    "hex": "0x8000034a",
    "symbol": "MONK",
    "name": "Monk",
    "link": "https://monkcoin.net"
  },
  "843": {
    "index": "843",
    "hex": "0x8000034b",
    "symbol": "SAGA",
    "name": "CryptoSaga",
    "link": "https://github.com/cryptosagacoin/SAGA"
  },
  "844": {
    "index": "844",
    "hex": "0x8000034c",
    "symbol": "SUV",
    "name": "Suvereno",
    "link": "https://github.com/decenomy/SUV"
  },
  "845": {
    "index": "845",
    "hex": "0x8000034d",
    "symbol": "ESK",
    "name": "EskaCoin",
    "link": "https://eskacoin.com"
  },
  "846": {
    "index": "846",
    "hex": "0x8000034e",
    "symbol": "OWO",
    "name": "OneWorld Coin",
    "link": "https://oneworldcoin.io"
  },
  "847": {
    "index": "847",
    "hex": "0x8000034f",
    "symbol": "PEPS",
    "name": "PEPS Coin",
    "link": "https://project.peps.today"
  },
  "848": {
    "index": "848",
    "hex": "0x80000350",
    "symbol": "BIR",
    "name": "Birake",
    "link": "https://birake.com"
  },
  "849": {
    "index": "849",
    "hex": "0x80000351",
    "symbol": "",
    "name": ""
  },
  "850": {
    "index": "850",
    "hex": "0x80000352",
    "symbol": "",
    "name": ""
  },
  "851": {
    "index": "851",
    "hex": "0x80000353",
    "symbol": "",
    "name": ""
  },
  "852": {
    "index": "852",
    "hex": "0x80000354",
    "symbol": "DSM",
    "name": "Desmos",
    "link": "https://desmos.network"
  },
  "853": {
    "index": "853",
    "hex": "0x80000355",
    "symbol": "PRCY",
    "name": "PRCY Coin",
    "link": "https://prcycoin.com"
  },
  "854": {
    "index": "854",
    "hex": "0x80000356",
    "symbol": "",
    "name": ""
  },
  "855": {
    "index": "855",
    "hex": "0x80000357",
    "symbol": "",
    "name": ""
  },
  "856": {
    "index": "856",
    "hex": "0x80000358",
    "symbol": "",
    "name": ""
  },
  "857": {
    "index": "857",
    "hex": "0x80000359",
    "symbol": "",
    "name": ""
  },
  "858": {
    "index": "858",
    "hex": "0x8000035a",
    "symbol": "",
    "name": ""
  },
  "859": {
    "index": "859",
    "hex": "0x8000035b",
    "symbol": "",
    "name": ""
  },
  "860": {
    "index": "860",
    "hex": "0x8000035c",
    "symbol": "",
    "name": ""
  },
  "861": {
    "index": "861",
    "hex": "0x8000035d",
    "symbol": "",
    "name": ""
  },
  "862": {
    "index": "862",
    "hex": "0x8000035e",
    "symbol": "",
    "name": ""
  },
  "863": {
    "index": "863",
    "hex": "0x8000035f",
    "symbol": "",
    "name": ""
  },
  "864": {
    "index": "864",
    "hex": "0x80000360",
    "symbol": "",
    "name": ""
  },
  "865": {
    "index": "865",
    "hex": "0x80000361",
    "symbol": "",
    "name": ""
  },
  "866": {
    "index": "866",
    "hex": "0x80000362",
    "symbol": "MOB",
    "name": "MobileCoin",
    "link": "https://www.mobilecoin.com"
  },
  "867": {
    "index": "867",
    "hex": "0x80000363",
    "symbol": "",
    "name": ""
  },
  "868": {
    "index": "868",
    "hex": "0x80000364",
    "symbol": "IF",
    "name": "Infinitefuture",
    "link": "https://infinitefuture.top"
  },
  "869": {
    "index": "869",
    "hex": "0x80000365",
    "symbol": "",
    "name": ""
  },
  "870": {
    "index": "870",
    "hex": "0x80000366",
    "symbol": "",
    "name": ""
  },
  "871": {
    "index": "871",
    "hex": "0x80000367",
    "symbol": "",
    "name": ""
  },
  "872": {
    "index": "872",
    "hex": "0x80000368",
    "symbol": "",
    "name": ""
  },
  "873": {
    "index": "873",
    "hex": "0x80000369",
    "symbol": "",
    "name": ""
  },
  "874": {
    "index": "874",
    "hex": "0x8000036a",
    "symbol": "",
    "name": ""
  },
  "875": {
    "index": "875",
    "hex": "0x8000036b",
    "symbol": "",
    "name": ""
  },
  "876": {
    "index": "876",
    "hex": "0x8000036c",
    "symbol": "",
    "name": ""
  },
  "877": {
    "index": "877",
    "hex": "0x8000036d",
    "symbol": "",
    "name": ""
  },
  "878": {
    "index": "878",
    "hex": "0x8000036e",
    "symbol": "",
    "name": ""
  },
  "879": {
    "index": "879",
    "hex": "0x8000036f",
    "symbol": "",
    "name": ""
  },
  "880": {
    "index": "880",
    "hex": "0x80000370",
    "symbol": "LUM",
    "name": "Lum Network",
    "link": "https://lum.network"
  },
  "881": {
    "index": "881",
    "hex": "0x80000371",
    "symbol": "",
    "name": ""
  },
  "882": {
    "index": "882",
    "hex": "0x80000372",
    "symbol": "",
    "name": ""
  },
  "883": {
    "index": "883",
    "hex": "0x80000373",
    "symbol": "ZBC",
    "name": "ZooBC",
    "link": "https://zoobc.com"
  },
  "884": {
    "index": "884",
    "hex": "0x80000374",
    "symbol": "",
    "name": ""
  },
  "885": {
    "index": "885",
    "hex": "0x80000375",
    "symbol": "",
    "name": ""
  },
  "886": {
    "index": "886",
    "hex": "0x80000376",
    "symbol": "ADF",
    "name": "AD Token",
    "link": "http://adfunds.org"
  },
  "887": {
    "index": "887",
    "hex": "0x80000377",
    "symbol": "",
    "name": ""
  },
  "888": {
    "index": "888",
    "hex": "0x80000378",
    "symbol": "NEO",
    "name": "NEO",
    "link": "https://neo.org"
  },
  "889": {
    "index": "889",
    "hex": "0x80000379",
    "symbol": "TOMO",
    "name": "TOMO",
    "link": "https://tomochain.com"
  },
  "890": {
    "index": "890",
    "hex": "0x8000037a",
    "symbol": "XSEL",
    "name": "Seln",
    "link": "https://selnx.jp"
  },
  "891": {
    "index": "891",
    "hex": "0x8000037b",
    "symbol": "",
    "name": ""
  },
  "892": {
    "index": "892",
    "hex": "0x8000037c",
    "symbol": "",
    "name": ""
  },
  "893": {
    "index": "893",
    "hex": "0x8000037d",
    "symbol": "",
    "name": ""
  },
  "894": {
    "index": "894",
    "hex": "0x8000037e",
    "symbol": "",
    "name": ""
  },
  "895": {
    "index": "895",
    "hex": "0x8000037f",
    "symbol": "",
    "name": ""
  },
  "896": {
    "index": "896",
    "hex": "0x80000380",
    "symbol": "LKSC",
    "name": "LKSCoin",
    "link": "https://www.lkschain.io"
  },
  "897": {
    "index": "897",
    "hex": "0x80000381",
    "symbol": "",
    "name": ""
  },
  "898": {
    "index": "898",
    "hex": "0x80000382",
    "symbol": "",
    "name": ""
  },
  "899": {
    "index": "899",
    "hex": "0x80000383",
    "symbol": "XEC",
    "name": "eCash",
    "link": "https://e.cash"
  },
  "900": {
    "index": "900",
    "hex": "0x80000384",
    "symbol": "LMO",
    "name": "Lumeneo",
    "link": "https://lumeneo.network"
  },
  "901": {
    "index": "901",
    "hex": "0x80000385",
    "symbol": "",
    "name": ""
  },
  "902": {
    "index": "902",
    "hex": "0x80000386",
    "symbol": "",
    "name": ""
  },
  "903": {
    "index": "903",
    "hex": "0x80000387",
    "symbol": "",
    "name": ""
  },
  "904": {
    "index": "904",
    "hex": "0x80000388",
    "symbol": "HNT",
    "name": "Helium",
    "link": "https://helium.com"
  },
  "905": {
    "index": "905",
    "hex": "0x80000389",
    "symbol": "",
    "name": ""
  },
  "906": {
    "index": "906",
    "hex": "0x8000038a",
    "symbol": "",
    "name": ""
  },
  "907": {
    "index": "907",
    "hex": "0x8000038b",
    "symbol": "FIS",
    "name": "StaFi",
    "link": "https://stafi.io"
  },
  "908": {
    "index": "908",
    "hex": "0x8000038c",
    "symbol": "",
    "name": ""
  },
  "909": {
    "index": "909",
    "hex": "0x8000038d",
    "symbol": "SAAGE",
    "name": "Saage",
    "link": "https://saage.io"
  },
  "910": {
    "index": "910",
    "hex": "0x8000038e",
    "symbol": "",
    "name": ""
  },
  "911": {
    "index": "911",
    "hex": "0x8000038f",
    "symbol": "",
    "name": ""
  },
  "912": {
    "index": "912",
    "hex": "0x80000390",
    "symbol": "",
    "name": ""
  },
  "913": {
    "index": "913",
    "hex": "0x80000391",
    "symbol": "",
    "name": ""
  },
  "914": {
    "index": "914",
    "hex": "0x80000392",
    "symbol": "",
    "name": ""
  },
  "915": {
    "index": "915",
    "hex": "0x80000393",
    "symbol": "",
    "name": ""
  },
  "916": {
    "index": "916",
    "hex": "0x80000394",
    "symbol": "META",
    "name": "Metadium",
    "link": "https://www.metadium.com"
  },
  "917": {
    "index": "917",
    "hex": "0x80000395",
    "symbol": "FRA",
    "name": "Findora",
    "link": "https://www.findora.org"
  },
  "918": {
    "index": "918",
    "hex": "0x80000396",
    "symbol": "",
    "name": ""
  },
  "919": {
    "index": "919",
    "hex": "0x80000397",
    "symbol": "",
    "name": ""
  },
  "920": {
    "index": "920",
    "hex": "0x80000398",
    "symbol": "",
    "name": ""
  },
  "921": {
    "index": "921",
    "hex": "0x80000399",
    "symbol": "",
    "name": ""
  },
  "922": {
    "index": "922",
    "hex": "0x8000039a",
    "symbol": "",
    "name": ""
  },
  "923": {
    "index": "923",
    "hex": "0x8000039b",
    "symbol": "",
    "name": ""
  },
  "924": {
    "index": "924",
    "hex": "0x8000039c",
    "symbol": "",
    "name": ""
  },
  "925": {
    "index": "925",
    "hex": "0x8000039d",
    "symbol": "DIP",
    "name": "Dipper Network",
    "link": "https://www.dippernetwork.com"
  },
  "926": {
    "index": "926",
    "hex": "0x8000039e",
    "symbol": "",
    "name": ""
  },
  "927": {
    "index": "927",
    "hex": "0x8000039f",
    "symbol": "",
    "name": ""
  },
  "928": {
    "index": "928",
    "hex": "0x800003a0",
    "symbol": "",
    "name": ""
  },
  "929": {
    "index": "929",
    "hex": "0x800003a1",
    "symbol": "",
    "name": ""
  },
  "930": {
    "index": "930",
    "hex": "0x800003a2",
    "symbol": "",
    "name": ""
  },
  "931": {
    "index": "931",
    "hex": "0x800003a3",
    "symbol": "RUNE",
    "name": "THORChain (RUNE)",
    "link": "RUNE"
  },
  "932": {
    "index": "932",
    "hex": "0x800003a4",
    "symbol": "",
    "name": ""
  },
  "933": {
    "index": "933",
    "hex": "0x800003a5",
    "symbol": "",
    "name": ""
  },
  "934": {
    "index": "934",
    "hex": "0x800003a6",
    "symbol": "",
    "name": ""
  },
  "935": {
    "index": "935",
    "hex": "0x800003a7",
    "symbol": "",
    "name": ""
  },
  "936": {
    "index": "936",
    "hex": "0x800003a8",
    "symbol": "",
    "name": ""
  },
  "937": {
    "index": "937",
    "hex": "0x800003a9",
    "symbol": "",
    "name": ""
  },
  "938": {
    "index": "938",
    "hex": "0x800003aa",
    "symbol": "",
    "name": ""
  },
  "939": {
    "index": "939",
    "hex": "0x800003ab",
    "symbol": "",
    "name": ""
  },
  "940": {
    "index": "940",
    "hex": "0x800003ac",
    "symbol": "",
    "name": ""
  },
  "941": {
    "index": "941",
    "hex": "0x800003ad",
    "symbol": "",
    "name": ""
  },
  "942": {
    "index": "942",
    "hex": "0x800003ae",
    "symbol": "",
    "name": ""
  },
  "943": {
    "index": "943",
    "hex": "0x800003af",
    "symbol": "",
    "name": ""
  },
  "944": {
    "index": "944",
    "hex": "0x800003b0",
    "symbol": "",
    "name": ""
  },
  "945": {
    "index": "945",
    "hex": "0x800003b1",
    "symbol": "",
    "name": ""
  },
  "946": {
    "index": "946",
    "hex": "0x800003b2",
    "symbol": "",
    "name": ""
  },
  "947": {
    "index": "947",
    "hex": "0x800003b3",
    "symbol": "",
    "name": ""
  },
  "948": {
    "index": "948",
    "hex": "0x800003b4",
    "symbol": "",
    "name": ""
  },
  "949": {
    "index": "949",
    "hex": "0x800003b5",
    "symbol": "",
    "name": ""
  },
  "950": {
    "index": "950",
    "hex": "0x800003b6",
    "symbol": "",
    "name": ""
  },
  "951": {
    "index": "951",
    "hex": "0x800003b7",
    "symbol": "",
    "name": ""
  },
  "952": {
    "index": "952",
    "hex": "0x800003b8",
    "symbol": "",
    "name": ""
  },
  "953": {
    "index": "953",
    "hex": "0x800003b9",
    "symbol": "",
    "name": ""
  },
  "954": {
    "index": "954",
    "hex": "0x800003ba",
    "symbol": "",
    "name": ""
  },
  "955": {
    "index": "955",
    "hex": "0x800003bb",
    "symbol": "LTP",
    "name": "LifetionCoin",
    "link": "https://cointobanks.com"
  },
  "956": {
    "index": "956",
    "hex": "0x800003bc",
    "symbol": "",
    "name": ""
  },
  "957": {
    "index": "957",
    "hex": "0x800003bd",
    "symbol": "",
    "name": ""
  },
  "958": {
    "index": "958",
    "hex": "0x800003be",
    "symbol": "",
    "name": "KickSoccer",
    "link": "https://kicksoccercoin.com"
  },
  "959": {
    "index": "959",
    "hex": "0x800003bf",
    "symbol": "",
    "name": ""
  },
  "960": {
    "index": "960",
    "hex": "0x800003c0",
    "symbol": "",
    "name": ""
  },
  "961": {
    "index": "961",
    "hex": "0x800003c1",
    "symbol": "",
    "name": ""
  },
  "962": {
    "index": "962",
    "hex": "0x800003c2",
    "symbol": "",
    "name": ""
  },
  "963": {
    "index": "963",
    "hex": "0x800003c3",
    "symbol": "",
    "name": ""
  },
  "964": {
    "index": "964",
    "hex": "0x800003c4",
    "symbol": "",
    "name": ""
  },
  "965": {
    "index": "965",
    "hex": "0x800003c5",
    "symbol": "",
    "name": ""
  },
  "966": {
    "index": "966",
    "hex": "0x800003c6",
    "symbol": "MATIC",
    "name": "Matic",
    "link": "https://matic.network"
  },
  "967": {
    "index": "967",
    "hex": "0x800003c7",
    "symbol": "",
    "name": ""
  },
  "968": {
    "index": "968",
    "hex": "0x800003c8",
    "symbol": "",
    "name": ""
  },
  "969": {
    "index": "969",
    "hex": "0x800003c9",
    "symbol": "",
    "name": ""
  },
  "970": {
    "index": "970",
    "hex": "0x800003ca",
    "symbol": "TWINS",
    "name": "TWINS",
    "link": "https://win.win"
  },
  "971": {
    "index": "971",
    "hex": "0x800003cb",
    "symbol": "",
    "name": ""
  },
  "972": {
    "index": "972",
    "hex": "0x800003cc",
    "symbol": "",
    "name": ""
  },
  "973": {
    "index": "973",
    "hex": "0x800003cd",
    "symbol": "",
    "name": ""
  },
  "974": {
    "index": "974",
    "hex": "0x800003ce",
    "symbol": "",
    "name": ""
  },
  "975": {
    "index": "975",
    "hex": "0x800003cf",
    "symbol": "",
    "name": ""
  },
  "976": {
    "index": "976",
    "hex": "0x800003d0",
    "symbol": "",
    "name": ""
  },
  "977": {
    "index": "977",
    "hex": "0x800003d1",
    "symbol": "",
    "name": ""
  },
  "978": {
    "index": "978",
    "hex": "0x800003d2",
    "symbol": "",
    "name": ""
  },
  "979": {
    "index": "979",
    "hex": "0x800003d3",
    "symbol": "",
    "name": ""
  },
  "980": {
    "index": "980",
    "hex": "0x800003d4",
    "symbol": "",
    "name": ""
  },
  "981": {
    "index": "981",
    "hex": "0x800003d5",
    "symbol": "",
    "name": ""
  },
  "982": {
    "index": "982",
    "hex": "0x800003d6",
    "symbol": "",
    "name": ""
  },
  "983": {
    "index": "983",
    "hex": "0x800003d7",
    "symbol": "",
    "name": ""
  },
  "984": {
    "index": "984",
    "hex": "0x800003d8",
    "symbol": "",
    "name": ""
  },
  "985": {
    "index": "985",
    "hex": "0x800003d9",
    "symbol": "",
    "name": ""
  },
  "986": {
    "index": "986",
    "hex": "0x800003da",
    "symbol": "",
    "name": ""
  },
  "987": {
    "index": "987",
    "hex": "0x800003db",
    "symbol": "VCG",
    "name": "VipCoin.Gold",
    "link": "https://vipcoin.gold"
  },
  "988": {
    "index": "988",
    "hex": "0x800003dc",
    "symbol": "XAZAB",
    "name": "Xazab core",
    "link": "https://github.com/xazab"
  },
  "989": {
    "index": "989",
    "hex": "0x800003dd",
    "symbol": "AIOZ",
    "name": "AIOZ",
    "link": "https://aioz.network"
  },
  "990": {
    "index": "990",
    "hex": "0x800003de",
    "symbol": "",
    "name": ""
  },
  "991": {
    "index": "991",
    "hex": "0x800003df",
    "symbol": "PEC",
    "name": "Phoenix",
    "link": "https://github.com/phoenixchain/phoenix"
  },
  "992": {
    "index": "992",
    "hex": "0x800003e0",
    "symbol": "",
    "name": ""
  },
  "993": {
    "index": "993",
    "hex": "0x800003e1",
    "symbol": "",
    "name": ""
  },
  "994": {
    "index": "994",
    "hex": "0x800003e2",
    "symbol": "",
    "name": ""
  },
  "995": {
    "index": "995",
    "hex": "0x800003e3",
    "symbol": "",
    "name": ""
  },
  "996": {
    "index": "996",
    "hex": "0x800003e4",
    "symbol": "OKT",
    "name": "OKChain Token",
    "link": "https://www.okex.com/okchain"
  },
  "997": {
    "index": "997",
    "hex": "0x800003e5",
    "symbol": "SUM",
    "name": "Solidum",
    "link": "https://solidum.network"
  },
  "998": {
    "index": "998",
    "hex": "0x800003e6",
    "symbol": "LBTC",
    "name": "Lightning Bitcoin",
    "link": "http://lbtc.io"
  },
  "999": {
    "index": "999",
    "hex": "0x800003e7",
    "symbol": "BCD",
    "name": "Bitcoin Diamond",
    "link": "http://btcd.io"
  },
  "1000": {
    "index": "1000",
    "hex": "0x800003e8",
    "symbol": "BTN",
    "name": "Bitcoin New",
    "link": "http://bitcoinnew.org"
  },
  "1001": {
    "index": "1001",
    "hex": "0x800003e9",
    "symbol": "TT",
    "name": "ThunderCore",
    "link": "https://thundercore.com"
  },
  "1002": {
    "index": "1002",
    "hex": "0x800003ea",
    "symbol": "BKT",
    "name": "BanKitt",
    "link": "https://www.bankitt.network"
  },
  "1003": {
    "index": "1003",
    "hex": "0x800003eb",
    "symbol": "NODL",
    "name": "Nodle",
    "link": "https://nodle.io"
  },
  "1007": {
    "index": "1007",
    "hex": "0x800003ef",
    "symbol": "FTM",
    "name": "Fantom",
    "link": "https://fantom.foundation"
  },
  "1008": {
    "index": "1008",
    "hex": "0x800003f0",
    "symbol": "RPG",
    "name": "RPG",
    "link": "https://rangersprotocol.com"
  },
  "1010": {
    "index": "1010",
    "hex": "0x800003f2",
    "symbol": "HT",
    "name": "Huobi ECO Chain",
    "link": "https://www.hecochain.com"
  },
  "1011": {
    "index": "1011",
    "hex": "0x800003f3",
    "symbol": "ELV",
    "name": "Eluvio",
    "link": "https://eluv.io"
  },
  "1013": {
    "index": "1013",
    "hex": "0x800003f5",
    "symbol": "BIC",
    "name": "Beincrypto",
    "link": "https://beincrypto.org"
  },
  "1020": {
    "index": "1020",
    "hex": "0x800003fc",
    "symbol": "EVC",
    "name": "Evrice",
    "link": "https://evrice.com"
  },
  "1022": {
    "index": "1022",
    "hex": "0x800003fe",
    "symbol": "XRD",
    "name": "Radix DLT",
    "link": "https://www.radixdlt.com"
  },
  "1023": {
    "index": "1023",
    "hex": "0x800003ff",
    "symbol": "ONE",
    "name": "HARMONY-ONE",
    "link": "https://harmony.one"
  },
  "1024": {
    "index": "1024",
    "hex": "0x80000400",
    "symbol": "ONT",
    "name": "Ontology",
    "link": "https://ont.io"
  },
  "1026": {
    "index": "1026",
    "hex": "0x80000402",
    "symbol": "KEX",
    "name": "Kira Exchange Token",
    "link": "https://kiraex.com"
  },
  "1027": {
    "index": "1027",
    "hex": "0x80000403",
    "symbol": "MCM",
    "name": "Mochimo",
    "link": "https://mochimo.org"
  },
  "1032": {
    "index": "1032",
    "hex": "0x80000408",
    "symbol": "BTCR",
    "name": "BTCR",
    "link": "https://github.com/did-btcr"
  },
  "1111": {
    "index": "1111",
    "hex": "0x80000457",
    "symbol": "BBC",
    "name": "Big Bitcoin",
    "link": "http://bigbitcoins.org"
  },
  "1120": {
    "index": "1120",
    "hex": "0x80000460",
    "symbol": "RISE",
    "name": "RISE",
    "link": "https://rise.vision"
  },
  "1122": {
    "index": "1122",
    "hex": "0x80000462",
    "symbol": "CMT",
    "name": "CyberMiles Token",
    "link": "https://www.cybermiles.io"
  },
  "1128": {
    "index": "1128",
    "hex": "0x80000468",
    "symbol": "ETSC",
    "name": "Ethereum Social",
    "link": "https://ethereumsocial.kr"
  },
  "1129": {
    "index": "1129",
    "hex": "0x80000469",
    "symbol": "DFI",
    "name": "DeFiChain",
    "link": "https://defichain.com"
  },
  "1137": {
    "index": "1137",
    "hex": "0x80000471",
    "symbol": "$DAG",
    "name": "Constellation Labs",
    "link": "https://constellationnetwork.io"
  },
  "1145": {
    "index": "1145",
    "hex": "0x80000479",
    "symbol": "CDY",
    "name": "Bitcoin Candy",
    "link": "http://www.bitcoincandy.one"
  },
  "1170": {
    "index": "1170",
    "hex": "0x80000492",
    "symbol": "HOO",
    "name": "Hoo Smart Chain",
    "link": "https://www.hoosmartchain.com"
  },
  "1234": {
    "index": "1234",
    "hex": "0x800004d2",
    "symbol": "ALPH",
    "name": "Alephium",
    "link": "https://github.com/alephium/alephium"
  },
  "1285": {
    "index": "1285",
    "hex": "0x80000505",
    "symbol": "MOVR",
    "name": "Moonriver",
    "link": "https://github.com/PureStake/moonbeam"
  },
  "1337": {
    "index": "1337",
    "hex": "0x80000539",
    "symbol": "DFC",
    "name": "Defcoin",
    "link": "http://defcoin-ng.org"
  },
  "1397": {
    "index": "1397",
    "hex": "0x80000575",
    "symbol": "HYC",
    "name": "Hycon",
    "link": "https://hycon.io"
  },
  "1410": {
    "index": "1410",
    "hex": "0x80000582",
    "symbol": "TENTSLP",
    "name": "TENT Simple Ledger Protocol"
  },
  "1524": {
    "index": "1524",
    "hex": "0x800005f4",
    "symbol": "",
    "name": "Taler",
    "link": "http://taler.site"
  },
  "1533": {
    "index": "1533",
    "hex": "0x800005fd",
    "symbol": "BEAM",
    "name": "Beam",
    "link": "https://www.beam.mw"
  },
  "1616": {
    "index": "1616",
    "hex": "0x80000650",
    "symbol": "ELF",
    "name": "AELF",
    "link": "https://aelf.io"
  },
  "1618": {
    "index": "1618",
    "hex": "0x80000652",
    "symbol": "AUDL",
    "name": "AUDL",
    "link": "https://aud.one"
  },
  "1620": {
    "index": "1620",
    "hex": "0x80000654",
    "symbol": "ATH",
    "name": "Atheios",
    "link": "https://atheios.com"
  },
  "1642": {
    "index": "1642",
    "hex": "0x8000066a",
    "symbol": "NEW",
    "name": "Newton",
    "link": "https://www.newtonproject.org"
  },
  "1657": {
    "index": "1657",
    "hex": "0x80000679",
    "symbol": "BTA",
    "name": "Btachain",
    "link": "https://bitcoinasset.io"
  },
  "1688": {
    "index": "1688",
    "hex": "0x80000698",
    "symbol": "BCX",
    "name": "BitcoinX",
    "link": "https://bcx.org"
  },
  "1729": {
    "index": "1729",
    "hex": "0x800006c1",
    "symbol": "XTZ",
    "name": "Tezos",
    "link": "https://tezos.com"
  },
  "1776": {
    "index": "1776",
    "hex": "0x800006f0",
    "symbol": "LBTC",
    "name": "Liquid BTC",
    "link": "https://blockstream.com/liquid"
  },
  "1777": {
    "index": "1777",
    "hex": "0x800006f1",
    "symbol": "BBP",
    "name": "Biblepay",
    "link": "https://www.biblepay.org"
  },
  "1784": {
    "index": "1784",
    "hex": "0x800006f8",
    "symbol": "JPYS",
    "name": "JPY Stablecoin",
    "link": "https://settlenet.io"
  },
  "1789": {
    "index": "1789",
    "hex": "0x800006fd",
    "symbol": "VEGA",
    "name": "Vega Protocol",
    "link": "https://vega.xyz"
  },
  "1815": {
    "index": "1815",
    "hex": "0x80000717",
    "symbol": "ADA",
    "name": "Cardano",
    "link": "https://www.cardanohub.org/en/home"
  },
  "1856": {
    "index": "1856",
    "hex": "0x80000743",
    "symbol": "TES",
    "name": "Teslacoin",
    "link": "https://www.tesla-coin.com"
  },
  "1888": {
    "index": "1888",
    "hex": "0x80000760",
    "symbol": "ZTX",
    "name": "Zetrix",
    "link": "https://zetrix.com/"
  },
  "1899": {
    "index": "1899",
    "hex": "0x8000076b",
    "symbol": "XEC",
    "name": "eCash token",
    "link": "https://e.cash"
  },
  "1901": {
    "index": "1901",
    "hex": "0x8000076d",
    "symbol": "CLC",
    "name": "Classica",
    "link": "https://github.com/classica"
  },
  "1919": {
    "index": "1919",
    "hex": "0x8000077f",
    "symbol": "VIPS",
    "name": "VIPSTARCOIN",
    "link": "https://www.vipstarcoin.jp"
  },
  "1926": {
    "index": "1926",
    "hex": "0x80000786",
    "symbol": "CITY",
    "name": "City Coin",
    "link": "https://city-chain.org"
  },
  "1955": {
    "index": "1955",
    "hex": "0x800007a3",
    "symbol": "XX",
    "name": "xx coin",
    "link": "https://xx.network"
  },
  "1977": {
    "index": "1977",
    "hex": "0x800007b9",
    "symbol": "XMX",
    "name": "Xuma",
    "link": "http://www.xumacoin.org"
  },
  "1984": {
    "index": "1984",
    "hex": "0x800007c0",
    "symbol": "TRTL",
    "name": "TurtleCoin",
    "link": "https://turtlecoin.lol"
  },
  "1987": {
    "index": "1987",
    "hex": "0x800007c3",
    "symbol": "EGEM",
    "name": "EtherGem",
    "link": "https://egem.io"
  },
  "1989": {
    "index": "1989",
    "hex": "0x800007c5",
    "symbol": "HODL",
    "name": "HOdlcoin",
    "link": "https://hodlcoin.com"
  },
  "1990": {
    "index": "1990",
    "hex": "0x800007c6",
    "symbol": "PHL",
    "name": "Placeholders",
    "link": "https://placeh.io"
  },
  "1991": {
    "index": "1991",
    "hex": "0x800007c7",
    "symbol": "SC",
    "name": "Sia",
    "link": "https://sia.tech"
  },
  "1996": {
    "index": "1996",
    "hex": "0x800007cc",
    "symbol": "MYT",
    "name": "Mineyourtime",
    "link": "https://mineyourtime.com"
  },
  "1997": {
    "index": "1997",
    "hex": "0x800007cd",
    "symbol": "POLIS",
    "name": "Polis",
    "link": "https://polispay.org"
  },
  "1998": {
    "index": "1998",
    "hex": "0x800007ce",
    "symbol": "XMCC",
    "name": "Monoeci",
    "link": "https://monoeci.io"
  },
  "1999": {
    "index": "1999",
    "hex": "0x800007cf",
    "symbol": "COLX",
    "name": "ColossusXT",
    "link": "https://colossusxt.io"
  },
  "2000": {
    "index": "2000",
    "hex": "0x800007d0",
    "symbol": "GIN",
    "name": "GinCoin",
    "link": "https://gincoin.io"
  },
  "2001": {
    "index": "2001",
    "hex": "0x800007d1",
    "symbol": "MNP",
    "name": "MNPCoin",
    "link": "https://mnpcoin.pro"
  },
  "2017": {
    "index": "2017",
    "hex": "0x800007e1",
    "symbol": "KIN",
    "name": "Kin",
    "link": "https://www.kinecosystem.org"
  },
  "2018": {
    "index": "2018",
    "hex": "0x800007e2",
    "symbol": "EOSC",
    "name": "EOSClassic",
    "link": "https://eos-classic.io"
  },
  "2019": {
    "index": "2019",
    "hex": "0x800007e3",
    "symbol": "GBT",
    "name": "GoldBean Token",
    "link": "http://www.adfunds.org"
  },
  "2020": {
    "index": "2020",
    "hex": "0x800007e4",
    "symbol": "PKC",
    "name": "PKC",
    "link": "https://www.pkc.ink"
  },
  "2021": {
    "index": "2021",
    "hex": "0x800007e5",
    "symbol": "SKT",
    "name": "Sukhavati",
    "link": "https://sukhavati.io"
  },
  "2022": {
    "index": "2022",
    "hex": "0x800007e6",
    "symbol": "XHT",
    "name": "Xinghuo Token",
    "link": "https://xinghuo.space"
  },
  "2048": {
    "index": "2048",
    "hex": "0x80000800",
    "symbol": "MCASH",
    "name": "MCashChain",
    "link": "https://mcash.network"
  },
  "2049": {
    "index": "2049",
    "hex": "0x80000801",
    "symbol": "TRUE",
    "name": "TrueChain",
    "link": "https://www.truechain.pro"
  },
  "2112": {
    "index": "2112",
    "hex": "0x80000840",
    "symbol": "IoTE",
    "name": "IoTE",
    "link": "https://www.iote.one"
  },
  "2137": {
    "index": "2137",
    "hex": "0x80000859",
    "symbol": "XRG",
    "name": "Ergon",
    "link": "https://ergon.moe"
  },
  "2221": {
    "index": "2221",
    "hex": "0x800008ad",
    "symbol": "ASK",
    "name": "ASK",
    "link": "https://permission.io"
  },
  "2301": {
    "index": "2301",
    "hex": "0x800008fd",
    "symbol": "QTUM",
    "name": "QTUM",
    "link": "https://qtum.org/en"
  },
  "2302": {
    "index": "2302",
    "hex": "0x800008fe",
    "symbol": "ETP",
    "name": "Metaverse",
    "link": "https://mvs.org"
  },
  "2303": {
    "index": "2303",
    "hex": "0x800008ff",
    "symbol": "GXC",
    "name": "GXChain",
    "link": "https://www.gxb.io"
  },
  "2304": {
    "index": "2304",
    "hex": "0x80000900",
    "symbol": "CRP",
    "name": "CranePay",
    "link": "https://cranepay.io"
  },
  "2305": {
    "index": "2305",
    "hex": "0x80000901",
    "symbol": "ELA",
    "name": "Elastos",
    "link": "https://www.elastos.org"
  },
  "2338": {
    "index": "2338",
    "hex": "0x80000922",
    "symbol": "SNOW",
    "name": "Snowblossom",
    "link": "https://snowblossom.org"
  },
  "2570": {
    "index": "2570",
    "hex": "0x80000a0a",
    "symbol": "AOA",
    "name": "Aurora",
    "link": "https://www.aurorachain.io"
  },
  "2718": {
    "index": "2718",
    "hex": "0x80000a9e",
    "symbol": "NAS",
    "name": "Nebulas",
    "link": "https://nebulas.io"
  },
  "2894": {
    "index": "2894",
    "hex": "0x80000b4e",
    "symbol": "REOSC",
    "name": "REOSC Ecosystem",
    "link": "https://www.reosc.io"
  },
  "2941": {
    "index": "2941",
    "hex": "0x80000b7d",
    "symbol": "BND",
    "name": "Blocknode",
    "link": "https://blocknode.tech"
  },
  "3003": {
    "index": "3003",
    "hex": "0x80000bbb",
    "symbol": "LUX",
    "name": "LUX",
    "link": "https://luxcore.io"
  },
  "3030": {
    "index": "3030",
    "hex": "0x80000bd6",
    "symbol": "XHB",
    "name": "Hedera HBAR",
    "link": "https://www.hedera.com"
  },
  "3077": {
    "index": "3077",
    "hex": "0x80000c05",
    "symbol": "COS",
    "name": "Contentos",
    "link": "https://www.contentos.io"
  },
  "3276": {
    "index": "3276",
    "hex": "0x80000ccc",
    "symbol": "CCC",
    "name": "CodeChain",
    "link": "https://codechain.io"
  },
  "3377": {
    "index": "3377",
    "hex": "0x80000d31",
    "symbol": "ROI",
    "name": "ROIcoin",
    "link": "https://roi-coin.com"
  },
  "3381": {
    "index": "3381",
    "hex": "0x80000d35",
    "symbol": "DYN",
    "name": "Dynamic",
    "link": "https://duality.solutions/dynamic"
  },
  "3383": {
    "index": "3383",
    "hex": "0x80000d37",
    "symbol": "SEQ",
    "name": "Sequence",
    "link": "https://duality.solutions/sequence"
  },
  "3552": {
    "index": "3552",
    "hex": "0x80000de0",
    "symbol": "DEO",
    "name": "Destocoin",
    "link": "https://desto.io"
  },
  "3564": {
    "index": "3564",
    "hex": "0x80000dec",
    "symbol": "DST",
    "name": "DeStream",
    "link": "https://destream.io"
  },
  "4040": {
    "index": "4040",
    "hex": "0x80000fc8",
    "symbol": "FC8",
    "name": "FCH Network",
    "link": "https://fch.network"
  },
  "4096": {
    "index": "4096",
    "hex": "0x80001000",
    "symbol": "YEE",
    "name": "YeeCo",
    "link": "https://www.yeeco.io"
  },
  "4218": {
    "index": "4218",
    "hex": "0x8000107a",
    "symbol": "IOTA",
    "name": "IOTA",
    "link": "https://www.iota.org"
  },
  "4242": {
    "index": "4242",
    "hex": "0x80001092",
    "symbol": "AXE",
    "name": "Axe",
    "link": "https://github.com/AXErunners/axe"
  },
  "4343": {
    "index": "4343",
    "hex": "0x800010f7",
    "symbol": "XYM",
    "name": "Symbol",
    "link": "https://github.com/nemtech/catapult-server"
  },
  "5248": {
    "index": "5248",
    "hex": "0x80001480",
    "symbol": "FIC",
    "name": "FIC",
    "link": "https://ficnetwork.com"
  },
  "5353": {
    "index": "5353",
    "hex": "0x800014e9",
    "symbol": "HNS",
    "name": "Handshake",
    "link": "https://handshake.org"
  },
  "5555": {
    "index": "5555",
    "hex": "0x800015b3",
    "symbol": "FUND",
    "name": "Unification",
    "link": "https://unification.com"
  },
  "5757": {
    "index": "5757",
    "hex": "0x8000167d",
    "symbol": "STX",
    "name": "Blockstack",
    "link": "https://github.com/blockstack/blockstack-core"
  },
  "5895": {
    "index": "5895",
    "hex": "0x80001707",
    "symbol": "VOW",
    "name": "VowChain VOW",
    "link": "https://vowchain.net"
  },
  "5920": {
    "index": "5920",
    "hex": "0x80001720",
    "symbol": "SLU",
    "name": "SILUBIUM",
    "link": "https://github.com/SilubiumProject/slucore"
  },
  "6060": {
    "index": "6060",
    "hex": "0x800017ac",
    "symbol": "GO",
    "name": "GoChain GO",
    "link": "https://gochain.io"
  },
  "6174": {
    "index": "6174",
    "hex": "0x8000181e",
    "symbol": "MOI",
    "name": "My Own Internet",
    "link": "https://moi-id.life"
  },
  "6666": {
    "index": "6666",
    "hex": "0x80001a0a",
    "symbol": "BPA",
    "name": "Bitcoin Pizza",
    "link": "http://p.top"
  },
  "6688": {
    "index": "6688",
    "hex": "0x80001a20",
    "symbol": "SAFE",
    "name": "SAFE",
    "link": "http://www.anwang.com"
  },
  "6969": {
    "index": "6969",
    "hex": "0x80001b39",
    "symbol": "ROGER",
    "name": "TheHolyrogerCoin",
    "link": "https://github.com/TheHolyRoger/TheHolyRogerCoin"
  },
  "7091": {
    "index": "7091",
    "hex": "0x80001bb3",
    "symbol": "TOPL",
    "name": "Topl",
    "link": "https://www.topl.co"
  },
  "7777": {
    "index": "7777",
    "hex": "0x80001e61",
    "symbol": "BTV",
    "name": "Bitvote",
    "link": "https://www.bitvote.one"
  },
  "8000": {
    "index": "8000",
    "hex": "0x80001f40",
    "symbol": "SKY",
    "name": "Skycoin",
    "link": "https://www.skycoin.net"
  },
  "8080": {
    "index": "8080",
    "hex": "0x80001f90",
    "symbol": "",
    "name": "DSRV",
    "link": "https://www.dsrvlabs.com"
  },
  "8192": {
    "index": "8192",
    "hex": "0x80002000",
    "symbol": "PAC",
    "name": "pacprotocol",
    "link": "https://www.pacprotocol.com"
  },
  "8217": {
    "index": "8217",
    "hex": "0x80002019",
    "symbol": "KLAY",
    "name": "KLAY",
    "link": "https://www.klaytn.com"
  },
  "8339": {
    "index": "8339",
    "hex": "0x80002093",
    "symbol": "BTQ",
    "name": "BitcoinQuark",
    "link": "https://www.bitcoinquark.org"
  },
  "8444": {
    "index": "8444",
    "hex": "0x800020fc",
    "symbol": "XCH",
    "name": "Chia",
    "link": "https://www.chia.net"
  },
  "8520": {
    "index": "8520",
    "hex": "0x80002148",
    "symbol": "---",
    "name": "reserved"
  },
  "8888": {
    "index": "8888",
    "hex": "0x800022b8",
    "symbol": "SBTC",
    "name": "Super Bitcoin",
    "link": "https://www.superbtc.org"
  },
  "8964": {
    "index": "8964",
    "hex": "0x80002304",
    "symbol": "NULS",
    "name": "NULS",
    "link": "https://nuls.io"
  },
  "8999": {
    "index": "8999",
    "hex": "0x80002327",
    "symbol": "BTP",
    "name": "Bitcoin Pay",
    "link": "http://www.btceasypay.com"
  },
  "9000": {
    "index": "9000",
    "hex": "0x80002328",
    "symbol": "AVAX",
    "name": "Avalanche",
    "link": "https://www.avax.network"
  },
  "9001": {
    "index": "9001",
    "hex": "0x80002329",
    "symbol": "ARB",
    "name": "Arbitrum",
    "link": "https://arbitrum.io"
  },
  "9002": {
    "index": "9002",
    "hex": "0x8000232a",
    "symbol": "BOBA",
    "name": "Boba",
    "link": "https://boba.network"
  },
  "9003": {
    "index": "9003",
    "hex": "0x8000232b",
    "symbol": "LOOP",
    "name": "Loopring",
    "link": "https://loopring.org"
  },
  "9004": {
    "index": "9004",
    "hex": "0x8000232c",
    "symbol": "STARK",
    "name": "Starkware",
    "link": "https://starkware.co"
  },
  "9005": {
    "index": "9005",
    "hex": "0x8000232d",
    "symbol": "AVAXC",
    "name": "Avalanche C-Chain",
    "link": "https://www.avax.network"
  },
  "9006": {
    "index": "9006",
    "hex": "0x8000232e",
    "symbol": "BSC",
    "name": "Binance Smart Chain",
    "link": "https://www.binance.org/en/smartChain"
  },
  "9797": {
    "index": "9797",
    "hex": "0x80002645",
    "symbol": "NRG",
    "name": "Energi",
    "link": "https://www.energi.world"
  },
  "9888": {
    "index": "9888",
    "hex": "0x800026a0",
    "symbol": "BTF",
    "name": "Bitcoin Faith",
    "link": "http://bitcoinfaith.org"
  },
  "9999": {
    "index": "9999",
    "hex": "0x8000270f",
    "symbol": "GOD",
    "name": "Bitcoin God",
    "link": "https://www.bitcoingod.org"
  },
  "10000": {
    "index": "10000",
    "hex": "0x80002710",
    "symbol": "FO",
    "name": "FIBOS",
    "link": "https://fibos.io"
  },
  "10226": {
    "index": "10226",
    "hex": "0x800027f2",
    "symbol": "RTM",
    "name": "Raptoreum",
    "link": "https://raptoreum.com"
  },
  "10291": {
    "index": "10291",
    "hex": "0x80002833",
    "symbol": "XRC",
    "name": "XRhodium",
    "link": "https://www.xrhodium.org"
  },
  "10605": {
    "index": "10605",
    "hex": "0x8000296d",
    "symbol": "XPI",
    "name": "Lotus",
    "link": "https://givelotus.org"
  },
  "11111": {
    "index": "11111",
    "hex": "0x80002b67",
    "symbol": "ESS",
    "name": "Essentia One",
    "link": "https://essentia.one"
  },
  "12345": {
    "index": "12345",
    "hex": "0x80003039",
    "symbol": "IPOS",
    "name": "IPOS",
    "link": "https://iposlab.com"
  },
  "12586": {
    "index": "12586",
    "hex": "0x8000312a",
    "symbol": "MINA",
    "name": "Mina",
    "link": "https://minaprotocol.com"
  },
  "13107": {
    "index": "13107",
    "hex": "0x80003333",
    "symbol": "BTY",
    "name": "BitYuan",
    "link": "https://www.bityuan.com"
  },
  "13108": {
    "index": "13108",
    "hex": "0x80003334",
    "symbol": "YCC",
    "name": "Yuan Chain Coin",
    "link": "https://www.yuan.org"
  },
  "15845": {
    "index": "15845",
    "hex": "0x80003de5",
    "symbol": "SDGO",
    "name": "SanDeGo",
    "link": "http://www.sandego.net"
  },
  "16181": {
    "index": "16181",
    "hex": "0x80003f35",
    "symbol": "XTX",
    "name": "Totem Live Network",
    "link": "https://totem.live"
  },
  "16754": {
    "index": "16754",
    "hex": "0x80004172",
    "symbol": "ARDR",
    "name": "Ardor",
    "link": "https://www.jelurida.com"
  },
  "18000": {
    "index": "18000",
    "hex": "0x80004650",
    "symbol": "MTR",
    "name": "Meter",
    "link": "https://Meter.io"
  },
  "19165": {
    "index": "19165",
    "hex": "0x80004add",
    "symbol": "SAFE",
    "name": "Safecoin",
    "link": "https://www.safecoin.org"
  },
  "19167": {
    "index": "19167",
    "hex": "0x80004adf",
    "symbol": "FLUX",
    "name": "Flux",
    "link": "https://runonflux.io"
  },
  "19169": {
    "index": "19169",
    "hex": "0x80004ae1",
    "symbol": "RITO",
    "name": "Ritocoin",
    "link": "https://www.ritocoin.org"
  },
  "20036": {
    "index": "20036",
    "hex": "0x80004e44",
    "symbol": "XND",
    "name": "ndau",
    "link": "https://ndau.io"
  },
  "22504": {
    "index": "22504",
    "hex": "0x800057e8",
    "symbol": "PWR",
    "name": "PWRcoin",
    "link": "https://github.com/Plainkoin/PWRcoin"
  },
  "25252": {
    "index": "25252",
    "hex": "0x800062a4",
    "symbol": "BELL",
    "name": "Bellcoin",
    "link": "https://bellcoin.web4u.jp"
  },
  "25718": {
    "index": "25718",
    "hex": "0x80006476",
    "symbol": "CHX",
    "name": "Own",
    "link": "https://wallet.weown.com"
  },
  "31102": {
    "index": "31102",
    "hex": "0x8000797e",
    "symbol": "ESN",
    "name": "EtherSocial Network",
    "link": "https://ethersocial.network"
  },
  "31337": {
    "index": "31337",
    "hex": "0x80007a69",
    "symbol": "",
    "name": "ThePower.io",
    "link": "https://thepower.io"
  },
  "33416": {
    "index": "33416",
    "hex": "0x80008288",
    "symbol": "TEO",
    "name": "Trust Eth reOrigin",
    "link": "https://tao.foundation"
  },
  "33878": {
    "index": "33878",
    "hex": "0x80008456",
    "symbol": "BTCS",
    "name": "Bitcoin Stake",
    "link": "http://www.btcscoin.com"
  },
  "34952": {
    "index": "34952",
    "hex": "0x80008888",
    "symbol": "BTT",
    "name": "ByteTrade",
    "link": "https://bytetrade.io"
  },
  "37992": {
    "index": "37992",
    "hex": "0x80009468",
    "symbol": "FXTC",
    "name": "FixedTradeCoin",
    "link": "https://fixedtradecoin.org"
  },
  "39321": {
    "index": "39321",
    "hex": "0x80009999",
    "symbol": "AMA",
    "name": "Amabig",
    "link": "https://amabig.com"
  },
  "43028": {
    "index": "43028",
    "hex": "0x8000a814",
    "symbol": "AXIV",
    "name": "AXIV",
    "link": "https://phore.io"
  },
  "49262": {
    "index": "49262",
    "hex": "0x8000c06e",
    "symbol": "EVE",
    "name": "evan.network",
    "link": "https://evan.network"
  },
  "49344": {
    "index": "49344",
    "hex": "0x8000c0c0",
    "symbol": "STASH",
    "name": "STASH",
    "link": "https://stashpay.io"
  },
  "52752": {
    "index": "52752",
    "hex": "0x8000ce10",
    "symbol": "CELO",
    "name": "Celo",
    "link": "https://celo.org"
  },
  "65536": {
    "index": "65536",
    "hex": "0x80010000",
    "symbol": "KETH",
    "name": "Krypton World",
    "link": "http:/krypton.world"
  },
  "69420": {
    "index": "69420",
    "hex": "0x80010f2c",
    "symbol": "GRLC",
    "name": "Garlicoin",
    "link": "https://garlicoin.io"
  },
  "70007": {
    "index": "70007",
    "hex": "0x80011177",
    "symbol": "GWL",
    "name": "Gewel",
    "link": "https://gewel.io"
  },
  "77777": {
    "index": "77777",
    "hex": "0x80012fd1",
    "symbol": "ZYN",
    "name": "Wethio",
    "link": "https://wethio.io"
  },
  "88888": {
    "index": "88888",
    "hex": "0x80015b38",
    "symbol": "RYO",
    "name": "c0ban",
    "link": "https://www.c0ban.co"
  },
  "99999": {
    "index": "99999",
    "hex": "0x8001869f",
    "symbol": "WICC",
    "name": "Waykichain",
    "link": "http://www.waykichain.com"
  },
  "100500": {
    "index": "100500",
    "hex": "0x80018894",
    "symbol": "HOME",
    "name": "HomeCoin",
    "link": "https://homecoin.ru"
  },
  "101010": {
    "index": "101010",
    "hex": "0x80018a92",
    "symbol": "STC",
    "name": "Starcoin",
    "link": "https://starcoin.org"
  },
  "105105": {
    "index": "105105",
    "hex": "0x80019a91",
    "symbol": "STRAX",
    "name": "Strax",
    "link": "http://www.stratisplatform.com"
  },
  "200625": {
    "index": "200625",
    "hex": "0x80030fb1",
    "symbol": "AKA",
    "name": "Akroma",
    "link": "https://akroma.io"
  },
  "200665": {
    "index": "200665",
    "hex": "0x80011000",
    "symbol": "GENOM",
    "name": "GENOM",
    "link": "https://genom.tech"
  },
  "246529": {
    "index": "246529",
    "hex": "0x8003c301",
    "symbol": "ATS",
    "name": "ARTIS sigma1",
    "link": "https://artis.eco"
  },
  "314159": {
    "index": "314159",
    "hex": "0x8004cb2f",
    "symbol": "PI",
    "name": "Pi Network",
    "link": "http://minepi.com"
  },
  "333332": {
    "index": "333332",
    "hex": "0x80051614",
    "symbol": "VALUE",
    "name": "Value Chain"
  },
  "333333": {
    "index": "333333",
    "hex": "0x80051615",
    "symbol": "3333",
    "name": "Pi Value Consensus"
  },
  "424242": {
    "index": "424242",
    "hex": "0x80067932",
    "symbol": "X42",
    "name": "x42",
    "link": "http://www.x42.tech"
  },
  "666666": {
    "index": "666666",
    "hex": "0x800a2c2a",
    "symbol": "VITE",
    "name": "Vite",
    "link": "https://www.vite.org"
  },
  "888888": {
    "index": "888888",
    "hex": "0x800d9038",
    "symbol": "SEA",
    "name": "Second Exchange Alliance",
    "link": "https://www.seaio.cc"
  },
  "1171337": {
    "index": "1171337",
    "hex": "0x8011df89",
    "symbol": "ILT",
    "name": "iOlite",
    "link": "https://iolite.io"
  },
  "1313114": {
    "index": "1313114",
    "hex": "0x8014095a",
    "symbol": "ETHO",
    "name": "Ether-1",
    "link": "https://www.ether1.org"
  },
  "1313500": {
    "index": "1313500",
    "hex": "0x80140adc",
    "symbol": "XERO",
    "name": "Xerom",
    "link": "https://www.xerom.org"
  },
  "1712144": {
    "index": "1712144",
    "hex": "0x801a2010",
    "symbol": "LAX",
    "name": "LAPO",
    "link": "https://lapo.io"
  },
  "3924011": {
    "index": "3924011",
    "hex": "0x803be02b",
    "symbol": "EPK",
    "name": "EPIK Protocol",
    "link": "https://www.epik-protocol.io"
  },
  "4741444": {
    "index": "4741444",
    "hex": "0x80485944",
    "symbol": "HYD",
    "name": "Hydra Token",
    "link": "https://iop.global/hydra-token"
  },
  "5249353": {
    "index": "5249353",
    "hex": "0x80501949",
    "symbol": "BCO",
    "name": "BitcoinOre",
    "link": "http://bitcoinore.org"
  },
  "5249354": {
    "index": "5249354",
    "hex": "0x8050194a",
    "symbol": "BHD",
    "name": "BitcoinHD",
    "link": "https://btchd.org"
  },
  "5264462": {
    "index": "5264462",
    "hex": "0x8050544e",
    "symbol": "PTN",
    "name": "PalletOne",
    "link": "https://pallet.one"
  },
  "5718350": {
    "index": "5718350",
    "hex": "0x8057414e",
    "symbol": "WAN",
    "name": "Wanchain",
    "link": "https://wanchain.org"
  },
  "5741564": {
    "index": "5741564",
    "hex": "0x80579bfc",
    "symbol": "WAVES",
    "name": "Waves",
    "link": "https://wavesplatform.com"
  },
  "6517357": {
    "index": "6517357",
    "hex": "0x8063726d",
    "symbol": "CRM",
    "name": "Creamcoin",
    "link": "https://explorer.creamcoin.com/"
  },
  "7562605": {
    "index": "7562605",
    "hex": "0x8073656d",
    "symbol": "SEM",
    "name": "Semux",
    "link": "https://semux.org"
  },
  "7567736": {
    "index": "7567736",
    "hex": "0x80737978",
    "symbol": "ION",
    "name": "ION",
    "link": "https://ionomy.com"
  },
  "7777777": {
    "index": "7777777",
    "hex": "0x8076adf1",
    "symbol": "FCT",
    "name": "FirmaChain",
    "link": "https://www.firmachain.org"
  },
  "7825266": {
    "index": "7825266",
    "hex": "0x80776772",
    "symbol": "WGR",
    "name": "WGR",
    "link": "https://wagerr.com"
  },
  "7825267": {
    "index": "7825267",
    "hex": "0x80776773",
    "symbol": "OBSR",
    "name": "OBServer",
    "link": "https://obsr.org"
  },
  "8163271": {
    "index": "8163271",
    "hex": "0x807c8fc7",
    "symbol": "AFS",
    "name": "ANFS",
    "link": "https://www.anfs.network"
  },
  "15118976": {
    "index": "15118976",
    "hex": "0x80e6b280",
    "symbol": "XDS",
    "name": "XDS",
    "link": "https://github.com/xds-decentralised"
  },
  "61717561": {
    "index": "61717561",
    "hex": "0x83adbc39",
    "symbol": "AQUA",
    "name": "Aquachain",
    "link": "https://aquachain.github.io"
  },
  "88888888": {
    "index": "88888888",
    "hex": "0x854c5638",
    "symbol": "HATCH",
    "name": "Hatch",
    "link": "https://hatch.ga"
  },
  "91927009": {
    "index": "91927009",
    "hex": "0x857ab1e1",
    "symbol": "kUSD",
    "name": "kUSD",
    "link": "https://kowala.tech"
  },
  "99999996": {
    "index": "99999996",
    "hex": "0x85f5e0fc",
    "symbol": "GENS",
    "name": "GENS",
    "link": "https://genshiro.equilibrium.io"
  },
  "99999997": {
    "index": "99999997",
    "hex": "0x85f5e0fd",
    "symbol": "EQ",
    "name": "EQ",
    "link": "https://equilibrium.io"
  },
  "99999998": {
    "index": "99999998",
    "hex": "0x85f5e0fe",
    "symbol": "FLUID",
    "name": "Fluid Chains",
    "link": "https://www.fluidchains.com"
  },
  "99999999": {
    "index": "99999999",
    "hex": "0x85f5e0ff",
    "symbol": "QKC",
    "name": "QuarkChain",
    "link": "https://www.quarkchain.io"
  },
  "608589380": {
    "index": "608589380",
    "hex": "0xa4465644",
    "symbol": "FVDC",
    "name": "ForumCoin",
    "link": "https://fvd.nl"
  }
}

      };
    };
  }
}, {package:"@metamask\\slip44",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\slip44\\slip44.json",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\alerts.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\shared\constants\alerts.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WEB3_SHIM_USAGE_ALERT_STATES = exports.TOGGLEABLE_ALERT_TYPES = exports.ALERT_TYPES = void 0;
const ALERT_TYPES = {
  unconnectedAccount: 'unconnectedAccount',
  web3ShimUsage: 'web3ShimUsage',
  invalidCustomNetwork: 'invalidCustomNetwork'
};
/**
 * Alerts that can be enabled or disabled by the user.
 */

exports.ALERT_TYPES = ALERT_TYPES;
const TOGGLEABLE_ALERT_TYPES = [ALERT_TYPES.unconnectedAccount, ALERT_TYPES.web3ShimUsage];
exports.TOGGLEABLE_ALERT_TYPES = TOGGLEABLE_ALERT_TYPES;
const WEB3_SHIM_USAGE_ALERT_STATES = {
  RECORDED: 1,
  DISMISSED: 2
};
exports.WEB3_SHIM_USAGE_ALERT_STATES = WEB3_SHIM_USAGE_ALERT_STATES;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\alerts.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pubnub\\dist\\web\\pubnub.min.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\pubnub\dist\web\pubnub.min.js
      return function (require, module, exports) {
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.PubNub=t():e.PubNub=t()}(window,function(){return r={},i.m=n=[function(e,t,n){"use strict";e.exports={}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;t.default={PNTimeOperation:"PNTimeOperation",PNHistoryOperation:"PNHistoryOperation",PNDeleteMessagesOperation:"PNDeleteMessagesOperation",PNFetchMessagesOperation:"PNFetchMessagesOperation",PNMessageCounts:"PNMessageCountsOperation",PNSubscribeOperation:"PNSubscribeOperation",PNUnsubscribeOperation:"PNUnsubscribeOperation",PNPublishOperation:"PNPublishOperation",PNSignalOperation:"PNSignalOperation",PNAddMessageActionOperation:"PNAddActionOperation",PNRemoveMessageActionOperation:"PNRemoveMessageActionOperation",PNGetMessageActionsOperation:"PNGetMessageActionsOperation",PNCreateUserOperation:"PNCreateUserOperation",PNUpdateUserOperation:"PNUpdateUserOperation",PNDeleteUserOperation:"PNDeleteUserOperation",PNGetUserOperation:"PNGetUsersOperation",PNGetUsersOperation:"PNGetUsersOperation",PNCreateSpaceOperation:"PNCreateSpaceOperation",PNUpdateSpaceOperation:"PNUpdateSpaceOperation",PNDeleteSpaceOperation:"PNDeleteSpaceOperation",PNGetSpaceOperation:"PNGetSpacesOperation",PNGetSpacesOperation:"PNGetSpacesOperation",PNGetMembersOperation:"PNGetMembersOperation",PNUpdateMembersOperation:"PNUpdateMembersOperation",PNGetMembershipsOperation:"PNGetMembershipsOperation",PNUpdateMembershipsOperation:"PNUpdateMembershipsOperation",PNPushNotificationEnabledChannelsOperation:"PNPushNotificationEnabledChannelsOperation",PNRemoveAllPushNotificationsOperation:"PNRemoveAllPushNotificationsOperation",PNWhereNowOperation:"PNWhereNowOperation",PNSetStateOperation:"PNSetStateOperation",PNHereNowOperation:"PNHereNowOperation",PNGetStateOperation:"PNGetStateOperation",PNHeartbeatOperation:"PNHeartbeatOperation",PNChannelGroupsOperation:"PNChannelGroupsOperation",PNRemoveGroupOperation:"PNRemoveGroupOperation",PNChannelsForGroupOperation:"PNChannelsForGroupOperation",PNAddChannelsToGroupOperation:"PNAddChannelsToGroupOperation",PNRemoveChannelsFromGroupOperation:"PNRemoveChannelsFromGroupOperation",PNAccessManagerGrant:"PNAccessManagerGrant",PNAccessManagerGrantToken:"PNAccessManagerGrantToken",PNAccessManagerAudit:"PNAccessManagerAudit"},e.exports=t.default},function(e,t,n){"use strict";function r(e){return encodeURIComponent(e).replace(/[!~*'()]/g,function(e){return"%".concat(e.charCodeAt(0).toString(16).toUpperCase())})}function i(e){return function(e){var t=[];return Object.keys(e).forEach(function(e){return t.push(e)}),t}(e).sort()}e.exports={signPamFromParams:function(t){return i(t).map(function(e){return"".concat(e,"=").concat(r(t[e]))}).join("&")},endsWith:function(e,t){return-1!==e.indexOf(t,this.length-t.length)},createPromise:function(){var n,r;return{promise:new Promise(function(e,t){n=e,r=t}),reject:r,fulfill:n}},encodeString:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var r,i=(r=n(5))&&r.__esModule?r:{default:r};n(0);function o(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var a,u,c,f=(a=l,(u=[{key:"getAuthKey",value:function(){return this.authKey}},{key:"setAuthKey",value:function(e){return this.authKey=e,this}},{key:"setCipherKey",value:function(e){return this.cipherKey=e,this}},{key:"getUUID",value:function(){return this.UUID}},{key:"setUUID",value:function(e){return this._db&&this._db.set&&this._db.set("".concat(this.subscribeKey,"uuid"),e),this.UUID=e,this}},{key:"getFilterExpression",value:function(){return this.filterExpression}},{key:"setFilterExpression",value:function(e){return this.filterExpression=e,this}},{key:"getPresenceTimeout",value:function(){return this._presenceTimeout}},{key:"setPresenceTimeout",value:function(e){return 20<=e?this._presenceTimeout=e:(this._presenceTimeout=20,console.log("WARNING: Presence timeout is less than the minimum. Using minimum value: ",this._presenceTimeout)),this.setHeartbeatInterval(this._presenceTimeout/2-1),this}},{key:"setProxy",value:function(e){this.proxy=e}},{key:"getHeartbeatInterval",value:function(){return this._heartbeatInterval}},{key:"setHeartbeatInterval",value:function(e){return this._heartbeatInterval=e,this}},{key:"getSubscribeTimeout",value:function(){return this._subscribeRequestTimeout}},{key:"setSubscribeTimeout",value:function(e){return this._subscribeRequestTimeout=e,this}},{key:"getTransactionTimeout",value:function(){return this._transactionalRequestTimeout}},{key:"setTransactionTimeout",value:function(e){return this._transactionalRequestTimeout=e,this}},{key:"isSendBeaconEnabled",value:function(){return this._useSendBeacon}},{key:"setSendBeaconConfig",value:function(e){return this._useSendBeacon=e,this}},{key:"getVersion",value:function(){return"4.27.3"}},{key:"_addPnsdkSuffix",value:function(e,t){this._PNSDKSuffix[e]=t}},{key:"_getPnsdkSuffix",value:function(n){var r=this;return Object.keys(this._PNSDKSuffix).reduce(function(e,t){return e+n+r._PNSDKSuffix[t]},"")}},{key:"_decideUUID",value:function(e){return e||(this._db&&this._db.get&&this._db.get("".concat(this.subscribeKey,"uuid"))?this._db.get("".concat(this.subscribeKey,"uuid")):"pn-".concat(i.default.createUUID()))}}])&&o(a.prototype,u),void(c&&o(a,c)),l);function l(e){var t=e.setup,n=e.db;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,l),s(this,"_db",void 0),s(this,"subscribeKey",void 0),s(this,"publishKey",void 0),s(this,"secretKey",void 0),s(this,"cipherKey",void 0),s(this,"authKey",void 0),s(this,"UUID",void 0),s(this,"proxy",void 0),s(this,"instanceId",void 0),s(this,"sdkName",void 0),s(this,"sdkFamily",void 0),s(this,"partnerId",void 0),s(this,"filterExpression",void 0),s(this,"suppressLeaveEvents",void 0),s(this,"secure",void 0),s(this,"origin",void 0),s(this,"logVerbosity",void 0),s(this,"useInstanceId",void 0),s(this,"useRequestId",void 0),s(this,"keepAlive",void 0),s(this,"keepAliveSettings",void 0),s(this,"autoNetworkDetection",void 0),s(this,"announceSuccessfulHeartbeats",void 0),s(this,"announceFailedHeartbeats",void 0),s(this,"_presenceTimeout",void 0),s(this,"_heartbeatInterval",void 0),s(this,"_subscribeRequestTimeout",void 0),s(this,"_transactionalRequestTimeout",void 0),s(this,"_useSendBeacon",void 0),s(this,"_PNSDKSuffix",void 0),s(this,"requestMessageCountThreshold",void 0),s(this,"restore",void 0),s(this,"dedupeOnSubscribe",void 0),s(this,"maximumCacheSize",void 0),s(this,"customEncrypt",void 0),s(this,"customDecrypt",void 0),this._PNSDKSuffix={},this._db=n,this.instanceId="pn-".concat(i.default.createUUID()),this.secretKey=t.secretKey||t.secret_key,this.subscribeKey=t.subscribeKey||t.subscribe_key,this.publishKey=t.publishKey||t.publish_key,this.sdkName=t.sdkName,this.sdkFamily=t.sdkFamily,this.partnerId=t.partnerId,this.setAuthKey(t.authKey),this.setCipherKey(t.cipherKey),this.setFilterExpression(t.filterExpression),this.origin=t.origin||"ps.pndsn.com",this.secure=t.ssl||!1,this.restore=t.restore||!1,this.proxy=t.proxy,this.keepAlive=t.keepAlive,this.keepAliveSettings=t.keepAliveSettings,this.autoNetworkDetection=t.autoNetworkDetection||!1,this.dedupeOnSubscribe=t.dedupeOnSubscribe||!1,this.maximumCacheSize=t.maximumCacheSize||100,this.customEncrypt=t.customEncrypt,this.customDecrypt=t.customDecrypt,"undefined"!=typeof location&&"https:"===location.protocol&&(this.secure=!0),this.logVerbosity=t.logVerbosity||!1,this.suppressLeaveEvents=t.suppressLeaveEvents||!1,this.announceFailedHeartbeats=t.announceFailedHeartbeats||!0,this.announceSuccessfulHeartbeats=t.announceSuccessfulHeartbeats||!1,this.useInstanceId=t.useInstanceId||!1,this.useRequestId=t.useRequestId||!1,this.requestMessageCountThreshold=t.requestMessageCountThreshold,this.setTransactionTimeout(t.transactionalRequestTimeout||15e3),this.setSubscribeTimeout(t.subscribeRequestTimeout||31e4),this.setSendBeaconConfig(t.useSendBeacon||!0),t.presenceTimeout?this.setPresenceTimeout(t.presenceTimeout):this._presenceTimeout=300,null!=t.heartbeatInterval&&this.setHeartbeatInterval(t.heartbeatInterval),this.setUUID(this._decideUUID(t.uuid))}t.default=f,e.exports=t.default},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;t.default={PNNetworkUpCategory:"PNNetworkUpCategory",PNNetworkDownCategory:"PNNetworkDownCategory",PNNetworkIssuesCategory:"PNNetworkIssuesCategory",PNTimeoutCategory:"PNTimeoutCategory",PNBadRequestCategory:"PNBadRequestCategory",PNAccessDeniedCategory:"PNAccessDeniedCategory",PNUnknownCategory:"PNUnknownCategory",PNReconnectedCategory:"PNReconnectedCategory",PNConnectedCategory:"PNConnectedCategory",PNRequestMessageCountExceededCategory:"PNRequestMessageCountExceededCategory"},e.exports=t.default},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var r,i=(r=n(13))&&r.__esModule?r:{default:r};var o={createUUID:function(){return i.default.uuid?i.default.uuid():(0,i.default)()}};t.default=o,e.exports=t.default},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;r(n(3));var u=r(n(14));function r(e){return e&&e.__esModule?e:{default:e}}function i(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var s,a,c,f=(s=l,(a=[{key:"HMACSHA256",value:function(e){return u.default.HmacSHA256(e,this._config.secretKey).toString(u.default.enc.Base64)}},{key:"SHA256",value:function(e){return u.default.SHA256(e).toString(u.default.enc.Hex)}},{key:"_parseOptions",value:function(e){var t=e||{};return t.hasOwnProperty("encryptKey")||(t.encryptKey=this._defaultOptions.encryptKey),t.hasOwnProperty("keyEncoding")||(t.keyEncoding=this._defaultOptions.keyEncoding),t.hasOwnProperty("keyLength")||(t.keyLength=this._defaultOptions.keyLength),t.hasOwnProperty("mode")||(t.mode=this._defaultOptions.mode),-1===this._allowedKeyEncodings.indexOf(t.keyEncoding.toLowerCase())&&(t.keyEncoding=this._defaultOptions.keyEncoding),-1===this._allowedKeyLengths.indexOf(parseInt(t.keyLength,10))&&(t.keyLength=this._defaultOptions.keyLength),-1===this._allowedModes.indexOf(t.mode.toLowerCase())&&(t.mode=this._defaultOptions.mode),t}},{key:"_decodeKey",value:function(e,t){return"base64"===t.keyEncoding?u.default.enc.Base64.parse(e):"hex"===t.keyEncoding?u.default.enc.Hex.parse(e):e}},{key:"_getPaddedKey",value:function(e,t){return e=this._decodeKey(e,t),t.encryptKey?u.default.enc.Utf8.parse(this.SHA256(e).slice(0,32)):e}},{key:"_getMode",value:function(e){return"ecb"===e.mode?u.default.mode.ECB:u.default.mode.CBC}},{key:"_getIV",value:function(e){return"cbc"===e.mode?u.default.enc.Utf8.parse(this._iv):null}},{key:"encrypt",value:function(e,t,n){return this._config.customEncrypt?this._config.customEncrypt(e):this.pnEncrypt(e,t,n)}},{key:"decrypt",value:function(e,t,n){return this._config.customDecrypt?this._config.customDecrypt(e):this.pnDecrypt(e,t,n)}},{key:"pnEncrypt",value:function(e,t,n){if(!t&&!this._config.cipherKey)return e;n=this._parseOptions(n);var r=this._getIV(n),i=this._getMode(n),o=this._getPaddedKey(t||this._config.cipherKey,n);return u.default.AES.encrypt(e,o,{iv:r,mode:i}).ciphertext.toString(u.default.enc.Base64)||e}},{key:"pnDecrypt",value:function(e,t,n){if(!t&&!this._config.cipherKey)return e;n=this._parseOptions(n);var r=this._getIV(n),i=this._getMode(n),o=this._getPaddedKey(t||this._config.cipherKey,n);try{var s=u.default.enc.Base64.parse(e),a=u.default.AES.decrypt({ciphertext:s},o,{iv:r,mode:i}).toString(u.default.enc.Utf8);return JSON.parse(a)}catch(e){return null}}}])&&i(s.prototype,a),void(c&&i(s,c)),l);function l(e){var t=e.config;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,l),o(this,"_config",void 0),o(this,"_iv",void 0),o(this,"_allowedKeyEncodings",void 0),o(this,"_allowedKeyLengths",void 0),o(this,"_allowedModes",void 0),o(this,"_defaultOptions",void 0),this._config=t,this._iv="0123456789012345",this._allowedKeyEncodings=["hex","utf8","base64","binary"],this._allowedKeyLengths=[128,256],this._allowedModes=["ecb","cbc"],this._defaultOptions={encryptKey:!0,keyEncoding:"utf8",keyLength:256,mode:"cbc"}}t.default=f,e.exports=t.default},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;n(0);var r,i=(r=n(4))&&r.__esModule?r:{default:r};function o(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var s,a,u,c=(s=f,(a=[{key:"addListener",value:function(e){this._listeners.push(e)}},{key:"removeListener",value:function(t){var n=[];this._listeners.forEach(function(e){e!==t&&n.push(e)}),this._listeners=n}},{key:"removeAllListeners",value:function(){this._listeners=[]}},{key:"announcePresence",value:function(t){this._listeners.forEach(function(e){e.presence&&e.presence(t)})}},{key:"announceStatus",value:function(t){this._listeners.forEach(function(e){e.status&&e.status(t)})}},{key:"announceMessage",value:function(t){this._listeners.forEach(function(e){e.message&&e.message(t)})}},{key:"announceSignal",value:function(t){this._listeners.forEach(function(e){e.signal&&e.signal(t)})}},{key:"announceMessageAction",value:function(t){this._listeners.forEach(function(e){e.messageAction&&e.messageAction(t)})}},{key:"announceUser",value:function(t){this._listeners.forEach(function(e){e.user&&e.user(t)})}},{key:"announceSpace",value:function(t){this._listeners.forEach(function(e){e.space&&e.space(t)})}},{key:"announceMembership",value:function(t){this._listeners.forEach(function(e){e.membership&&e.membership(t)})}},{key:"announceNetworkUp",value:function(){var e={};e.category=i.default.PNNetworkUpCategory,this.announceStatus(e)}},{key:"announceNetworkDown",value:function(){var e={};e.category=i.default.PNNetworkDownCategory,this.announceStatus(e)}}])&&o(s.prototype,a),void(u&&o(s,u)),f);function f(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,f),function(e,t,n){t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n}(this,"_listeners",void 0),this._listeners=[]}t.default=c,e.exports=t.default},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNTimeOperation},t.getURL=function(){return"/time/0"},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.prepareParams=function(){return{}},t.isAuthSupported=function(){return!1},t.handleResponse=function(e,t){return{timetoken:t[0]}},t.validateParams=function(){};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,I,D){"use strict";(function(e){var r=D(71),o=D(72),s=D(73);function n(){return l.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function a(e,t){if(n()<t)throw new RangeError("Invalid typed array length");return l.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(t)).__proto__=l.prototype:(null===e&&(e=new l(t)),e.length=t),e}function l(e,t,n){if(!(l.TYPED_ARRAY_SUPPORT||this instanceof l))return new l(e,t,n);if("number"!=typeof e)return i(this,e,t,n);if("string"==typeof t)throw new Error("If encoding is specified then the first argument must be a string");return c(this,e)}function i(e,t,n,r){if("number"==typeof t)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer?function(e,t,n,r){if(t.byteLength,n<0||t.byteLength<n)throw new RangeError("'offset' is out of bounds");if(t.byteLength<n+(r||0))throw new RangeError("'length' is out of bounds");t=void 0===n&&void 0===r?new Uint8Array(t):void 0===r?new Uint8Array(t,n):new Uint8Array(t,n,r);l.TYPED_ARRAY_SUPPORT?(e=t).__proto__=l.prototype:e=f(e,t);return e}(e,t,n,r):"string"==typeof t?function(e,t,n){"string"==typeof n&&""!==n||(n="utf8");if(!l.isEncoding(n))throw new TypeError('"encoding" must be a valid string encoding');var r=0|p(t,n),i=(e=a(e,r)).write(t,n);i!==r&&(e=e.slice(0,i));return e}(e,t,n):function(e,t){if(l.isBuffer(t)){var n=0|h(t.length);return 0===(e=a(e,n)).length||t.copy(e,0,0,n),e}if(t){if("undefined"!=typeof ArrayBuffer&&t.buffer instanceof ArrayBuffer||"length"in t)return"number"!=typeof t.length||function(e){return e!=e}(t.length)?a(e,0):f(e,t);if("Buffer"===t.type&&s(t.data))return f(e,t.data)}throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(e,t)}function u(e){if("number"!=typeof e)throw new TypeError('"size" argument must be a number');if(e<0)throw new RangeError('"size" argument must not be negative')}function c(e,t){if(u(t),e=a(e,t<0?0:0|h(t)),!l.TYPED_ARRAY_SUPPORT)for(var n=0;n<t;++n)e[n]=0;return e}function f(e,t){var n=t.length<0?0:0|h(t.length);e=a(e,n);for(var r=0;r<n;r+=1)e[r]=255&t[r];return e}function h(e){if(e>=n())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+n().toString(16)+" bytes");return 0|e}function p(e,t){if(l.isBuffer(e))return e.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;"string"!=typeof e&&(e=""+e);var n=e.length;if(0===n)return 0;for(var r=!1;;)switch(t){case"ascii":case"latin1":case"binary":return n;case"utf8":case"utf-8":case void 0:return x(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*n;case"hex":return n>>>1;case"base64":return U(e).length;default:if(r)return x(e).length;t=(""+t).toLowerCase(),r=!0}}function d(e,t,n){var r=e[t];e[t]=e[n],e[n]=r}function g(e,t,n,r,i){if(0===e.length)return-1;if("string"==typeof n?(r=n,n=0):2147483647<n?n=2147483647:n<-2147483648&&(n=-2147483648),n=+n,isNaN(n)&&(n=i?0:e.length-1),n<0&&(n=e.length+n),n>=e.length){if(i)return-1;n=e.length-1}else if(n<0){if(!i)return-1;n=0}if("string"==typeof t&&(t=l.from(t,r)),l.isBuffer(t))return 0===t.length?-1:y(e,t,n,r,i);if("number"==typeof t)return t&=255,l.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(e,t,n):Uint8Array.prototype.lastIndexOf.call(e,t,n):y(e,[t],n,r,i);throw new TypeError("val must be string, number or Buffer")}function y(e,t,n,r,i){var o,s=1,a=e.length,u=t.length;if(void 0!==r&&("ucs2"===(r=String(r).toLowerCase())||"ucs-2"===r||"utf16le"===r||"utf-16le"===r)){if(e.length<2||t.length<2)return-1;a/=s=2,u/=2,n/=2}function c(e,t){return 1===s?e[t]:e.readUInt16BE(t*s)}if(i){var f=-1;for(o=n;o<a;o++)if(c(e,o)===c(t,-1===f?0:o-f)){if(-1===f&&(f=o),o-f+1===u)return f*s}else-1!==f&&(o-=o-f),f=-1}else for(a<n+u&&(n=a-u),o=n;0<=o;o--){for(var l=!0,h=0;h<u;h++)if(c(e,o+h)!==c(t,h)){l=!1;break}if(l)return o}return-1}function v(e,t,n,r){n=Number(n)||0;var i=e.length-n;r?i<(r=Number(r))&&(r=i):r=i;var o=t.length;if(o%2!=0)throw new TypeError("Invalid hex string");o/2<r&&(r=o/2);for(var s=0;s<r;++s){var a=parseInt(t.substr(2*s,2),16);if(isNaN(a))return s;e[n+s]=a}return s}function b(e,t,n,r){return B(function(e){for(var t=[],n=0;n<e.length;++n)t.push(255&e.charCodeAt(n));return t}(t),e,n,r)}function m(e,t,n){return 0===t&&n===e.length?r.fromByteArray(e):r.fromByteArray(e.slice(t,n))}function _(e,t,n){n=Math.min(e.length,n);for(var r=[],i=t;i<n;){var o,s,a,u,c=e[i],f=null,l=239<c?4:223<c?3:191<c?2:1;if(i+l<=n)switch(l){case 1:c<128&&(f=c);break;case 2:128==(192&(o=e[i+1]))&&127<(u=(31&c)<<6|63&o)&&(f=u);break;case 3:o=e[i+1],s=e[i+2],128==(192&o)&&128==(192&s)&&2047<(u=(15&c)<<12|(63&o)<<6|63&s)&&(u<55296||57343<u)&&(f=u);break;case 4:o=e[i+1],s=e[i+2],a=e[i+3],128==(192&o)&&128==(192&s)&&128==(192&a)&&65535<(u=(15&c)<<18|(63&o)<<12|(63&s)<<6|63&a)&&u<1114112&&(f=u)}null===f?(f=65533,l=1):65535<f&&(f-=65536,r.push(f>>>10&1023|55296),f=56320|1023&f),r.push(f),i+=l}return function(e){var t=e.length;if(t<=k)return String.fromCharCode.apply(String,e);var n="",r=0;for(;r<t;)n+=String.fromCharCode.apply(String,e.slice(r,r+=k));return n}(r)}I.Buffer=l,I.SlowBuffer=function(e){+e!=e&&(e=0);return l.alloc(+e)},I.INSPECT_MAX_BYTES=50,l.TYPED_ARRAY_SUPPORT=void 0!==e.TYPED_ARRAY_SUPPORT?e.TYPED_ARRAY_SUPPORT:function(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()&&"function"==typeof e.subarray&&0===e.subarray(1,1).byteLength}catch(e){return!1}}(),I.kMaxLength=n(),l.poolSize=8192,l._augment=function(e){return e.__proto__=l.prototype,e},l.from=function(e,t,n){return i(null,e,t,n)},l.TYPED_ARRAY_SUPPORT&&(l.prototype.__proto__=Uint8Array.prototype,l.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&l[Symbol.species]===l&&Object.defineProperty(l,Symbol.species,{value:null,configurable:!0})),l.alloc=function(e,t,n){return function(e,t,n,r){return u(t),t<=0?a(e,t):void 0!==n?"string"==typeof r?a(e,t).fill(n,r):a(e,t).fill(n):a(e,t)}(null,e,t,n)},l.allocUnsafe=function(e){return c(null,e)},l.allocUnsafeSlow=function(e){return c(null,e)},l.isBuffer=function(e){return!(null==e||!e._isBuffer)},l.compare=function(e,t){if(!l.isBuffer(e)||!l.isBuffer(t))throw new TypeError("Arguments must be Buffers");if(e===t)return 0;for(var n=e.length,r=t.length,i=0,o=Math.min(n,r);i<o;++i)if(e[i]!==t[i]){n=e[i],r=t[i];break}return n<r?-1:r<n?1:0},l.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},l.concat=function(e,t){if(!s(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return l.alloc(0);var n;if(void 0===t)for(n=t=0;n<e.length;++n)t+=e[n].length;var r=l.allocUnsafe(t),i=0;for(n=0;n<e.length;++n){var o=e[n];if(!l.isBuffer(o))throw new TypeError('"list" argument must be an Array of Buffers');o.copy(r,i),i+=o.length}return r},l.byteLength=p,l.prototype._isBuffer=!0,l.prototype.swap16=function(){var e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;t<e;t+=2)d(this,t,t+1);return this},l.prototype.swap32=function(){var e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;t<e;t+=4)d(this,t,t+3),d(this,t+1,t+2);return this},l.prototype.swap64=function(){var e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;t<e;t+=8)d(this,t,t+7),d(this,t+1,t+6),d(this,t+2,t+5),d(this,t+3,t+4);return this},l.prototype.toString=function(){var e=0|this.length;return 0==e?"":0===arguments.length?_(this,0,e):function(e,t,n){var r=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===n||n>this.length)&&(n=this.length),n<=0)return"";if((n>>>=0)<=(t>>>=0))return"";for(e=e||"utf8";;)switch(e){case"hex":return T(this,t,n);case"utf8":case"utf-8":return _(this,t,n);case"ascii":return P(this,t,n);case"latin1":case"binary":return w(this,t,n);case"base64":return m(this,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return O(this,t,n);default:if(r)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),r=!0}}.apply(this,arguments)},l.prototype.equals=function(e){if(!l.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===l.compare(this,e)},l.prototype.inspect=function(){var e="",t=I.INSPECT_MAX_BYTES;return 0<this.length&&(e=this.toString("hex",0,t).match(/.{2}/g).join(" "),this.length>t&&(e+=" ... ")),"<Buffer "+e+">"},l.prototype.compare=function(e,t,n,r,i){if(!l.isBuffer(e))throw new TypeError("Argument must be a Buffer");if(void 0===t&&(t=0),void 0===n&&(n=e?e.length:0),void 0===r&&(r=0),void 0===i&&(i=this.length),t<0||n>e.length||r<0||i>this.length)throw new RangeError("out of range index");if(i<=r&&n<=t)return 0;if(i<=r)return-1;if(n<=t)return 1;if(this===e)return 0;for(var o=(i>>>=0)-(r>>>=0),s=(n>>>=0)-(t>>>=0),a=Math.min(o,s),u=this.slice(r,i),c=e.slice(t,n),f=0;f<a;++f)if(u[f]!==c[f]){o=u[f],s=c[f];break}return o<s?-1:s<o?1:0},l.prototype.includes=function(e,t,n){return-1!==this.indexOf(e,t,n)},l.prototype.indexOf=function(e,t,n){return g(this,e,t,n,!0)},l.prototype.lastIndexOf=function(e,t,n){return g(this,e,t,n,!1)},l.prototype.write=function(e,t,n,r){if(void 0===t)r="utf8",n=this.length,t=0;else if(void 0===n&&"string"==typeof t)r=t,n=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t|=0,isFinite(n)?(n|=0,void 0===r&&(r="utf8")):(r=n,n=void 0)}var i=this.length-t;if((void 0===n||i<n)&&(n=i),0<e.length&&(n<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");r=r||"utf8";for(var o,s,a,u,c,f,l,h,p,d=!1;;)switch(r){case"hex":return v(this,e,t,n);case"utf8":case"utf-8":return h=t,p=n,B(x(e,(l=this).length-h),l,h,p);case"ascii":return b(this,e,t,n);case"latin1":case"binary":return b(this,e,t,n);case"base64":return u=this,c=t,f=n,B(U(e),u,c,f);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return s=t,a=n,B(function(e,t){for(var n,r,i,o=[],s=0;s<e.length&&!((t-=2)<0);++s)n=e.charCodeAt(s),r=n>>8,i=n%256,o.push(i),o.push(r);return o}(e,(o=this).length-s),o,s,a);default:if(d)throw new TypeError("Unknown encoding: "+r);r=(""+r).toLowerCase(),d=!0}},l.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var k=4096;function P(e,t,n){var r="";n=Math.min(e.length,n);for(var i=t;i<n;++i)r+=String.fromCharCode(127&e[i]);return r}function w(e,t,n){var r="";n=Math.min(e.length,n);for(var i=t;i<n;++i)r+=String.fromCharCode(e[i]);return r}function T(e,t,n){var r=e.length;(!t||t<0)&&(t=0),(!n||n<0||r<n)&&(n=r);for(var i="",o=t;o<n;++o)i+=N(e[o]);return i}function O(e,t,n){for(var r=e.slice(t,n),i="",o=0;o<r.length;o+=2)i+=String.fromCharCode(r[o]+256*r[o+1]);return i}function S(e,t,n){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(n<e+t)throw new RangeError("Trying to access beyond buffer length")}function M(e,t,n,r,i,o){if(!l.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(i<t||t<o)throw new RangeError('"value" argument is out of bounds');if(n+r>e.length)throw new RangeError("Index out of range")}function E(e,t,n,r){t<0&&(t=65535+t+1);for(var i=0,o=Math.min(e.length-n,2);i<o;++i)e[n+i]=(t&255<<8*(r?i:1-i))>>>8*(r?i:1-i)}function A(e,t,n,r){t<0&&(t=4294967295+t+1);for(var i=0,o=Math.min(e.length-n,4);i<o;++i)e[n+i]=t>>>8*(r?i:3-i)&255}function C(e,t,n,r){if(n+r>e.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("Index out of range")}function R(e,t,n,r,i){return i||C(e,0,n,4),o.write(e,t,n,r,23,4),n+4}function j(e,t,n,r,i){return i||C(e,0,n,8),o.write(e,t,n,r,52,8),n+8}l.prototype.slice=function(e,t){var n,r=this.length;if((e=~~e)<0?(e+=r)<0&&(e=0):r<e&&(e=r),(t=void 0===t?r:~~t)<0?(t+=r)<0&&(t=0):r<t&&(t=r),t<e&&(t=e),l.TYPED_ARRAY_SUPPORT)(n=this.subarray(e,t)).__proto__=l.prototype;else{var i=t-e;n=new l(i,void 0);for(var o=0;o<i;++o)n[o]=this[o+e]}return n},l.prototype.readUIntLE=function(e,t,n){e|=0,t|=0,n||S(e,t,this.length);for(var r=this[e],i=1,o=0;++o<t&&(i*=256);)r+=this[e+o]*i;return r},l.prototype.readUIntBE=function(e,t,n){e|=0,t|=0,n||S(e,t,this.length);for(var r=this[e+--t],i=1;0<t&&(i*=256);)r+=this[e+--t]*i;return r},l.prototype.readUInt8=function(e,t){return t||S(e,1,this.length),this[e]},l.prototype.readUInt16LE=function(e,t){return t||S(e,2,this.length),this[e]|this[e+1]<<8},l.prototype.readUInt16BE=function(e,t){return t||S(e,2,this.length),this[e]<<8|this[e+1]},l.prototype.readUInt32LE=function(e,t){return t||S(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},l.prototype.readUInt32BE=function(e,t){return t||S(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},l.prototype.readIntLE=function(e,t,n){e|=0,t|=0,n||S(e,t,this.length);for(var r=this[e],i=1,o=0;++o<t&&(i*=256);)r+=this[e+o]*i;return(i*=128)<=r&&(r-=Math.pow(2,8*t)),r},l.prototype.readIntBE=function(e,t,n){e|=0,t|=0,n||S(e,t,this.length);for(var r=t,i=1,o=this[e+--r];0<r&&(i*=256);)o+=this[e+--r]*i;return(i*=128)<=o&&(o-=Math.pow(2,8*t)),o},l.prototype.readInt8=function(e,t){return t||S(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},l.prototype.readInt16LE=function(e,t){t||S(e,2,this.length);var n=this[e]|this[e+1]<<8;return 32768&n?4294901760|n:n},l.prototype.readInt16BE=function(e,t){t||S(e,2,this.length);var n=this[e+1]|this[e]<<8;return 32768&n?4294901760|n:n},l.prototype.readInt32LE=function(e,t){return t||S(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},l.prototype.readInt32BE=function(e,t){return t||S(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},l.prototype.readFloatLE=function(e,t){return t||S(e,4,this.length),o.read(this,e,!0,23,4)},l.prototype.readFloatBE=function(e,t){return t||S(e,4,this.length),o.read(this,e,!1,23,4)},l.prototype.readDoubleLE=function(e,t){return t||S(e,8,this.length),o.read(this,e,!0,52,8)},l.prototype.readDoubleBE=function(e,t){return t||S(e,8,this.length),o.read(this,e,!1,52,8)},l.prototype.writeUIntLE=function(e,t,n,r){e=+e,t|=0,n|=0,r||M(this,e,t,n,Math.pow(2,8*n)-1,0);var i=1,o=0;for(this[t]=255&e;++o<n&&(i*=256);)this[t+o]=e/i&255;return t+n},l.prototype.writeUIntBE=function(e,t,n,r){e=+e,t|=0,n|=0,r||M(this,e,t,n,Math.pow(2,8*n)-1,0);var i=n-1,o=1;for(this[t+i]=255&e;0<=--i&&(o*=256);)this[t+i]=e/o&255;return t+n},l.prototype.writeUInt8=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,1,255,0),l.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[t]=255&e,t+1},l.prototype.writeUInt16LE=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,2,65535,0),l.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):E(this,e,t,!0),t+2},l.prototype.writeUInt16BE=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,2,65535,0),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):E(this,e,t,!1),t+2},l.prototype.writeUInt32LE=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,4,4294967295,0),l.TYPED_ARRAY_SUPPORT?(this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e):A(this,e,t,!0),t+4},l.prototype.writeUInt32BE=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,4,4294967295,0),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):A(this,e,t,!1),t+4},l.prototype.writeIntLE=function(e,t,n,r){if(e=+e,t|=0,!r){var i=Math.pow(2,8*n-1);M(this,e,t,n,i-1,-i)}var o=0,s=1,a=0;for(this[t]=255&e;++o<n&&(s*=256);)e<0&&0===a&&0!==this[t+o-1]&&(a=1),this[t+o]=(e/s>>0)-a&255;return t+n},l.prototype.writeIntBE=function(e,t,n,r){if(e=+e,t|=0,!r){var i=Math.pow(2,8*n-1);M(this,e,t,n,i-1,-i)}var o=n-1,s=1,a=0;for(this[t+o]=255&e;0<=--o&&(s*=256);)e<0&&0===a&&0!==this[t+o+1]&&(a=1),this[t+o]=(e/s>>0)-a&255;return t+n},l.prototype.writeInt8=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,1,127,-128),l.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),e<0&&(e=255+e+1),this[t]=255&e,t+1},l.prototype.writeInt16LE=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,2,32767,-32768),l.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):E(this,e,t,!0),t+2},l.prototype.writeInt16BE=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,2,32767,-32768),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):E(this,e,t,!1),t+2},l.prototype.writeInt32LE=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,4,2147483647,-2147483648),l.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24):A(this,e,t,!0),t+4},l.prototype.writeInt32BE=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):A(this,e,t,!1),t+4},l.prototype.writeFloatLE=function(e,t,n){return R(this,e,t,!0,n)},l.prototype.writeFloatBE=function(e,t,n){return R(this,e,t,!1,n)},l.prototype.writeDoubleLE=function(e,t,n){return j(this,e,t,!0,n)},l.prototype.writeDoubleBE=function(e,t,n){return j(this,e,t,!1,n)},l.prototype.copy=function(e,t,n,r){if(n=n||0,r||0===r||(r=this.length),t>=e.length&&(t=e.length),t=t||0,0<r&&r<n&&(r=n),r===n)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(n<0||n>=this.length)throw new RangeError("sourceStart out of bounds");if(r<0)throw new RangeError("sourceEnd out of bounds");r>this.length&&(r=this.length),e.length-t<r-n&&(r=e.length-t+n);var i,o=r-n;if(this===e&&n<t&&t<r)for(i=o-1;0<=i;--i)e[i+t]=this[i+n];else if(o<1e3||!l.TYPED_ARRAY_SUPPORT)for(i=0;i<o;++i)e[i+t]=this[i+n];else Uint8Array.prototype.set.call(e,this.subarray(n,n+o),t);return o},l.prototype.fill=function(e,t,n,r){if("string"==typeof e){if("string"==typeof t?(r=t,t=0,n=this.length):"string"==typeof n&&(r=n,n=this.length),1===e.length){var i=e.charCodeAt(0);i<256&&(e=i)}if(void 0!==r&&"string"!=typeof r)throw new TypeError("encoding must be a string");if("string"==typeof r&&!l.isEncoding(r))throw new TypeError("Unknown encoding: "+r)}else"number"==typeof e&&(e&=255);if(t<0||this.length<t||this.length<n)throw new RangeError("Out of range index");if(n<=t)return this;var o;if(t>>>=0,n=void 0===n?this.length:n>>>0,"number"==typeof(e=e||0))for(o=t;o<n;++o)this[o]=e;else{var s=l.isBuffer(e)?e:x(new l(e,r).toString()),a=s.length;for(o=0;o<n-t;++o)this[o+t]=s[o%a]}return this};var t=/[^+\/0-9A-Za-z-_]/g;function N(e){return e<16?"0"+e.toString(16):e.toString(16)}function x(e,t){var n;t=t||1/0;for(var r=e.length,i=null,o=[],s=0;s<r;++s){if(55295<(n=e.charCodeAt(s))&&n<57344){if(!i){if(56319<n){-1<(t-=3)&&o.push(239,191,189);continue}if(s+1===r){-1<(t-=3)&&o.push(239,191,189);continue}i=n;continue}if(n<56320){-1<(t-=3)&&o.push(239,191,189),i=n;continue}n=65536+(i-55296<<10|n-56320)}else i&&-1<(t-=3)&&o.push(239,191,189);if(i=null,n<128){if((t-=1)<0)break;o.push(n)}else if(n<2048){if((t-=2)<0)break;o.push(n>>6|192,63&n|128)}else if(n<65536){if((t-=3)<0)break;o.push(n>>12|224,n>>6&63|128,63&n|128)}else{if(!(n<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;o.push(n>>18|240,n>>12&63|128,n>>6&63|128,63&n|128)}}return o}function U(e){return r.toByteArray(function(e){if((e=function(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}(e).replace(t,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function B(e,t,n,r){for(var i=0;i<r&&!(i+n>=t.length||i>=e.length);++i)t[i+n]=e[i];return i}}).call(this,D(70))},function(e,t,n){"use strict";e.exports=function(e){return null!==e&&"object"==typeof e}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var r=u(n(12)),i=u(n(67)),o=u(n(68)),s=u(n(69)),a=n(75);n(0);function u(e){return e&&e.__esModule?e:{default:e}}function c(e){return(c="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function f(e,t){return!t||"object"!==c(t)&&"function"!=typeof t?function(e){if(void 0!==e)return e;throw new ReferenceError("this hasn't been initialised - super() hasn't been called")}(e):t}function l(e){return(l=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function h(e,t){return(h=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function p(e){if(!navigator||!navigator.sendBeacon)return!1;navigator.sendBeacon(e)}var d=(function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&h(e,t)}(g,r.default),g);function g(e){var t;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,g);var n=e.listenToBrowserNetworkEvents,r=void 0===n||n;return e.db=o.default,e.cbor=new s.default,e.sdkFamily="Web",e.networking=new i.default({del:a.del,get:a.get,post:a.post,patch:a.patch,sendBeacon:p}),t=f(this,l(g).call(this,e)),r&&(window.addEventListener("offline",function(){t.networkDownDetected()}),window.addEventListener("online",function(){t.networkUpDetected()})),t}t.default=d,e.exports=t.default},function(e,t,n){"use strict";function s(e){return(s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var y=f(n(3)),v=f(n(6)),b=f(n(15)),r=f(n(18)),m=f(n(7)),_=f(n(19)),k=f(n(20)),P=c(n(21)),w=c(n(22)),T=c(n(23)),O=c(n(24)),S=c(n(25)),M=c(n(26)),E=c(n(27)),A=c(n(28)),C=c(n(29)),R=c(n(30)),j=c(n(31)),N=c(n(32)),x=c(n(33)),U=c(n(34)),B=c(n(35)),I=c(n(36)),D=c(n(37)),K=c(n(38)),L=c(n(39)),F=c(n(40)),G=c(n(41)),H=c(n(42)),q=c(n(43)),z=c(n(44)),Y=c(n(45)),$=c(n(46)),W=c(n(47)),J=c(n(48)),X=c(n(49)),V=c(n(50)),Q=c(n(51)),Z=c(n(52)),ee=c(n(53)),te=c(n(54)),ne=c(n(55)),re=c(n(56)),ie=c(n(57)),oe=c(n(58)),se=c(n(59)),ae=c(n(60)),ue=c(n(61)),ce=c(n(62)),fe=c(n(63)),le=c(n(64)),he=c(n(65)),pe=c(n(8)),de=c(n(66)),i=f(n(1)),o=f(n(4)),a=(n(0),f(n(5)));function u(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return u=function(){return e},e}function c(e){if(e&&e.__esModule)return e;if(null===e||"object"!==s(e)&&"function"!=typeof e)return{default:e};var t=u();if(t&&t.has(e))return t.get(e);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var o=r?Object.getOwnPropertyDescriptor(e,i):null;o&&(o.get||o.set)?Object.defineProperty(n,i,o):n[i]=e[i]}return n.default=e,t&&t.set(e,n),n}function f(e){return e&&e.__esModule?e:{default:e}}function l(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function ge(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var h,p,d,g=(h=ye,d=[{key:"notificationPayload",value:function(e,t){return new r.default(e,t)}},{key:"generateUUID",value:function(){return a.default.createUUID()}}],(p=[{key:"getVersion",value:function(){return this._config.getVersion()}},{key:"_addPnsdkSuffix",value:function(e,t){this._config._addPnsdkSuffix(e,t)}},{key:"networkDownDetected",value:function(){this._listenerManager.announceNetworkDown(),this._config.restore?this.disconnect():this.destroy(!0)}},{key:"networkUpDetected",value:function(){this._listenerManager.announceNetworkUp(),this.reconnect()}}])&&l(h.prototype,p),void(d&&l(h,d)),ye);function ye(e){var n=this;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,ye),ge(this,"_config",void 0),ge(this,"_listenerManager",void 0),ge(this,"_tokenManager",void 0),ge(this,"time",void 0),ge(this,"publish",void 0),ge(this,"fire",void 0),ge(this,"history",void 0),ge(this,"deleteMessages",void 0),ge(this,"messageCounts",void 0),ge(this,"fetchMessages",void 0),ge(this,"channelGroups",void 0),ge(this,"push",void 0),ge(this,"hereNow",void 0),ge(this,"whereNow",void 0),ge(this,"getState",void 0),ge(this,"setState",void 0),ge(this,"grant",void 0),ge(this,"grantToken",void 0),ge(this,"audit",void 0),ge(this,"subscribe",void 0),ge(this,"signal",void 0),ge(this,"presence",void 0),ge(this,"unsubscribe",void 0),ge(this,"unsubscribeAll",void 0),ge(this,"addMessageAction",void 0),ge(this,"removeMessageAction",void 0),ge(this,"getMessageActions",void 0),ge(this,"createUser",void 0),ge(this,"updateUser",void 0),ge(this,"deleteUser",void 0),ge(this,"getUser",void 0),ge(this,"getUsers",void 0),ge(this,"createSpace",void 0),ge(this,"updateSpace",void 0),ge(this,"deleteSpace",void 0),ge(this,"getSpaces",void 0),ge(this,"getSpace",void 0),ge(this,"getMembers",void 0),ge(this,"addMembers",void 0),ge(this,"updateMembers",void 0),ge(this,"removeMembers",void 0),ge(this,"getMemberships",void 0),ge(this,"joinSpaces",void 0),ge(this,"updateMemberships",void 0),ge(this,"leaveSpaces",void 0),ge(this,"disconnect",void 0),ge(this,"reconnect",void 0),ge(this,"destroy",void 0),ge(this,"stop",void 0),ge(this,"getSubscribedChannels",void 0),ge(this,"getSubscribedChannelGroups",void 0),ge(this,"addListener",void 0),ge(this,"removeListener",void 0),ge(this,"removeAllListeners",void 0),ge(this,"parseToken",void 0),ge(this,"setToken",void 0),ge(this,"setTokens",void 0),ge(this,"getToken",void 0),ge(this,"getTokens",void 0),ge(this,"clearTokens",void 0),ge(this,"getAuthKey",void 0),ge(this,"setAuthKey",void 0),ge(this,"setCipherKey",void 0),ge(this,"setUUID",void 0),ge(this,"getUUID",void 0),ge(this,"getFilterExpression",void 0),ge(this,"setFilterExpression",void 0),ge(this,"setHeartbeatInterval",void 0),ge(this,"setProxy",void 0),ge(this,"encrypt",void 0),ge(this,"decrypt",void 0);var t=e.db,r=e.networking,i=e.cbor,o=this._config=new y.default({setup:e,db:t}),s=new v.default({config:o});r.init(o);var a=this._tokenManager=new _.default(o,i),u={config:o,networking:r,crypto:s,tokenManager:a},c=k.default.bind(this,u,pe),f=k.default.bind(this,u,R),l=k.default.bind(this,u,N),h=k.default.bind(this,u,U),p=k.default.bind(this,u,de),d=this._listenerManager=new m.default,g=new b.default({timeEndpoint:c,leaveEndpoint:f,heartbeatEndpoint:l,setStateEndpoint:h,subscribeEndpoint:p,crypto:u.crypto,config:u.config,listenerManager:d});this.addListener=d.addListener.bind(d),this.removeListener=d.removeListener.bind(d),this.removeAllListeners=d.removeAllListeners.bind(d),this.parseToken=a.parseToken.bind(a),this.setToken=a.setToken.bind(a),this.setTokens=a.setTokens.bind(a),this.getToken=a.getToken.bind(a),this.getTokens=a.getTokens.bind(a),this.clearTokens=a.clearTokens.bind(a),this.channelGroups={listGroups:k.default.bind(this,u,O),listChannels:k.default.bind(this,u,S),addChannels:k.default.bind(this,u,P),removeChannels:k.default.bind(this,u,w),deleteGroup:k.default.bind(this,u,T)},this.push={addChannels:k.default.bind(this,u,M),removeChannels:k.default.bind(this,u,E),deleteDevice:k.default.bind(this,u,C),listChannels:k.default.bind(this,u,A)},this.hereNow=k.default.bind(this,u,B),this.whereNow=k.default.bind(this,u,j),this.getState=k.default.bind(this,u,x),this.setState=g.adaptStateChange.bind(g),this.grant=k.default.bind(this,u,oe),this.grantToken=k.default.bind(this,u,se),this.audit=k.default.bind(this,u,ie),this.publish=k.default.bind(this,u,ae),this.fire=function(e,t){return e.replicate=!1,e.storeInHistory=!1,n.publish(e,t)},this.signal=k.default.bind(this,u,ue),this.history=k.default.bind(this,u,ce),this.deleteMessages=k.default.bind(this,u,fe),this.messageCounts=k.default.bind(this,u,le),this.fetchMessages=k.default.bind(this,u,he),this.addMessageAction=k.default.bind(this,u,I),this.removeMessageAction=k.default.bind(this,u,D),this.getMessageActions=k.default.bind(this,u,K),this.createUser=k.default.bind(this,u,L),this.updateUser=k.default.bind(this,u,F),this.deleteUser=k.default.bind(this,u,G),this.getUser=k.default.bind(this,u,H),this.getUsers=k.default.bind(this,u,q),this.createSpace=k.default.bind(this,u,z),this.updateSpace=k.default.bind(this,u,Y),this.deleteSpace=k.default.bind(this,u,$),this.getSpaces=k.default.bind(this,u,W),this.getSpace=k.default.bind(this,u,J),this.addMembers=k.default.bind(this,u,V),this.updateMembers=k.default.bind(this,u,Q),this.removeMembers=k.default.bind(this,u,Z),this.getMembers=k.default.bind(this,u,X),this.getMemberships=k.default.bind(this,u,ee),this.joinSpaces=k.default.bind(this,u,ne),this.updateMemberships=k.default.bind(this,u,te),this.leaveSpaces=k.default.bind(this,u,re),this.time=c,this.subscribe=g.adaptSubscribeChange.bind(g),this.presence=g.adaptPresenceChange.bind(g),this.unsubscribe=g.adaptUnsubscribeChange.bind(g),this.disconnect=g.disconnect.bind(g),this.reconnect=g.reconnect.bind(g),this.destroy=function(e){g.unsubscribeAll(e),g.disconnect()},this.stop=this.destroy,this.unsubscribeAll=g.unsubscribeAll.bind(g),this.getSubscribedChannels=g.getSubscribedChannels.bind(g),this.getSubscribedChannelGroups=g.getSubscribedChannelGroups.bind(g),this.encrypt=s.encrypt.bind(s),this.decrypt=s.decrypt.bind(s),this.getAuthKey=u.config.getAuthKey.bind(u.config),this.setAuthKey=u.config.setAuthKey.bind(u.config),this.setCipherKey=u.config.setCipherKey.bind(u.config),this.getUUID=u.config.getUUID.bind(u.config),this.setUUID=u.config.setUUID.bind(u.config),this.getFilterExpression=u.config.getFilterExpression.bind(u.config),this.setFilterExpression=u.config.setFilterExpression.bind(u.config),this.setHeartbeatInterval=u.config.setHeartbeatInterval.bind(u.config),r.hasModule("proxy")&&(this.setProxy=function(e){u.config.setProxy(e),n.reconnect()})}ge(t.default=g,"OPERATIONS",i.default),ge(g,"CATEGORIES",o.default),e.exports=t.default},function(e,t,n){var r,i,o;i=[t],void 0===(o="function"==typeof(r=function(e){var r={3:/^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,4:/^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,5:/^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,all:/^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i};function t(){var e,t,n="";for(e=0;e<32;e++)t=16*Math.random()|0,8!==e&&12!==e&&16!==e&&20!==e||(n+="-"),n+=(12===e?4:16===e?3&t|8:t).toString(16);return n}function n(e,t){var n=r[t||"all"];return n&&n.test(e)||!1}t.isUUID=n,t.VERSION="0.1.0",e.uuid=t,e.isUUID=n})?r.apply(t,i):r)||(e.exports=o)},function(e,t,n){"use strict";var r,c,i,u,o,s,a,f,l,h,E=E||function(a){function n(){}var e={},t=e.lib={},r=t.Base={extend:function(e){n.prototype=this;var t=new n;return e&&t.mixIn(e),t.hasOwnProperty("init")||(t.init=function(){t.$super.init.apply(this,arguments)}),(t.init.prototype=t).$super=this,t},create:function(){var e=this.extend();return e.init.apply(e,arguments),e},init:function(){},mixIn:function(e){for(var t in e)e.hasOwnProperty(t)&&(this[t]=e[t]);e.hasOwnProperty("toString")&&(this.toString=e.toString)},clone:function(){return this.init.prototype.extend(this)}},u=t.WordArray=r.extend({init:function(e,t){e=this.words=e||[],this.sigBytes=null!=t?t:4*e.length},toString:function(e){return(e||o).stringify(this)},concat:function(e){var t=this.words,n=e.words,r=this.sigBytes;if(e=e.sigBytes,this.clamp(),r%4)for(var i=0;i<e;i++)t[r+i>>>2]|=(n[i>>>2]>>>24-i%4*8&255)<<24-(r+i)%4*8;else if(65535<n.length)for(i=0;i<e;i+=4)t[r+i>>>2]=n[i>>>2];else t.push.apply(t,n);return this.sigBytes+=e,this},clamp:function(){var e=this.words,t=this.sigBytes;e[t>>>2]&=4294967295<<32-t%4*8,e.length=a.ceil(t/4)},clone:function(){var e=r.clone.call(this);return e.words=this.words.slice(0),e},random:function(e){for(var t=[],n=0;n<e;n+=4)t.push(4294967296*a.random()|0);return new u.init(t,e)}}),i=e.enc={},o=i.Hex={stringify:function(e){var t=e.words;e=e.sigBytes;for(var n=[],r=0;r<e;r++){var i=t[r>>>2]>>>24-r%4*8&255;n.push((i>>>4).toString(16)),n.push((15&i).toString(16))}return n.join("")},parse:function(e){for(var t=e.length,n=[],r=0;r<t;r+=2)n[r>>>3]|=parseInt(e.substr(r,2),16)<<24-r%8*4;return new u.init(n,t/2)}},s=i.Latin1={stringify:function(e){var t=e.words;e=e.sigBytes;for(var n=[],r=0;r<e;r++)n.push(String.fromCharCode(t[r>>>2]>>>24-r%4*8&255));return n.join("")},parse:function(e){for(var t=e.length,n=[],r=0;r<t;r++)n[r>>>2]|=(255&e.charCodeAt(r))<<24-r%4*8;return new u.init(n,t)}},c=i.Utf8={stringify:function(e){try{return decodeURIComponent(escape(s.stringify(e)))}catch(e){throw Error("Malformed UTF-8 data")}},parse:function(e){return s.parse(unescape(encodeURIComponent(e)))}},f=t.BufferedBlockAlgorithm=r.extend({reset:function(){this._data=new u.init,this._nDataBytes=0},_append:function(e){"string"==typeof e&&(e=c.parse(e)),this._data.concat(e),this._nDataBytes+=e.sigBytes},_process:function(e){var t=this._data,n=t.words,r=t.sigBytes,i=this.blockSize,o=r/(4*i);if(e=(o=e?a.ceil(o):a.max((0|o)-this._minBufferSize,0))*i,r=a.min(4*e,r),e){for(var s=0;s<e;s+=i)this._doProcessBlock(n,s);s=n.splice(0,e),t.sigBytes-=r}return new u.init(s,r)},clone:function(){var e=r.clone.call(this);return e._data=this._data.clone(),e},_minBufferSize:0});t.Hasher=f.extend({cfg:r.extend(),init:function(e){this.cfg=this.cfg.extend(e),this.reset()},reset:function(){f.reset.call(this),this._doReset()},update:function(e){return this._append(e),this._process(),this},finalize:function(e){return e&&this._append(e),this._doFinalize()},blockSize:16,_createHelper:function(n){return function(e,t){return new n.init(t).finalize(e)}},_createHmacHelper:function(n){return function(e,t){return new l.HMAC.init(n,t).finalize(e)}}});var l=e.algo={};return e}(Math);!function(i){for(var e=E,t=(r=e.lib).WordArray,n=r.Hasher,r=e.algo,o=[],d=[],s=function(e){return 4294967296*(e-(0|e))|0},a=2,u=0;u<64;){var c;e:{c=a;for(var f=i.sqrt(c),l=2;l<=f;l++)if(!(c%l)){c=!1;break e}c=!0}c&&(u<8&&(o[u]=s(i.pow(a,.5))),d[u]=s(i.pow(a,1/3)),u++),a++}var g=[];r=r.SHA256=n.extend({_doReset:function(){this._hash=new t.init(o.slice(0))},_doProcessBlock:function(e,t){for(var n=this._hash.words,r=n[0],i=n[1],o=n[2],s=n[3],a=n[4],u=n[5],c=n[6],f=n[7],l=0;l<64;l++){if(l<16)g[l]=0|e[t+l];else{var h=g[l-15],p=g[l-2];g[l]=((h<<25|h>>>7)^(h<<14|h>>>18)^h>>>3)+g[l-7]+((p<<15|p>>>17)^(p<<13|p>>>19)^p>>>10)+g[l-16]}h=f+((a<<26|a>>>6)^(a<<21|a>>>11)^(a<<7|a>>>25))+(a&u^~a&c)+d[l]+g[l],p=((r<<30|r>>>2)^(r<<19|r>>>13)^(r<<10|r>>>22))+(r&i^r&o^i&o),f=c,c=u,u=a,a=s+h|0,s=o,o=i,i=r,r=h+p|0}n[0]=n[0]+r|0,n[1]=n[1]+i|0,n[2]=n[2]+o|0,n[3]=n[3]+s|0,n[4]=n[4]+a|0,n[5]=n[5]+u|0,n[6]=n[6]+c|0,n[7]=n[7]+f|0},_doFinalize:function(){var e=this._data,t=e.words,n=8*this._nDataBytes,r=8*e.sigBytes;return t[r>>>5]|=128<<24-r%32,t[14+(64+r>>>9<<4)]=i.floor(n/4294967296),t[15+(64+r>>>9<<4)]=n,e.sigBytes=4*t.length,this._process(),this._hash},clone:function(){var e=n.clone.call(this);return e._hash=this._hash.clone(),e}});e.SHA256=n._createHelper(r),e.HmacSHA256=n._createHmacHelper(r)}(Math),c=(r=E).enc.Utf8,r.algo.HMAC=r.lib.Base.extend({init:function(e,t){e=this._hasher=new e.init,"string"==typeof t&&(t=c.parse(t));var n=e.blockSize,r=4*n;t.sigBytes>r&&(t=e.finalize(t)),t.clamp();for(var i=this._oKey=t.clone(),o=this._iKey=t.clone(),s=i.words,a=o.words,u=0;u<n;u++)s[u]^=1549556828,a[u]^=909522486;i.sigBytes=o.sigBytes=r,this.reset()},reset:function(){var e=this._hasher;e.reset(),e.update(this._iKey)},update:function(e){return this._hasher.update(e),this},finalize:function(e){var t=this._hasher;return e=t.finalize(e),t.reset(),t.finalize(this._oKey.clone().concat(e))}}),u=(i=E).lib.WordArray,i.enc.Base64={stringify:function(e){var t=e.words,n=e.sigBytes,r=this._map;e.clamp(),e=[];for(var i=0;i<n;i+=3)for(var o=(t[i>>>2]>>>24-i%4*8&255)<<16|(t[i+1>>>2]>>>24-(i+1)%4*8&255)<<8|t[i+2>>>2]>>>24-(i+2)%4*8&255,s=0;s<4&&i+.75*s<n;s++)e.push(r.charAt(o>>>6*(3-s)&63));if(t=r.charAt(64))for(;e.length%4;)e.push(t);return e.join("")},parse:function(e){var t=e.length,n=this._map;!(r=n.charAt(64))||-1!=(r=e.indexOf(r))&&(t=r);for(var r=[],i=0,o=0;o<t;o++)if(o%4){var s=n.indexOf(e.charAt(o-1))<<o%4*2,a=n.indexOf(e.charAt(o))>>>6-o%4*2;r[i>>>2]|=(s|a)<<24-i%4*8,i++}return u.create(r,i)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="},function(o){function w(e,t,n,r,i,o,s){return((e=e+(t&n|~t&r)+i+s)<<o|e>>>32-o)+t}function T(e,t,n,r,i,o,s){return((e=e+(t&r|n&~r)+i+s)<<o|e>>>32-o)+t}function O(e,t,n,r,i,o,s){return((e=e+(t^n^r)+i+s)<<o|e>>>32-o)+t}function S(e,t,n,r,i,o,s){return((e=e+(n^(t|~r))+i+s)<<o|e>>>32-o)+t}for(var e=E,t=(r=e.lib).WordArray,n=r.Hasher,r=e.algo,M=[],i=0;i<64;i++)M[i]=4294967296*o.abs(o.sin(i+1))|0;r=r.MD5=n.extend({_doReset:function(){this._hash=new t.init([1732584193,4023233417,2562383102,271733878])},_doProcessBlock:function(e,t){for(var n=0;n<16;n++){var r=e[s=t+n];e[s]=16711935&(r<<8|r>>>24)|4278255360&(r<<24|r>>>8)}n=this._hash.words;var i,o,s=e[t+0],a=(r=e[t+1],e[t+2]),u=e[t+3],c=e[t+4],f=e[t+5],l=e[t+6],h=e[t+7],p=e[t+8],d=e[t+9],g=e[t+10],y=e[t+11],v=e[t+12],b=e[t+13],m=e[t+14],_=e[t+15],k=n[0],P=S(P=S(P=S(P=S(P=O(P=O(P=O(P=O(P=T(P=T(P=T(P=T(P=w(P=w(P=w(P=w(P=n[1],o=w(o=n[2],i=w(i=n[3],k=w(k,P,o,i,s,7,M[0]),P,o,r,12,M[1]),k,P,a,17,M[2]),i,k,u,22,M[3]),o=w(o,i=w(i,k=w(k,P,o,i,c,7,M[4]),P,o,f,12,M[5]),k,P,l,17,M[6]),i,k,h,22,M[7]),o=w(o,i=w(i,k=w(k,P,o,i,p,7,M[8]),P,o,d,12,M[9]),k,P,g,17,M[10]),i,k,y,22,M[11]),o=w(o,i=w(i,k=w(k,P,o,i,v,7,M[12]),P,o,b,12,M[13]),k,P,m,17,M[14]),i,k,_,22,M[15]),o=T(o,i=T(i,k=T(k,P,o,i,r,5,M[16]),P,o,l,9,M[17]),k,P,y,14,M[18]),i,k,s,20,M[19]),o=T(o,i=T(i,k=T(k,P,o,i,f,5,M[20]),P,o,g,9,M[21]),k,P,_,14,M[22]),i,k,c,20,M[23]),o=T(o,i=T(i,k=T(k,P,o,i,d,5,M[24]),P,o,m,9,M[25]),k,P,u,14,M[26]),i,k,p,20,M[27]),o=T(o,i=T(i,k=T(k,P,o,i,b,5,M[28]),P,o,a,9,M[29]),k,P,h,14,M[30]),i,k,v,20,M[31]),o=O(o,i=O(i,k=O(k,P,o,i,f,4,M[32]),P,o,p,11,M[33]),k,P,y,16,M[34]),i,k,m,23,M[35]),o=O(o,i=O(i,k=O(k,P,o,i,r,4,M[36]),P,o,c,11,M[37]),k,P,h,16,M[38]),i,k,g,23,M[39]),o=O(o,i=O(i,k=O(k,P,o,i,b,4,M[40]),P,o,s,11,M[41]),k,P,u,16,M[42]),i,k,l,23,M[43]),o=O(o,i=O(i,k=O(k,P,o,i,d,4,M[44]),P,o,v,11,M[45]),k,P,_,16,M[46]),i,k,a,23,M[47]),o=S(o,i=S(i,k=S(k,P,o,i,s,6,M[48]),P,o,h,10,M[49]),k,P,m,15,M[50]),i,k,f,21,M[51]),o=S(o,i=S(i,k=S(k,P,o,i,v,6,M[52]),P,o,u,10,M[53]),k,P,g,15,M[54]),i,k,r,21,M[55]),o=S(o,i=S(i,k=S(k,P,o,i,p,6,M[56]),P,o,_,10,M[57]),k,P,l,15,M[58]),i,k,b,21,M[59]),o=S(o,i=S(i,k=S(k,P,o,i,c,6,M[60]),P,o,y,10,M[61]),k,P,a,15,M[62]),i,k,d,21,M[63]);n[0]=n[0]+k|0,n[1]=n[1]+P|0,n[2]=n[2]+o|0,n[3]=n[3]+i|0},_doFinalize:function(){var e=this._data,t=e.words,n=8*this._nDataBytes,r=8*e.sigBytes;t[r>>>5]|=128<<24-r%32;var i=o.floor(n/4294967296);for(t[15+(r+64>>>9<<4)]=16711935&(i<<8|i>>>24)|4278255360&(i<<24|i>>>8),t[14+(r+64>>>9<<4)]=16711935&(n<<8|n>>>24)|4278255360&(n<<24|n>>>8),e.sigBytes=4*(t.length+1),this._process(),t=(e=this._hash).words,n=0;n<4;n++)r=t[n],t[n]=16711935&(r<<8|r>>>24)|4278255360&(r<<24|r>>>8);return e},clone:function(){var e=n.clone.call(this);return e._hash=this._hash.clone(),e}}),e.MD5=n._createHelper(r),e.HmacMD5=n._createHmacHelper(r)}(Math),a=(o=(s=E).lib).Base,f=o.WordArray,l=(o=s.algo).EvpKDF=a.extend({cfg:a.extend({keySize:4,hasher:o.MD5,iterations:1}),init:function(e){this.cfg=this.cfg.extend(e)},compute:function(e,t){for(var n=(s=this.cfg).hasher.create(),r=f.create(),i=r.words,o=s.keySize,s=s.iterations;i.length<o;){a&&n.update(a);var a=n.update(e).finalize(t);n.reset();for(var u=1;u<s;u++)a=n.finalize(a),n.reset();r.concat(a)}return r.sigBytes=4*o,r}}),s.EvpKDF=function(e,t,n){return l.create(n).compute(e,t)},E.lib.Cipher||function(){var e=(h=E).lib,t=e.Base,s=e.WordArray,n=e.BufferedBlockAlgorithm,r=h.enc.Base64,i=h.algo.EvpKDF,o=e.Cipher=n.extend({cfg:t.extend(),createEncryptor:function(e,t){return this.create(this._ENC_XFORM_MODE,e,t)},createDecryptor:function(e,t){return this.create(this._DEC_XFORM_MODE,e,t)},init:function(e,t,n){this.cfg=this.cfg.extend(n),this._xformMode=e,this._key=t,this.reset()},reset:function(){n.reset.call(this),this._doReset()},process:function(e){return this._append(e),this._process()},finalize:function(e){return e&&this._append(e),this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(r){return{encrypt:function(e,t,n){return("string"==typeof t?p:l).encrypt(r,e,t,n)},decrypt:function(e,t,n){return("string"==typeof t?p:l).decrypt(r,e,t,n)}}}});e.StreamCipher=o.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});function a(e,t,n){var r=this._iv;r?this._iv=void 0:r=this._prevBlock;for(var i=0;i<n;i++)e[t+i]^=r[i]}var u=h.mode={},c=(e.BlockCipherMode=t.extend({createEncryptor:function(e,t){return this.Encryptor.create(e,t)},createDecryptor:function(e,t){return this.Decryptor.create(e,t)},init:function(e,t){this._cipher=e,this._iv=t}})).extend();c.Encryptor=c.extend({processBlock:function(e,t){var n=this._cipher,r=n.blockSize;a.call(this,e,t,r),n.encryptBlock(e,t),this._prevBlock=e.slice(t,t+r)}}),c.Decryptor=c.extend({processBlock:function(e,t){var n=this._cipher,r=n.blockSize,i=e.slice(t,t+r);n.decryptBlock(e,t),a.call(this,e,t,r),this._prevBlock=i}}),u=u.CBC=c,c=(h.pad={}).Pkcs7={pad:function(e,t){for(var n,r=(n=(n=4*t)-e.sigBytes%n)<<24|n<<16|n<<8|n,i=[],o=0;o<n;o+=4)i.push(r);n=s.create(i,n),e.concat(n)},unpad:function(e){e.sigBytes-=255&e.words[e.sigBytes-1>>>2]}},e.BlockCipher=o.extend({cfg:o.cfg.extend({mode:u,padding:c}),reset:function(){o.reset.call(this);var e=(t=this.cfg).iv,t=t.mode;if(this._xformMode==this._ENC_XFORM_MODE)var n=t.createEncryptor;else n=t.createDecryptor,this._minBufferSize=1;this._mode=n.call(t,this,e&&e.words)},_doProcessBlock:function(e,t){this._mode.processBlock(e,t)},_doFinalize:function(){var e=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){e.pad(this._data,this.blockSize);var t=this._process(!0)}else t=this._process(!0),e.unpad(t);return t},blockSize:4});var f=e.CipherParams=t.extend({init:function(e){this.mixIn(e)},toString:function(e){return(e||this.formatter).stringify(this)}}),l=(u=(h.format={}).OpenSSL={stringify:function(e){var t=e.ciphertext;return((e=e.salt)?s.create([1398893684,1701076831]).concat(e).concat(t):t).toString(r)},parse:function(e){var t=(e=r.parse(e)).words;if(1398893684==t[0]&&1701076831==t[1]){var n=s.create(t.slice(2,4));t.splice(0,4),e.sigBytes-=16}return f.create({ciphertext:e,salt:n})}},e.SerializableCipher=t.extend({cfg:t.extend({format:u}),encrypt:function(e,t,n,r){r=this.cfg.extend(r);var i=e.createEncryptor(n,r);return t=i.finalize(t),i=i.cfg,f.create({ciphertext:t,key:n,iv:i.iv,algorithm:e,mode:i.mode,padding:i.padding,blockSize:e.blockSize,formatter:r.format})},decrypt:function(e,t,n,r){return r=this.cfg.extend(r),t=this._parse(t,r.format),e.createDecryptor(n,r).finalize(t.ciphertext)},_parse:function(e,t){return"string"==typeof e?t.parse(e,this):e}})),h=(h.kdf={}).OpenSSL={execute:function(e,t,n,r){return r=r||s.random(8),e=i.create({keySize:t+n}).compute(e,r),n=s.create(e.words.slice(t),4*n),e.sigBytes=4*t,f.create({key:e,iv:n,salt:r})}},p=e.PasswordBasedCipher=l.extend({cfg:l.cfg.extend({kdf:h}),encrypt:function(e,t,n,r){return n=(r=this.cfg.extend(r)).kdf.execute(n,e.keySize,e.ivSize),r.iv=n.iv,(e=l.encrypt.call(this,e,t,n.key,r)).mixIn(n),e},decrypt:function(e,t,n,r){return r=this.cfg.extend(r),t=this._parse(t,r.format),n=r.kdf.execute(n,e.keySize,e.ivSize,t.salt),r.iv=n.iv,l.decrypt.call(this,e,t,n.key,r)}})}(),function(){for(var e=E,t=e.lib.BlockCipher,n=e.algo,s=[],r=[],i=[],o=[],a=[],u=[],c=[],f=[],l=[],h=[],p=[],d=0;d<256;d++)p[d]=d<128?d<<1:d<<1^283;var g=0,y=0;for(d=0;d<256;d++){var v=(v=y^y<<1^y<<2^y<<3^y<<4)>>>8^255&v^99;s[g]=v;var b=p[r[v]=g],m=p[b],_=p[m],k=257*p[v]^16843008*v;i[g]=k<<24|k>>>8,o[g]=k<<16|k>>>16,a[g]=k<<8|k>>>24,u[g]=k,k=16843009*_^65537*m^257*b^16843008*g,c[v]=k<<24|k>>>8,f[v]=k<<16|k>>>16,l[v]=k<<8|k>>>24,h[v]=k,g?(g=b^p[p[p[_^b]]],y^=p[p[y]]):g=y=1}var P=[0,1,2,4,8,16,32,64,128,27,54];n=n.AES=t.extend({_doReset:function(){for(var e=(n=this._key).words,t=n.sigBytes/4,n=4*((this._nRounds=t+6)+1),r=this._keySchedule=[],i=0;i<n;i++)if(i<t)r[i]=e[i];else{var o=r[i-1];i%t?6<t&&4==i%t&&(o=s[o>>>24]<<24|s[o>>>16&255]<<16|s[o>>>8&255]<<8|s[255&o]):(o=s[(o=o<<8|o>>>24)>>>24]<<24|s[o>>>16&255]<<16|s[o>>>8&255]<<8|s[255&o],o^=P[i/t|0]<<24),r[i]=r[i-t]^o}for(e=this._invKeySchedule=[],t=0;t<n;t++)i=n-t,o=t%4?r[i]:r[i-4],e[t]=t<4||i<=4?o:c[s[o>>>24]]^f[s[o>>>16&255]]^l[s[o>>>8&255]]^h[s[255&o]]},encryptBlock:function(e,t){this._doCryptBlock(e,t,this._keySchedule,i,o,a,u,s)},decryptBlock:function(e,t){var n=e[t+1];e[t+1]=e[t+3],e[t+3]=n,this._doCryptBlock(e,t,this._invKeySchedule,c,f,l,h,r),n=e[t+1],e[t+1]=e[t+3],e[t+3]=n},_doCryptBlock:function(e,t,n,r,i,o,s,a){for(var u=this._nRounds,c=e[t]^n[0],f=e[t+1]^n[1],l=e[t+2]^n[2],h=e[t+3]^n[3],p=4,d=1;d<u;d++){var g=r[c>>>24]^i[f>>>16&255]^o[l>>>8&255]^s[255&h]^n[p++],y=r[f>>>24]^i[l>>>16&255]^o[h>>>8&255]^s[255&c]^n[p++],v=r[l>>>24]^i[h>>>16&255]^o[c>>>8&255]^s[255&f]^n[p++];h=r[h>>>24]^i[c>>>16&255]^o[f>>>8&255]^s[255&l]^n[p++],c=g,f=y,l=v}g=(a[c>>>24]<<24|a[f>>>16&255]<<16|a[l>>>8&255]<<8|a[255&h])^n[p++],y=(a[f>>>24]<<24|a[l>>>16&255]<<16|a[h>>>8&255]<<8|a[255&c])^n[p++],v=(a[l>>>24]<<24|a[h>>>16&255]<<16|a[c>>>8&255]<<8|a[255&f])^n[p++],h=(a[h>>>24]<<24|a[c>>>16&255]<<16|a[f>>>8&255]<<8|a[255&l])^n[p++],e[t]=g,e[t+1]=y,e[t+2]=v,e[t+3]=h},keySize:8});e.AES=t._createHelper(n)}(),E.mode.ECB=((h=E.lib.BlockCipherMode.extend()).Encryptor=h.extend({processBlock:function(e,t){this._cipher.encryptBlock(e,t)}}),h.Decryptor=h.extend({processBlock:function(e,t){this._cipher.decryptBlock(e,t)}}),h),e.exports=E},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;r(n(6)),r(n(3)),r(n(7));var c=r(n(16)),f=r(n(17)),l=r(n(2)),a=(n(0),r(n(4)));function r(e){return e&&e.__esModule?e:{default:e}}function i(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function h(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var o,s,u,p=(o=d,(s=[{key:"adaptStateChange",value:function(e,t){var n=this,r=e.state,i=e.channels,o=void 0===i?[]:i,s=e.channelGroups,a=void 0===s?[]:s;return o.forEach(function(e){e in n._channels&&(n._channels[e].state=r)}),a.forEach(function(e){e in n._channelGroups&&(n._channelGroups[e].state=r)}),this._setStateEndpoint({state:r,channels:o,channelGroups:a},t)}},{key:"adaptPresenceChange",value:function(e){var t=this,n=e.connected,r=e.channels,i=void 0===r?[]:r,o=e.channelGroups,s=void 0===o?[]:o;n?(i.forEach(function(e){t._heartbeatChannels[e]={state:{}}}),s.forEach(function(e){t._heartbeatChannelGroups[e]={state:{}}})):(i.forEach(function(e){e in t._heartbeatChannels&&delete t._heartbeatChannels[e]}),s.forEach(function(e){e in t._heartbeatChannelGroups&&delete t._heartbeatChannelGroups[e]}),!1===this._config.suppressLeaveEvents&&this._leaveEndpoint({channels:i,channelGroups:s},function(e){t._listenerManager.announceStatus(e)})),this.reconnect()}},{key:"adaptSubscribeChange",value:function(e){var t=this,n=e.timetoken,r=e.channels,i=void 0===r?[]:r,o=e.channelGroups,s=void 0===o?[]:o,a=e.withPresence,u=void 0!==a&&a,c=e.withHeartbeats,f=void 0!==c&&c;this._config.subscribeKey&&""!==this._config.subscribeKey?(n&&(this._lastTimetoken=this._currentTimetoken,this._currentTimetoken=n),"0"!==this._currentTimetoken&&0!==this._currentTimetoken&&(this._storedTimetoken=this._currentTimetoken,this._currentTimetoken=0),i.forEach(function(e){t._channels[e]={state:{}},u&&(t._presenceChannels[e]={}),(f||t._config.getHeartbeatInterval())&&(t._heartbeatChannels[e]={}),t._pendingChannelSubscriptions.push(e)}),s.forEach(function(e){t._channelGroups[e]={state:{}},u&&(t._presenceChannelGroups[e]={}),(f||t._config.getHeartbeatInterval())&&(t._heartbeatChannelGroups[e]={}),t._pendingChannelGroupSubscriptions.push(e)}),this._subscriptionStatusAnnounced=!1,this.reconnect()):console&&console.log&&console.log("subscribe key missing; aborting subscribe")}},{key:"adaptUnsubscribeChange",value:function(e,t){var n=this,r=e.channels,i=void 0===r?[]:r,o=e.channelGroups,s=void 0===o?[]:o,a=[],u=[];i.forEach(function(e){e in n._channels&&(delete n._channels[e],a.push(e),e in n._heartbeatChannels&&delete n._heartbeatChannels[e]),e in n._presenceChannels&&(delete n._presenceChannels[e],a.push(e))}),s.forEach(function(e){e in n._channelGroups&&(delete n._channelGroups[e],u.push(e),e in n._heartbeatChannelGroups&&delete n._heartbeatChannelGroups[e]),e in n._presenceChannelGroups&&(delete n._channelGroups[e],u.push(e))}),0===a.length&&0===u.length||(!1!==this._config.suppressLeaveEvents||t||this._leaveEndpoint({channels:a,channelGroups:u},function(e){e.affectedChannels=a,e.affectedChannelGroups=u,e.currentTimetoken=n._currentTimetoken,e.lastTimetoken=n._lastTimetoken,n._listenerManager.announceStatus(e)}),0===Object.keys(this._channels).length&&0===Object.keys(this._presenceChannels).length&&0===Object.keys(this._channelGroups).length&&0===Object.keys(this._presenceChannelGroups).length&&(this._lastTimetoken=0,this._currentTimetoken=0,this._storedTimetoken=null,this._region=null,this._reconnectionManager.stopPolling()),this.reconnect())}},{key:"unsubscribeAll",value:function(e){this.adaptUnsubscribeChange({channels:this.getSubscribedChannels(),channelGroups:this.getSubscribedChannelGroups()},e)}},{key:"getHeartbeatChannels",value:function(){return Object.keys(this._heartbeatChannels)}},{key:"getHeartbeatChannelGroups",value:function(){return Object.keys(this._heartbeatChannelGroups)}},{key:"getSubscribedChannels",value:function(){return Object.keys(this._channels)}},{key:"getSubscribedChannelGroups",value:function(){return Object.keys(this._channelGroups)}},{key:"reconnect",value:function(){this._startSubscribeLoop(),this._registerHeartbeatTimer()}},{key:"disconnect",value:function(){this._stopSubscribeLoop(),this._stopHeartbeatTimer(),this._reconnectionManager.stopPolling()}},{key:"_registerHeartbeatTimer",value:function(){this._stopHeartbeatTimer(),0!==this._config.getHeartbeatInterval()&&(this._performHeartbeatLoop(),this._heartbeatTimer=setInterval(this._performHeartbeatLoop.bind(this),1e3*this._config.getHeartbeatInterval()))}},{key:"_stopHeartbeatTimer",value:function(){this._heartbeatTimer&&(clearInterval(this._heartbeatTimer),this._heartbeatTimer=null)}},{key:"_performHeartbeatLoop",value:function(){var n=this,e=this.getHeartbeatChannels(),t=this.getHeartbeatChannelGroups(),r={};0===e.length&&0===t.length||(this.getSubscribedChannels().forEach(function(e){var t=n._channels[e].state;Object.keys(t).length&&(r[e]=t)}),this.getSubscribedChannelGroups().forEach(function(e){var t=n._channelGroups[e].state;Object.keys(t).length&&(r[e]=t)}),this._heartbeatEndpoint({channels:e,channelGroups:t,state:r},function(e){e.error&&n._config.announceFailedHeartbeats&&n._listenerManager.announceStatus(e),e.error&&n._config.autoNetworkDetection&&n._isOnline&&(n._isOnline=!1,n.disconnect(),n._listenerManager.announceNetworkDown(),n.reconnect()),!e.error&&n._config.announceSuccessfulHeartbeats&&n._listenerManager.announceStatus(e)}.bind(this)))}},{key:"_startSubscribeLoop",value:function(){var n=this;this._stopSubscribeLoop();var r={},i=[],o=[];if(Object.keys(this._channels).forEach(function(e){var t=n._channels[e].state;Object.keys(t).length&&(r[e]=t),i.push(e)}),Object.keys(this._presenceChannels).forEach(function(e){i.push("".concat(e,"-pnpres"))}),Object.keys(this._channelGroups).forEach(function(e){var t=n._channelGroups[e].state;Object.keys(t).length&&(r[e]=t),o.push(e)}),Object.keys(this._presenceChannelGroups).forEach(function(e){o.push("".concat(e,"-pnpres"))}),0!==i.length||0!==o.length){var e={channels:i,channelGroups:o,state:r,timetoken:this._currentTimetoken,filterExpression:this._config.filterExpression,region:this._region};this._subscribeCall=this._subscribeEndpoint(e,this._processSubscribeResponse.bind(this))}}},{key:"_processSubscribeResponse",value:function(t,e){var c=this;if(t.error)t.category===a.default.PNTimeoutCategory?this._startSubscribeLoop():(t.category===a.default.PNNetworkIssuesCategory?(this.disconnect(),t.error&&this._config.autoNetworkDetection&&this._isOnline&&(this._isOnline=!1,this._listenerManager.announceNetworkDown()),this._reconnectionManager.onReconnection(function(){c._config.autoNetworkDetection&&!c._isOnline&&(c._isOnline=!0,c._listenerManager.announceNetworkUp()),c.reconnect(),c._subscriptionStatusAnnounced=!0;var e={category:a.default.PNReconnectedCategory,operation:t.operation,lastTimetoken:c._lastTimetoken,currentTimetoken:c._currentTimetoken};c._listenerManager.announceStatus(e)}),this._reconnectionManager.startPolling()):t.category===a.default.PNBadRequestCategory&&this._stopHeartbeatTimer(),this._listenerManager.announceStatus(t));else{if(this._storedTimetoken?(this._currentTimetoken=this._storedTimetoken,this._storedTimetoken=null):(this._lastTimetoken=this._currentTimetoken,this._currentTimetoken=e.metadata.timetoken),!this._subscriptionStatusAnnounced){var n={};n.category=a.default.PNConnectedCategory,n.operation=t.operation,n.affectedChannels=this._pendingChannelSubscriptions,n.subscribedChannels=this.getSubscribedChannels(),n.affectedChannelGroups=this._pendingChannelGroupSubscriptions,n.lastTimetoken=this._lastTimetoken,n.currentTimetoken=this._currentTimetoken,this._subscriptionStatusAnnounced=!0,this._listenerManager.announceStatus(n),this._pendingChannelSubscriptions=[],this._pendingChannelGroupSubscriptions=[]}var r=e.messages||[],i=this._config,o=i.requestMessageCountThreshold,f=i.dedupeOnSubscribe;if(o&&r.length>=o){var s={};s.category=a.default.PNRequestMessageCountExceededCategory,s.operation=t.operation,this._listenerManager.announceStatus(s)}r.forEach(function(e){var t=e.channel,n=e.subscriptionMatch,r=e.publishMetaData;if(t===n&&(n=null),f){if(c._dedupingManager.isDuplicate(e))return;c._dedupingManager.addEntry(e)}if(l.default.endsWith(e.channel,"-pnpres")){var i={channel:null,subscription:null};i.actualChannel=null!=n?t:null,i.subscribedChannel=null!=n?n:t,t&&(i.channel=t.substring(0,t.lastIndexOf("-pnpres"))),n&&(i.subscription=n.substring(0,n.lastIndexOf("-pnpres"))),i.action=e.payload.action,i.state=e.payload.data,i.timetoken=r.publishTimetoken,i.occupancy=e.payload.occupancy,i.uuid=e.payload.uuid,i.timestamp=e.payload.timestamp,e.payload.join&&(i.join=e.payload.join),e.payload.leave&&(i.leave=e.payload.leave),e.payload.timeout&&(i.timeout=e.payload.timeout),c._listenerManager.announcePresence(i)}else if(1===e.messageType){var o={channel:null,subscription:null};o.channel=t,o.subscription=n,o.timetoken=r.publishTimetoken,o.publisher=e.issuingClientId,e.userMetadata&&(o.userMetadata=e.userMetadata),o.message=e.payload,c._listenerManager.announceSignal(o)}else if(2===e.messageType){var s={channel:null,subscription:null};s.channel=t,s.subscription=n,s.timetoken=r.publishTimetoken,s.publisher=e.issuingClientId,e.userMetadata&&(s.userMetadata=e.userMetadata),s.message={event:e.payload.event,type:e.payload.type,data:e.payload.data},"user"===e.payload.type?c._listenerManager.announceUser(s):"space"===e.payload.type?c._listenerManager.announceSpace(s):"membership"===e.payload.type&&c._listenerManager.announceMembership(s)}else if(3===e.messageType){var a={};a.channel=t,a.subscription=n,a.timetoken=r.publishTimetoken,a.publisher=e.issuingClientId,a.data={messageTimetoken:e.payload.data.messageTimetoken,actionTimetoken:e.payload.data.actionTimetoken,type:e.payload.data.type,uuid:e.issuingClientId,value:e.payload.data.value},a.event=e.payload.event,c._listenerManager.announceMessageAction(a)}else{var u={channel:null,subscription:null};u.actualChannel=null!=n?t:null,u.subscribedChannel=null!=n?n:t,u.channel=t,u.subscription=n,u.timetoken=r.publishTimetoken,u.publisher=e.issuingClientId,e.userMetadata&&(u.userMetadata=e.userMetadata),c._config.cipherKey?u.message=c._crypto.decrypt(e.payload):u.message=e.payload,c._listenerManager.announceMessage(u)}}),this._region=e.metadata.region,this._startSubscribeLoop()}}},{key:"_stopSubscribeLoop",value:function(){this._subscribeCall&&("function"==typeof this._subscribeCall.abort&&this._subscribeCall.abort(),this._subscribeCall=null)}}])&&i(o.prototype,s),void(u&&i(o,u)),d);function d(e){var t=e.subscribeEndpoint,n=e.leaveEndpoint,r=e.heartbeatEndpoint,i=e.setStateEndpoint,o=e.timeEndpoint,s=e.config,a=e.crypto,u=e.listenerManager;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,d),h(this,"_crypto",void 0),h(this,"_config",void 0),h(this,"_listenerManager",void 0),h(this,"_reconnectionManager",void 0),h(this,"_leaveEndpoint",void 0),h(this,"_heartbeatEndpoint",void 0),h(this,"_setStateEndpoint",void 0),h(this,"_subscribeEndpoint",void 0),h(this,"_channels",void 0),h(this,"_presenceChannels",void 0),h(this,"_heartbeatChannels",void 0),h(this,"_heartbeatChannelGroups",void 0),h(this,"_channelGroups",void 0),h(this,"_presenceChannelGroups",void 0),h(this,"_currentTimetoken",void 0),h(this,"_lastTimetoken",void 0),h(this,"_storedTimetoken",void 0),h(this,"_region",void 0),h(this,"_subscribeCall",void 0),h(this,"_heartbeatTimer",void 0),h(this,"_subscriptionStatusAnnounced",void 0),h(this,"_autoNetworkDetection",void 0),h(this,"_isOnline",void 0),h(this,"_pendingChannelSubscriptions",void 0),h(this,"_pendingChannelGroupSubscriptions",void 0),h(this,"_dedupingManager",void 0),this._listenerManager=u,this._config=s,this._leaveEndpoint=n,this._heartbeatEndpoint=r,this._setStateEndpoint=i,this._subscribeEndpoint=t,this._crypto=a,this._channels={},this._presenceChannels={},this._heartbeatChannels={},this._heartbeatChannelGroups={},this._channelGroups={},this._presenceChannelGroups={},this._pendingChannelSubscriptions=[],this._pendingChannelGroupSubscriptions=[],this._currentTimetoken=0,this._lastTimetoken=0,this._storedTimetoken=null,this._subscriptionStatusAnnounced=!1,this._isOnline=!0,this._reconnectionManager=new c.default({timeEndpoint:o}),this._dedupingManager=new f.default({config:s})}t.default=p,e.exports=t.default},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var r;(r=n(8))&&r.__esModule,n(0);function i(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var s,a,u,c=(s=f,(a=[{key:"onReconnection",value:function(e){this._reconnectionCallback=e}},{key:"startPolling",value:function(){this._timeTimer=setInterval(this._performTimeLoop.bind(this),3e3)}},{key:"stopPolling",value:function(){clearInterval(this._timeTimer)}},{key:"_performTimeLoop",value:function(){var t=this;this._timeEndpoint(function(e){e.error||(clearInterval(t._timeTimer),t._reconnectionCallback())})}}])&&i(s.prototype,a),void(u&&i(s,u)),f);function f(e){var t=e.timeEndpoint;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,f),o(this,"_reconnectionCallback",void 0),o(this,"_timeEndpoint",void 0),o(this,"_timeTimer",void 0),this._timeEndpoint=t}t.default=c,e.exports=t.default},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var r;(r=n(3))&&r.__esModule,n(0);function i(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var s,a,u,c=(s=f,(a=[{key:"getKey",value:function(e){var t=function(e){var t=0;if(0===e.length)return t;for(var n=0;n<e.length;n+=1)t=(t<<5)-t+e.charCodeAt(n),t&=t;return t}(JSON.stringify(e.payload)).toString(),n=e.publishMetaData.publishTimetoken;return"".concat(n,"-").concat(t)}},{key:"isDuplicate",value:function(e){return this.hashHistory.includes(this.getKey(e))}},{key:"addEntry",value:function(e){this.hashHistory.length>=this._config.maximumCacheSize&&this.hashHistory.shift(),this.hashHistory.push(this.getKey(e))}},{key:"clearHistory",value:function(){this.hashHistory=[]}}])&&i(s.prototype,a),void(u&&i(s,u)),f);function f(e){var t=e.config;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,f),o(this,"_config",void 0),o(this,"hashHistory",void 0),this.hashHistory=[],this._config=t}t.default=c,e.exports=t.default},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=t.FCMNotificationPayload=t.MPNSNotificationPayload=t.APNSNotificationPayload=void 0;n(0);function r(e){return(r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function i(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],0<=t.indexOf(n)||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],0<=t.indexOf(n)||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable})),n.push.apply(n,r)}return n}function s(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?o(Object(n),!0).forEach(function(e){g(t,e,n[e])}):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach(function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))})}return t}function a(e,t){return!t||"object"!==r(t)&&"function"!=typeof t?c(e):t}function u(e){return(u=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function c(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function f(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&l(e,t)}function l(e,t){return(l=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function h(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function p(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function d(e,t,n){return t&&p(e.prototype,t),n&&p(e,n),e}function g(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var y=(d(v,[{key:"payload",get:function(){return this._payload}},{key:"title",set:function(e){this._title=e}},{key:"subtitle",set:function(e){this._subtitle=e}},{key:"body",set:function(e){this._body=e}},{key:"badge",set:function(e){this._badge=e}},{key:"sound",set:function(e){this._sound=e}}]),d(v,[{key:"_setDefaultPayloadStructure",value:function(){}},{key:"toObject",value:function(){return{}}}]),v);function v(e,t,n){h(this,v),g(this,"_subtitle",void 0),g(this,"_payload",void 0),g(this,"_badge",void 0),g(this,"_sound",void 0),g(this,"_title",void 0),g(this,"_body",void 0),this._payload=e,this._setDefaultPayloadStructure(),this.title=t,this.body=n}var b=(f(m,y),d(m,[{key:"_setDefaultPayloadStructure",value:function(){this._payload.aps={alert:{}}}},{key:"toObject",value:function(){var t=this,e=s({},this._payload),n=e.aps,r=n.alert;if(this._isSilent&&(n["content-available"]=1),"apns2"===this._apnsPushType){if(!this._configurations||!this._configurations.length)throw new ReferenceError("APNS2 configuration is missing");var i=[];this._configurations.forEach(function(e){i.push(t._objectFromAPNS2Configuration(e))}),i.length&&(e.pn_push=i)}return r&&Object.keys(r).length||delete n.alert,this._isSilent&&(delete n.alert,delete n.badge,delete n.sound,r={}),this._isSilent||Object.keys(r).length?e:null}},{key:"_objectFromAPNS2Configuration",value:function(e){var t=this;if(!e.targets||!e.targets.length)throw new ReferenceError("At least one APNS2 target should be provided");var n=[];e.targets.forEach(function(e){n.push(t._objectFromAPNSTarget(e))});var r=e.collapseId,i=e.expirationDate,o={auth_method:"token",targets:n,version:"v2"};return r&&r.length&&(o.collapse_id=r),i&&(o.expiration=i.toISOString()),o}},{key:"_objectFromAPNSTarget",value:function(e){if(!e.topic||!e.topic.length)throw new TypeError("Target 'topic' undefined.");var t=e.topic,n=e.environment,r=void 0===n?"development":n,i=e.excludedDevices,o=void 0===i?[]:i,s={topic:t,environment:r};return o.length&&(s.excluded_devices=o),s}},{key:"configurations",set:function(e){e&&e.length&&(this._configurations=e)}},{key:"notification",get:function(){return this._payload.aps}},{key:"title",get:function(){return this._title},set:function(e){e&&e.length&&(this._payload.aps.alert.title=e,this._title=e)}},{key:"subtitle",get:function(){return this._subtitle},set:function(e){e&&e.length&&(this._payload.aps.alert.subtitle=e,this._subtitle=e)}},{key:"body",get:function(){return this._body},set:function(e){e&&e.length&&(this._payload.aps.alert.body=e,this._body=e)}},{key:"badge",get:function(){return this._badge},set:function(e){null!=e&&(this._payload.aps.badge=e,this._badge=e)}},{key:"sound",get:function(){return this._sound},set:function(e){e&&e.length&&(this._payload.aps.sound=e,this._sound=e)}},{key:"silent",set:function(e){this._isSilent=e}}]),m);function m(){var e,t;h(this,m);for(var n=arguments.length,r=new Array(n),i=0;i<n;i++)r[i]=arguments[i];return g(c(t=a(this,(e=u(m)).call.apply(e,[this].concat(r)))),"_configurations",void 0),g(c(t),"_apnsPushType",void 0),g(c(t),"_isSilent",void 0),t}t.APNSNotificationPayload=b;var _=(f(k,y),d(k,[{key:"toObject",value:function(){return Object.keys(this._payload).length?s({},this._payload):null}},{key:"backContent",get:function(){return this._backContent},set:function(e){e&&e.length&&(this._payload.back_content=e,this._backContent=e)}},{key:"backTitle",get:function(){return this._backTitle},set:function(e){e&&e.length&&(this._payload.back_title=e,this._backTitle=e)}},{key:"count",get:function(){return this._count},set:function(e){null!=e&&(this._payload.count=e,this._count=e)}},{key:"title",get:function(){return this._title},set:function(e){e&&e.length&&(this._payload.title=e,this._title=e)}},{key:"type",get:function(){return this._type},set:function(e){e&&e.length&&(this._payload.type=e,this._type=e)}},{key:"subtitle",get:function(){return this.backTitle},set:function(e){this.backTitle=e}},{key:"body",get:function(){return this.backContent},set:function(e){this.backContent=e}},{key:"badge",get:function(){return this.count},set:function(e){this.count=e}}]),k);function k(){var e,t;h(this,k);for(var n=arguments.length,r=new Array(n),i=0;i<n;i++)r[i]=arguments[i];return g(c(t=a(this,(e=u(k)).call.apply(e,[this].concat(r)))),"_backContent",void 0),g(c(t),"_backTitle",void 0),g(c(t),"_count",void 0),g(c(t),"_type",void 0),t}t.MPNSNotificationPayload=_;var P=(f(w,y),d(w,[{key:"_setDefaultPayloadStructure",value:function(){this._payload.notification={},this._payload.data={}}},{key:"toObject",value:function(){var e=s({},this._payload.data),t=null,n={};if(2<Object.keys(this._payload).length){var r=this._payload;r.notification,r.data,e=s({},e,{},i(r,["notification","data"]))}return this._isSilent?e.notification=this._payload.notification:t=this._payload.notification,Object.keys(e).length&&(n.data=e),t&&Object.keys(t).length&&(n.notification=t),Object.keys(n).length?n:null}},{key:"notification",get:function(){return this._payload.notification}},{key:"data",get:function(){return this._payload.data}},{key:"title",get:function(){return this._title},set:function(e){e&&e.length&&(this._payload.notification.title=e,this._title=e)}},{key:"body",get:function(){return this._body},set:function(e){e&&e.length&&(this._payload.notification.body=e,this._body=e)}},{key:"sound",get:function(){return this._sound},set:function(e){e&&e.length&&(this._payload.notification.sound=e,this._sound=e)}},{key:"icon",get:function(){return this._icon},set:function(e){e&&e.length&&(this._payload.notification.icon=e,this._icon=e)}},{key:"tag",get:function(){return this._tag},set:function(e){e&&e.length&&(this._payload.notification.tag=e,this._tag=e)}},{key:"silent",set:function(e){this._isSilent=e}}]),w);function w(){var e,t;h(this,w);for(var n=arguments.length,r=new Array(n),i=0;i<n;i++)r[i]=arguments[i];return g(c(t=a(this,(e=u(w)).call.apply(e,[this].concat(r)))),"_isSilent",void 0),g(c(t),"_icon",void 0),g(c(t),"_tag",void 0),t}function T(e,t){h(this,T),g(this,"_payload",void 0),g(this,"_debugging",void 0),g(this,"_subtitle",void 0),g(this,"_badge",void 0),g(this,"_sound",void 0),g(this,"_title",void 0),g(this,"_body",void 0),g(this,"apns",void 0),g(this,"mpns",void 0),g(this,"fcm",void 0),this._payload={apns:{},mpns:{},fcm:{}},this._title=e,this._body=t,this.apns=new b(this._payload.apns,e,t),this.mpns=new _(this._payload.mpns,e,t),this.fcm=new P(this._payload.fcm,e,t)}t.FCMNotificationPayload=P;var O=(d(T,[{key:"debugging",set:function(e){this._debugging=e}},{key:"title",get:function(){return this._title}},{key:"body",get:function(){return this._body}},{key:"subtitle",get:function(){return this._subtitle},set:function(e){this._subtitle=e,this.apns.subtitle=e,this.mpns.subtitle=e,this.fcm.subtitle=e}},{key:"badge",get:function(){return this._badge},set:function(e){this._badge=e,this.apns.badge=e,this.mpns.badge=e,this.fcm.badge=e}},{key:"sound",get:function(){return this._sound},set:function(e){this._sound=e,this.apns.sound=e,this.mpns.sound=e,this.fcm.sound=e}}]),d(T,[{key:"buildPayload",value:function(e){var t={};if(e.includes("apns")||e.includes("apns2")){this.apns._apnsPushType=e.includes("apns")?"apns":"apns2";var n=this.apns.toObject();n&&Object.keys(n).length&&(t.pn_apns=n)}if(e.includes("mpns")){var r=this.mpns.toObject();r&&Object.keys(r).length&&(t.pn_mpns=r)}if(e.includes("fcm")){var i=this.fcm.toObject();i&&Object.keys(i).length&&(t.pn_gcm=i)}return Object.keys(t).length&&this._debugging&&(t.pn_debug=!0),t}}]),T);t.default=O},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var r;(r=n(3))&&r.__esModule,n(0);function i(e){return(i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function o(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var a,u,c,f=(a=l,(u=[{key:"_initializeTokens",value:function(){this._userTokens={},this._spaceTokens={},this._userToken=void 0,this._spaceToken=void 0}},{key:"_setToken",value:function(t){var n=this,e=this.parseToken(t);e&&e.resources&&(e.resources.users&&Object.keys(e.resources.users).forEach(function(e){n._userTokens[e]=t}),e.resources.spaces&&Object.keys(e.resources.spaces).forEach(function(e){n._spaceTokens[e]=t})),e&&e.patterns&&(e.patterns.users&&0<Object.keys(e.patterns.users).length&&(this._userToken=t),e.patterns.spaces&&0<Object.keys(e.patterns.spaces).length&&(this._spaceToken=t))}},{key:"setToken",value:function(e){e&&0<e.length&&this._setToken(e)}},{key:"setTokens",value:function(e){var t=this;e&&e.length&&"object"===i(e)&&e.forEach(function(e){t.setToken(e)})}},{key:"getTokens",value:function(e){var t=this,n={users:{},spaces:{}};return e?(e.user&&(n.user=this._userToken),e.space&&(n.space=this._spaceToken),e.users&&e.users.forEach(function(e){n.users[e]=t._userTokens[e]}),e.space&&e.spaces.forEach(function(e){n.spaces[e]=t._spaceTokens[e]})):(this._userToken&&(n.user=this._userToken),this._spaceToken&&(n.space=this._spaceToken),Object.keys(this._userTokens).forEach(function(e){n.users[e]=t._userTokens[e]}),Object.keys(this._spaceTokens).forEach(function(e){n.spaces[e]=t._spaceTokens[e]})),n}},{key:"getToken",value:function(e,t){var n;return t?"user"===e?n=this._userTokens[t]:"space"===e&&(n=this._spaceTokens[t]):"user"===e?n=this._userToken:"space"===e&&(n=this._spaceToken),n}},{key:"extractPermissions",value:function(e){var t={create:!1,read:!1,write:!1,manage:!1,delete:!1};return 16==(16&e)&&(t.create=!0),8==(8&e)&&(t.delete=!0),4==(4&e)&&(t.manage=!0),2==(2&e)&&(t.write=!0),1==(1&e)&&(t.read=!0),t}},{key:"parseToken",value:function(e){var t=this,n=this._cbor.decodeToken(e);if(void 0!==n){var r=Object.keys(n.res.usr),i=Object.keys(n.res.spc),o=Object.keys(n.pat.usr),s=Object.keys(n.pat.spc),a={version:n.v,timestamp:n.t,ttl:n.ttl},u=0<r.length,c=0<i.length;(u||c)&&(a.resources={},u&&(a.resources.users={},r.forEach(function(e){a.resources.users[e]=t.extractPermissions(n.res.usr[e])})),c&&(a.resources.spaces={},i.forEach(function(e){a.resources.spaces[e]=t.extractPermissions(n.res.spc[e])})));var f=0<o.length,l=0<s.length;return(f||l)&&(a.patterns={},f&&(a.patterns.users={},o.forEach(function(e){a.patterns.users[e]=t.extractPermissions(n.pat.usr[e])})),l&&(a.patterns.spaces={},s.forEach(function(e){a.patterns.spaces[e]=t.extractPermissions(n.pat.spc[e])}))),0<Object.keys(n.meta).length&&(a.meta=n.meta),a.signature=n.sig,a}}},{key:"clearTokens",value:function(){this._initializeTokens()}}])&&o(a.prototype,u),void(c&&o(a,c)),l);function l(e,t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,l),s(this,"_config",void 0),s(this,"_cbor",void 0),s(this,"_userTokens",void 0),s(this,"_spaceTokens",void 0),s(this,"_userToken",void 0),s(this,"_spaceToken",void 0),this._config=e,this._cbor=t,this._initializeTokens()}t.default=f,e.exports=t.default},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(r,i){var e=r.networking,t=r.config,o=null,s=null,a={};o=i.getOperation()===b.default.PNTimeOperation||i.getOperation()===b.default.PNChannelGroupsOperation?arguments.length<=2?void 0:arguments[2]:(a=arguments.length<=2?void 0:arguments[2],arguments.length<=3?void 0:arguments[3]);"undefined"==typeof Promise||o||(s=v.default.createPromise());var n=i.validateParams(r,a);if(n)return o?o(_(n)):s?(s.reject(new m("Validation failed, check status for details",_(n))),s.promise):void 0;var u,c=i.prepareParams(r,a),f=function(e,t,n){return e.usePost&&e.usePost(t,n)?e.postURL(t,n):e.usePatch&&e.usePatch(t,n)?e.patchURL(t,n):e.getURL(t,n)}(i,r,a),l={url:f,operation:i.getOperation(),timeout:i.getRequestTimeout(r),headers:i.getRequestHeaders?i.getRequestHeaders():{}};c.uuid=t.UUID,c.pnsdk=function(e){if(e.sdkName)return e.sdkName;var t="PubNub-JS-".concat(e.sdkFamily);e.partnerId&&(t+="-".concat(e.partnerId));t+="/".concat(e.getVersion());var n=e._getPnsdkSuffix(" ");0<n.length&&(t+=n);return t}(t),t.useInstanceId&&(c.instanceid=t.instanceId);t.useRequestId&&(c.requestid=y.default.createUUID());if(i.isAuthSupported()){var h=function(e,t,n){var r;e.getAuthToken&&(r=e.getAuthToken(t,n));return r}(i,r,a)||t.getAuthKey();h&&(c.auth=h)}t.secretKey&&function(e,t,n,r,i){var o=e.config,s=e.crypto,a=k(e,i,r);n.timestamp=Math.floor((new Date).getTime()/1e3);var u="".concat(a,"\n").concat(o.publishKey,"\n").concat(t,"\n").concat(v.default.signPamFromParams(n),"\n");if("POST"===a){var c=i.postPayload(e,r);u+="string"==typeof c?c:JSON.stringify(c)}else if("PATCH"===a){var f=i.patchPayload(e,r);u+="string"==typeof f?f:JSON.stringify(f)}var l="v2.".concat(s.HMACSHA256(u));l=(l=(l=l.replace(/\+/g,"-")).replace(/\//g,"_")).replace(/=+$/,""),n.signature=l}(r,f,c,a,i);function p(e,t){if(e.error)o?o(e):s&&s.reject(new m("PubNub call failed, check status for details",e));else{var n=i.handleResponse(r,t,a);o?o(e,n):s&&s.fulfill(n)}}if("POST"===k(r,i,a)){var d=i.postPayload(r,a);u=e.POST(c,d,l,p)}else if("PATCH"===k(r,i,a)){var g=i.patchPayload(r,a);u=e.PATCH(c,g,l,p)}else u="DELETE"===k(r,i,a)?e.DELETE(c,l,p):e.GET(c,l,p);if(i.getOperation()===b.default.PNSubscribeOperation)return u;if(s)return s.promise};var y=r(n(5)),v=(n(0),r(n(2))),b=(r(n(3)),r(n(1)));function r(e){return e&&e.__esModule?e:{default:e}}function i(e){return(i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function o(e,t){return!t||"object"!==i(t)&&"function"!=typeof t?function(e){if(void 0!==e)return e;throw new ReferenceError("this hasn't been initialised - super() hasn't been called")}(e):t}function s(e){var n="function"==typeof Map?new Map:void 0;return(s=function(e){if(null===e||!function(e){return-1!==Function.toString.call(e).indexOf("[native code]")}(e))return e;if("function"!=typeof e)throw new TypeError("Super expression must either be null or a function");if(void 0!==n){if(n.has(e))return n.get(e);n.set(e,t)}function t(){return a(e,arguments,c(this).constructor)}return t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),u(t,e)})(e)}function a(e,t,n){return(a=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],function(){})),!0}catch(e){return!1}}()?Reflect.construct:function(e,t,n){var r=[null];r.push.apply(r,t);var i=new(Function.bind.apply(e,r));return n&&u(i,n.prototype),i}).apply(null,arguments)}function u(e,t){return(u=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function c(e){return(c=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var m=(function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&u(e,t)}(f,s(Error)),f);function f(e,t){var n;return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,f),(n=o(this,c(f).call(this,e))).name=n.constructor.name,n.status=t,n.message=e,n}function _(e){return function(e,t){return e.type=t,e.error=!0,e}({message:e},"validationError")}function k(e,t,n){return t.usePost&&t.usePost(e,n)?"POST":t.usePatch&&t.usePatch(e,n)?"PATCH":t.useDelete&&t.useDelete(e,n)?"DELETE":"GET"}e.exports=t.default},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNAddChannelsToGroupOperation},t.validateParams=function(e,t){var n=t.channels,r=t.channelGroup,i=e.config;if(!r)return"Missing Channel Group";if(!n||0===n.length)return"Missing Channels";if(!i.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=t.channelGroup,r=e.config;return"/v1/channel-registration/sub-key/".concat(r.subscribeKey,"/channel-group/").concat(i.default.encodeString(n))},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.channels;return{add:(void 0===n?[]:n).join(",")}},t.handleResponse=function(){return{}};n(0);var r=o(n(1)),i=o(n(2));function o(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNRemoveChannelsFromGroupOperation},t.validateParams=function(e,t){var n=t.channels,r=t.channelGroup,i=e.config;if(!r)return"Missing Channel Group";if(!n||0===n.length)return"Missing Channels";if(!i.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=t.channelGroup,r=e.config;return"/v1/channel-registration/sub-key/".concat(r.subscribeKey,"/channel-group/").concat(i.default.encodeString(n))},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.channels;return{remove:(void 0===n?[]:n).join(",")}},t.handleResponse=function(){return{}};n(0);var r=o(n(1)),i=o(n(2));function o(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNRemoveGroupOperation},t.validateParams=function(e,t){var n=t.channelGroup,r=e.config;if(!n)return"Missing Channel Group";if(!r.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=t.channelGroup,r=e.config;return"/v1/channel-registration/sub-key/".concat(r.subscribeKey,"/channel-group/").concat(i.default.encodeString(n),"/remove")},t.isAuthSupported=function(){return!0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.prepareParams=function(){return{}},t.handleResponse=function(){return{}};n(0);var r=o(n(1)),i=o(n(2));function o(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNChannelGroupsOperation},t.validateParams=function(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e){var t=e.config;return"/v1/channel-registration/sub-key/".concat(t.subscribeKey,"/channel-group")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(){return{}},t.handleResponse=function(e,t){return{groups:t.payload.groups}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNChannelsForGroupOperation},t.validateParams=function(e,t){var n=t.channelGroup,r=e.config;if(!n)return"Missing Channel Group";if(!r.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=t.channelGroup,r=e.config;return"/v1/channel-registration/sub-key/".concat(r.subscribeKey,"/channel-group/").concat(i.default.encodeString(n))},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(){return{}},t.handleResponse=function(e,t){return{channels:t.payload.channels}};n(0);var r=o(n(1)),i=o(n(2));function o(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNPushNotificationEnabledChannelsOperation},t.validateParams=function(e,t){var n=t.device,r=t.pushGateway,i=t.channels,o=t.topic,s=e.config;if(!n)return"Missing Device ID (device)";if(!r)return"Missing GW Type (pushGateway: gcm, apns or apns2)";if("apns2"===r&&!o)return"Missing APNS2 topic";if(!i||0===i.length)return"Missing Channels";if(!s.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=t.device,r=t.pushGateway,i=e.config;return"apns2"!==r?"/v1/push/sub-key/".concat(i.subscribeKey,"/devices/").concat(n):"/v2/push/sub-key/".concat(i.subscribeKey,"/devices-apns2/").concat(n)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.pushGateway,r=t.channels,i=void 0===r?[]:r,o=t.environment,s=void 0===o?"development":o,a=t.topic,u={type:n,add:i.join(",")};"apns2"===n&&delete(u=Object.assign({},u,{environment:s,topic:a})).type;return u},t.handleResponse=function(){return{}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNPushNotificationEnabledChannelsOperation},t.validateParams=function(e,t){var n=t.device,r=t.pushGateway,i=t.channels,o=t.topic,s=e.config;if(!n)return"Missing Device ID (device)";if(!r)return"Missing GW Type (pushGateway: gcm, apns or apns2)";if("apns2"===r&&!o)return"Missing APNS2 topic";if(!i||0===i.length)return"Missing Channels";if(!s.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=t.device,r=t.pushGateway,i=e.config;return"apns2"!==r?"/v1/push/sub-key/".concat(i.subscribeKey,"/devices/").concat(n):"/v2/push/sub-key/".concat(i.subscribeKey,"/devices-apns2/").concat(n)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.pushGateway,r=t.channels,i=void 0===r?[]:r,o=t.environment,s=void 0===o?"development":o,a=t.topic,u={type:n,remove:i.join(",")};"apns2"===n&&delete(u=Object.assign({},u,{environment:s,topic:a})).type;return u},t.handleResponse=function(){return{}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNPushNotificationEnabledChannelsOperation},t.validateParams=function(e,t){var n=t.device,r=t.pushGateway,i=t.topic,o=e.config;if(!n)return"Missing Device ID (device)";if(!r)return"Missing GW Type (pushGateway: gcm, apns or apns2)";if("apns2"===r&&!i)return"Missing APNS2 topic";if(!o.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=t.device,r=t.pushGateway,i=e.config;return"apns2"!==r?"/v1/push/sub-key/".concat(i.subscribeKey,"/devices/").concat(n):"/v2/push/sub-key/".concat(i.subscribeKey,"/devices-apns2/").concat(n)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.pushGateway,r=t.environment,i=void 0===r?"development":r,o=t.topic,s={type:n};"apns2"===n&&delete(s=Object.assign({},s,{environment:i,topic:o})).type;return s},t.handleResponse=function(e,t){return{channels:t}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNRemoveAllPushNotificationsOperation},t.validateParams=function(e,t){var n=t.device,r=t.pushGateway,i=t.topic,o=e.config;if(!n)return"Missing Device ID (device)";if(!r)return"Missing GW Type (pushGateway: gcm, apns or apns2)";if("apns2"===r&&!i)return"Missing APNS2 topic";if(!o.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=t.device,r=t.pushGateway,i=e.config;return"apns2"!==r?"/v1/push/sub-key/".concat(i.subscribeKey,"/devices/").concat(n,"/remove"):"/v2/push/sub-key/".concat(i.subscribeKey,"/devices-apns2/").concat(n,"/remove")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.pushGateway,r=t.environment,i=void 0===r?"development":r,o=t.topic,s={type:n};"apns2"===n&&delete(s=Object.assign({},s,{environment:i,topic:o})).type;return s},t.handleResponse=function(){return{}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNUnsubscribeOperation},t.validateParams=function(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=e.config,r=t.channels,i=void 0===r?[]:r,o=0<i.length?i.join(","):",";return"/v2/presence/sub-key/".concat(n.subscribeKey,"/channel/").concat(s.default.encodeString(o),"/leave")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.channelGroups,r=void 0===n?[]:n,i={};0<r.length&&(i["channel-group"]=r.join(","));return i},t.handleResponse=function(){return{}};n(0);var r=i(n(1)),s=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNWhereNowOperation},t.validateParams=function(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=e.config,r=t.uuid,i=void 0===r?n.UUID:r;return"/v2/presence/sub-key/".concat(n.subscribeKey,"/uuid/").concat(i)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(){return{}},t.handleResponse=function(e,t){return t.payload?{channels:t.payload.channels}:{channels:[]}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNHeartbeatOperation},t.validateParams=function(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=e.config,r=t.channels,i=void 0===r?[]:r,o=0<i.length?i.join(","):",";return"/v2/presence/sub-key/".concat(n.subscribeKey,"/channel/").concat(s.default.encodeString(o),"/heartbeat")},t.isAuthSupported=function(){return!0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.prepareParams=function(e,t){var n=t.channelGroups,r=void 0===n?[]:n,i=t.state,o=void 0===i?{}:i,s=e.config,a={};0<r.length&&(a["channel-group"]=r.join(","));return a.state=JSON.stringify(o),a.heartbeat=s.getPresenceTimeout(),a},t.handleResponse=function(){return{}};n(0);var r=i(n(1)),s=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNGetStateOperation},t.validateParams=function(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=e.config,r=t.uuid,i=void 0===r?n.UUID:r,o=t.channels,s=void 0===o?[]:o,a=0<s.length?s.join(","):",";return"/v2/presence/sub-key/".concat(n.subscribeKey,"/channel/").concat(u.default.encodeString(a),"/uuid/").concat(i)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.channelGroups,r=void 0===n?[]:n,i={};0<r.length&&(i["channel-group"]=r.join(","));return i},t.handleResponse=function(e,t,n){var r=n.channels,i=void 0===r?[]:r,o=n.channelGroups,s=void 0===o?[]:o,a={};1===i.length&&0===s.length?a[i[0]]=t.payload:a=t.payload;return{channels:a}};n(0);var r=i(n(1)),u=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNSetStateOperation},t.validateParams=function(e,t){var n=e.config,r=t.state,i=t.channels,o=void 0===i?[]:i,s=t.channelGroups,a=void 0===s?[]:s;if(!r)return"Missing State";if(!n.subscribeKey)return"Missing Subscribe Key";if(0===o.length&&0===a.length)return"Please provide a list of channels and/or channel-groups"},t.getURL=function(e,t){var n=e.config,r=t.channels,i=void 0===r?[]:r,o=0<i.length?i.join(","):",";return"/v2/presence/sub-key/".concat(n.subscribeKey,"/channel/").concat(s.default.encodeString(o),"/uuid/").concat(n.UUID,"/data")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.state,r=t.channelGroups,i=void 0===r?[]:r,o={};o.state=JSON.stringify(n),0<i.length&&(o["channel-group"]=i.join(","));return o},t.handleResponse=function(e,t){return{state:t.payload}};n(0);var r=i(n(1)),s=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNHereNowOperation},t.validateParams=function(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=e.config,r=t.channels,i=void 0===r?[]:r,o=t.channelGroups,s=void 0===o?[]:o,a="/v2/presence/sub-key/".concat(n.subscribeKey);if(0<i.length||0<s.length){var u=0<i.length?i.join(","):",";a+="/channel/".concat(c.default.encodeString(u))}return a},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.channelGroups,r=void 0===n?[]:n,i=t.includeUUIDs,o=void 0===i||i,s=t.includeState,a=void 0!==s&&s,u={};o||(u.disable_uuids=1);a&&(u.state=1);0<r.length&&(u["channel-group"]=r.join(","));return u},t.handleResponse=function(e,i,t){var n,r=t.channels,o=void 0===r?[]:r,s=t.channelGroups,a=void 0===s?[]:s,u=t.includeUUIDs,c=void 0===u||u,f=t.includeState,l=void 0!==f&&f;n=1<o.length||0<a.length||0===a.length&&0===o.length?function(){var r={};return r.totalChannels=i.payload.total_channels,r.totalOccupancy=i.payload.total_occupancy,r.channels={},Object.keys(i.payload.channels).forEach(function(e){var t=i.payload.channels[e],n=[];return r.channels[e]={occupants:n,name:e,occupancy:t.occupancy},c&&t.uuids.forEach(function(e){l?n.push({state:e.state,uuid:e.uuid}):n.push({state:null,uuid:e})}),r}),r}():function(){var e={},t=[];return e.totalChannels=1,e.totalOccupancy=i.occupancy,e.channels={},e.channels[o[0]]={occupants:t,name:o[0],occupancy:i.occupancy},c&&i.uuids&&i.uuids.forEach(function(e){l?t.push({state:e.state,uuid:e.uuid}):t.push({state:null,uuid:e})}),e}();return n};n(0);var r=i(n(1)),c=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNAddMessageActionOperation},t.validateParams=function(e,t){var n=e.config,r=t.action,i=t.channel;if(!t.messageTimetoken)return"Missing message timetoken";if(!n.subscribeKey)return"Missing Subscribe Key";if(!i)return"Missing message channel";if(!r)return"Missing Action";if(!r.value)return"Missing Action.value";if(!r.type)return"Missing Action.type";if(15<r.type.length)return"Action.type value exceed maximum length of 15"},t.usePost=function(){return!0},t.postURL=function(e,t){var n=e.config,r=t.channel,i=t.messageTimetoken;return"/v1/message-actions/".concat(n.subscribeKey,"/channel/").concat(r,"/message/").concat(i)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.getRequestHeaders=function(){return{"Content-Type":"application/json"}},t.isAuthSupported=function(){return!0},t.prepareParams=function(){return{}},t.postPayload=function(e,t){return t.action},t.handleResponse=function(e,t){return{data:t.data}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNRemoveMessageActionOperation},t.validateParams=function(e,t){var n=e.config,r=t.channel,i=t.actionTimetoken;if(!t.messageTimetoken)return"Missing message timetoken";if(!i)return"Missing action timetoken";if(!n.subscribeKey)return"Missing Subscribe Key";if(!r)return"Missing message channel"},t.useDelete=function(){return!0},t.getURL=function(e,t){var n=e.config,r=t.channel,i=t.actionTimetoken,o=t.messageTimetoken;return"/v1/message-actions/".concat(n.subscribeKey,"/channel/").concat(r,"/message/").concat(o,"/action/").concat(i)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(){return{}},t.handleResponse=function(e,t){return{data:t.data}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNGetMessageActionsOperation},t.validateParams=function(e,t){var n=e.config,r=t.channel;if(!n.subscribeKey)return"Missing Subscribe Key";if(!r)return"Missing message channel"},t.getURL=function(e,t){var n=e.config,r=t.channel;return"/v1/message-actions/".concat(n.subscribeKey,"/channel/").concat(r)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.limit,r=t.start,i=t.end,o={};n&&(o.limit=n);r&&(o.start=r);i&&(o.end=i);return o},t.handleResponse=function(e,t){var n={data:t.data,start:null,end:null};n.data.length&&(n.end=n.data[n.data.length-1].actionTimetoken,n.start=n.data[0].actionTimetoken);return n};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNCreateUserOperation},t.validateParams=function(e,t){var n=e.config,r=t.id,i=t.name,o=t.custom;if(!r)return"Missing User.id";if(!i)return"Missing User.name";if(!n.subscribeKey)return"Missing Subscribe Key";if(o&&!Object.values(o).every(function(e){return"string"==typeof e||"number"==typeof e||"boolean"==typeof e}))return"Invalid custom type, only string, number and boolean values are allowed."},t.usePost=function(){return!0},t.getURL=function(e){var t=e.config;return"/v1/objects/".concat(t.subscribeKey,"/users")},t.postURL=function(e){var t=e.config;return"/v1/objects/".concat(t.subscribeKey,"/users")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("user",t.id)||e.tokenManager.getToken("user")},t.prepareParams=function(e,t){var n=t.include,r={};n?void 0===n.customFields&&(n.customFields=!0):n={customFields:!0};if(n){var i=[];n.customFields&&i.push("custom");var o=i.join(",");0<o.length&&(r.include=o)}return r},t.postPayload=function(e,t){return function(e,t){return t}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNUpdateUserOperation},t.validateParams=function(e,t){var n=e.config,r=t.id,i=t.name,o=t.custom;if(!r)return"Missing User.id";if(!i)return"Missing User.name";if(!n.subscribeKey)return"Missing Subscribe Key";if(o&&!Object.values(o).every(function(e){return"string"==typeof e||"number"==typeof e||"boolean"==typeof e}))return"Invalid custom type, only string, number and boolean values are allowed."},t.usePatch=function(){return!0},t.getURL=function(e,t){var n=e.config,r=t.id;return"/v1/objects/".concat(n.subscribeKey,"/users/").concat(r)},t.patchURL=function(e,t){var n=e.config,r=t.id;return"/v1/objects/".concat(n.subscribeKey,"/users/").concat(r)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("user",t.id)||e.tokenManager.getToken("user")},t.prepareParams=function(e,t){var n=t.include,r={};n?void 0===n.customFields&&(n.customFields=!0):n={customFields:!0};if(n){var i=[];n.customFields&&i.push("custom");var o=i.join(",");0<o.length&&(r.include=o)}return r},t.patchPayload=function(e,t){return function(e,t){return t}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNDeleteUserOperation},t.validateParams=function(e,t){var n=e.config;if(!t)return"Missing UserId";if(!n.subscribeKey)return"Missing Subscribe Key"},t.useDelete=function(){return!0},t.getURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/users/").concat(t)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("user",t)||e.tokenManager.getToken("user")},t.prepareParams=function(){return{}},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNGetUserOperation},t.validateParams=function(e,t){if(!t.userId)return"Missing userId"},t.getURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/users/").concat(t.userId)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("user",t.userId)||e.tokenManager.getToken("user")},t.prepareParams=function(e,t){var n=t.include,r={};n?void 0===n.customFields&&(n.customFields=!0):n={customFields:!0};if(n){var i=[];n.customFields&&i.push("custom");var o=i.join(",");0<o.length&&(r.include=o)}return r},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNGetUsersOperation},t.validateParams=function(){},t.getURL=function(e){var t=e.config;return"/v1/objects/".concat(t.subscribeKey,"/users")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e){return e.tokenManager.getToken("user")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom");var a=s.join(",");0<a.length&&(o.include=a)}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNCreateSpaceOperation},t.validateParams=function(e,t){var n=e.config,r=t.id,i=t.name,o=t.custom;if(!r)return"Missing Space.id";if(!i)return"Missing Space.name";if(!n.subscribeKey)return"Missing Subscribe Key";if(o&&!Object.values(o).every(function(e){return"string"==typeof e||"number"==typeof e||"boolean"==typeof e}))return"Invalid custom type, only string, number and boolean values are allowed."},t.usePost=function(){return!0},t.getURL=function(e){var t=e.config;return"/v1/objects/".concat(t.subscribeKey,"/spaces")},t.postURL=function(e){var t=e.config;return"/v1/objects/".concat(t.subscribeKey,"/spaces")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("space",t.id)||e.tokenManager.getToken("space")},t.prepareParams=function(e,t){var n=t.include,r={};n?void 0===n.customFields&&(n.customFields=!0):n={customFields:!0};if(n){var i=[];n.customFields&&i.push("custom");var o=i.join(",");0<o.length&&(r.include=o)}return r},t.postPayload=function(e,t){return function(e,t){return t}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNUpdateSpaceOperation},t.validateParams=function(e,t){var n=e.config,r=t.id,i=t.name,o=t.custom;if(!r)return"Missing Space.id";if(!i)return"Missing Space.name";if(!n.subscribeKey)return"Missing Subscribe Key";if(o&&!Object.values(o).every(function(e){return"string"==typeof e||"number"==typeof e||"boolean"==typeof e}))return"Invalid custom type, only string, number and boolean values are allowed."},t.usePatch=function(){return!0},t.getURL=function(e,t){var n=e.config,r=t.id;return"/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(r)},t.patchURL=function(e,t){var n=e.config,r=t.id;return"/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(r)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("space",t.id)||e.tokenManager.getToken("space")},t.prepareParams=function(e,t){var n=t.include,r={};n?void 0===n.customFields&&(n.customFields=!0):n={customFields:!0};if(n){var i=[];n.customFields&&i.push("custom");var o=i.join(",");0<o.length&&(r.include=o)}return r},t.patchPayload=function(e,t){return function(e,t){return t}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNDeleteSpaceOperation},t.validateParams=function(e,t){var n=e.config;if(!t)return"Missing SpaceId";if(!n.subscribeKey)return"Missing Subscribe Key"},t.useDelete=function(){return!0},t.getURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("space",t)||e.tokenManager.getToken("space")},t.prepareParams=function(){return{}},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNGetSpacesOperation},t.validateParams=function(){},t.getURL=function(e){var t=e.config;return"/v1/objects/".concat(t.subscribeKey,"/spaces")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e){return e.tokenManager.getToken("space")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom");var a=s.join(",");0<a.length&&(o.include=a)}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNGetSpaceOperation},t.validateParams=function(e,t){if(!t.spaceId)return"Missing spaceId"},t.getURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t.spaceId)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("space",t.spaceId)||e.tokenManager.getToken("space")},t.prepareParams=function(e,t){var n=t.include,r={};n?void 0===n.customFields&&(n.customFields=!0):n={customFields:!0};if(n){var i=[];n.customFields&&i.push("custom");var o=i.join(",");0<o.length&&(r.include=o)}return r},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNGetMembersOperation},t.validateParams=function(e,t){if(!t.spaceId)return"Missing spaceId"},t.getURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t.spaceId,"/users")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("space",t.spaceId)||e.tokenManager.getToken("space")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom"),n.userFields&&s.push("user"),n.customUserFields&&s.push("user.custom");var a=s.join(",");0<a.length&&(o.include=a)}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNUpdateMembersOperation},t.validateParams=function(e,t){var n=t.spaceId,r=t.users;if(!n)return"Missing spaceId";if(!r)return"Missing users"},t.getURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t.spaceId,"/users")},t.patchURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t.spaceId,"/users")},t.usePatch=function(){return!0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("space",t.spaceId)||e.tokenManager.getToken("space")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom"),n.spaceFields&&s.push("space"),n.customSpaceFields&&s.push("space.custom");var a=s.join(",");0<a.length&&(o.include=a)}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.patchPayload=function(e,t){return function(e,t){var n=t.users,r={};n&&0<n.length&&(r.add=[],n.forEach(function(e){var t={id:e.id};e.custom&&(t.custom=e.custom),r.add.push(t)}));return r}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNUpdateMembersOperation},t.validateParams=function(e,t){var n=t.spaceId,r=t.users;if(!n)return"Missing spaceId";if(!r)return"Missing users"},t.getURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t.spaceId,"/users")},t.patchURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t.spaceId,"/users")},t.usePatch=function(){return!0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("space",t.spaceId)||e.tokenManager.getToken("space")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom"),n.spaceFields&&s.push("space"),n.customSpaceFields&&s.push("space.custom");var a=s.join(",");0<a.length&&(o.include=a)}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.patchPayload=function(e,t){return function(e,t){var n=t.addMembers,r=t.updateMembers,i=t.removeMembers,o=t.users,s={};n&&0<n.length&&(s.add=[],n.forEach(function(e){var t={id:e.id};e.custom&&(t.custom=e.custom),s.add.push(t)}));r&&0<r.length&&(s.update=[],r.forEach(function(e){var t={id:e.id};e.custom&&(t.custom=e.custom),s.update.push(t)}));o&&0<o.length&&(s.update=s.update||[],o.forEach(function(e){var t={id:e.id};e.custom&&(t.custom=e.custom),s.update.push(t)}));i&&0<i.length&&(s.remove=[],i.forEach(function(e){s.remove.push({id:e})}));return s}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNUpdateMembersOperation},t.validateParams=function(e,t){var n=t.spaceId,r=t.users;if(!n)return"Missing spaceId";if(!r)return"Missing users"},t.getURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t.spaceId,"/users")},t.patchURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t.spaceId,"/users")},t.usePatch=function(){return!0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("space",t.spaceId)||e.tokenManager.getToken("space")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom"),n.spaceFields&&s.push("space"),n.customSpaceFields&&s.push("space.custom");var a=s.join(",");0<a.length&&(o.include=a)}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.patchPayload=function(e,t){return function(e,t){var n=t.users,r={};n&&0<n.length&&(r.remove=[],n.forEach(function(e){r.remove.push({id:e})}));return r}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNGetMembershipsOperation},t.validateParams=function(e,t){if(!t.userId)return"Missing userId"},t.getURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/users/").concat(t.userId,"/spaces")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("user",t.userId)||e.tokenManager.getToken("user")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom"),n.spaceFields&&s.push("space"),n.customSpaceFields&&s.push("space.custom");var a=s.join(",");0<a.length&&(o.include=a)}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNUpdateMembershipsOperation},t.validateParams=function(e,t){var n=t.userId,r=t.spaces;if(!n)return"Missing userId";if(!r)return"Missing spaces"},t.getURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/users/").concat(t.userId,"/spaces")},t.patchURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/users/").concat(t.userId,"/spaces")},t.usePatch=function(){return!0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("user",t.userId)||e.tokenManager.getToken("user")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom"),n.spaceFields&&s.push("space"),n.customSpaceFields&&s.push("space.custom");var a=s.join(",");0<a.length&&(o.include=a)}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.patchPayload=function(e,t){return function(e,t){var n=t.addMemberships,r=t.updateMemberships,i=t.removeMemberships,o=t.spaces,s={};n&&0<n.length&&(s.add=[],n.forEach(function(e){var t={id:e.id};e.custom&&(t.custom=e.custom),s.add.push(t)}));r&&0<r.length&&(s.update=[],r.forEach(function(e){var t={id:e.id};e.custom&&(t.custom=e.custom),s.update.push(t)}));o&&0<o.length&&(s.update=s.update||[],o.forEach(function(e){var t={id:e.id};e.custom&&(t.custom=e.custom),s.update.push(t)}));i&&0<i.length&&(s.remove=[],i.forEach(function(e){s.remove.push({id:e})}));return s}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNUpdateMembershipsOperation},t.validateParams=function(e,t){var n=t.userId,r=t.spaces;if(!n)return"Missing userId";if(!r)return"Missing spaces"},t.getURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/users/").concat(t.userId,"/spaces")},t.patchURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/users/").concat(t.userId,"/spaces")},t.usePatch=function(){return!0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("user",t.userId)||e.tokenManager.getToken("user")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom"),n.spaceFields&&s.push("space"),n.customSpaceFields&&s.push("space.custom");var a=s.join(",");0<a.length&&(o.include=a)}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.patchPayload=function(e,t){return function(e,t){var n=t.spaces,r={};n&&0<n.length&&(r.add=[],n.forEach(function(e){var t={id:e.id};e.custom&&(t.custom=e.custom),r.add.push(t)}));return r}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNUpdateMembershipsOperation},t.validateParams=function(e,t){var n=t.userId,r=t.spaces;if(!n)return"Missing userId";if(!r)return"Missing spaces"},t.getURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/users/").concat(t.userId,"/spaces")},t.patchURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/users/").concat(t.userId,"/spaces")},t.usePatch=function(){return!0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("user",t.userId)||e.tokenManager.getToken("user")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom"),n.spaceFields&&s.push("space"),n.customSpaceFields&&s.push("space.custom");var a=s.join(",");0<a.length&&(o.include=a)}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.patchPayload=function(e,t){return function(e,t){var n=t.spaces,r={};n&&0<n.length&&(r.remove=[],n.forEach(function(e){r.remove.push({id:e})}));return r}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNAccessManagerAudit},t.validateParams=function(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e){var t=e.config;return"/v2/auth/audit/sub-key/".concat(t.subscribeKey)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!1},t.prepareParams=function(e,t){var n=t.channel,r=t.channelGroup,i=t.authKeys,o=void 0===i?[]:i,s={};n&&(s.channel=n);r&&(s["channel-group"]=r);0<o.length&&(s.auth=o.join(","));return s},t.handleResponse=function(e,t){return t.payload};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNAccessManagerGrant},t.validateParams=function(e){var t=e.config;if(!t.subscribeKey)return"Missing Subscribe Key";if(!t.publishKey)return"Missing Publish Key";if(!t.secretKey)return"Missing Secret Key"},t.getURL=function(e){var t=e.config;return"/v2/auth/grant/sub-key/".concat(t.subscribeKey)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!1},t.prepareParams=function(e,t){var n=t.channels,r=void 0===n?[]:n,i=t.channelGroups,o=void 0===i?[]:i,s=t.ttl,a=t.read,u=void 0!==a&&a,c=t.write,f=void 0!==c&&c,l=t.manage,h=void 0!==l&&l,p=t.authKeys,d=void 0===p?[]:p,g={};g.r=u?"1":"0",g.w=f?"1":"0",g.m=h?"1":"0",0<r.length&&(g.channel=r.join(","));0<o.length&&(g["channel-group"]=o.join(","));0<d.length&&(g.auth=d.join(","));!s&&0!==s||(g.ttl=s);return g},t.handleResponse=function(){return{}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNAccessManagerGrantToken},t.extractPermissions=l,t.validateParams=function(e,t){var n=e.config;if(!n.subscribeKey)return"Missing Subscribe Key";if(!n.publishKey)return"Missing Publish Key";if(!n.secretKey)return"Missing Secret Key";if(!t.resources&&!t.patterns)return"Missing either Resources or Patterns.";if(t.resources&&(!t.resources.users||0===Object.keys(t.resources.users).length)&&(!t.resources.spaces||0===Object.keys(t.resources.spaces).length)||t.patterns&&(!t.patterns.users||0===Object.keys(t.patterns.users).length)&&(!t.patterns.spaces||0===Object.keys(t.patterns.spaces).length))return"Missing values for either Resources or Patterns."},t.postURL=function(e){var t=e.config;return"/v3/pam/".concat(t.subscribeKey,"/grant")},t.usePost=function(){return!0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!1},t.prepareParams=function(){return{}},t.postPayload=function(e,t){return function(e,t){var n=t.ttl,r=t.resources,i=t.patterns,o=t.meta,s={ttl:0,permissions:{resources:{channels:{},groups:{},users:{},spaces:{}},patterns:{channels:{},groups:{},users:{},spaces:{}},meta:{}}};if(r){var a=r.users,u=r.spaces;a&&Object.keys(a).forEach(function(e){s.permissions.resources.users[e]=l(a[e])}),u&&Object.keys(u).forEach(function(e){s.permissions.resources.spaces[e]=l(u[e])})}if(i){var c=i.users,f=i.spaces;c&&Object.keys(c).forEach(function(e){s.permissions.patterns.users[e]=l(c[e])}),f&&Object.keys(f).forEach(function(e){s.permissions.patterns.spaces[e]=l(f[e])})}!n&&0!==n||(s.ttl=n);o&&(s.permissions.meta=o);return s}(0,t)},t.handleResponse=function(e,t){return t.data.token};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};function l(e){var t=0;return e.create&&(t|=16),e.delete&&(t|=8),e.manage&&(t|=4),e.write&&(t|=2),e.read&&(t|=1),t}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNPublishOperation},t.validateParams=function(e,t){var n=e.config,r=t.message;if(!t.channel)return"Missing Channel";if(!r)return"Missing Message";if(!n.subscribeKey)return"Missing Subscribe Key"},t.usePost=function(e,t){var n=t.sendByPost;return void 0!==n&&n},t.getURL=function(e,t){var n=e.config,r=t.channel,i=t.message,o=a(e,i);return"/publish/".concat(n.publishKey,"/").concat(n.subscribeKey,"/0/").concat(s.default.encodeString(r),"/0/").concat(s.default.encodeString(o))},t.postURL=function(e,t){var n=e.config,r=t.channel;return"/publish/".concat(n.publishKey,"/").concat(n.subscribeKey,"/0/").concat(s.default.encodeString(r),"/0")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.postPayload=function(e,t){var n=t.message;return a(e,n)},t.prepareParams=function(e,t){var n=t.meta,r=t.replicate,i=void 0===r||r,o=t.storeInHistory,s=t.ttl,a={};null!=o&&(a.store=o?"1":"0");s&&(a.ttl=s);!1===i&&(a.norep="true");n&&"object"===u(n)&&(a.meta=JSON.stringify(n));return a},t.handleResponse=function(e,t){return{timetoken:t[2]}};n(0);var r=i(n(1)),s=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}function u(e){return(u="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function a(e,t){var n=e.crypto,r=e.config,i=JSON.stringify(t);return r.cipherKey&&(i=n.encrypt(i),i=JSON.stringify(i)),i}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNSignalOperation},t.validateParams=function(e,t){var n=e.config,r=t.message;if(!t.channel)return"Missing Channel";if(!r)return"Missing Message";if(!n.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=e.config,r=t.channel,i=t.message,o=function(e,t){return JSON.stringify(t)}(0,i);return"/signal/".concat(n.publishKey,"/").concat(n.subscribeKey,"/0/").concat(s.default.encodeString(r),"/0/").concat(s.default.encodeString(o))},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(){return{}},t.handleResponse=function(e,t){return{timetoken:t[2]}};n(0);var r=i(n(1)),s=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNHistoryOperation},t.validateParams=function(e,t){var n=t.channel,r=e.config;if(!n)return"Missing channel";if(!r.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=t.channel,r=e.config;return"/v2/history/sub-key/".concat(r.subscribeKey,"/channel/").concat(i.default.encodeString(n))},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.start,r=t.end,i=t.reverse,o=t.count,s=void 0===o?100:o,a=t.stringifiedTimeToken,u=void 0!==a&&a,c=t.includeMeta,f=void 0!==c&&c,l={include_token:"true"};l.count=s,n&&(l.start=n);r&&(l.end=r);u&&(l.string_message_token="true");null!=i&&(l.reverse=i.toString());f&&(l.include_meta="true");return l},t.handleResponse=function(n,e){var r={messages:[],startTimeToken:e[1],endTimeToken:e[2]};Array.isArray(e[0])&&e[0].forEach(function(e){var t={timetoken:e.timetoken,entry:function(e,t){var n=e.config,r=e.crypto;if(!n.cipherKey)return t;try{return r.decrypt(t)}catch(e){return t}}(n,e.message)};e.meta&&(t.meta=e.meta),r.messages.push(t)});return r};n(0);var r=o(n(1)),i=o(n(2));function o(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNDeleteMessagesOperation},t.validateParams=function(e,t){var n=t.channel,r=e.config;if(!n)return"Missing channel";if(!r.subscribeKey)return"Missing Subscribe Key"},t.useDelete=function(){return!0},t.getURL=function(e,t){var n=t.channel,r=e.config;return"/v3/history/sub-key/".concat(r.subscribeKey,"/channel/").concat(i.default.encodeString(n))},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.start,r=t.end,i={};n&&(i.start=n);r&&(i.end=r);return i},t.handleResponse=function(e,t){return t.payload};n(0);var r=o(n(1)),i=o(n(2));function o(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNMessageCounts},t.validateParams=function(e,t){var n=t.channels,r=t.timetoken,i=t.channelTimetokens,o=e.config;if(!n)return"Missing channel";if(r&&i)return"timetoken and channelTimetokens are incompatible together";if(r&&i&&1<i.length&&n.length!==i.length)return"Length of channelTimetokens and channels do not match";if(!o.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=t.channels,r=e.config,i=n.join(",");return"/v3/history/sub-key/".concat(r.subscribeKey,"/message-counts/").concat(o.default.encodeString(i))},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.timetoken,r=t.channelTimetokens,i={};if(r&&1===r.length){var o=function(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if(!(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e)))return;var n=[],r=!0,i=!1,o=void 0;try{for(var s,a=e[Symbol.iterator]();!(r=(s=a.next()).done)&&(n.push(s.value),!t||n.length!==t);r=!0);}catch(e){i=!0,o=e}finally{try{r||null==a.return||a.return()}finally{if(i)throw o}}return n}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}(r,1)[0];i.timetoken=o}else r?i.channelsTimetoken=r.join(","):n&&(i.timetoken=n);return i},t.handleResponse=function(e,t){return{channels:t.channels}};var r=i(n(1)),o=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNFetchMessagesOperation},t.validateParams=function(e,t){var n=t.channels,r=t.includeMessageActions,i=void 0!==r&&r,o=e.config;if(!n||0===n.length)return"Missing channels";if(!o.subscribeKey)return"Missing Subscribe Key";if(i&&1<n.length)throw new TypeError("History can return actions data for a single channel only. Either pass a single channel or disable the includeMessageActions flag.")},t.getURL=function(e,t){var n=t.channels,r=void 0===n?[]:n,i=t.includeMessageActions,o=void 0!==i&&i,s=e.config,a=o?"history-with-actions":"history",u=0<r.length?r.join(","):",";return"/v3/".concat(a,"/sub-key/").concat(s.subscribeKey,"/channel/").concat(c.default.encodeString(u))},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.start,r=t.end,i=t.count,o=t.stringifiedTimeToken,s=void 0!==o&&o,a=t.includeMeta,u=void 0!==a&&a,c={};i&&(c.max=i);n&&(c.start=n);r&&(c.end=r);s&&(c.string_message_token="true");u&&(c.include_meta="true");return c},t.handleResponse=function(r,e){var i={channels:{}};return Object.keys(e.channels||{}).forEach(function(n){i.channels[n]=[],(e.channels[n]||[]).forEach(function(e){var t={};t.channel=n,t.timetoken=e.timetoken,t.message=function(e,t){var n=e.config,r=e.crypto;if(!n.cipherKey)return t;try{return r.decrypt(t)}catch(e){return t}}(r,e.message),e.actions&&(t.actions=e.actions,t.data=e.actions),e.meta&&(t.meta=e.meta),i.channels[n].push(t)})}),i};n(0);var r=i(n(1)),c=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNSubscribeOperation},t.validateParams=function(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=e.config,r=t.channels,i=void 0===r?[]:r,o=0<i.length?i.join(","):",";return"/v2/subscribe/".concat(n.subscribeKey,"/").concat(s.default.encodeString(o),"/0")},t.getRequestTimeout=function(e){return e.config.getSubscribeTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=e.config,r=t.state,i=t.channelGroups,o=void 0===i?[]:i,s=t.timetoken,a=t.filterExpression,u=t.region,c={heartbeat:n.getPresenceTimeout()};0<o.length&&(c["channel-group"]=o.join(","));a&&0<a.length&&(c["filter-expr"]=a);Object.keys(r).length&&(c.state=JSON.stringify(r));s&&(c.tt=s);u&&(c.tr=u);return c},t.handleResponse=function(e,t){var r=[];t.m.forEach(function(e){var t={publishTimetoken:e.p.t,region:e.p.r},n={shard:parseInt(e.a,10),subscriptionMatch:e.b,channel:e.c,messageType:e.e,payload:e.d,flags:e.f,issuingClientId:e.i,subscribeKey:e.k,originationTimetoken:e.o,userMetadata:e.u,publishMetaData:t};r.push(n)});var n={timetoken:t.t.t,region:t.t.r};return{messages:r,metadata:n}};n(0);var r=i(n(1)),s=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;i(n(3));var r=i(n(4));n(0);function i(e){return e&&e.__esModule?e:{default:e}}function o(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var a,u,c,f=(a=l,(u=[{key:"init",value:function(e){this._config=e,this._maxSubDomain=20,this._currentSubDomain=Math.floor(Math.random()*this._maxSubDomain),this._providedFQDN=(this._config.secure?"https://":"http://")+this._config.origin,this._coreParams={},this.shiftStandardOrigin()}},{key:"nextOrigin",value:function(){return this._providedFQDN.match(/ps\.pndsn\.com$/i)?(this._currentSubDomain=this._currentSubDomain+1,this._currentSubDomain>=this._maxSubDomain&&(this._currentSubDomain=1),e=this._currentSubDomain.toString(),this._providedFQDN.replace("ps.pndsn.com","ps".concat(e,".pndsn.com"))):this._providedFQDN;var e}},{key:"hasModule",value:function(e){return e in this._modules}},{key:"shiftStandardOrigin",value:function(){return this._standardOrigin=this.nextOrigin(),this._standardOrigin}},{key:"getStandardOrigin",value:function(){return this._standardOrigin}},{key:"POST",value:function(e,t,n,r){return this._modules.post(e,t,n,r)}},{key:"PATCH",value:function(e,t,n,r){return this._modules.patch(e,t,n,r)}},{key:"GET",value:function(e,t,n){return this._modules.get(e,t,n)}},{key:"DELETE",value:function(e,t,n){return this._modules.del(e,t,n)}},{key:"_detectErrorCategory",value:function(e){if("ENOTFOUND"===e.code)return r.default.PNNetworkIssuesCategory;if("ECONNREFUSED"===e.code)return r.default.PNNetworkIssuesCategory;if("ECONNRESET"===e.code)return r.default.PNNetworkIssuesCategory;if("EAI_AGAIN"===e.code)return r.default.PNNetworkIssuesCategory;if(0===e.status||e.hasOwnProperty("status")&&void 0===e.status)return r.default.PNNetworkIssuesCategory;if(e.timeout)return r.default.PNTimeoutCategory;if("ETIMEDOUT"===e.code)return r.default.PNNetworkIssuesCategory;if(e.response){if(e.response.badRequest)return r.default.PNBadRequestCategory;if(e.response.forbidden)return r.default.PNAccessDeniedCategory}return r.default.PNUnknownCategory}}])&&o(a.prototype,u),void(c&&o(a,c)),l);function l(t){var n=this;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,l),s(this,"_modules",void 0),s(this,"_config",void 0),s(this,"_maxSubDomain",void 0),s(this,"_currentSubDomain",void 0),s(this,"_standardOrigin",void 0),s(this,"_subscribeOrigin",void 0),s(this,"_providedFQDN",void 0),s(this,"_requestTimeout",void 0),s(this,"_coreParams",void 0),this._modules={},Object.keys(t).forEach(function(e){n._modules[e]=t[e].bind(n)})}t.default=f,e.exports=t.default},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var r={get:function(e){try{return localStorage.getItem(e)}catch(e){return null}},set:function(e,t){try{return localStorage.setItem(e,t)}catch(e){return null}}};t.default=r,e.exports=t.default},function(f,l,h){"use strict";(function(i){Object.defineProperty(l,"__esModule",{value:!0}),l.default=void 0;var e,o=(e=h(74))&&e.__esModule?e:{default:e};function s(e){return(s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function t(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var n,r,a,u=(n=c,(r=[{key:"decodeToken",value:function(e){var t="";e.length%4==3?t="=":e.length%4==2&&(t="==");var n=e.replace("-","+").replace("_","/")+t,r=o.default.decode(new i.from(n,"base64"));if("object"===s(r))return r}}])&&t(n.prototype,r),void(a&&t(n,a)),c);function c(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,c)}l.default=u,f.exports=l.default}).call(this,h(9).Buffer)},function(e,t){var n;n=function(){return this}();try{n=n||new Function("return this")()}catch(e){"object"==typeof window&&(n=window)}e.exports=n},function(e,t,n){"use strict";t.byteLength=function(e){var t=l(e),n=t[0],r=t[1];return 3*(n+r)/4-r},t.toByteArray=function(e){var t,n,r=l(e),i=r[0],o=r[1],s=new f(function(e,t,n){return 3*(t+n)/4-n}(0,i,o)),a=0,u=0<o?i-4:i;for(n=0;n<u;n+=4)t=c[e.charCodeAt(n)]<<18|c[e.charCodeAt(n+1)]<<12|c[e.charCodeAt(n+2)]<<6|c[e.charCodeAt(n+3)],s[a++]=t>>16&255,s[a++]=t>>8&255,s[a++]=255&t;2===o&&(t=c[e.charCodeAt(n)]<<2|c[e.charCodeAt(n+1)]>>4,s[a++]=255&t);1===o&&(t=c[e.charCodeAt(n)]<<10|c[e.charCodeAt(n+1)]<<4|c[e.charCodeAt(n+2)]>>2,s[a++]=t>>8&255,s[a++]=255&t);return s},t.fromByteArray=function(e){for(var t,n=e.length,r=n%3,i=[],o=0,s=n-r;o<s;o+=16383)i.push(u(e,o,s<o+16383?s:o+16383));1==r?(t=e[n-1],i.push(a[t>>2]+a[t<<4&63]+"==")):2==r&&(t=(e[n-2]<<8)+e[n-1],i.push(a[t>>10]+a[t>>4&63]+a[t<<2&63]+"="));return i.join("")};for(var a=[],c=[],f="undefined"!=typeof Uint8Array?Uint8Array:Array,r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",i=0,o=r.length;i<o;++i)a[i]=r[i],c[r.charCodeAt(i)]=i;function l(e){var t=e.length;if(0<t%4)throw new Error("Invalid string. Length must be a multiple of 4");var n=e.indexOf("=");return-1===n&&(n=t),[n,n===t?0:4-n%4]}function u(e,t,n){for(var r,i,o=[],s=t;s<n;s+=3)r=(e[s]<<16&16711680)+(e[s+1]<<8&65280)+(255&e[s+2]),o.push(a[(i=r)>>18&63]+a[i>>12&63]+a[i>>6&63]+a[63&i]);return o.join("")}c["-".charCodeAt(0)]=62,c["_".charCodeAt(0)]=63},function(e,t){t.read=function(e,t,n,r,i){var o,s,a=8*i-r-1,u=(1<<a)-1,c=u>>1,f=-7,l=n?i-1:0,h=n?-1:1,p=e[t+l];for(l+=h,o=p&(1<<-f)-1,p>>=-f,f+=a;0<f;o=256*o+e[t+l],l+=h,f-=8);for(s=o&(1<<-f)-1,o>>=-f,f+=r;0<f;s=256*s+e[t+l],l+=h,f-=8);if(0===o)o=1-c;else{if(o===u)return s?NaN:1/0*(p?-1:1);s+=Math.pow(2,r),o-=c}return(p?-1:1)*s*Math.pow(2,o-r)},t.write=function(e,t,n,r,i,o){var s,a,u,c=8*o-i-1,f=(1<<c)-1,l=f>>1,h=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,p=r?0:o-1,d=r?1:-1,g=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(a=isNaN(t)?1:0,s=f):(s=Math.floor(Math.log(t)/Math.LN2),t*(u=Math.pow(2,-s))<1&&(s--,u*=2),2<=(t+=1<=s+l?h/u:h*Math.pow(2,1-l))*u&&(s++,u/=2),f<=s+l?(a=0,s=f):1<=s+l?(a=(t*u-1)*Math.pow(2,i),s+=l):(a=t*Math.pow(2,l-1)*Math.pow(2,i),s=0));8<=i;e[n+p]=255&a,p+=d,a/=256,i-=8);for(s=s<<i|a,c+=i;0<c;e[n+p]=255&s,p+=d,s/=256,c-=8);e[n+p-d]|=128*g}},function(e,t){var n={}.toString;e.exports=Array.isArray||function(e){return"[object Array]"==n.call(e)}},function(r,i,e){(function(b){var e,t,n;t=[],void 0===(n="function"==typeof(e=function(){var e=function(){function o(e){this.$hex=e}o.prototype={length:function(){return this.$hex.length/2},toString:function(e){if(!e||"hex"===e||16===e)return this.$hex;if("utf-8"===e){for(var t="",n=0;n<this.$hex.length;n+=2)t+="%"+this.$hex.substring(n,n+2);return decodeURIComponent(t)}if("latin"!==e)throw new Error("Unrecognised format: "+e);for(var t=[],n=0;n<this.$hex.length;n+=2)t.push(parseInt(this.$hex.substring(n,n+2),16));return String.fromCharCode.apply(String,t)}},o.fromLatinString=function(e){for(var t="",n=0;n<e.length;n++){var r=e.charCodeAt(n).toString(16);1===r.length&&(r="0"+r),t+=r}return new o(t)},o.fromUtf8String=function(e){for(var t=encodeURIComponent(e),n="",r=0;r<t.length;r++)if("%"===t.charAt(r))n+=t.substring(r+1,r+3),r+=2;else{var i=t.charCodeAt(r).toString(16);i.length<2&&(i="0"+i),n+=i}return new o(n)};var s=[],f={},r=function(e){return function(){throw new Error(e+" not implemented")}};function e(){}function t(){}function l(e,t){var n=e.value;return n<24?n:24==n?t.readByte():25==n?t.readUint16():26==n?t.readUint32():27==n?t.readUint64():31==n?null:void r("Additional info: "+n)()}function a(e,t,n){var r=e<<5;t<24?n.writeByte(r|t):t<256?(n.writeByte(24|r),n.writeByte(t)):t<65536?(n.writeByte(25|r),n.writeUint16(t)):t<4294967296?(n.writeByte(26|r),n.writeUint32(t)):(n.writeByte(27|r),n.writeUint64(t))}e.prototype={peekByte:r("peekByte"),readByte:r("readByte"),readChunk:r("readChunk"),readFloat16:function(){var e=this.readUint16(),t=(32767&e)>>10,n=1023&e,r=32768&e;if(31==t)return 0==n?r?-1/0:1/0:NaN;var i=t?Math.pow(2,t-25)*(1024+n):Math.pow(2,-24)*n;return r?-i:i},readFloat32:function(){var e=this.readUint32(),t=(2147483647&e)>>23,n=8388607&e,r=2147483648&e;if(255==t)return 0==n?r?-1/0:1/0:NaN;var i=t?Math.pow(2,t-23-127)*(8388608+n):Math.pow(2,-149)*n;return r?-i:i},readFloat64:function(){var e=this.readUint32(),t=this.readUint32(),n=e>>20&2047,r=4294967296*(1048575&e)+t,i=2147483648&e;if(2047==n)return 0===r?i?-1/0:1/0:NaN;var o=n?Math.pow(2,n-52-1023)*(4503599627370496+r):Math.pow(2,-1074)*r;return i?-o:o},readUint16:function(){return 256*this.readByte()+this.readByte()},readUint32:function(){return 65536*this.readUint16()+this.readUint16()},readUint64:function(){return 4294967296*this.readUint32()+this.readUint32()}},t.prototype={writeByte:r("writeByte"),result:r("result"),writeFloat16:r("writeFloat16"),writeFloat32:r("writeFloat32"),writeFloat64:r("writeFloat64"),writeUint16:function(e){this.writeByte(e>>8&255),this.writeByte(255&e)},writeUint32:function(e){this.writeUint16(e>>16&65535),this.writeUint16(65535&e)},writeUint64:function(e){if(9007199254740992<=e||e<=-9007199254740992)throw new Error("Cannot encode Uint64 of: "+e+" magnitude to big (floating point errors)");this.writeUint32(Math.floor(e/4294967296)),this.writeUint32(e%4294967296)},writeString:r("writeString"),canWriteBinary:function(e){return!1},writeBinary:r("writeChunk")};var h=new Error;function p(e){var t=function(e){var t=e.readByte();return{type:t>>5,value:31&t}}(e);switch(t.type){case 0:return l(t,e);case 1:return-1-l(t,e);case 2:return e.readChunk(l(t,e));case 3:var n=e.readChunk(l(t,e));return n.toString("utf-8");case 4:case 5:var r=l(t,e),i=[];if(null!==r){5===t.type&&(r*=2);for(var o=0;o<r;o++)i[o]=p(e)}else for(var s;(s=p(e))!==h;)i.push(s);if(5!==t.type)return i;for(var a={},o=0;o<i.length;o+=2)a[i[o]]=i[o+1];return a;case 6:var u=l(t,e),c=f[u],i=p(e);return c?c(i):i;case 7:if(25===t.value)return e.readFloat16();if(26===t.value)return e.readFloat32();if(27===t.value)return e.readFloat64();switch(l(t,e)){case 20:return!1;case 21:return!0;case 22:return null;case 23:return;case null:return h;default:throw new Error("Unknown fixed value: "+t.value)}default:throw new Error("Unsupported header: "+JSON.stringify(t))}throw new Error("not implemented yet")}function u(e,t){for(var n=0;n<s.length;n++){var r=s[n].fn(e);if(void 0!==r)return a(6,s[n].tag,t),u(r,t)}if(e&&"function"==typeof e.toCBOR&&(e=e.toCBOR()),!1===e)a(7,20,t);else if(!0===e)a(7,21,t);else if(null===e)a(7,22,t);else if(void 0===e)a(7,23,t);else if("number"==typeof e)Math.floor(e)===e&&e<9007199254740992&&-9007199254740992<e?e<0?a(1,-1-e,t):a(0,e,t):(function(e,t,n){n.writeByte(e<<5|t)}(7,27,t),t.writeFloat64(e));else if("string"==typeof e)t.writeString(e,function(e){a(3,e,t)});else if(t.canWriteBinary(e))t.writeBinary(e,function(e){a(2,e,t)});else{if("object"!=typeof e)throw new Error("CBOR encoding not supported: "+e);if(g.config.useToJSON&&"function"==typeof e.toJSON&&(e=e.toJSON()),Array.isArray(e)){a(4,e.length,t);for(var n=0;n<e.length;n++)u(e[n],t)}else{var i=Object.keys(e);a(5,i.length,t);for(var n=0;n<i.length;n++)u(i[n],t),u(e[i[n]],t)}}}var c=[],d=[],g={config:{useToJSON:!0},addWriter:function(t,n){"string"==typeof t?d.push(function(e){if(t===e)return n(e)}):d.push(t)},addReader:function(n,r){"string"==typeof n?c.push(function(e,t){if(n===t)return r(e,t)}):c.push(n)},encode:function(e,t){for(var n=0;n<d.length;n++){var r=d[n],i=r(t);if(i)return u(e,i),i.result()}throw new Error("Unsupported output format: "+t)},decode:function(e,t){for(var n=0;n<c.length;n++){var r=c[n],i=r(e,t);if(i)return p(i)}throw new Error("Unsupported input format: "+t)},addSemanticEncode:function(e,t){if("number"!=typeof e||e%1!=0||e<0)throw new Error("Tag must be a positive integer");return s.push({tag:e,fn:t}),this},addSemanticDecode:function(e,t){if("number"!=typeof e||e%1!=0||e<0)throw new Error("Tag must be a positive integer");return f[e]=t,this},Reader:e,Writer:t};function i(e){this.buffer=e,this.pos=0}function n(e){this.byteLength=0,this.defaultBufferLength=16384,this.latestBuffer=b.alloc(this.defaultBufferLength),this.latestBufferOffset=0,this.completeBuffers=[],this.stringFormat=e}function y(e){this.hex=e,this.pos=0}function v(e){this.$hex="",this.finalFormat=e||"hex"}return(i.prototype=Object.create(e.prototype)).peekByte=function(){return this.buffer[this.pos]},i.prototype.readByte=function(){return this.buffer[this.pos++]},i.prototype.readUint16=function(){var e=this.buffer.readUInt16BE(this.pos);return this.pos+=2,e},i.prototype.readUint32=function(){var e=this.buffer.readUInt32BE(this.pos);return this.pos+=4,e},i.prototype.readFloat32=function(){var e=this.buffer.readFloatBE(this.pos);return this.pos+=4,e},i.prototype.readFloat64=function(){var e=this.buffer.readDoubleBE(this.pos);return this.pos+=8,e},i.prototype.readChunk=function(e){var t=b.alloc(e);return this.buffer.copy(t,0,this.pos,this.pos+=e),t},(n.prototype=Object.create(t.prototype)).writeByte=function(e){this.latestBuffer[this.latestBufferOffset++]=e,this.latestBufferOffset>=this.latestBuffer.length&&(this.completeBuffers.push(this.latestBuffer),this.latestBuffer=b.alloc(this.defaultBufferLength),this.latestBufferOffset=0),this.byteLength++},n.prototype.writeFloat32=function(e){var t=b.alloc(4);t.writeFloatBE(e,0),this.writeBuffer(t)},n.prototype.writeFloat64=function(e){var t=b.alloc(8);t.writeDoubleBE(e,0),this.writeBuffer(t)},n.prototype.writeString=function(e,t){var n=b.from(e,"utf-8");t(n.length),this.writeBuffer(n)},n.prototype.canWriteBinary=function(e){return e instanceof b},n.prototype.writeBinary=function(e,t){t(e.length),this.writeBuffer(e)},n.prototype.writeBuffer=function(e){if(!(e instanceof b))throw new TypeError("BufferWriter only accepts Buffers");this.latestBufferOffset?this.latestBuffer.length-this.latestBufferOffset>=e.length?(e.copy(this.latestBuffer,this.latestBufferOffset),this.latestBufferOffset+=e.length,this.latestBufferOffset>=this.latestBuffer.length&&(this.completeBuffers.push(this.latestBuffer),this.latestBuffer=b.alloc(this.defaultBufferLength),this.latestBufferOffset=0)):(this.completeBuffers.push(this.latestBuffer.slice(0,this.latestBufferOffset)),this.completeBuffers.push(e),this.latestBuffer=b.alloc(this.defaultBufferLength),this.latestBufferOffset=0):this.completeBuffers.push(e),this.byteLength+=e.length},n.prototype.result=function(){for(var e=b.alloc(this.byteLength),t=0,n=0;n<this.completeBuffers.length;n++){var r=this.completeBuffers[n];r.copy(e,t,0,r.length),t+=r.length}return this.latestBufferOffset&&this.latestBuffer.copy(e,t,0,this.latestBufferOffset),this.stringFormat?e.toString(this.stringFormat):e},"function"==typeof b&&(g.addReader(function(e,t){if(e instanceof b)return new i(e);if("hex"===t||"base64"===t){var n=b.from(e,t);return new i(n)}}),g.addWriter(function(e){return e&&"buffer"!==e?"hex"===e||"base64"===e?new n(e):void 0:new n})),(y.prototype=Object.create(e.prototype)).peekByte=function(){var e=this.hex.substring(this.pos,2);return parseInt(e,16)},y.prototype.readByte=function(){var e=this.hex.substring(this.pos,this.pos+2);return this.pos+=2,parseInt(e,16)},y.prototype.readChunk=function(e){var t=this.hex.substring(this.pos,this.pos+2*e);return this.pos+=2*e,"function"==typeof b?b.from(t,"hex"):new o(t)},(v.prototype=Object.create(t.prototype)).writeByte=function(e){if(e<0||255<e)throw new Error("Byte value out of range: "+e);var t=e.toString(16);1==t.length&&(t="0"+t),this.$hex+=t},v.prototype.canWriteBinary=function(e){return e instanceof o||"function"==typeof b&&e instanceof b},v.prototype.writeBinary=function(e,t){if(e instanceof o)t(e.length()),this.$hex+=e.$hex;else{if(!("function"==typeof b&&e instanceof b))throw new TypeError("HexWriter only accepts BinaryHex or Buffers");t(e.length),this.$hex+=e.toString("hex")}},v.prototype.result=function(){return"buffer"===this.finalFormat&&"function"==typeof b?b.from(this.$hex,"hex"):new o(this.$hex).toString(this.finalFormat)},v.prototype.writeString=function(e,t){var n=o.fromUtf8String(e);t(n.length()),this.$hex+=n.$hex},g.addReader(function(e,t){return e instanceof o||e.$hex?new y(e.$hex):"hex"===t?new y(e):void 0}),g.addWriter(function(e){if("hex"===e)return new v}),g}();return e.addSemanticEncode(0,function(e){if(e instanceof Date)return e.toISOString()}).addSemanticDecode(0,function(e){return new Date(e)}).addSemanticDecode(1,function(e){return new Date(e)}),e})?e.apply(i,t):e)||(r.exports=n)}).call(this,e(9).Buffer)},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.get=function(e,t,n){var r=o.default.get(this.getStandardOrigin()+t.url).set(t.headers).query(e);return s.call(this,r,t,n)},t.post=function(e,t,n,r){var i=o.default.post(this.getStandardOrigin()+n.url).query(e).set(n.headers).send(t);return s.call(this,i,n,r)},t.patch=function(e,t,n,r){var i=o.default.patch(this.getStandardOrigin()+n.url).query(e).set(n.headers).send(t);return s.call(this,i,n,r)},t.del=function(e,t,n){var r=o.default.delete(this.getStandardOrigin()+t.url).set(t.headers).query(e);return s.call(this,r,t,n)};var r,o=(r=n(76))&&r.__esModule?r:{default:r};n(0);function a(r){var i=(new Date).getTime(),e=(new Date).toISOString(),o=console&&console.log?console:window&&window.console&&window.console.log?window.console:console;o.log("<<<<<"),o.log("[".concat(e,"]"),"\n",r.url,"\n",r.qs),o.log("-----"),r.on("response",function(e){var t=(new Date).getTime()-i,n=(new Date).toISOString();o.log(">>>>>>"),o.log("[".concat(n," / ").concat(t,"]"),"\n",r.url,"\n",r.qs,"\n",e.text),o.log("-----")})}function s(e,i,o){var s=this;return this._config.logVerbosity&&(e=e.use(a)),this._config.proxy&&this._modules.proxy&&(e=this._modules.proxy.call(this,e)),this._config.keepAlive&&this._modules.keepAlive&&(e=this._modules.keepAlive(e)),e.timeout(i.timeout).end(function(t,n){var e,r={};if(r.error=null!==t,r.operation=i.operation,n&&n.status&&(r.statusCode=n.status),t){if(t.response&&t.response.text&&!s._config.logVerbosity)try{r.errorData=JSON.parse(t.response.text)}catch(e){r.errorData=t}else r.errorData=t;return r.category=s._detectErrorCategory(t),o(r,null)}try{e=JSON.parse(n.text)}catch(e){return r.errorData=n,r.error=!0,o(r,null)}return e.error&&1===e.error&&e.status&&e.message&&e.service?(r.errorData=e,r.statusCode=e.status,r.error=!0,r.category=s._detectErrorCategory(r),o(r,null)):(e.error&&e.error.message&&(r.errorData=e.error),o(r,e))})}},function(e,n,t){var r;r="undefined"!=typeof window?window:"undefined"!=typeof self?self:(console.warn("Using browser-only version of superagent in non-browser environment"),this);var i=t(77),o=t(78),s=t(10),a=t(79),u=t(81);function c(){}var f=n=e.exports=function(e,t){return"function"==typeof t?new n.Request("GET",e).end(t):1==arguments.length?new n.Request("GET",e):new n.Request(e,t)};n.Request=v,f.getXHR=function(){if(!(!r.XMLHttpRequest||r.location&&"file:"==r.location.protocol&&r.ActiveXObject))return new XMLHttpRequest;try{return new ActiveXObject("Microsoft.XMLHTTP")}catch(e){}try{return new ActiveXObject("Msxml2.XMLHTTP.6.0")}catch(e){}try{return new ActiveXObject("Msxml2.XMLHTTP.3.0")}catch(e){}try{return new ActiveXObject("Msxml2.XMLHTTP")}catch(e){}throw Error("Browser-only version of superagent could not find XHR")};var l="".trim?function(e){return e.trim()}:function(e){return e.replace(/(^\s*|\s*$)/g,"")};function h(e){if(!s(e))return e;var t=[];for(var n in e)p(t,n,e[n]);return t.join("&")}function p(t,n,e){if(null!=e)if(Array.isArray(e))e.forEach(function(e){p(t,n,e)});else if(s(e))for(var r in e)p(t,n+"["+r+"]",e[r]);else t.push(encodeURIComponent(n)+"="+encodeURIComponent(e));else null===e&&t.push(encodeURIComponent(n))}function d(e){for(var t,n,r={},i=e.split("&"),o=0,s=i.length;o<s;++o)-1==(n=(t=i[o]).indexOf("="))?r[decodeURIComponent(t)]="":r[decodeURIComponent(t.slice(0,n))]=decodeURIComponent(t.slice(n+1));return r}function g(e){return/[\/+]json($|[^-\w])/.test(e)}function y(e){this.req=e,this.xhr=this.req.xhr,this.text="HEAD"!=this.req.method&&(""===this.xhr.responseType||"text"===this.xhr.responseType)||void 0===this.xhr.responseType?this.xhr.responseText:null,this.statusText=this.req.xhr.statusText;var t=this.xhr.status;1223===t&&(t=204),this._setStatusProperties(t),this.header=this.headers=function(e){for(var t,n,r,i,o=e.split(/\r?\n/),s={},a=0,u=o.length;a<u;++a)-1!==(t=(n=o[a]).indexOf(":"))&&(r=n.slice(0,t).toLowerCase(),i=l(n.slice(t+1)),s[r]=i);return s}(this.xhr.getAllResponseHeaders()),this.header["content-type"]=this.xhr.getResponseHeader("content-type"),this._setHeaderProperties(this.header),null===this.text&&e._responseType?this.body=this.xhr.response:this.body="HEAD"!=this.req.method?this._parseBody(this.text?this.text:this.xhr.response):null}function v(e,t){var r=this;this._query=this._query||[],this.method=e,this.url=t,this.header={},this._header={},this.on("end",function(){var t,n=null,e=null;try{e=new y(r)}catch(e){return(n=new Error("Parser is unable to parse the response")).parse=!0,n.original=e,r.xhr?(n.rawResponse=void 0===r.xhr.responseType?r.xhr.responseText:r.xhr.response,n.status=r.xhr.status?r.xhr.status:null,n.statusCode=n.status):(n.rawResponse=null,n.status=null),r.callback(n)}r.emit("response",e);try{r._isResponseOK(e)||(t=new Error(e.statusText||"Unsuccessful HTTP response"))}catch(e){t=e}t?(t.original=n,t.response=e,t.status=e.status,r.callback(t,e)):r.callback(null,e)})}function b(e,t,n){var r=f("DELETE",e);return"function"==typeof t&&(n=t,t=null),t&&r.send(t),n&&r.end(n),r}f.serializeObject=h,f.parseString=d,f.types={html:"text/html",json:"application/json",xml:"text/xml",urlencoded:"application/x-www-form-urlencoded",form:"application/x-www-form-urlencoded","form-data":"application/x-www-form-urlencoded"},f.serialize={"application/x-www-form-urlencoded":h,"application/json":JSON.stringify},f.parse={"application/x-www-form-urlencoded":d,"application/json":JSON.parse},a(y.prototype),y.prototype._parseBody=function(e){var t=f.parse[this.type];return this.req._parser?this.req._parser(this,e):(!t&&g(this.type)&&(t=f.parse["application/json"]),t&&e&&(e.length||e instanceof Object)?t(e):null)},y.prototype.toError=function(){var e=this.req,t=e.method,n=e.url,r="cannot "+t+" "+n+" ("+this.status+")",i=new Error(r);return i.status=this.status,i.method=t,i.url=n,i},f.Response=y,i(v.prototype),o(v.prototype),v.prototype.type=function(e){return this.set("Content-Type",f.types[e]||e),this},v.prototype.accept=function(e){return this.set("Accept",f.types[e]||e),this},v.prototype.auth=function(e,t,n){1===arguments.length&&(t=""),"object"==typeof t&&null!==t&&(n=t,t=""),n=n||{type:"function"==typeof btoa?"basic":"auto"};return this._auth(e,t,n,function(e){if("function"==typeof btoa)return btoa(e);throw new Error("Cannot use basic auth, btoa is not a function")})},v.prototype.query=function(e){return"string"!=typeof e&&(e=h(e)),e&&this._query.push(e),this},v.prototype.attach=function(e,t,n){if(t){if(this._data)throw Error("superagent can't mix .send() and .attach()");this._getFormData().append(e,t,n||t.name)}return this},v.prototype._getFormData=function(){return this._formData||(this._formData=new r.FormData),this._formData},v.prototype.callback=function(e,t){if(this._shouldRetry(e,t))return this._retry();var n=this._callback;this.clearTimeout(),e&&(this._maxRetries&&(e.retries=this._retries-1),this.emit("error",e)),n(e,t)},v.prototype.crossDomainError=function(){var e=new Error("Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.");e.crossDomain=!0,e.status=this.status,e.method=this.method,e.url=this.url,this.callback(e)},v.prototype.buffer=v.prototype.ca=v.prototype.agent=function(){return console.warn("This is not supported in browser version of superagent"),this},v.prototype.pipe=v.prototype.write=function(){throw Error("Streaming is not supported in browser version of superagent")},v.prototype._isHost=function(e){return e&&"object"==typeof e&&!Array.isArray(e)&&"[object Object]"!==Object.prototype.toString.call(e)},v.prototype.end=function(e){return this._endCalled&&console.warn("Warning: .end() was called twice. This is not supported in superagent"),this._endCalled=!0,this._callback=e||c,this._finalizeQueryString(),this._end()},v.prototype._end=function(){var n=this,r=this.xhr=f.getXHR(),e=this._formData||this._data;this._setTimeouts(),r.onreadystatechange=function(){var e=r.readyState;if(2<=e&&n._responseTimeoutTimer&&clearTimeout(n._responseTimeoutTimer),4==e){var t;try{t=r.status}catch(e){t=0}if(!t){if(n.timedout||n._aborted)return;return n.crossDomainError()}n.emit("end")}};function t(e,t){0<t.total&&(t.percent=t.loaded/t.total*100),t.direction=e,n.emit("progress",t)}if(this.hasListeners("progress"))try{r.onprogress=t.bind(null,"download"),r.upload&&(r.upload.onprogress=t.bind(null,"upload"))}catch(e){}try{this.username&&this.password?r.open(this.method,this.url,!0,this.username,this.password):r.open(this.method,this.url,!0)}catch(e){return this.callback(e)}if(this._withCredentials&&(r.withCredentials=!0),!this._formData&&"GET"!=this.method&&"HEAD"!=this.method&&"string"!=typeof e&&!this._isHost(e)){var i=this._header["content-type"],o=this._serializer||f.serialize[i?i.split(";")[0]:""];!o&&g(i)&&(o=f.serialize["application/json"]),o&&(e=o(e))}for(var s in this.header)null!=this.header[s]&&this.header.hasOwnProperty(s)&&r.setRequestHeader(s,this.header[s]);return this._responseType&&(r.responseType=this._responseType),this.emit("request",this),r.send(void 0!==e?e:null),this},f.agent=function(){return new u},["GET","POST","OPTIONS","PATCH","PUT","DELETE"].forEach(function(r){u.prototype[r.toLowerCase()]=function(e,t){var n=new f.Request(r,e);return this._setDefaults(n),t&&n.end(t),n}}),u.prototype.del=u.prototype.delete,f.get=function(e,t,n){var r=f("GET",e);return"function"==typeof t&&(n=t,t=null),t&&r.query(t),n&&r.end(n),r},f.head=function(e,t,n){var r=f("HEAD",e);return"function"==typeof t&&(n=t,t=null),t&&r.query(t),n&&r.end(n),r},f.options=function(e,t,n){var r=f("OPTIONS",e);return"function"==typeof t&&(n=t,t=null),t&&r.send(t),n&&r.end(n),r},f.del=b,f.delete=b,f.patch=function(e,t,n){var r=f("PATCH",e);return"function"==typeof t&&(n=t,t=null),t&&r.send(t),n&&r.end(n),r},f.post=function(e,t,n){var r=f("POST",e);return"function"==typeof t&&(n=t,t=null),t&&r.send(t),n&&r.end(n),r},f.put=function(e,t,n){var r=f("PUT",e);return"function"==typeof t&&(n=t,t=null),t&&r.send(t),n&&r.end(n),r}},function(e,t,n){function r(e){if(e)return function(e){for(var t in r.prototype)e[t]=r.prototype[t];return e}(e)}(e.exports=r).prototype.on=r.prototype.addEventListener=function(e,t){return this._callbacks=this._callbacks||{},(this._callbacks["$"+e]=this._callbacks["$"+e]||[]).push(t),this},r.prototype.once=function(e,t){function n(){this.off(e,n),t.apply(this,arguments)}return n.fn=t,this.on(e,n),this},r.prototype.off=r.prototype.removeListener=r.prototype.removeAllListeners=r.prototype.removeEventListener=function(e,t){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var n,r=this._callbacks["$"+e];if(!r)return this;if(1==arguments.length)return delete this._callbacks["$"+e],this;for(var i=0;i<r.length;i++)if((n=r[i])===t||n.fn===t){r.splice(i,1);break}return 0===r.length&&delete this._callbacks["$"+e],this},r.prototype.emit=function(e){this._callbacks=this._callbacks||{};for(var t=new Array(arguments.length-1),n=this._callbacks["$"+e],r=1;r<arguments.length;r++)t[r-1]=arguments[r];if(n){r=0;for(var i=(n=n.slice(0)).length;r<i;++r)n[r].apply(this,t)}return this},r.prototype.listeners=function(e){return this._callbacks=this._callbacks||{},this._callbacks["$"+e]||[]},r.prototype.hasListeners=function(e){return!!this.listeners(e).length}},function(e,t,n){"use strict";var i=n(10);function r(e){if(e)return function(e){for(var t in r.prototype)e[t]=r.prototype[t];return e}(e)}(e.exports=r).prototype.clearTimeout=function(){return clearTimeout(this._timer),clearTimeout(this._responseTimeoutTimer),delete this._timer,delete this._responseTimeoutTimer,this},r.prototype.parse=function(e){return this._parser=e,this},r.prototype.responseType=function(e){return this._responseType=e,this},r.prototype.serialize=function(e){return this._serializer=e,this},r.prototype.timeout=function(e){if(!e||"object"!=typeof e)return this._timeout=e,this._responseTimeout=0,this;for(var t in e)switch(t){case"deadline":this._timeout=e.deadline;break;case"response":this._responseTimeout=e.response;break;default:console.warn("Unknown timeout option",t)}return this},r.prototype.retry=function(e,t){return 0!==arguments.length&&!0!==e||(e=1),e<=0&&(e=0),this._maxRetries=e,this._retries=0,this._retryCallback=t,this};var o=["ECONNRESET","ETIMEDOUT","EADDRINFO","ESOCKETTIMEDOUT"];r.prototype._shouldRetry=function(e,t){if(!this._maxRetries||this._retries++>=this._maxRetries)return!1;if(this._retryCallback)try{var n=this._retryCallback(e,t);if(!0===n)return!0;if(!1===n)return!1}catch(e){console.error(e)}if(t&&t.status&&500<=t.status&&501!=t.status)return!0;if(e){if(e.code&&~o.indexOf(e.code))return!0;if(e.timeout&&"ECONNABORTED"==e.code)return!0;if(e.crossDomain)return!0}return!1},r.prototype._retry=function(){return this.clearTimeout(),this.req&&(this.req=null,this.req=this.request()),this._aborted=!1,this.timedout=!1,this._end()},r.prototype.then=function(e,t){if(!this._fullfilledPromise){var i=this;this._endCalled&&console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises"),this._fullfilledPromise=new Promise(function(n,r){i.end(function(e,t){e?r(e):n(t)})})}return this._fullfilledPromise.then(e,t)},r.prototype.catch=function(e){return this.then(void 0,e)},r.prototype.use=function(e){return e(this),this},r.prototype.ok=function(e){if("function"!=typeof e)throw Error("Callback required");return this._okCallback=e,this},r.prototype._isResponseOK=function(e){return!!e&&(this._okCallback?this._okCallback(e):200<=e.status&&e.status<300)},r.prototype.getHeader=r.prototype.get=function(e){return this._header[e.toLowerCase()]},r.prototype.set=function(e,t){if(i(e)){for(var n in e)this.set(n,e[n]);return this}return this._header[e.toLowerCase()]=t,this.header[e]=t,this},r.prototype.unset=function(e){return delete this._header[e.toLowerCase()],delete this.header[e],this},r.prototype.field=function(e,t){if(null==e)throw new Error(".field(name, val) name can not be empty");if(this._data&&console.error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()"),i(e)){for(var n in e)this.field(n,e[n]);return this}if(Array.isArray(t)){for(var r in t)this.field(e,t[r]);return this}if(null==t)throw new Error(".field(name, val) val can not be empty");return"boolean"==typeof t&&(t=""+t),this._getFormData().append(e,t),this},r.prototype.abort=function(){return this._aborted||(this._aborted=!0,this.xhr&&this.xhr.abort(),this.req&&this.req.abort(),this.clearTimeout(),this.emit("abort")),this},r.prototype._auth=function(e,t,n,r){switch(n.type){case"basic":this.set("Authorization","Basic "+r(e+":"+t));break;case"auto":this.username=e,this.password=t;break;case"bearer":this.set("Authorization","Bearer "+e)}return this},r.prototype.withCredentials=function(e){return null==e&&(e=!0),this._withCredentials=e,this},r.prototype.redirects=function(e){return this._maxRedirects=e,this},r.prototype.maxResponseSize=function(e){if("number"!=typeof e)throw TypeError("Invalid argument");return this._maxResponseSize=e,this},r.prototype.toJSON=function(){return{method:this.method,url:this.url,data:this._data,headers:this._header}},r.prototype.send=function(e){var t=i(e),n=this._header["content-type"];if(this._formData&&console.error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()"),t&&!this._data)Array.isArray(e)?this._data=[]:this._isHost(e)||(this._data={});else if(e&&this._data&&this._isHost(this._data))throw Error("Can't merge these send calls");if(t&&i(this._data))for(var r in e)this._data[r]=e[r];else"string"==typeof e?(n||this.type("form"),n=this._header["content-type"],this._data="application/x-www-form-urlencoded"==n?this._data?this._data+"&"+e:e:(this._data||"")+e):this._data=e;return!t||this._isHost(e)||n||this.type("json"),this},r.prototype.sortQuery=function(e){return this._sort=void 0===e||e,this},r.prototype._finalizeQueryString=function(){var e=this._query.join("&");if(e&&(this.url+=(0<=this.url.indexOf("?")?"&":"?")+e),this._query.length=0,this._sort){var t=this.url.indexOf("?");if(0<=t){var n=this.url.substring(t+1).split("&");"function"==typeof this._sort?n.sort(this._sort):n.sort(),this.url=this.url.substring(0,t)+"?"+n.join("&")}}},r.prototype._appendQueryString=function(){console.trace("Unsupported")},r.prototype._timeoutError=function(e,t,n){if(!this._aborted){var r=new Error(e+t+"ms exceeded");r.timeout=t,r.code="ECONNABORTED",r.errno=n,this.timedout=!0,this.abort(),this.callback(r)}},r.prototype._setTimeouts=function(){var e=this;this._timeout&&!this._timer&&(this._timer=setTimeout(function(){e._timeoutError("Timeout of ",e._timeout,"ETIME")},this._timeout)),this._responseTimeout&&!this._responseTimeoutTimer&&(this._responseTimeoutTimer=setTimeout(function(){e._timeoutError("Response timeout of ",e._responseTimeout,"ETIMEDOUT")},this._responseTimeout))}},function(e,t,n){"use strict";var i=n(80);function r(e){if(e)return function(e){for(var t in r.prototype)e[t]=r.prototype[t];return e}(e)}(e.exports=r).prototype.get=function(e){return this.header[e.toLowerCase()]},r.prototype._setHeaderProperties=function(e){var t=e["content-type"]||"";this.type=i.type(t);var n=i.params(t);for(var r in n)this[r]=n[r];this.links={};try{e.link&&(this.links=i.parseLinks(e.link))}catch(e){}},r.prototype._setStatusProperties=function(e){var t=e/100|0;this.status=this.statusCode=e,this.statusType=t,this.info=1==t,this.ok=2==t,this.redirect=3==t,this.clientError=4==t,this.serverError=5==t,this.error=(4==t||5==t)&&this.toError(),this.created=201==e,this.accepted=202==e,this.noContent=204==e,this.badRequest=400==e,this.unauthorized=401==e,this.notAcceptable=406==e,this.forbidden=403==e,this.notFound=404==e,this.unprocessableEntity=422==e}},function(e,t,n){"use strict";t.type=function(e){return e.split(/ *; */).shift()},t.params=function(e){return e.split(/ *; */).reduce(function(e,t){var n=t.split(/ *= */),r=n.shift(),i=n.shift();return r&&i&&(e[r]=i),e},{})},t.parseLinks=function(e){return e.split(/ *, */).reduce(function(e,t){var n=t.split(/ *; */),r=n[0].slice(1,-1);return e[n[1].split(/ *= */)[1].slice(1,-1)]=r,e},{})},t.cleanHeader=function(e,t){return delete e["content-type"],delete e["content-length"],delete e["transfer-encoding"],delete e.host,t&&(delete e.authorization,delete e.cookie),e}},function(e,t){function n(){this._defaults=[]}["use","on","once","set","query","type","accept","auth","withCredentials","sortQuery","retry","ok","redirects","timeout","buffer","serialize","parse","ca","key","pfx","cert"].forEach(function(e){n.prototype[e]=function(){return this._defaults.push({fn:e,arguments:arguments}),this}}),n.prototype._setDefaults=function(t){this._defaults.forEach(function(e){t[e.fn].apply(t,e.arguments)})},e.exports=n}],i.c=r,i.d=function(e,t,n){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(t,e){if(1&e&&(t=i(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(i.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var r in t)i.d(n,r,function(e){return t[e]}.bind(null,r));return n},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i(i.s=11);function i(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,i),t.l=!0,t.exports}var n,r});
      };
    };
  }
}, {package:"pubnub",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pubnub\\dist\\web\\pubnub.min.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3\\index.js", {"./lib/web3":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3\\lib\\web3.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\web3\index.js
      return function (require, module, exports) {
var Web3 = require('./lib/web3');

// dont override global variable
if (typeof window !== 'undefined' && typeof window.Web3 === 'undefined') {
    window.Web3 = Web3;
}

module.exports = Web3;

      };
    };
  }
}, {package:"web3",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\single-call-balance-checker-abi\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\single-call-balance-checker-abi\index.js
      return function (require, module, exports) {

module.exports = [
    {
     "payable": true,
     "stateMutability": "payable",
     "type": "fallback"
    },
    {
     "constant": true,
     "inputs": [
      {
       "name": "user",
       "type": "address"
      },
      {
       "name": "token",
       "type": "address"
      }
     ],
     "name": "tokenBalance",
     "outputs": [
      {
       "name": "",
       "type": "uint256"
      }
     ],
     "payable": false,
     "stateMutability": "view",
     "type": "function"
    },
    {
     "constant": true,
     "inputs": [
      {
       "name": "users",
       "type": "address[]"
      },
      {
       "name": "tokens",
       "type": "address[]"
      }
     ],
     "name": "balances",
     "outputs": [
      {
       "name": "",
       "type": "uint256[]"
      }
     ],
     "payable": false,
     "stateMutability": "view",
     "type": "function"
    }
   ]

      };
    };
  }
}, {package:"single-call-balance-checker-abi",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\single-call-balance-checker-abi\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-sig-util\\dist\\index.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereumjs-abi":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-abi\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\index.js","tweetnacl":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tweetnacl\\nacl-fast.js","tweetnacl-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tweetnacl-util\\nacl-util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-sig-util\dist\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.recoverTypedSignature_v4 = exports.recoverTypedSignature = exports.signTypedData_v4 = exports.signTypedData = exports.recoverTypedMessage = exports.signTypedMessage = exports.getEncryptionPublicKey = exports.decryptSafely = exports.decrypt = exports.encryptSafely = exports.encrypt = exports.recoverTypedSignatureLegacy = exports.signTypedDataLegacy = exports.typedSignatureHash = exports.extractPublicKey = exports.recoverPersonalSignature = exports.personalSign = exports.normalize = exports.concatSig = exports.TypedDataUtils = exports.TYPED_MESSAGE_SCHEMA = void 0;
const ethUtil = __importStar(require("ethereumjs-util"));
const ethAbi = __importStar(require("ethereumjs-abi"));
const nacl = __importStar(require("tweetnacl"));
const naclUtil = __importStar(require("tweetnacl-util"));
const TYPED_MESSAGE_SCHEMA = {
    type: 'object',
    properties: {
        types: {
            type: 'object',
            additionalProperties: {
                type: 'array',
                items: {
                    type: 'object',
                    properties: {
                        name: { type: 'string' },
                        type: { type: 'string' },
                    },
                    required: ['name', 'type'],
                },
            },
        },
        primaryType: { type: 'string' },
        domain: { type: 'object' },
        message: { type: 'object' },
    },
    required: ['types', 'primaryType', 'domain', 'message'],
};
exports.TYPED_MESSAGE_SCHEMA = TYPED_MESSAGE_SCHEMA;
/**
 * A collection of utility functions used for signing typed data
 */
const TypedDataUtils = {
    /**
     * Encodes an object by encoding and concatenating each of its members
     *
     * @param {string} primaryType - Root type
     * @param {Object} data - Object to encode
     * @param {Object} types - Type definitions
     * @returns {Buffer} - Encoded representation of an object
     */
    encodeData(primaryType, data, types, useV4 = true) {
        const encodedTypes = ['bytes32'];
        const encodedValues = [this.hashType(primaryType, types)];
        if (useV4) {
            const encodeField = (name, type, value) => {
                if (types[type] !== undefined) {
                    return [
                        'bytes32',
                        value == null // eslint-disable-line no-eq-null
                            ? '0x0000000000000000000000000000000000000000000000000000000000000000'
                            : ethUtil.keccak(this.encodeData(type, value, types, useV4)),
                    ];
                }
                if (value === undefined) {
                    throw new Error(`missing value for field ${name} of type ${type}`);
                }
                if (type === 'bytes') {
                    return ['bytes32', ethUtil.keccak(value)];
                }
                if (type === 'string') {
                    // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
                    if (typeof value === 'string') {
                        value = Buffer.from(value, 'utf8');
                    }
                    return ['bytes32', ethUtil.keccak(value)];
                }
                if (type.lastIndexOf(']') === type.length - 1) {
                    const parsedType = type.slice(0, type.lastIndexOf('['));
                    const typeValuePairs = value.map((item) => encodeField(name, parsedType, item));
                    return [
                        'bytes32',
                        ethUtil.keccak(ethAbi.rawEncode(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v))),
                    ];
                }
                return [type, value];
            };
            for (const field of types[primaryType]) {
                const [type, value] = encodeField(field.name, field.type, data[field.name]);
                encodedTypes.push(type);
                encodedValues.push(value);
            }
        }
        else {
            for (const field of types[primaryType]) {
                let value = data[field.name];
                if (value !== undefined) {
                    if (field.type === 'bytes') {
                        encodedTypes.push('bytes32');
                        value = ethUtil.keccak(value);
                        encodedValues.push(value);
                    }
                    else if (field.type === 'string') {
                        encodedTypes.push('bytes32');
                        // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
                        if (typeof value === 'string') {
                            value = Buffer.from(value, 'utf8');
                        }
                        value = ethUtil.keccak(value);
                        encodedValues.push(value);
                    }
                    else if (types[field.type] !== undefined) {
                        encodedTypes.push('bytes32');
                        value = ethUtil.keccak(this.encodeData(field.type, value, types, useV4));
                        encodedValues.push(value);
                    }
                    else if (field.type.lastIndexOf(']') === field.type.length - 1) {
                        throw new Error('Arrays are unimplemented in encodeData; use V4 extension');
                    }
                    else {
                        encodedTypes.push(field.type);
                        encodedValues.push(value);
                    }
                }
            }
        }
        return ethAbi.rawEncode(encodedTypes, encodedValues);
    },
    /**
     * Encodes the type of an object by encoding a comma delimited list of its members
     *
     * @param {string} primaryType - Root type to encode
     * @param {Object} types - Type definitions
     * @returns {string} - Encoded representation of the type of an object
     */
    encodeType(primaryType, types) {
        let result = '';
        let deps = this.findTypeDependencies(primaryType, types).filter((dep) => dep !== primaryType);
        deps = [primaryType].concat(deps.sort());
        for (const type of deps) {
            const children = types[type];
            if (!children) {
                throw new Error(`No type definition specified: ${type}`);
            }
            result += `${type}(${types[type]
                .map(({ name, type: t }) => `${t} ${name}`)
                .join(',')})`;
        }
        return result;
    },
    /**
     * Finds all types within a type definition object
     *
     * @param {string} primaryType - Root type
     * @param {Object} types - Type definitions
     * @param {Array} results - current set of accumulated types
     * @returns {Array} - Set of all types found in the type definition
     */
    findTypeDependencies(primaryType, types, results = []) {
        [primaryType] = primaryType.match(/^\w*/u);
        if (results.includes(primaryType) || types[primaryType] === undefined) {
            return results;
        }
        results.push(primaryType);
        for (const field of types[primaryType]) {
            for (const dep of this.findTypeDependencies(field.type, types, results)) {
                !results.includes(dep) && results.push(dep);
            }
        }
        return results;
    },
    /**
     * Hashes an object
     *
     * @param {string} primaryType - Root type
     * @param {Object} data - Object to hash
     * @param {Object} types - Type definitions
     * @returns {Buffer} - Hash of an object
     */
    hashStruct(primaryType, data, types, useV4 = true) {
        return ethUtil.keccak(this.encodeData(primaryType, data, types, useV4));
    },
    /**
     * Hashes the type of an object
     *
     * @param {string} primaryType - Root type to hash
     * @param {Object} types - Type definitions
     * @returns {Buffer} - Hash of an object
     */
    hashType(primaryType, types) {
        return ethUtil.keccak(this.encodeType(primaryType, types));
    },
    /**
     * Removes properties from a message object that are not defined per EIP-712
     *
     * @param {Object} data - typed message object
     * @returns {Object} - typed message object with only allowed fields
     */
    sanitizeData(data) {
        const sanitizedData = {};
        for (const key in TYPED_MESSAGE_SCHEMA.properties) {
            if (data[key]) {
                sanitizedData[key] = data[key];
            }
        }
        if ('types' in sanitizedData) {
            sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types);
        }
        return sanitizedData;
    },
    /**
     * Signs a typed message as per EIP-712 and returns its keccak hash
     *
     * @param {Object} typedData - Types message data to sign
     * @returns {Buffer} - keccak hash of the resulting signed message
     */
    sign(typedData, useV4 = true) {
        const sanitizedData = this.sanitizeData(typedData);
        const parts = [Buffer.from('1901', 'hex')];
        parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4));
        if (sanitizedData.primaryType !== 'EIP712Domain') {
            parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));
        }
        return ethUtil.keccak(Buffer.concat(parts));
    },
};
exports.TypedDataUtils = TypedDataUtils;
function concatSig(v, r, s) {
    const rSig = ethUtil.fromSigned(r);
    const sSig = ethUtil.fromSigned(s);
    const vSig = ethUtil.bufferToInt(v);
    const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64);
    const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64);
    const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig));
    return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex');
}
exports.concatSig = concatSig;
function normalize(input) {
    if (!input) {
        return undefined;
    }
    if (typeof input === 'number') {
        const buffer = ethUtil.toBuffer(input);
        input = ethUtil.bufferToHex(buffer);
    }
    if (typeof input !== 'string') {
        let msg = 'eth-sig-util.normalize() requires hex string or integer input.';
        msg += ` received ${typeof input}: ${input}`;
        throw new Error(msg);
    }
    return ethUtil.addHexPrefix(input.toLowerCase());
}
exports.normalize = normalize;
function personalSign(privateKey, msgParams) {
    const message = ethUtil.toBuffer(msgParams.data);
    const msgHash = ethUtil.hashPersonalMessage(message);
    const sig = ethUtil.ecsign(msgHash, privateKey);
    const serialized = ethUtil.bufferToHex(concatSig(sig.v, sig.r, sig.s));
    return serialized;
}
exports.personalSign = personalSign;
function recoverPersonalSignature(msgParams) {
    const publicKey = getPublicKeyFor(msgParams);
    const sender = ethUtil.publicToAddress(publicKey);
    const senderHex = ethUtil.bufferToHex(sender);
    return senderHex;
}
exports.recoverPersonalSignature = recoverPersonalSignature;
function extractPublicKey(msgParams) {
    const publicKey = getPublicKeyFor(msgParams);
    return `0x${publicKey.toString('hex')}`;
}
exports.extractPublicKey = extractPublicKey;
function externalTypedSignatureHash(typedData) {
    const hashBuffer = typedSignatureHash(typedData);
    return ethUtil.bufferToHex(hashBuffer);
}
exports.typedSignatureHash = externalTypedSignatureHash;
function signTypedDataLegacy(privateKey, msgParams) {
    const msgHash = typedSignatureHash(msgParams.data);
    const sig = ethUtil.ecsign(msgHash, privateKey);
    return ethUtil.bufferToHex(concatSig(sig.v, sig.r, sig.s));
}
exports.signTypedDataLegacy = signTypedDataLegacy;
function recoverTypedSignatureLegacy(msgParams) {
    const msgHash = typedSignatureHash(msgParams.data);
    const publicKey = recoverPublicKey(msgHash, msgParams.sig);
    const sender = ethUtil.publicToAddress(publicKey);
    return ethUtil.bufferToHex(sender);
}
exports.recoverTypedSignatureLegacy = recoverTypedSignatureLegacy;
function encrypt(receiverPublicKey, msgParams, version) {
    switch (version) {
        case 'x25519-xsalsa20-poly1305': {
            if (typeof msgParams.data !== 'string') {
                throw new Error('Cannot detect secret message, message params should be of the form {data: "secret message"} ');
            }
            // generate ephemeral keypair
            const ephemeralKeyPair = nacl.box.keyPair();
            // assemble encryption parameters - from string to UInt8
            let pubKeyUInt8Array;
            try {
                pubKeyUInt8Array = naclUtil.decodeBase64(receiverPublicKey);
            }
            catch (err) {
                throw new Error('Bad public key');
            }
            const msgParamsUInt8Array = naclUtil.decodeUTF8(msgParams.data);
            const nonce = nacl.randomBytes(nacl.box.nonceLength);
            // encrypt
            const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey);
            // handle encrypted data
            const output = {
                version: 'x25519-xsalsa20-poly1305',
                nonce: naclUtil.encodeBase64(nonce),
                ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),
                ciphertext: naclUtil.encodeBase64(encryptedMessage),
            };
            // return encrypted msg data
            return output;
        }
        default:
            throw new Error('Encryption type/version not supported');
    }
}
exports.encrypt = encrypt;
function encryptSafely(receiverPublicKey, msgParams, version) {
    const DEFAULT_PADDING_LENGTH = 2 ** 11;
    const NACL_EXTRA_BYTES = 16;
    const { data } = msgParams;
    if (!data) {
        throw new Error('Cannot encrypt empty msg.data');
    }
    if (typeof data === 'object' && 'toJSON' in data) {
        // remove toJSON attack vector
        // TODO, check all possible children
        throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property');
    }
    // add padding
    const dataWithPadding = {
        data,
        padding: '',
    };
    // calculate padding
    const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8');
    const modVal = dataLength % DEFAULT_PADDING_LENGTH;
    let padLength = 0;
    // Only pad if necessary
    if (modVal > 0) {
        padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes
    }
    dataWithPadding.padding = '0'.repeat(padLength);
    const paddedMsgParams = { data: JSON.stringify(dataWithPadding) };
    return encrypt(receiverPublicKey, paddedMsgParams, version);
}
exports.encryptSafely = encryptSafely;
function decrypt(encryptedData, receiverPrivateKey) {
    switch (encryptedData.version) {
        case 'x25519-xsalsa20-poly1305': {
            // string to buffer to UInt8Array
            const recieverPrivateKeyUint8Array = nacl_decodeHex(receiverPrivateKey);
            const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey;
            // assemble decryption parameters
            const nonce = naclUtil.decodeBase64(encryptedData.nonce);
            const ciphertext = naclUtil.decodeBase64(encryptedData.ciphertext);
            const ephemPublicKey = naclUtil.decodeBase64(encryptedData.ephemPublicKey);
            // decrypt
            const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey);
            // return decrypted msg data
            let output;
            try {
                output = naclUtil.encodeUTF8(decryptedMessage);
            }
            catch (err) {
                throw new Error('Decryption failed.');
            }
            if (output) {
                return output;
            }
            throw new Error('Decryption failed.');
        }
        default:
            throw new Error('Encryption type/version not supported.');
    }
}
exports.decrypt = decrypt;
function decryptSafely(encryptedData, receiverPrivateKey) {
    const dataWithPadding = JSON.parse(decrypt(encryptedData, receiverPrivateKey));
    return dataWithPadding.data;
}
exports.decryptSafely = decryptSafely;
function getEncryptionPublicKey(privateKey) {
    const privateKeyUint8Array = nacl_decodeHex(privateKey);
    const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;
    return naclUtil.encodeBase64(encryptionPublicKey);
}
exports.getEncryptionPublicKey = getEncryptionPublicKey;
/**
 * A generic entry point for all typed data methods to be passed, includes a version parameter.
 */
function signTypedMessage(privateKey, msgParams, version = 'V4') {
    switch (version) {
        case 'V1':
            return signTypedDataLegacy(privateKey, msgParams);
        case 'V3':
            return signTypedData(privateKey, msgParams);
        case 'V4':
        default:
            return signTypedData_v4(privateKey, msgParams);
    }
}
exports.signTypedMessage = signTypedMessage;
function recoverTypedMessage(msgParams, version = 'V4') {
    switch (version) {
        case 'V1':
            return recoverTypedSignatureLegacy(msgParams);
        case 'V3':
            return recoverTypedSignature(msgParams);
        case 'V4':
        default:
            return recoverTypedSignature_v4(msgParams);
    }
}
exports.recoverTypedMessage = recoverTypedMessage;
function signTypedData(privateKey, msgParams) {
    const message = TypedDataUtils.sign(msgParams.data, false);
    const sig = ethUtil.ecsign(message, privateKey);
    return ethUtil.bufferToHex(concatSig(sig.v, sig.r, sig.s));
}
exports.signTypedData = signTypedData;
function signTypedData_v4(privateKey, msgParams) {
    const message = TypedDataUtils.sign(msgParams.data);
    const sig = ethUtil.ecsign(message, privateKey);
    return ethUtil.bufferToHex(concatSig(sig.v, sig.r, sig.s));
}
exports.signTypedData_v4 = signTypedData_v4;
function recoverTypedSignature(msgParams) {
    const message = TypedDataUtils.sign(msgParams.data, false);
    const publicKey = recoverPublicKey(message, msgParams.sig);
    const sender = ethUtil.publicToAddress(publicKey);
    return ethUtil.bufferToHex(sender);
}
exports.recoverTypedSignature = recoverTypedSignature;
function recoverTypedSignature_v4(msgParams) {
    const message = TypedDataUtils.sign(msgParams.data);
    const publicKey = recoverPublicKey(message, msgParams.sig);
    const sender = ethUtil.publicToAddress(publicKey);
    return ethUtil.bufferToHex(sender);
}
exports.recoverTypedSignature_v4 = recoverTypedSignature_v4;
/**
 * @param typedData - Array of data along with types, as per EIP712.
 * @returns Buffer
 */
function typedSignatureHash(typedData) {
    const error = new Error('Expect argument to be non-empty array');
    if (typeof typedData !== 'object' ||
        !('length' in typedData) ||
        !typedData.length) {
        throw error;
    }
    const data = typedData.map(function (e) {
        return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value;
    });
    const types = typedData.map(function (e) {
        return e.type;
    });
    const schema = typedData.map(function (e) {
        if (!e.name) {
            throw error;
        }
        return `${e.type} ${e.name}`;
    });
    return ethAbi.soliditySHA3(['bytes32', 'bytes32'], [
        ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema),
        ethAbi.soliditySHA3(types, data),
    ]);
}
function recoverPublicKey(hash, sig) {
    const signature = ethUtil.toBuffer(sig);
    const sigParams = ethUtil.fromRpcSig(signature);
    return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s);
}
function getPublicKeyFor(msgParams) {
    const message = ethUtil.toBuffer(msgParams.data);
    const msgHash = ethUtil.hashPersonalMessage(message);
    return recoverPublicKey(msgHash, msgParams.sig);
}
function padWithZeroes(number, length) {
    let myString = `${number}`;
    while (myString.length < length) {
        myString = `0${myString}`;
    }
    return myString;
}
// converts hex strings to the Uint8Array format used by nacl
function nacl_decodeHex(msgHex) {
    const msgBase64 = Buffer.from(msgHex, 'hex').toString('base64');
    return naclUtil.decodeBase64(msgBase64);
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"eth-sig-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-sig-util\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\assert.js", {"object-assign":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\object-assign\\index.js","util/":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\node_modules\\util\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\assert\assert.js
      return function (require, module, exports) {
'use strict';

var objectAssign = require('object-assign');

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:
// NB: The URL to the CommonJS spec is kept just for tradition.
//     node-assert has evolved a lot since then, both in API and behavior.

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

// Expose a strict only variant of assert
function strict(value, message) {
  if (!value) fail(value, true, message, '==', strict);
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

      };
    };
  }
}, {package:"assert",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\assert.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\jsonschema\\lib\\index.js", {"./helpers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\jsonschema\\lib\\helpers.js","./scan":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\jsonschema\\lib\\scan.js","./validator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\jsonschema\\lib\\validator.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\jsonschema\lib\index.js
      return function (require, module, exports) {
'use strict';

var Validator = module.exports.Validator = require('./validator');

module.exports.ValidatorResult = require('./helpers').ValidatorResult;
module.exports.ValidationError = require('./helpers').ValidationError;
module.exports.SchemaError = require('./helpers').SchemaError;
module.exports.SchemaScanResult = require('./scan').SchemaScanResult;
module.exports.scan = require('./scan').scan;

module.exports.validate = function (instance, schema, options) {
  var v = new Validator();
  return v.validate(instance, schema, options);
};

      };
    };
  }
}, {package:"jsonschema",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\jsonschema\\lib\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\contract-utils.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\shared\modules\contract-utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readAddressAsContract = void 0;

const readAddressAsContract = async (ethQuery, address) => {
  let contractCode;

  try {
    contractCode = await ethQuery.getCode(address);
  } catch (e) {
    contractCode = null;
  }

  const isContractAddress = contractCode && contractCode !== '0x' && contractCode !== '0x0';
  return {
    contractCode,
    isContractAddress
  };
};

exports.readAddressAsContract = readAddressAsContract;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\contract-utils.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethers\\lib\\index.js", {"./ethers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethers\\lib\\ethers.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethers\lib\index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Wordlist = exports.version = exports.wordlists = exports.utils = exports.logger = exports.errors = exports.constants = exports.FixedNumber = exports.BigNumber = exports.ContractFactory = exports.Contract = exports.BaseContract = exports.providers = exports.getDefaultProvider = exports.VoidSigner = exports.Wallet = exports.Signer = exports.ethers = void 0;
// To modify this file, you must update ./misc/admin/lib/cmds/update-exports.js
var ethers = __importStar(require("./ethers"));
exports.ethers = ethers;
try {
    var anyGlobal = window;
    if (anyGlobal._ethers == null) {
        anyGlobal._ethers = ethers;
    }
}
catch (error) { }
var ethers_1 = require("./ethers");
Object.defineProperty(exports, "Signer", { enumerable: true, get: function () { return ethers_1.Signer; } });
Object.defineProperty(exports, "Wallet", { enumerable: true, get: function () { return ethers_1.Wallet; } });
Object.defineProperty(exports, "VoidSigner", { enumerable: true, get: function () { return ethers_1.VoidSigner; } });
Object.defineProperty(exports, "getDefaultProvider", { enumerable: true, get: function () { return ethers_1.getDefaultProvider; } });
Object.defineProperty(exports, "providers", { enumerable: true, get: function () { return ethers_1.providers; } });
Object.defineProperty(exports, "BaseContract", { enumerable: true, get: function () { return ethers_1.BaseContract; } });
Object.defineProperty(exports, "Contract", { enumerable: true, get: function () { return ethers_1.Contract; } });
Object.defineProperty(exports, "ContractFactory", { enumerable: true, get: function () { return ethers_1.ContractFactory; } });
Object.defineProperty(exports, "BigNumber", { enumerable: true, get: function () { return ethers_1.BigNumber; } });
Object.defineProperty(exports, "FixedNumber", { enumerable: true, get: function () { return ethers_1.FixedNumber; } });
Object.defineProperty(exports, "constants", { enumerable: true, get: function () { return ethers_1.constants; } });
Object.defineProperty(exports, "errors", { enumerable: true, get: function () { return ethers_1.errors; } });
Object.defineProperty(exports, "logger", { enumerable: true, get: function () { return ethers_1.logger; } });
Object.defineProperty(exports, "utils", { enumerable: true, get: function () { return ethers_1.utils; } });
Object.defineProperty(exports, "wordlists", { enumerable: true, get: function () { return ethers_1.wordlists; } });
////////////////////////
// Compile-Time Constants
Object.defineProperty(exports, "version", { enumerable: true, get: function () { return ethers_1.version; } });
Object.defineProperty(exports, "Wordlist", { enumerable: true, get: function () { return ethers_1.Wordlist; } });
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"ethers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethers\\lib\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-method-registry\\dist\\index.js", {"./abi.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-method-registry\\dist\\abi.json","./registry-map.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-method-registry\\dist\\registry-map.json","ethjs":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-method-registry\dist\index.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MethodRegistry = void 0;
const ethjs_1 = __importDefault(require("ethjs"));
const registry_map_json_1 = __importDefault(require("./registry-map.json"));
const abi_json_1 = __importDefault(require("./abi.json"));
class MethodRegistry {
    constructor(opts) {
        if (!opts.provider) {
            throw new Error("Missing required 'provider' option");
        }
        this.provider = opts.provider;
        this.eth = new ethjs_1.default(this.provider);
        const address = registry_map_json_1.default[opts.network || '1'];
        if (!address) {
            throw new Error('No method registry found on the requested network.');
        }
        this.registry = this.eth.contract(abi_json_1.default).at(address);
    }
    /**
   * @param bytes - The `0x`-prefixed hexadecimal string representing the four-byte signature of the contract method to lookup.
   */
    async lookup(bytes) {
        const result = await this.registry.entries(bytes);
        if (result) {
            return result[0];
        }
        return undefined;
    }
    parse(signature) {
        const rawName = signature.match(/^([^)(]*)\((.*)\)([^)(]*)$/u);
        let parsedName;
        if (rawName) {
            parsedName = rawName[1].charAt(0).toUpperCase() + rawName[1].slice(1).split(/(?=[A-Z])/u).join(' ');
        }
        else {
            parsedName = '';
        }
        if (rawName) {
            const match = signature.match(new RegExp(`${rawName[1]}\\(+([a-z1-9,()\\[\\]]+)\\)`, 'u'));
            let matches;
            let args = [];
            if (match) {
                matches = match[1].match(/[A-z1-9]+/gu);
                if (matches) {
                    args = matches.map((arg) => {
                        return { type: arg };
                    });
                }
            }
            return {
                name: parsedName,
                args,
            };
        }
        return {};
    }
}
exports.MethodRegistry = MethodRegistry;
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"eth-method-registry",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-method-registry\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\utils\\fetch-with-cache.js", {"../../../shared/constants/time":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\time.js","../../../shared/modules/fetch-with-timeout":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\fetch-with-timeout.js","./storage-helpers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\utils\\storage-helpers.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\ui\helpers\utils\fetch-with-cache.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _time = require("../../../shared/constants/time");

var _fetchWithTimeout = _interopRequireDefault(require("../../../shared/modules/fetch-with-timeout"));

var _storageHelpers = require("./storage-helpers");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const fetchWithCache = async (url, fetchOptions = {}, {
  cacheRefreshTime = _time.MINUTE * 6,
  timeout = _time.SECOND * 30
} = {}) => {
  if (fetchOptions.body || fetchOptions.method && fetchOptions.method !== 'GET') {
    throw new Error('fetchWithCache only supports GET requests');
  }

  if (!(fetchOptions.headers instanceof window.Headers)) {
    fetchOptions.headers = new window.Headers(fetchOptions.headers);
  }

  if (fetchOptions.headers.has('Content-Type') && fetchOptions.headers.get('Content-Type') !== 'application/json') {
    throw new Error('fetchWithCache only supports JSON responses');
  }

  const currentTime = Date.now();
  const cacheKey = `cachedFetch:${url}`;
  const {
    cachedResponse,
    cachedTime
  } = (await (0, _storageHelpers.getStorageItem)(cacheKey)) || {};

  if (cachedResponse && currentTime - cachedTime < cacheRefreshTime) {
    return cachedResponse;
  }

  fetchOptions.headers.set('Content-Type', 'application/json');
  const fetchWithTimeout = (0, _fetchWithTimeout.default)(timeout);
  const response = await fetchWithTimeout(url, _objectSpread({
    referrerPolicy: 'no-referrer-when-downgrade',
    body: null,
    method: 'GET',
    mode: 'cors'
  }, fetchOptions));

  if (!response.ok) {
    throw new Error(`Fetch failed with status '${response.status}': '${response.statusText}'`);
  }

  const responseJson = await response.json();
  const cacheEntry = {
    cachedResponse: responseJson,
    cachedTime: currentTime
  };
  await (0, _storageHelpers.setStorageItem)(cacheKey, cacheEntry);
  return responseJson;
};

var _default = fetchWithCache;
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\utils\\fetch-with-cache.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\gas.js", {"../../ui/pages/send/send.constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\pages\\send\\send.constants.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\shared\constants\gas.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PRIORITY_LEVELS = exports.NETWORK_CONGESTION_THRESHOLDS = exports.GAS_RECOMMENDATIONS = exports.GAS_LIMITS = exports.GAS_ESTIMATE_TYPES = exports.EDIT_GAS_MODES = exports.CUSTOM_GAS_ESTIMATE = void 0;

var _ethereumjsUtil = require("ethereumjs-util");

var _send = require("../../ui/pages/send/send.constants");

const ONE_HUNDRED_THOUSAND = 100000;
const GAS_LIMITS = {
  // maximum gasLimit of a simple send
  SIMPLE: (0, _ethereumjsUtil.addHexPrefix)(_send.MIN_GAS_LIMIT_HEX),
  // a base estimate for token transfers.
  BASE_TOKEN_ESTIMATE: (0, _ethereumjsUtil.addHexPrefix)(ONE_HUNDRED_THOUSAND.toString(16))
};
/**
 * These are already declared in @metamask/controllers but importing them from
 * that module and re-exporting causes the UI bundle size to expand beyond 4MB
 */

exports.GAS_LIMITS = GAS_LIMITS;
const GAS_ESTIMATE_TYPES = {
  FEE_MARKET: 'fee-market',
  LEGACY: 'legacy',
  ETH_GASPRICE: 'eth_gasPrice',
  NONE: 'none'
};
/**
 * These represent gas recommendation levels presented in the UI
 */

exports.GAS_ESTIMATE_TYPES = GAS_ESTIMATE_TYPES;
const GAS_RECOMMENDATIONS = {
  LOW: 'low',
  MEDIUM: 'medium',
  HIGH: 'high'
};
/**
 * These represent types of gas estimation
 */

exports.GAS_RECOMMENDATIONS = GAS_RECOMMENDATIONS;
const PRIORITY_LEVELS = {
  TEN_PERCENT_INCREASED: 'tenPercentIncreased',
  LOW: 'low',
  MEDIUM: 'medium',
  HIGH: 'high',
  CUSTOM: 'custom',
  DAPP_SUGGESTED: 'dappSuggested'
};
/**
 * Represents the user customizing their gas preference
 */

exports.PRIORITY_LEVELS = PRIORITY_LEVELS;
const CUSTOM_GAS_ESTIMATE = 'custom';
/**
 * These represent the different edit modes presented in the UI
 */

exports.CUSTOM_GAS_ESTIMATE = CUSTOM_GAS_ESTIMATE;
const EDIT_GAS_MODES = {
  SPEED_UP: 'speed-up',
  CANCEL: 'cancel',
  MODIFY_IN_PLACE: 'modify-in-place',
  SWAPS: 'swaps'
};
/**
 * Represents levels for `networkCongestion` (calculated along with gas fee
 * estimates; represents a number between 0 and 1) that we use to render the
 * network status slider on the send transaction screen and inform users when
 * gas fees are high
 */

exports.EDIT_GAS_MODES = EDIT_GAS_MODES;
const NETWORK_CONGESTION_THRESHOLDS = {
  NOT_BUSY: 0,
  STABLE: 0.33,
  BUSY: 0.66
};
exports.NETWORK_CONGESTION_THRESHOLDS = NETWORK_CONGESTION_THRESHOLDS;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\gas.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\transaction.utils.js", {"ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\shared\modules\transaction.utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isEIP1559Transaction = isEIP1559Transaction;
exports.isLegacyTransaction = isLegacyTransaction;
exports.transactionMatchesNetwork = transactionMatchesNetwork;
exports.txParamsAreDappSuggested = txParamsAreDappSuggested;

var _ethereumjsUtil = require("ethereumjs-util");

function transactionMatchesNetwork(transaction, chainId, networkId) {
  if (typeof transaction.chainId !== 'undefined') {
    return transaction.chainId === chainId;
  }

  return transaction.metamaskNetworkId === networkId;
}
/**
 * Determines if the maxFeePerGas and maxPriorityFeePerGas fields are supplied
 * and valid inputs. This will return false for non hex string inputs.
 *
 * @param {__import__("../constants/transaction").TransactionMeta} transaction -
 *  the transaction to check
 * @returns {boolean} true if transaction uses valid EIP1559 fields
 */


function isEIP1559Transaction(transaction) {
  var _transaction$txParams, _transaction$txParams2;

  return (0, _ethereumjsUtil.isHexString)(transaction === null || transaction === void 0 ? void 0 : (_transaction$txParams = transaction.txParams) === null || _transaction$txParams === void 0 ? void 0 : _transaction$txParams.maxFeePerGas) && (0, _ethereumjsUtil.isHexString)(transaction === null || transaction === void 0 ? void 0 : (_transaction$txParams2 = transaction.txParams) === null || _transaction$txParams2 === void 0 ? void 0 : _transaction$txParams2.maxPriorityFeePerGas);
}
/**
 * Determine if the maxFeePerGas and maxPriorityFeePerGas fields are not
 * supplied and that the gasPrice field is valid if it is provided. This will
 * return false if gasPrice is a non hex string.
 *
 * @param {__import__("../constants/transaction").TransactionMeta} transaction -
 *  the transaction to check
 * @returns {boolean} true if transaction uses valid Legacy fields OR lacks
 *  EIP1559 fields
 */


function isLegacyTransaction(transaction) {
  return typeof transaction.txParams.maxFeePerGas === 'undefined' && typeof transaction.txParams.maxPriorityFeePerGas === 'undefined' && (typeof transaction.txParams.gasPrice === 'undefined' || (0, _ethereumjsUtil.isHexString)(transaction.txParams.gasPrice));
}
/**
 * Determine if a transactions gas fees in txParams match those in its dappSuggestedGasFees property
 *
 * @param {__import__("../constants/transaction").TransactionMeta} transaction -
 *  the transaction to check
 * @returns {boolean} true if both the txParams and dappSuggestedGasFees are objects with truthy gas fee properties,
 *   and those properties are strictly equal
 */


function txParamsAreDappSuggested(transaction) {
  var _transaction$dappSugg, _transaction$dappSugg2, _transaction$dappSugg3;

  const {
    gasPrice,
    maxPriorityFeePerGas,
    maxFeePerGas
  } = (transaction === null || transaction === void 0 ? void 0 : transaction.txParams) || {};
  return gasPrice && gasPrice === (transaction === null || transaction === void 0 ? void 0 : (_transaction$dappSugg = transaction.dappSuggestedGasFees) === null || _transaction$dappSugg === void 0 ? void 0 : _transaction$dappSugg.gasPrice) || maxPriorityFeePerGas && maxFeePerGas && (transaction === null || transaction === void 0 ? void 0 : (_transaction$dappSugg2 = transaction.dappSuggestedGasFees) === null || _transaction$dappSugg2 === void 0 ? void 0 : _transaction$dappSugg2.maxPriorityFeePerGas) === maxPriorityFeePerGas && (transaction === null || transaction === void 0 ? void 0 : (_transaction$dappSugg3 = transaction.dappSuggestedGasFees) === null || _transaction$dappSugg3 === void 0 ? void 0 : _transaction$dappSugg3.maxFeePerGas) === maxFeePerGas;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\transaction.utils.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\pages\\swaps\\swaps.util.js", {"../../../shared/constants/network":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\network.js","../../../shared/constants/swaps":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\swaps.js","../../../shared/constants/time":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\time.js","../../../shared/constants/transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\transaction.js","../../../shared/modules/conversion.utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\conversion.utils.js","../../../shared/modules/hexstring-utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\hexstring-utils.js","../../../shared/modules/swaps.utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\swaps.utils.js","../../helpers/utils/confirm-tx.util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\utils\\confirm-tx.util.js","../../helpers/utils/conversions.util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\utils\\conversions.util.js","../../helpers/utils/fetch-with-cache":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\utils\\fetch-with-cache.js","../../helpers/utils/token-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\utils\\token-util.js","../../helpers/utils/util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\utils\\util.js","../send/send.utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\pages\\send\\send.utils.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","bignumber.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bignumber.js\\bignumber.js","human-standard-token-abi":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\human-standard-token-abi\\index.js","loglevel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\ui\pages\swaps\swaps.util.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.countDecimals = void 0;
exports.fetchAggregatorMetadata = fetchAggregatorMetadata;
exports.fetchSwapsFeatureFlags = fetchSwapsFeatureFlags;
exports.fetchSwapsGasPrices = fetchSwapsGasPrices;
exports.fetchToken = fetchToken;
exports.fetchTokenBalance = fetchTokenBalance;
exports.fetchTokenPrice = fetchTokenPrice;
exports.fetchTokens = fetchTokens;
exports.fetchTopAssets = fetchTopAssets;
exports.fetchTradesInfo = fetchTradesInfo;
exports.formatSwapsValueForDisplay = formatSwapsValueForDisplay;
exports.getNetworkNameByChainId = exports.getFeeForSmartTransaction = exports.getBaseApi = void 0;
exports.getRenderableNetworkFeesForQuote = getRenderableNetworkFeesForQuote;
exports.getSwapsLivenessForNetwork = void 0;
exports.getSwapsTokensReceivedFromTxMeta = getSwapsTokensReceivedFromTxMeta;
exports.parseSmartTransactionsError = exports.isContractAddressValid = void 0;
exports.quotesToRenderableData = quotesToRenderableData;
exports.stxErrorTypes = exports.smartTransactionsErrorMessages = exports.showRemainingTimeInMinAndSec = exports.shouldEnableDirectWrapping = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _loglevel = _interopRequireDefault(require("loglevel"));

var _bignumber = _interopRequireDefault(require("bignumber.js"));

var _humanStandardTokenAbi = _interopRequireDefault(require("human-standard-token-abi"));

var _swaps = require("../../../shared/constants/swaps");

var _transaction = require("../../../shared/constants/transaction");

var _swaps2 = require("../../../shared/modules/swaps.utils");

var _network = require("../../../shared/constants/network");

var _time = require("../../../shared/constants/time");

var _tokenUtil = require("../../helpers/utils/token-util");

var _util = require("../../helpers/utils/util");

var _conversions = require("../../helpers/utils/conversions.util");

var _conversion = require("../../../shared/modules/conversion.utils");

var _confirmTx = require("../../helpers/utils/confirm-tx.util");

var _fetchWithCache = _interopRequireDefault(require("../../helpers/utils/fetch-with-cache"));

var _send = require("../send/send.utils");

var _hexstringUtils = require("../../../shared/modules/hexstring-utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const TOKEN_TRANSFER_LOG_TOPIC_HASH = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';
const CACHE_REFRESH_FIVE_MINUTES = 300000;
const clientIdHeader = {
  'X-Client-Id': _swaps.SWAPS_CLIENT_ID
};
/**
 * @param {string} type - Type of an API call, e.g. "tokens"
 * @param {string} chainId
 * @returns string
 */

const getBaseUrlForNewSwapsApi = (type, chainId) => {
  const useDevApis = false;
  const v2ApiBaseUrl = useDevApis ? _swaps.SWAPS_DEV_API_V2_BASE_URL : _swaps.SWAPS_API_V2_BASE_URL;
  const gasApiBaseUrl = useDevApis ? _swaps.GAS_DEV_API_BASE_URL : _swaps.GAS_API_BASE_URL;
  const noNetworkSpecificTypes = ['refreshTime']; // These types don't need network info in the URL.

  if (noNetworkSpecificTypes.includes(type)) {
    return v2ApiBaseUrl;
  }

  const chainIdDecimal = chainId && parseInt(chainId, 16);
  const gasApiTypes = ['gasPrices'];

  if (gasApiTypes.includes(type)) {
    return `${gasApiBaseUrl}/networks/${chainIdDecimal}`; // Gas calculations are in its own repo.
  }

  return `${v2ApiBaseUrl}/networks/${chainIdDecimal}`;
};

const TEST_CHAIN_IDS = [_network.RINKEBY_CHAIN_ID, _network.LOCALHOST_CHAIN_ID];

const getBaseApi = function (type, chainId = _network.MAINNET_CHAIN_ID) {
  // eslint-disable-next-line no-param-reassign
  chainId = TEST_CHAIN_IDS.includes(chainId) ? _network.MAINNET_CHAIN_ID : chainId;
  const baseUrl = getBaseUrlForNewSwapsApi(type, chainId);
  const chainIdDecimal = chainId && parseInt(chainId, 16);

  if (!baseUrl) {
    throw new Error(`Swaps API calls are disabled for chainId: ${chainId}`);
  }

  switch (type) {
    case 'trade':
      return `${baseUrl}/trades?`;

    case 'tokens':
      return `${baseUrl}/tokens`;

    case 'token':
      return `${baseUrl}/token`;

    case 'topAssets':
      return `${baseUrl}/topAssets`;

    case 'aggregatorMetadata':
      return `${baseUrl}/aggregatorMetadata`;

    case 'gasPrices':
      return `${baseUrl}/gasPrices`;

    case 'network':
      // Only use v2 for this endpoint.
      return `${_swaps.SWAPS_API_V2_BASE_URL}/networks/${chainIdDecimal}`;

    default:
      throw new Error('getBaseApi requires an api call type');
  }
};

exports.getBaseApi = getBaseApi;

const validHex = string => Boolean(string === null || string === void 0 ? void 0 : string.match(/^0x[a-f0-9]+$/u));

const truthyString = string => Boolean(string === null || string === void 0 ? void 0 : string.length);

const truthyDigitString = string => truthyString(string) && Boolean(string.match(/^\d+$/u));

const QUOTE_VALIDATORS = [{
  property: 'trade',
  type: 'object',
  validator: trade => trade && validHex(trade.data) && (0, _hexstringUtils.isValidHexAddress)(trade.to, {
    allowNonPrefixed: false
  }) && (0, _hexstringUtils.isValidHexAddress)(trade.from, {
    allowNonPrefixed: false
  }) && truthyString(trade.value)
}, {
  property: 'approvalNeeded',
  type: 'object',
  validator: approvalTx => approvalTx === null || approvalTx && validHex(approvalTx.data) && (0, _hexstringUtils.isValidHexAddress)(approvalTx.to, {
    allowNonPrefixed: false
  }) && (0, _hexstringUtils.isValidHexAddress)(approvalTx.from, {
    allowNonPrefixed: false
  })
}, {
  property: 'sourceAmount',
  type: 'string',
  validator: truthyDigitString
}, {
  property: 'destinationAmount',
  type: 'string',
  validator: truthyDigitString
}, {
  property: 'sourceToken',
  type: 'string',
  validator: input => (0, _hexstringUtils.isValidHexAddress)(input, {
    allowNonPrefixed: false
  })
}, {
  property: 'destinationToken',
  type: 'string',
  validator: input => (0, _hexstringUtils.isValidHexAddress)(input, {
    allowNonPrefixed: false
  })
}, {
  property: 'aggregator',
  type: 'string',
  validator: truthyString
}, {
  property: 'aggType',
  type: 'string',
  validator: truthyString
}, {
  property: 'error',
  type: 'object',
  validator: error => error === null || typeof error === 'object'
}, {
  property: 'averageGas',
  type: 'number'
}, {
  property: 'maxGas',
  type: 'number'
}, {
  property: 'gasEstimate',
  type: 'number|undefined',
  validator: gasEstimate => gasEstimate === undefined || gasEstimate > 0
}, {
  property: 'fee',
  type: 'number'
}];
const TOKEN_VALIDATORS = [{
  property: 'address',
  type: 'string',
  validator: input => (0, _hexstringUtils.isValidHexAddress)(input, {
    allowNonPrefixed: false
  })
}, {
  property: 'symbol',
  type: 'string',
  validator: string => truthyString(string) && string.length <= 12
}, {
  property: 'decimals',
  type: 'string|number',
  validator: string => Number(string) >= 0 && Number(string) <= 36
}];
const TOP_ASSET_VALIDATORS = TOKEN_VALIDATORS.slice(0, 2);
const AGGREGATOR_METADATA_VALIDATORS = [{
  property: 'color',
  type: 'string',
  validator: string => Boolean(string.match(/^#[A-Fa-f0-9]+$/u))
}, {
  property: 'title',
  type: 'string',
  validator: truthyString
}, {
  property: 'icon',
  type: 'string',
  validator: string => Boolean(string.match(/^data:image/u))
}];

const isValidDecimalNumber = string => !isNaN(string) && string.match(/^[.0-9]+$/u) && !isNaN(parseFloat(string));

const SWAP_GAS_PRICE_VALIDATOR = [{
  property: 'SafeGasPrice',
  type: 'string',
  validator: isValidDecimalNumber
}, {
  property: 'ProposeGasPrice',
  type: 'string',
  validator: isValidDecimalNumber
}, {
  property: 'FastGasPrice',
  type: 'string',
  validator: isValidDecimalNumber
}];

function validateData(validators, object, urlUsed) {
  return validators.every(({
    property,
    type,
    validator
  }) => {
    const types = type.split('|');
    const valid = types.some(_type => typeof object[property] === _type) && (!validator || validator(object[property]));

    if (!valid) {
      _loglevel.default.error(`response to GET ${urlUsed} invalid for property ${property}; value was:`, object[property], '| type was: ', typeof object[property]);
    }

    return valid;
  });
}

const shouldEnableDirectWrapping = (chainId, sourceToken, destinationToken) => {
  var _SWAPS_CHAINID_DEFAUL;

  if (!sourceToken || !destinationToken) {
    return false;
  }

  const wrappedToken = _swaps.SWAPS_WRAPPED_TOKENS_ADDRESSES[chainId];
  const nativeToken = (_SWAPS_CHAINID_DEFAUL = _swaps.SWAPS_CHAINID_DEFAULT_TOKEN_MAP[chainId]) === null || _SWAPS_CHAINID_DEFAUL === void 0 ? void 0 : _SWAPS_CHAINID_DEFAUL.address;
  const sourceTokenLowerCase = sourceToken.toLowerCase();
  const destinationTokenLowerCase = destinationToken.toLowerCase();
  return sourceTokenLowerCase === wrappedToken && destinationTokenLowerCase === nativeToken || sourceTokenLowerCase === nativeToken && destinationTokenLowerCase === wrappedToken;
};

exports.shouldEnableDirectWrapping = shouldEnableDirectWrapping;

async function fetchTradesInfo({
  slippage,
  sourceToken,
  sourceDecimals,
  destinationToken,
  value,
  fromAddress,
  exchangeList
}, {
  chainId
}) {
  const urlParams = {
    destinationToken,
    sourceToken,
    sourceAmount: (0, _tokenUtil.calcTokenValue)(value, sourceDecimals).toString(10),
    slippage,
    timeout: _time.SECOND * 10,
    walletAddress: fromAddress
  };

  if (exchangeList) {
    urlParams.exchangeList = exchangeList;
  }

  if (shouldEnableDirectWrapping(chainId, sourceToken, destinationToken)) {
    urlParams.enableDirectWrapping = true;
  }

  const queryString = new URLSearchParams(urlParams).toString();
  const tradeURL = `${getBaseApi('trade', chainId)}${queryString}`;
  const tradesResponse = await (0, _fetchWithCache.default)(tradeURL, {
    method: 'GET',
    headers: clientIdHeader
  }, {
    cacheRefreshTime: 0,
    timeout: _time.SECOND * 15
  });
  const newQuotes = tradesResponse.reduce((aggIdTradeMap, quote) => {
    if (quote.trade && !quote.error && validateData(QUOTE_VALIDATORS, quote, tradeURL)) {
      const constructedTrade = (0, _util.constructTxParams)({
        to: quote.trade.to,
        from: quote.trade.from,
        data: quote.trade.data,
        amount: (0, _conversions.decimalToHex)(quote.trade.value),
        gas: (0, _conversions.decimalToHex)(quote.maxGas)
      });
      let {
        approvalNeeded
      } = quote;

      if (approvalNeeded) {
        approvalNeeded = (0, _util.constructTxParams)(_objectSpread({}, approvalNeeded));
      }

      return _objectSpread(_objectSpread({}, aggIdTradeMap), {}, {
        [quote.aggregator]: _objectSpread(_objectSpread({}, quote), {}, {
          slippage,
          trade: constructedTrade,
          approvalNeeded
        })
      });
    }

    return aggIdTradeMap;
  }, {});
  return newQuotes;
}

async function fetchToken(contractAddress, chainId) {
  const tokenUrl = getBaseApi('token', chainId);
  const token = await (0, _fetchWithCache.default)(`${tokenUrl}?address=${contractAddress}`, {
    method: 'GET',
    headers: clientIdHeader
  }, {
    cacheRefreshTime: CACHE_REFRESH_FIVE_MINUTES
  });
  return token;
}

async function fetchTokens(chainId) {
  const tokensUrl = getBaseApi('tokens', chainId);
  const tokens = await (0, _fetchWithCache.default)(tokensUrl, {
    method: 'GET',
    headers: clientIdHeader
  }, {
    cacheRefreshTime: CACHE_REFRESH_FIVE_MINUTES
  });
  const filteredTokens = [_swaps.SWAPS_CHAINID_DEFAULT_TOKEN_MAP[chainId], ...tokens.filter(token => {
    return validateData(TOKEN_VALIDATORS, token, tokensUrl) && !((0, _swaps2.isSwapsDefaultTokenSymbol)(token.symbol, chainId) || (0, _swaps2.isSwapsDefaultTokenAddress)(token.address, chainId));
  })];
  return filteredTokens;
}

async function fetchAggregatorMetadata(chainId) {
  const aggregatorMetadataUrl = getBaseApi('aggregatorMetadata', chainId);
  const aggregators = await (0, _fetchWithCache.default)(aggregatorMetadataUrl, {
    method: 'GET',
    headers: clientIdHeader
  }, {
    cacheRefreshTime: CACHE_REFRESH_FIVE_MINUTES
  });
  const filteredAggregators = {};

  for (const aggKey in aggregators) {
    if (validateData(AGGREGATOR_METADATA_VALIDATORS, aggregators[aggKey], aggregatorMetadataUrl)) {
      filteredAggregators[aggKey] = aggregators[aggKey];
    }
  }

  return filteredAggregators;
}

async function fetchTopAssets(chainId) {
  const topAssetsUrl = getBaseApi('topAssets', chainId);
  const response = await (0, _fetchWithCache.default)(topAssetsUrl, {
    method: 'GET',
    headers: clientIdHeader
  }, {
    cacheRefreshTime: CACHE_REFRESH_FIVE_MINUTES
  });
  const topAssetsMap = response.reduce((_topAssetsMap, asset, index) => {
    if (validateData(TOP_ASSET_VALIDATORS, asset, topAssetsUrl)) {
      return _objectSpread(_objectSpread({}, _topAssetsMap), {}, {
        [asset.address]: {
          index: String(index)
        }
      });
    }

    return _topAssetsMap;
  }, {});
  return topAssetsMap;
}

async function fetchSwapsFeatureFlags() {
  const v2ApiBaseUrl = false ? _swaps.SWAPS_DEV_API_V2_BASE_URL : _swaps.SWAPS_API_V2_BASE_URL;
  const response = await (0, _fetchWithCache.default)(`${v2ApiBaseUrl}/featureFlags`, {
    method: 'GET',
    headers: clientIdHeader
  }, {
    cacheRefreshTime: 600000
  });
  return response;
}

async function fetchTokenPrice(address) {
  var _prices$address;

  const query = `contract_addresses=${address}&vs_currencies=eth`;
  const prices = await (0, _fetchWithCache.default)(`https://api.coingecko.com/api/v3/simple/token_price/ethereum?${query}`, {
    method: 'GET'
  }, {
    cacheRefreshTime: 60000
  });
  return prices && ((_prices$address = prices[address]) === null || _prices$address === void 0 ? void 0 : _prices$address.eth);
}

async function fetchTokenBalance(address, userAddress) {
  const tokenContract = global.eth.contract(_humanStandardTokenAbi.default).at(address);
  const tokenBalancePromise = tokenContract ? tokenContract.balanceOf(userAddress) : Promise.resolve();
  const usersToken = await tokenBalancePromise;
  return usersToken;
}

async function fetchSwapsGasPrices(chainId) {
  const gasPricesUrl = getBaseApi('gasPrices', chainId);
  const response = await (0, _fetchWithCache.default)(gasPricesUrl, {
    method: 'GET',
    headers: clientIdHeader
  }, {
    cacheRefreshTime: 30000
  });
  const responseIsValid = validateData(SWAP_GAS_PRICE_VALIDATOR, response, gasPricesUrl);

  if (!responseIsValid) {
    throw new Error(`${gasPricesUrl} response is invalid`);
  }

  const {
    SafeGasPrice: safeLow,
    ProposeGasPrice: average,
    FastGasPrice: fast
  } = response;
  return {
    safeLow,
    average,
    fast
  };
}

const getFeeForSmartTransaction = ({
  chainId,
  currentCurrency,
  conversionRate,
  nativeCurrencySymbol,
  feeInWeiDec
}) => {
  const feeInWeiHex = (0, _conversions.decimalToHex)(feeInWeiDec);
  const ethFee = (0, _conversions.getValueFromWeiHex)({
    value: feeInWeiHex,
    toDenomination: _network.ETH_SYMBOL,
    numberOfDecimals: 5
  });
  const rawNetworkFees = (0, _conversions.getValueFromWeiHex)({
    value: feeInWeiHex,
    toCurrency: currentCurrency,
    conversionRate,
    numberOfDecimals: 2
  });
  const formattedNetworkFee = (0, _confirmTx.formatCurrency)(rawNetworkFees, currentCurrency);
  const chainCurrencySymbolToUse = nativeCurrencySymbol || _swaps.SWAPS_CHAINID_DEFAULT_TOKEN_MAP[chainId].symbol;
  return {
    feeInFiat: formattedNetworkFee,
    feeInEth: `${ethFee} ${chainCurrencySymbolToUse}`
  };
};

exports.getFeeForSmartTransaction = getFeeForSmartTransaction;

function getRenderableNetworkFeesForQuote({
  tradeGas,
  approveGas,
  gasPrice,
  currentCurrency,
  conversionRate,
  tradeValue,
  sourceSymbol,
  sourceAmount,
  chainId,
  nativeCurrencySymbol
}) {
  const totalGasLimitForCalculation = new _bignumber.default(tradeGas || '0x0', 16).plus(approveGas || '0x0', 16).toString(16);
  const gasTotalInWeiHex = (0, _send.calcGasTotal)(totalGasLimitForCalculation, gasPrice);
  const nonGasFee = new _bignumber.default(tradeValue, 16).minus((0, _swaps2.isSwapsDefaultTokenSymbol)(sourceSymbol, chainId) ? sourceAmount : 0, 10).toString(16);
  const totalWeiCost = new _bignumber.default(gasTotalInWeiHex, 16).plus(nonGasFee, 16).toString(16);
  const ethFee = (0, _conversions.getValueFromWeiHex)({
    value: totalWeiCost,
    toDenomination: 'ETH',
    numberOfDecimals: 5
  });
  const rawNetworkFees = (0, _conversions.getValueFromWeiHex)({
    value: totalWeiCost,
    toCurrency: currentCurrency,
    conversionRate,
    numberOfDecimals: 2
  });
  const formattedNetworkFee = (0, _confirmTx.formatCurrency)(rawNetworkFees, currentCurrency);
  const chainCurrencySymbolToUse = nativeCurrencySymbol || _swaps.SWAPS_CHAINID_DEFAULT_TOKEN_MAP[chainId].symbol;
  return {
    rawNetworkFees,
    rawEthFee: ethFee,
    feeInFiat: formattedNetworkFee,
    feeInEth: `${ethFee} ${chainCurrencySymbolToUse}`,
    nonGasFee
  };
}

function quotesToRenderableData(quotes, gasPrice, conversionRate, currentCurrency, approveGas, tokenConversionRates, chainId, smartTransactionEstimatedGas, nativeCurrencySymbol) {
  return Object.values(quotes).map(quote => {
    const {
      destinationAmount = 0,
      sourceAmount = 0,
      sourceTokenInfo,
      destinationTokenInfo,
      slippage,
      aggType,
      aggregator,
      gasEstimateWithRefund,
      averageGas,
      fee,
      trade
    } = quote;
    const sourceValue = (0, _tokenUtil.calcTokenAmount)(sourceAmount, sourceTokenInfo.decimals).toString(10);
    const destinationValue = (0, _tokenUtil.calcTokenAmount)(destinationAmount, destinationTokenInfo.decimals).toPrecision(8);
    let feeInFiat = null;
    let feeInEth = null;
    let rawNetworkFees = null;
    let rawEthFee = null;
    ({
      feeInFiat,
      feeInEth,
      rawNetworkFees,
      rawEthFee
    } = getRenderableNetworkFeesForQuote({
      tradeGas: gasEstimateWithRefund || (0, _conversions.decimalToHex)(averageGas || 800000),
      approveGas,
      gasPrice,
      currentCurrency,
      conversionRate,
      tradeValue: trade.value,
      sourceSymbol: sourceTokenInfo.symbol,
      sourceAmount,
      chainId
    }));

    if (smartTransactionEstimatedGas) {
      ({
        feeInFiat,
        feeInEth
      } = getFeeForSmartTransaction({
        chainId,
        currentCurrency,
        conversionRate,
        nativeCurrencySymbol,
        estimatedFeeInWeiDec: smartTransactionEstimatedGas.feeEstimate
      }));
    }

    const slippageMultiplier = new _bignumber.default(100 - slippage).div(100);
    const minimumAmountReceived = new _bignumber.default(destinationValue).times(slippageMultiplier).toFixed(6);
    const tokenConversionRate = tokenConversionRates[destinationTokenInfo.address];
    const ethValueOfTrade = (0, _swaps2.isSwapsDefaultTokenSymbol)(destinationTokenInfo.symbol, chainId) ? (0, _tokenUtil.calcTokenAmount)(destinationAmount, destinationTokenInfo.decimals).minus(rawEthFee, 10) : new _bignumber.default(tokenConversionRate || 0, 10).times((0, _tokenUtil.calcTokenAmount)(destinationAmount, destinationTokenInfo.decimals), 10).minus(rawEthFee, 10);
    let liquiditySourceKey;
    let renderedSlippage = slippage;

    if (aggType === 'AGG') {
      liquiditySourceKey = 'swapAggregator';
    } else if (aggType === 'RFQ') {
      liquiditySourceKey = 'swapRequestForQuotation';
      renderedSlippage = 0;
    } else if (aggType === 'DEX') {
      liquiditySourceKey = 'swapDecentralizedExchange';
    } else if (aggType === 'CONTRACT') {
      liquiditySourceKey = 'swapDirectContract';
    } else {
      liquiditySourceKey = 'swapUnknown';
    }

    return {
      aggId: aggregator,
      amountReceiving: `${destinationValue} ${destinationTokenInfo.symbol}`,
      destinationTokenDecimals: destinationTokenInfo.decimals,
      destinationTokenSymbol: destinationTokenInfo.symbol,
      destinationTokenValue: formatSwapsValueForDisplay(destinationValue),
      destinationIconUrl: destinationTokenInfo.iconUrl,
      isBestQuote: quote.isBestQuote,
      liquiditySourceKey,
      feeInEth,
      detailedNetworkFees: `${feeInEth} (${feeInFiat})`,
      networkFees: feeInFiat,
      quoteSource: aggType,
      rawNetworkFees,
      slippage: renderedSlippage,
      sourceTokenDecimals: sourceTokenInfo.decimals,
      sourceTokenSymbol: sourceTokenInfo.symbol,
      sourceTokenValue: sourceValue,
      sourceTokenIconUrl: sourceTokenInfo.iconUrl,
      ethValueOfTrade,
      minimumAmountReceived,
      metaMaskFee: fee
    };
  });
}

function getSwapsTokensReceivedFromTxMeta(tokenSymbol, txMeta, tokenAddress, accountAddress, tokenDecimals, approvalTxMeta, chainId) {
  var _txMeta$txReceipt;

  const txReceipt = txMeta === null || txMeta === void 0 ? void 0 : txMeta.txReceipt;
  const networkAndAccountSupports1559 = (txMeta === null || txMeta === void 0 ? void 0 : (_txMeta$txReceipt = txMeta.txReceipt) === null || _txMeta$txReceipt === void 0 ? void 0 : _txMeta$txReceipt.type) === _transaction.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET;

  if ((0, _swaps2.isSwapsDefaultTokenSymbol)(tokenSymbol, chainId)) {
    if (!txReceipt || !txMeta || !txMeta.postTxBalance || !txMeta.preTxBalance) {
      return null;
    }

    let approvalTxGasCost = '0x0';

    if (approvalTxMeta && approvalTxMeta.txReceipt) {
      approvalTxGasCost = (0, _send.calcGasTotal)(approvalTxMeta.txReceipt.gasUsed, networkAndAccountSupports1559 ? approvalTxMeta.txReceipt.effectiveGasPrice // Base fee + priority fee.
      : approvalTxMeta.txParams.gasPrice);
    }

    const gasCost = (0, _send.calcGasTotal)(txReceipt.gasUsed, networkAndAccountSupports1559 ? txReceipt.effectiveGasPrice : txMeta.txParams.gasPrice);
    const totalGasCost = new _bignumber.default(gasCost, 16).plus(approvalTxGasCost, 16).toString(16);
    const preTxBalanceLessGasCost = (0, _conversion.subtractCurrencies)(txMeta.preTxBalance, totalGasCost, {
      aBase: 16,
      bBase: 16,
      toNumericBase: 'hex'
    });
    const ethReceived = (0, _conversion.subtractCurrencies)(txMeta.postTxBalance, preTxBalanceLessGasCost, {
      aBase: 16,
      bBase: 16,
      fromDenomination: 'WEI',
      toDenomination: 'ETH',
      toNumericBase: 'dec',
      numberOfDecimals: 6
    });
    return ethReceived;
  }

  const txReceiptLogs = txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.logs;

  if (txReceiptLogs && (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.status) !== '0x0') {
    const tokenTransferLog = txReceiptLogs.find(txReceiptLog => {
      const isTokenTransfer = txReceiptLog.topics && txReceiptLog.topics[0] === TOKEN_TRANSFER_LOG_TOPIC_HASH;
      const isTransferFromGivenToken = txReceiptLog.address === tokenAddress;
      const isTransferFromGivenAddress = txReceiptLog.topics && txReceiptLog.topics[2] && txReceiptLog.topics[2].match(accountAddress.slice(2));
      return isTokenTransfer && isTransferFromGivenToken && isTransferFromGivenAddress;
    });
    return tokenTransferLog ? (0, _util.toPrecisionWithoutTrailingZeros)((0, _tokenUtil.calcTokenAmount)(tokenTransferLog.data, tokenDecimals).toString(10), 6) : '';
  }

  return null;
}

function formatSwapsValueForDisplay(destinationAmount) {
  let amountToDisplay = (0, _util.toPrecisionWithoutTrailingZeros)(destinationAmount, 12);

  if (amountToDisplay.match(/e[+-]/u)) {
    amountToDisplay = new _bignumber.default(amountToDisplay).toFixed();
  }

  return amountToDisplay;
}
/**
 * Checks whether a contract address is valid before swapping tokens.
 *
 * @param {string} contractAddress - E.g. "0x881d40237659c251811cec9c364ef91dc08d300c" for mainnet
 * @param {string} chainId - The hex encoded chain ID to check
 * @returns {boolean} Whether a contract address is valid or not
 */


const isContractAddressValid = (contractAddress, chainId = _network.MAINNET_CHAIN_ID) => {
  if (!contractAddress || !_swaps.ALLOWED_CONTRACT_ADDRESSES[chainId]) {
    return false;
  }

  return _swaps.ALLOWED_CONTRACT_ADDRESSES[chainId].some( // Sometimes we get a contract address with a few upper-case chars and since addresses are
  // case-insensitive, we compare lowercase versions for validity.
  allowedContractAddress => contractAddress.toLowerCase() === allowedContractAddress.toLowerCase());
};
/**
 * @param {string} chainId
 * @returns string e.g. ethereum, bsc or polygon
 */


exports.isContractAddressValid = isContractAddressValid;

const getNetworkNameByChainId = chainId => {
  switch (chainId) {
    case _network.MAINNET_CHAIN_ID:
      return _swaps.ETHEREUM;

    case _network.BSC_CHAIN_ID:
      return _swaps.BSC;

    case _network.POLYGON_CHAIN_ID:
      return _swaps.POLYGON;

    case _network.RINKEBY_CHAIN_ID:
      return _swaps.RINKEBY;

    case _network.AVALANCHE_CHAIN_ID:
      return _swaps.AVALANCHE;

    default:
      return '';
  }
};
/**
 * It returns info about if Swaps are enabled and if we should use our new APIs for it.
 *
 * @param {object} swapsFeatureFlags
 * @param {string} chainId
 * @returns object with 2 items: "swapsFeatureIsLive"
 */


exports.getNetworkNameByChainId = getNetworkNameByChainId;

const getSwapsLivenessForNetwork = (swapsFeatureFlags = {}, chainId) => {
  const networkName = getNetworkNameByChainId(chainId); // Use old APIs for testnet and Rinkeby.

  if ([_network.LOCALHOST_CHAIN_ID, _network.RINKEBY_CHAIN_ID].includes(chainId)) {
    return {
      swapsFeatureIsLive: true
    };
  } // If a network name is not found in the list of feature flags, disable Swaps.


  if (!swapsFeatureFlags[networkName]) {
    return {
      swapsFeatureIsLive: false
    };
  }

  const isNetworkEnabledForNewApi = swapsFeatureFlags[networkName].extension_active;

  if (isNetworkEnabledForNewApi) {
    return {
      swapsFeatureIsLive: true
    };
  }

  return {
    swapsFeatureIsLive: swapsFeatureFlags[networkName].fallback_to_v1
  };
};
/**
 * @param {number} value
 * @returns number
 */


exports.getSwapsLivenessForNetwork = getSwapsLivenessForNetwork;

const countDecimals = value => {
  var _value$toString$split;

  if (!value || Math.floor(value) === value) {
    return 0;
  }

  return ((_value$toString$split = value.toString().split('.')[1]) === null || _value$toString$split === void 0 ? void 0 : _value$toString$split.length) || 0;
};

exports.countDecimals = countDecimals;

const showRemainingTimeInMinAndSec = remainingTimeInSec => {
  if (!Number.isInteger(remainingTimeInSec)) {
    return '0:00';
  }

  const minutes = Math.floor(remainingTimeInSec / 60);
  const seconds = remainingTimeInSec % 60;
  return `${minutes}:${seconds.toString().padStart(2, '0')}`;
};

exports.showRemainingTimeInMinAndSec = showRemainingTimeInMinAndSec;
const stxErrorTypes = ['unavailable', 'not_enough_funds'];
exports.stxErrorTypes = stxErrorTypes;
const smartTransactionsErrorMap = {
  unavailable: 'Smart Transactions are temporarily unavailable.',
  not_enough_funds: 'Not enough funds for a smart transaction.'
};

const smartTransactionsErrorMessages = errorType => {
  return smartTransactionsErrorMap[errorType] || smartTransactionsErrorMap.unavailable;
};

exports.smartTransactionsErrorMessages = smartTransactionsErrorMessages;

const parseSmartTransactionsError = errorMessage => {
  const errorJson = errorMessage.slice(12);
  return JSON.parse(errorJson.trim());
};

exports.parseSmartTransactionsError = parseSmartTransactionsError;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\pages\\swaps\\swaps.util.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\constants\\error-keys.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\ui\helpers\constants\error-keys.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UNSENDABLE_ASSET_ERROR_KEY = exports.TRANSACTION_NO_CONTRACT_ERROR_KEY = exports.TRANSACTION_ERROR_KEY = exports.INVALID_ASSET_TYPE = exports.INSUFFICIENT_FUNDS_FOR_GAS_ERROR_KEY = exports.INSUFFICIENT_FUNDS_ERROR_KEY = exports.GAS_PRICE_FETCH_FAILURE_ERROR_KEY = exports.GAS_PRICE_EXCESSIVE_ERROR_KEY = exports.GAS_LIMIT_TOO_LOW_ERROR_KEY = exports.ETH_GAS_PRICE_FETCH_WARNING_KEY = void 0;
const INSUFFICIENT_FUNDS_ERROR_KEY = 'insufficientFunds';
exports.INSUFFICIENT_FUNDS_ERROR_KEY = INSUFFICIENT_FUNDS_ERROR_KEY;
const GAS_LIMIT_TOO_LOW_ERROR_KEY = 'gasLimitTooLow';
exports.GAS_LIMIT_TOO_LOW_ERROR_KEY = GAS_LIMIT_TOO_LOW_ERROR_KEY;
const TRANSACTION_ERROR_KEY = 'transactionError';
exports.TRANSACTION_ERROR_KEY = TRANSACTION_ERROR_KEY;
const TRANSACTION_NO_CONTRACT_ERROR_KEY = 'transactionErrorNoContract';
exports.TRANSACTION_NO_CONTRACT_ERROR_KEY = TRANSACTION_NO_CONTRACT_ERROR_KEY;
const ETH_GAS_PRICE_FETCH_WARNING_KEY = 'ethGasPriceFetchWarning';
exports.ETH_GAS_PRICE_FETCH_WARNING_KEY = ETH_GAS_PRICE_FETCH_WARNING_KEY;
const GAS_PRICE_FETCH_FAILURE_ERROR_KEY = 'gasPriceFetchFailed';
exports.GAS_PRICE_FETCH_FAILURE_ERROR_KEY = GAS_PRICE_FETCH_FAILURE_ERROR_KEY;
const GAS_PRICE_EXCESSIVE_ERROR_KEY = 'gasPriceExcessive';
exports.GAS_PRICE_EXCESSIVE_ERROR_KEY = GAS_PRICE_EXCESSIVE_ERROR_KEY;
const UNSENDABLE_ASSET_ERROR_KEY = 'unsendableAsset';
exports.UNSENDABLE_ASSET_ERROR_KEY = UNSENDABLE_ASSET_ERROR_KEY;
const INSUFFICIENT_FUNDS_FOR_GAS_ERROR_KEY = 'insufficientFundsForGas';
exports.INSUFFICIENT_FUNDS_FOR_GAS_ERROR_KEY = INSUFFICIENT_FUNDS_FOR_GAS_ERROR_KEY;
const INVALID_ASSET_TYPE = 'invalidAssetType';
exports.INVALID_ASSET_TYPE = INVALID_ASSET_TYPE;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\constants\\error-keys.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethereumjs\\common\\dist.browser\\index.js", {"./chains":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethereumjs\\common\\dist.browser\\chains\\index.js","./eips":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethereumjs\\common\\dist.browser\\eips\\index.js","./hardforks":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethereumjs\\common\\dist.browser\\hardforks\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","crc-32":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\crc-32\\crc32.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\index.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ethereumjs\common\dist.browser\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Hardfork = exports.Chain = exports.CustomChain = void 0;
var events_1 = require("events");
var crc_32_1 = require("crc-32");
var ethereumjs_util_1 = require("ethereumjs-util");
var chains_1 = require("./chains");
var hardforks_1 = require("./hardforks");
var eips_1 = require("./eips");
var CustomChain;
(function (CustomChain) {
    /**
     * Polygon (Matic) Mainnet
     *
     * - [Documentation](https://docs.matic.network/docs/develop/network-details/network)
     */
    CustomChain["PolygonMainnet"] = "polygon-mainnet";
    /**
     * Polygon (Matic) Mumbai Testnet
     *
     * - [Documentation](https://docs.matic.network/docs/develop/network-details/network)
     */
    CustomChain["PolygonMumbai"] = "polygon-mumbai";
    /**
     * Arbitrum Rinkeby Testnet
     *
     * - [Documentation](https://developer.offchainlabs.com/docs/public_testnet)
     */
    CustomChain["ArbitrumRinkebyTestnet"] = "arbitrum-rinkeby-testnet";
    /**
     * xDai EVM sidechain with a native stable token
     *
     * - [Documentation](https://www.xdaichain.com/)
     */
    CustomChain["xDaiChain"] = "x-dai-chain";
})(CustomChain = exports.CustomChain || (exports.CustomChain = {}));
var Chain;
(function (Chain) {
    Chain[Chain["Mainnet"] = 1] = "Mainnet";
    Chain[Chain["Ropsten"] = 3] = "Ropsten";
    Chain[Chain["Rinkeby"] = 4] = "Rinkeby";
    Chain[Chain["Kovan"] = 42] = "Kovan";
    Chain[Chain["Goerli"] = 5] = "Goerli";
    Chain[Chain["Calaveras"] = 123] = "Calaveras";
})(Chain = exports.Chain || (exports.Chain = {}));
var Hardfork;
(function (Hardfork) {
    Hardfork["Chainstart"] = "chainstart";
    Hardfork["Homestead"] = "homestead";
    Hardfork["Dao"] = "dao";
    Hardfork["TangerineWhistle"] = "tangerineWhistle";
    Hardfork["SpuriousDragon"] = "spuriousDragon";
    Hardfork["Byzantium"] = "byzantium";
    Hardfork["Constantinople"] = "constantinople";
    Hardfork["Petersburg"] = "petersburg";
    Hardfork["Istanbul"] = "istanbul";
    Hardfork["MuirGlacier"] = "muirGlacier";
    Hardfork["Berlin"] = "berlin";
    Hardfork["London"] = "london";
})(Hardfork = exports.Hardfork || (exports.Hardfork = {}));
/**
 * Common class to access chain and hardfork parameters and to provide
 * a unified and shared view on the network and hardfork state.
 *
 * Use the {@link Common.custom} static constructor for creating simple
 * custom chain {@link Common} objects (more complete custom chain setups
 * can be created via the main constructor and the {@link CommonOpts.customChains} parameter).
 */
var Common = /** @class */ (function (_super) {
    __extends(Common, _super);
    /**
     * @constructor
     */
    function Common(opts) {
        var _a, _b;
        var _this = _super.call(this) || this;
        _this._supportedHardforks = [];
        _this._eips = [];
        _this._customChains = (_a = opts.customChains) !== null && _a !== void 0 ? _a : [];
        _this._chainParams = _this.setChain(opts.chain);
        _this.DEFAULT_HARDFORK = (_b = _this._chainParams.defaultHardfork) !== null && _b !== void 0 ? _b : Hardfork.Istanbul;
        _this._hardfork = _this.DEFAULT_HARDFORK;
        if (opts.supportedHardforks) {
            _this._supportedHardforks = opts.supportedHardforks;
        }
        if (opts.hardfork) {
            _this.setHardfork(opts.hardfork);
        }
        if (opts.eips) {
            _this.setEIPs(opts.eips);
        }
        return _this;
    }
    /**
     * Creates a {@link Common} object for a custom chain, based on a standard one.
     *
     * It uses all the {@link Chain} parameters from the {@link baseChain} option except the ones overridden
     * in a provided {@link chainParamsOrName} dictionary. Some usage example:
     *
     * ```javascript
     * Common.custom({chainId: 123})
     * ```
     *
     * There are also selected supported custom chains which can be initialized by using one of the
     * {@link CustomChains} for {@link chainParamsOrName}, e.g.:
     *
     * ```javascript
     * Common.custom(CustomChains.MaticMumbai)
     * ```
     *
     * Note that these supported custom chains only provide some base parameters (usually the chain and
     * network ID and a name) and can only be used for selected use cases (e.g. sending a tx with
     * the `@ethereumjs/tx` library to a Layer-2 chain).
     *
     * @param chainParamsOrName Custom parameter dict (`name` will default to `custom-chain`) or string with name of a supported custom chain
     * @param opts Custom chain options to set the {@link CustomCommonOpts.baseChain}, selected {@link CustomCommonOpts.hardfork} and others
     */
    Common.custom = function (chainParamsOrName, opts) {
        var _a;
        if (opts === void 0) { opts = {}; }
        var baseChain = (_a = opts.baseChain) !== null && _a !== void 0 ? _a : 'mainnet';
        var standardChainParams = __assign({}, Common._getChainParams(baseChain));
        standardChainParams['name'] = 'custom-chain';
        if (typeof chainParamsOrName !== 'string') {
            return new Common(__assign({ chain: __assign(__assign({}, standardChainParams), chainParamsOrName) }, opts));
        }
        else {
            if (chainParamsOrName === CustomChain.PolygonMainnet) {
                return Common.custom({
                    name: CustomChain.PolygonMainnet,
                    chainId: 137,
                    networkId: 137,
                });
            }
            if (chainParamsOrName === CustomChain.PolygonMumbai) {
                return Common.custom({
                    name: CustomChain.PolygonMumbai,
                    chainId: 80001,
                    networkId: 80001,
                });
            }
            if (chainParamsOrName === CustomChain.ArbitrumRinkebyTestnet) {
                return Common.custom({
                    name: CustomChain.ArbitrumRinkebyTestnet,
                    chainId: 421611,
                    networkId: 421611,
                });
            }
            if (chainParamsOrName === CustomChain.xDaiChain) {
                return Common.custom({
                    name: CustomChain.xDaiChain,
                    chainId: 100,
                    networkId: 100,
                });
            }
            throw new Error("Custom chain " + chainParamsOrName + " not supported");
        }
    };
    /**
     * Creates a {@link Common} object for a custom chain, based on a standard one. It uses all the `Chain`
     * params from {@link baseChain} except the ones overridden in {@link customChainParams}.
     *
     * @deprecated Use {@link Common.custom} instead
     *
     * @param baseChain The name (`mainnet`) or id (`1`) of a standard chain used to base the custom
     * chain params on.
     * @param customChainParams The custom parameters of the chain.
     * @param hardfork String identifier ('byzantium') for hardfork (optional)
     * @param supportedHardforks Limit parameter returns to the given hardforks (optional)
     */
    Common.forCustomChain = function (baseChain, customChainParams, hardfork, supportedHardforks) {
        var standardChainParams = Common._getChainParams(baseChain);
        return new Common({
            chain: __assign(__assign({}, standardChainParams), customChainParams),
            hardfork: hardfork,
            supportedHardforks: supportedHardforks,
        });
    };
    /**
     * Static method to determine if a {@link chainId} is supported as a standard chain
     * @param chainId BN id (`1`) of a standard chain
     * @returns boolean
     */
    Common.isSupportedChainId = function (chainId) {
        var initializedChains = chains_1._getInitializedChains();
        return Boolean(initializedChains['names'][chainId.toString()]);
    };
    Common._getChainParams = function (chain, customChains) {
        var initializedChains = chains_1._getInitializedChains(customChains);
        if (typeof chain === 'number' || ethereumjs_util_1.BN.isBN(chain)) {
            chain = chain.toString();
            if (initializedChains['names'][chain]) {
                var name_1 = initializedChains['names'][chain];
                return initializedChains[name_1];
            }
            throw new Error("Chain with ID " + chain + " not supported");
        }
        if (initializedChains[chain]) {
            return initializedChains[chain];
        }
        throw new Error("Chain with name " + chain + " not supported");
    };
    /**
     * Sets the chain
     * @param chain String ('mainnet') or Number (1) chain
     *     representation. Or, a Dictionary of chain parameters for a private network.
     * @returns The dictionary with parameters set as chain
     */
    Common.prototype.setChain = function (chain) {
        var e_1, _a;
        if (typeof chain === 'number' || typeof chain === 'string' || ethereumjs_util_1.BN.isBN(chain)) {
            this._chainParams = Common._getChainParams(chain, this._customChains);
        }
        else if (typeof chain === 'object') {
            if (this._customChains.length > 0) {
                throw new Error('Chain must be a string, number, or BN when initialized with customChains passed in');
            }
            var required = ['networkId', 'genesis', 'hardforks', 'bootstrapNodes'];
            try {
                for (var required_1 = __values(required), required_1_1 = required_1.next(); !required_1_1.done; required_1_1 = required_1.next()) {
                    var param = required_1_1.value;
                    if (chain[param] === undefined) {
                        throw new Error("Missing required chain parameter: " + param);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (required_1_1 && !required_1_1.done && (_a = required_1.return)) _a.call(required_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this._chainParams = chain;
        }
        else {
            throw new Error('Wrong input format');
        }
        return this._chainParams;
    };
    /**
     * Sets the hardfork to get params for
     * @param hardfork String identifier (e.g. 'byzantium')
     */
    Common.prototype.setHardfork = function (hardfork) {
        var e_2, _a;
        if (!this._isSupportedHardfork(hardfork)) {
            throw new Error("Hardfork " + hardfork + " not set as supported in supportedHardforks");
        }
        var existing = false;
        try {
            for (var HARDFORK_CHANGES_1 = __values(hardforks_1.hardforks), HARDFORK_CHANGES_1_1 = HARDFORK_CHANGES_1.next(); !HARDFORK_CHANGES_1_1.done; HARDFORK_CHANGES_1_1 = HARDFORK_CHANGES_1.next()) {
                var hfChanges = HARDFORK_CHANGES_1_1.value;
                if (hfChanges[0] === hardfork) {
                    if (this._hardfork !== hardfork) {
                        this._hardfork = hardfork;
                        this.emit('hardforkChanged', hardfork);
                    }
                    existing = true;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (HARDFORK_CHANGES_1_1 && !HARDFORK_CHANGES_1_1.done && (_a = HARDFORK_CHANGES_1.return)) _a.call(HARDFORK_CHANGES_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        if (!existing) {
            throw new Error("Hardfork with name " + hardfork + " not supported");
        }
    };
    /**
     * Returns the hardfork based on the block number provided
     * @param blockNumber
     * @returns The name of the HF
     */
    Common.prototype.getHardforkByBlockNumber = function (blockNumber) {
        var e_3, _a;
        blockNumber = ethereumjs_util_1.toType(blockNumber, ethereumjs_util_1.TypeOutput.BN);
        var hardfork = Hardfork.Chainstart;
        try {
            for (var _b = __values(this.hardforks()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var hf = _c.value;
                // Skip comparison for not applied HFs
                if (hf.block === null) {
                    continue;
                }
                if (blockNumber.gte(new ethereumjs_util_1.BN(hf.block))) {
                    hardfork = hf.name;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return hardfork;
    };
    /**
     * Sets a new hardfork based on the block number provided
     * @param blockNumber
     * @returns The name of the HF set
     */
    Common.prototype.setHardforkByBlockNumber = function (blockNumber) {
        blockNumber = ethereumjs_util_1.toType(blockNumber, ethereumjs_util_1.TypeOutput.BN);
        var hardfork = this.getHardforkByBlockNumber(blockNumber);
        this.setHardfork(hardfork);
        return hardfork;
    };
    /**
     * Internal helper function to choose between hardfork set and hardfork provided as param
     * @param hardfork Hardfork given to function as a parameter
     * @returns Hardfork chosen to be used
     */
    Common.prototype._chooseHardfork = function (hardfork, onlySupported) {
        if (onlySupported === void 0) { onlySupported = true; }
        if (!hardfork) {
            hardfork = this._hardfork;
        }
        else if (onlySupported && !this._isSupportedHardfork(hardfork)) {
            throw new Error("Hardfork " + hardfork + " not set as supported in supportedHardforks");
        }
        return hardfork;
    };
    /**
     * Internal helper function, returns the params for the given hardfork for the chain set
     * @param hardfork Hardfork name
     * @returns Dictionary with hardfork params
     */
    Common.prototype._getHardfork = function (hardfork) {
        var e_4, _a;
        var hfs = this.hardforks();
        try {
            for (var hfs_1 = __values(hfs), hfs_1_1 = hfs_1.next(); !hfs_1_1.done; hfs_1_1 = hfs_1.next()) {
                var hf = hfs_1_1.value;
                if (hf['name'] === hardfork)
                    return hf;
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (hfs_1_1 && !hfs_1_1.done && (_a = hfs_1.return)) _a.call(hfs_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
        throw new Error("Hardfork " + hardfork + " not defined for chain " + this.chainName());
    };
    /**
     * Internal helper function to check if a hardfork is set to be supported by the library
     * @param hardfork Hardfork name
     * @returns True if hardfork is supported
     */
    Common.prototype._isSupportedHardfork = function (hardfork) {
        var e_5, _a;
        if (this._supportedHardforks.length > 0) {
            try {
                for (var _b = __values(this._supportedHardforks), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var supportedHf = _c.value;
                    if (hardfork === supportedHf)
                        return true;
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_5) throw e_5.error; }
            }
        }
        else {
            return true;
        }
        return false;
    };
    /**
     * Sets the active EIPs
     * @param eips
     */
    Common.prototype.setEIPs = function (eips) {
        var e_6, _a;
        var _this = this;
        if (eips === void 0) { eips = []; }
        var _loop_1 = function (eip) {
            if (!(eip in eips_1.EIPs)) {
                throw new Error(eip + " not supported");
            }
            var minHF = this_1.gteHardfork(eips_1.EIPs[eip]['minimumHardfork']);
            if (!minHF) {
                throw new Error(eip + " cannot be activated on hardfork " + this_1.hardfork() + ", minimumHardfork: " + minHF);
            }
            if (eips_1.EIPs[eip].requiredEIPs) {
                // eslint-disable-next-line prettier/prettier
                eips_1.EIPs[eip].requiredEIPs.forEach(function (elem) {
                    if (!(eips.includes(elem) || _this.isActivatedEIP(elem))) {
                        throw new Error(eip + " requires EIP " + elem + ", but is not included in the EIP list");
                    }
                });
            }
        };
        var this_1 = this;
        try {
            for (var eips_2 = __values(eips), eips_2_1 = eips_2.next(); !eips_2_1.done; eips_2_1 = eips_2.next()) {
                var eip = eips_2_1.value;
                _loop_1(eip);
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (eips_2_1 && !eips_2_1.done && (_a = eips_2.return)) _a.call(eips_2);
            }
            finally { if (e_6) throw e_6.error; }
        }
        this._eips = eips;
    };
    /**
     * Returns a parameter for the current chain setup
     *
     * If the parameter is present in an EIP, the EIP always takes precendence.
     * Otherwise the parameter if taken from the latest applied HF with
     * a change on the respective parameter.
     *
     * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')
     * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)
     * @returns The value requested or `null` if not found
     */
    Common.prototype.param = function (topic, name) {
        var e_7, _a;
        // TODO: consider the case that different active EIPs
        // can change the same parameter
        var value = null;
        try {
            for (var _b = __values(this._eips), _c = _b.next(); !_c.done; _c = _b.next()) {
                var eip = _c.value;
                value = this.paramByEIP(topic, name, eip);
                if (value !== null) {
                    return value;
                }
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_7) throw e_7.error; }
        }
        return this.paramByHardfork(topic, name, this._hardfork);
    };
    /**
     * Returns the parameter corresponding to a hardfork
     * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')
     * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)
     * @param hardfork Hardfork name
     * @returns The value requested or `null` if not found
     */
    Common.prototype.paramByHardfork = function (topic, name, hardfork) {
        var e_8, _a, e_9, _b;
        hardfork = this._chooseHardfork(hardfork);
        var value = null;
        try {
            for (var HARDFORK_CHANGES_2 = __values(hardforks_1.hardforks), HARDFORK_CHANGES_2_1 = HARDFORK_CHANGES_2.next(); !HARDFORK_CHANGES_2_1.done; HARDFORK_CHANGES_2_1 = HARDFORK_CHANGES_2.next()) {
                var hfChanges = HARDFORK_CHANGES_2_1.value;
                // EIP-referencing HF file (e.g. berlin.json)
                if (hfChanges[1].hasOwnProperty('eips')) { // eslint-disable-line
                    var hfEIPs = hfChanges[1]['eips'];
                    try {
                        for (var hfEIPs_1 = (e_9 = void 0, __values(hfEIPs)), hfEIPs_1_1 = hfEIPs_1.next(); !hfEIPs_1_1.done; hfEIPs_1_1 = hfEIPs_1.next()) {
                            var eip = hfEIPs_1_1.value;
                            var valueEIP = this.paramByEIP(topic, name, eip);
                            value = valueEIP !== null ? valueEIP : value;
                        }
                    }
                    catch (e_9_1) { e_9 = { error: e_9_1 }; }
                    finally {
                        try {
                            if (hfEIPs_1_1 && !hfEIPs_1_1.done && (_b = hfEIPs_1.return)) _b.call(hfEIPs_1);
                        }
                        finally { if (e_9) throw e_9.error; }
                    }
                    // Paramater-inlining HF file (e.g. istanbul.json)
                }
                else {
                    if (!hfChanges[1][topic]) {
                        throw new Error("Topic " + topic + " not defined");
                    }
                    if (hfChanges[1][topic][name] !== undefined) {
                        value = hfChanges[1][topic][name].v;
                    }
                }
                if (hfChanges[0] === hardfork)
                    break;
            }
        }
        catch (e_8_1) { e_8 = { error: e_8_1 }; }
        finally {
            try {
                if (HARDFORK_CHANGES_2_1 && !HARDFORK_CHANGES_2_1.done && (_a = HARDFORK_CHANGES_2.return)) _a.call(HARDFORK_CHANGES_2);
            }
            finally { if (e_8) throw e_8.error; }
        }
        return value;
    };
    /**
     * Returns a parameter corresponding to an EIP
     * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')
     * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)
     * @param eip Number of the EIP
     * @returns The value requested or `null` if not found
     */
    Common.prototype.paramByEIP = function (topic, name, eip) {
        if (!(eip in eips_1.EIPs)) {
            throw new Error(eip + " not supported");
        }
        var eipParams = eips_1.EIPs[eip];
        if (!(topic in eipParams)) {
            throw new Error("Topic " + topic + " not defined");
        }
        if (eipParams[topic][name] === undefined) {
            return null;
        }
        var value = eipParams[topic][name].v;
        return value;
    };
    /**
     * Returns a parameter for the hardfork active on block number
     * @param topic Parameter topic
     * @param name Parameter name
     * @param blockNumber Block number
     */
    Common.prototype.paramByBlock = function (topic, name, blockNumber) {
        var activeHfs = this.activeHardforks(blockNumber);
        var hardfork = activeHfs[activeHfs.length - 1]['name'];
        return this.paramByHardfork(topic, name, hardfork);
    };
    /**
     * Checks if an EIP is activated by either being included in the EIPs
     * manually passed in with the {@link CommonOpts.eips} or in a
     * hardfork currently being active
     *
     * Note: this method only works for EIPs being supported
     * by the {@link CommonOpts.eips} constructor option
     * @param eip
     */
    Common.prototype.isActivatedEIP = function (eip) {
        var e_10, _a;
        if (this.eips().includes(eip)) {
            return true;
        }
        try {
            for (var HARDFORK_CHANGES_3 = __values(hardforks_1.hardforks), HARDFORK_CHANGES_3_1 = HARDFORK_CHANGES_3.next(); !HARDFORK_CHANGES_3_1.done; HARDFORK_CHANGES_3_1 = HARDFORK_CHANGES_3.next()) {
                var hfChanges = HARDFORK_CHANGES_3_1.value;
                var hf = hfChanges[1];
                if (this.gteHardfork(hf['name']) && 'eips' in hf) {
                    if (hf['eips'].includes(eip)) {
                        return true;
                    }
                }
            }
        }
        catch (e_10_1) { e_10 = { error: e_10_1 }; }
        finally {
            try {
                if (HARDFORK_CHANGES_3_1 && !HARDFORK_CHANGES_3_1.done && (_a = HARDFORK_CHANGES_3.return)) _a.call(HARDFORK_CHANGES_3);
            }
            finally { if (e_10) throw e_10.error; }
        }
        return false;
    };
    /**
     * Checks if set or provided hardfork is active on block number
     * @param hardfork Hardfork name or null (for HF set)
     * @param blockNumber
     * @param opts Hardfork options (onlyActive unused)
     * @returns True if HF is active on block number
     */
    Common.prototype.hardforkIsActiveOnBlock = function (hardfork, blockNumber, opts) {
        var _a;
        if (opts === void 0) { opts = {}; }
        blockNumber = ethereumjs_util_1.toType(blockNumber, ethereumjs_util_1.TypeOutput.BN);
        var onlySupported = (_a = opts.onlySupported) !== null && _a !== void 0 ? _a : false;
        hardfork = this._chooseHardfork(hardfork, onlySupported);
        var hfBlock = this.hardforkBlockBN(hardfork);
        if (hfBlock && blockNumber.gte(hfBlock)) {
            return true;
        }
        return false;
    };
    /**
     * Alias to hardforkIsActiveOnBlock when hardfork is set
     * @param blockNumber
     * @param opts Hardfork options (onlyActive unused)
     * @returns True if HF is active on block number
     */
    Common.prototype.activeOnBlock = function (blockNumber, opts) {
        return this.hardforkIsActiveOnBlock(null, blockNumber, opts);
    };
    /**
     * Sequence based check if given or set HF1 is greater than or equal HF2
     * @param hardfork1 Hardfork name or null (if set)
     * @param hardfork2 Hardfork name
     * @param opts Hardfork options
     * @returns True if HF1 gte HF2
     */
    Common.prototype.hardforkGteHardfork = function (hardfork1, hardfork2, opts) {
        var e_11, _a;
        if (opts === void 0) { opts = {}; }
        var onlyActive = opts.onlyActive === undefined ? false : opts.onlyActive;
        hardfork1 = this._chooseHardfork(hardfork1, opts.onlySupported);
        var hardforks;
        if (onlyActive) {
            hardforks = this.activeHardforks(null, opts);
        }
        else {
            hardforks = this.hardforks();
        }
        var posHf1 = -1, posHf2 = -1;
        var index = 0;
        try {
            for (var hardforks_2 = __values(hardforks), hardforks_2_1 = hardforks_2.next(); !hardforks_2_1.done; hardforks_2_1 = hardforks_2.next()) {
                var hf = hardforks_2_1.value;
                if (hf['name'] === hardfork1)
                    posHf1 = index;
                if (hf['name'] === hardfork2)
                    posHf2 = index;
                index += 1;
            }
        }
        catch (e_11_1) { e_11 = { error: e_11_1 }; }
        finally {
            try {
                if (hardforks_2_1 && !hardforks_2_1.done && (_a = hardforks_2.return)) _a.call(hardforks_2);
            }
            finally { if (e_11) throw e_11.error; }
        }
        return posHf1 >= posHf2 && posHf2 !== -1;
    };
    /**
     * Alias to hardforkGteHardfork when hardfork is set
     * @param hardfork Hardfork name
     * @param opts Hardfork options
     * @returns True if hardfork set is greater than hardfork provided
     */
    Common.prototype.gteHardfork = function (hardfork, opts) {
        return this.hardforkGteHardfork(null, hardfork, opts);
    };
    /**
     * Checks if given or set hardfork is active on the chain
     * @param hardfork Hardfork name, optional if HF set
     * @param opts Hardfork options (onlyActive unused)
     * @returns True if hardfork is active on the chain
     */
    Common.prototype.hardforkIsActiveOnChain = function (hardfork, opts) {
        var e_12, _a;
        var _b;
        if (opts === void 0) { opts = {}; }
        var onlySupported = (_b = opts.onlySupported) !== null && _b !== void 0 ? _b : false;
        hardfork = this._chooseHardfork(hardfork, onlySupported);
        try {
            for (var _c = __values(this.hardforks()), _d = _c.next(); !_d.done; _d = _c.next()) {
                var hf = _d.value;
                if (hf['name'] === hardfork && hf['block'] !== null)
                    return true;
            }
        }
        catch (e_12_1) { e_12 = { error: e_12_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_12) throw e_12.error; }
        }
        return false;
    };
    /**
     * Returns the active hardfork switches for the current chain
     * @param blockNumber up to block if provided, otherwise for the whole chain
     * @param opts Hardfork options (onlyActive unused)
     * @return Array with hardfork arrays
     */
    Common.prototype.activeHardforks = function (blockNumber, opts) {
        var e_13, _a;
        if (opts === void 0) { opts = {}; }
        var activeHardforks = [];
        var hfs = this.hardforks();
        try {
            for (var hfs_2 = __values(hfs), hfs_2_1 = hfs_2.next(); !hfs_2_1.done; hfs_2_1 = hfs_2.next()) {
                var hf = hfs_2_1.value;
                if (hf['block'] === null)
                    continue;
                if (blockNumber !== undefined && blockNumber !== null && blockNumber < hf['block'])
                    break;
                if (opts.onlySupported && !this._isSupportedHardfork(hf['name']))
                    continue;
                activeHardforks.push(hf);
            }
        }
        catch (e_13_1) { e_13 = { error: e_13_1 }; }
        finally {
            try {
                if (hfs_2_1 && !hfs_2_1.done && (_a = hfs_2.return)) _a.call(hfs_2);
            }
            finally { if (e_13) throw e_13.error; }
        }
        return activeHardforks;
    };
    /**
     * Returns the latest active hardfork name for chain or block or throws if unavailable
     * @param blockNumber up to block if provided, otherwise for the whole chain
     * @param opts Hardfork options (onlyActive unused)
     * @return Hardfork name
     */
    Common.prototype.activeHardfork = function (blockNumber, opts) {
        if (opts === void 0) { opts = {}; }
        var activeHardforks = this.activeHardforks(blockNumber, opts);
        if (activeHardforks.length > 0) {
            return activeHardforks[activeHardforks.length - 1]['name'];
        }
        else {
            throw new Error("No (supported) active hardfork found");
        }
    };
    /**
     * Returns the hardfork change block for hardfork provided or set
     * @param hardfork Hardfork name, optional if HF set
     * @returns Block number
     * @deprecated Please use hardforkBlockBN() for large number support
     */
    Common.prototype.hardforkBlock = function (hardfork) {
        return ethereumjs_util_1.toType(this.hardforkBlockBN(hardfork), ethereumjs_util_1.TypeOutput.Number);
    };
    /**
     * Returns the hardfork change block for hardfork provided or set
     * @param hardfork Hardfork name, optional if HF set
     * @returns Block number
     */
    Common.prototype.hardforkBlockBN = function (hardfork) {
        hardfork = this._chooseHardfork(hardfork, false);
        return new ethereumjs_util_1.BN(this._getHardfork(hardfork)['block']);
    };
    /**
     * True if block number provided is the hardfork (given or set) change block
     * @param blockNumber Number of the block to check
     * @param hardfork Hardfork name, optional if HF set
     * @returns True if blockNumber is HF block
     */
    Common.prototype.isHardforkBlock = function (blockNumber, hardfork) {
        blockNumber = ethereumjs_util_1.toType(blockNumber, ethereumjs_util_1.TypeOutput.BN);
        hardfork = this._chooseHardfork(hardfork, false);
        return this.hardforkBlockBN(hardfork).eq(blockNumber);
    };
    /**
     * Returns the change block for the next hardfork after the hardfork provided or set
     * @param hardfork Hardfork name, optional if HF set
     * @returns Block number or null if not available
     * @deprecated Please use nextHardforkBlockBN() for large number support
     */
    Common.prototype.nextHardforkBlock = function (hardfork) {
        var block = this.nextHardforkBlockBN(hardfork);
        return block === null ? null : ethereumjs_util_1.toType(block, ethereumjs_util_1.TypeOutput.Number);
    };
    /**
     * Returns the change block for the next hardfork after the hardfork provided or set
     * @param hardfork Hardfork name, optional if HF set
     * @returns Block number or null if not available
     */
    Common.prototype.nextHardforkBlockBN = function (hardfork) {
        hardfork = this._chooseHardfork(hardfork, false);
        var hfBlock = this.hardforkBlockBN(hardfork);
        // Next fork block number or null if none available
        // Logic: if accumulator is still null and on the first occurence of
        // a block greater than the current hfBlock set the accumulator,
        // pass on the accumulator as the final result from this time on
        var nextHfBlock = this.hardforks().reduce(function (acc, hf) {
            var block = new ethereumjs_util_1.BN(hf.block);
            return block.gt(hfBlock) && acc === null ? block : acc;
        }, null);
        return nextHfBlock;
    };
    /**
     * True if block number provided is the hardfork change block following the hardfork given or set
     * @param blockNumber Number of the block to check
     * @param hardfork Hardfork name, optional if HF set
     * @returns True if blockNumber is HF block
     */
    Common.prototype.isNextHardforkBlock = function (blockNumber, hardfork) {
        blockNumber = ethereumjs_util_1.toType(blockNumber, ethereumjs_util_1.TypeOutput.BN);
        hardfork = this._chooseHardfork(hardfork, false);
        var nextHardforkBlock = this.nextHardforkBlockBN(hardfork);
        return nextHardforkBlock === null ? false : nextHardforkBlock.eq(blockNumber);
    };
    /**
     * Internal helper function to calculate a fork hash
     * @param hardfork Hardfork name
     * @returns Fork hash as hex string
     */
    Common.prototype._calcForkHash = function (hardfork) {
        var e_14, _a;
        var genesis = Buffer.from(this.genesis().hash.substr(2), 'hex');
        var hfBuffer = Buffer.alloc(0);
        var prevBlock = 0;
        try {
            for (var _b = __values(this.hardforks()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var hf = _c.value;
                var block = hf.block;
                // Skip for chainstart (0), not applied HFs (null) and
                // when already applied on same block number HFs
                if (block !== 0 && block !== null && block !== prevBlock) {
                    var hfBlockBuffer = Buffer.from(block.toString(16).padStart(16, '0'), 'hex');
                    hfBuffer = Buffer.concat([hfBuffer, hfBlockBuffer]);
                }
                if (hf.name === hardfork)
                    break;
                prevBlock = block;
            }
        }
        catch (e_14_1) { e_14 = { error: e_14_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_14) throw e_14.error; }
        }
        var inputBuffer = Buffer.concat([genesis, hfBuffer]);
        // CRC32 delivers result as signed (negative) 32-bit integer,
        // convert to hex string
        var forkhash = ethereumjs_util_1.intToBuffer(crc_32_1.buf(inputBuffer) >>> 0).toString('hex');
        return "0x" + forkhash;
    };
    /**
     * Returns an eth/64 compliant fork hash (EIP-2124)
     * @param hardfork Hardfork name, optional if HF set
     */
    Common.prototype.forkHash = function (hardfork) {
        hardfork = this._chooseHardfork(hardfork, false);
        var data = this._getHardfork(hardfork);
        if (data['block'] === null) {
            var msg = 'No fork hash calculation possible for non-applied or future hardfork';
            throw new Error(msg);
        }
        if (data['forkHash'] !== undefined) {
            return data['forkHash'];
        }
        return this._calcForkHash(hardfork);
    };
    /**
     *
     * @param forkHash Fork hash as a hex string
     * @returns Array with hardfork data (name, block, forkHash)
     */
    Common.prototype.hardforkForForkHash = function (forkHash) {
        var resArray = this.hardforks().filter(function (hf) {
            return hf.forkHash === forkHash;
        });
        return resArray.length >= 1 ? resArray[resArray.length - 1] : null;
    };
    /**
     * Returns the Genesis parameters of current chain
     * @returns Genesis dictionary
     */
    Common.prototype.genesis = function () {
        return this._chainParams['genesis'];
    };
    /**
     * Returns the hardforks for current chain
     * @returns {Array} Array with arrays of hardforks
     */
    Common.prototype.hardforks = function () {
        return this._chainParams['hardforks'];
    };
    /**
     * Returns bootstrap nodes for the current chain
     * @returns {Dictionary} Dict with bootstrap nodes
     */
    Common.prototype.bootstrapNodes = function () {
        return this._chainParams['bootstrapNodes'];
    };
    /**
     * Returns DNS networks for the current chain
     * @returns {String[]} Array of DNS ENR urls
     */
    Common.prototype.dnsNetworks = function () {
        return this._chainParams['dnsNetworks'];
    };
    /**
     * Returns the hardfork set
     * @returns Hardfork name
     */
    Common.prototype.hardfork = function () {
        return this._hardfork;
    };
    /**
     * Returns the Id of current chain
     * @returns chain Id
     * @deprecated Please use chainIdBN() for large number support
     */
    Common.prototype.chainId = function () {
        return ethereumjs_util_1.toType(this.chainIdBN(), ethereumjs_util_1.TypeOutput.Number);
    };
    /**
     * Returns the Id of current chain
     * @returns chain Id
     */
    Common.prototype.chainIdBN = function () {
        return new ethereumjs_util_1.BN(this._chainParams['chainId']);
    };
    /**
     * Returns the name of current chain
     * @returns chain name (lower case)
     */
    Common.prototype.chainName = function () {
        return this._chainParams['name'];
    };
    /**
     * Returns the Id of current network
     * @returns network Id
     * @deprecated Please use networkIdBN() for large number support
     */
    Common.prototype.networkId = function () {
        return ethereumjs_util_1.toType(this.networkIdBN(), ethereumjs_util_1.TypeOutput.Number);
    };
    /**
     * Returns the Id of current network
     * @returns network Id
     */
    Common.prototype.networkIdBN = function () {
        return new ethereumjs_util_1.BN(this._chainParams['networkId']);
    };
    /**
     * Returns the active EIPs
     * @returns List of EIPs
     */
    Common.prototype.eips = function () {
        return this._eips;
    };
    /**
     * Returns the consensus type of the network
     * Possible values: "pow"|"poa"
     */
    Common.prototype.consensusType = function () {
        return this._chainParams['consensus']['type'];
    };
    /**
     * Returns the concrete consensus implementation
     * algorithm or protocol for the network
     * e.g. "ethash" for "pow" consensus type or
     * "clique" for "poa" consensus type
     */
    Common.prototype.consensusAlgorithm = function () {
        return this._chainParams['consensus']['algorithm'];
    };
    /**
     * Returns a dictionary with consensus configuration
     * parameters based on the consensus algorithm
     *
     * Expected returns (parameters must be present in
     * the respective chain json files):
     *
     * ethash: -
     * clique: period, epoch
     * aura: -
     */
    Common.prototype.consensusConfig = function () {
        return this._chainParams['consensus'][this.consensusAlgorithm()];
    };
    /**
     * Returns a deep copy of this {@link Common} instance.
     */
    Common.prototype.copy = function () {
        return Object.assign(Object.create(Object.getPrototypeOf(this)), this);
    };
    return Common;
}(events_1.EventEmitter));
exports.default = Common;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@ethereumjs\\common",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethereumjs\\common\\dist.browser\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethereumjs\\tx\\dist.browser\\index.js", {"./eip1559Transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethereumjs\\tx\\dist.browser\\eip1559Transaction.js","./eip2930Transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethereumjs\\tx\\dist.browser\\eip2930Transaction.js","./legacyTransaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethereumjs\\tx\\dist.browser\\legacyTransaction.js","./transactionFactory":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethereumjs\\tx\\dist.browser\\transactionFactory.js","./types":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethereumjs\\tx\\dist.browser\\types.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@ethereumjs\tx\dist.browser\index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
var legacyTransaction_1 = require("./legacyTransaction");
Object.defineProperty(exports, "Transaction", { enumerable: true, get: function () { return legacyTransaction_1.default; } });
var eip2930Transaction_1 = require("./eip2930Transaction");
Object.defineProperty(exports, "AccessListEIP2930Transaction", { enumerable: true, get: function () { return eip2930Transaction_1.default; } });
var transactionFactory_1 = require("./transactionFactory");
Object.defineProperty(exports, "TransactionFactory", { enumerable: true, get: function () { return transactionFactory_1.default; } });
var eip1559Transaction_1 = require("./eip1559Transaction");
Object.defineProperty(exports, "FeeMarketEIP1559Transaction", { enumerable: true, get: function () { return eip1559Transaction_1.default; } });
__exportStar(require("./types"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@ethereumjs\\tx",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethereumjs\\tx\\dist.browser\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\constants\\transactions.js", {"../../../shared/constants/transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\transaction.js","@babel/runtime/helpers/defineProperty":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\ui\helpers\constants\transactions.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TRANSACTION_ENVELOPE_TYPE_NAMES = exports.TOKEN_CATEGORY_HASH = exports.PRIORITY_STATUS_HASH = exports.PENDING_STATUS_HASH = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _transaction = require("../../../shared/constants/transaction");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const PENDING_STATUS_HASH = {
  [_transaction.TRANSACTION_STATUSES.UNAPPROVED]: true,
  [_transaction.TRANSACTION_STATUSES.APPROVED]: true,
  [_transaction.TRANSACTION_STATUSES.SUBMITTED]: true,
  [_transaction.TRANSACTION_STATUSES.PENDING]: true
};
exports.PENDING_STATUS_HASH = PENDING_STATUS_HASH;

const PRIORITY_STATUS_HASH = _objectSpread(_objectSpread({}, PENDING_STATUS_HASH), {}, {
  [_transaction.TRANSACTION_STATUSES.CONFIRMED]: true
});

exports.PRIORITY_STATUS_HASH = PRIORITY_STATUS_HASH;
const TOKEN_CATEGORY_HASH = {
  [_transaction.TRANSACTION_TYPES.TOKEN_METHOD_APPROVE]: true,
  [_transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER]: true,
  [_transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM]: true
};
exports.TOKEN_CATEGORY_HASH = TOKEN_CATEGORY_HASH;
const TRANSACTION_ENVELOPE_TYPE_NAMES = {
  FEE_MARKET: 'fee-market',
  LEGACY: 'legacy'
};
exports.TRANSACTION_ENVELOPE_TYPE_NAMES = TRANSACTION_ENVELOPE_TYPE_NAMES;

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\constants\\transactions.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\swaps.utils.js", {"../constants/swaps":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\swaps.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\shared\modules\swaps.utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSwapsDefaultTokenAddress = isSwapsDefaultTokenAddress;
exports.isSwapsDefaultTokenSymbol = isSwapsDefaultTokenSymbol;

var _swaps = require("../constants/swaps");

/**
 * Checks whether the provided address is strictly equal to the address for
 * the default swaps token of the provided chain.
 *
 * @param {string} address - The string to compare to the default token address
 * @param {string} chainId - The hex encoded chain ID of the default swaps token to check
 * @returns {boolean} Whether the address is the provided chain's default token address
 */
function isSwapsDefaultTokenAddress(address, chainId) {
  var _SWAPS_CHAINID_DEFAUL;

  if (!address || !chainId) {
    return false;
  }

  return address === ((_SWAPS_CHAINID_DEFAUL = _swaps.SWAPS_CHAINID_DEFAULT_TOKEN_MAP[chainId]) === null || _SWAPS_CHAINID_DEFAUL === void 0 ? void 0 : _SWAPS_CHAINID_DEFAUL.address);
}
/**
 * Checks whether the provided symbol is strictly equal to the symbol for
 * the default swaps token of the provided chain.
 *
 * @param {string} symbol - The string to compare to the default token symbol
 * @param {string} chainId - The hex encoded chain ID of the default swaps token to check
 * @returns {boolean} Whether the symbl is the provided chain's default token symbol
 */


function isSwapsDefaultTokenSymbol(symbol, chainId) {
  var _SWAPS_CHAINID_DEFAUL2;

  if (!symbol || !chainId) {
    return false;
  }

  return symbol === ((_SWAPS_CHAINID_DEFAUL2 = _swaps.SWAPS_CHAINID_DEFAULT_TOKEN_MAP[chainId]) === null || _SWAPS_CHAINID_DEFAUL2 === void 0 ? void 0 : _SWAPS_CHAINID_DEFAUL2.symbol);
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\swaps.utils.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\pages\\send\\send.utils.js", {"../../../app/scripts/lib/util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\app\\scripts\\lib\\util.js","../../../shared/modules/conversion.utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\conversion.utils.js","../../helpers/constants/common":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\constants\\common.js","../../helpers/utils/token-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\utils\\token-util.js","./send.constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\pages\\send\\send.constants.js","@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","ethereumjs-abi":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-abi\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\ui\pages\send\send.utils.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addGasBuffer = addGasBuffer;
exports.calcGasTotal = calcGasTotal;
exports.ellipsify = ellipsify;
exports.generateERC20TransferData = generateERC20TransferData;
exports.generateERC721TransferData = generateERC721TransferData;
exports.getAssetTransferData = getAssetTransferData;
exports.isBalanceSufficient = isBalanceSufficient;
exports.isTokenBalanceSufficient = isTokenBalanceSufficient;

var _ethereumjsAbi = _interopRequireDefault(require("ethereumjs-abi"));

var _conversion = require("../../../shared/modules/conversion.utils");

var _tokenUtil = require("../../helpers/utils/token-util");

var _util = require("../../../app/scripts/lib/util");

var _common = require("../../helpers/constants/common");

var _send = require("./send.constants");

function calcGasTotal(gasLimit = '0', gasPrice = '0') {
  return (0, _conversion.multiplyCurrencies)(gasLimit, gasPrice, {
    toNumericBase: 'hex',
    multiplicandBase: 16,
    multiplierBase: 16
  });
}

function isBalanceSufficient({
  amount = '0x0',
  balance = '0x0',
  conversionRate = 1,
  gasTotal = '0x0',
  primaryCurrency
}) {
  const totalAmount = (0, _conversion.addCurrencies)(amount, gasTotal, {
    aBase: 16,
    bBase: 16,
    toNumericBase: 'hex'
  });
  const balanceIsSufficient = (0, _conversion.conversionGTE)({
    value: balance,
    fromNumericBase: 'hex',
    fromCurrency: primaryCurrency,
    conversionRate
  }, {
    value: totalAmount,
    fromNumericBase: 'hex',
    conversionRate,
    fromCurrency: primaryCurrency
  });
  return balanceIsSufficient;
}

function isTokenBalanceSufficient({
  amount = '0x0',
  tokenBalance,
  decimals
}) {
  const amountInDec = (0, _conversion.conversionUtil)(amount, {
    fromNumericBase: 'hex'
  });
  const tokenBalanceIsSufficient = (0, _conversion.conversionGTE)({
    value: tokenBalance,
    fromNumericBase: 'hex'
  }, {
    value: (0, _tokenUtil.calcTokenAmount)(amountInDec, decimals)
  });
  return tokenBalanceIsSufficient;
}

function addGasBuffer(initialGasLimitHex, blockGasLimitHex, bufferMultiplier = 1.5) {
  const upperGasLimit = (0, _conversion.multiplyCurrencies)(blockGasLimitHex, 0.9, {
    toNumericBase: 'hex',
    multiplicandBase: 16,
    multiplierBase: 10,
    numberOfDecimals: '0'
  });
  const bufferedGasLimit = (0, _conversion.multiplyCurrencies)(initialGasLimitHex, bufferMultiplier, {
    toNumericBase: 'hex',
    multiplicandBase: 16,
    multiplierBase: 10,
    numberOfDecimals: '0'
  }); // if initialGasLimit is above blockGasLimit, dont modify it

  if ((0, _conversion.conversionGreaterThan)({
    value: initialGasLimitHex,
    fromNumericBase: 'hex'
  }, {
    value: upperGasLimit,
    fromNumericBase: 'hex'
  })) {
    return initialGasLimitHex;
  } // if bufferedGasLimit is below blockGasLimit, use bufferedGasLimit


  if ((0, _conversion.conversionLessThan)({
    value: bufferedGasLimit,
    fromNumericBase: 'hex'
  }, {
    value: upperGasLimit,
    fromNumericBase: 'hex'
  })) {
    return bufferedGasLimit;
  } // otherwise use blockGasLimit


  return upperGasLimit;
}

function generateERC20TransferData({
  toAddress = '0x0',
  amount = '0x0',
  sendToken
}) {
  if (!sendToken) {
    return undefined;
  }

  return _send.TOKEN_TRANSFER_FUNCTION_SIGNATURE + Array.prototype.map.call(_ethereumjsAbi.default.rawEncode(['address', 'uint256'], [toAddress, (0, _util.addHexPrefix)(amount)]), x => `00${x.toString(16)}`.slice(-2)).join('');
}

function generateERC721TransferData({
  toAddress = '0x0',
  fromAddress = '0x0',
  tokenId
}) {
  if (!tokenId) {
    return undefined;
  }

  return _send.COLLECTIBLE_TRANSFER_FROM_FUNCTION_SIGNATURE + Array.prototype.map.call(_ethereumjsAbi.default.rawEncode(['address', 'address', 'uint256'], [fromAddress, toAddress, tokenId]), x => `00${x.toString(16)}`.slice(-2)).join('');
}

function getAssetTransferData({
  sendToken,
  fromAddress,
  toAddress,
  amount
}) {
  switch (sendToken.standard) {
    case _common.ERC721:
      return generateERC721TransferData({
        toAddress,
        fromAddress,
        tokenId: sendToken.tokenId
      });

    case _common.ERC20:
    default:
      return generateERC20TransferData({
        toAddress,
        amount,
        sendToken
      });
  }
}

function ellipsify(text, first = 6, last = 4) {
  return `${text.slice(0, first)}...${text.slice(-last)}`;
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\pages\\send\\send.utils.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\isomorphic-fetch\\fetch-npm-browserify.js", {"whatwg-fetch":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\isomorphic-fetch\\node_modules\\whatwg-fetch\\dist\\fetch.umd.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\isomorphic-fetch\fetch-npm-browserify.js
      return function (require, module, exports) {
// the whatwg-fetch polyfill installs the fetch() function
// on the global object (window or self)
//
// Return that as the export for use in Webpack, Browserify etc.
require('whatwg-fetch');
module.exports = self.fetch.bind(self);

      };
    };
  }
}, {package:"isomorphic-fetch",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\isomorphic-fetch\\fetch-npm-browserify.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\crypto-browserify\\index.js", {"browserify-cipher":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify-cipher\\browser.js","browserify-sign":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify-sign\\browser\\index.js","browserify-sign/algos":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify-sign\\algos.js","create-ecdh":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\create-ecdh\\browser.js","create-hash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\create-hash\\browser.js","create-hmac":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\create-hmac\\browser.js","diffie-hellman":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\diffie-hellman\\browser.js","pbkdf2":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pbkdf2\\browser.js","public-encrypt":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\public-encrypt\\browser.js","randombytes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\randombytes\\browser.js","randomfill":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\randomfill\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\crypto-browserify\index.js
      return function (require, module, exports) {
'use strict'

exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require('randombytes')
exports.createHash = exports.Hash = require('create-hash')
exports.createHmac = exports.Hmac = require('create-hmac')

var algos = require('browserify-sign/algos')
var algoKeys = Object.keys(algos)
var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(algoKeys)
exports.getHashes = function () {
  return hashes
}

var p = require('pbkdf2')
exports.pbkdf2 = p.pbkdf2
exports.pbkdf2Sync = p.pbkdf2Sync

var aes = require('browserify-cipher')

exports.Cipher = aes.Cipher
exports.createCipher = aes.createCipher
exports.Cipheriv = aes.Cipheriv
exports.createCipheriv = aes.createCipheriv
exports.Decipher = aes.Decipher
exports.createDecipher = aes.createDecipher
exports.Decipheriv = aes.Decipheriv
exports.createDecipheriv = aes.createDecipheriv
exports.getCiphers = aes.getCiphers
exports.listCiphers = aes.listCiphers

var dh = require('diffie-hellman')

exports.DiffieHellmanGroup = dh.DiffieHellmanGroup
exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup
exports.getDiffieHellman = dh.getDiffieHellman
exports.createDiffieHellman = dh.createDiffieHellman
exports.DiffieHellman = dh.DiffieHellman

var sign = require('browserify-sign')

exports.createSign = sign.createSign
exports.Sign = sign.Sign
exports.createVerify = sign.createVerify
exports.Verify = sign.Verify

exports.createECDH = require('create-ecdh')

var publicEncrypt = require('public-encrypt')

exports.publicEncrypt = publicEncrypt.publicEncrypt
exports.privateEncrypt = publicEncrypt.privateEncrypt
exports.publicDecrypt = publicEncrypt.publicDecrypt
exports.privateDecrypt = publicEncrypt.privateDecrypt

// the least I can do is make error messages for the rest of the node.js/crypto api.
// ;[
//   'createCredentials'
// ].forEach(function (name) {
//   exports[name] = function () {
//     throw new Error([
//       'sorry, ' + name + ' is not implemented yet',
//       'we accept pull requests',
//       'https://github.com/crypto-browserify/crypto-browserify'
//     ].join('\n'))
//   }
// })

var rf = require('randomfill')

exports.randomFill = rf.randomFill
exports.randomFillSync = rf.randomFillSync

exports.createCredentials = function () {
  throw new Error([
    'sorry, createCredentials is not implemented yet',
    'we accept pull requests',
    'https://github.com/crypto-browserify/crypto-browserify'
  ].join('\n'))
}

exports.constants = {
  'DH_CHECK_P_NOT_SAFE_PRIME': 2,
  'DH_CHECK_P_NOT_PRIME': 1,
  'DH_UNABLE_TO_CHECK_GENERATOR': 4,
  'DH_NOT_SUITABLE_GENERATOR': 8,
  'NPN_ENABLED': 1,
  'ALPN_ENABLED': 1,
  'RSA_PKCS1_PADDING': 1,
  'RSA_SSLV23_PADDING': 2,
  'RSA_NO_PADDING': 3,
  'RSA_PKCS1_OAEP_PADDING': 4,
  'RSA_X931_PADDING': 5,
  'RSA_PKCS1_PSS_PADDING': 6,
  'POINT_CONVERSION_COMPRESSED': 2,
  'POINT_CONVERSION_UNCOMPRESSED': 4,
  'POINT_CONVERSION_HYBRID': 6
}

      };
    };
  }
}, {package:"crypto-browserify",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\crypto-browserify\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\address.js", {"./account":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\account.js","./bytes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\bytes.js","assert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\assert.js","bn.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\node_modules\\bn.js\\lib\\bn.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-util\dist.browser\address.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Address = void 0;
var assert_1 = __importDefault(require("assert"));
var bn_js_1 = __importDefault(require("bn.js"));
var bytes_1 = require("./bytes");
var account_1 = require("./account");
var Address = /** @class */ (function () {
    function Address(buf) {
        assert_1.default(buf.length === 20, 'Invalid address length');
        this.buf = buf;
    }
    /**
     * Returns the zero address.
     */
    Address.zero = function () {
        return new Address(bytes_1.zeros(20));
    };
    /**
     * Returns an Address object from a hex-encoded string.
     * @param str - Hex-encoded address
     */
    Address.fromString = function (str) {
        assert_1.default(account_1.isValidAddress(str), 'Invalid address');
        return new Address(bytes_1.toBuffer(str));
    };
    /**
     * Returns an address for a given public key.
     * @param pubKey The two points of an uncompressed key
     */
    Address.fromPublicKey = function (pubKey) {
        assert_1.default(Buffer.isBuffer(pubKey), 'Public key should be Buffer');
        var buf = account_1.pubToAddress(pubKey);
        return new Address(buf);
    };
    /**
     * Returns an address for a given private key.
     * @param privateKey A private key must be 256 bits wide
     */
    Address.fromPrivateKey = function (privateKey) {
        assert_1.default(Buffer.isBuffer(privateKey), 'Private key should be Buffer');
        var buf = account_1.privateToAddress(privateKey);
        return new Address(buf);
    };
    /**
     * Generates an address for a newly created contract.
     * @param from The address which is creating this new address
     * @param nonce The nonce of the from account
     */
    Address.generate = function (from, nonce) {
        assert_1.default(bn_js_1.default.isBN(nonce));
        return new Address(account_1.generateAddress(from.buf, nonce.toArrayLike(Buffer)));
    };
    /**
     * Generates an address for a contract created using CREATE2.
     * @param from The address which is creating this new address
     * @param salt A salt
     * @param initCode The init code of the contract being created
     */
    Address.generate2 = function (from, salt, initCode) {
        assert_1.default(Buffer.isBuffer(salt));
        assert_1.default(Buffer.isBuffer(initCode));
        return new Address(account_1.generateAddress2(from.buf, salt, initCode));
    };
    /**
     * Is address equal to another.
     */
    Address.prototype.equals = function (address) {
        return this.buf.equals(address.buf);
    };
    /**
     * Is address zero.
     */
    Address.prototype.isZero = function () {
        return this.equals(Address.zero());
    };
    /**
     * True if address is in the address range defined
     * by EIP-1352
     */
    Address.prototype.isPrecompileOrSystemAddress = function () {
        var addressBN = new bn_js_1.default(this.buf);
        var rangeMin = new bn_js_1.default(0);
        var rangeMax = new bn_js_1.default('ffff', 'hex');
        return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);
    };
    /**
     * Returns hex encoding of address.
     */
    Address.prototype.toString = function () {
        return '0x' + this.buf.toString('hex');
    };
    /**
     * Returns Buffer representation of address.
     */
    Address.prototype.toBuffer = function () {
        return Buffer.from(this.buf);
    };
    return Address;
}());
exports.Address = Address;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\address.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\types.js", {"./bytes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\bytes.js","bn.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\node_modules\\bn.js\\lib\\bn.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\node_modules\\ethjs-util\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-util\dist.browser\types.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toType = exports.TypeOutput = exports.bnToRlp = exports.bnToUnpaddedBuffer = exports.bnToHex = void 0;
var bn_js_1 = __importDefault(require("bn.js"));
var ethjs_util_1 = require("ethjs-util");
var bytes_1 = require("./bytes");
/**
 * Convert BN to 0x-prefixed hex string.
 */
function bnToHex(value) {
    return "0x" + value.toString(16);
}
exports.bnToHex = bnToHex;
/**
 * Convert value from BN to an unpadded Buffer
 * (useful for RLP transport)
 * @param value value to convert
 */
function bnToUnpaddedBuffer(value) {
    // Using `bn.toArrayLike(Buffer)` instead of `bn.toBuffer()`
    // for compatibility with browserify and similar tools
    return bytes_1.unpadBuffer(value.toArrayLike(Buffer));
}
exports.bnToUnpaddedBuffer = bnToUnpaddedBuffer;
/**
 * Deprecated alias for {@link bnToUnpaddedBuffer}
 * @deprecated
 */
function bnToRlp(value) {
    return bnToUnpaddedBuffer(value);
}
exports.bnToRlp = bnToRlp;
/**
 * Type output options
 */
var TypeOutput;
(function (TypeOutput) {
    TypeOutput[TypeOutput["Number"] = 0] = "Number";
    TypeOutput[TypeOutput["BN"] = 1] = "BN";
    TypeOutput[TypeOutput["Buffer"] = 2] = "Buffer";
    TypeOutput[TypeOutput["PrefixedHexString"] = 3] = "PrefixedHexString";
})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));
/**
 * Convert an input to a specified type
 * @param input value to convert
 * @param outputType type to output
 */
function toType(input, outputType) {
    if (typeof input === 'string' && !ethjs_util_1.isHexString(input)) {
        throw new Error("A string must be provided with a 0x-prefix, given: " + input);
    }
    else if (typeof input === 'number' && !Number.isSafeInteger(input)) {
        throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');
    }
    input = bytes_1.toBuffer(input);
    if (outputType === TypeOutput.Buffer) {
        return input;
    }
    else if (outputType === TypeOutput.BN) {
        return new bn_js_1.default(input);
    }
    else if (outputType === TypeOutput.Number) {
        var bn = new bn_js_1.default(input);
        var max = new bn_js_1.default(Number.MAX_SAFE_INTEGER.toString());
        if (bn.gt(max)) {
            throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)');
        }
        return bn.toNumber();
    }
    else {
        // outputType === TypeOutput.PrefixedHexString
        return "0x" + input.toString('hex');
    }
}
exports.toType = toType;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\types.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\bytes.js", {"./helpers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\helpers.js","bn.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\node_modules\\bn.js\\lib\\bn.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\node_modules\\ethjs-util\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-util\dist.browser\bytes.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.baToJSON = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.unpadHexString = exports.unpadArray = exports.unpadBuffer = exports.setLengthRight = exports.setLengthLeft = exports.zeros = void 0;
var bn_js_1 = __importDefault(require("bn.js"));
var ethjs_util_1 = require("ethjs-util");
var helpers_1 = require("./helpers");
/**
 * Returns a buffer filled with 0s.
 * @param bytes the number of bytes the buffer should be
 */
exports.zeros = function (bytes) {
    return Buffer.allocUnsafe(bytes).fill(0);
};
/**
 * Pads a `Buffer` with zeros till it has `length` bytes.
 * Truncates the beginning or end of input if its length exceeds `length`.
 * @param msg the value to pad (Buffer)
 * @param length the number of bytes the output should be
 * @param right whether to start padding form the left or right
 * @return (Buffer)
 */
var setLength = function (msg, length, right) {
    var buf = exports.zeros(length);
    if (right) {
        if (msg.length < length) {
            msg.copy(buf);
            return buf;
        }
        return msg.slice(0, length);
    }
    else {
        if (msg.length < length) {
            msg.copy(buf, length - msg.length);
            return buf;
        }
        return msg.slice(-length);
    }
};
/**
 * Left Pads a `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param msg the value to pad (Buffer)
 * @param length the number of bytes the output should be
 * @return (Buffer)
 */
exports.setLengthLeft = function (msg, length) {
    helpers_1.assertIsBuffer(msg);
    return setLength(msg, length, false);
};
/**
 * Right Pads a `Buffer` with trailing zeros till it has `length` bytes.
 * it truncates the end if it exceeds.
 * @param msg the value to pad (Buffer)
 * @param length the number of bytes the output should be
 * @return (Buffer)
 */
exports.setLengthRight = function (msg, length) {
    helpers_1.assertIsBuffer(msg);
    return setLength(msg, length, true);
};
/**
 * Trims leading zeros from a `Buffer`, `String` or `Number[]`.
 * @param a (Buffer|Array|String)
 * @return (Buffer|Array|String)
 */
var stripZeros = function (a) {
    var first = a[0];
    while (a.length > 0 && first.toString() === '0') {
        a = a.slice(1);
        first = a[0];
    }
    return a;
};
/**
 * Trims leading zeros from a `Buffer`.
 * @param a (Buffer)
 * @return (Buffer)
 */
exports.unpadBuffer = function (a) {
    helpers_1.assertIsBuffer(a);
    return stripZeros(a);
};
/**
 * Trims leading zeros from an `Array` (of numbers).
 * @param a (number[])
 * @return (number[])
 */
exports.unpadArray = function (a) {
    helpers_1.assertIsArray(a);
    return stripZeros(a);
};
/**
 * Trims leading zeros from a hex-prefixed `String`.
 * @param a (String)
 * @return (String)
 */
exports.unpadHexString = function (a) {
    helpers_1.assertIsHexString(a);
    a = ethjs_util_1.stripHexPrefix(a);
    return stripZeros(a);
};
/**
 * Attempts to turn a value into a `Buffer`.
 * Inputs supported: `Buffer`, `String` (hex-prefixed), `Number`, null/undefined, `BN` and other objects
 * with a `toArray()` or `toBuffer()` method.
 * @param v the value
 */
exports.toBuffer = function (v) {
    if (v === null || v === undefined) {
        return Buffer.allocUnsafe(0);
    }
    if (Buffer.isBuffer(v)) {
        return Buffer.from(v);
    }
    if (Array.isArray(v) || v instanceof Uint8Array) {
        return Buffer.from(v);
    }
    if (typeof v === 'string') {
        if (!ethjs_util_1.isHexString(v)) {
            throw new Error("Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: " + v);
        }
        return Buffer.from(ethjs_util_1.padToEven(ethjs_util_1.stripHexPrefix(v)), 'hex');
    }
    if (typeof v === 'number') {
        return ethjs_util_1.intToBuffer(v);
    }
    if (bn_js_1.default.isBN(v)) {
        return v.toArrayLike(Buffer);
    }
    if (v.toArray) {
        // converts a BN to a Buffer
        return Buffer.from(v.toArray());
    }
    if (v.toBuffer) {
        return Buffer.from(v.toBuffer());
    }
    throw new Error('invalid type');
};
/**
 * Converts a `Buffer` to a `Number`.
 * @param buf `Buffer` object to convert
 * @throws If the input number exceeds 53 bits.
 */
exports.bufferToInt = function (buf) {
    return new bn_js_1.default(exports.toBuffer(buf)).toNumber();
};
/**
 * Converts a `Buffer` into a `0x`-prefixed hex `String`.
 * @param buf `Buffer` object to convert
 */
exports.bufferToHex = function (buf) {
    buf = exports.toBuffer(buf);
    return '0x' + buf.toString('hex');
};
/**
 * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
 * @param num Signed integer value
 */
exports.fromSigned = function (num) {
    return new bn_js_1.default(num).fromTwos(256);
};
/**
 * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
 * @param num
 */
exports.toUnsigned = function (num) {
    return Buffer.from(num.toTwos(256).toArray());
};
/**
 * Adds "0x" to a given `String` if it does not already start with "0x".
 */
exports.addHexPrefix = function (str) {
    if (typeof str !== 'string') {
        return str;
    }
    return ethjs_util_1.isHexPrefixed(str) ? str : '0x' + str;
};
/**
 * Converts a `Buffer` or `Array` to JSON.
 * @param ba (Buffer|Array)
 * @return (Array|String|null)
 */
exports.baToJSON = function (ba) {
    if (Buffer.isBuffer(ba)) {
        return "0x" + ba.toString('hex');
    }
    else if (ba instanceof Array) {
        var array = [];
        for (var i = 0; i < ba.length; i++) {
            array.push(exports.baToJSON(ba[i]));
        }
        return array;
    }
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\bytes.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\externals.js", {"bn.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\node_modules\\bn.js\\lib\\bn.js","rlp":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\rlp\\dist.browser\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-util\dist.browser\externals.js
      return function (require, module, exports) {
"use strict";
/**
 * Re-exports commonly used modules:
 * * Exports [`BN`](https://github.com/indutny/bn.js), [`rlp`](https://github.com/ethereumjs/rlp).
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.rlp = exports.BN = void 0;
var bn_js_1 = __importDefault(require("bn.js"));
exports.BN = bn_js_1.default;
var rlp = __importStar(require("rlp"));
exports.rlp = rlp;
//# sourceMappingURL=externals.js.map
      };
    };
  }
}, {package:"ethereumjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\externals.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\object.js", {"./bytes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\bytes.js","assert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\assert.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\node_modules\\ethjs-util\\lib\\index.js","rlp":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\rlp\\dist.browser\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-util\dist.browser\object.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defineProperties = void 0;
var assert_1 = __importDefault(require("assert"));
var ethjsUtil = __importStar(require("ethjs-util"));
var rlp = __importStar(require("rlp"));
var bytes_1 = require("./bytes");
/**
 * Defines properties on a `Object`. It make the assumption that underlying data is binary.
 * @param self the `Object` to define properties on
 * @param fields an array fields to define. Fields can contain:
 * * `name` - the name of the properties
 * * `length` - the number of bytes the field can have
 * * `allowLess` - if the field can be less than the length
 * * `allowEmpty`
 * @param data data to be validated against the definitions
 * @deprecated
 */
exports.defineProperties = function (self, fields, data) {
    self.raw = [];
    self._fields = [];
    // attach the `toJSON`
    self.toJSON = function (label) {
        if (label === void 0) { label = false; }
        if (label) {
            var obj_1 = {};
            self._fields.forEach(function (field) {
                obj_1[field] = "0x" + self[field].toString('hex');
            });
            return obj_1;
        }
        return bytes_1.baToJSON(self.raw);
    };
    self.serialize = function serialize() {
        return rlp.encode(self.raw);
    };
    fields.forEach(function (field, i) {
        self._fields.push(field.name);
        function getter() {
            return self.raw[i];
        }
        function setter(v) {
            v = bytes_1.toBuffer(v);
            if (v.toString('hex') === '00' && !field.allowZero) {
                v = Buffer.allocUnsafe(0);
            }
            if (field.allowLess && field.length) {
                v = bytes_1.unpadBuffer(v);
                assert_1.default(field.length >= v.length, "The field " + field.name + " must not have more " + field.length + " bytes");
            }
            else if (!(field.allowZero && v.length === 0) && field.length) {
                assert_1.default(field.length === v.length, "The field " + field.name + " must have byte length of " + field.length);
            }
            self.raw[i] = v;
        }
        Object.defineProperty(self, field.name, {
            enumerable: true,
            configurable: true,
            get: getter,
            set: setter,
        });
        if (field.default) {
            self[field.name] = field.default;
        }
        // attach alias
        if (field.alias) {
            Object.defineProperty(self, field.alias, {
                enumerable: false,
                configurable: true,
                set: setter,
                get: getter,
            });
        }
    });
    // if the constuctor is passed data
    if (data) {
        if (typeof data === 'string') {
            data = Buffer.from(ethjsUtil.stripHexPrefix(data), 'hex');
        }
        if (Buffer.isBuffer(data)) {
            data = rlp.decode(data);
        }
        if (Array.isArray(data)) {
            if (data.length > self._fields.length) {
                throw new Error('wrong number of fields in data');
            }
            // make sure all the items are buffers
            data.forEach(function (d, i) {
                self[self._fields[i]] = bytes_1.toBuffer(d);
            });
        }
        else if (typeof data === 'object') {
            var keys_1 = Object.keys(data);
            fields.forEach(function (field) {
                if (keys_1.indexOf(field.name) !== -1)
                    self[field.name] = data[field.name];
                if (keys_1.indexOf(field.alias) !== -1)
                    self[field.alias] = data[field.alias];
            });
        }
        else {
            throw new Error('invalid data');
        }
    }
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\object.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\account.js", {"./bytes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\bytes.js","./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\constants.js","./hash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\hash.js","./helpers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\helpers.js","./types":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\types.js","assert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\assert.js","bn.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\node_modules\\bn.js\\lib\\bn.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereum-cryptography/secp256k1":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereum-cryptography\\secp256k1.js","ethjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\node_modules\\ethjs-util\\lib\\index.js","rlp":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\rlp\\dist.browser\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-util\dist.browser\account.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;
var assert_1 = __importDefault(require("assert"));
var bn_js_1 = __importDefault(require("bn.js"));
var rlp = __importStar(require("rlp"));
var secp256k1_1 = require("ethereum-cryptography/secp256k1");
var ethjs_util_1 = require("ethjs-util");
var constants_1 = require("./constants");
var bytes_1 = require("./bytes");
var hash_1 = require("./hash");
var helpers_1 = require("./helpers");
var types_1 = require("./types");
var Account = /** @class */ (function () {
    /**
     * This constructor assigns and validates the values.
     * Use the static factory methods to assist in creating an Account from varying data types.
     */
    function Account(nonce, balance, stateRoot, codeHash) {
        if (nonce === void 0) { nonce = new bn_js_1.default(0); }
        if (balance === void 0) { balance = new bn_js_1.default(0); }
        if (stateRoot === void 0) { stateRoot = constants_1.KECCAK256_RLP; }
        if (codeHash === void 0) { codeHash = constants_1.KECCAK256_NULL; }
        this.nonce = nonce;
        this.balance = balance;
        this.stateRoot = stateRoot;
        this.codeHash = codeHash;
        this._validate();
    }
    Account.fromAccountData = function (accountData) {
        var nonce = accountData.nonce, balance = accountData.balance, stateRoot = accountData.stateRoot, codeHash = accountData.codeHash;
        return new Account(nonce ? new bn_js_1.default(bytes_1.toBuffer(nonce)) : undefined, balance ? new bn_js_1.default(bytes_1.toBuffer(balance)) : undefined, stateRoot ? bytes_1.toBuffer(stateRoot) : undefined, codeHash ? bytes_1.toBuffer(codeHash) : undefined);
    };
    Account.fromRlpSerializedAccount = function (serialized) {
        var values = rlp.decode(serialized);
        if (!Array.isArray(values)) {
            throw new Error('Invalid serialized account input. Must be array');
        }
        return this.fromValuesArray(values);
    };
    Account.fromValuesArray = function (values) {
        var _a = __read(values, 4), nonce = _a[0], balance = _a[1], stateRoot = _a[2], codeHash = _a[3];
        return new Account(new bn_js_1.default(nonce), new bn_js_1.default(balance), stateRoot, codeHash);
    };
    Account.prototype._validate = function () {
        if (this.nonce.lt(new bn_js_1.default(0))) {
            throw new Error('nonce must be greater than zero');
        }
        if (this.balance.lt(new bn_js_1.default(0))) {
            throw new Error('balance must be greater than zero');
        }
        if (this.stateRoot.length !== 32) {
            throw new Error('stateRoot must have a length of 32');
        }
        if (this.codeHash.length !== 32) {
            throw new Error('codeHash must have a length of 32');
        }
    };
    /**
     * Returns a Buffer Array of the raw Buffers for the account, in order.
     */
    Account.prototype.raw = function () {
        return [
            types_1.bnToUnpaddedBuffer(this.nonce),
            types_1.bnToUnpaddedBuffer(this.balance),
            this.stateRoot,
            this.codeHash,
        ];
    };
    /**
     * Returns the RLP serialization of the account as a `Buffer`.
     */
    Account.prototype.serialize = function () {
        return rlp.encode(this.raw());
    };
    /**
     * Returns a `Boolean` determining if the account is a contract.
     */
    Account.prototype.isContract = function () {
        return !this.codeHash.equals(constants_1.KECCAK256_NULL);
    };
    /**
     * Returns a `Boolean` determining if the account is empty complying to the definition of
     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):
     * "An account is considered empty when it has no code and zero nonce and zero balance."
     */
    Account.prototype.isEmpty = function () {
        return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(constants_1.KECCAK256_NULL);
    };
    return Account;
}());
exports.Account = Account;
/**
 * Checks if the address is a valid. Accepts checksummed addresses too.
 */
exports.isValidAddress = function (hexAddress) {
    try {
        helpers_1.assertIsString(hexAddress);
    }
    catch (e) {
        return false;
    }
    return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);
};
/**
 * Returns a checksummed address.
 *
 * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This
 * has the effect of checksummed addresses for one chain having invalid checksums for others.
 * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).
 *
 * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly
 * used variation in Ethereum was without the chainId. This may change in the future.
 */
exports.toChecksumAddress = function (hexAddress, eip1191ChainId) {
    helpers_1.assertIsHexString(hexAddress);
    var address = ethjs_util_1.stripHexPrefix(hexAddress).toLowerCase();
    var prefix = '';
    if (eip1191ChainId) {
        var chainId = types_1.toType(eip1191ChainId, types_1.TypeOutput.BN);
        prefix = chainId.toString() + '0x';
    }
    var hash = hash_1.keccakFromString(prefix + address).toString('hex');
    var ret = '0x';
    for (var i = 0; i < address.length; i++) {
        if (parseInt(hash[i], 16) >= 8) {
            ret += address[i].toUpperCase();
        }
        else {
            ret += address[i];
        }
    }
    return ret;
};
/**
 * Checks if the address is a valid checksummed address.
 *
 * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.
 */
exports.isValidChecksumAddress = function (hexAddress, eip1191ChainId) {
    return exports.isValidAddress(hexAddress) && exports.toChecksumAddress(hexAddress, eip1191ChainId) === hexAddress;
};
/**
 * Generates an address of a newly created contract.
 * @param from The address which is creating this new address
 * @param nonce The nonce of the from account
 */
exports.generateAddress = function (from, nonce) {
    helpers_1.assertIsBuffer(from);
    helpers_1.assertIsBuffer(nonce);
    var nonceBN = new bn_js_1.default(nonce);
    if (nonceBN.isZero()) {
        // in RLP we want to encode null in the case of zero nonce
        // read the RLP documentation for an answer if you dare
        return hash_1.rlphash([from, null]).slice(-20);
    }
    // Only take the lower 160bits of the hash
    return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);
};
/**
 * Generates an address for a contract created using CREATE2.
 * @param from The address which is creating this new address
 * @param salt A salt
 * @param initCode The init code of the contract being created
 */
exports.generateAddress2 = function (from, salt, initCode) {
    helpers_1.assertIsBuffer(from);
    helpers_1.assertIsBuffer(salt);
    helpers_1.assertIsBuffer(initCode);
    assert_1.default(from.length === 20);
    assert_1.default(salt.length === 32);
    var address = hash_1.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, hash_1.keccak256(initCode)]));
    return address.slice(-20);
};
/**
 * Checks if the private key satisfies the rules of the curve secp256k1.
 */
exports.isValidPrivate = function (privateKey) {
    return secp256k1_1.privateKeyVerify(privateKey);
};
/**
 * Checks if the public key satisfies the rules of the curve secp256k1
 * and the requirements of Ethereum.
 * @param publicKey The two points of an uncompressed key, unless sanitize is enabled
 * @param sanitize Accept public keys in other formats
 */
exports.isValidPublic = function (publicKey, sanitize) {
    if (sanitize === void 0) { sanitize = false; }
    helpers_1.assertIsBuffer(publicKey);
    if (publicKey.length === 64) {
        // Convert to SEC1 for secp256k1
        return secp256k1_1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));
    }
    if (!sanitize) {
        return false;
    }
    return secp256k1_1.publicKeyVerify(publicKey);
};
/**
 * Returns the ethereum address of a given public key.
 * Accepts "Ethereum public keys" and SEC1 encoded keys.
 * @param pubKey The two points of an uncompressed key, unless sanitize is enabled
 * @param sanitize Accept public keys in other formats
 */
exports.pubToAddress = function (pubKey, sanitize) {
    if (sanitize === void 0) { sanitize = false; }
    helpers_1.assertIsBuffer(pubKey);
    if (sanitize && pubKey.length !== 64) {
        pubKey = Buffer.from(secp256k1_1.publicKeyConvert(pubKey, false).slice(1));
    }
    assert_1.default(pubKey.length === 64);
    // Only take the lower 160bits of the hash
    return hash_1.keccak(pubKey).slice(-20);
};
exports.publicToAddress = exports.pubToAddress;
/**
 * Returns the ethereum public key of a given private key.
 * @param privateKey A private key must be 256 bits wide
 */
exports.privateToPublic = function (privateKey) {
    helpers_1.assertIsBuffer(privateKey);
    // skip the type flag and use the X, Y points
    return Buffer.from(secp256k1_1.publicKeyCreate(privateKey, false)).slice(1);
};
/**
 * Returns the ethereum address of a given private key.
 * @param privateKey A private key must be 256 bits wide
 */
exports.privateToAddress = function (privateKey) {
    return exports.publicToAddress(exports.privateToPublic(privateKey));
};
/**
 * Converts a public key to the Ethereum format.
 */
exports.importPublic = function (publicKey) {
    helpers_1.assertIsBuffer(publicKey);
    if (publicKey.length !== 64) {
        publicKey = Buffer.from(secp256k1_1.publicKeyConvert(publicKey, false).slice(1));
    }
    return publicKey;
};
/**
 * Returns the zero address.
 */
exports.zeroAddress = function () {
    var addressLength = 20;
    var addr = bytes_1.zeros(addressLength);
    return bytes_1.bufferToHex(addr);
};
/**
 * Checks if a given address is the zero address.
 */
exports.isZeroAddress = function (hexAddress) {
    try {
        helpers_1.assertIsString(hexAddress);
    }
    catch (e) {
        return false;
    }
    var zeroAddr = exports.zeroAddress();
    return zeroAddr === hexAddress;
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\account.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\constants.js", {"bn.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\node_modules\\bn.js\\lib\\bn.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-util\dist.browser\constants.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.MAX_INTEGER = void 0;
var Buffer = require('buffer').Buffer;
var bn_js_1 = __importDefault(require("bn.js"));
/**
 * The max integer that this VM can handle
 */
exports.MAX_INTEGER = new bn_js_1.default('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);
/**
 * 2^256
 */
exports.TWO_POW256 = new bn_js_1.default('10000000000000000000000000000000000000000000000000000000000000000', 16);
/**
 * Keccak-256 hash of null
 */
exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
/**
 * Keccak-256 hash of null
 */
exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');
/**
 * Keccak-256 of an RLP of an empty array
 */
exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
/**
 * Keccak-256 of an RLP of an empty array
 */
exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
/**
 * Keccak-256 hash of the RLP of null
 */
exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
/**
 * Keccak-256 hash of the RLP of null
 */
exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');
//# sourceMappingURL=constants.js.map
      };
    };
  }
}, {package:"ethereumjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\constants.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\node_modules\\ethjs-util\\lib\\index.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","is-hex-prefixed":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-hex-prefixed\\src\\index.js","strip-hex-prefix":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\strip-hex-prefix\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-util\node_modules\ethjs-util\lib\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var isHexPrefixed = require('is-hex-prefixed');
var stripHexPrefix = require('strip-hex-prefix');

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + hex;
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return new Buffer(padToEven(hex.slice(2)), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\node_modules\\ethjs-util\\lib\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\signature.js", {"./bytes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\bytes.js","./hash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\hash.js","./helpers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\helpers.js","./types":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\types.js","bn.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\node_modules\\bn.js\\lib\\bn.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereum-cryptography/secp256k1":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereum-cryptography\\secp256k1.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-util\dist.browser\signature.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toCompactSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;
var secp256k1_1 = require("ethereum-cryptography/secp256k1");
var bn_js_1 = __importDefault(require("bn.js"));
var bytes_1 = require("./bytes");
var hash_1 = require("./hash");
var helpers_1 = require("./helpers");
var types_1 = require("./types");
function ecsign(msgHash, privateKey, chainId) {
    var _a = secp256k1_1.ecdsaSign(msgHash, privateKey), signature = _a.signature, recovery = _a.recid;
    var r = Buffer.from(signature.slice(0, 32));
    var s = Buffer.from(signature.slice(32, 64));
    if (!chainId || typeof chainId === 'number') {
        // return legacy type ECDSASignature (deprecated in favor of ECDSASignatureBuffer to handle large chainIds)
        if (chainId && !Number.isSafeInteger(chainId)) {
            throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');
        }
        var v_1 = chainId ? recovery + (chainId * 2 + 35) : recovery + 27;
        return { r: r, s: s, v: v_1 };
    }
    var chainIdBN = types_1.toType(chainId, types_1.TypeOutput.BN);
    var v = chainIdBN.muln(2).addn(35).addn(recovery).toArrayLike(Buffer);
    return { r: r, s: s, v: v };
}
exports.ecsign = ecsign;
function calculateSigRecovery(v, chainId) {
    var vBN = types_1.toType(v, types_1.TypeOutput.BN);
    if (!chainId) {
        return vBN.subn(27);
    }
    var chainIdBN = types_1.toType(chainId, types_1.TypeOutput.BN);
    return vBN.sub(chainIdBN.muln(2).addn(35));
}
function isValidSigRecovery(recovery) {
    var rec = new bn_js_1.default(recovery);
    return rec.eqn(0) || rec.eqn(1);
}
/**
 * ECDSA public key recovery from signature.
 * @returns Recovered public key
 */
exports.ecrecover = function (msgHash, v, r, s, chainId) {
    var signature = Buffer.concat([bytes_1.setLengthLeft(r, 32), bytes_1.setLengthLeft(s, 32)], 64);
    var recovery = calculateSigRecovery(v, chainId);
    if (!isValidSigRecovery(recovery)) {
        throw new Error('Invalid signature v value');
    }
    var senderPubKey = secp256k1_1.ecdsaRecover(signature, recovery.toNumber(), msgHash);
    return Buffer.from(secp256k1_1.publicKeyConvert(senderPubKey, false).slice(1));
};
/**
 * Convert signature parameters into the format of `eth_sign` RPC method.
 * @returns Signature
 */
exports.toRpcSig = function (v, r, s, chainId) {
    var recovery = calculateSigRecovery(v, chainId);
    if (!isValidSigRecovery(recovery)) {
        throw new Error('Invalid signature v value');
    }
    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
    return bytes_1.bufferToHex(Buffer.concat([bytes_1.setLengthLeft(r, 32), bytes_1.setLengthLeft(s, 32), bytes_1.toBuffer(v)]));
};
/**
 * Convert signature parameters into the format of Compact Signature Representation (EIP-2098).
 * @returns Signature
 */
exports.toCompactSig = function (v, r, s, chainId) {
    var recovery = calculateSigRecovery(v, chainId);
    if (!isValidSigRecovery(recovery)) {
        throw new Error('Invalid signature v value');
    }
    var vn = types_1.toType(v, types_1.TypeOutput.Number);
    var ss = s;
    if ((vn > 28 && vn % 2 === 1) || vn === 1 || vn === 28) {
        ss = Buffer.from(s);
        ss[0] |= 0x80;
    }
    return bytes_1.bufferToHex(Buffer.concat([bytes_1.setLengthLeft(r, 32), bytes_1.setLengthLeft(ss, 32)]));
};
/**
 * Convert signature format of the `eth_sign` RPC method to signature parameters
 * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053
 */
exports.fromRpcSig = function (sig) {
    var buf = bytes_1.toBuffer(sig);
    var r;
    var s;
    var v;
    if (buf.length >= 65) {
        r = buf.slice(0, 32);
        s = buf.slice(32, 64);
        v = bytes_1.bufferToInt(buf.slice(64));
    }
    else if (buf.length === 64) {
        // Compact Signature Representation (https://eips.ethereum.org/EIPS/eip-2098)
        r = buf.slice(0, 32);
        s = buf.slice(32, 64);
        v = bytes_1.bufferToInt(buf.slice(32, 33)) >> 7;
        s[0] &= 0x7f;
    }
    else {
        throw new Error('Invalid signature length');
    }
    // support both versions of `eth_sign` responses
    if (v < 27) {
        v += 27;
    }
    return {
        v: v,
        r: r,
        s: s,
    };
};
/**
 * Validate a ECDSA signature.
 * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one
 */
exports.isValidSignature = function (v, r, s, homesteadOrLater, chainId) {
    if (homesteadOrLater === void 0) { homesteadOrLater = true; }
    var SECP256K1_N_DIV_2 = new bn_js_1.default('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
    var SECP256K1_N = new bn_js_1.default('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);
    if (r.length !== 32 || s.length !== 32) {
        return false;
    }
    if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {
        return false;
    }
    var rBN = new bn_js_1.default(r);
    var sBN = new bn_js_1.default(s);
    if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {
        return false;
    }
    if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {
        return false;
    }
    return true;
};
/**
 * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
 * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
 * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
 * used to produce the signature.
 */
exports.hashPersonalMessage = function (message) {
    helpers_1.assertIsBuffer(message);
    var prefix = Buffer.from("\u0019Ethereum Signed Message:\n" + message.length.toString(), 'utf-8');
    return hash_1.keccak(Buffer.concat([prefix, message]));
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\signature.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\hash.js", {"./bytes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\bytes.js","./helpers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\helpers.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","create-hash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\create-hash\\browser.js","ethereum-cryptography/keccak":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereum-cryptography\\keccak.js","rlp":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\rlp\\dist.browser\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-util\dist.browser\hash.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.rlphash = exports.ripemd160FromArray = exports.ripemd160FromString = exports.ripemd160 = exports.sha256FromArray = exports.sha256FromString = exports.sha256 = exports.keccakFromArray = exports.keccakFromHexString = exports.keccakFromString = exports.keccak256 = exports.keccak = void 0;
var keccak_1 = require("ethereum-cryptography/keccak");
var createHash = require('create-hash');
var rlp = __importStar(require("rlp"));
var bytes_1 = require("./bytes");
var helpers_1 = require("./helpers");
/**
 * Creates Keccak hash of a Buffer input
 * @param a The input data (Buffer)
 * @param bits (number = 256) The Keccak width
 */
exports.keccak = function (a, bits) {
    if (bits === void 0) { bits = 256; }
    helpers_1.assertIsBuffer(a);
    switch (bits) {
        case 224: {
            return keccak_1.keccak224(a);
        }
        case 256: {
            return keccak_1.keccak256(a);
        }
        case 384: {
            return keccak_1.keccak384(a);
        }
        case 512: {
            return keccak_1.keccak512(a);
        }
        default: {
            throw new Error("Invald algorithm: keccak" + bits);
        }
    }
};
/**
 * Creates Keccak-256 hash of the input, alias for keccak(a, 256).
 * @param a The input data (Buffer)
 */
exports.keccak256 = function (a) {
    return exports.keccak(a);
};
/**
 * Creates Keccak hash of a utf-8 string input
 * @param a The input data (String)
 * @param bits (number = 256) The Keccak width
 */
exports.keccakFromString = function (a, bits) {
    if (bits === void 0) { bits = 256; }
    helpers_1.assertIsString(a);
    var buf = Buffer.from(a, 'utf8');
    return exports.keccak(buf, bits);
};
/**
 * Creates Keccak hash of an 0x-prefixed string input
 * @param a The input data (String)
 * @param bits (number = 256) The Keccak width
 */
exports.keccakFromHexString = function (a, bits) {
    if (bits === void 0) { bits = 256; }
    helpers_1.assertIsHexString(a);
    return exports.keccak(bytes_1.toBuffer(a), bits);
};
/**
 * Creates Keccak hash of a number array input
 * @param a The input data (number[])
 * @param bits (number = 256) The Keccak width
 */
exports.keccakFromArray = function (a, bits) {
    if (bits === void 0) { bits = 256; }
    helpers_1.assertIsArray(a);
    return exports.keccak(bytes_1.toBuffer(a), bits);
};
/**
 * Creates SHA256 hash of an input.
 * @param  a The input data (Buffer|Array|String)
 */
var _sha256 = function (a) {
    a = bytes_1.toBuffer(a);
    return createHash('sha256').update(a).digest();
};
/**
 * Creates SHA256 hash of a Buffer input.
 * @param a The input data (Buffer)
 */
exports.sha256 = function (a) {
    helpers_1.assertIsBuffer(a);
    return _sha256(a);
};
/**
 * Creates SHA256 hash of a string input.
 * @param a The input data (string)
 */
exports.sha256FromString = function (a) {
    helpers_1.assertIsString(a);
    return _sha256(a);
};
/**
 * Creates SHA256 hash of a number[] input.
 * @param a The input data (number[])
 */
exports.sha256FromArray = function (a) {
    helpers_1.assertIsArray(a);
    return _sha256(a);
};
/**
 * Creates RIPEMD160 hash of the input.
 * @param a The input data (Buffer|Array|String|Number)
 * @param padded Whether it should be padded to 256 bits or not
 */
var _ripemd160 = function (a, padded) {
    a = bytes_1.toBuffer(a);
    var hash = createHash('rmd160').update(a).digest();
    if (padded === true) {
        return bytes_1.setLengthLeft(hash, 32);
    }
    else {
        return hash;
    }
};
/**
 * Creates RIPEMD160 hash of a Buffer input.
 * @param a The input data (Buffer)
 * @param padded Whether it should be padded to 256 bits or not
 */
exports.ripemd160 = function (a, padded) {
    helpers_1.assertIsBuffer(a);
    return _ripemd160(a, padded);
};
/**
 * Creates RIPEMD160 hash of a string input.
 * @param a The input data (String)
 * @param padded Whether it should be padded to 256 bits or not
 */
exports.ripemd160FromString = function (a, padded) {
    helpers_1.assertIsString(a);
    return _ripemd160(a, padded);
};
/**
 * Creates RIPEMD160 hash of a number[] input.
 * @param a The input data (number[])
 * @param padded Whether it should be padded to 256 bits or not
 */
exports.ripemd160FromArray = function (a, padded) {
    helpers_1.assertIsArray(a);
    return _ripemd160(a, padded);
};
/**
 * Creates SHA-3 hash of the RLP encoded version of the input.
 * @param a The input data
 */
exports.rlphash = function (a) {
    return exports.keccak(rlp.encode(a));
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\hash.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\network.utils.js", {"../constants/network":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\constants\\network.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\shared\modules\network.utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPrefixedFormattedHexString = isPrefixedFormattedHexString;
exports.isSafeChainId = isSafeChainId;

var _network = require("../constants/network");

/**
 * Checks whether the given number primitive chain ID is safe.
 * Because some cryptographic libraries we use expect the chain ID to be a
 * number primitive, it must not exceed a certain size.
 *
 * @param {number} chainId - The chain ID to check for safety.
 * @returns {boolean} Whether the given chain ID is safe.
 */
function isSafeChainId(chainId) {
  return Number.isSafeInteger(chainId) && chainId > 0 && chainId <= _network.MAX_SAFE_CHAIN_ID;
}
/**
 * Checks whether the given value is a 0x-prefixed, non-zero, non-zero-padded,
 * hexadecimal string.
 *
 * @param {any} value - The value to check.
 * @returns {boolean} True if the value is a correctly formatted hex string,
 * false otherwise.
 */


function isPrefixedFormattedHexString(value) {
  if (typeof value !== 'string') {
    return false;
  }

  return /^0x[1-9a-f]+[0-9a-f]*$/iu.test(value);
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\shared\\modules\\network.utils.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\obs-store\\index.js", {"safe-event-emitter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\safe-event-emitter\\index.js","xtend":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\xtend\\immutable.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\obs-store\index.js
      return function (require, module, exports) {
'use strict'

const extend = require('xtend')
const SafeEventEmitter = require('safe-event-emitter')

class ObservableStore extends SafeEventEmitter {

  constructor (initState = {}) {
    super()
    // set init state
    this._state = initState
  }

  // wrapper around internal getState
  getState () {
    return this._getState()
  }
  
  // wrapper around internal putState
  putState (newState) {
    this._putState(newState)
    this.emit('update', newState)
  }

  updateState (partialState) {
    // if non-null object, merge
    if (partialState && typeof partialState === 'object') {
      const state = this.getState()
      const newState = Object.assign({}, state, partialState)
      this.putState(newState)
    // if not object, use new value
    } else {
      this.putState(partialState)
    }
  }

  // subscribe to changes
  subscribe (handler) {
    this.on('update', handler)
  }

  // unsubscribe to changes
  unsubscribe (handler) {
    this.removeListener('update', handler)
  }

  //
  // private
  //

  // read from persistence
  _getState () {
    return this._state
  }

  // write to persistence
  _putState (newState) {
    this._state = newState
  }

}

module.exports = ObservableStore

      };
    };
  }
}, {package:"obs-store",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\obs-store\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browser-passworder\\index.js", {"browserify-unibabel":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify-unibabel\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\browser-passworder\index.js
      return function (require, module, exports) {
var Unibabel = require('browserify-unibabel')

module.exports = {

  // Simple encryption methods:
  encrypt,
  decrypt,

  // More advanced encryption methods:
  keyFromPassword,
  encryptWithKey,
  decryptWithKey,

  // Buffer <-> Hex string methods
  serializeBufferForStorage,
  serializeBufferFromStorage,

  generateSalt,
}

// Takes a Pojo, returns cypher text.
function encrypt (password, dataObj) {
  var salt = generateSalt()

  return keyFromPassword(password, salt)
  .then(function (passwordDerivedKey) {
    return encryptWithKey(passwordDerivedKey, dataObj)
  })
  .then(function (payload) {
    payload.salt = salt
    return JSON.stringify(payload)
  })
}

function encryptWithKey (key, dataObj) {
  var data = JSON.stringify(dataObj)
  var dataBuffer = Unibabel.utf8ToBuffer(data)
  var vector = global.crypto.getRandomValues(new Uint8Array(16))
  return global.crypto.subtle.encrypt({
    name: 'AES-GCM',
    iv: vector,
  }, key, dataBuffer).then(function (buf) {
    var buffer = new Uint8Array(buf)
    var vectorStr = Unibabel.bufferToBase64(vector)
    var vaultStr = Unibabel.bufferToBase64(buffer)
    return {
      data: vaultStr,
      iv: vectorStr,
    }
  })
}

// Takes encrypted text, returns the restored Pojo.
function decrypt (password, text) {
  const payload = JSON.parse(text)
  const salt = payload.salt
  return keyFromPassword(password, salt)
  .then(function (key) {
    return decryptWithKey(key, payload)
  })
}

function decryptWithKey (key, payload) {
  const encryptedData = Unibabel.base64ToBuffer(payload.data)
  const vector = Unibabel.base64ToBuffer(payload.iv)
  return crypto.subtle.decrypt({name: 'AES-GCM', iv: vector}, key, encryptedData)
  .then(function (result) {
    const decryptedData = new Uint8Array(result)
    const decryptedStr = Unibabel.bufferToUtf8(decryptedData)
    const decryptedObj = JSON.parse(decryptedStr)
    return decryptedObj
  })
  .catch(function (reason) {
    throw new Error('Incorrect password')
  })
}

function keyFromPassword (password, salt) {
  var passBuffer = Unibabel.utf8ToBuffer(password)
  var saltBuffer = Unibabel.base64ToBuffer(salt)

  return global.crypto.subtle.importKey(
    'raw',
    passBuffer,
    { name: 'PBKDF2' },
    false,
    ['deriveBits', 'deriveKey']
  ).then(function (key) {

    return global.crypto.subtle.deriveKey(
      { name: 'PBKDF2',
        salt: saltBuffer,
        iterations: 10000,
        hash: 'SHA-256',
      },
      key,
      { name: 'AES-GCM', length: 256 },
      false,
      ['encrypt', 'decrypt']
    )
  })
}

function serializeBufferFromStorage (str) {
  var stripStr = (str.slice(0, 2) === '0x') ? str.slice(2) : str
  var buf = new Uint8Array(stripStr.length / 2)
  for (var i = 0; i < stripStr.length; i += 2) {
    var seg = stripStr.substr(i, 2)
    buf[i / 2] = parseInt(seg, 16)
  }
  return buf
}

// Should return a string, ready for storage, in hex format.
function serializeBufferForStorage (buffer) {
  var result = '0x'
  var len = buffer.length || buffer.byteLength
  for (var i = 0; i < len; i++) {
    result += unprefixedHex(buffer[i])
  }
  return result
}

function unprefixedHex (num) {
  var hex = num.toString(16)
  while (hex.length < 2) {
    hex = '0' + hex
  }
  return hex
}

function generateSalt (byteCount = 32) {
  var view = new Uint8Array(byteCount)
  global.crypto.getRandomValues(view)
  var b64encoded = btoa(String.fromCharCode.apply(null, view))
  return b64encoded
}

      };
    };
  }
}, {package:"browser-passworder",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browser-passworder\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bip39\\index.js", {"./wordlists/chinese_simplified.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bip39\\wordlists\\chinese_simplified.json","./wordlists/chinese_traditional.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bip39\\wordlists\\chinese_traditional.json","./wordlists/english.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bip39\\wordlists\\english.json","./wordlists/french.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bip39\\wordlists\\french.json","./wordlists/italian.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bip39\\wordlists\\italian.json","./wordlists/japanese.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bip39\\wordlists\\japanese.json","./wordlists/korean.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bip39\\wordlists\\korean.json","./wordlists/spanish.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bip39\\wordlists\\spanish.json","create-hash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\create-hash\\browser.js","pbkdf2":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\pbkdf2\\browser.js","randombytes":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\randombytes\\browser.js","safe-buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\safe-buffer\\index.js","unorm":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\unorm\\lib\\unorm.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\bip39\index.js
      return function (require, module, exports) {
var Buffer = require('safe-buffer').Buffer
var createHash = require('create-hash')
var pbkdf2 = require('pbkdf2').pbkdf2Sync
var randomBytes = require('randombytes')

// use unorm until String.prototype.normalize gets better browser support
var unorm = require('unorm')

var CHINESE_SIMPLIFIED_WORDLIST = require('./wordlists/chinese_simplified.json')
var CHINESE_TRADITIONAL_WORDLIST = require('./wordlists/chinese_traditional.json')
var ENGLISH_WORDLIST = require('./wordlists/english.json')
var FRENCH_WORDLIST = require('./wordlists/french.json')
var ITALIAN_WORDLIST = require('./wordlists/italian.json')
var JAPANESE_WORDLIST = require('./wordlists/japanese.json')
var KOREAN_WORDLIST = require('./wordlists/korean.json')
var SPANISH_WORDLIST = require('./wordlists/spanish.json')
var DEFAULT_WORDLIST = ENGLISH_WORDLIST

var INVALID_MNEMONIC = 'Invalid mnemonic'
var INVALID_ENTROPY = 'Invalid entropy'
var INVALID_CHECKSUM = 'Invalid mnemonic checksum'

function lpad (str, padString, length) {
  while (str.length < length) str = padString + str
  return str
}

function binaryToByte (bin) {
  return parseInt(bin, 2)
}

function bytesToBinary (bytes) {
  return bytes.map(function (x) {
    return lpad(x.toString(2), '0', 8)
  }).join('')
}

function deriveChecksumBits (entropyBuffer) {
  var ENT = entropyBuffer.length * 8
  var CS = ENT / 32
  var hash = createHash('sha256').update(entropyBuffer).digest()

  return bytesToBinary([].slice.call(hash)).slice(0, CS)
}

function salt (password) {
  return 'mnemonic' + (password || '')
}

function mnemonicToSeed (mnemonic, password) {
  var mnemonicBuffer = typeof mnemonic === 'string'
    ? Buffer.from(unorm.nfkd(mnemonic), 'utf8')
    : mnemonic
  var saltBuffer = Buffer.from(salt(unorm.nfkd(password)), 'utf8')

  return pbkdf2(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512')
}

function mnemonicToSeedHex (mnemonic, password) {
  return mnemonicToSeed(mnemonic, password).toString('hex')
}

function mnemonicToEntropy (mnemonic, wordlist) {
  wordlist = wordlist || DEFAULT_WORDLIST

  var mnemonicAsBuffer = typeof mnemonic === 'string'
    ? Buffer.from(unorm.nfkd(mnemonic), 'utf8')
    : mnemonic

  var words = [];
  var currentWord = [];
  for (const byte of mnemonicAsBuffer.values()) {
    // split at space or \u3000 (ideographic space, for Japanese wordlists)
    if (byte === 0x20 || byte === 0x3000) {
      words.push(Buffer.from(currentWord));
      currentWord = [];
    } else {
      currentWord.push(byte);
    }
  }
  words.push(Buffer.from(currentWord));

  if (words.length % 3 !== 0) throw new Error(INVALID_MNEMONIC)

  // convert word indices to 11 bit binary strings
  var bits = words.map(function (word) {
    var index = wordlist.indexOf(word.toString('utf8'))
    if (index === -1) throw new Error(INVALID_MNEMONIC)

    return lpad(index.toString(2), '0', 11)
  }).join('')

  // split the binary string into ENT/CS
  var dividerIndex = Math.floor(bits.length / 33) * 32
  var entropyBits = bits.slice(0, dividerIndex)
  var checksumBits = bits.slice(dividerIndex)

  // calculate the checksum and compare
  var entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte)
  if (entropyBytes.length < 16) throw new Error(INVALID_ENTROPY)
  if (entropyBytes.length > 32) throw new Error(INVALID_ENTROPY)
  if (entropyBytes.length % 4 !== 0) throw new Error(INVALID_ENTROPY)

  var entropy = Buffer.from(entropyBytes)
  var newChecksum = deriveChecksumBits(entropy)
  if (newChecksum !== checksumBits) throw new Error(INVALID_CHECKSUM)

  return entropy.toString('hex')
}

function entropyToMnemonic (entropy, wordlist) {
  if (!Buffer.isBuffer(entropy)) entropy = Buffer.from(entropy, 'hex')
  wordlist = wordlist || DEFAULT_WORDLIST

  // 128 <= ENT <= 256
  if (entropy.length < 16) throw new TypeError(INVALID_ENTROPY)
  if (entropy.length > 32) throw new TypeError(INVALID_ENTROPY)
  if (entropy.length % 4 !== 0) throw new TypeError(INVALID_ENTROPY)

  var entropyBits = bytesToBinary([].slice.call(entropy))
  var checksumBits = deriveChecksumBits(entropy)

  var bits = entropyBits + checksumBits
  var chunks = bits.match(/(.{1,11})/g)
  var wordsAsBuffers = chunks.map(function (binary) {
    var index = binaryToByte(binary)
    return Buffer.from(wordlist[index], 'utf8')
  })

  var bufferSize = wordsAsBuffers.reduce(function (bufferSize, wordAsBuffer, i) {
    var shouldAddSeparator = i < wordsAsBuffers.length - 1
    return (
      bufferSize +
      wordAsBuffer.length +
      (shouldAddSeparator ? 1 : 0)
    )
  }, 0)
  var separator = wordlist === JAPANESE_WORDLIST ? '\u3000' : ' '
  var result = wordsAsBuffers.reduce(function (result, wordAsBuffer, i) {
    var shouldAddSeparator = i < wordsAsBuffers.length - 1
    result.workingBuffer.set(wordAsBuffer, result.offset)
    if (shouldAddSeparator) {
      result.workingBuffer.write(
        separator,
        result.offset + wordAsBuffer.length,
        separator.length,
        'utf8'
      )
    }
    return {
      workingBuffer: result.workingBuffer,
      offset: (
        result.offset +
        wordAsBuffer.length +
        (shouldAddSeparator ? 1 : 0)
      )
    }
  }, { workingBuffer: Buffer.alloc(bufferSize), offset: 0 })
  return result.workingBuffer;
}

function generateMnemonic (strength, rng, wordlist) {
  strength = strength || 128
  if (strength % 32 !== 0) throw new TypeError(INVALID_ENTROPY)
  rng = rng || randomBytes

  return entropyToMnemonic(rng(strength / 8), wordlist)
}

function validateMnemonic (mnemonic, wordlist) {
  try {
    mnemonicToEntropy(mnemonic, wordlist)
  } catch (e) {
    console.log('could not validate mnemonic', e)
    return false
  }

  return true
}

module.exports = {
  mnemonicToSeed: mnemonicToSeed,
  mnemonicToSeedHex: mnemonicToSeedHex,
  mnemonicToEntropy: mnemonicToEntropy,
  entropyToMnemonic: entropyToMnemonic,
  generateMnemonic: generateMnemonic,
  validateMnemonic: validateMnemonic,
  wordlists: {
    EN: ENGLISH_WORDLIST,
    JA: JAPANESE_WORDLIST,

    chinese_simplified: CHINESE_SIMPLIFIED_WORDLIST,
    chinese_traditional: CHINESE_TRADITIONAL_WORDLIST,
    english: ENGLISH_WORDLIST,
    french: FRENCH_WORDLIST,
    italian: ITALIAN_WORDLIST,
    japanese: JAPANESE_WORDLIST,
    korean: KOREAN_WORDLIST,
    spanish: SPANISH_WORDLIST
  }
}

      };
    };
  }
}, {package:"bip39",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bip39\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-hd-keyring\\index.js", {"bip39":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bip39\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","eth-sig-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-sig-util\\dist\\index.js","eth-simple-keyring":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-simple-keyring\\index.js","ethereumjs-wallet":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-hd-keyring\\node_modules\\ethereumjs-wallet\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-hd-keyring\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
const { hdkey } = require('ethereumjs-wallet')
const SimpleKeyring = require('eth-simple-keyring')
const bip39 = require('bip39')
const sigUtil = require('eth-sig-util')

// Options:
const hdPathString = `m/44'/60'/0'/0`
const type = 'HD Key Tree'

class HdKeyring extends SimpleKeyring {

  /* PUBLIC METHODS */
  constructor (opts = {}) {
    super()
    this.type = type
    this.deserialize(opts)
  }

  serialize () {
    const mnemonicAsBuffer = typeof this.mnemonic === 'string'
      ? Buffer.from(this.mnemonic, 'utf8')
      : this.mnemonic
    return Promise.resolve({
      mnemonic: Array.from(mnemonicAsBuffer.values()),
      numberOfAccounts: this.wallets.length,
      hdPath: this.hdPath,
    })
  }

  deserialize (opts = {}) {
    this.opts = opts || {}
    this.wallets = []
    this.mnemonic = null
    this.root = null
    this.hdPath = opts.hdPath || hdPathString

    if (opts.mnemonic) {
      this._initFromMnemonic(opts.mnemonic)
    }

    if (opts.numberOfAccounts) {
      return this.addAccounts(opts.numberOfAccounts)
    }

    return Promise.resolve([])
  }

  addAccounts (numberOfAccounts = 1) {
    if (!this.root) {
      this._initFromMnemonic(bip39.generateMnemonic())
    }

    const oldLen = this.wallets.length
    const newWallets = []
    for (let i = oldLen; i < numberOfAccounts + oldLen; i++) {
      const child = this.root.deriveChild(i)
      const wallet = child.getWallet()
      newWallets.push(wallet)
      this.wallets.push(wallet)
    }
    const hexWallets = newWallets.map((w) => {
      return sigUtil.normalize(w.getAddress().toString('hex'))
    })
    return Promise.resolve(hexWallets)
  }

  getAccounts () {
    return Promise.resolve(this.wallets.map((w) => {
      return sigUtil.normalize(w.getAddress().toString('hex'))
    }))
  }

  /* PRIVATE METHODS */

  /**
   * Sets appropriate properties for the keyring based on the given
   * BIP39-compliant mnemonic.
   *
   * @param {string|Array<number>|Buffer} mnemonic - A seed phrase represented
   * as a string, an array of UTF-8 bytes, or a Buffer.
   */
  _initFromMnemonic(mnemonic) {
    if (typeof mnemonic === 'string') {
      this.mnemonic = Buffer.from(mnemonic, 'utf8')
    } else if (Array.isArray(mnemonic)) {
      this.mnemonic = Buffer.from(mnemonic)
    } else {
      this.mnemonic = mnemonic
    }
    const seed = bip39.mnemonicToSeed(this.mnemonic)
    this.hdWallet = hdkey.fromMasterSeed(seed)
    this.root = this.hdWallet.derivePath(this.hdPath)
  }
}

HdKeyring.type = type
module.exports = HdKeyring

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"eth-hd-keyring",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-hd-keyring\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-simple-keyring\\index.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","eth-sig-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-sig-util\\dist\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\index.js","ethereumjs-wallet":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-simple-keyring\\node_modules\\ethereumjs-wallet\\dist\\index.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-simple-keyring\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
const { EventEmitter } = require('events')
const Wallet = require('ethereumjs-wallet').default
const ethUtil = require('ethereumjs-util')

const type = 'Simple Key Pair'
const sigUtil = require('eth-sig-util')

class SimpleKeyring extends EventEmitter {

  constructor (opts) {
    super()
    this.type = type
    this.wallets = []
    this.deserialize(opts)
  }

  serialize () {
    return Promise.resolve(this.wallets.map((w) => w.getPrivateKey().toString('hex')))
  }

  deserialize (privateKeys = []) {
    return new Promise((resolve, reject) => {
      try {
        this.wallets = privateKeys.map((privateKey) => {
          const stripped = ethUtil.stripHexPrefix(privateKey)
          const buffer = Buffer.from(stripped, 'hex')
          const wallet = Wallet.fromPrivateKey(buffer)
          return wallet
        })
      } catch (e) {
        reject(e)
      }
      resolve()
    })
  }

  addAccounts (n = 1) {
    const newWallets = []
    for (let i = 0; i < n; i++) {
      newWallets.push(Wallet.generate())
    }
    this.wallets = this.wallets.concat(newWallets)
    const hexWallets = newWallets.map((w) => ethUtil.bufferToHex(w.getAddress()))
    return Promise.resolve(hexWallets)
  }

  getAccounts () {
    return Promise.resolve(this.wallets.map((w) => ethUtil.bufferToHex(w.getAddress())))
  }

  // tx is an instance of the ethereumjs-transaction class.
  signTransaction (address, tx, opts = {}) {
    const privKey = this.getPrivateKeyFor(address, opts)
    const signedTx = tx.sign(privKey)
    // Newer versions of Ethereumjs-tx are immutable and return a new tx object
    return Promise.resolve(signedTx === undefined ? tx : signedTx)
  }

  // For eth_sign, we need to sign arbitrary data:
  signMessage (address, data, opts = {}) {
    const message = ethUtil.stripHexPrefix(data)
    const privKey = this.getPrivateKeyFor(address, opts)
    const msgSig = ethUtil.ecsign(Buffer.from(message, 'hex'), privKey)
    const rawMsgSig = sigUtil.concatSig(msgSig.v, msgSig.r, msgSig.s)
    return Promise.resolve(rawMsgSig)
  }

  // For eth_sign, we need to sign transactions:
  newGethSignMessage (withAccount, msgHex, opts = {}) {
    const privKey = this.getPrivateKeyFor(withAccount, opts)
    const msgBuffer = ethUtil.toBuffer(msgHex)
    const msgHash = ethUtil.hashPersonalMessage(msgBuffer)
    const msgSig = ethUtil.ecsign(msgHash, privKey)
    const rawMsgSig = sigUtil.concatSig(msgSig.v, msgSig.r, msgSig.s)
    return Promise.resolve(rawMsgSig)
  }

  // For personal_sign, we need to prefix the message:
  signPersonalMessage (address, msgHex, opts = {}) {
    const privKey = this.getPrivateKeyFor(address, opts)
    const privKeyBuffer = Buffer.from(privKey, 'hex')
    const sig = sigUtil.personalSign(privKeyBuffer, { data: msgHex })
    return Promise.resolve(sig)
  }

  // For eth_decryptMessage:
  decryptMessage (withAccount, encryptedData) {
    const wallet = this._getWalletForAccount(withAccount)
    const privKey = ethUtil.stripHexPrefix(wallet.getPrivateKey())
    const sig = sigUtil.decrypt(encryptedData, privKey)
    return Promise.resolve(sig)
  }

  // personal_signTypedData, signs data along with the schema
  signTypedData (withAccount, typedData, opts = { version: 'V1' }) {
    switch (opts.version) {
      case 'V1':
        return this.signTypedData_v1(withAccount, typedData, opts)
      case 'V3':
        return this.signTypedData_v3(withAccount, typedData, opts)
      case 'V4':
        return this.signTypedData_v4(withAccount, typedData, opts)
      default:
        return this.signTypedData_v1(withAccount, typedData, opts)
    }
  }

  // personal_signTypedData, signs data along with the schema
  signTypedData_v1 (withAccount, typedData, opts = {}) {
    const privKey = this.getPrivateKeyFor(withAccount, opts)
    const sig = sigUtil.signTypedDataLegacy(privKey, { data: typedData })
    return Promise.resolve(sig)
  }

  // personal_signTypedData, signs data along with the schema
  signTypedData_v3 (withAccount, typedData, opts = {}) {
    const privKey = this.getPrivateKeyFor(withAccount, opts)
    const sig = sigUtil.signTypedData(privKey, { data: typedData })
    return Promise.resolve(sig)
  }

  // personal_signTypedData, signs data along with the schema
  signTypedData_v4 (withAccount, typedData, opts = {}) {
    const privKey = this.getPrivateKeyFor(withAccount, opts)
    const sig = sigUtil.signTypedData_v4(privKey, { data: typedData })
    return Promise.resolve(sig)
  }

  // get public key for nacl
  getEncryptionPublicKey (withAccount, opts = {}) {
    const privKey = this.getPrivateKeyFor(withAccount, opts)
    const publicKey = sigUtil.getEncryptionPublicKey(privKey)
    return Promise.resolve(publicKey)
  }

  getPrivateKeyFor (address, opts = {}) {
    if (!address) {
      throw new Error('Must specify address.')
    }
    const wallet = this._getWalletForAccount(address, opts)
    const privKey = ethUtil.toBuffer(wallet.getPrivateKey())
    return privKey
  }

  // returns an address specific to an app
  getAppKeyAddress (address, origin) {
    if (
      !origin ||
      typeof origin !== 'string'
    ) {
      throw new Error(`'origin' must be a non-empty string`)
    }
    return new Promise((resolve, reject) => {
      try {
        const wallet = this._getWalletForAccount(address, {
          withAppKeyOrigin: origin,
        })
        const appKeyAddress = sigUtil.normalize(wallet.getAddress().toString('hex'))
        return resolve(appKeyAddress)
      } catch (e) {
        return reject(e)
      }
    })
  }

  // exportAccount should return a hex-encoded private key:
  exportAccount (address, opts = {}) {
    const wallet = this._getWalletForAccount(address, opts)
    return Promise.resolve(wallet.getPrivateKey().toString('hex'))
  }

  removeAccount (address) {
    if (!this.wallets.map((w) => ethUtil.bufferToHex(w.getAddress()).toLowerCase()).includes(address.toLowerCase())) {
      throw new Error(`Address ${address} not found in this keyring`)
    }
    this.wallets = this.wallets.filter((w) => ethUtil.bufferToHex(w.getAddress()).toLowerCase() !== address.toLowerCase())
  }

  /**
   * @private
   */
  _getWalletForAccount (account, opts = {}) {
    const address = sigUtil.normalize(account)
    let wallet = this.wallets.find((w) => ethUtil.bufferToHex(w.getAddress()) === address)
    if (!wallet) {
      throw new Error('Simple Keyring - Unable to find matching address.')
    }

    if (opts.withAppKeyOrigin) {
      const privKey = wallet.getPrivateKey()
      const appKeyOriginBuffer = Buffer.from(opts.withAppKeyOrigin, 'utf8')
      const appKeyBuffer = Buffer.concat([privKey, appKeyOriginBuffer])
      const appKeyPrivKey = ethUtil.keccak(appKeyBuffer, 256)
      wallet = Wallet.fromPrivateKey(appKeyPrivKey)
    }

    return wallet
  }

}

SimpleKeyring.type = type
module.exports = SimpleKeyring

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"eth-simple-keyring",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-simple-keyring\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\BaseController.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\BaseController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseController = void 0;
/**
 * Controller class that provides configuration, state management, and subscriptions
 */
class BaseController {
    /**
     * Creates a BaseController instance. Both initial state and initial
     * configuration options are merged with defaults upon initialization.
     *
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor(config = {}, state = {}) {
        /**
         * Default options used to configure this controller
         */
        this.defaultConfig = {};
        /**
         * Default state set on this controller
         */
        this.defaultState = {};
        /**
         * Determines if listeners are notified of state changes
         */
        this.disabled = false;
        /**
         * Name of this controller used during composition
         */
        this.name = 'BaseController';
        this.internalConfig = this.defaultConfig;
        this.internalState = this.defaultState;
        this.internalListeners = [];
        // Use assign since generics can't be spread: https://git.io/vpRhY
        this.initialState = state;
        this.initialConfig = config;
    }
    /**
     * Enables the controller. This sets each config option as a member
     * variable on this instance and triggers any defined setters. This
     * also sets initial state and triggers any listeners.
     *
     * @returns This controller instance.
     */
    initialize() {
        this.internalState = this.defaultState;
        this.internalConfig = this.defaultConfig;
        this.configure(this.initialConfig);
        this.update(this.initialState);
        return this;
    }
    /**
     * Retrieves current controller configuration options.
     *
     * @returns The current configuration.
     */
    get config() {
        return this.internalConfig;
    }
    /**
     * Retrieves current controller state.
     *
     * @returns The current state.
     */
    get state() {
        return this.internalState;
    }
    /**
     * Updates controller configuration.
     *
     * @param config - New configuration options.
     * @param overwrite - Overwrite config instead of merging.
     * @param fullUpdate - Boolean that defines if the update is partial or not.
     */
    configure(config, overwrite = false, fullUpdate = true) {
        if (fullUpdate) {
            this.internalConfig = overwrite
                ? config
                : Object.assign(this.internalConfig, config);
            for (const key in this.internalConfig) {
                if (typeof this.internalConfig[key] !== 'undefined') {
                    this[key] = this.internalConfig[key];
                }
            }
        }
        else {
            for (const key in config) {
                /* istanbul ignore else */
                if (typeof this.internalConfig[key] !== 'undefined') {
                    this.internalConfig[key] = config[key];
                    this[key] = config[key];
                }
            }
        }
    }
    /**
     * Notifies all subscribed listeners of current state.
     */
    notify() {
        if (this.disabled) {
            return;
        }
        this.internalListeners.forEach((listener) => {
            listener(this.internalState);
        });
    }
    /**
     * Adds new listener to be notified of state changes.
     *
     * @param listener - The callback triggered when state changes.
     */
    subscribe(listener) {
        this.internalListeners.push(listener);
    }
    /**
     * Removes existing listener from receiving state changes.
     *
     * @param listener - The callback to remove.
     * @returns `true` if a listener is found and unsubscribed.
     */
    unsubscribe(listener) {
        const index = this.internalListeners.findIndex((cb) => listener === cb);
        index > -1 && this.internalListeners.splice(index, 1);
        return index > -1;
    }
    /**
     * Updates controller state.
     *
     * @param state - The new state.
     * @param overwrite - Overwrite state instead of merging.
     */
    update(state, overwrite = false) {
        this.internalState = overwrite
            ? Object.assign({}, state)
            : Object.assign({}, this.internalState, state);
        this.notify();
    }
}
exports.BaseController = BaseController;
exports.default = BaseController;
//# sourceMappingURL=BaseController.js.map
      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\BaseController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\ControllerMessenger.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\ControllerMessenger.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ControllerMessenger = exports.RestrictedControllerMessenger = void 0;
/**
 * A restricted controller messenger.
 *
 * This acts as a wrapper around the controller messenger instance that restricts access to actions
 * and events.
 *
 * @template N - The namespace for this messenger. Typically this is the name of the controller or
 * module that this messenger has been created for. The authority to publish events and register
 * actions under this namespace is granted to this restricted messenger instance.
 * @template Action - A type union of all Action types.
 * @template Event - A type union of all Event types.
 * @template AllowedAction - A type union of the 'type' string for any allowed actions.
 * @template AllowedEvent - A type union of the 'type' string for any allowed events.
 */
class RestrictedControllerMessenger {
    /**
     * Constructs a restricted controller messenger
     *
     * The provided allowlists grant the ability to call the listed actions and subscribe to the
     * listed events. The "name" provided grants ownership of any actions and events under that
     * namespace. Ownership allows registering actions and publishing events, as well as
     * unregistering actions and clearing event subscriptions.
     *
     * @param options - The controller options.
     * @param options.controllerMessenger - The controller messenger instance that is being wrapped.
     * @param options.name - The name of the thing this messenger will be handed to (e.g. the
     * controller name). This grants "ownership" of actions and events under this namespace to the
     * restricted controller messenger returned.
     * @param options.allowedActions - The list of actions that this restricted controller messenger
     * should be alowed to call.
     * @param options.allowedEvents - The list of events that this restricted controller messenger
     * should be allowed to subscribe to.
     */
    constructor({ controllerMessenger, name, allowedActions, allowedEvents, }) {
        this.controllerMessenger = controllerMessenger;
        this.controllerName = name;
        this.allowedActions = allowedActions || null;
        this.allowedEvents = allowedEvents || null;
    }
    /**
     * Register an action handler.
     *
     * This will make the registered function available to call via the `call` method.
     *
     * The action type this handler is registered under *must* be in the current namespace.
     *
     * @param action - The action type. This is a unqiue identifier for this action.
     * @param handler - The action handler. This function gets called when the `call` method is
     * invoked with the given action type.
     * @throws Will throw when a handler has been registered for this action type already.
     * @template T - A type union of Action type strings that are namespaced by N.
     */
    registerActionHandler(action, handler) {
        /* istanbul ignore if */ // Branch unreachable with valid types
        if (!action.startsWith(`${this.controllerName}:`)) {
            throw new Error(`Only allowed registering action handlers prefixed by '${this.controllerName}:'`);
        }
        this.controllerMessenger.registerActionHandler(action, handler);
    }
    /**
     * Unregister an action handler.
     *
     * This will prevent this action from being called.
     *
     * The action type being unregistered *must* be in the current namespace.
     *
     * @param action - The action type. This is a unqiue identifier for this action.
     * @template T - A type union of Action type strings that are namespaced by N.
     */
    unregisterActionHandler(action) {
        /* istanbul ignore if */ // Branch unreachable with valid types
        if (!action.startsWith(`${this.controllerName}:`)) {
            throw new Error(`Only allowed unregistering action handlers prefixed by '${this.controllerName}:'`);
        }
        this.controllerMessenger.unregisterActionHandler(action);
    }
    /**
     * Call an action.
     *
     * This function will call the action handler corresponding to the given action type, passing
     * along any parameters given.
     *
     * The action type being called must be on the action allowlist.
     *
     * @param action - The action type. This is a unqiue identifier for this action.
     * @param params - The action parameters. These must match the type of the parameters of the
     * registered action handler.
     * @throws Will throw when no handler has been registered for the given type.
     * @template T - A type union of allowed Action type strings.
     * @returns The action return value.
     */
    call(action, ...params) {
        /* istanbul ignore next */ // Branches unreachable with valid types
        if (this.allowedActions === null) {
            throw new Error('No actions allowed');
        }
        else if (!this.allowedActions.includes(action)) {
            throw new Error(`Action missing from allow list: ${action}`);
        }
        return this.controllerMessenger.call(action, ...params);
    }
    /**
     * Publish an event.
     *
     * Publishes the given payload to all subscribers of the given event type.
     *
     * The event type being published *must* be in the current namespace.
     *
     * @param event - The event type. This is a unique identifier for this event.
     * @param payload - The event payload. The type of the parameters for each event handler must
     * match the type of this payload.
     * @template E - A type union of Event type strings that are namespaced by N.
     */
    publish(event, ...payload) {
        /* istanbul ignore if */ // Branch unreachable with valid types
        if (!event.startsWith(`${this.controllerName}:`)) {
            throw new Error(`Only allowed publishing events prefixed by '${this.controllerName}:'`);
        }
        this.controllerMessenger.publish(event, ...payload);
    }
    subscribe(event, handler, selector) {
        /* istanbul ignore next */ // Branches unreachable with valid types
        if (this.allowedEvents === null) {
            throw new Error('No events allowed');
        }
        else if (!this.allowedEvents.includes(event)) {
            throw new Error(`Event missing from allow list: ${event}`);
        }
        if (selector) {
            return this.controllerMessenger.subscribe(event, handler, selector);
        }
        return this.controllerMessenger.subscribe(event, handler);
    }
    /**
     * Unsubscribe from an event.
     *
     * Unregisters the given function as an event handler for the given event.
     *
     * The event type being unsubscribed to must be on the event allowlist.
     *
     * @param event - The event type. This is a unique identifier for this event.
     * @param handler - The event handler to unregister.
     * @throws Will throw when the given event handler is not registered for this event.
     * @template T - A type union of allowed Event type strings.
     */
    unsubscribe(event, handler) {
        /* istanbul ignore next */ // Branches unreachable with valid types
        if (this.allowedEvents === null) {
            throw new Error('No events allowed');
        }
        else if (!this.allowedEvents.includes(event)) {
            throw new Error(`Event missing from allow list: ${event}`);
        }
        this.controllerMessenger.unsubscribe(event, handler);
    }
    /**
     * Clear subscriptions for a specific event.
     *
     * This will remove all subscribed handlers for this event.
     *
     * The event type being cleared *must* be in the current namespace.
     *
     * @param event - The event type. This is a unique identifier for this event.
     * @template E - A type union of Event type strings that are namespaced by N.
     */
    clearEventSubscriptions(event) {
        /* istanbul ignore if */ // Branch unreachable with valid types
        if (!event.startsWith(`${this.controllerName}:`)) {
            throw new Error(`Only allowed clearing events prefixed by '${this.controllerName}:'`);
        }
        this.controllerMessenger.clearEventSubscriptions(event);
    }
}
exports.RestrictedControllerMessenger = RestrictedControllerMessenger;
/**
 * A messaging system for controllers.
 *
 * The controller messenger allows registering functions as 'actions' that can be called elsewhere,
 * and it allows publishing and subscribing to events. Both actions and events are identified by
 * unique strings.
 *
 * @template Action - A type union of all Action types.
 * @template Event - A type union of all Event types.
 */
class ControllerMessenger {
    constructor() {
        this.actions = new Map();
        this.events = new Map();
        /**
         * A cache of selector return values for their respective handlers.
         */
        this.eventPayloadCache = new Map();
    }
    /**
     * Register an action handler.
     *
     * This will make the registered function available to call via the `call` method.
     *
     * @param actionType - The action type. This is a unqiue identifier for this action.
     * @param handler - The action handler. This function gets called when the `call` method is
     * invoked with the given action type.
     * @throws Will throw when a handler has been registered for this action type already.
     * @template T - A type union of Action type strings.
     */
    registerActionHandler(actionType, handler) {
        if (this.actions.has(actionType)) {
            throw new Error(`A handler for ${actionType} has already been registered`);
        }
        this.actions.set(actionType, handler);
    }
    /**
     * Unregister an action handler.
     *
     * This will prevent this action from being called.
     *
     * @param actionType - The action type. This is a unqiue identifier for this action.
     * @template T - A type union of Action type strings.
     */
    unregisterActionHandler(actionType) {
        this.actions.delete(actionType);
    }
    /**
     * Unregister all action handlers.
     *
     * This prevents all actions from being called.
     */
    clearActions() {
        this.actions.clear();
    }
    /**
     * Call an action.
     *
     * This function will call the action handler corresponding to the given action type, passing
     * along any parameters given.
     *
     * @param actionType - The action type. This is a unqiue identifier for this action.
     * @param params - The action parameters. These must match the type of the parameters of the
     * registered action handler.
     * @throws Will throw when no handler has been registered for the given type.
     * @template T - A type union of Action type strings.
     * @returns The action return value.
     */
    call(actionType, ...params) {
        const handler = this.actions.get(actionType);
        if (!handler) {
            throw new Error(`A handler for ${actionType} has not been registered`);
        }
        return handler(...params);
    }
    /**
     * Publish an event.
     *
     * Publishes the given payload to all subscribers of the given event type.
     *
     * @param eventType - The event type. This is a unique identifier for this event.
     * @param payload - The event payload. The type of the parameters for each event handler must
     * match the type of this payload.
     * @template E - A type union of Event type strings.
     */
    publish(eventType, ...payload) {
        const subscribers = this.events.get(eventType);
        if (subscribers) {
            for (const [handler, selector] of subscribers.entries()) {
                if (selector) {
                    const previousValue = this.eventPayloadCache.get(handler);
                    const newValue = selector(...payload);
                    if (newValue !== previousValue) {
                        this.eventPayloadCache.set(handler, newValue);
                        handler(newValue, previousValue);
                    }
                }
                else {
                    handler(...payload);
                }
            }
        }
    }
    subscribe(eventType, handler, selector) {
        let subscribers = this.events.get(eventType);
        if (!subscribers) {
            subscribers = new Map();
            this.events.set(eventType, subscribers);
        }
        subscribers.set(handler, selector);
    }
    /**
     * Unsubscribe from an event.
     *
     * Unregisters the given function as an event handler for the given event.
     *
     * @param eventType - The event type. This is a unique identifier for this event.
     * @param handler - The event handler to unregister.
     * @throws Will throw when the given event handler is not registered for this event.
     * @template E - A type union of Event type strings.
     */
    unsubscribe(eventType, handler) {
        const subscribers = this.events.get(eventType);
        if (!subscribers || !subscribers.has(handler)) {
            throw new Error(`Subscription not found for event: ${eventType}`);
        }
        const selector = subscribers.get(handler);
        if (selector) {
            this.eventPayloadCache.delete(handler);
        }
        subscribers.delete(handler);
    }
    /**
     * Clear subscriptions for a specific event.
     *
     * This will remove all subscribed handlers for this event.
     *
     * @param eventType - The event type. This is a unique identifier for this event.
     * @template E - A type union of Event type strings.
     */
    clearEventSubscriptions(eventType) {
        this.events.delete(eventType);
    }
    /**
     * Clear all subscriptions.
     *
     * This will remove all subscribed handlers for all events.
     */
    clearSubscriptions() {
        this.events.clear();
    }
    /**
     * Get a restricted controller messenger
     *
     * Returns a wrapper around the controller messenger instance that restricts access to actions
     * and events. The provided allowlists grant the ability to call the listed actions and subscribe
     * to the listed events. The "name" provided grants ownership of any actions and events under
     * that namespace. Ownership allows registering actions and publishing events, as well as
     * unregistering actions and clearing event subscriptions.
     *
     * @param options - Controller messenger options.
     * @param options.name - The name of the thing this messenger will be handed to (e.g. the
     * controller name). This grants "ownership" of actions and events under this namespace to the
     * restricted controller messenger returned.
     * @param options.allowedActions - The list of actions that this restricted controller messenger
     * should be alowed to call.
     * @param options.allowedEvents - The list of events that this restricted controller messenger
     * should be allowed to subscribe to.
     * @template N - The namespace for this messenger. Typically this is the name of the controller or
     * module that this messenger has been created for. The authority to publish events and register
     * actions under this namespace is granted to this restricted messenger instance.
     * @template AllowedAction - A type union of the 'type' string for any allowed actions.
     * @template AllowedEvent - A type union of the 'type' string for any allowed events.
     * @returns The restricted controller messenger.
     */
    getRestricted({ name, allowedActions, allowedEvents, }) {
        return new RestrictedControllerMessenger({
            controllerMessenger: this,
            name,
            allowedActions,
            allowedEvents,
        });
    }
}
exports.ControllerMessenger = ControllerMessenger;
//# sourceMappingURL=ControllerMessenger.js.map
      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\ControllerMessenger.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\ComposableController.js", {"./BaseController":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\BaseController.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\ComposableController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComposableController = void 0;
const BaseController_1 = require("./BaseController");
/**
 * Controller that can be used to compose multiple controllers together
 */
class ComposableController extends BaseController_1.BaseController {
    /**
     * Creates a ComposableController instance.
     *
     * @param controllers - Map of names to controller instances.
     * @param messenger - The controller messaging system, used for communicating with BaseControllerV2 controllers.
     */
    constructor(controllers, messenger) {
        super(undefined, controllers.reduce((state, controller) => {
            state[controller.name] = controller.state;
            return state;
        }, {}));
        this.controllers = [];
        /**
         * Name of this controller used during composition
         */
        this.name = 'ComposableController';
        this.initialize();
        this.controllers = controllers;
        this.messagingSystem = messenger;
        this.controllers.forEach((controller) => {
            const { name } = controller;
            if (controller.subscribe !== undefined) {
                controller.subscribe((state) => {
                    this.update({ [name]: state });
                });
            }
            else if (this.messagingSystem) {
                this.messagingSystem.subscribe(`${name}:stateChange`, (state) => {
                    this.update({ [name]: state });
                });
            }
            else {
                throw new Error(`Messaging system required if any BaseControllerV2 controllers are used`);
            }
        });
    }
    /**
     * Flat state representation, one that isn't keyed
     * of controller name. Instead, all child controller state is merged
     * together into a single, flat object.
     *
     * @returns Merged state representation of all child controllers.
     */
    get flatState() {
        let flatState = {};
        for (const controller of this.controllers) {
            flatState = Object.assign(Object.assign({}, flatState), controller.state);
        }
        return flatState;
    }
}
exports.ComposableController = ComposableController;
exports.default = ComposableController;
//# sourceMappingURL=ComposableController.js.map
      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\ComposableController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\user\\AddressBookController.js", {"../BaseController":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\user\AddressBookController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressBookController = void 0;
const util_1 = require("../util");
const BaseController_1 = require("../BaseController");
/**
 * Controller that manages a list of recipient addresses associated with nicknames
 */
class AddressBookController extends BaseController_1.BaseController {
    /**
     * Creates an AddressBookController instance.
     *
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor(config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'AddressBookController';
        this.defaultState = { addressBook: {} };
        this.initialize();
    }
    /**
     * Remove all contract entries.
     */
    clear() {
        this.update({ addressBook: {} });
    }
    /**
     * Remove a contract entry by address.
     *
     * @param chainId - Chain id identifies the current chain.
     * @param address - Recipient address to delete.
     * @returns Whether the entry was deleted.
     */
    delete(chainId, address) {
        address = util_1.toChecksumHexAddress(address);
        if (!util_1.isValidHexAddress(address) ||
            !this.state.addressBook[chainId] ||
            !this.state.addressBook[chainId][address]) {
            return false;
        }
        const addressBook = Object.assign({}, this.state.addressBook);
        delete addressBook[chainId][address];
        if (Object.keys(addressBook[chainId]).length === 0) {
            delete addressBook[chainId];
        }
        this.update({ addressBook });
        return true;
    }
    /**
     * Add or update a contact entry by address.
     *
     * @param address - Recipient address to add or update.
     * @param name - Nickname to associate with this address.
     * @param chainId - Chain id identifies the current chain.
     * @param memo - User's note about address.
     * @returns Boolean indicating if the address was successfully set.
     */
    set(address, name, chainId = '1', memo = '') {
        address = util_1.toChecksumHexAddress(address);
        if (!util_1.isValidHexAddress(address)) {
            return false;
        }
        const entry = {
            address,
            chainId,
            isEns: false,
            memo,
            name,
        };
        const ensName = util_1.normalizeEnsName(name);
        if (ensName) {
            entry.name = ensName;
            entry.isEns = true;
        }
        this.update({
            addressBook: Object.assign(Object.assign({}, this.state.addressBook), { [chainId]: Object.assign(Object.assign({}, this.state.addressBook[chainId]), { [address]: entry }) }),
        });
        return true;
    }
}
exports.AddressBookController = AddressBookController;
exports.default = AddressBookController;
//# sourceMappingURL=AddressBookController.js.map
      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\user\\AddressBookController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\user\\PreferencesController.js", {"../BaseController":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\user\PreferencesController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PreferencesController = void 0;
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
/**
 * Controller that stores shared settings and exposes convenience methods
 */
class PreferencesController extends BaseController_1.BaseController {
    /**
     * Creates a PreferencesController instance.
     *
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor(config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'PreferencesController';
        this.defaultState = {
            featureFlags: {},
            frequentRpcList: [],
            identities: {},
            ipfsGateway: 'https://ipfs.io/ipfs/',
            lostIdentities: {},
            selectedAddress: '',
            useStaticTokenList: false,
            useCollectibleDetection: false,
            openSeaEnabled: false,
        };
        this.initialize();
    }
    /**
     * Adds identities to state.
     *
     * @param addresses - List of addresses to use to generate new identities.
     */
    addIdentities(addresses) {
        const { identities } = this.state;
        addresses.forEach((address) => {
            address = util_1.toChecksumHexAddress(address);
            if (identities[address]) {
                return;
            }
            const identityCount = Object.keys(identities).length;
            identities[address] = {
                name: `Account ${identityCount + 1}`,
                address,
                importTime: Date.now(),
            };
        });
        this.update({ identities: Object.assign({}, identities) });
    }
    /**
     * Removes an identity from state.
     *
     * @param address - Address of the identity to remove.
     */
    removeIdentity(address) {
        address = util_1.toChecksumHexAddress(address);
        const { identities } = this.state;
        if (!identities[address]) {
            return;
        }
        delete identities[address];
        this.update({ identities: Object.assign({}, identities) });
        if (address === this.state.selectedAddress) {
            this.update({ selectedAddress: Object.keys(identities)[0] });
        }
    }
    /**
     * Associates a new label with an identity.
     *
     * @param address - Address of the identity to associate.
     * @param label - New label to assign.
     */
    setAccountLabel(address, label) {
        address = util_1.toChecksumHexAddress(address);
        const { identities } = this.state;
        identities[address] = identities[address] || {};
        identities[address].name = label;
        this.update({ identities: Object.assign({}, identities) });
    }
    /**
     * Enable or disable a specific feature flag.
     *
     * @param feature - Feature to toggle.
     * @param activated - Value to assign.
     */
    setFeatureFlag(feature, activated) {
        const oldFeatureFlags = this.state.featureFlags;
        const featureFlags = Object.assign(Object.assign({}, oldFeatureFlags), { [feature]: activated });
        this.update({ featureFlags: Object.assign({}, featureFlags) });
    }
    /**
     * Synchronizes the current identity list with new identities.
     *
     * @param addresses - List of addresses corresponding to identities to sync.
     * @returns Newly-selected address after syncing.
     */
    syncIdentities(addresses) {
        addresses = addresses.map((address) => util_1.toChecksumHexAddress(address));
        const { identities, lostIdentities } = this.state;
        const newlyLost = {};
        for (const identity in identities) {
            if (addresses.indexOf(identity) === -1) {
                newlyLost[identity] = identities[identity];
                delete identities[identity];
            }
        }
        if (Object.keys(newlyLost).length > 0) {
            for (const key in newlyLost) {
                lostIdentities[key] = newlyLost[key];
            }
        }
        this.update({
            identities: Object.assign({}, identities),
            lostIdentities: Object.assign({}, lostIdentities),
        });
        this.addIdentities(addresses);
        if (addresses.indexOf(this.state.selectedAddress) === -1) {
            this.update({ selectedAddress: addresses[0] });
        }
        return this.state.selectedAddress;
    }
    /**
     * Generates and stores a new list of stored identities based on address. If the selected address
     * is unset, or if it refers to an identity that was removed, it will be set to the first
     * identity.
     *
     * @param addresses - List of addresses to use as a basis for each identity.
     */
    updateIdentities(addresses) {
        addresses = addresses.map((address) => util_1.toChecksumHexAddress(address));
        const oldIdentities = this.state.identities;
        const identities = addresses.reduce((ids, address, index) => {
            ids[address] = oldIdentities[address] || {
                address,
                name: `Account ${index + 1}`,
                importTime: Date.now(),
            };
            return ids;
        }, {});
        let { selectedAddress } = this.state;
        if (!Object.keys(identities).includes(selectedAddress)) {
            selectedAddress = Object.keys(identities)[0];
        }
        this.update({ identities: Object.assign({}, identities), selectedAddress });
    }
    /**
     * Adds custom RPC URL to state.
     *
     * @param url - The custom RPC URL.
     * @param chainId - The chain ID of the network, as per EIP-155.
     * @param ticker - Currency ticker.
     * @param nickname - Personalized network name.
     * @param rpcPrefs - Personalized preferences.
     */
    addToFrequentRpcList(url, chainId, ticker, nickname, rpcPrefs) {
        const { frequentRpcList } = this.state;
        const index = frequentRpcList.findIndex(({ rpcUrl }) => {
            return rpcUrl === url;
        });
        if (index !== -1) {
            frequentRpcList.splice(index, 1);
        }
        const newFrequestRpc = {
            rpcUrl: url,
            chainId,
            ticker,
            nickname,
            rpcPrefs,
        };
        frequentRpcList.push(newFrequestRpc);
        this.update({ frequentRpcList: [...frequentRpcList] });
    }
    /**
     * Removes custom RPC URL from state.
     *
     * @param url - Custom RPC URL.
     */
    removeFromFrequentRpcList(url) {
        const { frequentRpcList } = this.state;
        const index = frequentRpcList.findIndex(({ rpcUrl }) => {
            return rpcUrl === url;
        });
        if (index !== -1) {
            frequentRpcList.splice(index, 1);
        }
        this.update({ frequentRpcList: [...frequentRpcList] });
    }
    /**
     * Sets selected address.
     *
     * @param selectedAddress - Ethereum address.
     */
    setSelectedAddress(selectedAddress) {
        this.update({ selectedAddress: util_1.toChecksumHexAddress(selectedAddress) });
    }
    /**
     * Sets new IPFS gateway.
     *
     * @param ipfsGateway - IPFS gateway string.
     */
    setIpfsGateway(ipfsGateway) {
        this.update({ ipfsGateway });
    }
    /**
     * Toggle the token detection setting to use dynamic token list.
     *
     * @param useStaticTokenList - Boolean indicating user preference on token detection.
     */
    setUseStaticTokenList(useStaticTokenList) {
        this.update({ useStaticTokenList });
    }
    /**
     * Toggle the collectible detection setting.
     *
     * @param useCollectibleDetection - Boolean indicating user preference on collectible detection.
     */
    setUseCollectibleDetection(useCollectibleDetection) {
        if (useCollectibleDetection && !this.state.openSeaEnabled) {
            throw new Error('useCollectibleDetection cannot be enabled if openSeaEnabled is false');
        }
        this.update({ useCollectibleDetection });
    }
    /**
     * Toggle the opensea enabled setting.
     *
     * @param openSeaEnabled - Boolean indicating user preference on using OpenSea's API.
     */
    setOpenSeaEnabled(openSeaEnabled) {
        this.update({ openSeaEnabled });
        if (!openSeaEnabled) {
            this.update({ useCollectibleDetection: false });
        }
    }
}
exports.PreferencesController = PreferencesController;
exports.default = PreferencesController;
//# sourceMappingURL=PreferencesController.js.map
      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\user\\PreferencesController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\notification\\NotificationController.js", {"../BaseController":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\BaseController.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\notification\NotificationController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NotificationController = void 0;
const BaseController_1 = require("../BaseController");
const defaultState = {
    notifications: {},
};
/**
 * Controller for managing in-app announcement notifications.
 */
class NotificationController extends BaseController_1.BaseController {
    /**
     * Creates a NotificationController instance.
     *
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor(config, state) {
        super(config, state || defaultState);
        this.initialize();
        this._addNotifications();
    }
    /**
     * Compares the notifications in state with the notifications from file
     * to check if there are any new notifications/announcements
     * if yes, the new notification will be added to the state with a flag indicating
     * that the notification is not seen by the user.
     */
    _addNotifications() {
        const newNotifications = {};
        const { allNotifications } = this.config;
        Object.values(allNotifications).forEach((notification) => {
            newNotifications[notification.id] = this.state.notifications[notification.id]
                ? this.state.notifications[notification.id]
                : Object.assign(Object.assign({}, notification), { isShown: false });
        });
        this.update({ notifications: newNotifications });
    }
    /**
     * Updates the status of the status of the specified notifications
     * once it is read by the user.
     *
     * @param viewedIds - The notification IDs to mark as viewed.
     */
    updateViewed(viewedIds) {
        const stateNotifications = this.state.notifications;
        for (const id of Object.keys(viewedIds).map(Number)) {
            stateNotifications[id].isShown = viewedIds[id];
        }
        this.update({ notifications: stateNotifications }, true);
    }
}
exports.NotificationController = NotificationController;
//# sourceMappingURL=NotificationController.js.map
      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\notification\\NotificationController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\assets\\TokenDetectionController.js", {"../BaseController":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\constants.js","../util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\assets\TokenDetectionController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenDetectionController = void 0;
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const constants_1 = require("../constants");
const DEFAULT_INTERVAL = 180000;
/**
 * Controller that passively polls on a set interval for Tokens auto detection
 */
class TokenDetectionController extends BaseController_1.BaseController {
    /**
     * Creates a TokenDetectionController instance.
     *
     * @param options - The controller options.
     * @param options.onTokensStateChange - Allows subscribing to tokens controller state changes.
     * @param options.onPreferencesStateChange - Allows subscribing to preferences controller state changes.
     * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
     * @param options.getBalancesInSingleCall - Gets the balances of a list of tokens for the given address.
     * @param options.addTokens - Add a list of tokens.
     * @param options.getTokenListState - Gets the current state of the TokenList controller.
     * @param options.getTokensState - Gets the current state of the Tokens controller.
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor({ onTokensStateChange, onPreferencesStateChange, onNetworkStateChange, getBalancesInSingleCall, addTokens, getTokenListState, getTokensState, }, config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'TokenDetectionController';
        /**
         * Checks whether network is mainnet or not.
         *
         * @returns Whether current network is mainnet.
         */
        this.isMainnet = () => this.config.networkType === constants_1.MAINNET;
        this.defaultConfig = {
            interval: DEFAULT_INTERVAL,
            networkType: constants_1.MAINNET,
            selectedAddress: '',
            tokens: [],
        };
        this.initialize();
        this.getTokensState = getTokensState;
        this.getTokenListState = getTokenListState;
        this.addTokens = addTokens;
        onTokensStateChange(({ tokens }) => {
            this.configure({ tokens });
        });
        onPreferencesStateChange(({ selectedAddress }) => {
            const actualSelectedAddress = this.config.selectedAddress;
            if (selectedAddress !== actualSelectedAddress) {
                this.configure({ selectedAddress });
                this.detectTokens();
            }
        });
        onNetworkStateChange(({ provider }) => {
            this.configure({ networkType: provider.type });
        });
        this.getBalancesInSingleCall = getBalancesInSingleCall;
    }
    /**
     * Start polling for the currency rate.
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isMainnet() || this.disabled) {
                return;
            }
            yield this.startPolling();
        });
    }
    /**
     * Stop polling for the currency rate.
     */
    stop() {
        this.stopPolling();
    }
    stopPolling() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
    }
    /**
     * Starts a new polling interval.
     *
     * @param interval - An interval on which to poll.
     */
    startPolling(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.stopPolling();
            yield this.detectTokens();
            this.intervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                yield this.detectTokens();
            }), this.config.interval);
        });
    }
    /**
     * Triggers asset ERC20 token auto detection for each contract address in contract metadata on mainnet.
     */
    detectTokens() {
        return __awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore if */
            if (!this.isMainnet() || this.disabled) {
                return;
            }
            const tokensAddresses = this.config.tokens.map(
            /* istanbul ignore next*/ (token) => token.address.toLowerCase());
            const { tokenList } = this.getTokenListState();
            const tokensToDetect = [];
            for (const address in tokenList) {
                if (!tokensAddresses.includes(address)) {
                    tokensToDetect.push(address);
                }
            }
            const sliceOfTokensToDetect = [];
            sliceOfTokensToDetect[0] = tokensToDetect.slice(0, 1000);
            sliceOfTokensToDetect[1] = tokensToDetect.slice(1000, tokensToDetect.length - 1);
            const { selectedAddress } = this.config;
            /* istanbul ignore else */
            if (!selectedAddress) {
                return;
            }
            for (const tokensSlice of sliceOfTokensToDetect) {
                if (tokensSlice.length === 0) {
                    break;
                }
                yield util_1.safelyExecute(() => __awaiter(this, void 0, void 0, function* () {
                    const balances = yield this.getBalancesInSingleCall(selectedAddress, tokensSlice);
                    const tokensToAdd = [];
                    for (const tokenAddress in balances) {
                        let ignored;
                        /* istanbul ignore else */
                        const { ignoredTokens } = this.getTokensState();
                        if (ignoredTokens.length) {
                            ignored = ignoredTokens.find((ignoredTokenAddress) => ignoredTokenAddress === util_1.toChecksumHexAddress(tokenAddress));
                        }
                        const caseInsensitiveTokenKey = Object.keys(tokenList).find((i) => i.toLowerCase() === tokenAddress.toLowerCase()) || '';
                        if (ignored === undefined) {
                            tokensToAdd.push({
                                address: tokenAddress,
                                decimals: tokenList[caseInsensitiveTokenKey].decimals,
                                symbol: tokenList[caseInsensitiveTokenKey].symbol,
                            });
                        }
                    }
                    if (tokensToAdd.length) {
                        yield this.addTokens(tokensToAdd);
                    }
                }));
            }
        });
    }
}
exports.TokenDetectionController = TokenDetectionController;
exports.default = TokenDetectionController;
//# sourceMappingURL=TokenDetectionController.js.map
      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\assets\\TokenDetectionController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\assets\\CollectibleDetectionController.js", {"../BaseController":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\constants.js","../util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\assets\CollectibleDetectionController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollectibleDetectionController = void 0;
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const constants_1 = require("../constants");
const DEFAULT_INTERVAL = 180000;
/**
 * Controller that passively polls on a set interval for Collectibles auto detection
 */
class CollectibleDetectionController extends BaseController_1.BaseController {
    /**
     * Creates a CollectibleDetectionController instance.
     *
     * @param options - The controller options.
     * @param options.onCollectiblesStateChange - Allows subscribing to assets controller state changes.
     * @param options.onPreferencesStateChange - Allows subscribing to preferences controller state changes.
     * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
     * @param options.getOpenSeaApiKey - Gets the OpenSea API key, if one is set.
     * @param options.addCollectible - Add a collectible.
     * @param options.getCollectiblesState - Gets the current state of the Assets controller.
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor({ onPreferencesStateChange, onNetworkStateChange, getOpenSeaApiKey, addCollectible, getCollectiblesState, }, config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'CollectibleDetectionController';
        /**
         * Checks whether network is mainnet or not.
         *
         * @returns Whether current network is mainnet.
         */
        this.isMainnet = () => this.config.networkType === constants_1.MAINNET;
        this.defaultConfig = {
            interval: DEFAULT_INTERVAL,
            networkType: constants_1.MAINNET,
            chainId: '1',
            selectedAddress: '',
            disabled: true,
        };
        this.initialize();
        this.getCollectiblesState = getCollectiblesState;
        onPreferencesStateChange(({ selectedAddress, useCollectibleDetection }) => {
            const { selectedAddress: previouslySelectedAddress, disabled, } = this.config;
            if (selectedAddress !== previouslySelectedAddress ||
                !useCollectibleDetection !== disabled) {
                this.configure({ selectedAddress, disabled: !useCollectibleDetection });
            }
            if (useCollectibleDetection !== undefined) {
                if (useCollectibleDetection) {
                    this.start();
                }
                else {
                    this.stop();
                }
            }
        });
        onNetworkStateChange(({ provider }) => {
            this.configure({
                networkType: provider.type,
                chainId: provider.chainId,
            });
        });
        this.getOpenSeaApiKey = getOpenSeaApiKey;
        this.addCollectible = addCollectible;
    }
    getOwnerCollectiblesApi(address, offset) {
        return `https://api.opensea.io/api/v1/assets?owner=${address}&offset=${offset}&limit=50`;
    }
    getOwnerCollectibles(address) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let response;
            let collectibles = [];
            const openSeaApiKey = this.getOpenSeaApiKey();
            try {
                let offset = 0;
                let pagingFinish = false;
                /* istanbul ignore if */
                do {
                    const api = this.getOwnerCollectiblesApi(address, offset);
                    response = yield util_1.timeoutFetch(api, openSeaApiKey ? { headers: { 'X-API-KEY': openSeaApiKey } } : {}, 15000);
                    const collectiblesArray = yield response.json();
                    ((_a = collectiblesArray.assets) === null || _a === void 0 ? void 0 : _a.length) !== 0
                        ? (collectibles = [...collectibles, ...collectiblesArray.assets])
                        : (pagingFinish = true);
                    offset += 50;
                } while (!pagingFinish);
            }
            catch (e) {
                /* istanbul ignore next */
                return [];
            }
            return collectibles;
        });
    }
    /**
     * Start polling for the currency rate.
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isMainnet() || this.disabled) {
                return;
            }
            yield this.startPolling();
        });
    }
    /**
     * Stop polling for the currency rate.
     */
    stop() {
        this.stopPolling();
    }
    stopPolling() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
    }
    /**
     * Starts a new polling interval.
     *
     * @param interval - An interval on which to poll.
     */
    startPolling(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.stopPolling();
            yield this.detectCollectibles();
            this.intervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                yield this.detectCollectibles();
            }), this.config.interval);
        });
    }
    /**
     * Triggers asset ERC721 token auto detection on mainnet. Any newly detected collectibles are
     * added.
     */
    detectCollectibles() {
        return __awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore if */
            if (!this.isMainnet() || this.disabled) {
                return;
            }
            const { selectedAddress, chainId } = this.config;
            /* istanbul ignore else */
            if (!selectedAddress) {
                return;
            }
            yield util_1.safelyExecute(() => __awaiter(this, void 0, void 0, function* () {
                const apiCollectibles = yield this.getOwnerCollectibles(selectedAddress);
                const addCollectiblesPromises = apiCollectibles.map((collectible) => __awaiter(this, void 0, void 0, function* () {
                    const { token_id, num_sales, background_color, image_url, image_preview_url, image_thumbnail_url, image_original_url, animation_url, animation_original_url, name, description, external_link, creator, asset_contract: { address, schema_name }, last_sale, } = collectible;
                    let ignored;
                    /* istanbul ignore else */
                    const { ignoredCollectibles } = this.getCollectiblesState();
                    if (ignoredCollectibles.length) {
                        ignored = ignoredCollectibles.find((c) => {
                            /* istanbul ignore next */
                            return (c.address === util_1.toChecksumHexAddress(address) &&
                                c.tokenId === token_id);
                        });
                    }
                    /* istanbul ignore else */
                    if (!ignored) {
                        /* istanbul ignore next */
                        const collectibleMetadata = Object.assign({}, { name }, creator && { creator }, description && { description }, image_url && { image: image_url }, num_sales && { numberOfSales: num_sales }, background_color && { backgroundColor: background_color }, image_preview_url && { imagePreview: image_preview_url }, image_thumbnail_url && { imageThumbnail: image_thumbnail_url }, image_original_url && { imageOriginal: image_original_url }, animation_url && { animation: animation_url }, animation_original_url && {
                            animationOriginal: animation_original_url,
                        }, schema_name && { standard: schema_name }, external_link && { externalLink: external_link }, last_sale && { lastSale: last_sale });
                        yield this.addCollectible(address, token_id, collectibleMetadata, {
                            userAddress: selectedAddress,
                            chainId: chainId,
                        });
                    }
                }));
                yield Promise.all(addCollectiblesPromises);
            }));
        });
    }
}
exports.CollectibleDetectionController = CollectibleDetectionController;
exports.default = CollectibleDetectionController;
//# sourceMappingURL=CollectibleDetectionController.js.map
      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\assets\\CollectibleDetectionController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\assets\\TokenRatesController.js", {"../BaseController":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../apis/crypto-compare":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\apis\\crypto-compare.js","../constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\constants.js","../util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\assets\TokenRatesController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenRatesController = void 0;
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const constants_1 = require("../constants");
const crypto_compare_1 = require("../apis/crypto-compare");
const CoinGeckoApi = {
    BASE_URL: 'https://api.coingecko.com/api/v3',
    getTokenPriceURL(chainSlug, query) {
        return `${this.BASE_URL}/simple/token_price/${chainSlug}?${query}`;
    },
    getPlatformsURL() {
        return `${this.BASE_URL}/asset_platforms`;
    },
    getSupportedVsCurrencies() {
        return `${this.BASE_URL}/simple/supported_vs_currencies`;
    },
};
/**
 * Finds the chain slug in the data array given a chainId.
 *
 * @param chainId - The current chain ID.
 * @param data - A list platforms supported by the CoinGecko API.
 * @returns The CoinGecko slug for the given chain ID, or `null` if the slug was not found.
 */
function findChainSlug(chainId, data) {
    var _a;
    if (!data) {
        return null;
    }
    const chain = (_a = data.find(({ chain_identifier }) => chain_identifier !== null && String(chain_identifier) === chainId)) !== null && _a !== void 0 ? _a : null;
    return (chain === null || chain === void 0 ? void 0 : chain.id) || null;
}
/**
 * Controller that passively polls on a set interval for token-to-fiat exchange rates
 * for tokens stored in the TokensController
 */
class TokenRatesController extends BaseController_1.BaseController {
    /**
     * Creates a TokenRatesController instance.
     *
     * @param options - The controller options.
     * @param options.onTokensStateChange - Allows subscribing to token controller state changes.
     * @param options.onCurrencyRateStateChange - Allows subscribing to currency rate controller state changes.
     * @param options.onNetworkStateChange - Allows subscribing to network state changes.
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor({ onTokensStateChange, onCurrencyRateStateChange, onNetworkStateChange, }, config, state) {
        super(config, state);
        this.tokenList = [];
        this.supportedChains = {
            timestamp: 0,
            data: null,
        };
        this.supportedVsCurrencies = {
            timestamp: 0,
            data: [],
        };
        /**
         * Name of this controller used during composition
         */
        this.name = 'TokenRatesController';
        this.defaultConfig = {
            disabled: true,
            interval: 3 * 60 * 1000,
            nativeCurrency: 'eth',
            chainId: '',
            tokens: [],
            threshold: 6 * 60 * 60 * 1000,
        };
        this.defaultState = {
            contractExchangeRates: {},
        };
        this.initialize();
        this.configure({ disabled: false }, false, false);
        onTokensStateChange((tokensState) => {
            this.configure({ tokens: tokensState.tokens });
        });
        onCurrencyRateStateChange((currencyRateState) => {
            this.configure({ nativeCurrency: currencyRateState.nativeCurrency });
        });
        onNetworkStateChange(({ provider }) => {
            const { chainId } = provider;
            this.update({ contractExchangeRates: {} });
            this.configure({ chainId });
        });
        this.poll();
    }
    /**
     * Sets a new polling interval.
     *
     * @param interval - Polling interval used to fetch new token rates.
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield util_1.safelyExecute(() => this.updateExchangeRates());
            this.handle = setTimeout(() => {
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
    /**
     * Sets a new chainId.
     *
     * TODO: Replace this with a method.
     *
     * @param _chainId - The current chain ID.
     */
    set chainId(_chainId) {
        !this.disabled && util_1.safelyExecute(() => this.updateExchangeRates());
    }
    get chainId() {
        throw new Error('Property only used for setting');
    }
    /**
     * Sets a new token list to track prices.
     *
     * TODO: Replace this with a method.
     *
     * @param tokens - List of tokens to track exchange rates for.
     */
    set tokens(tokens) {
        this.tokenList = tokens;
        !this.disabled && util_1.safelyExecute(() => this.updateExchangeRates());
    }
    get tokens() {
        throw new Error('Property only used for setting');
    }
    /**
     * Fetches a pairs of token address and native currency.
     *
     * @param chainSlug - Chain string identifier.
     * @param vsCurrency - Query according to tokens in tokenList and native currency.
     * @returns The exchange rates for the given pairs.
     */
    fetchExchangeRate(chainSlug, vsCurrency) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenPairs = this.tokenList.map((token) => token.address).join(',');
            const query = `contract_addresses=${tokenPairs}&vs_currencies=${vsCurrency.toLowerCase()}`;
            return util_1.handleFetch(CoinGeckoApi.getTokenPriceURL(chainSlug, query));
        });
    }
    /**
     * Checks if the current native currency is a supported vs currency to use
     * to query for token exchange rates.
     *
     * @param nativeCurrency - The native currency of the currently active network.
     * @returns A boolean indicating whether it's a supported vsCurrency.
     */
    checkIsSupportedVsCurrency(nativeCurrency) {
        return __awaiter(this, void 0, void 0, function* () {
            const { threshold } = this.config;
            const { timestamp, data } = this.supportedVsCurrencies;
            const now = Date.now();
            if (now - timestamp > threshold) {
                const currencies = yield util_1.handleFetch(CoinGeckoApi.getSupportedVsCurrencies());
                this.supportedVsCurrencies = {
                    data: currencies,
                    timestamp: Date.now(),
                };
                return currencies.includes(nativeCurrency.toLowerCase());
            }
            return data.includes(nativeCurrency.toLowerCase());
        });
    }
    /**
     * Gets current chain ID slug from cached supported platforms CoinGecko API response.
     * If cached supported platforms response is stale, fetches and updates it.
     *
     * @returns The CoinGecko slug for the current chain ID.
     */
    getChainSlug() {
        return __awaiter(this, void 0, void 0, function* () {
            const { threshold, chainId } = this.config;
            const { data, timestamp } = this.supportedChains;
            const now = Date.now();
            if (now - timestamp > threshold) {
                const platforms = yield util_1.handleFetch(CoinGeckoApi.getPlatformsURL());
                this.supportedChains = {
                    data: platforms,
                    timestamp: Date.now(),
                };
                return findChainSlug(chainId, platforms);
            }
            return findChainSlug(chainId, data);
        });
    }
    /**
     * Updates exchange rates for all tokens.
     */
    updateExchangeRates() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.tokenList.length === 0 || this.disabled) {
                return;
            }
            const slug = yield this.getChainSlug();
            let newContractExchangeRates = {};
            if (!slug) {
                this.tokenList.forEach((token) => {
                    const address = util_1.toChecksumHexAddress(token.address);
                    newContractExchangeRates[address] = undefined;
                });
            }
            else {
                const { nativeCurrency } = this.config;
                newContractExchangeRates = yield this.fetchAndMapExchangeRates(nativeCurrency, slug);
            }
            this.update({ contractExchangeRates: newContractExchangeRates });
        });
    }
    /**
     * Checks if the active network's native currency is supported by the coingecko API.
     * If supported, it fetches and maps contractExchange rates to a format to be consumed by the UI.
     * If not supported, it fetches contractExchange rates and maps them from token/fallback-currency
     * to token/nativeCurrency.
     *
     * @param nativeCurrency - The native currency of the currently active network.
     * @param slug - The unique slug used to id the chain by the coingecko api
     * should be used to query token exchange rates.
     * @returns An object with conversion rates for each token
     * related to the network's native currency.
     */
    fetchAndMapExchangeRates(nativeCurrency, slug) {
        return __awaiter(this, void 0, void 0, function* () {
            const contractExchangeRates = {};
            // check if native currency is supported as a vs_currency by the API
            const nativeCurrencySupported = yield this.checkIsSupportedVsCurrency(nativeCurrency);
            if (nativeCurrencySupported) {
                // If it is we can do a simple fetch against the CoinGecko API
                const prices = yield this.fetchExchangeRate(slug, nativeCurrency);
                this.tokenList.forEach((token) => {
                    const price = prices[token.address.toLowerCase()];
                    contractExchangeRates[util_1.toChecksumHexAddress(token.address)] = price
                        ? price[nativeCurrency.toLowerCase()]
                        : 0;
                });
            }
            else {
                // if native currency is not supported we need to use a fallback vsCurrency, get the exchange rates
                // in token/fallback-currency format and convert them to expected token/nativeCurrency format.
                let tokenExchangeRates;
                let vsCurrencyToNativeCurrencyConversionRate = 0;
                try {
                    [
                        tokenExchangeRates,
                        { conversionRate: vsCurrencyToNativeCurrencyConversionRate },
                    ] = yield Promise.all([
                        this.fetchExchangeRate(slug, constants_1.FALL_BACK_VS_CURRENCY),
                        crypto_compare_1.fetchExchangeRate(nativeCurrency, constants_1.FALL_BACK_VS_CURRENCY, false),
                    ]);
                }
                catch (error) {
                    if (error.message.includes('market does not exist for this coin pair')) {
                        return {};
                    }
                    throw error;
                }
                for (const [tokenAddress, conversion] of Object.entries(tokenExchangeRates)) {
                    const tokenToVsCurrencyConversionRate = conversion[constants_1.FALL_BACK_VS_CURRENCY.toLowerCase()];
                    contractExchangeRates[util_1.toChecksumHexAddress(tokenAddress)] =
                        tokenToVsCurrencyConversionRate *
                            vsCurrencyToNativeCurrencyConversionRate;
                }
            }
            return contractExchangeRates;
        });
    }
}
exports.TokenRatesController = TokenRatesController;
exports.default = TokenRatesController;
//# sourceMappingURL=TokenRatesController.js.map
      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\assets\\TokenRatesController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\assets\\CurrencyRateController.js", {"../BaseControllerV2":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\BaseControllerV2.js","../apis/crypto-compare":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\apis\\crypto-compare.js","../util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\util.js","async-mutex":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async-mutex\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\assets\CurrencyRateController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CurrencyRateController = void 0;
const async_mutex_1 = require("async-mutex");
const BaseControllerV2_1 = require("../BaseControllerV2");
const util_1 = require("../util");
const crypto_compare_1 = require("../apis/crypto-compare");
const name = 'CurrencyRateController';
const metadata = {
    conversionDate: { persist: true, anonymous: true },
    conversionRate: { persist: true, anonymous: true },
    currentCurrency: { persist: true, anonymous: true },
    nativeCurrency: { persist: true, anonymous: true },
    pendingCurrentCurrency: { persist: false, anonymous: true },
    pendingNativeCurrency: { persist: false, anonymous: true },
    usdConversionRate: { persist: true, anonymous: true },
};
const defaultState = {
    conversionDate: 0,
    conversionRate: 0,
    currentCurrency: 'usd',
    nativeCurrency: 'ETH',
    pendingCurrentCurrency: null,
    pendingNativeCurrency: null,
    usdConversionRate: null,
};
/**
 * Controller that passively polls on a set interval for an exchange rate from the current base
 * asset to the current currency
 */
class CurrencyRateController extends BaseControllerV2_1.BaseController {
    /**
     * Creates a CurrencyRateController instance.
     *
     * @param options - Constructor options.
     * @param options.includeUsdRate - Keep track of the USD rate in addition to the current currency rate.
     * @param options.interval - The polling interval, in milliseconds.
     * @param options.messenger - A reference to the messaging system.
     * @param options.state - Initial state to set on this controller.
     * @param options.fetchExchangeRate - Fetches the exchange rate from an external API. This option is primarily meant for use in unit tests.
     */
    constructor({ includeUsdRate = false, interval = 180000, messenger, state, fetchExchangeRate = crypto_compare_1.fetchExchangeRate, }) {
        super({
            name,
            metadata,
            messenger,
            state: Object.assign(Object.assign({}, defaultState), state),
        });
        this.mutex = new async_mutex_1.Mutex();
        this.includeUsdRate = includeUsdRate;
        this.intervalDelay = interval;
        this.fetchExchangeRate = fetchExchangeRate;
    }
    /**
     * Start polling for the currency rate.
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.startPolling();
        });
    }
    /**
     * Stop polling for the currency rate.
     */
    stop() {
        this.stopPolling();
    }
    /**
     * Prepare to discard this controller.
     *
     * This stops any active polling.
     */
    destroy() {
        super.destroy();
        this.stopPolling();
    }
    /**
     * Sets a currency to track.
     *
     * @param currentCurrency - ISO 4217 currency code.
     */
    setCurrentCurrency(currentCurrency) {
        return __awaiter(this, void 0, void 0, function* () {
            this.update((state) => {
                state.pendingCurrentCurrency = currentCurrency;
            });
            yield this.updateExchangeRate();
        });
    }
    /**
     * Sets a new native currency.
     *
     * @param symbol - Symbol for the base asset.
     */
    setNativeCurrency(symbol) {
        return __awaiter(this, void 0, void 0, function* () {
            this.update((state) => {
                state.pendingNativeCurrency = symbol;
            });
            yield this.updateExchangeRate();
        });
    }
    stopPolling() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
    }
    /**
     * Starts a new polling interval.
     */
    startPolling() {
        return __awaiter(this, void 0, void 0, function* () {
            this.stopPolling();
            // TODO: Expose polling currency rate update errors
            yield util_1.safelyExecute(() => this.updateExchangeRate());
            this.intervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                yield util_1.safelyExecute(() => this.updateExchangeRate());
            }), this.intervalDelay);
        });
    }
    /**
     * Updates exchange rate for the current currency.
     *
     * @returns The controller state.
     */
    updateExchangeRate() {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            const { currentCurrency: stateCurrentCurrency, nativeCurrency: stateNativeCurrency, pendingCurrentCurrency, pendingNativeCurrency, } = this.state;
            let conversionDate = null;
            let conversionRate = null;
            let usdConversionRate = null;
            const currentCurrency = pendingCurrentCurrency !== null && pendingCurrentCurrency !== void 0 ? pendingCurrentCurrency : stateCurrentCurrency;
            const nativeCurrency = pendingNativeCurrency !== null && pendingNativeCurrency !== void 0 ? pendingNativeCurrency : stateNativeCurrency;
            try {
                if (currentCurrency &&
                    nativeCurrency &&
                    // if either currency is an empty string we can skip the comparison
                    // because it will result in an error from the api and ultimately
                    // a null conversionRate either way.
                    currentCurrency !== '' &&
                    nativeCurrency !== '') {
                    ({ conversionRate, usdConversionRate } = yield this.fetchExchangeRate(currentCurrency, nativeCurrency, this.includeUsdRate));
                    conversionDate = Date.now() / 1000;
                }
            }
            catch (error) {
                if (!error.message.includes('market does not exist for this coin pair')) {
                    throw error;
                }
            }
            finally {
                try {
                    this.update(() => {
                        return {
                            conversionDate,
                            conversionRate,
                            // we currently allow and handle an empty string as a valid nativeCurrency
                            // in cases where a user has not entered a native ticker symbol for a custom network
                            // currentCurrency is not from user input but this protects us from unexpected changes.
                            nativeCurrency,
                            currentCurrency,
                            pendingCurrentCurrency: null,
                            pendingNativeCurrency: null,
                            usdConversionRate,
                        };
                    });
                }
                finally {
                    releaseLock();
                }
            }
            return this.state;
        });
    }
}
exports.CurrencyRateController = CurrencyRateController;
exports.default = CurrencyRateController;
//# sourceMappingURL=CurrencyRateController.js.map
      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\assets\\CurrencyRateController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\assets\\AccountTrackerController.js", {"../BaseController":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\util.js","async-mutex":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async-mutex\\lib\\index.js","eth-query":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-query\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\assets\AccountTrackerController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountTrackerController = void 0;
const eth_query_1 = __importDefault(require("eth-query"));
const async_mutex_1 = require("async-mutex");
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
/**
 * Controller that tracks information for all accounts in the current keychain
 */
class AccountTrackerController extends BaseController_1.BaseController {
    /**
     * Creates an AccountTracker instance.
     *
     * @param options - The controller options.
     * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
     * @param options.getIdentities - Gets the identities from the Preferences store.
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor({ onPreferencesStateChange, getIdentities, }, config, state) {
        super(config, state);
        this.mutex = new async_mutex_1.Mutex();
        /**
         * Name of this controller used during composition
         */
        this.name = 'AccountTrackerController';
        /**
         * Refreshes all accounts in the current keychain.
         */
        this.refresh = () => __awaiter(this, void 0, void 0, function* () {
            this.syncAccounts();
            const { accounts } = this.state;
            for (const address in accounts) {
                yield util_1.safelyExecuteWithTimeout(() => __awaiter(this, void 0, void 0, function* () {
                    const balance = yield util_1.query(this.ethQuery, 'getBalance', [address]);
                    accounts[address] = { balance: util_1.BNToHex(balance) };
                    this.update({ accounts: Object.assign({}, accounts) });
                }));
            }
        });
        this.defaultConfig = {
            interval: 10000,
        };
        this.defaultState = { accounts: {} };
        this.initialize();
        this.getIdentities = getIdentities;
        onPreferencesStateChange(() => {
            this.refresh();
        });
        this.poll();
    }
    syncAccounts() {
        const { accounts } = this.state;
        const addresses = Object.keys(this.getIdentities());
        const existing = Object.keys(accounts);
        const newAddresses = addresses.filter((address) => existing.indexOf(address) === -1);
        const oldAddresses = existing.filter((address) => addresses.indexOf(address) === -1);
        newAddresses.forEach((address) => {
            accounts[address] = { balance: '0x0' };
        });
        oldAddresses.forEach((address) => {
            delete accounts[address];
        });
        this.update({ accounts: Object.assign({}, accounts) });
    }
    /**
     * Sets a new provider.
     *
     * TODO: Replace this wth a method.
     *
     * @param provider - Provider used to create a new underlying EthQuery instance.
     */
    set provider(provider) {
        this.ethQuery = new eth_query_1.default(provider);
    }
    get provider() {
        throw new Error('Property only used for setting');
    }
    /**
     * Starts a new polling interval.
     *
     * @param interval - Polling interval trigger a 'refresh'.
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield this.refresh();
            this.handle = setTimeout(() => {
                releaseLock();
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
}
exports.AccountTrackerController = AccountTrackerController;
exports.default = AccountTrackerController;
//# sourceMappingURL=AccountTrackerController.js.map
      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\assets\\AccountTrackerController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\message-manager\\PersonalMessageManager.js", {"../util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\util.js","./AbstractMessageManager":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\message-manager\\AbstractMessageManager.js","uuid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\message-manager\PersonalMessageManager.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PersonalMessageManager = void 0;
const uuid_1 = require("uuid");
const util_1 = require("../util");
const AbstractMessageManager_1 = require("./AbstractMessageManager");
/**
 * Controller in charge of managing - storing, adding, removing, updating - Messages.
 */
class PersonalMessageManager extends AbstractMessageManager_1.AbstractMessageManager {
    constructor() {
        super(...arguments);
        /**
         * Name of this controller used during composition
         */
        this.name = 'PersonalMessageManager';
    }
    /**
     * Creates a new Message with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new Message to this.messages, and to save the unapproved Messages.
     *
     * @param messageParams - The params for the personal_sign call to be made after the message is approved.
     * @param req - The original request object possibly containing the origin.
     * @returns Promise resolving to the raw data of the signature request.
     */
    addUnapprovedMessageAsync(messageParams, req) {
        return new Promise((resolve, reject) => {
            util_1.validateSignMessageData(messageParams);
            const messageId = this.addUnapprovedMessage(messageParams, req);
            this.hub.once(`${messageId}:finished`, (data) => {
                switch (data.status) {
                    case 'signed':
                        return resolve(data.rawSig);
                    case 'rejected':
                        return reject(new Error('MetaMask Personal Message Signature: User denied message signature.'));
                    default:
                        return reject(new Error(`MetaMask Personal Message Signature: Unknown problem: ${JSON.stringify(messageParams)}`));
                }
            });
        });
    }
    /**
     * Creates a new Message with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new Message to this.messages, and to save the
     * unapproved Messages.
     *
     * @param messageParams - The params for the personal_sign call to be made after the message
     * is approved.
     * @param req - The original request object possibly containing the origin.
     * @returns The id of the newly created message.
     */
    addUnapprovedMessage(messageParams, req) {
        if (req) {
            messageParams.origin = req.origin;
        }
        messageParams.data = util_1.normalizeMessageData(messageParams.data);
        const messageId = uuid_1.v1();
        const messageData = {
            id: messageId,
            messageParams,
            status: 'unapproved',
            time: Date.now(),
            type: 'personal_sign',
        };
        this.addMessage(messageData);
        this.hub.emit(`unapprovedMessage`, Object.assign(Object.assign({}, messageParams), { metamaskId: messageId }));
        return messageId;
    }
    /**
     * Removes the metamaskId property from passed messageParams and returns a promise which
     * resolves the updated messageParams.
     *
     * @param messageParams - The messageParams to modify.
     * @returns Promise resolving to the messageParams with the metamaskId property removed.
     */
    prepMessageForSigning(messageParams) {
        delete messageParams.metamaskId;
        return Promise.resolve(messageParams);
    }
}
exports.PersonalMessageManager = PersonalMessageManager;
exports.default = PersonalMessageManager;
//# sourceMappingURL=PersonalMessageManager.js.map
      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\message-manager\\PersonalMessageManager.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\message-manager\\MessageManager.js", {"../util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\util.js","./AbstractMessageManager":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\message-manager\\AbstractMessageManager.js","uuid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\message-manager\MessageManager.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageManager = void 0;
const uuid_1 = require("uuid");
const util_1 = require("../util");
const AbstractMessageManager_1 = require("./AbstractMessageManager");
/**
 * Controller in charge of managing - storing, adding, removing, updating - Messages.
 */
class MessageManager extends AbstractMessageManager_1.AbstractMessageManager {
    constructor() {
        super(...arguments);
        /**
         * Name of this controller used during composition
         */
        this.name = 'MessageManager';
    }
    /**
     * Creates a new Message with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new Message to this.messages, and to save the unapproved Messages.
     *
     * @param messageParams - The params for the eth_sign call to be made after the message is approved.
     * @param req - The original request object possibly containing the origin.
     * @returns Promise resolving to the raw data of the signature request.
     */
    addUnapprovedMessageAsync(messageParams, req) {
        return new Promise((resolve, reject) => {
            util_1.validateSignMessageData(messageParams);
            const messageId = this.addUnapprovedMessage(messageParams, req);
            this.hub.once(`${messageId}:finished`, (data) => {
                switch (data.status) {
                    case 'signed':
                        return resolve(data.rawSig);
                    case 'rejected':
                        return reject(new Error('MetaMask Message Signature: User denied message signature.'));
                    default:
                        return reject(new Error(`MetaMask Message Signature: Unknown problem: ${JSON.stringify(messageParams)}`));
                }
            });
        });
    }
    /**
     * Creates a new Message with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new Message to this.messages, and to save the
     * unapproved Messages.
     *
     * @param messageParams - The params for the eth_sign call to be made after the message
     * is approved.
     * @param req - The original request object possibly containing the origin.
     * @returns The id of the newly created message.
     */
    addUnapprovedMessage(messageParams, req) {
        if (req) {
            messageParams.origin = req.origin;
        }
        messageParams.data = util_1.normalizeMessageData(messageParams.data);
        const messageId = uuid_1.v1();
        const messageData = {
            id: messageId,
            messageParams,
            status: 'unapproved',
            time: Date.now(),
            type: 'eth_sign',
        };
        this.addMessage(messageData);
        this.hub.emit(`unapprovedMessage`, Object.assign(Object.assign({}, messageParams), { metamaskId: messageId }));
        return messageId;
    }
    /**
     * Removes the metamaskId property from passed messageParams and returns a promise which
     * resolves the updated messageParams.
     *
     * @param messageParams - The messageParams to modify.
     * @returns Promise resolving to the messageParams with the metamaskId property removed.
     */
    prepMessageForSigning(messageParams) {
        delete messageParams.metamaskId;
        return Promise.resolve(messageParams);
    }
}
exports.MessageManager = MessageManager;
exports.default = MessageManager;
//# sourceMappingURL=MessageManager.js.map
      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\message-manager\\MessageManager.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\message-manager\\TypedMessageManager.js", {"../util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\util.js","./AbstractMessageManager":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\message-manager\\AbstractMessageManager.js","uuid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\message-manager\TypedMessageManager.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypedMessageManager = void 0;
const uuid_1 = require("uuid");
const util_1 = require("../util");
const AbstractMessageManager_1 = require("./AbstractMessageManager");
/**
 * Controller in charge of managing - storing, adding, removing, updating - TypedMessages.
 */
class TypedMessageManager extends AbstractMessageManager_1.AbstractMessageManager {
    constructor() {
        super(...arguments);
        /**
         * Name of this controller used during composition
         */
        this.name = 'TypedMessageManager';
    }
    /**
     * Creates a new TypedMessage with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new TypedMessage to this.messages, and to save the unapproved TypedMessages.
     *
     * @param messageParams - The params for the eth_signTypedData call to be made after the message is approved.
     * @param version - Compatibility version EIP712.
     * @param req - The original request object possibly containing the origin.
     * @returns Promise resolving to the raw data of the signature request.
     */
    addUnapprovedMessageAsync(messageParams, version, req) {
        return new Promise((resolve, reject) => {
            if (version === 'V1') {
                util_1.validateTypedSignMessageDataV1(messageParams);
            }
            if (version === 'V3') {
                util_1.validateTypedSignMessageDataV3(messageParams);
            }
            const messageId = this.addUnapprovedMessage(messageParams, version, req);
            this.hub.once(`${messageId}:finished`, (data) => {
                switch (data.status) {
                    case 'signed':
                        return resolve(data.rawSig);
                    case 'rejected':
                        return reject(new Error('MetaMask Typed Message Signature: User denied message signature.'));
                    case 'errored':
                        return reject(new Error(`MetaMask Typed Message Signature: ${data.error}`));
                    default:
                        return reject(new Error(`MetaMask Typed Message Signature: Unknown problem: ${JSON.stringify(messageParams)}`));
                }
            });
        });
    }
    /**
     * Creates a new TypedMessage with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new TypedMessage to this.messages, and to save the
     * unapproved TypedMessages.
     *
     * @param messageParams - The params for the 'eth_signTypedData' call to be made after the message
     * is approved.
     * @param version - Compatibility version EIP712.
     * @param req - The original request object possibly containing the origin.
     * @returns The id of the newly created TypedMessage.
     */
    addUnapprovedMessage(messageParams, version, req) {
        const messageId = uuid_1.v1();
        const messageParamsMetamask = Object.assign(Object.assign({}, messageParams), { metamaskId: messageId, version });
        if (req) {
            messageParams.origin = req.origin;
        }
        const messageData = {
            id: messageId,
            messageParams,
            status: 'unapproved',
            time: Date.now(),
            type: 'eth_signTypedData',
        };
        this.addMessage(messageData);
        this.hub.emit(`unapprovedMessage`, messageParamsMetamask);
        return messageId;
    }
    /**
     * Sets a TypedMessage status to 'errored' via a call to this.setMessageStatus.
     *
     * @param messageId - The id of the TypedMessage to error.
     * @param error - The error to be included in TypedMessage.
     */
    setMessageStatusErrored(messageId, error) {
        const message = this.getMessage(messageId);
        /* istanbul ignore if */
        if (!message) {
            return;
        }
        message.error = error;
        this.updateMessage(message);
        this.setMessageStatus(messageId, 'errored');
    }
    /**
     * Removes the metamaskId and version properties from passed messageParams and returns a promise which
     * resolves the updated messageParams.
     *
     * @param messageParams - The messageParams to modify.
     * @returns Promise resolving to the messageParams with the metamaskId and version properties removed.
     */
    prepMessageForSigning(messageParams) {
        delete messageParams.metamaskId;
        delete messageParams.version;
        return Promise.resolve(messageParams);
    }
}
exports.TypedMessageManager = TypedMessageManager;
exports.default = TypedMessageManager;
//# sourceMappingURL=TypedMessageManager.js.map
      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\message-manager\\TypedMessageManager.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\assets\\TokenBalancesController.js", {"../BaseController":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\util.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\assets\TokenBalancesController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenBalancesController = exports.BN = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
Object.defineProperty(exports, "BN", { enumerable: true, get: function () { return ethereumjs_util_1.BN; } });
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
/**
 * Controller that passively polls on a set interval token balances
 * for tokens stored in the TokensController
 */
class TokenBalancesController extends BaseController_1.BaseController {
    /**
     * Creates a TokenBalancesController instance.
     *
     * @param options - The controller options.
     * @param options.onTokensStateChange - Allows subscribing to assets controller state changes.
     * @param options.getSelectedAddress - Gets the current selected address.
     * @param options.getERC20BalanceOf - Gets the balance of the given account at the given contract address.
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor({ onTokensStateChange, getSelectedAddress, getERC20BalanceOf, }, config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'TokenBalancesController';
        this.defaultConfig = {
            interval: 180000,
            tokens: [],
        };
        this.defaultState = { contractBalances: {} };
        this.initialize();
        onTokensStateChange(({ tokens }) => {
            this.configure({ tokens });
            this.updateBalances();
        });
        this.getSelectedAddress = getSelectedAddress;
        this.getERC20BalanceOf = getERC20BalanceOf;
        this.poll();
    }
    /**
     * Starts a new polling interval.
     *
     * @param interval - Polling interval used to fetch new token balances.
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield util_1.safelyExecute(() => this.updateBalances());
            this.handle = setTimeout(() => {
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
    /**
     * Updates balances for all tokens.
     */
    updateBalances() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.disabled) {
                return;
            }
            const { tokens } = this.config;
            const newContractBalances = {};
            for (const i in tokens) {
                const { address } = tokens[i];
                try {
                    newContractBalances[address] = yield this.getERC20BalanceOf(address, this.getSelectedAddress());
                    tokens[i].balanceError = null;
                }
                catch (error) {
                    newContractBalances[address] = new ethereumjs_util_1.BN(0);
                    tokens[i].balanceError = error;
                }
            }
            this.update({ contractBalances: newContractBalances });
        });
    }
}
exports.TokenBalancesController = TokenBalancesController;
exports.default = TokenBalancesController;
//# sourceMappingURL=TokenBalancesController.js.map
      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\assets\\TokenBalancesController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\assets\\CollectiblesController.js", {"../BaseController":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\constants.js","../util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\util.js","./assetsUtil":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\assets\\assetsUtil.js","async-mutex":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async-mutex\\lib\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\index.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\assets\CollectiblesController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollectiblesController = void 0;
const events_1 = require("events");
const ethereumjs_util_1 = require("ethereumjs-util");
const async_mutex_1 = require("async-mutex");
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const constants_1 = require("../constants");
const assetsUtil_1 = require("./assetsUtil");
const ALL_COLLECTIBLES_STATE_KEY = 'allCollectibles';
const ALL_COLLECTIBLES_CONTRACTS_STATE_KEY = 'allCollectibleContracts';
/**
 * Controller that stores assets and exposes convenience methods
 */
class CollectiblesController extends BaseController_1.BaseController {
    /**
     * Creates a CollectiblesController instance.
     *
     * @param options - The controller options.
     * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
     * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
     * @param options.getERC721AssetName - Gets the name of the asset at the given address.
     * @param options.getERC721AssetSymbol - Gets the symbol of the asset at the given address.
     * @param options.getERC721TokenURI - Gets the URI of the ERC721 token at the given address, with the given ID.
     * @param options.getERC721OwnerOf - Get the owner of a ERC-721 collectible.
     * @param options.getERC1155BalanceOf - Gets balance of a ERC-1155 collectible.
     * @param options.getERC1155TokenURI - Gets the URI of the ERC1155 token at the given address, with the given ID.
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor({ onPreferencesStateChange, onNetworkStateChange, getERC721AssetName, getERC721AssetSymbol, getERC721TokenURI, getERC721OwnerOf, getERC1155BalanceOf, getERC1155TokenURI, }, config, state) {
        super(config, state);
        this.mutex = new async_mutex_1.Mutex();
        /**
         * EventEmitter instance used to listen to specific EIP747 events
         */
        this.hub = new events_1.EventEmitter();
        /**
         * Name of this controller used during composition
         */
        this.name = 'CollectiblesController';
        this.defaultConfig = {
            networkType: constants_1.MAINNET,
            selectedAddress: '',
            chainId: '',
            ipfsGateway: constants_1.IPFS_DEFAULT_GATEWAY_URL,
            openSeaEnabled: false,
            useIPFSSubdomains: true,
        };
        this.defaultState = {
            allCollectibleContracts: {},
            allCollectibles: {},
            ignoredCollectibles: [],
        };
        this.initialize();
        this.getERC721AssetName = getERC721AssetName;
        this.getERC721AssetSymbol = getERC721AssetSymbol;
        this.getERC721TokenURI = getERC721TokenURI;
        this.getERC721OwnerOf = getERC721OwnerOf;
        this.getERC1155BalanceOf = getERC1155BalanceOf;
        this.getERC1155TokenURI = getERC1155TokenURI;
        onPreferencesStateChange(({ selectedAddress, ipfsGateway, openSeaEnabled }) => {
            this.configure({ selectedAddress, ipfsGateway, openSeaEnabled });
        });
        onNetworkStateChange(({ provider }) => {
            const { chainId } = provider;
            this.configure({ chainId });
        });
    }
    getCollectibleApi(contractAddress, tokenId) {
        const { chainId } = this.config;
        switch (chainId) {
            case constants_1.RINKEBY_CHAIN_ID:
                return `https://testnets-api.opensea.io/api/v1/asset/${contractAddress}/${tokenId}`;
            default:
                return `https://api.opensea.io/api/v1/asset/${contractAddress}/${tokenId}`;
        }
    }
    getCollectibleContractInformationApi(contractAddress) {
        const { chainId } = this.config;
        switch (chainId) {
            case constants_1.RINKEBY_CHAIN_ID:
                return `https://testnets-api.opensea.io/api/v1/asset_contract/${contractAddress}`;
            default:
                return `https://api.opensea.io/api/v1/asset_contract/${contractAddress}`;
        }
    }
    /**
     * Helper method to update nested state for allCollectibles and allCollectibleContracts.
     *
     * @param newCollection - the modified piece of state to update in the controller's store
     * @param baseStateKey - The root key in the store to update.
     * @param passedConfig - An object containing the selectedAddress and chainId that are passed through the auto-detection flow.
     * @param passedConfig.userAddress - the address passed through the collectible detection flow to ensure detected assets are stored to the correct account
     * @param passedConfig.chainId - the chainId passed through the collectible detection flow to ensure detected assets are stored to the correct account
     */
    updateNestedCollectibleState(newCollection, baseStateKey, { userAddress, chainId } = {
        userAddress: this.config.selectedAddress,
        chainId: this.config.chainId,
    }) {
        const { [baseStateKey]: oldState } = this.state;
        const addressState = oldState[userAddress];
        const newAddressState = Object.assign(Object.assign({}, addressState), { [chainId]: newCollection });
        const newState = Object.assign(Object.assign({}, oldState), { [userAddress]: newAddressState });
        this.update({
            [baseStateKey]: newState,
        });
    }
    /**
     * Request individual collectible information from OpenSea API.
     *
     * @param contractAddress - Hex address of the collectible contract.
     * @param tokenId - The collectible identifier.
     * @returns Promise resolving to the current collectible name and image.
     */
    getCollectibleInformationFromApi(contractAddress, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenURI = this.getCollectibleApi(contractAddress, tokenId);
            let collectibleInformation;
            /* istanbul ignore if */
            if (this.openSeaApiKey) {
                collectibleInformation = yield util_1.handleFetch(tokenURI, {
                    headers: { 'X-API-KEY': this.openSeaApiKey },
                });
            }
            else {
                collectibleInformation = yield util_1.handleFetch(tokenURI);
            }
            const { num_sales, background_color, image_url, image_preview_url, image_thumbnail_url, image_original_url, animation_url, animation_original_url, name, description, external_link, creator, last_sale, asset_contract: { schema_name }, } = collectibleInformation;
            /* istanbul ignore next */
            const collectibleMetadata = Object.assign({}, { name: name || null }, { description: description || null }, { image: image_url || null }, creator && { creator }, num_sales && { numberOfSales: num_sales }, background_color && { backgroundColor: background_color }, image_preview_url && { imagePreview: image_preview_url }, image_thumbnail_url && { imageThumbnail: image_thumbnail_url }, image_original_url && { imageOriginal: image_original_url }, animation_url && { animation: animation_url }, animation_original_url && {
                animationOriginal: animation_original_url,
            }, external_link && { externalLink: external_link }, last_sale && { lastSale: last_sale }, schema_name && { standard: schema_name });
            return collectibleMetadata;
        });
    }
    /**
     * Request individual collectible information from contracts that follows Metadata Interface.
     *
     * @param contractAddress - Hex address of the collectible contract.
     * @param tokenId - The collectible identifier.
     * @returns Promise resolving to the current collectible name and image.
     */
    getCollectibleInformationFromTokenURI(contractAddress, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            const { ipfsGateway, useIPFSSubdomains } = this.config;
            const result = yield this.getCollectibleURIAndStandard(contractAddress, tokenId);
            let tokenURI = result[0];
            const standard = result[1];
            if (tokenURI.startsWith('ipfs://')) {
                tokenURI = util_1.getFormattedIpfsUrl(ipfsGateway, tokenURI, useIPFSSubdomains);
            }
            try {
                const object = yield util_1.handleFetch(tokenURI);
                // TODO: Check image_url existence. This is not part of EIP721 nor EIP1155
                const image = Object.prototype.hasOwnProperty.call(object, 'image')
                    ? 'image'
                    : /* istanbul ignore next */ 'image_url';
                return {
                    image: object[image],
                    name: object.name,
                    description: object.description,
                    standard,
                    favorite: false,
                };
            }
            catch (_a) {
                return {
                    image: null,
                    name: null,
                    description: null,
                    standard: standard || null,
                    favorite: false,
                };
            }
        });
    }
    /**
     * Retrieve collectible uri with  metadata. TODO Update method to use IPFS.
     *
     * @param contractAddress - Collectible contract address.
     * @param tokenId - Collectible token id.
     * @returns Promise resolving collectible uri and token standard.
     */
    getCollectibleURIAndStandard(contractAddress, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            // try ERC721 uri
            try {
                const uri = yield this.getERC721TokenURI(contractAddress, tokenId);
                return [uri, constants_1.ERC721];
            }
            catch (_a) {
                // Ignore error
            }
            // try ERC1155 uri
            try {
                const tokenURI = yield this.getERC1155TokenURI(contractAddress, tokenId);
                /**
                 * According to EIP1155 the URI value allows for ID substitution
                 * in case the string `{id}` exists.
                 * https://eips.ethereum.org/EIPS/eip-1155#metadata
                 */
                if (!tokenURI.includes('{id}')) {
                    return [tokenURI, constants_1.ERC1155];
                }
                const hexTokenId = ethereumjs_util_1.stripHexPrefix(util_1.BNToHex(new ethereumjs_util_1.BN(tokenId)))
                    .padStart(64, '0')
                    .toLowerCase();
                return [tokenURI.replace('{id}', hexTokenId), constants_1.ERC1155];
            }
            catch (_b) {
                // Ignore error
            }
            return ['', ''];
        });
    }
    /**
     * Request individual collectible information (name, image url and description).
     *
     * @param contractAddress - Hex address of the collectible contract.
     * @param tokenId - The collectible identifier.
     * @returns Promise resolving to the current collectible name and image.
     */
    getCollectibleInformation(contractAddress, tokenId) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return __awaiter(this, void 0, void 0, function* () {
            const blockchainMetadata = yield util_1.safelyExecute(() => __awaiter(this, void 0, void 0, function* () {
                return yield this.getCollectibleInformationFromTokenURI(contractAddress, tokenId);
            }));
            let openSeaMetadata;
            if (this.config.openSeaEnabled) {
                openSeaMetadata = yield util_1.safelyExecute(() => __awaiter(this, void 0, void 0, function* () {
                    return yield this.getCollectibleInformationFromApi(contractAddress, tokenId);
                }));
            }
            return Object.assign(Object.assign({}, openSeaMetadata), { name: (_b = (_a = blockchainMetadata.name) !== null && _a !== void 0 ? _a : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.name) !== null && _b !== void 0 ? _b : null, description: (_d = (_c = blockchainMetadata.description) !== null && _c !== void 0 ? _c : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.description) !== null && _d !== void 0 ? _d : null, image: (_f = (_e = blockchainMetadata.image) !== null && _e !== void 0 ? _e : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.image) !== null && _f !== void 0 ? _f : null, standard: (_h = (_g = blockchainMetadata.standard) !== null && _g !== void 0 ? _g : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.standard) !== null && _h !== void 0 ? _h : null });
        });
    }
    /**
     * Request collectible contract information from OpenSea API.
     *
     * @param contractAddress - Hex address of the collectible contract.
     * @returns Promise resolving to the current collectible name and image.
     */
    getCollectibleContractInformationFromApi(contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const api = this.getCollectibleContractInformationApi(contractAddress);
            let apiCollectibleContractObject;
            /* istanbul ignore if */
            if (this.openSeaApiKey) {
                apiCollectibleContractObject = yield util_1.handleFetch(api, {
                    headers: { 'X-API-KEY': this.openSeaApiKey },
                });
            }
            else {
                apiCollectibleContractObject = yield util_1.handleFetch(api);
            }
            return apiCollectibleContractObject;
        });
    }
    /**
     * Request collectible contract information from the contract itself.
     *
     * @param contractAddress - Hex address of the collectible contract.
     * @returns Promise resolving to the current collectible name and image.
     */
    getCollectibleContractInformationFromContract(contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const name = yield this.getERC721AssetName(contractAddress);
            const symbol = yield this.getERC721AssetSymbol(contractAddress);
            return {
                collection: { name },
                symbol,
                address: contractAddress,
            };
        });
    }
    /**
     * Request collectible contract information from OpenSea API.
     *
     * @param contractAddress - Hex address of the collectible contract.
     * @returns Promise resolving to the collectible contract name, image and description.
     */
    getCollectibleContractInformation(contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const blockchainContractData = yield util_1.safelyExecute(() => __awaiter(this, void 0, void 0, function* () {
                return yield this.getCollectibleContractInformationFromContract(contractAddress);
            }));
            let openSeaContractData;
            if (this.config.openSeaEnabled) {
                openSeaContractData = yield util_1.safelyExecute(() => __awaiter(this, void 0, void 0, function* () {
                    return yield this.getCollectibleContractInformationFromApi(contractAddress);
                }));
            }
            if (blockchainContractData || openSeaContractData) {
                return Object.assign(Object.assign(Object.assign({}, openSeaContractData), blockchainContractData), { collection: Object.assign(Object.assign({ image_url: null }, openSeaContractData === null || openSeaContractData === void 0 ? void 0 : openSeaContractData.collection), blockchainContractData === null || blockchainContractData === void 0 ? void 0 : blockchainContractData.collection) });
            }
            /* istanbul ignore next */
            return {
                address: contractAddress,
                asset_contract_type: null,
                created_date: null,
                schema_name: null,
                symbol: null,
                total_supply: null,
                description: null,
                external_link: null,
                collection: { name: null, image_url: null },
            };
        });
    }
    /**
     * Adds an individual collectible to the stored collectible list.
     *
     * @param address - Hex address of the collectible contract.
     * @param tokenId - The collectible identifier.
     * @param collectibleMetadata - Collectible optional information (name, image and description).
     * @param detection - The chain ID and address of the currently selected network and account at the moment the collectible was detected.
     * @returns Promise resolving to the current collectible list.
     */
    addIndividualCollectible(address, tokenId, collectibleMetadata, detection) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: Remove unused return
            const releaseLock = yield this.mutex.acquire();
            try {
                address = util_1.toChecksumHexAddress(address);
                const { allCollectibles } = this.state;
                let chainId, selectedAddress;
                if (detection) {
                    chainId = detection.chainId;
                    selectedAddress = detection.userAddress;
                }
                else {
                    chainId = this.config.chainId;
                    selectedAddress = this.config.selectedAddress;
                }
                const collectibles = ((_a = allCollectibles[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
                const existingEntry = collectibles.find((collectible) => collectible.address.toLowerCase() === address.toLowerCase() &&
                    collectible.tokenId === tokenId);
                if (existingEntry) {
                    const differentMetadata = assetsUtil_1.compareCollectiblesMetadata(collectibleMetadata, existingEntry);
                    if (differentMetadata) {
                        // TODO: Switch to indexToUpdate
                        const indexToRemove = collectibles.findIndex((collectible) => collectible.address.toLowerCase() === address.toLowerCase() &&
                            collectible.tokenId === tokenId);
                        /* istanbul ignore next */
                        if (indexToRemove !== -1) {
                            collectibles.splice(indexToRemove, 1);
                        }
                    }
                    else {
                        return collectibles;
                    }
                }
                const newEntry = Object.assign({ address,
                    tokenId, favorite: (existingEntry === null || existingEntry === void 0 ? void 0 : existingEntry.favorite) || false, isCurrentlyOwned: true }, collectibleMetadata);
                const newCollectibles = [...collectibles, newEntry];
                this.updateNestedCollectibleState(newCollectibles, ALL_COLLECTIBLES_STATE_KEY, { chainId, userAddress: selectedAddress });
                return newCollectibles;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Adds a collectible contract to the stored collectible contracts list.
     *
     * @param address - Hex address of the collectible contract.
     * @param detection - The chain ID and address of the currently selected network and account at the moment the collectible was detected.
     * @returns Promise resolving to the current collectible contracts list.
     */
    addCollectibleContract(address, detection) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                address = util_1.toChecksumHexAddress(address);
                const { allCollectibleContracts } = this.state;
                let chainId, selectedAddress;
                if (detection) {
                    chainId = detection.chainId;
                    selectedAddress = detection.userAddress;
                }
                else {
                    chainId = this.config.chainId;
                    selectedAddress = this.config.selectedAddress;
                }
                const collectibleContracts = ((_a = allCollectibleContracts[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
                const existingEntry = collectibleContracts.find((collectibleContract) => collectibleContract.address.toLowerCase() === address.toLowerCase());
                if (existingEntry) {
                    return collectibleContracts;
                }
                const contractInformation = yield this.getCollectibleContractInformation(address);
                const { asset_contract_type, created_date, schema_name, symbol, total_supply, description, external_link, collection: { name, image_url }, } = contractInformation;
                // If being auto-detected opensea information is expected
                // Otherwise at least name and symbol from contract is needed
                if ((detection && !name) ||
                    Object.keys(contractInformation).length === 0) {
                    return collectibleContracts;
                }
                /* istanbul ignore next */
                const newEntry = Object.assign({}, { address }, description && { description }, name && { name }, image_url && { logo: image_url }, symbol && { symbol }, total_supply !== null &&
                    typeof total_supply !== 'undefined' && { totalSupply: total_supply }, asset_contract_type && { assetContractType: asset_contract_type }, created_date && { createdDate: created_date }, schema_name && { schemaName: schema_name }, external_link && { externalLink: external_link });
                const newCollectibleContracts = [...collectibleContracts, newEntry];
                this.updateNestedCollectibleState(newCollectibleContracts, ALL_COLLECTIBLES_CONTRACTS_STATE_KEY, { chainId, userAddress: selectedAddress });
                return newCollectibleContracts;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Removes an individual collectible from the stored token list and saves it in ignored collectibles list.
     *
     * @param address - Hex address of the collectible contract.
     * @param tokenId - Token identifier of the collectible.
     */
    removeAndIgnoreIndividualCollectible(address, tokenId) {
        var _a;
        address = util_1.toChecksumHexAddress(address);
        const { allCollectibles, ignoredCollectibles } = this.state;
        const { chainId, selectedAddress } = this.config;
        const newIgnoredCollectibles = [...ignoredCollectibles];
        const collectibles = ((_a = allCollectibles[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
        const newCollectibles = collectibles.filter((collectible) => {
            if (collectible.address.toLowerCase() === address.toLowerCase() &&
                collectible.tokenId === tokenId) {
                const alreadyIgnored = newIgnoredCollectibles.find((c) => c.address === address && c.tokenId === tokenId);
                !alreadyIgnored && newIgnoredCollectibles.push(collectible);
                return false;
            }
            return true;
        });
        this.updateNestedCollectibleState(newCollectibles, ALL_COLLECTIBLES_STATE_KEY);
        this.update({
            ignoredCollectibles: newIgnoredCollectibles,
        });
    }
    /**
     * Removes an individual collectible from the stored token list.
     *
     * @param address - Hex address of the collectible contract.
     * @param tokenId - Token identifier of the collectible.
     */
    removeIndividualCollectible(address, tokenId) {
        var _a;
        address = util_1.toChecksumHexAddress(address);
        const { allCollectibles } = this.state;
        const { chainId, selectedAddress } = this.config;
        const collectibles = ((_a = allCollectibles[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
        const newCollectibles = collectibles.filter((collectible) => !(collectible.address.toLowerCase() === address.toLowerCase() &&
            collectible.tokenId === tokenId));
        this.updateNestedCollectibleState(newCollectibles, ALL_COLLECTIBLES_STATE_KEY);
    }
    /**
     * Removes a collectible contract to the stored collectible contracts list.
     *
     * @param address - Hex address of the collectible contract.
     * @returns Promise resolving to the current collectible contracts list.
     */
    removeCollectibleContract(address) {
        var _a;
        address = util_1.toChecksumHexAddress(address);
        const { allCollectibleContracts } = this.state;
        const { chainId, selectedAddress } = this.config;
        const collectibleContracts = ((_a = allCollectibleContracts[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
        const newCollectibleContracts = collectibleContracts.filter((collectibleContract) => !(collectibleContract.address.toLowerCase() === address.toLowerCase()));
        this.updateNestedCollectibleState(newCollectibleContracts, ALL_COLLECTIBLES_CONTRACTS_STATE_KEY);
        return newCollectibleContracts;
    }
    /**
     * Sets an OpenSea API key to retrieve collectible information.
     *
     * @param openSeaApiKey - OpenSea API key.
     */
    setApiKey(openSeaApiKey) {
        this.openSeaApiKey = openSeaApiKey;
    }
    /**
     * Checks the ownership of a ERC-721 or ERC-1155 collectible for a given address.
     *
     * @param ownerAddress - User public address.
     * @param collectibleAddress - Collectible contract address.
     * @param collectibleId - Collectible token ID.
     * @returns Promise resolving the collectible ownership.
     */
    isCollectibleOwner(ownerAddress, collectibleAddress, collectibleId) {
        return __awaiter(this, void 0, void 0, function* () {
            // Checks the ownership for ERC-721.
            try {
                const owner = yield this.getERC721OwnerOf(collectibleAddress, collectibleId);
                return ownerAddress.toLowerCase() === owner.toLowerCase();
                // eslint-disable-next-line no-empty
            }
            catch (_a) {
                // Ignore ERC-721 contract error
            }
            // Checks the ownership for ERC-1155.
            try {
                const balance = yield this.getERC1155BalanceOf(ownerAddress, collectibleAddress, collectibleId);
                return balance > 0;
                // eslint-disable-next-line no-empty
            }
            catch (_b) {
                // Ignore ERC-1155 contract error
            }
            throw new Error('Unable to verify ownership. Probably because the standard is not supported or the chain is incorrect.');
        });
    }
    /**
     * Verifies currently selected address owns entered collectible address/tokenId combo and
     * adds the collectible and respective collectible contract to the stored collectible and collectible contracts lists.
     *
     * @param address - Hex address of the collectible contract.
     * @param tokenId - The collectible identifier.
     */
    addCollectibleVerifyOwnership(address, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            const { selectedAddress } = this.config;
            if (!(yield this.isCollectibleOwner(selectedAddress, address, tokenId))) {
                throw new Error('This collectible is not owned by the user');
            }
            yield this.addCollectible(address, tokenId);
        });
    }
    /**
     * Adds a collectible and respective collectible contract to the stored collectible and collectible contracts lists.
     *
     * @param address - Hex address of the collectible contract.
     * @param tokenId - The collectible identifier.
     * @param collectibleMetadata - Collectible optional metadata.
     * @param detection - The chain ID and address of the currently selected network and account at the moment the collectible was detected.
     * @returns Promise resolving to the current collectible list.
     */
    addCollectible(address, tokenId, collectibleMetadata, detection) {
        return __awaiter(this, void 0, void 0, function* () {
            address = util_1.toChecksumHexAddress(address);
            const newCollectibleContracts = yield this.addCollectibleContract(address, detection);
            collectibleMetadata =
                collectibleMetadata ||
                    (yield this.getCollectibleInformation(address, tokenId));
            // If collectible contract was not added, do not add individual collectible
            const collectibleContract = newCollectibleContracts.find((contract) => contract.address.toLowerCase() === address.toLowerCase());
            // If collectible contract information, add individual collectible
            if (collectibleContract) {
                yield this.addIndividualCollectible(address, tokenId, collectibleMetadata, detection);
            }
        });
    }
    /**
     * Removes a collectible from the stored token list.
     *
     * @param address - Hex address of the collectible contract.
     * @param tokenId - Token identifier of the collectible.
     */
    removeCollectible(address, tokenId) {
        var _a;
        address = util_1.toChecksumHexAddress(address);
        this.removeIndividualCollectible(address, tokenId);
        const { allCollectibles } = this.state;
        const { chainId, selectedAddress } = this.config;
        const collectibles = ((_a = allCollectibles[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
        const remainingCollectible = collectibles.find((collectible) => collectible.address.toLowerCase() === address.toLowerCase());
        if (!remainingCollectible) {
            this.removeCollectibleContract(address);
        }
    }
    /**
     * Removes a collectible from the stored token list and saves it in ignored collectibles list.
     *
     * @param address - Hex address of the collectible contract.
     * @param tokenId - Token identifier of the collectible.
     */
    removeAndIgnoreCollectible(address, tokenId) {
        var _a;
        address = util_1.toChecksumHexAddress(address);
        this.removeAndIgnoreIndividualCollectible(address, tokenId);
        const { allCollectibles } = this.state;
        const { chainId, selectedAddress } = this.config;
        const collectibles = ((_a = allCollectibles[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
        const remainingCollectible = collectibles.find((collectible) => collectible.address.toLowerCase() === address.toLowerCase());
        if (!remainingCollectible) {
            this.removeCollectibleContract(address);
        }
    }
    /**
     * Removes all collectibles from the ignored list.
     */
    clearIgnoredCollectibles() {
        this.update({ ignoredCollectibles: [] });
    }
    /**
     * Checks whether input collectible is still owned by the user
     * And updates the isCurrentlyOwned value on the collectible object accordingly.
     *
     * @param collectible - The collectible object to check and update.
     * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.
     * @param accountParams - The userAddress and chainId to check ownership against
     * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure detected assets are stored to the correct account
     * @param accountParams.chainId - the chainId passed through the confirmed transaction flow to ensure detected assets are stored to the correct account
     * @returns the collectible with the updated isCurrentlyOwned value
     */
    checkAndUpdateSingleCollectibleOwnershipStatus(collectible, batch, { userAddress, chainId } = {
        userAddress: this.config.selectedAddress,
        chainId: this.config.chainId,
    }) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { address, tokenId } = collectible;
            let isOwned = collectible.isCurrentlyOwned;
            try {
                isOwned = yield this.isCollectibleOwner(userAddress, address, tokenId);
            }
            catch (error) {
                if (!error.message.includes('Unable to verify ownership')) {
                    throw error;
                }
            }
            collectible.isCurrentlyOwned = isOwned;
            if (batch === true) {
                return collectible;
            }
            // if this is not part of a batched update we update this one collectible in state
            const { allCollectibles } = this.state;
            const collectibles = ((_a = allCollectibles[userAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
            const collectibleToUpdate = collectibles.find((item) => item.tokenId === tokenId &&
                item.address.toLowerCase() === address.toLowerCase());
            if (collectibleToUpdate) {
                collectibleToUpdate.isCurrentlyOwned = isOwned;
                this.updateNestedCollectibleState(collectibles, ALL_COLLECTIBLES_STATE_KEY, { userAddress, chainId });
            }
            return collectible;
        });
    }
    /**
     * Checks whether Collectibles associated with current selectedAddress/chainId combination are still owned by the user
     * And updates the isCurrentlyOwned value on each accordingly.
     */
    checkAndUpdateAllCollectiblesOwnershipStatus() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { allCollectibles } = this.state;
            const { chainId, selectedAddress } = this.config;
            const collectibles = ((_a = allCollectibles[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
            const updatedCollectibles = yield Promise.all(collectibles.map((collectible) => __awaiter(this, void 0, void 0, function* () {
                var _b;
                return ((_b = (yield this.checkAndUpdateSingleCollectibleOwnershipStatus(collectible, true))) !== null && _b !== void 0 ? _b : collectible);
            })));
            this.updateNestedCollectibleState(updatedCollectibles, ALL_COLLECTIBLES_STATE_KEY);
        });
    }
    /**
     * Update collectible favorite status.
     *
     * @param address - Hex address of the collectible contract.
     * @param tokenId - Hex address of the collectible contract.
     * @param favorite - Collectible new favorite status.
     */
    updateCollectibleFavoriteStatus(address, tokenId, favorite) {
        var _a;
        const { allCollectibles } = this.state;
        const { chainId, selectedAddress } = this.config;
        const collectibles = ((_a = allCollectibles[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
        const index = collectibles.findIndex((collectible) => collectible.address === address && collectible.tokenId === tokenId);
        if (index === -1) {
            return;
        }
        const updatedCollectible = Object.assign(Object.assign({}, collectibles[index]), { favorite });
        // Update Collectibles array
        collectibles[index] = updatedCollectible;
        this.updateNestedCollectibleState(collectibles, ALL_COLLECTIBLES_STATE_KEY);
    }
}
exports.CollectiblesController = CollectiblesController;
exports.default = CollectiblesController;
//# sourceMappingURL=CollectiblesController.js.map
      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\assets\\CollectiblesController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\approval\\ApprovalController.js", {"../BaseControllerV2":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\BaseControllerV2.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js","nanoid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\node_modules\\nanoid\\index.browser.cjs"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\approval\ApprovalController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApprovalController = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const nanoid_1 = require("nanoid");
const BaseControllerV2_1 = require("../BaseControllerV2");
const controllerName = 'ApprovalController';
const stateMetadata = {
    pendingApprovals: { persist: false, anonymous: true },
    pendingApprovalCount: { persist: false, anonymous: false },
};
const getAlreadyPendingMessage = (origin, type) => `Request of type '${type}' already pending for origin ${origin}. Please wait.`;
const getDefaultState = () => {
    return {
        pendingApprovals: {},
        pendingApprovalCount: 0,
    };
};
/**
 * Controller for managing requests that require user approval.
 *
 * Enables limiting the number of pending requests by origin and type, counting
 * pending requests, and more.
 *
 * Adding a request returns a promise that resolves or rejects when the request
 * is approved or denied, respectively.
 */
class ApprovalController extends BaseControllerV2_1.BaseController {
    /**
     * Construct an Approval controller.
     *
     * @param options - The controller options.
     * @param options.showApprovalRequest - Function for opening the UI such that
     * the request can be displayed to the user.
     * @param options.messenger - The restricted controller messenger for the Approval controller.
     * @param options.state - The initial controller state.
     */
    constructor({ messenger, showApprovalRequest, state = {}, }) {
        super({
            name: controllerName,
            metadata: stateMetadata,
            messenger,
            state: Object.assign(Object.assign({}, getDefaultState()), state),
        });
        this._approvals = new Map();
        this._origins = new Map();
        this._showApprovalRequest = showApprovalRequest;
        this.registerMessageHandlers();
    }
    /**
     * Constructor helper for registering this controller's messaging system
     * actions.
     */
    registerMessageHandlers() {
        this.messagingSystem.registerActionHandler(`${controllerName}:clearRequests`, this.clear.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:addRequest`, (opts, shouldShowRequest) => {
            if (shouldShowRequest) {
                return this.addAndShowApprovalRequest(opts);
            }
            return this.add(opts);
        });
        this.messagingSystem.registerActionHandler(`${controllerName}:hasRequest`, this.has.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:acceptRequest`, this.accept.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:rejectRequest`, this.reject.bind(this));
    }
    /**
     * Adds an approval request per the given arguments, calls the show approval
     * request function, and returns the associated approval promise.
     *
     * There can only be one approval per origin and type. An error is thrown if
     * attempting to add an invalid or duplicate request.
     *
     * @param opts - Options bag.
     * @param opts.id - The id of the approval request. A random id will be
     * generated if none is provided.
     * @param opts.origin - The origin of the approval request.
     * @param opts.type - The type associated with the approval request.
     * @param opts.requestData - Additional data associated with the request,
     * if any.
     * @returns The approval promise.
     */
    addAndShowApprovalRequest(opts) {
        const promise = this._add(opts.origin, opts.type, opts.id, opts.requestData);
        this._showApprovalRequest();
        return promise;
    }
    /**
     * Adds an approval request per the given arguments and returns the approval
     * promise.
     *
     * There can only be one approval per origin and type. An error is thrown if
     * attempting to add an invalid or duplicate request.
     *
     * @param opts - Options bag.
     * @param opts.id - The id of the approval request. A random id will be
     * generated if none is provided.
     * @param opts.origin - The origin of the approval request.
     * @param opts.type - The type associated with the approval request.
     * @param opts.requestData - Additional data associated with the request,
     * if any.
     * @returns The approval promise.
     */
    add(opts) {
        return this._add(opts.origin, opts.type, opts.id, opts.requestData);
    }
    /**
     * Gets the info for the approval request with the given id.
     *
     * @param id - The id of the approval request.
     * @returns The approval request data associated with the id.
     */
    get(id) {
        return this.state.pendingApprovals[id];
    }
    /**
     * Gets the number of pending approvals, by origin and/or type.
     *
     * If only `origin` is specified, all approvals for that origin will be
     * counted, regardless of type.
     * If only `type` is specified, all approvals for that type will be counted,
     * regardless of origin.
     * If both `origin` and `type` are specified, 0 or 1 will be returned.
     *
     * @param opts - The approval count options.
     * @param opts.origin - An approval origin.
     * @param opts.type - The type of the approval request.
     * @returns The current approval request count for the given origin and/or
     * type.
     */
    getApprovalCount(opts = {}) {
        var _a, _b;
        if (!opts.origin && !opts.type) {
            throw new Error('Must specify origin, type, or both.');
        }
        const { origin, type: _type } = opts;
        if (origin && _type) {
            return Number(Boolean((_a = this._origins.get(origin)) === null || _a === void 0 ? void 0 : _a.has(_type)));
        }
        if (origin) {
            return ((_b = this._origins.get(origin)) === null || _b === void 0 ? void 0 : _b.size) || 0;
        }
        // Only "type" was specified
        let count = 0;
        for (const approval of Object.values(this.state.pendingApprovals)) {
            if (approval.type === _type) {
                count += 1;
            }
        }
        return count;
    }
    /**
     * Get the total count of all pending approval requests for all origins.
     *
     * @returns The total pending approval request count.
     */
    getTotalApprovalCount() {
        return this.state.pendingApprovalCount;
    }
    /**
     * Checks if there's a pending approval request per the given parameters.
     * At least one parameter must be specified. An error will be thrown if the
     * parameters are invalid.
     *
     * If `id` is specified, all other parameters will be ignored.
     * If `id` is not specified, the method will check for requests that match
     * all of the specified parameters.
     *
     * @param opts - Options bag.
     * @param opts.id - The ID to check for.
     * @param opts.origin - The origin to check for.
     * @param opts.type - The type to check for.
     * @returns `true` if a matching approval is found, and `false` otherwise.
     */
    has(opts = {}) {
        var _a;
        const { id, origin, type: _type } = opts;
        if (id) {
            if (typeof id !== 'string') {
                throw new Error('May not specify non-string id.');
            }
            return this._approvals.has(id);
        }
        if (_type && typeof _type !== 'string') {
            throw new Error('May not specify non-string type.');
        }
        if (origin) {
            if (typeof origin !== 'string') {
                throw new Error('May not specify non-string origin.');
            }
            // Check origin and type pair if type also specified
            if (_type) {
                return Boolean((_a = this._origins.get(origin)) === null || _a === void 0 ? void 0 : _a.has(_type));
            }
            return this._origins.has(origin);
        }
        if (_type) {
            for (const approval of Object.values(this.state.pendingApprovals)) {
                if (approval.type === _type) {
                    return true;
                }
            }
            return false;
        }
        throw new Error('Must specify a valid combination of id, origin, and type.');
    }
    /**
     * Resolves the promise of the approval with the given id, and deletes the
     * approval. Throws an error if no such approval exists.
     *
     * @param id - The id of the approval request.
     * @param value - The value to resolve the approval promise with.
     */
    accept(id, value) {
        this._deleteApprovalAndGetCallbacks(id).resolve(value);
    }
    /**
     * Rejects the promise of the approval with the given id, and deletes the
     * approval. Throws an error if no such approval exists.
     *
     * @param id - The id of the approval request.
     * @param error - The error to reject the approval promise with.
     */
    reject(id, error) {
        this._deleteApprovalAndGetCallbacks(id).reject(error);
    }
    /**
     * Rejects and deletes all approval requests.
     *
     * @param rejectionError - The EthereumRpcError to reject the approval
     * requests with.
     */
    clear(rejectionError) {
        for (const id of this._approvals.keys()) {
            this.reject(id, rejectionError);
        }
        this._origins.clear();
        this.update(() => getDefaultState());
    }
    /**
     * Implementation of add operation.
     *
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     * @param id - The id of the approval request.
     * @param requestData - The request data associated with the approval request.
     * @returns The approval promise.
     */
    _add(origin, type, id = nanoid_1.nanoid(), requestData) {
        var _a;
        this._validateAddParams(id, origin, type, requestData);
        if ((_a = this._origins.get(origin)) === null || _a === void 0 ? void 0 : _a.has(type)) {
            throw eth_rpc_errors_1.ethErrors.rpc.resourceUnavailable(getAlreadyPendingMessage(origin, type));
        }
        // add pending approval
        return new Promise((resolve, reject) => {
            this._approvals.set(id, { resolve, reject });
            this._addPendingApprovalOrigin(origin, type);
            this._addToStore(id, origin, type, requestData);
        });
    }
    /**
     * Validates parameters to the add method.
     *
     * @param id - The id of the approval request.
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     * @param requestData - The request data associated with the approval request.
     */
    _validateAddParams(id, origin, type, requestData) {
        let errorMessage = null;
        if (!id || typeof id !== 'string') {
            errorMessage = 'Must specify non-empty string id.';
        }
        else if (this._approvals.has(id)) {
            errorMessage = `Approval request with id '${id}' already exists.`;
        }
        else if (!origin || typeof origin !== 'string') {
            errorMessage = 'Must specify non-empty string origin.';
        }
        else if (!type || typeof type !== 'string') {
            errorMessage = 'Must specify non-empty string type.';
        }
        else if (requestData &&
            (typeof requestData !== 'object' || Array.isArray(requestData))) {
            errorMessage = 'Request data must be a plain object if specified.';
        }
        if (errorMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.internal(errorMessage);
        }
    }
    /**
     * Adds an entry to _origins.
     * Performs no validation.
     *
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     */
    _addPendingApprovalOrigin(origin, type) {
        const originSet = this._origins.get(origin) || new Set();
        originSet.add(type);
        if (!this._origins.has(origin)) {
            this._origins.set(origin, originSet);
        }
    }
    /**
     * Adds an entry to the store.
     * Performs no validation.
     *
     * @param id - The id of the approval request.
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     * @param requestData - The request data associated with the approval request.
     */
    _addToStore(id, origin, type, requestData) {
        const approval = {
            id,
            origin,
            type,
            time: Date.now(),
            requestData: requestData || null,
        };
        this.update((draftState) => {
            // Typecast: ts(2589)
            draftState.pendingApprovals[id] = approval;
            draftState.pendingApprovalCount = Object.keys(draftState.pendingApprovals).length;
        });
    }
    /**
     * Deletes the approval with the given id. The approval promise must be
     * resolved or reject before this method is called.
     * Deletion is an internal operation because approval state is solely
     * managed by this controller.
     *
     * @param id - The id of the approval request to be deleted.
     */
    _delete(id) {
        this._approvals.delete(id);
        // This method is only called after verifying that the approval with the
        // specified id exists.
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const { origin, type } = this.state.pendingApprovals[id];
        this._origins.get(origin).delete(type);
        if (this._isEmptyOrigin(origin)) {
            this._origins.delete(origin);
        }
        this.update((draftState) => {
            delete draftState.pendingApprovals[id];
            draftState.pendingApprovalCount = Object.keys(draftState.pendingApprovals).length;
        });
    }
    /**
     * Gets the approval callbacks for the given id, deletes the entry, and then
     * returns the callbacks for promise resolution.
     * Throws an error if no approval is found for the given id.
     *
     * @param id - The id of the approval request.
     * @returns The promise callbacks associated with the approval request.
     */
    _deleteApprovalAndGetCallbacks(id) {
        const callbacks = this._approvals.get(id);
        if (!callbacks) {
            throw new Error(`Approval request with id '${id}' not found.`);
        }
        this._delete(id);
        return callbacks;
    }
    /**
     * Checks whether there are any approvals associated with the given
     * origin.
     *
     * @param origin - The origin to check.
     * @returns True if the origin has no approvals, false otherwise.
     */
    _isEmptyOrigin(origin) {
        var _a;
        return !((_a = this._origins.get(origin)) === null || _a === void 0 ? void 0 : _a.size);
    }
}
exports.ApprovalController = ApprovalController;
exports.default = ApprovalController;
//# sourceMappingURL=ApprovalController.js.map
      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\approval\\ApprovalController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\BaseControllerV2.js", {"immer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\immer\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\BaseControllerV2.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPersistentState = exports.getAnonymizedState = exports.BaseController = void 0;
const immer_1 = require("immer");
immer_1.enablePatches();
/**
 * Controller class that provides state management, subscriptions, and state metadata
 */
class BaseController {
    /**
     * Creates a BaseController instance.
     *
     * @param options - Controller options.
     * @param options.messenger - Controller messaging system.
     * @param options.metadata - State metadata, describing how to "anonymize" the state, and which
     * parts should be persisted.
     * @param options.name - The name of the controller, used as a namespace for events and actions.
     * @param options.state - Initial controller state.
     */
    constructor({ messenger, metadata, name, state, }) {
        this.messagingSystem = messenger;
        this.name = name;
        this.internalState = state;
        this.metadata = metadata;
        this.messagingSystem.registerActionHandler(`${name}:getState`, () => this.state);
    }
    /**
     * Retrieves current controller state.
     *
     * @returns The current state.
     */
    get state() {
        return this.internalState;
    }
    set state(_) {
        throw new Error(`Controller state cannot be directly mutated; use 'update' method instead.`);
    }
    /**
     * Updates controller state. Accepts a callback that is passed a draft copy
     * of the controller state. If a value is returned, it is set as the new
     * state. Otherwise, any changes made within that callback to the draft are
     * applied to the controller state.
     *
     * @param callback - Callback for updating state, passed a draft state
     * object. Return a new state object or mutate the draft to update state.
     */
    update(callback) {
        // We run into ts2589, "infinite type depth", if we don't cast
        // produceWithPatches here.
        // The final, omitted member of the returned tuple are the inverse patches.
        const [nextState, patches] = immer_1.produceWithPatches(this.internalState, callback);
        this.internalState = nextState;
        this.messagingSystem.publish(`${this.name}:stateChange`, nextState, patches);
    }
    /**
     * Prepares the controller for garbage collection. This should be extended
     * by any subclasses to clean up any additional connections or events.
     *
     * The only cleanup performed here is to remove listeners. While technically
     * this is not required to ensure this instance is garbage collected, it at
     * least ensures this instance won't be responsible for preventing the
     * listeners from being garbage collected.
     */
    destroy() {
        this.messagingSystem.clearEventSubscriptions(`${this.name}:stateChange`);
    }
}
exports.BaseController = BaseController;
/**
 * Returns an anonymized representation of the controller state.
 *
 * By "anonymized" we mean that it should not contain any information that could be personally
 * identifiable.
 *
 * @param state - The controller state.
 * @param metadata - The controller state metadata, which describes how to derive the
 * anonymized state.
 * @returns The anonymized controller state.
 */
function getAnonymizedState(state, metadata) {
    return deriveStateFromMetadata(state, metadata, 'anonymous');
}
exports.getAnonymizedState = getAnonymizedState;
/**
 * Returns the subset of state that should be persisted.
 *
 * @param state - The controller state.
 * @param metadata - The controller state metadata, which describes which pieces of state should be persisted.
 * @returns The subset of controller state that should be persisted.
 */
function getPersistentState(state, metadata) {
    return deriveStateFromMetadata(state, metadata, 'persist');
}
exports.getPersistentState = getPersistentState;
/**
 * Use the metadata to derive state according to the given metadata property.
 *
 * @param state - The full controller state.
 * @param metadata - The controller metadata.
 * @param metadataProperty - The metadata property to use to derive state.
 * @returns The metadata-derived controller state.
 */
function deriveStateFromMetadata(state, metadata, metadataProperty) {
    return Object.keys(state).reduce((persistedState, key) => {
        const propertyMetadata = metadata[key][metadataProperty];
        const stateProperty = state[key];
        if (typeof propertyMetadata === 'function') {
            persistedState[key] = propertyMetadata(stateProperty);
        }
        else if (propertyMetadata) {
            persistedState[key] = stateProperty;
        }
        return persistedState;
    }, {});
}
//# sourceMappingURL=BaseControllerV2.js.map
      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\BaseControllerV2.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\assets\\TokenListController.js", {"../BaseControllerV2":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\BaseControllerV2.js","../apis/token-service":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\apis\\token-service.js","../util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\util.js","@metamask/contract-metadata":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\contract-metadata\\index.js","abort-controller":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\abort-controller\\browser.js","async-mutex":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async-mutex\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\assets\TokenListController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenListController = void 0;
const contract_metadata_1 = __importDefault(require("@metamask/contract-metadata"));
const async_mutex_1 = require("async-mutex");
// eslint-disable-next-line import/no-named-as-default
const abort_controller_1 = __importDefault(require("abort-controller"));
const BaseControllerV2_1 = require("../BaseControllerV2");
const util_1 = require("../util");
const token_service_1 = require("../apis/token-service");
const DEFAULT_INTERVAL = 60 * 60 * 1000;
const DEFAULT_THRESHOLD = 60 * 30 * 1000;
const name = 'TokenListController';
const metadata = {
    tokenList: { persist: true, anonymous: true },
    tokensChainsCache: { persist: true, anonymous: true },
};
const defaultState = {
    tokenList: {},
    tokensChainsCache: {},
};
/**
 * Controller that passively polls on a set interval for the list of tokens from metaswaps api
 */
class TokenListController extends BaseControllerV2_1.BaseController {
    // private abortSignal: AbortSignal;
    /**
     * Creates a TokenListController instance.
     *
     * @param options - The controller options.
     * @param options.chainId - The chain ID of the current network.
     * @param options.useStaticTokenList - Indicates whether to use the static token list or not.
     * @param options.onNetworkStateChange - A function for registering an event handler for network state changes.
     * @param options.onPreferencesStateChange -A function for registering an event handler for preference state changes.
     * @param options.interval - The polling interval, in milliseconds.
     * @param options.cacheRefreshThreshold - The token cache expiry time, in milliseconds.
     * @param options.messenger - A restricted controller messenger.
     * @param options.state - Initial state to set on this controller.
     */
    constructor({ chainId, useStaticTokenList, onNetworkStateChange, onPreferencesStateChange, interval = DEFAULT_INTERVAL, cacheRefreshThreshold = DEFAULT_THRESHOLD, messenger, state, }) {
        super({
            name,
            metadata,
            messenger,
            state: Object.assign(Object.assign({}, defaultState), state),
        });
        this.mutex = new async_mutex_1.Mutex();
        this.intervalDelay = interval;
        this.cacheRefreshThreshold = cacheRefreshThreshold;
        this.chainId = chainId;
        this.useStaticTokenList = useStaticTokenList;
        this.abortController = new abort_controller_1.default();
        onNetworkStateChange((networkState) => __awaiter(this, void 0, void 0, function* () {
            if (this.chainId !== networkState.provider.chainId) {
                this.abortController.abort();
                this.abortController = new abort_controller_1.default();
                this.chainId = networkState.provider.chainId;
                yield this.restart();
            }
        }));
        onPreferencesStateChange((preferencesState) => __awaiter(this, void 0, void 0, function* () {
            if (this.useStaticTokenList !== preferencesState.useStaticTokenList) {
                this.abortController.abort();
                this.abortController = new abort_controller_1.default();
                this.useStaticTokenList = preferencesState.useStaticTokenList;
                yield this.restart();
            }
        }));
    }
    /**
     * Start polling for the token list.
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.startPolling();
        });
    }
    /**
     * Restart polling for the token list.
     */
    restart() {
        return __awaiter(this, void 0, void 0, function* () {
            this.stopPolling();
            yield this.startPolling();
        });
    }
    /**
     * Stop polling for the token list.
     */
    stop() {
        this.stopPolling();
    }
    /**
     * Prepare to discard this controller.
     *
     * This stops any active polling.
     */
    destroy() {
        super.destroy();
        this.stopPolling();
    }
    stopPolling() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
    }
    /**
     * Starts a new polling interval.
     */
    startPolling() {
        return __awaiter(this, void 0, void 0, function* () {
            yield util_1.safelyExecute(() => this.fetchTokenList());
            this.intervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                yield util_1.safelyExecute(() => this.fetchTokenList());
            }), this.intervalDelay);
        });
    }
    /**
     * Fetching token list.
     */
    fetchTokenList() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.useStaticTokenList) {
                yield this.fetchFromStaticTokenList();
            }
            else {
                yield this.fetchFromDynamicTokenList();
            }
        });
    }
    /**
     * Fetching token list from the contract-metadata as a fallback.
     */
    fetchFromStaticTokenList() {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenList = {};
            for (const tokenAddress in contract_metadata_1.default) {
                const _a = contract_metadata_1.default[tokenAddress], { erc20, logo: filePath } = _a, token = __rest(_a, ["erc20", "logo"]);
                if (erc20) {
                    tokenList[tokenAddress] = Object.assign(Object.assign({}, token), { address: tokenAddress, iconUrl: filePath, occurrences: null });
                }
            }
            this.update(() => {
                return {
                    tokenList,
                    tokensChainsCache: {},
                };
            });
        });
    }
    /**
     * Fetching token list from the Token Service API.
     */
    fetchFromDynamicTokenList() {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                const cachedTokens = yield util_1.safelyExecute(() => this.fetchFromCache());
                const _a = this.state, { tokensChainsCache } = _a, tokensData = __rest(_a, ["tokensChainsCache"]);
                const tokenList = {};
                if (cachedTokens) {
                    for (const token of cachedTokens) {
                        tokenList[token.address] = token;
                    }
                }
                else {
                    const tokensFromAPI = yield util_1.safelyExecute(() => token_service_1.fetchTokenList(this.chainId, this.abortController.signal));
                    if (!tokensFromAPI) {
                        const backupTokenList = tokensChainsCache[this.chainId]
                            ? tokensChainsCache[this.chainId].data
                            : [];
                        for (const token of backupTokenList) {
                            tokenList[token.address] = token;
                        }
                        this.update(() => {
                            return Object.assign(Object.assign({}, tokensData), { tokenList,
                                tokensChainsCache });
                        });
                        return;
                    }
                    // filtering out tokens with less than 2 occurrences
                    const filteredTokenList = tokensFromAPI.filter((token) => token.occurrences && token.occurrences >= 2);
                    // removing the tokens with symbol conflicts
                    const symbolsList = filteredTokenList.map((token) => token.symbol);
                    const duplicateSymbols = [
                        ...new Set(symbolsList.filter((symbol, index) => symbolsList.indexOf(symbol) !== index)),
                    ];
                    const uniqueTokenList = filteredTokenList.filter((token) => !duplicateSymbols.includes(token.symbol));
                    for (const token of uniqueTokenList) {
                        tokenList[token.address] = token;
                    }
                }
                const updatedTokensChainsCache = Object.assign(Object.assign({}, tokensChainsCache), { [this.chainId]: {
                        timestamp: Date.now(),
                        data: Object.values(tokenList),
                    } });
                this.update(() => {
                    return Object.assign(Object.assign({}, tokensData), { tokenList, tokensChainsCache: updatedTokensChainsCache });
                });
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Checks if the Cache timestamp is valid,
     * if yes data in cache will be returned
     * otherwise null will be returned.
     *
     * @returns The cached data, or `null` if the cache was expired.
     */
    fetchFromCache() {
        return __awaiter(this, void 0, void 0, function* () {
            const { tokensChainsCache } = this.state;
            const dataCache = tokensChainsCache[this.chainId];
            const now = Date.now();
            if ((dataCache === null || dataCache === void 0 ? void 0 : dataCache.data) &&
                now - (dataCache === null || dataCache === void 0 ? void 0 : dataCache.timestamp) < this.cacheRefreshThreshold) {
                return dataCache.data;
            }
            return null;
        });
    }
    /**
     * Fetch metadata for a token.
     *
     * @param tokenAddress - The address of the token.
     * @returns The token metadata.
     */
    fetchTokenMetadata(tokenAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                const token = (yield token_service_1.fetchTokenMetadata(this.chainId, tokenAddress, this.abortController.signal));
                return token;
            }
            finally {
                releaseLock();
            }
        });
    }
}
exports.TokenListController = TokenListController;
exports.default = TokenListController;
//# sourceMappingURL=TokenListController.js.map
      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\assets\\TokenListController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\assets\\TokensController.js", {"../BaseController":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\constants.js","../util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\util.js","@metamask/contract-metadata":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\contract-metadata\\index.js","@metamask/metamask-eth-abis":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\metamask-eth-abis\\dist\\index.js","async-mutex":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async-mutex\\lib\\index.js","ethers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethers\\lib\\index.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","uuid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\assets\TokensController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokensController = void 0;
const events_1 = require("events");
const contract_metadata_1 = __importDefault(require("@metamask/contract-metadata"));
const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
const uuid_1 = require("uuid");
const async_mutex_1 = require("async-mutex");
const ethers_1 = require("ethers");
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const constants_1 = require("../constants");
var SuggestedAssetStatus;
(function (SuggestedAssetStatus) {
    SuggestedAssetStatus["accepted"] = "accepted";
    SuggestedAssetStatus["failed"] = "failed";
    SuggestedAssetStatus["pending"] = "pending";
    SuggestedAssetStatus["rejected"] = "rejected";
})(SuggestedAssetStatus || (SuggestedAssetStatus = {}));
/**
 * Controller that stores assets and exposes convenience methods
 */
class TokensController extends BaseController_1.BaseController {
    /**
     * Creates a TokensController instance.
     *
     * @param options - The controller options.
     * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
     * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
     * @param options.config - Initial options used to configure this controller.
     * @param options.state - Initial state to set on this controller.
     */
    constructor({ onPreferencesStateChange, onNetworkStateChange, config, state, }) {
        super(config, state);
        this.mutex = new async_mutex_1.Mutex();
        /**
         * EventEmitter instance used to listen to specific EIP747 events
         */
        this.hub = new events_1.EventEmitter();
        /**
         * Name of this controller used during composition
         */
        this.name = 'TokensController';
        this.defaultConfig = Object.assign({ networkType: constants_1.MAINNET, selectedAddress: '', chainId: '', provider: undefined }, config);
        this.defaultState = Object.assign({ allTokens: {}, allIgnoredTokens: {}, ignoredTokens: [], suggestedAssets: [], tokens: [] }, state);
        this.initialize();
        onPreferencesStateChange(({ selectedAddress }) => {
            var _a, _b;
            const { allTokens, allIgnoredTokens } = this.state;
            const { chainId } = this.config;
            this.configure({ selectedAddress });
            this.update({
                tokens: ((_a = allTokens[chainId]) === null || _a === void 0 ? void 0 : _a[selectedAddress]) || [],
                ignoredTokens: ((_b = allIgnoredTokens[chainId]) === null || _b === void 0 ? void 0 : _b[selectedAddress]) || [],
            });
        });
        onNetworkStateChange(({ provider }) => {
            var _a, _b;
            const { allTokens, allIgnoredTokens } = this.state;
            const { selectedAddress } = this.config;
            const { chainId } = provider;
            this.configure({ chainId });
            this.ethersProvider = this._instantiateNewEthersProvider();
            this.update({
                tokens: ((_a = allTokens[chainId]) === null || _a === void 0 ? void 0 : _a[selectedAddress]) || [],
                ignoredTokens: ((_b = allIgnoredTokens[chainId]) === null || _b === void 0 ? void 0 : _b[selectedAddress]) || [],
            });
        });
    }
    failSuggestedAsset(suggestedAssetMeta, error) {
        const failedSuggestedAssetMeta = Object.assign(Object.assign({}, suggestedAssetMeta), { status: SuggestedAssetStatus.failed, error });
        this.hub.emit(`${suggestedAssetMeta.id}:finished`, failedSuggestedAssetMeta);
    }
    _instantiateNewEthersProvider() {
        var _a;
        return new ethers_1.ethers.providers.Web3Provider((_a = this.config) === null || _a === void 0 ? void 0 : _a.provider);
    }
    /**
     * Adds a token to the stored token list.
     *
     * @param address - Hex address of the token contract.
     * @param symbol - Symbol of the token.
     * @param decimals - Number of decimals the token uses.
     * @param image - Image of the token.
     * @returns Current token list.
     */
    addToken(address, symbol, decimals, image) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                address = util_1.toChecksumHexAddress(address);
                const { tokens, ignoredTokens } = this.state;
                const isERC721 = yield this._detectIsERC721(address);
                const newEntry = { address, symbol, decimals, image, isERC721 };
                const previousEntry = tokens.find((token) => token.address.toLowerCase() === address.toLowerCase());
                if (previousEntry) {
                    const previousIndex = tokens.indexOf(previousEntry);
                    tokens[previousIndex] = newEntry;
                }
                else {
                    tokens.push(newEntry);
                }
                const newIgnoredTokens = ignoredTokens.filter((tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase());
                const { newAllTokens, newAllIgnoredTokens } = this._getNewAllTokensState(tokens, newIgnoredTokens);
                this.update({
                    allTokens: newAllTokens,
                    tokens,
                    allIgnoredTokens: newAllIgnoredTokens,
                    ignoredTokens: newIgnoredTokens,
                });
                return tokens;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Adds a batch of tokens to the stored token list.
     *
     * @param tokensToAdd - Array of Tokens to be added or updated.
     * @returns Current token list.
     */
    addTokens(tokensToAdd) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            const { tokens, ignoredTokens } = this.state;
            try {
                tokensToAdd = yield Promise.all(tokensToAdd.map((token) => __awaiter(this, void 0, void 0, function* () {
                    token.isERC721 = yield this._detectIsERC721(token.address);
                    return token;
                })));
                let newIgnoredTokens = ignoredTokens;
                tokensToAdd.forEach((tokenToAdd) => {
                    const { address, symbol, decimals, image, isERC721 } = tokenToAdd;
                    const checksumAddress = util_1.toChecksumHexAddress(address);
                    const newEntry = {
                        address: checksumAddress,
                        symbol,
                        decimals,
                        image,
                        isERC721,
                    };
                    const previousEntry = tokens.find((token) => token.address.toLowerCase() === checksumAddress.toLowerCase());
                    if (previousEntry) {
                        const previousIndex = tokens.indexOf(previousEntry);
                        tokens[previousIndex] = newEntry;
                    }
                    else {
                        tokens.push(newEntry);
                    }
                    newIgnoredTokens = newIgnoredTokens.filter((tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase());
                });
                const { newAllTokens, newAllIgnoredTokens } = this._getNewAllTokensState(tokens, newIgnoredTokens);
                this.update({
                    tokens,
                    allTokens: newAllTokens,
                    allIgnoredTokens: newAllIgnoredTokens,
                    ignoredTokens: newIgnoredTokens,
                });
                return tokens;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Adds isERC721 field to token object. This is called when a user attempts to add tokens that
     * were previously added which do not yet had isERC721 field.
     *
     * @param tokenAddress - The contract address of the token requiring the isERC721 field added.
     * @returns The new token object with the added isERC721 field.
     */
    updateTokenType(tokenAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const isERC721 = yield this._detectIsERC721(tokenAddress);
            const { tokens } = this.state;
            const tokenIndex = tokens.findIndex((token) => {
                return token.address.toLowerCase() === tokenAddress.toLowerCase();
            });
            tokens[tokenIndex].isERC721 = isERC721;
            this.update({ tokens });
            return tokens[tokenIndex];
        });
    }
    /**
     * Detects whether or not a token is ERC-721 compatible.
     *
     * @param tokenAddress - The token contract address.
     * @returns A boolean indicating whether the token address passed in supports the EIP-721
     * interface.
     */
    _detectIsERC721(tokenAddress) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const checksumAddress = util_1.toChecksumHexAddress(tokenAddress);
            // if this token is already in our contract metadata map we don't need
            // to check against the contract
            if (((_a = contract_metadata_1.default[checksumAddress]) === null || _a === void 0 ? void 0 : _a.erc721) === true) {
                return Promise.resolve(true);
            }
            else if (((_b = contract_metadata_1.default[checksumAddress]) === null || _b === void 0 ? void 0 : _b.erc20) === true) {
                return Promise.resolve(false);
            }
            const tokenContract = yield this._createEthersContract(tokenAddress, metamask_eth_abis_1.abiERC721, this.ethersProvider);
            try {
                return yield tokenContract.supportsInterface(constants_1.ERC721_INTERFACE_ID);
            }
            catch (error) {
                // currently we see a variety of errors across different networks when
                // token contracts are not ERC721 compatible. We need to figure out a better
                // way of differentiating token interface types but for now if we get an error
                // we have to assume the token is not ERC721 compatible.
                return false;
            }
        });
    }
    _createEthersContract(tokenAddress, abi, ethersProvider) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenContract = yield new ethers_1.ethers.Contract(tokenAddress, abi, ethersProvider);
            return tokenContract;
        });
    }
    _generateRandomId() {
        return uuid_1.v1();
    }
    /**
     * Adds a new suggestedAsset to state. Parameters will be validated according to
     * asset type being watched. A `<suggestedAssetMeta.id>:pending` hub event will be emitted once added.
     *
     * @param asset - The asset to be watched. For now only ERC20 tokens are accepted.
     * @param type - The asset type.
     * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.
     */
    watchAsset(asset, type) {
        return __awaiter(this, void 0, void 0, function* () {
            const suggestedAssetMeta = {
                asset,
                id: this._generateRandomId(),
                status: SuggestedAssetStatus.pending,
                time: Date.now(),
                type,
            };
            try {
                switch (type) {
                    case 'ERC20':
                        util_1.validateTokenToWatch(asset);
                        break;
                    default:
                        throw new Error(`Asset of type ${type} not supported`);
                }
            }
            catch (error) {
                this.failSuggestedAsset(suggestedAssetMeta, error);
                return Promise.reject(error);
            }
            const result = new Promise((resolve, reject) => {
                this.hub.once(`${suggestedAssetMeta.id}:finished`, (meta) => {
                    switch (meta.status) {
                        case SuggestedAssetStatus.accepted:
                            return resolve(meta.asset.address);
                        case SuggestedAssetStatus.rejected:
                            return reject(new Error('User rejected to watch the asset.'));
                        case SuggestedAssetStatus.failed:
                            return reject(new Error(meta.error.message));
                        /* istanbul ignore next */
                        default:
                            return reject(new Error(`Unknown status: ${meta.status}`));
                    }
                });
            });
            const { suggestedAssets } = this.state;
            suggestedAssets.push(suggestedAssetMeta);
            this.update({ suggestedAssets: [...suggestedAssets] });
            this.hub.emit('pendingSuggestedAsset', suggestedAssetMeta);
            return { result, suggestedAssetMeta };
        });
    }
    /**
     * Accepts to watch an asset and updates it's status and deletes the suggestedAsset from state,
     * adding the asset to corresponding asset state. In this case ERC20 tokens.
     * A `<suggestedAssetMeta.id>:finished` hub event is fired after accepted or failure.
     *
     * @param suggestedAssetID - The ID of the suggestedAsset to accept.
     */
    acceptWatchAsset(suggestedAssetID) {
        return __awaiter(this, void 0, void 0, function* () {
            const { suggestedAssets } = this.state;
            const index = suggestedAssets.findIndex(({ id }) => suggestedAssetID === id);
            const suggestedAssetMeta = suggestedAssets[index];
            try {
                switch (suggestedAssetMeta.type) {
                    case 'ERC20':
                        const { address, symbol, decimals, image } = suggestedAssetMeta.asset;
                        yield this.addToken(address, symbol, decimals, image);
                        suggestedAssetMeta.status = SuggestedAssetStatus.accepted;
                        this.hub.emit(`${suggestedAssetMeta.id}:finished`, suggestedAssetMeta);
                        break;
                    default:
                        throw new Error(`Asset of type ${suggestedAssetMeta.type} not supported`);
                }
            }
            catch (error) {
                this.failSuggestedAsset(suggestedAssetMeta, error);
            }
            const newSuggestedAssets = suggestedAssets.filter(({ id }) => id !== suggestedAssetID);
            this.update({ suggestedAssets: [...newSuggestedAssets] });
        });
    }
    /**
     * Rejects a watchAsset request based on its ID by setting its status to "rejected"
     * and emitting a `<suggestedAssetMeta.id>:finished` hub event.
     *
     * @param suggestedAssetID - The ID of the suggestedAsset to accept.
     */
    rejectWatchAsset(suggestedAssetID) {
        const { suggestedAssets } = this.state;
        const index = suggestedAssets.findIndex(({ id }) => suggestedAssetID === id);
        const suggestedAssetMeta = suggestedAssets[index];
        if (!suggestedAssetMeta) {
            return;
        }
        suggestedAssetMeta.status = SuggestedAssetStatus.rejected;
        this.hub.emit(`${suggestedAssetMeta.id}:finished`, suggestedAssetMeta);
        const newSuggestedAssets = suggestedAssets.filter(({ id }) => id !== suggestedAssetID);
        this.update({ suggestedAssets: [...newSuggestedAssets] });
    }
    /**
     * Removes a token from the stored token list and saves it in ignored tokens list.
     *
     * @param address - The hex address of the token contract.
     */
    removeAndIgnoreToken(address) {
        address = util_1.toChecksumHexAddress(address);
        const { tokens, ignoredTokens } = this.state;
        const alreadyIgnored = ignoredTokens.find((tokenAddress) => tokenAddress.toLowerCase() === address.toLowerCase());
        const newTokens = tokens.filter((token) => {
            if (token.address.toLowerCase() === address.toLowerCase()) {
                !alreadyIgnored && ignoredTokens.push(address);
                return false;
            }
            return true;
        });
        const { newAllTokens, newAllIgnoredTokens } = this._getNewAllTokensState(newTokens, ignoredTokens);
        this.update({
            allTokens: newAllTokens,
            tokens: newTokens,
            allIgnoredTokens: newAllIgnoredTokens,
            ignoredTokens,
        });
    }
    /**
     * Takes a new tokens and ignoredTokens array for the current network/account combination
     * and returns new allTokens and allIgnoredTokens state to update to.
     *
     * @param newTokens - The new tokens to set for the current network and selected account.
     * @param newIgnoredTokens - The new ignored tokens to set for the current network and selected account.
     * @returns The updated `allTokens` and `allIgnoredTokens` state.
     */
    _getNewAllTokensState(newTokens, newIgnoredTokens) {
        const { allTokens, allIgnoredTokens } = this.state;
        const { chainId, selectedAddress } = this.config;
        const networkTokens = allTokens[chainId];
        const networkIgnoredTokens = allIgnoredTokens[chainId];
        const newNetworkTokens = Object.assign(Object.assign({}, networkTokens), { [selectedAddress]: newTokens });
        const newIgnoredNetworkTokens = Object.assign(Object.assign({}, networkIgnoredTokens), { [selectedAddress]: newIgnoredTokens });
        const newAllTokens = Object.assign(Object.assign({}, allTokens), { [chainId]: newNetworkTokens });
        const newAllIgnoredTokens = Object.assign(Object.assign({}, allIgnoredTokens), { [chainId]: newIgnoredNetworkTokens });
        return { newAllTokens, newAllIgnoredTokens };
    }
    /**
     * Removes all tokens from the ignored list.
     */
    clearIgnoredTokens() {
        this.update({ ignoredTokens: [], allIgnoredTokens: {} });
    }
}
exports.TokensController = TokensController;
exports.default = TokensController;
//# sourceMappingURL=TokensController.js.map
      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\assets\\TokensController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\gas\\GasFeeController.js", {"../BaseControllerV2":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\BaseControllerV2.js","../util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\util.js","./determineGasFeeCalculations":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\gas\\determineGasFeeCalculations.js","./fetchGasEstimatesViaEthFeeHistory":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\gas\\fetchGasEstimatesViaEthFeeHistory.js","./gas-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\gas\\gas-util.js","eth-query":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-query\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\index.js","uuid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\gas\GasFeeController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GasFeeController = exports.GAS_ESTIMATE_TYPES = exports.LEGACY_GAS_PRICES_API_URL = void 0;
const eth_query_1 = __importDefault(require("eth-query"));
const uuid_1 = require("uuid");
const ethereumjs_util_1 = require("ethereumjs-util");
const BaseControllerV2_1 = require("../BaseControllerV2");
const util_1 = require("../util");
const gas_util_1 = require("./gas-util");
const determineGasFeeCalculations_1 = __importDefault(require("./determineGasFeeCalculations"));
const fetchGasEstimatesViaEthFeeHistory_1 = __importDefault(require("./fetchGasEstimatesViaEthFeeHistory"));
const GAS_FEE_API = 'https://mock-gas-server.herokuapp.com/';
exports.LEGACY_GAS_PRICES_API_URL = `https://api.metaswap.codefi.network/gasPrices`;
/**
 * Indicates which type of gasEstimate the controller is currently returning.
 * This is useful as a way of asserting that the shape of gasEstimates matches
 * expectations. NONE is a special case indicating that no previous gasEstimate
 * has been fetched.
 */
exports.GAS_ESTIMATE_TYPES = {
    FEE_MARKET: 'fee-market',
    LEGACY: 'legacy',
    ETH_GASPRICE: 'eth_gasPrice',
    NONE: 'none',
};
const metadata = {
    gasFeeEstimates: { persist: true, anonymous: false },
    estimatedGasFeeTimeBounds: { persist: true, anonymous: false },
    gasEstimateType: { persist: true, anonymous: false },
};
const name = 'GasFeeController';
const defaultState = {
    gasFeeEstimates: {},
    estimatedGasFeeTimeBounds: {},
    gasEstimateType: exports.GAS_ESTIMATE_TYPES.NONE,
};
/**
 * Controller that retrieves gas fee estimate data and polls for updated data on a set interval
 */
class GasFeeController extends BaseControllerV2_1.BaseController {
    /**
     * Creates a GasFeeController instance.
     *
     * @param options - The controller options.
     * @param options.interval - The time in milliseconds to wait between polls.
     * @param options.messenger - The controller messenger.
     * @param options.state - The initial state.
     * @param options.getCurrentNetworkEIP1559Compatibility - Determines whether or not the current
     * network is EIP-1559 compatible.
     * @param options.getCurrentNetworkLegacyGasAPICompatibility - Determines whether or not the
     * current network is compatible with the legacy gas price API.
     * @param options.getCurrentAccountEIP1559Compatibility - Determines whether or not the current
     * account is EIP-1559 compatible.
     * @param options.getChainId - Returns the current chain ID.
     * @param options.getProvider - Returns a network provider for the current network.
     * @param options.onNetworkStateChange - A function for registering an event handler for the
     * network state change event.
     * @param options.legacyAPIEndpoint - The legacy gas price API URL. This option is primarily for
     * testing purposes.
     * @param options.EIP1559APIEndpoint - The EIP-1559 gas price API URL. This option is primarily
     * for testing purposes.
     * @param options.clientId - The client ID used to identify to the gas estimation API who is
     * asking for estimates.
     */
    constructor({ interval = 15000, messenger, state, getCurrentNetworkEIP1559Compatibility, getCurrentAccountEIP1559Compatibility, getChainId, getCurrentNetworkLegacyGasAPICompatibility, getProvider, onNetworkStateChange, legacyAPIEndpoint = exports.LEGACY_GAS_PRICES_API_URL, EIP1559APIEndpoint = GAS_FEE_API, clientId, }) {
        super({
            name,
            metadata,
            messenger,
            state: Object.assign(Object.assign({}, defaultState), state),
        });
        this.intervalDelay = interval;
        this.pollTokens = new Set();
        this.getCurrentNetworkEIP1559Compatibility = getCurrentNetworkEIP1559Compatibility;
        this.getCurrentNetworkLegacyGasAPICompatibility = getCurrentNetworkLegacyGasAPICompatibility;
        this.getCurrentAccountEIP1559Compatibility = getCurrentAccountEIP1559Compatibility;
        this.EIP1559APIEndpoint = EIP1559APIEndpoint;
        this.legacyAPIEndpoint = legacyAPIEndpoint;
        this.getChainId = getChainId;
        this.currentChainId = this.getChainId();
        const provider = getProvider();
        this.ethQuery = new eth_query_1.default(provider);
        this.clientId = clientId;
        onNetworkStateChange(() => __awaiter(this, void 0, void 0, function* () {
            const newProvider = getProvider();
            const newChainId = this.getChainId();
            this.ethQuery = new eth_query_1.default(newProvider);
            if (this.currentChainId !== newChainId) {
                this.currentChainId = newChainId;
                yield this.resetPolling();
            }
        }));
    }
    resetPolling() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.pollTokens.size !== 0) {
                const tokens = Array.from(this.pollTokens);
                this.stopPolling();
                yield this.getGasFeeEstimatesAndStartPolling(tokens[0]);
                tokens.slice(1).forEach((token) => {
                    this.pollTokens.add(token);
                });
            }
        });
    }
    fetchGasFeeEstimates(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._fetchGasFeeEstimateData(options);
        });
    }
    getGasFeeEstimatesAndStartPolling(pollToken) {
        return __awaiter(this, void 0, void 0, function* () {
            const _pollToken = pollToken || uuid_1.v1();
            this.pollTokens.add(_pollToken);
            if (this.pollTokens.size === 1) {
                yield this._fetchGasFeeEstimateData();
                this._poll();
            }
            return _pollToken;
        });
    }
    /**
     * Gets and sets gasFeeEstimates in state.
     *
     * @param options - The gas fee estimate options.
     * @param options.shouldUpdateState - Determines whether the state should be updated with the
     * updated gas estimates.
     * @returns The gas fee estimates.
     */
    _fetchGasFeeEstimateData(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { shouldUpdateState = true } = options;
            let isEIP1559Compatible;
            const isLegacyGasAPICompatible = this.getCurrentNetworkLegacyGasAPICompatibility();
            let chainId = this.getChainId();
            if (typeof chainId === 'string' && ethereumjs_util_1.isHexString(chainId)) {
                chainId = parseInt(chainId, 16);
            }
            try {
                isEIP1559Compatible = yield this.getEIP1559Compatibility();
            }
            catch (e) {
                console.error(e);
                isEIP1559Compatible = false;
            }
            const gasFeeCalculations = yield determineGasFeeCalculations_1.default({
                isEIP1559Compatible,
                isLegacyGasAPICompatible,
                fetchGasEstimates: gas_util_1.fetchGasEstimates,
                fetchGasEstimatesUrl: this.EIP1559APIEndpoint.replace('<chain_id>', `${chainId}`),
                fetchGasEstimatesViaEthFeeHistory: fetchGasEstimatesViaEthFeeHistory_1.default,
                fetchLegacyGasPriceEstimates: gas_util_1.fetchLegacyGasPriceEstimates,
                fetchLegacyGasPriceEstimatesUrl: this.legacyAPIEndpoint.replace('<chain_id>', `${chainId}`),
                fetchEthGasPriceEstimate: gas_util_1.fetchEthGasPriceEstimate,
                calculateTimeEstimate: gas_util_1.calculateTimeEstimate,
                clientId: this.clientId,
                ethQuery: this.ethQuery,
            });
            if (shouldUpdateState) {
                this.update((state) => {
                    state.gasFeeEstimates = gasFeeCalculations.gasFeeEstimates;
                    state.estimatedGasFeeTimeBounds =
                        gasFeeCalculations.estimatedGasFeeTimeBounds;
                    state.gasEstimateType = gasFeeCalculations.gasEstimateType;
                });
            }
            return gasFeeCalculations;
        });
    }
    /**
     * Remove the poll token, and stop polling if the set of poll tokens is empty.
     *
     * @param pollToken - The poll token to disconnect.
     */
    disconnectPoller(pollToken) {
        this.pollTokens.delete(pollToken);
        if (this.pollTokens.size === 0) {
            this.stopPolling();
        }
    }
    stopPolling() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
        this.pollTokens.clear();
        this.resetState();
    }
    /**
     * Prepare to discard this controller.
     *
     * This stops any active polling.
     */
    destroy() {
        super.destroy();
        this.stopPolling();
    }
    _poll() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
        this.intervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {
            yield util_1.safelyExecute(() => this._fetchGasFeeEstimateData());
        }), this.intervalDelay);
    }
    resetState() {
        this.update(() => {
            return defaultState;
        });
    }
    getEIP1559Compatibility() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const currentNetworkIsEIP1559Compatible = yield this.getCurrentNetworkEIP1559Compatibility();
            const currentAccountIsEIP1559Compatible = (_b = (_a = this.getCurrentAccountEIP1559Compatibility) === null || _a === void 0 ? void 0 : _a.call(this)) !== null && _b !== void 0 ? _b : true;
            return (currentNetworkIsEIP1559Compatible && currentAccountIsEIP1559Compatible);
        });
    }
    getTimeEstimate(maxPriorityFeePerGas, maxFeePerGas) {
        if (!this.state.gasFeeEstimates ||
            this.state.gasEstimateType !== exports.GAS_ESTIMATE_TYPES.FEE_MARKET) {
            return {};
        }
        return gas_util_1.calculateTimeEstimate(maxPriorityFeePerGas, maxFeePerGas, this.state.gasFeeEstimates);
    }
}
exports.GasFeeController = GasFeeController;
exports.default = GasFeeController;
//# sourceMappingURL=GasFeeController.js.map
      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\gas\\GasFeeController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\util.js", {"./constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\constants.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","eth-ens-namehash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-ens-namehash\\index.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js","eth-sig-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-sig-util\\dist\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\index.js","ethjs-unit":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-unit\\lib\\index.js","jsonschema":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\jsonschema\\lib\\index.js","multiformats/cid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\multiformats\\cjs\\src\\cid.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\util.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFormattedIpfsUrl = exports.addUrlProtocolPrefix = exports.getIpfsCIDv1AndPath = exports.removeIpfsProtocolPrefix = exports.validateMinimumIncrease = exports.isGasPriceValue = exports.isFeeMarketEIP1559Values = exports.validateGasValues = exports.getIncreasedPriceFromExisting = exports.getIncreasedPriceHex = exports.convertPriceToDecimal = exports.isEIP1559Transaction = exports.query = exports.normalizeEnsName = exports.timeoutFetch = exports.handleFetch = exports.successfulFetch = exports.isSmartContractCode = exports.validateTokenToWatch = exports.validateTypedSignMessageDataV3 = exports.validateTypedSignMessageDataV1 = exports.validateSignMessageData = exports.normalizeMessageData = exports.validateTransaction = exports.isValidHexAddress = exports.toChecksumHexAddress = exports.safelyExecuteWithTimeout = exports.safelyExecute = exports.normalizeTransaction = exports.toHex = exports.fromHex = exports.hexToText = exports.hexToBN = exports.handleTransactionFetch = exports.getEtherscanApiUrl = exports.getBuyURL = exports.weiHexToGweiDec = exports.gweiDecToWEIBN = exports.fractionBN = exports.BNToHex = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
const ethjs_unit_1 = require("ethjs-unit");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const eth_ens_namehash_1 = __importDefault(require("eth-ens-namehash"));
const eth_sig_util_1 = require("eth-sig-util");
const jsonschema_1 = require("jsonschema");
const cid_1 = require("multiformats/cid");
const constants_1 = require("./constants");
const hexRe = /^[0-9A-Fa-f]+$/gu;
const NORMALIZERS = {
    data: (data) => ethereumjs_util_1.addHexPrefix(data),
    from: (from) => ethereumjs_util_1.addHexPrefix(from).toLowerCase(),
    gas: (gas) => ethereumjs_util_1.addHexPrefix(gas),
    gasPrice: (gasPrice) => ethereumjs_util_1.addHexPrefix(gasPrice),
    nonce: (nonce) => ethereumjs_util_1.addHexPrefix(nonce),
    to: (to) => ethereumjs_util_1.addHexPrefix(to).toLowerCase(),
    value: (value) => ethereumjs_util_1.addHexPrefix(value),
    maxFeePerGas: (maxFeePerGas) => ethereumjs_util_1.addHexPrefix(maxFeePerGas),
    maxPriorityFeePerGas: (maxPriorityFeePerGas) => ethereumjs_util_1.addHexPrefix(maxPriorityFeePerGas),
    estimatedBaseFee: (maxPriorityFeePerGas) => ethereumjs_util_1.addHexPrefix(maxPriorityFeePerGas),
};
/**
 * Converts a BN object to a hex string with a '0x' prefix.
 *
 * @param inputBn - BN instance to convert to a hex string.
 * @returns A '0x'-prefixed hex string.
 */
function BNToHex(inputBn) {
    return ethereumjs_util_1.addHexPrefix(inputBn.toString(16));
}
exports.BNToHex = BNToHex;
/**
 * Used to multiply a BN by a fraction.
 *
 * @param targetBN - Number to multiply by a fraction.
 * @param numerator - Numerator of the fraction multiplier.
 * @param denominator - Denominator of the fraction multiplier.
 * @returns Product of the multiplication.
 */
function fractionBN(targetBN, numerator, denominator) {
    const numBN = new ethereumjs_util_1.BN(numerator);
    const denomBN = new ethereumjs_util_1.BN(denominator);
    return targetBN.mul(numBN).div(denomBN);
}
exports.fractionBN = fractionBN;
/**
 * Used to convert a base-10 number from GWEI to WEI. Can handle numbers with decimal parts.
 *
 * @param n - The base 10 number to convert to WEI.
 * @returns The number in WEI, as a BN.
 */
function gweiDecToWEIBN(n) {
    if (Number.isNaN(n)) {
        return new ethereumjs_util_1.BN(0);
    }
    const parts = n.toString().split('.');
    const wholePart = parts[0] || '0';
    let decimalPart = parts[1] || '';
    if (!decimalPart) {
        return ethjs_unit_1.toWei(wholePart, 'gwei');
    }
    if (decimalPart.length <= 9) {
        return ethjs_unit_1.toWei(`${wholePart}.${decimalPart}`, 'gwei');
    }
    const decimalPartToRemove = decimalPart.slice(9);
    const decimalRoundingDigit = decimalPartToRemove[0];
    decimalPart = decimalPart.slice(0, 9);
    let wei = ethjs_unit_1.toWei(`${wholePart}.${decimalPart}`, 'gwei');
    if (Number(decimalRoundingDigit) >= 5) {
        wei = wei.add(new ethereumjs_util_1.BN(1));
    }
    return wei;
}
exports.gweiDecToWEIBN = gweiDecToWEIBN;
/**
 * Used to convert values from wei hex format to dec gwei format.
 *
 * @param hex - The value in hex wei.
 * @returns The value in dec gwei as string.
 */
function weiHexToGweiDec(hex) {
    const hexWei = new ethereumjs_util_1.BN(ethereumjs_util_1.stripHexPrefix(hex), 16);
    return ethjs_unit_1.fromWei(hexWei, 'gwei').toString(10);
}
exports.weiHexToGweiDec = weiHexToGweiDec;
/**
 * Return a URL that can be used to obtain ETH for a given network.
 *
 * @param networkCode - Network code of desired network.
 * @param address - Address to deposit obtained ETH.
 * @param amount - How much ETH is desired.
 * @returns URL to buy ETH based on network.
 */
function getBuyURL(networkCode = '1', address, amount = 5) {
    switch (networkCode) {
        case '1':
            return `https://buy.coinbase.com/?code=9ec56d01-7e81-5017-930c-513daa27bb6a&amount=${amount}&address=${address}&crypto_currency=ETH`;
        case '3':
            return 'https://faucet.metamask.io/';
        case '4':
            return 'https://www.rinkeby.io/';
        case '5':
            return 'https://goerli-faucet.slock.it/';
        case '42':
            return 'https://github.com/kovan-testnet/faucet';
        default:
            return undefined;
    }
}
exports.getBuyURL = getBuyURL;
/**
 * Return a URL that can be used to fetch ETH transactions.
 *
 * @param networkType - Network type of desired network.
 * @param urlParams - The parameters used to construct the URL.
 * @returns URL to fetch the access the endpoint.
 */
function getEtherscanApiUrl(networkType, urlParams) {
    let etherscanSubdomain = 'api';
    if (networkType !== constants_1.MAINNET) {
        etherscanSubdomain = `api-${networkType}`;
    }
    const apiUrl = `https://${etherscanSubdomain}.etherscan.io`;
    let url = `${apiUrl}/api?`;
    for (const paramKey in urlParams) {
        if (urlParams[paramKey]) {
            url += `${paramKey}=${urlParams[paramKey]}&`;
        }
    }
    url += 'tag=latest&page=1';
    return url;
}
exports.getEtherscanApiUrl = getEtherscanApiUrl;
/**
 * Handles the fetch of incoming transactions.
 *
 * @param networkType - Network type of desired network.
 * @param address - Address to get the transactions from.
 * @param txHistoryLimit - The maximum number of transactions to fetch.
 * @param opt - Object that can contain fromBlock and Etherscan service API key.
 * @returns Responses for both ETH and ERC20 token transactions.
 */
function handleTransactionFetch(networkType, address, txHistoryLimit, opt) {
    return __awaiter(this, void 0, void 0, function* () {
        // transactions
        const urlParams = {
            module: 'account',
            address,
            startBlock: opt === null || opt === void 0 ? void 0 : opt.fromBlock,
            apikey: opt === null || opt === void 0 ? void 0 : opt.etherscanApiKey,
            offset: txHistoryLimit.toString(),
            order: 'desc',
        };
        const etherscanTxUrl = getEtherscanApiUrl(networkType, Object.assign(Object.assign({}, urlParams), { action: 'txlist' }));
        const etherscanTxResponsePromise = handleFetch(etherscanTxUrl);
        // tokens
        const etherscanTokenUrl = getEtherscanApiUrl(networkType, Object.assign(Object.assign({}, urlParams), { action: 'tokentx' }));
        const etherscanTokenResponsePromise = handleFetch(etherscanTokenUrl);
        let [etherscanTxResponse, etherscanTokenResponse] = yield Promise.all([
            etherscanTxResponsePromise,
            etherscanTokenResponsePromise,
        ]);
        if (etherscanTxResponse.status === '0' ||
            etherscanTxResponse.result.length <= 0) {
            etherscanTxResponse = { status: etherscanTxResponse.status, result: [] };
        }
        if (etherscanTokenResponse.status === '0' ||
            etherscanTokenResponse.result.length <= 0) {
            etherscanTokenResponse = {
                status: etherscanTokenResponse.status,
                result: [],
            };
        }
        return [etherscanTxResponse, etherscanTokenResponse];
    });
}
exports.handleTransactionFetch = handleTransactionFetch;
/**
 * Converts a hex string to a BN object.
 *
 * @param inputHex - Number represented as a hex string.
 * @returns A BN instance.
 */
function hexToBN(inputHex) {
    return new ethereumjs_util_1.BN(ethereumjs_util_1.stripHexPrefix(inputHex), 16);
}
exports.hexToBN = hexToBN;
/**
 * A helper function that converts hex data to human readable string.
 *
 * @param hex - The hex string to convert to string.
 * @returns A human readable string conversion.
 */
function hexToText(hex) {
    try {
        const stripped = ethereumjs_util_1.stripHexPrefix(hex);
        const buff = Buffer.from(stripped, 'hex');
        return buff.toString('utf8');
    }
    catch (e) {
        /* istanbul ignore next */
        return hex;
    }
}
exports.hexToText = hexToText;
/**
 * Parses a hex string and converts it into a number that can be operated on in a bignum-safe,
 * base-10 way.
 *
 * @param value - A base-16 number encoded as a string.
 * @returns The number as a BN object in base-16 mode.
 */
function fromHex(value) {
    if (ethereumjs_util_1.BN.isBN(value)) {
        return value;
    }
    return new ethereumjs_util_1.BN(hexToBN(value).toString(10));
}
exports.fromHex = fromHex;
/**
 * Converts an integer to a hexadecimal representation.
 *
 * @param value - An integer, an integer encoded as a base-10 string, or a BN.
 * @returns The integer encoded as a hex string.
 */
function toHex(value) {
    if (typeof value === 'string' && ethereumjs_util_1.isHexString(value)) {
        return value;
    }
    const hexString = ethereumjs_util_1.BN.isBN(value)
        ? value.toString(16)
        : new ethereumjs_util_1.BN(value.toString(), 10).toString(16);
    return `0x${hexString}`;
}
exports.toHex = toHex;
/**
 * Normalizes properties on a Transaction object.
 *
 * @param transaction - Transaction object to normalize.
 * @returns Normalized Transaction object.
 */
function normalizeTransaction(transaction) {
    const normalizedTransaction = { from: '' };
    let key;
    for (key in NORMALIZERS) {
        if (transaction[key]) {
            normalizedTransaction[key] = NORMALIZERS[key](transaction[key]);
        }
    }
    return normalizedTransaction;
}
exports.normalizeTransaction = normalizeTransaction;
/**
 * Execute and return an asynchronous operation without throwing errors.
 *
 * @param operation - Function returning a Promise.
 * @param logError - Determines if the error should be logged.
 * @param retry - Function called if an error is caught.
 * @returns Promise resolving to the result of the async operation.
 */
function safelyExecute(operation, logError = false, retry) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield operation();
        }
        catch (error) {
            /* istanbul ignore next */
            if (logError) {
                console.error(error);
            }
            retry === null || retry === void 0 ? void 0 : retry(error);
            return undefined;
        }
    });
}
exports.safelyExecute = safelyExecute;
/**
 * Execute and return an asynchronous operation with a timeout.
 *
 * @param operation - Function returning a Promise.
 * @param logError - Determines if the error should be logged.
 * @param timeout - Timeout to fail the operation.
 * @returns Promise resolving to the result of the async operation.
 */
function safelyExecuteWithTimeout(operation, logError = false, timeout = 500) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield Promise.race([
                operation(),
                new Promise((_, reject) => setTimeout(() => {
                    reject(new Error('timeout'));
                }, timeout)),
            ]);
        }
        catch (error) {
            /* istanbul ignore next */
            if (logError) {
                console.error(error);
            }
            return undefined;
        }
    });
}
exports.safelyExecuteWithTimeout = safelyExecuteWithTimeout;
/**
 * Convert an address to a checksummed hexidecimal address.
 *
 * @param address - The address to convert.
 * @returns A 0x-prefixed hexidecimal checksummed address.
 */
function toChecksumHexAddress(address) {
    const hexPrefixed = ethereumjs_util_1.addHexPrefix(address);
    if (!ethereumjs_util_1.isHexString(hexPrefixed)) {
        // Version 5.1 of ethereumjs-utils would have returned '0xY' for input 'y'
        // but we shouldn't waste effort trying to change case on a clearly invalid
        // string. Instead just return the hex prefixed original string which most
        // closely mimics the original behavior.
        return hexPrefixed;
    }
    return ethereumjs_util_1.toChecksumAddress(hexPrefixed);
}
exports.toChecksumHexAddress = toChecksumHexAddress;
/**
 * Validates that the input is a hex address. This utility method is a thin
 * wrapper around ethereumjs-util.isValidAddress, with the exception that it
 * does not throw an error when provided values that are not hex strings. In
 * addition, and by default, this method will return true for hex strings that
 * meet the length requirement of a hex address, but are not prefixed with `0x`
 * Finally, if the mixedCaseUseChecksum flag is true and a mixed case string is
 * provided this method will validate it has the proper checksum formatting.
 *
 * @param possibleAddress - Input parameter to check against.
 * @param options - The validation options.
 * @param options.allowNonPrefixed - If true will first ensure '0x' is prepended to the string.
 * @returns Whether or not the input is a valid hex address.
 */
function isValidHexAddress(possibleAddress, { allowNonPrefixed = true } = {}) {
    const addressToCheck = allowNonPrefixed
        ? ethereumjs_util_1.addHexPrefix(possibleAddress)
        : possibleAddress;
    if (!ethereumjs_util_1.isHexString(addressToCheck)) {
        return false;
    }
    return ethereumjs_util_1.isValidAddress(addressToCheck);
}
exports.isValidHexAddress = isValidHexAddress;
/**
 * Validates a Transaction object for required properties and throws in
 * the event of any validation error.
 *
 * @param transaction - Transaction object to validate.
 */
function validateTransaction(transaction) {
    if (!transaction.from ||
        typeof transaction.from !== 'string' ||
        !isValidHexAddress(transaction.from)) {
        throw new Error(`Invalid "from" address: ${transaction.from} must be a valid string.`);
    }
    if (transaction.to === '0x' || transaction.to === undefined) {
        if (transaction.data) {
            delete transaction.to;
        }
        else {
            throw new Error(`Invalid "to" address: ${transaction.to} must be a valid string.`);
        }
    }
    else if (transaction.to !== undefined &&
        !isValidHexAddress(transaction.to)) {
        throw new Error(`Invalid "to" address: ${transaction.to} must be a valid string.`);
    }
    if (transaction.value !== undefined) {
        const value = transaction.value.toString();
        if (value.includes('-')) {
            throw new Error(`Invalid "value": ${value} is not a positive number.`);
        }
        if (value.includes('.')) {
            throw new Error(`Invalid "value": ${value} number must be denominated in wei.`);
        }
        const intValue = parseInt(transaction.value, 10);
        const isValid = Number.isFinite(intValue) &&
            !Number.isNaN(intValue) &&
            !isNaN(Number(value)) &&
            Number.isSafeInteger(intValue);
        if (!isValid) {
            throw new Error(`Invalid "value": ${value} number must be a valid number.`);
        }
    }
}
exports.validateTransaction = validateTransaction;
/**
 * A helper function that converts rawmessageData buffer data to a hex, or just returns the data if
 * it is already formatted as a hex.
 *
 * @param data - The buffer data to convert to a hex.
 * @returns A hex string conversion of the buffer data.
 */
function normalizeMessageData(data) {
    try {
        const stripped = ethereumjs_util_1.stripHexPrefix(data);
        if (stripped.match(hexRe)) {
            return ethereumjs_util_1.addHexPrefix(stripped);
        }
    }
    catch (e) {
        /* istanbul ignore next */
    }
    return ethereumjs_util_1.bufferToHex(Buffer.from(data, 'utf8'));
}
exports.normalizeMessageData = normalizeMessageData;
/**
 * Validates a PersonalMessageParams and MessageParams objects for required properties and throws in
 * the event of any validation error.
 *
 * @param messageData - PersonalMessageParams object to validate.
 */
function validateSignMessageData(messageData) {
    const { from, data } = messageData;
    if (!from || typeof from !== 'string' || !isValidHexAddress(from)) {
        throw new Error(`Invalid "from" address: ${from} must be a valid string.`);
    }
    if (!data || typeof data !== 'string') {
        throw new Error(`Invalid message "data": ${data} must be a valid string.`);
    }
}
exports.validateSignMessageData = validateSignMessageData;
/**
 * Validates a TypedMessageParams object for required properties and throws in
 * the event of any validation error for eth_signTypedMessage_V1.
 *
 * @param messageData - TypedMessageParams object to validate.
 */
function validateTypedSignMessageDataV1(messageData) {
    if (!messageData.from ||
        typeof messageData.from !== 'string' ||
        !isValidHexAddress(messageData.from)) {
        throw new Error(`Invalid "from" address: ${messageData.from} must be a valid string.`);
    }
    if (!messageData.data || !Array.isArray(messageData.data)) {
        throw new Error(`Invalid message "data": ${messageData.data} must be a valid array.`);
    }
    try {
        // typedSignatureHash will throw if the data is invalid.
        eth_sig_util_1.typedSignatureHash(messageData.data);
    }
    catch (e) {
        throw new Error(`Expected EIP712 typed data.`);
    }
}
exports.validateTypedSignMessageDataV1 = validateTypedSignMessageDataV1;
/**
 * Validates a TypedMessageParams object for required properties and throws in
 * the event of any validation error for eth_signTypedMessage_V3.
 *
 * @param messageData - TypedMessageParams object to validate.
 */
function validateTypedSignMessageDataV3(messageData) {
    if (!messageData.from ||
        typeof messageData.from !== 'string' ||
        !isValidHexAddress(messageData.from)) {
        throw new Error(`Invalid "from" address: ${messageData.from} must be a valid string.`);
    }
    if (!messageData.data || typeof messageData.data !== 'string') {
        throw new Error(`Invalid message "data": ${messageData.data} must be a valid array.`);
    }
    let data;
    try {
        data = JSON.parse(messageData.data);
    }
    catch (e) {
        throw new Error('Data must be passed as a valid JSON string.');
    }
    const validation = jsonschema_1.validate(data, eth_sig_util_1.TYPED_MESSAGE_SCHEMA);
    if (validation.errors.length > 0) {
        throw new Error('Data must conform to EIP-712 schema. See https://git.io/fNtcx.');
    }
}
exports.validateTypedSignMessageDataV3 = validateTypedSignMessageDataV3;
/**
 * Validates a ERC20 token to be added with EIP747.
 *
 * @param token - Token object to validate.
 */
function validateTokenToWatch(token) {
    const { address, symbol, decimals } = token;
    if (!address || !symbol || typeof decimals === 'undefined') {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Must specify address, symbol, and decimals.`);
    }
    if (typeof symbol !== 'string') {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Invalid symbol: not a string.`);
    }
    if (symbol.length > 11) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Invalid symbol "${symbol}": longer than 11 characters.`);
    }
    const numDecimals = parseInt(decimals, 10);
    if (isNaN(numDecimals) || numDecimals > 36 || numDecimals < 0) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Invalid decimals "${decimals}": must be 0 <= 36.`);
    }
    if (!isValidHexAddress(address)) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Invalid address "${address}".`);
    }
}
exports.validateTokenToWatch = validateTokenToWatch;
/**
 * Returns whether the given code corresponds to a smart contract.
 *
 * @param code - The potential smart contract code.
 * @returns Whether the code was smart contract code or not.
 */
function isSmartContractCode(code) {
    /* istanbul ignore if */
    if (!code) {
        return false;
    }
    // Geth will return '0x', and ganache-core v2.2.1 will return '0x0'
    const smartContractCode = code !== '0x' && code !== '0x0';
    return smartContractCode;
}
exports.isSmartContractCode = isSmartContractCode;
/**
 * Execute fetch and verify that the response was successful.
 *
 * @param request - Request information.
 * @param options - Fetch options.
 * @returns The fetch response.
 */
function successfulFetch(request, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield fetch(request, options);
        if (!response.ok) {
            throw new Error(`Fetch failed with status '${response.status}' for request '${request}'`);
        }
        return response;
    });
}
exports.successfulFetch = successfulFetch;
/**
 * Execute fetch and return object response.
 *
 * @param request - The request information.
 * @param options - The fetch options.
 * @returns The fetch response JSON data.
 */
function handleFetch(request, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield successfulFetch(request, options);
        const object = yield response.json();
        return object;
    });
}
exports.handleFetch = handleFetch;
/**
 * Fetch that fails after timeout.
 *
 * @param url - Url to fetch.
 * @param options - Options to send with the request.
 * @param timeout - Timeout to fail request.
 * @returns Promise resolving the request.
 */
function timeoutFetch(url, options, timeout = 500) {
    return __awaiter(this, void 0, void 0, function* () {
        return Promise.race([
            successfulFetch(url, options),
            new Promise((_, reject) => setTimeout(() => {
                reject(new Error('timeout'));
            }, timeout)),
        ]);
    });
}
exports.timeoutFetch = timeoutFetch;
/**
 * Normalizes the given ENS name.
 *
 * @param ensName - The ENS name.
 * @returns The normalized ENS name string.
 */
function normalizeEnsName(ensName) {
    if (ensName && typeof ensName === 'string') {
        try {
            const normalized = eth_ens_namehash_1.default.normalize(ensName.trim());
            // this regex is only sufficient with the above call to ensNamehash.normalize
            // TODO: change 7 in regex to 3 when shorter ENS domains are live
            if (normalized.match(/^(([\w\d-]+)\.)*[\w\d-]{7,}\.(eth|test)$/u)) {
                return normalized;
            }
        }
        catch (_) {
            // do nothing
        }
    }
    return null;
}
exports.normalizeEnsName = normalizeEnsName;
/**
 * Wrapper method to handle EthQuery requests.
 *
 * @param ethQuery - EthQuery object initialized with a provider.
 * @param method - Method to request.
 * @param args - Arguments to send.
 * @returns Promise resolving the request.
 */
function query(ethQuery, method, args = []) {
    return new Promise((resolve, reject) => {
        const cb = (error, result) => {
            if (error) {
                reject(error);
                return;
            }
            resolve(result);
        };
        if (typeof ethQuery[method] === 'function') {
            ethQuery[method](...args, cb);
        }
        else {
            ethQuery.sendAsync({ method, params: args }, cb);
        }
    });
}
exports.query = query;
/**
 * Checks if a transaction is EIP-1559 by checking for the existence of
 * maxFeePerGas and maxPriorityFeePerGas within its parameters.
 *
 * @param transaction - Transaction object to add.
 * @returns Boolean that is true if the transaction is EIP-1559 (has maxFeePerGas and maxPriorityFeePerGas), otherwise returns false.
 */
const isEIP1559Transaction = (transaction) => {
    const hasOwnProp = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
    return (hasOwnProp(transaction, 'maxFeePerGas') &&
        hasOwnProp(transaction, 'maxPriorityFeePerGas'));
};
exports.isEIP1559Transaction = isEIP1559Transaction;
const convertPriceToDecimal = (value) => parseInt(value === undefined ? '0x0' : value, 16);
exports.convertPriceToDecimal = convertPriceToDecimal;
const getIncreasedPriceHex = (value, rate) => ethereumjs_util_1.addHexPrefix(`${parseInt(`${value * rate}`, 10).toString(16)}`);
exports.getIncreasedPriceHex = getIncreasedPriceHex;
const getIncreasedPriceFromExisting = (value, rate) => {
    return exports.getIncreasedPriceHex(exports.convertPriceToDecimal(value), rate);
};
exports.getIncreasedPriceFromExisting = getIncreasedPriceFromExisting;
const validateGasValues = (gasValues) => {
    Object.keys(gasValues).forEach((key) => {
        const value = gasValues[key];
        if (typeof value !== 'string' || !ethereumjs_util_1.isHexString(value)) {
            throw new TypeError(`expected hex string for ${key} but received: ${value}`);
        }
    });
};
exports.validateGasValues = validateGasValues;
const isFeeMarketEIP1559Values = (gasValues) => {
    var _a, _b;
    return ((_a = gasValues) === null || _a === void 0 ? void 0 : _a.maxFeePerGas) !== undefined ||
        ((_b = gasValues) === null || _b === void 0 ? void 0 : _b.maxPriorityFeePerGas) !== undefined;
};
exports.isFeeMarketEIP1559Values = isFeeMarketEIP1559Values;
const isGasPriceValue = (gasValues) => { var _a; return ((_a = gasValues) === null || _a === void 0 ? void 0 : _a.gasPrice) !== undefined; };
exports.isGasPriceValue = isGasPriceValue;
/**
 * Validates that the proposed value is greater than or equal to the minimum value.
 *
 * @param proposed - The proposed value.
 * @param min - The minimum value.
 * @returns The proposed value.
 * @throws Will throw if the proposed value is too low.
 */
function validateMinimumIncrease(proposed, min) {
    const proposedDecimal = exports.convertPriceToDecimal(proposed);
    const minDecimal = exports.convertPriceToDecimal(min);
    if (proposedDecimal >= minDecimal) {
        return proposed;
    }
    const errorMsg = `The proposed value: ${proposedDecimal} should meet or exceed the minimum value: ${minDecimal}`;
    throw new Error(errorMsg);
}
exports.validateMinimumIncrease = validateMinimumIncrease;
/**
 * Removes IPFS protocol prefix from input string.
 *
 * @param ipfsUrl - An IPFS url (e.g. ipfs://{content id})
 * @returns IPFS content identifier and (possibly) path in a string
 * @throws Will throw if the url passed is not IPFS.
 */
function removeIpfsProtocolPrefix(ipfsUrl) {
    if (ipfsUrl.startsWith('ipfs://ipfs/')) {
        return ipfsUrl.replace('ipfs://ipfs/', '');
    }
    else if (ipfsUrl.startsWith('ipfs://')) {
        return ipfsUrl.replace('ipfs://', '');
    }
    // this method should not be used with non-ipfs urls (i.e. startsWith('ipfs://') === true)
    throw new Error('this method should not be used with non ipfs urls');
}
exports.removeIpfsProtocolPrefix = removeIpfsProtocolPrefix;
/**
 * Extracts content identifier and path from an input string.
 *
 * @param ipfsUrl - An IPFS URL minus the IPFS protocol prefix
 * @returns IFPS content identifier (cid) and sub path as string.
 * @throws Will throw if the url passed is not ipfs.
 */
function getIpfsCIDv1AndPath(ipfsUrl) {
    const url = removeIpfsProtocolPrefix(ipfsUrl);
    // check if there is a path
    // (CID is everything preceding first forward slash, path is everything after)
    const index = url.indexOf('/');
    const cid = index !== -1 ? url.substring(0, index) : url;
    const path = index !== -1 ? url.substring(index) : undefined;
    // We want to ensure that the CID is v1 (https://docs.ipfs.io/concepts/content-addressing/#identifier-formats)
    // because most cid v0s appear to be incompatible with IPFS subdomains
    return {
        cid: cid_1.CID.parse(cid).toV1().toString(),
        path,
    };
}
exports.getIpfsCIDv1AndPath = getIpfsCIDv1AndPath;
/**
 * Adds URL protocol prefix to input URL string if missing.
 *
 * @param urlString - An IPFS URL.
 * @returns A URL with a https:// prepended.
 */
function addUrlProtocolPrefix(urlString) {
    if (!urlString.match(/(^http:\/\/)|(^https:\/\/)/u)) {
        return `https://${urlString}`;
    }
    return urlString;
}
exports.addUrlProtocolPrefix = addUrlProtocolPrefix;
/**
 * Formats URL correctly for use retrieving assets hosted on IPFS.
 *
 * @param ipfsGateway - The users preferred IPFS gateway (full URL or just host).
 * @param ipfsUrl - The IFPS URL pointed at the asset.
 * @param subdomainSupported - Boolean indicating whether the URL should be formatted with subdomains or not.
 * @returns A formatted URL, with the user's preferred IPFS gateway and format (subdomain or not), pointing to an asset hosted on IPFS.
 */
function getFormattedIpfsUrl(ipfsGateway, ipfsUrl, subdomainSupported) {
    const { host, protocol, origin } = new URL(addUrlProtocolPrefix(ipfsGateway));
    if (subdomainSupported) {
        const { cid, path } = getIpfsCIDv1AndPath(ipfsUrl);
        return `${protocol}//${cid}.ipfs.${host}${path !== null && path !== void 0 ? path : ''}`;
    }
    const cidAndPath = removeIpfsProtocolPrefix(ipfsUrl);
    return `${origin}/ipfs/${cidAndPath}`;
}
exports.getFormattedIpfsUrl = getFormattedIpfsUrl;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\util.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\third-party\\PhishingController.js", {"../BaseController":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\util.js","eth-phishing-detect/src/config.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-phishing-detect\\src\\config.json","eth-phishing-detect/src/detector":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-phishing-detect\\src\\detector.js","punycode/":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\punycode\\punycode.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\third-party\PhishingController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PhishingController = void 0;
const punycode_1 = require("punycode/");
const config_json_1 = __importDefault(require("eth-phishing-detect/src/config.json"));
const detector_1 = __importDefault(require("eth-phishing-detect/src/detector"));
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
/**
 * Controller that passively polls on a set interval for approved and unapproved website origins
 */
class PhishingController extends BaseController_1.BaseController {
    /**
     * Creates a PhishingController instance.
     *
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor(config, state) {
        super(config, state);
        this.configUrl = 'https://cdn.jsdelivr.net/gh/MetaMask/eth-phishing-detect@master/src/config.json';
        /**
         * Name of this controller used during composition
         */
        this.name = 'PhishingController';
        this.defaultConfig = { interval: 60 * 60 * 1000 };
        this.defaultState = {
            phishing: config_json_1.default,
            whitelist: [],
        };
        this.detector = new detector_1.default(this.defaultState.phishing);
        this.initialize();
        this.poll();
    }
    /**
     * Starts a new polling interval.
     *
     * @param interval - Polling interval used to fetch new approval lists.
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield util_1.safelyExecute(() => this.updatePhishingLists());
            this.handle = setTimeout(() => {
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
    /**
     * Determines if a given origin is unapproved.
     *
     * @param origin - Domain origin of a website.
     * @returns Whether the origin is an unapproved origin.
     */
    test(origin) {
        const punycodeOrigin = punycode_1.toASCII(origin);
        if (this.state.whitelist.indexOf(punycodeOrigin) !== -1) {
            return false;
        }
        return this.detector.check(punycodeOrigin).result;
    }
    /**
     * Temporarily marks a given origin as approved.
     *
     * @param origin - The origin to mark as approved.
     */
    bypass(origin) {
        const punycodeOrigin = punycode_1.toASCII(origin);
        const { whitelist } = this.state;
        if (whitelist.indexOf(punycodeOrigin) !== -1) {
            return;
        }
        this.update({ whitelist: [...whitelist, punycodeOrigin] });
    }
    /**
     * Updates lists of approved and unapproved website origins.
     */
    updatePhishingLists() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.disabled) {
                return;
            }
            const phishingOpts = yield this.queryConfig(this.configUrl);
            if (phishingOpts) {
                this.detector = new detector_1.default(phishingOpts);
                this.update({
                    phishing: phishingOpts,
                });
            }
        });
    }
    queryConfig(input) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield fetch(input, { cache: 'no-cache' });
            switch (response.status) {
                case 200: {
                    return yield response.json();
                }
                case 304:
                case 403: {
                    return null;
                }
                default: {
                    throw new Error(`Fetch failed with status '${response.status}' for request '${input}'`);
                }
            }
        });
    }
}
exports.PhishingController = PhishingController;
exports.default = PhishingController;
//# sourceMappingURL=PhishingController.js.map
      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\third-party\\PhishingController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\keyring\\KeyringController.js", {"../BaseController":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\util.js","async-mutex":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async-mutex\\lib\\index.js","eth-keyring-controller":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-keyring-controller\\index.js","eth-sig-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-sig-util\\dist\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\index.js","ethereumjs-wallet":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\node_modules\\ethereumjs-wallet\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\keyring\KeyringController.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyringController = exports.SignTypedDataVersion = exports.AccountImportStrategy = exports.KeyringTypes = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
const eth_sig_util_1 = require("eth-sig-util");
const ethereumjs_wallet_1 = __importStar(require("ethereumjs-wallet"));
const eth_keyring_controller_1 = __importDefault(require("eth-keyring-controller"));
const async_mutex_1 = require("async-mutex");
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const privates = new WeakMap();
/**
 * Available keyring types
 */
var KeyringTypes;
(function (KeyringTypes) {
    KeyringTypes["simple"] = "Simple Key Pair";
    KeyringTypes["hd"] = "HD Key Tree";
})(KeyringTypes = exports.KeyringTypes || (exports.KeyringTypes = {}));
/**
 * A strategy for importing an account
 */
var AccountImportStrategy;
(function (AccountImportStrategy) {
    AccountImportStrategy["privateKey"] = "privateKey";
    AccountImportStrategy["json"] = "json";
})(AccountImportStrategy = exports.AccountImportStrategy || (exports.AccountImportStrategy = {}));
/**
 * The `signTypedMessage` version
 *
 * @see https://docs.metamask.io/guide/signing-data.html
 */
var SignTypedDataVersion;
(function (SignTypedDataVersion) {
    SignTypedDataVersion["V1"] = "V1";
    SignTypedDataVersion["V3"] = "V3";
    SignTypedDataVersion["V4"] = "V4";
})(SignTypedDataVersion = exports.SignTypedDataVersion || (exports.SignTypedDataVersion = {}));
/**
 * Controller responsible for establishing and managing user identity
 */
class KeyringController extends BaseController_1.BaseController {
    /**
     * Creates a KeyringController instance.
     *
     * @param options - The controller options.
     * @param options.removeIdentity - Remove the identity with the given address.
     * @param options.syncIdentities - Sync identities with the given list of addresses.
     * @param options.updateIdentities - Generate an identity for each address given that doesn't already have an identity.
     * @param options.setSelectedAddress - Set the selected address.
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor({ removeIdentity, syncIdentities, updateIdentities, setSelectedAddress, }, config, state) {
        super(config, state);
        this.mutex = new async_mutex_1.Mutex();
        /**
         * Name of this controller used during composition
         */
        this.name = 'KeyringController';
        privates.set(this, {
            keyring: new eth_keyring_controller_1.default(Object.assign({ initState: state }, config)),
        });
        this.defaultState = Object.assign(Object.assign({}, privates.get(this).keyring.store.getState()), { keyrings: [] });
        this.removeIdentity = removeIdentity;
        this.syncIdentities = syncIdentities;
        this.updateIdentities = updateIdentities;
        this.setSelectedAddress = setSelectedAddress;
        this.initialize();
        this.fullUpdate();
    }
    /**
     * Adds a new account to the default (first) HD seed phrase keyring.
     *
     * @returns Promise resolving to current state when the account is added.
     */
    addNewAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            const primaryKeyring = privates
                .get(this)
                .keyring.getKeyringsByType('HD Key Tree')[0];
            /* istanbul ignore if */
            if (!primaryKeyring) {
                throw new Error('No HD keyring found');
            }
            const oldAccounts = yield privates.get(this).keyring.getAccounts();
            yield privates.get(this).keyring.addNewAccount(primaryKeyring);
            const newAccounts = yield privates.get(this).keyring.getAccounts();
            yield this.verifySeedPhrase();
            this.updateIdentities(newAccounts);
            newAccounts.forEach((selectedAddress) => {
                if (!oldAccounts.includes(selectedAddress)) {
                    this.setSelectedAddress(selectedAddress);
                }
            });
            return this.fullUpdate();
        });
    }
    /**
     * Adds a new account to the default (first) HD seed phrase keyring without updating identities in preferences.
     *
     * @returns Promise resolving to current state when the account is added.
     */
    addNewAccountWithoutUpdate() {
        return __awaiter(this, void 0, void 0, function* () {
            const primaryKeyring = privates
                .get(this)
                .keyring.getKeyringsByType('HD Key Tree')[0];
            /* istanbul ignore if */
            if (!primaryKeyring) {
                throw new Error('No HD keyring found');
            }
            yield privates.get(this).keyring.addNewAccount(primaryKeyring);
            yield this.verifySeedPhrase();
            return this.fullUpdate();
        });
    }
    /**
     * Effectively the same as creating a new keychain then populating it
     * using the given seed phrase.
     *
     * @param password - Password to unlock keychain.
     * @param seed - Seed phrase to restore keychain.
     * @returns Promise resolving to th restored keychain object.
     */
    createNewVaultAndRestore(password, seed) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                this.updateIdentities([]);
                const vault = yield privates
                    .get(this)
                    .keyring.createNewVaultAndRestore(password, seed);
                this.updateIdentities(yield privates.get(this).keyring.getAccounts());
                this.fullUpdate();
                return vault;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Create a new primary keychain and wipe any previous keychains.
     *
     * @param password - Password to unlock the new vault.
     * @returns Newly-created keychain object.
     */
    createNewVaultAndKeychain(password) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                const vault = yield privates
                    .get(this)
                    .keyring.createNewVaultAndKeychain(password);
                this.updateIdentities(yield privates.get(this).keyring.getAccounts());
                this.fullUpdate();
                return vault;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Returns the status of the vault.
     *
     * @returns Boolean returning true if the vault is unlocked.
     */
    isUnlocked() {
        return privates.get(this).keyring.memStore.getState().isUnlocked;
    }
    /**
     * Gets the seed phrase of the HD keyring.
     *
     * @param password - Password of the keyring.
     * @returns Promise resolving to the seed phrase.
     */
    exportSeedPhrase(password) {
        if (privates.get(this).keyring.password === password) {
            return privates.get(this).keyring.keyrings[0].mnemonic;
        }
        throw new Error('Invalid password');
    }
    /**
     * Gets the private key from the keyring controlling an address.
     *
     * @param password - Password of the keyring.
     * @param address - Address to export.
     * @returns Promise resolving to the private key for an address.
     */
    exportAccount(password, address) {
        if (privates.get(this).keyring.password === password) {
            return privates.get(this).keyring.exportAccount(address);
        }
        throw new Error('Invalid password');
    }
    /**
     * Returns the public addresses of all accounts for the current keyring.
     *
     * @returns A promise resolving to an array of addresses.
     */
    getAccounts() {
        return privates.get(this).keyring.getAccounts();
    }
    /**
     * Imports an account with the specified import strategy.
     *
     * @param strategy - Import strategy name.
     * @param args - Array of arguments to pass to the underlying stategy.
     * @throws Will throw when passed an unrecognized strategy.
     * @returns Promise resolving to current state when the import is complete.
     */
    importAccountWithStrategy(strategy, args) {
        return __awaiter(this, void 0, void 0, function* () {
            let privateKey;
            switch (strategy) {
                case 'privateKey':
                    const [importedKey] = args;
                    if (!importedKey) {
                        throw new Error('Cannot import an empty key.');
                    }
                    const prefixed = ethereumjs_util_1.addHexPrefix(importedKey);
                    /* istanbul ignore if */
                    if (!ethereumjs_util_1.isValidPrivate(ethereumjs_util_1.toBuffer(prefixed))) {
                        throw new Error('Cannot import invalid private key.');
                    }
                    privateKey = ethereumjs_util_1.stripHexPrefix(prefixed);
                    break;
                case 'json':
                    let wallet;
                    const [input, password] = args;
                    try {
                        wallet = ethereumjs_wallet_1.thirdparty.fromEtherWallet(input, password);
                    }
                    catch (e) {
                        wallet = wallet || (yield ethereumjs_wallet_1.default.fromV3(input, password, true));
                    }
                    privateKey = ethereumjs_util_1.bufferToHex(wallet.getPrivateKey());
                    break;
                default:
                    throw new Error(`Unexpected import strategy: '${strategy}'`);
            }
            const newKeyring = yield privates
                .get(this)
                .keyring.addNewKeyring(KeyringTypes.simple, [privateKey]);
            const accounts = yield newKeyring.getAccounts();
            const allAccounts = yield privates.get(this).keyring.getAccounts();
            this.updateIdentities(allAccounts);
            this.setSelectedAddress(accounts[0]);
            return this.fullUpdate();
        });
    }
    /**
     * Removes an account from keyring state.
     *
     * @param address - Address of the account to remove.
     * @returns Promise resolving current state when this account removal completes.
     */
    removeAccount(address) {
        return __awaiter(this, void 0, void 0, function* () {
            this.removeIdentity(address);
            yield privates.get(this).keyring.removeAccount(address);
            return this.fullUpdate();
        });
    }
    /**
     * Deallocates all secrets and locks the wallet.
     *
     * @returns Promise resolving to current state.
     */
    setLocked() {
        return privates.get(this).keyring.setLocked();
    }
    /**
     * Signs message by calling down into a specific keyring.
     *
     * @param messageParams - PersonalMessageParams object to sign.
     * @returns Promise resolving to a signed message string.
     */
    signMessage(messageParams) {
        return privates.get(this).keyring.signMessage(messageParams);
    }
    /**
     * Signs personal message by calling down into a specific keyring.
     *
     * @param messageParams - PersonalMessageParams object to sign.
     * @returns Promise resolving to a signed message string.
     */
    signPersonalMessage(messageParams) {
        return privates.get(this).keyring.signPersonalMessage(messageParams);
    }
    /**
     * Signs typed message by calling down into a specific keyring.
     *
     * @param messageParams - TypedMessageParams object to sign.
     * @param version - Compatibility version EIP712.
     * @throws Will throw when passed an unrecognized version.
     * @returns Promise resolving to a signed message string or an error if any.
     */
    signTypedMessage(messageParams, version) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const address = eth_sig_util_1.normalize(messageParams.from);
                const { password } = privates.get(this).keyring;
                const privateKey = yield this.exportAccount(password, address);
                const privateKeyBuffer = ethereumjs_util_1.toBuffer(ethereumjs_util_1.addHexPrefix(privateKey));
                switch (version) {
                    case SignTypedDataVersion.V1:
                        // signTypedDataLegacy will throw if the data is invalid.
                        return eth_sig_util_1.signTypedDataLegacy(privateKeyBuffer, {
                            data: messageParams.data,
                        });
                    case SignTypedDataVersion.V3:
                        return eth_sig_util_1.signTypedData(privateKeyBuffer, {
                            data: JSON.parse(messageParams.data),
                        });
                    case SignTypedDataVersion.V4:
                        return eth_sig_util_1.signTypedData_v4(privateKeyBuffer, {
                            data: JSON.parse(messageParams.data),
                        });
                    default:
                        throw new Error(`Unexpected signTypedMessage version: '${version}'`);
                }
            }
            catch (error) {
                throw new Error(`Keyring Controller signTypedMessage: ${error}`);
            }
        });
    }
    /**
     * Signs a transaction by calling down into a specific keyring.
     *
     * @param transaction - Transaction object to sign. Must be a `ethereumjs-tx` transaction instance.
     * @param from - Address to sign from, should be in keychain.
     * @returns Promise resolving to a signed transaction string.
     */
    signTransaction(transaction, from) {
        return privates.get(this).keyring.signTransaction(transaction, from);
    }
    /**
     * Attempts to decrypt the current vault and load its keyrings.
     *
     * @param password - Password to unlock the keychain.
     * @returns Promise resolving to the current state.
     */
    submitPassword(password) {
        return __awaiter(this, void 0, void 0, function* () {
            yield privates.get(this).keyring.submitPassword(password);
            const accounts = yield privates.get(this).keyring.getAccounts();
            yield this.syncIdentities(accounts);
            return this.fullUpdate();
        });
    }
    /**
     * Adds new listener to be notified of state changes.
     *
     * @param listener - Callback triggered when state changes.
     */
    subscribe(listener) {
        privates.get(this).keyring.store.subscribe(listener);
    }
    /**
     * Removes existing listener from receiving state changes.
     *
     * @param listener - Callback to remove.
     * @returns True if a listener is found and unsubscribed.
     */
    unsubscribe(listener) {
        return privates.get(this).keyring.store.unsubscribe(listener);
    }
    /**
     * Adds new listener to be notified when the wallet is locked.
     *
     * @param listener - Callback triggered when wallet is locked.
     * @returns EventEmitter if listener added.
     */
    onLock(listener) {
        return privates.get(this).keyring.on('lock', listener);
    }
    /**
     * Adds new listener to be notified when the wallet is unlocked.
     *
     * @param listener - Callback triggered when wallet is unlocked.
     * @returns EventEmitter if listener added.
     */
    onUnlock(listener) {
        return privates.get(this).keyring.on('unlock', listener);
    }
    /**
     * Verifies the that the seed phrase restores the current keychain's accounts.
     *
     * @returns Whether the verification succeeds.
     */
    verifySeedPhrase() {
        return __awaiter(this, void 0, void 0, function* () {
            const primaryKeyring = privates
                .get(this)
                .keyring.getKeyringsByType(KeyringTypes.hd)[0];
            /* istanbul ignore if */
            if (!primaryKeyring) {
                throw new Error('No HD keyring found.');
            }
            const seedWords = (yield primaryKeyring.serialize()).mnemonic;
            const accounts = yield primaryKeyring.getAccounts();
            /* istanbul ignore if */
            if (accounts.length === 0) {
                throw new Error('Cannot verify an empty keyring.');
            }
            const TestKeyringClass = privates
                .get(this)
                .keyring.getKeyringClassForType(KeyringTypes.hd);
            const testKeyring = new TestKeyringClass({
                mnemonic: seedWords,
                numberOfAccounts: accounts.length,
            });
            const testAccounts = yield testKeyring.getAccounts();
            /* istanbul ignore if */
            if (testAccounts.length !== accounts.length) {
                throw new Error('Seed phrase imported incorrect number of accounts.');
            }
            testAccounts.forEach((account, i) => {
                /* istanbul ignore if */
                if (account.toLowerCase() !== accounts[i].toLowerCase()) {
                    throw new Error('Seed phrase imported different accounts.');
                }
            });
            return seedWords;
        });
    }
    /**
     * Update keyrings in state and calls KeyringController fullUpdate method returning current state.
     *
     * @returns The current state.
     */
    fullUpdate() {
        return __awaiter(this, void 0, void 0, function* () {
            const keyrings = yield Promise.all(privates.get(this).keyring.keyrings.map((keyring, index) => __awaiter(this, void 0, void 0, function* () {
                const keyringAccounts = yield keyring.getAccounts();
                const accounts = Array.isArray(keyringAccounts)
                    ? keyringAccounts.map((address) => util_1.toChecksumHexAddress(address))
                    : /* istanbul ignore next */ [];
                return {
                    accounts,
                    index,
                    type: keyring.type,
                };
            })));
            this.update({ keyrings: [...keyrings] });
            return privates.get(this).keyring.fullUpdate();
        });
    }
}
exports.KeyringController = KeyringController;
exports.default = KeyringController;
//# sourceMappingURL=KeyringController.js.map
      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\keyring\\KeyringController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\assets\\AssetsContractController.js", {"../BaseController":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","./Standards/CollectibleStandards/ERC1155/ERC1155Standard":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\assets\\Standards\\CollectibleStandards\\ERC1155\\ERC1155Standard.js","./Standards/CollectibleStandards/ERC721/ERC721Standard":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\assets\\Standards\\CollectibleStandards\\ERC721\\ERC721Standard.js","./Standards/ERC20Standard":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\assets\\Standards\\ERC20Standard.js","single-call-balance-checker-abi":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\single-call-balance-checker-abi\\index.js","web3":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\assets\AssetsContractController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AssetsContractController = void 0;
const web3_1 = __importDefault(require("web3"));
const single_call_balance_checker_abi_1 = __importDefault(require("single-call-balance-checker-abi"));
const BaseController_1 = require("../BaseController");
const ERC721Standard_1 = require("./Standards/CollectibleStandards/ERC721/ERC721Standard");
const ERC1155Standard_1 = require("./Standards/CollectibleStandards/ERC1155/ERC1155Standard");
const ERC20Standard_1 = require("./Standards/ERC20Standard");
const SINGLE_CALL_BALANCES_ADDRESS = '0xb1f8e55c7f64d203c1400b9d8555d050f94adf39';
const MISSING_PROVIDER_ERROR = 'AssetsContractController failed to set the provider correctly. A provider must be set for this method to be available';
/**
 * Controller that interacts with contracts on mainnet through web3
 */
class AssetsContractController extends BaseController_1.BaseController {
    /**
     * Creates a AssetsContractController instance.
     *
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor(config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'AssetsContractController';
        this.defaultConfig = {
            provider: undefined,
        };
        this.initialize();
    }
    /**
     * Sets a new provider.
     *
     * TODO: Replace this wth a method.
     *
     * @property provider - Provider used to create a new underlying Web3 instance
     */
    set provider(provider) {
        this.web3 = new web3_1.default(provider);
        this.erc721Standard = new ERC721Standard_1.ERC721Standard(this.web3);
        this.erc1155Standard = new ERC1155Standard_1.ERC1155Standard(this.web3);
        this.erc20Standard = new ERC20Standard_1.ERC20Standard(this.web3);
    }
    get provider() {
        throw new Error('Property only used for setting');
    }
    /**
     * Get balance or count for current account on specific asset contract.
     *
     * @param address - Asset ERC20 contract address.
     * @param selectedAddress - Current account public address.
     * @returns Promise resolving to BN object containing balance for current account on specific asset contract.
     */
    getERC20BalanceOf(address, selectedAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.erc20Standard) {
                throw new Error(MISSING_PROVIDER_ERROR);
            }
            return this.erc20Standard.getBalanceOf(address, selectedAddress);
        });
    }
    /**
     * Query for the decimals for a given ERC20 asset.
     *
     * @param address - ERC20 asset contract address.
     * @returns Promise resolving to the 'decimals'.
     */
    getERC20TokenDecimals(address) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.erc20Standard === undefined) {
                throw new Error(MISSING_PROVIDER_ERROR);
            }
            return yield this.erc20Standard.getTokenDecimals(address);
        });
    }
    /**
     * Enumerate assets assigned to an owner.
     *
     * @param address - ERC721 asset contract address.
     * @param selectedAddress - Current account public address.
     * @param index - A collectible counter less than `balanceOf(selectedAddress)`.
     * @returns Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'.
     */
    getERC721CollectibleTokenId(address, selectedAddress, index) {
        if (this.erc721Standard === undefined) {
            throw new Error(MISSING_PROVIDER_ERROR);
        }
        return this.erc721Standard.getCollectibleTokenId(address, selectedAddress, index);
    }
    /**
     * Enumerate assets assigned to an owner.
     *
     * @param tokenAddress - ERC721 asset contract address.
     * @param userAddress - Current account public address.
     * @param tokenId - ERC721 asset identifier.
     * @returns Promise resolving to an object containing the token standard and a set of details which depend on which standard the token supports.
     */
    getTokenStandardAndDetails(tokenAddress, userAddress, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.erc721Standard === undefined ||
                this.erc1155Standard === undefined ||
                this.erc20Standard === undefined) {
                throw new Error(MISSING_PROVIDER_ERROR);
            }
            // ERC721
            try {
                return Object.assign({}, (yield this.erc721Standard.getDetails(tokenAddress, tokenId)));
            }
            catch (_a) {
                // Ignore
            }
            // ERC1155
            try {
                return Object.assign({}, (yield this.erc1155Standard.getDetails(tokenAddress, tokenId)));
            }
            catch (_b) {
                // Ignore
            }
            // ERC20
            try {
                return Object.assign({}, (yield this.erc20Standard.getDetails(tokenAddress, userAddress)));
            }
            catch (_c) {
                // Ignore
            }
            throw new Error('Unable to determine contract standard');
        });
    }
    /**
     * Query for tokenURI for a given ERC721 asset.
     *
     * @param address - ERC721 asset contract address.
     * @param tokenId - ERC721 asset identifier.
     * @returns Promise resolving to the 'tokenURI'.
     */
    getERC721TokenURI(address, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.erc721Standard === undefined) {
                throw new Error(MISSING_PROVIDER_ERROR);
            }
            return this.erc721Standard.getTokenURI(address, tokenId);
        });
    }
    /**
     * Query for name for a given asset.
     *
     * @param address - ERC721 or ERC20 asset contract address.
     * @returns Promise resolving to the 'name'.
     */
    getERC721AssetName(address) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.erc721Standard === undefined) {
                throw new Error(MISSING_PROVIDER_ERROR);
            }
            return this.erc721Standard.getAssetName(address);
        });
    }
    /**
     * Query for symbol for a given asset.
     *
     * @param address - ERC721 or ERC20 asset contract address.
     * @returns Promise resolving to the 'symbol'.
     */
    getERC721AssetSymbol(address) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.erc721Standard === undefined) {
                throw new Error(MISSING_PROVIDER_ERROR);
            }
            return this.erc721Standard.getAssetSymbol(address);
        });
    }
    /**
     * Query for owner for a given ERC721 asset.
     *
     * @param address - ERC721 asset contract address.
     * @param tokenId - ERC721 asset identifier.
     * @returns Promise resolving to the owner address.
     */
    getERC721OwnerOf(address, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.erc721Standard === undefined) {
                throw new Error(MISSING_PROVIDER_ERROR);
            }
            return this.erc721Standard.getOwnerOf(address, tokenId);
        });
    }
    /**
     * Query for tokenURI for a given asset.
     *
     * @param address - ERC1155 asset contract address.
     * @param tokenId - ERC1155 asset identifier.
     * @returns Promise resolving to the 'tokenURI'.
     */
    getERC1155TokenURI(address, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.erc1155Standard === undefined) {
                throw new Error(MISSING_PROVIDER_ERROR);
            }
            return this.erc1155Standard.getTokenURI(address, tokenId);
        });
    }
    /**
     * Query for balance of a given ERC 1155 token.
     *
     * @param userAddress - Wallet public address.
     * @param collectibleAddress - ERC1155 asset contract address.
     * @param collectibleId - ERC1155 asset identifier.
     * @returns Promise resolving to the 'balanceOf'.
     */
    getERC1155BalanceOf(userAddress, collectibleAddress, collectibleId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.erc1155Standard === undefined) {
                throw new Error(MISSING_PROVIDER_ERROR);
            }
            return yield this.erc1155Standard.getBalanceOf(collectibleAddress, userAddress, collectibleId);
        });
    }
    /**
     * Transfer single ERC1155 token.
     *
     * @param collectibleAddress - ERC1155 token address.
     * @param senderAddress - ERC1155 token sender.
     * @param recipientAddress - ERC1155 token recipient.
     * @param collectibleId - ERC1155 token id.
     * @param qty - Quantity of tokens to be sent.
     * @returns Promise resolving to the 'transferSingle' ERC1155 token.
     */
    transferSingleERC1155(collectibleAddress, senderAddress, recipientAddress, collectibleId, qty) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.erc1155Standard === undefined) {
                throw new Error(MISSING_PROVIDER_ERROR);
            }
            return yield this.erc1155Standard.transferSingle(collectibleAddress, senderAddress, recipientAddress, collectibleId, qty);
        });
    }
    /**
     * Get the token balance for a list of token addresses in a single call. Only non-zero balances
     * are returned.
     *
     * @param selectedAddress - The address to check token balances for.
     * @param tokensToDetect - The token addresses to detect balances for.
     * @returns The list of non-zero token balances.
     */
    getBalancesInSingleCall(selectedAddress, tokensToDetect) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth
                .contract(single_call_balance_checker_abi_1.default)
                .at(SINGLE_CALL_BALANCES_ADDRESS);
            return new Promise((resolve, reject) => {
                contract.balances([selectedAddress], tokensToDetect, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    const nonZeroBalances = {};
                    /* istanbul ignore else */
                    if (result.length > 0) {
                        tokensToDetect.forEach((tokenAddress, index) => {
                            const balance = result[index];
                            /* istanbul ignore else */
                            if (!balance.isZero()) {
                                nonZeroBalances[tokenAddress] = balance;
                            }
                        });
                    }
                    resolve(nonZeroBalances);
                });
            });
        });
    }
}
exports.AssetsContractController = AssetsContractController;
exports.default = AssetsContractController;
//# sourceMappingURL=AssetsContractController.js.map
      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\assets\\AssetsContractController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\network\\NetworkController.js", {"../BaseController":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\constants.js","async-mutex":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async-mutex\\lib\\index.js","eth-json-rpc-infura/src/createProvider":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-infura\\src\\createProvider.js","eth-query":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-query\\index.js","web3-provider-engine/subproviders/provider":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3-provider-engine\\subproviders\\provider.js","web3-provider-engine/zero":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3-provider-engine\\zero.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\network\NetworkController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkController = exports.NetworksChainId = void 0;
const eth_query_1 = __importDefault(require("eth-query"));
const provider_1 = __importDefault(require("web3-provider-engine/subproviders/provider"));
const createProvider_1 = __importDefault(require("eth-json-rpc-infura/src/createProvider"));
const zero_1 = __importDefault(require("web3-provider-engine/zero"));
const async_mutex_1 = require("async-mutex");
const BaseController_1 = require("../BaseController");
const constants_1 = require("../constants");
var NetworksChainId;
(function (NetworksChainId) {
    NetworksChainId["mainnet"] = "1";
    NetworksChainId["kovan"] = "42";
    NetworksChainId["rinkeby"] = "4";
    NetworksChainId["goerli"] = "5";
    NetworksChainId["ropsten"] = "3";
    NetworksChainId["localhost"] = "";
    NetworksChainId["rpc"] = "";
    NetworksChainId["optimism"] = "10";
    NetworksChainId["optimismTest"] = "69";
})(NetworksChainId = exports.NetworksChainId || (exports.NetworksChainId = {}));
const LOCALHOST_RPC_URL = 'http://localhost:8545';
/**
 * Controller that creates and manages an Ethereum network provider
 */
class NetworkController extends BaseController_1.BaseController {
    /**
     * Creates a NetworkController instance.
     *
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor(config, state) {
        super(config, state);
        this.internalProviderConfig = {};
        this.mutex = new async_mutex_1.Mutex();
        /**
         * Name of this controller used during composition
         */
        this.name = 'NetworkController';
        this.defaultState = {
            network: 'loading',
            isCustomNetwork: false,
            provider: { type: constants_1.MAINNET, chainId: NetworksChainId.mainnet },
            properties: { isEIP1559Compatible: false },
        };
        this.initialize();
        this.getEIP1559Compatibility();
    }
    initializeProvider(type, rpcTarget, chainId, ticker, nickname) {
        this.update({ isCustomNetwork: this.getIsCustomNetwork(chainId) });
        switch (type) {
            case 'kovan':
            case constants_1.MAINNET:
            case 'rinkeby':
            case 'goerli':
            case 'optimism':
            case 'optimismTest':
            case 'ropsten':
                this.setupInfuraProvider(type);
                break;
            case 'localhost':
                this.setupStandardProvider(LOCALHOST_RPC_URL);
                break;
            case constants_1.RPC:
                rpcTarget &&
                    this.setupStandardProvider(rpcTarget, chainId, ticker, nickname);
                break;
            default:
                throw new Error(`Unrecognized network type: '${type}'`);
        }
    }
    refreshNetwork() {
        this.update({ network: 'loading', properties: {} });
        const { rpcTarget, type, chainId, ticker } = this.state.provider;
        this.initializeProvider(type, rpcTarget, chainId, ticker);
        this.lookupNetwork();
    }
    registerProvider() {
        this.provider.on('error', this.verifyNetwork.bind(this));
        this.ethQuery = new eth_query_1.default(this.provider);
    }
    setupInfuraProvider(type) {
        const infuraProvider = createProvider_1.default({
            network: type,
            projectId: this.config.infuraProjectId,
        });
        const infuraSubprovider = new provider_1.default(infuraProvider);
        const config = Object.assign(Object.assign({}, this.internalProviderConfig), {
            dataSubprovider: infuraSubprovider,
            engineParams: {
                blockTrackerProvider: infuraProvider,
                pollingInterval: 12000,
            },
        });
        this.updateProvider(zero_1.default(config));
    }
    getIsCustomNetwork(chainId) {
        return (chainId !== NetworksChainId.mainnet &&
            chainId !== NetworksChainId.kovan &&
            chainId !== NetworksChainId.rinkeby &&
            chainId !== NetworksChainId.goerli &&
            chainId !== NetworksChainId.ropsten &&
            chainId !== NetworksChainId.localhost);
    }
    setupStandardProvider(rpcTarget, chainId, ticker, nickname) {
        const config = Object.assign(Object.assign({}, this.internalProviderConfig), {
            chainId,
            engineParams: { pollingInterval: 12000 },
            nickname,
            rpcUrl: rpcTarget,
            ticker,
        });
        this.updateProvider(zero_1.default(config));
    }
    updateProvider(provider) {
        this.safelyStopProvider(this.provider);
        this.provider = provider;
        this.registerProvider();
    }
    safelyStopProvider(provider) {
        setTimeout(() => {
            provider === null || provider === void 0 ? void 0 : provider.stop();
        }, 500);
    }
    verifyNetwork() {
        this.state.network === 'loading' && this.lookupNetwork();
    }
    /**
     * Sets a new configuration for web3-provider-engine.
     *
     * TODO: Replace this wth a method.
     *
     * @param providerConfig - The web3-provider-engine configuration.
     */
    set providerConfig(providerConfig) {
        this.internalProviderConfig = providerConfig;
        const { type, rpcTarget, chainId, ticker, nickname } = this.state.provider;
        this.initializeProvider(type, rpcTarget, chainId, ticker, nickname);
        this.registerProvider();
        this.lookupNetwork();
    }
    get providerConfig() {
        throw new Error('Property only used for setting');
    }
    /**
     * Refreshes the current network code.
     */
    lookupNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore if */
            if (!this.ethQuery || !this.ethQuery.sendAsync) {
                return;
            }
            const releaseLock = yield this.mutex.acquire();
            this.ethQuery.sendAsync({ method: 'net_version' }, (error, network) => {
                this.update({
                    network: error ? /* istanbul ignore next*/ 'loading' : network,
                });
                releaseLock();
            });
        });
    }
    /**
     * Convenience method to update provider network type settings.
     *
     * @param type - Human readable network name.
     */
    setProviderType(type) {
        const _a = this.state.provider, { rpcTarget, chainId, nickname } = _a, providerState = __rest(_a, ["rpcTarget", "chainId", "nickname"]);
        this.update({
            provider: Object.assign(Object.assign({}, providerState), { type, ticker: 'ETH', chainId: NetworksChainId[type] }),
        });
        this.refreshNetwork();
    }
    /**
     * Convenience method to update provider RPC settings.
     *
     * @param rpcTarget - The RPC endpoint URL.
     * @param chainId - The chain ID as per EIP-155.
     * @param ticker - The currency ticker.
     * @param nickname - Personalized network name.
     */
    setRpcTarget(rpcTarget, chainId, ticker, nickname) {
        this.update({
            provider: Object.assign(Object.assign({}, this.state.provider), { type: constants_1.RPC, ticker, rpcTarget, chainId, nickname }),
        });
        this.refreshNetwork();
    }
    getEIP1559Compatibility() {
        var _a;
        const { properties = {} } = this.state;
        if (!properties.isEIP1559Compatible) {
            if (typeof ((_a = this.ethQuery) === null || _a === void 0 ? void 0 : _a.sendAsync) !== 'function') {
                return Promise.resolve(true);
            }
            return new Promise((resolve, reject) => {
                this.ethQuery.sendAsync({ method: 'eth_getBlockByNumber', params: ['latest', false] }, (error, block) => {
                    if (error) {
                        reject(error);
                    }
                    else {
                        const isEIP1559Compatible = typeof block.baseFeePerGas !== 'undefined';
                        if (properties.isEIP1559Compatible !== isEIP1559Compatible) {
                            this.update({
                                properties: {
                                    isEIP1559Compatible,
                                },
                            });
                        }
                        resolve(isEIP1559Compatible);
                    }
                });
            });
        }
        return Promise.resolve(true);
    }
}
exports.NetworkController = NetworkController;
exports.default = NetworkController;
//# sourceMappingURL=NetworkController.js.map
      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\network\\NetworkController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\transaction\\TransactionController.js", {"../BaseController":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\constants.js","../util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\util.js","@ethereumjs/common":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethereumjs\\common\\dist.browser\\index.js","@ethereumjs/tx":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethereumjs\\tx\\dist.browser\\index.js","async-mutex":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\async-mutex\\lib\\index.js","eth-method-registry":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\node_modules\\eth-method-registry\\index.js","eth-query":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-query\\index.js","eth-rpc-errors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-rpc-errors\\dist\\index.js","ethereumjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-util\\dist.browser\\index.js","events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js","uuid":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\controllers\dist\transaction\TransactionController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionController = exports.SPEED_UP_RATE = exports.CANCEL_RATE = exports.WalletDevice = exports.TransactionStatus = void 0;
const events_1 = require("events");
const ethereumjs_util_1 = require("ethereumjs-util");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const eth_method_registry_1 = __importDefault(require("eth-method-registry"));
const eth_query_1 = __importDefault(require("eth-query"));
const common_1 = __importDefault(require("@ethereumjs/common"));
const tx_1 = require("@ethereumjs/tx");
const uuid_1 = require("uuid");
const async_mutex_1 = require("async-mutex");
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const constants_1 = require("../constants");
const HARDFORK = 'london';
/**
 * The status of the transaction. Each status represents the state of the transaction internally
 * in the wallet. Some of these correspond with the state of the transaction on the network, but
 * some are wallet-specific.
 */
var TransactionStatus;
(function (TransactionStatus) {
    TransactionStatus["approved"] = "approved";
    TransactionStatus["cancelled"] = "cancelled";
    TransactionStatus["confirmed"] = "confirmed";
    TransactionStatus["failed"] = "failed";
    TransactionStatus["rejected"] = "rejected";
    TransactionStatus["signed"] = "signed";
    TransactionStatus["submitted"] = "submitted";
    TransactionStatus["unapproved"] = "unapproved";
})(TransactionStatus = exports.TransactionStatus || (exports.TransactionStatus = {}));
/**
 * Options for wallet device.
 */
var WalletDevice;
(function (WalletDevice) {
    WalletDevice["MM_MOBILE"] = "metamask_mobile";
    WalletDevice["MM_EXTENSION"] = "metamask_extension";
    WalletDevice["OTHER"] = "other_device";
})(WalletDevice = exports.WalletDevice || (exports.WalletDevice = {}));
/**
 * Multiplier used to determine a transaction's increased gas fee during cancellation
 */
exports.CANCEL_RATE = 1.5;
/**
 * Multiplier used to determine a transaction's increased gas fee during speed up
 */
exports.SPEED_UP_RATE = 1.1;
/**
 * Controller responsible for submitting and managing transactions
 */
class TransactionController extends BaseController_1.BaseController {
    /**
     * Creates a TransactionController instance.
     *
     * @param options - The controller options.
     * @param options.getNetworkState - Gets the state of the network controller.
     * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
     * @param options.getProvider - Returns a provider for the current network.
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor({ getNetworkState, onNetworkStateChange, getProvider, }, config, state) {
        super(config, state);
        this.mutex = new async_mutex_1.Mutex();
        this.normalizeTokenTx = (txMeta, currentNetworkID, currentChainId) => {
            const time = parseInt(txMeta.timeStamp, 10) * 1000;
            const { to, from, gas, gasPrice, gasUsed, hash, contractAddress, tokenDecimal, tokenSymbol, value, } = txMeta;
            return {
                id: uuid_1.v1({ msecs: time }),
                isTransfer: true,
                networkID: currentNetworkID,
                chainId: currentChainId,
                status: TransactionStatus.confirmed,
                time,
                transaction: {
                    chainId: 1,
                    from,
                    gas,
                    gasPrice,
                    gasUsed,
                    to,
                    value,
                },
                transactionHash: hash,
                transferInformation: {
                    contractAddress,
                    decimals: Number(tokenDecimal),
                    symbol: tokenSymbol,
                },
                verifiedOnBlockchain: false,
            };
        };
        /**
         * EventEmitter instance used to listen to specific transactional events
         */
        this.hub = new events_1.EventEmitter();
        /**
         * Name of this controller used during composition
         */
        this.name = 'TransactionController';
        this.defaultConfig = {
            interval: 15000,
            txHistoryLimit: 40,
        };
        this.defaultState = {
            methodData: {},
            transactions: [],
        };
        this.initialize();
        const provider = getProvider();
        this.getNetworkState = getNetworkState;
        this.ethQuery = new eth_query_1.default(provider);
        this.registry = new eth_method_registry_1.default({ provider });
        onNetworkStateChange(() => {
            const newProvider = getProvider();
            this.ethQuery = new eth_query_1.default(newProvider);
            this.registry = new eth_method_registry_1.default({ provider: newProvider });
        });
        this.poll();
    }
    failTransaction(transactionMeta, error) {
        const newTransactionMeta = Object.assign(Object.assign({}, transactionMeta), { error, status: TransactionStatus.failed });
        this.updateTransaction(newTransactionMeta);
        this.hub.emit(`${transactionMeta.id}:finished`, newTransactionMeta);
    }
    registryLookup(fourBytePrefix) {
        return __awaiter(this, void 0, void 0, function* () {
            const registryMethod = yield this.registry.lookup(fourBytePrefix);
            const parsedRegistryMethod = this.registry.parse(registryMethod);
            return { registryMethod, parsedRegistryMethod };
        });
    }
    /**
     * Normalizes the transaction information from etherscan
     * to be compatible with the TransactionMeta interface.
     *
     * @param txMeta - The transaction.
     * @param currentNetworkID - The current network ID.
     * @param currentChainId - The current chain ID.
     * @returns The normalized transaction.
     */
    normalizeTx(txMeta, currentNetworkID, currentChainId) {
        const time = parseInt(txMeta.timeStamp, 10) * 1000;
        const normalizedTransactionBase = {
            blockNumber: txMeta.blockNumber,
            id: uuid_1.v1({ msecs: time }),
            networkID: currentNetworkID,
            chainId: currentChainId,
            time,
            transaction: {
                data: txMeta.input,
                from: txMeta.from,
                gas: util_1.BNToHex(new ethereumjs_util_1.BN(txMeta.gas)),
                gasPrice: util_1.BNToHex(new ethereumjs_util_1.BN(txMeta.gasPrice)),
                gasUsed: util_1.BNToHex(new ethereumjs_util_1.BN(txMeta.gasUsed)),
                nonce: util_1.BNToHex(new ethereumjs_util_1.BN(txMeta.nonce)),
                to: txMeta.to,
                value: util_1.BNToHex(new ethereumjs_util_1.BN(txMeta.value)),
            },
            transactionHash: txMeta.hash,
            verifiedOnBlockchain: false,
        };
        /* istanbul ignore else */
        if (txMeta.isError === '0') {
            return Object.assign(Object.assign({}, normalizedTransactionBase), { status: TransactionStatus.confirmed });
        }
        /* istanbul ignore next */
        return Object.assign(Object.assign({}, normalizedTransactionBase), { error: new Error('Transaction failed'), status: TransactionStatus.failed });
    }
    /**
     * Starts a new polling interval.
     *
     * @param interval - The polling interval used to fetch new transaction statuses.
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield util_1.safelyExecute(() => this.queryTransactionStatuses());
            this.handle = setTimeout(() => {
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
    /**
     * Handle new method data request.
     *
     * @param fourBytePrefix - The method prefix.
     * @returns The method data object corresponding to the given signature prefix.
     */
    handleMethodData(fourBytePrefix) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                const { methodData } = this.state;
                const knownMethod = Object.keys(methodData).find((knownFourBytePrefix) => fourBytePrefix === knownFourBytePrefix);
                if (knownMethod) {
                    return methodData[fourBytePrefix];
                }
                const registry = yield this.registryLookup(fourBytePrefix);
                this.update({
                    methodData: Object.assign(Object.assign({}, methodData), { [fourBytePrefix]: registry }),
                });
                return registry;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Add a new unapproved transaction to state. Parameters will be validated, a
     * unique transaction id will be generated, and gas and gasPrice will be calculated
     * if not provided. If A `<tx.id>:unapproved` hub event will be emitted once added.
     *
     * @param transaction - The transaction object to add.
     * @param origin - The domain origin to append to the generated TransactionMeta.
     * @param deviceConfirmedOn - An enum to indicate what device the transaction was confirmed to append to the generated TransactionMeta.
     * @returns Object containing a promise resolving to the transaction hash if approved.
     */
    addTransaction(transaction, origin, deviceConfirmedOn) {
        return __awaiter(this, void 0, void 0, function* () {
            const { provider, network } = this.getNetworkState();
            const { transactions } = this.state;
            transaction = util_1.normalizeTransaction(transaction);
            util_1.validateTransaction(transaction);
            const transactionMeta = {
                id: uuid_1.v1(),
                networkID: network,
                chainId: provider.chainId,
                origin,
                status: TransactionStatus.unapproved,
                time: Date.now(),
                transaction,
                deviceConfirmedOn,
                verifiedOnBlockchain: false,
            };
            try {
                const { gas } = yield this.estimateGas(transaction);
                transaction.gas = gas;
            }
            catch (error) {
                this.failTransaction(transactionMeta, error);
                return Promise.reject(error);
            }
            const result = new Promise((resolve, reject) => {
                this.hub.once(`${transactionMeta.id}:finished`, (meta) => {
                    switch (meta.status) {
                        case TransactionStatus.submitted:
                            return resolve(meta.transactionHash);
                        case TransactionStatus.rejected:
                            return reject(eth_rpc_errors_1.ethErrors.provider.userRejectedRequest('User rejected the transaction'));
                        case TransactionStatus.cancelled:
                            return reject(eth_rpc_errors_1.ethErrors.rpc.internal('User cancelled the transaction'));
                        case TransactionStatus.failed:
                            return reject(eth_rpc_errors_1.ethErrors.rpc.internal(meta.error.message));
                        /* istanbul ignore next */
                        default:
                            return reject(eth_rpc_errors_1.ethErrors.rpc.internal(`MetaMask Tx Signature: Unknown problem: ${JSON.stringify(meta)}`));
                    }
                });
            });
            transactions.push(transactionMeta);
            this.update({ transactions: this.trimTransactionsForState(transactions) });
            this.hub.emit(`unapprovedTransaction`, transactionMeta);
            return { result, transactionMeta };
        });
    }
    prepareUnsignedEthTx(txParams) {
        return tx_1.TransactionFactory.fromTxData(txParams, {
            common: this.getCommonConfiguration(),
            freeze: false,
        });
    }
    /**
     * `@ethereumjs/tx` uses `@ethereumjs/common` as a configuration tool for
     * specifying which chain, network, hardfork and EIPs to support for
     * a transaction. By referencing this configuration, and analyzing the fields
     * specified in txParams, @ethereumjs/tx is able to determine which EIP-2718
     * transaction type to use.
     *
     * @returns {Common} common configuration object
     */
    getCommonConfiguration() {
        const { network: networkId, provider: { type: chain, chainId, nickname: name }, } = this.getNetworkState();
        if (chain !== constants_1.RPC) {
            return new common_1.default({ chain, hardfork: HARDFORK });
        }
        const customChainParams = {
            name,
            chainId: parseInt(chainId, undefined),
            networkId: parseInt(networkId, undefined),
        };
        return common_1.default.forCustomChain(constants_1.MAINNET, customChainParams, HARDFORK);
    }
    /**
     * Approves a transaction and updates it's status in state. If this is not a
     * retry transaction, a nonce will be generated. The transaction is signed
     * using the sign configuration property, then published to the blockchain.
     * A `<tx.id>:finished` hub event is fired after success or failure.
     *
     * @param transactionID - The ID of the transaction to approve.
     */
    approveTransaction(transactionID) {
        return __awaiter(this, void 0, void 0, function* () {
            const { transactions } = this.state;
            const releaseLock = yield this.mutex.acquire();
            const { provider } = this.getNetworkState();
            const { chainId: currentChainId } = provider;
            const index = transactions.findIndex(({ id }) => transactionID === id);
            const transactionMeta = transactions[index];
            const { nonce } = transactionMeta.transaction;
            try {
                const { from } = transactionMeta.transaction;
                if (!this.sign) {
                    releaseLock();
                    this.failTransaction(transactionMeta, new Error('No sign method defined.'));
                    return;
                }
                else if (!currentChainId) {
                    releaseLock();
                    this.failTransaction(transactionMeta, new Error('No chainId defined.'));
                    return;
                }
                const chainId = parseInt(currentChainId, undefined);
                const { approved: status } = TransactionStatus;
                const txNonce = nonce ||
                    (yield util_1.query(this.ethQuery, 'getTransactionCount', [from, 'pending']));
                transactionMeta.status = status;
                transactionMeta.transaction.nonce = txNonce;
                transactionMeta.transaction.chainId = chainId;
                const baseTxParams = Object.assign(Object.assign({}, transactionMeta.transaction), { gasLimit: transactionMeta.transaction.gas, chainId, nonce: txNonce, status });
                const isEIP1559 = util_1.isEIP1559Transaction(transactionMeta.transaction);
                const txParams = isEIP1559
                    ? Object.assign(Object.assign({}, baseTxParams), { maxFeePerGas: transactionMeta.transaction.maxFeePerGas, maxPriorityFeePerGas: transactionMeta.transaction.maxPriorityFeePerGas, estimatedBaseFee: transactionMeta.transaction.estimatedBaseFee, 
                        // specify type 2 if maxFeePerGas and maxPriorityFeePerGas are set
                        type: 2 }) : baseTxParams;
                // delete gasPrice if maxFeePerGas and maxPriorityFeePerGas are set
                if (isEIP1559) {
                    delete txParams.gasPrice;
                }
                const unsignedEthTx = this.prepareUnsignedEthTx(txParams);
                const signedTx = yield this.sign(unsignedEthTx, from);
                transactionMeta.status = TransactionStatus.signed;
                this.updateTransaction(transactionMeta);
                const rawTransaction = ethereumjs_util_1.bufferToHex(signedTx.serialize());
                transactionMeta.rawTransaction = rawTransaction;
                this.updateTransaction(transactionMeta);
                const transactionHash = yield util_1.query(this.ethQuery, 'sendRawTransaction', [
                    rawTransaction,
                ]);
                transactionMeta.transactionHash = transactionHash;
                transactionMeta.status = TransactionStatus.submitted;
                this.updateTransaction(transactionMeta);
                this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);
            }
            catch (error) {
                this.failTransaction(transactionMeta, error);
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Cancels a transaction based on its ID by setting its status to "rejected"
     * and emitting a `<tx.id>:finished` hub event.
     *
     * @param transactionID - The ID of the transaction to cancel.
     */
    cancelTransaction(transactionID) {
        const transactionMeta = this.state.transactions.find(({ id }) => id === transactionID);
        if (!transactionMeta) {
            return;
        }
        transactionMeta.status = TransactionStatus.rejected;
        this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);
        const transactions = this.state.transactions.filter(({ id }) => id !== transactionID);
        this.update({ transactions: this.trimTransactionsForState(transactions) });
    }
    /**
     * Attempts to cancel a transaction based on its ID by setting its status to "rejected"
     * and emitting a `<tx.id>:finished` hub event.
     *
     * @param transactionID - The ID of the transaction to cancel.
     * @param gasValues - The gas values to use for the cancellation transation.
     */
    stopTransaction(transactionID, gasValues) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (gasValues) {
                util_1.validateGasValues(gasValues);
            }
            const transactionMeta = this.state.transactions.find(({ id }) => id === transactionID);
            if (!transactionMeta) {
                return;
            }
            if (!this.sign) {
                throw new Error('No sign method defined.');
            }
            // gasPrice (legacy non EIP1559)
            const minGasPrice = util_1.getIncreasedPriceFromExisting(transactionMeta.transaction.gasPrice, exports.CANCEL_RATE);
            const gasPriceFromValues = util_1.isGasPriceValue(gasValues) && gasValues.gasPrice;
            const newGasPrice = (gasPriceFromValues &&
                util_1.validateMinimumIncrease(gasPriceFromValues, minGasPrice)) ||
                minGasPrice;
            // maxFeePerGas (EIP1559)
            const existingMaxFeePerGas = (_a = transactionMeta.transaction) === null || _a === void 0 ? void 0 : _a.maxFeePerGas;
            const minMaxFeePerGas = util_1.getIncreasedPriceFromExisting(existingMaxFeePerGas, exports.CANCEL_RATE);
            const maxFeePerGasValues = util_1.isFeeMarketEIP1559Values(gasValues) && gasValues.maxFeePerGas;
            const newMaxFeePerGas = (maxFeePerGasValues &&
                util_1.validateMinimumIncrease(maxFeePerGasValues, minMaxFeePerGas)) ||
                (existingMaxFeePerGas && minMaxFeePerGas);
            // maxPriorityFeePerGas (EIP1559)
            const existingMaxPriorityFeePerGas = (_b = transactionMeta.transaction) === null || _b === void 0 ? void 0 : _b.maxPriorityFeePerGas;
            const minMaxPriorityFeePerGas = util_1.getIncreasedPriceFromExisting(existingMaxPriorityFeePerGas, exports.CANCEL_RATE);
            const maxPriorityFeePerGasValues = util_1.isFeeMarketEIP1559Values(gasValues) && gasValues.maxPriorityFeePerGas;
            const newMaxPriorityFeePerGas = (maxPriorityFeePerGasValues &&
                util_1.validateMinimumIncrease(maxPriorityFeePerGasValues, minMaxPriorityFeePerGas)) ||
                (existingMaxPriorityFeePerGas && minMaxPriorityFeePerGas);
            const txParams = newMaxFeePerGas && newMaxPriorityFeePerGas
                ? {
                    from: transactionMeta.transaction.from,
                    gasLimit: transactionMeta.transaction.gas,
                    maxFeePerGas: newMaxFeePerGas,
                    maxPriorityFeePerGas: newMaxPriorityFeePerGas,
                    type: 2,
                    nonce: transactionMeta.transaction.nonce,
                    to: transactionMeta.transaction.from,
                    value: '0x0',
                }
                : {
                    from: transactionMeta.transaction.from,
                    gasLimit: transactionMeta.transaction.gas,
                    gasPrice: newGasPrice,
                    nonce: transactionMeta.transaction.nonce,
                    to: transactionMeta.transaction.from,
                    value: '0x0',
                };
            const unsignedEthTx = this.prepareUnsignedEthTx(txParams);
            const signedTx = yield this.sign(unsignedEthTx, transactionMeta.transaction.from);
            const rawTransaction = ethereumjs_util_1.bufferToHex(signedTx.serialize());
            yield util_1.query(this.ethQuery, 'sendRawTransaction', [rawTransaction]);
            transactionMeta.status = TransactionStatus.cancelled;
            this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);
        });
    }
    /**
     * Attemps to speed up a transaction increasing transaction gasPrice by ten percent.
     *
     * @param transactionID - The ID of the transaction to speed up.
     * @param gasValues - The gas values to use for the speed up transation.
     */
    speedUpTransaction(transactionID, gasValues) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (gasValues) {
                util_1.validateGasValues(gasValues);
            }
            const transactionMeta = this.state.transactions.find(({ id }) => id === transactionID);
            /* istanbul ignore next */
            if (!transactionMeta) {
                return;
            }
            /* istanbul ignore next */
            if (!this.sign) {
                throw new Error('No sign method defined.');
            }
            const { transactions } = this.state;
            // gasPrice (legacy non EIP1559)
            const minGasPrice = util_1.getIncreasedPriceFromExisting(transactionMeta.transaction.gasPrice, exports.SPEED_UP_RATE);
            const gasPriceFromValues = util_1.isGasPriceValue(gasValues) && gasValues.gasPrice;
            const newGasPrice = (gasPriceFromValues &&
                util_1.validateMinimumIncrease(gasPriceFromValues, minGasPrice)) ||
                minGasPrice;
            // maxFeePerGas (EIP1559)
            const existingMaxFeePerGas = (_a = transactionMeta.transaction) === null || _a === void 0 ? void 0 : _a.maxFeePerGas;
            const minMaxFeePerGas = util_1.getIncreasedPriceFromExisting(existingMaxFeePerGas, exports.SPEED_UP_RATE);
            const maxFeePerGasValues = util_1.isFeeMarketEIP1559Values(gasValues) && gasValues.maxFeePerGas;
            const newMaxFeePerGas = (maxFeePerGasValues &&
                util_1.validateMinimumIncrease(maxFeePerGasValues, minMaxFeePerGas)) ||
                (existingMaxFeePerGas && minMaxFeePerGas);
            // maxPriorityFeePerGas (EIP1559)
            const existingMaxPriorityFeePerGas = (_b = transactionMeta.transaction) === null || _b === void 0 ? void 0 : _b.maxPriorityFeePerGas;
            const minMaxPriorityFeePerGas = util_1.getIncreasedPriceFromExisting(existingMaxPriorityFeePerGas, exports.SPEED_UP_RATE);
            const maxPriorityFeePerGasValues = util_1.isFeeMarketEIP1559Values(gasValues) && gasValues.maxPriorityFeePerGas;
            const newMaxPriorityFeePerGas = (maxPriorityFeePerGasValues &&
                util_1.validateMinimumIncrease(maxPriorityFeePerGasValues, minMaxPriorityFeePerGas)) ||
                (existingMaxPriorityFeePerGas && minMaxPriorityFeePerGas);
            const txParams = newMaxFeePerGas && newMaxPriorityFeePerGas
                ? Object.assign(Object.assign({}, transactionMeta.transaction), { gasLimit: transactionMeta.transaction.gas, maxFeePerGas: newMaxFeePerGas, maxPriorityFeePerGas: newMaxPriorityFeePerGas, type: 2 }) : Object.assign(Object.assign({}, transactionMeta.transaction), { gasLimit: transactionMeta.transaction.gas, gasPrice: newGasPrice });
            const unsignedEthTx = this.prepareUnsignedEthTx(txParams);
            const signedTx = yield this.sign(unsignedEthTx, transactionMeta.transaction.from);
            const rawTransaction = ethereumjs_util_1.bufferToHex(signedTx.serialize());
            const transactionHash = yield util_1.query(this.ethQuery, 'sendRawTransaction', [
                rawTransaction,
            ]);
            const baseTransactionMeta = Object.assign(Object.assign({}, transactionMeta), { id: uuid_1.v1(), time: Date.now(), transactionHash });
            const newTransactionMeta = newMaxFeePerGas && newMaxPriorityFeePerGas
                ? Object.assign(Object.assign({}, baseTransactionMeta), { transaction: Object.assign(Object.assign({}, transactionMeta.transaction), { maxFeePerGas: newMaxFeePerGas, maxPriorityFeePerGas: newMaxPriorityFeePerGas }) }) : Object.assign(Object.assign({}, baseTransactionMeta), { transaction: Object.assign(Object.assign({}, transactionMeta.transaction), { gasPrice: newGasPrice }) });
            transactions.push(newTransactionMeta);
            this.update({ transactions: this.trimTransactionsForState(transactions) });
            this.hub.emit(`${transactionMeta.id}:speedup`, newTransactionMeta);
        });
    }
    /**
     * Estimates required gas for a given transaction.
     *
     * @param transaction - The transaction to estimate gas for.
     * @returns The gas and gas price.
     */
    estimateGas(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const estimatedTransaction = Object.assign({}, transaction);
            const { gas, gasPrice: providedGasPrice, to, value, data, } = estimatedTransaction;
            const gasPrice = typeof providedGasPrice === 'undefined'
                ? yield util_1.query(this.ethQuery, 'gasPrice')
                : providedGasPrice;
            const { isCustomNetwork } = this.getNetworkState();
            // 1. If gas is already defined on the transaction, use it
            if (typeof gas !== 'undefined') {
                return { gas, gasPrice };
            }
            const { gasLimit } = yield util_1.query(this.ethQuery, 'getBlockByNumber', [
                'latest',
                false,
            ]);
            // 2. If to is not defined or this is not a contract address, and there is no data use 0x5208 / 21000.
            // If the newtwork is a custom network then bypass this check and fetch 'estimateGas'.
            /* istanbul ignore next */
            const code = to ? yield util_1.query(this.ethQuery, 'getCode', [to]) : undefined;
            /* istanbul ignore next */
            if (!isCustomNetwork &&
                (!to || (to && !data && (!code || code === '0x')))) {
                return { gas: '0x5208', gasPrice };
            }
            // if data, should be hex string format
            estimatedTransaction.data = !data
                ? data
                : /* istanbul ignore next */ ethereumjs_util_1.addHexPrefix(data);
            // 3. If this is a contract address, safely estimate gas using RPC
            estimatedTransaction.value =
                typeof value === 'undefined' ? '0x0' : /* istanbul ignore next */ value;
            const gasLimitBN = util_1.hexToBN(gasLimit);
            estimatedTransaction.gas = util_1.BNToHex(util_1.fractionBN(gasLimitBN, 19, 20));
            const gasHex = yield util_1.query(this.ethQuery, 'estimateGas', [
                estimatedTransaction,
            ]);
            // 4. Pad estimated gas without exceeding the most recent block gasLimit. If the network is a
            // a custom network then return the eth_estimateGas value.
            const gasBN = util_1.hexToBN(gasHex);
            const maxGasBN = gasLimitBN.muln(0.9);
            const paddedGasBN = gasBN.muln(1.5);
            /* istanbul ignore next */
            if (gasBN.gt(maxGasBN) || isCustomNetwork) {
                return { gas: ethereumjs_util_1.addHexPrefix(gasHex), gasPrice };
            }
            /* istanbul ignore next */
            if (paddedGasBN.lt(maxGasBN)) {
                return { gas: ethereumjs_util_1.addHexPrefix(util_1.BNToHex(paddedGasBN)), gasPrice };
            }
            return { gas: ethereumjs_util_1.addHexPrefix(util_1.BNToHex(maxGasBN)), gasPrice };
        });
    }
    /**
     * Check the status of submitted transactions on the network to determine whether they have
     * been included in a block. Any that have been included in a block are marked as confirmed.
     */
    queryTransactionStatuses() {
        return __awaiter(this, void 0, void 0, function* () {
            const { transactions } = this.state;
            const { provider, network: currentNetworkID } = this.getNetworkState();
            const { chainId: currentChainId } = provider;
            let gotUpdates = false;
            yield util_1.safelyExecute(() => Promise.all(transactions.map((meta, index) => __awaiter(this, void 0, void 0, function* () {
                // Using fallback to networkID only when there is no chainId present.
                // Should be removed when networkID is completely removed.
                const txBelongsToCurrentChain = meta.chainId === currentChainId ||
                    (!meta.chainId && meta.networkID === currentNetworkID);
                if (!meta.verifiedOnBlockchain && txBelongsToCurrentChain) {
                    const [reconciledTx, updateRequired,] = yield this.blockchainTransactionStateReconciler(meta);
                    if (updateRequired) {
                        transactions[index] = reconciledTx;
                        gotUpdates = updateRequired;
                    }
                }
            }))));
            /* istanbul ignore else */
            if (gotUpdates) {
                this.update({
                    transactions: this.trimTransactionsForState(transactions),
                });
            }
        });
    }
    /**
     * Updates an existing transaction in state.
     *
     * @param transactionMeta - The new transaction to store in state.
     */
    updateTransaction(transactionMeta) {
        const { transactions } = this.state;
        transactionMeta.transaction = util_1.normalizeTransaction(transactionMeta.transaction);
        util_1.validateTransaction(transactionMeta.transaction);
        const index = transactions.findIndex(({ id }) => transactionMeta.id === id);
        transactions[index] = transactionMeta;
        this.update({ transactions: this.trimTransactionsForState(transactions) });
    }
    /**
     * Removes all transactions from state, optionally based on the current network.
     *
     * @param ignoreNetwork - Determines whether to wipe all transactions, or just those on the
     * current network. If `true`, all transactions are wiped.
     */
    wipeTransactions(ignoreNetwork) {
        /* istanbul ignore next */
        if (ignoreNetwork) {
            this.update({ transactions: [] });
            return;
        }
        const { provider, network: currentNetworkID } = this.getNetworkState();
        const { chainId: currentChainId } = provider;
        const newTransactions = this.state.transactions.filter(({ networkID, chainId }) => {
            // Using fallback to networkID only when there is no chainId present. Should be removed when networkID is completely removed.
            const isCurrentNetwork = chainId === currentChainId ||
                (!chainId && networkID === currentNetworkID);
            return !isCurrentNetwork;
        });
        this.update({
            transactions: this.trimTransactionsForState(newTransactions),
        });
    }
    /**
     * Get transactions from Etherscan for the given address. By default all transactions are
     * returned, but the `fromBlock` option can be given to filter just for transactions from a
     * specific block onward.
     *
     * @param address - The address to fetch the transactions for.
     * @param opt - Object containing optional data, fromBlock and Etherscan API key.
     * @returns The block number of the latest incoming transaction.
     */
    fetchAll(address, opt) {
        return __awaiter(this, void 0, void 0, function* () {
            const { provider, network: currentNetworkID } = this.getNetworkState();
            const { chainId: currentChainId, type: networkType } = provider;
            const { transactions } = this.state;
            const supportedNetworkIds = ['1', '3', '4', '42'];
            /* istanbul ignore next */
            if (supportedNetworkIds.indexOf(currentNetworkID) === -1) {
                return undefined;
            }
            const [etherscanTxResponse, etherscanTokenResponse,] = yield util_1.handleTransactionFetch(networkType, address, this.config.txHistoryLimit, opt);
            const normalizedTxs = etherscanTxResponse.result.map((tx) => this.normalizeTx(tx, currentNetworkID, currentChainId));
            const normalizedTokenTxs = etherscanTokenResponse.result.map((tx) => this.normalizeTokenTx(tx, currentNetworkID, currentChainId));
            const [updateRequired, allTxs] = this.etherscanTransactionStateReconciler([...normalizedTxs, ...normalizedTokenTxs], transactions);
            allTxs.sort((a, b) => (a.time < b.time ? -1 : 1));
            let latestIncomingTxBlockNumber;
            allTxs.forEach((tx) => __awaiter(this, void 0, void 0, function* () {
                /* istanbul ignore next */
                if (
                // Using fallback to networkID only when there is no chainId present. Should be removed when networkID is completely removed.
                (tx.chainId === currentChainId ||
                    (!tx.chainId && tx.networkID === currentNetworkID)) &&
                    tx.transaction.to &&
                    tx.transaction.to.toLowerCase() === address.toLowerCase()) {
                    if (tx.blockNumber &&
                        (!latestIncomingTxBlockNumber ||
                            parseInt(latestIncomingTxBlockNumber, 10) <
                                parseInt(tx.blockNumber, 10))) {
                        latestIncomingTxBlockNumber = tx.blockNumber;
                    }
                }
                /* istanbul ignore else */
                if (tx.toSmartContract === undefined) {
                    // If not `to` is a contract deploy, if not `data` is send eth
                    if (tx.transaction.to &&
                        (!tx.transaction.data || tx.transaction.data !== '0x')) {
                        const code = yield util_1.query(this.ethQuery, 'getCode', [
                            tx.transaction.to,
                        ]);
                        tx.toSmartContract = util_1.isSmartContractCode(code);
                    }
                    else {
                        tx.toSmartContract = false;
                    }
                }
            }));
            // Update state only if new transactions were fetched or
            // the status or gas data of a transaction has changed
            if (updateRequired) {
                this.update({ transactions: this.trimTransactionsForState(allTxs) });
            }
            return latestIncomingTxBlockNumber;
        });
    }
    /**
     * Trim the amount of transactions that are set on the state. Checks
     * if the length of the tx history is longer then desired persistence
     * limit and then if it is removes the oldest confirmed or rejected tx.
     * Pending or unapproved transactions will not be removed by this
     * operation. For safety of presenting a fully functional transaction UI
     * representation, this function will not break apart transactions with the
     * same nonce, created on the same day, per network. Not accounting for transactions of the same
     * nonce, same day and network combo can result in confusing or broken experiences
     * in the UI. The transactions are then updated using the BaseController update.
     *
     * @param transactions - The transactions to be applied to the state.
     * @returns The trimmed list of transactions.
     */
    trimTransactionsForState(transactions) {
        const nonceNetworkSet = new Set();
        const txsToKeep = transactions.reverse().filter((tx) => {
            const { chainId, networkID, status, transaction, time } = tx;
            if (transaction) {
                const key = `${transaction.nonce}-${chainId !== null && chainId !== void 0 ? chainId : networkID}-${new Date(time).toDateString()}`;
                if (nonceNetworkSet.has(key)) {
                    return true;
                }
                else if (nonceNetworkSet.size < this.config.txHistoryLimit ||
                    !this.isFinalState(status)) {
                    nonceNetworkSet.add(key);
                    return true;
                }
            }
            return false;
        });
        txsToKeep.reverse();
        return txsToKeep;
    }
    /**
     * Determines if the transaction is in a final state.
     *
     * @param status - The transaction status.
     * @returns Whether the transaction is in a final state.
     */
    isFinalState(status) {
        return (status === TransactionStatus.rejected ||
            status === TransactionStatus.confirmed ||
            status === TransactionStatus.failed ||
            status === TransactionStatus.cancelled);
    }
    /**
     * Method to verify the state of a transaction using the Blockchain as a source of truth.
     *
     * @param meta - The local transaction to verify on the blockchain.
     * @returns A tuple containing the updated transaction, and whether or not an update was required.
     */
    blockchainTransactionStateReconciler(meta) {
        return __awaiter(this, void 0, void 0, function* () {
            const { status, transactionHash } = meta;
            switch (status) {
                case TransactionStatus.confirmed:
                    const txReceipt = yield util_1.query(this.ethQuery, 'getTransactionReceipt', [
                        transactionHash,
                    ]);
                    if (!txReceipt) {
                        return [meta, false];
                    }
                    meta.verifiedOnBlockchain = true;
                    meta.transaction.gasUsed = txReceipt.gasUsed;
                    // According to the Web3 docs:
                    // TRUE if the transaction was successful, FALSE if the EVM reverted the transaction.
                    if (Number(txReceipt.status) === 0) {
                        const error = new Error('Transaction failed. The transaction was reversed');
                        this.failTransaction(meta, error);
                        return [meta, false];
                    }
                    return [meta, true];
                case TransactionStatus.submitted:
                    const txObj = yield util_1.query(this.ethQuery, 'getTransactionByHash', [
                        transactionHash,
                    ]);
                    if (!txObj) {
                        const receiptShowsFailedStatus = yield this.checkTxReceiptStatusIsFailed(transactionHash);
                        // Case the txObj is evaluated as false, a second check will
                        // determine if the tx failed or it is pending or confirmed
                        if (receiptShowsFailedStatus) {
                            const error = new Error('Transaction failed. The transaction was dropped or replaced by a new one');
                            this.failTransaction(meta, error);
                        }
                    }
                    /* istanbul ignore next */
                    if (txObj === null || txObj === void 0 ? void 0 : txObj.blockNumber) {
                        meta.status = TransactionStatus.confirmed;
                        this.hub.emit(`${meta.id}:confirmed`, meta);
                        return [meta, true];
                    }
                    return [meta, false];
                default:
                    return [meta, false];
            }
        });
    }
    /**
     * Method to check if a tx has failed according to their receipt
     * According to the Web3 docs:
     * TRUE if the transaction was successful, FALSE if the EVM reverted the transaction.
     * The receipt is not available for pending transactions and returns null.
     *
     * @param txHash - The transaction hash.
     * @returns Whether the transaction has failed.
     */
    checkTxReceiptStatusIsFailed(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const txReceipt = yield util_1.query(this.ethQuery, 'getTransactionReceipt', [
                txHash,
            ]);
            if (!txReceipt) {
                // Transaction is pending
                return false;
            }
            return Number(txReceipt.status) === 0;
        });
    }
    /**
     * Method to verify the state of transactions using Etherscan as a source of truth.
     *
     * @param remoteTxs - Transactions to reconcile that are from a remote source.
     * @param localTxs - Transactions to reconcile that are local.
     * @returns A tuple containing a boolean indicating whether or not an update was required, and the updated transaction.
     */
    etherscanTransactionStateReconciler(remoteTxs, localTxs) {
        const updatedTxs = this.getUpdatedTransactions(remoteTxs, localTxs);
        const newTxs = this.getNewTransactions(remoteTxs, localTxs);
        const updatedLocalTxs = localTxs.map((tx) => {
            const txIdx = updatedTxs.findIndex(({ transactionHash }) => transactionHash === tx.transactionHash);
            return txIdx === -1 ? tx : updatedTxs[txIdx];
        });
        const updateRequired = newTxs.length > 0 || updatedLocalTxs.length > 0;
        return [updateRequired, [...newTxs, ...updatedLocalTxs]];
    }
    /**
     * Get all transactions that are in the remote transactions array
     * but not in the local transactions array.
     *
     * @param remoteTxs - Array of transactions from remote source.
     * @param localTxs - Array of transactions stored locally.
     * @returns The new transactions.
     */
    getNewTransactions(remoteTxs, localTxs) {
        return remoteTxs.filter((tx) => {
            const alreadyInTransactions = localTxs.find(({ transactionHash }) => transactionHash === tx.transactionHash);
            return !alreadyInTransactions;
        });
    }
    /**
     * Get all the transactions that are locally outdated with respect
     * to a remote source (etherscan or blockchain). The returned array
     * contains the transactions with the updated data.
     *
     * @param remoteTxs - Array of transactions from remote source.
     * @param localTxs - Array of transactions stored locally.
     * @returns The updated transactions.
     */
    getUpdatedTransactions(remoteTxs, localTxs) {
        return remoteTxs.filter((remoteTx) => {
            const isTxOutdated = localTxs.find((localTx) => {
                return (remoteTx.transactionHash === localTx.transactionHash &&
                    this.isTransactionOutdated(remoteTx, localTx));
            });
            return isTxOutdated;
        });
    }
    /**
     * Verifies if a local transaction is outdated with respect to the remote transaction.
     *
     * @param remoteTx - The remote transaction from Etherscan.
     * @param localTx - The local transaction.
     * @returns Whether the transaction is outdated.
     */
    isTransactionOutdated(remoteTx, localTx) {
        const statusOutdated = this.isStatusOutdated(remoteTx.transactionHash, localTx.transactionHash, remoteTx.status, localTx.status);
        const gasDataOutdated = this.isGasDataOutdated(remoteTx.transaction.gasUsed, localTx.transaction.gasUsed);
        return statusOutdated || gasDataOutdated;
    }
    /**
     * Verifies if the status of a local transaction is outdated with respect to the remote transaction.
     *
     * @param remoteTxHash - Remote transaction hash.
     * @param localTxHash - Local transaction hash.
     * @param remoteTxStatus - Remote transaction status.
     * @param localTxStatus - Local transaction status.
     * @returns Whether the status is outdated.
     */
    isStatusOutdated(remoteTxHash, localTxHash, remoteTxStatus, localTxStatus) {
        return remoteTxHash === localTxHash && remoteTxStatus !== localTxStatus;
    }
    /**
     * Verifies if the gas data of a local transaction is outdated with respect to the remote transaction.
     *
     * @param remoteGasUsed - Remote gas used in the transaction.
     * @param localGasUsed - Local gas used in the transaction.
     * @returns Whether the gas data is outdated.
     */
    isGasDataOutdated(remoteGasUsed, localGasUsed) {
        return remoteGasUsed !== localGasUsed;
    }
}
exports.TransactionController = TransactionController;
exports.default = TransactionController;
//# sourceMappingURL=TransactionController.js.map
      };
    };
  }
}, {package:"@metamask\\controllers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\controllers\\dist\\transaction\\TransactionController.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\etherscan-link\\dist\\prefix-for-chain.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\etherscan-link\dist\prefix-for-chain.js
      return function (require, module, exports) {
"use strict";
module.exports = function getPrefixForChain(chainId) {
    let prefix;
    switch (chainId) {
        case '0x1': // main net
            prefix = '';
            break;
        case '0x3': // ropsten test net
            prefix = 'ropsten.';
            break;
        case '0x4': // rinkeby test net
            prefix = 'rinkeby.';
            break;
        case '0x5': // goerli test net
            prefix = 'goerli.';
            break;
        case '0x2a': // kovan test net
            prefix = 'kovan.';
            break;
        default:
            prefix = null;
    }
    return prefix;
};
//# sourceMappingURL=prefix-for-chain.js.map
      };
    };
  }
}, {package:"@metamask\\etherscan-link",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\etherscan-link\\dist\\prefix-for-chain.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\etherscan-link\\dist\\helpers.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\etherscan-link\dist\helpers.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addPathToUrl = void 0;
exports.addPathToUrl = (customNetworkUrl, linkType, suffixType) => {
    const { username, password, protocol, host, pathname, search, hash } = new URL(customNetworkUrl);
    const newPath = pathname.endsWith('/') ? `${pathname}${linkType}/${suffixType}` : `${pathname}/${linkType}/${suffixType}`;
    const auth = username ? `${username}:${password}` : '';
    const parsedUrl = new URL(`${protocol}//${auth}${host}${newPath}${search}${hash}`);
    return parsedUrl.toString();
};
//# sourceMappingURL=helpers.js.map
      };
    };
  }
}, {package:"@metamask\\etherscan-link",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\etherscan-link\\dist\\helpers.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\etherscan-link\\dist\\prefix-for-network.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@metamask\etherscan-link\dist\prefix-for-network.js
      return function (require, module, exports) {
"use strict";
module.exports = function getPrefixForNetwork(networkId) {
    // eslint-disable-next-line radix
    const net = parseInt(networkId);
    let prefix;
    switch (net) {
        case 1: // main net
            prefix = '';
            break;
        case 3: // ropsten test net
            prefix = 'ropsten.';
            break;
        case 4: // rinkeby test net
            prefix = 'rinkeby.';
            break;
        case 5: // goerli test net
            prefix = 'goerli.';
            break;
        case 42: // kovan test net
            prefix = 'kovan.';
            break;
        default:
            prefix = null;
    }
    return prefix;
};
//# sourceMappingURL=prefix-for-network.js.map
      };
    };
  }
}, {package:"@metamask\\etherscan-link",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@metamask\\etherscan-link\\dist\\prefix-for-network.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\util\\support\\isBufferBrowser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\browserify\node_modules\util\support\isBufferBrowser.js
      return function (require, module, exports) {
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
      };
    };
  }
}, {package:"util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\util\\support\\isBufferBrowser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\util\\node_modules\\inherits\\inherits_browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\browserify\node_modules\util\node_modules\inherits\inherits_browser.js
      return function (require, module, exports) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

      };
    };
  }
}, {package:"inherits",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\util\\node_modules\\inherits\\inherits_browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\core-util-is\\lib\\util.js", {"../../is-buffer/index.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\core-util-is\lib\util.js
      return function (require, module, exports) {
(function (Buffer){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

      };
    };
  }
}, {package:"core-util-is",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\core-util-is\\lib\\util.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-stream\\node_modules\\process-nextick-args\\index.js", {"_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\readable-stream\node_modules\process-nextick-args\index.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"process-nextick-args",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-stream\\node_modules\\process-nextick-args\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\util-deprecate\\browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\util-deprecate\browser.js
      return function (require, module, exports) {

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

      };
    };
  }
}, {package:"util-deprecate",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\util-deprecate\\browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-stream\\lib\\internal\\streams\\stream-browser.js", {"events":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\events\\events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\readable-stream\lib\internal\streams\stream-browser.js
      return function (require, module, exports) {
module.exports = require('events').EventEmitter;

      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-stream\\lib\\internal\\streams\\stream-browser.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-stream\\node_modules\\safe-buffer\\index.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\readable-stream\node_modules\safe-buffer\index.js
      return function (require, module, exports) {
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

      };
    };
  }
}, {package:"safe-buffer",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-stream\\node_modules\\safe-buffer\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-stream\\lib\\internal\\streams\\destroy.js", {"process-nextick-args":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-stream\\node_modules\\process-nextick-args\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\readable-stream\lib\internal\streams\destroy.js
      return function (require, module, exports) {
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-stream\\lib\\internal\\streams\\destroy.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\isarray\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\isarray\index.js
      return function (require, module, exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

      };
    };
  }
}, {package:"isarray",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\isarray\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-stream\\lib\\internal\\streams\\BufferList.js", {"safe-buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-stream\\node_modules\\safe-buffer\\index.js","util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\readable-stream\lib\internal\streams\BufferList.js
      return function (require, module, exports) {
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
      };
    };
  }
}, {package:"readable-stream",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-stream\\lib\\internal\\streams\\BufferList.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-stream\\node_modules\\string_decoder\\lib\\string_decoder.js", {"safe-buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-stream\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\readable-stream\node_modules\string_decoder\lib\string_decoder.js
      return function (require, module, exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
      };
    };
  }
}, {package:"string_decoder",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\readable-stream\\node_modules\\string_decoder\\lib\\string_decoder.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\objectWithoutPropertiesLoose.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@babel\runtime\helpers\objectWithoutPropertiesLoose.js
      return function (require, module, exports) {
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

module.exports = _objectWithoutPropertiesLoose;
module.exports["default"] = module.exports, module.exports.__esModule = true;
      };
    };
  }
}, {package:"@babel\\runtime",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\objectWithoutPropertiesLoose.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\types\\dist\\session.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@sentry\types\dist\session.js
      return function (require, module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Session Status
 */
var SessionStatus;
(function (SessionStatus) {
    /** JSDoc */
    SessionStatus["Ok"] = "ok";
    /** JSDoc */
    SessionStatus["Exited"] = "exited";
    /** JSDoc */
    SessionStatus["Crashed"] = "crashed";
    /** JSDoc */
    SessionStatus["Abnormal"] = "abnormal";
})(SessionStatus = exports.SessionStatus || (exports.SessionStatus = {}));
var RequestSessionStatus;
(function (RequestSessionStatus) {
    /** JSDoc */
    RequestSessionStatus["Ok"] = "ok";
    /** JSDoc */
    RequestSessionStatus["Errored"] = "errored";
    /** JSDoc */
    RequestSessionStatus["Crashed"] = "crashed";
})(RequestSessionStatus = exports.RequestSessionStatus || (exports.RequestSessionStatus = {}));
//# sourceMappingURL=session.js.map
      };
    };
  }
}, {package:"@sentry\\types",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\types\\dist\\session.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\types\\dist\\loglevel.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@sentry\types\dist\loglevel.js
      return function (require, module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/** Console logging verbosity for the SDK. */
var LogLevel;
(function (LogLevel) {
    /** No logs will be generated. */
    LogLevel[LogLevel["None"] = 0] = "None";
    /** Only SDK internal errors will be logged. */
    LogLevel[LogLevel["Error"] = 1] = "Error";
    /** Information useful for debugging the SDK will be logged. */
    LogLevel[LogLevel["Debug"] = 2] = "Debug";
    /** All SDK actions will be logged. */
    LogLevel[LogLevel["Verbose"] = 3] = "Verbose";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
//# sourceMappingURL=loglevel.js.map
      };
    };
  }
}, {package:"@sentry\\types",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\types\\dist\\loglevel.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\types\\dist\\transaction.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@sentry\types\dist\transaction.js
      return function (require, module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var TransactionSamplingMethod;
(function (TransactionSamplingMethod) {
    TransactionSamplingMethod["Explicit"] = "explicitly_set";
    TransactionSamplingMethod["Sampler"] = "client_sampler";
    TransactionSamplingMethod["Rate"] = "client_rate";
    TransactionSamplingMethod["Inheritance"] = "inheritance";
})(TransactionSamplingMethod = exports.TransactionSamplingMethod || (exports.TransactionSamplingMethod = {}));
//# sourceMappingURL=transaction.js.map
      };
    };
  }
}, {package:"@sentry\\types",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\types\\dist\\transaction.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\types\\dist\\severity.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@sentry\types\dist\severity.js
      return function (require, module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/** JSDoc */
// eslint-disable-next-line import/export
var Severity;
(function (Severity) {
    /** JSDoc */
    Severity["Fatal"] = "fatal";
    /** JSDoc */
    Severity["Error"] = "error";
    /** JSDoc */
    Severity["Warning"] = "warning";
    /** JSDoc */
    Severity["Log"] = "log";
    /** JSDoc */
    Severity["Info"] = "info";
    /** JSDoc */
    Severity["Debug"] = "debug";
    /** JSDoc */
    Severity["Critical"] = "critical";
})(Severity = exports.Severity || (exports.Severity = {}));
// eslint-disable-next-line @typescript-eslint/no-namespace, import/export
(function (Severity) {
    /**
     * Converts a string-based level into a {@link Severity}.
     *
     * @param level string representation of Severity
     * @returns Severity
     */
    function fromString(level) {
        switch (level) {
            case 'debug':
                return Severity.Debug;
            case 'info':
                return Severity.Info;
            case 'warn':
            case 'warning':
                return Severity.Warning;
            case 'error':
                return Severity.Error;
            case 'fatal':
                return Severity.Fatal;
            case 'critical':
                return Severity.Critical;
            case 'log':
            default:
                return Severity.Log;
        }
    }
    Severity.fromString = fromString;
})(Severity = exports.Severity || (exports.Severity = {}));
//# sourceMappingURL=severity.js.map
      };
    };
  }
}, {package:"@sentry\\types",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\types\\dist\\severity.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\types\\dist\\transport.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@sentry\types\dist\transport.js
      return function (require, module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var Outcome;
(function (Outcome) {
    Outcome["BeforeSend"] = "before_send";
    Outcome["EventProcessor"] = "event_processor";
    Outcome["NetworkError"] = "network_error";
    Outcome["QueueOverflow"] = "queue_overflow";
    Outcome["RateLimitBackoff"] = "ratelimit_backoff";
    Outcome["SampleRate"] = "sample_rate";
})(Outcome = exports.Outcome || (exports.Outcome = {}));
//# sourceMappingURL=transport.js.map
      };
    };
  }
}, {package:"@sentry\\types",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\types\\dist\\transport.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\types\\dist\\status.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@sentry\types\dist\status.js
      return function (require, module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/** The status of an event. */
// eslint-disable-next-line import/export
var Status;
(function (Status) {
    /** The status could not be determined. */
    Status["Unknown"] = "unknown";
    /** The event was skipped due to configuration or callbacks. */
    Status["Skipped"] = "skipped";
    /** The event was sent to Sentry successfully. */
    Status["Success"] = "success";
    /** The client is currently rate limited and will try again later. */
    Status["RateLimit"] = "rate_limit";
    /** The event could not be processed. */
    Status["Invalid"] = "invalid";
    /** A server-side error occurred during submission. */
    Status["Failed"] = "failed";
})(Status = exports.Status || (exports.Status = {}));
// eslint-disable-next-line @typescript-eslint/no-namespace, import/export
(function (Status) {
    /**
     * Converts a HTTP status code into a {@link Status}.
     *
     * @param code The HTTP response status code.
     * @returns The send status or {@link Status.Unknown}.
     */
    function fromHttpCode(code) {
        if (code >= 200 && code < 300) {
            return Status.Success;
        }
        if (code === 429) {
            return Status.RateLimit;
        }
        if (code >= 400 && code < 500) {
            return Status.Invalid;
        }
        if (code >= 500) {
            return Status.Failed;
        }
        return Status.Unknown;
    }
    Status.fromHttpCode = fromHttpCode;
})(Status = exports.Status || (exports.Status = {}));
//# sourceMappingURL=status.js.map
      };
    };
  }
}, {package:"@sentry\\types",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\types\\dist\\status.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\browser\\dist\\tracekit.js", {"tslib":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tslib\\tslib.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@sentry\browser\dist\tracekit.js
      return function (require, module, exports) {
/**
 * This was originally forked from https://github.com/occ/TraceKit, but has since been
 * largely modified and is now maintained as part of Sentry JS SDK.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
// global reference to slice
var UNKNOWN_FUNCTION = '?';
// Chromium based browsers: Chrome, Brave, new Opera, new Edge
var chrome = /^\s*at (?:(.*?) ?\()?((?:file|https?|blob|chrome-extension|address|native|eval|webpack|<anonymous>|[-a-z]+:|.*bundle|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
// gecko regex: `(?:bundle|\d+\.js)`: `bundle` is for react native, `\d+\.js` also but specifically for ram bundles because it
// generates filenames without a prefix like `file://` the filenames in the stacktrace are just 42.js
// We need this specific case for now because we want no other regex to match.
var gecko = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:file|https?|blob|chrome|webpack|resource|moz-extension|capacitor).*?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i;
var winjs = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
var geckoEval = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
var chromeEval = /\((\S*)(?::(\d+))(?::(\d+))\)/;
// Based on our own mapping pattern - https://github.com/getsentry/sentry/blob/9f08305e09866c8bd6d0c24f5b0aabdd7dd6c59c/src/sentry/lang/javascript/errormapping.py#L83-L108
var reactMinifiedRegexp = /Minified React error #\d+;/i;
/** JSDoc */
// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
function computeStackTrace(ex) {
    var stack = null;
    var popSize = 0;
    if (ex) {
        if (typeof ex.framesToPop === 'number') {
            popSize = ex.framesToPop;
        }
        else if (reactMinifiedRegexp.test(ex.message)) {
            popSize = 1;
        }
    }
    try {
        // This must be tried first because Opera 10 *destroys*
        // its stacktrace property if you try to access the stack
        // property first!!
        stack = computeStackTraceFromStacktraceProp(ex);
        if (stack) {
            return popFrames(stack, popSize);
        }
    }
    catch (e) {
        // no-empty
    }
    try {
        stack = computeStackTraceFromStackProp(ex);
        if (stack) {
            return popFrames(stack, popSize);
        }
    }
    catch (e) {
        // no-empty
    }
    return {
        message: extractMessage(ex),
        name: ex && ex.name,
        stack: [],
        failed: true,
    };
}
exports.computeStackTrace = computeStackTrace;
/** JSDoc */
// eslint-disable-next-line @typescript-eslint/no-explicit-any, complexity
function computeStackTraceFromStackProp(ex) {
    var _a, _b;
    if (!ex || !ex.stack) {
        return null;
    }
    var stack = [];
    var lines = ex.stack.split('\n');
    var isEval;
    var submatch;
    var parts;
    var element;
    for (var i = 0; i < lines.length; ++i) {
        if ((parts = chrome.exec(lines[i]))) {
            var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line
            isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line
            if (isEval && (submatch = chromeEval.exec(parts[2]))) {
                // throw out eval line/column and use top-most line/column number
                parts[2] = submatch[1]; // url
                parts[3] = submatch[2]; // line
                parts[4] = submatch[3]; // column
            }
            // Arpad: Working with the regexp above is super painful. it is quite a hack, but just stripping the `address at `
            // prefix here seems like the quickest solution for now.
            var url = parts[2] && parts[2].indexOf('address at ') === 0 ? parts[2].substr('address at '.length) : parts[2];
            // Kamil: One more hack won't hurt us right? Understanding and adding more rules on top of these regexps right now
            // would be way too time consuming. (TODO: Rewrite whole RegExp to be more readable)
            var func = parts[1] || UNKNOWN_FUNCTION;
            _a = tslib_1.__read(extractSafariExtensionDetails(func, url), 2), func = _a[0], url = _a[1];
            element = {
                url: url,
                func: func,
                args: isNative ? [parts[2]] : [],
                line: parts[3] ? +parts[3] : null,
                column: parts[4] ? +parts[4] : null,
            };
        }
        else if ((parts = winjs.exec(lines[i]))) {
            element = {
                url: parts[2],
                func: parts[1] || UNKNOWN_FUNCTION,
                args: [],
                line: +parts[3],
                column: parts[4] ? +parts[4] : null,
            };
        }
        else if ((parts = gecko.exec(lines[i]))) {
            isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
            if (isEval && (submatch = geckoEval.exec(parts[3]))) {
                // throw out eval line/column and use top-most line number
                parts[1] = parts[1] || "eval";
                parts[3] = submatch[1];
                parts[4] = submatch[2];
                parts[5] = ''; // no column when eval
            }
            else if (i === 0 && !parts[5] && ex.columnNumber !== void 0) {
                // FireFox uses this awesome columnNumber property for its top frame
                // Also note, Firefox's column number is 0-based and everything else expects 1-based,
                // so adding 1
                // NOTE: this hack doesn't work if top-most frame is eval
                stack[0].column = ex.columnNumber + 1;
            }
            var url = parts[3];
            var func = parts[1] || UNKNOWN_FUNCTION;
            _b = tslib_1.__read(extractSafariExtensionDetails(func, url), 2), func = _b[0], url = _b[1];
            element = {
                url: url,
                func: func,
                args: parts[2] ? parts[2].split(',') : [],
                line: parts[4] ? +parts[4] : null,
                column: parts[5] ? +parts[5] : null,
            };
        }
        else {
            continue;
        }
        if (!element.func && element.line) {
            element.func = UNKNOWN_FUNCTION;
        }
        stack.push(element);
    }
    if (!stack.length) {
        return null;
    }
    return {
        message: extractMessage(ex),
        name: ex.name,
        stack: stack,
    };
}
/** JSDoc */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function computeStackTraceFromStacktraceProp(ex) {
    if (!ex || !ex.stacktrace) {
        return null;
    }
    // Access and store the stacktrace property before doing ANYTHING
    // else to it because Opera is not very good at providing it
    // reliably in other circumstances.
    var stacktrace = ex.stacktrace;
    var opera10Regex = / line (\d+).*script (?:in )?(\S+)(?:: in function (\S+))?$/i;
    var opera11Regex = / line (\d+), column (\d+)\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\((.*)\))? in (.*):\s*$/i;
    var lines = stacktrace.split('\n');
    var stack = [];
    var parts;
    for (var line = 0; line < lines.length; line += 2) {
        var element = null;
        if ((parts = opera10Regex.exec(lines[line]))) {
            element = {
                url: parts[2],
                func: parts[3],
                args: [],
                line: +parts[1],
                column: null,
            };
        }
        else if ((parts = opera11Regex.exec(lines[line]))) {
            element = {
                url: parts[6],
                func: parts[3] || parts[4],
                args: parts[5] ? parts[5].split(',') : [],
                line: +parts[1],
                column: +parts[2],
            };
        }
        if (element) {
            if (!element.func && element.line) {
                element.func = UNKNOWN_FUNCTION;
            }
            stack.push(element);
        }
    }
    if (!stack.length) {
        return null;
    }
    return {
        message: extractMessage(ex),
        name: ex.name,
        stack: stack,
    };
}
/**
 * Safari web extensions, starting version unknown, can produce "frames-only" stacktraces.
 * What it means, is that instead of format like:
 *
 * Error: wat
 *   at function@url:row:col
 *   at function@url:row:col
 *   at function@url:row:col
 *
 * it produces something like:
 *
 *   function@url:row:col
 *   function@url:row:col
 *   function@url:row:col
 *
 * Because of that, it won't be captured by `chrome` RegExp and will fall into `Gecko` branch.
 * This function is extracted so that we can use it in both places without duplicating the logic.
 * Unfortunatelly "just" changing RegExp is too complicated now and making it pass all tests
 * and fix this case seems like an impossible, or at least way too time-consuming task.
 */
var extractSafariExtensionDetails = function (func, url) {
    var isSafariExtension = func.indexOf('safari-extension') !== -1;
    var isSafariWebExtension = func.indexOf('safari-web-extension') !== -1;
    return isSafariExtension || isSafariWebExtension
        ? [
            func.indexOf('@') !== -1 ? func.split('@')[0] : UNKNOWN_FUNCTION,
            isSafariExtension ? "safari-extension:" + url : "safari-web-extension:" + url,
        ]
        : [func, url];
};
/** Remove N number of frames from the stack */
function popFrames(stacktrace, popSize) {
    try {
        return tslib_1.__assign(tslib_1.__assign({}, stacktrace), { stack: stacktrace.stack.slice(popSize) });
    }
    catch (e) {
        return stacktrace;
    }
}
/**
 * There are cases where stacktrace.message is an Event object
 * https://github.com/getsentry/sentry-javascript/issues/1949
 * In this specific case we try to extract stacktrace.message.error.message
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function extractMessage(ex) {
    var message = ex && ex.message;
    if (!message) {
        return 'No error message';
    }
    if (message.error && typeof message.error.message === 'string') {
        return message.error.message;
    }
    return message;
}
//# sourceMappingURL=tracekit.js.map
      };
    };
  }
}, {package:"@sentry\\browser",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\browser\\dist\\tracekit.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\browser\\dist\\parsers.js", {"./tracekit":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\browser\\dist\\tracekit.js","@sentry/utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\utils\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@sentry\browser\dist\parsers.js
      return function (require, module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("@sentry/utils");
var tracekit_1 = require("./tracekit");
var STACKTRACE_LIMIT = 50;
/**
 * This function creates an exception from an TraceKitStackTrace
 * @param stacktrace TraceKitStackTrace that will be converted to an exception
 * @hidden
 */
function exceptionFromStacktrace(stacktrace) {
    var frames = prepareFramesForEvent(stacktrace.stack);
    var exception = {
        type: stacktrace.name,
        value: stacktrace.message,
    };
    if (frames && frames.length) {
        exception.stacktrace = { frames: frames };
    }
    if (exception.type === undefined && exception.value === '') {
        exception.value = 'Unrecoverable error caught';
    }
    return exception;
}
exports.exceptionFromStacktrace = exceptionFromStacktrace;
/**
 * @hidden
 */
function eventFromPlainObject(exception, syntheticException, rejection) {
    var event = {
        exception: {
            values: [
                {
                    type: utils_1.isEvent(exception) ? exception.constructor.name : rejection ? 'UnhandledRejection' : 'Error',
                    value: "Non-Error " + (rejection ? 'promise rejection' : 'exception') + " captured with keys: " + utils_1.extractExceptionKeysForMessage(exception),
                },
            ],
        },
        extra: {
            __serialized__: utils_1.normalizeToSize(exception),
        },
    };
    if (syntheticException) {
        var stacktrace = tracekit_1.computeStackTrace(syntheticException);
        var frames_1 = prepareFramesForEvent(stacktrace.stack);
        event.stacktrace = {
            frames: frames_1,
        };
    }
    return event;
}
exports.eventFromPlainObject = eventFromPlainObject;
/**
 * @hidden
 */
function eventFromStacktrace(stacktrace) {
    var exception = exceptionFromStacktrace(stacktrace);
    return {
        exception: {
            values: [exception],
        },
    };
}
exports.eventFromStacktrace = eventFromStacktrace;
/**
 * @hidden
 */
function prepareFramesForEvent(stack) {
    if (!stack || !stack.length) {
        return [];
    }
    var localStack = stack;
    var firstFrameFunction = localStack[0].func || '';
    var lastFrameFunction = localStack[localStack.length - 1].func || '';
    // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)
    if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {
        localStack = localStack.slice(1);
    }
    // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)
    if (lastFrameFunction.indexOf('sentryWrapped') !== -1) {
        localStack = localStack.slice(0, -1);
    }
    // The frame where the crash happened, should be the last entry in the array
    return localStack
        .slice(0, STACKTRACE_LIMIT)
        .map(function (frame) { return ({
        colno: frame.column === null ? undefined : frame.column,
        filename: frame.url || localStack[0].url,
        function: frame.func || '?',
        in_app: true,
        lineno: frame.line === null ? undefined : frame.line,
    }); })
        .reverse();
}
exports.prepareFramesForEvent = prepareFramesForEvent;
//# sourceMappingURL=parsers.js.map
      };
    };
  }
}, {package:"@sentry\\browser",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\browser\\dist\\parsers.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\browser\\dist\\backend.js", {"./eventbuilder":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\browser\\dist\\eventbuilder.js","./transports":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\browser\\dist\\transports\\index.js","@sentry/core":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\core\\dist\\index.js","@sentry/types":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\types\\dist\\index.js","@sentry/utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\utils\\dist\\index.js","tslib":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tslib\\tslib.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@sentry\browser\dist\backend.js
      return function (require, module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var core_1 = require("@sentry/core");
var types_1 = require("@sentry/types");
var utils_1 = require("@sentry/utils");
var eventbuilder_1 = require("./eventbuilder");
var transports_1 = require("./transports");
/**
 * The Sentry Browser SDK Backend.
 * @hidden
 */
var BrowserBackend = /** @class */ (function (_super) {
    tslib_1.__extends(BrowserBackend, _super);
    function BrowserBackend() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @inheritDoc
     */
    BrowserBackend.prototype.eventFromException = function (exception, hint) {
        return eventbuilder_1.eventFromException(this._options, exception, hint);
    };
    /**
     * @inheritDoc
     */
    BrowserBackend.prototype.eventFromMessage = function (message, level, hint) {
        if (level === void 0) { level = types_1.Severity.Info; }
        return eventbuilder_1.eventFromMessage(this._options, message, level, hint);
    };
    /**
     * @inheritDoc
     */
    BrowserBackend.prototype._setupTransport = function () {
        if (!this._options.dsn) {
            // We return the noop transport here in case there is no Dsn.
            return _super.prototype._setupTransport.call(this);
        }
        var transportOptions = tslib_1.__assign(tslib_1.__assign({}, this._options.transportOptions), { dsn: this._options.dsn, tunnel: this._options.tunnel, sendClientReports: this._options.sendClientReports, _metadata: this._options._metadata });
        if (this._options.transport) {
            return new this._options.transport(transportOptions);
        }
        if (utils_1.supportsFetch()) {
            return new transports_1.FetchTransport(transportOptions);
        }
        return new transports_1.XHRTransport(transportOptions);
    };
    return BrowserBackend;
}(core_1.BaseBackend));
exports.BrowserBackend = BrowserBackend;
//# sourceMappingURL=backend.js.map
      };
    };
  }
}, {package:"@sentry\\browser",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\browser\\dist\\backend.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\utils\\dist\\polyfill.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@sentry\utils\dist\polyfill.js
      return function (require, module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.setPrototypeOf = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
/**
 * setPrototypeOf polyfill using __proto__
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function setProtoOf(obj, proto) {
    // @ts-ignore __proto__ does not exist on obj
    obj.__proto__ = proto;
    return obj;
}
/**
 * setPrototypeOf polyfill using mixin
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function mixinProperties(obj, proto) {
    for (var prop in proto) {
        // eslint-disable-next-line no-prototype-builtins
        if (!obj.hasOwnProperty(prop)) {
            // @ts-ignore typescript complains about indexing so we remove
            obj[prop] = proto[prop];
        }
    }
    return obj;
}
//# sourceMappingURL=polyfill.js.map
      };
    };
  }
}, {package:"@sentry\\utils",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\utils\\dist\\polyfill.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\browser\\dist\\transports\\utils.js", {"@sentry/utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\utils\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@sentry\browser\dist\transports\utils.js
      return function (require, module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("@sentry/utils");
var global = utils_1.getGlobalObject();
var cachedFetchImpl;
/**
 * A special usecase for incorrectly wrapped Fetch APIs in conjunction with ad-blockers.
 * Whenever someone wraps the Fetch API and returns the wrong promise chain,
 * this chain becomes orphaned and there is no possible way to capture it's rejections
 * other than allowing it bubble up to this very handler. eg.
 *
 * const f = window.fetch;
 * window.fetch = function () {
 *   const p = f.apply(this, arguments);
 *
 *   p.then(function() {
 *     console.log('hi.');
 *   });
 *
 *   return p;
 * }
 *
 * `p.then(function () { ... })` is producing a completely separate promise chain,
 * however, what's returned is `p` - the result of original `fetch` call.
 *
 * This mean, that whenever we use the Fetch API to send our own requests, _and_
 * some ad-blocker blocks it, this orphaned chain will _always_ reject,
 * effectively causing another event to be captured.
 * This makes a whole process become an infinite loop, which we need to somehow
 * deal with, and break it in one way or another.
 *
 * To deal with this issue, we are making sure that we _always_ use the real
 * browser Fetch API, instead of relying on what `window.fetch` exposes.
 * The only downside to this would be missing our own requests as breadcrumbs,
 * but because we are already not doing this, it should be just fine.
 *
 * Possible failed fetch error messages per-browser:
 *
 * Chrome:  Failed to fetch
 * Edge:    Failed to Fetch
 * Firefox: NetworkError when attempting to fetch resource
 * Safari:  resource blocked by content blocker
 */
function getNativeFetchImplementation() {
    var _a, _b;
    if (cachedFetchImpl) {
        return cachedFetchImpl;
    }
    /* eslint-disable @typescript-eslint/unbound-method */
    // Fast path to avoid DOM I/O
    if (utils_1.isNativeFetch(global.fetch)) {
        return (cachedFetchImpl = global.fetch.bind(global));
    }
    var document = global.document;
    var fetchImpl = global.fetch;
    // eslint-disable-next-line deprecation/deprecation
    if (typeof ((_a = document) === null || _a === void 0 ? void 0 : _a.createElement) === "function") {
        try {
            var sandbox = document.createElement('iframe');
            sandbox.hidden = true;
            document.head.appendChild(sandbox);
            if ((_b = sandbox.contentWindow) === null || _b === void 0 ? void 0 : _b.fetch) {
                fetchImpl = sandbox.contentWindow.fetch;
            }
            document.head.removeChild(sandbox);
        }
        catch (e) {
            utils_1.logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', e);
        }
    }
    return (cachedFetchImpl = fetchImpl.bind(global));
    /* eslint-enable @typescript-eslint/unbound-method */
}
exports.getNativeFetchImplementation = getNativeFetchImplementation;
/**
 * Sends sdk client report using sendBeacon or fetch as a fallback if available
 *
 * @param url report endpoint
 * @param body report payload
 */
function sendReport(url, body) {
    var isRealNavigator = Object.prototype.toString.call(global && global.navigator) === '[object Navigator]';
    var hasSendBeacon = isRealNavigator && typeof global.navigator.sendBeacon === 'function';
    if (hasSendBeacon) {
        // Prevent illegal invocations - https://xgwang.me/posts/you-may-not-know-beacon/#it-may-throw-error%2C-be-sure-to-catch
        var sendBeacon = global.navigator.sendBeacon.bind(global.navigator);
        return sendBeacon(url, body);
    }
    if (utils_1.supportsFetch()) {
        var fetch_1 = getNativeFetchImplementation();
        return utils_1.forget(fetch_1(url, {
            body: body,
            method: 'POST',
            credentials: 'omit',
            keepalive: true,
        }));
    }
}
exports.sendReport = sendReport;
//# sourceMappingURL=utils.js.map
      };
    };
  }
}, {package:"@sentry\\browser",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\browser\\dist\\transports\\utils.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\core\\dist\\integration.js", {"@sentry/hub":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\hub\\dist\\index.js","@sentry/utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\utils\\dist\\index.js","tslib":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tslib\\tslib.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@sentry\core\dist\integration.js
      return function (require, module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var hub_1 = require("@sentry/hub");
var utils_1 = require("@sentry/utils");
exports.installedIntegrations = [];
/**
 * @private
 */
function filterDuplicates(integrations) {
    return integrations.reduce(function (acc, integrations) {
        if (acc.every(function (accIntegration) { return integrations.name !== accIntegration.name; })) {
            acc.push(integrations);
        }
        return acc;
    }, []);
}
/** Gets integration to install */
function getIntegrationsToSetup(options) {
    var defaultIntegrations = (options.defaultIntegrations && tslib_1.__spread(options.defaultIntegrations)) || [];
    var userIntegrations = options.integrations;
    var integrations = tslib_1.__spread(filterDuplicates(defaultIntegrations));
    if (Array.isArray(userIntegrations)) {
        // Filter out integrations that are also included in user options
        integrations = tslib_1.__spread(integrations.filter(function (integrations) {
            return userIntegrations.every(function (userIntegration) { return userIntegration.name !== integrations.name; });
        }), filterDuplicates(userIntegrations));
    }
    else if (typeof userIntegrations === 'function') {
        integrations = userIntegrations(integrations);
        integrations = Array.isArray(integrations) ? integrations : [integrations];
    }
    // Make sure that if present, `Debug` integration will always run last
    var integrationsNames = integrations.map(function (i) { return i.name; });
    var alwaysLastToRun = 'Debug';
    if (integrationsNames.indexOf(alwaysLastToRun) !== -1) {
        integrations.push.apply(integrations, tslib_1.__spread(integrations.splice(integrationsNames.indexOf(alwaysLastToRun), 1)));
    }
    return integrations;
}
exports.getIntegrationsToSetup = getIntegrationsToSetup;
/** Setup given integration */
function setupIntegration(integration) {
    if (exports.installedIntegrations.indexOf(integration.name) !== -1) {
        return;
    }
    integration.setupOnce(hub_1.addGlobalEventProcessor, hub_1.getCurrentHub);
    exports.installedIntegrations.push(integration.name);
    utils_1.logger.log("Integration installed: " + integration.name);
}
exports.setupIntegration = setupIntegration;
/**
 * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default
 * integrations are added unless they were already provided before.
 * @param integrations array of integration instances
 * @param withDefault should enable default integrations
 */
function setupIntegrations(options) {
    var integrations = {};
    getIntegrationsToSetup(options).forEach(function (integration) {
        integrations[integration.name] = integration;
        setupIntegration(integration);
    });
    // set the `initialized` flag so we don't run through the process again unecessarily; use `Object.defineProperty`
    // because by default it creates a property which is nonenumerable, which we want since `initialized` shouldn't be
    // considered a member of the index the way the actual integrations are
    Object.defineProperty(integrations, 'initialized', { value: true });
    return integrations;
}
exports.setupIntegrations = setupIntegrations;
//# sourceMappingURL=integration.js.map
      };
    };
  }
}, {package:"@sentry\\core",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\core\\dist\\integration.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\core\\dist\\integrations\\functiontostring.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@sentry\core\dist\integrations\functiontostring.js
      return function (require, module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var originalFunctionToString;
/** Patch toString calls to return proper name for wrapped functions */
var FunctionToString = /** @class */ (function () {
    function FunctionToString() {
        /**
         * @inheritDoc
         */
        this.name = FunctionToString.id;
    }
    /**
     * @inheritDoc
     */
    FunctionToString.prototype.setupOnce = function () {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        originalFunctionToString = Function.prototype.toString;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Function.prototype.toString = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var context = this.__sentry_original__ || this;
            return originalFunctionToString.apply(context, args);
        };
    };
    /**
     * @inheritDoc
     */
    FunctionToString.id = 'FunctionToString';
    return FunctionToString;
}());
exports.FunctionToString = FunctionToString;
//# sourceMappingURL=functiontostring.js.map
      };
    };
  }
}, {package:"@sentry\\core",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\core\\dist\\integrations\\functiontostring.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\core\\dist\\integrations\\inboundfilters.js", {"@sentry/hub":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\hub\\dist\\index.js","@sentry/utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\utils\\dist\\index.js","tslib":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tslib\\tslib.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@sentry\core\dist\integrations\inboundfilters.js
      return function (require, module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var hub_1 = require("@sentry/hub");
var utils_1 = require("@sentry/utils");
// "Script error." is hard coded into browsers for errors that it can't read.
// this is the result of a script being pulled in from an external domain and CORS.
var DEFAULT_IGNORE_ERRORS = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/];
/** Inbound filters configurable by the user */
var InboundFilters = /** @class */ (function () {
    function InboundFilters(_options) {
        if (_options === void 0) { _options = {}; }
        this._options = _options;
        /**
         * @inheritDoc
         */
        this.name = InboundFilters.id;
    }
    /**
     * @inheritDoc
     */
    InboundFilters.prototype.setupOnce = function () {
        hub_1.addGlobalEventProcessor(function (event) {
            var hub = hub_1.getCurrentHub();
            if (!hub) {
                return event;
            }
            var self = hub.getIntegration(InboundFilters);
            if (self) {
                var client = hub.getClient();
                var clientOptions = client ? client.getOptions() : {};
                // This checks prevents most of the occurrences of the bug linked below:
                // https://github.com/getsentry/sentry-javascript/issues/2622
                // The bug is caused by multiple SDK instances, where one is minified and one is using non-mangled code.
                // Unfortunatelly we cannot fix it reliably (thus reserved property in rollup's terser config),
                // as we cannot force people using multiple instances in their apps to sync SDK versions.
                var options = typeof self._mergeOptions === 'function' ? self._mergeOptions(clientOptions) : {};
                if (typeof self._shouldDropEvent !== 'function') {
                    return event;
                }
                return self._shouldDropEvent(event, options) ? null : event;
            }
            return event;
        });
    };
    /** JSDoc */
    InboundFilters.prototype._shouldDropEvent = function (event, options) {
        if (this._isSentryError(event, options)) {
            utils_1.logger.warn("Event dropped due to being internal Sentry Error.\nEvent: " + utils_1.getEventDescription(event));
            return true;
        }
        if (this._isIgnoredError(event, options)) {
            utils_1.logger.warn("Event dropped due to being matched by `ignoreErrors` option.\nEvent: " + utils_1.getEventDescription(event));
            return true;
        }
        if (this._isDeniedUrl(event, options)) {
            utils_1.logger.warn("Event dropped due to being matched by `denyUrls` option.\nEvent: " + utils_1.getEventDescription(event) + ".\nUrl: " + this._getEventFilterUrl(event));
            return true;
        }
        if (!this._isAllowedUrl(event, options)) {
            utils_1.logger.warn("Event dropped due to not being matched by `allowUrls` option.\nEvent: " + utils_1.getEventDescription(event) + ".\nUrl: " + this._getEventFilterUrl(event));
            return true;
        }
        return false;
    };
    /** JSDoc */
    InboundFilters.prototype._isSentryError = function (event, options) {
        if (!options.ignoreInternal) {
            return false;
        }
        try {
            return ((event &&
                event.exception &&
                event.exception.values &&
                event.exception.values[0] &&
                event.exception.values[0].type === 'SentryError') ||
                false);
        }
        catch (_oO) {
            return false;
        }
    };
    /** JSDoc */
    InboundFilters.prototype._isIgnoredError = function (event, options) {
        if (!options.ignoreErrors || !options.ignoreErrors.length) {
            return false;
        }
        return this._getPossibleEventMessages(event).some(function (message) {
            // Not sure why TypeScript complains here...
            return options.ignoreErrors.some(function (pattern) { return utils_1.isMatchingPattern(message, pattern); });
        });
    };
    /** JSDoc */
    InboundFilters.prototype._isDeniedUrl = function (event, options) {
        // TODO: Use Glob instead?
        if (!options.denyUrls || !options.denyUrls.length) {
            return false;
        }
        var url = this._getEventFilterUrl(event);
        return !url ? false : options.denyUrls.some(function (pattern) { return utils_1.isMatchingPattern(url, pattern); });
    };
    /** JSDoc */
    InboundFilters.prototype._isAllowedUrl = function (event, options) {
        // TODO: Use Glob instead?
        if (!options.allowUrls || !options.allowUrls.length) {
            return true;
        }
        var url = this._getEventFilterUrl(event);
        return !url ? true : options.allowUrls.some(function (pattern) { return utils_1.isMatchingPattern(url, pattern); });
    };
    /** JSDoc */
    InboundFilters.prototype._mergeOptions = function (clientOptions) {
        if (clientOptions === void 0) { clientOptions = {}; }
        return {
            allowUrls: tslib_1.__spread((this._options.whitelistUrls || []), (this._options.allowUrls || []), (clientOptions.whitelistUrls || []), (clientOptions.allowUrls || [])),
            denyUrls: tslib_1.__spread((this._options.blacklistUrls || []), (this._options.denyUrls || []), (clientOptions.blacklistUrls || []), (clientOptions.denyUrls || [])),
            ignoreErrors: tslib_1.__spread((this._options.ignoreErrors || []), (clientOptions.ignoreErrors || []), DEFAULT_IGNORE_ERRORS),
            ignoreInternal: typeof this._options.ignoreInternal !== 'undefined' ? this._options.ignoreInternal : true,
        };
    };
    /** JSDoc */
    InboundFilters.prototype._getPossibleEventMessages = function (event) {
        if (event.message) {
            return [event.message];
        }
        if (event.exception) {
            try {
                var _a = (event.exception.values && event.exception.values[0]) || {}, _b = _a.type, type = _b === void 0 ? '' : _b, _c = _a.value, value = _c === void 0 ? '' : _c;
                return ["" + value, type + ": " + value];
            }
            catch (oO) {
                utils_1.logger.error("Cannot extract message for event " + utils_1.getEventDescription(event));
                return [];
            }
        }
        return [];
    };
    /** JSDoc */
    InboundFilters.prototype._getLastValidUrl = function (frames) {
        if (frames === void 0) { frames = []; }
        var _a, _b;
        for (var i = frames.length - 1; i >= 0; i--) {
            var frame = frames[i];
            if (((_a = frame) === null || _a === void 0 ? void 0 : _a.filename) !== '<anonymous>' && ((_b = frame) === null || _b === void 0 ? void 0 : _b.filename) !== '[native code]') {
                return frame.filename || null;
            }
        }
        return null;
    };
    /** JSDoc */
    InboundFilters.prototype._getEventFilterUrl = function (event) {
        try {
            if (event.stacktrace) {
                var frames_1 = event.stacktrace.frames;
                return this._getLastValidUrl(frames_1);
            }
            if (event.exception) {
                var frames_2 = event.exception.values && event.exception.values[0].stacktrace && event.exception.values[0].stacktrace.frames;
                return this._getLastValidUrl(frames_2);
            }
            return null;
        }
        catch (oO) {
            utils_1.logger.error("Cannot extract url for event " + utils_1.getEventDescription(event));
            return null;
        }
    };
    /**
     * @inheritDoc
     */
    InboundFilters.id = 'InboundFilters';
    return InboundFilters;
}());
exports.InboundFilters = InboundFilters;
//# sourceMappingURL=inboundfilters.js.map
      };
    };
  }
}, {package:"@sentry\\core",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\core\\dist\\integrations\\inboundfilters.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\hub\\dist\\sessionflusher.js", {"./hub":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\hub\\dist\\hub.js","@sentry/types":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\types\\dist\\index.js","@sentry/utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\utils\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@sentry\hub\dist\sessionflusher.js
      return function (require, module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var types_1 = require("@sentry/types");
var utils_1 = require("@sentry/utils");
var hub_1 = require("./hub");
/**
 * @inheritdoc
 */
var SessionFlusher = /** @class */ (function () {
    function SessionFlusher(transport, attrs) {
        var _this = this;
        this.flushTimeout = 60;
        this._pendingAggregates = {};
        this._isEnabled = true;
        this._transport = transport;
        // Call to setInterval, so that flush is called every 60 seconds
        this._intervalId = setInterval(function () { return _this.flush(); }, this.flushTimeout * 1000);
        this._sessionAttrs = attrs;
    }
    /** Sends session aggregates to Transport */
    SessionFlusher.prototype.sendSessionAggregates = function (sessionAggregates) {
        if (!this._transport.sendSession) {
            utils_1.logger.warn("Dropping session because custom transport doesn't implement sendSession");
            return;
        }
        void this._transport.sendSession(sessionAggregates).then(null, function (reason) {
            utils_1.logger.error("Error while sending session: " + reason);
        });
    };
    /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSessions` */
    SessionFlusher.prototype.flush = function () {
        var sessionAggregates = this.getSessionAggregates();
        if (sessionAggregates.aggregates.length === 0) {
            return;
        }
        this._pendingAggregates = {};
        this.sendSessionAggregates(sessionAggregates);
    };
    /** Massages the entries in `pendingAggregates` and returns aggregated sessions */
    SessionFlusher.prototype.getSessionAggregates = function () {
        var _this = this;
        var aggregates = Object.keys(this._pendingAggregates).map(function (key) {
            return _this._pendingAggregates[parseInt(key)];
        });
        var sessionAggregates = {
            attrs: this._sessionAttrs,
            aggregates: aggregates,
        };
        return utils_1.dropUndefinedKeys(sessionAggregates);
    };
    /** JSDoc */
    SessionFlusher.prototype.close = function () {
        clearInterval(this._intervalId);
        this._isEnabled = false;
        this.flush();
    };
    /**
     * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then
     * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to
     * `_incrementSessionStatusCount` along with the start date
     */
    SessionFlusher.prototype.incrementSessionStatusCount = function () {
        var _a, _b;
        if (!this._isEnabled) {
            return;
        }
        var scope = hub_1.getCurrentHub().getScope();
        var requestSession = (_a = scope) === null || _a === void 0 ? void 0 : _a.getRequestSession();
        if (requestSession && requestSession.status) {
            this._incrementSessionStatusCount(requestSession.status, new Date());
            // This is not entirely necessarily but is added as a safe guard to indicate the bounds of a request and so in
            // case captureRequestSession is called more than once to prevent double count
            (_b = scope) === null || _b === void 0 ? void 0 : _b.setRequestSession(undefined);
            /* eslint-enable @typescript-eslint/no-unsafe-member-access */
        }
    };
    /**
     * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of
     * the session received
     */
    SessionFlusher.prototype._incrementSessionStatusCount = function (status, date) {
        // Truncate minutes and seconds on Session Started attribute to have one minute bucket keys
        var sessionStartedTrunc = new Date(date).setSeconds(0, 0);
        this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};
        // corresponds to aggregated sessions in one specific minute bucket
        // for example, {"started":"2021-03-16T08:00:00.000Z","exited":4, "errored": 1}
        var aggregationCounts = this._pendingAggregates[sessionStartedTrunc];
        if (!aggregationCounts.started) {
            aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();
        }
        switch (status) {
            case types_1.RequestSessionStatus.Errored:
                aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;
                return aggregationCounts.errored;
            case types_1.RequestSessionStatus.Ok:
                aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;
                return aggregationCounts.exited;
            case types_1.RequestSessionStatus.Crashed:
                aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;
                return aggregationCounts.crashed;
        }
    };
    return SessionFlusher;
}());
exports.SessionFlusher = SessionFlusher;
//# sourceMappingURL=sessionflusher.js.map
      };
    };
  }
}, {package:"@sentry\\hub",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\hub\\dist\\sessionflusher.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\hub\\dist\\scope.js", {"@sentry/utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\utils\\dist\\index.js","tslib":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tslib\\tslib.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@sentry\hub\dist\scope.js
      return function (require, module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var utils_1 = require("@sentry/utils");
/**
 * Absolute maximum number of breadcrumbs added to an event.
 * The `maxBreadcrumbs` option cannot be higher than this value.
 */
var MAX_BREADCRUMBS = 100;
/**
 * Holds additional event information. {@link Scope.applyToEvent} will be
 * called by the client before an event will be sent.
 */
var Scope = /** @class */ (function () {
    function Scope() {
        /** Flag if notifying is happening. */
        this._notifyingListeners = false;
        /** Callback for client to receive scope changes. */
        this._scopeListeners = [];
        /** Callback list that will be called after {@link applyToEvent}. */
        this._eventProcessors = [];
        /** Array of breadcrumbs. */
        this._breadcrumbs = [];
        /** User */
        this._user = {};
        /** Tags */
        this._tags = {};
        /** Extra */
        this._extra = {};
        /** Contexts */
        this._contexts = {};
    }
    /**
     * Inherit values from the parent scope.
     * @param scope to clone.
     */
    Scope.clone = function (scope) {
        var newScope = new Scope();
        if (scope) {
            newScope._breadcrumbs = tslib_1.__spread(scope._breadcrumbs);
            newScope._tags = tslib_1.__assign({}, scope._tags);
            newScope._extra = tslib_1.__assign({}, scope._extra);
            newScope._contexts = tslib_1.__assign({}, scope._contexts);
            newScope._user = scope._user;
            newScope._level = scope._level;
            newScope._span = scope._span;
            newScope._session = scope._session;
            newScope._transactionName = scope._transactionName;
            newScope._fingerprint = scope._fingerprint;
            newScope._eventProcessors = tslib_1.__spread(scope._eventProcessors);
            newScope._requestSession = scope._requestSession;
        }
        return newScope;
    };
    /**
     * Add internal on change listener. Used for sub SDKs that need to store the scope.
     * @hidden
     */
    Scope.prototype.addScopeListener = function (callback) {
        this._scopeListeners.push(callback);
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.addEventProcessor = function (callback) {
        this._eventProcessors.push(callback);
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setUser = function (user) {
        this._user = user || {};
        if (this._session) {
            this._session.update({ user: user });
        }
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.getUser = function () {
        return this._user;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.getRequestSession = function () {
        return this._requestSession;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setRequestSession = function (requestSession) {
        this._requestSession = requestSession;
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setTags = function (tags) {
        this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), tags);
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setTag = function (key, value) {
        var _a;
        this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), (_a = {}, _a[key] = value, _a));
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setExtras = function (extras) {
        this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), extras);
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setExtra = function (key, extra) {
        var _a;
        this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), (_a = {}, _a[key] = extra, _a));
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setFingerprint = function (fingerprint) {
        this._fingerprint = fingerprint;
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setLevel = function (level) {
        this._level = level;
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setTransactionName = function (name) {
        this._transactionName = name;
        this._notifyScopeListeners();
        return this;
    };
    /**
     * Can be removed in major version.
     * @deprecated in favor of {@link this.setTransactionName}
     */
    Scope.prototype.setTransaction = function (name) {
        return this.setTransactionName(name);
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setContext = function (key, context) {
        var _a;
        if (context === null) {
            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
            delete this._contexts[key];
        }
        else {
            this._contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), (_a = {}, _a[key] = context, _a));
        }
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setSpan = function (span) {
        this._span = span;
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.getSpan = function () {
        return this._span;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.getTransaction = function () {
        var _a, _b, _c, _d;
        // often, this span will be a transaction, but it's not guaranteed to be
        var span = this.getSpan();
        // try it the new way first
        if ((_a = span) === null || _a === void 0 ? void 0 : _a.transaction) {
            return (_b = span) === null || _b === void 0 ? void 0 : _b.transaction;
        }
        // fallback to the old way (known bug: this only finds transactions with sampled = true)
        if ((_d = (_c = span) === null || _c === void 0 ? void 0 : _c.spanRecorder) === null || _d === void 0 ? void 0 : _d.spans[0]) {
            return span.spanRecorder.spans[0];
        }
        // neither way found a transaction
        return undefined;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.setSession = function (session) {
        if (!session) {
            delete this._session;
        }
        else {
            this._session = session;
        }
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.getSession = function () {
        return this._session;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.update = function (captureContext) {
        if (!captureContext) {
            return this;
        }
        if (typeof captureContext === 'function') {
            var updatedScope = captureContext(this);
            return updatedScope instanceof Scope ? updatedScope : this;
        }
        if (captureContext instanceof Scope) {
            this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), captureContext._tags);
            this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), captureContext._extra);
            this._contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), captureContext._contexts);
            if (captureContext._user && Object.keys(captureContext._user).length) {
                this._user = captureContext._user;
            }
            if (captureContext._level) {
                this._level = captureContext._level;
            }
            if (captureContext._fingerprint) {
                this._fingerprint = captureContext._fingerprint;
            }
            if (captureContext._requestSession) {
                this._requestSession = captureContext._requestSession;
            }
        }
        else if (utils_1.isPlainObject(captureContext)) {
            // eslint-disable-next-line no-param-reassign
            captureContext = captureContext;
            this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), captureContext.tags);
            this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), captureContext.extra);
            this._contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), captureContext.contexts);
            if (captureContext.user) {
                this._user = captureContext.user;
            }
            if (captureContext.level) {
                this._level = captureContext.level;
            }
            if (captureContext.fingerprint) {
                this._fingerprint = captureContext.fingerprint;
            }
            if (captureContext.requestSession) {
                this._requestSession = captureContext.requestSession;
            }
        }
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.clear = function () {
        this._breadcrumbs = [];
        this._tags = {};
        this._extra = {};
        this._user = {};
        this._contexts = {};
        this._level = undefined;
        this._transactionName = undefined;
        this._fingerprint = undefined;
        this._requestSession = undefined;
        this._span = undefined;
        this._session = undefined;
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.addBreadcrumb = function (breadcrumb, maxBreadcrumbs) {
        var maxCrumbs = typeof maxBreadcrumbs === 'number' ? Math.min(maxBreadcrumbs, MAX_BREADCRUMBS) : MAX_BREADCRUMBS;
        // No data has been changed, so don't notify scope listeners
        if (maxCrumbs <= 0) {
            return this;
        }
        var mergedBreadcrumb = tslib_1.__assign({ timestamp: utils_1.dateTimestampInSeconds() }, breadcrumb);
        this._breadcrumbs = tslib_1.__spread(this._breadcrumbs, [mergedBreadcrumb]).slice(-maxCrumbs);
        this._notifyScopeListeners();
        return this;
    };
    /**
     * @inheritDoc
     */
    Scope.prototype.clearBreadcrumbs = function () {
        this._breadcrumbs = [];
        this._notifyScopeListeners();
        return this;
    };
    /**
     * Applies the current context and fingerprint to the event.
     * Note that breadcrumbs will be added by the client.
     * Also if the event has already breadcrumbs on it, we do not merge them.
     * @param event Event
     * @param hint May contain additional information about the original exception.
     * @hidden
     */
    Scope.prototype.applyToEvent = function (event, hint) {
        var _a;
        if (this._extra && Object.keys(this._extra).length) {
            event.extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), event.extra);
        }
        if (this._tags && Object.keys(this._tags).length) {
            event.tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), event.tags);
        }
        if (this._user && Object.keys(this._user).length) {
            event.user = tslib_1.__assign(tslib_1.__assign({}, this._user), event.user);
        }
        if (this._contexts && Object.keys(this._contexts).length) {
            event.contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), event.contexts);
        }
        if (this._level) {
            event.level = this._level;
        }
        if (this._transactionName) {
            event.transaction = this._transactionName;
        }
        // We want to set the trace context for normal events only if there isn't already
        // a trace context on the event. There is a product feature in place where we link
        // errors with transaction and it relies on that.
        if (this._span) {
            event.contexts = tslib_1.__assign({ trace: this._span.getTraceContext() }, event.contexts);
            var transactionName = (_a = this._span.transaction) === null || _a === void 0 ? void 0 : _a.name;
            if (transactionName) {
                event.tags = tslib_1.__assign({ transaction: transactionName }, event.tags);
            }
        }
        this._applyFingerprint(event);
        event.breadcrumbs = tslib_1.__spread((event.breadcrumbs || []), this._breadcrumbs);
        event.breadcrumbs = event.breadcrumbs.length > 0 ? event.breadcrumbs : undefined;
        return this._notifyEventProcessors(tslib_1.__spread(getGlobalEventProcessors(), this._eventProcessors), event, hint);
    };
    /**
     * This will be called after {@link applyToEvent} is finished.
     */
    Scope.prototype._notifyEventProcessors = function (processors, event, hint, index) {
        var _this = this;
        if (index === void 0) { index = 0; }
        return new utils_1.SyncPromise(function (resolve, reject) {
            var processor = processors[index];
            if (event === null || typeof processor !== 'function') {
                resolve(event);
            }
            else {
                var result = processor(tslib_1.__assign({}, event), hint);
                if (utils_1.isThenable(result)) {
                    void result
                        .then(function (final) { return _this._notifyEventProcessors(processors, final, hint, index + 1).then(resolve); })
                        .then(null, reject);
                }
                else {
                    void _this._notifyEventProcessors(processors, result, hint, index + 1)
                        .then(resolve)
                        .then(null, reject);
                }
            }
        });
    };
    /**
     * This will be called on every set call.
     */
    Scope.prototype._notifyScopeListeners = function () {
        var _this = this;
        // We need this check for this._notifyingListeners to be able to work on scope during updates
        // If this check is not here we'll produce endless recursion when something is done with the scope
        // during the callback.
        if (!this._notifyingListeners) {
            this._notifyingListeners = true;
            this._scopeListeners.forEach(function (callback) {
                callback(_this);
            });
            this._notifyingListeners = false;
        }
    };
    /**
     * Applies fingerprint from the scope to the event if there's one,
     * uses message if there's one instead or get rid of empty fingerprint
     */
    Scope.prototype._applyFingerprint = function (event) {
        // Make sure it's an array first and we actually have something in place
        event.fingerprint = event.fingerprint
            ? Array.isArray(event.fingerprint)
                ? event.fingerprint
                : [event.fingerprint]
            : [];
        // If we have something on the scope, then merge it with event
        if (this._fingerprint) {
            event.fingerprint = event.fingerprint.concat(this._fingerprint);
        }
        // If we have no data at all, remove empty array default
        if (event.fingerprint && !event.fingerprint.length) {
            delete event.fingerprint;
        }
    };
    return Scope;
}());
exports.Scope = Scope;
/**
 * Returns the global event processors.
 */
function getGlobalEventProcessors() {
    /* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access  */
    var global = utils_1.getGlobalObject();
    global.__SENTRY__ = global.__SENTRY__ || {};
    global.__SENTRY__.globalEventProcessors = global.__SENTRY__.globalEventProcessors || [];
    return global.__SENTRY__.globalEventProcessors;
    /* eslint-enable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access */
}
/**
 * Add a EventProcessor to be kept globally.
 * @param callback EventProcessor to add
 */
function addGlobalEventProcessor(callback) {
    getGlobalEventProcessors().push(callback);
}
exports.addGlobalEventProcessor = addGlobalEventProcessor;
//# sourceMappingURL=scope.js.map
      };
    };
  }
}, {package:"@sentry\\hub",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\hub\\dist\\scope.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\hub\\dist\\session.js", {"@sentry/types":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\types\\dist\\index.js","@sentry/utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\utils\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@sentry\hub\dist\session.js
      return function (require, module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var types_1 = require("@sentry/types");
var utils_1 = require("@sentry/utils");
/**
 * @inheritdoc
 */
var Session = /** @class */ (function () {
    function Session(context) {
        this.errors = 0;
        this.sid = utils_1.uuid4();
        this.duration = 0;
        this.status = types_1.SessionStatus.Ok;
        this.init = true;
        this.ignoreDuration = false;
        // Both timestamp and started are in seconds since the UNIX epoch.
        var startingTime = utils_1.timestampInSeconds();
        this.timestamp = startingTime;
        this.started = startingTime;
        if (context) {
            this.update(context);
        }
    }
    /** JSDoc */
    // eslint-disable-next-line complexity
    Session.prototype.update = function (context) {
        if (context === void 0) { context = {}; }
        if (context.user) {
            if (!this.ipAddress && context.user.ip_address) {
                this.ipAddress = context.user.ip_address;
            }
            if (!this.did && !context.did) {
                this.did = context.user.id || context.user.email || context.user.username;
            }
        }
        this.timestamp = context.timestamp || utils_1.timestampInSeconds();
        if (context.ignoreDuration) {
            this.ignoreDuration = context.ignoreDuration;
        }
        if (context.sid) {
            // Good enough uuid validation. — Kamil
            this.sid = context.sid.length === 32 ? context.sid : utils_1.uuid4();
        }
        if (context.init !== undefined) {
            this.init = context.init;
        }
        if (!this.did && context.did) {
            this.did = "" + context.did;
        }
        if (typeof context.started === 'number') {
            this.started = context.started;
        }
        if (this.ignoreDuration) {
            this.duration = undefined;
        }
        else if (typeof context.duration === 'number') {
            this.duration = context.duration;
        }
        else {
            var duration = this.timestamp - this.started;
            this.duration = duration >= 0 ? duration : 0;
        }
        if (context.release) {
            this.release = context.release;
        }
        if (context.environment) {
            this.environment = context.environment;
        }
        if (!this.ipAddress && context.ipAddress) {
            this.ipAddress = context.ipAddress;
        }
        if (!this.userAgent && context.userAgent) {
            this.userAgent = context.userAgent;
        }
        if (typeof context.errors === 'number') {
            this.errors = context.errors;
        }
        if (context.status) {
            this.status = context.status;
        }
    };
    /** JSDoc */
    Session.prototype.close = function (status) {
        if (status) {
            this.update({ status: status });
        }
        else if (this.status === types_1.SessionStatus.Ok) {
            this.update({ status: types_1.SessionStatus.Exited });
        }
        else {
            this.update();
        }
    };
    /** JSDoc */
    Session.prototype.toJSON = function () {
        return utils_1.dropUndefinedKeys({
            sid: "" + this.sid,
            init: this.init,
            // Make sure that sec is converted to ms for date constructor
            started: new Date(this.started * 1000).toISOString(),
            timestamp: new Date(this.timestamp * 1000).toISOString(),
            status: this.status,
            errors: this.errors,
            did: typeof this.did === 'number' || typeof this.did === 'string' ? "" + this.did : undefined,
            duration: this.duration,
            attrs: utils_1.dropUndefinedKeys({
                release: this.release,
                environment: this.environment,
                ip_address: this.ipAddress,
                user_agent: this.userAgent,
            }),
        });
    };
    return Session;
}());
exports.Session = Session;
//# sourceMappingURL=session.js.map
      };
    };
  }
}, {package:"@sentry\\hub",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\hub\\dist\\session.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\hub\\dist\\hub.js", {"./scope":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\hub\\dist\\scope.js","./session":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\hub\\dist\\session.js","@sentry/types":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\types\\dist\\index.js","@sentry/utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\utils\\dist\\index.js","tslib":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tslib\\tslib.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@sentry\hub\dist\hub.js
      return function (require, module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/* eslint-disable max-lines */
var types_1 = require("@sentry/types");
var utils_1 = require("@sentry/utils");
var scope_1 = require("./scope");
var session_1 = require("./session");
/**
 * API compatibility version of this hub.
 *
 * WARNING: This number should only be increased when the global interface
 * changes and new methods are introduced.
 *
 * @hidden
 */
exports.API_VERSION = 4;
/**
 * Default maximum number of breadcrumbs added to an event. Can be overwritten
 * with {@link Options.maxBreadcrumbs}.
 */
var DEFAULT_BREADCRUMBS = 100;
/**
 * @inheritDoc
 */
var Hub = /** @class */ (function () {
    /**
     * Creates a new instance of the hub, will push one {@link Layer} into the
     * internal stack on creation.
     *
     * @param client bound to the hub.
     * @param scope bound to the hub.
     * @param version number, higher number means higher priority.
     */
    function Hub(client, scope, _version) {
        if (scope === void 0) { scope = new scope_1.Scope(); }
        if (_version === void 0) { _version = exports.API_VERSION; }
        this._version = _version;
        /** Is a {@link Layer}[] containing the client and scope */
        this._stack = [{}];
        this.getStackTop().scope = scope;
        if (client) {
            this.bindClient(client);
        }
    }
    /**
     * @inheritDoc
     */
    Hub.prototype.isOlderThan = function (version) {
        return this._version < version;
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.bindClient = function (client) {
        var top = this.getStackTop();
        top.client = client;
        if (client && client.setupIntegrations) {
            client.setupIntegrations();
        }
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.pushScope = function () {
        // We want to clone the content of prev scope
        var scope = scope_1.Scope.clone(this.getScope());
        this.getStack().push({
            client: this.getClient(),
            scope: scope,
        });
        return scope;
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.popScope = function () {
        if (this.getStack().length <= 1)
            return false;
        return !!this.getStack().pop();
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.withScope = function (callback) {
        var scope = this.pushScope();
        try {
            callback(scope);
        }
        finally {
            this.popScope();
        }
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.getClient = function () {
        return this.getStackTop().client;
    };
    /** Returns the scope of the top stack. */
    Hub.prototype.getScope = function () {
        return this.getStackTop().scope;
    };
    /** Returns the scope stack for domains or the process. */
    Hub.prototype.getStack = function () {
        return this._stack;
    };
    /** Returns the topmost scope layer in the order domain > local > process. */
    Hub.prototype.getStackTop = function () {
        return this._stack[this._stack.length - 1];
    };
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    Hub.prototype.captureException = function (exception, hint) {
        var eventId = (this._lastEventId = utils_1.uuid4());
        var finalHint = hint;
        // If there's no explicit hint provided, mimic the same thing that would happen
        // in the minimal itself to create a consistent behavior.
        // We don't do this in the client, as it's the lowest level API, and doing this,
        // would prevent user from having full control over direct calls.
        if (!hint) {
            var syntheticException = void 0;
            try {
                throw new Error('Sentry syntheticException');
            }
            catch (exception) {
                syntheticException = exception;
            }
            finalHint = {
                originalException: exception,
                syntheticException: syntheticException,
            };
        }
        this._invokeClient('captureException', exception, tslib_1.__assign(tslib_1.__assign({}, finalHint), { event_id: eventId }));
        return eventId;
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.captureMessage = function (message, level, hint) {
        var eventId = (this._lastEventId = utils_1.uuid4());
        var finalHint = hint;
        // If there's no explicit hint provided, mimic the same thing that would happen
        // in the minimal itself to create a consistent behavior.
        // We don't do this in the client, as it's the lowest level API, and doing this,
        // would prevent user from having full control over direct calls.
        if (!hint) {
            var syntheticException = void 0;
            try {
                throw new Error(message);
            }
            catch (exception) {
                syntheticException = exception;
            }
            finalHint = {
                originalException: message,
                syntheticException: syntheticException,
            };
        }
        this._invokeClient('captureMessage', message, level, tslib_1.__assign(tslib_1.__assign({}, finalHint), { event_id: eventId }));
        return eventId;
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.captureEvent = function (event, hint) {
        var eventId = utils_1.uuid4();
        if (event.type !== 'transaction') {
            this._lastEventId = eventId;
        }
        this._invokeClient('captureEvent', event, tslib_1.__assign(tslib_1.__assign({}, hint), { event_id: eventId }));
        return eventId;
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.lastEventId = function () {
        return this._lastEventId;
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.addBreadcrumb = function (breadcrumb, hint) {
        var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
        if (!scope || !client)
            return;
        // eslint-disable-next-line @typescript-eslint/unbound-method
        var _b = (client.getOptions && client.getOptions()) || {}, _c = _b.beforeBreadcrumb, beforeBreadcrumb = _c === void 0 ? null : _c, _d = _b.maxBreadcrumbs, maxBreadcrumbs = _d === void 0 ? DEFAULT_BREADCRUMBS : _d;
        if (maxBreadcrumbs <= 0)
            return;
        var timestamp = utils_1.dateTimestampInSeconds();
        var mergedBreadcrumb = tslib_1.__assign({ timestamp: timestamp }, breadcrumb);
        var finalBreadcrumb = beforeBreadcrumb
            ? utils_1.consoleSandbox(function () { return beforeBreadcrumb(mergedBreadcrumb, hint); })
            : mergedBreadcrumb;
        if (finalBreadcrumb === null)
            return;
        scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.setUser = function (user) {
        var scope = this.getScope();
        if (scope)
            scope.setUser(user);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.setTags = function (tags) {
        var scope = this.getScope();
        if (scope)
            scope.setTags(tags);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.setExtras = function (extras) {
        var scope = this.getScope();
        if (scope)
            scope.setExtras(extras);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.setTag = function (key, value) {
        var scope = this.getScope();
        if (scope)
            scope.setTag(key, value);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.setExtra = function (key, extra) {
        var scope = this.getScope();
        if (scope)
            scope.setExtra(key, extra);
    };
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Hub.prototype.setContext = function (name, context) {
        var scope = this.getScope();
        if (scope)
            scope.setContext(name, context);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.configureScope = function (callback) {
        var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
        if (scope && client) {
            callback(scope);
        }
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.run = function (callback) {
        var oldHub = makeMain(this);
        try {
            callback(this);
        }
        finally {
            makeMain(oldHub);
        }
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.getIntegration = function (integration) {
        var client = this.getClient();
        if (!client)
            return null;
        try {
            return client.getIntegration(integration);
        }
        catch (_oO) {
            utils_1.logger.warn("Cannot retrieve integration " + integration.id + " from the current Hub");
            return null;
        }
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.startSpan = function (context) {
        return this._callExtensionMethod('startSpan', context);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.startTransaction = function (context, customSamplingContext) {
        return this._callExtensionMethod('startTransaction', context, customSamplingContext);
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.traceHeaders = function () {
        return this._callExtensionMethod('traceHeaders');
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.captureSession = function (endSession) {
        if (endSession === void 0) { endSession = false; }
        // both send the update and pull the session from the scope
        if (endSession) {
            return this.endSession();
        }
        // only send the update
        this._sendSessionUpdate();
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.endSession = function () {
        var _a, _b, _c, _d, _e;
        (_c = (_b = (_a = this.getStackTop()) === null || _a === void 0 ? void 0 : _a.scope) === null || _b === void 0 ? void 0 : _b.getSession()) === null || _c === void 0 ? void 0 : _c.close();
        this._sendSessionUpdate();
        // the session is over; take it off of the scope
        (_e = (_d = this.getStackTop()) === null || _d === void 0 ? void 0 : _d.scope) === null || _e === void 0 ? void 0 : _e.setSession();
    };
    /**
     * @inheritDoc
     */
    Hub.prototype.startSession = function (context) {
        var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
        var _b = (client && client.getOptions()) || {}, release = _b.release, environment = _b.environment;
        // Will fetch userAgent if called from browser sdk
        var global = utils_1.getGlobalObject();
        var userAgent = (global.navigator || {}).userAgent;
        var session = new session_1.Session(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({ release: release,
            environment: environment }, (scope && { user: scope.getUser() })), (userAgent && { userAgent: userAgent })), context));
        if (scope) {
            // End existing session if there's one
            var currentSession = scope.getSession && scope.getSession();
            if (currentSession && currentSession.status === types_1.SessionStatus.Ok) {
                currentSession.update({ status: types_1.SessionStatus.Exited });
            }
            this.endSession();
            // Afterwards we set the new session on the scope
            scope.setSession(session);
        }
        return session;
    };
    /**
     * Sends the current Session on the scope
     */
    Hub.prototype._sendSessionUpdate = function () {
        var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
        if (!scope)
            return;
        var session = scope.getSession && scope.getSession();
        if (session) {
            if (client && client.captureSession) {
                client.captureSession(session);
            }
        }
    };
    /**
     * Internal helper function to call a method on the top client if it exists.
     *
     * @param method The method to call on the client.
     * @param args Arguments to pass to the client function.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Hub.prototype._invokeClient = function (method) {
        var _a;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var _b = this.getStackTop(), scope = _b.scope, client = _b.client;
        if (client && client[method]) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any
            (_a = client)[method].apply(_a, tslib_1.__spread(args, [scope]));
        }
    };
    /**
     * Calls global extension method and binding current instance to the function call
     */
    // @ts-ignore Function lacks ending return statement and return type does not include 'undefined'. ts(2366)
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Hub.prototype._callExtensionMethod = function (method) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var carrier = getMainCarrier();
        var sentry = carrier.__SENTRY__;
        if (sentry && sentry.extensions && typeof sentry.extensions[method] === 'function') {
            return sentry.extensions[method].apply(this, args);
        }
        utils_1.logger.warn("Extension method " + method + " couldn't be found, doing nothing.");
    };
    return Hub;
}());
exports.Hub = Hub;
/**
 * Returns the global shim registry.
 *
 * FIXME: This function is problematic, because despite always returning a valid Carrier,
 * it has an optional `__SENTRY__` property, which then in turn requires us to always perform an unnecessary check
 * at the call-site. We always access the carrier through this function, so we can guarantee that `__SENTRY__` is there.
 **/
function getMainCarrier() {
    var carrier = utils_1.getGlobalObject();
    carrier.__SENTRY__ = carrier.__SENTRY__ || {
        extensions: {},
        hub: undefined,
    };
    return carrier;
}
exports.getMainCarrier = getMainCarrier;
/**
 * Replaces the current main hub with the passed one on the global object
 *
 * @returns The old replaced hub
 */
function makeMain(hub) {
    var registry = getMainCarrier();
    var oldHub = getHubFromCarrier(registry);
    setHubOnCarrier(registry, hub);
    return oldHub;
}
exports.makeMain = makeMain;
/**
 * Returns the default hub instance.
 *
 * If a hub is already registered in the global carrier but this module
 * contains a more recent version, it replaces the registered version.
 * Otherwise, the currently registered hub will be returned.
 */
function getCurrentHub() {
    // Get main carrier (global for every environment)
    var registry = getMainCarrier();
    // If there's no hub, or its an old API, assign a new one
    if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(exports.API_VERSION)) {
        setHubOnCarrier(registry, new Hub());
    }
    // Prefer domains over global if they are there (applicable only to Node environment)
    if (utils_1.isNodeEnv()) {
        return getHubFromActiveDomain(registry);
    }
    // Return hub that lives on a global object
    return getHubFromCarrier(registry);
}
exports.getCurrentHub = getCurrentHub;
/**
 * Returns the active domain, if one exists
 * @deprecated No longer used; remove in v7
 * @returns The domain, or undefined if there is no active domain
 */
// eslint-disable-next-line deprecation/deprecation
function getActiveDomain() {
    utils_1.logger.warn('Function `getActiveDomain` is deprecated and will be removed in a future version.');
    var sentry = getMainCarrier().__SENTRY__;
    return sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;
}
exports.getActiveDomain = getActiveDomain;
/**
 * Try to read the hub from an active domain, and fallback to the registry if one doesn't exist
 * @returns discovered hub
 */
function getHubFromActiveDomain(registry) {
    var _a, _b, _c;
    try {
        var activeDomain = (_c = (_b = (_a = getMainCarrier().__SENTRY__) === null || _a === void 0 ? void 0 : _a.extensions) === null || _b === void 0 ? void 0 : _b.domain) === null || _c === void 0 ? void 0 : _c.active;
        // If there's no active domain, just return global hub
        if (!activeDomain) {
            return getHubFromCarrier(registry);
        }
        // If there's no hub on current domain, or it's an old API, assign a new one
        if (!hasHubOnCarrier(activeDomain) || getHubFromCarrier(activeDomain).isOlderThan(exports.API_VERSION)) {
            var registryHubTopStack = getHubFromCarrier(registry).getStackTop();
            setHubOnCarrier(activeDomain, new Hub(registryHubTopStack.client, scope_1.Scope.clone(registryHubTopStack.scope)));
        }
        // Return hub that lives on a domain
        return getHubFromCarrier(activeDomain);
    }
    catch (_Oo) {
        // Return hub that lives on a global object
        return getHubFromCarrier(registry);
    }
}
/**
 * This will tell whether a carrier has a hub on it or not
 * @param carrier object
 */
function hasHubOnCarrier(carrier) {
    return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
}
/**
 * This will create a new {@link Hub} and add to the passed object on
 * __SENTRY__.hub.
 * @param carrier object
 * @hidden
 */
function getHubFromCarrier(carrier) {
    if (carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub)
        return carrier.__SENTRY__.hub;
    carrier.__SENTRY__ = carrier.__SENTRY__ || {};
    carrier.__SENTRY__.hub = new Hub();
    return carrier.__SENTRY__.hub;
}
exports.getHubFromCarrier = getHubFromCarrier;
/**
 * This will set passed {@link Hub} on the passed object's __SENTRY__.hub attribute
 * @param carrier object
 * @param hub Hub
 * @returns A boolean indicating success or failure
 */
function setHubOnCarrier(carrier, hub) {
    if (!carrier)
        return false;
    carrier.__SENTRY__ = carrier.__SENTRY__ || {};
    carrier.__SENTRY__.hub = hub;
    return true;
}
exports.setHubOnCarrier = setHubOnCarrier;
//# sourceMappingURL=hub.js.map
      };
    };
  }
}, {package:"@sentry\\hub",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@sentry\\hub\\dist\\hub.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-rpc\\lib\\index.js", {"promise-to-callback":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\promise-to-callback\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethjs-rpc\lib\index.js
      return function (require, module, exports) {
'use strict';

var promiseToCallback = require('promise-to-callback');

module.exports = EthRPC;

/**
 * Constructs the EthRPC instance
 *
 * @method EthRPC
 * @param {Object} cprovider the eth rpc provider web3 standard..
 * @param {Object} options the options, if any
 * @returns {Object} ethrpc instance
 */
function EthRPC(cprovider, options) {
  var self = this;
  var optionsObject = options || {};

  if (!(this instanceof EthRPC)) {
    throw new Error('[ethjs-rpc] the EthRPC object requires the "new" flag in order to function normally (i.e. `const eth = new EthRPC(provider);`).');
  }

  self.options = Object.assign({
    jsonSpace: optionsObject.jsonSpace || 0,
    max: optionsObject.max || 9999999999999
  });
  self.idCounter = Math.floor(Math.random() * self.options.max);
  self.setProvider = function (provider) {
    if (typeof provider !== 'object') {
      throw new Error('[ethjs-rpc] the EthRPC object requires that the first input \'provider\' must be an object, got \'' + typeof provider + '\' (i.e. \'const eth = new EthRPC(provider);\')');
    }

    self.currentProvider = provider;
  };
  self.setProvider(cprovider);
}

/**
 * The main send async method
 *
 * @method sendAsync
 * @param {Object} payload the rpc payload object
 * @param {Function} cb the async standard callback
 * @callback {Object|Array|Boolean|String} vary result instance output
 */
EthRPC.prototype.sendAsync = function sendAsync(payload, callback) {
  var self = this;
  self.idCounter = self.idCounter % self.options.max;
  var parsedPayload = createPayload(payload, self.idCounter++);

  var promise = new Promise(function (resolve, reject) {
    self.currentProvider.sendAsync(parsedPayload, function (err, response) {
      var responseObject = response || {};

      if (err || responseObject.error) {
        var payloadErrorMessage = '[ethjs-rpc] ' + (responseObject.error && 'rpc' || '') + ' error with payload ' + JSON.stringify(parsedPayload, null, self.options.jsonSpace) + ' ' + (err ? String(err) : JSON.stringify(responseObject.error, null, self.options.jsonSpace));
        var payloadError = new Error(payloadErrorMessage);
        payloadError.value = err || responseObject.error;
        reject(payloadError);
        return;
      }

      resolve(responseObject.result);
      return;
    });
  });

  if (callback) {
    // connect promise resolve handlers to callback
    return promiseToCallback(promise)(callback);
  }

  // only return promise if no callback specified
  return promise;
};

/**
 * A simple create payload method
 *
 * @method createPayload
 * @param {Object} data the rpc payload data
 * @param {String} id the rpc data payload ID
 * @returns {Object} payload the completed payload object
 */
function createPayload(data, id) {
  return Object.assign({}, {
    id: id,
    jsonrpc: '2.0',
    params: []
  }, data);
}
      };
    };
  }
}, {package:"ethjs-rpc",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-rpc\\lib\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-format\\lib\\index.js", {"ethjs-schema":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-schema\\src\\schema.json","ethjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-util\\lib\\index.js","number-to-bn":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\number-to-bn\\src\\index.js","strip-hex-prefix":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\strip-hex-prefix\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethjs-format\lib\index.js
      return function (require, module, exports) {
'use strict';

var schema = require('ethjs-schema');
var util = require('ethjs-util');
var numberToBN = require('number-to-bn');
var stripHexPrefix = require('strip-hex-prefix');
var padToEven = util.padToEven;
var arrayContainsArray = util.arrayContainsArray;
var getBinarySize = util.getBinarySize;

/**
 * Format quantity values, either encode to hex or decode to BigNumber
 * should intake null, stringNumber, number, BN
 *
 * @method formatQuantity
 * @param {String|BigNumber|Number} value quantity or tag to convert
 * @param {Boolean} encode to hex or decode to BigNumber
 * @returns {Optional} output to BigNumber or string
 * @throws error if value is a float
 */
function formatQuantity(value, encode, pad) {
  if (['string', 'number', 'object'].indexOf(typeof value) === -1 || value === null) {
    return value;
  }

  var numberValue = numberToBN(value);
  var numPadding = pad && numberValue.toString(16).length % 2 ? '0' : '';

  if (numberToBN(value).isNeg()) {
    throw new Error('[ethjs-format] while formatting quantity \'' + numberValue.toString(10) + '\', invalid negative number. Number must be positive or zero.');
  }

  return encode ? '0x' + numPadding + numberValue.toString(16) : numberValue;
}

/**
 * Format quantity or tag, if tag bypass return, else format quantity
 * should intake null, stringNumber, number, BN, string tag
 *
 * @method formatQuantityOrTag
 * @param {String|BigNumber|Number} value quantity or tag to convert
 * @param {Boolean} encode encode the number to hex or decode to BigNumber
 * @returns {Object|String} output to BigNumber or string
 * @throws error if value is a float
 */
function formatQuantityOrTag(value, encode) {
  var output = value; // eslint-disable-line

  // if the value is a tag, bypass
  if (schema.tags.indexOf(value) === -1) {
    output = formatQuantity(value, encode);
  }

  return output;
}

/**
 * FormatData under strict conditions hex prefix
 *
 * @method formatData
 * @param {String} value the bytes data to be formatted
 * @param {Number} byteLength the required byte length (usually 20 or 32)
 * @returns {String} output output formatted data
 * @throws error if minimum length isnt met
 */
function formatData(value, byteLength) {
  var output = value; // eslint-disable-line
  var outputByteLength = 0; // eslint-disable-line

  // prefix only under strict conditions, else bypass
  if (typeof value === 'string') {
    output = '0x' + padToEven(stripHexPrefix(value));
    outputByteLength = getBinarySize(output);
  }

  // format double padded zeros.
  if (output === '0x00') {
    output = '0x0';
  }

  // throw if bytelength is not correct
  if (typeof byteLength === 'number' && value !== null && output !== '0x' && output !== '0x0' // support empty values
  && (!/^[0-9A-Fa-f]+$/.test(stripHexPrefix(output)) || outputByteLength !== 2 + byteLength * 2)) {
    throw new Error('[ethjs-format] hex string \'' + output + '\' must be an alphanumeric ' + (2 + byteLength * 2) + ' utf8 byte hex (chars: a-fA-F) string, is ' + outputByteLength + ' bytes');
  }

  return output;
}

/**
 * Format object, even with random RPC caviets
 *
 * @method formatObject
 * @param {String|Array} formatter the unit to convert to, default ether
 * @param {Object} value the object value
 * @param {Boolean} encode encode to hex or decode to BigNumber
 * @returns {Object} output object
 * @throws error if value is a float
 */
function formatObject(formatter, value, encode) {
  var output = Object.assign({}, value); // eslint-disable-line
  var formatObject = null; // eslint-disable-line

  // if the object is a string flag, then retreive the object
  if (typeof formatter === 'string') {
    if (formatter === 'Boolean|EthSyncing') {
      formatObject = Object.assign({}, schema.objects.EthSyncing);
    } else if (formatter === 'DATA|Transaction') {
      formatObject = Object.assign({}, schema.objects.Transaction);
    } else {
      formatObject = Object.assign({}, schema.objects[formatter]);
    }
  }

  // check if all required data keys are fulfilled
  if (!arrayContainsArray(Object.keys(value), formatObject.__required)) {
    // eslint-disable-line
    throw new Error('[ethjs-format] object ' + JSON.stringify(value) + ' must contain properties: ' + formatObject.__required.join(', ')); // eslint-disable-line
  }

  // assume formatObject is an object, go through keys and format each
  Object.keys(formatObject).forEach(function (valueKey) {
    if (valueKey !== '__required' && typeof value[valueKey] !== 'undefined') {
      output[valueKey] = format(formatObject[valueKey], value[valueKey], encode);
    }
  });

  return output;
}

/**
 * Format array
 *
 * @method formatArray
 * @param {String|Array} formatter the unit to convert to, default ether
 * @param {Object} value the value in question
 * @param {Boolean} encode encode to hex or decode to BigNumber
 * @param {Number} lengthRequirement the required minimum array length
 * @returns {Object} output object
 * @throws error if minimum length isnt met
 */
function formatArray(formatter, value, encode, lengthRequirement) {
  var output = value.slice(); // eslint-disable-line
  var formatObject = formatter; // eslint-disable-line

  // if the formatter is an array or data, then make format object an array data
  if (formatter === 'Array|DATA') {
    formatObject = ['D'];
  }

  // if formatter is a FilterChange and acts like a BlockFilter
  // or PendingTx change format object to tx hash array
  if (formatter === 'FilterChange' && typeof value[0] === 'string') {
    formatObject = ['D32'];
  }

  // enforce minimum value length requirements
  if (encode === true && typeof lengthRequirement === 'number' && value.length < lengthRequirement) {
    throw new Error('array ' + JSON.stringify(value) + ' must contain at least ' + lengthRequirement + ' params, but only contains ' + value.length + '.'); // eslint-disable-line
  }

  // make new array, avoid mutation
  formatObject = formatObject.slice();

  // assume formatObject is an object, go through keys and format each
  value.forEach(function (valueKey, valueIndex) {
    // use key zero as formatter for all values, unless otherwise specified
    var formatObjectKey = 0; // eslint-disable-line

    // if format array is exact, check each argument against formatter argument
    if (formatObject.length > 1) {
      formatObjectKey = valueIndex;
    }

    output[valueIndex] = format(formatObject[formatObjectKey], valueKey, encode);
  });

  return output;
}

/**
 * Format various kinds of data to RPC spec or into digestable JS objects
 *
 * @method format
 * @param {String|Array} formatter the data formatter
 * @param {String|Array|Object|Null|Number} value the data value input
 * @param {Boolean} encode encode to hex or decode to BigNumbers, Strings, Booleans, Null
 * @param {Number} lengthRequirement the minimum data length requirement
 * @throws error if minimum length isnt met
 */
function format(formatter, value, encode, lengthRequirement) {
  var output = value; // eslint-disable-line

  // if formatter is quantity or quantity or tag
  if (formatter === 'Q') {
    output = formatQuantity(value, encode);
  } else if (formatter === 'QP') {
    output = formatQuantity(value, encode, true);
  } else if (formatter === 'Q|T') {
    output = formatQuantityOrTag(value, encode);
  } else if (formatter === 'D') {
    output = formatData(value); // dont format data flagged objects like compiler output
  } else if (formatter === 'D20') {
    output = formatData(value, 20); // dont format data flagged objects like compiler output
  } else if (formatter === 'D32') {
    output = formatData(value, 32); // dont format data flagged objects like compiler output
  } else {
    // if value is an object or array
    if (typeof value === 'object' && value !== null && Array.isArray(value) === false) {
      output = formatObject(formatter, value, encode);
    } else if (Array.isArray(value)) {
      output = formatArray(formatter, value, encode, lengthRequirement);
    }
  }

  return output;
}

/**
 * Format RPC inputs generally to the node or TestRPC
 *
 * @method formatInputs
 * @param {Object} method the data formatter
 * @param {Array} inputs the data inputs
 * @returns {Array} output the formatted inputs array
 * @throws error if minimum length isnt met
 */
function formatInputs(method, inputs) {
  return format(schema.methods[method][0], inputs, true, schema.methods[method][2]);
}

/**
 * Format RPC outputs generally from the node or TestRPC
 *
 * @method formatOutputs
 * @param {Object} method the data formatter
 * @param {Array|String|Null|Boolean|Object} outputs the data inputs
 * @returns {Array|String|Null|Boolean|Object} output the formatted data
 */
function formatOutputs(method, outputs) {
  return format(schema.methods[method][1], outputs, false);
}

// export formatters
module.exports = {
  schema: schema,
  formatQuantity: formatQuantity,
  formatQuantityOrTag: formatQuantityOrTag,
  formatObject: formatObject,
  formatArray: formatArray,
  format: format,
  formatInputs: formatInputs,
  formatOutputs: formatOutputs
};
      };
    };
  }
}, {package:"ethjs-format",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-format\\lib\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-filter\\lib\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethjs-filter\lib\index.js
      return function (require, module, exports) {
'use strict';

function constructFilter(filterName, query) {
  function Filter(options) {
    var self = this;
    self.filterId = null;
    self.options = Object.assign({
      delay: 300,
      decoder: function decodeData(data) {
        return data;
      },
      defaultFilterObject: {}
    }, options || {});

    self.watchers = {};
    self.interval = setInterval(function () {
      if (self.filterId !== null && Object.keys(self.watchers).length > 0) {
        query.getFilterChanges(self.filterId, function (changeError, changeResult) {
          var decodedChangeResults = [];
          var decodingError = null; // eslint-disable-line

          if (!changeError) {
            try {
              changeResult.forEach(function (log, logIndex) {
                decodedChangeResults[logIndex] = changeResult[logIndex];
                if (typeof changeResult[logIndex] === 'object') {
                  decodedChangeResults[logIndex].data = self.options.decoder(decodedChangeResults[logIndex].data);
                }
              });
            } catch (decodingErrorMesage) {
              decodingError = new Error('[ethjs-filter] while decoding filter change event data from RPC \'' + JSON.stringify(decodedChangeResults) + '\': ' + decodingErrorMesage);
            }
          }

          Object.keys(self.watchers).forEach(function (id) {
            var watcher = self.watchers[id];
            if (watcher.stop === true) {
              delete self.watchers[id];
              return;
            }

            if (decodingError) {
              watcher.callback(decodingError, null);
            } else {
              if (changeError) {
                watcher.callback(changeError, null);
              } else if (Array.isArray(decodedChangeResults) && changeResult.length > 0) {
                watcher.callback(changeError, decodedChangeResults);
              }
            }
          });
        });
      }
    }, self.options.delay);
  }

  Filter.prototype.at = function atFilter(filterId) {
    var self = this;
    self.filterId = filterId;
  };

  Filter.prototype.watch = function watchFilter(watchCallbackInput) {
    var callback = watchCallbackInput || function () {}; // eslint-disable-line
    var self = this;
    var id = Math.random().toString(36).substring(7);
    self.watchers[id] = { callback: callback, stop: false, stopWatching: function stopWatching() {
        self.watchers[id].stop = true;
      } };

    return self.watchers[id];
  };

  Filter.prototype.uninstall = function uninstallFilter(cb) {
    var self = this;
    var callback = cb || null;
    self.watchers = Object.assign({});
    clearInterval(self.interval);

    var prom = new Promise(function (resolve, reject) {
      query.uninstallFilter(self.filterId, function (uninstallError, uninstallResilt) {
        if (uninstallError) {
          reject(uninstallError);
        } else {
          resolve(uninstallResilt);
        }
      });
    });

    if (callback) {
      prom.then(function (res) {
        return callback(null, res);
      })['catch'](function (err) {
        return callback(err, null);
      });
    }

    return callback ? null : prom;
  };

  Filter.prototype['new'] = function newFilter() {
    var callback = null; // eslint-disable-line
    var self = this;
    var filterInputs = [];
    var args = [].slice.call(arguments); // eslint-disable-line
    // pop callback if provided
    if (typeof args[args.length - 1] === 'function') {
      callback = args.pop();
    }

    // if a param object was presented, push that into the inputs
    if (filterName === 'Filter') {
      filterInputs.push(Object.assign(self.options.defaultFilterObject, args[args.length - 1] || {}));
    }

    var prom = new Promise(function (resolve, reject) {
      // add complex callback
      filterInputs.push(function (setupError, filterId) {
        if (!setupError) {
          self.filterId = filterId;
          resolve(filterId);
        } else {
          reject(setupError);
        }
      });

      // apply filter, call new.. filter method
      query['new' + filterName].apply(query, filterInputs);
    });

    if (callback) {
      prom.then(function (res) {
        return callback(null, res);
      })['catch'](function (err) {
        return callback(err, null);
      });
    }

    return callback ? null : prom;
  };

  return Filter;
}

/**
 * EthFilter constructor, intakes a query, helps manage filter event polling
 *
 * @method EthFilter
 * @param {Object} query the `ethjs-query` or `eth-query` object
 * @returns {Object} output an EthFilter instance
 * @throws error if new is not used
 */

function EthFilter(query) {
  var self = this;
  if (!(self instanceof EthFilter)) {
    throw new Error('the EthFilter object must be instantiated with `new` flag.. (e.g. `const filters = new EthFilter(query);`)');
  }
  if (typeof query !== 'object') {
    throw new Error('the EthFilter object must be instantiated with an EthQuery instance (e.g. `const filters = new EthFilter(new EthQuery(provider));`). See github.com/ethjs/ethjs-query for more details..');
  }

  self.Filter = constructFilter('Filter', query);
  self.BlockFilter = constructFilter('BlockFilter', query);
  self.PendingTransactionFilter = constructFilter('PendingTransactionFilter', query);
}

// export EthFilter
module.exports = EthFilter;
      };
    };
  }
}, {package:"ethjs-filter",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-filter\\lib\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-util\\lib\\index.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","is-hex-prefixed":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\is-hex-prefixed\\src\\index.js","strip-hex-prefix":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\strip-hex-prefix\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethjs-util\lib\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var isHexPrefixed = require('is-hex-prefixed');
var stripHexPrefix = require('strip-hex-prefix');

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + padToEven(hex);
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return Buffer.from(hex.slice(2), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-util\\lib\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-contract\\node_modules\\js-sha3\\src\\sha3.js", {"_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethjs-contract\node_modules\js-sha3\src\sha3.js
      return function (require, module, exports) {
(function (process){(function (){
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.5.5
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2016
 * @license MIT
 */
(function (root) {
  'use strict';

  var NODE_JS = typeof process == 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = global;
  }
  var COMMON_JS = !root.JS_SHA3_TEST && typeof module == 'object' && module.exports;
  var HEX_CHARS = '0123456789abcdef'.split('');
  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
  var KECCAK_PADDING = [1, 256, 65536, 16777216];
  var PADDING = [6, 1536, 393216, 100663296];
  var SHIFT = [0, 8, 16, 24];
  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,
            0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 
            2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 
            2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,
            2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
  var BITS = [224, 256, 384, 512];
  var SHAKE_BITS = [128, 256];
  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array'];

  var createOutputMethod = function (bits, padding, outputType) {
    return function (message) {
      return new Keccak(bits, padding, bits).update(message)[outputType]();
    }
  };

  var createShakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits) {
      return new Keccak(bits, padding, outputBits).update(message)[outputType]();
    }
  };

  var createMethod = function (bits, padding) {
    var method = createOutputMethod(bits, padding, 'hex');
    method.create = function () {
      return new Keccak(bits, padding, bits);
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    for (var i = 0;i < OUTPUT_TYPES.length;++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createOutputMethod(bits, padding, type);
    }
    return method;
  };

  var createShakeMethod = function (bits, padding) {
    var method = createShakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits) {
      return new Keccak(bits, padding, outputBits);
    };
    method.update = function (message, outputBits) {
      return method.create(outputBits).update(message);
    };
    for (var i = 0;i < OUTPUT_TYPES.length;++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createShakeOutputMethod(bits, padding, type);
    }
    return method;
  };

  var algorithms = [
    {name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod},
    {name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod},
    {name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod}
  ];

  var methods = {};

  for (var i = 0;i < algorithms.length;++i) {
    var algorithm = algorithms[i];
    var bits  = algorithm.bits;
    for (var j = 0;j < bits.length;++j) {
      methods[algorithm.name +'_' + bits[j]] = algorithm.createMethod(bits[j], algorithm.padding);
    }
  }

  function Keccak(bits, padding, outputBits) {
    this.blocks = [];
    this.s = [];
    this.padding = padding;
    this.outputBits = outputBits;
    this.reset = true;
    this.block = 0;
    this.start = 0;
    this.blockCount = (1600 - (bits << 1)) >> 5;
    this.byteCount = this.blockCount << 2;
    this.outputBlocks = outputBits >> 5;
    this.extraBytes = (outputBits & 31) >> 3;

    for (var i = 0;i < 50;++i) {
      this.s[i] = 0;
    }
  };

  Keccak.prototype.update = function (message) {
    var notString = typeof message != 'string';
    if (notString && message.constructor == root.ArrayBuffer) {
      message = new Uint8Array(message);
    }
    var length = message.length, blocks = this.blocks, byteCount = this.byteCount, 
        blockCount = this.blockCount, index = 0, s = this.s, i, code;
    
    while (index < length) {
      if (this.reset) {
        this.reset = false;
        blocks[0] = this.block;
        for (i = 1;i < blockCount + 1;++i) {
          blocks[i] = 0;
        }
      }
      if (notString) {
        for (i = this.start;index < length && i < byteCount;++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start;index < length && i < byteCount;++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          }
        }
      }
      this.lastByteIndex = i;
      if (i >= byteCount) {
        this.start = i - byteCount;
        this.block = blocks[blockCount];
        for (i = 0;i < blockCount;++i) {
          s[i] ^= blocks[i];
        }
        f(s);
        this.reset = true;
      } else {
        this.start = i;
      }
    }
    return this;
  };

  Keccak.prototype.finalize = function () {
    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
    blocks[i >> 2] |= this.padding[i & 3];
    if (this.lastByteIndex == this.byteCount) {
      blocks[0] = blocks[blockCount];
      for (i = 1;i < blockCount + 1;++i) {
        blocks[i] = 0;
      }
    }
    blocks[blockCount - 1] |= 0x80000000;
    for (i = 0;i < blockCount;++i) {
      s[i] ^= blocks[i];
    }
    f(s);
  };

  Keccak.prototype.toString = Keccak.prototype.hex = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, 
        extraBytes = this.extraBytes, i = 0, j = 0;
    var hex = '', block;
    while (j < outputBlocks) {
      for (i = 0;i < blockCount && j < outputBlocks;++i, ++j) {
        block = s[i];
        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +
               HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +
               HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +
               HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];
      }
      if (j % blockCount == 0) {
        f(s);
        i = 0;
      }
    }
    if (extraBytes) {
      block = s[i];
      if (extraBytes > 0) {
        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];
      }
      if (extraBytes > 1) {
        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];
      }
      if (extraBytes > 2) {
        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];
      }
    }
    return hex;
  };

  Keccak.prototype.arrayBuffer = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, 
        extraBytes = this.extraBytes, i = 0, j = 0;
    var bytes = this.outputBits >> 3;
    var buffer;
    if (extraBytes) {
      buffer = new ArrayBuffer((outputBlocks + 1) << 2);
    } else {
      buffer = new ArrayBuffer(bytes);
    }
    var array = new Uint32Array(buffer);
    while (j < outputBlocks) {
      for (i = 0;i < blockCount && j < outputBlocks;++i, ++j) {
        array[j] = s[i];
      }
      if (j % blockCount == 0) {
        f(s);
      }
    }
    if (extraBytes) {
      array[i] = s[i];
      buffer = buffer.slice(0, bytes);
    }
    return buffer;
  };

  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;

  Keccak.prototype.digest = Keccak.prototype.array = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, 
        extraBytes = this.extraBytes, i = 0, j = 0;
    var array = [], offset, block;
    while (j < outputBlocks) {
      for (i = 0;i < blockCount && j < outputBlocks;++i, ++j) {
        offset = j << 2;
        block = s[i];
        array[offset] = block & 0xFF;
        array[offset + 1] = (block >> 8) & 0xFF;
        array[offset + 2] = (block >> 16) & 0xFF;
        array[offset + 3] = (block >> 24) & 0xFF;
      }
      if (j % blockCount == 0) {
        f(s);
      }
    }
    if (extraBytes) {
      offset = j << 2;
      block = s[i];
      if (extraBytes > 0) {
        array[offset] = block & 0xFF;
      }
      if (extraBytes > 1) {
        array[offset + 1] = (block >> 8) & 0xFF;
      }
      if (extraBytes > 2) {
        array[offset + 2] = (block >> 16) & 0xFF;
      }
    }
    return array;
  };

  var f = function (s) {
    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, 
        b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, 
        b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, 
        b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
    for (n = 0;n < 48;n += 2) {
      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

      h = c8 ^ ((c2 << 1) | (c3 >>> 31));
      l = c9 ^ ((c3 << 1) | (c2 >>> 31));
      s[0] ^= h;
      s[1] ^= l;
      s[10] ^= h;
      s[11] ^= l;
      s[20] ^= h;
      s[21] ^= l;
      s[30] ^= h;
      s[31] ^= l;
      s[40] ^= h;
      s[41] ^= l;
      h = c0 ^ ((c4 << 1) | (c5 >>> 31));
      l = c1 ^ ((c5 << 1) | (c4 >>> 31));
      s[2] ^= h;
      s[3] ^= l;
      s[12] ^= h;
      s[13] ^= l;
      s[22] ^= h;
      s[23] ^= l;
      s[32] ^= h;
      s[33] ^= l;
      s[42] ^= h;
      s[43] ^= l;
      h = c2 ^ ((c6 << 1) | (c7 >>> 31));
      l = c3 ^ ((c7 << 1) | (c6 >>> 31));
      s[4] ^= h;
      s[5] ^= l;
      s[14] ^= h;
      s[15] ^= l;
      s[24] ^= h;
      s[25] ^= l;
      s[34] ^= h;
      s[35] ^= l;
      s[44] ^= h;
      s[45] ^= l;
      h = c4 ^ ((c8 << 1) | (c9 >>> 31));
      l = c5 ^ ((c9 << 1) | (c8 >>> 31));
      s[6] ^= h;
      s[7] ^= l;
      s[16] ^= h;
      s[17] ^= l;
      s[26] ^= h;
      s[27] ^= l;
      s[36] ^= h;
      s[37] ^= l;
      s[46] ^= h;
      s[47] ^= l;
      h = c6 ^ ((c0 << 1) | (c1 >>> 31));
      l = c7 ^ ((c1 << 1) | (c0 >>> 31));
      s[8] ^= h;
      s[9] ^= l;
      s[18] ^= h;
      s[19] ^= l;
      s[28] ^= h;
      s[29] ^= l;
      s[38] ^= h;
      s[39] ^= l;
      s[48] ^= h;
      s[49] ^= l;

      b0 = s[0];
      b1 = s[1];
      b32 = (s[11] << 4) | (s[10] >>> 28);
      b33 = (s[10] << 4) | (s[11] >>> 28);
      b14 = (s[20] << 3) | (s[21] >>> 29);
      b15 = (s[21] << 3) | (s[20] >>> 29);
      b46 = (s[31] << 9) | (s[30] >>> 23);
      b47 = (s[30] << 9) | (s[31] >>> 23);
      b28 = (s[40] << 18) | (s[41] >>> 14);
      b29 = (s[41] << 18) | (s[40] >>> 14);
      b20 = (s[2] << 1) | (s[3] >>> 31);
      b21 = (s[3] << 1) | (s[2] >>> 31);
      b2 = (s[13] << 12) | (s[12] >>> 20);
      b3 = (s[12] << 12) | (s[13] >>> 20);
      b34 = (s[22] << 10) | (s[23] >>> 22);
      b35 = (s[23] << 10) | (s[22] >>> 22);
      b16 = (s[33] << 13) | (s[32] >>> 19);
      b17 = (s[32] << 13) | (s[33] >>> 19);
      b48 = (s[42] << 2) | (s[43] >>> 30);
      b49 = (s[43] << 2) | (s[42] >>> 30);
      b40 = (s[5] << 30) | (s[4] >>> 2);
      b41 = (s[4] << 30) | (s[5] >>> 2);
      b22 = (s[14] << 6) | (s[15] >>> 26);
      b23 = (s[15] << 6) | (s[14] >>> 26);
      b4 = (s[25] << 11) | (s[24] >>> 21);
      b5 = (s[24] << 11) | (s[25] >>> 21);
      b36 = (s[34] << 15) | (s[35] >>> 17);
      b37 = (s[35] << 15) | (s[34] >>> 17);
      b18 = (s[45] << 29) | (s[44] >>> 3);
      b19 = (s[44] << 29) | (s[45] >>> 3);
      b10 = (s[6] << 28) | (s[7] >>> 4);
      b11 = (s[7] << 28) | (s[6] >>> 4);
      b42 = (s[17] << 23) | (s[16] >>> 9);
      b43 = (s[16] << 23) | (s[17] >>> 9);
      b24 = (s[26] << 25) | (s[27] >>> 7);
      b25 = (s[27] << 25) | (s[26] >>> 7);
      b6 = (s[36] << 21) | (s[37] >>> 11);
      b7 = (s[37] << 21) | (s[36] >>> 11);
      b38 = (s[47] << 24) | (s[46] >>> 8);
      b39 = (s[46] << 24) | (s[47] >>> 8);
      b30 = (s[8] << 27) | (s[9] >>> 5);
      b31 = (s[9] << 27) | (s[8] >>> 5);
      b12 = (s[18] << 20) | (s[19] >>> 12);
      b13 = (s[19] << 20) | (s[18] >>> 12);
      b44 = (s[29] << 7) | (s[28] >>> 25);
      b45 = (s[28] << 7) | (s[29] >>> 25);
      b26 = (s[38] << 8) | (s[39] >>> 24);
      b27 = (s[39] << 8) | (s[38] >>> 24);
      b8 = (s[48] << 14) | (s[49] >>> 18);
      b9 = (s[49] << 14) | (s[48] >>> 18);

      s[0] = b0 ^ (~b2 & b4);
      s[1] = b1 ^ (~b3 & b5);
      s[10] = b10 ^ (~b12 & b14);
      s[11] = b11 ^ (~b13 & b15);
      s[20] = b20 ^ (~b22 & b24);
      s[21] = b21 ^ (~b23 & b25);
      s[30] = b30 ^ (~b32 & b34);
      s[31] = b31 ^ (~b33 & b35);
      s[40] = b40 ^ (~b42 & b44);
      s[41] = b41 ^ (~b43 & b45);
      s[2] = b2 ^ (~b4 & b6);
      s[3] = b3 ^ (~b5 & b7);
      s[12] = b12 ^ (~b14 & b16);
      s[13] = b13 ^ (~b15 & b17);
      s[22] = b22 ^ (~b24 & b26);
      s[23] = b23 ^ (~b25 & b27);
      s[32] = b32 ^ (~b34 & b36);
      s[33] = b33 ^ (~b35 & b37);
      s[42] = b42 ^ (~b44 & b46);
      s[43] = b43 ^ (~b45 & b47);
      s[4] = b4 ^ (~b6 & b8);
      s[5] = b5 ^ (~b7 & b9);
      s[14] = b14 ^ (~b16 & b18);
      s[15] = b15 ^ (~b17 & b19);
      s[24] = b24 ^ (~b26 & b28);
      s[25] = b25 ^ (~b27 & b29);
      s[34] = b34 ^ (~b36 & b38);
      s[35] = b35 ^ (~b37 & b39);
      s[44] = b44 ^ (~b46 & b48);
      s[45] = b45 ^ (~b47 & b49);
      s[6] = b6 ^ (~b8 & b0);
      s[7] = b7 ^ (~b9 & b1);
      s[16] = b16 ^ (~b18 & b10);
      s[17] = b17 ^ (~b19 & b11);
      s[26] = b26 ^ (~b28 & b20);
      s[27] = b27 ^ (~b29 & b21);
      s[36] = b36 ^ (~b38 & b30);
      s[37] = b37 ^ (~b39 & b31);
      s[46] = b46 ^ (~b48 & b40);
      s[47] = b47 ^ (~b49 & b41);
      s[8] = b8 ^ (~b0 & b2);
      s[9] = b9 ^ (~b1 & b3);
      s[18] = b18 ^ (~b10 & b12);
      s[19] = b19 ^ (~b11 & b13);
      s[28] = b28 ^ (~b20 & b22);
      s[29] = b29 ^ (~b21 & b23);
      s[38] = b38 ^ (~b30 & b32);
      s[39] = b39 ^ (~b31 & b33);
      s[48] = b48 ^ (~b40 & b42);
      s[49] = b49 ^ (~b41 & b43);

      s[0] ^= RC[n];
      s[1] ^= RC[n + 1];
    }
  }

  if (COMMON_JS) {
    module.exports = methods;
  } else if (root) {
    for (var key in methods) {
      root[key] = methods[key];
    }
  }
}(this));

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"js-sha3",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-contract\\node_modules\\js-sha3\\src\\sha3.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-abi\\lib\\index.js", {"./utils/index.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-abi\\lib\\utils\\index.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethjs-abi\lib\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

/* eslint-disable */

var utils = require('./utils/index.js');
var uint256Coder = utils.uint256Coder;
var coderBoolean = utils.coderBoolean;
var coderFixedBytes = utils.coderFixedBytes;
var coderAddress = utils.coderAddress;
var coderDynamicBytes = utils.coderDynamicBytes;
var coderString = utils.coderString;
var coderArray = utils.coderArray;
var paramTypePart = utils.paramTypePart;
var getParamCoder = utils.getParamCoder;

function Result() {}

function encodeParams(types, values) {
  if (types.length !== values.length) {
    throw new Error('[ethjs-abi] while encoding params, types/values mismatch, Your contract requires ' + types.length + ' types (arguments), and you passed in ' + values.length);
  }

  var parts = [];

  types.forEach(function (type, index) {
    var coder = getParamCoder(type);
    parts.push({ dynamic: coder.dynamic, value: coder.encode(values[index]) });
  });

  function alignSize(size) {
    return parseInt(32 * Math.ceil(size / 32));
  }

  var staticSize = 0,
      dynamicSize = 0;
  parts.forEach(function (part) {
    if (part.dynamic) {
      staticSize += 32;
      dynamicSize += alignSize(part.value.length);
    } else {
      staticSize += alignSize(part.value.length);
    }
  });

  var offset = 0,
      dynamicOffset = staticSize;
  var data = new Buffer(staticSize + dynamicSize);

  parts.forEach(function (part, index) {
    if (part.dynamic) {
      uint256Coder.encode(dynamicOffset).copy(data, offset);
      offset += 32;

      part.value.copy(data, dynamicOffset);
      dynamicOffset += alignSize(part.value.length);
    } else {
      part.value.copy(data, offset);
      offset += alignSize(part.value.length);
    }
  });

  return '0x' + data.toString('hex');
}

// decode bytecode data from output names and types
function decodeParams(names, types, data) {
  var useNumberedParams = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  // Names is optional, so shift over all the parameters if not provided
  if (arguments.length < 3) {
    data = types;
    types = names;
    names = [];
  }

  data = utils.hexOrBuffer(data);
  var values = new Result();

  var offset = 0;
  types.forEach(function (type, index) {
    var coder = getParamCoder(type);
    if (coder.dynamic) {
      var dynamicOffset = uint256Coder.decode(data, offset);
      var result = coder.decode(data, dynamicOffset.value.toNumber());
      offset += dynamicOffset.consumed;
    } else {
      var result = coder.decode(data, offset);
      offset += result.consumed;
    }
    if (useNumberedParams) values[index] = result.value;
    if (names[index]) {
      values[names[index]] = result.value;
    }
  });
  return values;
}

// encode method ABI object with values in an array, output bytecode
function encodeMethod(method, values) {
  var signature = method.name + '(' + utils.getKeys(method.inputs, 'type').join(',') + ')';
  var signatureEncoded = '0x' + new Buffer(utils.keccak256(signature), 'hex').slice(0, 4).toString('hex');
  var paramsEncoded = encodeParams(utils.getKeys(method.inputs, 'type'), values).substring(2);

  return '' + signatureEncoded + paramsEncoded;
}

// decode method data bytecode, from method ABI object
function decodeMethod(method, data) {
  var outputNames = utils.getKeys(method.outputs, 'name', true);
  var outputTypes = utils.getKeys(method.outputs, 'type');

  return decodeParams(outputNames, outputTypes, utils.hexOrBuffer(data));
}

// decode method data bytecode, from method ABI object
function encodeEvent(eventObject, values) {
  return encodeMethod(eventObject, values);
}

function eventSignature(eventObject) {
  var signature = eventObject.name + '(' + utils.getKeys(eventObject.inputs, 'type').join(',') + ')';
  return '0x' + utils.keccak256(signature);
}

// decode method data bytecode, from method ABI object
function decodeEvent(eventObject, data, topics) {
  var useNumberedParams = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  var nonIndexed = eventObject.inputs.filter(function (input) {
    return !input.indexed;
  });
  var nonIndexedNames = utils.getKeys(nonIndexed, 'name', true);
  var nonIndexedTypes = utils.getKeys(nonIndexed, 'type');
  var event = decodeParams(nonIndexedNames, nonIndexedTypes, utils.hexOrBuffer(data), useNumberedParams);
  var topicOffset = eventObject.anonymous ? 0 : 1;
  eventObject.inputs.filter(function (input) {
    return input.indexed;
  }).map(function (input, i) {
    var topic = new Buffer(topics[i + topicOffset].slice(2), 'hex');
    var coder = getParamCoder(input.type);
    event[input.name] = coder.decode(topic, 0).value;
  });
  event._eventName = eventObject.name;
  return event;
}

// Decode a specific log item with a specific event abi
function decodeLogItem(eventObject, log) {
  var useNumberedParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

  if (eventObject && log.topics[0] === eventSignature(eventObject)) {
    return decodeEvent(eventObject, log.data, log.topics, useNumberedParams);
  }
}

// Create a decoder for all events defined in an abi. It returns a function which is called
// on an array of log entries such as received from getLogs or getTransactionReceipt and parses
// any matching log entries
function logDecoder(abi) {
  var useNumberedParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  var eventMap = {};
  abi.filter(function (item) {
    return item.type === 'event';
  }).map(function (item) {
    eventMap[eventSignature(item)] = item;
  });
  return function (logItems) {
    return logItems.map(function (log) {
      return decodeLogItem(eventMap[log.topics[0]], log, useNumberedParams);
    }).filter(function (i) {
      return i;
    });
  };
}

module.exports = {
  encodeParams: encodeParams,
  decodeParams: decodeParams,
  encodeMethod: encodeMethod,
  decodeMethod: decodeMethod,
  encodeEvent: encodeEvent,
  decodeEvent: decodeEvent,
  decodeLogItem: decodeLogItem,
  logDecoder: logDecoder,
  eventSignature: eventSignature
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethjs-abi",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-abi\\lib\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\babel-runtime\\core-js\\object\\assign.js", {"core-js/library/fn/object/assign":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\babel-runtime\\node_modules\\core-js\\library\\fn\\object\\assign.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\babel-runtime\core-js\object\assign.js
      return function (require, module, exports) {
module.exports = { "default": require("core-js/library/fn/object/assign"), __esModule: true };
      };
    };
  }
}, {package:"babel-runtime",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\babel-runtime\\core-js\\object\\assign.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-contract\\lib\\contract.js", {"./has-tx-object":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-contract\\lib\\has-tx-object.js","babel-runtime/core-js/json/stringify":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\babel-runtime\\core-js\\json\\stringify.js","babel-runtime/core-js/object/assign":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\babel-runtime\\core-js\\object\\assign.js","babel-runtime/helpers/asyncToGenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\babel-runtime\\helpers\\asyncToGenerator.js","babel-runtime/regenerator":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\babel-runtime\\regenerator\\index.js","ethjs-abi":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-abi\\lib\\index.js","ethjs-filter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-filter\\lib\\index.js","ethjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-util\\lib\\index.js","js-sha3":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-contract\\node_modules\\js-sha3\\src\\sha3.js","promise-to-callback":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\promise-to-callback\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethjs-contract\lib\contract.js
      return function (require, module, exports) {
'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var abi = require('ethjs-abi'); // eslint-disable-line
var EthFilter = require('ethjs-filter'); // eslint-disable-line
var getKeys = require('ethjs-util').getKeys; // eslint-disable-line
var keccak256 = require('js-sha3').keccak_256; // eslint-disable-line
var hasTransactionObject = require('./has-tx-object');
var promiseToCallback = require('promise-to-callback');

module.exports = Contract;

function Contract() {
  var performCall = function () {
    var _ref2 = (0, _asyncToGenerator3['default'])( /*#__PURE__*/_regenerator2['default'].mark(function _callee(_ref) {
      var methodObject = _ref.methodObject,
          methodArgs = _ref.methodArgs;
      var queryMethod, providedTxObject, methodTxObject, queryResult, decodedMethodResult, decodingError;
      return _regenerator2['default'].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              queryMethod = 'call'; // eslint-disable-line

              providedTxObject = {}; // eslint-disable-line

              if (hasTransactionObject(methodArgs)) providedTxObject = methodArgs.pop();
              methodTxObject = (0, _assign2['default'])({}, self.defaultTxObject, providedTxObject, {
                to: self.address
              });

              methodTxObject.data = abi.encodeMethod(methodObject, methodArgs);

              if (methodObject.constant === false) {
                queryMethod = 'sendTransaction';
              }

              _context.next = 8;
              return self.query[queryMethod](methodTxObject);

            case 8:
              queryResult = _context.sent;

              if (!(queryMethod === 'call')) {
                _context.next = 19;
                break;
              }

              _context.prev = 10;
              decodedMethodResult = abi.decodeMethod(methodObject, queryResult);
              return _context.abrupt('return', decodedMethodResult);

            case 15:
              _context.prev = 15;
              _context.t0 = _context['catch'](10);
              decodingError = new Error('[ethjs-contract] while formatting incoming raw call data ' + (0, _stringify2['default'])(queryResult) + ' ' + _context.t0);
              throw decodingError;

            case 19:
              return _context.abrupt('return', queryResult);

            case 20:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this, [[10, 15]]);
    }));

    return function performCall(_x2) {
      return _ref2.apply(this, arguments);
    };
  }();

  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var self = this;
  self.abi = opts.contractABI || [];
  self.query = opts.query;
  self.address = opts.address || '0x';
  self.bytecode = opts.contractBytecode || '0x';
  self.defaultTxObject = opts.contractDefaultTxObject || {};
  self.filters = new EthFilter(self.query);

  getCallableMethodsFromABI(self.abi).forEach(function (methodObject) {
    if (methodObject.type === 'function') {
      self[methodObject.name] = createContractFunction(methodObject);
    } else if (methodObject.type === 'event') {
      self[methodObject.name] = createContractEvent(methodObject);
    }
  });

  function createContractEvent(methodObject) {
    return function contractEvent() {
      var methodArgs = [].slice.call(arguments); // eslint-disable-line

      var filterInputTypes = getKeys(methodObject.inputs, 'type', false);
      var filterTopic = '0x' + keccak256(methodObject.name + '(' + filterInputTypes.join(',') + ')');
      var filterTopcis = [filterTopic];
      var argsObject = (0, _assign2['default'])({}, methodArgs[0]) || {};

      var defaultFilterObject = (0, _assign2['default'])({}, methodArgs[0] || {}, {
        to: self.address,
        topics: filterTopcis
      });
      var filterOpts = (0, _assign2['default'])({}, argsObject, {
        decoder: function decoder(logData) {
          return abi.decodeEvent(methodObject, logData, filterTopcis);
        },
        defaultFilterObject: defaultFilterObject
      });

      return new self.filters.Filter(filterOpts);
    };
  }

  function createContractFunction(methodObject) {
    return function contractFunction() {
      var methodCallback = void 0; // eslint-disable-line
      var methodArgs = [].slice.call(arguments); // eslint-disable-line
      if (typeof methodArgs[methodArgs.length - 1] === 'function') {
        methodCallback = methodArgs.pop();
      }

      var promise = performCall({ methodObject: methodObject, methodArgs: methodArgs });

      if (methodCallback) {
        return promiseToCallback(promise)(methodCallback);
      }

      return promise;
    };
  }
}

function getCallableMethodsFromABI(contractABI) {
  return contractABI.filter(function (json) {
    return (json.type === 'function' || json.type === 'event') && json.name.length > 0;
  });
}
      };
    };
  }
}, {package:"ethjs-contract",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-contract\\lib\\contract.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-contract\\lib\\has-tx-object.js", {"babel-runtime/core-js/object/keys":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\babel-runtime\\core-js\\object\\keys.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethjs-contract\lib\has-tx-object.js
      return function (require, module, exports) {
'use strict';

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var txObjectProperties = ['from', 'to', 'data', 'value', 'gasPrice', 'gas'];

module.exports = hasTransactionObject;

function hasTransactionObject(args) {
  // bad/empty args: bad
  if (!Array.isArray(args) || args.length === 0) {
    return false;
  }
  var lastArg = args[args.length - 1];
  // missing or non-object: bad
  if (!lastArg) return false;
  if (typeof lastArg !== 'object') {
    return false;
  }
  // empty object: good
  if ((0, _keys2['default'])(lastArg).length === 0) {
    return true;
  }
  // txParams object: good
  var keys = (0, _keys2['default'])(lastArg);
  var hasMatchingKeys = txObjectProperties.some(function (value) {
    return keys.includes(value);
  });
  if (hasMatchingKeys) {
    return true;
  }
  // no match
  return false;
}
      };
    };
  }
}, {package:"ethjs-contract",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-contract\\lib\\has-tx-object.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-ens-namehash\\node_modules\\js-sha3\\src\\sha3.js", {"_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-ens-namehash\node_modules\js-sha3\src\sha3.js
      return function (require, module, exports) {
(function (process){(function (){
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.5.7
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2016
 * @license MIT
 */
/*jslint bitwise: true */
(function () {
  'use strict';

  var root = typeof window === 'object' ? window : {};
  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = global;
  }
  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === 'object' && module.exports;
  var HEX_CHARS = '0123456789abcdef'.split('');
  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
  var KECCAK_PADDING = [1, 256, 65536, 16777216];
  var PADDING = [6, 1536, 393216, 100663296];
  var SHIFT = [0, 8, 16, 24];
  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,
            0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,
            2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,
            2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,
            2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
  var BITS = [224, 256, 384, 512];
  var SHAKE_BITS = [128, 256];
  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array'];

  var createOutputMethod = function (bits, padding, outputType) {
    return function (message) {
      return new Keccak(bits, padding, bits).update(message)[outputType]();
    };
  };

  var createShakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits) {
      return new Keccak(bits, padding, outputBits).update(message)[outputType]();
    };
  };

  var createMethod = function (bits, padding) {
    var method = createOutputMethod(bits, padding, 'hex');
    method.create = function () {
      return new Keccak(bits, padding, bits);
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createOutputMethod(bits, padding, type);
    }
    return method;
  };

  var createShakeMethod = function (bits, padding) {
    var method = createShakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits) {
      return new Keccak(bits, padding, outputBits);
    };
    method.update = function (message, outputBits) {
      return method.create(outputBits).update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createShakeOutputMethod(bits, padding, type);
    }
    return method;
  };

  var algorithms = [
    {name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod},
    {name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod},
    {name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod}
  ];

  var methods = {}, methodNames = [];

  for (var i = 0; i < algorithms.length; ++i) {
    var algorithm = algorithms[i];
    var bits  = algorithm.bits;
    for (var j = 0; j < bits.length; ++j) {
      var methodName = algorithm.name +'_' + bits[j];
      methodNames.push(methodName);
      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
    }
  }

  function Keccak(bits, padding, outputBits) {
    this.blocks = [];
    this.s = [];
    this.padding = padding;
    this.outputBits = outputBits;
    this.reset = true;
    this.block = 0;
    this.start = 0;
    this.blockCount = (1600 - (bits << 1)) >> 5;
    this.byteCount = this.blockCount << 2;
    this.outputBlocks = outputBits >> 5;
    this.extraBytes = (outputBits & 31) >> 3;

    for (var i = 0; i < 50; ++i) {
      this.s[i] = 0;
    }
  }

  Keccak.prototype.update = function (message) {
    var notString = typeof message !== 'string';
    if (notString && message.constructor === ArrayBuffer) {
      message = new Uint8Array(message);
    }
    var length = message.length, blocks = this.blocks, byteCount = this.byteCount,
      blockCount = this.blockCount, index = 0, s = this.s, i, code;

    while (index < length) {
      if (this.reset) {
        this.reset = false;
        blocks[0] = this.block;
        for (i = 1; i < blockCount + 1; ++i) {
          blocks[i] = 0;
        }
      }
      if (notString) {
        for (i = this.start; index < length && i < byteCount; ++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start; index < length && i < byteCount; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          }
        }
      }
      this.lastByteIndex = i;
      if (i >= byteCount) {
        this.start = i - byteCount;
        this.block = blocks[blockCount];
        for (i = 0; i < blockCount; ++i) {
          s[i] ^= blocks[i];
        }
        f(s);
        this.reset = true;
      } else {
        this.start = i;
      }
    }
    return this;
  };

  Keccak.prototype.finalize = function () {
    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
    blocks[i >> 2] |= this.padding[i & 3];
    if (this.lastByteIndex === this.byteCount) {
      blocks[0] = blocks[blockCount];
      for (i = 1; i < blockCount + 1; ++i) {
        blocks[i] = 0;
      }
    }
    blocks[blockCount - 1] |= 0x80000000;
    for (i = 0; i < blockCount; ++i) {
      s[i] ^= blocks[i];
    }
    f(s);
  };

  Keccak.prototype.toString = Keccak.prototype.hex = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
        extraBytes = this.extraBytes, i = 0, j = 0;
    var hex = '', block;
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        block = s[i];
        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +
               HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +
               HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +
               HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];
      }
      if (j % blockCount === 0) {
        f(s);
        i = 0;
      }
    }
    if (extraBytes) {
      block = s[i];
      if (extraBytes > 0) {
        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];
      }
      if (extraBytes > 1) {
        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];
      }
      if (extraBytes > 2) {
        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];
      }
    }
    return hex;
  };

  Keccak.prototype.arrayBuffer = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
        extraBytes = this.extraBytes, i = 0, j = 0;
    var bytes = this.outputBits >> 3;
    var buffer;
    if (extraBytes) {
      buffer = new ArrayBuffer((outputBlocks + 1) << 2);
    } else {
      buffer = new ArrayBuffer(bytes);
    }
    var array = new Uint32Array(buffer);
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        array[j] = s[i];
      }
      if (j % blockCount === 0) {
        f(s);
      }
    }
    if (extraBytes) {
      array[i] = s[i];
      buffer = buffer.slice(0, bytes);
    }
    return buffer;
  };

  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;

  Keccak.prototype.digest = Keccak.prototype.array = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
        extraBytes = this.extraBytes, i = 0, j = 0;
    var array = [], offset, block;
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        offset = j << 2;
        block = s[i];
        array[offset] = block & 0xFF;
        array[offset + 1] = (block >> 8) & 0xFF;
        array[offset + 2] = (block >> 16) & 0xFF;
        array[offset + 3] = (block >> 24) & 0xFF;
      }
      if (j % blockCount === 0) {
        f(s);
      }
    }
    if (extraBytes) {
      offset = j << 2;
      block = s[i];
      if (extraBytes > 0) {
        array[offset] = block & 0xFF;
      }
      if (extraBytes > 1) {
        array[offset + 1] = (block >> 8) & 0xFF;
      }
      if (extraBytes > 2) {
        array[offset + 2] = (block >> 16) & 0xFF;
      }
    }
    return array;
  };

  var f = function (s) {
    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,
        b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,
        b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,
        b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
    for (n = 0; n < 48; n += 2) {
      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

      h = c8 ^ ((c2 << 1) | (c3 >>> 31));
      l = c9 ^ ((c3 << 1) | (c2 >>> 31));
      s[0] ^= h;
      s[1] ^= l;
      s[10] ^= h;
      s[11] ^= l;
      s[20] ^= h;
      s[21] ^= l;
      s[30] ^= h;
      s[31] ^= l;
      s[40] ^= h;
      s[41] ^= l;
      h = c0 ^ ((c4 << 1) | (c5 >>> 31));
      l = c1 ^ ((c5 << 1) | (c4 >>> 31));
      s[2] ^= h;
      s[3] ^= l;
      s[12] ^= h;
      s[13] ^= l;
      s[22] ^= h;
      s[23] ^= l;
      s[32] ^= h;
      s[33] ^= l;
      s[42] ^= h;
      s[43] ^= l;
      h = c2 ^ ((c6 << 1) | (c7 >>> 31));
      l = c3 ^ ((c7 << 1) | (c6 >>> 31));
      s[4] ^= h;
      s[5] ^= l;
      s[14] ^= h;
      s[15] ^= l;
      s[24] ^= h;
      s[25] ^= l;
      s[34] ^= h;
      s[35] ^= l;
      s[44] ^= h;
      s[45] ^= l;
      h = c4 ^ ((c8 << 1) | (c9 >>> 31));
      l = c5 ^ ((c9 << 1) | (c8 >>> 31));
      s[6] ^= h;
      s[7] ^= l;
      s[16] ^= h;
      s[17] ^= l;
      s[26] ^= h;
      s[27] ^= l;
      s[36] ^= h;
      s[37] ^= l;
      s[46] ^= h;
      s[47] ^= l;
      h = c6 ^ ((c0 << 1) | (c1 >>> 31));
      l = c7 ^ ((c1 << 1) | (c0 >>> 31));
      s[8] ^= h;
      s[9] ^= l;
      s[18] ^= h;
      s[19] ^= l;
      s[28] ^= h;
      s[29] ^= l;
      s[38] ^= h;
      s[39] ^= l;
      s[48] ^= h;
      s[49] ^= l;

      b0 = s[0];
      b1 = s[1];
      b32 = (s[11] << 4) | (s[10] >>> 28);
      b33 = (s[10] << 4) | (s[11] >>> 28);
      b14 = (s[20] << 3) | (s[21] >>> 29);
      b15 = (s[21] << 3) | (s[20] >>> 29);
      b46 = (s[31] << 9) | (s[30] >>> 23);
      b47 = (s[30] << 9) | (s[31] >>> 23);
      b28 = (s[40] << 18) | (s[41] >>> 14);
      b29 = (s[41] << 18) | (s[40] >>> 14);
      b20 = (s[2] << 1) | (s[3] >>> 31);
      b21 = (s[3] << 1) | (s[2] >>> 31);
      b2 = (s[13] << 12) | (s[12] >>> 20);
      b3 = (s[12] << 12) | (s[13] >>> 20);
      b34 = (s[22] << 10) | (s[23] >>> 22);
      b35 = (s[23] << 10) | (s[22] >>> 22);
      b16 = (s[33] << 13) | (s[32] >>> 19);
      b17 = (s[32] << 13) | (s[33] >>> 19);
      b48 = (s[42] << 2) | (s[43] >>> 30);
      b49 = (s[43] << 2) | (s[42] >>> 30);
      b40 = (s[5] << 30) | (s[4] >>> 2);
      b41 = (s[4] << 30) | (s[5] >>> 2);
      b22 = (s[14] << 6) | (s[15] >>> 26);
      b23 = (s[15] << 6) | (s[14] >>> 26);
      b4 = (s[25] << 11) | (s[24] >>> 21);
      b5 = (s[24] << 11) | (s[25] >>> 21);
      b36 = (s[34] << 15) | (s[35] >>> 17);
      b37 = (s[35] << 15) | (s[34] >>> 17);
      b18 = (s[45] << 29) | (s[44] >>> 3);
      b19 = (s[44] << 29) | (s[45] >>> 3);
      b10 = (s[6] << 28) | (s[7] >>> 4);
      b11 = (s[7] << 28) | (s[6] >>> 4);
      b42 = (s[17] << 23) | (s[16] >>> 9);
      b43 = (s[16] << 23) | (s[17] >>> 9);
      b24 = (s[26] << 25) | (s[27] >>> 7);
      b25 = (s[27] << 25) | (s[26] >>> 7);
      b6 = (s[36] << 21) | (s[37] >>> 11);
      b7 = (s[37] << 21) | (s[36] >>> 11);
      b38 = (s[47] << 24) | (s[46] >>> 8);
      b39 = (s[46] << 24) | (s[47] >>> 8);
      b30 = (s[8] << 27) | (s[9] >>> 5);
      b31 = (s[9] << 27) | (s[8] >>> 5);
      b12 = (s[18] << 20) | (s[19] >>> 12);
      b13 = (s[19] << 20) | (s[18] >>> 12);
      b44 = (s[29] << 7) | (s[28] >>> 25);
      b45 = (s[28] << 7) | (s[29] >>> 25);
      b26 = (s[38] << 8) | (s[39] >>> 24);
      b27 = (s[39] << 8) | (s[38] >>> 24);
      b8 = (s[48] << 14) | (s[49] >>> 18);
      b9 = (s[49] << 14) | (s[48] >>> 18);

      s[0] = b0 ^ (~b2 & b4);
      s[1] = b1 ^ (~b3 & b5);
      s[10] = b10 ^ (~b12 & b14);
      s[11] = b11 ^ (~b13 & b15);
      s[20] = b20 ^ (~b22 & b24);
      s[21] = b21 ^ (~b23 & b25);
      s[30] = b30 ^ (~b32 & b34);
      s[31] = b31 ^ (~b33 & b35);
      s[40] = b40 ^ (~b42 & b44);
      s[41] = b41 ^ (~b43 & b45);
      s[2] = b2 ^ (~b4 & b6);
      s[3] = b3 ^ (~b5 & b7);
      s[12] = b12 ^ (~b14 & b16);
      s[13] = b13 ^ (~b15 & b17);
      s[22] = b22 ^ (~b24 & b26);
      s[23] = b23 ^ (~b25 & b27);
      s[32] = b32 ^ (~b34 & b36);
      s[33] = b33 ^ (~b35 & b37);
      s[42] = b42 ^ (~b44 & b46);
      s[43] = b43 ^ (~b45 & b47);
      s[4] = b4 ^ (~b6 & b8);
      s[5] = b5 ^ (~b7 & b9);
      s[14] = b14 ^ (~b16 & b18);
      s[15] = b15 ^ (~b17 & b19);
      s[24] = b24 ^ (~b26 & b28);
      s[25] = b25 ^ (~b27 & b29);
      s[34] = b34 ^ (~b36 & b38);
      s[35] = b35 ^ (~b37 & b39);
      s[44] = b44 ^ (~b46 & b48);
      s[45] = b45 ^ (~b47 & b49);
      s[6] = b6 ^ (~b8 & b0);
      s[7] = b7 ^ (~b9 & b1);
      s[16] = b16 ^ (~b18 & b10);
      s[17] = b17 ^ (~b19 & b11);
      s[26] = b26 ^ (~b28 & b20);
      s[27] = b27 ^ (~b29 & b21);
      s[36] = b36 ^ (~b38 & b30);
      s[37] = b37 ^ (~b39 & b31);
      s[46] = b46 ^ (~b48 & b40);
      s[47] = b47 ^ (~b49 & b41);
      s[8] = b8 ^ (~b0 & b2);
      s[9] = b9 ^ (~b1 & b3);
      s[18] = b18 ^ (~b10 & b12);
      s[19] = b19 ^ (~b11 & b13);
      s[28] = b28 ^ (~b20 & b22);
      s[29] = b29 ^ (~b21 & b23);
      s[38] = b38 ^ (~b30 & b32);
      s[39] = b39 ^ (~b31 & b33);
      s[48] = b48 ^ (~b40 & b42);
      s[49] = b49 ^ (~b41 & b43);

      s[0] ^= RC[n];
      s[1] ^= RC[n + 1];
    }
  };

  if (COMMON_JS) {
    module.exports = methods;
  } else {
    for (var i = 0; i < methodNames.length; ++i) {
      root[methodNames[i]] = methods[methodNames[i]];
    }
  }
})();

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"js-sha3",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-ens-namehash\\node_modules\\js-sha3\\src\\sha3.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\idna-uts46-hx\\uts46.js", {"./idna-map":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\idna-uts46-hx\\idna-map.js","punycode":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\punycode\\punycode.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\idna-uts46-hx\uts46.js
      return function (require, module, exports) {
(function(root, factory) {
  /* istanbul ignore next */
  if (typeof define === 'function' && define.amd) {
    define(['punycode', './idna-map'], function(punycode, idna_map) {
      return factory(punycode, idna_map);
    });
  }
  else if (typeof exports === 'object') {
    module.exports = factory(require('punycode'), require('./idna-map'));
  }
  else {
    root.uts46 = factory(root.punycode, root.idna_map);
  }
}(this, function(punycode, idna_map) {

  function mapLabel(label, useStd3ASCII, transitional) {
    var mapped = [];
    var chars = punycode.ucs2.decode(label);
    for (var i = 0; i < chars.length; i++) {
      var cp = chars[i];
      var ch = punycode.ucs2.encode([chars[i]]);
      var composite = idna_map.mapChar(cp);
      var flags = (composite >> 23);
      var kind = (composite >> 21) & 3;
      var index = (composite >> 5) & 0xffff;
      var length = composite & 0x1f;
      var value = idna_map.mapStr.substr(index, length);
      if (kind === 0 || (useStd3ASCII && (flags & 1))) {
        throw new Error("Illegal char " + ch);
      }
      else if (kind === 1) {
        mapped.push(value);
      }
      else if (kind === 2) {
        mapped.push(transitional ? value : ch);
      }
      /* istanbul ignore next */
      else if (kind === 3) {
        mapped.push(ch);
      }
    }

    var newLabel = mapped.join("").normalize("NFC");
    return newLabel;
  }

  function process(domain, transitional, useStd3ASCII) {
    /* istanbul ignore if */
    if (useStd3ASCII === undefined)
      useStd3ASCII = false;
    var mappedIDNA = mapLabel(domain, useStd3ASCII, transitional);

    // Step 3. Break
    var labels = mappedIDNA.split(".");

    // Step 4. Convert/Validate
    labels = labels.map(function(label) {
      if (label.startsWith("xn--")) {
        label = punycode.decode(label.substring(4));
        validateLabel(label, useStd3ASCII, false);
      }
      else {
        validateLabel(label, useStd3ASCII, transitional);
      }
      return label;
    });

    return labels.join(".");
  }

  function validateLabel(label, useStd3ASCII, transitional) {
    // 2. The label must not contain a U+002D HYPHEN-MINUS character in both the
    // third position and fourth positions.
    if (label[2] === '-' && label[3] === '-')
      throw new Error("Failed to validate " + label);

    // 3. The label must neither begin nor end with a U+002D HYPHEN-MINUS
    // character.
    if (label.startsWith('-') || label.endsWith('-'))
      throw new Error("Failed to validate " + label);

    // 4. The label must not contain a U+002E ( . ) FULL STOP.
    // this should nerver happen as label is chunked internally by this character
    /* istanbul ignore if */
    if (label.includes('.'))
      throw new Error("Failed to validate " + label);

    if (mapLabel(label, useStd3ASCII, transitional) !== label)
      throw new Error("Failed to validate " + label);

    // 5. The label must not begin with a combining mark, that is:
    // General_Category=Mark.
    var ch = label.codePointAt(0);
    if (idna_map.mapChar(ch) & (0x2 << 23))
      throw new Error("Label contains illegal character: " + ch);
  }

  function toAscii(domain, options) {
    if (options === undefined)
      options = {};
    var transitional = 'transitional' in options ? options.transitional : true;
    var useStd3ASCII = 'useStd3ASCII' in options ? options.useStd3ASCII : false;
    var verifyDnsLength = 'verifyDnsLength' in options ? options.verifyDnsLength : false;
    var labels = process(domain, transitional, useStd3ASCII).split('.');
    var asciiLabels = labels.map(punycode.toASCII);
    var asciiString = asciiLabels.join('.');
    var i;
    if (verifyDnsLength) {
      if (asciiString.length < 1 || asciiString.length > 253) {
        throw new Error("DNS name has wrong length: " + asciiString);
      }
      for (i = 0; i < asciiLabels.length; i++) {//for .. of replacement
        var label = asciiLabels[i];
        if (label.length < 1 || label.length > 63)
          throw new Error("DNS label has wrong length: " + label);
      }
    }
    return asciiString;
  }

  function toUnicode(domain, options) {
    if (options === undefined)
      options = {};
    var useStd3ASCII = 'useStd3ASCII' in options ? options.useStd3ASCII : false;
    return process(domain, false, useStd3ASCII);
  }

  return {
    toUnicode: toUnicode,
    toAscii: toAscii,
  };
}));

      };
    };
  }
}, {package:"idna-uts46-hx",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\idna-uts46-hx\\uts46.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\extends.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\@babel\runtime\helpers\extends.js
      return function (require, module, exports) {
function _extends() {
  return Object.assign(...arguments)
}

module.exports = _extends;
module.exports["default"] = module.exports, module.exports.__esModule = true;
      };
    };
  }
}, {package:"@babel\\runtime",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\extends.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\selectors\\index.js", {"./confirm-transaction":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\selectors\\confirm-transaction.js","./custom-gas":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\selectors\\custom-gas.js","./first-time-flow":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\selectors\\first-time-flow.js","./metametrics":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\selectors\\metametrics.js","./permissions":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\selectors\\permissions.js","./selectors":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\selectors\\selectors.js","./transactions":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\selectors\\transactions.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\ui\selectors\index.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _confirmTransaction = require("./confirm-transaction");

Object.keys(_confirmTransaction).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _confirmTransaction[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _confirmTransaction[key];
    }
  });
});

var _customGas = require("./custom-gas");

Object.keys(_customGas).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _customGas[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _customGas[key];
    }
  });
});

var _firstTimeFlow = require("./first-time-flow");

Object.keys(_firstTimeFlow).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _firstTimeFlow[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _firstTimeFlow[key];
    }
  });
});

var _metametrics = require("./metametrics");

Object.keys(_metametrics).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _metametrics[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _metametrics[key];
    }
  });
});

var _permissions = require("./permissions");

Object.keys(_permissions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _permissions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _permissions[key];
    }
  });
});

var _selectors = require("./selectors");

Object.keys(_selectors).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _selectors[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _selectors[key];
    }
  });
});

var _transactions = require("./transactions");

Object.keys(_transactions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _transactions[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _transactions[key];
    }
  });
});

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\selectors\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\currency-formatter\\currencies.js", {"./index":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\currency-formatter\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\currency-formatter\currencies.js
      return function (require, module, exports) {
var formatter = require('./index')

/**
 * This module exists purely for backwards compatibility reasons. Historically, the currencies
 * would be stored in an array available through the default export from this exact file.
 * We've opted to store currencies in a JSON object now (currencies.json).
 */
module.exports = formatter.currencies
      };
    };
  }
}, {package:"currency-formatter",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\currency-formatter\\currencies.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\currency-formatter\\index.js", {"./currencies.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\currency-formatter\\currencies.json","./localeFormats.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\currency-formatter\\localeFormats.json","accounting":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\accounting\\accounting.js","locale-currency":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\locale-currency\\index.js","object-assign":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\object-assign\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\currency-formatter\index.js
      return function (require, module, exports) {
var accounting = require('accounting')
var assign = require('object-assign')
var localeCurrency = require('locale-currency')
var currencies = require('./currencies.json')
var localeFormats = require('./localeFormats.json')

var defaultCurrency = {
  symbol: '',
  thousandsSeparator: ',',
  decimalSeparator: '.',
  symbolOnLeft: true,
  spaceBetweenAmountAndSymbol: false,
  decimalDigits: 2
}

var defaultLocaleFormat = {}

var formatMapping = [
  {
    symbolOnLeft: true,
    spaceBetweenAmountAndSymbol: false,
    format: {
      pos: '%s%v',
      neg: '-%s%v',
      zero: '%s%v'
    }
  },
  {
    symbolOnLeft: true,
    spaceBetweenAmountAndSymbol: true,
    format: {
      pos: '%s %v',
      neg: '-%s %v',
      zero: '%s %v'
    }
  },
  {
    symbolOnLeft: false,
    spaceBetweenAmountAndSymbol: false,
    format: {
      pos: '%v%s',
      neg: '-%v%s',
      zero: '%v%s'
    }
  },
  {
    symbolOnLeft: false,
    spaceBetweenAmountAndSymbol: true,
    format: {
      pos: '%v %s',
      neg: '-%v %s',
      zero: '%v %s'
    }
  }
]

function format(value, options) {
  var code = options.code || (options.locale && localeCurrency.getCurrency(options.locale))
  var localeMatch = /^([a-z]+)([_-]([a-z]+))?$/i.exec(options.locale) || []
  var language = localeMatch[1]
  var region = localeMatch[3]
  var localeFormat = assign({}, defaultLocaleFormat,
                            localeFormats[language] || {},
                            localeFormats[language + '-' + region] || {})
  var currency = assign({}, defaultCurrency, findCurrency(code), localeFormat)
  
  var symbolOnLeft = currency.symbolOnLeft
  var spaceBetweenAmountAndSymbol = currency.spaceBetweenAmountAndSymbol

  var format = formatMapping.filter(function(f) {
    return f.symbolOnLeft == symbolOnLeft && f.spaceBetweenAmountAndSymbol == spaceBetweenAmountAndSymbol
  })[0].format

  return accounting.formatMoney(value, {
    symbol: isUndefined(options.symbol)
              ? currency.symbol
              : options.symbol,

    decimal: isUndefined(options.decimal)
              ? currency.decimalSeparator
              : options.decimal,

    thousand: isUndefined(options.thousand)
              ? currency.thousandsSeparator
              : options.thousand,

    precision: typeof options.precision === 'number'
              ? options.precision
              : currency.decimalDigits,

    format: ['string', 'object'].indexOf(typeof options.format) > -1
              ? options.format
              : format
  })
}

function findCurrency (currencyCode) {
  return currencies[currencyCode]
}

function isUndefined (val) {
  return typeof val === 'undefined'
}

function unformat(value, options) {
  var code = options.code || (options.locale && localeCurrency.getCurrency(options.locale))
  var localeFormat = localeFormats[options.locale] || defaultLocaleFormat
  var currency = assign({}, defaultCurrency, findCurrency(code), localeFormat)
  var decimal = isUndefined(options.decimal) ? currency.decimalSeparator : options.decimal
  return accounting.unformat(value, decimal)
}

module.exports = {
  defaultCurrency: defaultCurrency,
  get currencies() {
    // In favor of backwards compatibility, the currencies map is converted to an array here
    return Object.keys(currencies).map(function(key) {
      return currencies[key]
    })
  },
  findCurrency: findCurrency,
  format: format,
  unformat: unformat
}
      };
    };
  }
}, {package:"currency-formatter",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\currency-formatter\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-filters\\node_modules\\json-rpc-engine\\src\\createScaffoldMiddleware.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-json-rpc-filters\node_modules\json-rpc-engine\src\createScaffoldMiddleware.js
      return function (require, module, exports) {
module.exports = function createScaffoldMiddleware (handlers) {
  return (req, res, next, end) => {
    const handler = handlers[req.method]
    // if no handler, return
    if (handler === undefined) {
      return next()
    }
    // if handler is fn, call as middleware
    if (typeof handler === 'function') {
      return handler(req, res, next, end)
    }
    // if handler is some other value, use as result
    res.result = handler
    return end()
  }
}

      };
    };
  }
}, {package:"json-rpc-engine",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-filters\\node_modules\\json-rpc-engine\\src\\createScaffoldMiddleware.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-filters\\base-filter.js", {"safe-event-emitter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\safe-event-emitter\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-json-rpc-filters\base-filter.js
      return function (require, module, exports) {
const SafeEventEmitter = require('safe-event-emitter')

class BaseFilter extends SafeEventEmitter {

  constructor () {
    super()
    this.updates = []
  }

  async initialize () {}

  async update () {
    throw new Error('BaseFilter - no update method specified')
  }

  addResults (newResults) {
    this.updates = this.updates.concat(newResults)
    newResults.forEach(result => this.emit('update', result))
  }

  addInitialResults (newResults) {}

  getChangesAndClear () {
    const updates = this.updates
    this.updates = []
    return updates
  }
  
}

module.exports = BaseFilter

      };
    };
  }
}, {package:"eth-json-rpc-filters",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-filters\\base-filter.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-filters\\node_modules\\pify\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-json-rpc-filters\node_modules\pify\index.js
      return function (require, module, exports) {
'use strict';

const processFn = (fn, opts) => function () {
	const P = opts.promiseModule;
	const args = new Array(arguments.length);

	for (let i = 0; i < arguments.length; i++) {
		args[i] = arguments[i];
	}

	return new P((resolve, reject) => {
		if (opts.errorFirst) {
			args.push(function (err, result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 1; i < arguments.length; i++) {
						results[i - 1] = arguments[i];
					}

					if (err) {
						results.unshift(err);
						reject(results);
					} else {
						resolve(results);
					}
				} else if (err) {
					reject(err);
				} else {
					resolve(result);
				}
			});
		} else {
			args.push(function (result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 0; i < arguments.length; i++) {
						results[i] = arguments[i];
					}

					resolve(results);
				} else {
					resolve(result);
				}
			});
		}

		fn.apply(this, args);
	});
};

module.exports = (obj, opts) => {
	opts = Object.assign({
		exclude: [/.+(Sync|Stream)$/],
		errorFirst: true,
		promiseModule: Promise
	}, opts);

	const filter = key => {
		const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);
		return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
	};

	let ret;
	if (typeof obj === 'function') {
		ret = function () {
			if (opts.excludeMain) {
				return obj.apply(this, arguments);
			}

			return processFn(obj, opts).apply(this, arguments);
		};
	} else {
		ret = Object.create(Object.getPrototypeOf(obj));
	}

	for (const key in obj) { // eslint-disable-line guard-for-in
		const x = obj[key];
		ret[key] = typeof x === 'function' && filter(key) ? processFn(x, opts) : x;
	}

	return ret;
};

      };
    };
  }
}, {package:"pify",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-filters\\node_modules\\pify\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-filters\\base-filter-history.js", {"./base-filter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-filters\\base-filter.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-json-rpc-filters\base-filter-history.js
      return function (require, module, exports) {
const BaseFilter = require('./base-filter')

// tracks all results ever recorded
class BaseFilterWithHistory extends BaseFilter {

  constructor () {
    super()
    this.allResults = []
  }

  async update () {
    throw new Error('BaseFilterWithHistory - no update method specified')
  }

  addResults (newResults) {
    this.allResults = this.allResults.concat(newResults)
    super.addResults(newResults)
  }

  addInitialResults (newResults) {
    this.allResults = this.allResults.concat(newResults)
    super.addInitialResults(newResults)
  }

  getAllResults () {
    return this.allResults
  }

}

module.exports = BaseFilterWithHistory
      };
    };
  }
}, {package:"eth-json-rpc-filters",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-json-rpc-filters\\base-filter-history.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash.flatmap\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\lodash.flatmap\index.js
      return function (require, module, exports) {
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice,
    spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {boolean} [bitmask] The bitmask of comparison flags.
 *  The bitmask may be composed of the following flags:
 *     1 - Unordered comparison
 *     2 - Partial comparison
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, bitmask, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = getTag(object);
    objTag = objTag == argsTag ? objectTag : objTag;
  }
  if (!othIsArr) {
    othTag = getTag(other);
    othTag = othTag == argsTag ? objectTag : othTag;
  }
  var objIsObj = objTag == objectTag && !isHostObject(object),
      othIsObj = othTag == objectTag && !isHostObject(other),
      isSameTag = objTag == othTag;

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
  }
  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
  };
}

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!seen.has(othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, customizer, bitmask, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= UNORDERED_COMPARE_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = isKey(path, object) ? [path] : castPath(path);

  var result,
      index = -1,
      length = path.length;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result) {
    return result;
  }
  var length = object ? object.length : 0;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function(string) {
  string = toString(string);

  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a flattened array of values by running each element in `collection`
 * thru `iteratee` and flattening the mapped results. The iteratee is invoked
 * with three arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity]
 *  The function invoked per iteration.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * function duplicate(n) {
 *   return [n, n];
 * }
 *
 * _.flatMap([1, 2], duplicate);
 * // => [1, 1, 2, 2]
 */
function flatMap(collection, iteratee) {
  return baseFlatten(map(collection, iteratee), 1);
}

/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee, 3));
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = flatMap;

      };
    };
  }
}, {package:"lodash.flatmap",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\lodash.flatmap\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3\\lib\\web3.js", {"./utils/sha3":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3\\lib\\utils\\sha3.js","./utils/utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3\\lib\\utils\\utils.js","./version.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3\\lib\\version.json","./web3/batch":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3\\lib\\web3\\batch.js","./web3/extend":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3\\lib\\web3\\extend.js","./web3/httpprovider":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3\\lib\\web3\\httpprovider.js","./web3/iban":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3\\lib\\web3\\iban.js","./web3/ipcprovider":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3\\lib\\web3\\ipcprovider.js","./web3/methods/db":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3\\lib\\web3\\methods\\db.js","./web3/methods/eth":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3\\lib\\web3\\methods\\eth.js","./web3/methods/net":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3\\lib\\web3\\methods\\net.js","./web3/methods/personal":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3\\lib\\web3\\methods\\personal.js","./web3/methods/shh":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3\\lib\\web3\\methods\\shh.js","./web3/methods/swarm":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3\\lib\\web3\\methods\\swarm.js","./web3/property":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3\\lib\\web3\\property.js","./web3/requestmanager":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3\\lib\\web3\\requestmanager.js","./web3/settings":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3\\lib\\web3\\settings.js","bignumber.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3\\node_modules\\bignumber.js\\bignumber.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\web3\lib\web3.js
      return function (require, module, exports) {
/*!
 * web3.js - Ethereum JavaScript API
 *
 * @license lgpl-3.0
 * @see https://github.com/ethereum/web3.js
*/

/*
 * This file is part of web3.js.
 * 
 * web3.js is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * web3.js is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @file web3.js
 * @authors:
 *   Jeffrey Wilcke <jeff@ethdev.com>
 *   Marek Kotewicz <marek@ethdev.com>
 *   Marian Oancea <marian@ethdev.com>
 *   Fabian Vogelsteller <fabian@ethdev.com>
 *   Gav Wood <g@ethdev.com>
 * @date 2014
 */

var RequestManager = require('./web3/requestmanager');
var Iban = require('./web3/iban');
var Eth = require('./web3/methods/eth');
var DB = require('./web3/methods/db');
var Shh = require('./web3/methods/shh');
var Net = require('./web3/methods/net');
var Personal = require('./web3/methods/personal');
var Swarm = require('./web3/methods/swarm');
var Settings = require('./web3/settings');
var version = require('./version.json');
var utils = require('./utils/utils');
var sha3 = require('./utils/sha3');
var extend = require('./web3/extend');
var Batch = require('./web3/batch');
var Property = require('./web3/property');
var HttpProvider = require('./web3/httpprovider');
var IpcProvider = require('./web3/ipcprovider');
var BigNumber = require('bignumber.js');



function Web3 (provider) {
    this._requestManager = new RequestManager(provider);
    this.currentProvider = provider;
    this.eth = new Eth(this);
    this.db = new DB(this);
    this.shh = new Shh(this);
    this.net = new Net(this);
    this.personal = new Personal(this);
    this.bzz = new Swarm(this);
    this.settings = new Settings();
    this.version = {
        api: version.version
    };
    this.providers = {
        HttpProvider: HttpProvider,
        IpcProvider: IpcProvider
    };
    this._extend = extend(this);
    this._extend({
        properties: properties()
    });
}

// expose providers on the class
Web3.providers = {
    HttpProvider: HttpProvider,
    IpcProvider: IpcProvider
};

Web3.prototype.setProvider = function (provider) {
    this._requestManager.setProvider(provider);
    this.currentProvider = provider;
};

Web3.prototype.reset = function (keepIsSyncing) {
    this._requestManager.reset(keepIsSyncing);
    this.settings = new Settings();
};

Web3.prototype.BigNumber = BigNumber;
Web3.prototype.toHex = utils.toHex;
Web3.prototype.toAscii = utils.toAscii;
Web3.prototype.toUtf8 = utils.toUtf8;
Web3.prototype.fromAscii = utils.fromAscii;
Web3.prototype.fromUtf8 = utils.fromUtf8;
Web3.prototype.toDecimal = utils.toDecimal;
Web3.prototype.fromDecimal = utils.fromDecimal;
Web3.prototype.toBigNumber = utils.toBigNumber;
Web3.prototype.toWei = utils.toWei;
Web3.prototype.fromWei = utils.fromWei;
Web3.prototype.isAddress = utils.isAddress;
Web3.prototype.isChecksumAddress = utils.isChecksumAddress;
Web3.prototype.toChecksumAddress = utils.toChecksumAddress;
Web3.prototype.isIBAN = utils.isIBAN;
Web3.prototype.padLeft = utils.padLeft;
Web3.prototype.padRight = utils.padRight;


Web3.prototype.sha3 = function(string, options) {
    return '0x' + sha3(string, options);
};

/**
 * Transforms direct icap to address
 */
Web3.prototype.fromICAP = function (icap) {
    var iban = new Iban(icap);
    return iban.address();
};

var properties = function () {
    return [
        new Property({
            name: 'version.node',
            getter: 'web3_clientVersion'
        }),
        new Property({
            name: 'version.network',
            getter: 'net_version',
            inputFormatter: utils.toDecimal
        }),
        new Property({
            name: 'version.ethereum',
            getter: 'eth_protocolVersion',
            inputFormatter: utils.toDecimal
        }),
        new Property({
            name: 'version.whisper',
            getter: 'shh_version',
            inputFormatter: utils.toDecimal
        })
    ];
};

Web3.prototype.isConnected = function(){
    return (this.currentProvider && this.currentProvider.isConnected());
};

Web3.prototype.createBatch = function () {
    return new Batch(this);
};

module.exports = Web3;


      };
    };
  }
}, {package:"web3",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\web3\\lib\\web3.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-abi\\index.js", {"./lib/index.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-abi\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereumjs-abi\index.js
      return function (require, module, exports) {
module.exports = require('./lib/index.js')

      };
    };
  }
}, {package:"ethereumjs-abi",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereumjs-abi\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tweetnacl-util\\nacl-util.js", {"buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\tweetnacl-util\nacl-util.js
      return function (require, module, exports) {
(function (Buffer){(function (){
// Written in 2014-2016 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
(function(root, f) {
  'use strict';
  if (typeof module !== 'undefined' && module.exports) module.exports = f();
  else if (root.nacl) root.nacl.util = f();
  else {
    root.nacl = {};
    root.nacl.util = f();
  }
}(this, function() {
  'use strict';

  var util = {};

  function validateBase64(s) {
    if (!(/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(s))) {
      throw new TypeError('invalid encoding');
    }
  }

  util.decodeUTF8 = function(s) {
    if (typeof s !== 'string') throw new TypeError('expected string');
    var i, d = unescape(encodeURIComponent(s)), b = new Uint8Array(d.length);
    for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
    return b;
  };

  util.encodeUTF8 = function(arr) {
    var i, s = [];
    for (i = 0; i < arr.length; i++) s.push(String.fromCharCode(arr[i]));
    return decodeURIComponent(escape(s.join('')));
  };

  if (typeof atob === 'undefined') {
    // Node.js

    if (typeof Buffer.from !== 'undefined') {
       // Node v6 and later
      util.encodeBase64 = function (arr) { // v6 and later
          return Buffer.from(arr).toString('base64');
      };

      util.decodeBase64 = function (s) {
        validateBase64(s);
        return new Uint8Array(Array.prototype.slice.call(Buffer.from(s, 'base64'), 0));
      };

    } else {
      // Node earlier than v6
      util.encodeBase64 = function (arr) { // v6 and later
        return (new Buffer(arr)).toString('base64');
      };

      util.decodeBase64 = function(s) {
        validateBase64(s);
        return new Uint8Array(Array.prototype.slice.call(new Buffer(s, 'base64'), 0));
      };
    }

  } else {
    // Browsers

    util.encodeBase64 = function(arr) {
      var i, s = [], len = arr.length;
      for (i = 0; i < len; i++) s.push(String.fromCharCode(arr[i]));
      return btoa(s.join(''));
    };

    util.decodeBase64 = function(s) {
      validateBase64(s);
      var i, d = atob(s), b = new Uint8Array(d.length);
      for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
      return b;
    };

  }

  return util;

}));

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"tweetnacl-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tweetnacl-util\\nacl-util.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tweetnacl\\nacl-fast.js", {"crypto":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\tweetnacl\nacl-fast.js
      return function (require, module, exports) {
(function(nacl) {
'use strict';

// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
//
// Implementation derived from TweetNaCl version 20140427.
// See for details: http://tweetnacl.cr.yp.to/

var gf = function(init) {
  var i, r = new Float64Array(16);
  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
  return r;
};

//  Pluggable, initialized in high-level API below.
var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };

var _0 = new Uint8Array(16);
var _9 = new Uint8Array(32); _9[0] = 9;

var gf0 = gf(),
    gf1 = gf([1]),
    _121665 = gf([0xdb41, 1]),
    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

function ts64(x, i, h, l) {
  x[i]   = (h >> 24) & 0xff;
  x[i+1] = (h >> 16) & 0xff;
  x[i+2] = (h >>  8) & 0xff;
  x[i+3] = h & 0xff;
  x[i+4] = (l >> 24)  & 0xff;
  x[i+5] = (l >> 16)  & 0xff;
  x[i+6] = (l >>  8)  & 0xff;
  x[i+7] = l & 0xff;
}

function vn(x, xi, y, yi, n) {
  var i,d = 0;
  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
  return (1 & ((d - 1) >>> 8)) - 1;
}

function crypto_verify_16(x, xi, y, yi) {
  return vn(x,xi,y,yi,16);
}

function crypto_verify_32(x, xi, y, yi) {
  return vn(x,xi,y,yi,32);
}

function core_salsa20(o, p, k, c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }
   x0 =  x0 +  j0 | 0;
   x1 =  x1 +  j1 | 0;
   x2 =  x2 +  j2 | 0;
   x3 =  x3 +  j3 | 0;
   x4 =  x4 +  j4 | 0;
   x5 =  x5 +  j5 | 0;
   x6 =  x6 +  j6 | 0;
   x7 =  x7 +  j7 | 0;
   x8 =  x8 +  j8 | 0;
   x9 =  x9 +  j9 | 0;
  x10 = x10 + j10 | 0;
  x11 = x11 + j11 | 0;
  x12 = x12 + j12 | 0;
  x13 = x13 + j13 | 0;
  x14 = x14 + j14 | 0;
  x15 = x15 + j15 | 0;

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x1 >>>  0 & 0xff;
  o[ 5] = x1 >>>  8 & 0xff;
  o[ 6] = x1 >>> 16 & 0xff;
  o[ 7] = x1 >>> 24 & 0xff;

  o[ 8] = x2 >>>  0 & 0xff;
  o[ 9] = x2 >>>  8 & 0xff;
  o[10] = x2 >>> 16 & 0xff;
  o[11] = x2 >>> 24 & 0xff;

  o[12] = x3 >>>  0 & 0xff;
  o[13] = x3 >>>  8 & 0xff;
  o[14] = x3 >>> 16 & 0xff;
  o[15] = x3 >>> 24 & 0xff;

  o[16] = x4 >>>  0 & 0xff;
  o[17] = x4 >>>  8 & 0xff;
  o[18] = x4 >>> 16 & 0xff;
  o[19] = x4 >>> 24 & 0xff;

  o[20] = x5 >>>  0 & 0xff;
  o[21] = x5 >>>  8 & 0xff;
  o[22] = x5 >>> 16 & 0xff;
  o[23] = x5 >>> 24 & 0xff;

  o[24] = x6 >>>  0 & 0xff;
  o[25] = x6 >>>  8 & 0xff;
  o[26] = x6 >>> 16 & 0xff;
  o[27] = x6 >>> 24 & 0xff;

  o[28] = x7 >>>  0 & 0xff;
  o[29] = x7 >>>  8 & 0xff;
  o[30] = x7 >>> 16 & 0xff;
  o[31] = x7 >>> 24 & 0xff;

  o[32] = x8 >>>  0 & 0xff;
  o[33] = x8 >>>  8 & 0xff;
  o[34] = x8 >>> 16 & 0xff;
  o[35] = x8 >>> 24 & 0xff;

  o[36] = x9 >>>  0 & 0xff;
  o[37] = x9 >>>  8 & 0xff;
  o[38] = x9 >>> 16 & 0xff;
  o[39] = x9 >>> 24 & 0xff;

  o[40] = x10 >>>  0 & 0xff;
  o[41] = x10 >>>  8 & 0xff;
  o[42] = x10 >>> 16 & 0xff;
  o[43] = x10 >>> 24 & 0xff;

  o[44] = x11 >>>  0 & 0xff;
  o[45] = x11 >>>  8 & 0xff;
  o[46] = x11 >>> 16 & 0xff;
  o[47] = x11 >>> 24 & 0xff;

  o[48] = x12 >>>  0 & 0xff;
  o[49] = x12 >>>  8 & 0xff;
  o[50] = x12 >>> 16 & 0xff;
  o[51] = x12 >>> 24 & 0xff;

  o[52] = x13 >>>  0 & 0xff;
  o[53] = x13 >>>  8 & 0xff;
  o[54] = x13 >>> 16 & 0xff;
  o[55] = x13 >>> 24 & 0xff;

  o[56] = x14 >>>  0 & 0xff;
  o[57] = x14 >>>  8 & 0xff;
  o[58] = x14 >>> 16 & 0xff;
  o[59] = x14 >>> 24 & 0xff;

  o[60] = x15 >>>  0 & 0xff;
  o[61] = x15 >>>  8 & 0xff;
  o[62] = x15 >>> 16 & 0xff;
  o[63] = x15 >>> 24 & 0xff;
}

function core_hsalsa20(o,p,k,c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x5 >>>  0 & 0xff;
  o[ 5] = x5 >>>  8 & 0xff;
  o[ 6] = x5 >>> 16 & 0xff;
  o[ 7] = x5 >>> 24 & 0xff;

  o[ 8] = x10 >>>  0 & 0xff;
  o[ 9] = x10 >>>  8 & 0xff;
  o[10] = x10 >>> 16 & 0xff;
  o[11] = x10 >>> 24 & 0xff;

  o[12] = x15 >>>  0 & 0xff;
  o[13] = x15 >>>  8 & 0xff;
  o[14] = x15 >>> 16 & 0xff;
  o[15] = x15 >>> 24 & 0xff;

  o[16] = x6 >>>  0 & 0xff;
  o[17] = x6 >>>  8 & 0xff;
  o[18] = x6 >>> 16 & 0xff;
  o[19] = x6 >>> 24 & 0xff;

  o[20] = x7 >>>  0 & 0xff;
  o[21] = x7 >>>  8 & 0xff;
  o[22] = x7 >>> 16 & 0xff;
  o[23] = x7 >>> 24 & 0xff;

  o[24] = x8 >>>  0 & 0xff;
  o[25] = x8 >>>  8 & 0xff;
  o[26] = x8 >>> 16 & 0xff;
  o[27] = x8 >>> 24 & 0xff;

  o[28] = x9 >>>  0 & 0xff;
  o[29] = x9 >>>  8 & 0xff;
  o[30] = x9 >>> 16 & 0xff;
  o[31] = x9 >>> 24 & 0xff;
}

function crypto_core_salsa20(out,inp,k,c) {
  core_salsa20(out,inp,k,c);
}

function crypto_core_hsalsa20(out,inp,k,c) {
  core_hsalsa20(out,inp,k,c);
}

var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
            // "expand 32-byte k"

function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
    mpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
  }
  return 0;
}

function crypto_stream_salsa20(c,cpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = x[i];
  }
  return 0;
}

function crypto_stream(c,cpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20(c,cpos,d,sn,s);
}

function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
}

/*
* Port of Andrew Moon's Poly1305-donna-16. Public domain.
* https://github.com/floodyberry/poly1305-donna
*/

var poly1305 = function(key) {
  this.buffer = new Uint8Array(16);
  this.r = new Uint16Array(10);
  this.h = new Uint16Array(10);
  this.pad = new Uint16Array(8);
  this.leftover = 0;
  this.fin = 0;

  var t0, t1, t2, t3, t4, t5, t6, t7;

  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
  this.r[5] = ((t4 >>>  1)) & 0x1ffe;
  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
  this.r[9] = ((t7 >>>  5)) & 0x007f;

  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
};

poly1305.prototype.blocks = function(m, mpos, bytes) {
  var hibit = this.fin ? 0 : (1 << 11);
  var t0, t1, t2, t3, t4, t5, t6, t7, c;
  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;

  var h0 = this.h[0],
      h1 = this.h[1],
      h2 = this.h[2],
      h3 = this.h[3],
      h4 = this.h[4],
      h5 = this.h[5],
      h6 = this.h[6],
      h7 = this.h[7],
      h8 = this.h[8],
      h9 = this.h[9];

  var r0 = this.r[0],
      r1 = this.r[1],
      r2 = this.r[2],
      r3 = this.r[3],
      r4 = this.r[4],
      r5 = this.r[5],
      r6 = this.r[6],
      r7 = this.r[7],
      r8 = this.r[8],
      r9 = this.r[9];

  while (bytes >= 16) {
    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
    h5 += ((t4 >>>  1)) & 0x1fff;
    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
    h9 += ((t7 >>> 5)) | hibit;

    c = 0;

    d0 = c;
    d0 += h0 * r0;
    d0 += h1 * (5 * r9);
    d0 += h2 * (5 * r8);
    d0 += h3 * (5 * r7);
    d0 += h4 * (5 * r6);
    c = (d0 >>> 13); d0 &= 0x1fff;
    d0 += h5 * (5 * r5);
    d0 += h6 * (5 * r4);
    d0 += h7 * (5 * r3);
    d0 += h8 * (5 * r2);
    d0 += h9 * (5 * r1);
    c += (d0 >>> 13); d0 &= 0x1fff;

    d1 = c;
    d1 += h0 * r1;
    d1 += h1 * r0;
    d1 += h2 * (5 * r9);
    d1 += h3 * (5 * r8);
    d1 += h4 * (5 * r7);
    c = (d1 >>> 13); d1 &= 0x1fff;
    d1 += h5 * (5 * r6);
    d1 += h6 * (5 * r5);
    d1 += h7 * (5 * r4);
    d1 += h8 * (5 * r3);
    d1 += h9 * (5 * r2);
    c += (d1 >>> 13); d1 &= 0x1fff;

    d2 = c;
    d2 += h0 * r2;
    d2 += h1 * r1;
    d2 += h2 * r0;
    d2 += h3 * (5 * r9);
    d2 += h4 * (5 * r8);
    c = (d2 >>> 13); d2 &= 0x1fff;
    d2 += h5 * (5 * r7);
    d2 += h6 * (5 * r6);
    d2 += h7 * (5 * r5);
    d2 += h8 * (5 * r4);
    d2 += h9 * (5 * r3);
    c += (d2 >>> 13); d2 &= 0x1fff;

    d3 = c;
    d3 += h0 * r3;
    d3 += h1 * r2;
    d3 += h2 * r1;
    d3 += h3 * r0;
    d3 += h4 * (5 * r9);
    c = (d3 >>> 13); d3 &= 0x1fff;
    d3 += h5 * (5 * r8);
    d3 += h6 * (5 * r7);
    d3 += h7 * (5 * r6);
    d3 += h8 * (5 * r5);
    d3 += h9 * (5 * r4);
    c += (d3 >>> 13); d3 &= 0x1fff;

    d4 = c;
    d4 += h0 * r4;
    d4 += h1 * r3;
    d4 += h2 * r2;
    d4 += h3 * r1;
    d4 += h4 * r0;
    c = (d4 >>> 13); d4 &= 0x1fff;
    d4 += h5 * (5 * r9);
    d4 += h6 * (5 * r8);
    d4 += h7 * (5 * r7);
    d4 += h8 * (5 * r6);
    d4 += h9 * (5 * r5);
    c += (d4 >>> 13); d4 &= 0x1fff;

    d5 = c;
    d5 += h0 * r5;
    d5 += h1 * r4;
    d5 += h2 * r3;
    d5 += h3 * r2;
    d5 += h4 * r1;
    c = (d5 >>> 13); d5 &= 0x1fff;
    d5 += h5 * r0;
    d5 += h6 * (5 * r9);
    d5 += h7 * (5 * r8);
    d5 += h8 * (5 * r7);
    d5 += h9 * (5 * r6);
    c += (d5 >>> 13); d5 &= 0x1fff;

    d6 = c;
    d6 += h0 * r6;
    d6 += h1 * r5;
    d6 += h2 * r4;
    d6 += h3 * r3;
    d6 += h4 * r2;
    c = (d6 >>> 13); d6 &= 0x1fff;
    d6 += h5 * r1;
    d6 += h6 * r0;
    d6 += h7 * (5 * r9);
    d6 += h8 * (5 * r8);
    d6 += h9 * (5 * r7);
    c += (d6 >>> 13); d6 &= 0x1fff;

    d7 = c;
    d7 += h0 * r7;
    d7 += h1 * r6;
    d7 += h2 * r5;
    d7 += h3 * r4;
    d7 += h4 * r3;
    c = (d7 >>> 13); d7 &= 0x1fff;
    d7 += h5 * r2;
    d7 += h6 * r1;
    d7 += h7 * r0;
    d7 += h8 * (5 * r9);
    d7 += h9 * (5 * r8);
    c += (d7 >>> 13); d7 &= 0x1fff;

    d8 = c;
    d8 += h0 * r8;
    d8 += h1 * r7;
    d8 += h2 * r6;
    d8 += h3 * r5;
    d8 += h4 * r4;
    c = (d8 >>> 13); d8 &= 0x1fff;
    d8 += h5 * r3;
    d8 += h6 * r2;
    d8 += h7 * r1;
    d8 += h8 * r0;
    d8 += h9 * (5 * r9);
    c += (d8 >>> 13); d8 &= 0x1fff;

    d9 = c;
    d9 += h0 * r9;
    d9 += h1 * r8;
    d9 += h2 * r7;
    d9 += h3 * r6;
    d9 += h4 * r5;
    c = (d9 >>> 13); d9 &= 0x1fff;
    d9 += h5 * r4;
    d9 += h6 * r3;
    d9 += h7 * r2;
    d9 += h8 * r1;
    d9 += h9 * r0;
    c += (d9 >>> 13); d9 &= 0x1fff;

    c = (((c << 2) + c)) | 0;
    c = (c + d0) | 0;
    d0 = c & 0x1fff;
    c = (c >>> 13);
    d1 += c;

    h0 = d0;
    h1 = d1;
    h2 = d2;
    h3 = d3;
    h4 = d4;
    h5 = d5;
    h6 = d6;
    h7 = d7;
    h8 = d8;
    h9 = d9;

    mpos += 16;
    bytes -= 16;
  }
  this.h[0] = h0;
  this.h[1] = h1;
  this.h[2] = h2;
  this.h[3] = h3;
  this.h[4] = h4;
  this.h[5] = h5;
  this.h[6] = h6;
  this.h[7] = h7;
  this.h[8] = h8;
  this.h[9] = h9;
};

poly1305.prototype.finish = function(mac, macpos) {
  var g = new Uint16Array(10);
  var c, mask, f, i;

  if (this.leftover) {
    i = this.leftover;
    this.buffer[i++] = 1;
    for (; i < 16; i++) this.buffer[i] = 0;
    this.fin = 1;
    this.blocks(this.buffer, 0, 16);
  }

  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  for (i = 2; i < 10; i++) {
    this.h[i] += c;
    c = this.h[i] >>> 13;
    this.h[i] &= 0x1fff;
  }
  this.h[0] += (c * 5);
  c = this.h[0] >>> 13;
  this.h[0] &= 0x1fff;
  this.h[1] += c;
  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  this.h[2] += c;

  g[0] = this.h[0] + 5;
  c = g[0] >>> 13;
  g[0] &= 0x1fff;
  for (i = 1; i < 10; i++) {
    g[i] = this.h[i] + c;
    c = g[i] >>> 13;
    g[i] &= 0x1fff;
  }
  g[9] -= (1 << 13);

  mask = (c ^ 1) - 1;
  for (i = 0; i < 10; i++) g[i] &= mask;
  mask = ~mask;
  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];

  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;

  f = this.h[0] + this.pad[0];
  this.h[0] = f & 0xffff;
  for (i = 1; i < 8; i++) {
    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
    this.h[i] = f & 0xffff;
  }

  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
};

poly1305.prototype.update = function(m, mpos, bytes) {
  var i, want;

  if (this.leftover) {
    want = (16 - this.leftover);
    if (want > bytes)
      want = bytes;
    for (i = 0; i < want; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    bytes -= want;
    mpos += want;
    this.leftover += want;
    if (this.leftover < 16)
      return;
    this.blocks(this.buffer, 0, 16);
    this.leftover = 0;
  }

  if (bytes >= 16) {
    want = bytes - (bytes % 16);
    this.blocks(m, mpos, want);
    mpos += want;
    bytes -= want;
  }

  if (bytes) {
    for (i = 0; i < bytes; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    this.leftover += bytes;
  }
};

function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
  var s = new poly1305(k);
  s.update(m, mpos, n);
  s.finish(out, outpos);
  return 0;
}

function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
  var x = new Uint8Array(16);
  crypto_onetimeauth(x,0,m,mpos,n,k);
  return crypto_verify_16(h,hpos,x,0);
}

function crypto_secretbox(c,m,d,n,k) {
  var i;
  if (d < 32) return -1;
  crypto_stream_xor(c,0,m,0,d,n,k);
  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
  for (i = 0; i < 16; i++) c[i] = 0;
  return 0;
}

function crypto_secretbox_open(m,c,d,n,k) {
  var i;
  var x = new Uint8Array(32);
  if (d < 32) return -1;
  crypto_stream(x,0,32,n,k);
  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
  crypto_stream_xor(m,0,c,0,d,n,k);
  for (i = 0; i < 32; i++) m[i] = 0;
  return 0;
}

function set25519(r, a) {
  var i;
  for (i = 0; i < 16; i++) r[i] = a[i]|0;
}

function car25519(o) {
  var i, v, c = 1;
  for (i = 0; i < 16; i++) {
    v = o[i] + c + 65535;
    c = Math.floor(v / 65536);
    o[i] = v - c * 65536;
  }
  o[0] += c-1 + 37 * (c-1);
}

function sel25519(p, q, b) {
  var t, c = ~(b-1);
  for (var i = 0; i < 16; i++) {
    t = c & (p[i] ^ q[i]);
    p[i] ^= t;
    q[i] ^= t;
  }
}

function pack25519(o, n) {
  var i, j, b;
  var m = gf(), t = gf();
  for (i = 0; i < 16; i++) t[i] = n[i];
  car25519(t);
  car25519(t);
  car25519(t);
  for (j = 0; j < 2; j++) {
    m[0] = t[0] - 0xffed;
    for (i = 1; i < 15; i++) {
      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
      m[i-1] &= 0xffff;
    }
    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
    b = (m[15]>>16) & 1;
    m[14] &= 0xffff;
    sel25519(t, m, 1-b);
  }
  for (i = 0; i < 16; i++) {
    o[2*i] = t[i] & 0xff;
    o[2*i+1] = t[i]>>8;
  }
}

function neq25519(a, b) {
  var c = new Uint8Array(32), d = new Uint8Array(32);
  pack25519(c, a);
  pack25519(d, b);
  return crypto_verify_32(c, 0, d, 0);
}

function par25519(a) {
  var d = new Uint8Array(32);
  pack25519(d, a);
  return d[0] & 1;
}

function unpack25519(o, n) {
  var i;
  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
  o[15] &= 0x7fff;
}

function A(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
}

function Z(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
}

function M(o, a, b) {
  var v, c,
     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
    b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7],
    b8 = b[8],
    b9 = b[9],
    b10 = b[10],
    b11 = b[11],
    b12 = b[12],
    b13 = b[13],
    b14 = b[14],
    b15 = b[15];

  v = a[0];
  t0 += v * b0;
  t1 += v * b1;
  t2 += v * b2;
  t3 += v * b3;
  t4 += v * b4;
  t5 += v * b5;
  t6 += v * b6;
  t7 += v * b7;
  t8 += v * b8;
  t9 += v * b9;
  t10 += v * b10;
  t11 += v * b11;
  t12 += v * b12;
  t13 += v * b13;
  t14 += v * b14;
  t15 += v * b15;
  v = a[1];
  t1 += v * b0;
  t2 += v * b1;
  t3 += v * b2;
  t4 += v * b3;
  t5 += v * b4;
  t6 += v * b5;
  t7 += v * b6;
  t8 += v * b7;
  t9 += v * b8;
  t10 += v * b9;
  t11 += v * b10;
  t12 += v * b11;
  t13 += v * b12;
  t14 += v * b13;
  t15 += v * b14;
  t16 += v * b15;
  v = a[2];
  t2 += v * b0;
  t3 += v * b1;
  t4 += v * b2;
  t5 += v * b3;
  t6 += v * b4;
  t7 += v * b5;
  t8 += v * b6;
  t9 += v * b7;
  t10 += v * b8;
  t11 += v * b9;
  t12 += v * b10;
  t13 += v * b11;
  t14 += v * b12;
  t15 += v * b13;
  t16 += v * b14;
  t17 += v * b15;
  v = a[3];
  t3 += v * b0;
  t4 += v * b1;
  t5 += v * b2;
  t6 += v * b3;
  t7 += v * b4;
  t8 += v * b5;
  t9 += v * b6;
  t10 += v * b7;
  t11 += v * b8;
  t12 += v * b9;
  t13 += v * b10;
  t14 += v * b11;
  t15 += v * b12;
  t16 += v * b13;
  t17 += v * b14;
  t18 += v * b15;
  v = a[4];
  t4 += v * b0;
  t5 += v * b1;
  t6 += v * b2;
  t7 += v * b3;
  t8 += v * b4;
  t9 += v * b5;
  t10 += v * b6;
  t11 += v * b7;
  t12 += v * b8;
  t13 += v * b9;
  t14 += v * b10;
  t15 += v * b11;
  t16 += v * b12;
  t17 += v * b13;
  t18 += v * b14;
  t19 += v * b15;
  v = a[5];
  t5 += v * b0;
  t6 += v * b1;
  t7 += v * b2;
  t8 += v * b3;
  t9 += v * b4;
  t10 += v * b5;
  t11 += v * b6;
  t12 += v * b7;
  t13 += v * b8;
  t14 += v * b9;
  t15 += v * b10;
  t16 += v * b11;
  t17 += v * b12;
  t18 += v * b13;
  t19 += v * b14;
  t20 += v * b15;
  v = a[6];
  t6 += v * b0;
  t7 += v * b1;
  t8 += v * b2;
  t9 += v * b3;
  t10 += v * b4;
  t11 += v * b5;
  t12 += v * b6;
  t13 += v * b7;
  t14 += v * b8;
  t15 += v * b9;
  t16 += v * b10;
  t17 += v * b11;
  t18 += v * b12;
  t19 += v * b13;
  t20 += v * b14;
  t21 += v * b15;
  v = a[7];
  t7 += v * b0;
  t8 += v * b1;
  t9 += v * b2;
  t10 += v * b3;
  t11 += v * b4;
  t12 += v * b5;
  t13 += v * b6;
  t14 += v * b7;
  t15 += v * b8;
  t16 += v * b9;
  t17 += v * b10;
  t18 += v * b11;
  t19 += v * b12;
  t20 += v * b13;
  t21 += v * b14;
  t22 += v * b15;
  v = a[8];
  t8 += v * b0;
  t9 += v * b1;
  t10 += v * b2;
  t11 += v * b3;
  t12 += v * b4;
  t13 += v * b5;
  t14 += v * b6;
  t15 += v * b7;
  t16 += v * b8;
  t17 += v * b9;
  t18 += v * b10;
  t19 += v * b11;
  t20 += v * b12;
  t21 += v * b13;
  t22 += v * b14;
  t23 += v * b15;
  v = a[9];
  t9 += v * b0;
  t10 += v * b1;
  t11 += v * b2;
  t12 += v * b3;
  t13 += v * b4;
  t14 += v * b5;
  t15 += v * b6;
  t16 += v * b7;
  t17 += v * b8;
  t18 += v * b9;
  t19 += v * b10;
  t20 += v * b11;
  t21 += v * b12;
  t22 += v * b13;
  t23 += v * b14;
  t24 += v * b15;
  v = a[10];
  t10 += v * b0;
  t11 += v * b1;
  t12 += v * b2;
  t13 += v * b3;
  t14 += v * b4;
  t15 += v * b5;
  t16 += v * b6;
  t17 += v * b7;
  t18 += v * b8;
  t19 += v * b9;
  t20 += v * b10;
  t21 += v * b11;
  t22 += v * b12;
  t23 += v * b13;
  t24 += v * b14;
  t25 += v * b15;
  v = a[11];
  t11 += v * b0;
  t12 += v * b1;
  t13 += v * b2;
  t14 += v * b3;
  t15 += v * b4;
  t16 += v * b5;
  t17 += v * b6;
  t18 += v * b7;
  t19 += v * b8;
  t20 += v * b9;
  t21 += v * b10;
  t22 += v * b11;
  t23 += v * b12;
  t24 += v * b13;
  t25 += v * b14;
  t26 += v * b15;
  v = a[12];
  t12 += v * b0;
  t13 += v * b1;
  t14 += v * b2;
  t15 += v * b3;
  t16 += v * b4;
  t17 += v * b5;
  t18 += v * b6;
  t19 += v * b7;
  t20 += v * b8;
  t21 += v * b9;
  t22 += v * b10;
  t23 += v * b11;
  t24 += v * b12;
  t25 += v * b13;
  t26 += v * b14;
  t27 += v * b15;
  v = a[13];
  t13 += v * b0;
  t14 += v * b1;
  t15 += v * b2;
  t16 += v * b3;
  t17 += v * b4;
  t18 += v * b5;
  t19 += v * b6;
  t20 += v * b7;
  t21 += v * b8;
  t22 += v * b9;
  t23 += v * b10;
  t24 += v * b11;
  t25 += v * b12;
  t26 += v * b13;
  t27 += v * b14;
  t28 += v * b15;
  v = a[14];
  t14 += v * b0;
  t15 += v * b1;
  t16 += v * b2;
  t17 += v * b3;
  t18 += v * b4;
  t19 += v * b5;
  t20 += v * b6;
  t21 += v * b7;
  t22 += v * b8;
  t23 += v * b9;
  t24 += v * b10;
  t25 += v * b11;
  t26 += v * b12;
  t27 += v * b13;
  t28 += v * b14;
  t29 += v * b15;
  v = a[15];
  t15 += v * b0;
  t16 += v * b1;
  t17 += v * b2;
  t18 += v * b3;
  t19 += v * b4;
  t20 += v * b5;
  t21 += v * b6;
  t22 += v * b7;
  t23 += v * b8;
  t24 += v * b9;
  t25 += v * b10;
  t26 += v * b11;
  t27 += v * b12;
  t28 += v * b13;
  t29 += v * b14;
  t30 += v * b15;

  t0  += 38 * t16;
  t1  += 38 * t17;
  t2  += 38 * t18;
  t3  += 38 * t19;
  t4  += 38 * t20;
  t5  += 38 * t21;
  t6  += 38 * t22;
  t7  += 38 * t23;
  t8  += 38 * t24;
  t9  += 38 * t25;
  t10 += 38 * t26;
  t11 += 38 * t27;
  t12 += 38 * t28;
  t13 += 38 * t29;
  t14 += 38 * t30;
  // t15 left as is

  // first car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  // second car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  o[ 0] = t0;
  o[ 1] = t1;
  o[ 2] = t2;
  o[ 3] = t3;
  o[ 4] = t4;
  o[ 5] = t5;
  o[ 6] = t6;
  o[ 7] = t7;
  o[ 8] = t8;
  o[ 9] = t9;
  o[10] = t10;
  o[11] = t11;
  o[12] = t12;
  o[13] = t13;
  o[14] = t14;
  o[15] = t15;
}

function S(o, a) {
  M(o, a, a);
}

function inv25519(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 253; a >= 0; a--) {
    S(c, c);
    if(a !== 2 && a !== 4) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function pow2523(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 250; a >= 0; a--) {
      S(c, c);
      if(a !== 1) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function crypto_scalarmult(q, n, p) {
  var z = new Uint8Array(32);
  var x = new Float64Array(80), r, i;
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf();
  for (i = 0; i < 31; i++) z[i] = n[i];
  z[31]=(n[31]&127)|64;
  z[0]&=248;
  unpack25519(x,p);
  for (i = 0; i < 16; i++) {
    b[i]=x[i];
    d[i]=a[i]=c[i]=0;
  }
  a[0]=d[0]=1;
  for (i=254; i>=0; --i) {
    r=(z[i>>>3]>>>(i&7))&1;
    sel25519(a,b,r);
    sel25519(c,d,r);
    A(e,a,c);
    Z(a,a,c);
    A(c,b,d);
    Z(b,b,d);
    S(d,e);
    S(f,a);
    M(a,c,a);
    M(c,b,e);
    A(e,a,c);
    Z(a,a,c);
    S(b,a);
    Z(c,d,f);
    M(a,c,_121665);
    A(a,a,d);
    M(c,c,a);
    M(a,d,f);
    M(d,b,x);
    S(b,e);
    sel25519(a,b,r);
    sel25519(c,d,r);
  }
  for (i = 0; i < 16; i++) {
    x[i+16]=a[i];
    x[i+32]=c[i];
    x[i+48]=b[i];
    x[i+64]=d[i];
  }
  var x32 = x.subarray(32);
  var x16 = x.subarray(16);
  inv25519(x32,x32);
  M(x16,x16,x32);
  pack25519(q,x16);
  return 0;
}

function crypto_scalarmult_base(q, n) {
  return crypto_scalarmult(q, n, _9);
}

function crypto_box_keypair(y, x) {
  randombytes(x, 32);
  return crypto_scalarmult_base(y, x);
}

function crypto_box_beforenm(k, y, x) {
  var s = new Uint8Array(32);
  crypto_scalarmult(s, x, y);
  return crypto_core_hsalsa20(k, _0, s, sigma);
}

var crypto_box_afternm = crypto_secretbox;
var crypto_box_open_afternm = crypto_secretbox_open;

function crypto_box(c, m, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_afternm(c, m, d, n, k);
}

function crypto_box_open(m, c, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_open_afternm(m, c, d, n, k);
}

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function crypto_hashblocks_hl(hh, hl, m, n) {
  var wh = new Int32Array(16), wl = new Int32Array(16),
      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
      th, tl, i, j, h, l, a, b, c, d;

  var ah0 = hh[0],
      ah1 = hh[1],
      ah2 = hh[2],
      ah3 = hh[3],
      ah4 = hh[4],
      ah5 = hh[5],
      ah6 = hh[6],
      ah7 = hh[7],

      al0 = hl[0],
      al1 = hl[1],
      al2 = hl[2],
      al3 = hl[3],
      al4 = hl[4],
      al5 = hl[5],
      al6 = hl[6],
      al7 = hl[7];

  var pos = 0;
  while (n >= 128) {
    for (i = 0; i < 16; i++) {
      j = 8 * i + pos;
      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
    }
    for (i = 0; i < 80; i++) {
      bh0 = ah0;
      bh1 = ah1;
      bh2 = ah2;
      bh3 = ah3;
      bh4 = ah4;
      bh5 = ah5;
      bh6 = ah6;
      bh7 = ah7;

      bl0 = al0;
      bl1 = al1;
      bl2 = al2;
      bl3 = al3;
      bl4 = al4;
      bl5 = al5;
      bl6 = al6;
      bl7 = al7;

      // add
      h = ah7;
      l = al7;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma1
      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Ch
      h = (ah4 & ah5) ^ (~ah4 & ah6);
      l = (al4 & al5) ^ (~al4 & al6);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // K
      h = K[i*2];
      l = K[i*2+1];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // w
      h = wh[i%16];
      l = wl[i%16];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      th = c & 0xffff | d << 16;
      tl = a & 0xffff | b << 16;

      // add
      h = th;
      l = tl;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma0
      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Maj
      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh7 = (c & 0xffff) | (d << 16);
      bl7 = (a & 0xffff) | (b << 16);

      // add
      h = bh3;
      l = bl3;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      h = th;
      l = tl;

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh3 = (c & 0xffff) | (d << 16);
      bl3 = (a & 0xffff) | (b << 16);

      ah1 = bh0;
      ah2 = bh1;
      ah3 = bh2;
      ah4 = bh3;
      ah5 = bh4;
      ah6 = bh5;
      ah7 = bh6;
      ah0 = bh7;

      al1 = bl0;
      al2 = bl1;
      al3 = bl2;
      al4 = bl3;
      al5 = bl4;
      al6 = bl5;
      al7 = bl6;
      al0 = bl7;

      if (i%16 === 15) {
        for (j = 0; j < 16; j++) {
          // add
          h = wh[j];
          l = wl[j];

          a = l & 0xffff; b = l >>> 16;
          c = h & 0xffff; d = h >>> 16;

          h = wh[(j+9)%16];
          l = wl[(j+9)%16];

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma0
          th = wh[(j+1)%16];
          tl = wl[(j+1)%16];
          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma1
          th = wh[(j+14)%16];
          tl = wl[(j+14)%16];
          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;

          wh[j] = (c & 0xffff) | (d << 16);
          wl[j] = (a & 0xffff) | (b << 16);
        }
      }
    }

    // add
    h = ah0;
    l = al0;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[0];
    l = hl[0];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[0] = ah0 = (c & 0xffff) | (d << 16);
    hl[0] = al0 = (a & 0xffff) | (b << 16);

    h = ah1;
    l = al1;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[1];
    l = hl[1];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[1] = ah1 = (c & 0xffff) | (d << 16);
    hl[1] = al1 = (a & 0xffff) | (b << 16);

    h = ah2;
    l = al2;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[2];
    l = hl[2];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[2] = ah2 = (c & 0xffff) | (d << 16);
    hl[2] = al2 = (a & 0xffff) | (b << 16);

    h = ah3;
    l = al3;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[3];
    l = hl[3];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[3] = ah3 = (c & 0xffff) | (d << 16);
    hl[3] = al3 = (a & 0xffff) | (b << 16);

    h = ah4;
    l = al4;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[4];
    l = hl[4];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[4] = ah4 = (c & 0xffff) | (d << 16);
    hl[4] = al4 = (a & 0xffff) | (b << 16);

    h = ah5;
    l = al5;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[5];
    l = hl[5];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[5] = ah5 = (c & 0xffff) | (d << 16);
    hl[5] = al5 = (a & 0xffff) | (b << 16);

    h = ah6;
    l = al6;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[6];
    l = hl[6];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[6] = ah6 = (c & 0xffff) | (d << 16);
    hl[6] = al6 = (a & 0xffff) | (b << 16);

    h = ah7;
    l = al7;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[7];
    l = hl[7];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[7] = ah7 = (c & 0xffff) | (d << 16);
    hl[7] = al7 = (a & 0xffff) | (b << 16);

    pos += 128;
    n -= 128;
  }

  return n;
}

function crypto_hash(out, m, n) {
  var hh = new Int32Array(8),
      hl = new Int32Array(8),
      x = new Uint8Array(256),
      i, b = n;

  hh[0] = 0x6a09e667;
  hh[1] = 0xbb67ae85;
  hh[2] = 0x3c6ef372;
  hh[3] = 0xa54ff53a;
  hh[4] = 0x510e527f;
  hh[5] = 0x9b05688c;
  hh[6] = 0x1f83d9ab;
  hh[7] = 0x5be0cd19;

  hl[0] = 0xf3bcc908;
  hl[1] = 0x84caa73b;
  hl[2] = 0xfe94f82b;
  hl[3] = 0x5f1d36f1;
  hl[4] = 0xade682d1;
  hl[5] = 0x2b3e6c1f;
  hl[6] = 0xfb41bd6b;
  hl[7] = 0x137e2179;

  crypto_hashblocks_hl(hh, hl, m, n);
  n %= 128;

  for (i = 0; i < n; i++) x[i] = m[b-n+i];
  x[n] = 128;

  n = 256-128*(n<112?1:0);
  x[n-9] = 0;
  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
  crypto_hashblocks_hl(hh, hl, x, n);

  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);

  return 0;
}

function add(p, q) {
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf(),
      g = gf(), h = gf(), t = gf();

  Z(a, p[1], p[0]);
  Z(t, q[1], q[0]);
  M(a, a, t);
  A(b, p[0], p[1]);
  A(t, q[0], q[1]);
  M(b, b, t);
  M(c, p[3], q[3]);
  M(c, c, D2);
  M(d, p[2], q[2]);
  A(d, d, d);
  Z(e, b, a);
  Z(f, d, c);
  A(g, d, c);
  A(h, b, a);

  M(p[0], e, f);
  M(p[1], h, g);
  M(p[2], g, f);
  M(p[3], e, h);
}

function cswap(p, q, b) {
  var i;
  for (i = 0; i < 4; i++) {
    sel25519(p[i], q[i], b);
  }
}

function pack(r, p) {
  var tx = gf(), ty = gf(), zi = gf();
  inv25519(zi, p[2]);
  M(tx, p[0], zi);
  M(ty, p[1], zi);
  pack25519(r, ty);
  r[31] ^= par25519(tx) << 7;
}

function scalarmult(p, q, s) {
  var b, i;
  set25519(p[0], gf0);
  set25519(p[1], gf1);
  set25519(p[2], gf1);
  set25519(p[3], gf0);
  for (i = 255; i >= 0; --i) {
    b = (s[(i/8)|0] >> (i&7)) & 1;
    cswap(p, q, b);
    add(q, p);
    add(p, p);
    cswap(p, q, b);
  }
}

function scalarbase(p, s) {
  var q = [gf(), gf(), gf(), gf()];
  set25519(q[0], X);
  set25519(q[1], Y);
  set25519(q[2], gf1);
  M(q[3], X, Y);
  scalarmult(p, q, s);
}

function crypto_sign_keypair(pk, sk, seeded) {
  var d = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()];
  var i;

  if (!seeded) randombytes(sk, 32);
  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  scalarbase(p, d);
  pack(pk, p);

  for (i = 0; i < 32; i++) sk[i+32] = pk[i];
  return 0;
}

var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

function modL(r, x) {
  var carry, i, j, k;
  for (i = 63; i >= 32; --i) {
    carry = 0;
    for (j = i - 32, k = i - 12; j < k; ++j) {
      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
      carry = Math.floor((x[j] + 128) / 256);
      x[j] -= carry * 256;
    }
    x[j] += carry;
    x[i] = 0;
  }
  carry = 0;
  for (j = 0; j < 32; j++) {
    x[j] += carry - (x[31] >> 4) * L[j];
    carry = x[j] >> 8;
    x[j] &= 255;
  }
  for (j = 0; j < 32; j++) x[j] -= carry * L[j];
  for (i = 0; i < 32; i++) {
    x[i+1] += x[i] >> 8;
    r[i] = x[i] & 255;
  }
}

function reduce(r) {
  var x = new Float64Array(64), i;
  for (i = 0; i < 64; i++) x[i] = r[i];
  for (i = 0; i < 64; i++) r[i] = 0;
  modL(r, x);
}

// Note: difference from C - smlen returned, not passed as argument.
function crypto_sign(sm, m, n, sk) {
  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
  var i, j, x = new Float64Array(64);
  var p = [gf(), gf(), gf(), gf()];

  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  var smlen = n + 64;
  for (i = 0; i < n; i++) sm[64 + i] = m[i];
  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

  crypto_hash(r, sm.subarray(32), n+32);
  reduce(r);
  scalarbase(p, r);
  pack(sm, p);

  for (i = 32; i < 64; i++) sm[i] = sk[i];
  crypto_hash(h, sm, n + 64);
  reduce(h);

  for (i = 0; i < 64; i++) x[i] = 0;
  for (i = 0; i < 32; i++) x[i] = r[i];
  for (i = 0; i < 32; i++) {
    for (j = 0; j < 32; j++) {
      x[i+j] += h[i] * d[j];
    }
  }

  modL(sm.subarray(32), x);
  return smlen;
}

function unpackneg(r, p) {
  var t = gf(), chk = gf(), num = gf(),
      den = gf(), den2 = gf(), den4 = gf(),
      den6 = gf();

  set25519(r[2], gf1);
  unpack25519(r[1], p);
  S(num, r[1]);
  M(den, num, D);
  Z(num, num, r[2]);
  A(den, r[2], den);

  S(den2, den);
  S(den4, den2);
  M(den6, den4, den2);
  M(t, den6, num);
  M(t, t, den);

  pow2523(t, t);
  M(t, t, num);
  M(t, t, den);
  M(t, t, den);
  M(r[0], t, den);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) M(r[0], r[0], I);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) return -1;

  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

  M(r[3], r[0], r[1]);
  return 0;
}

function crypto_sign_open(m, sm, n, pk) {
  var i;
  var t = new Uint8Array(32), h = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()],
      q = [gf(), gf(), gf(), gf()];

  if (n < 64) return -1;

  if (unpackneg(q, pk)) return -1;

  for (i = 0; i < n; i++) m[i] = sm[i];
  for (i = 0; i < 32; i++) m[i+32] = pk[i];
  crypto_hash(h, m, n);
  reduce(h);
  scalarmult(p, q, h);

  scalarbase(q, sm.subarray(32));
  add(p, q);
  pack(t, p);

  n -= 64;
  if (crypto_verify_32(sm, 0, t, 0)) {
    for (i = 0; i < n; i++) m[i] = 0;
    return -1;
  }

  for (i = 0; i < n; i++) m[i] = sm[i + 64];
  return n;
}

var crypto_secretbox_KEYBYTES = 32,
    crypto_secretbox_NONCEBYTES = 24,
    crypto_secretbox_ZEROBYTES = 32,
    crypto_secretbox_BOXZEROBYTES = 16,
    crypto_scalarmult_BYTES = 32,
    crypto_scalarmult_SCALARBYTES = 32,
    crypto_box_PUBLICKEYBYTES = 32,
    crypto_box_SECRETKEYBYTES = 32,
    crypto_box_BEFORENMBYTES = 32,
    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
    crypto_sign_BYTES = 64,
    crypto_sign_PUBLICKEYBYTES = 32,
    crypto_sign_SECRETKEYBYTES = 64,
    crypto_sign_SEEDBYTES = 32,
    crypto_hash_BYTES = 64;

nacl.lowlevel = {
  crypto_core_hsalsa20: crypto_core_hsalsa20,
  crypto_stream_xor: crypto_stream_xor,
  crypto_stream: crypto_stream,
  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
  crypto_stream_salsa20: crypto_stream_salsa20,
  crypto_onetimeauth: crypto_onetimeauth,
  crypto_onetimeauth_verify: crypto_onetimeauth_verify,
  crypto_verify_16: crypto_verify_16,
  crypto_verify_32: crypto_verify_32,
  crypto_secretbox: crypto_secretbox,
  crypto_secretbox_open: crypto_secretbox_open,
  crypto_scalarmult: crypto_scalarmult,
  crypto_scalarmult_base: crypto_scalarmult_base,
  crypto_box_beforenm: crypto_box_beforenm,
  crypto_box_afternm: crypto_box_afternm,
  crypto_box: crypto_box,
  crypto_box_open: crypto_box_open,
  crypto_box_keypair: crypto_box_keypair,
  crypto_hash: crypto_hash,
  crypto_sign: crypto_sign,
  crypto_sign_keypair: crypto_sign_keypair,
  crypto_sign_open: crypto_sign_open,

  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
  crypto_sign_BYTES: crypto_sign_BYTES,
  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
  crypto_hash_BYTES: crypto_hash_BYTES,

  gf: gf,
  D: D,
  L: L,
  pack25519: pack25519,
  unpack25519: unpack25519,
  M: M,
  A: A,
  S: S,
  Z: Z,
  pow2523: pow2523,
  add: add,
  set25519: set25519,
  modL: modL,
  scalarmult: scalarmult,
  scalarbase: scalarbase,
};

/* High-level API */

function checkLengths(k, n) {
  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
}

function checkBoxLengths(pk, sk) {
  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
}

function checkArrayTypes() {
  for (var i = 0; i < arguments.length; i++) {
    if (!(arguments[i] instanceof Uint8Array))
      throw new TypeError('unexpected type, use Uint8Array');
  }
}

function cleanup(arr) {
  for (var i = 0; i < arr.length; i++) arr[i] = 0;
}

nacl.randomBytes = function(n) {
  var b = new Uint8Array(n);
  randombytes(b, n);
  return b;
};

nacl.secretbox = function(msg, nonce, key) {
  checkArrayTypes(msg, nonce, key);
  checkLengths(key, nonce);
  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
  var c = new Uint8Array(m.length);
  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
  crypto_secretbox(c, m, m.length, nonce, key);
  return c.subarray(crypto_secretbox_BOXZEROBYTES);
};

nacl.secretbox.open = function(box, nonce, key) {
  checkArrayTypes(box, nonce, key);
  checkLengths(key, nonce);
  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
  var m = new Uint8Array(c.length);
  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
  if (c.length < 32) return null;
  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
  return m.subarray(crypto_secretbox_ZEROBYTES);
};

nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

nacl.scalarMult = function(n, p) {
  checkArrayTypes(n, p);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult(q, n, p);
  return q;
};

nacl.scalarMult.base = function(n) {
  checkArrayTypes(n);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult_base(q, n);
  return q;
};

nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

nacl.box = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox(msg, nonce, k);
};

nacl.box.before = function(publicKey, secretKey) {
  checkArrayTypes(publicKey, secretKey);
  checkBoxLengths(publicKey, secretKey);
  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
  crypto_box_beforenm(k, publicKey, secretKey);
  return k;
};

nacl.box.after = nacl.secretbox;

nacl.box.open = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox.open(msg, nonce, k);
};

nacl.box.open.after = nacl.secretbox.open;

nacl.box.keyPair = function() {
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
  crypto_box_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.box.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_box_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  crypto_scalarmult_base(pk, secretKey);
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
nacl.box.nonceLength = crypto_box_NONCEBYTES;
nacl.box.overheadLength = nacl.secretbox.overheadLength;

nacl.sign = function(msg, secretKey) {
  checkArrayTypes(msg, secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
  crypto_sign(signedMsg, msg, msg.length, secretKey);
  return signedMsg;
};

nacl.sign.open = function(signedMsg, publicKey) {
  checkArrayTypes(signedMsg, publicKey);
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var tmp = new Uint8Array(signedMsg.length);
  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
  if (mlen < 0) return null;
  var m = new Uint8Array(mlen);
  for (var i = 0; i < m.length; i++) m[i] = tmp[i];
  return m;
};

nacl.sign.detached = function(msg, secretKey) {
  var signedMsg = nacl.sign(msg, secretKey);
  var sig = new Uint8Array(crypto_sign_BYTES);
  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
  return sig;
};

nacl.sign.detached.verify = function(msg, sig, publicKey) {
  checkArrayTypes(msg, sig, publicKey);
  if (sig.length !== crypto_sign_BYTES)
    throw new Error('bad signature size');
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
  var m = new Uint8Array(crypto_sign_BYTES + msg.length);
  var i;
  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
};

nacl.sign.keyPair = function() {
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  crypto_sign_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.sign.keyPair.fromSeed = function(seed) {
  checkArrayTypes(seed);
  if (seed.length !== crypto_sign_SEEDBYTES)
    throw new Error('bad seed size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  for (var i = 0; i < 32; i++) sk[i] = seed[i];
  crypto_sign_keypair(pk, sk, true);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
nacl.sign.seedLength = crypto_sign_SEEDBYTES;
nacl.sign.signatureLength = crypto_sign_BYTES;

nacl.hash = function(msg) {
  checkArrayTypes(msg);
  var h = new Uint8Array(crypto_hash_BYTES);
  crypto_hash(h, msg, msg.length);
  return h;
};

nacl.hash.hashLength = crypto_hash_BYTES;

nacl.verify = function(x, y) {
  checkArrayTypes(x, y);
  // Zero length arguments are considered not equal.
  if (x.length === 0 || y.length === 0) return false;
  if (x.length !== y.length) return false;
  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
};

nacl.setPRNG = function(fn) {
  randombytes = fn;
};

(function() {
  // Initialize PRNG if environment provides CSPRNG.
  // If not, methods calling randombytes will throw.
  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
  if (crypto && crypto.getRandomValues) {
    // Browsers.
    var QUOTA = 65536;
    nacl.setPRNG(function(x, n) {
      var i, v = new Uint8Array(n);
      for (i = 0; i < n; i += QUOTA) {
        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
      }
      for (i = 0; i < n; i++) x[i] = v[i];
      cleanup(v);
    });
  } else if (typeof require !== 'undefined') {
    // Node.js.
    crypto = require('crypto');
    if (crypto && crypto.randomBytes) {
      nacl.setPRNG(function(x, n) {
        var i, v = crypto.randomBytes(n);
        for (i = 0; i < n; i++) x[i] = v[i];
        cleanup(v);
      });
    }
  }
})();

})(typeof module !== 'undefined' && module.exports ? module.exports : (self.nacl = self.nacl || {}));

      };
    };
  }
}, {package:"tweetnacl",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\tweetnacl\\nacl-fast.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\index.js", {"assert":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\assert.js","bn.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\bn.js\\lib\\bn.js","create-hash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\create-hash\\browser.js","ethjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-sig-util\\node_modules\\ethjs-util\\lib\\index.js","keccak":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-sig-util\\node_modules\\keccak\\js.js","rlp":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\rlp\\dist.browser\\index.js","safe-buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\safe-buffer\\index.js","secp256k1":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-sig-util\\node_modules\\secp256k1\\elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-sig-util\node_modules\ethereumjs-util\dist\index.js
      return function (require, module, exports) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var createKeccakHash = require('keccak');
var secp256k1 = require('secp256k1');
var assert = require('assert');
var rlp = require('rlp');
var BN = require('bn.js');
var createHash = require('create-hash');
var Buffer = require('safe-buffer').Buffer;
Object.assign(exports, require('ethjs-util'));

/**
 * the max integer that this VM can handle (a ```BN```)
 * @var {BN} MAX_INTEGER
 */
exports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);

/**
 * 2^256 (a ```BN```)
 * @var {BN} TWO_POW256
 */
exports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);

/**
 * Keccak-256 hash of null (a ```String```)
 * @var {String} KECCAK256_NULL_S
 */
exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
exports.SHA3_NULL_S = exports.KECCAK256_NULL_S;

/**
 * Keccak-256 hash of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_NULL
 */
exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');
exports.SHA3_NULL = exports.KECCAK256_NULL;

/**
 * Keccak-256 of an RLP of an empty array (a ```String```)
 * @var {String} KECCAK256_RLP_ARRAY_S
 */
exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
exports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;

/**
 * Keccak-256 of an RLP of an empty array (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP_ARRAY
 */
exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
exports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;

/**
 * Keccak-256 hash of the RLP of null  (a ```String```)
 * @var {String} KECCAK256_RLP_S
 */
exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
exports.SHA3_RLP_S = exports.KECCAK256_RLP_S;

/**
 * Keccak-256 hash of the RLP of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP
 */
exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');
exports.SHA3_RLP = exports.KECCAK256_RLP;

/**
 * [`BN`](https://github.com/indutny/bn.js)
 * @var {Function}
 */
exports.BN = BN;

/**
 * [`rlp`](https://github.com/ethereumjs/rlp)
 * @var {Function}
 */
exports.rlp = rlp;

/**
 * [`secp256k1`](https://github.com/cryptocoinjs/secp256k1-node/)
 * @var {Object}
 */
exports.secp256k1 = secp256k1;

/**
 * Returns a buffer filled with 0s
 * @method zeros
 * @param {Number} bytes  the number of bytes the buffer should be
 * @return {Buffer}
 */
exports.zeros = function (bytes) {
  return Buffer.allocUnsafe(bytes).fill(0);
};

/**
  * Returns a zero address
  * @method zeroAddress
  * @return {String}
  */
exports.zeroAddress = function () {
  var addressLength = 20;
  var zeroAddress = exports.zeros(addressLength);
  return exports.bufferToHex(zeroAddress);
};

/**
 * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @method lsetLength
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @param {Boolean} [right=false] whether to start padding form the left or right
 * @return {Buffer|Array}
 */
exports.setLengthLeft = exports.setLength = function (msg, length, right) {
  var buf = exports.zeros(length);
  msg = exports.toBuffer(msg);
  if (right) {
    if (msg.length < length) {
      msg.copy(buf);
      return buf;
    }
    return msg.slice(0, length);
  } else {
    if (msg.length < length) {
      msg.copy(buf, length - msg.length);
      return buf;
    }
    return msg.slice(-length);
  }
};

/**
 * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @return {Buffer|Array}
 */
exports.setLengthRight = function (msg, length) {
  return exports.setLength(msg, length, true);
};

/**
 * Trims leading zeros from a `Buffer` or an `Array`
 * @param {Buffer|Array|String} a
 * @return {Buffer|Array|String}
 */
exports.unpad = exports.stripZeros = function (a) {
  a = exports.stripHexPrefix(a);
  var first = a[0];
  while (a.length > 0 && first.toString() === '0') {
    a = a.slice(1);
    first = a[0];
  }
  return a;
};
/**
 * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
 * @param {*} v the value
 */
exports.toBuffer = function (v) {
  if (!Buffer.isBuffer(v)) {
    if (Array.isArray(v)) {
      v = Buffer.from(v);
    } else if (typeof v === 'string') {
      if (exports.isHexString(v)) {
        v = Buffer.from(exports.padToEven(exports.stripHexPrefix(v)), 'hex');
      } else {
        v = Buffer.from(v);
      }
    } else if (typeof v === 'number') {
      v = exports.intToBuffer(v);
    } else if (v === null || v === undefined) {
      v = Buffer.allocUnsafe(0);
    } else if (BN.isBN(v)) {
      v = v.toArrayLike(Buffer);
    } else if (v.toArray) {
      // converts a BN to a Buffer
      v = Buffer.from(v.toArray());
    } else {
      throw new Error('invalid type');
    }
  }
  return v;
};

/**
 * Converts a `Buffer` to a `Number`
 * @param {Buffer} buf
 * @return {Number}
 * @throws If the input number exceeds 53 bits.
 */
exports.bufferToInt = function (buf) {
  return new BN(exports.toBuffer(buf)).toNumber();
};

/**
 * Converts a `Buffer` into a hex `String`
 * @param {Buffer} buf
 * @return {String}
 */
exports.bufferToHex = function (buf) {
  buf = exports.toBuffer(buf);
  return '0x' + buf.toString('hex');
};

/**
 * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
 * @param {Buffer} num
 * @return {BN}
 */
exports.fromSigned = function (num) {
  return new BN(num).fromTwos(256);
};

/**
 * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
 * @param {BN} num
 * @return {Buffer}
 */
exports.toUnsigned = function (num) {
  return Buffer.from(num.toTwos(256).toArray());
};

/**
 * Creates Keccak hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the Keccak width
 * @return {Buffer}
 */
exports.keccak = function (a, bits) {
  a = exports.toBuffer(a);
  if (!bits) bits = 256;

  return createKeccakHash('keccak' + bits).update(a).digest();
};

/**
 * Creates Keccak-256 hash of the input, alias for keccak(a, 256)
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.keccak256 = function (a) {
  return exports.keccak(a);
};

/**
 * Creates SHA-3 (Keccak) hash of the input [OBSOLETE]
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the SHA-3 width
 * @return {Buffer}
 */
exports.sha3 = exports.keccak;

/**
 * Creates SHA256 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.sha256 = function (a) {
  a = exports.toBuffer(a);
  return createHash('sha256').update(a).digest();
};

/**
 * Creates RIPEMD160 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Boolean} padded whether it should be padded to 256 bits or not
 * @return {Buffer}
 */
exports.ripemd160 = function (a, padded) {
  a = exports.toBuffer(a);
  var hash = createHash('rmd160').update(a).digest();
  if (padded === true) {
    return exports.setLength(hash, 32);
  } else {
    return hash;
  }
};

/**
 * Creates SHA-3 hash of the RLP encoded version of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.rlphash = function (a) {
  return exports.keccak(rlp.encode(a));
};

/**
 * Checks if the private key satisfies the rules of the curve secp256k1.
 * @param {Buffer} privateKey
 * @return {Boolean}
 */
exports.isValidPrivate = function (privateKey) {
  return secp256k1.privateKeyVerify(privateKey);
};

/**
 * Checks if the public key satisfies the rules of the curve secp256k1
 * and the requirements of Ethereum.
 * @param {Buffer} publicKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Boolean}
 */
exports.isValidPublic = function (publicKey, sanitize) {
  if (publicKey.length === 64) {
    // Convert to SEC1 for secp256k1
    return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));
  }

  if (!sanitize) {
    return false;
  }

  return secp256k1.publicKeyVerify(publicKey);
};

/**
 * Returns the ethereum address of a given public key.
 * Accepts "Ethereum public keys" and SEC1 encoded keys.
 * @param {Buffer} pubKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Buffer}
 */
exports.pubToAddress = exports.publicToAddress = function (pubKey, sanitize) {
  pubKey = exports.toBuffer(pubKey);
  if (sanitize && pubKey.length !== 64) {
    pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
  }
  assert(pubKey.length === 64);
  // Only take the lower 160bits of the hash
  return exports.keccak(pubKey).slice(-20);
};

/**
 * Returns the ethereum public key of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
var privateToPublic = exports.privateToPublic = function (privateKey) {
  privateKey = exports.toBuffer(privateKey);
  // skip the type flag and use the X, Y points
  return secp256k1.publicKeyCreate(privateKey, false).slice(1);
};

/**
 * Converts a public key to the Ethereum format.
 * @param {Buffer} publicKey
 * @return {Buffer}
 */
exports.importPublic = function (publicKey) {
  publicKey = exports.toBuffer(publicKey);
  if (publicKey.length !== 64) {
    publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
  }
  return publicKey;
};

/**
 * ECDSA sign
 * @param {Buffer} msgHash
 * @param {Buffer} privateKey
 * @return {Object}
 */
exports.ecsign = function (msgHash, privateKey) {
  var sig = secp256k1.sign(msgHash, privateKey);

  var ret = {};
  ret.r = sig.signature.slice(0, 32);
  ret.s = sig.signature.slice(32, 64);
  ret.v = sig.recovery + 27;
  return ret;
};

/**
 * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
 * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
 * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
 * used to produce the signature.
 * @param message
 * @returns {Buffer} hash
 */
exports.hashPersonalMessage = function (message) {
  var prefix = exports.toBuffer('\x19Ethereum Signed Message:\n' + message.length.toString());
  return exports.keccak(Buffer.concat([prefix, message]));
};

/**
 * ECDSA public key recovery from signature
 * @param {Buffer} msgHash
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {Buffer} publicKey
 */
exports.ecrecover = function (msgHash, v, r, s) {
  var signature = Buffer.concat([exports.setLength(r, 32), exports.setLength(s, 32)], 64);
  var recovery = v - 27;
  if (recovery !== 0 && recovery !== 1) {
    throw new Error('Invalid signature v value');
  }
  var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
  return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
};

/**
 * Convert signature parameters into the format of `eth_sign` RPC method
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {String} sig
 */
exports.toRpcSig = function (v, r, s) {
  // NOTE: with potential introduction of chainId this might need to be updated
  if (v !== 27 && v !== 28) {
    throw new Error('Invalid recovery id');
  }

  // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
  // FIXME: this might change in the future - https://github.com/ethereum/go-ethereum/issues/2053
  return exports.bufferToHex(Buffer.concat([exports.setLengthLeft(r, 32), exports.setLengthLeft(s, 32), exports.toBuffer(v - 27)]));
};

/**
 * Convert signature format of the `eth_sign` RPC method to signature parameters
 * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053
 * @param {String} sig
 * @return {Object}
 */
exports.fromRpcSig = function (sig) {
  sig = exports.toBuffer(sig);

  // NOTE: with potential introduction of chainId this might need to be updated
  if (sig.length !== 65) {
    throw new Error('Invalid signature length');
  }

  var v = sig[64];
  // support both versions of `eth_sign` responses
  if (v < 27) {
    v += 27;
  }

  return {
    v: v,
    r: sig.slice(0, 32),
    s: sig.slice(32, 64)
  };
};

/**
 * Returns the ethereum address of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
exports.privateToAddress = function (privateKey) {
  return exports.publicToAddress(privateToPublic(privateKey));
};

/**
 * Checks if the address is a valid. Accepts checksummed addresses too
 * @param {String} address
 * @return {Boolean}
 */
exports.isValidAddress = function (address) {
  return (/^0x[0-9a-fA-F]{40}$/.test(address)
  );
};

/**
  * Checks if a given address is a zero address
  * @method isZeroAddress
  * @param {String} address
  * @return {Boolean}
  */
exports.isZeroAddress = function (address) {
  var zeroAddress = exports.zeroAddress();
  return zeroAddress === exports.addHexPrefix(address);
};

/**
 * Returns a checksummed address
 * @param {String} address
 * @return {String}
 */
exports.toChecksumAddress = function (address) {
  address = exports.stripHexPrefix(address).toLowerCase();
  var hash = exports.keccak(address).toString('hex');
  var ret = '0x';

  for (var i = 0; i < address.length; i++) {
    if (parseInt(hash[i], 16) >= 8) {
      ret += address[i].toUpperCase();
    } else {
      ret += address[i];
    }
  }

  return ret;
};

/**
 * Checks if the address is a valid checksummed address
 * @param {Buffer} address
 * @return {Boolean}
 */
exports.isValidChecksumAddress = function (address) {
  return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;
};

/**
 * Generates an address of a newly created contract
 * @param {Buffer} from the address which is creating this new address
 * @param {Buffer} nonce the nonce of the from account
 * @return {Buffer}
 */
exports.generateAddress = function (from, nonce) {
  from = exports.toBuffer(from);
  nonce = new BN(nonce);

  if (nonce.isZero()) {
    // in RLP we want to encode null in the case of zero nonce
    // read the RLP documentation for an answer if you dare
    nonce = null;
  } else {
    nonce = Buffer.from(nonce.toArray());
  }

  // Only take the lower 160bits of the hash
  return exports.rlphash([from, nonce]).slice(-20);
};

/**
 * Returns true if the supplied address belongs to a precompiled account (Byzantium)
 * @param {Buffer|String} address
 * @return {Boolean}
 */
exports.isPrecompiled = function (address) {
  var a = exports.unpad(address);
  return a.length === 1 && a[0] >= 1 && a[0] <= 8;
};

/**
 * Adds "0x" to a given `String` if it does not already start with "0x"
 * @param {String} str
 * @return {String}
 */
exports.addHexPrefix = function (str) {
  if (typeof str !== 'string') {
    return str;
  }

  return exports.isHexPrefixed(str) ? str : '0x' + str;
};

/**
 * Validate ECDSA signature
 * @method isValidSignature
 * @param {Buffer} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @param {Boolean} [homestead=true]
 * @return {Boolean}
 */

exports.isValidSignature = function (v, r, s, homestead) {
  var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
  var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);

  if (r.length !== 32 || s.length !== 32) {
    return false;
  }

  if (v !== 27 && v !== 28) {
    return false;
  }

  r = new BN(r);
  s = new BN(s);

  if (r.isZero() || r.gt(SECP256K1_N) || s.isZero() || s.gt(SECP256K1_N)) {
    return false;
  }

  if (homestead === false && new BN(s).cmp(SECP256K1_N_DIV_2) === 1) {
    return false;
  }

  return true;
};

/**
 * Converts a `Buffer` or `Array` to JSON
 * @param {Buffer|Array} ba
 * @return {Array|String|null}
 */
exports.baToJSON = function (ba) {
  if (Buffer.isBuffer(ba)) {
    return '0x' + ba.toString('hex');
  } else if (ba instanceof Array) {
    var array = [];
    for (var i = 0; i < ba.length; i++) {
      array.push(exports.baToJSON(ba[i]));
    }
    return array;
  }
};

/**
 * Defines properties on a `Object`. It make the assumption that underlying data is binary.
 * @param {Object} self the `Object` to define properties on
 * @param {Array} fields an array fields to define. Fields can contain:
 * * `name` - the name of the properties
 * * `length` - the number of bytes the field can have
 * * `allowLess` - if the field can be less than the length
 * * `allowEmpty`
 * @param {*} data data to be validated against the definitions
 */
exports.defineProperties = function (self, fields, data) {
  self.raw = [];
  self._fields = [];

  // attach the `toJSON`
  self.toJSON = function (label) {
    if (label) {
      var obj = {};
      self._fields.forEach(function (field) {
        obj[field] = '0x' + self[field].toString('hex');
      });
      return obj;
    }
    return exports.baToJSON(this.raw);
  };

  self.serialize = function serialize() {
    return rlp.encode(self.raw);
  };

  fields.forEach(function (field, i) {
    self._fields.push(field.name);
    function getter() {
      return self.raw[i];
    }
    function setter(v) {
      v = exports.toBuffer(v);

      if (v.toString('hex') === '00' && !field.allowZero) {
        v = Buffer.allocUnsafe(0);
      }

      if (field.allowLess && field.length) {
        v = exports.stripZeros(v);
        assert(field.length >= v.length, 'The field ' + field.name + ' must not have more ' + field.length + ' bytes');
      } else if (!(field.allowZero && v.length === 0) && field.length) {
        assert(field.length === v.length, 'The field ' + field.name + ' must have byte length of ' + field.length);
      }

      self.raw[i] = v;
    }

    Object.defineProperty(self, field.name, {
      enumerable: true,
      configurable: true,
      get: getter,
      set: setter
    });

    if (field.default) {
      self[field.name] = field.default;
    }

    // attach alias
    if (field.alias) {
      Object.defineProperty(self, field.alias, {
        enumerable: false,
        configurable: true,
        set: setter,
        get: getter
      });
    }
  });

  // if the constuctor is passed data
  if (data) {
    if (typeof data === 'string') {
      data = Buffer.from(exports.stripHexPrefix(data), 'hex');
    }

    if (Buffer.isBuffer(data)) {
      data = rlp.decode(data);
    }

    if (Array.isArray(data)) {
      if (data.length > self._fields.length) {
        throw new Error('wrong number of fields in data');
      }

      // make sure all the items are buffers
      data.forEach(function (d, i) {
        self[self._fields[i]] = exports.toBuffer(d);
      });
    } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
      var keys = Object.keys(data);
      fields.forEach(function (field) {
        if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name];
        if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];
      });
    } else {
      throw new Error('invalid data');
    }
  }
};
      };
    };
  }
}, {package:"ethereumjs-util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\object-assign\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\object-assign\index.js
      return function (require, module, exports) {
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

      };
    };
  }
}, {package:"object-assign",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\object-assign\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\node_modules\\util\\util.js", {"./support/isBuffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\node_modules\\util\\support\\isBufferBrowser.js","_process":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\process\\browser.js","inherits":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\node_modules\\inherits\\inherits_browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\assert\node_modules\util\util.js
      return function (require, module, exports) {
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"util",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\assert\\node_modules\\util\\util.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\jsonschema\\lib\\scan.js", {"./helpers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\jsonschema\\lib\\helpers.js","url":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\url\\url.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\jsonschema\lib\scan.js
      return function (require, module, exports) {

var urilib = require('url');
var helpers = require('./helpers');

module.exports.SchemaScanResult = SchemaScanResult;
function SchemaScanResult(found, ref){
  this.id = found;
  this.ref = ref;
}

/**
 * Adds a schema with a certain urn to the Validator instance.
 * @param string uri
 * @param object schema
 * @return {Object}
 */
module.exports.scan = function scan(base, schema){
  function scanSchema(baseuri, schema){
    if(!schema || typeof schema!='object') return;
    // Mark all referenced schemas so we can tell later which schemas are referred to, but never defined
    if(schema.$ref){
      var resolvedUri = urilib.resolve(baseuri, schema.$ref);
      ref[resolvedUri] = ref[resolvedUri] ? ref[resolvedUri]+1 : 0;
      return;
    }
    var ourBase = schema.id ? urilib.resolve(baseuri, schema.id) : baseuri;
    if (ourBase) {
      // If there's no fragment, append an empty one
      if(ourBase.indexOf('#')<0) ourBase += '#';
      if(found[ourBase]){
        if(!helpers.deepCompareStrict(found[ourBase], schema)){
          throw new Error('Schema <'+schema+'> already exists with different definition');
        }
        return found[ourBase];
      }
      found[ourBase] = schema;
      // strip trailing fragment
      if(ourBase[ourBase.length-1]=='#'){
        found[ourBase.substring(0, ourBase.length-1)] = schema;
      }
    }
    scanArray(ourBase+'/items', ((schema.items instanceof Array)?schema.items:[schema.items]));
    scanArray(ourBase+'/extends', ((schema.extends instanceof Array)?schema.extends:[schema.extends]));
    scanSchema(ourBase+'/additionalItems', schema.additionalItems);
    scanObject(ourBase+'/properties', schema.properties);
    scanSchema(ourBase+'/additionalProperties', schema.additionalProperties);
    scanObject(ourBase+'/definitions', schema.definitions);
    scanObject(ourBase+'/patternProperties', schema.patternProperties);
    scanObject(ourBase+'/dependencies', schema.dependencies);
    scanArray(ourBase+'/disallow', schema.disallow);
    scanArray(ourBase+'/allOf', schema.allOf);
    scanArray(ourBase+'/anyOf', schema.anyOf);
    scanArray(ourBase+'/oneOf', schema.oneOf);
    scanSchema(ourBase+'/not', schema.not);
  }
  function scanArray(baseuri, schemas){
    if(!(schemas instanceof Array)) return;
    for(var i=0; i<schemas.length; i++){
      scanSchema(baseuri+'/'+i, schemas[i]);
    }
  }
  function scanObject(baseuri, schemas){
    if(!schemas || typeof schemas!='object') return;
    for(var p in schemas){
      scanSchema(baseuri+'/'+p, schemas[p]);
    }
  }

  var found = {};
  var ref = {};
  var schemaUri = base;
  scanSchema(base, schema);
  return new SchemaScanResult(found, ref);
}

      };
    };
  }
}, {package:"jsonschema",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\jsonschema\\lib\\scan.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\jsonschema\\lib\\validator.js", {"./attribute":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\jsonschema\\lib\\attribute.js","./helpers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\jsonschema\\lib\\helpers.js","./scan":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\jsonschema\\lib\\scan.js","url":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\url\\url.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\jsonschema\lib\validator.js
      return function (require, module, exports) {
'use strict';

var urilib = require('url');

var attribute = require('./attribute');
var helpers = require('./helpers');
var scanSchema = require('./scan').scan;
var ValidatorResult = helpers.ValidatorResult;
var SchemaError = helpers.SchemaError;
var SchemaContext = helpers.SchemaContext;
//var anonymousBase = 'vnd.jsonschema:///';
var anonymousBase = '/';

/**
 * Creates a new Validator object
 * @name Validator
 * @constructor
 */
var Validator = function Validator () {
  // Allow a validator instance to override global custom formats or to have their
  // own custom formats.
  this.customFormats = Object.create(Validator.prototype.customFormats);
  this.schemas = {};
  this.unresolvedRefs = [];

  // Use Object.create to make this extensible without Validator instances stepping on each other's toes.
  this.types = Object.create(types);
  this.attributes = Object.create(attribute.validators);
};

// Allow formats to be registered globally.
Validator.prototype.customFormats = {};

// Hint at the presence of a property
Validator.prototype.schemas = null;
Validator.prototype.types = null;
Validator.prototype.attributes = null;
Validator.prototype.unresolvedRefs = null;

/**
 * Adds a schema with a certain urn to the Validator instance.
 * @param schema
 * @param urn
 * @return {Object}
 */
Validator.prototype.addSchema = function addSchema (schema, base) {
  var self = this;
  if (!schema) {
    return null;
  }
  var scan = scanSchema(base||anonymousBase, schema);
  var ourUri = base || schema.id;
  for(var uri in scan.id){
    this.schemas[uri] = scan.id[uri];
  }
  for(var uri in scan.ref){
    this.unresolvedRefs.push(uri);
  }
  this.unresolvedRefs = this.unresolvedRefs.filter(function(uri){
    return typeof self.schemas[uri]==='undefined';
  });
  return this.schemas[ourUri];
};

Validator.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {
  if(!(schemas instanceof Array)) return;
  for(var i=0; i<schemas.length; i++){
    this.addSubSchema(baseuri, schemas[i]);
  }
};

Validator.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {
  if(!schemas || typeof schemas!='object') return;
  for(var p in schemas){
    this.addSubSchema(baseuri, schemas[p]);
  }
};



/**
 * Sets all the schemas of the Validator instance.
 * @param schemas
 */
Validator.prototype.setSchemas = function setSchemas (schemas) {
  this.schemas = schemas;
};

/**
 * Returns the schema of a certain urn
 * @param urn
 */
Validator.prototype.getSchema = function getSchema (urn) {
  return this.schemas[urn];
};

/**
 * Validates instance against the provided schema
 * @param instance
 * @param schema
 * @param [options]
 * @param [ctx]
 * @return {Array}
 */
Validator.prototype.validate = function validate (instance, schema, options, ctx) {
  if (!options) {
    options = {};
  }
  var propertyName = options.propertyName || 'instance';
  // This will work so long as the function at uri.resolve() will resolve a relative URI to a relative URI
  var base = urilib.resolve(options.base||anonymousBase, schema.id||'');
  if(!ctx){
    ctx = new SchemaContext(schema, options, propertyName, base, Object.create(this.schemas));
    if (!ctx.schemas[base]) {
      ctx.schemas[base] = schema;
    }
    var found = scanSchema(base, schema);
    for(var n in found.id){
      var sch = found.id[n];
      ctx.schemas[n] = sch;
    }
  }
  if (schema) {
    var result = this.validateSchema(instance, schema, options, ctx);
    if (!result) {
      throw new Error('Result undefined');
    }
    return result;
  }
  throw new SchemaError('no schema specified', schema);
};

/**
* @param Object schema
* @return mixed schema uri or false
*/
function shouldResolve(schema) {
  var ref = (typeof schema === 'string') ? schema : schema.$ref;
  if (typeof ref=='string') return ref;
  return false;
}

/**
 * Validates an instance against the schema (the actual work horse)
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @private
 * @return {ValidatorResult}
 */
Validator.prototype.validateSchema = function validateSchema (instance, schema, options, ctx) {
  var result = new ValidatorResult(instance, schema, options, ctx);

    // Support for the true/false schemas
  if(typeof schema==='boolean') {
    if(schema===true){
      // `true` is always valid
      schema = {};
    }else if(schema===false){
      // `false` is always invalid
      schema = {type: []};
    }
  }else if(!schema){
    // This might be a string
    throw new Error("schema is undefined");
  }

  if (schema['extends']) {
    if (schema['extends'] instanceof Array) {
      var schemaobj = {schema: schema, ctx: ctx};
      schema['extends'].forEach(this.schemaTraverser.bind(this, schemaobj));
      schema = schemaobj.schema;
      schemaobj.schema = null;
      schemaobj.ctx = null;
      schemaobj = null;
    } else {
      schema = helpers.deepMerge(schema, this.superResolve(schema['extends'], ctx));
    }
  }

  // If passed a string argument, load that schema URI
  var switchSchema;
  if (switchSchema = shouldResolve(schema)) {
    var resolved = this.resolve(schema, switchSchema, ctx);
    var subctx = new SchemaContext(resolved.subschema, options, ctx.propertyPath, resolved.switchSchema, ctx.schemas);
    return this.validateSchema(instance, resolved.subschema, options, subctx);
  }

  var skipAttributes = options && options.skipAttributes || [];
  // Validate each schema attribute against the instance
  for (var key in schema) {
    if (!attribute.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {
      var validatorErr = null;
      var validator = this.attributes[key];
      if (validator) {
        validatorErr = validator.call(this, instance, schema, options, ctx);
      } else if (options.allowUnknownAttributes === false) {
        // This represents an error with the schema itself, not an invalid instance
        throw new SchemaError("Unsupported attribute: " + key, schema);
      }
      if (validatorErr) {
        result.importErrors(validatorErr);
      }
    }
  }

  if (typeof options.rewrite == 'function') {
    var value = options.rewrite.call(this, instance, schema, options, ctx);
    result.instance = value;
  }
  return result;
};

/**
* @private
* @param Object schema
* @param SchemaContext ctx
* @returns Object schema or resolved schema
*/
Validator.prototype.schemaTraverser = function schemaTraverser (schemaobj, s) {
  schemaobj.schema = helpers.deepMerge(schemaobj.schema, this.superResolve(s, schemaobj.ctx));
}

/**
* @private
* @param Object schema
* @param SchemaContext ctx
* @returns Object schema or resolved schema
*/
Validator.prototype.superResolve = function superResolve (schema, ctx) {
  var ref;
  if(ref = shouldResolve(schema)) {
    return this.resolve(schema, ref, ctx).subschema;
  }
  return schema;
}

/**
* @private
* @param Object schema
* @param Object switchSchema
* @param SchemaContext ctx
* @return Object resolved schemas {subschema:String, switchSchema: String}
* @throws SchemaError
*/
Validator.prototype.resolve = function resolve (schema, switchSchema, ctx) {
  switchSchema = ctx.resolve(switchSchema);
  // First see if the schema exists under the provided URI
  if (ctx.schemas[switchSchema]) {
    return {subschema: ctx.schemas[switchSchema], switchSchema: switchSchema};
  }
  // Else try walking the property pointer
  var parsed = urilib.parse(switchSchema);
  var fragment = parsed && parsed.hash;
  var document = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);
  if (!document || !ctx.schemas[document]) {
    throw new SchemaError("no such schema <" + switchSchema + ">", schema);
  }
  var subschema = helpers.objectGetPath(ctx.schemas[document], fragment.substr(1));
  if(subschema===undefined){
    throw new SchemaError("no such schema " + fragment + " located in <" + document + ">", schema);
  }
  return {subschema: subschema, switchSchema: switchSchema};
};

/**
 * Tests whether the instance if of a certain type.
 * @private
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @param type
 * @return {boolean}
 */
Validator.prototype.testType = function validateType (instance, schema, options, ctx, type) {
  if (typeof this.types[type] == 'function') {
    return this.types[type].call(this, instance);
  }
  if (type && typeof type == 'object') {
    var res = this.validateSchema(instance, type, options, ctx);
    return res === undefined || !(res && res.errors.length);
  }
  // Undefined or properties not on the list are acceptable, same as not being defined
  return true;
};

var types = Validator.prototype.types = {};
types.string = function testString (instance) {
  return typeof instance == 'string';
};
types.number = function testNumber (instance) {
  // isFinite returns false for NaN, Infinity, and -Infinity
  return typeof instance == 'number' && isFinite(instance);
};
types.integer = function testInteger (instance) {
  return (typeof instance == 'number') && instance % 1 === 0;
};
types.boolean = function testBoolean (instance) {
  return typeof instance == 'boolean';
};
types.array = function testArray (instance) {
  return Array.isArray(instance);
};
types['null'] = function testNull (instance) {
  return instance === null;
};
types.date = function testDate (instance) {
  return instance instanceof Date;
};
types.any = function testAny (instance) {
  return true;
};
types.object = function testObject (instance) {
  // TODO: fix this - see #15
  return instance && (typeof instance) === 'object' && !(instance instanceof Array) && !(instance instanceof Date);
};

module.exports = Validator;

      };
    };
  }
}, {package:"jsonschema",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\jsonschema\\lib\\validator.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\jsonschema\\lib\\helpers.js", {"url":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\url\\url.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\jsonschema\lib\helpers.js
      return function (require, module, exports) {
'use strict';

var uri = require('url');

var ValidationError = exports.ValidationError = function ValidationError (message, instance, schema, propertyPath, name, argument) {
  if (propertyPath) {
    this.property = propertyPath;
  }
  if (message) {
    this.message = message;
  }
  if (schema) {
    if (schema.id) {
      this.schema = schema.id;
    } else {
      this.schema = schema;
    }
  }
  if (instance) {
    this.instance = instance;
  }
  this.name = name;
  this.argument = argument;
  this.stack = this.toString();
};

ValidationError.prototype.toString = function toString() {
  return this.property + ' ' + this.message;
};

var ValidatorResult = exports.ValidatorResult = function ValidatorResult(instance, schema, options, ctx) {
  this.instance = instance;
  this.schema = schema;
  this.propertyPath = ctx.propertyPath;
  this.errors = [];
  this.throwError = options && options.throwError;
  this.disableFormat = options && options.disableFormat === true;
};

ValidatorResult.prototype.addError = function addError(detail) {
  var err;
  if (typeof detail == 'string') {
    err = new ValidationError(detail, this.instance, this.schema, this.propertyPath);
  } else {
    if (!detail) throw new Error('Missing error detail');
    if (!detail.message) throw new Error('Missing error message');
    if (!detail.name) throw new Error('Missing validator type');
    err = new ValidationError(detail.message, this.instance, this.schema, this.propertyPath, detail.name, detail.argument);
  }

  if (this.throwError) {
    throw err;
  }
  this.errors.push(err);
  return err;
};

ValidatorResult.prototype.importErrors = function importErrors(res) {
  if (typeof res == 'string' || (res && res.validatorType)) {
    this.addError(res);
  } else if (res && res.errors) {
    Array.prototype.push.apply(this.errors, res.errors);
  }
};

function stringizer (v,i){
  return i+': '+v.toString()+'\n';
}
ValidatorResult.prototype.toString = function toString(res) {
  return this.errors.map(stringizer).join('');
};

Object.defineProperty(ValidatorResult.prototype, "valid", { get: function() {
  return !this.errors.length;
} });

/**
 * Describes a problem with a Schema which prevents validation of an instance
 * @name SchemaError
 * @constructor
 */
var SchemaError = exports.SchemaError = function SchemaError (msg, schema) {
  this.message = msg;
  this.schema = schema;
  Error.call(this, msg);
  Error.captureStackTrace(this, SchemaError);
};
SchemaError.prototype = Object.create(Error.prototype,
  { constructor: {value: SchemaError, enumerable: false}
  , name: {value: 'SchemaError', enumerable: false}
  });

var SchemaContext = exports.SchemaContext = function SchemaContext (schema, options, propertyPath, base, schemas) {
  this.schema = schema;
  this.options = options;
  this.propertyPath = propertyPath;
  this.base = base;
  this.schemas = schemas;
};

SchemaContext.prototype.resolve = function resolve (target) {
  return uri.resolve(this.base, target);
};

SchemaContext.prototype.makeChild = function makeChild(schema, propertyName){
  var propertyPath = (propertyName===undefined) ? this.propertyPath : this.propertyPath+makeSuffix(propertyName);
  var base = uri.resolve(this.base, schema.id||'');
  var ctx = new SchemaContext(schema, this.options, propertyPath, base, Object.create(this.schemas));
  if(schema.id && !ctx.schemas[base]){
    ctx.schemas[base] = schema;
  }
  return ctx;
}

var FORMAT_REGEXPS = exports.FORMAT_REGEXPS = {
  'date-time': /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])[tT ](2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])(\.\d+)?([zZ]|[+-]([0-5][0-9]):(60|[0-5][0-9]))$/,
  'date': /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])$/,
  'time': /^(2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])$/,

  'email': /^(?:[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+\.)*[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!\.)){0,61}[a-zA-Z0-9]?\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\[(?:(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\]))$/,
  'ip-address': /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,
  'ipv6': /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/,
  'uri': /^[a-zA-Z][a-zA-Z0-9+-.]*:[^\s]*$/,

  'color': /^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/,

  // hostname regex from: http://stackoverflow.com/a/1420225/5628
  'hostname': /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$/,
  'host-name': /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$/,

  'alpha': /^[a-zA-Z]+$/,
  'alphanumeric': /^[a-zA-Z0-9]+$/,
  'utc-millisec': function (input) {
    return (typeof input === 'string') && parseFloat(input) === parseInt(input, 10) && !isNaN(input);
  },
  'regex': function (input) {
    var result = true;
    try {
      new RegExp(input);
    } catch (e) {
      result = false;
    }
    return result;
  },
  'style': /\s*(.+?):\s*([^;]+);?/g,
  'phone': /^\+(?:[0-9] ?){6,14}[0-9]$/
};

FORMAT_REGEXPS.regexp = FORMAT_REGEXPS.regex;
FORMAT_REGEXPS.pattern = FORMAT_REGEXPS.regex;
FORMAT_REGEXPS.ipv4 = FORMAT_REGEXPS['ip-address'];

exports.isFormat = function isFormat (input, format, validator) {
  if (typeof input === 'string' && FORMAT_REGEXPS[format] !== undefined) {
    if (FORMAT_REGEXPS[format] instanceof RegExp) {
      return FORMAT_REGEXPS[format].test(input);
    }
    if (typeof FORMAT_REGEXPS[format] === 'function') {
      return FORMAT_REGEXPS[format](input);
    }
  } else if (validator && validator.customFormats &&
      typeof validator.customFormats[format] === 'function') {
    return validator.customFormats[format](input);
  }
  return true;
};

var makeSuffix = exports.makeSuffix = function makeSuffix (key) {
  key = key.toString();
  // This function could be capable of outputting valid a ECMAScript string, but the
  // resulting code for testing which form to use would be tens of thousands of characters long
  // That means this will use the name form for some illegal forms
  if (!key.match(/[.\s\[\]]/) && !key.match(/^[\d]/)) {
    return '.' + key;
  }
  if (key.match(/^\d+$/)) {
    return '[' + key + ']';
  }
  return '[' + JSON.stringify(key) + ']';
};

exports.deepCompareStrict = function deepCompareStrict (a, b) {
  if (typeof a !== typeof b) {
    return false;
  }
  if (a instanceof Array) {
    if (!(b instanceof Array)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    return a.every(function (v, i) {
      return deepCompareStrict(a[i], b[i]);
    });
  }
  if (typeof a === 'object') {
    if (!a || !b) {
      return a === b;
    }
    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    return aKeys.every(function (v) {
      return deepCompareStrict(a[v], b[v]);
    });
  }
  return a === b;
};

function deepMerger (target, dst, e, i) {
  if (typeof e === 'object') {
    dst[i] = deepMerge(target[i], e)
  } else {
    if (target.indexOf(e) === -1) {
      dst.push(e)
    }
  }
}

function copyist (src, dst, key) {
  dst[key] = src[key];
}

function copyistWithDeepMerge (target, src, dst, key) {
  if (typeof src[key] !== 'object' || !src[key]) {
    dst[key] = src[key];
  }
  else {
    if (!target[key]) {
      dst[key] = src[key];
    } else {
      dst[key] = deepMerge(target[key], src[key])
    }
  }
}

function deepMerge (target, src) {
  var array = Array.isArray(src);
  var dst = array && [] || {};

  if (array) {
    target = target || [];
    dst = dst.concat(target);
    src.forEach(deepMerger.bind(null, target, dst));
  } else {
    if (target && typeof target === 'object') {
      Object.keys(target).forEach(copyist.bind(null, target, dst));
    }
    Object.keys(src).forEach(copyistWithDeepMerge.bind(null, target, src, dst));
  }

  return dst;
};

module.exports.deepMerge = deepMerge;

/**
 * Validates instance against the provided schema
 * Implements URI+JSON Pointer encoding, e.g. "%7e"="~0"=>"~", "~1"="%2f"=>"/"
 * @param o
 * @param s The path to walk o along
 * @return any
 */
exports.objectGetPath = function objectGetPath(o, s) {
  var parts = s.split('/').slice(1);
  var k;
  while (typeof (k=parts.shift()) == 'string') {
    var n = decodeURIComponent(k.replace(/~0/,'~').replace(/~1/g,'/'));
    if (!(n in o)) return;
    o = o[n];
  }
  return o;
};

function pathEncoder (v) {
  return '/'+encodeURIComponent(v).replace(/~/g,'%7E');
}
/**
 * Accept an Array of property names and return a JSON Pointer URI fragment
 * @param Array a
 * @return {String}
 */
exports.encodePath = function encodePointer(a){
	// ~ must be encoded explicitly because hacks
	// the slash is encoded by encodeURIComponent
	return a.map(pathEncoder).join('');
};


/**
 * Calculate the number of decimal places a number uses
 * We need this to get correct results out of multipleOf and divisibleBy
 * when either figure is has decimal places, due to IEEE-754 float issues.
 * @param number
 * @returns {number}
 */
exports.getDecimalPlaces = function getDecimalPlaces(number) {

  var decimalPlaces = 0;
  if (isNaN(number)) return decimalPlaces;

  if (typeof number !== 'number') {
    number = Number(number);
  }

  var parts = number.toString().split('e');
  if (parts.length === 2) {
    if (parts[1][0] !== '-') {
      return decimalPlaces;
    } else {
      decimalPlaces = Number(parts[1].slice(1));
    }
  }

  var decimalParts = parts[0].split('.');
  if (decimalParts.length === 2) {
    decimalPlaces += decimalParts[1].length;
  }

  return decimalPlaces;
};


      };
    };
  }
}, {package:"jsonschema",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\jsonschema\\lib\\helpers.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethers\\lib\\ethers.js", {"./_version":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethers\\lib\\_version.js","./utils":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethers\\lib\\utils.js","@ethersproject/abstract-signer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethersproject\\abstract-signer\\lib\\index.js","@ethersproject/bignumber":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethersproject\\bignumber\\lib\\index.js","@ethersproject/constants":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethersproject\\constants\\lib\\index.js","@ethersproject/contracts":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethersproject\\contracts\\lib\\index.js","@ethersproject/logger":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethersproject\\logger\\lib\\index.js","@ethersproject/providers":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethersproject\\providers\\lib\\index.js","@ethersproject/wallet":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethersproject\\wallet\\lib\\index.js","@ethersproject/wordlists":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@ethersproject\\wordlists\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethers\lib\ethers.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Wordlist = exports.version = exports.wordlists = exports.utils = exports.logger = exports.errors = exports.constants = exports.FixedNumber = exports.BigNumber = exports.ContractFactory = exports.Contract = exports.BaseContract = exports.providers = exports.getDefaultProvider = exports.VoidSigner = exports.Wallet = exports.Signer = void 0;
var contracts_1 = require("@ethersproject/contracts");
Object.defineProperty(exports, "BaseContract", { enumerable: true, get: function () { return contracts_1.BaseContract; } });
Object.defineProperty(exports, "Contract", { enumerable: true, get: function () { return contracts_1.Contract; } });
Object.defineProperty(exports, "ContractFactory", { enumerable: true, get: function () { return contracts_1.ContractFactory; } });
var bignumber_1 = require("@ethersproject/bignumber");
Object.defineProperty(exports, "BigNumber", { enumerable: true, get: function () { return bignumber_1.BigNumber; } });
Object.defineProperty(exports, "FixedNumber", { enumerable: true, get: function () { return bignumber_1.FixedNumber; } });
var abstract_signer_1 = require("@ethersproject/abstract-signer");
Object.defineProperty(exports, "Signer", { enumerable: true, get: function () { return abstract_signer_1.Signer; } });
Object.defineProperty(exports, "VoidSigner", { enumerable: true, get: function () { return abstract_signer_1.VoidSigner; } });
var wallet_1 = require("@ethersproject/wallet");
Object.defineProperty(exports, "Wallet", { enumerable: true, get: function () { return wallet_1.Wallet; } });
var constants = __importStar(require("@ethersproject/constants"));
exports.constants = constants;
var providers = __importStar(require("@ethersproject/providers"));
exports.providers = providers;
var providers_1 = require("@ethersproject/providers");
Object.defineProperty(exports, "getDefaultProvider", { enumerable: true, get: function () { return providers_1.getDefaultProvider; } });
var wordlists_1 = require("@ethersproject/wordlists");
Object.defineProperty(exports, "Wordlist", { enumerable: true, get: function () { return wordlists_1.Wordlist; } });
Object.defineProperty(exports, "wordlists", { enumerable: true, get: function () { return wordlists_1.wordlists; } });
var utils = __importStar(require("./utils"));
exports.utils = utils;
var logger_1 = require("@ethersproject/logger");
Object.defineProperty(exports, "errors", { enumerable: true, get: function () { return logger_1.ErrorCode; } });
////////////////////////
// Compile-Time Constants
// This is generated by "npm run dist"
var _version_1 = require("./_version");
Object.defineProperty(exports, "version", { enumerable: true, get: function () { return _version_1.version; } });
var logger = new logger_1.Logger(_version_1.version);
exports.logger = logger;
//# sourceMappingURL=ethers.js.map
      };
    };
  }
}, {package:"ethers",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethers\\lib\\ethers.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-method-registry\\dist\\registry-map.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-method-registry\dist\registry-map.json
      return function (require, module, exports) {
module.exports={
    "1": "0x44691B39d1a75dC4E0A0346CBB15E310e6ED1E86"
}

      };
    };
  }
}, {package:"eth-method-registry",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-method-registry\\dist\\registry-map.json",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-method-registry\\dist\\abi.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\eth-method-registry\dist\abi.json
      return function (require, module, exports) {
module.exports=[{ "constant": false, "inputs": [{ "name": "_new", "type": "address" }], "name": "setOwner", "outputs": [], "payable": false, "type": "function" }, { "constant": true, "inputs": [], "name": "totalSignatures", "outputs": [{ "name": "", "type": "uint256" }], "payable": false, "type": "function" }, { "constant": true, "inputs": [], "name": "owner", "outputs": [{ "name": "", "type": "address" }], "payable": false, "type": "function" }, { "constant": false, "inputs": [], "name": "drain", "outputs": [], "payable": false, "type": "function" }, { "constant": true, "inputs": [{ "name": "", "type": "bytes4" }], "name": "entries", "outputs": [{ "name": "", "type": "string" }], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "_method", "type": "string" }], "name": "register", "outputs": [{ "name": "", "type": "bool" }], "payable": false, "type": "function" }, { "inputs": [], "type": "constructor" }, { "anonymous": false, "inputs": [{ "indexed": true, "name": "creator", "type": "address" }, { "indexed": true, "name": "signature", "type": "bytes4" }, { "indexed": false, "name": "method", "type": "string" }], "name": "Registered", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "name": "old", "type": "address" }, { "indexed": true, "name": "current", "type": "address" }], "name": "NewOwner", "type": "event" }]

      };
    };
  }
}, {package:"eth-method-registry",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\eth-method-registry\\dist\\abi.json",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs\\lib\\index.js", {"./lib/getTransactionSuccess.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs\\lib\\lib\\getTransactionSuccess.js","bn.js":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs\\node_modules\\bn.js\\lib\\bn.js","buffer":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethjs-abi":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs\\node_modules\\ethjs-abi\\lib\\index.js","ethjs-contract":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-contract\\lib\\index.js","ethjs-filter":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-filter\\lib\\index.js","ethjs-provider-http":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-provider-http\\lib\\index.js","ethjs-query":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-query\\lib\\index.js","ethjs-unit":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-unit\\lib\\index.js","ethjs-util":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-util\\lib\\index.js","js-sha3":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs\\node_modules\\js-sha3\\src\\sha3.js","number-to-bn":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\number-to-bn\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethjs\lib\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var EthQuery = require('ethjs-query');
var EthFilter = require('ethjs-filter');
var EthContract = require('ethjs-contract');
var HttpProvider = require('ethjs-provider-http');
var abi = require('ethjs-abi');
// const getTxSuccess = require('ethjs-transaction-success'); // eslint-disable-line
var unit = require('ethjs-unit');
var keccak256 = require('js-sha3').keccak_256;
var toBN = require('number-to-bn');
var BN = require('bn.js');
var utils = require('ethjs-util');
var getTransactionSuccess = require('./lib/getTransactionSuccess.js');

module.exports = Eth;

/**
 * Returns the ethjs Eth instance.
 *
 * @method Eth
 * @param {Object} cprovider the web3 standard provider object
 * @param {Object} options the Eth options object
 * @returns {Object} eth Eth object instance
 * @throws if the new flag is not used in construction
 */

function Eth(cprovider, options) {
  if (!(this instanceof Eth)) {
    throw new Error('[ethjs] the Eth object requires you construct it with the "new" flag (i.e. `const eth = new Eth(...);`).');
  }
  var self = this;
  self.options = options || {};
  var query = new EthQuery(cprovider, self.options.query);
  Object.keys(Object.getPrototypeOf(query)).forEach(function (methodName) {
    self[methodName] = function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return query[methodName].apply(query, args);
    };
  });
  self.filter = new EthFilter(query, self.options.query);
  self.contract = new EthContract(query, self.options.query);
  self.currentProvider = query.rpc.currentProvider;
  self.setProvider = query.setProvider;
  self.getTransactionSuccess = getTransactionSuccess(self);
}

Eth.BN = BN;
Eth.isAddress = function (val) {
  return utils.isHexString(val, 20);
};
Eth.keccak256 = function (val) {
  return '0x' + keccak256(val);
};
Eth.Buffer = Buffer;
Eth.isHexString = utils.isHexString;
Eth.fromWei = unit.fromWei;
Eth.toWei = unit.toWei;
Eth.toBN = toBN;
Eth.abi = abi;
Eth.fromAscii = utils.fromAscii;
Eth.toAscii = utils.toAscii;
Eth.fromUtf8 = utils.fromUtf8;
Eth.toUtf8 = utils.toUtf8;
Eth.HttpProvider = HttpProvider;
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethjs",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs\\lib\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\utils\\storage-helpers.js", {"@babel/runtime/helpers/interopRequireDefault":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js","localforage":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\localforage\\dist\\localforage.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\ui\helpers\utils\storage-helpers.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getStorageItem = getStorageItem;
exports.setStorageItem = setStorageItem;

var _localforage = _interopRequireDefault(require("localforage"));

async function getStorageItem(key) {
  try {
    const serializedData = await _localforage.default.getItem(key);

    if (serializedData === null) {
      return undefined;
    }

    return JSON.parse(serializedData);
  } catch (err) {
    return undefined;
  }
}

async function setStorageItem(key, value) {
  try {
    const serializedData = JSON.stringify(value);
    await _localforage.default.setItem(key, serializedData);
  } catch (err) {
    console.warn(err);
  }
}

      };
    };
  }
}, {package:"<root>",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\ui\\helpers\\utils\\storage-helpers.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-ens\\index.js", {"./abis/registry.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-ens\\abis\\registry.json","./abis/resolver.json":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-ens\\abis\\resolver.json","eth-ens-namehash":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-ens\\node_modules\\eth-ens-namehash\\index.js","ethereum-ens-network-map":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereum-ens-network-map\\index.js","ethjs-contract":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-ens\\node_modules\\ethjs-contract\\lib\\index.js","ethjs-query":"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-ens\\node_modules\\ethjs-query\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethjs-ens\index.js
      return function (require, module, exports) {
// External Deps
const Eth = require('ethjs-query')
const EthContract = require('ethjs-contract')
const namehash = require('eth-ens-namehash')

// ABIs
const registryAbi = require('./abis/registry.json')
const resolverAbi = require('./abis/resolver.json')

// Map network to known ENS registries
const networkMap = require('ethereum-ens-network-map')
const emptyHash = '0x0000000000000000000000000000000000000000000000000000000000000000'
const emptyAddr = '0x0000000000000000000000000000000000000000'

const NotFoundError = new Error('ENS name not defined.')
const BadCharacterError = new Error('Illegal Character for ENS.')

class Ens {

  constructor (opts = {}) {
    const { provider, network } = opts
    let { registryAddress } = opts

    // Validations
    if (!provider) {
      throw new Error('The EthJsENS Constructor requires a provider.')
    }

    // Requires EITHER a network or a registryAddress
    if (!network && !registryAddress) {
      throw new Error('The EthJsENS Constructor requires a network or registry address.')
    }

    this.provider = provider
    this.eth = new Eth(this.provider)
    this.contract = new EthContract(this.eth)
    this.namehash = namehash

    // Link to Registry
    this.Registry = this.contract(registryAbi)
    if (!registryAddress && network) {
      registryAddress = networkMap[network]
    }
    this.registry = this.Registry.at(registryAddress)

    // Create Resolver class
    this.Resolver = this.contract(resolverAbi)
  }

  lookup (name = '') {
    return this.getNamehash(name)
    .then((node) => {
      if (node === emptyHash) {
        return Promise.reject(NotFoundError)
      }
      return this.resolveAddressForNode(node)
    })
  }

  getNamehash (name) {
    try {
      return Promise.resolve(namehash(name))
    } catch (e) {
      return Promise.reject(BadCharacterError)
    }
  }

  getOwner (name = '') {
    return this.getNamehash(name)
    .then(node => this.getOwnerForNode(node))
  }

  getOwnerForNode (node) {
    if (node === emptyHash) {
      return Promise.reject(NotFoundError)
    }
    return this.registry.owner(node)
    .then((result) => {
      const ownerAddress = result[0]
      if (ownerAddress === emptyAddr) {
        throw NotFoundError
      }

      return ownerAddress
    })
  }

  getResolver (name = '') {
    return this.getNamehash(name)
    .then(node => this.getResolverForNode(node))
  }

  getResolverAddress (name = '') {
    return this.getNamehash(name)
    .then(node => this.getResolverAddressForNode(node))
  }

  getResolverForNode (node) {
    if (!node.startsWith('0x')) {
      node = `0x${node}`
    }

    return this.getResolverAddressForNode(node)
    .then((resolverAddress) => {
      return this.Resolver.at(resolverAddress)
    })
  }

  getResolverAddressForNode (node) {
    return this.registry.resolver(node)
    .then((result) => {
      const resolverAddress = result[0]
      if (resolverAddress === emptyAddr) {
        throw NotFoundError
      }
      return resolverAddress
    })
  }

  resolveAddressForNode (node) {
    return this.getResolverForNode(node)
    .then((resolver) => {
      return resolver.addr(node)
    })
    .then(result => result[0])
  }

  reverse (address) {
    if (!address) {
      return Promise.reject(new Error('Must supply an address to reverse lookup.'))
    }

    if (address.startsWith('0x')) {
      address = address.slice(2)
    }

    const name = `${address.toLowerCase()}.addr.reverse`
    const node = namehash(name)
    return this.getNamehash(name)
    .then(node => this.getResolverForNode(node))
    .then(resolver => resolver.name(node))
    .then(results => results[0])
  }

}

module.exports = Ens

      };
    };
  }
}, {package:"ethjs-ens",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethjs-ens\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereum-ens-network-map\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\ethereum-ens-network-map\index.js
      return function (require, module, exports) {
module.exports = {
  // Mainnet
  '1': '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
  // Ropsten
  '3': '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
  // Rinkeby
  '4': '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
  // Goerli
  '5': '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
}

      };
    };
  }
}, {package:"ethereum-ens-network-map",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\ethereum-ens-network-map\\index.js",}],
["D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\reselect\\lib\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: D:\Building_Projects\blockchain\metamaskextension\metamask-extension-latest\node_modules\reselect\lib\index.js
      return function (require, module, exports) {
'use strict';

exports.__esModule = true;
exports.defaultMemoize = defaultMemoize;
exports.createSelectorCreator = createSelectorCreator;
exports.createStructuredSelector = createStructuredSelector;
function defaultEqualityCheck(a, b) {
  return a === b;
}

function areArgumentsShallowlyEqual(equalityCheck, prev, next) {
  if (prev === null || next === null || prev.length !== next.length) {
    return false;
  }

  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.
  var length = prev.length;
  for (var i = 0; i < length; i++) {
    if (!equalityCheck(prev[i], next[i])) {
      return false;
    }
  }

  return true;
}

function defaultMemoize(func) {
  var equalityCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultEqualityCheck;

  var lastArgs = null;
  var lastResult = null;
  // we reference arguments instead of spreading them for performance reasons
  return function () {
    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {
      // apply arguments instead of spreading for performance.
      lastResult = func.apply(null, arguments);
    }

    lastArgs = arguments;
    return lastResult;
  };
}

function getDependencies(funcs) {
  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;

  if (!dependencies.every(function (dep) {
    return typeof dep === 'function';
  })) {
    var dependencyTypes = dependencies.map(function (dep) {
      return typeof dep;
    }).join(', ');
    throw new Error('Selector creators expect all input-selectors to be functions, ' + ('instead received the following types: [' + dependencyTypes + ']'));
  }

  return dependencies;
}

function createSelectorCreator(memoize) {
  for (var _len = arguments.length, memoizeOptions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    memoizeOptions[_key - 1] = arguments[_key];
  }

  return function () {
    for (var _len2 = arguments.length, funcs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      funcs[_key2] = arguments[_key2];
    }

    var recomputations = 0;
    var resultFunc = funcs.pop();
    var dependencies = getDependencies(funcs);

    var memoizedResultFunc = memoize.apply(undefined, [function () {
      recomputations++;
      // apply arguments instead of spreading for performance.
      return resultFunc.apply(null, arguments);
    }].concat(memoizeOptions));

    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.
    var selector = defaultMemoize(function () {
      var params = [];
      var length = dependencies.length;

      for (var i = 0; i < length; i++) {
        // apply arguments instead of spreading and mutate a local list of params for performance.
        params.push(dependencies[i].apply(null, arguments));
      }

      // apply arguments instead of spreading for performance.
      return memoizedResultFunc.apply(null, params);
    });

    selector.resultFunc = resultFunc;
    selector.recomputations = function () {
      return recomputations;
    };
    selector.resetRecomputations = function () {
      return recomputations = 0;
    };
    return selector;
  };
}

var createSelector = exports.createSelector = createSelectorCreator(defaultMemoize);

function createStructuredSelector(selectors) {
  var selectorCreator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createSelector;

  if (typeof selectors !== 'object') {
    throw new Error('createStructuredSelector expects first argument to be an object ' + ('where each property is a selector, instead received a ' + typeof selectors));
  }
  var objectKeys = Object.keys(selectors);
  return selectorCreator(objectKeys.map(function (key) {
    return selectors[key];
  }), function () {
    for (var _len3 = arguments.length, values = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      values[_key3] = arguments[_key3];
    }

    return values.reduce(function (composition, value, index) {
      composition[objectKeys[index]] = value;
      return composition;
    }, {});
  });
}
      };
    };
  }
}, {package:"reselect",file:"D:\\Building_Projects\\blockchain\\metamaskextension\\metamask-extension-latest\\node_modules\\reselect\\lib\\index.js",}]],[],{})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9sdXhvbi9idWlsZC9janMtYnJvd3Nlci9sdXhvbi5qcyIsIm5vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc2xpcDQ0L3NsaXA0NC5qc29uIiwic2hhcmVkL2NvbnN0YW50cy9hbGVydHMuanMiLCJub2RlX21vZHVsZXMvcHVibnViL2Rpc3Qvd2ViL3B1Ym51Yi5taW4uanMiLCJub2RlX21vZHVsZXMvd2ViMy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaW5nbGUtY2FsbC1iYWxhbmNlLWNoZWNrZXItYWJpL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V0aC1zaWctdXRpbC9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Fzc2VydC9hc3NlcnQuanMiLCJub2RlX21vZHVsZXMvanNvbnNjaGVtYS9saWIvaW5kZXguanMiLCJzaGFyZWQvbW9kdWxlcy9jb250cmFjdC11dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9ldGhlcnMvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V0aC1tZXRob2QtcmVnaXN0cnkvZGlzdC9pbmRleC5qcyIsInVpL2hlbHBlcnMvdXRpbHMvZmV0Y2gtd2l0aC1jYWNoZS5qcyIsInNoYXJlZC9jb25zdGFudHMvZ2FzLmpzIiwic2hhcmVkL21vZHVsZXMvdHJhbnNhY3Rpb24udXRpbHMuanMiLCJ1aS9wYWdlcy9zd2Fwcy9zd2Fwcy51dGlsLmpzIiwidWkvaGVscGVycy9jb25zdGFudHMvZXJyb3Ita2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9jb21tb24vZGlzdC5icm93c2VyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3R4L2Rpc3QuYnJvd3Nlci9pbmRleC5qcyIsInVpL2hlbHBlcnMvY29uc3RhbnRzL3RyYW5zYWN0aW9ucy5qcyIsInNoYXJlZC9tb2R1bGVzL3N3YXBzLnV0aWxzLmpzIiwidWkvcGFnZXMvc2VuZC9zZW5kLnV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2lzb21vcnBoaWMtZmV0Y2gvZmV0Y2gtbnBtLWJyb3dzZXJpZnkuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QuYnJvd3Nlci9hZGRyZXNzLmpzIiwibm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0LmJyb3dzZXIvdHlwZXMuanMiLCJub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QuYnJvd3Nlci9ieXRlcy5qcyIsIm5vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC5icm93c2VyL2V4dGVybmFscy5qcyIsIm5vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC5icm93c2VyL29iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC5icm93c2VyL2FjY291bnQuanMiLCJub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QuYnJvd3Nlci9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL25vZGVfbW9kdWxlcy9ldGhqcy11dGlsL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC5icm93c2VyL3NpZ25hdHVyZS5qcyIsIm5vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC5icm93c2VyL2hhc2guanMiLCJzaGFyZWQvbW9kdWxlcy9uZXR3b3JrLnV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL29icy1zdG9yZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhc3N3b3JkZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmlwMzkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXRoLWhkLWtleXJpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXRoLXNpbXBsZS1rZXlyaW5nL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L0Jhc2VDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L0NvbnRyb2xsZXJNZXNzZW5nZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvQ29tcG9zYWJsZUNvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvdXNlci9BZGRyZXNzQm9va0NvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvdXNlci9QcmVmZXJlbmNlc0NvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3Qvbm90aWZpY2F0aW9uL05vdGlmaWNhdGlvbkNvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvYXNzZXRzL1Rva2VuRGV0ZWN0aW9uQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9hc3NldHMvQ29sbGVjdGlibGVEZXRlY3Rpb25Db250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L2Fzc2V0cy9Ub2tlblJhdGVzQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9hc3NldHMvQ3VycmVuY3lSYXRlQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9hc3NldHMvQWNjb3VudFRyYWNrZXJDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L21lc3NhZ2UtbWFuYWdlci9QZXJzb25hbE1lc3NhZ2VNYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L21lc3NhZ2UtbWFuYWdlci9NZXNzYWdlTWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9tZXNzYWdlLW1hbmFnZXIvVHlwZWRNZXNzYWdlTWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9hc3NldHMvVG9rZW5CYWxhbmNlc0NvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvYXNzZXRzL0NvbGxlY3RpYmxlc0NvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvYXBwcm92YWwvQXBwcm92YWxDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L0Jhc2VDb250cm9sbGVyVjIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvYXNzZXRzL1Rva2VuTGlzdENvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvYXNzZXRzL1Rva2Vuc0NvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvZ2FzL0dhc0ZlZUNvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC90aGlyZC1wYXJ0eS9QaGlzaGluZ0NvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3Qva2V5cmluZy9LZXlyaW5nQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9hc3NldHMvQXNzZXRzQ29udHJhY3RDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L25ldHdvcmsvTmV0d29ya0NvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvdHJhbnNhY3Rpb24vVHJhbnNhY3Rpb25Db250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGhlcnNjYW4tbGluay9kaXN0L3ByZWZpeC1mb3ItY2hhaW4uanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aGVyc2Nhbi1saW5rL2Rpc3QvaGVscGVycy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoZXJzY2FuLWxpbmsvZGlzdC9wcmVmaXgtZm9yLW5ldHdvcmsuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91dGlsL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL3Byb2Nlc3MtbmV4dGljay1hcmdzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiLCJub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2xpYi9zdHJpbmdfZGVjb2Rlci5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UuanMiLCJub2RlX21vZHVsZXMvQHNlbnRyeS90eXBlcy9kaXN0L3Nlc3Npb24uanMiLCJub2RlX21vZHVsZXMvQHNlbnRyeS90eXBlcy9kaXN0L2xvZ2xldmVsLmpzIiwibm9kZV9tb2R1bGVzL0BzZW50cnkvdHlwZXMvZGlzdC90cmFuc2FjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9Ac2VudHJ5L3R5cGVzL2Rpc3Qvc2V2ZXJpdHkuanMiLCJub2RlX21vZHVsZXMvQHNlbnRyeS90eXBlcy9kaXN0L3RyYW5zcG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9Ac2VudHJ5L3R5cGVzL2Rpc3Qvc3RhdHVzLmpzIiwibm9kZV9tb2R1bGVzL0BzZW50cnkvYnJvd3Nlci9kaXN0L3RyYWNla2l0LmpzIiwibm9kZV9tb2R1bGVzL0BzZW50cnkvYnJvd3Nlci9kaXN0L3BhcnNlcnMuanMiLCJub2RlX21vZHVsZXMvQHNlbnRyeS9icm93c2VyL2Rpc3QvYmFja2VuZC5qcyIsIm5vZGVfbW9kdWxlcy9Ac2VudHJ5L3V0aWxzL2Rpc3QvcG9seWZpbGwuanMiLCJub2RlX21vZHVsZXMvQHNlbnRyeS9icm93c2VyL2Rpc3QvdHJhbnNwb3J0cy91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvZGlzdC9pbnRlZ3JhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvZGlzdC9pbnRlZ3JhdGlvbnMvZnVuY3Rpb250b3N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvZGlzdC9pbnRlZ3JhdGlvbnMvaW5ib3VuZGZpbHRlcnMuanMiLCJub2RlX21vZHVsZXMvQHNlbnRyeS9odWIvZGlzdC9zZXNzaW9uZmx1c2hlci5qcyIsIm5vZGVfbW9kdWxlcy9Ac2VudHJ5L2h1Yi9kaXN0L3Njb3BlLmpzIiwibm9kZV9tb2R1bGVzL0BzZW50cnkvaHViL2Rpc3Qvc2Vzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9Ac2VudHJ5L2h1Yi9kaXN0L2h1Yi5qcyIsIm5vZGVfbW9kdWxlcy9ldGhqcy1ycGMvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V0aGpzLWZvcm1hdC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXRoanMtZmlsdGVyL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldGhqcy11dGlsL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldGhqcy1jb250cmFjdC9ub2RlX21vZHVsZXMvanMtc2hhMy9zcmMvc2hhMy5qcyIsIm5vZGVfbW9kdWxlcy9ldGhqcy1hYmkvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2V0aGpzLWNvbnRyYWN0L2xpYi9jb250cmFjdC5qcyIsIm5vZGVfbW9kdWxlcy9ldGhqcy1jb250cmFjdC9saWIvaGFzLXR4LW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtZW5zLW5hbWVoYXNoL25vZGVfbW9kdWxlcy9qcy1zaGEzL3NyYy9zaGEzLmpzIiwibm9kZV9tb2R1bGVzL2lkbmEtdXRzNDYtaHgvdXRzNDYuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzLmpzIiwidWkvc2VsZWN0b3JzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2N1cnJlbmN5LWZvcm1hdHRlci9jdXJyZW5jaWVzLmpzIiwibm9kZV9tb2R1bGVzL2N1cnJlbmN5LWZvcm1hdHRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtZmlsdGVycy9ub2RlX21vZHVsZXMvanNvbi1ycGMtZW5naW5lL3NyYy9jcmVhdGVTY2FmZm9sZE1pZGRsZXdhcmUuanMiLCJub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLWZpbHRlcnMvYmFzZS1maWx0ZXIuanMiLCJub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLWZpbHRlcnMvbm9kZV9tb2R1bGVzL3BpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLWZpbHRlcnMvYmFzZS1maWx0ZXItaGlzdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2guZmxhdG1hcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzLmpzIiwibm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtYWJpL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3R3ZWV0bmFjbC11dGlsL25hY2wtdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy90d2VldG5hY2wvbmFjbC1mYXN0LmpzIiwibm9kZV9tb2R1bGVzL2V0aC1zaWctdXRpbC9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hc3NlcnQvbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9qc29uc2NoZW1hL2xpYi9zY2FuLmpzIiwibm9kZV9tb2R1bGVzL2pzb25zY2hlbWEvbGliL3ZhbGlkYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9qc29uc2NoZW1hL2xpYi9oZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL2V0aGVycy9saWIvZXRoZXJzLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1tZXRob2QtcmVnaXN0cnkvZGlzdC9yZWdpc3RyeS1tYXAuanNvbiIsIm5vZGVfbW9kdWxlcy9ldGgtbWV0aG9kLXJlZ2lzdHJ5L2Rpc3QvYWJpLmpzb24iLCJub2RlX21vZHVsZXMvZXRoanMvbGliL2luZGV4LmpzIiwidWkvaGVscGVycy91dGlscy9zdG9yYWdlLWhlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvZXRoanMtZW5zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V0aGVyZXVtLWVucy1uZXR3b3JrLW1hcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZXNlbGVjdC9saWIvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0dlFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3Y4UE8sTUFBTSxXQUFXLEdBQUc7QUFDekIsRUFBQSxrQkFBa0IsRUFBRSxvQkFESztBQUV6QixFQUFBLGFBQWEsRUFBRSxlQUZVO0FBR3pCLEVBQUEsb0JBQW9CLEVBQUU7QUFIRyxDQUFwQjtBQU1QO0FBQ0E7QUFDQTs7O0FBQ08sTUFBTSxzQkFBc0IsR0FBRyxDQUNwQyxXQUFXLENBQUMsa0JBRHdCLEVBRXBDLFdBQVcsQ0FBQyxhQUZ3QixDQUEvQjs7QUFLQSxNQUFNLDRCQUE0QixHQUFHO0FBQzFDLEVBQUEsUUFBUSxFQUFFLENBRGdDO0FBRTFDLEVBQUEsU0FBUyxFQUFFO0FBRitCLENBQXJDOzs7Ozs7Ozs7Ozs7O0FDZFA7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9mQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMWZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDZE8sTUFBTSxxQkFBcUIsR0FBRyxPQUFPLFFBQVAsRUFBaUIsT0FBakIsS0FBNkI7QUFDaEUsTUFBSSxZQUFKOztBQUNBLE1BQUk7QUFDRixJQUFBLFlBQVksR0FBRyxNQUFNLFFBQVEsQ0FBQyxPQUFULENBQWlCLE9BQWpCLENBQXJCO0FBQ0QsR0FGRCxDQUVFLE9BQU8sQ0FBUCxFQUFVO0FBQ1YsSUFBQSxZQUFZLEdBQUcsSUFBZjtBQUNEOztBQUVELFFBQU0saUJBQWlCLEdBQ3JCLFlBQVksSUFBSSxZQUFZLEtBQUssSUFBakMsSUFBeUMsWUFBWSxLQUFLLEtBRDVEO0FBRUEsU0FBTztBQUFFLElBQUEsWUFBRjtBQUFnQixJQUFBO0FBQWhCLEdBQVA7QUFDRCxDQVhNOzs7Ozs7Ozs7Ozs7OztBQ0FQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlEQTs7QUFDQTs7QUFDQTs7Ozs7O0FBRUEsTUFBTSxjQUFjLEdBQUcsT0FDckIsR0FEcUIsRUFFckIsWUFBWSxHQUFHLEVBRk0sRUFHckI7QUFBRSxFQUFBLGdCQUFnQixHQUFHLGVBQVMsQ0FBOUI7QUFBaUMsRUFBQSxPQUFPLEdBQUcsZUFBUztBQUFwRCxJQUEyRCxFQUh0QyxLQUlsQjtBQUNILE1BQ0UsWUFBWSxDQUFDLElBQWIsSUFDQyxZQUFZLENBQUMsTUFBYixJQUF1QixZQUFZLENBQUMsTUFBYixLQUF3QixLQUZsRCxFQUdFO0FBQ0EsVUFBTSxJQUFJLEtBQUosQ0FBVSwyQ0FBVixDQUFOO0FBQ0Q7O0FBQ0QsTUFBSSxFQUFFLFlBQVksQ0FBQyxPQUFiLFlBQWdDLE1BQU0sQ0FBQyxPQUF6QyxDQUFKLEVBQXVEO0FBQ3JELElBQUEsWUFBWSxDQUFDLE9BQWIsR0FBdUIsSUFBSSxNQUFNLENBQUMsT0FBWCxDQUFtQixZQUFZLENBQUMsT0FBaEMsQ0FBdkI7QUFDRDs7QUFDRCxNQUNFLFlBQVksQ0FBQyxPQUFiLENBQXFCLEdBQXJCLENBQXlCLGNBQXpCLEtBQ0EsWUFBWSxDQUFDLE9BQWIsQ0FBcUIsR0FBckIsQ0FBeUIsY0FBekIsTUFBNkMsa0JBRi9DLEVBR0U7QUFDQSxVQUFNLElBQUksS0FBSixDQUFVLDZDQUFWLENBQU47QUFDRDs7QUFFRCxRQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsR0FBTCxFQUFwQjtBQUNBLFFBQU0sUUFBUSxHQUFJLGVBQWMsR0FBSSxFQUFwQztBQUNBLFFBQU07QUFBRSxJQUFBLGNBQUY7QUFBa0IsSUFBQTtBQUFsQixNQUFpQyxDQUFDLE1BQU0sb0NBQWUsUUFBZixDQUFQLEtBQW9DLEVBQTNFOztBQUNBLE1BQUksY0FBYyxJQUFJLFdBQVcsR0FBRyxVQUFkLEdBQTJCLGdCQUFqRCxFQUFtRTtBQUNqRSxXQUFPLGNBQVA7QUFDRDs7QUFDRCxFQUFBLFlBQVksQ0FBQyxPQUFiLENBQXFCLEdBQXJCLENBQXlCLGNBQXpCLEVBQXlDLGtCQUF6QztBQUNBLFFBQU0sZ0JBQWdCLEdBQUcsK0JBQW9CLE9BQXBCLENBQXpCO0FBQ0EsUUFBTSxRQUFRLEdBQUcsTUFBTSxnQkFBZ0IsQ0FBQyxHQUFEO0FBQ3JDLElBQUEsY0FBYyxFQUFFLDRCQURxQjtBQUVyQyxJQUFBLElBQUksRUFBRSxJQUYrQjtBQUdyQyxJQUFBLE1BQU0sRUFBRSxLQUg2QjtBQUlyQyxJQUFBLElBQUksRUFBRTtBQUorQixLQUtsQyxZQUxrQyxFQUF2Qzs7QUFPQSxNQUFJLENBQUMsUUFBUSxDQUFDLEVBQWQsRUFBa0I7QUFDaEIsVUFBTSxJQUFJLEtBQUosQ0FDSCw2QkFBNEIsUUFBUSxDQUFDLE1BQU8sT0FBTSxRQUFRLENBQUMsVUFBVyxHQURuRSxDQUFOO0FBR0Q7O0FBQ0QsUUFBTSxZQUFZLEdBQUcsTUFBTSxRQUFRLENBQUMsSUFBVCxFQUEzQjtBQUNBLFFBQU0sVUFBVSxHQUFHO0FBQ2pCLElBQUEsY0FBYyxFQUFFLFlBREM7QUFFakIsSUFBQSxVQUFVLEVBQUU7QUFGSyxHQUFuQjtBQUtBLFFBQU0sb0NBQWUsUUFBZixFQUF5QixVQUF6QixDQUFOO0FBQ0EsU0FBTyxZQUFQO0FBQ0QsQ0FqREQ7O2VBbURlLGM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkRmOztBQUNBOztBQUVBLE1BQU0sb0JBQW9CLEdBQUcsTUFBN0I7QUFFTyxNQUFNLFVBQVUsR0FBRztBQUN4QjtBQUNBLEVBQUEsTUFBTSxFQUFFLGtDQUFhLHVCQUFiLENBRmdCO0FBR3hCO0FBQ0EsRUFBQSxtQkFBbUIsRUFBRSxrQ0FBYSxvQkFBb0IsQ0FBQyxRQUFyQixDQUE4QixFQUE5QixDQUFiO0FBSkcsQ0FBbkI7QUFPUDtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sTUFBTSxrQkFBa0IsR0FBRztBQUNoQyxFQUFBLFVBQVUsRUFBRSxZQURvQjtBQUVoQyxFQUFBLE1BQU0sRUFBRSxRQUZ3QjtBQUdoQyxFQUFBLFlBQVksRUFBRSxjQUhrQjtBQUloQyxFQUFBLElBQUksRUFBRTtBQUowQixDQUEzQjtBQU9QO0FBQ0E7QUFDQTs7O0FBQ08sTUFBTSxtQkFBbUIsR0FBRztBQUNqQyxFQUFBLEdBQUcsRUFBRSxLQUQ0QjtBQUVqQyxFQUFBLE1BQU0sRUFBRSxRQUZ5QjtBQUdqQyxFQUFBLElBQUksRUFBRTtBQUgyQixDQUE1QjtBQU1QO0FBQ0E7QUFDQTs7O0FBQ08sTUFBTSxlQUFlLEdBQUc7QUFDN0IsRUFBQSxxQkFBcUIsRUFBRSxxQkFETTtBQUU3QixFQUFBLEdBQUcsRUFBRSxLQUZ3QjtBQUc3QixFQUFBLE1BQU0sRUFBRSxRQUhxQjtBQUk3QixFQUFBLElBQUksRUFBRSxNQUp1QjtBQUs3QixFQUFBLE1BQU0sRUFBRSxRQUxxQjtBQU03QixFQUFBLGNBQWMsRUFBRTtBQU5hLENBQXhCO0FBU1A7QUFDQTtBQUNBOzs7QUFDTyxNQUFNLG1CQUFtQixHQUFHLFFBQTVCO0FBRVA7QUFDQTtBQUNBOzs7QUFDTyxNQUFNLGNBQWMsR0FBRztBQUM1QixFQUFBLFFBQVEsRUFBRSxVQURrQjtBQUU1QixFQUFBLE1BQU0sRUFBRSxRQUZvQjtBQUc1QixFQUFBLGVBQWUsRUFBRSxpQkFIVztBQUk1QixFQUFBLEtBQUssRUFBRTtBQUpxQixDQUF2QjtBQU9QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sTUFBTSw2QkFBNkIsR0FBRztBQUMzQyxFQUFBLFFBQVEsRUFBRSxDQURpQztBQUUzQyxFQUFBLE1BQU0sRUFBRSxJQUZtQztBQUczQyxFQUFBLElBQUksRUFBRTtBQUhxQyxDQUF0Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqRVA7O0FBRU8sU0FBUyx5QkFBVCxDQUFtQyxXQUFuQyxFQUFnRCxPQUFoRCxFQUF5RCxTQUF6RCxFQUFvRTtBQUN6RSxNQUFJLE9BQU8sV0FBVyxDQUFDLE9BQW5CLEtBQStCLFdBQW5DLEVBQWdEO0FBQzlDLFdBQU8sV0FBVyxDQUFDLE9BQVosS0FBd0IsT0FBL0I7QUFDRDs7QUFDRCxTQUFPLFdBQVcsQ0FBQyxpQkFBWixLQUFrQyxTQUF6QztBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sU0FBUyxvQkFBVCxDQUE4QixXQUE5QixFQUEyQztBQUFBOztBQUNoRCxTQUNFLGlDQUFZLFdBQVosYUFBWSxXQUFaLGdEQUFZLFdBQVcsQ0FBRSxRQUF6QiwwREFBWSxzQkFBdUIsWUFBbkMsS0FDQSxpQ0FBWSxXQUFaLGFBQVksV0FBWixpREFBWSxXQUFXLENBQUUsUUFBekIsMkRBQVksdUJBQXVCLG9CQUFuQyxDQUZGO0FBSUQ7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sU0FBUyxtQkFBVCxDQUE2QixXQUE3QixFQUEwQztBQUMvQyxTQUNFLE9BQU8sV0FBVyxDQUFDLFFBQVosQ0FBcUIsWUFBNUIsS0FBNkMsV0FBN0MsSUFDQSxPQUFPLFdBQVcsQ0FBQyxRQUFaLENBQXFCLG9CQUE1QixLQUFxRCxXQURyRCxLQUVDLE9BQU8sV0FBVyxDQUFDLFFBQVosQ0FBcUIsUUFBNUIsS0FBeUMsV0FBekMsSUFDQyxpQ0FBWSxXQUFXLENBQUMsUUFBWixDQUFxQixRQUFqQyxDQUhGLENBREY7QUFNRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNPLFNBQVMsd0JBQVQsQ0FBa0MsV0FBbEMsRUFBK0M7QUFBQTs7QUFDcEQsUUFBTTtBQUFFLElBQUEsUUFBRjtBQUFZLElBQUEsb0JBQVo7QUFBa0MsSUFBQTtBQUFsQyxNQUNKLENBQUEsV0FBVyxTQUFYLElBQUEsV0FBVyxXQUFYLFlBQUEsV0FBVyxDQUFFLFFBQWIsS0FBeUIsRUFEM0I7QUFFQSxTQUNHLFFBQVEsSUFBSSxRQUFRLE1BQUssV0FBTCxhQUFLLFdBQUwsZ0RBQUssV0FBVyxDQUFFLG9CQUFsQiwwREFBSyxzQkFBbUMsUUFBeEMsQ0FBckIsSUFDQyxvQkFBb0IsSUFDbkIsWUFERCxJQUVDLENBQUEsV0FBVyxTQUFYLElBQUEsV0FBVyxXQUFYLHNDQUFBLFdBQVcsQ0FBRSxvQkFBYixrRkFBbUMsb0JBQW5DLE1BQ0Usb0JBSEgsSUFJQyxDQUFBLFdBQVcsU0FBWCxJQUFBLFdBQVcsV0FBWCxzQ0FBQSxXQUFXLENBQUUsb0JBQWIsa0ZBQW1DLFlBQW5DLE1BQW9ELFlBTnhEO0FBUUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5REQ7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBZUE7O0FBQ0E7O0FBSUE7O0FBU0E7O0FBQ0E7O0FBSUE7O0FBSUE7O0FBS0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7Ozs7OztBQUVBLE1BQU0sNkJBQTZCLEdBQ2pDLG9FQURGO0FBR0EsTUFBTSwwQkFBMEIsR0FBRyxNQUFuQztBQUVBLE1BQU0sY0FBYyxHQUFHO0FBQUUsaUJBQWU7QUFBakIsQ0FBdkI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLE1BQU0sd0JBQXdCLEdBQUcsQ0FBQyxJQUFELEVBQU8sT0FBUCxLQUFtQjtBQUNsRCxRQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsR0FBUixDQUFZLGtCQUEvQjtBQUNBLFFBQU0sWUFBWSxHQUFHLFVBQVUsR0FDM0IsZ0NBRDJCLEdBRTNCLDRCQUZKO0FBR0EsUUFBTSxhQUFhLEdBQUcsVUFBVSxHQUFHLDJCQUFILEdBQTBCLHVCQUExRDtBQUNBLFFBQU0sc0JBQXNCLEdBQUcsQ0FBQyxhQUFELENBQS9CLENBTmtELENBTUY7O0FBQ2hELE1BQUksc0JBQXNCLENBQUMsUUFBdkIsQ0FBZ0MsSUFBaEMsQ0FBSixFQUEyQztBQUN6QyxXQUFPLFlBQVA7QUFDRDs7QUFDRCxRQUFNLGNBQWMsR0FBRyxPQUFPLElBQUksUUFBUSxDQUFDLE9BQUQsRUFBVSxFQUFWLENBQTFDO0FBQ0EsUUFBTSxXQUFXLEdBQUcsQ0FBQyxXQUFELENBQXBCOztBQUNBLE1BQUksV0FBVyxDQUFDLFFBQVosQ0FBcUIsSUFBckIsQ0FBSixFQUFnQztBQUM5QixXQUFRLEdBQUUsYUFBYyxhQUFZLGNBQWUsRUFBbkQsQ0FEOEIsQ0FDd0I7QUFDdkQ7O0FBQ0QsU0FBUSxHQUFFLFlBQWEsYUFBWSxjQUFlLEVBQWxEO0FBQ0QsQ0FoQkQ7O0FBa0JBLE1BQU0sY0FBYyxHQUFHLENBQUMseUJBQUQsRUFBbUIsMkJBQW5CLENBQXZCOztBQUVPLE1BQU0sVUFBVSxHQUFHLFVBQVUsSUFBVixFQUFnQixPQUFPLEdBQUcseUJBQTFCLEVBQTRDO0FBQ3BFO0FBQ0EsRUFBQSxPQUFPLEdBQUcsY0FBYyxDQUFDLFFBQWYsQ0FBd0IsT0FBeEIsSUFBbUMseUJBQW5DLEdBQXNELE9BQWhFO0FBQ0EsUUFBTSxPQUFPLEdBQUcsd0JBQXdCLENBQUMsSUFBRCxFQUFPLE9BQVAsQ0FBeEM7QUFDQSxRQUFNLGNBQWMsR0FBRyxPQUFPLElBQUksUUFBUSxDQUFDLE9BQUQsRUFBVSxFQUFWLENBQTFDOztBQUNBLE1BQUksQ0FBQyxPQUFMLEVBQWM7QUFDWixVQUFNLElBQUksS0FBSixDQUFXLDZDQUE0QyxPQUFRLEVBQS9ELENBQU47QUFDRDs7QUFDRCxVQUFRLElBQVI7QUFDRSxTQUFLLE9BQUw7QUFDRSxhQUFRLEdBQUUsT0FBUSxVQUFsQjs7QUFDRixTQUFLLFFBQUw7QUFDRSxhQUFRLEdBQUUsT0FBUSxTQUFsQjs7QUFDRixTQUFLLE9BQUw7QUFDRSxhQUFRLEdBQUUsT0FBUSxRQUFsQjs7QUFDRixTQUFLLFdBQUw7QUFDRSxhQUFRLEdBQUUsT0FBUSxZQUFsQjs7QUFDRixTQUFLLG9CQUFMO0FBQ0UsYUFBUSxHQUFFLE9BQVEscUJBQWxCOztBQUNGLFNBQUssV0FBTDtBQUNFLGFBQVEsR0FBRSxPQUFRLFlBQWxCOztBQUNGLFNBQUssU0FBTDtBQUNFO0FBQ0EsYUFBUSxHQUFFLDRCQUFzQixhQUFZLGNBQWUsRUFBM0Q7O0FBQ0Y7QUFDRSxZQUFNLElBQUksS0FBSixDQUFVLHNDQUFWLENBQU47QUFqQko7QUFtQkQsQ0EzQk07Ozs7QUE2QlAsTUFBTSxRQUFRLEdBQUksTUFBRCxJQUFZLE9BQU8sQ0FBQyxNQUFELGFBQUMsTUFBRCx1QkFBQyxNQUFNLENBQUUsS0FBUixDQUFjLGdCQUFkLENBQUQsQ0FBcEM7O0FBQ0EsTUFBTSxZQUFZLEdBQUksTUFBRCxJQUFZLE9BQU8sQ0FBQyxNQUFELGFBQUMsTUFBRCx1QkFBQyxNQUFNLENBQUUsTUFBVCxDQUF4Qzs7QUFDQSxNQUFNLGlCQUFpQixHQUFJLE1BQUQsSUFDeEIsWUFBWSxDQUFDLE1BQUQsQ0FBWixJQUF3QixPQUFPLENBQUMsTUFBTSxDQUFDLEtBQVAsQ0FBYSxRQUFiLENBQUQsQ0FEakM7O0FBR0EsTUFBTSxnQkFBZ0IsR0FBRyxDQUN2QjtBQUNFLEVBQUEsUUFBUSxFQUFFLE9BRFo7QUFFRSxFQUFBLElBQUksRUFBRSxRQUZSO0FBR0UsRUFBQSxTQUFTLEVBQUcsS0FBRCxJQUNULEtBQUssSUFDTCxRQUFRLENBQUMsS0FBSyxDQUFDLElBQVAsQ0FEUixJQUVBLHVDQUFrQixLQUFLLENBQUMsRUFBeEIsRUFBNEI7QUFBRSxJQUFBLGdCQUFnQixFQUFFO0FBQXBCLEdBQTVCLENBRkEsSUFHQSx1Q0FBa0IsS0FBSyxDQUFDLElBQXhCLEVBQThCO0FBQUUsSUFBQSxnQkFBZ0IsRUFBRTtBQUFwQixHQUE5QixDQUhBLElBSUEsWUFBWSxDQUFDLEtBQUssQ0FBQyxLQUFQO0FBUmhCLENBRHVCLEVBV3ZCO0FBQ0UsRUFBQSxRQUFRLEVBQUUsZ0JBRFo7QUFFRSxFQUFBLElBQUksRUFBRSxRQUZSO0FBR0UsRUFBQSxTQUFTLEVBQUcsVUFBRCxJQUNULFVBQVUsS0FBSyxJQUFmLElBQ0MsVUFBVSxJQUNULFFBQVEsQ0FBQyxVQUFVLENBQUMsSUFBWixDQURULElBRUMsdUNBQWtCLFVBQVUsQ0FBQyxFQUE3QixFQUFpQztBQUFFLElBQUEsZ0JBQWdCLEVBQUU7QUFBcEIsR0FBakMsQ0FGRCxJQUdDLHVDQUFrQixVQUFVLENBQUMsSUFBN0IsRUFBbUM7QUFBRSxJQUFBLGdCQUFnQixFQUFFO0FBQXBCLEdBQW5DO0FBUk4sQ0FYdUIsRUFxQnZCO0FBQ0UsRUFBQSxRQUFRLEVBQUUsY0FEWjtBQUVFLEVBQUEsSUFBSSxFQUFFLFFBRlI7QUFHRSxFQUFBLFNBQVMsRUFBRTtBQUhiLENBckJ1QixFQTBCdkI7QUFDRSxFQUFBLFFBQVEsRUFBRSxtQkFEWjtBQUVFLEVBQUEsSUFBSSxFQUFFLFFBRlI7QUFHRSxFQUFBLFNBQVMsRUFBRTtBQUhiLENBMUJ1QixFQStCdkI7QUFDRSxFQUFBLFFBQVEsRUFBRSxhQURaO0FBRUUsRUFBQSxJQUFJLEVBQUUsUUFGUjtBQUdFLEVBQUEsU0FBUyxFQUFHLEtBQUQsSUFBVyx1Q0FBa0IsS0FBbEIsRUFBeUI7QUFBRSxJQUFBLGdCQUFnQixFQUFFO0FBQXBCLEdBQXpCO0FBSHhCLENBL0J1QixFQW9DdkI7QUFDRSxFQUFBLFFBQVEsRUFBRSxrQkFEWjtBQUVFLEVBQUEsSUFBSSxFQUFFLFFBRlI7QUFHRSxFQUFBLFNBQVMsRUFBRyxLQUFELElBQVcsdUNBQWtCLEtBQWxCLEVBQXlCO0FBQUUsSUFBQSxnQkFBZ0IsRUFBRTtBQUFwQixHQUF6QjtBQUh4QixDQXBDdUIsRUF5Q3ZCO0FBQ0UsRUFBQSxRQUFRLEVBQUUsWUFEWjtBQUVFLEVBQUEsSUFBSSxFQUFFLFFBRlI7QUFHRSxFQUFBLFNBQVMsRUFBRTtBQUhiLENBekN1QixFQThDdkI7QUFDRSxFQUFBLFFBQVEsRUFBRSxTQURaO0FBRUUsRUFBQSxJQUFJLEVBQUUsUUFGUjtBQUdFLEVBQUEsU0FBUyxFQUFFO0FBSGIsQ0E5Q3VCLEVBbUR2QjtBQUNFLEVBQUEsUUFBUSxFQUFFLE9BRFo7QUFFRSxFQUFBLElBQUksRUFBRSxRQUZSO0FBR0UsRUFBQSxTQUFTLEVBQUcsS0FBRCxJQUFXLEtBQUssS0FBSyxJQUFWLElBQWtCLE9BQU8sS0FBUCxLQUFpQjtBQUgzRCxDQW5EdUIsRUF3RHZCO0FBQ0UsRUFBQSxRQUFRLEVBQUUsWUFEWjtBQUVFLEVBQUEsSUFBSSxFQUFFO0FBRlIsQ0F4RHVCLEVBNER2QjtBQUNFLEVBQUEsUUFBUSxFQUFFLFFBRFo7QUFFRSxFQUFBLElBQUksRUFBRTtBQUZSLENBNUR1QixFQWdFdkI7QUFDRSxFQUFBLFFBQVEsRUFBRSxhQURaO0FBRUUsRUFBQSxJQUFJLEVBQUUsa0JBRlI7QUFHRSxFQUFBLFNBQVMsRUFBRyxXQUFELElBQWlCLFdBQVcsS0FBSyxTQUFoQixJQUE2QixXQUFXLEdBQUc7QUFIekUsQ0FoRXVCLEVBcUV2QjtBQUNFLEVBQUEsUUFBUSxFQUFFLEtBRFo7QUFFRSxFQUFBLElBQUksRUFBRTtBQUZSLENBckV1QixDQUF6QjtBQTJFQSxNQUFNLGdCQUFnQixHQUFHLENBQ3ZCO0FBQ0UsRUFBQSxRQUFRLEVBQUUsU0FEWjtBQUVFLEVBQUEsSUFBSSxFQUFFLFFBRlI7QUFHRSxFQUFBLFNBQVMsRUFBRyxLQUFELElBQVcsdUNBQWtCLEtBQWxCLEVBQXlCO0FBQUUsSUFBQSxnQkFBZ0IsRUFBRTtBQUFwQixHQUF6QjtBQUh4QixDQUR1QixFQU12QjtBQUNFLEVBQUEsUUFBUSxFQUFFLFFBRFo7QUFFRSxFQUFBLElBQUksRUFBRSxRQUZSO0FBR0UsRUFBQSxTQUFTLEVBQUcsTUFBRCxJQUFZLFlBQVksQ0FBQyxNQUFELENBQVosSUFBd0IsTUFBTSxDQUFDLE1BQVAsSUFBaUI7QUFIbEUsQ0FOdUIsRUFXdkI7QUFDRSxFQUFBLFFBQVEsRUFBRSxVQURaO0FBRUUsRUFBQSxJQUFJLEVBQUUsZUFGUjtBQUdFLEVBQUEsU0FBUyxFQUFHLE1BQUQsSUFBWSxNQUFNLENBQUMsTUFBRCxDQUFOLElBQWtCLENBQWxCLElBQXVCLE1BQU0sQ0FBQyxNQUFELENBQU4sSUFBa0I7QUFIbEUsQ0FYdUIsQ0FBekI7QUFrQkEsTUFBTSxvQkFBb0IsR0FBRyxnQkFBZ0IsQ0FBQyxLQUFqQixDQUF1QixDQUF2QixFQUEwQixDQUExQixDQUE3QjtBQUVBLE1BQU0sOEJBQThCLEdBQUcsQ0FDckM7QUFDRSxFQUFBLFFBQVEsRUFBRSxPQURaO0FBRUUsRUFBQSxJQUFJLEVBQUUsUUFGUjtBQUdFLEVBQUEsU0FBUyxFQUFHLE1BQUQsSUFBWSxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQVAsQ0FBYSxrQkFBYixDQUFEO0FBSGhDLENBRHFDLEVBTXJDO0FBQ0UsRUFBQSxRQUFRLEVBQUUsT0FEWjtBQUVFLEVBQUEsSUFBSSxFQUFFLFFBRlI7QUFHRSxFQUFBLFNBQVMsRUFBRTtBQUhiLENBTnFDLEVBV3JDO0FBQ0UsRUFBQSxRQUFRLEVBQUUsTUFEWjtBQUVFLEVBQUEsSUFBSSxFQUFFLFFBRlI7QUFHRSxFQUFBLFNBQVMsRUFBRyxNQUFELElBQVksT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFQLENBQWEsY0FBYixDQUFEO0FBSGhDLENBWHFDLENBQXZDOztBQWtCQSxNQUFNLG9CQUFvQixHQUFJLE1BQUQsSUFDM0IsQ0FBQyxLQUFLLENBQUMsTUFBRCxDQUFOLElBQWtCLE1BQU0sQ0FBQyxLQUFQLENBQWEsWUFBYixDQUFsQixJQUFnRCxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsTUFBRCxDQUFYLENBRHhEOztBQUdBLE1BQU0sd0JBQXdCLEdBQUcsQ0FDL0I7QUFDRSxFQUFBLFFBQVEsRUFBRSxjQURaO0FBRUUsRUFBQSxJQUFJLEVBQUUsUUFGUjtBQUdFLEVBQUEsU0FBUyxFQUFFO0FBSGIsQ0FEK0IsRUFNL0I7QUFDRSxFQUFBLFFBQVEsRUFBRSxpQkFEWjtBQUVFLEVBQUEsSUFBSSxFQUFFLFFBRlI7QUFHRSxFQUFBLFNBQVMsRUFBRTtBQUhiLENBTitCLEVBVy9CO0FBQ0UsRUFBQSxRQUFRLEVBQUUsY0FEWjtBQUVFLEVBQUEsSUFBSSxFQUFFLFFBRlI7QUFHRSxFQUFBLFNBQVMsRUFBRTtBQUhiLENBWCtCLENBQWpDOztBQWtCQSxTQUFTLFlBQVQsQ0FBc0IsVUFBdEIsRUFBa0MsTUFBbEMsRUFBMEMsT0FBMUMsRUFBbUQ7QUFDakQsU0FBTyxVQUFVLENBQUMsS0FBWCxDQUFpQixDQUFDO0FBQUUsSUFBQSxRQUFGO0FBQVksSUFBQSxJQUFaO0FBQWtCLElBQUE7QUFBbEIsR0FBRCxLQUFtQztBQUN6RCxVQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBTCxDQUFXLEdBQVgsQ0FBZDtBQUVBLFVBQU0sS0FBSyxHQUNULEtBQUssQ0FBQyxJQUFOLENBQVksS0FBRCxJQUFXLE9BQU8sTUFBTSxDQUFDLFFBQUQsQ0FBYixLQUE0QixLQUFsRCxNQUNDLENBQUMsU0FBRCxJQUFjLFNBQVMsQ0FBQyxNQUFNLENBQUMsUUFBRCxDQUFQLENBRHhCLENBREY7O0FBR0EsUUFBSSxDQUFDLEtBQUwsRUFBWTtBQUNWLHdCQUFJLEtBQUosQ0FDRyxtQkFBa0IsT0FBUSx5QkFBd0IsUUFBUyxjQUQ5RCxFQUVFLE1BQU0sQ0FBQyxRQUFELENBRlIsRUFHRSxjQUhGLEVBSUUsT0FBTyxNQUFNLENBQUMsUUFBRCxDQUpmO0FBTUQ7O0FBQ0QsV0FBTyxLQUFQO0FBQ0QsR0FmTSxDQUFQO0FBZ0JEOztBQUVNLE1BQU0sMEJBQTBCLEdBQUcsQ0FDeEMsT0FEd0MsRUFFeEMsV0FGd0MsRUFHeEMsZ0JBSHdDLEtBSXJDO0FBQUE7O0FBQ0gsTUFBSSxDQUFDLFdBQUQsSUFBZ0IsQ0FBQyxnQkFBckIsRUFBdUM7QUFDckMsV0FBTyxLQUFQO0FBQ0Q7O0FBQ0QsUUFBTSxZQUFZLEdBQUcsc0NBQStCLE9BQS9CLENBQXJCO0FBQ0EsUUFBTSxXQUFXLDRCQUFHLHVDQUFnQyxPQUFoQyxDQUFILDBEQUFHLHNCQUEwQyxPQUE5RDtBQUNBLFFBQU0sb0JBQW9CLEdBQUcsV0FBVyxDQUFDLFdBQVosRUFBN0I7QUFDQSxRQUFNLHlCQUF5QixHQUFHLGdCQUFnQixDQUFDLFdBQWpCLEVBQWxDO0FBQ0EsU0FDRyxvQkFBb0IsS0FBSyxZQUF6QixJQUNDLHlCQUF5QixLQUFLLFdBRGhDLElBRUMsb0JBQW9CLEtBQUssV0FBekIsSUFDQyx5QkFBeUIsS0FBSyxZQUpsQztBQU1ELENBbEJNOzs7O0FBb0JBLGVBQWUsZUFBZixDQUNMO0FBQ0UsRUFBQSxRQURGO0FBRUUsRUFBQSxXQUZGO0FBR0UsRUFBQSxjQUhGO0FBSUUsRUFBQSxnQkFKRjtBQUtFLEVBQUEsS0FMRjtBQU1FLEVBQUEsV0FORjtBQU9FLEVBQUE7QUFQRixDQURLLEVBVUw7QUFBRSxFQUFBO0FBQUYsQ0FWSyxFQVdMO0FBQ0EsUUFBTSxTQUFTLEdBQUc7QUFDaEIsSUFBQSxnQkFEZ0I7QUFFaEIsSUFBQSxXQUZnQjtBQUdoQixJQUFBLFlBQVksRUFBRSwrQkFBZSxLQUFmLEVBQXNCLGNBQXRCLEVBQXNDLFFBQXRDLENBQStDLEVBQS9DLENBSEU7QUFJaEIsSUFBQSxRQUpnQjtBQUtoQixJQUFBLE9BQU8sRUFBRSxlQUFTLEVBTEY7QUFNaEIsSUFBQSxhQUFhLEVBQUU7QUFOQyxHQUFsQjs7QUFTQSxNQUFJLFlBQUosRUFBa0I7QUFDaEIsSUFBQSxTQUFTLENBQUMsWUFBVixHQUF5QixZQUF6QjtBQUNEOztBQUNELE1BQUksMEJBQTBCLENBQUMsT0FBRCxFQUFVLFdBQVYsRUFBdUIsZ0JBQXZCLENBQTlCLEVBQXdFO0FBQ3RFLElBQUEsU0FBUyxDQUFDLG9CQUFWLEdBQWlDLElBQWpDO0FBQ0Q7O0FBRUQsUUFBTSxXQUFXLEdBQUcsSUFBSSxlQUFKLENBQW9CLFNBQXBCLEVBQStCLFFBQS9CLEVBQXBCO0FBQ0EsUUFBTSxRQUFRLEdBQUksR0FBRSxVQUFVLENBQUMsT0FBRCxFQUFVLE9BQVYsQ0FBbUIsR0FBRSxXQUFZLEVBQS9EO0FBQ0EsUUFBTSxjQUFjLEdBQUcsTUFBTSw2QkFDM0IsUUFEMkIsRUFFM0I7QUFBRSxJQUFBLE1BQU0sRUFBRSxLQUFWO0FBQWlCLElBQUEsT0FBTyxFQUFFO0FBQTFCLEdBRjJCLEVBRzNCO0FBQUUsSUFBQSxnQkFBZ0IsRUFBRSxDQUFwQjtBQUF1QixJQUFBLE9BQU8sRUFBRSxlQUFTO0FBQXpDLEdBSDJCLENBQTdCO0FBS0EsUUFBTSxTQUFTLEdBQUcsY0FBYyxDQUFDLE1BQWYsQ0FBc0IsQ0FBQyxhQUFELEVBQWdCLEtBQWhCLEtBQTBCO0FBQ2hFLFFBQ0UsS0FBSyxDQUFDLEtBQU4sSUFDQSxDQUFDLEtBQUssQ0FBQyxLQURQLElBRUEsWUFBWSxDQUFDLGdCQUFELEVBQW1CLEtBQW5CLEVBQTBCLFFBQTFCLENBSGQsRUFJRTtBQUNBLFlBQU0sZ0JBQWdCLEdBQUcsNkJBQWtCO0FBQ3pDLFFBQUEsRUFBRSxFQUFFLEtBQUssQ0FBQyxLQUFOLENBQVksRUFEeUI7QUFFekMsUUFBQSxJQUFJLEVBQUUsS0FBSyxDQUFDLEtBQU4sQ0FBWSxJQUZ1QjtBQUd6QyxRQUFBLElBQUksRUFBRSxLQUFLLENBQUMsS0FBTixDQUFZLElBSHVCO0FBSXpDLFFBQUEsTUFBTSxFQUFFLCtCQUFhLEtBQUssQ0FBQyxLQUFOLENBQVksS0FBekIsQ0FKaUM7QUFLekMsUUFBQSxHQUFHLEVBQUUsK0JBQWEsS0FBSyxDQUFDLE1BQW5CO0FBTG9DLE9BQWxCLENBQXpCO0FBUUEsVUFBSTtBQUFFLFFBQUE7QUFBRixVQUFxQixLQUF6Qjs7QUFFQSxVQUFJLGNBQUosRUFBb0I7QUFDbEIsUUFBQSxjQUFjLEdBQUcsK0NBQ1osY0FEWSxFQUFqQjtBQUdEOztBQUVELDZDQUNLLGFBREw7QUFFRSxTQUFDLEtBQUssQ0FBQyxVQUFQLG1DQUNLLEtBREw7QUFFRSxVQUFBLFFBRkY7QUFHRSxVQUFBLEtBQUssRUFBRSxnQkFIVDtBQUlFLFVBQUE7QUFKRjtBQUZGO0FBU0Q7O0FBQ0QsV0FBTyxhQUFQO0FBQ0QsR0FqQ2lCLEVBaUNmLEVBakNlLENBQWxCO0FBbUNBLFNBQU8sU0FBUDtBQUNEOztBQUVNLGVBQWUsVUFBZixDQUEwQixlQUExQixFQUEyQyxPQUEzQyxFQUFvRDtBQUN6RCxRQUFNLFFBQVEsR0FBRyxVQUFVLENBQUMsT0FBRCxFQUFVLE9BQVYsQ0FBM0I7QUFDQSxRQUFNLEtBQUssR0FBRyxNQUFNLDZCQUNqQixHQUFFLFFBQVMsWUFBVyxlQUFnQixFQURyQixFQUVsQjtBQUFFLElBQUEsTUFBTSxFQUFFLEtBQVY7QUFBaUIsSUFBQSxPQUFPLEVBQUU7QUFBMUIsR0FGa0IsRUFHbEI7QUFBRSxJQUFBLGdCQUFnQixFQUFFO0FBQXBCLEdBSGtCLENBQXBCO0FBS0EsU0FBTyxLQUFQO0FBQ0Q7O0FBRU0sZUFBZSxXQUFmLENBQTJCLE9BQTNCLEVBQW9DO0FBQ3pDLFFBQU0sU0FBUyxHQUFHLFVBQVUsQ0FBQyxRQUFELEVBQVcsT0FBWCxDQUE1QjtBQUNBLFFBQU0sTUFBTSxHQUFHLE1BQU0sNkJBQ25CLFNBRG1CLEVBRW5CO0FBQUUsSUFBQSxNQUFNLEVBQUUsS0FBVjtBQUFpQixJQUFBLE9BQU8sRUFBRTtBQUExQixHQUZtQixFQUduQjtBQUFFLElBQUEsZ0JBQWdCLEVBQUU7QUFBcEIsR0FIbUIsQ0FBckI7QUFLQSxRQUFNLGNBQWMsR0FBRyxDQUNyQix1Q0FBZ0MsT0FBaEMsQ0FEcUIsRUFFckIsR0FBRyxNQUFNLENBQUMsTUFBUCxDQUFlLEtBQUQsSUFBVztBQUMxQixXQUNFLFlBQVksQ0FBQyxnQkFBRCxFQUFtQixLQUFuQixFQUEwQixTQUExQixDQUFaLElBQ0EsRUFDRSx1Q0FBMEIsS0FBSyxDQUFDLE1BQWhDLEVBQXdDLE9BQXhDLEtBQ0Esd0NBQTJCLEtBQUssQ0FBQyxPQUFqQyxFQUEwQyxPQUExQyxDQUZGLENBRkY7QUFPRCxHQVJFLENBRmtCLENBQXZCO0FBWUEsU0FBTyxjQUFQO0FBQ0Q7O0FBRU0sZUFBZSx1QkFBZixDQUF1QyxPQUF2QyxFQUFnRDtBQUNyRCxRQUFNLHFCQUFxQixHQUFHLFVBQVUsQ0FBQyxvQkFBRCxFQUF1QixPQUF2QixDQUF4QztBQUNBLFFBQU0sV0FBVyxHQUFHLE1BQU0sNkJBQ3hCLHFCQUR3QixFQUV4QjtBQUFFLElBQUEsTUFBTSxFQUFFLEtBQVY7QUFBaUIsSUFBQSxPQUFPLEVBQUU7QUFBMUIsR0FGd0IsRUFHeEI7QUFBRSxJQUFBLGdCQUFnQixFQUFFO0FBQXBCLEdBSHdCLENBQTFCO0FBS0EsUUFBTSxtQkFBbUIsR0FBRyxFQUE1Qjs7QUFDQSxPQUFLLE1BQU0sTUFBWCxJQUFxQixXQUFyQixFQUFrQztBQUNoQyxRQUNFLFlBQVksQ0FDViw4QkFEVSxFQUVWLFdBQVcsQ0FBQyxNQUFELENBRkQsRUFHVixxQkFIVSxDQURkLEVBTUU7QUFDQSxNQUFBLG1CQUFtQixDQUFDLE1BQUQsQ0FBbkIsR0FBOEIsV0FBVyxDQUFDLE1BQUQsQ0FBekM7QUFDRDtBQUNGOztBQUNELFNBQU8sbUJBQVA7QUFDRDs7QUFFTSxlQUFlLGNBQWYsQ0FBOEIsT0FBOUIsRUFBdUM7QUFDNUMsUUFBTSxZQUFZLEdBQUcsVUFBVSxDQUFDLFdBQUQsRUFBYyxPQUFkLENBQS9CO0FBQ0EsUUFBTSxRQUFRLEdBQUcsTUFBTSw2QkFDckIsWUFEcUIsRUFFckI7QUFBRSxJQUFBLE1BQU0sRUFBRSxLQUFWO0FBQWlCLElBQUEsT0FBTyxFQUFFO0FBQTFCLEdBRnFCLEVBR3JCO0FBQUUsSUFBQSxnQkFBZ0IsRUFBRTtBQUFwQixHQUhxQixDQUF2QjtBQUtBLFFBQU0sWUFBWSxHQUFHLFFBQVEsQ0FBQyxNQUFULENBQWdCLENBQUMsYUFBRCxFQUFnQixLQUFoQixFQUF1QixLQUF2QixLQUFpQztBQUNwRSxRQUFJLFlBQVksQ0FBQyxvQkFBRCxFQUF1QixLQUF2QixFQUE4QixZQUE5QixDQUFoQixFQUE2RDtBQUMzRCw2Q0FBWSxhQUFaO0FBQTJCLFNBQUMsS0FBSyxDQUFDLE9BQVAsR0FBaUI7QUFBRSxVQUFBLEtBQUssRUFBRSxNQUFNLENBQUMsS0FBRDtBQUFmO0FBQTVDO0FBQ0Q7O0FBQ0QsV0FBTyxhQUFQO0FBQ0QsR0FMb0IsRUFLbEIsRUFMa0IsQ0FBckI7QUFNQSxTQUFPLFlBQVA7QUFDRDs7QUFFTSxlQUFlLHNCQUFmLEdBQXdDO0FBQzdDLFFBQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxHQUFSLENBQVksa0JBQVosR0FDakIsZ0NBRGlCLEdBRWpCLDRCQUZKO0FBR0EsUUFBTSxRQUFRLEdBQUcsTUFBTSw2QkFDcEIsR0FBRSxZQUFhLGVBREssRUFFckI7QUFBRSxJQUFBLE1BQU0sRUFBRSxLQUFWO0FBQWlCLElBQUEsT0FBTyxFQUFFO0FBQTFCLEdBRnFCLEVBR3JCO0FBQUUsSUFBQSxnQkFBZ0IsRUFBRTtBQUFwQixHQUhxQixDQUF2QjtBQUtBLFNBQU8sUUFBUDtBQUNEOztBQUVNLGVBQWUsZUFBZixDQUErQixPQUEvQixFQUF3QztBQUFBOztBQUM3QyxRQUFNLEtBQUssR0FBSSxzQkFBcUIsT0FBUSxvQkFBNUM7QUFFQSxRQUFNLE1BQU0sR0FBRyxNQUFNLDZCQUNsQixnRUFBK0QsS0FBTSxFQURuRCxFQUVuQjtBQUFFLElBQUEsTUFBTSxFQUFFO0FBQVYsR0FGbUIsRUFHbkI7QUFBRSxJQUFBLGdCQUFnQixFQUFFO0FBQXBCLEdBSG1CLENBQXJCO0FBS0EsU0FBTyxNQUFNLHdCQUFJLE1BQU0sQ0FBQyxPQUFELENBQVYsb0RBQUksZ0JBQWlCLEdBQXJCLENBQWI7QUFDRDs7QUFFTSxlQUFlLGlCQUFmLENBQWlDLE9BQWpDLEVBQTBDLFdBQTFDLEVBQXVEO0FBQzVELFFBQU0sYUFBYSxHQUFHLE1BQU0sQ0FBQyxHQUFQLENBQVcsUUFBWCxDQUFvQiw4QkFBcEIsRUFBeUIsRUFBekIsQ0FBNEIsT0FBNUIsQ0FBdEI7QUFDQSxRQUFNLG1CQUFtQixHQUFHLGFBQWEsR0FDckMsYUFBYSxDQUFDLFNBQWQsQ0FBd0IsV0FBeEIsQ0FEcUMsR0FFckMsT0FBTyxDQUFDLE9BQVIsRUFGSjtBQUdBLFFBQU0sVUFBVSxHQUFHLE1BQU0sbUJBQXpCO0FBQ0EsU0FBTyxVQUFQO0FBQ0Q7O0FBRU0sZUFBZSxtQkFBZixDQUFtQyxPQUFuQyxFQUE0QztBQUNqRCxRQUFNLFlBQVksR0FBRyxVQUFVLENBQUMsV0FBRCxFQUFjLE9BQWQsQ0FBL0I7QUFDQSxRQUFNLFFBQVEsR0FBRyxNQUFNLDZCQUNyQixZQURxQixFQUVyQjtBQUFFLElBQUEsTUFBTSxFQUFFLEtBQVY7QUFBaUIsSUFBQSxPQUFPLEVBQUU7QUFBMUIsR0FGcUIsRUFHckI7QUFBRSxJQUFBLGdCQUFnQixFQUFFO0FBQXBCLEdBSHFCLENBQXZCO0FBS0EsUUFBTSxlQUFlLEdBQUcsWUFBWSxDQUNsQyx3QkFEa0MsRUFFbEMsUUFGa0MsRUFHbEMsWUFIa0MsQ0FBcEM7O0FBTUEsTUFBSSxDQUFDLGVBQUwsRUFBc0I7QUFDcEIsVUFBTSxJQUFJLEtBQUosQ0FBVyxHQUFFLFlBQWEsc0JBQTFCLENBQU47QUFDRDs7QUFFRCxRQUFNO0FBQ0osSUFBQSxZQUFZLEVBQUUsT0FEVjtBQUVKLElBQUEsZUFBZSxFQUFFLE9BRmI7QUFHSixJQUFBLFlBQVksRUFBRTtBQUhWLE1BSUYsUUFKSjtBQU1BLFNBQU87QUFDTCxJQUFBLE9BREs7QUFFTCxJQUFBLE9BRks7QUFHTCxJQUFBO0FBSEssR0FBUDtBQUtEOztBQUVNLE1BQU0seUJBQXlCLEdBQUcsQ0FBQztBQUN4QyxFQUFBLE9BRHdDO0FBRXhDLEVBQUEsZUFGd0M7QUFHeEMsRUFBQSxjQUh3QztBQUl4QyxFQUFBLG9CQUp3QztBQUt4QyxFQUFBO0FBTHdDLENBQUQsS0FNbkM7QUFDSixRQUFNLFdBQVcsR0FBRywrQkFBYSxXQUFiLENBQXBCO0FBQ0EsUUFBTSxNQUFNLEdBQUcscUNBQW1CO0FBQ2hDLElBQUEsS0FBSyxFQUFFLFdBRHlCO0FBRWhDLElBQUEsY0FBYyxFQUFFLG1CQUZnQjtBQUdoQyxJQUFBLGdCQUFnQixFQUFFO0FBSGMsR0FBbkIsQ0FBZjtBQUtBLFFBQU0sY0FBYyxHQUFHLHFDQUFtQjtBQUN4QyxJQUFBLEtBQUssRUFBRSxXQURpQztBQUV4QyxJQUFBLFVBQVUsRUFBRSxlQUY0QjtBQUd4QyxJQUFBLGNBSHdDO0FBSXhDLElBQUEsZ0JBQWdCLEVBQUU7QUFKc0IsR0FBbkIsQ0FBdkI7QUFNQSxRQUFNLG1CQUFtQixHQUFHLCtCQUFlLGNBQWYsRUFBK0IsZUFBL0IsQ0FBNUI7QUFDQSxRQUFNLHdCQUF3QixHQUM1QixvQkFBb0IsSUFBSSx1Q0FBZ0MsT0FBaEMsRUFBeUMsTUFEbkU7QUFFQSxTQUFPO0FBQ0wsSUFBQSxTQUFTLEVBQUUsbUJBRE47QUFFTCxJQUFBLFFBQVEsRUFBRyxHQUFFLE1BQU8sSUFBRyx3QkFBeUI7QUFGM0MsR0FBUDtBQUlELENBMUJNOzs7O0FBNEJBLFNBQVMsZ0NBQVQsQ0FBMEM7QUFDL0MsRUFBQSxRQUQrQztBQUUvQyxFQUFBLFVBRitDO0FBRy9DLEVBQUEsUUFIK0M7QUFJL0MsRUFBQSxlQUorQztBQUsvQyxFQUFBLGNBTCtDO0FBTS9DLEVBQUEsVUFOK0M7QUFPL0MsRUFBQSxZQVArQztBQVEvQyxFQUFBLFlBUitDO0FBUy9DLEVBQUEsT0FUK0M7QUFVL0MsRUFBQTtBQVYrQyxDQUExQyxFQVdKO0FBQ0QsUUFBTSwyQkFBMkIsR0FBRyxJQUFJLGtCQUFKLENBQWMsUUFBUSxJQUFJLEtBQTFCLEVBQWlDLEVBQWpDLEVBQ2pDLElBRGlDLENBQzVCLFVBQVUsSUFBSSxLQURjLEVBQ1AsRUFETyxFQUVqQyxRQUZpQyxDQUV4QixFQUZ3QixDQUFwQztBQUdBLFFBQU0sZ0JBQWdCLEdBQUcsd0JBQWEsMkJBQWIsRUFBMEMsUUFBMUMsQ0FBekI7QUFFQSxRQUFNLFNBQVMsR0FBRyxJQUFJLGtCQUFKLENBQWMsVUFBZCxFQUEwQixFQUExQixFQUNmLEtBRGUsQ0FFZCx1Q0FBMEIsWUFBMUIsRUFBd0MsT0FBeEMsSUFBbUQsWUFBbkQsR0FBa0UsQ0FGcEQsRUFHZCxFQUhjLEVBS2YsUUFMZSxDQUtOLEVBTE0sQ0FBbEI7QUFPQSxRQUFNLFlBQVksR0FBRyxJQUFJLGtCQUFKLENBQWMsZ0JBQWQsRUFBZ0MsRUFBaEMsRUFDbEIsSUFEa0IsQ0FDYixTQURhLEVBQ0YsRUFERSxFQUVsQixRQUZrQixDQUVULEVBRlMsQ0FBckI7QUFJQSxRQUFNLE1BQU0sR0FBRyxxQ0FBbUI7QUFDaEMsSUFBQSxLQUFLLEVBQUUsWUFEeUI7QUFFaEMsSUFBQSxjQUFjLEVBQUUsS0FGZ0I7QUFHaEMsSUFBQSxnQkFBZ0IsRUFBRTtBQUhjLEdBQW5CLENBQWY7QUFLQSxRQUFNLGNBQWMsR0FBRyxxQ0FBbUI7QUFDeEMsSUFBQSxLQUFLLEVBQUUsWUFEaUM7QUFFeEMsSUFBQSxVQUFVLEVBQUUsZUFGNEI7QUFHeEMsSUFBQSxjQUh3QztBQUl4QyxJQUFBLGdCQUFnQixFQUFFO0FBSnNCLEdBQW5CLENBQXZCO0FBTUEsUUFBTSxtQkFBbUIsR0FBRywrQkFBZSxjQUFmLEVBQStCLGVBQS9CLENBQTVCO0FBRUEsUUFBTSx3QkFBd0IsR0FDNUIsb0JBQW9CLElBQUksdUNBQWdDLE9BQWhDLEVBQXlDLE1BRG5FO0FBR0EsU0FBTztBQUNMLElBQUEsY0FESztBQUVMLElBQUEsU0FBUyxFQUFFLE1BRk47QUFHTCxJQUFBLFNBQVMsRUFBRSxtQkFITjtBQUlMLElBQUEsUUFBUSxFQUFHLEdBQUUsTUFBTyxJQUFHLHdCQUF5QixFQUozQztBQUtMLElBQUE7QUFMSyxHQUFQO0FBT0Q7O0FBRU0sU0FBUyxzQkFBVCxDQUNMLE1BREssRUFFTCxRQUZLLEVBR0wsY0FISyxFQUlMLGVBSkssRUFLTCxVQUxLLEVBTUwsb0JBTkssRUFPTCxPQVBLLEVBUUwsNEJBUkssRUFTTCxvQkFUSyxFQVVMO0FBQ0EsU0FBTyxNQUFNLENBQUMsTUFBUCxDQUFjLE1BQWQsRUFBc0IsR0FBdEIsQ0FBMkIsS0FBRCxJQUFXO0FBQzFDLFVBQU07QUFDSixNQUFBLGlCQUFpQixHQUFHLENBRGhCO0FBRUosTUFBQSxZQUFZLEdBQUcsQ0FGWDtBQUdKLE1BQUEsZUFISTtBQUlKLE1BQUEsb0JBSkk7QUFLSixNQUFBLFFBTEk7QUFNSixNQUFBLE9BTkk7QUFPSixNQUFBLFVBUEk7QUFRSixNQUFBLHFCQVJJO0FBU0osTUFBQSxVQVRJO0FBVUosTUFBQSxHQVZJO0FBV0osTUFBQTtBQVhJLFFBWUYsS0FaSjtBQWFBLFVBQU0sV0FBVyxHQUFHLGdDQUNsQixZQURrQixFQUVsQixlQUFlLENBQUMsUUFGRSxFQUdsQixRQUhrQixDQUdULEVBSFMsQ0FBcEI7QUFJQSxVQUFNLGdCQUFnQixHQUFHLGdDQUN2QixpQkFEdUIsRUFFdkIsb0JBQW9CLENBQUMsUUFGRSxFQUd2QixXQUh1QixDQUdYLENBSFcsQ0FBekI7QUFLQSxRQUFJLFNBQVMsR0FBRyxJQUFoQjtBQUNBLFFBQUksUUFBUSxHQUFHLElBQWY7QUFDQSxRQUFJLGNBQWMsR0FBRyxJQUFyQjtBQUNBLFFBQUksU0FBUyxHQUFHLElBQWhCO0FBRUEsS0FBQztBQUNDLE1BQUEsU0FERDtBQUVDLE1BQUEsUUFGRDtBQUdDLE1BQUEsY0FIRDtBQUlDLE1BQUE7QUFKRCxRQUtHLGdDQUFnQyxDQUFDO0FBQ25DLE1BQUEsUUFBUSxFQUFFLHFCQUFxQixJQUFJLCtCQUFhLFVBQVUsSUFBSSxNQUEzQixDQURBO0FBRW5DLE1BQUEsVUFGbUM7QUFHbkMsTUFBQSxRQUhtQztBQUluQyxNQUFBLGVBSm1DO0FBS25DLE1BQUEsY0FMbUM7QUFNbkMsTUFBQSxVQUFVLEVBQUUsS0FBSyxDQUFDLEtBTmlCO0FBT25DLE1BQUEsWUFBWSxFQUFFLGVBQWUsQ0FBQyxNQVBLO0FBUW5DLE1BQUEsWUFSbUM7QUFTbkMsTUFBQTtBQVRtQyxLQUFELENBTHBDOztBQWlCQSxRQUFJLDRCQUFKLEVBQWtDO0FBQ2hDLE9BQUM7QUFBRSxRQUFBLFNBQUY7QUFBYSxRQUFBO0FBQWIsVUFBMEIseUJBQXlCLENBQUM7QUFDbkQsUUFBQSxPQURtRDtBQUVuRCxRQUFBLGVBRm1EO0FBR25ELFFBQUEsY0FIbUQ7QUFJbkQsUUFBQSxvQkFKbUQ7QUFLbkQsUUFBQSxvQkFBb0IsRUFBRSw0QkFBNEIsQ0FBQztBQUxBLE9BQUQsQ0FBcEQ7QUFPRDs7QUFFRCxVQUFNLGtCQUFrQixHQUFHLElBQUksa0JBQUosQ0FBYyxNQUFNLFFBQXBCLEVBQThCLEdBQTlCLENBQWtDLEdBQWxDLENBQTNCO0FBQ0EsVUFBTSxxQkFBcUIsR0FBRyxJQUFJLGtCQUFKLENBQWMsZ0JBQWQsRUFDM0IsS0FEMkIsQ0FDckIsa0JBRHFCLEVBRTNCLE9BRjJCLENBRW5CLENBRm1CLENBQTlCO0FBSUEsVUFBTSxtQkFBbUIsR0FDdkIsb0JBQW9CLENBQUMsb0JBQW9CLENBQUMsT0FBdEIsQ0FEdEI7QUFFQSxVQUFNLGVBQWUsR0FBRyx1Q0FDdEIsb0JBQW9CLENBQUMsTUFEQyxFQUV0QixPQUZzQixJQUlwQixnQ0FBZ0IsaUJBQWhCLEVBQW1DLG9CQUFvQixDQUFDLFFBQXhELEVBQWtFLEtBQWxFLENBQ0UsU0FERixFQUVFLEVBRkYsQ0FKb0IsR0FRcEIsSUFBSSxrQkFBSixDQUFjLG1CQUFtQixJQUFJLENBQXJDLEVBQXdDLEVBQXhDLEVBQ0csS0FESCxDQUVJLGdDQUFnQixpQkFBaEIsRUFBbUMsb0JBQW9CLENBQUMsUUFBeEQsQ0FGSixFQUdJLEVBSEosRUFLRyxLQUxILENBS1MsU0FMVCxFQUtvQixFQUxwQixDQVJKO0FBZUEsUUFBSSxrQkFBSjtBQUNBLFFBQUksZ0JBQWdCLEdBQUcsUUFBdkI7O0FBRUEsUUFBSSxPQUFPLEtBQUssS0FBaEIsRUFBdUI7QUFDckIsTUFBQSxrQkFBa0IsR0FBRyxnQkFBckI7QUFDRCxLQUZELE1BRU8sSUFBSSxPQUFPLEtBQUssS0FBaEIsRUFBdUI7QUFDNUIsTUFBQSxrQkFBa0IsR0FBRyx5QkFBckI7QUFDQSxNQUFBLGdCQUFnQixHQUFHLENBQW5CO0FBQ0QsS0FITSxNQUdBLElBQUksT0FBTyxLQUFLLEtBQWhCLEVBQXVCO0FBQzVCLE1BQUEsa0JBQWtCLEdBQUcsMkJBQXJCO0FBQ0QsS0FGTSxNQUVBLElBQUksT0FBTyxLQUFLLFVBQWhCLEVBQTRCO0FBQ2pDLE1BQUEsa0JBQWtCLEdBQUcsb0JBQXJCO0FBQ0QsS0FGTSxNQUVBO0FBQ0wsTUFBQSxrQkFBa0IsR0FBRyxhQUFyQjtBQUNEOztBQUVELFdBQU87QUFDTCxNQUFBLEtBQUssRUFBRSxVQURGO0FBRUwsTUFBQSxlQUFlLEVBQUcsR0FBRSxnQkFBaUIsSUFBRyxvQkFBb0IsQ0FBQyxNQUFPLEVBRi9EO0FBR0wsTUFBQSx3QkFBd0IsRUFBRSxvQkFBb0IsQ0FBQyxRQUgxQztBQUlMLE1BQUEsc0JBQXNCLEVBQUUsb0JBQW9CLENBQUMsTUFKeEM7QUFLTCxNQUFBLHFCQUFxQixFQUFFLDBCQUEwQixDQUFDLGdCQUFELENBTDVDO0FBTUwsTUFBQSxrQkFBa0IsRUFBRSxvQkFBb0IsQ0FBQyxPQU5wQztBQU9MLE1BQUEsV0FBVyxFQUFFLEtBQUssQ0FBQyxXQVBkO0FBUUwsTUFBQSxrQkFSSztBQVNMLE1BQUEsUUFUSztBQVVMLE1BQUEsbUJBQW1CLEVBQUcsR0FBRSxRQUFTLEtBQUksU0FBVSxHQVYxQztBQVdMLE1BQUEsV0FBVyxFQUFFLFNBWFI7QUFZTCxNQUFBLFdBQVcsRUFBRSxPQVpSO0FBYUwsTUFBQSxjQWJLO0FBY0wsTUFBQSxRQUFRLEVBQUUsZ0JBZEw7QUFlTCxNQUFBLG1CQUFtQixFQUFFLGVBQWUsQ0FBQyxRQWZoQztBQWdCTCxNQUFBLGlCQUFpQixFQUFFLGVBQWUsQ0FBQyxNQWhCOUI7QUFpQkwsTUFBQSxnQkFBZ0IsRUFBRSxXQWpCYjtBQWtCTCxNQUFBLGtCQUFrQixFQUFFLGVBQWUsQ0FBQyxPQWxCL0I7QUFtQkwsTUFBQSxlQW5CSztBQW9CTCxNQUFBLHFCQXBCSztBQXFCTCxNQUFBLFdBQVcsRUFBRTtBQXJCUixLQUFQO0FBdUJELEdBcEhNLENBQVA7QUFxSEQ7O0FBRU0sU0FBUyxnQ0FBVCxDQUNMLFdBREssRUFFTCxNQUZLLEVBR0wsWUFISyxFQUlMLGNBSkssRUFLTCxhQUxLLEVBTUwsY0FOSyxFQU9MLE9BUEssRUFRTDtBQUFBOztBQUNBLFFBQU0sU0FBUyxHQUFHLE1BQUgsYUFBRyxNQUFILHVCQUFHLE1BQU0sQ0FBRSxTQUExQjtBQUNBLFFBQU0sNkJBQTZCLEdBQ2pDLENBQUEsTUFBTSxTQUFOLElBQUEsTUFBTSxXQUFOLGlDQUFBLE1BQU0sQ0FBRSxTQUFSLHdFQUFtQixJQUFuQixNQUE0Qix3Q0FBMkIsVUFEekQ7O0FBRUEsTUFBSSx1Q0FBMEIsV0FBMUIsRUFBdUMsT0FBdkMsQ0FBSixFQUFxRDtBQUNuRCxRQUNFLENBQUMsU0FBRCxJQUNBLENBQUMsTUFERCxJQUVBLENBQUMsTUFBTSxDQUFDLGFBRlIsSUFHQSxDQUFDLE1BQU0sQ0FBQyxZQUpWLEVBS0U7QUFDQSxhQUFPLElBQVA7QUFDRDs7QUFFRCxRQUFJLGlCQUFpQixHQUFHLEtBQXhCOztBQUNBLFFBQUksY0FBYyxJQUFJLGNBQWMsQ0FBQyxTQUFyQyxFQUFnRDtBQUM5QyxNQUFBLGlCQUFpQixHQUFHLHdCQUNsQixjQUFjLENBQUMsU0FBZixDQUF5QixPQURQLEVBRWxCLDZCQUE2QixHQUN6QixjQUFjLENBQUMsU0FBZixDQUF5QixpQkFEQSxDQUNrQjtBQURsQixRQUV6QixjQUFjLENBQUMsUUFBZixDQUF3QixRQUpWLENBQXBCO0FBTUQ7O0FBRUQsVUFBTSxPQUFPLEdBQUcsd0JBQ2QsU0FBUyxDQUFDLE9BREksRUFFZCw2QkFBNkIsR0FDekIsU0FBUyxDQUFDLGlCQURlLEdBRXpCLE1BQU0sQ0FBQyxRQUFQLENBQWdCLFFBSk4sQ0FBaEI7QUFNQSxVQUFNLFlBQVksR0FBRyxJQUFJLGtCQUFKLENBQWMsT0FBZCxFQUF1QixFQUF2QixFQUNsQixJQURrQixDQUNiLGlCQURhLEVBQ00sRUFETixFQUVsQixRQUZrQixDQUVULEVBRlMsQ0FBckI7QUFJQSxVQUFNLHVCQUF1QixHQUFHLG9DQUM5QixNQUFNLENBQUMsWUFEdUIsRUFFOUIsWUFGOEIsRUFHOUI7QUFDRSxNQUFBLEtBQUssRUFBRSxFQURUO0FBRUUsTUFBQSxLQUFLLEVBQUUsRUFGVDtBQUdFLE1BQUEsYUFBYSxFQUFFO0FBSGpCLEtBSDhCLENBQWhDO0FBVUEsVUFBTSxXQUFXLEdBQUcsb0NBQ2xCLE1BQU0sQ0FBQyxhQURXLEVBRWxCLHVCQUZrQixFQUdsQjtBQUNFLE1BQUEsS0FBSyxFQUFFLEVBRFQ7QUFFRSxNQUFBLEtBQUssRUFBRSxFQUZUO0FBR0UsTUFBQSxnQkFBZ0IsRUFBRSxLQUhwQjtBQUlFLE1BQUEsY0FBYyxFQUFFLEtBSmxCO0FBS0UsTUFBQSxhQUFhLEVBQUUsS0FMakI7QUFNRSxNQUFBLGdCQUFnQixFQUFFO0FBTnBCLEtBSGtCLENBQXBCO0FBWUEsV0FBTyxXQUFQO0FBQ0Q7O0FBQ0QsUUFBTSxhQUFhLEdBQUcsU0FBSCxhQUFHLFNBQUgsdUJBQUcsU0FBUyxDQUFFLElBQWpDOztBQUNBLE1BQUksYUFBYSxJQUFJLENBQUEsU0FBUyxTQUFULElBQUEsU0FBUyxXQUFULFlBQUEsU0FBUyxDQUFFLE1BQVgsTUFBc0IsS0FBM0MsRUFBa0Q7QUFDaEQsVUFBTSxnQkFBZ0IsR0FBRyxhQUFhLENBQUMsSUFBZCxDQUFvQixZQUFELElBQWtCO0FBQzVELFlBQU0sZUFBZSxHQUNuQixZQUFZLENBQUMsTUFBYixJQUNBLFlBQVksQ0FBQyxNQUFiLENBQW9CLENBQXBCLE1BQTJCLDZCQUY3QjtBQUdBLFlBQU0sd0JBQXdCLEdBQUcsWUFBWSxDQUFDLE9BQWIsS0FBeUIsWUFBMUQ7QUFDQSxZQUFNLDBCQUEwQixHQUM5QixZQUFZLENBQUMsTUFBYixJQUNBLFlBQVksQ0FBQyxNQUFiLENBQW9CLENBQXBCLENBREEsSUFFQSxZQUFZLENBQUMsTUFBYixDQUFvQixDQUFwQixFQUF1QixLQUF2QixDQUE2QixjQUFjLENBQUMsS0FBZixDQUFxQixDQUFyQixDQUE3QixDQUhGO0FBSUEsYUFDRSxlQUFlLElBQ2Ysd0JBREEsSUFFQSwwQkFIRjtBQUtELEtBZHdCLENBQXpCO0FBZUEsV0FBTyxnQkFBZ0IsR0FDbkIsMkNBQ0UsZ0NBQWdCLGdCQUFnQixDQUFDLElBQWpDLEVBQXVDLGFBQXZDLEVBQXNELFFBQXRELENBQStELEVBQS9ELENBREYsRUFFRSxDQUZGLENBRG1CLEdBS25CLEVBTEo7QUFNRDs7QUFDRCxTQUFPLElBQVA7QUFDRDs7QUFFTSxTQUFTLDBCQUFULENBQW9DLGlCQUFwQyxFQUF1RDtBQUM1RCxNQUFJLGVBQWUsR0FBRywyQ0FBZ0MsaUJBQWhDLEVBQW1ELEVBQW5ELENBQXRCOztBQUNBLE1BQUksZUFBZSxDQUFDLEtBQWhCLENBQXNCLFFBQXRCLENBQUosRUFBcUM7QUFDbkMsSUFBQSxlQUFlLEdBQUcsSUFBSSxrQkFBSixDQUFjLGVBQWQsRUFBK0IsT0FBL0IsRUFBbEI7QUFDRDs7QUFDRCxTQUFPLGVBQVA7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxNQUFNLHNCQUFzQixHQUFHLENBQ3BDLGVBRG9DLEVBRXBDLE9BQU8sR0FBRyx5QkFGMEIsS0FHakM7QUFDSCxNQUFJLENBQUMsZUFBRCxJQUFvQixDQUFDLGtDQUEyQixPQUEzQixDQUF6QixFQUE4RDtBQUM1RCxXQUFPLEtBQVA7QUFDRDs7QUFDRCxTQUFPLGtDQUEyQixPQUEzQixFQUFvQyxJQUFwQyxFQUNMO0FBQ0E7QUFDQyxFQUFBLHNCQUFELElBQ0UsZUFBZSxDQUFDLFdBQWhCLE9BQWtDLHNCQUFzQixDQUFDLFdBQXZCLEVBSi9CLENBQVA7QUFNRCxDQWJNO0FBZVA7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBQ08sTUFBTSx1QkFBdUIsR0FBSSxPQUFELElBQWE7QUFDbEQsVUFBUSxPQUFSO0FBQ0UsU0FBSyx5QkFBTDtBQUNFLGFBQU8sZUFBUDs7QUFDRixTQUFLLHFCQUFMO0FBQ0UsYUFBTyxVQUFQOztBQUNGLFNBQUsseUJBQUw7QUFDRSxhQUFPLGNBQVA7O0FBQ0YsU0FBSyx5QkFBTDtBQUNFLGFBQU8sY0FBUDs7QUFDRixTQUFLLDJCQUFMO0FBQ0UsYUFBTyxnQkFBUDs7QUFDRjtBQUNFLGFBQU8sRUFBUDtBQVpKO0FBY0QsQ0FmTTtBQWlCUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFDTyxNQUFNLDBCQUEwQixHQUFHLENBQUMsaUJBQWlCLEdBQUcsRUFBckIsRUFBeUIsT0FBekIsS0FBcUM7QUFDN0UsUUFBTSxXQUFXLEdBQUcsdUJBQXVCLENBQUMsT0FBRCxDQUEzQyxDQUQ2RSxDQUU3RTs7QUFDQSxNQUFJLENBQUMsMkJBQUQsRUFBcUIseUJBQXJCLEVBQXVDLFFBQXZDLENBQWdELE9BQWhELENBQUosRUFBOEQ7QUFDNUQsV0FBTztBQUNMLE1BQUEsa0JBQWtCLEVBQUU7QUFEZixLQUFQO0FBR0QsR0FQNEUsQ0FRN0U7OztBQUNBLE1BQUksQ0FBQyxpQkFBaUIsQ0FBQyxXQUFELENBQXRCLEVBQXFDO0FBQ25DLFdBQU87QUFDTCxNQUFBLGtCQUFrQixFQUFFO0FBRGYsS0FBUDtBQUdEOztBQUNELFFBQU0seUJBQXlCLEdBQzdCLGlCQUFpQixDQUFDLFdBQUQsQ0FBakIsQ0FBK0IsZ0JBRGpDOztBQUVBLE1BQUkseUJBQUosRUFBK0I7QUFDN0IsV0FBTztBQUNMLE1BQUEsa0JBQWtCLEVBQUU7QUFEZixLQUFQO0FBR0Q7O0FBQ0QsU0FBTztBQUNMLElBQUEsa0JBQWtCLEVBQUUsaUJBQWlCLENBQUMsV0FBRCxDQUFqQixDQUErQjtBQUQ5QyxHQUFQO0FBR0QsQ0F4Qk07QUEwQlA7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBQ08sTUFBTSxhQUFhLEdBQUksS0FBRCxJQUFXO0FBQUE7O0FBQ3RDLE1BQUksQ0FBQyxLQUFELElBQVUsSUFBSSxDQUFDLEtBQUwsQ0FBVyxLQUFYLE1BQXNCLEtBQXBDLEVBQTJDO0FBQ3pDLFdBQU8sQ0FBUDtBQUNEOztBQUNELFNBQU8sMEJBQUEsS0FBSyxDQUFDLFFBQU4sR0FBaUIsS0FBakIsQ0FBdUIsR0FBdkIsRUFBNEIsQ0FBNUIsaUZBQWdDLE1BQWhDLEtBQTBDLENBQWpEO0FBQ0QsQ0FMTTs7OztBQU9BLE1BQU0sNEJBQTRCLEdBQUksa0JBQUQsSUFBd0I7QUFDbEUsTUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFQLENBQWlCLGtCQUFqQixDQUFMLEVBQTJDO0FBQ3pDLFdBQU8sTUFBUDtBQUNEOztBQUNELFFBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFMLENBQVcsa0JBQWtCLEdBQUcsRUFBaEMsQ0FBaEI7QUFDQSxRQUFNLE9BQU8sR0FBRyxrQkFBa0IsR0FBRyxFQUFyQztBQUNBLFNBQVEsR0FBRSxPQUFRLElBQUcsT0FBTyxDQUFDLFFBQVIsR0FBbUIsUUFBbkIsQ0FBNEIsQ0FBNUIsRUFBK0IsR0FBL0IsQ0FBb0MsRUFBekQ7QUFDRCxDQVBNOzs7QUFTQSxNQUFNLGFBQWEsR0FBRyxDQUFDLGFBQUQsRUFBZ0Isa0JBQWhCLENBQXRCOztBQUVQLE1BQU0seUJBQXlCLEdBQUc7QUFDaEMsRUFBQSxXQUFXLEVBQUUsaURBRG1CO0FBRWhDLEVBQUEsZ0JBQWdCLEVBQUU7QUFGYyxDQUFsQzs7QUFLTyxNQUFNLDhCQUE4QixHQUFJLFNBQUQsSUFBZTtBQUMzRCxTQUNFLHlCQUF5QixDQUFDLFNBQUQsQ0FBekIsSUFDQSx5QkFBeUIsQ0FBQyxXQUY1QjtBQUlELENBTE07Ozs7QUFPQSxNQUFNLDJCQUEyQixHQUFJLFlBQUQsSUFBa0I7QUFDM0QsUUFBTSxTQUFTLEdBQUcsWUFBWSxDQUFDLEtBQWIsQ0FBbUIsRUFBbkIsQ0FBbEI7QUFDQSxTQUFPLElBQUksQ0FBQyxLQUFMLENBQVcsU0FBUyxDQUFDLElBQVYsRUFBWCxDQUFQO0FBQ0QsQ0FITTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2NUJBLE1BQU0sNEJBQTRCLEdBQUcsbUJBQXJDOztBQUNBLE1BQU0sMkJBQTJCLEdBQUcsZ0JBQXBDOztBQUNBLE1BQU0scUJBQXFCLEdBQUcsa0JBQTlCOztBQUNBLE1BQU0saUNBQWlDLEdBQUcsNEJBQTFDOztBQUNBLE1BQU0sK0JBQStCLEdBQUcseUJBQXhDOztBQUNBLE1BQU0saUNBQWlDLEdBQUcscUJBQTFDOztBQUNBLE1BQU0sNkJBQTZCLEdBQUcsbUJBQXRDOztBQUNBLE1BQU0sMEJBQTBCLEdBQUcsaUJBQW5DOztBQUNBLE1BQU0sb0NBQW9DLEdBQUcseUJBQTdDOztBQUNBLE1BQU0sa0JBQWtCLEdBQUcsa0JBQTNCOzs7Ozs7Ozs7Ozs7OztBQ1RQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3gvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyQkE7Ozs7OztBQUtPLE1BQU0sbUJBQW1CLEdBQUc7QUFDakMsR0FBQyxrQ0FBcUIsVUFBdEIsR0FBbUMsSUFERjtBQUVqQyxHQUFDLGtDQUFxQixRQUF0QixHQUFpQyxJQUZBO0FBR2pDLEdBQUMsa0NBQXFCLFNBQXRCLEdBQWtDLElBSEQ7QUFJakMsR0FBQyxrQ0FBcUIsT0FBdEIsR0FBZ0M7QUFKQyxDQUE1Qjs7O0FBT0EsTUFBTSxvQkFBb0IsbUNBQzVCLG1CQUQ0QjtBQUUvQixHQUFDLGtDQUFxQixTQUF0QixHQUFrQztBQUZILEVBQTFCOzs7QUFLQSxNQUFNLG1CQUFtQixHQUFHO0FBQ2pDLEdBQUMsK0JBQWtCLG9CQUFuQixHQUEwQyxJQURUO0FBRWpDLEdBQUMsK0JBQWtCLHFCQUFuQixHQUEyQyxJQUZWO0FBR2pDLEdBQUMsK0JBQWtCLDBCQUFuQixHQUFnRDtBQUhmLENBQTVCOztBQU1BLE1BQU0sK0JBQStCLEdBQUc7QUFDN0MsRUFBQSxVQUFVLEVBQUUsWUFEaUM7QUFFN0MsRUFBQSxNQUFNLEVBQUU7QUFGcUMsQ0FBeEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZCUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBUywwQkFBVCxDQUFvQyxPQUFwQyxFQUE2QyxPQUE3QyxFQUFzRDtBQUFBOztBQUMzRCxNQUFJLENBQUMsT0FBRCxJQUFZLENBQUMsT0FBakIsRUFBMEI7QUFDeEIsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQsU0FBTyxPQUFPLCtCQUFLLHVDQUFnQyxPQUFoQyxDQUFMLDBEQUFLLHNCQUEwQyxPQUEvQyxDQUFkO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxTQUFTLHlCQUFULENBQW1DLE1BQW5DLEVBQTJDLE9BQTNDLEVBQW9EO0FBQUE7O0FBQ3pELE1BQUksQ0FBQyxNQUFELElBQVcsQ0FBQyxPQUFoQixFQUF5QjtBQUN2QixXQUFPLEtBQVA7QUFDRDs7QUFFRCxTQUFPLE1BQU0sZ0NBQUssdUNBQWdDLE9BQWhDLENBQUwsMkRBQUssdUJBQTBDLE1BQS9DLENBQWI7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hDRDs7QUFDQTs7QUFTQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFnQkEsU0FBUyxZQUFULENBQXNCLFFBQVEsR0FBRyxHQUFqQyxFQUFzQyxRQUFRLEdBQUcsR0FBakQsRUFBc0Q7QUFDcEQsU0FBTyxvQ0FBbUIsUUFBbkIsRUFBNkIsUUFBN0IsRUFBdUM7QUFDNUMsSUFBQSxhQUFhLEVBQUUsS0FENkI7QUFFNUMsSUFBQSxnQkFBZ0IsRUFBRSxFQUYwQjtBQUc1QyxJQUFBLGNBQWMsRUFBRTtBQUg0QixHQUF2QyxDQUFQO0FBS0Q7O0FBRUQsU0FBUyxtQkFBVCxDQUE2QjtBQUMzQixFQUFBLE1BQU0sR0FBRyxLQURrQjtBQUUzQixFQUFBLE9BQU8sR0FBRyxLQUZpQjtBQUczQixFQUFBLGNBQWMsR0FBRyxDQUhVO0FBSTNCLEVBQUEsUUFBUSxHQUFHLEtBSmdCO0FBSzNCLEVBQUE7QUFMMkIsQ0FBN0IsRUFNRztBQUNELFFBQU0sV0FBVyxHQUFHLCtCQUFjLE1BQWQsRUFBc0IsUUFBdEIsRUFBZ0M7QUFDbEQsSUFBQSxLQUFLLEVBQUUsRUFEMkM7QUFFbEQsSUFBQSxLQUFLLEVBQUUsRUFGMkM7QUFHbEQsSUFBQSxhQUFhLEVBQUU7QUFIbUMsR0FBaEMsQ0FBcEI7QUFNQSxRQUFNLG1CQUFtQixHQUFHLCtCQUMxQjtBQUNFLElBQUEsS0FBSyxFQUFFLE9BRFQ7QUFFRSxJQUFBLGVBQWUsRUFBRSxLQUZuQjtBQUdFLElBQUEsWUFBWSxFQUFFLGVBSGhCO0FBSUUsSUFBQTtBQUpGLEdBRDBCLEVBTzFCO0FBQ0UsSUFBQSxLQUFLLEVBQUUsV0FEVDtBQUVFLElBQUEsZUFBZSxFQUFFLEtBRm5CO0FBR0UsSUFBQSxjQUhGO0FBSUUsSUFBQSxZQUFZLEVBQUU7QUFKaEIsR0FQMEIsQ0FBNUI7QUFlQSxTQUFPLG1CQUFQO0FBQ0Q7O0FBRUQsU0FBUyx3QkFBVCxDQUFrQztBQUFFLEVBQUEsTUFBTSxHQUFHLEtBQVg7QUFBa0IsRUFBQSxZQUFsQjtBQUFnQyxFQUFBO0FBQWhDLENBQWxDLEVBQThFO0FBQzVFLFFBQU0sV0FBVyxHQUFHLGdDQUFlLE1BQWYsRUFBdUI7QUFDekMsSUFBQSxlQUFlLEVBQUU7QUFEd0IsR0FBdkIsQ0FBcEI7QUFJQSxRQUFNLHdCQUF3QixHQUFHLCtCQUMvQjtBQUNFLElBQUEsS0FBSyxFQUFFLFlBRFQ7QUFFRSxJQUFBLGVBQWUsRUFBRTtBQUZuQixHQUQrQixFQUsvQjtBQUNFLElBQUEsS0FBSyxFQUFFLGdDQUFnQixXQUFoQixFQUE2QixRQUE3QjtBQURULEdBTCtCLENBQWpDO0FBVUEsU0FBTyx3QkFBUDtBQUNEOztBQUVELFNBQVMsWUFBVCxDQUNFLGtCQURGLEVBRUUsZ0JBRkYsRUFHRSxnQkFBZ0IsR0FBRyxHQUhyQixFQUlFO0FBQ0EsUUFBTSxhQUFhLEdBQUcsb0NBQW1CLGdCQUFuQixFQUFxQyxHQUFyQyxFQUEwQztBQUM5RCxJQUFBLGFBQWEsRUFBRSxLQUQrQztBQUU5RCxJQUFBLGdCQUFnQixFQUFFLEVBRjRDO0FBRzlELElBQUEsY0FBYyxFQUFFLEVBSDhDO0FBSTlELElBQUEsZ0JBQWdCLEVBQUU7QUFKNEMsR0FBMUMsQ0FBdEI7QUFNQSxRQUFNLGdCQUFnQixHQUFHLG9DQUN2QixrQkFEdUIsRUFFdkIsZ0JBRnVCLEVBR3ZCO0FBQ0UsSUFBQSxhQUFhLEVBQUUsS0FEakI7QUFFRSxJQUFBLGdCQUFnQixFQUFFLEVBRnBCO0FBR0UsSUFBQSxjQUFjLEVBQUUsRUFIbEI7QUFJRSxJQUFBLGdCQUFnQixFQUFFO0FBSnBCLEdBSHVCLENBQXpCLENBUEEsQ0FrQkE7O0FBQ0EsTUFDRSx1Q0FDRTtBQUFFLElBQUEsS0FBSyxFQUFFLGtCQUFUO0FBQTZCLElBQUEsZUFBZSxFQUFFO0FBQTlDLEdBREYsRUFFRTtBQUFFLElBQUEsS0FBSyxFQUFFLGFBQVQ7QUFBd0IsSUFBQSxlQUFlLEVBQUU7QUFBekMsR0FGRixDQURGLEVBS0U7QUFDQSxXQUFPLGtCQUFQO0FBQ0QsR0ExQkQsQ0EyQkE7OztBQUNBLE1BQ0Usb0NBQ0U7QUFBRSxJQUFBLEtBQUssRUFBRSxnQkFBVDtBQUEyQixJQUFBLGVBQWUsRUFBRTtBQUE1QyxHQURGLEVBRUU7QUFBRSxJQUFBLEtBQUssRUFBRSxhQUFUO0FBQXdCLElBQUEsZUFBZSxFQUFFO0FBQXpDLEdBRkYsQ0FERixFQUtFO0FBQ0EsV0FBTyxnQkFBUDtBQUNELEdBbkNELENBb0NBOzs7QUFDQSxTQUFPLGFBQVA7QUFDRDs7QUFFRCxTQUFTLHlCQUFULENBQW1DO0FBQ2pDLEVBQUEsU0FBUyxHQUFHLEtBRHFCO0FBRWpDLEVBQUEsTUFBTSxHQUFHLEtBRndCO0FBR2pDLEVBQUE7QUFIaUMsQ0FBbkMsRUFJRztBQUNELE1BQUksQ0FBQyxTQUFMLEVBQWdCO0FBQ2QsV0FBTyxTQUFQO0FBQ0Q7O0FBQ0QsU0FDRSwwQ0FDQSxLQUFLLENBQUMsU0FBTixDQUFnQixHQUFoQixDQUNHLElBREgsQ0FFSSx1QkFBSSxTQUFKLENBQ0UsQ0FBQyxTQUFELEVBQVksU0FBWixDQURGLEVBRUUsQ0FBQyxTQUFELEVBQVksd0JBQWEsTUFBYixDQUFaLENBRkYsQ0FGSixFQU1LLENBQUQsSUFBUSxLQUFJLENBQUMsQ0FBQyxRQUFGLENBQVcsRUFBWCxDQUFlLEVBQXBCLENBQXNCLEtBQXRCLENBQTRCLENBQUMsQ0FBN0IsQ0FOWCxFQVFHLElBUkgsQ0FRUSxFQVJSLENBRkY7QUFZRDs7QUFFRCxTQUFTLDBCQUFULENBQW9DO0FBQ2xDLEVBQUEsU0FBUyxHQUFHLEtBRHNCO0FBRWxDLEVBQUEsV0FBVyxHQUFHLEtBRm9CO0FBR2xDLEVBQUE7QUFIa0MsQ0FBcEMsRUFJRztBQUNELE1BQUksQ0FBQyxPQUFMLEVBQWM7QUFDWixXQUFPLFNBQVA7QUFDRDs7QUFDRCxTQUNFLHFEQUNBLEtBQUssQ0FBQyxTQUFOLENBQWdCLEdBQWhCLENBQ0csSUFESCxDQUVJLHVCQUFJLFNBQUosQ0FDRSxDQUFDLFNBQUQsRUFBWSxTQUFaLEVBQXVCLFNBQXZCLENBREYsRUFFRSxDQUFDLFdBQUQsRUFBYyxTQUFkLEVBQXlCLE9BQXpCLENBRkYsQ0FGSixFQU1LLENBQUQsSUFBUSxLQUFJLENBQUMsQ0FBQyxRQUFGLENBQVcsRUFBWCxDQUFlLEVBQXBCLENBQXNCLEtBQXRCLENBQTRCLENBQUMsQ0FBN0IsQ0FOWCxFQVFHLElBUkgsQ0FRUSxFQVJSLENBRkY7QUFZRDs7QUFFRCxTQUFTLG9CQUFULENBQThCO0FBQUUsRUFBQSxTQUFGO0FBQWEsRUFBQSxXQUFiO0FBQTBCLEVBQUEsU0FBMUI7QUFBcUMsRUFBQTtBQUFyQyxDQUE5QixFQUE2RTtBQUMzRSxVQUFRLFNBQVMsQ0FBQyxRQUFsQjtBQUNFLFNBQUssY0FBTDtBQUNFLGFBQU8sMEJBQTBCLENBQUM7QUFDaEMsUUFBQSxTQURnQztBQUVoQyxRQUFBLFdBRmdDO0FBR2hDLFFBQUEsT0FBTyxFQUFFLFNBQVMsQ0FBQztBQUhhLE9BQUQsQ0FBakM7O0FBS0YsU0FBSyxhQUFMO0FBQ0E7QUFDRSxhQUFPLHlCQUF5QixDQUFDO0FBQy9CLFFBQUEsU0FEK0I7QUFFL0IsUUFBQSxNQUYrQjtBQUcvQixRQUFBO0FBSCtCLE9BQUQsQ0FBaEM7QUFUSjtBQWVEOztBQUVELFNBQVMsU0FBVCxDQUFtQixJQUFuQixFQUF5QixLQUFLLEdBQUcsQ0FBakMsRUFBb0MsSUFBSSxHQUFHLENBQTNDLEVBQThDO0FBQzVDLFNBQVEsR0FBRSxJQUFJLENBQUMsS0FBTCxDQUFXLENBQVgsRUFBYyxLQUFkLENBQXFCLE1BQUssSUFBSSxDQUFDLEtBQUwsQ0FBVyxDQUFDLElBQVosQ0FBa0IsRUFBdEQ7QUFDRDs7Ozs7Ozs7Ozs7O0FDbE1EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUMzTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1S0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVMsYUFBVCxDQUF1QixPQUF2QixFQUFnQztBQUNyQyxTQUNFLE1BQU0sQ0FBQyxhQUFQLENBQXFCLE9BQXJCLEtBQWlDLE9BQU8sR0FBRyxDQUEzQyxJQUFnRCxPQUFPLElBQUksMEJBRDdEO0FBR0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxTQUFTLDRCQUFULENBQXNDLEtBQXRDLEVBQTZDO0FBQ2xELE1BQUksT0FBTyxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQzdCLFdBQU8sS0FBUDtBQUNEOztBQUNELFNBQU8sMkJBQTJCLElBQTNCLENBQWdDLEtBQWhDLENBQVA7QUFDRDs7Ozs7Ozs7Ozs7O0FDN0JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN6TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNockJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQy9PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeHZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuRUE7QUFDQTs7Ozs7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUMzTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdmRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUxBOzs7Ozs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ0xBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMTVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOUpBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3YxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTs7Ozs7Ozs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuRUE7O0FBRU8sZUFBZSxjQUFmLENBQThCLEdBQTlCLEVBQW1DO0FBQ3hDLE1BQUk7QUFDRixVQUFNLGNBQWMsR0FBRyxNQUFNLHFCQUFZLE9BQVosQ0FBb0IsR0FBcEIsQ0FBN0I7O0FBQ0EsUUFBSSxjQUFjLEtBQUssSUFBdkIsRUFBNkI7QUFDM0IsYUFBTyxTQUFQO0FBQ0Q7O0FBRUQsV0FBTyxJQUFJLENBQUMsS0FBTCxDQUFXLGNBQVgsQ0FBUDtBQUNELEdBUEQsQ0FPRSxPQUFPLEdBQVAsRUFBWTtBQUNaLFdBQU8sU0FBUDtBQUNEO0FBQ0Y7O0FBRU0sZUFBZSxjQUFmLENBQThCLEdBQTlCLEVBQW1DLEtBQW5DLEVBQTBDO0FBQy9DLE1BQUk7QUFDRixVQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsU0FBTCxDQUFlLEtBQWYsQ0FBdkI7QUFDQSxVQUFNLHFCQUFZLE9BQVosQ0FBb0IsR0FBcEIsRUFBeUIsY0FBekIsQ0FBTjtBQUNELEdBSEQsQ0FHRSxPQUFPLEdBQVAsRUFBWTtBQUNaLElBQUEsT0FBTyxDQUFDLElBQVIsQ0FBYSxHQUFiO0FBQ0Q7QUFDRjs7Ozs7Ozs7Ozs7O0FDdEJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiY29tbW9uLTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xuICB9IGVsc2Uge1xuICAgIF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xuXG4gIF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzcztcblxuICAgIGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTtcblxuICAgICAgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgIHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuXG4gICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7XG4gIH07XG5cbiAgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShuKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2Uobykge1xuICB2YXIgaSA9IDA7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAobyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkpIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICB9O1xuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICB9XG5cbiAgaSA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xuICByZXR1cm4gaS5uZXh0LmJpbmQoaSk7XG59XG5cbi8vIHRoZXNlIGFyZW4ndCByZWFsbHkgcHJpdmF0ZSwgYnV0IG5vciBhcmUgdGhleSByZWFsbHkgdXNlZnVsIHRvIGRvY3VtZW50XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xudmFyIEx1eG9uRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHNMb29zZShMdXhvbkVycm9yLCBfRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIEx1eG9uRXJyb3IoKSB7XG4gICAgcmV0dXJuIF9FcnJvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICByZXR1cm4gTHV4b25FcnJvcjtcbn0oIC8qI19fUFVSRV9fKi9fd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuXG52YXIgSW52YWxpZERhdGVUaW1lRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9MdXhvbkVycm9yKSB7XG4gIF9pbmhlcml0c0xvb3NlKEludmFsaWREYXRlVGltZUVycm9yLCBfTHV4b25FcnJvcik7XG5cbiAgZnVuY3Rpb24gSW52YWxpZERhdGVUaW1lRXJyb3IocmVhc29uKSB7XG4gICAgcmV0dXJuIF9MdXhvbkVycm9yLmNhbGwodGhpcywgXCJJbnZhbGlkIERhdGVUaW1lOiBcIiArIHJlYXNvbi50b01lc3NhZ2UoKSkgfHwgdGhpcztcbiAgfVxuXG4gIHJldHVybiBJbnZhbGlkRGF0ZVRpbWVFcnJvcjtcbn0oTHV4b25FcnJvcik7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIEludmFsaWRJbnRlcnZhbEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTHV4b25FcnJvcjIpIHtcbiAgX2luaGVyaXRzTG9vc2UoSW52YWxpZEludGVydmFsRXJyb3IsIF9MdXhvbkVycm9yMik7XG5cbiAgZnVuY3Rpb24gSW52YWxpZEludGVydmFsRXJyb3IocmVhc29uKSB7XG4gICAgcmV0dXJuIF9MdXhvbkVycm9yMi5jYWxsKHRoaXMsIFwiSW52YWxpZCBJbnRlcnZhbDogXCIgKyByZWFzb24udG9NZXNzYWdlKCkpIHx8IHRoaXM7XG4gIH1cblxuICByZXR1cm4gSW52YWxpZEludGVydmFsRXJyb3I7XG59KEx1eG9uRXJyb3IpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBJbnZhbGlkRHVyYXRpb25FcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0x1eG9uRXJyb3IzKSB7XG4gIF9pbmhlcml0c0xvb3NlKEludmFsaWREdXJhdGlvbkVycm9yLCBfTHV4b25FcnJvcjMpO1xuXG4gIGZ1bmN0aW9uIEludmFsaWREdXJhdGlvbkVycm9yKHJlYXNvbikge1xuICAgIHJldHVybiBfTHV4b25FcnJvcjMuY2FsbCh0aGlzLCBcIkludmFsaWQgRHVyYXRpb246IFwiICsgcmVhc29uLnRvTWVzc2FnZSgpKSB8fCB0aGlzO1xuICB9XG5cbiAgcmV0dXJuIEludmFsaWREdXJhdGlvbkVycm9yO1xufShMdXhvbkVycm9yKTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9MdXhvbkVycm9yNCkge1xuICBfaW5oZXJpdHNMb29zZShDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvciwgX0x1eG9uRXJyb3I0KTtcblxuICBmdW5jdGlvbiBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcigpIHtcbiAgICByZXR1cm4gX0x1eG9uRXJyb3I0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHJldHVybiBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvcjtcbn0oTHV4b25FcnJvcik7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIEludmFsaWRVbml0RXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9MdXhvbkVycm9yNSkge1xuICBfaW5oZXJpdHNMb29zZShJbnZhbGlkVW5pdEVycm9yLCBfTHV4b25FcnJvcjUpO1xuXG4gIGZ1bmN0aW9uIEludmFsaWRVbml0RXJyb3IodW5pdCkge1xuICAgIHJldHVybiBfTHV4b25FcnJvcjUuY2FsbCh0aGlzLCBcIkludmFsaWQgdW5pdCBcIiArIHVuaXQpIHx8IHRoaXM7XG4gIH1cblxuICByZXR1cm4gSW52YWxpZFVuaXRFcnJvcjtcbn0oTHV4b25FcnJvcik7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIEludmFsaWRBcmd1bWVudEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTHV4b25FcnJvcjYpIHtcbiAgX2luaGVyaXRzTG9vc2UoSW52YWxpZEFyZ3VtZW50RXJyb3IsIF9MdXhvbkVycm9yNik7XG5cbiAgZnVuY3Rpb24gSW52YWxpZEFyZ3VtZW50RXJyb3IoKSB7XG4gICAgcmV0dXJuIF9MdXhvbkVycm9yNi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICByZXR1cm4gSW52YWxpZEFyZ3VtZW50RXJyb3I7XG59KEx1eG9uRXJyb3IpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBab25lSXNBYnN0cmFjdEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTHV4b25FcnJvcjcpIHtcbiAgX2luaGVyaXRzTG9vc2UoWm9uZUlzQWJzdHJhY3RFcnJvciwgX0x1eG9uRXJyb3I3KTtcblxuICBmdW5jdGlvbiBab25lSXNBYnN0cmFjdEVycm9yKCkge1xuICAgIHJldHVybiBfTHV4b25FcnJvcjcuY2FsbCh0aGlzLCBcIlpvbmUgaXMgYW4gYWJzdHJhY3QgY2xhc3NcIikgfHwgdGhpcztcbiAgfVxuXG4gIHJldHVybiBab25lSXNBYnN0cmFjdEVycm9yO1xufShMdXhvbkVycm9yKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgbiA9IFwibnVtZXJpY1wiLFxuICAgIHMgPSBcInNob3J0XCIsXG4gICAgbCA9IFwibG9uZ1wiO1xudmFyIERBVEVfU0hPUlQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBuLFxuICBkYXk6IG5cbn07XG52YXIgREFURV9NRUQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG5cbn07XG52YXIgREFURV9NRURfV0lUSF9XRUVLREFZID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBzXG59O1xudmFyIERBVEVfRlVMTCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogblxufTtcbnZhciBEQVRFX0hVR0UgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IGxcbn07XG52YXIgVElNRV9TSU1QTEUgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogblxufTtcbnZhciBUSU1FX1dJVEhfU0VDT05EUyA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG5cbn07XG52YXIgVElNRV9XSVRIX1NIT1JUX09GRlNFVCA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIHRpbWVab25lTmFtZTogc1xufTtcbnZhciBUSU1FX1dJVEhfTE9OR19PRkZTRVQgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICB0aW1lWm9uZU5hbWU6IGxcbn07XG52YXIgVElNRV8yNF9TSU1QTEUgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgaG91cjEyOiBmYWxzZVxufTtcbi8qKlxuICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfTsgZm9ybWF0IGxpa2UgJzA5OjMwOjIzJywgYWx3YXlzIDI0LWhvdXIuXG4gKi9cblxudmFyIFRJTUVfMjRfV0lUSF9TRUNPTkRTID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgaG91cjEyOiBmYWxzZVxufTtcbi8qKlxuICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfTsgZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEVEVCcsIGFsd2F5cyAyNC1ob3VyLlxuICovXG5cbnZhciBUSU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgaG91cjEyOiBmYWxzZSxcbiAgdGltZVpvbmVOYW1lOiBzXG59O1xuLyoqXG4gKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9OyBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgRWFzdGVybiBEYXlsaWdodCBUaW1lJywgYWx3YXlzIDI0LWhvdXIuXG4gKi9cblxudmFyIFRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIGhvdXIxMjogZmFsc2UsXG4gIHRpbWVab25lTmFtZTogbFxufTtcbi8qKlxuICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfTsgZm9ybWF0IGxpa2UgJzEwLzE0LzE5ODMsIDk6MzAgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAqL1xuXG52YXIgREFURVRJTUVfU0hPUlQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBuLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogblxufTtcbi8qKlxuICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfTsgZm9ybWF0IGxpa2UgJzEwLzE0LzE5ODMsIDk6MzA6MzMgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAqL1xuXG52YXIgREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbixcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogblxufTtcbnZhciBEQVRFVElNRV9NRUQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogblxufTtcbnZhciBEQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogblxufTtcbnZhciBEQVRFVElNRV9NRURfV0lUSF9XRUVLREFZID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBzLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG5cbn07XG52YXIgREFURVRJTUVfRlVMTCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICB0aW1lWm9uZU5hbWU6IHNcbn07XG52YXIgREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICB0aW1lWm9uZU5hbWU6IHNcbn07XG52YXIgREFURVRJTUVfSFVHRSA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgd2Vla2RheTogbCxcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICB0aW1lWm9uZU5hbWU6IGxcbn07XG52YXIgREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IGwsXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICB0aW1lWm9uZU5hbWU6IGxcbn07XG5cbi8qXG4gIFRoaXMgaXMganVzdCBhIGp1bmsgZHJhd2VyLCBjb250YWluaW5nIGFueXRoaW5nIHVzZWQgYWNyb3NzIG11bHRpcGxlIGNsYXNzZXMuXG4gIEJlY2F1c2UgTHV4b24gaXMgc21hbGwoaXNoKSwgdGhpcyBzaG91bGQgc3RheSBzbWFsbCBhbmQgd2Ugd29uJ3Qgd29ycnkgYWJvdXQgc3BsaXR0aW5nXG4gIGl0IHVwIGludG8sIHNheSwgcGFyc2luZ1V0aWwuanMgYW5kIGJhc2ljVXRpbC5qcyBhbmQgc28gb24uIEJ1dCB0aGV5IGFyZSBkaXZpZGVkIHVwIGJ5IGZlYXR1cmUgYXJlYS5cbiovXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbi8vIFRZUEVTXG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSBcInVuZGVmaW5lZFwiO1xufVxuZnVuY3Rpb24gaXNOdW1iZXIobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwibnVtYmVyXCI7XG59XG5mdW5jdGlvbiBpc0ludGVnZXIobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwibnVtYmVyXCIgJiYgbyAlIDEgPT09IDA7XG59XG5mdW5jdGlvbiBpc1N0cmluZyhvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzRGF0ZShvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09IFwiW29iamVjdCBEYXRlXVwiO1xufSAvLyBDQVBBQklMSVRJRVNcblxuZnVuY3Rpb24gaGFzSW50bCgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdHlwZW9mIEludGwgIT09IFwidW5kZWZpbmVkXCIgJiYgSW50bC5EYXRlVGltZUZvcm1hdDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gaGFzRm9ybWF0VG9QYXJ0cygpIHtcbiAgcmV0dXJuICFpc1VuZGVmaW5lZChJbnRsLkRhdGVUaW1lRm9ybWF0LnByb3RvdHlwZS5mb3JtYXRUb1BhcnRzKTtcbn1cbmZ1bmN0aW9uIGhhc1JlbGF0aXZlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB0eXBlb2YgSW50bCAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhIUludGwuUmVsYXRpdmVUaW1lRm9ybWF0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59IC8vIE9CSkVDVFMgQU5EIEFSUkFZU1xuXG5mdW5jdGlvbiBtYXliZUFycmF5KHRoaW5nKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHRoaW5nKSA/IHRoaW5nIDogW3RoaW5nXTtcbn1cbmZ1bmN0aW9uIGJlc3RCeShhcnIsIGJ5LCBjb21wYXJlKSB7XG4gIGlmIChhcnIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBhcnIucmVkdWNlKGZ1bmN0aW9uIChiZXN0LCBuZXh0KSB7XG4gICAgdmFyIHBhaXIgPSBbYnkobmV4dCksIG5leHRdO1xuXG4gICAgaWYgKCFiZXN0KSB7XG4gICAgICByZXR1cm4gcGFpcjtcbiAgICB9IGVsc2UgaWYgKGNvbXBhcmUoYmVzdFswXSwgcGFpclswXSkgPT09IGJlc3RbMF0pIHtcbiAgICAgIHJldHVybiBiZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFpcjtcbiAgICB9XG4gIH0sIG51bGwpWzFdO1xufVxuZnVuY3Rpb24gcGljayhvYmosIGtleXMpIHtcbiAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChhLCBrKSB7XG4gICAgYVtrXSA9IG9ialtrXTtcbiAgICByZXR1cm4gYTtcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn0gLy8gTlVNQkVSUyBBTkQgU1RSSU5HU1xuXG5mdW5jdGlvbiBpbnRlZ2VyQmV0d2Vlbih0aGluZywgYm90dG9tLCB0b3ApIHtcbiAgcmV0dXJuIGlzSW50ZWdlcih0aGluZykgJiYgdGhpbmcgPj0gYm90dG9tICYmIHRoaW5nIDw9IHRvcDtcbn0gLy8geCAlIG4gYnV0IHRha2VzIHRoZSBzaWduIG9mIG4gaW5zdGVhZCBvZiB4XG5cbmZ1bmN0aW9uIGZsb29yTW9kKHgsIG4pIHtcbiAgcmV0dXJuIHggLSBuICogTWF0aC5mbG9vcih4IC8gbik7XG59XG5mdW5jdGlvbiBwYWRTdGFydChpbnB1dCwgbikge1xuICBpZiAobiA9PT0gdm9pZCAwKSB7XG4gICAgbiA9IDI7XG4gIH1cblxuICB2YXIgbWludXMgPSBpbnB1dCA8IDAgPyBcIi1cIiA6IFwiXCI7XG4gIHZhciB0YXJnZXQgPSBtaW51cyA/IGlucHV0ICogLTEgOiBpbnB1dDtcbiAgdmFyIHJlc3VsdDtcblxuICBpZiAodGFyZ2V0LnRvU3RyaW5nKCkubGVuZ3RoIDwgbikge1xuICAgIHJlc3VsdCA9IChcIjBcIi5yZXBlYXQobikgKyB0YXJnZXQpLnNsaWNlKC1uKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSB0YXJnZXQudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHJldHVybiBcIlwiICsgbWludXMgKyByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUludGVnZXIoc3RyaW5nKSB7XG4gIGlmIChpc1VuZGVmaW5lZChzdHJpbmcpIHx8IHN0cmluZyA9PT0gbnVsbCB8fCBzdHJpbmcgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJzZUludChzdHJpbmcsIDEwKTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VNaWxsaXMoZnJhY3Rpb24pIHtcbiAgLy8gUmV0dXJuIHVuZGVmaW5lZCAoaW5zdGVhZCBvZiAwKSBpbiB0aGVzZSBjYXNlcywgd2hlcmUgZnJhY3Rpb24gaXMgbm90IHNldFxuICBpZiAoaXNVbmRlZmluZWQoZnJhY3Rpb24pIHx8IGZyYWN0aW9uID09PSBudWxsIHx8IGZyYWN0aW9uID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZiA9IHBhcnNlRmxvYXQoXCIwLlwiICsgZnJhY3Rpb24pICogMTAwMDtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihmKTtcbiAgfVxufVxuZnVuY3Rpb24gcm91bmRUbyhudW1iZXIsIGRpZ2l0cywgdG93YXJkWmVybykge1xuICBpZiAodG93YXJkWmVybyA9PT0gdm9pZCAwKSB7XG4gICAgdG93YXJkWmVybyA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGZhY3RvciA9IE1hdGgucG93KDEwLCBkaWdpdHMpLFxuICAgICAgcm91bmRlciA9IHRvd2FyZFplcm8gPyBNYXRoLnRydW5jIDogTWF0aC5yb3VuZDtcbiAgcmV0dXJuIHJvdW5kZXIobnVtYmVyICogZmFjdG9yKSAvIGZhY3Rvcjtcbn0gLy8gREFURSBCQVNJQ1NcblxuZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbn1cbmZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbn1cbmZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gIHZhciBtb2RNb250aCA9IGZsb29yTW9kKG1vbnRoIC0gMSwgMTIpICsgMSxcbiAgICAgIG1vZFllYXIgPSB5ZWFyICsgKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG5cbiAgaWYgKG1vZE1vbnRoID09PSAyKSB7XG4gICAgcmV0dXJuIGlzTGVhcFllYXIobW9kWWVhcikgPyAyOSA6IDI4O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbMzEsIG51bGwsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXVttb2RNb250aCAtIDFdO1xuICB9XG59IC8vIGNvdmVydCBhIGNhbGVuZGFyIG9iamVjdCB0byBhIGxvY2FsIHRpbWVzdGFtcCAoZXBvY2gsIGJ1dCB3aXRoIHRoZSBvZmZzZXQgYmFrZWQgaW4pXG5cbmZ1bmN0aW9uIG9ialRvTG9jYWxUUyhvYmopIHtcbiAgdmFyIGQgPSBEYXRlLlVUQyhvYmoueWVhciwgb2JqLm1vbnRoIC0gMSwgb2JqLmRheSwgb2JqLmhvdXIsIG9iai5taW51dGUsIG9iai5zZWNvbmQsIG9iai5taWxsaXNlY29uZCk7IC8vIGZvciBsZWdhY3kgcmVhc29ucywgeWVhcnMgYmV0d2VlbiAwIGFuZCA5OSBhcmUgaW50ZXJwcmV0ZWQgYXMgMTlYWDsgcmV2ZXJ0IHRoYXRcblxuICBpZiAob2JqLnllYXIgPCAxMDAgJiYgb2JqLnllYXIgPj0gMCkge1xuICAgIGQgPSBuZXcgRGF0ZShkKTtcbiAgICBkLnNldFVUQ0Z1bGxZZWFyKGQuZ2V0VVRDRnVsbFllYXIoKSAtIDE5MDApO1xuICB9XG5cbiAgcmV0dXJuICtkO1xufVxuZnVuY3Rpb24gd2Vla3NJbldlZWtZZWFyKHdlZWtZZWFyKSB7XG4gIHZhciBwMSA9ICh3ZWVrWWVhciArIE1hdGguZmxvb3Iod2Vla1llYXIgLyA0KSAtIE1hdGguZmxvb3Iod2Vla1llYXIgLyAxMDApICsgTWF0aC5mbG9vcih3ZWVrWWVhciAvIDQwMCkpICUgNyxcbiAgICAgIGxhc3QgPSB3ZWVrWWVhciAtIDEsXG4gICAgICBwMiA9IChsYXN0ICsgTWF0aC5mbG9vcihsYXN0IC8gNCkgLSBNYXRoLmZsb29yKGxhc3QgLyAxMDApICsgTWF0aC5mbG9vcihsYXN0IC8gNDAwKSkgJSA3O1xuICByZXR1cm4gcDEgPT09IDQgfHwgcDIgPT09IDMgPyA1MyA6IDUyO1xufVxuZnVuY3Rpb24gdW50cnVuY2F0ZVllYXIoeWVhcikge1xuICBpZiAoeWVhciA+IDk5KSB7XG4gICAgcmV0dXJuIHllYXI7XG4gIH0gZWxzZSByZXR1cm4geWVhciA+IDYwID8gMTkwMCArIHllYXIgOiAyMDAwICsgeWVhcjtcbn0gLy8gUEFSU0lOR1xuXG5mdW5jdGlvbiBwYXJzZVpvbmVJbmZvKHRzLCBvZmZzZXRGb3JtYXQsIGxvY2FsZSwgdGltZVpvbmUpIHtcbiAgaWYgKHRpbWVab25lID09PSB2b2lkIDApIHtcbiAgICB0aW1lWm9uZSA9IG51bGw7XG4gIH1cblxuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHRzKSxcbiAgICAgIGludGxPcHRzID0ge1xuICAgIGhvdXIxMjogZmFsc2UsXG4gICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgbW9udGg6IFwiMi1kaWdpdFwiLFxuICAgIGRheTogXCIyLWRpZ2l0XCIsXG4gICAgaG91cjogXCIyLWRpZ2l0XCIsXG4gICAgbWludXRlOiBcIjItZGlnaXRcIlxuICB9O1xuXG4gIGlmICh0aW1lWm9uZSkge1xuICAgIGludGxPcHRzLnRpbWVab25lID0gdGltZVpvbmU7XG4gIH1cblxuICB2YXIgbW9kaWZpZWQgPSBPYmplY3QuYXNzaWduKHtcbiAgICB0aW1lWm9uZU5hbWU6IG9mZnNldEZvcm1hdFxuICB9LCBpbnRsT3B0cyksXG4gICAgICBpbnRsID0gaGFzSW50bCgpO1xuXG4gIGlmIChpbnRsICYmIGhhc0Zvcm1hdFRvUGFydHMoKSkge1xuICAgIHZhciBwYXJzZWQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIG1vZGlmaWVkKS5mb3JtYXRUb1BhcnRzKGRhdGUpLmZpbmQoZnVuY3Rpb24gKG0pIHtcbiAgICAgIHJldHVybiBtLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0aW1lem9uZW5hbWVcIjtcbiAgICB9KTtcbiAgICByZXR1cm4gcGFyc2VkID8gcGFyc2VkLnZhbHVlIDogbnVsbDtcbiAgfSBlbHNlIGlmIChpbnRsKSB7XG4gICAgLy8gdGhpcyBwcm9iYWJseSBkb2Vzbid0IHdvcmsgZm9yIGFsbCBsb2NhbGVzXG4gICAgdmFyIHdpdGhvdXQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIGludGxPcHRzKS5mb3JtYXQoZGF0ZSksXG4gICAgICAgIGluY2x1ZGVkID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBtb2RpZmllZCkuZm9ybWF0KGRhdGUpLFxuICAgICAgICBkaWZmZWQgPSBpbmNsdWRlZC5zdWJzdHJpbmcod2l0aG91dC5sZW5ndGgpLFxuICAgICAgICB0cmltbWVkID0gZGlmZmVkLnJlcGxhY2UoL15bLCBcXHUyMDBlXSsvLCBcIlwiKTtcbiAgICByZXR1cm4gdHJpbW1lZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufSAvLyBzaWduZWRPZmZzZXQoJy01JywgJzMwJykgLT4gLTMzMFxuXG5mdW5jdGlvbiBzaWduZWRPZmZzZXQob2ZmSG91clN0ciwgb2ZmTWludXRlU3RyKSB7XG4gIHZhciBvZmZIb3VyID0gcGFyc2VJbnQob2ZmSG91clN0ciwgMTApOyAvLyBkb24ndCB8fCB0aGlzIGJlY2F1c2Ugd2Ugd2FudCB0byBwcmVzZXJ2ZSAtMFxuXG4gIGlmIChOdW1iZXIuaXNOYU4ob2ZmSG91cikpIHtcbiAgICBvZmZIb3VyID0gMDtcbiAgfVxuXG4gIHZhciBvZmZNaW4gPSBwYXJzZUludChvZmZNaW51dGVTdHIsIDEwKSB8fCAwLFxuICAgICAgb2ZmTWluU2lnbmVkID0gb2ZmSG91ciA8IDAgfHwgT2JqZWN0LmlzKG9mZkhvdXIsIC0wKSA/IC1vZmZNaW4gOiBvZmZNaW47XG4gIHJldHVybiBvZmZIb3VyICogNjAgKyBvZmZNaW5TaWduZWQ7XG59IC8vIENPRVJDSU9OXG5cbmZ1bmN0aW9uIGFzTnVtYmVyKHZhbHVlKSB7XG4gIHZhciBudW1lcmljVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIiB8fCB2YWx1ZSA9PT0gXCJcIiB8fCBOdW1iZXIuaXNOYU4obnVtZXJpY1ZhbHVlKSkgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiSW52YWxpZCB1bml0IHZhbHVlIFwiICsgdmFsdWUpO1xuICByZXR1cm4gbnVtZXJpY1ZhbHVlO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0KG9iaiwgbm9ybWFsaXplciwgbm9uVW5pdEtleXMpIHtcbiAgdmFyIG5vcm1hbGl6ZWQgPSB7fTtcblxuICBmb3IgKHZhciB1IGluIG9iaikge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eShvYmosIHUpKSB7XG4gICAgICBpZiAobm9uVW5pdEtleXMuaW5kZXhPZih1KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIHZhciB2ID0gb2JqW3VdO1xuICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgIG5vcm1hbGl6ZWRbbm9ybWFsaXplcih1KV0gPSBhc051bWJlcih2KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cbmZ1bmN0aW9uIGZvcm1hdE9mZnNldChvZmZzZXQsIGZvcm1hdCkge1xuICB2YXIgaG91cnMgPSBNYXRoLnRydW5jKE1hdGguYWJzKG9mZnNldCAvIDYwKSksXG4gICAgICBtaW51dGVzID0gTWF0aC50cnVuYyhNYXRoLmFicyhvZmZzZXQgJSA2MCkpLFxuICAgICAgc2lnbiA9IG9mZnNldCA+PSAwID8gXCIrXCIgOiBcIi1cIjtcblxuICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgcmV0dXJuIFwiXCIgKyBzaWduICsgcGFkU3RhcnQoaG91cnMsIDIpICsgXCI6XCIgKyBwYWRTdGFydChtaW51dGVzLCAyKTtcblxuICAgIGNhc2UgXCJuYXJyb3dcIjpcbiAgICAgIHJldHVybiBcIlwiICsgc2lnbiArIGhvdXJzICsgKG1pbnV0ZXMgPiAwID8gXCI6XCIgKyBtaW51dGVzIDogXCJcIik7XG5cbiAgICBjYXNlIFwidGVjaGllXCI6XG4gICAgICByZXR1cm4gXCJcIiArIHNpZ24gKyBwYWRTdGFydChob3VycywgMikgKyBwYWRTdGFydChtaW51dGVzLCAyKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlZhbHVlIGZvcm1hdCBcIiArIGZvcm1hdCArIFwiIGlzIG91dCBvZiByYW5nZSBmb3IgcHJvcGVydHkgZm9ybWF0XCIpO1xuICB9XG59XG5mdW5jdGlvbiB0aW1lT2JqZWN0KG9iaikge1xuICByZXR1cm4gcGljayhvYmosIFtcImhvdXJcIiwgXCJtaW51dGVcIiwgXCJzZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiXSk7XG59XG52YXIgaWFuYVJlZ2V4ID0gL1tBLVphLXpfKy1dezEsMjU2fSg6P1xcL1tBLVphLXpfKy1dezEsMjU2fShcXC9bQS1aYS16XystXXsxLDI1Nn0pPyk/LztcblxuZnVuY3Rpb24gc3RyaW5naWZ5KG9iaikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBPYmplY3Qua2V5cyhvYmopLnNvcnQoKSk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuXG52YXIgbW9udGhzTG9uZyA9IFtcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdO1xudmFyIG1vbnRoc1Nob3J0ID0gW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdO1xudmFyIG1vbnRoc05hcnJvdyA9IFtcIkpcIiwgXCJGXCIsIFwiTVwiLCBcIkFcIiwgXCJNXCIsIFwiSlwiLCBcIkpcIiwgXCJBXCIsIFwiU1wiLCBcIk9cIiwgXCJOXCIsIFwiRFwiXTtcbmZ1bmN0aW9uIG1vbnRocyhsZW5ndGgpIHtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gbW9udGhzTmFycm93O1xuXG4gICAgY2FzZSBcInNob3J0XCI6XG4gICAgICByZXR1cm4gbW9udGhzU2hvcnQ7XG5cbiAgICBjYXNlIFwibG9uZ1wiOlxuICAgICAgcmV0dXJuIG1vbnRoc0xvbmc7XG5cbiAgICBjYXNlIFwibnVtZXJpY1wiOlxuICAgICAgcmV0dXJuIFtcIjFcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIiwgXCI4XCIsIFwiOVwiLCBcIjEwXCIsIFwiMTFcIiwgXCIxMlwiXTtcblxuICAgIGNhc2UgXCIyLWRpZ2l0XCI6XG4gICAgICByZXR1cm4gW1wiMDFcIiwgXCIwMlwiLCBcIjAzXCIsIFwiMDRcIiwgXCIwNVwiLCBcIjA2XCIsIFwiMDdcIiwgXCIwOFwiLCBcIjA5XCIsIFwiMTBcIiwgXCIxMVwiLCBcIjEyXCJdO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG52YXIgd2Vla2RheXNMb25nID0gW1wiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIiwgXCJTdW5kYXlcIl07XG52YXIgd2Vla2RheXNTaG9ydCA9IFtcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiLCBcIlN1blwiXTtcbnZhciB3ZWVrZGF5c05hcnJvdyA9IFtcIk1cIiwgXCJUXCIsIFwiV1wiLCBcIlRcIiwgXCJGXCIsIFwiU1wiLCBcIlNcIl07XG5mdW5jdGlvbiB3ZWVrZGF5cyhsZW5ndGgpIHtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gd2Vla2RheXNOYXJyb3c7XG5cbiAgICBjYXNlIFwic2hvcnRcIjpcbiAgICAgIHJldHVybiB3ZWVrZGF5c1Nob3J0O1xuXG4gICAgY2FzZSBcImxvbmdcIjpcbiAgICAgIHJldHVybiB3ZWVrZGF5c0xvbmc7XG5cbiAgICBjYXNlIFwibnVtZXJpY1wiOlxuICAgICAgcmV0dXJuIFtcIjFcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIl07XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbnZhciBtZXJpZGllbXMgPSBbXCJBTVwiLCBcIlBNXCJdO1xudmFyIGVyYXNMb25nID0gW1wiQmVmb3JlIENocmlzdFwiLCBcIkFubm8gRG9taW5pXCJdO1xudmFyIGVyYXNTaG9ydCA9IFtcIkJDXCIsIFwiQURcIl07XG52YXIgZXJhc05hcnJvdyA9IFtcIkJcIiwgXCJBXCJdO1xuZnVuY3Rpb24gZXJhcyhsZW5ndGgpIHtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIFwibmFycm93XCI6XG4gICAgICByZXR1cm4gZXJhc05hcnJvdztcblxuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgcmV0dXJuIGVyYXNTaG9ydDtcblxuICAgIGNhc2UgXCJsb25nXCI6XG4gICAgICByZXR1cm4gZXJhc0xvbmc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIG1lcmlkaWVtRm9yRGF0ZVRpbWUoZHQpIHtcbiAgcmV0dXJuIG1lcmlkaWVtc1tkdC5ob3VyIDwgMTIgPyAwIDogMV07XG59XG5mdW5jdGlvbiB3ZWVrZGF5Rm9yRGF0ZVRpbWUoZHQsIGxlbmd0aCkge1xuICByZXR1cm4gd2Vla2RheXMobGVuZ3RoKVtkdC53ZWVrZGF5IC0gMV07XG59XG5mdW5jdGlvbiBtb250aEZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIG1vbnRocyhsZW5ndGgpW2R0Lm1vbnRoIC0gMV07XG59XG5mdW5jdGlvbiBlcmFGb3JEYXRlVGltZShkdCwgbGVuZ3RoKSB7XG4gIHJldHVybiBlcmFzKGxlbmd0aClbZHQueWVhciA8IDAgPyAwIDogMV07XG59XG5mdW5jdGlvbiBmb3JtYXRSZWxhdGl2ZVRpbWUodW5pdCwgY291bnQsIG51bWVyaWMsIG5hcnJvdykge1xuICBpZiAobnVtZXJpYyA9PT0gdm9pZCAwKSB7XG4gICAgbnVtZXJpYyA9IFwiYWx3YXlzXCI7XG4gIH1cblxuICBpZiAobmFycm93ID09PSB2b2lkIDApIHtcbiAgICBuYXJyb3cgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciB1bml0cyA9IHtcbiAgICB5ZWFyczogW1wieWVhclwiLCBcInlyLlwiXSxcbiAgICBxdWFydGVyczogW1wicXVhcnRlclwiLCBcInF0ci5cIl0sXG4gICAgbW9udGhzOiBbXCJtb250aFwiLCBcIm1vLlwiXSxcbiAgICB3ZWVrczogW1wid2Vla1wiLCBcIndrLlwiXSxcbiAgICBkYXlzOiBbXCJkYXlcIiwgXCJkYXlcIiwgXCJkYXlzXCJdLFxuICAgIGhvdXJzOiBbXCJob3VyXCIsIFwiaHIuXCJdLFxuICAgIG1pbnV0ZXM6IFtcIm1pbnV0ZVwiLCBcIm1pbi5cIl0sXG4gICAgc2Vjb25kczogW1wic2Vjb25kXCIsIFwic2VjLlwiXVxuICB9O1xuICB2YXIgbGFzdGFibGUgPSBbXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCJdLmluZGV4T2YodW5pdCkgPT09IC0xO1xuXG4gIGlmIChudW1lcmljID09PSBcImF1dG9cIiAmJiBsYXN0YWJsZSkge1xuICAgIHZhciBpc0RheSA9IHVuaXQgPT09IFwiZGF5c1wiO1xuXG4gICAgc3dpdGNoIChjb3VudCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gaXNEYXkgPyBcInRvbW9ycm93XCIgOiBcIm5leHQgXCIgKyB1bml0c1t1bml0XVswXTtcblxuICAgICAgY2FzZSAtMTpcbiAgICAgICAgcmV0dXJuIGlzRGF5ID8gXCJ5ZXN0ZXJkYXlcIiA6IFwibGFzdCBcIiArIHVuaXRzW3VuaXRdWzBdO1xuXG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBpc0RheSA/IFwidG9kYXlcIiA6IFwidGhpcyBcIiArIHVuaXRzW3VuaXRdWzBdO1xuXG4gICAgfVxuICB9XG5cbiAgdmFyIGlzSW5QYXN0ID0gT2JqZWN0LmlzKGNvdW50LCAtMCkgfHwgY291bnQgPCAwLFxuICAgICAgZm10VmFsdWUgPSBNYXRoLmFicyhjb3VudCksXG4gICAgICBzaW5ndWxhciA9IGZtdFZhbHVlID09PSAxLFxuICAgICAgbGlsVW5pdHMgPSB1bml0c1t1bml0XSxcbiAgICAgIGZtdFVuaXQgPSBuYXJyb3cgPyBzaW5ndWxhciA/IGxpbFVuaXRzWzFdIDogbGlsVW5pdHNbMl0gfHwgbGlsVW5pdHNbMV0gOiBzaW5ndWxhciA/IHVuaXRzW3VuaXRdWzBdIDogdW5pdDtcbiAgcmV0dXJuIGlzSW5QYXN0ID8gZm10VmFsdWUgKyBcIiBcIiArIGZtdFVuaXQgKyBcIiBhZ29cIiA6IFwiaW4gXCIgKyBmbXRWYWx1ZSArIFwiIFwiICsgZm10VW5pdDtcbn1cbmZ1bmN0aW9uIGZvcm1hdFN0cmluZyhrbm93bkZvcm1hdCkge1xuICAvLyB0aGVzZSBhbGwgaGF2ZSB0aGUgb2Zmc2V0cyByZW1vdmVkIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gdGhlbVxuICAvLyB3aXRob3V0IGFsbCB0aGUgaW50bCBzdHVmZiB0aGlzIGlzIGJhY2tmaWxsaW5nXG4gIHZhciBmaWx0ZXJlZCA9IHBpY2soa25vd25Gb3JtYXQsIFtcIndlZWtkYXlcIiwgXCJlcmFcIiwgXCJ5ZWFyXCIsIFwibW9udGhcIiwgXCJkYXlcIiwgXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwidGltZVpvbmVOYW1lXCIsIFwiaG91cjEyXCJdKSxcbiAgICAgIGtleSA9IHN0cmluZ2lmeShmaWx0ZXJlZCksXG4gICAgICBkYXRlVGltZUh1Z2UgPSBcIkVFRUUsIExMTEwgZCwgeXl5eSwgaDptbSBhXCI7XG5cbiAgc3dpdGNoIChrZXkpIHtcbiAgICBjYXNlIHN0cmluZ2lmeShEQVRFX1NIT1JUKTpcbiAgICAgIHJldHVybiBcIk0vZC95eXl5XCI7XG5cbiAgICBjYXNlIHN0cmluZ2lmeShEQVRFX01FRCk6XG4gICAgICByZXR1cm4gXCJMTEwgZCwgeXl5eVwiO1xuXG4gICAgY2FzZSBzdHJpbmdpZnkoREFURV9NRURfV0lUSF9XRUVLREFZKTpcbiAgICAgIHJldHVybiBcIkVFRSwgTExMIGQsIHl5eXlcIjtcblxuICAgIGNhc2Ugc3RyaW5naWZ5KERBVEVfRlVMTCk6XG4gICAgICByZXR1cm4gXCJMTExMIGQsIHl5eXlcIjtcblxuICAgIGNhc2Ugc3RyaW5naWZ5KERBVEVfSFVHRSk6XG4gICAgICByZXR1cm4gXCJFRUVFLCBMTExMIGQsIHl5eXlcIjtcblxuICAgIGNhc2Ugc3RyaW5naWZ5KFRJTUVfU0lNUExFKTpcbiAgICAgIHJldHVybiBcImg6bW0gYVwiO1xuXG4gICAgY2FzZSBzdHJpbmdpZnkoVElNRV9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiaDptbTpzcyBhXCI7XG5cbiAgICBjYXNlIHN0cmluZ2lmeShUSU1FX1dJVEhfU0hPUlRfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcImg6bW0gYVwiO1xuXG4gICAgY2FzZSBzdHJpbmdpZnkoVElNRV9XSVRIX0xPTkdfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcImg6bW0gYVwiO1xuXG4gICAgY2FzZSBzdHJpbmdpZnkoVElNRV8yNF9TSU1QTEUpOlxuICAgICAgcmV0dXJuIFwiSEg6bW1cIjtcblxuICAgIGNhc2Ugc3RyaW5naWZ5KFRJTUVfMjRfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIkhIOm1tOnNzXCI7XG5cbiAgICBjYXNlIHN0cmluZ2lmeShUSU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcIkhIOm1tXCI7XG5cbiAgICBjYXNlIHN0cmluZ2lmeShUSU1FXzI0X1dJVEhfTE9OR19PRkZTRVQpOlxuICAgICAgcmV0dXJuIFwiSEg6bW1cIjtcblxuICAgIGNhc2Ugc3RyaW5naWZ5KERBVEVUSU1FX1NIT1JUKTpcbiAgICAgIHJldHVybiBcIk0vZC95eXl5LCBoOm1tIGFcIjtcblxuICAgIGNhc2Ugc3RyaW5naWZ5KERBVEVUSU1FX01FRCk6XG4gICAgICByZXR1cm4gXCJMTEwgZCwgeXl5eSwgaDptbSBhXCI7XG5cbiAgICBjYXNlIHN0cmluZ2lmeShEQVRFVElNRV9GVUxMKTpcbiAgICAgIHJldHVybiBcIkxMTEwgZCwgeXl5eSwgaDptbSBhXCI7XG5cbiAgICBjYXNlIHN0cmluZ2lmeShEQVRFVElNRV9IVUdFKTpcbiAgICAgIHJldHVybiBkYXRlVGltZUh1Z2U7XG5cbiAgICBjYXNlIHN0cmluZ2lmeShEQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiTS9kL3l5eXksIGg6bW06c3MgYVwiO1xuXG4gICAgY2FzZSBzdHJpbmdpZnkoREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJMTEwgZCwgeXl5eSwgaDptbTpzcyBhXCI7XG5cbiAgICBjYXNlIHN0cmluZ2lmeShEQVRFVElNRV9NRURfV0lUSF9XRUVLREFZKTpcbiAgICAgIHJldHVybiBcIkVFRSwgZCBMTEwgeXl5eSwgaDptbSBhXCI7XG5cbiAgICBjYXNlIHN0cmluZ2lmeShEQVRFVElNRV9GVUxMX1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJMTExMIGQsIHl5eXksIGg6bW06c3MgYVwiO1xuXG4gICAgY2FzZSBzdHJpbmdpZnkoREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiRUVFRSwgTExMTCBkLCB5eXl5LCBoOm1tOnNzIGFcIjtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZGF0ZVRpbWVIdWdlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVRva2VucyhzcGxpdHMsIHRva2VuVG9TdHJpbmcpIHtcbiAgdmFyIHMgPSBcIlwiO1xuXG4gIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2Uoc3BsaXRzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICB2YXIgdG9rZW4gPSBfc3RlcC52YWx1ZTtcblxuICAgIGlmICh0b2tlbi5saXRlcmFsKSB7XG4gICAgICBzICs9IHRva2VuLnZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyArPSB0b2tlblRvU3RyaW5nKHRva2VuLnZhbCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHM7XG59XG5cbnZhciBfbWFjcm9Ub2tlblRvRm9ybWF0T3B0cyA9IHtcbiAgRDogREFURV9TSE9SVCxcbiAgREQ6IERBVEVfTUVELFxuICBEREQ6IERBVEVfRlVMTCxcbiAgRERERDogREFURV9IVUdFLFxuICB0OiBUSU1FX1NJTVBMRSxcbiAgdHQ6IFRJTUVfV0lUSF9TRUNPTkRTLFxuICB0dHQ6IFRJTUVfV0lUSF9TSE9SVF9PRkZTRVQsXG4gIHR0dHQ6IFRJTUVfV0lUSF9MT05HX09GRlNFVCxcbiAgVDogVElNRV8yNF9TSU1QTEUsXG4gIFRUOiBUSU1FXzI0X1dJVEhfU0VDT05EUyxcbiAgVFRUOiBUSU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VULFxuICBUVFRUOiBUSU1FXzI0X1dJVEhfTE9OR19PRkZTRVQsXG4gIGY6IERBVEVUSU1FX1NIT1JULFxuICBmZjogREFURVRJTUVfTUVELFxuICBmZmY6IERBVEVUSU1FX0ZVTEwsXG4gIGZmZmY6IERBVEVUSU1FX0hVR0UsXG4gIEY6IERBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUyxcbiAgRkY6IERBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMsXG4gIEZGRjogREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMsXG4gIEZGRkY6IERBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTXG59O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBGb3JtYXR0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBGb3JtYXR0ZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGxvY2FsZSwgb3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEZvcm1hdHRlcihsb2NhbGUsIG9wdHMpO1xuICB9O1xuXG4gIEZvcm1hdHRlci5wYXJzZUZvcm1hdCA9IGZ1bmN0aW9uIHBhcnNlRm9ybWF0KGZtdCkge1xuICAgIHZhciBjdXJyZW50ID0gbnVsbCxcbiAgICAgICAgY3VycmVudEZ1bGwgPSBcIlwiLFxuICAgICAgICBicmFja2V0ZWQgPSBmYWxzZTtcbiAgICB2YXIgc3BsaXRzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZtdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBmbXQuY2hhckF0KGkpO1xuXG4gICAgICBpZiAoYyA9PT0gXCInXCIpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRGdWxsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzcGxpdHMucHVzaCh7XG4gICAgICAgICAgICBsaXRlcmFsOiBicmFja2V0ZWQsXG4gICAgICAgICAgICB2YWw6IGN1cnJlbnRGdWxsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgICAgY3VycmVudEZ1bGwgPSBcIlwiO1xuICAgICAgICBicmFja2V0ZWQgPSAhYnJhY2tldGVkO1xuICAgICAgfSBlbHNlIGlmIChicmFja2V0ZWQpIHtcbiAgICAgICAgY3VycmVudEZ1bGwgKz0gYztcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gY3VycmVudCkge1xuICAgICAgICBjdXJyZW50RnVsbCArPSBjO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGN1cnJlbnRGdWxsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzcGxpdHMucHVzaCh7XG4gICAgICAgICAgICBsaXRlcmFsOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbDogY3VycmVudEZ1bGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRGdWxsID0gYztcbiAgICAgICAgY3VycmVudCA9IGM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRGdWxsLmxlbmd0aCA+IDApIHtcbiAgICAgIHNwbGl0cy5wdXNoKHtcbiAgICAgICAgbGl0ZXJhbDogYnJhY2tldGVkLFxuICAgICAgICB2YWw6IGN1cnJlbnRGdWxsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3BsaXRzO1xuICB9O1xuXG4gIEZvcm1hdHRlci5tYWNyb1Rva2VuVG9Gb3JtYXRPcHRzID0gZnVuY3Rpb24gbWFjcm9Ub2tlblRvRm9ybWF0T3B0cyh0b2tlbikge1xuICAgIHJldHVybiBfbWFjcm9Ub2tlblRvRm9ybWF0T3B0c1t0b2tlbl07XG4gIH07XG5cbiAgZnVuY3Rpb24gRm9ybWF0dGVyKGxvY2FsZSwgZm9ybWF0T3B0cykge1xuICAgIHRoaXMub3B0cyA9IGZvcm1hdE9wdHM7XG4gICAgdGhpcy5sb2MgPSBsb2NhbGU7XG4gICAgdGhpcy5zeXN0ZW1Mb2MgPSBudWxsO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEZvcm1hdHRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmZvcm1hdFdpdGhTeXN0ZW1EZWZhdWx0ID0gZnVuY3Rpb24gZm9ybWF0V2l0aFN5c3RlbURlZmF1bHQoZHQsIG9wdHMpIHtcbiAgICBpZiAodGhpcy5zeXN0ZW1Mb2MgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuc3lzdGVtTG9jID0gdGhpcy5sb2MucmVkZWZhdWx0VG9TeXN0ZW0oKTtcbiAgICB9XG5cbiAgICB2YXIgZGYgPSB0aGlzLnN5c3RlbUxvYy5kdEZvcm1hdHRlcihkdCwgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRzLCBvcHRzKSk7XG4gICAgcmV0dXJuIGRmLmZvcm1hdCgpO1xuICB9O1xuXG4gIF9wcm90by5mb3JtYXREYXRlVGltZSA9IGZ1bmN0aW9uIGZvcm1hdERhdGVUaW1lKGR0LCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBkZiA9IHRoaXMubG9jLmR0Rm9ybWF0dGVyKGR0LCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdHMsIG9wdHMpKTtcbiAgICByZXR1cm4gZGYuZm9ybWF0KCk7XG4gIH07XG5cbiAgX3Byb3RvLmZvcm1hdERhdGVUaW1lUGFydHMgPSBmdW5jdGlvbiBmb3JtYXREYXRlVGltZVBhcnRzKGR0LCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBkZiA9IHRoaXMubG9jLmR0Rm9ybWF0dGVyKGR0LCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdHMsIG9wdHMpKTtcbiAgICByZXR1cm4gZGYuZm9ybWF0VG9QYXJ0cygpO1xuICB9O1xuXG4gIF9wcm90by5yZXNvbHZlZE9wdGlvbnMgPSBmdW5jdGlvbiByZXNvbHZlZE9wdGlvbnMoZHQsIG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuXG4gICAgdmFyIGRmID0gdGhpcy5sb2MuZHRGb3JtYXR0ZXIoZHQsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0cywgb3B0cykpO1xuICAgIHJldHVybiBkZi5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgfTtcblxuICBfcHJvdG8ubnVtID0gZnVuY3Rpb24gbnVtKG4sIHApIHtcbiAgICBpZiAocCA9PT0gdm9pZCAwKSB7XG4gICAgICBwID0gMDtcbiAgICB9XG5cbiAgICAvLyB3ZSBnZXQgc29tZSBwZXJmIG91dCBvZiBkb2luZyB0aGlzIGhlcmUsIGFubm95aW5nbHlcbiAgICBpZiAodGhpcy5vcHRzLmZvcmNlU2ltcGxlKSB7XG4gICAgICByZXR1cm4gcGFkU3RhcnQobiwgcCk7XG4gICAgfVxuXG4gICAgdmFyIG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdHMpO1xuXG4gICAgaWYgKHAgPiAwKSB7XG4gICAgICBvcHRzLnBhZFRvID0gcDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5sb2MubnVtYmVyRm9ybWF0dGVyKG9wdHMpLmZvcm1hdChuKTtcbiAgfTtcblxuICBfcHJvdG8uZm9ybWF0RGF0ZVRpbWVGcm9tU3RyaW5nID0gZnVuY3Rpb24gZm9ybWF0RGF0ZVRpbWVGcm9tU3RyaW5nKGR0LCBmbXQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGtub3duRW5nbGlzaCA9IHRoaXMubG9jLmxpc3RpbmdNb2RlKCkgPT09IFwiZW5cIixcbiAgICAgICAgdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPSB0aGlzLmxvYy5vdXRwdXRDYWxlbmRhciAmJiB0aGlzLmxvYy5vdXRwdXRDYWxlbmRhciAhPT0gXCJncmVnb3J5XCIgJiYgaGFzRm9ybWF0VG9QYXJ0cygpLFxuICAgICAgICBzdHJpbmcgPSBmdW5jdGlvbiBzdHJpbmcob3B0cywgZXh0cmFjdCkge1xuICAgICAgcmV0dXJuIF90aGlzLmxvYy5leHRyYWN0KGR0LCBvcHRzLCBleHRyYWN0KTtcbiAgICB9LFxuICAgICAgICBmb3JtYXRPZmZzZXQgPSBmdW5jdGlvbiBmb3JtYXRPZmZzZXQob3B0cykge1xuICAgICAgaWYgKGR0LmlzT2Zmc2V0Rml4ZWQgJiYgZHQub2Zmc2V0ID09PSAwICYmIG9wdHMuYWxsb3daKSB7XG4gICAgICAgIHJldHVybiBcIlpcIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGR0LmlzVmFsaWQgPyBkdC56b25lLmZvcm1hdE9mZnNldChkdC50cywgb3B0cy5mb3JtYXQpIDogXCJcIjtcbiAgICB9LFxuICAgICAgICBtZXJpZGllbSA9IGZ1bmN0aW9uIG1lcmlkaWVtKCkge1xuICAgICAgcmV0dXJuIGtub3duRW5nbGlzaCA/IG1lcmlkaWVtRm9yRGF0ZVRpbWUoZHQpIDogc3RyaW5nKHtcbiAgICAgICAgaG91cjogXCJudW1lcmljXCIsXG4gICAgICAgIGhvdXIxMjogdHJ1ZVxuICAgICAgfSwgXCJkYXlwZXJpb2RcIik7XG4gICAgfSxcbiAgICAgICAgbW9udGggPSBmdW5jdGlvbiBtb250aChsZW5ndGgsIHN0YW5kYWxvbmUpIHtcbiAgICAgIHJldHVybiBrbm93bkVuZ2xpc2ggPyBtb250aEZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIDogc3RyaW5nKHN0YW5kYWxvbmUgPyB7XG4gICAgICAgIG1vbnRoOiBsZW5ndGhcbiAgICAgIH0gOiB7XG4gICAgICAgIG1vbnRoOiBsZW5ndGgsXG4gICAgICAgIGRheTogXCJudW1lcmljXCJcbiAgICAgIH0sIFwibW9udGhcIik7XG4gICAgfSxcbiAgICAgICAgd2Vla2RheSA9IGZ1bmN0aW9uIHdlZWtkYXkobGVuZ3RoLCBzdGFuZGFsb25lKSB7XG4gICAgICByZXR1cm4ga25vd25FbmdsaXNoID8gd2Vla2RheUZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIDogc3RyaW5nKHN0YW5kYWxvbmUgPyB7XG4gICAgICAgIHdlZWtkYXk6IGxlbmd0aFxuICAgICAgfSA6IHtcbiAgICAgICAgd2Vla2RheTogbGVuZ3RoLFxuICAgICAgICBtb250aDogXCJsb25nXCIsXG4gICAgICAgIGRheTogXCJudW1lcmljXCJcbiAgICAgIH0sIFwid2Vla2RheVwiKTtcbiAgICB9LFxuICAgICAgICBtYXliZU1hY3JvID0gZnVuY3Rpb24gbWF5YmVNYWNybyh0b2tlbikge1xuICAgICAgdmFyIGZvcm1hdE9wdHMgPSBGb3JtYXR0ZXIubWFjcm9Ub2tlblRvRm9ybWF0T3B0cyh0b2tlbik7XG5cbiAgICAgIGlmIChmb3JtYXRPcHRzKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5mb3JtYXRXaXRoU3lzdGVtRGVmYXVsdChkdCwgZm9ybWF0T3B0cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgZXJhID0gZnVuY3Rpb24gZXJhKGxlbmd0aCkge1xuICAgICAgcmV0dXJuIGtub3duRW5nbGlzaCA/IGVyYUZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIDogc3RyaW5nKHtcbiAgICAgICAgZXJhOiBsZW5ndGhcbiAgICAgIH0sIFwiZXJhXCIpO1xuICAgIH0sXG4gICAgICAgIHRva2VuVG9TdHJpbmcgPSBmdW5jdGlvbiB0b2tlblRvU3RyaW5nKHRva2VuKSB7XG4gICAgICAvLyBXaGVyZSBwb3NzaWJsZTogaHR0cDovL2NsZHIudW5pY29kZS5vcmcvdHJhbnNsYXRpb24vZGF0ZS10aW1lLTEvZGF0ZS10aW1lI1RPQy1TdGFuZGFsb25lLXZzLi1Gb3JtYXQtU3R5bGVzXG4gICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIC8vIG1zXG4gICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgcmV0dXJuIF90aGlzLm51bShkdC5taWxsaXNlY29uZCk7XG5cbiAgICAgICAgY2FzZSBcInVcIjogLy8gZmFsbHMgdGhyb3VnaFxuXG4gICAgICAgIGNhc2UgXCJTU1NcIjpcbiAgICAgICAgICByZXR1cm4gX3RoaXMubnVtKGR0Lm1pbGxpc2Vjb25kLCAzKTtcbiAgICAgICAgLy8gc2Vjb25kc1xuXG4gICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgcmV0dXJuIF90aGlzLm51bShkdC5zZWNvbmQpO1xuXG4gICAgICAgIGNhc2UgXCJzc1wiOlxuICAgICAgICAgIHJldHVybiBfdGhpcy5udW0oZHQuc2Vjb25kLCAyKTtcbiAgICAgICAgLy8gbWludXRlc1xuXG4gICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgcmV0dXJuIF90aGlzLm51bShkdC5taW51dGUpO1xuXG4gICAgICAgIGNhc2UgXCJtbVwiOlxuICAgICAgICAgIHJldHVybiBfdGhpcy5udW0oZHQubWludXRlLCAyKTtcbiAgICAgICAgLy8gaG91cnNcblxuICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgIHJldHVybiBfdGhpcy5udW0oZHQuaG91ciAlIDEyID09PSAwID8gMTIgOiBkdC5ob3VyICUgMTIpO1xuXG4gICAgICAgIGNhc2UgXCJoaFwiOlxuICAgICAgICAgIHJldHVybiBfdGhpcy5udW0oZHQuaG91ciAlIDEyID09PSAwID8gMTIgOiBkdC5ob3VyICUgMTIsIDIpO1xuXG4gICAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgICAgcmV0dXJuIF90aGlzLm51bShkdC5ob3VyKTtcblxuICAgICAgICBjYXNlIFwiSEhcIjpcbiAgICAgICAgICByZXR1cm4gX3RoaXMubnVtKGR0LmhvdXIsIDIpO1xuICAgICAgICAvLyBvZmZzZXRcblxuICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICAgIC8vIGxpa2UgKzZcbiAgICAgICAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHtcbiAgICAgICAgICAgIGZvcm1hdDogXCJuYXJyb3dcIixcbiAgICAgICAgICAgIGFsbG93WjogX3RoaXMub3B0cy5hbGxvd1pcbiAgICAgICAgICB9KTtcblxuICAgICAgICBjYXNlIFwiWlpcIjpcbiAgICAgICAgICAvLyBsaWtlICswNjowMFxuICAgICAgICAgIHJldHVybiBmb3JtYXRPZmZzZXQoe1xuICAgICAgICAgICAgZm9ybWF0OiBcInNob3J0XCIsXG4gICAgICAgICAgICBhbGxvd1o6IF90aGlzLm9wdHMuYWxsb3daXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgY2FzZSBcIlpaWlwiOlxuICAgICAgICAgIC8vIGxpa2UgKzA2MDBcbiAgICAgICAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHtcbiAgICAgICAgICAgIGZvcm1hdDogXCJ0ZWNoaWVcIixcbiAgICAgICAgICAgIGFsbG93WjogX3RoaXMub3B0cy5hbGxvd1pcbiAgICAgICAgICB9KTtcblxuICAgICAgICBjYXNlIFwiWlpaWlwiOlxuICAgICAgICAgIC8vIGxpa2UgRVNUXG4gICAgICAgICAgcmV0dXJuIGR0LnpvbmUub2Zmc2V0TmFtZShkdC50cywge1xuICAgICAgICAgICAgZm9ybWF0OiBcInNob3J0XCIsXG4gICAgICAgICAgICBsb2NhbGU6IF90aGlzLmxvYy5sb2NhbGVcbiAgICAgICAgICB9KTtcblxuICAgICAgICBjYXNlIFwiWlpaWlpcIjpcbiAgICAgICAgICAvLyBsaWtlIEVhc3Rlcm4gU3RhbmRhcmQgVGltZVxuICAgICAgICAgIHJldHVybiBkdC56b25lLm9mZnNldE5hbWUoZHQudHMsIHtcbiAgICAgICAgICAgIGZvcm1hdDogXCJsb25nXCIsXG4gICAgICAgICAgICBsb2NhbGU6IF90aGlzLmxvYy5sb2NhbGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgLy8gem9uZVxuXG4gICAgICAgIGNhc2UgXCJ6XCI6XG4gICAgICAgICAgLy8gbGlrZSBBbWVyaWNhL05ld19Zb3JrXG4gICAgICAgICAgcmV0dXJuIGR0LnpvbmVOYW1lO1xuICAgICAgICAvLyBtZXJpZGllbXNcblxuICAgICAgICBjYXNlIFwiYVwiOlxuICAgICAgICAgIHJldHVybiBtZXJpZGllbSgpO1xuICAgICAgICAvLyBkYXRlc1xuXG4gICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyID8gc3RyaW5nKHtcbiAgICAgICAgICAgIGRheTogXCJudW1lcmljXCJcbiAgICAgICAgICB9LCBcImRheVwiKSA6IF90aGlzLm51bShkdC5kYXkpO1xuXG4gICAgICAgIGNhc2UgXCJkZFwiOlxuICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlciA/IHN0cmluZyh7XG4gICAgICAgICAgICBkYXk6IFwiMi1kaWdpdFwiXG4gICAgICAgICAgfSwgXCJkYXlcIikgOiBfdGhpcy5udW0oZHQuZGF5LCAyKTtcbiAgICAgICAgLy8gd2Vla2RheXMgLSBzdGFuZGFsb25lXG5cbiAgICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICByZXR1cm4gX3RoaXMubnVtKGR0LndlZWtkYXkpO1xuXG4gICAgICAgIGNhc2UgXCJjY2NcIjpcbiAgICAgICAgICAvLyBsaWtlICdUdWVzJ1xuICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwic2hvcnRcIiwgdHJ1ZSk7XG5cbiAgICAgICAgY2FzZSBcImNjY2NcIjpcbiAgICAgICAgICAvLyBsaWtlICdUdWVzZGF5J1xuICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibG9uZ1wiLCB0cnVlKTtcblxuICAgICAgICBjYXNlIFwiY2NjY2NcIjpcbiAgICAgICAgICAvLyBsaWtlICdUJ1xuICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibmFycm93XCIsIHRydWUpO1xuICAgICAgICAvLyB3ZWVrZGF5cyAtIGZvcm1hdFxuXG4gICAgICAgIGNhc2UgXCJFXCI6XG4gICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgcmV0dXJuIF90aGlzLm51bShkdC53ZWVrZGF5KTtcblxuICAgICAgICBjYXNlIFwiRUVFXCI6XG4gICAgICAgICAgLy8gbGlrZSAnVHVlcydcbiAgICAgICAgICByZXR1cm4gd2Vla2RheShcInNob3J0XCIsIGZhbHNlKTtcblxuICAgICAgICBjYXNlIFwiRUVFRVwiOlxuICAgICAgICAgIC8vIGxpa2UgJ1R1ZXNkYXknXG4gICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJsb25nXCIsIGZhbHNlKTtcblxuICAgICAgICBjYXNlIFwiRUVFRUVcIjpcbiAgICAgICAgICAvLyBsaWtlICdUJ1xuICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibmFycm93XCIsIGZhbHNlKTtcbiAgICAgICAgLy8gbW9udGhzIC0gc3RhbmRhbG9uZVxuXG4gICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyID8gc3RyaW5nKHtcbiAgICAgICAgICAgIG1vbnRoOiBcIm51bWVyaWNcIixcbiAgICAgICAgICAgIGRheTogXCJudW1lcmljXCJcbiAgICAgICAgICB9LCBcIm1vbnRoXCIpIDogX3RoaXMubnVtKGR0Lm1vbnRoKTtcblxuICAgICAgICBjYXNlIFwiTExcIjpcbiAgICAgICAgICAvLyBsaWtlIDAxLCBkb2Vzbid0IHNlZW0gdG8gd29ya1xuICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlciA/IHN0cmluZyh7XG4gICAgICAgICAgICBtb250aDogXCIyLWRpZ2l0XCIsXG4gICAgICAgICAgICBkYXk6IFwibnVtZXJpY1wiXG4gICAgICAgICAgfSwgXCJtb250aFwiKSA6IF90aGlzLm51bShkdC5tb250aCwgMik7XG5cbiAgICAgICAgY2FzZSBcIkxMTFwiOlxuICAgICAgICAgIC8vIGxpa2UgSmFuXG4gICAgICAgICAgcmV0dXJuIG1vbnRoKFwic2hvcnRcIiwgdHJ1ZSk7XG5cbiAgICAgICAgY2FzZSBcIkxMTExcIjpcbiAgICAgICAgICAvLyBsaWtlIEphbnVhcnlcbiAgICAgICAgICByZXR1cm4gbW9udGgoXCJsb25nXCIsIHRydWUpO1xuXG4gICAgICAgIGNhc2UgXCJMTExMTFwiOlxuICAgICAgICAgIC8vIGxpa2UgSlxuICAgICAgICAgIHJldHVybiBtb250aChcIm5hcnJvd1wiLCB0cnVlKTtcbiAgICAgICAgLy8gbW9udGhzIC0gZm9ybWF0XG5cbiAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPyBzdHJpbmcoe1xuICAgICAgICAgICAgbW9udGg6IFwibnVtZXJpY1wiXG4gICAgICAgICAgfSwgXCJtb250aFwiKSA6IF90aGlzLm51bShkdC5tb250aCk7XG5cbiAgICAgICAgY2FzZSBcIk1NXCI6XG4gICAgICAgICAgLy8gbGlrZSAwMVxuICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlciA/IHN0cmluZyh7XG4gICAgICAgICAgICBtb250aDogXCIyLWRpZ2l0XCJcbiAgICAgICAgICB9LCBcIm1vbnRoXCIpIDogX3RoaXMubnVtKGR0Lm1vbnRoLCAyKTtcblxuICAgICAgICBjYXNlIFwiTU1NXCI6XG4gICAgICAgICAgLy8gbGlrZSBKYW5cbiAgICAgICAgICByZXR1cm4gbW9udGgoXCJzaG9ydFwiLCBmYWxzZSk7XG5cbiAgICAgICAgY2FzZSBcIk1NTU1cIjpcbiAgICAgICAgICAvLyBsaWtlIEphbnVhcnlcbiAgICAgICAgICByZXR1cm4gbW9udGgoXCJsb25nXCIsIGZhbHNlKTtcblxuICAgICAgICBjYXNlIFwiTU1NTU1cIjpcbiAgICAgICAgICAvLyBsaWtlIEpcbiAgICAgICAgICByZXR1cm4gbW9udGgoXCJuYXJyb3dcIiwgZmFsc2UpO1xuICAgICAgICAvLyB5ZWFyc1xuXG4gICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgLy8gbGlrZSAyMDE0XG4gICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyID8gc3RyaW5nKHtcbiAgICAgICAgICAgIHllYXI6IFwibnVtZXJpY1wiXG4gICAgICAgICAgfSwgXCJ5ZWFyXCIpIDogX3RoaXMubnVtKGR0LnllYXIpO1xuXG4gICAgICAgIGNhc2UgXCJ5eVwiOlxuICAgICAgICAgIC8vIGxpa2UgMTRcbiAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPyBzdHJpbmcoe1xuICAgICAgICAgICAgeWVhcjogXCIyLWRpZ2l0XCJcbiAgICAgICAgICB9LCBcInllYXJcIikgOiBfdGhpcy5udW0oZHQueWVhci50b1N0cmluZygpLnNsaWNlKC0yKSwgMik7XG5cbiAgICAgICAgY2FzZSBcInl5eXlcIjpcbiAgICAgICAgICAvLyBsaWtlIDAwMTJcbiAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPyBzdHJpbmcoe1xuICAgICAgICAgICAgeWVhcjogXCJudW1lcmljXCJcbiAgICAgICAgICB9LCBcInllYXJcIikgOiBfdGhpcy5udW0oZHQueWVhciwgNCk7XG5cbiAgICAgICAgY2FzZSBcInl5eXl5eVwiOlxuICAgICAgICAgIC8vIGxpa2UgMDAwMDEyXG4gICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyID8gc3RyaW5nKHtcbiAgICAgICAgICAgIHllYXI6IFwibnVtZXJpY1wiXG4gICAgICAgICAgfSwgXCJ5ZWFyXCIpIDogX3RoaXMubnVtKGR0LnllYXIsIDYpO1xuICAgICAgICAvLyBlcmFzXG5cbiAgICAgICAgY2FzZSBcIkdcIjpcbiAgICAgICAgICAvLyBsaWtlIEFEXG4gICAgICAgICAgcmV0dXJuIGVyYShcInNob3J0XCIpO1xuXG4gICAgICAgIGNhc2UgXCJHR1wiOlxuICAgICAgICAgIC8vIGxpa2UgQW5ubyBEb21pbmlcbiAgICAgICAgICByZXR1cm4gZXJhKFwibG9uZ1wiKTtcblxuICAgICAgICBjYXNlIFwiR0dHR0dcIjpcbiAgICAgICAgICByZXR1cm4gZXJhKFwibmFycm93XCIpO1xuXG4gICAgICAgIGNhc2UgXCJra1wiOlxuICAgICAgICAgIHJldHVybiBfdGhpcy5udW0oZHQud2Vla1llYXIudG9TdHJpbmcoKS5zbGljZSgtMiksIDIpO1xuXG4gICAgICAgIGNhc2UgXCJra2trXCI6XG4gICAgICAgICAgcmV0dXJuIF90aGlzLm51bShkdC53ZWVrWWVhciwgNCk7XG5cbiAgICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgICByZXR1cm4gX3RoaXMubnVtKGR0LndlZWtOdW1iZXIpO1xuXG4gICAgICAgIGNhc2UgXCJXV1wiOlxuICAgICAgICAgIHJldHVybiBfdGhpcy5udW0oZHQud2Vla051bWJlciwgMik7XG5cbiAgICAgICAgY2FzZSBcIm9cIjpcbiAgICAgICAgICByZXR1cm4gX3RoaXMubnVtKGR0Lm9yZGluYWwpO1xuXG4gICAgICAgIGNhc2UgXCJvb29cIjpcbiAgICAgICAgICByZXR1cm4gX3RoaXMubnVtKGR0Lm9yZGluYWwsIDMpO1xuXG4gICAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgcmV0dXJuIF90aGlzLm51bShkdC5xdWFydGVyKTtcblxuICAgICAgICBjYXNlIFwicXFcIjpcbiAgICAgICAgICAvLyBsaWtlIDAxXG4gICAgICAgICAgcmV0dXJuIF90aGlzLm51bShkdC5xdWFydGVyLCAyKTtcblxuICAgICAgICBjYXNlIFwiWFwiOlxuICAgICAgICAgIHJldHVybiBfdGhpcy5udW0oTWF0aC5mbG9vcihkdC50cyAvIDEwMDApKTtcblxuICAgICAgICBjYXNlIFwieFwiOlxuICAgICAgICAgIHJldHVybiBfdGhpcy5udW0oZHQudHMpO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG1heWJlTWFjcm8odG9rZW4pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5VG9rZW5zKEZvcm1hdHRlci5wYXJzZUZvcm1hdChmbXQpLCB0b2tlblRvU3RyaW5nKTtcbiAgfTtcblxuICBfcHJvdG8uZm9ybWF0RHVyYXRpb25Gcm9tU3RyaW5nID0gZnVuY3Rpb24gZm9ybWF0RHVyYXRpb25Gcm9tU3RyaW5nKGR1ciwgZm10KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgdG9rZW5Ub0ZpZWxkID0gZnVuY3Rpb24gdG9rZW5Ub0ZpZWxkKHRva2VuKSB7XG4gICAgICBzd2l0Y2ggKHRva2VuWzBdKSB7XG4gICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgcmV0dXJuIFwibWlsbGlzZWNvbmRcIjtcblxuICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgIHJldHVybiBcInNlY29uZFwiO1xuXG4gICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgcmV0dXJuIFwibWludXRlXCI7XG5cbiAgICAgICAgY2FzZSBcImhcIjpcbiAgICAgICAgICByZXR1cm4gXCJob3VyXCI7XG5cbiAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICByZXR1cm4gXCJkYXlcIjtcblxuICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgIHJldHVybiBcIm1vbnRoXCI7XG5cbiAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICByZXR1cm4gXCJ5ZWFyXCI7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgICAgICB0b2tlblRvU3RyaW5nID0gZnVuY3Rpb24gdG9rZW5Ub1N0cmluZyhsaWxkdXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdmFyIG1hcHBlZCA9IHRva2VuVG9GaWVsZCh0b2tlbik7XG5cbiAgICAgICAgaWYgKG1hcHBlZCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIubnVtKGxpbGR1ci5nZXQobWFwcGVkKSwgdG9rZW4ubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICAgICAgdG9rZW5zID0gRm9ybWF0dGVyLnBhcnNlRm9ybWF0KGZtdCksXG4gICAgICAgIHJlYWxUb2tlbnMgPSB0b2tlbnMucmVkdWNlKGZ1bmN0aW9uIChmb3VuZCwgX3JlZikge1xuICAgICAgdmFyIGxpdGVyYWwgPSBfcmVmLmxpdGVyYWwsXG4gICAgICAgICAgdmFsID0gX3JlZi52YWw7XG4gICAgICByZXR1cm4gbGl0ZXJhbCA/IGZvdW5kIDogZm91bmQuY29uY2F0KHZhbCk7XG4gICAgfSwgW10pLFxuICAgICAgICBjb2xsYXBzZWQgPSBkdXIuc2hpZnRUby5hcHBseShkdXIsIHJlYWxUb2tlbnMubWFwKHRva2VuVG9GaWVsZCkuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdDtcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5VG9rZW5zKHRva2VucywgdG9rZW5Ub1N0cmluZyhjb2xsYXBzZWQpKTtcbiAgfTtcblxuICByZXR1cm4gRm9ybWF0dGVyO1xufSgpO1xuXG52YXIgSW52YWxpZCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbikge1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMuZXhwbGFuYXRpb24gPSBleHBsYW5hdGlvbjtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBJbnZhbGlkLnByb3RvdHlwZTtcblxuICBfcHJvdG8udG9NZXNzYWdlID0gZnVuY3Rpb24gdG9NZXNzYWdlKCkge1xuICAgIGlmICh0aGlzLmV4cGxhbmF0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFzb24gKyBcIjogXCIgKyB0aGlzLmV4cGxhbmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFzb247XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBJbnZhbGlkO1xufSgpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2VcbiAqL1xuXG52YXIgWm9uZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFpvbmUoKSB7fVxuXG4gIHZhciBfcHJvdG8gPSBab25lLnByb3RvdHlwZTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0J3MgY29tbW9uIG5hbWUgKHN1Y2ggYXMgRVNUKSBhdCB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcFxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRzIC0gRXBvY2ggbWlsbGlzZWNvbmRzIGZvciB3aGljaCB0byBnZXQgdGhlIG5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBPcHRpb25zIHRvIGFmZmVjdCB0aGUgZm9ybWF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmZvcm1hdCAtIFdoYXQgc3R5bGUgb2Ygb2Zmc2V0IHRvIHJldHVybi4gQWNjZXB0cyAnbG9uZycgb3IgJ3Nob3J0Jy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubG9jYWxlIC0gV2hhdCBsb2NhbGUgdG8gcmV0dXJuIHRoZSBvZmZzZXQgbmFtZSBpbi5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgX3Byb3RvLm9mZnNldE5hbWUgPSBmdW5jdGlvbiBvZmZzZXROYW1lKHRzLCBvcHRzKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0J3MgdmFsdWUgYXMgYSBzdHJpbmdcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cyAtIEVwb2NoIG1pbGxpc2Vjb25kcyBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBvZmZzZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCAtIFdoYXQgc3R5bGUgb2Ygb2Zmc2V0IHRvIHJldHVybi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIEFjY2VwdHMgJ25hcnJvdycsICdzaG9ydCcsIG9yICd0ZWNoaWUnLiBSZXR1cm5pbmcgJys2JywgJyswNjowMCcsIG9yICcrMDYwMCcgcmVzcGVjdGl2ZWx5XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZm9ybWF0T2Zmc2V0ID0gZnVuY3Rpb24gZm9ybWF0T2Zmc2V0KHRzLCBmb3JtYXQpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG9mZnNldCBpbiBtaW51dGVzIGZvciB0aGlzIHpvbmUgYXQgdGhlIHNwZWNpZmllZCB0aW1lc3RhbXAuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gdHMgLSBFcG9jaCBtaWxsaXNlY29uZHMgZm9yIHdoaWNoIHRvIGNvbXB1dGUgdGhlIG9mZnNldFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9mZnNldCA9IGZ1bmN0aW9uIG9mZnNldCh0cykge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgWm9uZSBpcyBlcXVhbCB0byBhbm90aGVyIHpvbmVcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7Wm9uZX0gb3RoZXJab25lIC0gdGhlIHpvbmUgdG8gY29tcGFyZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBab25lIGlzIHZhbGlkLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICA7XG5cbiAgX2NyZWF0ZUNsYXNzKFpvbmUsIFt7XG4gICAga2V5OiBcInR5cGVcIixcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHpvbmVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhpcyB6b25lLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuYW1lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIG9mZnNldCBpcyBrbm93biB0byBiZSBmaXhlZCBmb3IgdGhlIHdob2xlIHllYXIuXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1bml2ZXJzYWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVmFsaWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFpvbmU7XG59KCk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBsb2NhbCB6b25lIGZvciB0aGlzIEphdmFTY3JpcHQgZW52aXJvbm1lbnQuXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuXG52YXIgTG9jYWxab25lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfWm9uZSkge1xuICBfaW5oZXJpdHNMb29zZShMb2NhbFpvbmUsIF9ab25lKTtcblxuICBmdW5jdGlvbiBMb2NhbFpvbmUoKSB7XG4gICAgcmV0dXJuIF9ab25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBMb2NhbFpvbmUucHJvdG90eXBlO1xuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIF9wcm90by5vZmZzZXROYW1lID0gZnVuY3Rpb24gb2Zmc2V0TmFtZSh0cywgX3JlZikge1xuICAgIHZhciBmb3JtYXQgPSBfcmVmLmZvcm1hdCxcbiAgICAgICAgbG9jYWxlID0gX3JlZi5sb2NhbGU7XG4gICAgcmV0dXJuIHBhcnNlWm9uZUluZm8odHMsIGZvcm1hdCwgbG9jYWxlKTtcbiAgfVxuICAvKiogQG92ZXJyaWRlICoqL1xuICA7XG5cbiAgX3Byb3RvLmZvcm1hdE9mZnNldCA9IGZ1bmN0aW9uIGZvcm1hdE9mZnNldCQxKHRzLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHRoaXMub2Zmc2V0KHRzKSwgZm9ybWF0KTtcbiAgfVxuICAvKiogQG92ZXJyaWRlICoqL1xuICA7XG5cbiAgX3Byb3RvLm9mZnNldCA9IGZ1bmN0aW9uIG9mZnNldCh0cykge1xuICAgIHJldHVybiAtbmV3IERhdGUodHMpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gIH1cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgO1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgcmV0dXJuIG90aGVyWm9uZS50eXBlID09PSBcImxvY2FsXCI7XG4gIH1cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgO1xuXG4gIF9jcmVhdGVDbGFzcyhMb2NhbFpvbmUsIFt7XG4gICAga2V5OiBcInR5cGVcIixcblxuICAgIC8qKiBAb3ZlcnJpZGUgKiovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gXCJsb2NhbFwiO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmFtZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKGhhc0ludGwoKSkge1xuICAgICAgICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS50aW1lWm9uZTtcbiAgICAgIH0gZWxzZSByZXR1cm4gXCJsb2NhbFwiO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidW5pdmVyc2FsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVmFsaWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImluc3RhbmNlXCIsXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhlIGxvY2FsIHpvbmVcbiAgICAgKiBAcmV0dXJuIHtMb2NhbFpvbmV9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoc2luZ2xldG9uID09PSBudWxsKSB7XG4gICAgICAgIHNpbmdsZXRvbiA9IG5ldyBMb2NhbFpvbmUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNpbmdsZXRvbjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTG9jYWxab25lO1xufShab25lKTtcblxudmFyIG1hdGNoaW5nUmVnZXggPSBSZWdFeHAoXCJeXCIgKyBpYW5hUmVnZXguc291cmNlICsgXCIkXCIpO1xudmFyIGR0ZkNhY2hlID0ge307XG5cbmZ1bmN0aW9uIG1ha2VEVEYoem9uZSkge1xuICBpZiAoIWR0ZkNhY2hlW3pvbmVdKSB7XG4gICAgZHRmQ2FjaGVbem9uZV0gPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHtcbiAgICAgIGhvdXIxMjogZmFsc2UsXG4gICAgICB0aW1lWm9uZTogem9uZSxcbiAgICAgIHllYXI6IFwibnVtZXJpY1wiLFxuICAgICAgbW9udGg6IFwiMi1kaWdpdFwiLFxuICAgICAgZGF5OiBcIjItZGlnaXRcIixcbiAgICAgIGhvdXI6IFwiMi1kaWdpdFwiLFxuICAgICAgbWludXRlOiBcIjItZGlnaXRcIixcbiAgICAgIHNlY29uZDogXCIyLWRpZ2l0XCJcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBkdGZDYWNoZVt6b25lXTtcbn1cblxudmFyIHR5cGVUb1BvcyA9IHtcbiAgeWVhcjogMCxcbiAgbW9udGg6IDEsXG4gIGRheTogMixcbiAgaG91cjogMyxcbiAgbWludXRlOiA0LFxuICBzZWNvbmQ6IDVcbn07XG5cbmZ1bmN0aW9uIGhhY2t5T2Zmc2V0KGR0ZiwgZGF0ZSkge1xuICB2YXIgZm9ybWF0dGVkID0gZHRmLmZvcm1hdChkYXRlKS5yZXBsYWNlKC9cXHUyMDBFL2csIFwiXCIpLFxuICAgICAgcGFyc2VkID0gLyhcXGQrKVxcLyhcXGQrKVxcLyhcXGQrKSw/IChcXGQrKTooXFxkKyk6KFxcZCspLy5leGVjKGZvcm1hdHRlZCksXG4gICAgICBmTW9udGggPSBwYXJzZWRbMV0sXG4gICAgICBmRGF5ID0gcGFyc2VkWzJdLFxuICAgICAgZlllYXIgPSBwYXJzZWRbM10sXG4gICAgICBmSG91ciA9IHBhcnNlZFs0XSxcbiAgICAgIGZNaW51dGUgPSBwYXJzZWRbNV0sXG4gICAgICBmU2Vjb25kID0gcGFyc2VkWzZdO1xuICByZXR1cm4gW2ZZZWFyLCBmTW9udGgsIGZEYXksIGZIb3VyLCBmTWludXRlLCBmU2Vjb25kXTtcbn1cblxuZnVuY3Rpb24gcGFydHNPZmZzZXQoZHRmLCBkYXRlKSB7XG4gIHZhciBmb3JtYXR0ZWQgPSBkdGYuZm9ybWF0VG9QYXJ0cyhkYXRlKSxcbiAgICAgIGZpbGxlZCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm9ybWF0dGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9mb3JtYXR0ZWQkaSA9IGZvcm1hdHRlZFtpXSxcbiAgICAgICAgdHlwZSA9IF9mb3JtYXR0ZWQkaS50eXBlLFxuICAgICAgICB2YWx1ZSA9IF9mb3JtYXR0ZWQkaS52YWx1ZSxcbiAgICAgICAgcG9zID0gdHlwZVRvUG9zW3R5cGVdO1xuXG4gICAgaWYgKCFpc1VuZGVmaW5lZChwb3MpKSB7XG4gICAgICBmaWxsZWRbcG9zXSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbGxlZDtcbn1cblxudmFyIGlhbmFab25lQ2FjaGUgPSB7fTtcbi8qKlxuICogQSB6b25lIGlkZW50aWZpZWQgYnkgYW4gSUFOQSBpZGVudGlmaWVyLCBsaWtlIEFtZXJpY2EvTmV3X1lvcmtcbiAqIEBpbXBsZW1lbnRzIHtab25lfVxuICovXG5cbnZhciBJQU5BWm9uZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1pvbmUpIHtcbiAgX2luaGVyaXRzTG9vc2UoSUFOQVpvbmUsIF9ab25lKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBab25lIG5hbWVcbiAgICogQHJldHVybiB7SUFOQVpvbmV9XG4gICAqL1xuICBJQU5BWm9uZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUobmFtZSkge1xuICAgIGlmICghaWFuYVpvbmVDYWNoZVtuYW1lXSkge1xuICAgICAgaWFuYVpvbmVDYWNoZVtuYW1lXSA9IG5ldyBJQU5BWm9uZShuYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaWFuYVpvbmVDYWNoZVtuYW1lXTtcbiAgfVxuICAvKipcbiAgICogUmVzZXQgbG9jYWwgY2FjaGVzLiBTaG91bGQgb25seSBiZSBuZWNlc3NhcnkgaW4gdGVzdGluZyBzY2VuYXJpb3MuXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICA7XG5cbiAgSUFOQVpvbmUucmVzZXRDYWNoZSA9IGZ1bmN0aW9uIHJlc2V0Q2FjaGUoKSB7XG4gICAgaWFuYVpvbmVDYWNoZSA9IHt9O1xuICAgIGR0ZkNhY2hlID0ge307XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgc3RyaW5nIGlzIGEgdmFsaWQgc3BlY2lmaWVyLiBUaGlzIG9ubHkgY2hlY2tzIHRoZSBzdHJpbmcncyBmb3JtYXQsIG5vdCB0aGF0IHRoZSBzcGVjaWZpZXIgaWRlbnRpZmllcyBhIGtub3duIHpvbmU7IHNlZSBpc1ZhbGlkWm9uZSBmb3IgdGhhdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHMgLSBUaGUgc3RyaW5nIHRvIGNoZWNrIHZhbGlkaXR5IG9uXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRTcGVjaWZpZXIoXCJBbWVyaWNhL05ld19Zb3JrXCIpIC8vPT4gdHJ1ZVxuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkU3BlY2lmaWVyKFwiRmFudGFzaWEvQ2FzdGxlXCIpIC8vPT4gdHJ1ZVxuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkU3BlY2lmaWVyKFwiU3BvcnR+fmJsb3JwXCIpIC8vPT4gZmFsc2VcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIDtcblxuICBJQU5BWm9uZS5pc1ZhbGlkU3BlY2lmaWVyID0gZnVuY3Rpb24gaXNWYWxpZFNwZWNpZmllcihzKSB7XG4gICAgcmV0dXJuICEhKHMgJiYgcy5tYXRjaChtYXRjaGluZ1JlZ2V4KSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgc3RyaW5nIGlkZW50aWZpZXMgYSByZWFsIHpvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHpvbmUgLSBUaGUgc3RyaW5nIHRvIGNoZWNrXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRab25lKFwiQW1lcmljYS9OZXdfWW9ya1wiKSAvLz0+IHRydWVcbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFpvbmUoXCJGYW50YXNpYS9DYXN0bGVcIikgLy89PiBmYWxzZVxuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkWm9uZShcIlNwb3J0fn5ibG9ycFwiKSAvLz0+IGZhbHNlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICA7XG5cbiAgSUFOQVpvbmUuaXNWYWxpZFpvbmUgPSBmdW5jdGlvbiBpc1ZhbGlkWm9uZSh6b25lKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tVVNcIiwge1xuICAgICAgICB0aW1lWm9uZTogem9uZVxuICAgICAgfSkuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IC8vIEV0Yy9HTVQrOCAtPiAtNDgwXG5cbiAgLyoqIEBpZ25vcmUgKi9cbiAgO1xuXG4gIElBTkFab25lLnBhcnNlR01UT2Zmc2V0ID0gZnVuY3Rpb24gcGFyc2VHTVRPZmZzZXQoc3BlY2lmaWVyKSB7XG4gICAgaWYgKHNwZWNpZmllcikge1xuICAgICAgdmFyIG1hdGNoID0gc3BlY2lmaWVyLm1hdGNoKC9eRXRjXFwvR01UKFsrLV1cXGR7MSwyfSkkL2kpO1xuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIC02MCAqIHBhcnNlSW50KG1hdGNoWzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBmdW5jdGlvbiBJQU5BWm9uZShuYW1lKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfWm9uZS5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgLyoqIEBwcml2YXRlICoqL1xuXG4gICAgX3RoaXMuem9uZU5hbWUgPSBuYW1lO1xuICAgIC8qKiBAcHJpdmF0ZSAqKi9cblxuICAgIF90aGlzLnZhbGlkID0gSUFOQVpvbmUuaXNWYWxpZFpvbmUobmFtZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKiBAb3ZlcnJpZGUgKiovXG5cblxuICB2YXIgX3Byb3RvID0gSUFOQVpvbmUucHJvdG90eXBlO1xuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIF9wcm90by5vZmZzZXROYW1lID0gZnVuY3Rpb24gb2Zmc2V0TmFtZSh0cywgX3JlZikge1xuICAgIHZhciBmb3JtYXQgPSBfcmVmLmZvcm1hdCxcbiAgICAgICAgbG9jYWxlID0gX3JlZi5sb2NhbGU7XG4gICAgcmV0dXJuIHBhcnNlWm9uZUluZm8odHMsIGZvcm1hdCwgbG9jYWxlLCB0aGlzLm5hbWUpO1xuICB9XG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIDtcblxuICBfcHJvdG8uZm9ybWF0T2Zmc2V0ID0gZnVuY3Rpb24gZm9ybWF0T2Zmc2V0JDEodHMsIGZvcm1hdCkge1xuICAgIHJldHVybiBmb3JtYXRPZmZzZXQodGhpcy5vZmZzZXQodHMpLCBmb3JtYXQpO1xuICB9XG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIDtcblxuICBfcHJvdG8ub2Zmc2V0ID0gZnVuY3Rpb24gb2Zmc2V0KHRzKSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh0cyksXG4gICAgICAgIGR0ZiA9IG1ha2VEVEYodGhpcy5uYW1lKSxcbiAgICAgICAgX3JlZjIgPSBkdGYuZm9ybWF0VG9QYXJ0cyA/IHBhcnRzT2Zmc2V0KGR0ZiwgZGF0ZSkgOiBoYWNreU9mZnNldChkdGYsIGRhdGUpLFxuICAgICAgICB5ZWFyID0gX3JlZjJbMF0sXG4gICAgICAgIG1vbnRoID0gX3JlZjJbMV0sXG4gICAgICAgIGRheSA9IF9yZWYyWzJdLFxuICAgICAgICBob3VyID0gX3JlZjJbM10sXG4gICAgICAgIG1pbnV0ZSA9IF9yZWYyWzRdLFxuICAgICAgICBzZWNvbmQgPSBfcmVmMls1XSxcbiAgICAgICAgYWRqdXN0ZWRIb3VyID0gaG91ciA9PT0gMjQgPyAwIDogaG91cjtcblxuICAgIHZhciBhc1VUQyA9IG9ialRvTG9jYWxUUyh7XG4gICAgICB5ZWFyOiB5ZWFyLFxuICAgICAgbW9udGg6IG1vbnRoLFxuICAgICAgZGF5OiBkYXksXG4gICAgICBob3VyOiBhZGp1c3RlZEhvdXIsXG4gICAgICBtaW51dGU6IG1pbnV0ZSxcbiAgICAgIHNlY29uZDogc2Vjb25kLFxuICAgICAgbWlsbGlzZWNvbmQ6IDBcbiAgICB9KTtcbiAgICB2YXIgYXNUUyA9ICtkYXRlO1xuICAgIHZhciBvdmVyID0gYXNUUyAlIDEwMDA7XG4gICAgYXNUUyAtPSBvdmVyID49IDAgPyBvdmVyIDogMTAwMCArIG92ZXI7XG4gICAgcmV0dXJuIChhc1VUQyAtIGFzVFMpIC8gKDYwICogMTAwMCk7XG4gIH1cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgO1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgcmV0dXJuIG90aGVyWm9uZS50eXBlID09PSBcImlhbmFcIiAmJiBvdGhlclpvbmUubmFtZSA9PT0gdGhpcy5uYW1lO1xuICB9XG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIDtcblxuICBfY3JlYXRlQ2xhc3MoSUFOQVpvbmUsIFt7XG4gICAga2V5OiBcInR5cGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBcImlhbmFcIjtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm5hbWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnpvbmVOYW1lO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidW5pdmVyc2FsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVmFsaWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbGlkO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJQU5BWm9uZTtcbn0oWm9uZSk7XG5cbnZhciBzaW5nbGV0b24kMSA9IG51bGw7XG4vKipcbiAqIEEgem9uZSB3aXRoIGEgZml4ZWQgb2Zmc2V0IChtZWFuaW5nIG5vIERTVClcbiAqIEBpbXBsZW1lbnRzIHtab25lfVxuICovXG5cbnZhciBGaXhlZE9mZnNldFpvbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9ab25lKSB7XG4gIF9pbmhlcml0c0xvb3NlKEZpeGVkT2Zmc2V0Wm9uZSwgX1pvbmUpO1xuXG4gIC8qKlxuICAgKiBHZXQgYW4gaW5zdGFuY2Ugd2l0aCBhIHNwZWNpZmllZCBvZmZzZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIFRoZSBvZmZzZXQgaW4gbWludXRlc1xuICAgKiBAcmV0dXJuIHtGaXhlZE9mZnNldFpvbmV9XG4gICAqL1xuICBGaXhlZE9mZnNldFpvbmUuaW5zdGFuY2UgPSBmdW5jdGlvbiBpbnN0YW5jZShvZmZzZXQpIHtcbiAgICByZXR1cm4gb2Zmc2V0ID09PSAwID8gRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlIDogbmV3IEZpeGVkT2Zmc2V0Wm9uZShvZmZzZXQpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYW4gaW5zdGFuY2Ugb2YgRml4ZWRPZmZzZXRab25lIGZyb20gYSBVVEMgb2Zmc2V0IHN0cmluZywgbGlrZSBcIlVUQys2XCJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHMgLSBUaGUgb2Zmc2V0IHN0cmluZyB0byBwYXJzZVxuICAgKiBAZXhhbXBsZSBGaXhlZE9mZnNldFpvbmUucGFyc2VTcGVjaWZpZXIoXCJVVEMrNlwiKVxuICAgKiBAZXhhbXBsZSBGaXhlZE9mZnNldFpvbmUucGFyc2VTcGVjaWZpZXIoXCJVVEMrMDZcIilcbiAgICogQGV4YW1wbGUgRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKFwiVVRDLTY6MDBcIilcbiAgICogQHJldHVybiB7Rml4ZWRPZmZzZXRab25lfVxuICAgKi9cbiAgO1xuXG4gIEZpeGVkT2Zmc2V0Wm9uZS5wYXJzZVNwZWNpZmllciA9IGZ1bmN0aW9uIHBhcnNlU3BlY2lmaWVyKHMpIHtcbiAgICBpZiAocykge1xuICAgICAgdmFyIHIgPSBzLm1hdGNoKC9edXRjKD86KFsrLV1cXGR7MSwyfSkoPzo6KFxcZHsyfSkpPyk/JC9pKTtcblxuICAgICAgaWYgKHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE9mZnNldFpvbmUoc2lnbmVkT2Zmc2V0KHJbMV0sIHJbMl0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoRml4ZWRPZmZzZXRab25lLCBudWxsLCBbe1xuICAgIGtleTogXCJ1dGNJbnN0YW5jZVwiLFxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIFVUQ1xuICAgICAqIEByZXR1cm4ge0ZpeGVkT2Zmc2V0Wm9uZX1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmIChzaW5nbGV0b24kMSA9PT0gbnVsbCkge1xuICAgICAgICBzaW5nbGV0b24kMSA9IG5ldyBGaXhlZE9mZnNldFpvbmUoMCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzaW5nbGV0b24kMTtcbiAgICB9XG4gIH1dKTtcblxuICBmdW5jdGlvbiBGaXhlZE9mZnNldFpvbmUob2Zmc2V0KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfWm9uZS5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgLyoqIEBwcml2YXRlICoqL1xuXG4gICAgX3RoaXMuZml4ZWQgPSBvZmZzZXQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKiBAb3ZlcnJpZGUgKiovXG5cblxuICB2YXIgX3Byb3RvID0gRml4ZWRPZmZzZXRab25lLnByb3RvdHlwZTtcblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBfcHJvdG8ub2Zmc2V0TmFtZSA9IGZ1bmN0aW9uIG9mZnNldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuICAvKiogQG92ZXJyaWRlICoqL1xuICA7XG5cbiAgX3Byb3RvLmZvcm1hdE9mZnNldCA9IGZ1bmN0aW9uIGZvcm1hdE9mZnNldCQxKHRzLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHRoaXMuZml4ZWQsIGZvcm1hdCk7XG4gIH1cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgO1xuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIF9wcm90by5vZmZzZXQgPSBmdW5jdGlvbiBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZml4ZWQ7XG4gIH1cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgO1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgcmV0dXJuIG90aGVyWm9uZS50eXBlID09PSBcImZpeGVkXCIgJiYgb3RoZXJab25lLmZpeGVkID09PSB0aGlzLmZpeGVkO1xuICB9XG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIDtcblxuICBfY3JlYXRlQ2xhc3MoRml4ZWRPZmZzZXRab25lLCBbe1xuICAgIGtleTogXCJ0eXBlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gXCJmaXhlZFwiO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmFtZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZml4ZWQgPT09IDAgPyBcIlVUQ1wiIDogXCJVVENcIiArIGZvcm1hdE9mZnNldCh0aGlzLmZpeGVkLCBcIm5hcnJvd1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5pdmVyc2FsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNWYWxpZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZpeGVkT2Zmc2V0Wm9uZTtcbn0oWm9uZSk7XG5cbi8qKlxuICogQSB6b25lIHRoYXQgZmFpbGVkIHRvIHBhcnNlLiBZb3Ugc2hvdWxkIG5ldmVyIG5lZWQgdG8gaW5zdGFudGlhdGUgdGhpcy5cbiAqIEBpbXBsZW1lbnRzIHtab25lfVxuICovXG5cbnZhciBJbnZhbGlkWm9uZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1pvbmUpIHtcbiAgX2luaGVyaXRzTG9vc2UoSW52YWxpZFpvbmUsIF9ab25lKTtcblxuICBmdW5jdGlvbiBJbnZhbGlkWm9uZSh6b25lTmFtZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1pvbmUuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIC8qKiAgQHByaXZhdGUgKi9cblxuICAgIF90aGlzLnpvbmVOYW1lID0gem9uZU5hbWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKiBAb3ZlcnJpZGUgKiovXG5cblxuICB2YXIgX3Byb3RvID0gSW52YWxpZFpvbmUucHJvdG90eXBlO1xuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIF9wcm90by5vZmZzZXROYW1lID0gZnVuY3Rpb24gb2Zmc2V0TmFtZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKiogQG92ZXJyaWRlICoqL1xuICA7XG5cbiAgX3Byb3RvLmZvcm1hdE9mZnNldCA9IGZ1bmN0aW9uIGZvcm1hdE9mZnNldCgpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICAvKiogQG92ZXJyaWRlICoqL1xuICA7XG5cbiAgX3Byb3RvLm9mZnNldCA9IGZ1bmN0aW9uIG9mZnNldCgpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIDtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKiogQG92ZXJyaWRlICoqL1xuICA7XG5cbiAgX2NyZWF0ZUNsYXNzKEludmFsaWRab25lLCBbe1xuICAgIGtleTogXCJ0eXBlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gXCJpbnZhbGlkXCI7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKiovXG5cbiAgfSwge1xuICAgIGtleTogXCJuYW1lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy56b25lTmFtZTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVuaXZlcnNhbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1ZhbGlkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEludmFsaWRab25lO1xufShab25lKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVab25lKGlucHV0LCBkZWZhdWx0Wm9uZSkge1xuICB2YXIgb2Zmc2V0O1xuXG4gIGlmIChpc1VuZGVmaW5lZChpbnB1dCkgfHwgaW5wdXQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZGVmYXVsdFpvbmU7XG4gIH0gZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBab25lKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9IGVsc2UgaWYgKGlzU3RyaW5nKGlucHV0KSkge1xuICAgIHZhciBsb3dlcmVkID0gaW5wdXQudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobG93ZXJlZCA9PT0gXCJsb2NhbFwiKSByZXR1cm4gZGVmYXVsdFpvbmU7ZWxzZSBpZiAobG93ZXJlZCA9PT0gXCJ1dGNcIiB8fCBsb3dlcmVkID09PSBcImdtdFwiKSByZXR1cm4gRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlO2Vsc2UgaWYgKChvZmZzZXQgPSBJQU5BWm9uZS5wYXJzZUdNVE9mZnNldChpbnB1dCkpICE9IG51bGwpIHtcbiAgICAgIC8vIGhhbmRsZSBFdGMvR01ULTQsIHdoaWNoIFY4IGNob2tlcyBvblxuICAgICAgcmV0dXJuIEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShvZmZzZXQpO1xuICAgIH0gZWxzZSBpZiAoSUFOQVpvbmUuaXNWYWxpZFNwZWNpZmllcihsb3dlcmVkKSkgcmV0dXJuIElBTkFab25lLmNyZWF0ZShpbnB1dCk7ZWxzZSByZXR1cm4gRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKGxvd2VyZWQpIHx8IG5ldyBJbnZhbGlkWm9uZShpbnB1dCk7XG4gIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgcmV0dXJuIEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShpbnB1dCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiICYmIGlucHV0Lm9mZnNldCAmJiB0eXBlb2YgaW5wdXQub2Zmc2V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgLy8gVGhpcyBpcyBkdW1iLCBidXQgdGhlIGluc3RhbmNlb2YgY2hlY2sgYWJvdmUgZG9lc24ndCBzZWVtIHRvIHJlYWxseSB3b3JrXG4gICAgLy8gc28gd2UncmUgZHVjayBjaGVja2luZyBpdFxuICAgIHJldHVybiBpbnB1dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEludmFsaWRab25lKGlucHV0KTtcbiAgfVxufVxuXG52YXIgbm93ID0gZnVuY3Rpb24gbm93KCkge1xuICByZXR1cm4gRGF0ZS5ub3coKTtcbn0sXG4gICAgZGVmYXVsdFpvbmUgPSBudWxsLFxuICAgIC8vIG5vdCBzZXR0aW5nIHRoaXMgZGlyZWN0bHkgdG8gTG9jYWxab25lLmluc3RhbmNlIGJjIGxvYWRpbmcgb3JkZXIgaXNzdWVzXG5kZWZhdWx0TG9jYWxlID0gbnVsbCxcbiAgICBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtID0gbnVsbCxcbiAgICBkZWZhdWx0T3V0cHV0Q2FsZW5kYXIgPSBudWxsLFxuICAgIHRocm93T25JbnZhbGlkID0gZmFsc2U7XG4vKipcbiAqIFNldHRpbmdzIGNvbnRhaW5zIHN0YXRpYyBnZXR0ZXJzIGFuZCBzZXR0ZXJzIHRoYXQgY29udHJvbCBMdXhvbidzIG92ZXJhbGwgYmVoYXZpb3IuIEx1eG9uIGlzIGEgc2ltcGxlIGxpYnJhcnkgd2l0aCBmZXcgb3B0aW9ucywgYnV0IHRoZSBvbmVzIGl0IGRvZXMgaGF2ZSBsaXZlIGhlcmUuXG4gKi9cblxuXG52YXIgU2V0dGluZ3MgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTZXR0aW5ncygpIHt9XG5cbiAgLyoqXG4gICAqIFJlc2V0IEx1eG9uJ3MgZ2xvYmFsIGNhY2hlcy4gU2hvdWxkIG9ubHkgYmUgbmVjZXNzYXJ5IGluIHRlc3Rpbmcgc2NlbmFyaW9zLlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgU2V0dGluZ3MucmVzZXRDYWNoZXMgPSBmdW5jdGlvbiByZXNldENhY2hlcygpIHtcbiAgICBMb2NhbGUucmVzZXRDYWNoZSgpO1xuICAgIElBTkFab25lLnJlc2V0Q2FjaGUoKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoU2V0dGluZ3MsIG51bGwsIFt7XG4gICAga2V5OiBcIm5vd1wiLFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjYWxsYmFjayBmb3IgcmV0dXJuaW5nIHRoZSBjdXJyZW50IHRpbWVzdGFtcC5cbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gbm93O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNhbGxiYWNrIGZvciByZXR1cm5pbmcgdGhlIGN1cnJlbnQgdGltZXN0YW1wLlxuICAgICAqIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgbnVtYmVyLCB3aGljaCB3aWxsIGJlIGludGVycHJldGVkIGFzIGFuIEVwb2NoIG1pbGxpc2Vjb25kIGNvdW50XG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqIEBleGFtcGxlIFNldHRpbmdzLm5vdyA9ICgpID0+IERhdGUubm93KCkgKyAzMDAwIC8vIHByZXRlbmQgaXQgaXMgMyBzZWNvbmRzIGluIHRoZSBmdXR1cmVcbiAgICAgKiBAZXhhbXBsZSBTZXR0aW5ncy5ub3cgPSAoKSA9PiAwIC8vIGFsd2F5cyBwcmV0ZW5kIGl0J3MgSmFuIDEsIDE5NzAgYXQgbWlkbmlnaHQgaW4gVVRDIHRpbWVcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobikge1xuICAgICAgbm93ID0gbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkZWZhdWx0IHRpbWUgem9uZSB0byBjcmVhdGUgRGF0ZVRpbWVzIGluLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZWZhdWx0Wm9uZU5hbWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBTZXR0aW5ncy5kZWZhdWx0Wm9uZS5uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGRlZmF1bHQgdGltZSB6b25lIHRvIGNyZWF0ZSBEYXRlVGltZXMgaW4uIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoeikge1xuICAgICAgaWYgKCF6KSB7XG4gICAgICAgIGRlZmF1bHRab25lID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmF1bHRab25lID0gbm9ybWFsaXplWm9uZSh6KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkZWZhdWx0IHRpbWUgem9uZSBvYmplY3QgdG8gY3JlYXRlIERhdGVUaW1lcyBpbi4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICAgKiBAdHlwZSB7Wm9uZX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlZmF1bHRab25lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFpvbmUgfHwgTG9jYWxab25lLmluc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRlZmF1bHQgbG9jYWxlIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVmYXVsdExvY2FsZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRMb2NhbGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZGVmYXVsdCBsb2NhbGUgdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGxvY2FsZSkge1xuICAgICAgZGVmYXVsdExvY2FsZSA9IGxvY2FsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkZWZhdWx0IG51bWJlcmluZyBzeXN0ZW0gdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZWZhdWx0TnVtYmVyaW5nU3lzdGVtXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdE51bWJlcmluZ1N5c3RlbTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBkZWZhdWx0IG51bWJlcmluZyBzeXN0ZW0gdG8gY3JlYXRlIERhdGVUaW1lcyB3aXRoLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG51bWJlcmluZ1N5c3RlbSkge1xuICAgICAgZGVmYXVsdE51bWJlcmluZ1N5c3RlbSA9IG51bWJlcmluZ1N5c3RlbTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkZWZhdWx0IG91dHB1dCBjYWxlbmRhciB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlZmF1bHRPdXRwdXRDYWxlbmRhclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRPdXRwdXRDYWxlbmRhcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBkZWZhdWx0IG91dHB1dCBjYWxlbmRhciB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQob3V0cHV0Q2FsZW5kYXIpIHtcbiAgICAgIGRlZmF1bHRPdXRwdXRDYWxlbmRhciA9IG91dHB1dENhbGVuZGFyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgd2hldGhlciBMdXhvbiB3aWxsIHRocm93IHdoZW4gaXQgZW5jb3VudGVycyBpbnZhbGlkIERhdGVUaW1lcywgRHVyYXRpb25zLCBvciBJbnRlcnZhbHNcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRocm93T25JbnZhbGlkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhyb3dPbkludmFsaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB3aGV0aGVyIEx1eG9uIHdpbGwgdGhyb3cgd2hlbiBpdCBlbmNvdW50ZXJzIGludmFsaWQgRGF0ZVRpbWVzLCBEdXJhdGlvbnMsIG9yIEludGVydmFsc1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0KSB7XG4gICAgICB0aHJvd09uSW52YWxpZCA9IHQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNldHRpbmdzO1xufSgpO1xuXG52YXIgaW50bERUQ2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q2FjaGVkRFRGKGxvY1N0cmluZywgb3B0cykge1xuICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgdmFyIGtleSA9IEpTT04uc3RyaW5naWZ5KFtsb2NTdHJpbmcsIG9wdHNdKTtcbiAgdmFyIGR0ZiA9IGludGxEVENhY2hlW2tleV07XG5cbiAgaWYgKCFkdGYpIHtcbiAgICBkdGYgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NTdHJpbmcsIG9wdHMpO1xuICAgIGludGxEVENhY2hlW2tleV0gPSBkdGY7XG4gIH1cblxuICByZXR1cm4gZHRmO1xufVxuXG52YXIgaW50bE51bUNhY2hlID0ge307XG5cbmZ1bmN0aW9uIGdldENhY2hlZElORihsb2NTdHJpbmcsIG9wdHMpIHtcbiAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIHZhciBrZXkgPSBKU09OLnN0cmluZ2lmeShbbG9jU3RyaW5nLCBvcHRzXSk7XG4gIHZhciBpbmYgPSBpbnRsTnVtQ2FjaGVba2V5XTtcblxuICBpZiAoIWluZikge1xuICAgIGluZiA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NTdHJpbmcsIG9wdHMpO1xuICAgIGludGxOdW1DYWNoZVtrZXldID0gaW5mO1xuICB9XG5cbiAgcmV0dXJuIGluZjtcbn1cblxudmFyIGludGxSZWxDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDYWNoZWRSVEYobG9jU3RyaW5nLCBvcHRzKSB7XG4gIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICBvcHRzID0ge307XG4gIH1cblxuICB2YXIgX29wdHMgPSBvcHRzLFxuICAgICAgYmFzZSA9IF9vcHRzLmJhc2UsXG4gICAgICBjYWNoZUtleU9wdHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfb3B0cywgW1wiYmFzZVwiXSk7IC8vIGV4Y2x1ZGUgYGJhc2VgIGZyb20gdGhlIG9wdGlvbnNcblxuXG4gIHZhciBrZXkgPSBKU09OLnN0cmluZ2lmeShbbG9jU3RyaW5nLCBjYWNoZUtleU9wdHNdKTtcbiAgdmFyIGluZiA9IGludGxSZWxDYWNoZVtrZXldO1xuXG4gIGlmICghaW5mKSB7XG4gICAgaW5mID0gbmV3IEludGwuUmVsYXRpdmVUaW1lRm9ybWF0KGxvY1N0cmluZywgb3B0cyk7XG4gICAgaW50bFJlbENhY2hlW2tleV0gPSBpbmY7XG4gIH1cblxuICByZXR1cm4gaW5mO1xufVxuXG52YXIgc3lzTG9jYWxlQ2FjaGUgPSBudWxsO1xuXG5mdW5jdGlvbiBzeXN0ZW1Mb2NhbGUoKSB7XG4gIGlmIChzeXNMb2NhbGVDYWNoZSkge1xuICAgIHJldHVybiBzeXNMb2NhbGVDYWNoZTtcbiAgfSBlbHNlIGlmIChoYXNJbnRsKCkpIHtcbiAgICB2YXIgY29tcHV0ZWRTeXMgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLmxvY2FsZTsgLy8gbm9kZSBzb21ldGltZXMgZGVmYXVsdHMgdG8gXCJ1bmRcIi4gT3ZlcnJpZGUgdGhhdCBiZWNhdXNlIHRoYXQgaXMgZHVtYlxuXG4gICAgc3lzTG9jYWxlQ2FjaGUgPSAhY29tcHV0ZWRTeXMgfHwgY29tcHV0ZWRTeXMgPT09IFwidW5kXCIgPyBcImVuLVVTXCIgOiBjb21wdXRlZFN5cztcbiAgICByZXR1cm4gc3lzTG9jYWxlQ2FjaGU7XG4gIH0gZWxzZSB7XG4gICAgc3lzTG9jYWxlQ2FjaGUgPSBcImVuLVVTXCI7XG4gICAgcmV0dXJuIHN5c0xvY2FsZUNhY2hlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlTG9jYWxlU3RyaW5nKGxvY2FsZVN0cikge1xuICAvLyBJIHJlYWxseSB3YW50IHRvIGF2b2lkIHdyaXRpbmcgYSBCQ1AgNDcgcGFyc2VyXG4gIC8vIHNlZSwgZS5nLiBodHRwczovL2dpdGh1Yi5jb20vd29vb3JtL2JjcC00N1xuICAvLyBJbnN0ZWFkLCB3ZSdsbCBkbyB0aGlzOlxuICAvLyBhKSBpZiB0aGUgc3RyaW5nIGhhcyBubyAtdSBleHRlbnNpb25zLCBqdXN0IGxlYXZlIGl0IGFsb25lXG4gIC8vIGIpIGlmIGl0IGRvZXMsIHVzZSBJbnRsIHRvIHJlc29sdmUgZXZlcnl0aGluZ1xuICAvLyBjKSBpZiBJbnRsIGZhaWxzLCB0cnkgYWdhaW4gd2l0aG91dCB0aGUgLXVcbiAgdmFyIHVJbmRleCA9IGxvY2FsZVN0ci5pbmRleE9mKFwiLXUtXCIpO1xuXG4gIGlmICh1SW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuIFtsb2NhbGVTdHJdO1xuICB9IGVsc2Uge1xuICAgIHZhciBvcHRpb25zO1xuICAgIHZhciBzbWFsbGVyID0gbG9jYWxlU3RyLnN1YnN0cmluZygwLCB1SW5kZXgpO1xuXG4gICAgdHJ5IHtcbiAgICAgIG9wdGlvbnMgPSBnZXRDYWNoZWREVEYobG9jYWxlU3RyKS5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBvcHRpb25zID0gZ2V0Q2FjaGVkRFRGKHNtYWxsZXIpLnJlc29sdmVkT3B0aW9ucygpO1xuICAgIH1cblxuICAgIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSA9IF9vcHRpb25zLm51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgY2FsZW5kYXIgPSBfb3B0aW9ucy5jYWxlbmRhcjsgLy8gcmV0dXJuIHRoZSBzbWFsbGVyIG9uZSBzbyB0aGF0IHdlIGNhbiBhcHBlbmQgdGhlIGNhbGVuZGFyIGFuZCBudW1iZXJpbmcgb3ZlcnJpZGVzIHRvIGl0XG5cbiAgICByZXR1cm4gW3NtYWxsZXIsIG51bWJlcmluZ1N5c3RlbSwgY2FsZW5kYXJdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGxDb25maWdTdHJpbmcobG9jYWxlU3RyLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyKSB7XG4gIGlmIChoYXNJbnRsKCkpIHtcbiAgICBpZiAob3V0cHV0Q2FsZW5kYXIgfHwgbnVtYmVyaW5nU3lzdGVtKSB7XG4gICAgICBsb2NhbGVTdHIgKz0gXCItdVwiO1xuXG4gICAgICBpZiAob3V0cHV0Q2FsZW5kYXIpIHtcbiAgICAgICAgbG9jYWxlU3RyICs9IFwiLWNhLVwiICsgb3V0cHV0Q2FsZW5kYXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChudW1iZXJpbmdTeXN0ZW0pIHtcbiAgICAgICAgbG9jYWxlU3RyICs9IFwiLW51LVwiICsgbnVtYmVyaW5nU3lzdGVtO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbG9jYWxlU3RyO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbG9jYWxlU3RyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFwTW9udGhzKGYpIHtcbiAgdmFyIG1zID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gMTI7IGkrKykge1xuICAgIHZhciBkdCA9IERhdGVUaW1lLnV0YygyMDE2LCBpLCAxKTtcbiAgICBtcy5wdXNoKGYoZHQpKTtcbiAgfVxuXG4gIHJldHVybiBtcztcbn1cblxuZnVuY3Rpb24gbWFwV2Vla2RheXMoZikge1xuICB2YXIgbXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8PSA3OyBpKyspIHtcbiAgICB2YXIgZHQgPSBEYXRlVGltZS51dGMoMjAxNiwgMTEsIDEzICsgaSk7XG4gICAgbXMucHVzaChmKGR0KSk7XG4gIH1cblxuICByZXR1cm4gbXM7XG59XG5cbmZ1bmN0aW9uIGxpc3RTdHVmZihsb2MsIGxlbmd0aCwgZGVmYXVsdE9LLCBlbmdsaXNoRm4sIGludGxGbikge1xuICB2YXIgbW9kZSA9IGxvYy5saXN0aW5nTW9kZShkZWZhdWx0T0spO1xuXG4gIGlmIChtb2RlID09PSBcImVycm9yXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmIChtb2RlID09PSBcImVuXCIpIHtcbiAgICByZXR1cm4gZW5nbGlzaEZuKGxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGludGxGbihsZW5ndGgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRzRmFzdE51bWJlcnMobG9jKSB7XG4gIGlmIChsb2MubnVtYmVyaW5nU3lzdGVtICYmIGxvYy5udW1iZXJpbmdTeXN0ZW0gIT09IFwibGF0blwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsb2MubnVtYmVyaW5nU3lzdGVtID09PSBcImxhdG5cIiB8fCAhbG9jLmxvY2FsZSB8fCBsb2MubG9jYWxlLnN0YXJ0c1dpdGgoXCJlblwiKSB8fCBoYXNJbnRsKCkgJiYgbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jLmludGwpLnJlc29sdmVkT3B0aW9ucygpLm51bWJlcmluZ1N5c3RlbSA9PT0gXCJsYXRuXCI7XG4gIH1cbn1cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5cbnZhciBQb2x5TnVtYmVyRm9ybWF0dGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUG9seU51bWJlckZvcm1hdHRlcihpbnRsLCBmb3JjZVNpbXBsZSwgb3B0cykge1xuICAgIHRoaXMucGFkVG8gPSBvcHRzLnBhZFRvIHx8IDA7XG4gICAgdGhpcy5mbG9vciA9IG9wdHMuZmxvb3IgfHwgZmFsc2U7XG5cbiAgICBpZiAoIWZvcmNlU2ltcGxlICYmIGhhc0ludGwoKSkge1xuICAgICAgdmFyIGludGxPcHRzID0ge1xuICAgICAgICB1c2VHcm91cGluZzogZmFsc2VcbiAgICAgIH07XG4gICAgICBpZiAob3B0cy5wYWRUbyA+IDApIGludGxPcHRzLm1pbmltdW1JbnRlZ2VyRGlnaXRzID0gb3B0cy5wYWRUbztcbiAgICAgIHRoaXMuaW5mID0gZ2V0Q2FjaGVkSU5GKGludGwsIGludGxPcHRzKTtcbiAgICB9XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUG9seU51bWJlckZvcm1hdHRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmZvcm1hdCA9IGZ1bmN0aW9uIGZvcm1hdChpKSB7XG4gICAgaWYgKHRoaXMuaW5mKSB7XG4gICAgICB2YXIgZml4ZWQgPSB0aGlzLmZsb29yID8gTWF0aC5mbG9vcihpKSA6IGk7XG4gICAgICByZXR1cm4gdGhpcy5pbmYuZm9ybWF0KGZpeGVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdG8gbWF0Y2ggdGhlIGJyb3dzZXIncyBudW1iZXJmb3JtYXR0ZXIgZGVmYXVsdHNcbiAgICAgIHZhciBfZml4ZWQgPSB0aGlzLmZsb29yID8gTWF0aC5mbG9vcihpKSA6IHJvdW5kVG8oaSwgMyk7XG5cbiAgICAgIHJldHVybiBwYWRTdGFydChfZml4ZWQsIHRoaXMucGFkVG8pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUG9seU51bWJlckZvcm1hdHRlcjtcbn0oKTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5cbnZhciBQb2x5RGF0ZUZvcm1hdHRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBvbHlEYXRlRm9ybWF0dGVyKGR0LCBpbnRsLCBvcHRzKSB7XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICB0aGlzLmhhc0ludGwgPSBoYXNJbnRsKCk7XG4gICAgdmFyIHo7XG5cbiAgICBpZiAoZHQuem9uZS51bml2ZXJzYWwgJiYgdGhpcy5oYXNJbnRsKSB7XG4gICAgICAvLyBVVEMtOCBvciBFdGMvVVRDLTggYXJlIG5vdCBwYXJ0IG9mIHR6ZGF0YSwgb25seSBFdGMvR01UKzggYW5kIHRoZSBsaWtlLlxuICAgICAgLy8gVGhhdCBpcyB3aHkgZml4ZWQtb2Zmc2V0IFRaIGlzIHNldCB0byB0aGF0IHVubGVzcyBpdCBpczpcbiAgICAgIC8vIDEuIE91dHNpZGUgb2YgdGhlIHN1cHBvcnRlZCByYW5nZSBFdGMvR01ULTE0IHRvIEV0Yy9HTVQrMTIuXG4gICAgICAvLyAyLiBOb3QgYSB3aG9sZSBob3VyLCBlLmcuIFVUQys0OjMwLlxuICAgICAgdmFyIGdtdE9mZnNldCA9IC0xICogKGR0Lm9mZnNldCAvIDYwKTtcblxuICAgICAgaWYgKGdtdE9mZnNldCA+PSAtMTQgJiYgZ210T2Zmc2V0IDw9IDEyICYmIGdtdE9mZnNldCAlIDEgPT09IDApIHtcbiAgICAgICAgeiA9IGdtdE9mZnNldCA+PSAwID8gXCJFdGMvR01UK1wiICsgZ210T2Zmc2V0IDogXCJFdGMvR01UXCIgKyBnbXRPZmZzZXQ7XG4gICAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vdCBhbGwgZml4ZWQtb2Zmc2V0IHpvbmVzIGxpa2UgRXRjLys0OjMwIGFyZSBwcmVzZW50IGluIHR6ZGF0YS5cbiAgICAgICAgLy8gU28gd2UgaGF2ZSB0byBtYWtlIGRvLiBUd28gY2FzZXM6XG4gICAgICAgIC8vIDEuIFRoZSBmb3JtYXQgb3B0aW9ucyB0ZWxsIHVzIHRvIHNob3cgdGhlIHpvbmUuIFdlIGNhbid0IGRvIHRoYXQsIHNvIHRoZSBiZXN0XG4gICAgICAgIC8vIHdlIGNhbiBkbyBpcyBmb3JtYXQgdGhlIGRhdGUgaW4gVVRDLlxuICAgICAgICAvLyAyLiBUaGUgZm9ybWF0IG9wdGlvbnMgZG9uJ3QgdGVsbCB1cyB0byBzaG93IHRoZSB6b25lLiBUaGVuIHdlIGNhbiBhZGp1c3QgdGhlbVxuICAgICAgICAvLyB0aGUgdGltZSBhbmQgdGVsbCB0aGUgZm9ybWF0dGVyIHRvIHNob3cgaXQgdG8gdXMgaW4gVVRDLCBzbyB0aGF0IHRoZSB0aW1lIGlzIHJpZ2h0XG4gICAgICAgIC8vIGFuZCB0aGUgYmFkIHpvbmUgZG9lc24ndCBzaG93IHVwLlxuICAgICAgICB6ID0gXCJVVENcIjtcblxuICAgICAgICBpZiAob3B0cy50aW1lWm9uZU5hbWUpIHtcbiAgICAgICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kdCA9IGR0Lm9mZnNldCA9PT0gMCA/IGR0IDogRGF0ZVRpbWUuZnJvbU1pbGxpcyhkdC50cyArIGR0Lm9mZnNldCAqIDYwICogMTAwMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGR0LnpvbmUudHlwZSA9PT0gXCJsb2NhbFwiKSB7XG4gICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICAgIHogPSBkdC56b25lLm5hbWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzSW50bCkge1xuICAgICAgdmFyIGludGxPcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRzKTtcblxuICAgICAgaWYgKHopIHtcbiAgICAgICAgaW50bE9wdHMudGltZVpvbmUgPSB6O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmR0ZiA9IGdldENhY2hlZERURihpbnRsLCBpbnRsT3B0cyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBQb2x5RGF0ZUZvcm1hdHRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi5mb3JtYXQgPSBmdW5jdGlvbiBmb3JtYXQoKSB7XG4gICAgaWYgKHRoaXMuaGFzSW50bCkge1xuICAgICAgcmV0dXJuIHRoaXMuZHRmLmZvcm1hdCh0aGlzLmR0LnRvSlNEYXRlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdG9rZW5Gb3JtYXQgPSBmb3JtYXRTdHJpbmcodGhpcy5vcHRzKSxcbiAgICAgICAgICBsb2MgPSBMb2NhbGUuY3JlYXRlKFwiZW4tVVNcIik7XG4gICAgICByZXR1cm4gRm9ybWF0dGVyLmNyZWF0ZShsb2MpLmZvcm1hdERhdGVUaW1lRnJvbVN0cmluZyh0aGlzLmR0LCB0b2tlbkZvcm1hdCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90bzIuZm9ybWF0VG9QYXJ0cyA9IGZ1bmN0aW9uIGZvcm1hdFRvUGFydHMoKSB7XG4gICAgaWYgKHRoaXMuaGFzSW50bCAmJiBoYXNGb3JtYXRUb1BhcnRzKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmR0Zi5mb3JtYXRUb1BhcnRzKHRoaXMuZHQudG9KU0RhdGUoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMga2luZCBvZiBhIGNvcCBvdXQuIFdlIGFjdHVhbGx5IGNvdWxkIGRvIHRoaXMgZm9yIEVuZ2xpc2guIEhvd2V2ZXIsIHdlIGNvdWxkbid0IGRvIGl0IGZvciBpbnRsIHN0cmluZ3NcbiAgICAgIC8vIGFuZCBJTU8gaXQncyB0b28gd2VpcmQgdG8gaGF2ZSBhbiB1bmNhbm55IHZhbGxleSBsaWtlIHRoYXRcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvMi5yZXNvbHZlZE9wdGlvbnMgPSBmdW5jdGlvbiByZXNvbHZlZE9wdGlvbnMoKSB7XG4gICAgaWYgKHRoaXMuaGFzSW50bCkge1xuICAgICAgcmV0dXJuIHRoaXMuZHRmLnJlc29sdmVkT3B0aW9ucygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsb2NhbGU6IFwiZW4tVVNcIixcbiAgICAgICAgbnVtYmVyaW5nU3lzdGVtOiBcImxhdG5cIixcbiAgICAgICAgb3V0cHV0Q2FsZW5kYXI6IFwiZ3JlZ29yeVwiXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUG9seURhdGVGb3JtYXR0ZXI7XG59KCk7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuXG52YXIgUG9seVJlbEZvcm1hdHRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBvbHlSZWxGb3JtYXR0ZXIoaW50bCwgaXNFbmdsaXNoLCBvcHRzKSB7XG4gICAgdGhpcy5vcHRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBzdHlsZTogXCJsb25nXCJcbiAgICB9LCBvcHRzKTtcblxuICAgIGlmICghaXNFbmdsaXNoICYmIGhhc1JlbGF0aXZlKCkpIHtcbiAgICAgIHRoaXMucnRmID0gZ2V0Q2FjaGVkUlRGKGludGwsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfcHJvdG8zID0gUG9seVJlbEZvcm1hdHRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMy5mb3JtYXQgPSBmdW5jdGlvbiBmb3JtYXQoY291bnQsIHVuaXQpIHtcbiAgICBpZiAodGhpcy5ydGYpIHtcbiAgICAgIHJldHVybiB0aGlzLnJ0Zi5mb3JtYXQoY291bnQsIHVuaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZm9ybWF0UmVsYXRpdmVUaW1lKHVuaXQsIGNvdW50LCB0aGlzLm9wdHMubnVtZXJpYywgdGhpcy5vcHRzLnN0eWxlICE9PSBcImxvbmdcIik7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90bzMuZm9ybWF0VG9QYXJ0cyA9IGZ1bmN0aW9uIGZvcm1hdFRvUGFydHMoY291bnQsIHVuaXQpIHtcbiAgICBpZiAodGhpcy5ydGYpIHtcbiAgICAgIHJldHVybiB0aGlzLnJ0Zi5mb3JtYXRUb1BhcnRzKGNvdW50LCB1bml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUG9seVJlbEZvcm1hdHRlcjtcbn0oKTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5cbnZhciBMb2NhbGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBMb2NhbGUuZnJvbU9wdHMgPSBmdW5jdGlvbiBmcm9tT3B0cyhvcHRzKSB7XG4gICAgcmV0dXJuIExvY2FsZS5jcmVhdGUob3B0cy5sb2NhbGUsIG9wdHMubnVtYmVyaW5nU3lzdGVtLCBvcHRzLm91dHB1dENhbGVuZGFyLCBvcHRzLmRlZmF1bHRUb0VOKTtcbiAgfTtcblxuICBMb2NhbGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhciwgZGVmYXVsdFRvRU4pIHtcbiAgICBpZiAoZGVmYXVsdFRvRU4gPT09IHZvaWQgMCkge1xuICAgICAgZGVmYXVsdFRvRU4gPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc3BlY2lmaWVkTG9jYWxlID0gbG9jYWxlIHx8IFNldHRpbmdzLmRlZmF1bHRMb2NhbGUsXG4gICAgICAgIC8vIHRoZSBzeXN0ZW0gbG9jYWxlIGlzIHVzZWZ1bCBmb3IgaHVtYW4gcmVhZGFibGUgc3RyaW5ncyBidXQgYW5ub3lpbmcgZm9yIHBhcnNpbmcvZm9ybWF0dGluZyBrbm93biBmb3JtYXRzXG4gICAgbG9jYWxlUiA9IHNwZWNpZmllZExvY2FsZSB8fCAoZGVmYXVsdFRvRU4gPyBcImVuLVVTXCIgOiBzeXN0ZW1Mb2NhbGUoKSksXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbVIgPSBudW1iZXJpbmdTeXN0ZW0gfHwgU2V0dGluZ3MuZGVmYXVsdE51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgb3V0cHV0Q2FsZW5kYXJSID0gb3V0cHV0Q2FsZW5kYXIgfHwgU2V0dGluZ3MuZGVmYXVsdE91dHB1dENhbGVuZGFyO1xuICAgIHJldHVybiBuZXcgTG9jYWxlKGxvY2FsZVIsIG51bWJlcmluZ1N5c3RlbVIsIG91dHB1dENhbGVuZGFyUiwgc3BlY2lmaWVkTG9jYWxlKTtcbiAgfTtcblxuICBMb2NhbGUucmVzZXRDYWNoZSA9IGZ1bmN0aW9uIHJlc2V0Q2FjaGUoKSB7XG4gICAgc3lzTG9jYWxlQ2FjaGUgPSBudWxsO1xuICAgIGludGxEVENhY2hlID0ge307XG4gICAgaW50bE51bUNhY2hlID0ge307XG4gICAgaW50bFJlbENhY2hlID0ge307XG4gIH07XG5cbiAgTG9jYWxlLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KF90ZW1wKSB7XG4gICAgdmFyIF9yZWYgPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcCxcbiAgICAgICAgbG9jYWxlID0gX3JlZi5sb2NhbGUsXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSA9IF9yZWYubnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBvdXRwdXRDYWxlbmRhciA9IF9yZWYub3V0cHV0Q2FsZW5kYXI7XG5cbiAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIExvY2FsZShsb2NhbGUsIG51bWJlcmluZywgb3V0cHV0Q2FsZW5kYXIsIHNwZWNpZmllZExvY2FsZSkge1xuICAgIHZhciBfcGFyc2VMb2NhbGVTdHJpbmcgPSBwYXJzZUxvY2FsZVN0cmluZyhsb2NhbGUpLFxuICAgICAgICBwYXJzZWRMb2NhbGUgPSBfcGFyc2VMb2NhbGVTdHJpbmdbMF0sXG4gICAgICAgIHBhcnNlZE51bWJlcmluZ1N5c3RlbSA9IF9wYXJzZUxvY2FsZVN0cmluZ1sxXSxcbiAgICAgICAgcGFyc2VkT3V0cHV0Q2FsZW5kYXIgPSBfcGFyc2VMb2NhbGVTdHJpbmdbMl07XG5cbiAgICB0aGlzLmxvY2FsZSA9IHBhcnNlZExvY2FsZTtcbiAgICB0aGlzLm51bWJlcmluZ1N5c3RlbSA9IG51bWJlcmluZyB8fCBwYXJzZWROdW1iZXJpbmdTeXN0ZW0gfHwgbnVsbDtcbiAgICB0aGlzLm91dHB1dENhbGVuZGFyID0gb3V0cHV0Q2FsZW5kYXIgfHwgcGFyc2VkT3V0cHV0Q2FsZW5kYXIgfHwgbnVsbDtcbiAgICB0aGlzLmludGwgPSBpbnRsQ29uZmlnU3RyaW5nKHRoaXMubG9jYWxlLCB0aGlzLm51bWJlcmluZ1N5c3RlbSwgdGhpcy5vdXRwdXRDYWxlbmRhcik7XG4gICAgdGhpcy53ZWVrZGF5c0NhY2hlID0ge1xuICAgICAgZm9ybWF0OiB7fSxcbiAgICAgIHN0YW5kYWxvbmU6IHt9XG4gICAgfTtcbiAgICB0aGlzLm1vbnRoc0NhY2hlID0ge1xuICAgICAgZm9ybWF0OiB7fSxcbiAgICAgIHN0YW5kYWxvbmU6IHt9XG4gICAgfTtcbiAgICB0aGlzLm1lcmlkaWVtQ2FjaGUgPSBudWxsO1xuICAgIHRoaXMuZXJhQ2FjaGUgPSB7fTtcbiAgICB0aGlzLnNwZWNpZmllZExvY2FsZSA9IHNwZWNpZmllZExvY2FsZTtcbiAgICB0aGlzLmZhc3ROdW1iZXJzQ2FjaGVkID0gbnVsbDtcbiAgfVxuXG4gIHZhciBfcHJvdG80ID0gTG9jYWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG80Lmxpc3RpbmdNb2RlID0gZnVuY3Rpb24gbGlzdGluZ01vZGUoZGVmYXVsdE9LKSB7XG4gICAgaWYgKGRlZmF1bHRPSyA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWZhdWx0T0sgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpbnRsID0gaGFzSW50bCgpLFxuICAgICAgICBoYXNGVFAgPSBpbnRsICYmIGhhc0Zvcm1hdFRvUGFydHMoKSxcbiAgICAgICAgaXNBY3R1YWxseUVuID0gdGhpcy5pc0VuZ2xpc2goKSxcbiAgICAgICAgaGFzTm9XZWlyZG5lc3MgPSAodGhpcy5udW1iZXJpbmdTeXN0ZW0gPT09IG51bGwgfHwgdGhpcy5udW1iZXJpbmdTeXN0ZW0gPT09IFwibGF0blwiKSAmJiAodGhpcy5vdXRwdXRDYWxlbmRhciA9PT0gbnVsbCB8fCB0aGlzLm91dHB1dENhbGVuZGFyID09PSBcImdyZWdvcnlcIik7XG5cbiAgICBpZiAoIWhhc0ZUUCAmJiAhKGlzQWN0dWFsbHlFbiAmJiBoYXNOb1dlaXJkbmVzcykgJiYgIWRlZmF1bHRPSykge1xuICAgICAgcmV0dXJuIFwiZXJyb3JcIjtcbiAgICB9IGVsc2UgaWYgKCFoYXNGVFAgfHwgaXNBY3R1YWxseUVuICYmIGhhc05vV2VpcmRuZXNzKSB7XG4gICAgICByZXR1cm4gXCJlblwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJpbnRsXCI7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90bzQuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZShhbHRzKSB7XG4gICAgaWYgKCFhbHRzIHx8IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFsdHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGFsdHMubG9jYWxlIHx8IHRoaXMuc3BlY2lmaWVkTG9jYWxlLCBhbHRzLm51bWJlcmluZ1N5c3RlbSB8fCB0aGlzLm51bWJlcmluZ1N5c3RlbSwgYWx0cy5vdXRwdXRDYWxlbmRhciB8fCB0aGlzLm91dHB1dENhbGVuZGFyLCBhbHRzLmRlZmF1bHRUb0VOIHx8IGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvNC5yZWRlZmF1bHRUb0VOID0gZnVuY3Rpb24gcmVkZWZhdWx0VG9FTihhbHRzKSB7XG4gICAgaWYgKGFsdHMgPT09IHZvaWQgMCkge1xuICAgICAgYWx0cyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNsb25lKE9iamVjdC5hc3NpZ24oe30sIGFsdHMsIHtcbiAgICAgIGRlZmF1bHRUb0VOOiB0cnVlXG4gICAgfSkpO1xuICB9O1xuXG4gIF9wcm90bzQucmVkZWZhdWx0VG9TeXN0ZW0gPSBmdW5jdGlvbiByZWRlZmF1bHRUb1N5c3RlbShhbHRzKSB7XG4gICAgaWYgKGFsdHMgPT09IHZvaWQgMCkge1xuICAgICAgYWx0cyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNsb25lKE9iamVjdC5hc3NpZ24oe30sIGFsdHMsIHtcbiAgICAgIGRlZmF1bHRUb0VOOiBmYWxzZVxuICAgIH0pKTtcbiAgfTtcblxuICBfcHJvdG80Lm1vbnRocyA9IGZ1bmN0aW9uIG1vbnRocyQxKGxlbmd0aCwgZm9ybWF0LCBkZWZhdWx0T0spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKGZvcm1hdCA9PT0gdm9pZCAwKSB7XG4gICAgICBmb3JtYXQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZGVmYXVsdE9LID09PSB2b2lkIDApIHtcbiAgICAgIGRlZmF1bHRPSyA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpc3RTdHVmZih0aGlzLCBsZW5ndGgsIGRlZmF1bHRPSywgbW9udGhzLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaW50bCA9IGZvcm1hdCA/IHtcbiAgICAgICAgbW9udGg6IGxlbmd0aCxcbiAgICAgICAgZGF5OiBcIm51bWVyaWNcIlxuICAgICAgfSA6IHtcbiAgICAgICAgbW9udGg6IGxlbmd0aFxuICAgICAgfSxcbiAgICAgICAgICBmb3JtYXRTdHIgPSBmb3JtYXQgPyBcImZvcm1hdFwiIDogXCJzdGFuZGFsb25lXCI7XG5cbiAgICAgIGlmICghX3RoaXMubW9udGhzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdKSB7XG4gICAgICAgIF90aGlzLm1vbnRoc0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXSA9IG1hcE1vbnRocyhmdW5jdGlvbiAoZHQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuZXh0cmFjdChkdCwgaW50bCwgXCJtb250aFwiKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcy5tb250aHNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF07XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvNC53ZWVrZGF5cyA9IGZ1bmN0aW9uIHdlZWtkYXlzJDEobGVuZ3RoLCBmb3JtYXQsIGRlZmF1bHRPSykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgaWYgKGZvcm1hdCA9PT0gdm9pZCAwKSB7XG4gICAgICBmb3JtYXQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZGVmYXVsdE9LID09PSB2b2lkIDApIHtcbiAgICAgIGRlZmF1bHRPSyA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpc3RTdHVmZih0aGlzLCBsZW5ndGgsIGRlZmF1bHRPSywgd2Vla2RheXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpbnRsID0gZm9ybWF0ID8ge1xuICAgICAgICB3ZWVrZGF5OiBsZW5ndGgsXG4gICAgICAgIHllYXI6IFwibnVtZXJpY1wiLFxuICAgICAgICBtb250aDogXCJsb25nXCIsXG4gICAgICAgIGRheTogXCJudW1lcmljXCJcbiAgICAgIH0gOiB7XG4gICAgICAgIHdlZWtkYXk6IGxlbmd0aFxuICAgICAgfSxcbiAgICAgICAgICBmb3JtYXRTdHIgPSBmb3JtYXQgPyBcImZvcm1hdFwiIDogXCJzdGFuZGFsb25lXCI7XG5cbiAgICAgIGlmICghX3RoaXMyLndlZWtkYXlzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdKSB7XG4gICAgICAgIF90aGlzMi53ZWVrZGF5c0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXSA9IG1hcFdlZWtkYXlzKGZ1bmN0aW9uIChkdCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuZXh0cmFjdChkdCwgaW50bCwgXCJ3ZWVrZGF5XCIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzMi53ZWVrZGF5c0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG80Lm1lcmlkaWVtcyA9IGZ1bmN0aW9uIG1lcmlkaWVtcyQxKGRlZmF1bHRPSykge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgaWYgKGRlZmF1bHRPSyA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWZhdWx0T0sgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBsaXN0U3R1ZmYodGhpcywgdW5kZWZpbmVkLCBkZWZhdWx0T0ssIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBtZXJpZGllbXM7XG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gSW4gdGhlb3J5IHRoZXJlIGNvdWxkIGJlIGFyaWJpdHJhcnkgZGF5IHBlcmlvZHMuIFdlJ3JlIGdvbm5hIGFzc3VtZSB0aGVyZSBhcmUgZXhhY3RseSB0d29cbiAgICAgIC8vIGZvciBBTSBhbmQgUE0uIFRoaXMgaXMgcHJvYmFibHkgd3JvbmcsIGJ1dCBpdCdzIG1ha2VzIHBhcnNpbmcgd2F5IGVhc2llci5cbiAgICAgIGlmICghX3RoaXMzLm1lcmlkaWVtQ2FjaGUpIHtcbiAgICAgICAgdmFyIGludGwgPSB7XG4gICAgICAgICAgaG91cjogXCJudW1lcmljXCIsXG4gICAgICAgICAgaG91cjEyOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzMy5tZXJpZGllbUNhY2hlID0gW0RhdGVUaW1lLnV0YygyMDE2LCAxMSwgMTMsIDkpLCBEYXRlVGltZS51dGMoMjAxNiwgMTEsIDEzLCAxOSldLm1hcChmdW5jdGlvbiAoZHQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMzLmV4dHJhY3QoZHQsIGludGwsIFwiZGF5cGVyaW9kXCIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzMy5tZXJpZGllbUNhY2hlO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90bzQuZXJhcyA9IGZ1bmN0aW9uIGVyYXMkMShsZW5ndGgsIGRlZmF1bHRPSykge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgaWYgKGRlZmF1bHRPSyA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWZhdWx0T0sgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBsaXN0U3R1ZmYodGhpcywgbGVuZ3RoLCBkZWZhdWx0T0ssIGVyYXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpbnRsID0ge1xuICAgICAgICBlcmE6IGxlbmd0aFxuICAgICAgfTsgLy8gVGhpcyBpcyBwcm9ibGVtYXRpYy4gRGlmZmVyZW50IGNhbGVuZGFycyBhcmUgZ29pbmcgdG8gZGVmaW5lIGVyYXMgdG90YWxseSBkaWZmZXJlbnRseS4gV2hhdCBJIG5lZWQgaXMgdGhlIG1pbmltdW0gc2V0IG9mIGRhdGVzXG4gICAgICAvLyB0byBkZWZpbml0ZWx5IGVudW1lcmF0ZSB0aGVtLlxuXG4gICAgICBpZiAoIV90aGlzNC5lcmFDYWNoZVtsZW5ndGhdKSB7XG4gICAgICAgIF90aGlzNC5lcmFDYWNoZVtsZW5ndGhdID0gW0RhdGVUaW1lLnV0YygtNDAsIDEsIDEpLCBEYXRlVGltZS51dGMoMjAxNywgMSwgMSldLm1hcChmdW5jdGlvbiAoZHQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0LmV4dHJhY3QoZHQsIGludGwsIFwiZXJhXCIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzNC5lcmFDYWNoZVtsZW5ndGhdO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90bzQuZXh0cmFjdCA9IGZ1bmN0aW9uIGV4dHJhY3QoZHQsIGludGxPcHRzLCBmaWVsZCkge1xuICAgIHZhciBkZiA9IHRoaXMuZHRGb3JtYXR0ZXIoZHQsIGludGxPcHRzKSxcbiAgICAgICAgcmVzdWx0cyA9IGRmLmZvcm1hdFRvUGFydHMoKSxcbiAgICAgICAgbWF0Y2hpbmcgPSByZXN1bHRzLmZpbmQoZnVuY3Rpb24gKG0pIHtcbiAgICAgIHJldHVybiBtLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gZmllbGQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hdGNoaW5nID8gbWF0Y2hpbmcudmFsdWUgOiBudWxsO1xuICB9O1xuXG4gIF9wcm90bzQubnVtYmVyRm9ybWF0dGVyID0gZnVuY3Rpb24gbnVtYmVyRm9ybWF0dGVyKG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuXG4gICAgLy8gdGhpcyBmb3JjZXNpbXBsZSBvcHRpb24gaXMgbmV2ZXIgdXNlZCAodGhlIG9ubHkgY2FsbGVyIHNob3J0LWNpcmN1aXRzIG9uIGl0LCBidXQgaXQgc2VlbXMgc2FmZXIgdG8gbGVhdmUpXG4gICAgLy8gKGluIGNvbnRyYXN0LCB0aGUgcmVzdCBvZiB0aGUgY29uZGl0aW9uIGlzIHVzZWQgaGVhdmlseSlcbiAgICByZXR1cm4gbmV3IFBvbHlOdW1iZXJGb3JtYXR0ZXIodGhpcy5pbnRsLCBvcHRzLmZvcmNlU2ltcGxlIHx8IHRoaXMuZmFzdE51bWJlcnMsIG9wdHMpO1xuICB9O1xuXG4gIF9wcm90bzQuZHRGb3JtYXR0ZXIgPSBmdW5jdGlvbiBkdEZvcm1hdHRlcihkdCwgaW50bE9wdHMpIHtcbiAgICBpZiAoaW50bE9wdHMgPT09IHZvaWQgMCkge1xuICAgICAgaW50bE9wdHMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFBvbHlEYXRlRm9ybWF0dGVyKGR0LCB0aGlzLmludGwsIGludGxPcHRzKTtcbiAgfTtcblxuICBfcHJvdG80LnJlbEZvcm1hdHRlciA9IGZ1bmN0aW9uIHJlbEZvcm1hdHRlcihvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUG9seVJlbEZvcm1hdHRlcih0aGlzLmludGwsIHRoaXMuaXNFbmdsaXNoKCksIG9wdHMpO1xuICB9O1xuXG4gIF9wcm90bzQuaXNFbmdsaXNoID0gZnVuY3Rpb24gaXNFbmdsaXNoKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZSA9PT0gXCJlblwiIHx8IHRoaXMubG9jYWxlLnRvTG93ZXJDYXNlKCkgPT09IFwiZW4tdXNcIiB8fCBoYXNJbnRsKCkgJiYgbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQodGhpcy5pbnRsKS5yZXNvbHZlZE9wdGlvbnMoKS5sb2NhbGUuc3RhcnRzV2l0aChcImVuLXVzXCIpO1xuICB9O1xuXG4gIF9wcm90bzQuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlID09PSBvdGhlci5sb2NhbGUgJiYgdGhpcy5udW1iZXJpbmdTeXN0ZW0gPT09IG90aGVyLm51bWJlcmluZ1N5c3RlbSAmJiB0aGlzLm91dHB1dENhbGVuZGFyID09PSBvdGhlci5vdXRwdXRDYWxlbmRhcjtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoTG9jYWxlLCBbe1xuICAgIGtleTogXCJmYXN0TnVtYmVyc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKHRoaXMuZmFzdE51bWJlcnNDYWNoZWQgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmZhc3ROdW1iZXJzQ2FjaGVkID0gc3VwcG9ydHNGYXN0TnVtYmVycyh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZmFzdE51bWJlcnNDYWNoZWQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExvY2FsZTtcbn0oKTtcblxuLypcbiAqIFRoaXMgZmlsZSBoYW5kbGVzIHBhcnNpbmcgZm9yIHdlbGwtc3BlY2lmaWVkIGZvcm1hdHMuIEhlcmUncyBob3cgaXQgd29ya3M6XG4gKiBUd28gdGhpbmdzIGdvIGludG8gcGFyc2luZzogYSByZWdleCB0byBtYXRjaCB3aXRoIGFuZCBhbiBleHRyYWN0b3IgdG8gdGFrZSBhcGFydCB0aGUgZ3JvdXBzIGluIHRoZSBtYXRjaC5cbiAqIEFuIGV4dHJhY3RvciBpcyBqdXN0IGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHJlZ2V4IG1hdGNoIGFycmF5IGFuZCByZXR1cm5zIGEgeyB5ZWFyOiAuLi4sIG1vbnRoOiAuLi4gfSBvYmplY3RcbiAqIHBhcnNlKCkgZG9lcyB0aGUgd29yayBvZiBleGVjdXRpbmcgdGhlIHJlZ2V4IGFuZCBhcHBseWluZyB0aGUgZXh0cmFjdG9yLiBJdCB0YWtlcyBtdWx0aXBsZSByZWdleC9leHRyYWN0b3IgcGFpcnMgdG8gdHJ5IGluIHNlcXVlbmNlLlxuICogRXh0cmFjdG9ycyBjYW4gdGFrZSBhIFwiY3Vyc29yXCIgcmVwcmVzZW50aW5nIHRoZSBvZmZzZXQgaW4gdGhlIG1hdGNoIHRvIGxvb2sgYXQuIFRoaXMgbWFrZXMgaXQgZWFzeSB0byBjb21iaW5lIGV4dHJhY3RvcnMuXG4gKiBjb21iaW5lRXh0cmFjdG9ycygpIGRvZXMgdGhlIHdvcmsgb2YgY29tYmluaW5nIHRoZW0sIGtlZXBpbmcgdHJhY2sgb2YgdGhlIGN1cnNvciB0aHJvdWdoIG11bHRpcGxlIGV4dHJhY3Rpb25zLlxuICogU29tZSBleHRyYWN0aW9ucyBhcmUgc3VwZXIgZHVtYiBhbmQgc2ltcGxlUGFyc2UgYW5kIGZyb21TdHJpbmdzIGhlbHAgRFJZIHRoZW0uXG4gKi9cblxuZnVuY3Rpb24gY29tYmluZVJlZ2V4ZXMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZWdleGVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHJlZ2V4ZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgZnVsbCA9IHJlZ2V4ZXMucmVkdWNlKGZ1bmN0aW9uIChmLCByKSB7XG4gICAgcmV0dXJuIGYgKyByLnNvdXJjZTtcbiAgfSwgXCJcIik7XG4gIHJldHVybiBSZWdFeHAoXCJeXCIgKyBmdWxsICsgXCIkXCIpO1xufVxuXG5mdW5jdGlvbiBjb21iaW5lRXh0cmFjdG9ycygpIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBleHRyYWN0b3JzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgZXh0cmFjdG9yc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChtKSB7XG4gICAgcmV0dXJuIGV4dHJhY3RvcnMucmVkdWNlKGZ1bmN0aW9uIChfcmVmLCBleCkge1xuICAgICAgdmFyIG1lcmdlZFZhbHMgPSBfcmVmWzBdLFxuICAgICAgICAgIG1lcmdlZFpvbmUgPSBfcmVmWzFdLFxuICAgICAgICAgIGN1cnNvciA9IF9yZWZbMl07XG5cbiAgICAgIHZhciBfZXggPSBleChtLCBjdXJzb3IpLFxuICAgICAgICAgIHZhbCA9IF9leFswXSxcbiAgICAgICAgICB6b25lID0gX2V4WzFdLFxuICAgICAgICAgIG5leHQgPSBfZXhbMl07XG5cbiAgICAgIHJldHVybiBbT2JqZWN0LmFzc2lnbihtZXJnZWRWYWxzLCB2YWwpLCBtZXJnZWRab25lIHx8IHpvbmUsIG5leHRdO1xuICAgIH0sIFt7fSwgbnVsbCwgMV0pLnNsaWNlKDAsIDIpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZShzKSB7XG4gIGlmIChzID09IG51bGwpIHtcbiAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICB9XG5cbiAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBwYXR0ZXJucyA9IG5ldyBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgcGF0dGVybnNbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cblxuICBmb3IgKHZhciBfaSA9IDAsIF9wYXR0ZXJucyA9IHBhdHRlcm5zOyBfaSA8IF9wYXR0ZXJucy5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgX3BhdHRlcm5zJF9pID0gX3BhdHRlcm5zW19pXSxcbiAgICAgICAgcmVnZXggPSBfcGF0dGVybnMkX2lbMF0sXG4gICAgICAgIGV4dHJhY3RvciA9IF9wYXR0ZXJucyRfaVsxXTtcbiAgICB2YXIgbSA9IHJlZ2V4LmV4ZWMocyk7XG5cbiAgICBpZiAobSkge1xuICAgICAgcmV0dXJuIGV4dHJhY3RvcihtKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW251bGwsIG51bGxdO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVQYXJzZSgpIHtcbiAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBrZXlzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAga2V5c1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChtYXRjaCwgY3Vyc29yKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldFtrZXlzW2ldXSA9IHBhcnNlSW50ZWdlcihtYXRjaFtjdXJzb3IgKyBpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtyZXQsIG51bGwsIGN1cnNvciArIGldO1xuICB9O1xufSAvLyBJU08gYW5kIFNRTCBwYXJzaW5nXG5cblxudmFyIG9mZnNldFJlZ2V4ID0gLyg/OihaKXwoWystXVxcZFxcZCkoPzo6PyhcXGRcXGQpKT8pLyxcbiAgICBpc29UaW1lQmFzZVJlZ2V4ID0gLyhcXGRcXGQpKD86Oj8oXFxkXFxkKSg/Ojo/KFxcZFxcZCkoPzpbLixdKFxcZHsxLDMwfSkpPyk/KT8vLFxuICAgIGlzb1RpbWVSZWdleCA9IFJlZ0V4cChcIlwiICsgaXNvVGltZUJhc2VSZWdleC5zb3VyY2UgKyBvZmZzZXRSZWdleC5zb3VyY2UgKyBcIj9cIiksXG4gICAgaXNvVGltZUV4dGVuc2lvblJlZ2V4ID0gUmVnRXhwKFwiKD86VFwiICsgaXNvVGltZVJlZ2V4LnNvdXJjZSArIFwiKT9cIiksXG4gICAgaXNvWW1kUmVnZXggPSAvKFsrLV1cXGR7Nn18XFxkezR9KSg/Oi0/KFxcZFxcZCkoPzotPyhcXGRcXGQpKT8pPy8sXG4gICAgaXNvV2Vla1JlZ2V4ID0gLyhcXGR7NH0pLT9XKFxcZFxcZCkoPzotPyhcXGQpKT8vLFxuICAgIGlzb09yZGluYWxSZWdleCA9IC8oXFxkezR9KS0/KFxcZHszfSkvLFxuICAgIGV4dHJhY3RJU09XZWVrRGF0YSA9IHNpbXBsZVBhcnNlKFwid2Vla1llYXJcIiwgXCJ3ZWVrTnVtYmVyXCIsIFwid2Vla0RheVwiKSxcbiAgICBleHRyYWN0SVNPT3JkaW5hbERhdGEgPSBzaW1wbGVQYXJzZShcInllYXJcIiwgXCJvcmRpbmFsXCIpLFxuICAgIHNxbFltZFJlZ2V4ID0gLyhcXGR7NH0pLShcXGRcXGQpLShcXGRcXGQpLyxcbiAgICAvLyBkdW1iZWQtZG93biB2ZXJzaW9uIG9mIHRoZSBJU08gb25lXG5zcWxUaW1lUmVnZXggPSBSZWdFeHAoaXNvVGltZUJhc2VSZWdleC5zb3VyY2UgKyBcIiA/KD86XCIgKyBvZmZzZXRSZWdleC5zb3VyY2UgKyBcInwoXCIgKyBpYW5hUmVnZXguc291cmNlICsgXCIpKT9cIiksXG4gICAgc3FsVGltZUV4dGVuc2lvblJlZ2V4ID0gUmVnRXhwKFwiKD86IFwiICsgc3FsVGltZVJlZ2V4LnNvdXJjZSArIFwiKT9cIik7XG5cbmZ1bmN0aW9uIGludChtYXRjaCwgcG9zLCBmYWxsYmFjaykge1xuICB2YXIgbSA9IG1hdGNoW3Bvc107XG4gIHJldHVybiBpc1VuZGVmaW5lZChtKSA/IGZhbGxiYWNrIDogcGFyc2VJbnRlZ2VyKG0pO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SVNPWW1kKG1hdGNoLCBjdXJzb3IpIHtcbiAgdmFyIGl0ZW0gPSB7XG4gICAgeWVhcjogaW50KG1hdGNoLCBjdXJzb3IpLFxuICAgIG1vbnRoOiBpbnQobWF0Y2gsIGN1cnNvciArIDEsIDEpLFxuICAgIGRheTogaW50KG1hdGNoLCBjdXJzb3IgKyAyLCAxKVxuICB9O1xuICByZXR1cm4gW2l0ZW0sIG51bGwsIGN1cnNvciArIDNdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SVNPVGltZShtYXRjaCwgY3Vyc29yKSB7XG4gIHZhciBpdGVtID0ge1xuICAgIGhvdXJzOiBpbnQobWF0Y2gsIGN1cnNvciwgMCksXG4gICAgbWludXRlczogaW50KG1hdGNoLCBjdXJzb3IgKyAxLCAwKSxcbiAgICBzZWNvbmRzOiBpbnQobWF0Y2gsIGN1cnNvciArIDIsIDApLFxuICAgIG1pbGxpc2Vjb25kczogcGFyc2VNaWxsaXMobWF0Y2hbY3Vyc29yICsgM10pXG4gIH07XG4gIHJldHVybiBbaXRlbSwgbnVsbCwgY3Vyc29yICsgNF07XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09PZmZzZXQobWF0Y2gsIGN1cnNvcikge1xuICB2YXIgbG9jYWwgPSAhbWF0Y2hbY3Vyc29yXSAmJiAhbWF0Y2hbY3Vyc29yICsgMV0sXG4gICAgICBmdWxsT2Zmc2V0ID0gc2lnbmVkT2Zmc2V0KG1hdGNoW2N1cnNvciArIDFdLCBtYXRjaFtjdXJzb3IgKyAyXSksXG4gICAgICB6b25lID0gbG9jYWwgPyBudWxsIDogRml4ZWRPZmZzZXRab25lLmluc3RhbmNlKGZ1bGxPZmZzZXQpO1xuICByZXR1cm4gW3t9LCB6b25lLCBjdXJzb3IgKyAzXTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdElBTkFab25lKG1hdGNoLCBjdXJzb3IpIHtcbiAgdmFyIHpvbmUgPSBtYXRjaFtjdXJzb3JdID8gSUFOQVpvbmUuY3JlYXRlKG1hdGNoW2N1cnNvcl0pIDogbnVsbDtcbiAgcmV0dXJuIFt7fSwgem9uZSwgY3Vyc29yICsgMV07XG59IC8vIElTTyB0aW1lIHBhcnNpbmdcblxuXG52YXIgaXNvVGltZU9ubHkgPSBSZWdFeHAoXCJeVD9cIiArIGlzb1RpbWVCYXNlUmVnZXguc291cmNlICsgXCIkXCIpOyAvLyBJU08gZHVyYXRpb24gcGFyc2luZ1xuXG52YXIgaXNvRHVyYXRpb24gPSAvXi0/UCg/Oig/OigtP1xcZHsxLDl9KVkpPyg/OigtP1xcZHsxLDl9KU0pPyg/OigtP1xcZHsxLDl9KVcpPyg/OigtP1xcZHsxLDl9KUQpPyg/OlQoPzooLT9cXGR7MSw5fSlIKT8oPzooLT9cXGR7MSw5fSlNKT8oPzooLT9cXGR7MSwyMH0pKD86Wy4sXSgtP1xcZHsxLDl9KSk/Uyk/KT8pJC87XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09EdXJhdGlvbihtYXRjaCkge1xuICB2YXIgcyA9IG1hdGNoWzBdLFxuICAgICAgeWVhclN0ciA9IG1hdGNoWzFdLFxuICAgICAgbW9udGhTdHIgPSBtYXRjaFsyXSxcbiAgICAgIHdlZWtTdHIgPSBtYXRjaFszXSxcbiAgICAgIGRheVN0ciA9IG1hdGNoWzRdLFxuICAgICAgaG91clN0ciA9IG1hdGNoWzVdLFxuICAgICAgbWludXRlU3RyID0gbWF0Y2hbNl0sXG4gICAgICBzZWNvbmRTdHIgPSBtYXRjaFs3XSxcbiAgICAgIG1pbGxpc2Vjb25kc1N0ciA9IG1hdGNoWzhdO1xuICB2YXIgaGFzTmVnYXRpdmVQcmVmaXggPSBzWzBdID09PSBcIi1cIjtcblxuICB2YXIgbWF5YmVOZWdhdGUgPSBmdW5jdGlvbiBtYXliZU5lZ2F0ZShudW0pIHtcbiAgICByZXR1cm4gbnVtICYmIGhhc05lZ2F0aXZlUHJlZml4ID8gLW51bSA6IG51bTtcbiAgfTtcblxuICByZXR1cm4gW3tcbiAgICB5ZWFyczogbWF5YmVOZWdhdGUocGFyc2VJbnRlZ2VyKHllYXJTdHIpKSxcbiAgICBtb250aHM6IG1heWJlTmVnYXRlKHBhcnNlSW50ZWdlcihtb250aFN0cikpLFxuICAgIHdlZWtzOiBtYXliZU5lZ2F0ZShwYXJzZUludGVnZXIod2Vla1N0cikpLFxuICAgIGRheXM6IG1heWJlTmVnYXRlKHBhcnNlSW50ZWdlcihkYXlTdHIpKSxcbiAgICBob3VyczogbWF5YmVOZWdhdGUocGFyc2VJbnRlZ2VyKGhvdXJTdHIpKSxcbiAgICBtaW51dGVzOiBtYXliZU5lZ2F0ZShwYXJzZUludGVnZXIobWludXRlU3RyKSksXG4gICAgc2Vjb25kczogbWF5YmVOZWdhdGUocGFyc2VJbnRlZ2VyKHNlY29uZFN0cikpLFxuICAgIG1pbGxpc2Vjb25kczogbWF5YmVOZWdhdGUocGFyc2VNaWxsaXMobWlsbGlzZWNvbmRzU3RyKSlcbiAgfV07XG59IC8vIFRoZXNlIGFyZSBhIGxpdHRsZSBicmFpbmRlYWQuIEVEVCAqc2hvdWxkKiB0ZWxsIHVzIHRoYXQgd2UncmUgaW4sIHNheSwgQW1lcmljYS9OZXdfWW9ya1xuLy8gYW5kIG5vdCBqdXN0IHRoYXQgd2UncmUgaW4gLTI0MCAqcmlnaHQgbm93Ki4gQnV0IHNpbmNlIEkgZG9uJ3QgdGhpbmsgdGhlc2UgYXJlIHVzZWQgdGhhdCBvZnRlblxuLy8gSSdtIGp1c3QgZ29pbmcgdG8gaWdub3JlIHRoYXRcblxuXG52YXIgb2JzT2Zmc2V0cyA9IHtcbiAgR01UOiAwLFxuICBFRFQ6IC00ICogNjAsXG4gIEVTVDogLTUgKiA2MCxcbiAgQ0RUOiAtNSAqIDYwLFxuICBDU1Q6IC02ICogNjAsXG4gIE1EVDogLTYgKiA2MCxcbiAgTVNUOiAtNyAqIDYwLFxuICBQRFQ6IC03ICogNjAsXG4gIFBTVDogLTggKiA2MFxufTtcblxuZnVuY3Rpb24gZnJvbVN0cmluZ3Mod2Vla2RheVN0ciwgeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpIHtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICB5ZWFyOiB5ZWFyU3RyLmxlbmd0aCA9PT0gMiA/IHVudHJ1bmNhdGVZZWFyKHBhcnNlSW50ZWdlcih5ZWFyU3RyKSkgOiBwYXJzZUludGVnZXIoeWVhclN0ciksXG4gICAgbW9udGg6IG1vbnRoc1Nob3J0LmluZGV4T2YobW9udGhTdHIpICsgMSxcbiAgICBkYXk6IHBhcnNlSW50ZWdlcihkYXlTdHIpLFxuICAgIGhvdXI6IHBhcnNlSW50ZWdlcihob3VyU3RyKSxcbiAgICBtaW51dGU6IHBhcnNlSW50ZWdlcihtaW51dGVTdHIpXG4gIH07XG4gIGlmIChzZWNvbmRTdHIpIHJlc3VsdC5zZWNvbmQgPSBwYXJzZUludGVnZXIoc2Vjb25kU3RyKTtcblxuICBpZiAod2Vla2RheVN0cikge1xuICAgIHJlc3VsdC53ZWVrZGF5ID0gd2Vla2RheVN0ci5sZW5ndGggPiAzID8gd2Vla2RheXNMb25nLmluZGV4T2Yod2Vla2RheVN0cikgKyAxIDogd2Vla2RheXNTaG9ydC5pbmRleE9mKHdlZWtkYXlTdHIpICsgMTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59IC8vIFJGQyAyODIyLzUzMjJcblxuXG52YXIgcmZjMjgyMiA9IC9eKD86KE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksXFxzKT8oXFxkezEsMn0pXFxzKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKVxccyhcXGR7Miw0fSlcXHMoXFxkXFxkKTooXFxkXFxkKSg/OjooXFxkXFxkKSk/XFxzKD86KFVUfEdNVHxbRUNNUF1bU0RdVCl8KFtael0pfCg/OihbKy1dXFxkXFxkKShcXGRcXGQpKSkkLztcblxuZnVuY3Rpb24gZXh0cmFjdFJGQzI4MjIobWF0Y2gpIHtcbiAgdmFyIHdlZWtkYXlTdHIgPSBtYXRjaFsxXSxcbiAgICAgIGRheVN0ciA9IG1hdGNoWzJdLFxuICAgICAgbW9udGhTdHIgPSBtYXRjaFszXSxcbiAgICAgIHllYXJTdHIgPSBtYXRjaFs0XSxcbiAgICAgIGhvdXJTdHIgPSBtYXRjaFs1XSxcbiAgICAgIG1pbnV0ZVN0ciA9IG1hdGNoWzZdLFxuICAgICAgc2Vjb25kU3RyID0gbWF0Y2hbN10sXG4gICAgICBvYnNPZmZzZXQgPSBtYXRjaFs4XSxcbiAgICAgIG1pbE9mZnNldCA9IG1hdGNoWzldLFxuICAgICAgb2ZmSG91clN0ciA9IG1hdGNoWzEwXSxcbiAgICAgIG9mZk1pbnV0ZVN0ciA9IG1hdGNoWzExXSxcbiAgICAgIHJlc3VsdCA9IGZyb21TdHJpbmdzKHdlZWtkYXlTdHIsIHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKTtcbiAgdmFyIG9mZnNldDtcblxuICBpZiAob2JzT2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gb2JzT2Zmc2V0c1tvYnNPZmZzZXRdO1xuICB9IGVsc2UgaWYgKG1pbE9mZnNldCkge1xuICAgIG9mZnNldCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgb2Zmc2V0ID0gc2lnbmVkT2Zmc2V0KG9mZkhvdXJTdHIsIG9mZk1pbnV0ZVN0cik7XG4gIH1cblxuICByZXR1cm4gW3Jlc3VsdCwgbmV3IEZpeGVkT2Zmc2V0Wm9uZShvZmZzZXQpXTtcbn1cblxuZnVuY3Rpb24gcHJlcHJvY2Vzc1JGQzI4MjIocykge1xuICAvLyBSZW1vdmUgY29tbWVudHMgYW5kIGZvbGRpbmcgd2hpdGVzcGFjZSBhbmQgcmVwbGFjZSBtdWx0aXBsZS1zcGFjZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICByZXR1cm4gcy5yZXBsYWNlKC9cXChbXildKlxcKXxbXFxuXFx0XS9nLCBcIiBcIikucmVwbGFjZSgvKFxcc1xccyspL2csIFwiIFwiKS50cmltKCk7XG59IC8vIGh0dHAgZGF0ZVxuXG5cbnZhciByZmMxMTIzID0gL14oTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSwgKFxcZFxcZCkgKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKSAoXFxkezR9KSAoXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKSBHTVQkLyxcbiAgICByZmM4NTAgPSAvXihNb25kYXl8VHVlc2RheXxXZWRzZGF5fFRodXJzZGF5fEZyaWRheXxTYXR1cmRheXxTdW5kYXkpLCAoXFxkXFxkKS0oSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpLShcXGRcXGQpIChcXGRcXGQpOihcXGRcXGQpOihcXGRcXGQpIEdNVCQvLFxuICAgIGFzY2lpID0gL14oTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSAoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpICggXFxkfFxcZFxcZCkgKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkgKFxcZHs0fSkkLztcblxuZnVuY3Rpb24gZXh0cmFjdFJGQzExMjNPcjg1MChtYXRjaCkge1xuICB2YXIgd2Vla2RheVN0ciA9IG1hdGNoWzFdLFxuICAgICAgZGF5U3RyID0gbWF0Y2hbMl0sXG4gICAgICBtb250aFN0ciA9IG1hdGNoWzNdLFxuICAgICAgeWVhclN0ciA9IG1hdGNoWzRdLFxuICAgICAgaG91clN0ciA9IG1hdGNoWzVdLFxuICAgICAgbWludXRlU3RyID0gbWF0Y2hbNl0sXG4gICAgICBzZWNvbmRTdHIgPSBtYXRjaFs3XSxcbiAgICAgIHJlc3VsdCA9IGZyb21TdHJpbmdzKHdlZWtkYXlTdHIsIHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKTtcbiAgcmV0dXJuIFtyZXN1bHQsIEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZV07XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RBU0NJSShtYXRjaCkge1xuICB2YXIgd2Vla2RheVN0ciA9IG1hdGNoWzFdLFxuICAgICAgbW9udGhTdHIgPSBtYXRjaFsyXSxcbiAgICAgIGRheVN0ciA9IG1hdGNoWzNdLFxuICAgICAgaG91clN0ciA9IG1hdGNoWzRdLFxuICAgICAgbWludXRlU3RyID0gbWF0Y2hbNV0sXG4gICAgICBzZWNvbmRTdHIgPSBtYXRjaFs2XSxcbiAgICAgIHllYXJTdHIgPSBtYXRjaFs3XSxcbiAgICAgIHJlc3VsdCA9IGZyb21TdHJpbmdzKHdlZWtkYXlTdHIsIHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKTtcbiAgcmV0dXJuIFtyZXN1bHQsIEZpeGVkT2Zmc2V0Wm9uZS51dGNJbnN0YW5jZV07XG59XG5cbnZhciBpc29ZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoaXNvWW1kUmVnZXgsIGlzb1RpbWVFeHRlbnNpb25SZWdleCk7XG52YXIgaXNvV2Vla1dpdGhUaW1lRXh0ZW5zaW9uUmVnZXggPSBjb21iaW5lUmVnZXhlcyhpc29XZWVrUmVnZXgsIGlzb1RpbWVFeHRlbnNpb25SZWdleCk7XG52YXIgaXNvT3JkaW5hbFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXggPSBjb21iaW5lUmVnZXhlcyhpc29PcmRpbmFsUmVnZXgsIGlzb1RpbWVFeHRlbnNpb25SZWdleCk7XG52YXIgaXNvVGltZUNvbWJpbmVkUmVnZXggPSBjb21iaW5lUmVnZXhlcyhpc29UaW1lUmVnZXgpO1xudmFyIGV4dHJhY3RJU09ZbWRUaW1lQW5kT2Zmc2V0ID0gY29tYmluZUV4dHJhY3RvcnMoZXh0cmFjdElTT1ltZCwgZXh0cmFjdElTT1RpbWUsIGV4dHJhY3RJU09PZmZzZXQpO1xudmFyIGV4dHJhY3RJU09XZWVrVGltZUFuZE9mZnNldCA9IGNvbWJpbmVFeHRyYWN0b3JzKGV4dHJhY3RJU09XZWVrRGF0YSwgZXh0cmFjdElTT1RpbWUsIGV4dHJhY3RJU09PZmZzZXQpO1xudmFyIGV4dHJhY3RJU09PcmRpbmFsRGF0YUFuZFRpbWUgPSBjb21iaW5lRXh0cmFjdG9ycyhleHRyYWN0SVNPT3JkaW5hbERhdGEsIGV4dHJhY3RJU09UaW1lKTtcbnZhciBleHRyYWN0SVNPVGltZUFuZE9mZnNldCA9IGNvbWJpbmVFeHRyYWN0b3JzKGV4dHJhY3RJU09UaW1lLCBleHRyYWN0SVNPT2Zmc2V0KTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZUlTT0RhdGUocykge1xuICByZXR1cm4gcGFyc2UocywgW2lzb1ltZFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXgsIGV4dHJhY3RJU09ZbWRUaW1lQW5kT2Zmc2V0XSwgW2lzb1dlZWtXaXRoVGltZUV4dGVuc2lvblJlZ2V4LCBleHRyYWN0SVNPV2Vla1RpbWVBbmRPZmZzZXRdLCBbaXNvT3JkaW5hbFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXgsIGV4dHJhY3RJU09PcmRpbmFsRGF0YUFuZFRpbWVdLCBbaXNvVGltZUNvbWJpbmVkUmVnZXgsIGV4dHJhY3RJU09UaW1lQW5kT2Zmc2V0XSk7XG59XG5mdW5jdGlvbiBwYXJzZVJGQzI4MjJEYXRlKHMpIHtcbiAgcmV0dXJuIHBhcnNlKHByZXByb2Nlc3NSRkMyODIyKHMpLCBbcmZjMjgyMiwgZXh0cmFjdFJGQzI4MjJdKTtcbn1cbmZ1bmN0aW9uIHBhcnNlSFRUUERhdGUocykge1xuICByZXR1cm4gcGFyc2UocywgW3JmYzExMjMsIGV4dHJhY3RSRkMxMTIzT3I4NTBdLCBbcmZjODUwLCBleHRyYWN0UkZDMTEyM09yODUwXSwgW2FzY2lpLCBleHRyYWN0QVNDSUldKTtcbn1cbmZ1bmN0aW9uIHBhcnNlSVNPRHVyYXRpb24ocykge1xuICByZXR1cm4gcGFyc2UocywgW2lzb0R1cmF0aW9uLCBleHRyYWN0SVNPRHVyYXRpb25dKTtcbn1cbnZhciBleHRyYWN0SVNPVGltZU9ubHkgPSBjb21iaW5lRXh0cmFjdG9ycyhleHRyYWN0SVNPVGltZSk7XG5mdW5jdGlvbiBwYXJzZUlTT1RpbWVPbmx5KHMpIHtcbiAgcmV0dXJuIHBhcnNlKHMsIFtpc29UaW1lT25seSwgZXh0cmFjdElTT1RpbWVPbmx5XSk7XG59XG52YXIgc3FsWW1kV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKHNxbFltZFJlZ2V4LCBzcWxUaW1lRXh0ZW5zaW9uUmVnZXgpO1xudmFyIHNxbFRpbWVDb21iaW5lZFJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoc3FsVGltZVJlZ2V4KTtcbnZhciBleHRyYWN0SVNPWW1kVGltZU9mZnNldEFuZElBTkFab25lID0gY29tYmluZUV4dHJhY3RvcnMoZXh0cmFjdElTT1ltZCwgZXh0cmFjdElTT1RpbWUsIGV4dHJhY3RJU09PZmZzZXQsIGV4dHJhY3RJQU5BWm9uZSk7XG52YXIgZXh0cmFjdElTT1RpbWVPZmZzZXRBbmRJQU5BWm9uZSA9IGNvbWJpbmVFeHRyYWN0b3JzKGV4dHJhY3RJU09UaW1lLCBleHRyYWN0SVNPT2Zmc2V0LCBleHRyYWN0SUFOQVpvbmUpO1xuZnVuY3Rpb24gcGFyc2VTUUwocykge1xuICByZXR1cm4gcGFyc2UocywgW3NxbFltZFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXgsIGV4dHJhY3RJU09ZbWRUaW1lT2Zmc2V0QW5kSUFOQVpvbmVdLCBbc3FsVGltZUNvbWJpbmVkUmVnZXgsIGV4dHJhY3RJU09UaW1lT2Zmc2V0QW5kSUFOQVpvbmVdKTtcbn1cblxudmFyIElOVkFMSUQgPSBcIkludmFsaWQgRHVyYXRpb25cIjsgLy8gdW5pdCBjb252ZXJzaW9uIGNvbnN0YW50c1xuXG52YXIgbG93T3JkZXJNYXRyaXggPSB7XG4gIHdlZWtzOiB7XG4gICAgZGF5czogNyxcbiAgICBob3VyczogNyAqIDI0LFxuICAgIG1pbnV0ZXM6IDcgKiAyNCAqIDYwLFxuICAgIHNlY29uZHM6IDcgKiAyNCAqIDYwICogNjAsXG4gICAgbWlsbGlzZWNvbmRzOiA3ICogMjQgKiA2MCAqIDYwICogMTAwMFxuICB9LFxuICBkYXlzOiB7XG4gICAgaG91cnM6IDI0LFxuICAgIG1pbnV0ZXM6IDI0ICogNjAsXG4gICAgc2Vjb25kczogMjQgKiA2MCAqIDYwLFxuICAgIG1pbGxpc2Vjb25kczogMjQgKiA2MCAqIDYwICogMTAwMFxuICB9LFxuICBob3Vyczoge1xuICAgIG1pbnV0ZXM6IDYwLFxuICAgIHNlY29uZHM6IDYwICogNjAsXG4gICAgbWlsbGlzZWNvbmRzOiA2MCAqIDYwICogMTAwMFxuICB9LFxuICBtaW51dGVzOiB7XG4gICAgc2Vjb25kczogNjAsXG4gICAgbWlsbGlzZWNvbmRzOiA2MCAqIDEwMDBcbiAgfSxcbiAgc2Vjb25kczoge1xuICAgIG1pbGxpc2Vjb25kczogMTAwMFxuICB9XG59LFxuICAgIGNhc3VhbE1hdHJpeCA9IE9iamVjdC5hc3NpZ24oe1xuICB5ZWFyczoge1xuICAgIHF1YXJ0ZXJzOiA0LFxuICAgIG1vbnRoczogMTIsXG4gICAgd2Vla3M6IDUyLFxuICAgIGRheXM6IDM2NSxcbiAgICBob3VyczogMzY1ICogMjQsXG4gICAgbWludXRlczogMzY1ICogMjQgKiA2MCxcbiAgICBzZWNvbmRzOiAzNjUgKiAyNCAqIDYwICogNjAsXG4gICAgbWlsbGlzZWNvbmRzOiAzNjUgKiAyNCAqIDYwICogNjAgKiAxMDAwXG4gIH0sXG4gIHF1YXJ0ZXJzOiB7XG4gICAgbW9udGhzOiAzLFxuICAgIHdlZWtzOiAxMyxcbiAgICBkYXlzOiA5MSxcbiAgICBob3VyczogOTEgKiAyNCxcbiAgICBtaW51dGVzOiA5MSAqIDI0ICogNjAsXG4gICAgc2Vjb25kczogOTEgKiAyNCAqIDYwICogNjAsXG4gICAgbWlsbGlzZWNvbmRzOiA5MSAqIDI0ICogNjAgKiA2MCAqIDEwMDBcbiAgfSxcbiAgbW9udGhzOiB7XG4gICAgd2Vla3M6IDQsXG4gICAgZGF5czogMzAsXG4gICAgaG91cnM6IDMwICogMjQsXG4gICAgbWludXRlczogMzAgKiAyNCAqIDYwLFxuICAgIHNlY29uZHM6IDMwICogMjQgKiA2MCAqIDYwLFxuICAgIG1pbGxpc2Vjb25kczogMzAgKiAyNCAqIDYwICogNjAgKiAxMDAwXG4gIH1cbn0sIGxvd09yZGVyTWF0cml4KSxcbiAgICBkYXlzSW5ZZWFyQWNjdXJhdGUgPSAxNDYwOTcuMCAvIDQwMCxcbiAgICBkYXlzSW5Nb250aEFjY3VyYXRlID0gMTQ2MDk3LjAgLyA0ODAwLFxuICAgIGFjY3VyYXRlTWF0cml4ID0gT2JqZWN0LmFzc2lnbih7XG4gIHllYXJzOiB7XG4gICAgcXVhcnRlcnM6IDQsXG4gICAgbW9udGhzOiAxMixcbiAgICB3ZWVrczogZGF5c0luWWVhckFjY3VyYXRlIC8gNyxcbiAgICBkYXlzOiBkYXlzSW5ZZWFyQWNjdXJhdGUsXG4gICAgaG91cnM6IGRheXNJblllYXJBY2N1cmF0ZSAqIDI0LFxuICAgIG1pbnV0ZXM6IGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAsXG4gICAgc2Vjb25kczogZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCAqIDYwLFxuICAgIG1pbGxpc2Vjb25kczogZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCAqIDYwICogMTAwMFxuICB9LFxuICBxdWFydGVyczoge1xuICAgIG1vbnRoczogMyxcbiAgICB3ZWVrczogZGF5c0luWWVhckFjY3VyYXRlIC8gMjgsXG4gICAgZGF5czogZGF5c0luWWVhckFjY3VyYXRlIC8gNCxcbiAgICBob3VyczogZGF5c0luWWVhckFjY3VyYXRlICogMjQgLyA0LFxuICAgIG1pbnV0ZXM6IGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAgLyA0LFxuICAgIHNlY29uZHM6IGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCAvIDQsXG4gICAgbWlsbGlzZWNvbmRzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwICogNjAgKiAxMDAwIC8gNFxuICB9LFxuICBtb250aHM6IHtcbiAgICB3ZWVrczogZGF5c0luTW9udGhBY2N1cmF0ZSAvIDcsXG4gICAgZGF5czogZGF5c0luTW9udGhBY2N1cmF0ZSxcbiAgICBob3VyczogZGF5c0luTW9udGhBY2N1cmF0ZSAqIDI0LFxuICAgIG1pbnV0ZXM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCAqIDYwLFxuICAgIHNlY29uZHM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCAqIDYwICogNjAsXG4gICAgbWlsbGlzZWNvbmRzOiBkYXlzSW5Nb250aEFjY3VyYXRlICogMjQgKiA2MCAqIDYwICogMTAwMFxuICB9XG59LCBsb3dPcmRlck1hdHJpeCk7IC8vIHVuaXRzIG9yZGVyZWQgYnkgc2l6ZVxuXG52YXIgb3JkZXJlZFVuaXRzID0gW1wieWVhcnNcIiwgXCJxdWFydGVyc1wiLCBcIm1vbnRoc1wiLCBcIndlZWtzXCIsIFwiZGF5c1wiLCBcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIiwgXCJtaWxsaXNlY29uZHNcIl07XG52YXIgcmV2ZXJzZVVuaXRzID0gb3JkZXJlZFVuaXRzLnNsaWNlKDApLnJldmVyc2UoKTsgLy8gY2xvbmUgcmVhbGx5IG1lYW5zIFwiY3JlYXRlIGFub3RoZXIgaW5zdGFuY2UganVzdCBsaWtlIHRoaXMgb25lLCBidXQgd2l0aCB0aGVzZSBjaGFuZ2VzXCJcblxuZnVuY3Rpb24gY2xvbmUoZHVyLCBhbHRzLCBjbGVhcikge1xuICBpZiAoY2xlYXIgPT09IHZvaWQgMCkge1xuICAgIGNsZWFyID0gZmFsc2U7XG4gIH1cblxuICAvLyBkZWVwIG1lcmdlIGZvciB2YWxzXG4gIHZhciBjb25mID0ge1xuICAgIHZhbHVlczogY2xlYXIgPyBhbHRzLnZhbHVlcyA6IE9iamVjdC5hc3NpZ24oe30sIGR1ci52YWx1ZXMsIGFsdHMudmFsdWVzIHx8IHt9KSxcbiAgICBsb2M6IGR1ci5sb2MuY2xvbmUoYWx0cy5sb2MpLFxuICAgIGNvbnZlcnNpb25BY2N1cmFjeTogYWx0cy5jb252ZXJzaW9uQWNjdXJhY3kgfHwgZHVyLmNvbnZlcnNpb25BY2N1cmFjeVxuICB9O1xuICByZXR1cm4gbmV3IER1cmF0aW9uKGNvbmYpO1xufVxuXG5mdW5jdGlvbiBhbnRpVHJ1bmMobikge1xuICByZXR1cm4gbiA8IDAgPyBNYXRoLmZsb29yKG4pIDogTWF0aC5jZWlsKG4pO1xufSAvLyBOQjogbXV0YXRlcyBwYXJhbWV0ZXJzXG5cblxuZnVuY3Rpb24gY29udmVydChtYXRyaXgsIGZyb21NYXAsIGZyb21Vbml0LCB0b01hcCwgdG9Vbml0KSB7XG4gIHZhciBjb252ID0gbWF0cml4W3RvVW5pdF1bZnJvbVVuaXRdLFxuICAgICAgcmF3ID0gZnJvbU1hcFtmcm9tVW5pdF0gLyBjb252LFxuICAgICAgc2FtZVNpZ24gPSBNYXRoLnNpZ24ocmF3KSA9PT0gTWF0aC5zaWduKHRvTWFwW3RvVW5pdF0pLFxuICAgICAgLy8gb2ssIHNvIHRoaXMgaXMgd2lsZCwgYnV0IHNlZSB0aGUgbWF0cml4IGluIHRoZSB0ZXN0c1xuICBhZGRlZCA9ICFzYW1lU2lnbiAmJiB0b01hcFt0b1VuaXRdICE9PSAwICYmIE1hdGguYWJzKHJhdykgPD0gMSA/IGFudGlUcnVuYyhyYXcpIDogTWF0aC50cnVuYyhyYXcpO1xuICB0b01hcFt0b1VuaXRdICs9IGFkZGVkO1xuICBmcm9tTWFwW2Zyb21Vbml0XSAtPSBhZGRlZCAqIGNvbnY7XG59IC8vIE5COiBtdXRhdGVzIHBhcmFtZXRlcnNcblxuXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZXMobWF0cml4LCB2YWxzKSB7XG4gIHJldmVyc2VVbml0cy5yZWR1Y2UoZnVuY3Rpb24gKHByZXZpb3VzLCBjdXJyZW50KSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh2YWxzW2N1cnJlbnRdKSkge1xuICAgICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICAgIGNvbnZlcnQobWF0cml4LCB2YWxzLCBwcmV2aW91cywgdmFscywgY3VycmVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcHJldmlvdXM7XG4gICAgfVxuICB9LCBudWxsKTtcbn1cbi8qKlxuICogQSBEdXJhdGlvbiBvYmplY3QgcmVwcmVzZW50cyBhIHBlcmlvZCBvZiB0aW1lLCBsaWtlIFwiMiBtb250aHNcIiBvciBcIjEgZGF5LCAxIGhvdXJcIi4gQ29uY2VwdHVhbGx5LCBpdCdzIGp1c3QgYSBtYXAgb2YgdW5pdHMgdG8gdGhlaXIgcXVhbnRpdGllcywgYWNjb21wYW5pZWQgYnkgc29tZSBhZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gYW5kIG1ldGhvZHMgZm9yIGNyZWF0aW5nLCBwYXJzaW5nLCBpbnRlcnJvZ2F0aW5nLCB0cmFuc2Zvcm1pbmcsIGFuZCBmb3JtYXR0aW5nIHRoZW0uIFRoZXkgY2FuIGJlIHVzZWQgb24gdGhlaXIgb3duIG9yIGluIGNvbmp1bmN0aW9uIHdpdGggb3RoZXIgTHV4b24gdHlwZXM7IGZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSB7QGxpbmsgRGF0ZVRpbWUucGx1c30gdG8gYWRkIGEgRHVyYXRpb24gb2JqZWN0IHRvIGEgRGF0ZVRpbWUsIHByb2R1Y2luZyBhbm90aGVyIERhdGVUaW1lLlxuICpcbiAqIEhlcmUgaXMgYSBicmllZiBvdmVydmlldyBvZiBjb21tb25seSB1c2VkIG1ldGhvZHMgYW5kIGdldHRlcnMgaW4gRHVyYXRpb246XG4gKlxuICogKiAqKkNyZWF0aW9uKiogVG8gY3JlYXRlIGEgRHVyYXRpb24sIHVzZSB7QGxpbmsgRHVyYXRpb24uZnJvbU1pbGxpc30sIHtAbGluayBEdXJhdGlvbi5mcm9tT2JqZWN0fSwgb3Ige0BsaW5rIER1cmF0aW9uLmZyb21JU099LlxuICogKiAqKlVuaXQgdmFsdWVzKiogU2VlIHRoZSB7QGxpbmsgRHVyYXRpb24ueWVhcnN9LCB7QGxpbmsgRHVyYXRpb24ubW9udGhzfSwge0BsaW5rIER1cmF0aW9uLndlZWtzfSwge0BsaW5rIER1cmF0aW9uLmRheXN9LCB7QGxpbmsgRHVyYXRpb24uaG91cnN9LCB7QGxpbmsgRHVyYXRpb24ubWludXRlc30sIHtAbGluayBEdXJhdGlvbi5zZWNvbmRzfSwge0BsaW5rIER1cmF0aW9uLm1pbGxpc2Vjb25kc30gYWNjZXNzb3JzLlxuICogKiAqKkNvbmZpZ3VyYXRpb24qKiBTZWUgIHtAbGluayBEdXJhdGlvbi5sb2NhbGV9IGFuZCB7QGxpbmsgRHVyYXRpb24ubnVtYmVyaW5nU3lzdGVtfSBhY2Nlc3NvcnMuXG4gKiAqICoqVHJhbnNmb3JtYXRpb24qKiBUbyBjcmVhdGUgbmV3IER1cmF0aW9ucyBvdXQgb2Ygb2xkIG9uZXMgdXNlIHtAbGluayBEdXJhdGlvbi5wbHVzfSwge0BsaW5rIER1cmF0aW9uLm1pbnVzfSwge0BsaW5rIER1cmF0aW9uLm5vcm1hbGl6ZX0sIHtAbGluayBEdXJhdGlvbi5zZXR9LCB7QGxpbmsgRHVyYXRpb24ucmVjb25maWd1cmV9LCB7QGxpbmsgRHVyYXRpb24uc2hpZnRUb30sIGFuZCB7QGxpbmsgRHVyYXRpb24ubmVnYXRlfS5cbiAqICogKipPdXRwdXQqKiBUbyBjb252ZXJ0IHRoZSBEdXJhdGlvbiBpbnRvIG90aGVyIHJlcHJlc2VudGF0aW9ucywgc2VlIHtAbGluayBEdXJhdGlvbi5hc30sIHtAbGluayBEdXJhdGlvbi50b0lTT30sIHtAbGluayBEdXJhdGlvbi50b0Zvcm1hdH0sIGFuZCB7QGxpbmsgRHVyYXRpb24udG9KU09OfVxuICpcbiAqIFRoZXJlJ3MgYXJlIG1vcmUgbWV0aG9kcyBkb2N1bWVudGVkIGJlbG93LiBJbiBhZGRpdGlvbiwgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gc3VidGxlciB0b3BpY3MgbGlrZSBpbnRlcm5hdGlvbmFsaXphdGlvbiBhbmQgdmFsaWRpdHksIHNlZSB0aGUgZXh0ZXJuYWwgZG9jdW1lbnRhdGlvbi5cbiAqL1xuXG5cbnZhciBEdXJhdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gRHVyYXRpb24oY29uZmlnKSB7XG4gICAgdmFyIGFjY3VyYXRlID0gY29uZmlnLmNvbnZlcnNpb25BY2N1cmFjeSA9PT0gXCJsb25ndGVybVwiIHx8IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy52YWx1ZXMgPSBjb25maWcudmFsdWVzO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5sb2MgPSBjb25maWcubG9jIHx8IExvY2FsZS5jcmVhdGUoKTtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuY29udmVyc2lvbkFjY3VyYWN5ID0gYWNjdXJhdGUgPyBcImxvbmd0ZXJtXCIgOiBcImNhc3VhbFwiO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5pbnZhbGlkID0gY29uZmlnLmludmFsaWQgfHwgbnVsbDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMubWF0cml4ID0gYWNjdXJhdGUgPyBhY2N1cmF0ZU1hdHJpeCA6IGNhc3VhbE1hdHJpeDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuaXNMdXhvbkR1cmF0aW9uID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIER1cmF0aW9uIGZyb20gYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gY291bnQgb2YgbWlsbGlzZWNvbmRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyBmb3IgcGFyc2luZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gdGhlIGxvY2FsZSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG5cblxuICBEdXJhdGlvbi5mcm9tTWlsbGlzID0gZnVuY3Rpb24gZnJvbU1pbGxpcyhjb3VudCwgb3B0cykge1xuICAgIHJldHVybiBEdXJhdGlvbi5mcm9tT2JqZWN0KE9iamVjdC5hc3NpZ24oe1xuICAgICAgbWlsbGlzZWNvbmRzOiBjb3VudFxuICAgIH0sIG9wdHMpKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgRHVyYXRpb24gZnJvbSBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGgga2V5cyBsaWtlICd5ZWFycycgYW5kICdob3Vycy5cbiAgICogSWYgdGhpcyBvYmplY3QgaXMgZW1wdHkgdGhlbiBhIHplcm8gbWlsbGlzZWNvbmRzIGR1cmF0aW9uIGlzIHJldHVybmVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gdGhlIG9iamVjdCB0byBjcmVhdGUgdGhlIERhdGVUaW1lIGZyb21cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai55ZWFyc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnF1YXJ0ZXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubW9udGhzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoud2Vla3NcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5kYXlzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouaG91cnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taW51dGVzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouc2Vjb25kc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1pbGxpc2Vjb25kc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29iai5sb2NhbGU9J2VuLVVTJ10gLSB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2JqLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29iai5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIDtcblxuICBEdXJhdGlvbi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiRHVyYXRpb24uZnJvbU9iamVjdDogYXJndW1lbnQgZXhwZWN0ZWQgdG8gYmUgYW4gb2JqZWN0LCBnb3QgXCIgKyAob2JqID09PSBudWxsID8gXCJudWxsXCIgOiB0eXBlb2Ygb2JqKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEdXJhdGlvbih7XG4gICAgICB2YWx1ZXM6IG5vcm1hbGl6ZU9iamVjdChvYmosIER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQsIFtcImxvY2FsZVwiLCBcIm51bWJlcmluZ1N5c3RlbVwiLCBcImNvbnZlcnNpb25BY2N1cmFjeVwiLCBcInpvbmVcIiAvLyBhIGJpdCBvZiBkZWJ0OyBpdCdzIHN1cGVyIGluY29udmVuaWVudCBpbnRlcm5hbGx5IG5vdCB0byBiZSBhYmxlIHRvIGJsaW5kbHkgcGFzcyB0aGlzXG4gICAgICBdKSxcbiAgICAgIGxvYzogTG9jYWxlLmZyb21PYmplY3Qob2JqKSxcbiAgICAgIGNvbnZlcnNpb25BY2N1cmFjeTogb2JqLmNvbnZlcnNpb25BY2N1cmFjeVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiBmcm9tIGFuIElTTyA4NjAxIGR1cmF0aW9uIHN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0ZXh0IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyBmb3IgcGFyc2luZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gdGhlIGxvY2FsZSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI0R1cmF0aW9uc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPKCdQM1k2TTFXNERUMTJIMzBNNVMnKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMywgbW9udGhzOiA2LCB3ZWVrczogMSwgZGF5czogNCwgaG91cnM6IDEyLCBtaW51dGVzOiAzMCwgc2Vjb25kczogNSB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU08oJ1BUMjNIJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDIzIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTTygnUDVZM00nKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogNSwgbW9udGhzOiAzIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICA7XG5cbiAgRHVyYXRpb24uZnJvbUlTTyA9IGZ1bmN0aW9uIGZyb21JU08odGV4dCwgb3B0cykge1xuICAgIHZhciBfcGFyc2VJU09EdXJhdGlvbiA9IHBhcnNlSVNPRHVyYXRpb24odGV4dCksXG4gICAgICAgIHBhcnNlZCA9IF9wYXJzZUlTT0R1cmF0aW9uWzBdO1xuXG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgdmFyIG9iaiA9IE9iamVjdC5hc3NpZ24ocGFyc2VkLCBvcHRzKTtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5mcm9tT2JqZWN0KG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5pbnZhbGlkKFwidW5wYXJzYWJsZVwiLCBcInRoZSBpbnB1dCBcXFwiXCIgKyB0ZXh0ICsgXCJcXFwiIGNhbid0IGJlIHBhcnNlZCBhcyBJU08gODYwMVwiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIER1cmF0aW9uIGZyb20gYW4gSVNPIDg2MDEgdGltZSBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGV4dCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPVGltZSgnMTE6MjI6MzMuNDQ0JykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAyMiwgc2Vjb25kczogMzMsIG1pbGxpc2Vjb25kczogNDQ0IH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJzExOjAwJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAwLCBzZWNvbmRzOiAwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJ1QxMTowMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCcxMTAwJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAwLCBzZWNvbmRzOiAwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJ1QxMTAwJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAwLCBzZWNvbmRzOiAwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICA7XG5cbiAgRHVyYXRpb24uZnJvbUlTT1RpbWUgPSBmdW5jdGlvbiBmcm9tSVNPVGltZSh0ZXh0LCBvcHRzKSB7XG4gICAgdmFyIF9wYXJzZUlTT1RpbWVPbmx5ID0gcGFyc2VJU09UaW1lT25seSh0ZXh0KSxcbiAgICAgICAgcGFyc2VkID0gX3BhcnNlSVNPVGltZU9ubHlbMF07XG5cbiAgICBpZiAocGFyc2VkKSB7XG4gICAgICB2YXIgb2JqID0gT2JqZWN0LmFzc2lnbihwYXJzZWQsIG9wdHMpO1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmZyb21PYmplY3Qob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIFwidGhlIGlucHV0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgY2FuJ3QgYmUgcGFyc2VkIGFzIElTTyA4NjAxXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuIGludmFsaWQgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gLSBzaW1wbGUgc3RyaW5nIG9mIHdoeSB0aGlzIGRhdGV0aW1lIGlzIGludmFsaWQuIFNob3VsZCBub3QgY29udGFpbiBwYXJhbWV0ZXJzIG9yIGFueXRoaW5nIGVsc2UgZGF0YS1kZXBlbmRlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtleHBsYW5hdGlvbj1udWxsXSAtIGxvbmdlciBleHBsYW5hdGlvbiwgbWF5IGluY2x1ZGUgcGFyYW1ldGVycyBhbmQgb3RoZXIgdXNlZnVsIGRlYnVnZ2luZyBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIDtcblxuICBEdXJhdGlvbi5pbnZhbGlkID0gZnVuY3Rpb24gaW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uKSB7XG4gICAgaWYgKGV4cGxhbmF0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIGV4cGxhbmF0aW9uID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIXJlYXNvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibmVlZCB0byBzcGVjaWZ5IGEgcmVhc29uIHRoZSBEdXJhdGlvbiBpcyBpbnZhbGlkXCIpO1xuICAgIH1cblxuICAgIHZhciBpbnZhbGlkID0gcmVhc29uIGluc3RhbmNlb2YgSW52YWxpZCA/IHJlYXNvbiA6IG5ldyBJbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24pO1xuXG4gICAgaWYgKFNldHRpbmdzLnRocm93T25JbnZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZER1cmF0aW9uRXJyb3IoaW52YWxpZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRHVyYXRpb24oe1xuICAgICAgICBpbnZhbGlkOiBpbnZhbGlkXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICA7XG5cbiAgRHVyYXRpb24ubm9ybWFsaXplVW5pdCA9IGZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXQodW5pdCkge1xuICAgIHZhciBub3JtYWxpemVkID0ge1xuICAgICAgeWVhcjogXCJ5ZWFyc1wiLFxuICAgICAgeWVhcnM6IFwieWVhcnNcIixcbiAgICAgIHF1YXJ0ZXI6IFwicXVhcnRlcnNcIixcbiAgICAgIHF1YXJ0ZXJzOiBcInF1YXJ0ZXJzXCIsXG4gICAgICBtb250aDogXCJtb250aHNcIixcbiAgICAgIG1vbnRoczogXCJtb250aHNcIixcbiAgICAgIHdlZWs6IFwid2Vla3NcIixcbiAgICAgIHdlZWtzOiBcIndlZWtzXCIsXG4gICAgICBkYXk6IFwiZGF5c1wiLFxuICAgICAgZGF5czogXCJkYXlzXCIsXG4gICAgICBob3VyOiBcImhvdXJzXCIsXG4gICAgICBob3VyczogXCJob3Vyc1wiLFxuICAgICAgbWludXRlOiBcIm1pbnV0ZXNcIixcbiAgICAgIG1pbnV0ZXM6IFwibWludXRlc1wiLFxuICAgICAgc2Vjb25kOiBcInNlY29uZHNcIixcbiAgICAgIHNlY29uZHM6IFwic2Vjb25kc1wiLFxuICAgICAgbWlsbGlzZWNvbmQ6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgICBtaWxsaXNlY29uZHM6IFwibWlsbGlzZWNvbmRzXCJcbiAgICB9W3VuaXQgPyB1bml0LnRvTG93ZXJDYXNlKCkgOiB1bml0XTtcbiAgICBpZiAoIW5vcm1hbGl6ZWQpIHRocm93IG5ldyBJbnZhbGlkVW5pdEVycm9yKHVuaXQpO1xuICAgIHJldHVybiBub3JtYWxpemVkO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgYSBEdXJhdGlvbi4gV29ya3MgYWNyb3NzIGNvbnRleHQgYm91bmRhcmllc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgO1xuXG4gIER1cmF0aW9uLmlzRHVyYXRpb24gPSBmdW5jdGlvbiBpc0R1cmF0aW9uKG8pIHtcbiAgICByZXR1cm4gbyAmJiBvLmlzTHV4b25EdXJhdGlvbiB8fCBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogR2V0ICB0aGUgbG9jYWxlIG9mIGEgRHVyYXRpb24sIHN1Y2ggJ2VuLUdCJ1xuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgO1xuXG4gIHZhciBfcHJvdG8gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbiBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgZm9ybWF0IHN0cmluZy4gWW91IG1heSB1c2UgdGhlc2UgdG9rZW5zOlxuICAgKiAqIGBTYCBmb3IgbWlsbGlzZWNvbmRzXG4gICAqICogYHNgIGZvciBzZWNvbmRzXG4gICAqICogYG1gIGZvciBtaW51dGVzXG4gICAqICogYGhgIGZvciBob3Vyc1xuICAgKiAqIGBkYCBmb3IgZGF5c1xuICAgKiAqIGBNYCBmb3IgbW9udGhzXG4gICAqICogYHlgIGZvciB5ZWFyc1xuICAgKiBOb3RlczpcbiAgICogKiBBZGQgcGFkZGluZyBieSByZXBlYXRpbmcgdGhlIHRva2VuLCBlLmcuIFwieXlcIiBwYWRzIHRoZSB5ZWFycyB0byB0d28gZGlnaXRzLCBcImhoaGhcIiBwYWRzIHRoZSBob3VycyBvdXQgdG8gZm91ciBkaWdpdHNcbiAgICogKiBUaGUgZHVyYXRpb24gd2lsbCBiZSBjb252ZXJ0ZWQgdG8gdGhlIHNldCBvZiB1bml0cyBpbiB0aGUgZm9ybWF0IHN0cmluZyB1c2luZyB7QGxpbmsgRHVyYXRpb24uc2hpZnRUb30gYW5kIHRoZSBEdXJhdGlvbnMncyBjb252ZXJzaW9uIGFjY3VyYWN5IHNldHRpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbXQgLSB0aGUgZm9ybWF0IHN0cmluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5mbG9vcj10cnVlXSAtIGZsb29yIG51bWVyaWNhbCB2YWx1ZXNcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAxLCBkYXlzOiA2LCBzZWNvbmRzOiAyIH0pLnRvRm9ybWF0KFwieSBkIHNcIikgLy89PiBcIjEgNiAyXCJcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAxLCBkYXlzOiA2LCBzZWNvbmRzOiAyIH0pLnRvRm9ybWF0KFwieXkgZGQgc3NzXCIpIC8vPT4gXCIwMSAwNiAwMDJcIlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9Gb3JtYXQoXCJNIFNcIikgLy89PiBcIjEyIDUxODQwMjAwMFwiXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIF9wcm90by50b0Zvcm1hdCA9IGZ1bmN0aW9uIHRvRm9ybWF0KGZtdCwgb3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyByZXZlcnNlLWNvbXBhdCBzaW5jZSAxLjI7IHdlIGFsd2F5cyByb3VuZCBkb3duIG5vdywgbmV2ZXIgdXAsIGFuZCB3ZSBkbyBpdCBieSBkZWZhdWx0XG4gICAgdmFyIGZtdE9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzLCB7XG4gICAgICBmbG9vcjogb3B0cy5yb3VuZCAhPT0gZmFsc2UgJiYgb3B0cy5mbG9vciAhPT0gZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLmxvYywgZm10T3B0cykuZm9ybWF0RHVyYXRpb25Gcm9tU3RyaW5nKHRoaXMsIGZtdCkgOiBJTlZBTElEO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCB0aGlzIER1cmF0aW9uJ3MgdmFsdWVzLlxuICAgKiBAcGFyYW0gb3B0cyAtIG9wdGlvbnMgZm9yIGdlbmVyYXRpbmcgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVDb25maWc9ZmFsc2VdIC0gaW5jbHVkZSBjb25maWd1cmF0aW9uIGF0dHJpYnV0ZXMgaW4gdGhlIG91dHB1dFxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9PYmplY3QoKSAvLz0+IHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3Qob3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHt9O1xuICAgIHZhciBiYXNlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy52YWx1ZXMpO1xuXG4gICAgaWYgKG9wdHMuaW5jbHVkZUNvbmZpZykge1xuICAgICAgYmFzZS5jb252ZXJzaW9uQWNjdXJhY3kgPSB0aGlzLmNvbnZlcnNpb25BY2N1cmFjeTtcbiAgICAgIGJhc2UubnVtYmVyaW5nU3lzdGVtID0gdGhpcy5sb2MubnVtYmVyaW5nU3lzdGVtO1xuICAgICAgYmFzZS5sb2NhbGUgPSB0aGlzLmxvYy5sb2NhbGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI0R1cmF0aW9uc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDMsIHNlY29uZHM6IDQ1IH0pLnRvSVNPKCkgLy89PiAnUDNZVDQ1UydcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1vbnRoczogNCwgc2Vjb25kczogNDUgfSkudG9JU08oKSAvLz0+ICdQNE1UNDVTJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbW9udGhzOiA1IH0pLnRvSVNPKCkgLy89PiAnUDVNJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWludXRlczogNSB9KS50b0lTTygpIC8vPT4gJ1BUNU0nXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtaWxsaXNlY29uZHM6IDYgfSkudG9JU08oKSAvLz0+ICdQVDAuMDA2UydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b0lTTyA9IGZ1bmN0aW9uIHRvSVNPKCkge1xuICAgIC8vIHdlIGNvdWxkIHVzZSB0aGUgZm9ybWF0dGVyLCBidXQgdGhpcyBpcyBhbiBlYXNpZXIgd2F5IHRvIGdldCB0aGUgbWluaW11bSBzdHJpbmdcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIHMgPSBcIlBcIjtcbiAgICBpZiAodGhpcy55ZWFycyAhPT0gMCkgcyArPSB0aGlzLnllYXJzICsgXCJZXCI7XG4gICAgaWYgKHRoaXMubW9udGhzICE9PSAwIHx8IHRoaXMucXVhcnRlcnMgIT09IDApIHMgKz0gdGhpcy5tb250aHMgKyB0aGlzLnF1YXJ0ZXJzICogMyArIFwiTVwiO1xuICAgIGlmICh0aGlzLndlZWtzICE9PSAwKSBzICs9IHRoaXMud2Vla3MgKyBcIldcIjtcbiAgICBpZiAodGhpcy5kYXlzICE9PSAwKSBzICs9IHRoaXMuZGF5cyArIFwiRFwiO1xuICAgIGlmICh0aGlzLmhvdXJzICE9PSAwIHx8IHRoaXMubWludXRlcyAhPT0gMCB8fCB0aGlzLnNlY29uZHMgIT09IDAgfHwgdGhpcy5taWxsaXNlY29uZHMgIT09IDApIHMgKz0gXCJUXCI7XG4gICAgaWYgKHRoaXMuaG91cnMgIT09IDApIHMgKz0gdGhpcy5ob3VycyArIFwiSFwiO1xuICAgIGlmICh0aGlzLm1pbnV0ZXMgIT09IDApIHMgKz0gdGhpcy5taW51dGVzICsgXCJNXCI7XG4gICAgaWYgKHRoaXMuc2Vjb25kcyAhPT0gMCB8fCB0aGlzLm1pbGxpc2Vjb25kcyAhPT0gMCkgLy8gdGhpcyB3aWxsIGhhbmRsZSBcImZsb2F0aW5nIHBvaW50IG1hZG5lc3NcIiBieSByZW1vdmluZyBleHRyYSBkZWNpbWFsIHBsYWNlc1xuICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTg4MDA0L2lzLWZsb2F0aW5nLXBvaW50LW1hdGgtYnJva2VuXG4gICAgICBzICs9IHJvdW5kVG8odGhpcy5zZWNvbmRzICsgdGhpcy5taWxsaXNlY29uZHMgLyAxMDAwLCAzKSArIFwiU1wiO1xuICAgIGlmIChzID09PSBcIlBcIikgcyArPSBcIlQwU1wiO1xuICAgIHJldHVybiBzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbiwgZm9ybWF0dGVkIGFzIGEgdGltZSBvZiBkYXkuXG4gICAqIE5vdGUgdGhhdCB0aGlzIHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlIGR1cmF0aW9uIGlzIGludmFsaWQsIG5lZ2F0aXZlLCBvciBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gMjQgaG91cnMuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NNaWxsaXNlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBtaWxsaXNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzU2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIHNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVQcmVmaXg9ZmFsc2VdIC0gaW5jbHVkZSB0aGUgYFRgIHByZWZpeFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZm9ybWF0PSdleHRlbmRlZCddIC0gY2hvb3NlIGJldHdlZW4gdGhlIGJhc2ljIGFuZCBleHRlbmRlZCBmb3JtYXRcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoKSAvLz0+ICcxMTowMDowMC4wMDAnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKHsgc3VwcHJlc3NNaWxsaXNlY29uZHM6IHRydWUgfSkgLy89PiAnMTE6MDA6MDAnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKHsgc3VwcHJlc3NTZWNvbmRzOiB0cnVlIH0pIC8vPT4gJzExOjAwJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSh7IGluY2x1ZGVQcmVmaXg6IHRydWUgfSkgLy89PiAnVDExOjAwOjAwLjAwMCdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoeyBmb3JtYXQ6ICdiYXNpYycgfSkgLy89PiAnMTEwMDAwLjAwMCdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b0lTT1RpbWUgPSBmdW5jdGlvbiB0b0lTT1RpbWUob3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIG1pbGxpcyA9IHRoaXMudG9NaWxsaXMoKTtcbiAgICBpZiAobWlsbGlzIDwgMCB8fCBtaWxsaXMgPj0gODY0MDAwMDApIHJldHVybiBudWxsO1xuICAgIG9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHN1cHByZXNzTWlsbGlzZWNvbmRzOiBmYWxzZSxcbiAgICAgIHN1cHByZXNzU2Vjb25kczogZmFsc2UsXG4gICAgICBpbmNsdWRlUHJlZml4OiBmYWxzZSxcbiAgICAgIGZvcm1hdDogXCJleHRlbmRlZFwiXG4gICAgfSwgb3B0cyk7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5zaGlmdFRvKFwiaG91cnNcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiLCBcIm1pbGxpc2Vjb25kc1wiKTtcbiAgICB2YXIgZm10ID0gb3B0cy5mb3JtYXQgPT09IFwiYmFzaWNcIiA/IFwiaGhtbVwiIDogXCJoaDptbVwiO1xuXG4gICAgaWYgKCFvcHRzLnN1cHByZXNzU2Vjb25kcyB8fCB2YWx1ZS5zZWNvbmRzICE9PSAwIHx8IHZhbHVlLm1pbGxpc2Vjb25kcyAhPT0gMCkge1xuICAgICAgZm10ICs9IG9wdHMuZm9ybWF0ID09PSBcImJhc2ljXCIgPyBcInNzXCIgOiBcIjpzc1wiO1xuXG4gICAgICBpZiAoIW9wdHMuc3VwcHJlc3NNaWxsaXNlY29uZHMgfHwgdmFsdWUubWlsbGlzZWNvbmRzICE9PSAwKSB7XG4gICAgICAgIGZtdCArPSBcIi5TU1NcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3RyID0gdmFsdWUudG9Gb3JtYXQoZm10KTtcblxuICAgIGlmIChvcHRzLmluY2x1ZGVQcmVmaXgpIHtcbiAgICAgIHN0ciA9IFwiVFwiICsgc3RyO1xuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbiBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIEpTT04uXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvSVNPKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbiBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIGRlYnVnZ2luZy5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnRvSVNPKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gbWlsbGlzZWNvbmRzIHZhbHVlIG9mIHRoaXMgRHVyYXRpb24uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9NaWxsaXMgPSBmdW5jdGlvbiB0b01pbGxpcygpIHtcbiAgICByZXR1cm4gdGhpcy5hcyhcIm1pbGxpc2Vjb25kc1wiKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBtaWxsaXNlY29uZHMgdmFsdWUgb2YgdGhpcyBEdXJhdGlvbi4gQWxpYXMgb2Yge0BsaW5rIHRvTWlsbGlzfVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnZhbHVlT2YgPSBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0aGlzLnRvTWlsbGlzKCk7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2UgdGhpcyBEdXJhdGlvbiBsb25nZXIgYnkgdGhlIHNwZWNpZmllZCBhbW91bnQuIFJldHVybiBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGFtb3VudCB0byBhZGQuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wbHVzID0gZnVuY3Rpb24gcGx1cyhkdXJhdGlvbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICB2YXIgZHVyID0gZnJpZW5kbHlEdXJhdGlvbihkdXJhdGlvbiksXG4gICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvcmRlcmVkVW5pdHMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgdmFyIGsgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgaWYgKGhhc093blByb3BlcnR5KGR1ci52YWx1ZXMsIGspIHx8IGhhc093blByb3BlcnR5KHRoaXMudmFsdWVzLCBrKSkge1xuICAgICAgICByZXN1bHRba10gPSBkdXIuZ2V0KGspICsgdGhpcy5nZXQoayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHtcbiAgICAgIHZhbHVlczogcmVzdWx0XG4gICAgfSwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2UgdGhpcyBEdXJhdGlvbiBzaG9ydGVyIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LiBSZXR1cm4gYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gc3VidHJhY3QuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5taW51cyA9IGZ1bmN0aW9uIG1pbnVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIHZhciBkdXIgPSBmcmllbmRseUR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5wbHVzKGR1ci5uZWdhdGUoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFNjYWxlIHRoaXMgRHVyYXRpb24gYnkgdGhlIHNwZWNpZmllZCBhbW91bnQuIFJldHVybiBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIHVuaXQuIEFyaXR5IGlzIDEgb3IgMjogdGhlIHZhbHVlIG9mIHRoZSB1bml0IGFuZCwgb3B0aW9uYWxseSwgdGhlIHVuaXQgbmFtZS4gTXVzdCByZXR1cm4gYSBudW1iZXIuXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSwgbWludXRlczogMzAgfSkubWFwVW5pdCh4ID0+IHggKiAyKSAvLz0+IHsgaG91cnM6IDIsIG1pbnV0ZXM6IDYwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBtaW51dGVzOiAzMCB9KS5tYXBVbml0KCh4LCB1KSA9PiB1ID09PSBcImhvdXJcIiA/IHggKiAyIDogeCkgLy89PiB7IGhvdXJzOiAyLCBtaW51dGVzOiAzMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5tYXBVbml0cyA9IGZ1bmN0aW9uIG1hcFVuaXRzKGZuKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgIGZvciAodmFyIF9pID0gMCwgX09iamVjdCRrZXlzID0gT2JqZWN0LmtleXModGhpcy52YWx1ZXMpOyBfaSA8IF9PYmplY3Qka2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBrID0gX09iamVjdCRrZXlzW19pXTtcbiAgICAgIHJlc3VsdFtrXSA9IGFzTnVtYmVyKGZuKHRoaXMudmFsdWVzW2tdLCBrKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHtcbiAgICAgIHZhbHVlczogcmVzdWx0XG4gICAgfSwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBhIHVuaXQgc3VjaCBhcyAnbWludXRlJyBvciAnZGF5J1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMiwgZGF5czogM30pLnllYXJzIC8vPT4gMlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMiwgZGF5czogM30pLm1vbnRocyAvLz0+IDBcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDIsIGRheXM6IDN9KS5kYXlzIC8vPT4gM1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldCh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXNbRHVyYXRpb24ubm9ybWFsaXplVW5pdCh1bml0KV07XG4gIH1cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIHZhbHVlcyBvZiBzcGVjaWZpZWQgdW5pdHMuIFJldHVybiBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIC0gYSBtYXBwaW5nIG9mIHVuaXRzIHRvIG51bWJlcnNcbiAgICogQGV4YW1wbGUgZHVyLnNldCh7IHllYXJzOiAyMDE3IH0pXG4gICAqIEBleGFtcGxlIGR1ci5zZXQoeyBob3VyczogOCwgbWludXRlczogMzAgfSlcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnNldCA9IGZ1bmN0aW9uIHNldCh2YWx1ZXMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgdmFyIG1peGVkID0gT2JqZWN0LmFzc2lnbih0aGlzLnZhbHVlcywgbm9ybWFsaXplT2JqZWN0KHZhbHVlcywgRHVyYXRpb24ubm9ybWFsaXplVW5pdCwgW10pKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywge1xuICAgICAgdmFsdWVzOiBtaXhlZFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBsb2NhbGUgYW5kL29yIG51bWJlcmluZ1N5c3RlbS4gIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQGV4YW1wbGUgZHVyLnJlY29uZmlndXJlKHsgbG9jYWxlOiAnZW4tR0InIH0pXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZWNvbmZpZ3VyZSA9IGZ1bmN0aW9uIHJlY29uZmlndXJlKF90ZW1wKSB7XG4gICAgdmFyIF9yZWYgPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcCxcbiAgICAgICAgbG9jYWxlID0gX3JlZi5sb2NhbGUsXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSA9IF9yZWYubnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBjb252ZXJzaW9uQWNjdXJhY3kgPSBfcmVmLmNvbnZlcnNpb25BY2N1cmFjeTtcblxuICAgIHZhciBsb2MgPSB0aGlzLmxvYy5jbG9uZSh7XG4gICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgIG51bWJlcmluZ1N5c3RlbTogbnVtYmVyaW5nU3lzdGVtXG4gICAgfSksXG4gICAgICAgIG9wdHMgPSB7XG4gICAgICBsb2M6IGxvY1xuICAgIH07XG5cbiAgICBpZiAoY29udmVyc2lvbkFjY3VyYWN5KSB7XG4gICAgICBvcHRzLmNvbnZlcnNpb25BY2N1cmFjeSA9IGNvbnZlcnNpb25BY2N1cmFjeTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmUodGhpcywgb3B0cyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBkdXJhdGlvbiBpbiB0aGUgc3BlY2lmaWVkIHVuaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gYSB1bml0IHN1Y2ggYXMgJ21pbnV0ZXMnIG9yICdkYXlzJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMX0pLmFzKCdkYXlzJykgLy89PiAzNjVcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDF9KS5hcygnbW9udGhzJykgLy89PiAxMlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHtob3VyczogNjB9KS5hcygnZGF5cycpIC8vPT4gMi41XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYXMgPSBmdW5jdGlvbiBhcyh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuc2hpZnRUbyh1bml0KS5nZXQodW5pdCkgOiBOYU47XG4gIH1cbiAgLyoqXG4gICAqIFJlZHVjZSB0aGlzIER1cmF0aW9uIHRvIGl0cyBjYW5vbmljYWwgcmVwcmVzZW50YXRpb24gaW4gaXRzIGN1cnJlbnQgdW5pdHMuXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMiwgZGF5czogNTAwMCB9KS5ub3JtYWxpemUoKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMTUsIGRheXM6IDI1NSB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTIsIG1pbnV0ZXM6IC00NSB9KS5ub3JtYWxpemUoKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDE1IH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgdmFyIHZhbHMgPSB0aGlzLnRvT2JqZWN0KCk7XG4gICAgbm9ybWFsaXplVmFsdWVzKHRoaXMubWF0cml4LCB2YWxzKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywge1xuICAgICAgdmFsdWVzOiB2YWxzXG4gICAgfSwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhpcyBEdXJhdGlvbiBpbnRvIGl0cyByZXByZXNlbnRhdGlvbiBpbiBhIGRpZmZlcmVudCBzZXQgb2YgdW5pdHMuXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSwgc2Vjb25kczogMzAgfSkuc2hpZnRUbygnbWludXRlcycsICdtaWxsaXNlY29uZHMnKS50b09iamVjdCgpIC8vPT4geyBtaW51dGVzOiA2MCwgbWlsbGlzZWNvbmRzOiAzMDAwMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zaGlmdFRvID0gZnVuY3Rpb24gc2hpZnRUbygpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdW5pdHMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICB1bml0c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAodW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB1bml0cyA9IHVuaXRzLm1hcChmdW5jdGlvbiAodSkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQodSk7XG4gICAgfSk7XG4gICAgdmFyIGJ1aWx0ID0ge30sXG4gICAgICAgIGFjY3VtdWxhdGVkID0ge30sXG4gICAgICAgIHZhbHMgPSB0aGlzLnRvT2JqZWN0KCk7XG4gICAgdmFyIGxhc3RVbml0O1xuXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2Uob3JkZXJlZFVuaXRzKSwgX3N0ZXAyOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIoKSkuZG9uZTspIHtcbiAgICAgIHZhciBrID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICBpZiAodW5pdHMuaW5kZXhPZihrKSA+PSAwKSB7XG4gICAgICAgIGxhc3RVbml0ID0gaztcbiAgICAgICAgdmFyIG93biA9IDA7IC8vIGFueXRoaW5nIHdlIGhhdmVuJ3QgYm9pbGVkIGRvd24geWV0IHNob3VsZCBnZXQgYm9pbGVkIHRvIHRoaXMgdW5pdFxuXG4gICAgICAgIGZvciAodmFyIGFrIGluIGFjY3VtdWxhdGVkKSB7XG4gICAgICAgICAgb3duICs9IHRoaXMubWF0cml4W2FrXVtrXSAqIGFjY3VtdWxhdGVkW2FrXTtcbiAgICAgICAgICBhY2N1bXVsYXRlZFtha10gPSAwO1xuICAgICAgICB9IC8vIHBsdXMgYW55dGhpbmcgdGhhdCdzIGFscmVhZHkgaW4gdGhpcyB1bml0XG5cblxuICAgICAgICBpZiAoaXNOdW1iZXIodmFsc1trXSkpIHtcbiAgICAgICAgICBvd24gKz0gdmFsc1trXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gTWF0aC50cnVuYyhvd24pO1xuICAgICAgICBidWlsdFtrXSA9IGk7XG4gICAgICAgIGFjY3VtdWxhdGVkW2tdID0gb3duIC0gaTsgLy8gd2UnZCBsaWtlIHRvIGFic29yYiB0aGVzZSBmcmFjdGlvbnMgaW4gYW5vdGhlciB1bml0XG4gICAgICAgIC8vIHBsdXMgYW55dGhpbmcgZnVydGhlciBkb3duIHRoZSBjaGFpbiB0aGF0IHNob3VsZCBiZSByb2xsZWQgdXAgaW4gdG8gdGhpc1xuXG4gICAgICAgIGZvciAodmFyIGRvd24gaW4gdmFscykge1xuICAgICAgICAgIGlmIChvcmRlcmVkVW5pdHMuaW5kZXhPZihkb3duKSA+IG9yZGVyZWRVbml0cy5pbmRleE9mKGspKSB7XG4gICAgICAgICAgICBjb252ZXJ0KHRoaXMubWF0cml4LCB2YWxzLCBkb3duLCBidWlsdCwgayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIG90aGVyd2lzZSwga2VlcCBpdCBpbiB0aGUgd2luZ3MgdG8gYm9pbCBpdCBsYXRlclxuXG4gICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKHZhbHNba10pKSB7XG4gICAgICAgIGFjY3VtdWxhdGVkW2tdID0gdmFsc1trXTtcbiAgICAgIH1cbiAgICB9IC8vIGFueXRoaW5nIGxlZnRvdmVyIGJlY29tZXMgdGhlIGRlY2ltYWwgZm9yIHRoZSBsYXN0IHVuaXRcbiAgICAvLyBsYXN0VW5pdCBtdXN0IGJlIGRlZmluZWQgc2luY2UgdW5pdHMgaXMgbm90IGVtcHR5XG5cblxuICAgIGZvciAodmFyIGtleSBpbiBhY2N1bXVsYXRlZCkge1xuICAgICAgaWYgKGFjY3VtdWxhdGVkW2tleV0gIT09IDApIHtcbiAgICAgICAgYnVpbHRbbGFzdFVuaXRdICs9IGtleSA9PT0gbGFzdFVuaXQgPyBhY2N1bXVsYXRlZFtrZXldIDogYWNjdW11bGF0ZWRba2V5XSAvIHRoaXMubWF0cml4W2xhc3RVbml0XVtrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7XG4gICAgICB2YWx1ZXM6IGJ1aWx0XG4gICAgfSwgdHJ1ZSkubm9ybWFsaXplKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbmVnYXRpdmUgb2YgdGhpcyBEdXJhdGlvbi5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBzZWNvbmRzOiAzMCB9KS5uZWdhdGUoKS50b09iamVjdCgpIC8vPT4geyBob3VyczogLTEsIHNlY29uZHM6IC0zMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5uZWdhdGUgPSBmdW5jdGlvbiBuZWdhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIHZhciBuZWdhdGVkID0ge307XG5cbiAgICBmb3IgKHZhciBfaTIgPSAwLCBfT2JqZWN0JGtleXMyID0gT2JqZWN0LmtleXModGhpcy52YWx1ZXMpOyBfaTIgPCBfT2JqZWN0JGtleXMyLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIHZhciBrID0gX09iamVjdCRrZXlzMltfaTJdO1xuICAgICAgbmVnYXRlZFtrXSA9IC10aGlzLnZhbHVlc1trXTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmUodGhpcywge1xuICAgICAgdmFsdWVzOiBuZWdhdGVkXG4gICAgfSwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgeWVhcnMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICA7XG5cbiAgLyoqXG4gICAqIEVxdWFsaXR5IGNoZWNrXG4gICAqIFR3byBEdXJhdGlvbnMgYXJlIGVxdWFsIGlmZiB0aGV5IGhhdmUgdGhlIHNhbWUgdW5pdHMgYW5kIHRoZSBzYW1lIHZhbHVlcyBmb3IgZWFjaCB1bml0LlxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFvdGhlci5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmxvYy5lcXVhbHMob3RoZXIubG9jKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVxKHYxLCB2Mikge1xuICAgICAgLy8gQ29uc2lkZXIgMCBhbmQgdW5kZWZpbmVkIGFzIGVxdWFsXG4gICAgICBpZiAodjEgPT09IHVuZGVmaW5lZCB8fCB2MSA9PT0gMCkgcmV0dXJuIHYyID09PSB1bmRlZmluZWQgfHwgdjIgPT09IDA7XG4gICAgICByZXR1cm4gdjEgPT09IHYyO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG9yZGVyZWRVbml0cyksIF9zdGVwMzsgIShfc3RlcDMgPSBfaXRlcmF0b3IzKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgdSA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgaWYgKCFlcSh0aGlzLnZhbHVlc1t1XSwgb3RoZXIudmFsdWVzW3VdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKER1cmF0aW9uLCBbe1xuICAgIGtleTogXCJsb2NhbGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmxvYy5sb2NhbGUgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG51bWJlcmluZyBzeXN0ZW0gb2YgYSBEdXJhdGlvbiwgc3VjaCAnYmVuZycuIFRoZSBudW1iZXJpbmcgc3lzdGVtIGlzIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBEdXJhdGlvblxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm51bWJlcmluZ1N5c3RlbVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLm51bWJlcmluZ1N5c3RlbSA6IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInllYXJzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMueWVhcnMgfHwgMCA6IE5hTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBxdWFydGVycy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicXVhcnRlcnNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5xdWFydGVycyB8fCAwIDogTmFOO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG1vbnRocy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMubW9udGhzIHx8IDAgOiBOYU47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgd2Vla3NcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2Vla3NcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy53ZWVrcyB8fCAwIDogTmFOO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRheXMuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRheXNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5kYXlzIHx8IDAgOiBOYU47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaG91cnMuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImhvdXJzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMuaG91cnMgfHwgMCA6IE5hTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBtaW51dGVzLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtaW51dGVzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMubWludXRlcyB8fCAwIDogTmFOO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHNlY29uZHMuXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2Vjb25kc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLnNlY29uZHMgfHwgMCA6IE5hTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBtaWxsaXNlY29uZHMuXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMubWlsbGlzZWNvbmRzIHx8IDAgOiBOYU47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgRHVyYXRpb24gaXMgaW52YWxpZC4gSW52YWxpZCBkdXJhdGlvbnMgYXJlIHJldHVybmVkIGJ5IGRpZmYgb3BlcmF0aW9uc1xuICAgICAqIG9uIGludmFsaWQgRGF0ZVRpbWVzIG9yIEludGVydmFscy5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNWYWxpZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW52YWxpZCA9PT0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBlcnJvciBjb2RlIGlmIHRoaXMgRHVyYXRpb24gYmVjYW1lIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIER1cmF0aW9uIGlzIHZhbGlkXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW52YWxpZFJlYXNvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5yZWFzb24gOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGV4cGxhbmF0aW9uIG9mIHdoeSB0aGlzIER1cmF0aW9uIGJlY2FtZSBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBEdXJhdGlvbiBpcyB2YWxpZFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpbnZhbGlkRXhwbGFuYXRpb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQuZXhwbGFuYXRpb24gOiBudWxsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEdXJhdGlvbjtcbn0oKTtcbmZ1bmN0aW9uIGZyaWVuZGx5RHVyYXRpb24oZHVyYXRpb25pc2gpIHtcbiAgaWYgKGlzTnVtYmVyKGR1cmF0aW9uaXNoKSkge1xuICAgIHJldHVybiBEdXJhdGlvbi5mcm9tTWlsbGlzKGR1cmF0aW9uaXNoKTtcbiAgfSBlbHNlIGlmIChEdXJhdGlvbi5pc0R1cmF0aW9uKGR1cmF0aW9uaXNoKSkge1xuICAgIHJldHVybiBkdXJhdGlvbmlzaDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb25pc2ggPT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gRHVyYXRpb24uZnJvbU9iamVjdChkdXJhdGlvbmlzaCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiVW5rbm93biBkdXJhdGlvbiBhcmd1bWVudCBcIiArIGR1cmF0aW9uaXNoICsgXCIgb2YgdHlwZSBcIiArIHR5cGVvZiBkdXJhdGlvbmlzaCk7XG4gIH1cbn1cblxudmFyIElOVkFMSUQkMSA9IFwiSW52YWxpZCBJbnRlcnZhbFwiOyAvLyBjaGVja3MgaWYgdGhlIHN0YXJ0IGlzIGVxdWFsIHRvIG9yIGJlZm9yZSB0aGUgZW5kXG5cbmZ1bmN0aW9uIHZhbGlkYXRlU3RhcnRFbmQoc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0IHx8ICFzdGFydC5pc1ZhbGlkKSB7XG4gICAgcmV0dXJuIEludGVydmFsLmludmFsaWQoXCJtaXNzaW5nIG9yIGludmFsaWQgc3RhcnRcIik7XG4gIH0gZWxzZSBpZiAoIWVuZCB8fCAhZW5kLmlzVmFsaWQpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwuaW52YWxpZChcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRcIik7XG4gIH0gZWxzZSBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwuaW52YWxpZChcImVuZCBiZWZvcmUgc3RhcnRcIiwgXCJUaGUgZW5kIG9mIGFuIGludGVydmFsIG11c3QgYmUgYWZ0ZXIgaXRzIHN0YXJ0LCBidXQgeW91IGhhZCBzdGFydD1cIiArIHN0YXJ0LnRvSVNPKCkgKyBcIiBhbmQgZW5kPVwiICsgZW5kLnRvSVNPKCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG4vKipcbiAqIEFuIEludGVydmFsIG9iamVjdCByZXByZXNlbnRzIGEgaGFsZi1vcGVuIGludGVydmFsIG9mIHRpbWUsIHdoZXJlIGVhY2ggZW5kcG9pbnQgaXMgYSB7QGxpbmsgRGF0ZVRpbWV9LiBDb25jZXB0dWFsbHksIGl0J3MgYSBjb250YWluZXIgZm9yIHRob3NlIHR3byBlbmRwb2ludHMsIGFjY29tcGFuaWVkIGJ5IG1ldGhvZHMgZm9yIGNyZWF0aW5nLCBwYXJzaW5nLCBpbnRlcnJvZ2F0aW5nLCBjb21wYXJpbmcsIHRyYW5zZm9ybWluZywgYW5kIGZvcm1hdHRpbmcgdGhlbS5cbiAqXG4gKiBIZXJlIGlzIGEgYnJpZWYgb3ZlcnZpZXcgb2YgdGhlIG1vc3QgY29tbW9ubHkgdXNlZCBtZXRob2RzIGFuZCBnZXR0ZXJzIGluIEludGVydmFsOlxuICpcbiAqICogKipDcmVhdGlvbioqIFRvIGNyZWF0ZSBhbiBJbnRlcnZhbCwgdXNlIHtAbGluayBmcm9tRGF0ZVRpbWVzfSwge0BsaW5rIGFmdGVyfSwge0BsaW5rIGJlZm9yZX0sIG9yIHtAbGluayBmcm9tSVNPfS5cbiAqICogKipBY2Nlc3NvcnMqKiBVc2Uge0BsaW5rIHN0YXJ0fSBhbmQge0BsaW5rIGVuZH0gdG8gZ2V0IHRoZSBzdGFydCBhbmQgZW5kLlxuICogKiAqKkludGVycm9nYXRpb24qKiBUbyBhbmFseXplIHRoZSBJbnRlcnZhbCwgdXNlIHtAbGluayBjb3VudH0sIHtAbGluayBsZW5ndGh9LCB7QGxpbmsgaGFzU2FtZX0sIHtAbGluayBjb250YWluc30sIHtAbGluayBpc0FmdGVyfSwgb3Ige0BsaW5rIGlzQmVmb3JlfS5cbiAqICogKipUcmFuc2Zvcm1hdGlvbioqIFRvIGNyZWF0ZSBvdGhlciBJbnRlcnZhbHMgb3V0IG9mIHRoaXMgb25lLCB1c2Uge0BsaW5rIHNldH0sIHtAbGluayBzcGxpdEF0fSwge0BsaW5rIHNwbGl0Qnl9LCB7QGxpbmsgZGl2aWRlRXF1YWxseX0sIHtAbGluayBtZXJnZX0sIHtAbGluayB4b3J9LCB7QGxpbmsgdW5pb259LCB7QGxpbmsgaW50ZXJzZWN0aW9ufSwgb3Ige0BsaW5rIGRpZmZlcmVuY2V9LlxuICogKiAqKkNvbXBhcmlzb24qKiBUbyBjb21wYXJlIHRoaXMgSW50ZXJ2YWwgdG8gYW5vdGhlciBvbmUsIHVzZSB7QGxpbmsgZXF1YWxzfSwge0BsaW5rIG92ZXJsYXBzfSwge0BsaW5rIGFidXRzU3RhcnR9LCB7QGxpbmsgYWJ1dHNFbmR9LCB7QGxpbmsgZW5ndWxmc30uXG4gKiAqICoqT3V0cHV0KiogVG8gY29udmVydCB0aGUgSW50ZXJ2YWwgaW50byBvdGhlciByZXByZXNlbnRhdGlvbnMsIHNlZSB7QGxpbmsgdG9TdHJpbmd9LCB7QGxpbmsgdG9JU099LCB7QGxpbmsgdG9JU09EYXRlfSwge0BsaW5rIHRvSVNPVGltZX0sIHtAbGluayB0b0Zvcm1hdH0sIGFuZCB7QGxpbmsgdG9EdXJhdGlvbn0uXG4gKi9cblxuXG52YXIgSW50ZXJ2YWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIEludGVydmFsKGNvbmZpZykge1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucyA9IGNvbmZpZy5zdGFydDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuZSA9IGNvbmZpZy5lbmQ7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG5cbiAgICB0aGlzLmludmFsaWQgPSBjb25maWcuaW52YWxpZCB8fCBudWxsO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5pc0x1eG9uSW50ZXJ2YWwgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW52YWxpZCBJbnRlcnZhbC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiAtIHNpbXBsZSBzdHJpbmcgb2Ygd2h5IHRoaXMgSW50ZXJ2YWwgaXMgaW52YWxpZC4gU2hvdWxkIG5vdCBjb250YWluIHBhcmFtZXRlcnMgb3IgYW55dGhpbmcgZWxzZSBkYXRhLWRlcGVuZGVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2V4cGxhbmF0aW9uPW51bGxdIC0gbG9uZ2VyIGV4cGxhbmF0aW9uLCBtYXkgaW5jbHVkZSBwYXJhbWV0ZXJzIGFuZCBvdGhlciB1c2VmdWwgZGVidWdnaW5nIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cblxuXG4gIEludGVydmFsLmludmFsaWQgPSBmdW5jdGlvbiBpbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24pIHtcbiAgICBpZiAoZXhwbGFuYXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgZXhwbGFuYXRpb24gPSBudWxsO1xuICAgIH1cblxuICAgIGlmICghcmVhc29uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJuZWVkIHRvIHNwZWNpZnkgYSByZWFzb24gdGhlIEludGVydmFsIGlzIGludmFsaWRcIik7XG4gICAgfVxuXG4gICAgdmFyIGludmFsaWQgPSByZWFzb24gaW5zdGFuY2VvZiBJbnZhbGlkID8gcmVhc29uIDogbmV3IEludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbik7XG5cbiAgICBpZiAoU2V0dGluZ3MudGhyb3dPbkludmFsaWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkSW50ZXJ2YWxFcnJvcihpbnZhbGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbCh7XG4gICAgICAgIGludmFsaWQ6IGludmFsaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuIEludGVydmFsIGZyb20gYSBzdGFydCBEYXRlVGltZSBhbmQgYW4gZW5kIERhdGVUaW1lLiBJbmNsdXNpdmUgb2YgdGhlIHN0YXJ0IGJ1dCBub3QgdGhlIGVuZC5cbiAgICogQHBhcmFtIHtEYXRlVGltZXxEYXRlfE9iamVjdH0gc3RhcnRcbiAgICogQHBhcmFtIHtEYXRlVGltZXxEYXRlfE9iamVjdH0gZW5kXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgO1xuXG4gIEludGVydmFsLmZyb21EYXRlVGltZXMgPSBmdW5jdGlvbiBmcm9tRGF0ZVRpbWVzKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgYnVpbHRTdGFydCA9IGZyaWVuZGx5RGF0ZVRpbWUoc3RhcnQpLFxuICAgICAgICBidWlsdEVuZCA9IGZyaWVuZGx5RGF0ZVRpbWUoZW5kKTtcbiAgICB2YXIgdmFsaWRhdGVFcnJvciA9IHZhbGlkYXRlU3RhcnRFbmQoYnVpbHRTdGFydCwgYnVpbHRFbmQpO1xuXG4gICAgaWYgKHZhbGlkYXRlRXJyb3IgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbCh7XG4gICAgICAgIHN0YXJ0OiBidWlsdFN0YXJ0LFxuICAgICAgICBlbmQ6IGJ1aWx0RW5kXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbGlkYXRlRXJyb3I7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gSW50ZXJ2YWwgZnJvbSBhIHN0YXJ0IERhdGVUaW1lIGFuZCBhIER1cmF0aW9uIHRvIGV4dGVuZCB0by5cbiAgICogQHBhcmFtIHtEYXRlVGltZXxEYXRlfE9iamVjdH0gc3RhcnRcbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIHRoZSBsZW5ndGggb2YgdGhlIEludGVydmFsLlxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIDtcblxuICBJbnRlcnZhbC5hZnRlciA9IGZ1bmN0aW9uIGFmdGVyKHN0YXJ0LCBkdXJhdGlvbikge1xuICAgIHZhciBkdXIgPSBmcmllbmRseUR1cmF0aW9uKGR1cmF0aW9uKSxcbiAgICAgICAgZHQgPSBmcmllbmRseURhdGVUaW1lKHN0YXJ0KTtcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdCwgZHQucGx1cyhkdXIpKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuIEludGVydmFsIGZyb20gYW4gZW5kIERhdGVUaW1lIGFuZCBhIER1cmF0aW9uIHRvIGV4dGVuZCBiYWNrd2FyZHMgdG8uXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IGVuZFxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gdGhlIGxlbmd0aCBvZiB0aGUgSW50ZXJ2YWwuXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgO1xuXG4gIEludGVydmFsLmJlZm9yZSA9IGZ1bmN0aW9uIGJlZm9yZShlbmQsIGR1cmF0aW9uKSB7XG4gICAgdmFyIGR1ciA9IGZyaWVuZGx5RHVyYXRpb24oZHVyYXRpb24pLFxuICAgICAgICBkdCA9IGZyaWVuZGx5RGF0ZVRpbWUoZW5kKTtcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdC5taW51cyhkdXIpLCBkdCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBJbnRlcnZhbCBmcm9tIGFuIElTTyA4NjAxIHN0cmluZy5cbiAgICogQWNjZXB0cyBgPHN0YXJ0Pi88ZW5kPmAsIGA8c3RhcnQ+LzxkdXJhdGlvbj5gLCBhbmQgYDxkdXJhdGlvbj4vPGVuZD5gIGZvcm1hdHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIElTTyBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIG9wdGlvbnMgdG8gcGFzcyB7QGxpbmsgRGF0ZVRpbWUuZnJvbUlTT30gYW5kIG9wdGlvbmFsbHkge0BsaW5rIER1cmF0aW9uLmZyb21JU099XG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZV9pbnRlcnZhbHNcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICA7XG5cbiAgSW50ZXJ2YWwuZnJvbUlTTyA9IGZ1bmN0aW9uIGZyb21JU08odGV4dCwgb3B0cykge1xuICAgIHZhciBfc3BsaXQgPSAodGV4dCB8fCBcIlwiKS5zcGxpdChcIi9cIiwgMiksXG4gICAgICAgIHMgPSBfc3BsaXRbMF0sXG4gICAgICAgIGUgPSBfc3BsaXRbMV07XG5cbiAgICBpZiAocyAmJiBlKSB7XG4gICAgICB2YXIgc3RhcnQsIHN0YXJ0SXNWYWxpZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgc3RhcnQgPSBEYXRlVGltZS5mcm9tSVNPKHMsIG9wdHMpO1xuICAgICAgICBzdGFydElzVmFsaWQgPSBzdGFydC5pc1ZhbGlkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzdGFydElzVmFsaWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVuZCwgZW5kSXNWYWxpZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZW5kID0gRGF0ZVRpbWUuZnJvbUlTTyhlLCBvcHRzKTtcbiAgICAgICAgZW5kSXNWYWxpZCA9IGVuZC5pc1ZhbGlkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlbmRJc1ZhbGlkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydElzVmFsaWQgJiYgZW5kSXNWYWxpZCkge1xuICAgICAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzdGFydCwgZW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0SXNWYWxpZCkge1xuICAgICAgICB2YXIgZHVyID0gRHVyYXRpb24uZnJvbUlTTyhlLCBvcHRzKTtcblxuICAgICAgICBpZiAoZHVyLmlzVmFsaWQpIHtcbiAgICAgICAgICByZXR1cm4gSW50ZXJ2YWwuYWZ0ZXIoc3RhcnQsIGR1cik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZW5kSXNWYWxpZCkge1xuICAgICAgICB2YXIgX2R1ciA9IER1cmF0aW9uLmZyb21JU08ocywgb3B0cyk7XG5cbiAgICAgICAgaWYgKF9kdXIuaXNWYWxpZCkge1xuICAgICAgICAgIHJldHVybiBJbnRlcnZhbC5iZWZvcmUoZW5kLCBfZHVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBJbnRlcnZhbC5pbnZhbGlkKFwidW5wYXJzYWJsZVwiLCBcInRoZSBpbnB1dCBcXFwiXCIgKyB0ZXh0ICsgXCJcXFwiIGNhbid0IGJlIHBhcnNlZCBhcyBJU08gODYwMVwiKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGFuIEludGVydmFsLiBXb3JrcyBhY3Jvc3MgY29udGV4dCBib3VuZGFyaWVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICA7XG5cbiAgSW50ZXJ2YWwuaXNJbnRlcnZhbCA9IGZ1bmN0aW9uIGlzSW50ZXJ2YWwobykge1xuICAgIHJldHVybiBvICYmIG8uaXNMdXhvbkludGVydmFsIHx8IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdGFydCBvZiB0aGUgSW50ZXJ2YWxcbiAgICogQHR5cGUge0RhdGVUaW1lfVxuICAgKi9cbiAgO1xuXG4gIHZhciBfcHJvdG8gPSBJbnRlcnZhbC5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgSW50ZXJ2YWwgaW4gdGhlIHNwZWNpZmllZCB1bml0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIHRoZSB1bml0IChzdWNoIGFzICdob3Vycycgb3IgJ2RheXMnKSB0byByZXR1cm4gdGhlIGxlbmd0aCBpbi5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgX3Byb3RvLmxlbmd0aCA9IGZ1bmN0aW9uIGxlbmd0aCh1bml0KSB7XG4gICAgaWYgKHVuaXQgPT09IHZvaWQgMCkge1xuICAgICAgdW5pdCA9IFwibWlsbGlzZWNvbmRzXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudG9EdXJhdGlvbi5hcHBseSh0aGlzLCBbdW5pdF0pLmdldCh1bml0KSA6IE5hTjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY291bnQgb2YgbWludXRlcywgaG91cnMsIGRheXMsIG1vbnRocywgb3IgeWVhcnMgaW5jbHVkZWQgaW4gdGhlIEludGVydmFsLCBldmVuIGluIHBhcnQuXG4gICAqIFVubGlrZSB7QGxpbmsgbGVuZ3RofSB0aGlzIGNvdW50cyBzZWN0aW9ucyBvZiB0aGUgY2FsZW5kYXIsIG5vdCBwZXJpb2RzIG9mIHRpbWUsIGUuZy4gc3BlY2lmeWluZyAnZGF5J1xuICAgKiBhc2tzICd3aGF0IGRhdGVzIGFyZSBpbmNsdWRlZCBpbiB0aGlzIGludGVydmFsPycsIG5vdCAnaG93IG1hbnkgZGF5cyBsb25nIGlzIHRoaXMgaW50ZXJ2YWw/J1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW3VuaXQ9J21pbGxpc2Vjb25kcyddIC0gdGhlIHVuaXQgb2YgdGltZSB0byBjb3VudC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5jb3VudCA9IGZ1bmN0aW9uIGNvdW50KHVuaXQpIHtcbiAgICBpZiAodW5pdCA9PT0gdm9pZCAwKSB7XG4gICAgICB1bml0ID0gXCJtaWxsaXNlY29uZHNcIjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIE5hTjtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0LnN0YXJ0T2YodW5pdCksXG4gICAgICAgIGVuZCA9IHRoaXMuZW5kLnN0YXJ0T2YodW5pdCk7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoZW5kLmRpZmYoc3RhcnQsIHVuaXQpLmdldCh1bml0KSkgKyAxO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIHN0YXJ0IGFuZCBlbmQgYXJlIGJvdGggaW4gdGhlIHNhbWUgdW5pdCBvZiB0aW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gdGhlIHVuaXQgb2YgdGltZSB0byBjaGVjayBzYW1lbmVzcyBvblxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5oYXNTYW1lID0gZnVuY3Rpb24gaGFzU2FtZSh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuaXNFbXB0eSgpIHx8IHRoaXMuZS5taW51cygxKS5oYXNTYW1lKHRoaXMucywgdW5pdCkgOiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCBoYXMgdGhlIHNhbWUgc3RhcnQgYW5kIGVuZCBEYXRlVGltZXMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLnMudmFsdWVPZigpID09PSB0aGlzLmUudmFsdWVPZigpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsJ3Mgc3RhcnQgaXMgYWZ0ZXIgdGhlIHNwZWNpZmllZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gZGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaXNBZnRlciA9IGZ1bmN0aW9uIGlzQWZ0ZXIoZGF0ZVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLnMgPiBkYXRlVGltZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIGVuZCBpcyBiZWZvcmUgdGhlIHNwZWNpZmllZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gZGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaXNCZWZvcmUgPSBmdW5jdGlvbiBpc0JlZm9yZShkYXRlVGltZSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMuZSA8PSBkYXRlVGltZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCBjb250YWlucyB0aGUgc3BlY2lmaWVkIERhdGVUaW1lLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBkYXRlVGltZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5jb250YWlucyA9IGZ1bmN0aW9uIGNvbnRhaW5zKGRhdGVUaW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5zIDw9IGRhdGVUaW1lICYmIHRoaXMuZSA+IGRhdGVUaW1lO1xuICB9XG4gIC8qKlxuICAgKiBcIlNldHNcIiB0aGUgc3RhcnQgYW5kL29yIGVuZCBkYXRlcy4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIEludGVydmFsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIC0gdGhlIHZhbHVlcyB0byBzZXRcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gdmFsdWVzLnN0YXJ0IC0gdGhlIHN0YXJ0aW5nIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IHZhbHVlcy5lbmQgLSB0aGUgZW5kaW5nIERhdGVUaW1lXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zZXQgPSBmdW5jdGlvbiBzZXQoX3RlbXApIHtcbiAgICB2YXIgX3JlZiA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wLFxuICAgICAgICBzdGFydCA9IF9yZWYuc3RhcnQsXG4gICAgICAgIGVuZCA9IF9yZWYuZW5kO1xuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHN0YXJ0IHx8IHRoaXMucywgZW5kIHx8IHRoaXMuZSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwbGl0IHRoaXMgSW50ZXJ2YWwgYXQgZWFjaCBvZiB0aGUgc3BlY2lmaWVkIERhdGVUaW1lc1xuICAgKiBAcGFyYW0gey4uLltEYXRlVGltZV19IGRhdGVUaW1lcyAtIHRoZSB1bml0IG9mIHRpbWUgdG8gY291bnQuXG4gICAqIEByZXR1cm4ge1tJbnRlcnZhbF19XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnNwbGl0QXQgPSBmdW5jdGlvbiBzcGxpdEF0KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIFtdO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGRhdGVUaW1lcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGRhdGVUaW1lc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgc29ydGVkID0gZGF0ZVRpbWVzLm1hcChmcmllbmRseURhdGVUaW1lKS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBfdGhpcy5jb250YWlucyhkKTtcbiAgICB9KS5zb3J0KCksXG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgcyA9IHRoaXMucyxcbiAgICAgICAgaSA9IDA7XG5cbiAgICB3aGlsZSAocyA8IHRoaXMuZSkge1xuICAgICAgdmFyIGFkZGVkID0gc29ydGVkW2ldIHx8IHRoaXMuZSxcbiAgICAgICAgICBuZXh0ID0gK2FkZGVkID4gK3RoaXMuZSA/IHRoaXMuZSA6IGFkZGVkO1xuICAgICAgcmVzdWx0cy5wdXNoKEludGVydmFsLmZyb21EYXRlVGltZXMocywgbmV4dCkpO1xuICAgICAgcyA9IG5leHQ7XG4gICAgICBpICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgLyoqXG4gICAqIFNwbGl0IHRoaXMgSW50ZXJ2YWwgaW50byBzbWFsbGVyIEludGVydmFscywgZWFjaCBvZiB0aGUgc3BlY2lmaWVkIGxlbmd0aC5cbiAgICogTGVmdCBvdmVyIHRpbWUgaXMgZ3JvdXBlZCBpbnRvIGEgc21hbGxlciBpbnRlcnZhbFxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGxlbmd0aCBvZiBlYWNoIHJlc3VsdGluZyBpbnRlcnZhbC5cbiAgICogQHJldHVybiB7W0ludGVydmFsXX1cbiAgICovXG4gIDtcblxuICBfcHJvdG8uc3BsaXRCeSA9IGZ1bmN0aW9uIHNwbGl0QnkoZHVyYXRpb24pIHtcbiAgICB2YXIgZHVyID0gZnJpZW5kbHlEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZCB8fCAhZHVyLmlzVmFsaWQgfHwgZHVyLmFzKFwibWlsbGlzZWNvbmRzXCIpID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIHMgPSB0aGlzLnMsXG4gICAgICAgIGFkZGVkLFxuICAgICAgICBuZXh0O1xuICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICB3aGlsZSAocyA8IHRoaXMuZSkge1xuICAgICAgYWRkZWQgPSBzLnBsdXMoZHVyKTtcbiAgICAgIG5leHQgPSArYWRkZWQgPiArdGhpcy5lID8gdGhpcy5lIDogYWRkZWQ7XG4gICAgICByZXN1bHRzLnB1c2goSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzLCBuZXh0KSk7XG4gICAgICBzID0gbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICAvKipcbiAgICogU3BsaXQgdGhpcyBJbnRlcnZhbCBpbnRvIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHNtYWxsZXIgaW50ZXJ2YWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyT2ZQYXJ0cyAtIFRoZSBudW1iZXIgb2YgSW50ZXJ2YWxzIHRvIGRpdmlkZSB0aGUgSW50ZXJ2YWwgaW50by5cbiAgICogQHJldHVybiB7W0ludGVydmFsXX1cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGl2aWRlRXF1YWxseSA9IGZ1bmN0aW9uIGRpdmlkZUVxdWFsbHkobnVtYmVyT2ZQYXJ0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gW107XG4gICAgcmV0dXJuIHRoaXMuc3BsaXRCeSh0aGlzLmxlbmd0aCgpIC8gbnVtYmVyT2ZQYXJ0cykuc2xpY2UoMCwgbnVtYmVyT2ZQYXJ0cyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgb3ZlcmxhcHMgd2l0aCB0aGUgc3BlY2lmaWVkIEludGVydmFsXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm92ZXJsYXBzID0gZnVuY3Rpb24gb3ZlcmxhcHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5lID4gb3RoZXIucyAmJiB0aGlzLnMgPCBvdGhlci5lO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsJ3MgZW5kIGlzIGFkamFjZW50IHRvIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwncyBzdGFydC5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYWJ1dHNTdGFydCA9IGZ1bmN0aW9uIGFidXRzU3RhcnQob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiArdGhpcy5lID09PSArb3RoZXIucztcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIHN0YXJ0IGlzIGFkamFjZW50IHRvIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwncyBlbmQuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmFidXRzRW5kID0gZnVuY3Rpb24gYWJ1dHNFbmQob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiArb3RoZXIuZSA9PT0gK3RoaXMucztcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCBlbmd1bGZzIHRoZSBzdGFydCBhbmQgZW5kIG9mIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmVuZ3VsZnMgPSBmdW5jdGlvbiBlbmd1bGZzKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5zIDw9IG90aGVyLnMgJiYgdGhpcy5lID49IG90aGVyLmU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgaGFzIHRoZSBzYW1lIHN0YXJ0IGFuZCBlbmQgYXMgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgIW90aGVyLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zLmVxdWFscyhvdGhlci5zKSAmJiB0aGlzLmUuZXF1YWxzKG90aGVyLmUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gSW50ZXJ2YWwgcmVwcmVzZW50aW5nIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhpcyBJbnRlcnZhbCBhbmQgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogU3BlY2lmaWNhbGx5LCB0aGUgcmVzdWx0aW5nIEludGVydmFsIGhhcyB0aGUgbWF4aW11bSBzdGFydCB0aW1lIGFuZCB0aGUgbWluaW11bSBlbmQgdGltZSBvZiB0aGUgdHdvIEludGVydmFscy5cbiAgICogUmV0dXJucyBudWxsIGlmIHRoZSBpbnRlcnNlY3Rpb24gaXMgZW1wdHksIG1lYW5pbmcsIHRoZSBpbnRlcnZhbHMgZG9uJ3QgaW50ZXJzZWN0LlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaW50ZXJzZWN0aW9uKG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIHZhciBzID0gdGhpcy5zID4gb3RoZXIucyA/IHRoaXMucyA6IG90aGVyLnMsXG4gICAgICAgIGUgPSB0aGlzLmUgPCBvdGhlci5lID8gdGhpcy5lIDogb3RoZXIuZTtcblxuICAgIGlmIChzID4gZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIGUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFuIEludGVydmFsIHJlcHJlc2VudGluZyB0aGUgdW5pb24gb2YgdGhpcyBJbnRlcnZhbCBhbmQgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogU3BlY2lmaWNhbGx5LCB0aGUgcmVzdWx0aW5nIEludGVydmFsIGhhcyB0aGUgbWluaW11bSBzdGFydCB0aW1lIGFuZCB0aGUgbWF4aW11bSBlbmQgdGltZSBvZiB0aGUgdHdvIEludGVydmFscy5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVuaW9uID0gZnVuY3Rpb24gdW5pb24ob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgdmFyIHMgPSB0aGlzLnMgPCBvdGhlci5zID8gdGhpcy5zIDogb3RoZXIucyxcbiAgICAgICAgZSA9IHRoaXMuZSA+IG90aGVyLmUgPyB0aGlzLmUgOiBvdGhlci5lO1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIGUpO1xuICB9XG4gIC8qKlxuICAgKiBNZXJnZSBhbiBhcnJheSBvZiBJbnRlcnZhbHMgaW50byBhIGVxdWl2YWxlbnQgbWluaW1hbCBzZXQgb2YgSW50ZXJ2YWxzLlxuICAgKiBDb21iaW5lcyBvdmVybGFwcGluZyBhbmQgYWRqYWNlbnQgSW50ZXJ2YWxzLlxuICAgKiBAcGFyYW0ge1tJbnRlcnZhbF19IGludGVydmFsc1xuICAgKiBAcmV0dXJuIHtbSW50ZXJ2YWxdfVxuICAgKi9cbiAgO1xuXG4gIEludGVydmFsLm1lcmdlID0gZnVuY3Rpb24gbWVyZ2UoaW50ZXJ2YWxzKSB7XG4gICAgdmFyIF9pbnRlcnZhbHMkc29ydCRyZWR1YyA9IGludGVydmFscy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5zIC0gYi5zO1xuICAgIH0pLnJlZHVjZShmdW5jdGlvbiAoX3JlZjIsIGl0ZW0pIHtcbiAgICAgIHZhciBzb2ZhciA9IF9yZWYyWzBdLFxuICAgICAgICAgIGN1cnJlbnQgPSBfcmVmMlsxXTtcblxuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHJldHVybiBbc29mYXIsIGl0ZW1dO1xuICAgICAgfSBlbHNlIGlmIChjdXJyZW50Lm92ZXJsYXBzKGl0ZW0pIHx8IGN1cnJlbnQuYWJ1dHNTdGFydChpdGVtKSkge1xuICAgICAgICByZXR1cm4gW3NvZmFyLCBjdXJyZW50LnVuaW9uKGl0ZW0pXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbc29mYXIuY29uY2F0KFtjdXJyZW50XSksIGl0ZW1dO1xuICAgICAgfVxuICAgIH0sIFtbXSwgbnVsbF0pLFxuICAgICAgICBmb3VuZCA9IF9pbnRlcnZhbHMkc29ydCRyZWR1Y1swXSxcbiAgICAgICAgZmluYWwgPSBfaW50ZXJ2YWxzJHNvcnQkcmVkdWNbMV07XG5cbiAgICBpZiAoZmluYWwpIHtcbiAgICAgIGZvdW5kLnB1c2goZmluYWwpO1xuICAgIH1cblxuICAgIHJldHVybiBmb3VuZDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIEludGVydmFscyByZXByZXNlbnRpbmcgdGhlIHNwYW5zIG9mIHRpbWUgdGhhdCBvbmx5IGFwcGVhciBpbiBvbmUgb2YgdGhlIHNwZWNpZmllZCBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7W0ludGVydmFsXX0gaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge1tJbnRlcnZhbF19XG4gICAqL1xuICA7XG5cbiAgSW50ZXJ2YWwueG9yID0gZnVuY3Rpb24geG9yKGludGVydmFscykge1xuICAgIHZhciBfQXJyYXkkcHJvdG90eXBlO1xuXG4gICAgdmFyIHN0YXJ0ID0gbnVsbCxcbiAgICAgICAgY3VycmVudENvdW50ID0gMDtcblxuICAgIHZhciByZXN1bHRzID0gW10sXG4gICAgICAgIGVuZHMgPSBpbnRlcnZhbHMubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgdGltZTogaS5zLFxuICAgICAgICB0eXBlOiBcInNcIlxuICAgICAgfSwge1xuICAgICAgICB0aW1lOiBpLmUsXG4gICAgICAgIHR5cGU6IFwiZVwiXG4gICAgICB9XTtcbiAgICB9KSxcbiAgICAgICAgZmxhdHRlbmVkID0gKF9BcnJheSRwcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGUpLmNvbmNhdC5hcHBseShfQXJyYXkkcHJvdG90eXBlLCBlbmRzKSxcbiAgICAgICAgYXJyID0gZmxhdHRlbmVkLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLnRpbWUgLSBiLnRpbWU7XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGFyciksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgaSA9IF9zdGVwLnZhbHVlO1xuICAgICAgY3VycmVudENvdW50ICs9IGkudHlwZSA9PT0gXCJzXCIgPyAxIDogLTE7XG5cbiAgICAgIGlmIChjdXJyZW50Q291bnQgPT09IDEpIHtcbiAgICAgICAgc3RhcnQgPSBpLnRpbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3RhcnQgJiYgK3N0YXJ0ICE9PSAraS50aW1lKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKEludGVydmFsLmZyb21EYXRlVGltZXMoc3RhcnQsIGkudGltZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBJbnRlcnZhbC5tZXJnZShyZXN1bHRzKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFuIEludGVydmFsIHJlcHJlc2VudGluZyB0aGUgc3BhbiBvZiB0aW1lIGluIHRoaXMgSW50ZXJ2YWwgdGhhdCBkb2Vzbid0IG92ZXJsYXAgd2l0aCBhbnkgb2YgdGhlIHNwZWNpZmllZCBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7Li4uSW50ZXJ2YWx9IGludGVydmFsc1xuICAgKiBAcmV0dXJuIHtbSW50ZXJ2YWxdfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kaWZmZXJlbmNlID0gZnVuY3Rpb24gZGlmZmVyZW5jZSgpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgaW50ZXJ2YWxzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBpbnRlcnZhbHNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICByZXR1cm4gSW50ZXJ2YWwueG9yKFt0aGlzXS5jb25jYXQoaW50ZXJ2YWxzKSkubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gX3RoaXMyLmludGVyc2VjdGlvbihpKTtcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBpICYmICFpLmlzRW1wdHkoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEludGVydmFsIGFwcHJvcHJpYXRlIGZvciBkZWJ1Z2dpbmcuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQkMTtcbiAgICByZXR1cm4gXCJbXCIgKyB0aGlzLnMudG9JU08oKSArIFwiIFxcdTIwMTMgXCIgKyB0aGlzLmUudG9JU08oKSArIFwiKVwiO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBJbnRlcnZhbC5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lX2ludGVydmFsc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBzYW1lIG9wdGlvbnMgYXMge0BsaW5rIERhdGVUaW1lLnRvSVNPfVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvSVNPID0gZnVuY3Rpb24gdG9JU08ob3B0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRCQxO1xuICAgIHJldHVybiB0aGlzLnMudG9JU08ob3B0cykgKyBcIi9cIiArIHRoaXMuZS50b0lTTyhvcHRzKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGRhdGUgb2YgdGhpcyBJbnRlcnZhbC5cbiAgICogVGhlIHRpbWUgY29tcG9uZW50cyBhcmUgaWdub3JlZC5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lX2ludGVydmFsc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvSVNPRGF0ZSA9IGZ1bmN0aW9uIHRvSVNPRGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQkMTtcbiAgICByZXR1cm4gdGhpcy5zLnRvSVNPRGF0ZSgpICsgXCIvXCIgKyB0aGlzLmUudG9JU09EYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aW1lIG9mIHRoaXMgSW50ZXJ2YWwuXG4gICAqIFRoZSBkYXRlIGNvbXBvbmVudHMgYXJlIGlnbm9yZWQuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZV9pbnRlcnZhbHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgc2FtZSBvcHRpb25zIGFzIHtAbGluayBEYXRlVGltZS50b0lTT31cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b0lTT1RpbWUgPSBmdW5jdGlvbiB0b0lTT1RpbWUob3B0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gSU5WQUxJRCQxO1xuICAgIHJldHVybiB0aGlzLnMudG9JU09UaW1lKG9wdHMpICsgXCIvXCIgKyB0aGlzLmUudG9JU09UaW1lKG9wdHMpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgSW50ZXJ2YWwgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGZvcm1hdCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlRm9ybWF0IC0gdGhlIGZvcm1hdCBzdHJpbmcuIFRoaXMgc3RyaW5nIGZvcm1hdHMgdGhlIHN0YXJ0IGFuZCBlbmQgdGltZS4gU2VlIHtAbGluayBEYXRlVGltZS50b0Zvcm1hdH0gZm9yIGRldGFpbHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuc2VwYXJhdG9yID0gICcg4oCTICddIC0gYSBzZXBhcmF0b3IgdG8gcGxhY2UgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCByZXByZXNlbnRhdGlvbnNcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b0Zvcm1hdCA9IGZ1bmN0aW9uIHRvRm9ybWF0KGRhdGVGb3JtYXQsIF90ZW1wMikge1xuICAgIHZhciBfcmVmMyA9IF90ZW1wMiA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDIsXG4gICAgICAgIF9yZWYzJHNlcGFyYXRvciA9IF9yZWYzLnNlcGFyYXRvcixcbiAgICAgICAgc2VwYXJhdG9yID0gX3JlZjMkc2VwYXJhdG9yID09PSB2b2lkIDAgPyBcIiDigJMgXCIgOiBfcmVmMyRzZXBhcmF0b3I7XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQkMTtcbiAgICByZXR1cm4gXCJcIiArIHRoaXMucy50b0Zvcm1hdChkYXRlRm9ybWF0KSArIHNlcGFyYXRvciArIHRoaXMuZS50b0Zvcm1hdChkYXRlRm9ybWF0KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGEgRHVyYXRpb24gcmVwcmVzZW50aW5nIHRoZSB0aW1lIHNwYW5uZWQgYnkgdGhpcyBpbnRlcnZhbC5cbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFt1bml0PVsnbWlsbGlzZWNvbmRzJ11dIC0gdGhlIHVuaXQgb3IgdW5pdHMgKHN1Y2ggYXMgJ2hvdXJzJyBvciAnZGF5cycpIHRvIGluY2x1ZGUgaW4gdGhlIGR1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIGNyZWF0aW9uIG9mIHRoZSBEdXJhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbigpLnRvT2JqZWN0KCkgLy89PiB7IG1pbGxpc2Vjb25kczogODg0ODkyNTcgfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKCdkYXlzJykudG9PYmplY3QoKSAvLz0+IHsgZGF5czogMS4wMjQxODEyMTUyNzc3Nzc4IH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbihbJ2hvdXJzJywgJ21pbnV0ZXMnXSkudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDI0LCBtaW51dGVzOiAzNC44MjA5NSB9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oWydob3VycycsICdtaW51dGVzJywgJ3NlY29uZHMnXSkudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDI0LCBtaW51dGVzOiAzNCwgc2Vjb25kczogNDkuMjU3IH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbignc2Vjb25kcycpLnRvT2JqZWN0KCkgLy89PiB7IHNlY29uZHM6IDg4NDg5LjI1NyB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b0R1cmF0aW9uID0gZnVuY3Rpb24gdG9EdXJhdGlvbih1bml0LCBvcHRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5pbnZhbGlkKHRoaXMuaW52YWxpZFJlYXNvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZS5kaWZmKHRoaXMucywgdW5pdCwgb3B0cyk7XG4gIH1cbiAgLyoqXG4gICAqIFJ1biBtYXBGbiBvbiB0aGUgaW50ZXJ2YWwgc3RhcnQgYW5kIGVuZCwgcmV0dXJuaW5nIGEgbmV3IEludGVydmFsIGZyb20gdGhlIHJlc3VsdGluZyBEYXRlVGltZXNcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWFwRm5cbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLm1hcEVuZHBvaW50cyhlbmRwb2ludCA9PiBlbmRwb2ludC50b1VUQygpKVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS5tYXBFbmRwb2ludHMoZW5kcG9pbnQgPT4gZW5kcG9pbnQucGx1cyh7IGhvdXJzOiAyIH0pKVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5tYXBFbmRwb2ludHMgPSBmdW5jdGlvbiBtYXBFbmRwb2ludHMobWFwRm4pIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhtYXBGbih0aGlzLnMpLCBtYXBGbih0aGlzLmUpKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoSW50ZXJ2YWwsIFt7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5zIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZW5kIG9mIHRoZSBJbnRlcnZhbFxuICAgICAqIEB0eXBlIHtEYXRlVGltZX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVuZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuZSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIEludGVydmFsJ3MgZW5kIGlzIGF0IGxlYXN0IGl0cyBzdGFydCwgbWVhbmluZyB0aGF0IHRoZSBJbnRlcnZhbCBpc24ndCAnYmFja3dhcmRzJy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzVmFsaWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmludmFsaWRSZWFzb24gPT09IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gZXJyb3IgY29kZSBpZiB0aGlzIEludGVydmFsIGlzIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIEludGVydmFsIGlzIHZhbGlkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImludmFsaWRSZWFzb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQucmVhc29uIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyBJbnRlcnZhbCBiZWNhbWUgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgSW50ZXJ2YWwgaXMgdmFsaWRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW52YWxpZEV4cGxhbmF0aW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLmV4cGxhbmF0aW9uIDogbnVsbDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW50ZXJ2YWw7XG59KCk7XG5cbi8qKlxuICogVGhlIEluZm8gY2xhc3MgY29udGFpbnMgc3RhdGljIG1ldGhvZHMgZm9yIHJldHJpZXZpbmcgZ2VuZXJhbCB0aW1lIGFuZCBkYXRlIHJlbGF0ZWQgZGF0YS4gRm9yIGV4YW1wbGUsIGl0IGhhcyBtZXRob2RzIGZvciBmaW5kaW5nIG91dCBpZiBhIHRpbWUgem9uZSBoYXMgYSBEU1QsIGZvciBsaXN0aW5nIHRoZSBtb250aHMgaW4gYW55IHN1cHBvcnRlZCBsb2NhbGUsIGFuZCBmb3IgZGlzY292ZXJpbmcgd2hpY2ggb2YgTHV4b24gZmVhdHVyZXMgYXJlIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cbiAqL1xuXG52YXIgSW5mbyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEluZm8oKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgc3BlY2lmaWVkIHpvbmUgY29udGFpbnMgYSBEU1QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFt6b25lPSdsb2NhbCddIC0gWm9uZSB0byBjaGVjay4gRGVmYXVsdHMgdG8gdGhlIGVudmlyb25tZW50J3MgbG9jYWwgem9uZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIEluZm8uaGFzRFNUID0gZnVuY3Rpb24gaGFzRFNUKHpvbmUpIHtcbiAgICBpZiAoem9uZSA9PT0gdm9pZCAwKSB7XG4gICAgICB6b25lID0gU2V0dGluZ3MuZGVmYXVsdFpvbmU7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvID0gRGF0ZVRpbWUubm93KCkuc2V0Wm9uZSh6b25lKS5zZXQoe1xuICAgICAgbW9udGg6IDEyXG4gICAgfSk7XG4gICAgcmV0dXJuICF6b25lLnVuaXZlcnNhbCAmJiBwcm90by5vZmZzZXQgIT09IHByb3RvLnNldCh7XG4gICAgICBtb250aDogNlxuICAgIH0pLm9mZnNldDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhlIHNwZWNpZmllZCB6b25lIGlzIGEgdmFsaWQgSUFOQSBzcGVjaWZpZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB6b25lIC0gWm9uZSB0byBjaGVja1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgO1xuXG4gIEluZm8uaXNWYWxpZElBTkFab25lID0gZnVuY3Rpb24gaXNWYWxpZElBTkFab25lKHpvbmUpIHtcbiAgICByZXR1cm4gSUFOQVpvbmUuaXNWYWxpZFNwZWNpZmllcih6b25lKSAmJiBJQU5BWm9uZS5pc1ZhbGlkWm9uZSh6b25lKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIGlucHV0IGludG8gYSB7QGxpbmsgWm9uZX0gaW5zdGFuY2UuXG4gICAqXG4gICAqICogSWYgYGlucHV0YCBpcyBhbHJlYWR5IGEgWm9uZSBpbnN0YW5jZSwgaXQgaXMgcmV0dXJuZWQgdW5jaGFuZ2VkLlxuICAgKiAqIElmIGBpbnB1dGAgaXMgYSBzdHJpbmcgY29udGFpbmluZyBhIHZhbGlkIHRpbWUgem9uZSBuYW1lLCBhIFpvbmUgaW5zdGFuY2VcbiAgICogICB3aXRoIHRoYXQgbmFtZSBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXRgIGlzIGEgc3RyaW5nIHRoYXQgZG9lc24ndCByZWZlciB0byBhIGtub3duIHRpbWUgem9uZSwgYSBab25lXG4gICAqICAgaW5zdGFuY2Ugd2l0aCB7QGxpbmsgWm9uZS5pc1ZhbGlkfSA9PSBmYWxzZSBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXQgaXMgYSBudW1iZXIsIGEgWm9uZSBpbnN0YW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgZml4ZWQgb2Zmc2V0XG4gICAqICAgaW4gbWludXRlcyBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXRgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYCwgdGhlIGRlZmF1bHQgem9uZSBpcyByZXR1cm5lZC5cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZXxudW1iZXJ9IFtpbnB1dF0gLSB0aGUgdmFsdWUgdG8gYmUgY29udmVydGVkXG4gICAqIEByZXR1cm4ge1pvbmV9XG4gICAqL1xuICA7XG5cbiAgSW5mby5ub3JtYWxpemVab25lID0gZnVuY3Rpb24gbm9ybWFsaXplWm9uZSQxKGlucHV0KSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVpvbmUoaW5wdXQsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIHN0YW5kYWxvbmUgbW9udGggbmFtZXMuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIG1vbnRoIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibnVtZXJpY1wiLCBcIjItZGlnaXRcIiwgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbT1udWxsXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5vdXRwdXRDYWxlbmRhcj0nZ3JlZ29yeSddIC0gdGhlIGNhbGVuZGFyXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKClbMF0gLy89PiAnSmFudWFyeSdcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ3Nob3J0JylbMF0gLy89PiAnSmFuJ1xuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygnbnVtZXJpYycpWzBdIC8vPT4gJzEnXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdzaG9ydCcsIHsgbG9jYWxlOiAnZnItQ0EnIH0gKVswXSAvLz0+ICdqYW52LidcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ251bWVyaWMnLCB7IGxvY2FsZTogJ2FyJyB9KVswXSAvLz0+ICfZoSdcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ2xvbmcnLCB7IG91dHB1dENhbGVuZGFyOiAnaXNsYW1pYycgfSlbMF0gLy89PiAnUmFiacq7IEknXG4gICAqIEByZXR1cm4ge1tzdHJpbmddfVxuICAgKi9cbiAgO1xuXG4gIEluZm8ubW9udGhzID0gZnVuY3Rpb24gbW9udGhzKGxlbmd0aCwgX3RlbXApIHtcbiAgICBpZiAobGVuZ3RoID09PSB2b2lkIDApIHtcbiAgICAgIGxlbmd0aCA9IFwibG9uZ1wiO1xuICAgIH1cblxuICAgIHZhciBfcmVmID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICAgIF9yZWYkbG9jYWxlID0gX3JlZi5sb2NhbGUsXG4gICAgICAgIGxvY2FsZSA9IF9yZWYkbG9jYWxlID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRsb2NhbGUsXG4gICAgICAgIF9yZWYkbnVtYmVyaW5nU3lzdGVtID0gX3JlZi5udW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSA9IF9yZWYkbnVtYmVyaW5nU3lzdGVtID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRudW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIF9yZWYkb3V0cHV0Q2FsZW5kYXIgPSBfcmVmLm91dHB1dENhbGVuZGFyLFxuICAgICAgICBvdXRwdXRDYWxlbmRhciA9IF9yZWYkb3V0cHV0Q2FsZW5kYXIgPT09IHZvaWQgMCA/IFwiZ3JlZ29yeVwiIDogX3JlZiRvdXRwdXRDYWxlbmRhcjtcblxuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcikubW9udGhzKGxlbmd0aCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBmb3JtYXQgbW9udGggbmFtZXMuXG4gICAqIEZvcm1hdCBtb250aHMgZGlmZmVyIGZyb20gc3RhbmRhbG9uZSBtb250aHMgaW4gdGhhdCB0aGV5J3JlIG1lYW50IHRvIGFwcGVhciBuZXh0IHRvIHRoZSBkYXkgb2YgdGhlIG1vbnRoLiBJbiBzb21lIGxhbmd1YWdlcywgdGhhdFxuICAgKiBjaGFuZ2VzIHRoZSBzdHJpbmcuXG4gICAqIFNlZSB7QGxpbmsgbW9udGhzfVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xlbmd0aD0nbG9uZyddIC0gdGhlIGxlbmd0aCBvZiB0aGUgbW9udGggcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJudW1lcmljXCIsIFwiMi1kaWdpdFwiLCBcIm5hcnJvd1wiLCBcInNob3J0XCIsIFwibG9uZ1wiXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtPW51bGxdIC0gdGhlIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm91dHB1dENhbGVuZGFyPSdncmVnb3J5J10gLSB0aGUgY2FsZW5kYXJcbiAgICogQHJldHVybiB7W3N0cmluZ119XG4gICAqL1xuICA7XG5cbiAgSW5mby5tb250aHNGb3JtYXQgPSBmdW5jdGlvbiBtb250aHNGb3JtYXQobGVuZ3RoLCBfdGVtcDIpIHtcbiAgICBpZiAobGVuZ3RoID09PSB2b2lkIDApIHtcbiAgICAgIGxlbmd0aCA9IFwibG9uZ1wiO1xuICAgIH1cblxuICAgIHZhciBfcmVmMiA9IF90ZW1wMiA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDIsXG4gICAgICAgIF9yZWYyJGxvY2FsZSA9IF9yZWYyLmxvY2FsZSxcbiAgICAgICAgbG9jYWxlID0gX3JlZjIkbG9jYWxlID09PSB2b2lkIDAgPyBudWxsIDogX3JlZjIkbG9jYWxlLFxuICAgICAgICBfcmVmMiRudW1iZXJpbmdTeXN0ZW0gPSBfcmVmMi5udW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSA9IF9yZWYyJG51bWJlcmluZ1N5c3RlbSA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYyJG51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgX3JlZjIkb3V0cHV0Q2FsZW5kYXIgPSBfcmVmMi5vdXRwdXRDYWxlbmRhcixcbiAgICAgICAgb3V0cHV0Q2FsZW5kYXIgPSBfcmVmMiRvdXRwdXRDYWxlbmRhciA9PT0gdm9pZCAwID8gXCJncmVnb3J5XCIgOiBfcmVmMiRvdXRwdXRDYWxlbmRhcjtcblxuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcikubW9udGhzKGxlbmd0aCwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBzdGFuZGFsb25lIHdlZWsgbmFtZXMuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIHdlZWtkYXkgcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW09bnVsbF0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAZXhhbXBsZSBJbmZvLndlZWtkYXlzKClbMF0gLy89PiAnTW9uZGF5J1xuICAgKiBAZXhhbXBsZSBJbmZvLndlZWtkYXlzKCdzaG9ydCcpWzBdIC8vPT4gJ01vbidcbiAgICogQGV4YW1wbGUgSW5mby53ZWVrZGF5cygnc2hvcnQnLCB7IGxvY2FsZTogJ2ZyLUNBJyB9KVswXSAvLz0+ICdsdW4uJ1xuICAgKiBAZXhhbXBsZSBJbmZvLndlZWtkYXlzKCdzaG9ydCcsIHsgbG9jYWxlOiAnYXInIH0pWzBdIC8vPT4gJ9in2YTYp9ir2YbZitmGJ1xuICAgKiBAcmV0dXJuIHtbc3RyaW5nXX1cbiAgICovXG4gIDtcblxuICBJbmZvLndlZWtkYXlzID0gZnVuY3Rpb24gd2Vla2RheXMobGVuZ3RoLCBfdGVtcDMpIHtcbiAgICBpZiAobGVuZ3RoID09PSB2b2lkIDApIHtcbiAgICAgIGxlbmd0aCA9IFwibG9uZ1wiO1xuICAgIH1cblxuICAgIHZhciBfcmVmMyA9IF90ZW1wMyA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDMsXG4gICAgICAgIF9yZWYzJGxvY2FsZSA9IF9yZWYzLmxvY2FsZSxcbiAgICAgICAgbG9jYWxlID0gX3JlZjMkbG9jYWxlID09PSB2b2lkIDAgPyBudWxsIDogX3JlZjMkbG9jYWxlLFxuICAgICAgICBfcmVmMyRudW1iZXJpbmdTeXN0ZW0gPSBfcmVmMy5udW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSA9IF9yZWYzJG51bWJlcmluZ1N5c3RlbSA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYzJG51bWJlcmluZ1N5c3RlbTtcblxuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBudWxsKS53ZWVrZGF5cyhsZW5ndGgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgZm9ybWF0IHdlZWsgbmFtZXMuXG4gICAqIEZvcm1hdCB3ZWVrZGF5cyBkaWZmZXIgZnJvbSBzdGFuZGFsb25lIHdlZWtkYXlzIGluIHRoYXQgdGhleSdyZSBtZWFudCB0byBhcHBlYXIgbmV4dCB0byBtb3JlIGRhdGUgaW5mb3JtYXRpb24uIEluIHNvbWUgbGFuZ3VhZ2VzLCB0aGF0XG4gICAqIGNoYW5nZXMgdGhlIHN0cmluZy5cbiAgICogU2VlIHtAbGluayB3ZWVrZGF5c31cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIHdlZWtkYXkgcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9bnVsbF0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbT1udWxsXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEByZXR1cm4ge1tzdHJpbmddfVxuICAgKi9cbiAgO1xuXG4gIEluZm8ud2Vla2RheXNGb3JtYXQgPSBmdW5jdGlvbiB3ZWVrZGF5c0Zvcm1hdChsZW5ndGgsIF90ZW1wNCkge1xuICAgIGlmIChsZW5ndGggPT09IHZvaWQgMCkge1xuICAgICAgbGVuZ3RoID0gXCJsb25nXCI7XG4gICAgfVxuXG4gICAgdmFyIF9yZWY0ID0gX3RlbXA0ID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wNCxcbiAgICAgICAgX3JlZjQkbG9jYWxlID0gX3JlZjQubG9jYWxlLFxuICAgICAgICBsb2NhbGUgPSBfcmVmNCRsb2NhbGUgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmNCRsb2NhbGUsXG4gICAgICAgIF9yZWY0JG51bWJlcmluZ1N5c3RlbSA9IF9yZWY0Lm51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgbnVtYmVyaW5nU3lzdGVtID0gX3JlZjQkbnVtYmVyaW5nU3lzdGVtID09PSB2b2lkIDAgPyBudWxsIDogX3JlZjQkbnVtYmVyaW5nU3lzdGVtO1xuXG4gICAgcmV0dXJuIExvY2FsZS5jcmVhdGUobG9jYWxlLCBudW1iZXJpbmdTeXN0ZW0sIG51bGwpLndlZWtkYXlzKGxlbmd0aCwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBtZXJpZGllbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAZXhhbXBsZSBJbmZvLm1lcmlkaWVtcygpIC8vPT4gWyAnQU0nLCAnUE0nIF1cbiAgICogQGV4YW1wbGUgSW5mby5tZXJpZGllbXMoeyBsb2NhbGU6ICdteScgfSkgLy89PiBbICfhgJThgLbhgJThgIDhgLonLCAn4YCK4YCU4YCxJyBdXG4gICAqIEByZXR1cm4ge1tzdHJpbmddfVxuICAgKi9cbiAgO1xuXG4gIEluZm8ubWVyaWRpZW1zID0gZnVuY3Rpb24gbWVyaWRpZW1zKF90ZW1wNSkge1xuICAgIHZhciBfcmVmNSA9IF90ZW1wNSA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDUsXG4gICAgICAgIF9yZWY1JGxvY2FsZSA9IF9yZWY1LmxvY2FsZSxcbiAgICAgICAgbG9jYWxlID0gX3JlZjUkbG9jYWxlID09PSB2b2lkIDAgPyBudWxsIDogX3JlZjUkbG9jYWxlO1xuXG4gICAgcmV0dXJuIExvY2FsZS5jcmVhdGUobG9jYWxlKS5tZXJpZGllbXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIGVyYXMsIHN1Y2ggYXMgWydCQycsICdBRCddLiBUaGUgbG9jYWxlIGNhbiBiZSBzcGVjaWZpZWQsIGJ1dCB0aGUgY2FsZW5kYXIgc3lzdGVtIGlzIGFsd2F5cyBHcmVnb3JpYW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdzaG9ydCddIC0gdGhlIGxlbmd0aCBvZiB0aGUgZXJhIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwic2hvcnRcIiBvciBcImxvbmdcIi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBleGFtcGxlIEluZm8uZXJhcygpIC8vPT4gWyAnQkMnLCAnQUQnIF1cbiAgICogQGV4YW1wbGUgSW5mby5lcmFzKCdsb25nJykgLy89PiBbICdCZWZvcmUgQ2hyaXN0JywgJ0Fubm8gRG9taW5pJyBdXG4gICAqIEBleGFtcGxlIEluZm8uZXJhcygnbG9uZycsIHsgbG9jYWxlOiAnZnInIH0pIC8vPT4gWyAnYXZhbnQgSsOpc3VzLUNocmlzdCcsICdhcHLDqHMgSsOpc3VzLUNocmlzdCcgXVxuICAgKiBAcmV0dXJuIHtbc3RyaW5nXX1cbiAgICovXG4gIDtcblxuICBJbmZvLmVyYXMgPSBmdW5jdGlvbiBlcmFzKGxlbmd0aCwgX3RlbXA2KSB7XG4gICAgaWYgKGxlbmd0aCA9PT0gdm9pZCAwKSB7XG4gICAgICBsZW5ndGggPSBcInNob3J0XCI7XG4gICAgfVxuXG4gICAgdmFyIF9yZWY2ID0gX3RlbXA2ID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wNixcbiAgICAgICAgX3JlZjYkbG9jYWxlID0gX3JlZjYubG9jYWxlLFxuICAgICAgICBsb2NhbGUgPSBfcmVmNiRsb2NhbGUgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmNiRsb2NhbGU7XG5cbiAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bGwsIFwiZ3JlZ29yeVwiKS5lcmFzKGxlbmd0aCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc2V0IG9mIGF2YWlsYWJsZSBmZWF0dXJlcyBpbiB0aGlzIGVudmlyb25tZW50LlxuICAgKiBTb21lIGZlYXR1cmVzIG9mIEx1eG9uIGFyZSBub3QgYXZhaWxhYmxlIGluIGFsbCBlbnZpcm9ubWVudHMuIEZvciBleGFtcGxlLCBvbiBvbGRlciBicm93c2VycywgdGltZXpvbmUgc3VwcG9ydCBpcyBub3QgYXZhaWxhYmxlLiBVc2UgdGhpcyBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IGlmIHRoYXQncyB0aGUgY2FzZS5cbiAgICogS2V5czpcbiAgICogKiBgem9uZXNgOiB3aGV0aGVyIHRoaXMgZW52aXJvbm1lbnQgc3VwcG9ydHMgSUFOQSB0aW1lem9uZXNcbiAgICogKiBgaW50bFRva2Vuc2A6IHdoZXRoZXIgdGhpcyBlbnZpcm9ubWVudCBzdXBwb3J0cyBpbnRlcm5hdGlvbmFsaXplZCB0b2tlbi1iYXNlZCBmb3JtYXR0aW5nL3BhcnNpbmdcbiAgICogKiBgaW50bGA6IHdoZXRoZXIgdGhpcyBlbnZpcm9ubWVudCBzdXBwb3J0cyBnZW5lcmFsIGludGVybmF0aW9uYWxpemF0aW9uXG4gICAqICogYHJlbGF0aXZlYDogd2hldGhlciB0aGlzIGVudmlyb25tZW50IHN1cHBvcnRzIHJlbGF0aXZlIHRpbWUgZm9ybWF0dGluZ1xuICAgKiBAZXhhbXBsZSBJbmZvLmZlYXR1cmVzKCkgLy89PiB7IGludGw6IHRydWUsIGludGxUb2tlbnM6IGZhbHNlLCB6b25lczogdHJ1ZSwgcmVsYXRpdmU6IGZhbHNlIH1cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgO1xuXG4gIEluZm8uZmVhdHVyZXMgPSBmdW5jdGlvbiBmZWF0dXJlcygpIHtcbiAgICB2YXIgaW50bCA9IGZhbHNlLFxuICAgICAgICBpbnRsVG9rZW5zID0gZmFsc2UsXG4gICAgICAgIHpvbmVzID0gZmFsc2UsXG4gICAgICAgIHJlbGF0aXZlID0gZmFsc2U7XG5cbiAgICBpZiAoaGFzSW50bCgpKSB7XG4gICAgICBpbnRsID0gdHJ1ZTtcbiAgICAgIGludGxUb2tlbnMgPSBoYXNGb3JtYXRUb1BhcnRzKCk7XG4gICAgICByZWxhdGl2ZSA9IGhhc1JlbGF0aXZlKCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHpvbmVzID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoXCJlblwiLCB7XG4gICAgICAgICAgdGltZVpvbmU6IFwiQW1lcmljYS9OZXdfWW9ya1wiXG4gICAgICAgIH0pLnJlc29sdmVkT3B0aW9ucygpLnRpbWVab25lID09PSBcIkFtZXJpY2EvTmV3X1lvcmtcIjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgem9uZXMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaW50bDogaW50bCxcbiAgICAgIGludGxUb2tlbnM6IGludGxUb2tlbnMsXG4gICAgICB6b25lczogem9uZXMsXG4gICAgICByZWxhdGl2ZTogcmVsYXRpdmVcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBJbmZvO1xufSgpO1xuXG5mdW5jdGlvbiBkYXlEaWZmKGVhcmxpZXIsIGxhdGVyKSB7XG4gIHZhciB1dGNEYXlTdGFydCA9IGZ1bmN0aW9uIHV0Y0RheVN0YXJ0KGR0KSB7XG4gICAgcmV0dXJuIGR0LnRvVVRDKDAsIHtcbiAgICAgIGtlZXBMb2NhbFRpbWU6IHRydWVcbiAgICB9KS5zdGFydE9mKFwiZGF5XCIpLnZhbHVlT2YoKTtcbiAgfSxcbiAgICAgIG1zID0gdXRjRGF5U3RhcnQobGF0ZXIpIC0gdXRjRGF5U3RhcnQoZWFybGllcik7XG5cbiAgcmV0dXJuIE1hdGguZmxvb3IoRHVyYXRpb24uZnJvbU1pbGxpcyhtcykuYXMoXCJkYXlzXCIpKTtcbn1cblxuZnVuY3Rpb24gaGlnaE9yZGVyRGlmZnMoY3Vyc29yLCBsYXRlciwgdW5pdHMpIHtcbiAgdmFyIGRpZmZlcnMgPSBbW1wieWVhcnNcIiwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi55ZWFyIC0gYS55ZWFyO1xuICB9XSwgW1wicXVhcnRlcnNcIiwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5xdWFydGVyIC0gYS5xdWFydGVyO1xuICB9XSwgW1wibW9udGhzXCIsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIubW9udGggLSBhLm1vbnRoICsgKGIueWVhciAtIGEueWVhcikgKiAxMjtcbiAgfV0sIFtcIndlZWtzXCIsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGRheXMgPSBkYXlEaWZmKGEsIGIpO1xuICAgIHJldHVybiAoZGF5cyAtIGRheXMgJSA3KSAvIDc7XG4gIH1dLCBbXCJkYXlzXCIsIGRheURpZmZdXTtcbiAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgdmFyIGxvd2VzdE9yZGVyLCBoaWdoV2F0ZXI7XG5cbiAgZm9yICh2YXIgX2kgPSAwLCBfZGlmZmVycyA9IGRpZmZlcnM7IF9pIDwgX2RpZmZlcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIF9kaWZmZXJzJF9pID0gX2RpZmZlcnNbX2ldLFxuICAgICAgICB1bml0ID0gX2RpZmZlcnMkX2lbMF0sXG4gICAgICAgIGRpZmZlciA9IF9kaWZmZXJzJF9pWzFdO1xuXG4gICAgaWYgKHVuaXRzLmluZGV4T2YodW5pdCkgPj0gMCkge1xuICAgICAgdmFyIF9jdXJzb3IkcGx1cztcblxuICAgICAgbG93ZXN0T3JkZXIgPSB1bml0O1xuICAgICAgdmFyIGRlbHRhID0gZGlmZmVyKGN1cnNvciwgbGF0ZXIpO1xuICAgICAgaGlnaFdhdGVyID0gY3Vyc29yLnBsdXMoKF9jdXJzb3IkcGx1cyA9IHt9LCBfY3Vyc29yJHBsdXNbdW5pdF0gPSBkZWx0YSwgX2N1cnNvciRwbHVzKSk7XG5cbiAgICAgIGlmIChoaWdoV2F0ZXIgPiBsYXRlcikge1xuICAgICAgICB2YXIgX2N1cnNvciRwbHVzMjtcblxuICAgICAgICBjdXJzb3IgPSBjdXJzb3IucGx1cygoX2N1cnNvciRwbHVzMiA9IHt9LCBfY3Vyc29yJHBsdXMyW3VuaXRdID0gZGVsdGEgLSAxLCBfY3Vyc29yJHBsdXMyKSk7XG4gICAgICAgIGRlbHRhIC09IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJzb3IgPSBoaWdoV2F0ZXI7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdHNbdW5pdF0gPSBkZWx0YTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW2N1cnNvciwgcmVzdWx0cywgaGlnaFdhdGVyLCBsb3dlc3RPcmRlcl07XG59XG5cbmZ1bmN0aW9uIF9kaWZmIChlYXJsaWVyLCBsYXRlciwgdW5pdHMsIG9wdHMpIHtcbiAgdmFyIF9oaWdoT3JkZXJEaWZmcyA9IGhpZ2hPcmRlckRpZmZzKGVhcmxpZXIsIGxhdGVyLCB1bml0cyksXG4gICAgICBjdXJzb3IgPSBfaGlnaE9yZGVyRGlmZnNbMF0sXG4gICAgICByZXN1bHRzID0gX2hpZ2hPcmRlckRpZmZzWzFdLFxuICAgICAgaGlnaFdhdGVyID0gX2hpZ2hPcmRlckRpZmZzWzJdLFxuICAgICAgbG93ZXN0T3JkZXIgPSBfaGlnaE9yZGVyRGlmZnNbM107XG5cbiAgdmFyIHJlbWFpbmluZ01pbGxpcyA9IGxhdGVyIC0gY3Vyc29yO1xuICB2YXIgbG93ZXJPcmRlclVuaXRzID0gdW5pdHMuZmlsdGVyKGZ1bmN0aW9uICh1KSB7XG4gICAgcmV0dXJuIFtcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIiwgXCJtaWxsaXNlY29uZHNcIl0uaW5kZXhPZih1KSA+PSAwO1xuICB9KTtcblxuICBpZiAobG93ZXJPcmRlclVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChoaWdoV2F0ZXIgPCBsYXRlcikge1xuICAgICAgdmFyIF9jdXJzb3IkcGx1czM7XG5cbiAgICAgIGhpZ2hXYXRlciA9IGN1cnNvci5wbHVzKChfY3Vyc29yJHBsdXMzID0ge30sIF9jdXJzb3IkcGx1czNbbG93ZXN0T3JkZXJdID0gMSwgX2N1cnNvciRwbHVzMykpO1xuICAgIH1cblxuICAgIGlmIChoaWdoV2F0ZXIgIT09IGN1cnNvcikge1xuICAgICAgcmVzdWx0c1tsb3dlc3RPcmRlcl0gPSAocmVzdWx0c1tsb3dlc3RPcmRlcl0gfHwgMCkgKyByZW1haW5pbmdNaWxsaXMgLyAoaGlnaFdhdGVyIC0gY3Vyc29yKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZHVyYXRpb24gPSBEdXJhdGlvbi5mcm9tT2JqZWN0KE9iamVjdC5hc3NpZ24ocmVzdWx0cywgb3B0cykpO1xuXG4gIGlmIChsb3dlck9yZGVyVW5pdHMubGVuZ3RoID4gMCkge1xuICAgIHZhciBfRHVyYXRpb24kZnJvbU1pbGxpcztcblxuICAgIHJldHVybiAoX0R1cmF0aW9uJGZyb21NaWxsaXMgPSBEdXJhdGlvbi5mcm9tTWlsbGlzKHJlbWFpbmluZ01pbGxpcywgb3B0cykpLnNoaWZ0VG8uYXBwbHkoX0R1cmF0aW9uJGZyb21NaWxsaXMsIGxvd2VyT3JkZXJVbml0cykucGx1cyhkdXJhdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGR1cmF0aW9uO1xuICB9XG59XG5cbnZhciBudW1iZXJpbmdTeXN0ZW1zID0ge1xuICBhcmFiOiBcIltcXHUwNjYwLVxcdTA2NjldXCIsXG4gIGFyYWJleHQ6IFwiW1xcdTA2RjAtXFx1MDZGOV1cIixcbiAgYmFsaTogXCJbXFx1MUI1MC1cXHUxQjU5XVwiLFxuICBiZW5nOiBcIltcXHUwOUU2LVxcdTA5RUZdXCIsXG4gIGRldmE6IFwiW1xcdTA5NjYtXFx1MDk2Rl1cIixcbiAgZnVsbHdpZGU6IFwiW1xcdUZGMTAtXFx1RkYxOV1cIixcbiAgZ3VqcjogXCJbXFx1MEFFNi1cXHUwQUVGXVwiLFxuICBoYW5pZGVjOiBcIlvjgId85LiAfOS6jHzkuIl85ZubfOS6lHzlha185LiDfOWFq3zkuZ1dXCIsXG4gIGtobXI6IFwiW1xcdTE3RTAtXFx1MTdFOV1cIixcbiAga25kYTogXCJbXFx1MENFNi1cXHUwQ0VGXVwiLFxuICBsYW9vOiBcIltcXHUwRUQwLVxcdTBFRDldXCIsXG4gIGxpbWI6IFwiW1xcdTE5NDYtXFx1MTk0Rl1cIixcbiAgbWx5bTogXCJbXFx1MEQ2Ni1cXHUwRDZGXVwiLFxuICBtb25nOiBcIltcXHUxODEwLVxcdTE4MTldXCIsXG4gIG15bXI6IFwiW1xcdTEwNDAtXFx1MTA0OV1cIixcbiAgb3J5YTogXCJbXFx1MEI2Ni1cXHUwQjZGXVwiLFxuICB0YW1sZGVjOiBcIltcXHUwQkU2LVxcdTBCRUZdXCIsXG4gIHRlbHU6IFwiW1xcdTBDNjYtXFx1MEM2Rl1cIixcbiAgdGhhaTogXCJbXFx1MEU1MC1cXHUwRTU5XVwiLFxuICB0aWJ0OiBcIltcXHUwRjIwLVxcdTBGMjldXCIsXG4gIGxhdG46IFwiXFxcXGRcIlxufTtcbnZhciBudW1iZXJpbmdTeXN0ZW1zVVRGMTYgPSB7XG4gIGFyYWI6IFsxNjMyLCAxNjQxXSxcbiAgYXJhYmV4dDogWzE3NzYsIDE3ODVdLFxuICBiYWxpOiBbNjk5MiwgNzAwMV0sXG4gIGJlbmc6IFsyNTM0LCAyNTQzXSxcbiAgZGV2YTogWzI0MDYsIDI0MTVdLFxuICBmdWxsd2lkZTogWzY1Mjk2LCA2NTMwM10sXG4gIGd1anI6IFsyNzkwLCAyNzk5XSxcbiAga2htcjogWzYxMTIsIDYxMjFdLFxuICBrbmRhOiBbMzMwMiwgMzMxMV0sXG4gIGxhb286IFszNzkyLCAzODAxXSxcbiAgbGltYjogWzY0NzAsIDY0NzldLFxuICBtbHltOiBbMzQzMCwgMzQzOV0sXG4gIG1vbmc6IFs2MTYwLCA2MTY5XSxcbiAgbXltcjogWzQxNjAsIDQxNjldLFxuICBvcnlhOiBbMjkxOCwgMjkyN10sXG4gIHRhbWxkZWM6IFszMDQ2LCAzMDU1XSxcbiAgdGVsdTogWzMxNzQsIDMxODNdLFxuICB0aGFpOiBbMzY2NCwgMzY3M10sXG4gIHRpYnQ6IFszODcyLCAzODgxXVxufTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbnZhciBoYW5pZGVjQ2hhcnMgPSBudW1iZXJpbmdTeXN0ZW1zLmhhbmlkZWMucmVwbGFjZSgvW1xcW3xcXF1dL2csIFwiXCIpLnNwbGl0KFwiXCIpO1xuZnVuY3Rpb24gcGFyc2VEaWdpdHMoc3RyKSB7XG4gIHZhciB2YWx1ZSA9IHBhcnNlSW50KHN0ciwgMTApO1xuXG4gIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IFwiXCI7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgICAgaWYgKHN0cltpXS5zZWFyY2gobnVtYmVyaW5nU3lzdGVtcy5oYW5pZGVjKSAhPT0gLTEpIHtcbiAgICAgICAgdmFsdWUgKz0gaGFuaWRlY0NoYXJzLmluZGV4T2Yoc3RyW2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBudW1iZXJpbmdTeXN0ZW1zVVRGMTYpIHtcbiAgICAgICAgICB2YXIgX251bWJlcmluZ1N5c3RlbXNVVEYgPSBudW1iZXJpbmdTeXN0ZW1zVVRGMTZba2V5XSxcbiAgICAgICAgICAgICAgbWluID0gX251bWJlcmluZ1N5c3RlbXNVVEZbMF0sXG4gICAgICAgICAgICAgIG1heCA9IF9udW1iZXJpbmdTeXN0ZW1zVVRGWzFdO1xuXG4gICAgICAgICAgaWYgKGNvZGUgPj0gbWluICYmIGNvZGUgPD0gbWF4KSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBjb2RlIC0gbWluO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gZGlnaXRSZWdleChfcmVmLCBhcHBlbmQpIHtcbiAgdmFyIG51bWJlcmluZ1N5c3RlbSA9IF9yZWYubnVtYmVyaW5nU3lzdGVtO1xuXG4gIGlmIChhcHBlbmQgPT09IHZvaWQgMCkge1xuICAgIGFwcGVuZCA9IFwiXCI7XG4gIH1cblxuICByZXR1cm4gbmV3IFJlZ0V4cChcIlwiICsgbnVtYmVyaW5nU3lzdGVtc1tudW1iZXJpbmdTeXN0ZW0gfHwgXCJsYXRuXCJdICsgYXBwZW5kKTtcbn1cblxudmFyIE1JU1NJTkdfRlRQID0gXCJtaXNzaW5nIEludGwuRGF0ZVRpbWVGb3JtYXQuZm9ybWF0VG9QYXJ0cyBzdXBwb3J0XCI7XG5cbmZ1bmN0aW9uIGludFVuaXQocmVnZXgsIHBvc3QpIHtcbiAgaWYgKHBvc3QgPT09IHZvaWQgMCkge1xuICAgIHBvc3QgPSBmdW5jdGlvbiBwb3N0KGkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlZ2V4OiByZWdleCxcbiAgICBkZXNlcjogZnVuY3Rpb24gZGVzZXIoX3JlZikge1xuICAgICAgdmFyIHMgPSBfcmVmWzBdO1xuICAgICAgcmV0dXJuIHBvc3QocGFyc2VEaWdpdHMocykpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIE5CU1AgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDE2MCk7XG52YXIgc3BhY2VPck5CU1AgPSBcIiggfFwiICsgTkJTUCArIFwiKVwiO1xudmFyIHNwYWNlT3JOQlNQUmVnRXhwID0gbmV3IFJlZ0V4cChzcGFjZU9yTkJTUCwgXCJnXCIpO1xuXG5mdW5jdGlvbiBmaXhMaXN0UmVnZXgocykge1xuICAvLyBtYWtlIGRvdHMgb3B0aW9uYWwgYW5kIGFsc28gbWFrZSB0aGVtIGxpdGVyYWxcbiAgLy8gbWFrZSBzcGFjZSBhbmQgbm9uIGJyZWFrYWJsZSBzcGFjZSBjaGFyYWN0ZXJzIGludGVyY2hhbmdlYWJsZVxuICByZXR1cm4gcy5yZXBsYWNlKC9cXC4vZywgXCJcXFxcLj9cIikucmVwbGFjZShzcGFjZU9yTkJTUFJlZ0V4cCwgc3BhY2VPck5CU1ApO1xufVxuXG5mdW5jdGlvbiBzdHJpcEluc2Vuc2l0aXZpdGllcyhzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1xcLi9nLCBcIlwiKSAvLyBpZ25vcmUgZG90cyB0aGF0IHdlcmUgbWFkZSBvcHRpb25hbFxuICAucmVwbGFjZShzcGFjZU9yTkJTUFJlZ0V4cCwgXCIgXCIpIC8vIGludGVyY2hhbmdlIHNwYWNlIGFuZCBuYnNwXG4gIC50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBvbmVPZihzdHJpbmdzLCBzdGFydEluZGV4KSB7XG4gIGlmIChzdHJpbmdzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZ2V4OiBSZWdFeHAoc3RyaW5ncy5tYXAoZml4TGlzdFJlZ2V4KS5qb2luKFwifFwiKSksXG4gICAgICBkZXNlcjogZnVuY3Rpb24gZGVzZXIoX3JlZjIpIHtcbiAgICAgICAgdmFyIHMgPSBfcmVmMlswXTtcbiAgICAgICAgcmV0dXJuIHN0cmluZ3MuZmluZEluZGV4KGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmlwSW5zZW5zaXRpdml0aWVzKHMpID09PSBzdHJpcEluc2Vuc2l0aXZpdGllcyhpKTtcbiAgICAgICAgfSkgKyBzdGFydEluZGV4O1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gb2Zmc2V0KHJlZ2V4LCBncm91cHMpIHtcbiAgcmV0dXJuIHtcbiAgICByZWdleDogcmVnZXgsXG4gICAgZGVzZXI6IGZ1bmN0aW9uIGRlc2VyKF9yZWYzKSB7XG4gICAgICB2YXIgaCA9IF9yZWYzWzFdLFxuICAgICAgICAgIG0gPSBfcmVmM1syXTtcbiAgICAgIHJldHVybiBzaWduZWRPZmZzZXQoaCwgbSk7XG4gICAgfSxcbiAgICBncm91cHM6IGdyb3Vwc1xuICB9O1xufVxuXG5mdW5jdGlvbiBzaW1wbGUocmVnZXgpIHtcbiAgcmV0dXJuIHtcbiAgICByZWdleDogcmVnZXgsXG4gICAgZGVzZXI6IGZ1bmN0aW9uIGRlc2VyKF9yZWY0KSB7XG4gICAgICB2YXIgcyA9IF9yZWY0WzBdO1xuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBlc2NhcGVUb2tlbih2YWx1ZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1tcXC1cXFtcXF17fSgpKis/LixcXFxcXFxeJHwjXFxzXS9nLCBcIlxcXFwkJlwiKTtcbn1cblxuZnVuY3Rpb24gdW5pdEZvclRva2VuKHRva2VuLCBsb2MpIHtcbiAgdmFyIG9uZSA9IGRpZ2l0UmVnZXgobG9jKSxcbiAgICAgIHR3byA9IGRpZ2l0UmVnZXgobG9jLCBcInsyfVwiKSxcbiAgICAgIHRocmVlID0gZGlnaXRSZWdleChsb2MsIFwiezN9XCIpLFxuICAgICAgZm91ciA9IGRpZ2l0UmVnZXgobG9jLCBcIns0fVwiKSxcbiAgICAgIHNpeCA9IGRpZ2l0UmVnZXgobG9jLCBcIns2fVwiKSxcbiAgICAgIG9uZU9yVHdvID0gZGlnaXRSZWdleChsb2MsIFwiezEsMn1cIiksXG4gICAgICBvbmVUb1RocmVlID0gZGlnaXRSZWdleChsb2MsIFwiezEsM31cIiksXG4gICAgICBvbmVUb1NpeCA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDZ9XCIpLFxuICAgICAgb25lVG9OaW5lID0gZGlnaXRSZWdleChsb2MsIFwiezEsOX1cIiksXG4gICAgICB0d29Ub0ZvdXIgPSBkaWdpdFJlZ2V4KGxvYywgXCJ7Miw0fVwiKSxcbiAgICAgIGZvdXJUb1NpeCA9IGRpZ2l0UmVnZXgobG9jLCBcIns0LDZ9XCIpLFxuICAgICAgbGl0ZXJhbCA9IGZ1bmN0aW9uIGxpdGVyYWwodCkge1xuICAgIHJldHVybiB7XG4gICAgICByZWdleDogUmVnRXhwKGVzY2FwZVRva2VuKHQudmFsKSksXG4gICAgICBkZXNlcjogZnVuY3Rpb24gZGVzZXIoX3JlZjUpIHtcbiAgICAgICAgdmFyIHMgPSBfcmVmNVswXTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9LFxuICAgICAgbGl0ZXJhbDogdHJ1ZVxuICAgIH07XG4gIH0sXG4gICAgICB1bml0YXRlID0gZnVuY3Rpb24gdW5pdGF0ZSh0KSB7XG4gICAgaWYgKHRva2VuLmxpdGVyYWwpIHtcbiAgICAgIHJldHVybiBsaXRlcmFsKHQpO1xuICAgIH1cblxuICAgIHN3aXRjaCAodC52YWwpIHtcbiAgICAgIC8vIGVyYVxuICAgICAgY2FzZSBcIkdcIjpcbiAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5lcmFzKFwic2hvcnRcIiwgZmFsc2UpLCAwKTtcblxuICAgICAgY2FzZSBcIkdHXCI6XG4gICAgICAgIHJldHVybiBvbmVPZihsb2MuZXJhcyhcImxvbmdcIiwgZmFsc2UpLCAwKTtcbiAgICAgIC8vIHllYXJzXG5cbiAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KG9uZVRvU2l4KTtcblxuICAgICAgY2FzZSBcInl5XCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KHR3b1RvRm91ciwgdW50cnVuY2F0ZVllYXIpO1xuXG4gICAgICBjYXNlIFwieXl5eVwiOlxuICAgICAgICByZXR1cm4gaW50VW5pdChmb3VyKTtcblxuICAgICAgY2FzZSBcInl5eXl5XCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KGZvdXJUb1NpeCk7XG5cbiAgICAgIGNhc2UgXCJ5eXl5eXlcIjpcbiAgICAgICAgcmV0dXJuIGludFVuaXQoc2l4KTtcbiAgICAgIC8vIG1vbnRoc1xuXG4gICAgICBjYXNlIFwiTVwiOlxuICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG5cbiAgICAgIGNhc2UgXCJNTVwiOlxuICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuXG4gICAgICBjYXNlIFwiTU1NXCI6XG4gICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwic2hvcnRcIiwgdHJ1ZSwgZmFsc2UpLCAxKTtcblxuICAgICAgY2FzZSBcIk1NTU1cIjpcbiAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tb250aHMoXCJsb25nXCIsIHRydWUsIGZhbHNlKSwgMSk7XG5cbiAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcblxuICAgICAgY2FzZSBcIkxMXCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG5cbiAgICAgIGNhc2UgXCJMTExcIjpcbiAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tb250aHMoXCJzaG9ydFwiLCBmYWxzZSwgZmFsc2UpLCAxKTtcblxuICAgICAgY2FzZSBcIkxMTExcIjpcbiAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy5tb250aHMoXCJsb25nXCIsIGZhbHNlLCBmYWxzZSksIDEpO1xuICAgICAgLy8gZGF0ZXNcblxuICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuXG4gICAgICBjYXNlIFwiZGRcIjpcbiAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgIC8vIG9yZGluYWxzXG5cbiAgICAgIGNhc2UgXCJvXCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KG9uZVRvVGhyZWUpO1xuXG4gICAgICBjYXNlIFwib29vXCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KHRocmVlKTtcbiAgICAgIC8vIHRpbWVcblxuICAgICAgY2FzZSBcIkhIXCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG5cbiAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcblxuICAgICAgY2FzZSBcImhoXCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG5cbiAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcblxuICAgICAgY2FzZSBcIm1tXCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG5cbiAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcblxuICAgICAgY2FzZSBcInFcIjpcbiAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuXG4gICAgICBjYXNlIFwicXFcIjpcbiAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcblxuICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuXG4gICAgICBjYXNlIFwic3NcIjpcbiAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcblxuICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgcmV0dXJuIGludFVuaXQob25lVG9UaHJlZSk7XG5cbiAgICAgIGNhc2UgXCJTU1NcIjpcbiAgICAgICAgcmV0dXJuIGludFVuaXQodGhyZWUpO1xuXG4gICAgICBjYXNlIFwidVwiOlxuICAgICAgICByZXR1cm4gc2ltcGxlKG9uZVRvTmluZSk7XG4gICAgICAvLyBtZXJpZGllbVxuXG4gICAgICBjYXNlIFwiYVwiOlxuICAgICAgICByZXR1cm4gb25lT2YobG9jLm1lcmlkaWVtcygpLCAwKTtcbiAgICAgIC8vIHdlZWtZZWFyIChrKVxuXG4gICAgICBjYXNlIFwia2tra1wiOlxuICAgICAgICByZXR1cm4gaW50VW5pdChmb3VyKTtcblxuICAgICAgY2FzZSBcImtrXCI6XG4gICAgICAgIHJldHVybiBpbnRVbml0KHR3b1RvRm91ciwgdW50cnVuY2F0ZVllYXIpO1xuICAgICAgLy8gd2Vla051bWJlciAoVylcblxuICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuXG4gICAgICBjYXNlIFwiV1dcIjpcbiAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgIC8vIHdlZWtkYXlzXG5cbiAgICAgIGNhc2UgXCJFXCI6XG4gICAgICBjYXNlIFwiY1wiOlxuICAgICAgICByZXR1cm4gaW50VW5pdChvbmUpO1xuXG4gICAgICBjYXNlIFwiRUVFXCI6XG4gICAgICAgIHJldHVybiBvbmVPZihsb2Mud2Vla2RheXMoXCJzaG9ydFwiLCBmYWxzZSwgZmFsc2UpLCAxKTtcblxuICAgICAgY2FzZSBcIkVFRUVcIjpcbiAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy53ZWVrZGF5cyhcImxvbmdcIiwgZmFsc2UsIGZhbHNlKSwgMSk7XG5cbiAgICAgIGNhc2UgXCJjY2NcIjpcbiAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy53ZWVrZGF5cyhcInNob3J0XCIsIHRydWUsIGZhbHNlKSwgMSk7XG5cbiAgICAgIGNhc2UgXCJjY2NjXCI6XG4gICAgICAgIHJldHVybiBvbmVPZihsb2Mud2Vla2RheXMoXCJsb25nXCIsIHRydWUsIGZhbHNlKSwgMSk7XG4gICAgICAvLyBvZmZzZXQvem9uZVxuXG4gICAgICBjYXNlIFwiWlwiOlxuICAgICAgY2FzZSBcIlpaXCI6XG4gICAgICAgIHJldHVybiBvZmZzZXQobmV3IFJlZ0V4cChcIihbKy1dXCIgKyBvbmVPclR3by5zb3VyY2UgKyBcIikoPzo6KFwiICsgdHdvLnNvdXJjZSArIFwiKSk/XCIpLCAyKTtcblxuICAgICAgY2FzZSBcIlpaWlwiOlxuICAgICAgICByZXR1cm4gb2Zmc2V0KG5ldyBSZWdFeHAoXCIoWystXVwiICsgb25lT3JUd28uc291cmNlICsgXCIpKFwiICsgdHdvLnNvdXJjZSArIFwiKT9cIiksIDIpO1xuICAgICAgLy8gd2UgZG9uJ3Qgc3VwcG9ydCBaWlpaIChQU1QpIG9yIFpaWlpaIChQYWNpZmljIFN0YW5kYXJkIFRpbWUpIGluIHBhcnNpbmdcbiAgICAgIC8vIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhbnkgd2F5IHRvIGZpZ3VyZSBvdXQgd2hhdCB0aGV5IGFyZVxuXG4gICAgICBjYXNlIFwielwiOlxuICAgICAgICByZXR1cm4gc2ltcGxlKC9bYS16XystL117MSwyNTZ9Py9pKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGxpdGVyYWwodCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciB1bml0ID0gdW5pdGF0ZSh0b2tlbikgfHwge1xuICAgIGludmFsaWRSZWFzb246IE1JU1NJTkdfRlRQXG4gIH07XG4gIHVuaXQudG9rZW4gPSB0b2tlbjtcbiAgcmV0dXJuIHVuaXQ7XG59XG5cbnZhciBwYXJ0VHlwZVN0eWxlVG9Ub2tlblZhbCA9IHtcbiAgeWVhcjoge1xuICAgIFwiMi1kaWdpdFwiOiBcInl5XCIsXG4gICAgbnVtZXJpYzogXCJ5eXl5eVwiXG4gIH0sXG4gIG1vbnRoOiB7XG4gICAgbnVtZXJpYzogXCJNXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwiTU1cIixcbiAgICBzaG9ydDogXCJNTU1cIixcbiAgICBsb25nOiBcIk1NTU1cIlxuICB9LFxuICBkYXk6IHtcbiAgICBudW1lcmljOiBcImRcIixcbiAgICBcIjItZGlnaXRcIjogXCJkZFwiXG4gIH0sXG4gIHdlZWtkYXk6IHtcbiAgICBzaG9ydDogXCJFRUVcIixcbiAgICBsb25nOiBcIkVFRUVcIlxuICB9LFxuICBkYXlwZXJpb2Q6IFwiYVwiLFxuICBkYXlQZXJpb2Q6IFwiYVwiLFxuICBob3VyOiB7XG4gICAgbnVtZXJpYzogXCJoXCIsXG4gICAgXCIyLWRpZ2l0XCI6IFwiaGhcIlxuICB9LFxuICBtaW51dGU6IHtcbiAgICBudW1lcmljOiBcIm1cIixcbiAgICBcIjItZGlnaXRcIjogXCJtbVwiXG4gIH0sXG4gIHNlY29uZDoge1xuICAgIG51bWVyaWM6IFwic1wiLFxuICAgIFwiMi1kaWdpdFwiOiBcInNzXCJcbiAgfVxufTtcblxuZnVuY3Rpb24gdG9rZW5Gb3JQYXJ0KHBhcnQsIGxvY2FsZSwgZm9ybWF0T3B0cykge1xuICB2YXIgdHlwZSA9IHBhcnQudHlwZSxcbiAgICAgIHZhbHVlID0gcGFydC52YWx1ZTtcblxuICBpZiAodHlwZSA9PT0gXCJsaXRlcmFsXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGl0ZXJhbDogdHJ1ZSxcbiAgICAgIHZhbDogdmFsdWVcbiAgICB9O1xuICB9XG5cbiAgdmFyIHN0eWxlID0gZm9ybWF0T3B0c1t0eXBlXTtcbiAgdmFyIHZhbCA9IHBhcnRUeXBlU3R5bGVUb1Rva2VuVmFsW3R5cGVdO1xuXG4gIGlmICh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiKSB7XG4gICAgdmFsID0gdmFsW3N0eWxlXTtcbiAgfVxuXG4gIGlmICh2YWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGl0ZXJhbDogZmFsc2UsXG4gICAgICB2YWw6IHZhbFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBidWlsZFJlZ2V4KHVuaXRzKSB7XG4gIHZhciByZSA9IHVuaXRzLm1hcChmdW5jdGlvbiAodSkge1xuICAgIHJldHVybiB1LnJlZ2V4O1xuICB9KS5yZWR1Y2UoZnVuY3Rpb24gKGYsIHIpIHtcbiAgICByZXR1cm4gZiArIFwiKFwiICsgci5zb3VyY2UgKyBcIilcIjtcbiAgfSwgXCJcIik7XG4gIHJldHVybiBbXCJeXCIgKyByZSArIFwiJFwiLCB1bml0c107XG59XG5cbmZ1bmN0aW9uIG1hdGNoKGlucHV0LCByZWdleCwgaGFuZGxlcnMpIHtcbiAgdmFyIG1hdGNoZXMgPSBpbnB1dC5tYXRjaChyZWdleCk7XG5cbiAgaWYgKG1hdGNoZXMpIHtcbiAgICB2YXIgYWxsID0ge307XG4gICAgdmFyIG1hdGNoSW5kZXggPSAxO1xuXG4gICAgZm9yICh2YXIgaSBpbiBoYW5kbGVycykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KGhhbmRsZXJzLCBpKSkge1xuICAgICAgICB2YXIgaCA9IGhhbmRsZXJzW2ldLFxuICAgICAgICAgICAgZ3JvdXBzID0gaC5ncm91cHMgPyBoLmdyb3VwcyArIDEgOiAxO1xuXG4gICAgICAgIGlmICghaC5saXRlcmFsICYmIGgudG9rZW4pIHtcbiAgICAgICAgICBhbGxbaC50b2tlbi52YWxbMF1dID0gaC5kZXNlcihtYXRjaGVzLnNsaWNlKG1hdGNoSW5kZXgsIG1hdGNoSW5kZXggKyBncm91cHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hdGNoSW5kZXggKz0gZ3JvdXBzO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbbWF0Y2hlcywgYWxsXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW21hdGNoZXMsIHt9XTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkYXRlVGltZUZyb21NYXRjaGVzKG1hdGNoZXMpIHtcbiAgdmFyIHRvRmllbGQgPSBmdW5jdGlvbiB0b0ZpZWxkKHRva2VuKSB7XG4gICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgcmV0dXJuIFwibWlsbGlzZWNvbmRcIjtcblxuICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgcmV0dXJuIFwic2Vjb25kXCI7XG5cbiAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgIHJldHVybiBcIm1pbnV0ZVwiO1xuXG4gICAgICBjYXNlIFwiaFwiOlxuICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgcmV0dXJuIFwiaG91clwiO1xuXG4gICAgICBjYXNlIFwiZFwiOlxuICAgICAgICByZXR1cm4gXCJkYXlcIjtcblxuICAgICAgY2FzZSBcIm9cIjpcbiAgICAgICAgcmV0dXJuIFwib3JkaW5hbFwiO1xuXG4gICAgICBjYXNlIFwiTFwiOlxuICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgcmV0dXJuIFwibW9udGhcIjtcblxuICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgcmV0dXJuIFwieWVhclwiO1xuXG4gICAgICBjYXNlIFwiRVwiOlxuICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgcmV0dXJuIFwid2Vla2RheVwiO1xuXG4gICAgICBjYXNlIFwiV1wiOlxuICAgICAgICByZXR1cm4gXCJ3ZWVrTnVtYmVyXCI7XG5cbiAgICAgIGNhc2UgXCJrXCI6XG4gICAgICAgIHJldHVybiBcIndlZWtZZWFyXCI7XG5cbiAgICAgIGNhc2UgXCJxXCI6XG4gICAgICAgIHJldHVybiBcInF1YXJ0ZXJcIjtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIHZhciB6b25lO1xuXG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy5aKSkge1xuICAgIHpvbmUgPSBuZXcgRml4ZWRPZmZzZXRab25lKG1hdGNoZXMuWik7XG4gIH0gZWxzZSBpZiAoIWlzVW5kZWZpbmVkKG1hdGNoZXMueikpIHtcbiAgICB6b25lID0gSUFOQVpvbmUuY3JlYXRlKG1hdGNoZXMueik7XG4gIH0gZWxzZSB7XG4gICAgem9uZSA9IG51bGw7XG4gIH1cblxuICBpZiAoIWlzVW5kZWZpbmVkKG1hdGNoZXMucSkpIHtcbiAgICBtYXRjaGVzLk0gPSAobWF0Y2hlcy5xIC0gMSkgKiAzICsgMTtcbiAgfVxuXG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy5oKSkge1xuICAgIGlmIChtYXRjaGVzLmggPCAxMiAmJiBtYXRjaGVzLmEgPT09IDEpIHtcbiAgICAgIG1hdGNoZXMuaCArPSAxMjtcbiAgICB9IGVsc2UgaWYgKG1hdGNoZXMuaCA9PT0gMTIgJiYgbWF0Y2hlcy5hID09PSAwKSB7XG4gICAgICBtYXRjaGVzLmggPSAwO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtYXRjaGVzLkcgPT09IDAgJiYgbWF0Y2hlcy55KSB7XG4gICAgbWF0Y2hlcy55ID0gLW1hdGNoZXMueTtcbiAgfVxuXG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy51KSkge1xuICAgIG1hdGNoZXMuUyA9IHBhcnNlTWlsbGlzKG1hdGNoZXMudSk7XG4gIH1cblxuICB2YXIgdmFscyA9IE9iamVjdC5rZXlzKG1hdGNoZXMpLnJlZHVjZShmdW5jdGlvbiAociwgaykge1xuICAgIHZhciBmID0gdG9GaWVsZChrKTtcblxuICAgIGlmIChmKSB7XG4gICAgICByW2ZdID0gbWF0Y2hlc1trXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfSwge30pO1xuICByZXR1cm4gW3ZhbHMsIHpvbmVdO1xufVxuXG52YXIgZHVtbXlEYXRlVGltZUNhY2hlID0gbnVsbDtcblxuZnVuY3Rpb24gZ2V0RHVtbXlEYXRlVGltZSgpIHtcbiAgaWYgKCFkdW1teURhdGVUaW1lQ2FjaGUpIHtcbiAgICBkdW1teURhdGVUaW1lQ2FjaGUgPSBEYXRlVGltZS5mcm9tTWlsbGlzKDE1NTU1NTU1NTU1NTUpO1xuICB9XG5cbiAgcmV0dXJuIGR1bW15RGF0ZVRpbWVDYWNoZTtcbn1cblxuZnVuY3Rpb24gbWF5YmVFeHBhbmRNYWNyb1Rva2VuKHRva2VuLCBsb2NhbGUpIHtcbiAgaWYgKHRva2VuLmxpdGVyYWwpIHtcbiAgICByZXR1cm4gdG9rZW47XG4gIH1cblxuICB2YXIgZm9ybWF0T3B0cyA9IEZvcm1hdHRlci5tYWNyb1Rva2VuVG9Gb3JtYXRPcHRzKHRva2VuLnZhbCk7XG5cbiAgaWYgKCFmb3JtYXRPcHRzKSB7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgdmFyIGZvcm1hdHRlciA9IEZvcm1hdHRlci5jcmVhdGUobG9jYWxlLCBmb3JtYXRPcHRzKTtcbiAgdmFyIHBhcnRzID0gZm9ybWF0dGVyLmZvcm1hdERhdGVUaW1lUGFydHMoZ2V0RHVtbXlEYXRlVGltZSgpKTtcbiAgdmFyIHRva2VucyA9IHBhcnRzLm1hcChmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiB0b2tlbkZvclBhcnQocCwgbG9jYWxlLCBmb3JtYXRPcHRzKTtcbiAgfSk7XG5cbiAgaWYgKHRva2Vucy5pbmNsdWRlcyh1bmRlZmluZWQpKSB7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgcmV0dXJuIHRva2Vucztcbn1cblxuZnVuY3Rpb24gZXhwYW5kTWFjcm9Ub2tlbnModG9rZW5zLCBsb2NhbGUpIHtcbiAgdmFyIF9BcnJheSRwcm90b3R5cGU7XG5cbiAgcmV0dXJuIChfQXJyYXkkcHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlKS5jb25jYXQuYXBwbHkoX0FycmF5JHByb3RvdHlwZSwgdG9rZW5zLm1hcChmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBtYXliZUV4cGFuZE1hY3JvVG9rZW4odCwgbG9jYWxlKTtcbiAgfSkpO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gZXhwbGFpbkZyb21Ub2tlbnMobG9jYWxlLCBpbnB1dCwgZm9ybWF0KSB7XG4gIHZhciB0b2tlbnMgPSBleHBhbmRNYWNyb1Rva2VucyhGb3JtYXR0ZXIucGFyc2VGb3JtYXQoZm9ybWF0KSwgbG9jYWxlKSxcbiAgICAgIHVuaXRzID0gdG9rZW5zLm1hcChmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB1bml0Rm9yVG9rZW4odCwgbG9jYWxlKTtcbiAgfSksXG4gICAgICBkaXNxdWFsaWZ5aW5nVW5pdCA9IHVuaXRzLmZpbmQoZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdC5pbnZhbGlkUmVhc29uO1xuICB9KTtcblxuICBpZiAoZGlzcXVhbGlmeWluZ1VuaXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXQ6IGlucHV0LFxuICAgICAgdG9rZW5zOiB0b2tlbnMsXG4gICAgICBpbnZhbGlkUmVhc29uOiBkaXNxdWFsaWZ5aW5nVW5pdC5pbnZhbGlkUmVhc29uXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX2J1aWxkUmVnZXggPSBidWlsZFJlZ2V4KHVuaXRzKSxcbiAgICAgICAgcmVnZXhTdHJpbmcgPSBfYnVpbGRSZWdleFswXSxcbiAgICAgICAgaGFuZGxlcnMgPSBfYnVpbGRSZWdleFsxXSxcbiAgICAgICAgcmVnZXggPSBSZWdFeHAocmVnZXhTdHJpbmcsIFwiaVwiKSxcbiAgICAgICAgX21hdGNoID0gbWF0Y2goaW5wdXQsIHJlZ2V4LCBoYW5kbGVycyksXG4gICAgICAgIHJhd01hdGNoZXMgPSBfbWF0Y2hbMF0sXG4gICAgICAgIG1hdGNoZXMgPSBfbWF0Y2hbMV0sXG4gICAgICAgIF9yZWY2ID0gbWF0Y2hlcyA/IGRhdGVUaW1lRnJvbU1hdGNoZXMobWF0Y2hlcykgOiBbbnVsbCwgbnVsbF0sXG4gICAgICAgIHJlc3VsdCA9IF9yZWY2WzBdLFxuICAgICAgICB6b25lID0gX3JlZjZbMV07XG5cbiAgICBpZiAoaGFzT3duUHJvcGVydHkobWF0Y2hlcywgXCJhXCIpICYmIGhhc093blByb3BlcnR5KG1hdGNoZXMsIFwiSFwiKSkge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFwiQ2FuJ3QgaW5jbHVkZSBtZXJpZGllbSB3aGVuIHNwZWNpZnlpbmcgMjQtaG91ciBmb3JtYXRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0OiBpbnB1dCxcbiAgICAgIHRva2VuczogdG9rZW5zLFxuICAgICAgcmVnZXg6IHJlZ2V4LFxuICAgICAgcmF3TWF0Y2hlczogcmF3TWF0Y2hlcyxcbiAgICAgIG1hdGNoZXM6IG1hdGNoZXMsXG4gICAgICByZXN1bHQ6IHJlc3VsdCxcbiAgICAgIHpvbmU6IHpvbmVcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZUZyb21Ub2tlbnMobG9jYWxlLCBpbnB1dCwgZm9ybWF0KSB7XG4gIHZhciBfZXhwbGFpbkZyb21Ub2tlbnMgPSBleHBsYWluRnJvbVRva2Vucyhsb2NhbGUsIGlucHV0LCBmb3JtYXQpLFxuICAgICAgcmVzdWx0ID0gX2V4cGxhaW5Gcm9tVG9rZW5zLnJlc3VsdCxcbiAgICAgIHpvbmUgPSBfZXhwbGFpbkZyb21Ub2tlbnMuem9uZSxcbiAgICAgIGludmFsaWRSZWFzb24gPSBfZXhwbGFpbkZyb21Ub2tlbnMuaW52YWxpZFJlYXNvbjtcblxuICByZXR1cm4gW3Jlc3VsdCwgem9uZSwgaW52YWxpZFJlYXNvbl07XG59XG5cbnZhciBub25MZWFwTGFkZGVyID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XSxcbiAgICBsZWFwTGFkZGVyID0gWzAsIDMxLCA2MCwgOTEsIDEyMSwgMTUyLCAxODIsIDIxMywgMjQ0LCAyNzQsIDMwNSwgMzM1XTtcblxuZnVuY3Rpb24gdW5pdE91dE9mUmFuZ2UodW5pdCwgdmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBJbnZhbGlkKFwidW5pdCBvdXQgb2YgcmFuZ2VcIiwgXCJ5b3Ugc3BlY2lmaWVkIFwiICsgdmFsdWUgKyBcIiAob2YgdHlwZSBcIiArIHR5cGVvZiB2YWx1ZSArIFwiKSBhcyBhIFwiICsgdW5pdCArIFwiLCB3aGljaCBpcyBpbnZhbGlkXCIpO1xufVxuXG5mdW5jdGlvbiBkYXlPZldlZWsoeWVhciwgbW9udGgsIGRheSkge1xuICB2YXIganMgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCAtIDEsIGRheSkpLmdldFVUQ0RheSgpO1xuICByZXR1cm4ganMgPT09IDAgPyA3IDoganM7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVPcmRpbmFsKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgcmV0dXJuIGRheSArIChpc0xlYXBZZWFyKHllYXIpID8gbGVhcExhZGRlciA6IG5vbkxlYXBMYWRkZXIpW21vbnRoIC0gMV07XG59XG5cbmZ1bmN0aW9uIHVuY29tcHV0ZU9yZGluYWwoeWVhciwgb3JkaW5hbCkge1xuICB2YXIgdGFibGUgPSBpc0xlYXBZZWFyKHllYXIpID8gbGVhcExhZGRlciA6IG5vbkxlYXBMYWRkZXIsXG4gICAgICBtb250aDAgPSB0YWJsZS5maW5kSW5kZXgoZnVuY3Rpb24gKGkpIHtcbiAgICByZXR1cm4gaSA8IG9yZGluYWw7XG4gIH0pLFxuICAgICAgZGF5ID0gb3JkaW5hbCAtIHRhYmxlW21vbnRoMF07XG4gIHJldHVybiB7XG4gICAgbW9udGg6IG1vbnRoMCArIDEsXG4gICAgZGF5OiBkYXlcbiAgfTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGdyZWdvcmlhblRvV2VlayhncmVnT2JqKSB7XG4gIHZhciB5ZWFyID0gZ3JlZ09iai55ZWFyLFxuICAgICAgbW9udGggPSBncmVnT2JqLm1vbnRoLFxuICAgICAgZGF5ID0gZ3JlZ09iai5kYXksXG4gICAgICBvcmRpbmFsID0gY29tcHV0ZU9yZGluYWwoeWVhciwgbW9udGgsIGRheSksXG4gICAgICB3ZWVrZGF5ID0gZGF5T2ZXZWVrKHllYXIsIG1vbnRoLCBkYXkpO1xuICB2YXIgd2Vla051bWJlciA9IE1hdGguZmxvb3IoKG9yZGluYWwgLSB3ZWVrZGF5ICsgMTApIC8gNyksXG4gICAgICB3ZWVrWWVhcjtcblxuICBpZiAod2Vla051bWJlciA8IDEpIHtcbiAgICB3ZWVrWWVhciA9IHllYXIgLSAxO1xuICAgIHdlZWtOdW1iZXIgPSB3ZWVrc0luV2Vla1llYXIod2Vla1llYXIpO1xuICB9IGVsc2UgaWYgKHdlZWtOdW1iZXIgPiB3ZWVrc0luV2Vla1llYXIoeWVhcikpIHtcbiAgICB3ZWVrWWVhciA9IHllYXIgKyAxO1xuICAgIHdlZWtOdW1iZXIgPSAxO1xuICB9IGVsc2Uge1xuICAgIHdlZWtZZWFyID0geWVhcjtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICB3ZWVrWWVhcjogd2Vla1llYXIsXG4gICAgd2Vla051bWJlcjogd2Vla051bWJlcixcbiAgICB3ZWVrZGF5OiB3ZWVrZGF5XG4gIH0sIHRpbWVPYmplY3QoZ3JlZ09iaikpO1xufVxuZnVuY3Rpb24gd2Vla1RvR3JlZ29yaWFuKHdlZWtEYXRhKSB7XG4gIHZhciB3ZWVrWWVhciA9IHdlZWtEYXRhLndlZWtZZWFyLFxuICAgICAgd2Vla051bWJlciA9IHdlZWtEYXRhLndlZWtOdW1iZXIsXG4gICAgICB3ZWVrZGF5ID0gd2Vla0RhdGEud2Vla2RheSxcbiAgICAgIHdlZWtkYXlPZkphbjQgPSBkYXlPZldlZWsod2Vla1llYXIsIDEsIDQpLFxuICAgICAgeWVhckluRGF5cyA9IGRheXNJblllYXIod2Vla1llYXIpO1xuICB2YXIgb3JkaW5hbCA9IHdlZWtOdW1iZXIgKiA3ICsgd2Vla2RheSAtIHdlZWtkYXlPZkphbjQgLSAzLFxuICAgICAgeWVhcjtcblxuICBpZiAob3JkaW5hbCA8IDEpIHtcbiAgICB5ZWFyID0gd2Vla1llYXIgLSAxO1xuICAgIG9yZGluYWwgKz0gZGF5c0luWWVhcih5ZWFyKTtcbiAgfSBlbHNlIGlmIChvcmRpbmFsID4geWVhckluRGF5cykge1xuICAgIHllYXIgPSB3ZWVrWWVhciArIDE7XG4gICAgb3JkaW5hbCAtPSBkYXlzSW5ZZWFyKHdlZWtZZWFyKTtcbiAgfSBlbHNlIHtcbiAgICB5ZWFyID0gd2Vla1llYXI7XG4gIH1cblxuICB2YXIgX3VuY29tcHV0ZU9yZGluYWwgPSB1bmNvbXB1dGVPcmRpbmFsKHllYXIsIG9yZGluYWwpLFxuICAgICAgbW9udGggPSBfdW5jb21wdXRlT3JkaW5hbC5tb250aCxcbiAgICAgIGRheSA9IF91bmNvbXB1dGVPcmRpbmFsLmRheTtcblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgeWVhcjogeWVhcixcbiAgICBtb250aDogbW9udGgsXG4gICAgZGF5OiBkYXlcbiAgfSwgdGltZU9iamVjdCh3ZWVrRGF0YSkpO1xufVxuZnVuY3Rpb24gZ3JlZ29yaWFuVG9PcmRpbmFsKGdyZWdEYXRhKSB7XG4gIHZhciB5ZWFyID0gZ3JlZ0RhdGEueWVhcixcbiAgICAgIG1vbnRoID0gZ3JlZ0RhdGEubW9udGgsXG4gICAgICBkYXkgPSBncmVnRGF0YS5kYXksXG4gICAgICBvcmRpbmFsID0gY29tcHV0ZU9yZGluYWwoeWVhciwgbW9udGgsIGRheSk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICB5ZWFyOiB5ZWFyLFxuICAgIG9yZGluYWw6IG9yZGluYWxcbiAgfSwgdGltZU9iamVjdChncmVnRGF0YSkpO1xufVxuZnVuY3Rpb24gb3JkaW5hbFRvR3JlZ29yaWFuKG9yZGluYWxEYXRhKSB7XG4gIHZhciB5ZWFyID0gb3JkaW5hbERhdGEueWVhcixcbiAgICAgIG9yZGluYWwgPSBvcmRpbmFsRGF0YS5vcmRpbmFsLFxuICAgICAgX3VuY29tcHV0ZU9yZGluYWwyID0gdW5jb21wdXRlT3JkaW5hbCh5ZWFyLCBvcmRpbmFsKSxcbiAgICAgIG1vbnRoID0gX3VuY29tcHV0ZU9yZGluYWwyLm1vbnRoLFxuICAgICAgZGF5ID0gX3VuY29tcHV0ZU9yZGluYWwyLmRheTtcblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgeWVhcjogeWVhcixcbiAgICBtb250aDogbW9udGgsXG4gICAgZGF5OiBkYXlcbiAgfSwgdGltZU9iamVjdChvcmRpbmFsRGF0YSkpO1xufVxuZnVuY3Rpb24gaGFzSW52YWxpZFdlZWtEYXRhKG9iaikge1xuICB2YXIgdmFsaWRZZWFyID0gaXNJbnRlZ2VyKG9iai53ZWVrWWVhciksXG4gICAgICB2YWxpZFdlZWsgPSBpbnRlZ2VyQmV0d2VlbihvYmoud2Vla051bWJlciwgMSwgd2Vla3NJbldlZWtZZWFyKG9iai53ZWVrWWVhcikpLFxuICAgICAgdmFsaWRXZWVrZGF5ID0gaW50ZWdlckJldHdlZW4ob2JqLndlZWtkYXksIDEsIDcpO1xuXG4gIGlmICghdmFsaWRZZWFyKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwid2Vla1llYXJcIiwgb2JqLndlZWtZZWFyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRXZWVrKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwid2Vla1wiLCBvYmoud2Vlayk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkV2Vla2RheSkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIndlZWtkYXlcIiwgb2JqLndlZWtkYXkpO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaGFzSW52YWxpZE9yZGluYWxEYXRhKG9iaikge1xuICB2YXIgdmFsaWRZZWFyID0gaXNJbnRlZ2VyKG9iai55ZWFyKSxcbiAgICAgIHZhbGlkT3JkaW5hbCA9IGludGVnZXJCZXR3ZWVuKG9iai5vcmRpbmFsLCAxLCBkYXlzSW5ZZWFyKG9iai55ZWFyKSk7XG5cbiAgaWYgKCF2YWxpZFllYXIpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ5ZWFyXCIsIG9iai55ZWFyKTtcbiAgfSBlbHNlIGlmICghdmFsaWRPcmRpbmFsKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwib3JkaW5hbFwiLCBvYmoub3JkaW5hbCk7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YShvYmopIHtcbiAgdmFyIHZhbGlkWWVhciA9IGlzSW50ZWdlcihvYmoueWVhciksXG4gICAgICB2YWxpZE1vbnRoID0gaW50ZWdlckJldHdlZW4ob2JqLm1vbnRoLCAxLCAxMiksXG4gICAgICB2YWxpZERheSA9IGludGVnZXJCZXR3ZWVuKG9iai5kYXksIDEsIGRheXNJbk1vbnRoKG9iai55ZWFyLCBvYmoubW9udGgpKTtcblxuICBpZiAoIXZhbGlkWWVhcikge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcInllYXJcIiwgb2JqLnllYXIpO1xuICB9IGVsc2UgaWYgKCF2YWxpZE1vbnRoKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwibW9udGhcIiwgb2JqLm1vbnRoKTtcbiAgfSBlbHNlIGlmICghdmFsaWREYXkpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJkYXlcIiwgb2JqLmRheSk7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBoYXNJbnZhbGlkVGltZURhdGEob2JqKSB7XG4gIHZhciBob3VyID0gb2JqLmhvdXIsXG4gICAgICBtaW51dGUgPSBvYmoubWludXRlLFxuICAgICAgc2Vjb25kID0gb2JqLnNlY29uZCxcbiAgICAgIG1pbGxpc2Vjb25kID0gb2JqLm1pbGxpc2Vjb25kO1xuICB2YXIgdmFsaWRIb3VyID0gaW50ZWdlckJldHdlZW4oaG91ciwgMCwgMjMpIHx8IGhvdXIgPT09IDI0ICYmIG1pbnV0ZSA9PT0gMCAmJiBzZWNvbmQgPT09IDAgJiYgbWlsbGlzZWNvbmQgPT09IDAsXG4gICAgICB2YWxpZE1pbnV0ZSA9IGludGVnZXJCZXR3ZWVuKG1pbnV0ZSwgMCwgNTkpLFxuICAgICAgdmFsaWRTZWNvbmQgPSBpbnRlZ2VyQmV0d2VlbihzZWNvbmQsIDAsIDU5KSxcbiAgICAgIHZhbGlkTWlsbGlzZWNvbmQgPSBpbnRlZ2VyQmV0d2VlbihtaWxsaXNlY29uZCwgMCwgOTk5KTtcblxuICBpZiAoIXZhbGlkSG91cikge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcImhvdXJcIiwgaG91cik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkTWludXRlKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwibWludXRlXCIsIG1pbnV0ZSk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkU2Vjb25kKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwic2Vjb25kXCIsIHNlY29uZCk7XG4gIH0gZWxzZSBpZiAoIXZhbGlkTWlsbGlzZWNvbmQpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJtaWxsaXNlY29uZFwiLCBtaWxsaXNlY29uZCk7XG4gIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBJTlZBTElEJDIgPSBcIkludmFsaWQgRGF0ZVRpbWVcIjtcbnZhciBNQVhfREFURSA9IDguNjRlMTU7XG5cbmZ1bmN0aW9uIHVuc3VwcG9ydGVkWm9uZSh6b25lKSB7XG4gIHJldHVybiBuZXcgSW52YWxpZChcInVuc3VwcG9ydGVkIHpvbmVcIiwgXCJ0aGUgem9uZSBcXFwiXCIgKyB6b25lLm5hbWUgKyBcIlxcXCIgaXMgbm90IHN1cHBvcnRlZFwiKTtcbn0gLy8gd2UgY2FjaGUgd2VlayBkYXRhIG9uIHRoZSBEVCBvYmplY3QgYW5kIHRoaXMgaW50ZXJtZWRpYXRlcyB0aGUgY2FjaGVcblxuXG5mdW5jdGlvbiBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKGR0KSB7XG4gIGlmIChkdC53ZWVrRGF0YSA9PT0gbnVsbCkge1xuICAgIGR0LndlZWtEYXRhID0gZ3JlZ29yaWFuVG9XZWVrKGR0LmMpO1xuICB9XG5cbiAgcmV0dXJuIGR0LndlZWtEYXRhO1xufSAvLyBjbG9uZSByZWFsbHkgbWVhbnMsIFwibWFrZSBhIG5ldyBvYmplY3Qgd2l0aCB0aGVzZSBtb2RpZmljYXRpb25zXCIuIGFsbCBcInNldHRlcnNcIiByZWFsbHkgdXNlIHRoaXNcbi8vIHRvIGNyZWF0ZSBhIG5ldyBvYmplY3Qgd2hpbGUgb25seSBjaGFuZ2luZyBzb21lIG9mIHRoZSBwcm9wZXJ0aWVzXG5cblxuZnVuY3Rpb24gY2xvbmUkMShpbnN0LCBhbHRzKSB7XG4gIHZhciBjdXJyZW50ID0ge1xuICAgIHRzOiBpbnN0LnRzLFxuICAgIHpvbmU6IGluc3Quem9uZSxcbiAgICBjOiBpbnN0LmMsXG4gICAgbzogaW5zdC5vLFxuICAgIGxvYzogaW5zdC5sb2MsXG4gICAgaW52YWxpZDogaW5zdC5pbnZhbGlkXG4gIH07XG4gIHJldHVybiBuZXcgRGF0ZVRpbWUoT2JqZWN0LmFzc2lnbih7fSwgY3VycmVudCwgYWx0cywge1xuICAgIG9sZDogY3VycmVudFxuICB9KSk7XG59IC8vIGZpbmQgdGhlIHJpZ2h0IG9mZnNldCBhIGdpdmVuIGxvY2FsIHRpbWUuIFRoZSBvIGlucHV0IGlzIG91ciBndWVzcywgd2hpY2ggZGV0ZXJtaW5lcyB3aGljaFxuLy8gb2Zmc2V0IHdlJ2xsIHBpY2sgaW4gYW1iaWd1b3VzIGNhc2VzIChlLmcuIHRoZXJlIGFyZSB0d28gMyBBTXMgYi9jIEZhbGxiYWNrIERTVClcblxuXG5mdW5jdGlvbiBmaXhPZmZzZXQobG9jYWxUUywgbywgdHopIHtcbiAgLy8gT3VyIFVUQyB0aW1lIGlzIGp1c3QgYSBndWVzcyBiZWNhdXNlIG91ciBvZmZzZXQgaXMganVzdCBhIGd1ZXNzXG4gIHZhciB1dGNHdWVzcyA9IGxvY2FsVFMgLSBvICogNjAgKiAxMDAwOyAvLyBUZXN0IHdoZXRoZXIgdGhlIHpvbmUgbWF0Y2hlcyB0aGUgb2Zmc2V0IGZvciB0aGlzIHRzXG5cbiAgdmFyIG8yID0gdHoub2Zmc2V0KHV0Y0d1ZXNzKTsgLy8gSWYgc28sIG9mZnNldCBkaWRuJ3QgY2hhbmdlIGFuZCB3ZSdyZSBkb25lXG5cbiAgaWYgKG8gPT09IG8yKSB7XG4gICAgcmV0dXJuIFt1dGNHdWVzcywgb107XG4gIH0gLy8gSWYgbm90LCBjaGFuZ2UgdGhlIHRzIGJ5IHRoZSBkaWZmZXJlbmNlIGluIHRoZSBvZmZzZXRcblxuXG4gIHV0Y0d1ZXNzIC09IChvMiAtIG8pICogNjAgKiAxMDAwOyAvLyBJZiB0aGF0IGdpdmVzIHVzIHRoZSBsb2NhbCB0aW1lIHdlIHdhbnQsIHdlJ3JlIGRvbmVcblxuICB2YXIgbzMgPSB0ei5vZmZzZXQodXRjR3Vlc3MpO1xuXG4gIGlmIChvMiA9PT0gbzMpIHtcbiAgICByZXR1cm4gW3V0Y0d1ZXNzLCBvMl07XG4gIH0gLy8gSWYgaXQncyBkaWZmZXJlbnQsIHdlJ3JlIGluIGEgaG9sZSB0aW1lLiBUaGUgb2Zmc2V0IGhhcyBjaGFuZ2VkLCBidXQgdGhlIHdlIGRvbid0IGFkanVzdCB0aGUgdGltZVxuXG5cbiAgcmV0dXJuIFtsb2NhbFRTIC0gTWF0aC5taW4obzIsIG8zKSAqIDYwICogMTAwMCwgTWF0aC5tYXgobzIsIG8zKV07XG59IC8vIGNvbnZlcnQgYW4gZXBvY2ggdGltZXN0YW1wIGludG8gYSBjYWxlbmRhciBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gb2Zmc2V0XG5cblxuZnVuY3Rpb24gdHNUb09iaih0cywgb2Zmc2V0KSB7XG4gIHRzICs9IG9mZnNldCAqIDYwICogMTAwMDtcbiAgdmFyIGQgPSBuZXcgRGF0ZSh0cyk7XG4gIHJldHVybiB7XG4gICAgeWVhcjogZC5nZXRVVENGdWxsWWVhcigpLFxuICAgIG1vbnRoOiBkLmdldFVUQ01vbnRoKCkgKyAxLFxuICAgIGRheTogZC5nZXRVVENEYXRlKCksXG4gICAgaG91cjogZC5nZXRVVENIb3VycygpLFxuICAgIG1pbnV0ZTogZC5nZXRVVENNaW51dGVzKCksXG4gICAgc2Vjb25kOiBkLmdldFVUQ1NlY29uZHMoKSxcbiAgICBtaWxsaXNlY29uZDogZC5nZXRVVENNaWxsaXNlY29uZHMoKVxuICB9O1xufSAvLyBjb252ZXJ0IGEgY2FsZW5kYXIgb2JqZWN0IHRvIGEgZXBvY2ggdGltZXN0YW1wXG5cblxuZnVuY3Rpb24gb2JqVG9UUyhvYmosIG9mZnNldCwgem9uZSkge1xuICByZXR1cm4gZml4T2Zmc2V0KG9ialRvTG9jYWxUUyhvYmopLCBvZmZzZXQsIHpvbmUpO1xufSAvLyBjcmVhdGUgYSBuZXcgRFQgaW5zdGFuY2UgYnkgYWRkaW5nIGEgZHVyYXRpb24sIGFkanVzdGluZyBmb3IgRFNUc1xuXG5cbmZ1bmN0aW9uIGFkanVzdFRpbWUoaW5zdCwgZHVyKSB7XG4gIHZhciBvUHJlID0gaW5zdC5vLFxuICAgICAgeWVhciA9IGluc3QuYy55ZWFyICsgTWF0aC50cnVuYyhkdXIueWVhcnMpLFxuICAgICAgbW9udGggPSBpbnN0LmMubW9udGggKyBNYXRoLnRydW5jKGR1ci5tb250aHMpICsgTWF0aC50cnVuYyhkdXIucXVhcnRlcnMpICogMyxcbiAgICAgIGMgPSBPYmplY3QuYXNzaWduKHt9LCBpbnN0LmMsIHtcbiAgICB5ZWFyOiB5ZWFyLFxuICAgIG1vbnRoOiBtb250aCxcbiAgICBkYXk6IE1hdGgubWluKGluc3QuYy5kYXksIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSkgKyBNYXRoLnRydW5jKGR1ci5kYXlzKSArIE1hdGgudHJ1bmMoZHVyLndlZWtzKSAqIDdcbiAgfSksXG4gICAgICBtaWxsaXNUb0FkZCA9IER1cmF0aW9uLmZyb21PYmplY3Qoe1xuICAgIHllYXJzOiBkdXIueWVhcnMgLSBNYXRoLnRydW5jKGR1ci55ZWFycyksXG4gICAgcXVhcnRlcnM6IGR1ci5xdWFydGVycyAtIE1hdGgudHJ1bmMoZHVyLnF1YXJ0ZXJzKSxcbiAgICBtb250aHM6IGR1ci5tb250aHMgLSBNYXRoLnRydW5jKGR1ci5tb250aHMpLFxuICAgIHdlZWtzOiBkdXIud2Vla3MgLSBNYXRoLnRydW5jKGR1ci53ZWVrcyksXG4gICAgZGF5czogZHVyLmRheXMgLSBNYXRoLnRydW5jKGR1ci5kYXlzKSxcbiAgICBob3VyczogZHVyLmhvdXJzLFxuICAgIG1pbnV0ZXM6IGR1ci5taW51dGVzLFxuICAgIHNlY29uZHM6IGR1ci5zZWNvbmRzLFxuICAgIG1pbGxpc2Vjb25kczogZHVyLm1pbGxpc2Vjb25kc1xuICB9KS5hcyhcIm1pbGxpc2Vjb25kc1wiKSxcbiAgICAgIGxvY2FsVFMgPSBvYmpUb0xvY2FsVFMoYyk7XG5cbiAgdmFyIF9maXhPZmZzZXQgPSBmaXhPZmZzZXQobG9jYWxUUywgb1ByZSwgaW5zdC56b25lKSxcbiAgICAgIHRzID0gX2ZpeE9mZnNldFswXSxcbiAgICAgIG8gPSBfZml4T2Zmc2V0WzFdO1xuXG4gIGlmIChtaWxsaXNUb0FkZCAhPT0gMCkge1xuICAgIHRzICs9IG1pbGxpc1RvQWRkOyAvLyB0aGF0IGNvdWxkIGhhdmUgY2hhbmdlZCB0aGUgb2Zmc2V0IGJ5IGdvaW5nIG92ZXIgYSBEU1QsIGJ1dCB3ZSB3YW50IHRvIGtlZXAgdGhlIHRzIHRoZSBzYW1lXG5cbiAgICBvID0gaW5zdC56b25lLm9mZnNldCh0cyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRzOiB0cyxcbiAgICBvOiBvXG4gIH07XG59IC8vIGhlbHBlciB1c2VmdWwgaW4gdHVybmluZyB0aGUgcmVzdWx0cyBvZiBwYXJzaW5nIGludG8gcmVhbCBkYXRlc1xuLy8gYnkgaGFuZGxpbmcgdGhlIHpvbmUgb3B0aW9uc1xuXG5cbmZ1bmN0aW9uIHBhcnNlRGF0YVRvRGF0ZVRpbWUocGFyc2VkLCBwYXJzZWRab25lLCBvcHRzLCBmb3JtYXQsIHRleHQpIHtcbiAgdmFyIHNldFpvbmUgPSBvcHRzLnNldFpvbmUsXG4gICAgICB6b25lID0gb3B0cy56b25lO1xuXG4gIGlmIChwYXJzZWQgJiYgT2JqZWN0LmtleXMocGFyc2VkKS5sZW5ndGggIT09IDApIHtcbiAgICB2YXIgaW50ZXJwcmV0YXRpb25ab25lID0gcGFyc2VkWm9uZSB8fCB6b25lLFxuICAgICAgICBpbnN0ID0gRGF0ZVRpbWUuZnJvbU9iamVjdChPYmplY3QuYXNzaWduKHBhcnNlZCwgb3B0cywge1xuICAgICAgem9uZTogaW50ZXJwcmV0YXRpb25ab25lLFxuICAgICAgLy8gc2V0Wm9uZSBpcyBhIHZhbGlkIG9wdGlvbiBpbiB0aGUgY2FsbGluZyBtZXRob2RzLCBidXQgbm90IGluIGZyb21PYmplY3RcbiAgICAgIHNldFpvbmU6IHVuZGVmaW5lZFxuICAgIH0pKTtcbiAgICByZXR1cm4gc2V0Wm9uZSA/IGluc3QgOiBpbnN0LnNldFpvbmUoem9uZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQobmV3IEludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIFwidGhlIGlucHV0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgY2FuJ3QgYmUgcGFyc2VkIGFzIFwiICsgZm9ybWF0KSk7XG4gIH1cbn0gLy8gaWYgeW91IHdhbnQgdG8gb3V0cHV0IGEgdGVjaG5pY2FsIGZvcm1hdCAoZS5nLiBSRkMgMjgyMiksIHRoaXMgaGVscGVyXG4vLyBoZWxwcyBoYW5kbGUgdGhlIGRldGFpbHNcblxuXG5mdW5jdGlvbiB0b1RlY2hGb3JtYXQoZHQsIGZvcm1hdCwgYWxsb3daKSB7XG4gIGlmIChhbGxvd1ogPT09IHZvaWQgMCkge1xuICAgIGFsbG93WiA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gZHQuaXNWYWxpZCA/IEZvcm1hdHRlci5jcmVhdGUoTG9jYWxlLmNyZWF0ZShcImVuLVVTXCIpLCB7XG4gICAgYWxsb3daOiBhbGxvd1osXG4gICAgZm9yY2VTaW1wbGU6IHRydWVcbiAgfSkuZm9ybWF0RGF0ZVRpbWVGcm9tU3RyaW5nKGR0LCBmb3JtYXQpIDogbnVsbDtcbn0gLy8gdGVjaG5pY2FsIHRpbWUgZm9ybWF0cyAoZS5nLiB0aGUgdGltZSBwYXJ0IG9mIElTTyA4NjAxKSwgdGFrZSBzb21lIG9wdGlvbnNcbi8vIGFuZCB0aGlzIGNvbW1vbml6ZXMgdGhlaXIgaGFuZGxpbmdcblxuXG5mdW5jdGlvbiB0b1RlY2hUaW1lRm9ybWF0KGR0LCBfcmVmKSB7XG4gIHZhciBfcmVmJHN1cHByZXNzU2Vjb25kcyA9IF9yZWYuc3VwcHJlc3NTZWNvbmRzLFxuICAgICAgc3VwcHJlc3NTZWNvbmRzID0gX3JlZiRzdXBwcmVzc1NlY29uZHMgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRzdXBwcmVzc1NlY29uZHMsXG4gICAgICBfcmVmJHN1cHByZXNzTWlsbGlzZWMgPSBfcmVmLnN1cHByZXNzTWlsbGlzZWNvbmRzLFxuICAgICAgc3VwcHJlc3NNaWxsaXNlY29uZHMgPSBfcmVmJHN1cHByZXNzTWlsbGlzZWMgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRzdXBwcmVzc01pbGxpc2VjLFxuICAgICAgaW5jbHVkZU9mZnNldCA9IF9yZWYuaW5jbHVkZU9mZnNldCxcbiAgICAgIF9yZWYkaW5jbHVkZVByZWZpeCA9IF9yZWYuaW5jbHVkZVByZWZpeCxcbiAgICAgIGluY2x1ZGVQcmVmaXggPSBfcmVmJGluY2x1ZGVQcmVmaXggPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRpbmNsdWRlUHJlZml4LFxuICAgICAgX3JlZiRpbmNsdWRlWm9uZSA9IF9yZWYuaW5jbHVkZVpvbmUsXG4gICAgICBpbmNsdWRlWm9uZSA9IF9yZWYkaW5jbHVkZVpvbmUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRpbmNsdWRlWm9uZSxcbiAgICAgIF9yZWYkc3BhY2Vab25lID0gX3JlZi5zcGFjZVpvbmUsXG4gICAgICBzcGFjZVpvbmUgPSBfcmVmJHNwYWNlWm9uZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJHNwYWNlWm9uZSxcbiAgICAgIF9yZWYkZm9ybWF0ID0gX3JlZi5mb3JtYXQsXG4gICAgICBmb3JtYXQgPSBfcmVmJGZvcm1hdCA9PT0gdm9pZCAwID8gXCJleHRlbmRlZFwiIDogX3JlZiRmb3JtYXQ7XG4gIHZhciBmbXQgPSBmb3JtYXQgPT09IFwiYmFzaWNcIiA/IFwiSEhtbVwiIDogXCJISDptbVwiO1xuXG4gIGlmICghc3VwcHJlc3NTZWNvbmRzIHx8IGR0LnNlY29uZCAhPT0gMCB8fCBkdC5taWxsaXNlY29uZCAhPT0gMCkge1xuICAgIGZtdCArPSBmb3JtYXQgPT09IFwiYmFzaWNcIiA/IFwic3NcIiA6IFwiOnNzXCI7XG5cbiAgICBpZiAoIXN1cHByZXNzTWlsbGlzZWNvbmRzIHx8IGR0Lm1pbGxpc2Vjb25kICE9PSAwKSB7XG4gICAgICBmbXQgKz0gXCIuU1NTXCI7XG4gICAgfVxuICB9XG5cbiAgaWYgKChpbmNsdWRlWm9uZSB8fCBpbmNsdWRlT2Zmc2V0KSAmJiBzcGFjZVpvbmUpIHtcbiAgICBmbXQgKz0gXCIgXCI7XG4gIH1cblxuICBpZiAoaW5jbHVkZVpvbmUpIHtcbiAgICBmbXQgKz0gXCJ6XCI7XG4gIH0gZWxzZSBpZiAoaW5jbHVkZU9mZnNldCkge1xuICAgIGZtdCArPSBmb3JtYXQgPT09IFwiYmFzaWNcIiA/IFwiWlpaXCIgOiBcIlpaXCI7XG4gIH1cblxuICB2YXIgc3RyID0gdG9UZWNoRm9ybWF0KGR0LCBmbXQpO1xuXG4gIGlmIChpbmNsdWRlUHJlZml4KSB7XG4gICAgc3RyID0gXCJUXCIgKyBzdHI7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufSAvLyBkZWZhdWx0cyBmb3IgdW5zcGVjaWZpZWQgdW5pdHMgaW4gdGhlIHN1cHBvcnRlZCBjYWxlbmRhcnNcblxuXG52YXIgZGVmYXVsdFVuaXRWYWx1ZXMgPSB7XG4gIG1vbnRoOiAxLFxuICBkYXk6IDEsXG4gIGhvdXI6IDAsXG4gIG1pbnV0ZTogMCxcbiAgc2Vjb25kOiAwLFxuICBtaWxsaXNlY29uZDogMFxufSxcbiAgICBkZWZhdWx0V2Vla1VuaXRWYWx1ZXMgPSB7XG4gIHdlZWtOdW1iZXI6IDEsXG4gIHdlZWtkYXk6IDEsXG4gIGhvdXI6IDAsXG4gIG1pbnV0ZTogMCxcbiAgc2Vjb25kOiAwLFxuICBtaWxsaXNlY29uZDogMFxufSxcbiAgICBkZWZhdWx0T3JkaW5hbFVuaXRWYWx1ZXMgPSB7XG4gIG9yZGluYWw6IDEsXG4gIGhvdXI6IDAsXG4gIG1pbnV0ZTogMCxcbiAgc2Vjb25kOiAwLFxuICBtaWxsaXNlY29uZDogMFxufTsgLy8gVW5pdHMgaW4gdGhlIHN1cHBvcnRlZCBjYWxlbmRhcnMsIHNvcnRlZCBieSBiaWduZXNzXG5cbnZhciBvcmRlcmVkVW5pdHMkMSA9IFtcInllYXJcIiwgXCJtb250aFwiLCBcImRheVwiLCBcImhvdXJcIiwgXCJtaW51dGVcIiwgXCJzZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiXSxcbiAgICBvcmRlcmVkV2Vla1VuaXRzID0gW1wid2Vla1llYXJcIiwgXCJ3ZWVrTnVtYmVyXCIsIFwid2Vla2RheVwiLCBcImhvdXJcIiwgXCJtaW51dGVcIiwgXCJzZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiXSxcbiAgICBvcmRlcmVkT3JkaW5hbFVuaXRzID0gW1wieWVhclwiLCBcIm9yZGluYWxcIiwgXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwibWlsbGlzZWNvbmRcIl07IC8vIHN0YW5kYXJkaXplIGNhc2UgYW5kIHBsdXJhbGl0eSBpbiB1bml0c1xuXG5mdW5jdGlvbiBub3JtYWxpemVVbml0KHVuaXQpIHtcbiAgdmFyIG5vcm1hbGl6ZWQgPSB7XG4gICAgeWVhcjogXCJ5ZWFyXCIsXG4gICAgeWVhcnM6IFwieWVhclwiLFxuICAgIG1vbnRoOiBcIm1vbnRoXCIsXG4gICAgbW9udGhzOiBcIm1vbnRoXCIsXG4gICAgZGF5OiBcImRheVwiLFxuICAgIGRheXM6IFwiZGF5XCIsXG4gICAgaG91cjogXCJob3VyXCIsXG4gICAgaG91cnM6IFwiaG91clwiLFxuICAgIG1pbnV0ZTogXCJtaW51dGVcIixcbiAgICBtaW51dGVzOiBcIm1pbnV0ZVwiLFxuICAgIHF1YXJ0ZXI6IFwicXVhcnRlclwiLFxuICAgIHF1YXJ0ZXJzOiBcInF1YXJ0ZXJcIixcbiAgICBzZWNvbmQ6IFwic2Vjb25kXCIsXG4gICAgc2Vjb25kczogXCJzZWNvbmRcIixcbiAgICBtaWxsaXNlY29uZDogXCJtaWxsaXNlY29uZFwiLFxuICAgIG1pbGxpc2Vjb25kczogXCJtaWxsaXNlY29uZFwiLFxuICAgIHdlZWtkYXk6IFwid2Vla2RheVwiLFxuICAgIHdlZWtkYXlzOiBcIndlZWtkYXlcIixcbiAgICB3ZWVrbnVtYmVyOiBcIndlZWtOdW1iZXJcIixcbiAgICB3ZWVrc251bWJlcjogXCJ3ZWVrTnVtYmVyXCIsXG4gICAgd2Vla251bWJlcnM6IFwid2Vla051bWJlclwiLFxuICAgIHdlZWt5ZWFyOiBcIndlZWtZZWFyXCIsXG4gICAgd2Vla3llYXJzOiBcIndlZWtZZWFyXCIsXG4gICAgb3JkaW5hbDogXCJvcmRpbmFsXCJcbiAgfVt1bml0LnRvTG93ZXJDYXNlKCldO1xuICBpZiAoIW5vcm1hbGl6ZWQpIHRocm93IG5ldyBJbnZhbGlkVW5pdEVycm9yKHVuaXQpO1xuICByZXR1cm4gbm9ybWFsaXplZDtcbn0gLy8gdGhpcyBpcyBhIGR1bWJlZCBkb3duIHZlcnNpb24gb2YgZnJvbU9iamVjdCgpIHRoYXQgcnVucyBhYm91dCA2MCUgZmFzdGVyXG4vLyBidXQgZG9lc24ndCBkbyBhbnkgdmFsaWRhdGlvbiwgbWFrZXMgYSBidW5jaCBvZiBhc3N1bXB0aW9ucyBhYm91dCB3aGF0IHVuaXRzXG4vLyBhcmUgcHJlc2VudCwgYW5kIHNvIG9uLlxuXG5cbmZ1bmN0aW9uIHF1aWNrRFQob2JqLCB6b25lKSB7XG4gIC8vIGFzc3VtZSB3ZSBoYXZlIHRoZSBoaWdoZXItb3JkZXIgdW5pdHNcbiAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvcmRlcmVkVW5pdHMkMSksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgdmFyIHUgPSBfc3RlcC52YWx1ZTtcblxuICAgIGlmIChpc1VuZGVmaW5lZChvYmpbdV0pKSB7XG4gICAgICBvYmpbdV0gPSBkZWZhdWx0VW5pdFZhbHVlc1t1XTtcbiAgICB9XG4gIH1cblxuICB2YXIgaW52YWxpZCA9IGhhc0ludmFsaWRHcmVnb3JpYW5EYXRhKG9iaikgfHwgaGFzSW52YWxpZFRpbWVEYXRhKG9iaik7XG5cbiAgaWYgKGludmFsaWQpIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChpbnZhbGlkKTtcbiAgfVxuXG4gIHZhciB0c05vdyA9IFNldHRpbmdzLm5vdygpLFxuICAgICAgb2Zmc2V0UHJvdmlzID0gem9uZS5vZmZzZXQodHNOb3cpLFxuICAgICAgX29ialRvVFMgPSBvYmpUb1RTKG9iaiwgb2Zmc2V0UHJvdmlzLCB6b25lKSxcbiAgICAgIHRzID0gX29ialRvVFNbMF0sXG4gICAgICBvID0gX29ialRvVFNbMV07XG5cbiAgcmV0dXJuIG5ldyBEYXRlVGltZSh7XG4gICAgdHM6IHRzLFxuICAgIHpvbmU6IHpvbmUsXG4gICAgbzogb1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZGlmZlJlbGF0aXZlKHN0YXJ0LCBlbmQsIG9wdHMpIHtcbiAgdmFyIHJvdW5kID0gaXNVbmRlZmluZWQob3B0cy5yb3VuZCkgPyB0cnVlIDogb3B0cy5yb3VuZCxcbiAgICAgIGZvcm1hdCA9IGZ1bmN0aW9uIGZvcm1hdChjLCB1bml0KSB7XG4gICAgYyA9IHJvdW5kVG8oYywgcm91bmQgfHwgb3B0cy5jYWxlbmRhcnkgPyAwIDogMiwgdHJ1ZSk7XG4gICAgdmFyIGZvcm1hdHRlciA9IGVuZC5sb2MuY2xvbmUob3B0cykucmVsRm9ybWF0dGVyKG9wdHMpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KGMsIHVuaXQpO1xuICB9LFxuICAgICAgZGlmZmVyID0gZnVuY3Rpb24gZGlmZmVyKHVuaXQpIHtcbiAgICBpZiAob3B0cy5jYWxlbmRhcnkpIHtcbiAgICAgIGlmICghZW5kLmhhc1NhbWUoc3RhcnQsIHVuaXQpKSB7XG4gICAgICAgIHJldHVybiBlbmQuc3RhcnRPZih1bml0KS5kaWZmKHN0YXJ0LnN0YXJ0T2YodW5pdCksIHVuaXQpLmdldCh1bml0KTtcbiAgICAgIH0gZWxzZSByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVuZC5kaWZmKHN0YXJ0LCB1bml0KS5nZXQodW5pdCk7XG4gICAgfVxuICB9O1xuXG4gIGlmIChvcHRzLnVuaXQpIHtcbiAgICByZXR1cm4gZm9ybWF0KGRpZmZlcihvcHRzLnVuaXQpLCBvcHRzLnVuaXQpO1xuICB9XG5cbiAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2Uob3B0cy51bml0cyksIF9zdGVwMjsgIShfc3RlcDIgPSBfaXRlcmF0b3IyKCkpLmRvbmU7KSB7XG4gICAgdmFyIHVuaXQgPSBfc3RlcDIudmFsdWU7XG4gICAgdmFyIGNvdW50ID0gZGlmZmVyKHVuaXQpO1xuXG4gICAgaWYgKE1hdGguYWJzKGNvdW50KSA+PSAxKSB7XG4gICAgICByZXR1cm4gZm9ybWF0KGNvdW50LCB1bml0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZm9ybWF0KDAsIG9wdHMudW5pdHNbb3B0cy51bml0cy5sZW5ndGggLSAxXSk7XG59XG4vKipcbiAqIEEgRGF0ZVRpbWUgaXMgYW4gaW1tdXRhYmxlIGRhdGEgc3RydWN0dXJlIHJlcHJlc2VudGluZyBhIHNwZWNpZmljIGRhdGUgYW5kIHRpbWUgYW5kIGFjY29tcGFueWluZyBtZXRob2RzLiBJdCBjb250YWlucyBjbGFzcyBhbmQgaW5zdGFuY2UgbWV0aG9kcyBmb3IgY3JlYXRpbmcsIHBhcnNpbmcsIGludGVycm9nYXRpbmcsIHRyYW5zZm9ybWluZywgYW5kIGZvcm1hdHRpbmcgdGhlbS5cbiAqXG4gKiBBIERhdGVUaW1lIGNvbXByaXNlcyBvZjpcbiAqICogQSB0aW1lc3RhbXAuIEVhY2ggRGF0ZVRpbWUgaW5zdGFuY2UgcmVmZXJzIHRvIGEgc3BlY2lmaWMgbWlsbGlzZWNvbmQgb2YgdGhlIFVuaXggZXBvY2guXG4gKiAqIEEgdGltZSB6b25lLiBFYWNoIGluc3RhbmNlIGlzIGNvbnNpZGVyZWQgaW4gdGhlIGNvbnRleHQgb2YgYSBzcGVjaWZpYyB6b25lIChieSBkZWZhdWx0IHRoZSBsb2NhbCBzeXN0ZW0ncyB6b25lKS5cbiAqICogQ29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIHRoYXQgZWZmZWN0IGhvdyBvdXRwdXQgc3RyaW5ncyBhcmUgZm9ybWF0dGVkLCBzdWNoIGFzIGBsb2NhbGVgLCBgbnVtYmVyaW5nU3lzdGVtYCwgYW5kIGBvdXRwdXRDYWxlbmRhcmAuXG4gKlxuICogSGVyZSBpcyBhIGJyaWVmIG92ZXJ2aWV3IG9mIHRoZSBtb3N0IGNvbW1vbmx5IHVzZWQgZnVuY3Rpb25hbGl0eSBpdCBwcm92aWRlczpcbiAqXG4gKiAqICoqQ3JlYXRpb24qKjogVG8gY3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBpdHMgY29tcG9uZW50cywgdXNlIG9uZSBvZiBpdHMgZmFjdG9yeSBjbGFzcyBtZXRob2RzOiB7QGxpbmsgbG9jYWx9LCB7QGxpbmsgdXRjfSwgYW5kIChtb3N0IGZsZXhpYmx5KSB7QGxpbmsgZnJvbU9iamVjdH0uIFRvIGNyZWF0ZSBvbmUgZnJvbSBhIHN0YW5kYXJkIHN0cmluZyBmb3JtYXQsIHVzZSB7QGxpbmsgZnJvbUlTT30sIHtAbGluayBmcm9tSFRUUH0sIGFuZCB7QGxpbmsgZnJvbVJGQzI4MjJ9LiBUbyBjcmVhdGUgb25lIGZyb20gYSBjdXN0b20gc3RyaW5nIGZvcm1hdCwgdXNlIHtAbGluayBmcm9tRm9ybWF0fS4gVG8gY3JlYXRlIG9uZSBmcm9tIGEgbmF0aXZlIEpTIGRhdGUsIHVzZSB7QGxpbmsgZnJvbUpTRGF0ZX0uXG4gKiAqICoqR3JlZ29yaWFuIGNhbGVuZGFyIGFuZCB0aW1lKio6IFRvIGV4YW1pbmUgdGhlIEdyZWdvcmlhbiBwcm9wZXJ0aWVzIG9mIGEgRGF0ZVRpbWUgaW5kaXZpZHVhbGx5IChpLmUgYXMgb3Bwb3NlZCB0byBjb2xsZWN0aXZlbHkgdGhyb3VnaCB7QGxpbmsgdG9PYmplY3R9KSwgdXNlIHRoZSB7QGxpbmsgeWVhcn0sIHtAbGluayBtb250aH0sXG4gKiB7QGxpbmsgZGF5fSwge0BsaW5rIGhvdXJ9LCB7QGxpbmsgbWludXRlfSwge0BsaW5rIHNlY29uZH0sIHtAbGluayBtaWxsaXNlY29uZH0gYWNjZXNzb3JzLlxuICogKiAqKldlZWsgY2FsZW5kYXIqKjogRm9yIElTTyB3ZWVrIGNhbGVuZGFyIGF0dHJpYnV0ZXMsIHNlZSB0aGUge0BsaW5rIHdlZWtZZWFyfSwge0BsaW5rIHdlZWtOdW1iZXJ9LCBhbmQge0BsaW5rIHdlZWtkYXl9IGFjY2Vzc29ycy5cbiAqICogKipDb25maWd1cmF0aW9uKiogU2VlIHRoZSB7QGxpbmsgbG9jYWxlfSBhbmQge0BsaW5rIG51bWJlcmluZ1N5c3RlbX0gYWNjZXNzb3JzLlxuICogKiAqKlRyYW5zZm9ybWF0aW9uKio6IFRvIHRyYW5zZm9ybSB0aGUgRGF0ZVRpbWUgaW50byBvdGhlciBEYXRlVGltZXMsIHVzZSB7QGxpbmsgc2V0fSwge0BsaW5rIHJlY29uZmlndXJlfSwge0BsaW5rIHNldFpvbmV9LCB7QGxpbmsgc2V0TG9jYWxlfSwge0BsaW5rIHBsdXN9LCB7QGxpbmsgbWludXN9LCB7QGxpbmsgZW5kT2Z9LCB7QGxpbmsgc3RhcnRPZn0sIHtAbGluayB0b1VUQ30sIGFuZCB7QGxpbmsgdG9Mb2NhbH0uXG4gKiAqICoqT3V0cHV0Kio6IFRvIGNvbnZlcnQgdGhlIERhdGVUaW1lIHRvIG90aGVyIHJlcHJlc2VudGF0aW9ucywgdXNlIHRoZSB7QGxpbmsgdG9SZWxhdGl2ZX0sIHtAbGluayB0b1JlbGF0aXZlQ2FsZW5kYXJ9LCB7QGxpbmsgdG9KU09OfSwge0BsaW5rIHRvSVNPfSwge0BsaW5rIHRvSFRUUH0sIHtAbGluayB0b09iamVjdH0sIHtAbGluayB0b1JGQzI4MjJ9LCB7QGxpbmsgdG9TdHJpbmd9LCB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9LCB7QGxpbmsgdG9Gb3JtYXR9LCB7QGxpbmsgdG9NaWxsaXN9IGFuZCB7QGxpbmsgdG9KU0RhdGV9LlxuICpcbiAqIFRoZXJlJ3MgcGxlbnR5IG90aGVycyBkb2N1bWVudGVkIGJlbG93LiBJbiBhZGRpdGlvbiwgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gc3VidGxlciB0b3BpY3MgbGlrZSBpbnRlcm5hdGlvbmFsaXphdGlvbiwgdGltZSB6b25lcywgYWx0ZXJuYXRpdmUgY2FsZW5kYXJzLCB2YWxpZGl0eSwgYW5kIHNvIG9uLCBzZWUgdGhlIGV4dGVybmFsIGRvY3VtZW50YXRpb24uXG4gKi9cblxuXG52YXIgRGF0ZVRpbWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBEYXRlVGltZShjb25maWcpIHtcbiAgICB2YXIgem9uZSA9IGNvbmZpZy56b25lIHx8IFNldHRpbmdzLmRlZmF1bHRab25lO1xuICAgIHZhciBpbnZhbGlkID0gY29uZmlnLmludmFsaWQgfHwgKE51bWJlci5pc05hTihjb25maWcudHMpID8gbmV3IEludmFsaWQoXCJpbnZhbGlkIGlucHV0XCIpIDogbnVsbCkgfHwgKCF6b25lLmlzVmFsaWQgPyB1bnN1cHBvcnRlZFpvbmUoem9uZSkgOiBudWxsKTtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMudHMgPSBpc1VuZGVmaW5lZChjb25maWcudHMpID8gU2V0dGluZ3Mubm93KCkgOiBjb25maWcudHM7XG4gICAgdmFyIGMgPSBudWxsLFxuICAgICAgICBvID0gbnVsbDtcblxuICAgIGlmICghaW52YWxpZCkge1xuICAgICAgdmFyIHVuY2hhbmdlZCA9IGNvbmZpZy5vbGQgJiYgY29uZmlnLm9sZC50cyA9PT0gdGhpcy50cyAmJiBjb25maWcub2xkLnpvbmUuZXF1YWxzKHpvbmUpO1xuXG4gICAgICBpZiAodW5jaGFuZ2VkKSB7XG4gICAgICAgIHZhciBfcmVmMiA9IFtjb25maWcub2xkLmMsIGNvbmZpZy5vbGQub107XG4gICAgICAgIGMgPSBfcmVmMlswXTtcbiAgICAgICAgbyA9IF9yZWYyWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG90ID0gem9uZS5vZmZzZXQodGhpcy50cyk7XG4gICAgICAgIGMgPSB0c1RvT2JqKHRoaXMudHMsIG90KTtcbiAgICAgICAgaW52YWxpZCA9IE51bWJlci5pc05hTihjLnllYXIpID8gbmV3IEludmFsaWQoXCJpbnZhbGlkIGlucHV0XCIpIDogbnVsbDtcbiAgICAgICAgYyA9IGludmFsaWQgPyBudWxsIDogYztcbiAgICAgICAgbyA9IGludmFsaWQgPyBudWxsIDogb3Q7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICB0aGlzLl96b25lID0gem9uZTtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMubG9jID0gY29uZmlnLmxvYyB8fCBMb2NhbGUuY3JlYXRlKCk7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG5cbiAgICB0aGlzLmludmFsaWQgPSBpbnZhbGlkO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy53ZWVrRGF0YSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG5cbiAgICB0aGlzLmMgPSBjO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgdGhpcy5vID0gbztcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cblxuICAgIHRoaXMuaXNMdXhvbkRhdGVUaW1lID0gdHJ1ZTtcbiAgfSAvLyBDT05TVFJVQ1RcblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZm9yIHRoZSBjdXJyZW50IGluc3RhbnQsIGluIHRoZSBzeXN0ZW0ncyB0aW1lIHpvbmUuXG4gICAqXG4gICAqIFVzZSBTZXR0aW5ncyB0byBvdmVycmlkZSB0aGVzZSBkZWZhdWx0IHZhbHVlcyBpZiBuZWVkZWQuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKCkgLy9+PiBub3cgaW4gdGhlIElTTyBmb3JtYXRcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuXG5cbiAgRGF0ZVRpbWUubm93ID0gZnVuY3Rpb24gbm93KCkge1xuICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe30pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBsb2NhbCBEYXRlVGltZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3llYXJdIC0gVGhlIGNhbGVuZGFyIHllYXIuIElmIG9taXR0ZWQgKGFzIGluLCBjYWxsIGBsb2NhbCgpYCB3aXRoIG5vIGFyZ3VtZW50cyksIHRoZSBjdXJyZW50IHRpbWUgd2lsbCBiZSB1c2VkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbW9udGg9MV0gLSBUaGUgbW9udGgsIDEtaW5kZXhlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RheT0xXSAtIFRoZSBkYXkgb2YgdGhlIG1vbnRoLCAxLWluZGV4ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtob3VyPTBdIC0gVGhlIGhvdXIgb2YgdGhlIGRheSwgaW4gMjQtaG91ciB0aW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWludXRlPTBdIC0gVGhlIG1pbnV0ZSBvZiB0aGUgaG91ciwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2Vjb25kPTBdIC0gVGhlIHNlY29uZCBvZiB0aGUgbWludXRlLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaWxsaXNlY29uZD0wXSAtIFRoZSBtaWxsaXNlY29uZCBvZiB0aGUgc2Vjb25kLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgOTk5XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiBub3dcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNykgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDEtMDFUMDA6MDA6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMykgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMDFUMDA6MDA6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIpICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDA6MDA6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUpICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6MDA6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1KSAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCkgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCwgNzY1KSAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTAuNzY1XG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgO1xuXG4gIERhdGVUaW1lLmxvY2FsID0gZnVuY3Rpb24gbG9jYWwoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kKSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKHllYXIpKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGVUaW1lKHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHF1aWNrRFQoe1xuICAgICAgICB5ZWFyOiB5ZWFyLFxuICAgICAgICBtb250aDogbW9udGgsXG4gICAgICAgIGRheTogZGF5LFxuICAgICAgICBob3VyOiBob3VyLFxuICAgICAgICBtaW51dGU6IG1pbnV0ZSxcbiAgICAgICAgc2Vjb25kOiBzZWNvbmQsXG4gICAgICAgIG1pbGxpc2Vjb25kOiBtaWxsaXNlY29uZFxuICAgICAgfSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgaW4gVVRDXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeWVhcl0gLSBUaGUgY2FsZW5kYXIgeWVhci4gSWYgb21pdHRlZCAoYXMgaW4sIGNhbGwgYHV0YygpYCB3aXRoIG5vIGFyZ3VtZW50cyksIHRoZSBjdXJyZW50IHRpbWUgd2lsbCBiZSB1c2VkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbW9udGg9MV0gLSBUaGUgbW9udGgsIDEtaW5kZXhlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RheT0xXSAtIFRoZSBkYXkgb2YgdGhlIG1vbnRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaG91cj0wXSAtIFRoZSBob3VyIG9mIHRoZSBkYXksIGluIDI0LWhvdXIgdGltZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbnV0ZT0wXSAtIFRoZSBtaW51dGUgb2YgdGhlIGhvdXIsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1OVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NlY29uZD0wXSAtIFRoZSBzZWNvbmQgb2YgdGhlIG1pbnV0ZSwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWlsbGlzZWNvbmQ9MF0gLSBUaGUgbWlsbGlzZWNvbmQgb2YgdGhlIHNlY29uZCwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDk5OVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IG5vd1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNykgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDEtMDFUMDA6MDA6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzKSAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0wMVQwMDowMDowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyKSAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDAwOjAwOjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUpICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6MDA6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSwgNDUpICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwNTo0NTowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1LCA0NSwgMTApICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjEwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCwgNzY1KSAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTAuNzY1WlxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIDtcblxuICBEYXRlVGltZS51dGMgPSBmdW5jdGlvbiB1dGMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kKSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKHllYXIpKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGVUaW1lKHtcbiAgICAgICAgdHM6IFNldHRpbmdzLm5vdygpLFxuICAgICAgICB6b25lOiBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcXVpY2tEVCh7XG4gICAgICAgIHllYXI6IHllYXIsXG4gICAgICAgIG1vbnRoOiBtb250aCxcbiAgICAgICAgZGF5OiBkYXksXG4gICAgICAgIGhvdXI6IGhvdXIsXG4gICAgICAgIG1pbnV0ZTogbWludXRlLFxuICAgICAgICBzZWNvbmQ6IHNlY29uZCxcbiAgICAgICAgbWlsbGlzZWNvbmQ6IG1pbGxpc2Vjb25kXG4gICAgICB9LCBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIEphdmFTY3JpcHQgRGF0ZSBvYmplY3QuIFVzZXMgdGhlIGRlZmF1bHQgem9uZS5cbiAgICogQHBhcmFtIHtEYXRlfSBkYXRlIC0gYSBKYXZhU2NyaXB0IERhdGUgb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdGlvbnMuem9uZT0nbG9jYWwnXSAtIHRoZSB6b25lIHRvIHBsYWNlIHRoZSBEYXRlVGltZSBpbnRvXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgO1xuXG4gIERhdGVUaW1lLmZyb21KU0RhdGUgPSBmdW5jdGlvbiBmcm9tSlNEYXRlKGRhdGUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIHRzID0gaXNEYXRlKGRhdGUpID8gZGF0ZS52YWx1ZU9mKCkgOiBOYU47XG5cbiAgICBpZiAoTnVtYmVyLmlzTmFOKHRzKSkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXCJpbnZhbGlkIGlucHV0XCIpO1xuICAgIH1cblxuICAgIHZhciB6b25lVG9Vc2UgPSBub3JtYWxpemVab25lKG9wdGlvbnMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuXG4gICAgaWYgKCF6b25lVG9Vc2UuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQodW5zdXBwb3J0ZWRab25lKHpvbmVUb1VzZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe1xuICAgICAgdHM6IHRzLFxuICAgICAgem9uZTogem9uZVRvVXNlLFxuICAgICAgbG9jOiBMb2NhbGUuZnJvbU9iamVjdChvcHRpb25zKVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgZXBvY2ggKG1lYW5pbmcgc2luY2UgMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS4gVXNlcyB0aGUgZGVmYXVsdCB6b25lLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWlsbGlzZWNvbmRzIC0gYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIDE5NzAgVVRDXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdGlvbnMuem9uZT0nbG9jYWwnXSAtIHRoZSB6b25lIHRvIHBsYWNlIHRoZSBEYXRlVGltZSBpbnRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhbGVdIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgO1xuXG4gIERhdGVUaW1lLmZyb21NaWxsaXMgPSBmdW5jdGlvbiBmcm9tTWlsbGlzKG1pbGxpc2Vjb25kcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoIWlzTnVtYmVyKG1pbGxpc2Vjb25kcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImZyb21NaWxsaXMgcmVxdWlyZXMgYSBudW1lcmljYWwgaW5wdXQsIGJ1dCByZWNlaXZlZCBhIFwiICsgdHlwZW9mIG1pbGxpc2Vjb25kcyArIFwiIHdpdGggdmFsdWUgXCIgKyBtaWxsaXNlY29uZHMpO1xuICAgIH0gZWxzZSBpZiAobWlsbGlzZWNvbmRzIDwgLU1BWF9EQVRFIHx8IG1pbGxpc2Vjb25kcyA+IE1BWF9EQVRFKSB7XG4gICAgICAvLyB0aGlzIGlzbid0IHBlcmZlY3QgYmVjYXVzZSBiZWNhdXNlIHdlIGNhbiBzdGlsbCBlbmQgdXAgb3V0IG9mIHJhbmdlIGJlY2F1c2Ugb2YgYWRkaXRpb25hbCBzaGlmdGluZywgYnV0IGl0J3MgYSBzdGFydFxuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXCJUaW1lc3RhbXAgb3V0IG9mIHJhbmdlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IERhdGVUaW1lKHtcbiAgICAgICAgdHM6IG1pbGxpc2Vjb25kcyxcbiAgICAgICAgem9uZTogbm9ybWFsaXplWm9uZShvcHRpb25zLnpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKSxcbiAgICAgICAgbG9jOiBMb2NhbGUuZnJvbU9iamVjdChvcHRpb25zKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgdGhlIGVwb2NoIChtZWFuaW5nIHNpbmNlIDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuIFVzZXMgdGhlIGRlZmF1bHQgem9uZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlY29uZHMgLSBhIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIDE5NzAgVVRDXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdGlvbnMuem9uZT0nbG9jYWwnXSAtIHRoZSB6b25lIHRvIHBsYWNlIHRoZSBEYXRlVGltZSBpbnRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhbGVdIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgO1xuXG4gIERhdGVUaW1lLmZyb21TZWNvbmRzID0gZnVuY3Rpb24gZnJvbVNlY29uZHMoc2Vjb25kcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoIWlzTnVtYmVyKHNlY29uZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJmcm9tU2Vjb25kcyByZXF1aXJlcyBhIG51bWVyaWNhbCBpbnB1dFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZSh7XG4gICAgICAgIHRzOiBzZWNvbmRzICogMTAwMCxcbiAgICAgICAgem9uZTogbm9ybWFsaXplWm9uZShvcHRpb25zLnpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKSxcbiAgICAgICAgbG9jOiBMb2NhbGUuZnJvbU9iamVjdChvcHRpb25zKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCBrZXlzIGxpa2UgJ3llYXInIGFuZCAnaG91cicgd2l0aCByZWFzb25hYmxlIGRlZmF1bHRzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gdGhlIG9iamVjdCB0byBjcmVhdGUgdGhlIERhdGVUaW1lIGZyb21cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai55ZWFyIC0gYSB5ZWFyLCBzdWNoIGFzIDE5ODdcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5tb250aCAtIGEgbW9udGgsIDEtMTJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5kYXkgLSBhIGRheSBvZiB0aGUgbW9udGgsIDEtMzEsIGRlcGVuZGluZyBvbiB0aGUgbW9udGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5vcmRpbmFsIC0gZGF5IG9mIHRoZSB5ZWFyLCAxLTM2NSBvciAzNjZcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai53ZWVrWWVhciAtIGFuIElTTyB3ZWVrIHllYXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai53ZWVrTnVtYmVyIC0gYW4gSVNPIHdlZWsgbnVtYmVyLCBiZXR3ZWVuIDEgYW5kIDUyIG9yIDUzLCBkZXBlbmRpbmcgb24gdGhlIHllYXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai53ZWVrZGF5IC0gYW4gSVNPIHdlZWtkYXksIDEtNywgd2hlcmUgMSBpcyBNb25kYXkgYW5kIDcgaXMgU3VuZGF5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouaG91ciAtIGhvdXIgb2YgdGhlIGRheSwgMC0yM1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1pbnV0ZSAtIG1pbnV0ZSBvZiB0aGUgaG91ciwgMC01OVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnNlY29uZCAtIHNlY29uZCBvZiB0aGUgbWludXRlLCAwLTU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubWlsbGlzZWNvbmQgLSBtaWxsaXNlY29uZCBvZiB0aGUgc2Vjb25kLCAwLTk5OVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb2JqLnpvbmU9J2xvY2FsJ10gLSBpbnRlcnByZXQgdGhlIG51bWJlcnMgaW4gdGhlIGNvbnRleHQgb2YgYSBwYXJ0aWN1bGFyIHpvbmUuIENhbiB0YWtlIGFueSB2YWx1ZSB0YWtlbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gc2V0Wm9uZSgpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb2JqLmxvY2FsZT0nc3lzdGVtJ3MgbG9jYWxlJ10gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2JqLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2JqLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB5ZWFyOiAxOTgyLCBtb250aDogNSwgZGF5OiAyNX0pLnRvSVNPRGF0ZSgpIC8vPT4gJzE5ODItMDUtMjUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB5ZWFyOiAxOTgyIH0pLnRvSVNPRGF0ZSgpIC8vPT4gJzE5ODItMDEtMDEnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2IH0pIC8vfj4gdG9kYXkgYXQgMTA6MjY6MDZcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbU9iamVjdCh7IGhvdXI6IDEwLCBtaW51dGU6IDI2LCBzZWNvbmQ6IDYsIHpvbmU6ICd1dGMnIH0pLFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgaG91cjogMTAsIG1pbnV0ZTogMjYsIHNlY29uZDogNiwgem9uZTogJ2xvY2FsJyB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgaG91cjogMTAsIG1pbnV0ZTogMjYsIHNlY29uZDogNiwgem9uZTogJ0FtZXJpY2EvTmV3X1lvcmsnIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyB3ZWVrWWVhcjogMjAxNiwgd2Vla051bWJlcjogMiwgd2Vla2RheTogMyB9KS50b0lTT0RhdGUoKSAvLz0+ICcyMDE2LTAxLTEzJ1xuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIDtcblxuICBEYXRlVGltZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmopIHtcbiAgICB2YXIgem9uZVRvVXNlID0gbm9ybWFsaXplWm9uZShvYmouem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuXG4gICAgaWYgKCF6b25lVG9Vc2UuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQodW5zdXBwb3J0ZWRab25lKHpvbmVUb1VzZSkpO1xuICAgIH1cblxuICAgIHZhciB0c05vdyA9IFNldHRpbmdzLm5vdygpLFxuICAgICAgICBvZmZzZXRQcm92aXMgPSB6b25lVG9Vc2Uub2Zmc2V0KHRzTm93KSxcbiAgICAgICAgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZU9iamVjdChvYmosIG5vcm1hbGl6ZVVuaXQsIFtcInpvbmVcIiwgXCJsb2NhbGVcIiwgXCJvdXRwdXRDYWxlbmRhclwiLCBcIm51bWJlcmluZ1N5c3RlbVwiXSksXG4gICAgICAgIGNvbnRhaW5zT3JkaW5hbCA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLm9yZGluYWwpLFxuICAgICAgICBjb250YWluc0dyZWdvclllYXIgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC55ZWFyKSxcbiAgICAgICAgY29udGFpbnNHcmVnb3JNRCA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLm1vbnRoKSB8fCAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5kYXkpLFxuICAgICAgICBjb250YWluc0dyZWdvciA9IGNvbnRhaW5zR3JlZ29yWWVhciB8fCBjb250YWluc0dyZWdvck1ELFxuICAgICAgICBkZWZpbml0ZVdlZWtEZWYgPSBub3JtYWxpemVkLndlZWtZZWFyIHx8IG5vcm1hbGl6ZWQud2Vla051bWJlcixcbiAgICAgICAgbG9jID0gTG9jYWxlLmZyb21PYmplY3Qob2JqKTsgLy8gY2FzZXM6XG4gICAgLy8ganVzdCBhIHdlZWtkYXkgLT4gdGhpcyB3ZWVrJ3MgaW5zdGFuY2Ugb2YgdGhhdCB3ZWVrZGF5LCBubyB3b3JyaWVzXG4gICAgLy8gKGdyZWdvcmlhbiBkYXRhIG9yIG9yZGluYWwpICsgKHdlZWtZZWFyIG9yIHdlZWtOdW1iZXIpIC0+IGVycm9yXG4gICAgLy8gKGdyZWdvcmlhbiBtb250aCBvciBkYXkpICsgb3JkaW5hbCAtPiBlcnJvclxuICAgIC8vIG90aGVyd2lzZSBqdXN0IHVzZSB3ZWVrcyBvciBvcmRpbmFscyBvciBncmVnb3JpYW4sIGRlcGVuZGluZyBvbiB3aGF0J3Mgc3BlY2lmaWVkXG5cbiAgICBpZiAoKGNvbnRhaW5zR3JlZ29yIHx8IGNvbnRhaW5zT3JkaW5hbCkgJiYgZGVmaW5pdGVXZWVrRGVmKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXCJDYW4ndCBtaXggd2Vla1llYXIvd2Vla051bWJlciB1bml0cyB3aXRoIHllYXIvbW9udGgvZGF5IG9yIG9yZGluYWxzXCIpO1xuICAgIH1cblxuICAgIGlmIChjb250YWluc0dyZWdvck1EICYmIGNvbnRhaW5zT3JkaW5hbCkge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFwiQ2FuJ3QgbWl4IG9yZGluYWwgZGF0ZXMgd2l0aCBtb250aC9kYXlcIik7XG4gICAgfVxuXG4gICAgdmFyIHVzZVdlZWtEYXRhID0gZGVmaW5pdGVXZWVrRGVmIHx8IG5vcm1hbGl6ZWQud2Vla2RheSAmJiAhY29udGFpbnNHcmVnb3I7IC8vIGNvbmZpZ3VyZSBvdXJzZWx2ZXMgdG8gZGVhbCB3aXRoIGdyZWdvcmlhbiBkYXRlcyBvciB3ZWVrIHN0dWZmXG5cbiAgICB2YXIgdW5pdHMsXG4gICAgICAgIGRlZmF1bHRWYWx1ZXMsXG4gICAgICAgIG9iak5vdyA9IHRzVG9PYmoodHNOb3csIG9mZnNldFByb3Zpcyk7XG5cbiAgICBpZiAodXNlV2Vla0RhdGEpIHtcbiAgICAgIHVuaXRzID0gb3JkZXJlZFdlZWtVbml0cztcbiAgICAgIGRlZmF1bHRWYWx1ZXMgPSBkZWZhdWx0V2Vla1VuaXRWYWx1ZXM7XG4gICAgICBvYmpOb3cgPSBncmVnb3JpYW5Ub1dlZWsob2JqTm93KTtcbiAgICB9IGVsc2UgaWYgKGNvbnRhaW5zT3JkaW5hbCkge1xuICAgICAgdW5pdHMgPSBvcmRlcmVkT3JkaW5hbFVuaXRzO1xuICAgICAgZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRPcmRpbmFsVW5pdFZhbHVlcztcbiAgICAgIG9iak5vdyA9IGdyZWdvcmlhblRvT3JkaW5hbChvYmpOb3cpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bml0cyA9IG9yZGVyZWRVbml0cyQxO1xuICAgICAgZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRVbml0VmFsdWVzO1xuICAgIH0gLy8gc2V0IGRlZmF1bHQgdmFsdWVzIGZvciBtaXNzaW5nIHN0dWZmXG5cblxuICAgIHZhciBmb3VuZEZpcnN0ID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSh1bml0cyksIF9zdGVwMzsgIShfc3RlcDMgPSBfaXRlcmF0b3IzKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgdSA9IF9zdGVwMy52YWx1ZTtcbiAgICAgIHZhciB2ID0gbm9ybWFsaXplZFt1XTtcblxuICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2KSkge1xuICAgICAgICBmb3VuZEZpcnN0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZm91bmRGaXJzdCkge1xuICAgICAgICBub3JtYWxpemVkW3VdID0gZGVmYXVsdFZhbHVlc1t1XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vcm1hbGl6ZWRbdV0gPSBvYmpOb3dbdV07XG4gICAgICB9XG4gICAgfSAvLyBtYWtlIHN1cmUgdGhlIHZhbHVlcyB3ZSBoYXZlIGFyZSBpbiByYW5nZVxuXG5cbiAgICB2YXIgaGlnaGVyT3JkZXJJbnZhbGlkID0gdXNlV2Vla0RhdGEgPyBoYXNJbnZhbGlkV2Vla0RhdGEobm9ybWFsaXplZCkgOiBjb250YWluc09yZGluYWwgPyBoYXNJbnZhbGlkT3JkaW5hbERhdGEobm9ybWFsaXplZCkgOiBoYXNJbnZhbGlkR3JlZ29yaWFuRGF0YShub3JtYWxpemVkKSxcbiAgICAgICAgaW52YWxpZCA9IGhpZ2hlck9yZGVySW52YWxpZCB8fCBoYXNJbnZhbGlkVGltZURhdGEobm9ybWFsaXplZCk7XG5cbiAgICBpZiAoaW52YWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoaW52YWxpZCk7XG4gICAgfSAvLyBjb21wdXRlIHRoZSBhY3R1YWwgdGltZVxuXG5cbiAgICB2YXIgZ3JlZ29yaWFuID0gdXNlV2Vla0RhdGEgPyB3ZWVrVG9HcmVnb3JpYW4obm9ybWFsaXplZCkgOiBjb250YWluc09yZGluYWwgPyBvcmRpbmFsVG9HcmVnb3JpYW4obm9ybWFsaXplZCkgOiBub3JtYWxpemVkLFxuICAgICAgICBfb2JqVG9UUzIgPSBvYmpUb1RTKGdyZWdvcmlhbiwgb2Zmc2V0UHJvdmlzLCB6b25lVG9Vc2UpLFxuICAgICAgICB0c0ZpbmFsID0gX29ialRvVFMyWzBdLFxuICAgICAgICBvZmZzZXRGaW5hbCA9IF9vYmpUb1RTMlsxXSxcbiAgICAgICAgaW5zdCA9IG5ldyBEYXRlVGltZSh7XG4gICAgICB0czogdHNGaW5hbCxcbiAgICAgIHpvbmU6IHpvbmVUb1VzZSxcbiAgICAgIG86IG9mZnNldEZpbmFsLFxuICAgICAgbG9jOiBsb2NcbiAgICB9KTsgLy8gZ3JlZ29yaWFuIGRhdGEgKyB3ZWVrZGF5IHNlcnZlcyBvbmx5IHRvIHZhbGlkYXRlXG5cblxuICAgIGlmIChub3JtYWxpemVkLndlZWtkYXkgJiYgY29udGFpbnNHcmVnb3IgJiYgb2JqLndlZWtkYXkgIT09IGluc3Qud2Vla2RheSkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXCJtaXNtYXRjaGVkIHdlZWtkYXlcIiwgXCJ5b3UgY2FuJ3Qgc3BlY2lmeSBib3RoIGEgd2Vla2RheSBvZiBcIiArIG5vcm1hbGl6ZWQud2Vla2RheSArIFwiIGFuZCBhIGRhdGUgb2YgXCIgKyBpbnN0LnRvSVNPKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGFuIElTTyA4NjAxIHN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBJU08gc3RyaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSB1c2UgdGhpcyB6b25lIGlmIG5vIG9mZnNldCBpcyBzcGVjaWZpZWQgaW4gdGhlIGlucHV0IHN0cmluZyBpdHNlbGYuIFdpbGwgYWxzbyBjb252ZXJ0IHRoZSB0aW1lIHRvIHRoaXMgem9uZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCBhIGZpeGVkLW9mZnNldCB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgaWYgaXQgc3BlY2lmaWVzIG9uZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdzeXN0ZW0ncyBsb2NhbGUnXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LTA1LTI1VDA5OjA4OjM0LjEyMycpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtMDUtMjVUMDk6MDg6MzQuMTIzKzA2OjAwJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi0wNS0yNVQwOTowODozNC4xMjMrMDY6MDAnLCB7c2V0Wm9uZTogdHJ1ZX0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtMDUtMjVUMDk6MDg6MzQuMTIzJywge3pvbmU6ICd1dGMnfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi1XMDUtNCcpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgO1xuXG4gIERhdGVUaW1lLmZyb21JU08gPSBmdW5jdGlvbiBmcm9tSVNPKHRleHQsIG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuXG4gICAgdmFyIF9wYXJzZUlTT0RhdGUgPSBwYXJzZUlTT0RhdGUodGV4dCksXG4gICAgICAgIHZhbHMgPSBfcGFyc2VJU09EYXRlWzBdLFxuICAgICAgICBwYXJzZWRab25lID0gX3BhcnNlSVNPRGF0ZVsxXTtcblxuICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIFwiSVNPIDg2MDFcIiwgdGV4dCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYW4gUkZDIDI4MjIgc3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIFJGQyAyODIyIHN0cmluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gY29udmVydCB0aGUgdGltZSB0byB0aGlzIHpvbmUuIFNpbmNlIHRoZSBvZmZzZXQgaXMgYWx3YXlzIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgdGhpcyBoYXMgbm8gZWZmZWN0IG9uIHRoZSBpbnRlcnByZXRhdGlvbiBvZiBzdHJpbmcsIG1lcmVseSB0aGUgem9uZSB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGlzIGV4cHJlc3NlZCBpbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggYSBmaXhlZC1vZmZzZXQgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZyBpdHNlbGYsIGlmIGl0IHNwZWNpZmllcyBvbmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nc3lzdGVtJ3MgbG9jYWxlJ10gLSBhIGxvY2FsZSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVJGQzI4MjIoJzI1IE5vdiAyMDE2IDEzOjIzOjEyIEdNVCcpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21SRkMyODIyKCdGcmksIDI1IE5vdiAyMDE2IDEzOjIzOjEyICswNjAwJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVJGQzI4MjIoJzI1IE5vdiAyMDE2IDEzOjIzIFonKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIDtcblxuICBEYXRlVGltZS5mcm9tUkZDMjgyMiA9IGZ1bmN0aW9uIGZyb21SRkMyODIyKHRleHQsIG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuXG4gICAgdmFyIF9wYXJzZVJGQzI4MjJEYXRlID0gcGFyc2VSRkMyODIyRGF0ZSh0ZXh0KSxcbiAgICAgICAgdmFscyA9IF9wYXJzZVJGQzI4MjJEYXRlWzBdLFxuICAgICAgICBwYXJzZWRab25lID0gX3BhcnNlUkZDMjgyMkRhdGVbMV07XG5cbiAgICByZXR1cm4gcGFyc2VEYXRhVG9EYXRlVGltZSh2YWxzLCBwYXJzZWRab25lLCBvcHRzLCBcIlJGQyAyODIyXCIsIHRleHQpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGFuIEhUVFAgaGVhZGVyIGRhdGVcbiAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvUHJvdG9jb2xzL3JmYzI2MTYvcmZjMjYxNi1zZWMzLmh0bWwjc2VjMy4zLjFcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgSFRUUCBoZWFkZXIgZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gY29udmVydCB0aGUgdGltZSB0byB0aGlzIHpvbmUuIFNpbmNlIEhUVFAgZGF0ZXMgYXJlIGFsd2F5cyBpbiBVVEMsIHRoaXMgaGFzIG5vIGVmZmVjdCBvbiB0aGUgaW50ZXJwcmV0YXRpb24gb2Ygc3RyaW5nLCBtZXJlbHkgdGhlIHpvbmUgdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpcyBleHByZXNzZWQgaW4uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIHRoZSBmaXhlZC1vZmZzZXQgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZy4gRm9yIEhUVFAgZGF0ZXMsIHRoaXMgaXMgYWx3YXlzIFVUQywgc28gdGhpcyBvcHRpb24gaXMgZXF1aXZhbGVudCB0byBzZXR0aW5nIHRoZSBgem9uZWAgb3B0aW9uIHRvICd1dGMnLCBidXQgdGhpcyBvcHRpb24gaXMgaW5jbHVkZWQgZm9yIGNvbnNpc3RlbmN5IHdpdGggc2ltaWxhciBtZXRob2RzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdzeXN0ZW0ncyBsb2NhbGUnXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSFRUUCgnU3VuLCAwNiBOb3YgMTk5NCAwODo0OTozNyBHTVQnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSFRUUCgnU3VuZGF5LCAwNi1Ob3YtOTQgMDg6NDk6MzcgR01UJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUhUVFAoJ1N1biBOb3YgIDYgMDg6NDk6MzcgMTk5NCcpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgO1xuXG4gIERhdGVUaW1lLmZyb21IVFRQID0gZnVuY3Rpb24gZnJvbUhUVFAodGV4dCwgb3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgX3BhcnNlSFRUUERhdGUgPSBwYXJzZUhUVFBEYXRlKHRleHQpLFxuICAgICAgICB2YWxzID0gX3BhcnNlSFRUUERhdGVbMF0sXG4gICAgICAgIHBhcnNlZFpvbmUgPSBfcGFyc2VIVFRQRGF0ZVsxXTtcblxuICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIFwiSFRUUFwiLCBvcHRzKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhbiBpbnB1dCBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmcuXG4gICAqIERlZmF1bHRzIHRvIGVuLVVTIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHN5c3RlbSdzIGxvY2FsZS5cbiAgICogQHNlZSBodHRwczovL21vbWVudC5naXRodWIuaW8vbHV4b24vZG9jcy9tYW51YWwvcGFyc2luZy5odG1sI3RhYmxlLW9mLXRva2Vuc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgdGhlIHN0cmluZyBpcyBleHBlY3RlZCB0byBiZSBpbiAoc2VlIHRoZSBsaW5rIGJlbG93IGZvciB0aGUgZm9ybWF0cylcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIHVzZSB0aGlzIHpvbmUgaWYgbm8gb2Zmc2V0IGlzIHNwZWNpZmllZCBpbiB0aGUgaW5wdXQgc3RyaW5nIGl0c2VsZi4gV2lsbCBhbHNvIGNvbnZlcnQgdGhlIERhdGVUaW1lIHRvIHRoaXMgem9uZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCBhIHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCBpZiBpdCBzcGVjaWZpZXMgb25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSBhIGxvY2FsZSBzdHJpbmcgdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgRGF0ZVRpbWUgdG8gdGhpcyBsb2NhbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIHRvIHRoaXMgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICA7XG5cbiAgRGF0ZVRpbWUuZnJvbUZvcm1hdCA9IGZ1bmN0aW9uIGZyb21Gb3JtYXQodGV4dCwgZm10LCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChpc1VuZGVmaW5lZCh0ZXh0KSB8fCBpc1VuZGVmaW5lZChmbXQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJmcm9tRm9ybWF0IHJlcXVpcmVzIGFuIGlucHV0IHN0cmluZyBhbmQgYSBmb3JtYXRcIik7XG4gICAgfVxuXG4gICAgdmFyIF9vcHRzID0gb3B0cyxcbiAgICAgICAgX29wdHMkbG9jYWxlID0gX29wdHMubG9jYWxlLFxuICAgICAgICBsb2NhbGUgPSBfb3B0cyRsb2NhbGUgPT09IHZvaWQgMCA/IG51bGwgOiBfb3B0cyRsb2NhbGUsXG4gICAgICAgIF9vcHRzJG51bWJlcmluZ1N5c3RlbSA9IF9vcHRzLm51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgbnVtYmVyaW5nU3lzdGVtID0gX29wdHMkbnVtYmVyaW5nU3lzdGVtID09PSB2b2lkIDAgPyBudWxsIDogX29wdHMkbnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBsb2NhbGVUb1VzZSA9IExvY2FsZS5mcm9tT3B0cyh7XG4gICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgIG51bWJlcmluZ1N5c3RlbTogbnVtYmVyaW5nU3lzdGVtLFxuICAgICAgZGVmYXVsdFRvRU46IHRydWVcbiAgICB9KSxcbiAgICAgICAgX3BhcnNlRnJvbVRva2VucyA9IHBhcnNlRnJvbVRva2Vucyhsb2NhbGVUb1VzZSwgdGV4dCwgZm10KSxcbiAgICAgICAgdmFscyA9IF9wYXJzZUZyb21Ub2tlbnNbMF0sXG4gICAgICAgIHBhcnNlZFpvbmUgPSBfcGFyc2VGcm9tVG9rZW5zWzFdLFxuICAgICAgICBpbnZhbGlkID0gX3BhcnNlRnJvbVRva2Vuc1syXTtcblxuICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChpbnZhbGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgXCJmb3JtYXQgXCIgKyBmbXQsIHRleHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGZyb21Gb3JtYXQgaW5zdGVhZFxuICAgKi9cbiAgO1xuXG4gIERhdGVUaW1lLmZyb21TdHJpbmcgPSBmdW5jdGlvbiBmcm9tU3RyaW5nKHRleHQsIGZtdCwgb3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbUZvcm1hdCh0ZXh0LCBmbXQsIG9wdHMpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgU1FMIGRhdGUsIHRpbWUsIG9yIGRhdGV0aW1lXG4gICAqIERlZmF1bHRzIHRvIGVuLVVTIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHN5c3RlbSdzIGxvY2FsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIHVzZSB0aGlzIHpvbmUgaWYgbm8gb2Zmc2V0IGlzIHNwZWNpZmllZCBpbiB0aGUgaW5wdXQgc3RyaW5nIGl0c2VsZi4gV2lsbCBhbHNvIGNvbnZlcnQgdGhlIERhdGVUaW1lIHRvIHRoaXMgem9uZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCBhIHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCBpZiBpdCBzcGVjaWZpZXMgb25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSBhIGxvY2FsZSBzdHJpbmcgdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgRGF0ZVRpbWUgdG8gdGhpcyBsb2NhbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIHRvIHRoaXMgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNScpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MicpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyKzA2OjAwJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDIgQW1lcmljYS9Mb3NfQW5nZWxlcycpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyIEFtZXJpY2EvTG9zX0FuZ2VsZXMnLCB7IHNldFpvbmU6IHRydWUgfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDInLCB7IHpvbmU6ICdBbWVyaWNhL0xvc19BbmdlbGVzJyB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcwOToxMjozNC4zNDInKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIDtcblxuICBEYXRlVGltZS5mcm9tU1FMID0gZnVuY3Rpb24gZnJvbVNRTCh0ZXh0LCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBfcGFyc2VTUUwgPSBwYXJzZVNRTCh0ZXh0KSxcbiAgICAgICAgdmFscyA9IF9wYXJzZVNRTFswXSxcbiAgICAgICAgcGFyc2VkWm9uZSA9IF9wYXJzZVNRTFsxXTtcblxuICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIFwiU1FMXCIsIHRleHQpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW52YWxpZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiAtIHNpbXBsZSBzdHJpbmcgb2Ygd2h5IHRoaXMgRGF0ZVRpbWUgaXMgaW52YWxpZC4gU2hvdWxkIG5vdCBjb250YWluIHBhcmFtZXRlcnMgb3IgYW55dGhpbmcgZWxzZSBkYXRhLWRlcGVuZGVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2V4cGxhbmF0aW9uPW51bGxdIC0gbG9uZ2VyIGV4cGxhbmF0aW9uLCBtYXkgaW5jbHVkZSBwYXJhbWV0ZXJzIGFuZCBvdGhlciB1c2VmdWwgZGVidWdnaW5nIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgO1xuXG4gIERhdGVUaW1lLmludmFsaWQgPSBmdW5jdGlvbiBpbnZhbGlkKHJlYXNvbiwgZXhwbGFuYXRpb24pIHtcbiAgICBpZiAoZXhwbGFuYXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgZXhwbGFuYXRpb24gPSBudWxsO1xuICAgIH1cblxuICAgIGlmICghcmVhc29uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJuZWVkIHRvIHNwZWNpZnkgYSByZWFzb24gdGhlIERhdGVUaW1lIGlzIGludmFsaWRcIik7XG4gICAgfVxuXG4gICAgdmFyIGludmFsaWQgPSByZWFzb24gaW5zdGFuY2VvZiBJbnZhbGlkID8gcmVhc29uIDogbmV3IEludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbik7XG5cbiAgICBpZiAoU2V0dGluZ3MudGhyb3dPbkludmFsaWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkRGF0ZVRpbWVFcnJvcihpbnZhbGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZSh7XG4gICAgICAgIGludmFsaWQ6IGludmFsaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGEgRGF0ZVRpbWUuIFdvcmtzIGFjcm9zcyBjb250ZXh0IGJvdW5kYXJpZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIDtcblxuICBEYXRlVGltZS5pc0RhdGVUaW1lID0gZnVuY3Rpb24gaXNEYXRlVGltZShvKSB7XG4gICAgcmV0dXJuIG8gJiYgby5pc0x1eG9uRGF0ZVRpbWUgfHwgZmFsc2U7XG4gIH0gLy8gSU5GT1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIHVuaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gYSB1bml0IHN1Y2ggYXMgJ21pbnV0ZScgb3IgJ2RheSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNywgNCkuZ2V0KCdtb250aCcpOyAvLz0+IDdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNywgNCkuZ2V0KCdkYXknKTsgLy89PiA0XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIDtcblxuICB2YXIgX3Byb3RvID0gRGF0ZVRpbWUucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQodW5pdCkge1xuICAgIHJldHVybiB0aGlzW3VuaXRdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIERhdGVUaW1lIGlzIHZhbGlkLiBJbnZhbGlkIERhdGVUaW1lcyBvY2N1ciB3aGVuOlxuICAgKiAqIFRoZSBEYXRlVGltZSB3YXMgY3JlYXRlZCBmcm9tIGludmFsaWQgY2FsZW5kYXIgaW5mb3JtYXRpb24sIHN1Y2ggYXMgdGhlIDEzdGggbW9udGggb3IgRmVicnVhcnkgMzBcbiAgICogKiBUaGUgRGF0ZVRpbWUgd2FzIGNyZWF0ZWQgYnkgYW4gb3BlcmF0aW9uIG9uIGFub3RoZXIgaW52YWxpZCBkYXRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXNvbHZlZCBJbnRsIG9wdGlvbnMgZm9yIHRoaXMgRGF0ZVRpbWUuXG4gICAqIFRoaXMgaXMgdXNlZnVsIGluIHVuZGVyc3RhbmRpbmcgdGhlIGJlaGF2aW9yIG9mIGZvcm1hdHRpbmcgbWV0aG9kc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIHRoZSBzYW1lIG9wdGlvbnMgYXMgdG9Mb2NhbGVTdHJpbmdcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgX3Byb3RvLnJlc29sdmVkTG9jYWxlT3B0cyA9IGZ1bmN0aW9uIHJlc29sdmVkTG9jYWxlT3B0cyhvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBfRm9ybWF0dGVyJGNyZWF0ZSRyZXMgPSBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMubG9jLmNsb25lKG9wdHMpLCBvcHRzKS5yZXNvbHZlZE9wdGlvbnModGhpcyksXG4gICAgICAgIGxvY2FsZSA9IF9Gb3JtYXR0ZXIkY3JlYXRlJHJlcy5sb2NhbGUsXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbSA9IF9Gb3JtYXR0ZXIkY3JlYXRlJHJlcy5udW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIGNhbGVuZGFyID0gX0Zvcm1hdHRlciRjcmVhdGUkcmVzLmNhbGVuZGFyO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgbnVtYmVyaW5nU3lzdGVtOiBudW1iZXJpbmdTeXN0ZW0sXG4gICAgICBvdXRwdXRDYWxlbmRhcjogY2FsZW5kYXJcbiAgICB9O1xuICB9IC8vIFRSQU5TRk9STVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBEYXRlVGltZSdzIHpvbmUgdG8gVVRDLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqXG4gICAqIEVxdWl2YWxlbnQgdG8ge0BsaW5rIHNldFpvbmV9KCd1dGMnKVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldD0wXSAtIG9wdGlvbmFsbHksIGFuIG9mZnNldCBmcm9tIFVUQyBpbiBtaW51dGVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cz17fV0gLSBvcHRpb25zIHRvIHBhc3MgdG8gYHNldFpvbmUoKWBcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvVVRDID0gZnVuY3Rpb24gdG9VVEMob2Zmc2V0LCBvcHRzKSB7XG4gICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXRab25lKEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShvZmZzZXQpLCBvcHRzKTtcbiAgfVxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgRGF0ZVRpbWUncyB6b25lIHRvIHRoZSBob3N0J3MgbG9jYWwgem9uZS4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKlxuICAgKiBFcXVpdmFsZW50IHRvIGBzZXRab25lKCdsb2NhbCcpYFxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9Mb2NhbCA9IGZ1bmN0aW9uIHRvTG9jYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0Wm9uZShTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gIH1cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIERhdGVUaW1lJ3Mgem9uZSB0byBzcGVjaWZpZWQgem9uZS4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgc2V0dGVyIGtlZXBzIHRoZSB1bmRlcmx5aW5nIHRpbWUgdGhlIHNhbWUgKGFzIGluLCB0aGUgc2FtZSB0aW1lc3RhbXApLCBidXQgdGhlIG5ldyBpbnN0YW5jZSB3aWxsIHJlcG9ydCBkaWZmZXJlbnQgbG9jYWwgdGltZXMgYW5kIGNvbnNpZGVyIERTVHMgd2hlbiBtYWtpbmcgY29tcHV0YXRpb25zLCBhcyB3aXRoIHtAbGluayBwbHVzfS4gWW91IG1heSB3aXNoIHRvIHVzZSB7QGxpbmsgdG9Mb2NhbH0gYW5kIHtAbGluayB0b1VUQ30gd2hpY2ggcHJvdmlkZSBzaW1wbGUgY29udmVuaWVuY2Ugd3JhcHBlcnMgZm9yIGNvbW1vbmx5IHVzZWQgem9uZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFt6b25lPSdsb2NhbCddIC0gYSB6b25lIGlkZW50aWZpZXIuIEFzIGEgc3RyaW5nLCB0aGF0IGNhbiBiZSBhbnkgSUFOQSB6b25lIHN1cHBvcnRlZCBieSB0aGUgaG9zdCBlbnZpcm9ubWVudCwgb3IgYSBmaXhlZC1vZmZzZXQgbmFtZSBvZiB0aGUgZm9ybSAnVVRDKzMnLCBvciB0aGUgc3RyaW5ncyAnbG9jYWwnIG9yICd1dGMnLiBZb3UgbWF5IGFsc28gc3VwcGx5IGFuIGluc3RhbmNlIG9mIGEge0BsaW5rIFpvbmV9IGNsYXNzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5rZWVwTG9jYWxUaW1lPWZhbHNlXSAtIElmIHRydWUsIGFkanVzdCB0aGUgdW5kZXJseWluZyB0aW1lIHNvIHRoYXQgdGhlIGxvY2FsIHRpbWUgc3RheXMgdGhlIHNhbWUsIGJ1dCBpbiB0aGUgdGFyZ2V0IHpvbmUuIFlvdSBzaG91bGQgcmFyZWx5IG5lZWQgdGhpcy5cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnNldFpvbmUgPSBmdW5jdGlvbiBzZXRab25lKHpvbmUsIF90ZW1wKSB7XG4gICAgdmFyIF9yZWYzID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICAgIF9yZWYzJGtlZXBMb2NhbFRpbWUgPSBfcmVmMy5rZWVwTG9jYWxUaW1lLFxuICAgICAgICBrZWVwTG9jYWxUaW1lID0gX3JlZjMka2VlcExvY2FsVGltZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMyRrZWVwTG9jYWxUaW1lLFxuICAgICAgICBfcmVmMyRrZWVwQ2FsZW5kYXJUaW0gPSBfcmVmMy5rZWVwQ2FsZW5kYXJUaW1lLFxuICAgICAgICBrZWVwQ2FsZW5kYXJUaW1lID0gX3JlZjMka2VlcENhbGVuZGFyVGltID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYzJGtlZXBDYWxlbmRhclRpbTtcblxuICAgIHpvbmUgPSBub3JtYWxpemVab25lKHpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKTtcblxuICAgIGlmICh6b25lLmVxdWFscyh0aGlzLnpvbmUpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2UgaWYgKCF6b25lLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKHVuc3VwcG9ydGVkWm9uZSh6b25lKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuZXdUUyA9IHRoaXMudHM7XG5cbiAgICAgIGlmIChrZWVwTG9jYWxUaW1lIHx8IGtlZXBDYWxlbmRhclRpbWUpIHtcbiAgICAgICAgdmFyIG9mZnNldEd1ZXNzID0gem9uZS5vZmZzZXQodGhpcy50cyk7XG4gICAgICAgIHZhciBhc09iaiA9IHRoaXMudG9PYmplY3QoKTtcblxuICAgICAgICB2YXIgX29ialRvVFMzID0gb2JqVG9UUyhhc09iaiwgb2Zmc2V0R3Vlc3MsIHpvbmUpO1xuXG4gICAgICAgIG5ld1RTID0gX29ialRvVFMzWzBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvbmUkMSh0aGlzLCB7XG4gICAgICAgIHRzOiBuZXdUUyxcbiAgICAgICAgem9uZTogem9uZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3Igb3V0cHV0Q2FsZW5kYXIuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgLSB0aGUgcHJvcGVydGllcyB0byBzZXRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLnJlY29uZmlndXJlKHsgbG9jYWxlOiAnZW4tR0InIH0pXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZWNvbmZpZ3VyZSA9IGZ1bmN0aW9uIHJlY29uZmlndXJlKF90ZW1wMikge1xuICAgIHZhciBfcmVmNCA9IF90ZW1wMiA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDIsXG4gICAgICAgIGxvY2FsZSA9IF9yZWY0LmxvY2FsZSxcbiAgICAgICAgbnVtYmVyaW5nU3lzdGVtID0gX3JlZjQubnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBvdXRwdXRDYWxlbmRhciA9IF9yZWY0Lm91dHB1dENhbGVuZGFyO1xuXG4gICAgdmFyIGxvYyA9IHRoaXMubG9jLmNsb25lKHtcbiAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgbnVtYmVyaW5nU3lzdGVtOiBudW1iZXJpbmdTeXN0ZW0sXG4gICAgICBvdXRwdXRDYWxlbmRhcjogb3V0cHV0Q2FsZW5kYXJcbiAgICB9KTtcbiAgICByZXR1cm4gY2xvbmUkMSh0aGlzLCB7XG4gICAgICBsb2M6IGxvY1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSBsb2NhbGUuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICogSnVzdCBhIGNvbnZlbmllbnQgYWxpYXMgZm9yIHJlY29uZmlndXJlKHsgbG9jYWxlIH0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5zZXRMb2NhbGUoJ2VuLUdCJylcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnNldExvY2FsZSA9IGZ1bmN0aW9uIHNldExvY2FsZShsb2NhbGUpIHtcbiAgICByZXR1cm4gdGhpcy5yZWNvbmZpZ3VyZSh7XG4gICAgICBsb2NhbGU6IGxvY2FsZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSB2YWx1ZXMgb2Ygc3BlY2lmaWVkIHVuaXRzLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqIFlvdSBjYW4gb25seSBzZXQgdW5pdHMgd2l0aCB0aGlzIG1ldGhvZDsgZm9yIFwic2V0dGluZ1wiIG1ldGFkYXRhLCBzZWUge0BsaW5rIHJlY29uZmlndXJlfSBhbmQge0BsaW5rIHNldFpvbmV9LlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIC0gYSBtYXBwaW5nIG9mIHVuaXRzIHRvIG51bWJlcnNcbiAgICogQGV4YW1wbGUgZHQuc2V0KHsgeWVhcjogMjAxNyB9KVxuICAgKiBAZXhhbXBsZSBkdC5zZXQoeyBob3VyOiA4LCBtaW51dGU6IDMwIH0pXG4gICAqIEBleGFtcGxlIGR0LnNldCh7IHdlZWtkYXk6IDUgfSlcbiAgICogQGV4YW1wbGUgZHQuc2V0KHsgeWVhcjogMjAwNSwgb3JkaW5hbDogMjM0IH0pXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zZXQgPSBmdW5jdGlvbiBzZXQodmFsdWVzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIHZhciBub3JtYWxpemVkID0gbm9ybWFsaXplT2JqZWN0KHZhbHVlcywgbm9ybWFsaXplVW5pdCwgW10pLFxuICAgICAgICBzZXR0aW5nV2Vla1N0dWZmID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQud2Vla1llYXIpIHx8ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLndlZWtOdW1iZXIpIHx8ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLndlZWtkYXkpO1xuICAgIHZhciBtaXhlZDtcblxuICAgIGlmIChzZXR0aW5nV2Vla1N0dWZmKSB7XG4gICAgICBtaXhlZCA9IHdlZWtUb0dyZWdvcmlhbihPYmplY3QuYXNzaWduKGdyZWdvcmlhblRvV2Vlayh0aGlzLmMpLCBub3JtYWxpemVkKSk7XG4gICAgfSBlbHNlIGlmICghaXNVbmRlZmluZWQobm9ybWFsaXplZC5vcmRpbmFsKSkge1xuICAgICAgbWl4ZWQgPSBvcmRpbmFsVG9HcmVnb3JpYW4oT2JqZWN0LmFzc2lnbihncmVnb3JpYW5Ub09yZGluYWwodGhpcy5jKSwgbm9ybWFsaXplZCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaXhlZCA9IE9iamVjdC5hc3NpZ24odGhpcy50b09iamVjdCgpLCBub3JtYWxpemVkKTsgLy8gaWYgd2UgZGlkbid0IHNldCB0aGUgZGF5IGJ1dCB3ZSBlbmRlZCB1cCBvbiBhbiBvdmVyZmxvdyBkYXRlLFxuICAgICAgLy8gdXNlIHRoZSBsYXN0IGRheSBvZiB0aGUgcmlnaHQgbW9udGhcblxuICAgICAgaWYgKGlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQuZGF5KSkge1xuICAgICAgICBtaXhlZC5kYXkgPSBNYXRoLm1pbihkYXlzSW5Nb250aChtaXhlZC55ZWFyLCBtaXhlZC5tb250aCksIG1peGVkLmRheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9vYmpUb1RTNCA9IG9ialRvVFMobWl4ZWQsIHRoaXMubywgdGhpcy56b25lKSxcbiAgICAgICAgdHMgPSBfb2JqVG9UUzRbMF0sXG4gICAgICAgIG8gPSBfb2JqVG9UUzRbMV07XG5cbiAgICByZXR1cm4gY2xvbmUkMSh0aGlzLCB7XG4gICAgICB0czogdHMsXG4gICAgICBvOiBvXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIHBlcmlvZCBvZiB0aW1lIHRvIHRoaXMgRGF0ZVRpbWUgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lXG4gICAqXG4gICAqIEFkZGluZyBob3VycywgbWludXRlcywgc2Vjb25kcywgb3IgbWlsbGlzZWNvbmRzIGluY3JlYXNlcyB0aGUgdGltZXN0YW1wIGJ5IHRoZSByaWdodCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLiBBZGRpbmcgZGF5cywgbW9udGhzLCBvciB5ZWFycyBzaGlmdHMgdGhlIGNhbGVuZGFyLCBhY2NvdW50aW5nIGZvciBEU1RzIGFuZCBsZWFwIHllYXJzIGFsb25nIHRoZSB3YXkuIFRodXMsIGBkdC5wbHVzKHsgaG91cnM6IDI0IH0pYCBtYXkgcmVzdWx0IGluIGEgZGlmZmVyZW50IHRpbWUgdGhhbiBgZHQucGx1cyh7IGRheXM6IDEgfSlgIGlmIHRoZXJlJ3MgYSBEU1Qgc2hpZnQgaW4gYmV0d2Vlbi5cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gYWRkLiBFaXRoZXIgYSBMdXhvbiBEdXJhdGlvbiwgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCB0aGUgb2JqZWN0IGFyZ3VtZW50IHRvIER1cmF0aW9uLmZyb21PYmplY3QoKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKDEyMykgLy9+PiBpbiAxMjMgbWlsbGlzZWNvbmRzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBtaW51dGVzOiAxNSB9KSAvL34+IGluIDE1IG1pbnV0ZXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkgLy9+PiB0aGlzIHRpbWUgdG9tb3Jyb3dcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IC0xIH0pIC8vfj4gdGhpcyB0aW1lIHllc3RlcmRheVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgaG91cnM6IDMsIG1pbnV0ZXM6IDEzIH0pIC8vfj4gaW4gMyBociwgMTMgbWluXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAzLCBtaW51dGVzOiAxMyB9KSkgLy9+PiBpbiAzIGhyLCAxMyBtaW5cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnBsdXMgPSBmdW5jdGlvbiBwbHVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIHZhciBkdXIgPSBmcmllbmRseUR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICByZXR1cm4gY2xvbmUkMSh0aGlzLCBhZGp1c3RUaW1lKHRoaXMsIGR1cikpO1xuICB9XG4gIC8qKlxuICAgKiBTdWJ0cmFjdCBhIHBlcmlvZCBvZiB0aW1lIHRvIHRoaXMgRGF0ZVRpbWUgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lXG4gICAqIFNlZSB7QGxpbmsgcGx1c31cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gc3VidHJhY3QuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICBAcmV0dXJuIHtEYXRlVGltZX1cbiAgKi9cbiAgO1xuXG4gIF9wcm90by5taW51cyA9IGZ1bmN0aW9uIG1pbnVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIHZhciBkdXIgPSBmcmllbmRseUR1cmF0aW9uKGR1cmF0aW9uKS5uZWdhdGUoKTtcbiAgICByZXR1cm4gY2xvbmUkMSh0aGlzLCBhZGp1c3RUaW1lKHRoaXMsIGR1cikpO1xuICB9XG4gIC8qKlxuICAgKiBcIlNldFwiIHRoaXMgRGF0ZVRpbWUgdG8gdGhlIGJlZ2lubmluZyBvZiBhIHVuaXQgb2YgdGltZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBUaGUgdW5pdCB0byBnbyB0byB0aGUgYmVnaW5uaW5nIG9mLiBDYW4gYmUgJ3llYXInLCAncXVhcnRlcicsICdtb250aCcsICd3ZWVrJywgJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLCBvciAnbWlsbGlzZWNvbmQnLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5zdGFydE9mKCdtb250aCcpLnRvSVNPRGF0ZSgpOyAvLz0+ICcyMDE0LTAzLTAxJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5zdGFydE9mKCd5ZWFyJykudG9JU09EYXRlKCk7IC8vPT4gJzIwMTQtMDEtMDEnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLnN0YXJ0T2YoJ3dlZWsnKS50b0lTT0RhdGUoKTsgLy89PiAnMjAxNC0wMy0wMycsIHdlZWtzIGFsd2F5cyBzdGFydCBvbiBNb25kYXlzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5zdGFydE9mKCdkYXknKS50b0lTT1RpbWUoKTsgLy89PiAnMDA6MDAuMDAwLTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzLCA1LCAzMCkuc3RhcnRPZignaG91cicpLnRvSVNPVGltZSgpOyAvLz0+ICcwNTowMDowMC4wMDAtMDU6MDAnXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zdGFydE9mID0gZnVuY3Rpb24gc3RhcnRPZih1bml0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIHZhciBvID0ge30sXG4gICAgICAgIG5vcm1hbGl6ZWRVbml0ID0gRHVyYXRpb24ubm9ybWFsaXplVW5pdCh1bml0KTtcblxuICAgIHN3aXRjaCAobm9ybWFsaXplZFVuaXQpIHtcbiAgICAgIGNhc2UgXCJ5ZWFyc1wiOlxuICAgICAgICBvLm1vbnRoID0gMTtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcblxuICAgICAgY2FzZSBcInF1YXJ0ZXJzXCI6XG4gICAgICBjYXNlIFwibW9udGhzXCI6XG4gICAgICAgIG8uZGF5ID0gMTtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcblxuICAgICAgY2FzZSBcIndlZWtzXCI6XG4gICAgICBjYXNlIFwiZGF5c1wiOlxuICAgICAgICBvLmhvdXIgPSAwO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuXG4gICAgICBjYXNlIFwiaG91cnNcIjpcbiAgICAgICAgby5taW51dGUgPSAwO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuXG4gICAgICBjYXNlIFwibWludXRlc1wiOlxuICAgICAgICBvLnNlY29uZCA9IDA7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG5cbiAgICAgIGNhc2UgXCJzZWNvbmRzXCI6XG4gICAgICAgIG8ubWlsbGlzZWNvbmQgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIG5vIGRlZmF1bHQsIGludmFsaWQgdW5pdHMgdGhyb3cgaW4gbm9ybWFsaXplVW5pdCgpXG4gICAgfVxuXG4gICAgaWYgKG5vcm1hbGl6ZWRVbml0ID09PSBcIndlZWtzXCIpIHtcbiAgICAgIG8ud2Vla2RheSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKG5vcm1hbGl6ZWRVbml0ID09PSBcInF1YXJ0ZXJzXCIpIHtcbiAgICAgIHZhciBxID0gTWF0aC5jZWlsKHRoaXMubW9udGggLyAzKTtcbiAgICAgIG8ubW9udGggPSAocSAtIDEpICogMyArIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2V0KG8pO1xuICB9XG4gIC8qKlxuICAgKiBcIlNldFwiIHRoaXMgRGF0ZVRpbWUgdG8gdGhlIGVuZCAobWVhbmluZyB0aGUgbGFzdCBtaWxsaXNlY29uZCkgb2YgYSB1bml0IG9mIHRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBUaGUgdW5pdCB0byBnbyB0byB0aGUgZW5kIG9mLiBDYW4gYmUgJ3llYXInLCAncXVhcnRlcicsICdtb250aCcsICd3ZWVrJywgJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLCBvciAnbWlsbGlzZWNvbmQnLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5lbmRPZignbW9udGgnKS50b0lTTygpOyAvLz0+ICcyMDE0LTAzLTMxVDIzOjU5OjU5Ljk5OS0wNTowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuZW5kT2YoJ3llYXInKS50b0lTTygpOyAvLz0+ICcyMDE0LTEyLTMxVDIzOjU5OjU5Ljk5OS0wNTowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMykuZW5kT2YoJ3dlZWsnKS50b0lTTygpOyAvLyA9PiAnMjAxNC0wMy0wOVQyMzo1OTo1OS45OTktMDU6MDAnLCB3ZWVrcyBzdGFydCBvbiBNb25kYXlzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5lbmRPZignZGF5JykudG9JU08oKTsgLy89PiAnMjAxNC0wMy0wM1QyMzo1OTo1OS45OTktMDU6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5lbmRPZignaG91cicpLnRvSVNPKCk7IC8vPT4gJzIwMTQtMDMtMDNUMDU6NTk6NTkuOTk5LTA1OjAwJ1xuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZW5kT2YgPSBmdW5jdGlvbiBlbmRPZih1bml0KSB7XG4gICAgdmFyIF90aGlzJHBsdXM7XG5cbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5wbHVzKChfdGhpcyRwbHVzID0ge30sIF90aGlzJHBsdXNbdW5pdF0gPSAxLCBfdGhpcyRwbHVzKSkuc3RhcnRPZih1bml0KS5taW51cygxKSA6IHRoaXM7XG4gIH0gLy8gT1VUUFVUXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgZm9ybWF0IHN0cmluZy5cbiAgICogKipZb3UgbWF5IG5vdCB3YW50IHRoaXMuKiogU2VlIHtAbGluayB0b0xvY2FsZVN0cmluZ30gZm9yIGEgbW9yZSBmbGV4aWJsZSBmb3JtYXR0aW5nIHRvb2wuIEZvciBhIHRhYmxlIG9mIHRva2VucyBhbmQgdGhlaXIgaW50ZXJwcmV0YXRpb25zLCBzZWUgW2hlcmVdKGh0dHBzOi8vbW9tZW50LmdpdGh1Yi5pby9sdXhvbi9kb2NzL21hbnVhbC9mb3JtYXR0aW5nLmh0bWwjdGFibGUtb2YtdG9rZW5zKS5cbiAgICogRGVmYXVsdHMgdG8gZW4tVVMgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZCwgcmVnYXJkbGVzcyBvZiB0aGUgc3lzdGVtJ3MgbG9jYWxlLlxuICAgKiBAc2VlIGh0dHBzOi8vbW9tZW50LmdpdGh1Yi5pby9sdXhvbi9kb2NzL21hbnVhbC9mb3JtYXR0aW5nLmh0bWwjdGFibGUtb2YtdG9rZW5zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbXQgLSB0aGUgZm9ybWF0IHN0cmluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdHMgdG8gb3ZlcnJpZGUgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0Zvcm1hdCgneXl5eSBMTEwgZGQnKSAvLz0+ICcyMDE3IEFwciAyMidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuc2V0TG9jYWxlKCdmcicpLnRvRm9ybWF0KCd5eXl5IExMTCBkZCcpIC8vPT4gJzIwMTcgYXZyLiAyMidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Gb3JtYXQoJ3l5eXkgTExMIGRkJywgeyBsb2NhbGU6IFwiZnJcIiB9KSAvLz0+ICcyMDE3IGF2ci4gMjInXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvRm9ybWF0KFwiSEggJ2hvdXJzIGFuZCcgbW0gJ21pbnV0ZXMnXCIpIC8vPT4gJzIwIGhvdXJzIGFuZCA1NSBtaW51dGVzJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvRm9ybWF0ID0gZnVuY3Rpb24gdG9Gb3JtYXQoZm10LCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMubG9jLnJlZGVmYXVsdFRvRU4ob3B0cykpLmZvcm1hdERhdGVUaW1lRnJvbVN0cmluZyh0aGlzLCBmbXQpIDogSU5WQUxJRCQyO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbG9jYWxpemVkIHN0cmluZyByZXByZXNlbnRpbmcgdGhpcyBkYXRlLiBBY2NlcHRzIHRoZSBzYW1lIG9wdGlvbnMgYXMgdGhlIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3IgYW5kIGFueSBwcmVzZXRzIGRlZmluZWQgYnkgTHV4b24sIHN1Y2ggYXMgYERhdGVUaW1lLkRBVEVfRlVMTGAgb3IgYERhdGVUaW1lLlRJTUVfU0lNUExFYC5cbiAgICogVGhlIGV4YWN0IGJlaGF2aW9yIG9mIHRoaXMgbWV0aG9kIGlzIGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBpbiBnZW5lcmFsIGl0IHdpbGwgcmV0dXJuIGFuIGFwcHJvcHJpYXRlIHJlcHJlc2VudGF0aW9uXG4gICAqIG9mIHRoZSBEYXRlVGltZSBpbiB0aGUgYXNzaWduZWQgbG9jYWxlLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdFxuICAgKiBAcGFyYW0gb3B0cyB7T2JqZWN0fSAtIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3Igb3B0aW9ucyBhbmQgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKCk7IC8vPT4gNC8yMC8yMDE3XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnNldExvY2FsZSgnZW4tZ2InKS50b0xvY2FsZVN0cmluZygpOyAvLz0+ICcyMC8wNC8yMDE3J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyh7IGxvY2FsZTogJ2VuLWdiJyB9KTsgLy89PiAnMjAvMDQvMjAxNydcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURV9GVUxMKTsgLy89PiAnQXByaWwgMjAsIDIwMTcnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLlRJTUVfU0lNUExFKTsgLy89PiAnMTE6MzIgQU0nXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVUSU1FX1NIT1JUKTsgLy89PiAnNC8yMC8yMDE3LCAxMTozMiBBTSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoeyB3ZWVrZGF5OiAnbG9uZycsIG1vbnRoOiAnbG9uZycsIGRheTogJzItZGlnaXQnIH0pOyAvLz0+ICdUaHVyc2RheSwgQXByaWwgMjAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKHsgd2Vla2RheTogJ3Nob3J0JywgbW9udGg6ICdzaG9ydCcsIGRheTogJzItZGlnaXQnLCBob3VyOiAnMi1kaWdpdCcsIG1pbnV0ZTogJzItZGlnaXQnIH0pOyAvLz0+ICdUaHUsIEFwciAyMCwgMTE6MjcgQU0nXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKHsgaG91cjogJzItZGlnaXQnLCBtaW51dGU6ICcyLWRpZ2l0JywgaG91cjEyOiBmYWxzZSB9KTsgLy89PiAnMTE6MzInXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIDtcblxuICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KF9wcm90bywgJ3RvTG9jYWxlU3RyaW5nJywgeyB2YWx1ZTogZnVuY3Rpb24gdG9Mb2NhbGVTdHJpbmcob3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSBEQVRFX1NIT1JUO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBGb3JtYXR0ZXIuY3JlYXRlKHRoaXMubG9jLmNsb25lKG9wdHMpLCBvcHRzKS5mb3JtYXREYXRlVGltZSh0aGlzKSA6IElOVkFMSUQkMjtcbiAgfX0pXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGZvcm1hdCBcInBhcnRzXCIsIG1lYW5pbmcgaW5kaXZpZHVhbCB0b2tlbnMgYWxvbmcgd2l0aCBtZXRhZGF0YS4gVGhpcyBpcyBhbGxvd3MgY2FsbGVycyB0byBwb3N0LXByb2Nlc3MgaW5kaXZpZHVhbCBzZWN0aW9ucyBvZiB0aGUgZm9ybWF0dGVkIG91dHB1dC5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXQvZm9ybWF0VG9QYXJ0c1xuICAgKiBAcGFyYW0gb3B0cyB7T2JqZWN0fSAtIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3Igb3B0aW9ucywgc2FtZSBhcyBgdG9Mb2NhbGVTdHJpbmdgLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVBhcnRzKCk7IC8vPT4gW1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ2RheScsIHZhbHVlOiAnMjUnIH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAnbGl0ZXJhbCcsIHZhbHVlOiAnLycgfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICdtb250aCcsIHZhbHVlOiAnMDUnIH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAnbGl0ZXJhbCcsIHZhbHVlOiAnLycgfSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICd5ZWFyJywgdmFsdWU6ICcxOTgyJyB9XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+IF1cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9Mb2NhbGVQYXJ0cyA9IGZ1bmN0aW9uIHRvTG9jYWxlUGFydHMob3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLmxvYy5jbG9uZShvcHRzKSwgb3B0cykuZm9ybWF0RGF0ZVRpbWVQYXJ0cyh0aGlzKSA6IFtdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc01pbGxpc2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NTZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGNob29zZSBiZXR3ZWVuIHRoZSBiYXNpYyBhbmQgZXh0ZW5kZWQgZm9ybWF0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygxOTgyLCA1LCAyNSkudG9JU08oKSAvLz0+ICcxOTgyLTA1LTI1VDAwOjAwOjAwLjAwMFonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKCkgLy89PiAnMjAxNy0wNC0yMlQyMDo0NzowNS4zMzUtMDQ6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKHsgaW5jbHVkZU9mZnNldDogZmFsc2UgfSkgLy89PiAnMjAxNy0wNC0yMlQyMDo0NzowNS4zMzUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvSVNPKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzIwMTcwNDIyVDIwNDcwNS4zMzUtMDQwMCdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b0lTTyA9IGZ1bmN0aW9uIHRvSVNPKG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRvSVNPRGF0ZShvcHRzKSArIFwiVFwiICsgdGhpcy50b0lTT1RpbWUob3B0cyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lJ3MgZGF0ZSBjb21wb25lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5mb3JtYXQ9J2V4dGVuZGVkJ10gLSBjaG9vc2UgYmV0d2VlbiB0aGUgYmFzaWMgYW5kIGV4dGVuZGVkIGZvcm1hdFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MiwgNSwgMjUpLnRvSVNPRGF0ZSgpIC8vPT4gJzE5ODItMDUtMjUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygxOTgyLCA1LCAyNSkudG9JU09EYXRlKHsgZm9ybWF0OiAnYmFzaWMnIH0pIC8vPT4gJzE5ODIwNTI1J1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvSVNPRGF0ZSA9IGZ1bmN0aW9uIHRvSVNPRGF0ZShfdGVtcDMpIHtcbiAgICB2YXIgX3JlZjUgPSBfdGVtcDMgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAzLFxuICAgICAgICBfcmVmNSRmb3JtYXQgPSBfcmVmNS5mb3JtYXQsXG4gICAgICAgIGZvcm1hdCA9IF9yZWY1JGZvcm1hdCA9PT0gdm9pZCAwID8gXCJleHRlbmRlZFwiIDogX3JlZjUkZm9ybWF0O1xuXG4gICAgdmFyIGZtdCA9IGZvcm1hdCA9PT0gXCJiYXNpY1wiID8gXCJ5eXl5TU1kZFwiIDogXCJ5eXl5LU1NLWRkXCI7XG5cbiAgICBpZiAodGhpcy55ZWFyID4gOTk5OSkge1xuICAgICAgZm10ID0gXCIrXCIgKyBmbXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvVGVjaEZvcm1hdCh0aGlzLCBmbXQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSdzIHdlZWsgZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMTk4MiwgNSwgMjUpLnRvSVNPV2Vla0RhdGUoKSAvLz0+ICcxOTgyLVcyMS0yJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvSVNPV2Vla0RhdGUgPSBmdW5jdGlvbiB0b0lTT1dlZWtEYXRlKCkge1xuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcywgXCJra2trLSdXJ1dXLWNcIik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lJ3MgdGltZSBjb21wb25lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NNaWxsaXNlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBtaWxsaXNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzU2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIHNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXQ9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJ1onIG9yICctMDQ6MDAnXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZVByZWZpeD1mYWxzZV0gLSBpbmNsdWRlIHRoZSBgVGAgcHJlZml4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5mb3JtYXQ9J2V4dGVuZGVkJ10gLSBjaG9vc2UgYmV0d2VlbiB0aGUgYmFzaWMgYW5kIGV4dGVuZGVkIGZvcm1hdFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5zZXQoeyBob3VyOiA3LCBtaW51dGU6IDM0IH0pLnRvSVNPVGltZSgpIC8vPT4gJzA3OjM0OjE5LjM2MVonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQsIHNlY29uZHM6IDAsIG1pbGxpc2Vjb25kczogMCB9KS50b0lTT1RpbWUoeyBzdXBwcmVzc1NlY29uZHM6IHRydWUgfSkgLy89PiAnMDc6MzRaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5zZXQoeyBob3VyOiA3LCBtaW51dGU6IDM0IH0pLnRvSVNPVGltZSh7IGZvcm1hdDogJ2Jhc2ljJyB9KSAvLz0+ICcwNzM0MTkuMzYxWidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkuc2V0KHsgaG91cjogNywgbWludXRlOiAzNCB9KS50b0lTT1RpbWUoeyBpbmNsdWRlUHJlZml4OiB0cnVlIH0pIC8vPT4gJ1QwNzozNDoxOS4zNjFaJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvSVNPVGltZSA9IGZ1bmN0aW9uIHRvSVNPVGltZShfdGVtcDQpIHtcbiAgICB2YXIgX3JlZjYgPSBfdGVtcDQgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA0LFxuICAgICAgICBfcmVmNiRzdXBwcmVzc01pbGxpc2UgPSBfcmVmNi5zdXBwcmVzc01pbGxpc2Vjb25kcyxcbiAgICAgICAgc3VwcHJlc3NNaWxsaXNlY29uZHMgPSBfcmVmNiRzdXBwcmVzc01pbGxpc2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjYkc3VwcHJlc3NNaWxsaXNlLFxuICAgICAgICBfcmVmNiRzdXBwcmVzc1NlY29uZHMgPSBfcmVmNi5zdXBwcmVzc1NlY29uZHMsXG4gICAgICAgIHN1cHByZXNzU2Vjb25kcyA9IF9yZWY2JHN1cHByZXNzU2Vjb25kcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmNiRzdXBwcmVzc1NlY29uZHMsXG4gICAgICAgIF9yZWY2JGluY2x1ZGVPZmZzZXQgPSBfcmVmNi5pbmNsdWRlT2Zmc2V0LFxuICAgICAgICBpbmNsdWRlT2Zmc2V0ID0gX3JlZjYkaW5jbHVkZU9mZnNldCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWY2JGluY2x1ZGVPZmZzZXQsXG4gICAgICAgIF9yZWY2JGluY2x1ZGVQcmVmaXggPSBfcmVmNi5pbmNsdWRlUHJlZml4LFxuICAgICAgICBpbmNsdWRlUHJlZml4ID0gX3JlZjYkaW5jbHVkZVByZWZpeCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmNiRpbmNsdWRlUHJlZml4LFxuICAgICAgICBfcmVmNiRmb3JtYXQgPSBfcmVmNi5mb3JtYXQsXG4gICAgICAgIGZvcm1hdCA9IF9yZWY2JGZvcm1hdCA9PT0gdm9pZCAwID8gXCJleHRlbmRlZFwiIDogX3JlZjYkZm9ybWF0O1xuXG4gICAgcmV0dXJuIHRvVGVjaFRpbWVGb3JtYXQodGhpcywge1xuICAgICAgc3VwcHJlc3NTZWNvbmRzOiBzdXBwcmVzc1NlY29uZHMsXG4gICAgICBzdXBwcmVzc01pbGxpc2Vjb25kczogc3VwcHJlc3NNaWxsaXNlY29uZHMsXG4gICAgICBpbmNsdWRlT2Zmc2V0OiBpbmNsdWRlT2Zmc2V0LFxuICAgICAgaW5jbHVkZVByZWZpeDogaW5jbHVkZVByZWZpeCxcbiAgICAgIGZvcm1hdDogZm9ybWF0XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gUkZDIDI4MjItY29tcGF0aWJsZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSwgYWx3YXlzIGluIFVUQ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNCwgNywgMTMpLnRvUkZDMjgyMigpIC8vPT4gJ1N1biwgMTMgSnVsIDIwMTQgMDA6MDA6MDAgKzAwMDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1JGQzI4MjIoKSAvLz0+ICdTdW4sIDEzIEp1bCAyMDE0IDAwOjAwOjAwIC0wNDAwJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvUkZDMjgyMiA9IGZ1bmN0aW9uIHRvUkZDMjgyMigpIHtcbiAgICByZXR1cm4gdG9UZWNoRm9ybWF0KHRoaXMsIFwiRUVFLCBkZCBMTEwgeXl5eSBISDptbTpzcyBaWlpcIiwgZmFsc2UpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBIVFRQIGhlYWRlcnMuXG4gICAqIFNwZWNpZmljYWxseSwgdGhlIHN0cmluZyBjb25mb3JtcyB0byBSRkMgMTEyMy5cbiAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvUHJvdG9jb2xzL3JmYzI2MTYvcmZjMjYxNi1zZWMzLmh0bWwjc2VjMy4zLjFcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b0hUVFAoKSAvLz0+ICdTdW4sIDEzIEp1bCAyMDE0IDAwOjAwOjAwIEdNVCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzLCAxOSkudG9IVFRQKCkgLy89PiAnU3VuLCAxMyBKdWwgMjAxNCAxOTowMDowMCBHTVQnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9IVFRQID0gZnVuY3Rpb24gdG9IVFRQKCkge1xuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcy50b1VUQygpLCBcIkVFRSwgZGQgTExMIHl5eXkgSEg6bW06c3MgJ0dNVCdcIik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIFNRTCBEYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMykudG9TUUxEYXRlKCkgLy89PiAnMjAxNC0wNy0xMydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1NRTERhdGUgPSBmdW5jdGlvbiB0b1NRTERhdGUoKSB7XG4gICAgcmV0dXJuIHRvVGVjaEZvcm1hdCh0aGlzLCBcInl5eXktTU0tZGRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIFNRTCBUaW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVab25lPWZhbHNlXSAtIGluY2x1ZGUgdGhlIHpvbmUsIHN1Y2ggYXMgJ0FtZXJpY2EvTmV3X1lvcmsnLiBPdmVycmlkZXMgaW5jbHVkZU9mZnNldC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0PXRydWVdIC0gaW5jbHVkZSB0aGUgb2Zmc2V0LCBzdWNoIGFzICdaJyBvciAnLTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS50b1NRTCgpIC8vPT4gJzA1OjE1OjE2LjM0NSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9TUUwoKSAvLz0+ICcwNToxNToxNi4zNDUgLTA0OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b1NRTCh7IGluY2x1ZGVPZmZzZXQ6IGZhbHNlIH0pIC8vPT4gJzA1OjE1OjE2LjM0NSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9TUUwoeyBpbmNsdWRlWm9uZTogZmFsc2UgfSkgLy89PiAnMDU6MTU6MTYuMzQ1IEFtZXJpY2EvTmV3X1lvcmsnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TUUxUaW1lID0gZnVuY3Rpb24gdG9TUUxUaW1lKF90ZW1wNSkge1xuICAgIHZhciBfcmVmNyA9IF90ZW1wNSA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDUsXG4gICAgICAgIF9yZWY3JGluY2x1ZGVPZmZzZXQgPSBfcmVmNy5pbmNsdWRlT2Zmc2V0LFxuICAgICAgICBpbmNsdWRlT2Zmc2V0ID0gX3JlZjckaW5jbHVkZU9mZnNldCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWY3JGluY2x1ZGVPZmZzZXQsXG4gICAgICAgIF9yZWY3JGluY2x1ZGVab25lID0gX3JlZjcuaW5jbHVkZVpvbmUsXG4gICAgICAgIGluY2x1ZGVab25lID0gX3JlZjckaW5jbHVkZVpvbmUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjckaW5jbHVkZVpvbmU7XG5cbiAgICByZXR1cm4gdG9UZWNoVGltZUZvcm1hdCh0aGlzLCB7XG4gICAgICBpbmNsdWRlT2Zmc2V0OiBpbmNsdWRlT2Zmc2V0LFxuICAgICAgaW5jbHVkZVpvbmU6IGluY2x1ZGVab25lLFxuICAgICAgc3BhY2Vab25lOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIFNRTCBEYXRlVGltZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlWm9uZT1mYWxzZV0gLSBpbmNsdWRlIHRoZSB6b25lLCBzdWNoIGFzICdBbWVyaWNhL05ld19Zb3JrJy4gT3ZlcnJpZGVzIGluY2x1ZGVPZmZzZXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b1NRTCgpIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIFonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1NRTCgpIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIC0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgNywgMTMpLnRvU1FMKHsgaW5jbHVkZU9mZnNldDogZmFsc2UgfSkgLy89PiAnMjAxNC0wNy0xMyAwMDowMDowMC4wMDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1NRTCh7IGluY2x1ZGVab25lOiB0cnVlIH0pIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwIEFtZXJpY2EvTmV3X1lvcmsnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TUUwgPSBmdW5jdGlvbiB0b1NRTChvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50b1NRTERhdGUoKSArIFwiIFwiICsgdGhpcy50b1NRTFRpbWUob3B0cyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZSBhcHByb3ByaWF0ZSBmb3IgZGVidWdnaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy50b0lTTygpIDogSU5WQUxJRCQyO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlcG9jaCBtaWxsaXNlY29uZHMgb2YgdGhpcyBEYXRlVGltZS4gQWxpYXMgb2Yge0BsaW5rIHRvTWlsbGlzfVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnZhbHVlT2YgPSBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0aGlzLnRvTWlsbGlzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVwb2NoIG1pbGxpc2Vjb25kcyBvZiB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvTWlsbGlzID0gZnVuY3Rpb24gdG9NaWxsaXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudHMgOiBOYU47XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVwb2NoIHNlY29uZHMgb2YgdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1NlY29uZHMgPSBmdW5jdGlvbiB0b1NlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudHMgLyAxMDAwIDogTmFOO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBKU09OLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b0lTTygpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgQlNPTiBzZXJpYWxpemFibGUgZXF1aXZhbGVudCB0byB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtEYXRlfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b0JTT04gPSBmdW5jdGlvbiB0b0JTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9KU0RhdGUoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGggdGhpcyBEYXRlVGltZSdzIHllYXIsIG1vbnRoLCBkYXksIGFuZCBzbyBvbi5cbiAgICogQHBhcmFtIG9wdHMgLSBvcHRpb25zIGZvciBnZW5lcmF0aW5nIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlQ29uZmlnPWZhbHNlXSAtIGluY2x1ZGUgY29uZmlndXJhdGlvbiBhdHRyaWJ1dGVzIGluIHRoZSBvdXRwdXRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9PYmplY3QoKSAvLz0+IHsgeWVhcjogMjAxNywgbW9udGg6IDQsIGRheTogMjIsIGhvdXI6IDIwLCBtaW51dGU6IDQ5LCBzZWNvbmQ6IDQyLCBtaWxsaXNlY29uZDogMjY4IH1cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB7fTtcbiAgICB2YXIgYmFzZSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYyk7XG5cbiAgICBpZiAob3B0cy5pbmNsdWRlQ29uZmlnKSB7XG4gICAgICBiYXNlLm91dHB1dENhbGVuZGFyID0gdGhpcy5vdXRwdXRDYWxlbmRhcjtcbiAgICAgIGJhc2UubnVtYmVyaW5nU3lzdGVtID0gdGhpcy5sb2MubnVtYmVyaW5nU3lzdGVtO1xuICAgICAgYmFzZS5sb2NhbGUgPSB0aGlzLmxvYy5sb2NhbGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKYXZhU2NyaXB0IERhdGUgZXF1aXZhbGVudCB0byB0aGlzIERhdGVUaW1lLlxuICAgKiBAcmV0dXJuIHtEYXRlfVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b0pTRGF0ZSA9IGZ1bmN0aW9uIHRvSlNEYXRlKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLmlzVmFsaWQgPyB0aGlzLnRzIDogTmFOKTtcbiAgfSAvLyBDT01QQVJFXG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBEYXRlVGltZXMgYXMgYSBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXJEYXRlVGltZSAtIHRoZSBEYXRlVGltZSB0byBjb21wYXJlIHRoaXMgb25lIHRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbdW5pdD1bJ21pbGxpc2Vjb25kcyddXSAtIHRoZSB1bml0IG9yIGFycmF5IG9mIHVuaXRzIChzdWNoIGFzICdob3Vycycgb3IgJ2RheXMnKSB0byBpbmNsdWRlIGluIHRoZSBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBjcmVhdGlvbiBvZiB0aGUgRHVyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBpMSA9IERhdGVUaW1lLmZyb21JU08oJzE5ODItMDUtMjVUMDk6NDUnKSxcbiAgICogICAgIGkyID0gRGF0ZVRpbWUuZnJvbUlTTygnMTk4My0xMC0xNFQxMDozMCcpO1xuICAgKiBpMi5kaWZmKGkxKS50b09iamVjdCgpIC8vPT4geyBtaWxsaXNlY29uZHM6IDQzODA3NTAwMDAwIH1cbiAgICogaTIuZGlmZihpMSwgJ2hvdXJzJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDEyMTY4Ljc1IH1cbiAgICogaTIuZGlmZihpMSwgWydtb250aHMnLCAnZGF5cyddKS50b09iamVjdCgpIC8vPT4geyBtb250aHM6IDE2LCBkYXlzOiAxOS4wMzEyNSB9XG4gICAqIGkyLmRpZmYoaTEsIFsnbW9udGhzJywgJ2RheXMnLCAnaG91cnMnXSkudG9PYmplY3QoKSAvLz0+IHsgbW9udGhzOiAxNiwgZGF5czogMTksIGhvdXJzOiAwLjc1IH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRpZmYgPSBmdW5jdGlvbiBkaWZmKG90aGVyRGF0ZVRpbWUsIHVuaXQsIG9wdHMpIHtcbiAgICBpZiAodW5pdCA9PT0gdm9pZCAwKSB7XG4gICAgICB1bml0ID0gXCJtaWxsaXNlY29uZHNcIjtcbiAgICB9XG5cbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgIW90aGVyRGF0ZVRpbWUuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQodGhpcy5pbnZhbGlkIHx8IG90aGVyRGF0ZVRpbWUuaW52YWxpZCwgXCJjcmVhdGVkIGJ5IGRpZmZpbmcgYW4gaW52YWxpZCBEYXRlVGltZVwiKTtcbiAgICB9XG5cbiAgICB2YXIgZHVyT3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZSxcbiAgICAgIG51bWJlcmluZ1N5c3RlbTogdGhpcy5udW1iZXJpbmdTeXN0ZW1cbiAgICB9LCBvcHRzKTtcblxuICAgIHZhciB1bml0cyA9IG1heWJlQXJyYXkodW5pdCkubWFwKER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQpLFxuICAgICAgICBvdGhlcklzTGF0ZXIgPSBvdGhlckRhdGVUaW1lLnZhbHVlT2YoKSA+IHRoaXMudmFsdWVPZigpLFxuICAgICAgICBlYXJsaWVyID0gb3RoZXJJc0xhdGVyID8gdGhpcyA6IG90aGVyRGF0ZVRpbWUsXG4gICAgICAgIGxhdGVyID0gb3RoZXJJc0xhdGVyID8gb3RoZXJEYXRlVGltZSA6IHRoaXMsXG4gICAgICAgIGRpZmZlZCA9IF9kaWZmKGVhcmxpZXIsIGxhdGVyLCB1bml0cywgZHVyT3B0cyk7XG5cbiAgICByZXR1cm4gb3RoZXJJc0xhdGVyID8gZGlmZmVkLm5lZ2F0ZSgpIDogZGlmZmVkO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGlzIERhdGVUaW1lIGFuZCByaWdodCBub3cuXG4gICAqIFNlZSB7QGxpbmsgZGlmZn1cbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFt1bml0PVsnbWlsbGlzZWNvbmRzJ11dIC0gdGhlIHVuaXQgb3IgdW5pdHMgdW5pdHMgKHN1Y2ggYXMgJ2hvdXJzJyBvciAnZGF5cycpIHRvIGluY2x1ZGUgaW4gdGhlIGR1cmF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgY3JlYXRpb24gb2YgdGhlIER1cmF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGlmZk5vdyA9IGZ1bmN0aW9uIGRpZmZOb3codW5pdCwgb3B0cykge1xuICAgIGlmICh1bml0ID09PSB2b2lkIDApIHtcbiAgICAgIHVuaXQgPSBcIm1pbGxpc2Vjb25kc1wiO1xuICAgIH1cblxuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kaWZmKERhdGVUaW1lLm5vdygpLCB1bml0LCBvcHRzKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFuIEludGVydmFsIHNwYW5uaW5nIGJldHdlZW4gdGhpcyBEYXRlVGltZSBhbmQgYW5vdGhlciBEYXRlVGltZVxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBvdGhlckRhdGVUaW1lIC0gdGhlIG90aGVyIGVuZCBwb2ludCBvZiB0aGUgSW50ZXJ2YWxcbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVudGlsID0gZnVuY3Rpb24gdW50aWwob3RoZXJEYXRlVGltZSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHRoaXMsIG90aGVyRGF0ZVRpbWUpIDogdGhpcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBEYXRlVGltZSBpcyBpbiB0aGUgc2FtZSB1bml0IG9mIHRpbWUgYXMgYW5vdGhlciBEYXRlVGltZS5cbiAgICogSGlnaGVyLW9yZGVyIHVuaXRzIG11c3QgYWxzbyBiZSBpZGVudGljYWwgZm9yIHRoaXMgZnVuY3Rpb24gdG8gcmV0dXJuIGB0cnVlYC5cbiAgICogTm90ZSB0aGF0IHRpbWUgem9uZXMgYXJlICoqaWdub3JlZCoqIGluIHRoaXMgY29tcGFyaXNvbiwgd2hpY2ggY29tcGFyZXMgdGhlICoqbG9jYWwqKiBjYWxlbmRhciB0aW1lLiBVc2Uge0BsaW5rIHNldFpvbmV9IHRvIGNvbnZlcnQgb25lIG9mIHRoZSBkYXRlcyBpZiBuZWVkZWQuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IG90aGVyRGF0ZVRpbWUgLSB0aGUgb3RoZXIgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSB0aGUgdW5pdCBvZiB0aW1lIHRvIGNoZWNrIHNhbWVuZXNzIG9uXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLmhhc1NhbWUob3RoZXJEVCwgJ2RheScpOyAvL34+IHRydWUgaWYgb3RoZXJEVCBpcyBpbiB0aGUgc2FtZSBjdXJyZW50IGNhbGVuZGFyIGRheVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5oYXNTYW1lID0gZnVuY3Rpb24gaGFzU2FtZShvdGhlckRhdGVUaW1lLCB1bml0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgaW5wdXRNcyA9IG90aGVyRGF0ZVRpbWUudmFsdWVPZigpO1xuICAgIHZhciBvdGhlclpvbmVEYXRlVGltZSA9IHRoaXMuc2V0Wm9uZShvdGhlckRhdGVUaW1lLnpvbmUsIHtcbiAgICAgIGtlZXBMb2NhbFRpbWU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gb3RoZXJab25lRGF0ZVRpbWUuc3RhcnRPZih1bml0KSA8PSBpbnB1dE1zICYmIGlucHV0TXMgPD0gb3RoZXJab25lRGF0ZVRpbWUuZW5kT2YodW5pdCk7XG4gIH1cbiAgLyoqXG4gICAqIEVxdWFsaXR5IGNoZWNrXG4gICAqIFR3byBEYXRlVGltZXMgYXJlIGVxdWFsIGlmZiB0aGV5IHJlcHJlc2VudCB0aGUgc2FtZSBtaWxsaXNlY29uZCwgaGF2ZSB0aGUgc2FtZSB6b25lIGFuZCBsb2NhdGlvbiwgYW5kIGFyZSBib3RoIHZhbGlkLlxuICAgKiBUbyBjb21wYXJlIGp1c3QgdGhlIG1pbGxpc2Vjb25kIHZhbHVlcywgdXNlIGArZHQxID09PSArZHQyYC5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXIgLSB0aGUgb3RoZXIgRGF0ZVRpbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCAmJiBvdGhlci5pc1ZhbGlkICYmIHRoaXMudmFsdWVPZigpID09PSBvdGhlci52YWx1ZU9mKCkgJiYgdGhpcy56b25lLmVxdWFscyhvdGhlci56b25lKSAmJiB0aGlzLmxvYy5lcXVhbHMob3RoZXIubG9jKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHRoaXMgdGltZSByZWxhdGl2ZSB0byBub3csIHN1Y2ggYXMgXCJpbiB0d28gZGF5c1wiLiBDYW4gb25seSBpbnRlcm5hdGlvbmFsaXplIGlmIHlvdXJcbiAgICogcGxhdGZvcm0gc3VwcG9ydHMgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQuIFJvdW5kcyBkb3duIGJ5IGRlZmF1bHQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgb3V0cHV0XG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IFtvcHRpb25zLmJhc2U9RGF0ZVRpbWUubm93KCldIC0gdGhlIERhdGVUaW1lIHRvIHVzZSBhcyB0aGUgYmFzaXMgdG8gd2hpY2ggdGhpcyB0aW1lIGlzIGNvbXBhcmVkLiBEZWZhdWx0cyB0byBub3cuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zdHlsZT1cImxvbmdcIl0gLSB0aGUgc3R5bGUgb2YgdW5pdHMsIG11c3QgYmUgXCJsb25nXCIsIFwic2hvcnRcIiwgb3IgXCJuYXJyb3dcIlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy51bml0IC0gdXNlIGEgc3BlY2lmaWMgdW5pdDsgaWYgb21pdHRlZCwgdGhlIG1ldGhvZCB3aWxsIHBpY2sgdGhlIHVuaXQuIFVzZSBvbmUgb2YgXCJ5ZWFyc1wiLCBcInF1YXJ0ZXJzXCIsIFwibW9udGhzXCIsIFwid2Vla3NcIiwgXCJkYXlzXCIsIFwiaG91cnNcIiwgXCJtaW51dGVzXCIsIG9yIFwic2Vjb25kc1wiXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucm91bmQ9dHJ1ZV0gLSB3aGV0aGVyIHRvIHJvdW5kIHRoZSBudW1iZXJzIGluIHRoZSBvdXRwdXQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5wYWRkaW5nPTBdIC0gcGFkZGluZyBpbiBtaWxsaXNlY29uZHMuIFRoaXMgYWxsb3dzIHlvdSB0byByb3VuZCB1cCB0aGUgcmVzdWx0IGlmIGl0IGZpdHMgaW5zaWRlIHRoZSB0aHJlc2hvbGQuIERvbid0IHVzZSBpbiBjb21iaW5hdGlvbiB3aXRoIHtyb3VuZDogZmFsc2V9IGJlY2F1c2UgdGhlIGRlY2ltYWwgb3V0cHV0IHdpbGwgaW5jbHVkZSB0aGUgcGFkZGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubG9jYWxlIC0gb3ZlcnJpZGUgdGhlIGxvY2FsZSBvZiB0aGlzIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSAtIG92ZXJyaWRlIHRoZSBudW1iZXJpbmdTeXN0ZW0gb2YgdGhpcyBEYXRlVGltZS4gVGhlIEludGwgc3lzdGVtIG1heSBjaG9vc2Ugbm90IHRvIGhvbm9yIHRoaXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZSgpIC8vPT4gXCJpbiAxIGRheVwiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnNldExvY2FsZShcImVzXCIpLnRvUmVsYXRpdmUoeyBkYXlzOiAxIH0pIC8vPT4gXCJkZW50cm8gZGUgMSBkw61hXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZSh7IGxvY2FsZTogXCJmclwiIH0pIC8vPT4gXCJkYW5zIDIzIGhldXJlc1wiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm1pbnVzKHsgZGF5czogMiB9KS50b1JlbGF0aXZlKCkgLy89PiBcIjIgZGF5cyBhZ29cIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5taW51cyh7IGRheXM6IDIgfSkudG9SZWxhdGl2ZSh7IHVuaXQ6IFwiaG91cnNcIiB9KSAvLz0+IFwiNDggaG91cnMgYWdvXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkubWludXMoeyBob3VyczogMzYgfSkudG9SZWxhdGl2ZSh7IHJvdW5kOiBmYWxzZSB9KSAvLz0+IFwiMS41IGRheXMgYWdvXCJcbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9SZWxhdGl2ZSA9IGZ1bmN0aW9uIHRvUmVsYXRpdmUob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIGJhc2UgPSBvcHRpb25zLmJhc2UgfHwgRGF0ZVRpbWUuZnJvbU9iamVjdCh7XG4gICAgICB6b25lOiB0aGlzLnpvbmVcbiAgICB9KSxcbiAgICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyA/IHRoaXMgPCBiYXNlID8gLW9wdGlvbnMucGFkZGluZyA6IG9wdGlvbnMucGFkZGluZyA6IDA7XG4gICAgcmV0dXJuIGRpZmZSZWxhdGl2ZShiYXNlLCB0aGlzLnBsdXMocGFkZGluZyksIE9iamVjdC5hc3NpZ24ob3B0aW9ucywge1xuICAgICAgbnVtZXJpYzogXCJhbHdheXNcIixcbiAgICAgIHVuaXRzOiBbXCJ5ZWFyc1wiLCBcIm1vbnRoc1wiLCBcImRheXNcIiwgXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCJdXG4gICAgfSkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZGF0ZSByZWxhdGl2ZSB0byB0b2RheSwgc3VjaCBhcyBcInllc3RlcmRheVwiIG9yIFwibmV4dCBtb250aFwiLlxuICAgKiBPbmx5IGludGVybmF0aW9uYWxpemVzIG9uIHBsYXRmb3JtcyB0aGF0IHN1cHBvcnRzIEludGwuUmVsYXRpdmVUaW1lRm9ybWF0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIG91dHB1dFxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBbb3B0aW9ucy5iYXNlPURhdGVUaW1lLm5vdygpXSAtIHRoZSBEYXRlVGltZSB0byB1c2UgYXMgdGhlIGJhc2lzIHRvIHdoaWNoIHRoaXMgdGltZSBpcyBjb21wYXJlZC4gRGVmYXVsdHMgdG8gbm93LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sb2NhbGUgLSBvdmVycmlkZSB0aGUgbG9jYWxlIG9mIHRoaXMgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudW5pdCAtIHVzZSBhIHNwZWNpZmljIHVuaXQ7IGlmIG9taXR0ZWQsIHRoZSBtZXRob2Qgd2lsbCBwaWNrIHRoZSB1bml0LiBVc2Ugb25lIG9mIFwieWVhcnNcIiwgXCJxdWFydGVyc1wiLCBcIm1vbnRoc1wiLCBcIndlZWtzXCIsIG9yIFwiZGF5c1wiXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSAtIG92ZXJyaWRlIHRoZSBudW1iZXJpbmdTeXN0ZW0gb2YgdGhpcyBEYXRlVGltZS4gVGhlIEludGwgc3lzdGVtIG1heSBjaG9vc2Ugbm90IHRvIGhvbm9yIHRoaXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZUNhbGVuZGFyKCkgLy89PiBcInRvbW9ycm93XCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuc2V0TG9jYWxlKFwiZXNcIikucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZSgpIC8vPT4gXCJcIm1hw7FhbmFcIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogMSB9KS50b1JlbGF0aXZlQ2FsZW5kYXIoeyBsb2NhbGU6IFwiZnJcIiB9KSAvLz0+IFwiZGVtYWluXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkubWludXMoeyBkYXlzOiAyIH0pLnRvUmVsYXRpdmVDYWxlbmRhcigpIC8vPT4gXCIyIGRheXMgYWdvXCJcbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9SZWxhdGl2ZUNhbGVuZGFyID0gZnVuY3Rpb24gdG9SZWxhdGl2ZUNhbGVuZGFyKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBkaWZmUmVsYXRpdmUob3B0aW9ucy5iYXNlIHx8IERhdGVUaW1lLmZyb21PYmplY3Qoe1xuICAgICAgem9uZTogdGhpcy56b25lXG4gICAgfSksIHRoaXMsIE9iamVjdC5hc3NpZ24ob3B0aW9ucywge1xuICAgICAgbnVtZXJpYzogXCJhdXRvXCIsXG4gICAgICB1bml0czogW1wieWVhcnNcIiwgXCJtb250aHNcIiwgXCJkYXlzXCJdLFxuICAgICAgY2FsZW5kYXJ5OiB0cnVlXG4gICAgfSkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG1pbiBvZiBzZXZlcmFsIGRhdGUgdGltZXNcbiAgICogQHBhcmFtIHsuLi5EYXRlVGltZX0gZGF0ZVRpbWVzIC0gdGhlIERhdGVUaW1lcyBmcm9tIHdoaWNoIHRvIGNob29zZSB0aGUgbWluaW11bVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX0gdGhlIG1pbiBEYXRlVGltZSwgb3IgdW5kZWZpbmVkIGlmIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50XG4gICAqL1xuICA7XG5cbiAgRGF0ZVRpbWUubWluID0gZnVuY3Rpb24gbWluKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBkYXRlVGltZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBkYXRlVGltZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaWYgKCFkYXRlVGltZXMuZXZlcnkoRGF0ZVRpbWUuaXNEYXRlVGltZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIm1pbiByZXF1aXJlcyBhbGwgYXJndW1lbnRzIGJlIERhdGVUaW1lc1wiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmVzdEJ5KGRhdGVUaW1lcywgZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBpLnZhbHVlT2YoKTtcbiAgICB9LCBNYXRoLm1pbik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWF4IG9mIHNldmVyYWwgZGF0ZSB0aW1lc1xuICAgKiBAcGFyYW0gey4uLkRhdGVUaW1lfSBkYXRlVGltZXMgLSB0aGUgRGF0ZVRpbWVzIGZyb20gd2hpY2ggdG8gY2hvb3NlIHRoZSBtYXhpbXVtXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfSB0aGUgbWF4IERhdGVUaW1lLCBvciB1bmRlZmluZWQgaWYgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRcbiAgICovXG4gIDtcblxuICBEYXRlVGltZS5tYXggPSBmdW5jdGlvbiBtYXgoKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBkYXRlVGltZXMgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGRhdGVUaW1lc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIGlmICghZGF0ZVRpbWVzLmV2ZXJ5KERhdGVUaW1lLmlzRGF0ZVRpbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJtYXggcmVxdWlyZXMgYWxsIGFyZ3VtZW50cyBiZSBEYXRlVGltZXNcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJlc3RCeShkYXRlVGltZXMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gaS52YWx1ZU9mKCk7XG4gICAgfSwgTWF0aC5tYXgpO1xuICB9IC8vIE1JU0NcblxuICAvKipcbiAgICogRXhwbGFpbiBob3cgYSBzdHJpbmcgd291bGQgYmUgcGFyc2VkIGJ5IGZyb21Gb3JtYXQoKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgdGhlIHN0cmluZyBpcyBleHBlY3RlZCB0byBiZSBpbiAoc2VlIGRlc2NyaXB0aW9uKVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdGFrZW4gYnkgZnJvbUZvcm1hdCgpXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIDtcblxuICBEYXRlVGltZS5mcm9tRm9ybWF0RXhwbGFpbiA9IGZ1bmN0aW9uIGZyb21Gb3JtYXRFeHBsYWluKHRleHQsIGZtdCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgICBfb3B0aW9ucyRsb2NhbGUgPSBfb3B0aW9ucy5sb2NhbGUsXG4gICAgICAgIGxvY2FsZSA9IF9vcHRpb25zJGxvY2FsZSA9PT0gdm9pZCAwID8gbnVsbCA6IF9vcHRpb25zJGxvY2FsZSxcbiAgICAgICAgX29wdGlvbnMkbnVtYmVyaW5nU3lzID0gX29wdGlvbnMubnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBudW1iZXJpbmdTeXN0ZW0gPSBfb3B0aW9ucyRudW1iZXJpbmdTeXMgPT09IHZvaWQgMCA/IG51bGwgOiBfb3B0aW9ucyRudW1iZXJpbmdTeXMsXG4gICAgICAgIGxvY2FsZVRvVXNlID0gTG9jYWxlLmZyb21PcHRzKHtcbiAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgbnVtYmVyaW5nU3lzdGVtOiBudW1iZXJpbmdTeXN0ZW0sXG4gICAgICBkZWZhdWx0VG9FTjogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBleHBsYWluRnJvbVRva2Vucyhsb2NhbGVUb1VzZSwgdGV4dCwgZm10KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGZyb21Gb3JtYXRFeHBsYWluIGluc3RlYWRcbiAgICovXG4gIDtcblxuICBEYXRlVGltZS5mcm9tU3RyaW5nRXhwbGFpbiA9IGZ1bmN0aW9uIGZyb21TdHJpbmdFeHBsYWluKHRleHQsIGZtdCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbUZvcm1hdEV4cGxhaW4odGV4dCwgZm10LCBvcHRpb25zKTtcbiAgfSAvLyBGT1JNQVQgUFJFU0VUU1xuXG4gIC8qKlxuICAgKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlIDEwLzE0LzE5ODNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIDtcblxuICBfY3JlYXRlQ2xhc3MoRGF0ZVRpbWUsIFt7XG4gICAga2V5OiBcImlzVmFsaWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmludmFsaWQgPT09IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gZXJyb3IgY29kZSBpZiB0aGlzIERhdGVUaW1lIGlzIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIERhdGVUaW1lIGlzIHZhbGlkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImludmFsaWRSZWFzb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQucmVhc29uIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyBEYXRlVGltZSBiZWNhbWUgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgRGF0ZVRpbWUgaXMgdmFsaWRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW52YWxpZEV4cGxhbmF0aW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLmV4cGxhbmF0aW9uIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsb2NhbGUgb2YgYSBEYXRlVGltZSwgc3VjaCAnZW4tR0InLiBUaGUgbG9jYWxlIGlzIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBEYXRlVGltZVxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxvY2FsZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLmxvY2FsZSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbnVtYmVyaW5nIHN5c3RlbSBvZiBhIERhdGVUaW1lLCBzdWNoICdiZW5nJy4gVGhlIG51bWJlcmluZyBzeXN0ZW0gaXMgdXNlZCB3aGVuIGZvcm1hdHRpbmcgdGhlIERhdGVUaW1lXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibnVtYmVyaW5nU3lzdGVtXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubnVtYmVyaW5nU3lzdGVtIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBvdXRwdXQgY2FsZW5kYXIgb2YgYSBEYXRlVGltZSwgc3VjaCAnaXNsYW1pYycuIFRoZSBvdXRwdXQgY2FsZW5kYXIgaXMgdXNlZCB3aGVuIGZvcm1hdHRpbmcgdGhlIERhdGVUaW1lXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib3V0cHV0Q2FsZW5kYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmxvYy5vdXRwdXRDYWxlbmRhciA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdGltZSB6b25lIGFzc29jaWF0ZWQgd2l0aCB0aGlzIERhdGVUaW1lLlxuICAgICAqIEB0eXBlIHtab25lfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiem9uZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3pvbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgdGltZSB6b25lLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ6b25lTmFtZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuem9uZS5uYW1lIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB5ZWFyXG4gICAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLnllYXIgLy89PiAyMDE3XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInllYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMueWVhciA6IE5hTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBxdWFydGVyXG4gICAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLnF1YXJ0ZXIgLy89PiAyXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInF1YXJ0ZXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBNYXRoLmNlaWwodGhpcy5jLm1vbnRoIC8gMykgOiBOYU47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbW9udGggKDEtMTIpLlxuICAgICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5tb250aCAvLz0+IDVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMubW9udGggOiBOYU47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGF5IG9mIHRoZSBtb250aCAoMS0zMGlzaCkuXG4gICAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLmRheSAvLz0+IDI1XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRheVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5kYXkgOiBOYU47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaG91ciBvZiB0aGUgZGF5ICgwLTIzKS5cbiAgICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSwgOSkuaG91ciAvLz0+IDlcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaG91clwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5ob3VyIDogTmFOO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG1pbnV0ZSBvZiB0aGUgaG91ciAoMC01OSkuXG4gICAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUsIDksIDMwKS5taW51dGUgLy89PiAzMFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtaW51dGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMubWludXRlIDogTmFOO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHNlY29uZCBvZiB0aGUgbWludXRlICgwLTU5KS5cbiAgICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSwgOSwgMzAsIDUyKS5zZWNvbmQgLy89PiA1MlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZWNvbmRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmMuc2Vjb25kIDogTmFOO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQgKDAtOTk5KS5cbiAgICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSwgOSwgMzAsIDUyLCA2NTQpLm1pbGxpc2Vjb25kIC8vPT4gNjU0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1pbGxpc2Vjb25kXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLm1pbGxpc2Vjb25kIDogTmFOO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHdlZWsgeWVhclxuICAgICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDExLCAzMSkud2Vla1llYXIgLy89PiAyMDE1XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndlZWtZZWFyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gcG9zc2libHlDYWNoZWRXZWVrRGF0YSh0aGlzKS53ZWVrWWVhciA6IE5hTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB3ZWVrIG51bWJlciBvZiB0aGUgd2VlayB5ZWFyICgxLTUyaXNoKS5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAgICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkud2Vla051bWJlciAvLz0+IDIxXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndlZWtOdW1iZXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKHRoaXMpLndlZWtOdW1iZXIgOiBOYU47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAqIDEgaXMgTW9uZGF5IGFuZCA3IGlzIFN1bmRheVxuICAgICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDExLCAzMSkud2Vla2RheSAvLz0+IDRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2Vla2RheVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHBvc3NpYmx5Q2FjaGVkV2Vla0RhdGEodGhpcykud2Vla2RheSA6IE5hTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBvcmRpbmFsIChtZWFuaW5nIHRoZSBkYXkgb2YgdGhlIHllYXIpXG4gICAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUpLm9yZGluYWwgLy89PiAxNDVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfERhdGVUaW1lfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib3JkaW5hbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IGdyZWdvcmlhblRvT3JkaW5hbCh0aGlzLmMpLm9yZGluYWwgOiBOYU47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgc2hvcnQgbW9udGggbmFtZSwgc3VjaCBhcyAnT2N0Jy5cbiAgICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAxMCwgMzApLm1vbnRoU2hvcnQgLy89PiBPY3RcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhTaG9ydFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEluZm8ubW9udGhzKFwic2hvcnRcIiwge1xuICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlXG4gICAgICB9KVt0aGlzLm1vbnRoIC0gMV0gOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGh1bWFuIHJlYWRhYmxlIGxvbmcgbW9udGggbmFtZSwgc3VjaCBhcyAnT2N0b2JlcicuXG4gICAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMTAsIDMwKS5tb250aExvbmcgLy89PiBPY3RvYmVyXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1vbnRoTG9uZ1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IEluZm8ubW9udGhzKFwibG9uZ1wiLCB7XG4gICAgICAgIGxvY2FsZTogdGhpcy5sb2NhbGVcbiAgICAgIH0pW3RoaXMubW9udGggLSAxXSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgc2hvcnQgd2Vla2RheSwgc3VjaCBhcyAnTW9uJy5cbiAgICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAxMCwgMzApLndlZWtkYXlTaG9ydCAvLz0+IE1vblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3ZWVrZGF5U2hvcnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbmZvLndlZWtkYXlzKFwic2hvcnRcIiwge1xuICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlXG4gICAgICB9KVt0aGlzLndlZWtkYXkgLSAxXSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgbG9uZyB3ZWVrZGF5LCBzdWNoIGFzICdNb25kYXknLlxuICAgICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDEwLCAzMCkud2Vla2RheUxvbmcgLy89PiBNb25kYXlcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2Vla2RheUxvbmdcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbmZvLndlZWtkYXlzKFwibG9uZ1wiLCB7XG4gICAgICAgIGxvY2FsZTogdGhpcy5sb2NhbGVcbiAgICAgIH0pW3RoaXMud2Vla2RheSAtIDFdIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBVVEMgb2Zmc2V0IG9mIHRoaXMgRGF0ZVRpbWUgaW4gbWludXRlc1xuICAgICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm9mZnNldCAvLz0+IC0yNDBcbiAgICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5vZmZzZXQgLy89PiAwXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9mZnNldFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/ICt0aGlzLm8gOiBOYU47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc2hvcnQgaHVtYW4gbmFtZSBmb3IgdGhlIHpvbmUncyBjdXJyZW50IG9mZnNldCwgZm9yIGV4YW1wbGUgXCJFU1RcIiBvciBcIkVEVFwiLlxuICAgICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvZmZzZXROYW1lU2hvcnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICh0aGlzLmlzVmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuem9uZS5vZmZzZXROYW1lKHRoaXMudHMsIHtcbiAgICAgICAgICBmb3JtYXQ6IFwic2hvcnRcIixcbiAgICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbG9uZyBodW1hbiBuYW1lIGZvciB0aGUgem9uZSdzIGN1cnJlbnQgb2Zmc2V0LCBmb3IgZXhhbXBsZSBcIkVhc3Rlcm4gU3RhbmRhcmQgVGltZVwiIG9yIFwiRWFzdGVybiBEYXlsaWdodCBUaW1lXCIuXG4gICAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9mZnNldE5hbWVMb25nXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5pc1ZhbGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnpvbmUub2Zmc2V0TmFtZSh0aGlzLnRzLCB7XG4gICAgICAgICAgZm9ybWF0OiBcImxvbmdcIixcbiAgICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB3aGV0aGVyIHRoaXMgem9uZSdzIG9mZnNldCBldmVyIGNoYW5nZXMsIGFzIGluIGEgRFNULlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNPZmZzZXRGaXhlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuem9uZS51bml2ZXJzYWwgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgd2hldGhlciB0aGUgRGF0ZVRpbWUgaXMgaW4gYSBEU1QuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc0luRFNUXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5pc09mZnNldEZpeGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZnNldCA+IHRoaXMuc2V0KHtcbiAgICAgICAgICBtb250aDogMVxuICAgICAgICB9KS5vZmZzZXQgfHwgdGhpcy5vZmZzZXQgPiB0aGlzLnNldCh7XG4gICAgICAgICAgbW9udGg6IDVcbiAgICAgICAgfSkub2Zmc2V0O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBEYXRlVGltZSBpcyBpbiBhIGxlYXAgeWVhciwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNikuaXNJbkxlYXBZZWFyIC8vPT4gdHJ1ZVxuICAgICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTMpLmlzSW5MZWFwWWVhciAvLz0+IGZhbHNlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc0luTGVhcFllYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXlzIGluIHRoaXMgRGF0ZVRpbWUncyBtb250aFxuICAgICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYsIDIpLmRheXNJbk1vbnRoIC8vPT4gMjlcbiAgICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE2LCAzKS5kYXlzSW5Nb250aCAvLz0+IDMxXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRheXNJbk1vbnRoXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyLCB0aGlzLm1vbnRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRheXMgaW4gdGhpcyBEYXRlVGltZSdzIHllYXJcbiAgICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE2KS5kYXlzSW5ZZWFyIC8vPT4gMzY2XG4gICAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxMykuZGF5c0luWWVhciAvLz0+IDM2NVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkYXlzSW5ZZWFyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gZGF5c0luWWVhcih0aGlzLnllYXIpIDogTmFOO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygd2Vla3MgaW4gdGhpcyBEYXRlVGltZSdzIHllYXJcbiAgICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAgICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDA0KS53ZWVrc0luV2Vla1llYXIgLy89PiA1M1xuICAgICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTMpLndlZWtzSW5XZWVrWWVhciAvLz0+IDUyXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndlZWtzSW5XZWVrWWVhclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHdlZWtzSW5XZWVrWWVhcih0aGlzLndlZWtZZWFyKSA6IE5hTjtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJEQVRFX1NIT1JUXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gREFURV9TSE9SVDtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0IDE0LCAxOTgzJ1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJEQVRFX01FRFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIERBVEVfTUVEO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdGcmksIE9jdCAxNCwgMTk4MydcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiREFURV9NRURfV0lUSF9XRUVLREFZXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gREFURV9NRURfV0lUSF9XRUVLREFZO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3RvYmVyIDE0LCAxOTgzJ1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJEQVRFX0ZVTExcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBEQVRFX0ZVTEw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAbGluayB0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ1R1ZXNkYXksIE9jdG9iZXIgMTQsIDE5ODMnXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIkRBVEVfSFVHRVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIERBVEVfSFVHRTtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzAgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiVElNRV9TSU1QTEVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBUSU1FX1NJTVBMRTtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiVElNRV9XSVRIX1NFQ09ORFNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBUSU1FX1dJVEhfU0VDT05EUztcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgQU0gRURUJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIlRJTUVfV0lUSF9TSE9SVF9PRkZTRVRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBUSU1FX1dJVEhfU0hPUlRfT0ZGU0VUO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBBTSBFYXN0ZXJuIERheWxpZ2h0IFRpbWUnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiVElNRV9XSVRIX0xPTkdfT0ZGU0VUXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gVElNRV9XSVRIX0xPTkdfT0ZGU0VUO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMCcsIGFsd2F5cyAyNC1ob3VyLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJUSU1FXzI0X1NJTVBMRVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFRJTUVfMjRfU0lNUExFO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMycsIGFsd2F5cyAyNC1ob3VyLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJUSU1FXzI0X1dJVEhfU0VDT05EU1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFRJTUVfMjRfV0lUSF9TRUNPTkRTO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QGxpbmsgdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBFRFQnLCBhbHdheXMgMjQtaG91ci5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAbGluayB0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEVhc3Rlcm4gRGF5bGlnaHQgVGltZScsIGFsd2F5cyAyNC1ob3VyLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJUSU1FXzI0X1dJVEhfTE9OR19PRkZTRVRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBUSU1FXzI0X1dJVEhfTE9OR19PRkZTRVQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAbGluayB0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzEwLzE0LzE5ODMsIDk6MzAgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiREFURVRJTUVfU0hPUlRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBEQVRFVElNRV9TSE9SVDtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMTAvMTQvMTk4MywgOTozMDozMyBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJEQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBEQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAbGluayB0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdCAxNCwgMTk4MywgOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJEQVRFVElNRV9NRURcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBEQVRFVElNRV9NRUQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAbGluayB0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdCAxNCwgMTk4MywgOTozMDozMyBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJEQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUztcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpLCAxNCBPY3QgMTk4MywgOTozMCBBTScuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJEQVRFVElNRV9NRURfV0lUSF9XRUVLREFZXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gREFURVRJTUVfTUVEX1dJVEhfV0VFS0RBWTtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIHRvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0b2JlciAxNCwgMTk4MywgOTozMCBBTSBFRFQnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiREFURVRJTUVfRlVMTFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIERBVEVUSU1FX0ZVTEw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAbGluayB0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdG9iZXIgMTQsIDE5ODMsIDk6MzA6MzMgQU0gRURUJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIkRBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAbGluayB0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ0ZyaWRheSwgT2N0b2JlciAxNCwgMTk4MywgOTozMCBBTSBFYXN0ZXJuIERheWxpZ2h0IFRpbWUnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiREFURVRJTUVfSFVHRVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIERBVEVUSU1FX0hVR0U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAbGluayB0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ0ZyaWRheSwgT2N0b2JlciAxNCwgMTk4MywgOTozMDozMyBBTSBFYXN0ZXJuIERheWxpZ2h0IFRpbWUnLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBEQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGF0ZVRpbWU7XG59KCk7XG5mdW5jdGlvbiBmcmllbmRseURhdGVUaW1lKGRhdGVUaW1laXNoKSB7XG4gIGlmIChEYXRlVGltZS5pc0RhdGVUaW1lKGRhdGVUaW1laXNoKSkge1xuICAgIHJldHVybiBkYXRlVGltZWlzaDtcbiAgfSBlbHNlIGlmIChkYXRlVGltZWlzaCAmJiBkYXRlVGltZWlzaC52YWx1ZU9mICYmIGlzTnVtYmVyKGRhdGVUaW1laXNoLnZhbHVlT2YoKSkpIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbUpTRGF0ZShkYXRlVGltZWlzaCk7XG4gIH0gZWxzZSBpZiAoZGF0ZVRpbWVpc2ggJiYgdHlwZW9mIGRhdGVUaW1laXNoID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmZyb21PYmplY3QoZGF0ZVRpbWVpc2gpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcIlVua25vd24gZGF0ZXRpbWUgYXJndW1lbnQ6IFwiICsgZGF0ZVRpbWVpc2ggKyBcIiwgb2YgdHlwZSBcIiArIHR5cGVvZiBkYXRlVGltZWlzaCk7XG4gIH1cbn1cblxudmFyIFZFUlNJT04gPSBcIjEuMjYuMFwiO1xuXG5leHBvcnRzLkRhdGVUaW1lID0gRGF0ZVRpbWU7XG5leHBvcnRzLkR1cmF0aW9uID0gRHVyYXRpb247XG5leHBvcnRzLkZpeGVkT2Zmc2V0Wm9uZSA9IEZpeGVkT2Zmc2V0Wm9uZTtcbmV4cG9ydHMuSUFOQVpvbmUgPSBJQU5BWm9uZTtcbmV4cG9ydHMuSW5mbyA9IEluZm87XG5leHBvcnRzLkludGVydmFsID0gSW50ZXJ2YWw7XG5leHBvcnRzLkludmFsaWRab25lID0gSW52YWxpZFpvbmU7XG5leHBvcnRzLkxvY2FsWm9uZSA9IExvY2FsWm9uZTtcbmV4cG9ydHMuU2V0dGluZ3MgPSBTZXR0aW5ncztcbmV4cG9ydHMuVkVSU0lPTiA9IFZFUlNJT047XG5leHBvcnRzLlpvbmUgPSBab25lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bHV4b24uanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cbmNvbnN0IG1heEludCA9IDIxNDc0ODM2NDc7IC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuLyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuY29uc3QgYmFzZSA9IDM2O1xuY29uc3QgdE1pbiA9IDE7XG5jb25zdCB0TWF4ID0gMjY7XG5jb25zdCBza2V3ID0gMzg7XG5jb25zdCBkYW1wID0gNzAwO1xuY29uc3QgaW5pdGlhbEJpYXMgPSA3MjtcbmNvbnN0IGluaXRpYWxOID0gMTI4OyAvLyAweDgwXG5jb25zdCBkZWxpbWl0ZXIgPSAnLSc7IC8vICdcXHgyRCdcblxuLyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cbmNvbnN0IHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vO1xuY29uc3QgcmVnZXhOb25BU0NJSSA9IC9bXlxcMC1cXHg3RV0vOyAvLyBub24tQVNDSUkgY2hhcnNcbmNvbnN0IHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2c7IC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuLyoqIEVycm9yIG1lc3NhZ2VzICovXG5jb25zdCBlcnJvcnMgPSB7XG5cdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG59O1xuXG4vKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5jb25zdCBiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW47XG5jb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG5jb25zdCBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xufVxuXG4vKipcbiAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcbiAqIGl0ZW0uXG4gKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0Y29uc3QgcmVzdWx0ID0gW107XG5cdGxldCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcbiAqIGFkZHJlc3Nlcy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG4gKiBjaGFyYWN0ZXIuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuICogZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdGNvbnN0IHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdGxldCByZXN1bHQgPSAnJztcblx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0fVxuXHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdGNvbnN0IGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRjb25zdCBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcbiAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuICogbWF0Y2hpbmcgVVRGLTE2LlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG4gKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBkZWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG4gKi9cbmZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdGNvbnN0IG91dHB1dCA9IFtdO1xuXHRsZXQgY291bnRlciA9IDA7XG5cdGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0Y29uc3QgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdC8vIEl0J3MgYSBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXIuXG5cdFx0XHRjb25zdCBleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gTG93IHN1cnJvZ2F0ZS5cblx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEl0J3MgYW4gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlXG5cdFx0XHRcdC8vIG5leHQgY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLlxuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcbiAqIEBuYW1lIGVuY29kZVxuICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cbiAqL1xuY29uc3QgdWNzMmVuY29kZSA9IGFycmF5ID0+IFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmFycmF5KTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG4gKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cbiAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcbiAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuICovXG5jb25zdCBiYXNpY1RvRGlnaXQgPSBmdW5jdGlvbihjb2RlUG9pbnQpIHtcblx0aWYgKGNvZGVQb2ludCAtIDB4MzAgPCAweDBBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4MTY7XG5cdH1cblx0aWYgKGNvZGVQb2ludCAtIDB4NDEgPCAweDFBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4NDE7XG5cdH1cblx0aWYgKGNvZGVQb2ludCAtIDB4NjEgPCAweDFBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4NjE7XG5cdH1cblx0cmV0dXJuIGJhc2U7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2VcbiAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcbiAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG4gKi9cbmNvbnN0IGRpZ2l0VG9CYXNpYyA9IGZ1bmN0aW9uKGRpZ2l0LCBmbGFnKSB7XG5cdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xufTtcblxuLyoqXG4gKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGFkYXB0ID0gZnVuY3Rpb24oZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdGxldCBrID0gMDtcblx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0fVxuXHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcbiAqIHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqL1xuY29uc3QgZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcblx0Ly8gRG9uJ3QgdXNlIFVDUy0yLlxuXHRjb25zdCBvdXRwdXQgPSBbXTtcblx0Y29uc3QgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cdGxldCBpID0gMDtcblx0bGV0IG4gPSBpbml0aWFsTjtcblx0bGV0IGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0bGV0IGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdGJhc2ljID0gMDtcblx0fVxuXG5cdGZvciAobGV0IGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHR9XG5cdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdH1cblxuXHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0Zm9yIChsZXQgaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdGxldCBvbGRpID0gaTtcblx0XHRmb3IgKGxldCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRjb25zdCB0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgb3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0fVxuXG5cdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRpICU9IG91dDtcblxuXHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXQuXG5cdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdH1cblxuXHRyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4ub3V0cHV0KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcbiAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqL1xuY29uc3QgZW5jb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcblx0Y29uc3Qgb3V0cHV0ID0gW107XG5cblx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gYW4gYXJyYXkgb2YgVW5pY29kZSBjb2RlIHBvaW50cy5cblx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHQvLyBDYWNoZSB0aGUgbGVuZ3RoLlxuXHRsZXQgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGUuXG5cdGxldCBuID0gaW5pdGlhbE47XG5cdGxldCBkZWx0YSA9IDA7XG5cdGxldCBiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50cy5cblx0Zm9yIChjb25zdCBjdXJyZW50VmFsdWUgb2YgaW5wdXQpIHtcblx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdH1cblx0fVxuXG5cdGxldCBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cdGxldCBoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoO1xuXG5cdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgd2l0aCBhIGRlbGltaXRlciB1bmxlc3MgaXQncyBlbXB0eS5cblx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0fVxuXG5cdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdGxldCBtID0gbWF4SW50O1xuXHRcdGZvciAoY29uc3QgY3VycmVudFZhbHVlIG9mIGlucHV0KSB7XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvdy5cblx0XHRjb25zdCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdH1cblxuXHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0biA9IG07XG5cblx0XHRmb3IgKGNvbnN0IGN1cnJlbnRWYWx1ZSBvZiBpbnB1dCkge1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cblx0XHRcdFx0bGV0IHEgPSBkZWx0YTtcblx0XHRcdFx0Zm9yIChsZXQgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0Y29uc3QgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29uc3QgcU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdGNvbnN0IGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQrK2RlbHRhO1xuXHRcdCsrbjtcblxuXHR9XG5cdHJldHVybiBvdXRwdXQuam9pbignJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3NcbiAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cbiAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuICogY29udmVydGVkIHRvIFVuaWNvZGUuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cbiAqIGNvbnZlcnQgdG8gVW5pY29kZS5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuICogc3RyaW5nLlxuICovXG5jb25zdCB0b1VuaWNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuXHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0OiBzdHJpbmc7XG5cdH0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cbiAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG4gKiBBU0NJSS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcbiAqIFVuaWNvZGUgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuICogZW1haWwgYWRkcmVzcy5cbiAqL1xuY29uc3QgdG9BU0NJSSA9IGZ1bmN0aW9uKGlucHV0KSB7XG5cdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0OiBzdHJpbmc7XG5cdH0pO1xufTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cbmNvbnN0IHB1bnljb2RlID0ge1xuXHQvKipcblx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqL1xuXHQndmVyc2lvbic6ICcyLjEuMCcsXG5cdC8qKlxuXHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0J3VjczInOiB7XG5cdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0fSxcblx0J2RlY29kZSc6IGRlY29kZSxcblx0J2VuY29kZSc6IGVuY29kZSxcblx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIjBcIjoge1xuICAgIFwiaW5kZXhcIjogXCIwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDAwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJCVENcIixcbiAgICBcIm5hbWVcIjogXCJCaXRjb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9iaXRjb2luLm9yZ1wiXG4gIH0sXG4gIFwiMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwMDFcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlRlc3RuZXQgKGFsbCBjb2lucylcIlxuICB9LFxuICBcIjJcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDAyXCIsXG4gICAgXCJzeW1ib2xcIjogXCJMVENcIixcbiAgICBcIm5hbWVcIjogXCJMaXRlY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbGl0ZWNvaW4ub3JnXCJcbiAgfSxcbiAgXCIzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiM1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDAwM1wiLFxuICAgIFwic3ltYm9sXCI6IFwiRE9HRVwiLFxuICAgIFwibmFtZVwiOiBcIkRvZ2Vjb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2RvZ2Vjb2luL2RvZ2Vjb2luXCJcbiAgfSxcbiAgXCI0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDAwNFwiLFxuICAgIFwic3ltYm9sXCI6IFwiUkREXCIsXG4gICAgXCJuYW1lXCI6IFwiUmVkZGNvaW5cIlxuICB9LFxuICBcIjVcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDA1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJEQVNIXCIsXG4gICAgXCJuYW1lXCI6IFwiRGFzaFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9kYXNocGF5L2Rhc2hcIlxuICB9LFxuICBcIjZcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDA2XCIsXG4gICAgXCJzeW1ib2xcIjogXCJQUENcIixcbiAgICBcIm5hbWVcIjogXCJQZWVyY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vcGVlcmNvaW4ubmV0XCJcbiAgfSxcbiAgXCI3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiN1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDAwN1wiLFxuICAgIFwic3ltYm9sXCI6IFwiTk1DXCIsXG4gICAgXCJuYW1lXCI6IFwiTmFtZWNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5uYW1lY29pbi5vcmdcIlxuICB9LFxuICBcIjhcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDA4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJGVENcIixcbiAgICBcIm5hbWVcIjogXCJGZWF0aGVyY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmZlYXRoZXJjb2luLmNvbVwiXG4gIH0sXG4gIFwiOVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwMDlcIixcbiAgICBcInN5bWJvbFwiOiBcIlhDUFwiLFxuICAgIFwibmFtZVwiOiBcIkNvdW50ZXJwYXJ0eVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vY291bnRlcnBhcnR5LmlvXCJcbiAgfSxcbiAgXCIxMFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjEwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDBhXCIsXG4gICAgXCJzeW1ib2xcIjogXCJCTEtcIixcbiAgICBcIm5hbWVcIjogXCJCbGFja2NvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2JsYWNrY29pbi5vcmdcIlxuICB9LFxuICBcIjExXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwMGJcIixcbiAgICBcInN5bWJvbFwiOiBcIk5TUlwiLFxuICAgIFwibmFtZVwiOiBcIk51U2hhcmVzXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9udWJpdHMuY29tL251c2hhcmVzL2ludHJvZHVjdGlvblwiXG4gIH0sXG4gIFwiMTJcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDAwY1wiLFxuICAgIFwic3ltYm9sXCI6IFwiTkJUXCIsXG4gICAgXCJuYW1lXCI6IFwiTnVCaXRzXCJcbiAgfSxcbiAgXCIxM1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjEzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDBkXCIsXG4gICAgXCJzeW1ib2xcIjogXCJNWkNcIixcbiAgICBcIm5hbWVcIjogXCJNYXphY29pblwiXG4gIH0sXG4gIFwiMTRcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxNFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDAwZVwiLFxuICAgIFwic3ltYm9sXCI6IFwiVklBXCIsXG4gICAgXCJuYW1lXCI6IFwiVmlhY29pblwiXG4gIH0sXG4gIFwiMTVcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxNVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDAwZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiWENIXCIsXG4gICAgXCJuYW1lXCI6IFwiQ2xlYXJpbmdIb3VzZVwiXG4gIH0sXG4gIFwiMTZcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxNlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDAxMFwiLFxuICAgIFwic3ltYm9sXCI6IFwiUkJZXCIsXG4gICAgXCJuYW1lXCI6IFwiUnVieWNvaW5cIlxuICB9LFxuICBcIjE3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwMTFcIixcbiAgICBcInN5bWJvbFwiOiBcIkdSU1wiLFxuICAgIFwibmFtZVwiOiBcIkdyb2VzdGxjb2luXCJcbiAgfSxcbiAgXCIxOFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDEyXCIsXG4gICAgXCJzeW1ib2xcIjogXCJER0NcIixcbiAgICBcIm5hbWVcIjogXCJEaWdpdGFsY29pblwiXG4gIH0sXG4gIFwiMTlcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxOVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDAxM1wiLFxuICAgIFwic3ltYm9sXCI6IFwiQ0NOXCIsXG4gICAgXCJuYW1lXCI6IFwiQ2FubmFjb2luXCJcbiAgfSxcbiAgXCIyMFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjIwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDE0XCIsXG4gICAgXCJzeW1ib2xcIjogXCJER0JcIixcbiAgICBcIm5hbWVcIjogXCJEaWdpQnl0ZVwiXG4gIH0sXG4gIFwiMjFcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyMVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDAxNVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiT3BlbiBBc3NldHNcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dpdGh1Yi5jb20vT3BlbkFzc2V0cy9vcGVuLWFzc2V0cy1wcm90b2NvbFwiXG4gIH0sXG4gIFwiMjJcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyMlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDAxNlwiLFxuICAgIFwic3ltYm9sXCI6IFwiTU9OQVwiLFxuICAgIFwibmFtZVwiOiBcIk1vbmFjb2luXCJcbiAgfSxcbiAgXCIyM1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjIzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDE3XCIsXG4gICAgXCJzeW1ib2xcIjogXCJDTEFNXCIsXG4gICAgXCJuYW1lXCI6IFwiQ2xhbXNcIlxuICB9LFxuICBcIjI0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwMThcIixcbiAgICBcInN5bWJvbFwiOiBcIlhQTVwiLFxuICAgIFwibmFtZVwiOiBcIlByaW1lY29pblwiXG4gIH0sXG4gIFwiMjVcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyNVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDAxOVwiLFxuICAgIFwic3ltYm9sXCI6IFwiTkVPU1wiLFxuICAgIFwibmFtZVwiOiBcIk5lb3Njb2luXCJcbiAgfSxcbiAgXCIyNlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjI2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDFhXCIsXG4gICAgXCJzeW1ib2xcIjogXCJKQlNcIixcbiAgICBcIm5hbWVcIjogXCJKdW1idWNrc1wiXG4gIH0sXG4gIFwiMjdcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyN1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDAxYlwiLFxuICAgIFwic3ltYm9sXCI6IFwiWlJDXCIsXG4gICAgXCJuYW1lXCI6IFwiemlmdHJDT0lOXCJcbiAgfSxcbiAgXCIyOFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjI4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDFjXCIsXG4gICAgXCJzeW1ib2xcIjogXCJWVENcIixcbiAgICBcIm5hbWVcIjogXCJWZXJ0Y29pblwiXG4gIH0sXG4gIFwiMjlcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyOVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDAxZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiTlhUXCIsXG4gICAgXCJuYW1lXCI6IFwiTlhUXCJcbiAgfSxcbiAgXCIzMFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjMwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDFlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJCVVJTVFwiLFxuICAgIFwibmFtZVwiOiBcIkJ1cnN0XCJcbiAgfSxcbiAgXCIzMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjMxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDFmXCIsXG4gICAgXCJzeW1ib2xcIjogXCJNVUVcIixcbiAgICBcIm5hbWVcIjogXCJNb25ldGFyeVVuaXRcIlxuICB9LFxuICBcIjMyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwMjBcIixcbiAgICBcInN5bWJvbFwiOiBcIlpPT01cIixcbiAgICBcIm5hbWVcIjogXCJab29tXCJcbiAgfSxcbiAgXCIzM1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjMzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDIxXCIsXG4gICAgXCJzeW1ib2xcIjogXCJWQVNIXCIsXG4gICAgXCJuYW1lXCI6IFwiVmlydHVhbCBDYXNoXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL3d3dy5iaXRuZXQuY2NcIlxuICB9LFxuICBcIjM0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwMjJcIixcbiAgICBcInN5bWJvbFwiOiBcIkNETlwiLFxuICAgIFwibmFtZVwiOiBcIkNhbmFkYSBlQ29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9DYW5hZGEtZUNvaW5cIlxuICB9LFxuICBcIjM1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwMjNcIixcbiAgICBcInN5bWJvbFwiOiBcIlNEQ1wiLFxuICAgIFwibmFtZVwiOiBcIlNoYWRvd0Nhc2hcIlxuICB9LFxuICBcIjM2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwMjRcIixcbiAgICBcInN5bWJvbFwiOiBcIlBLQlwiLFxuICAgIFwibmFtZVwiOiBcIlBhcmtCeXRlXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3BhcmtieXRlXCJcbiAgfSxcbiAgXCIzN1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDI1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJQTkRcIixcbiAgICBcIm5hbWVcIjogXCJQYW5kYWNvaW5cIlxuICB9LFxuICBcIjM4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwMjZcIixcbiAgICBcInN5bWJvbFwiOiBcIlNUQVJUXCIsXG4gICAgXCJuYW1lXCI6IFwiU3RhcnRDT0lOXCJcbiAgfSxcbiAgXCIzOVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDI3XCIsXG4gICAgXCJzeW1ib2xcIjogXCJNT0lOXCIsXG4gICAgXCJuYW1lXCI6IFwiTU9JTlwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZGlzY292ZXJtb2luLmNvbVwiXG4gIH0sXG4gIFwiNDBcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0MFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDAyOFwiLFxuICAgIFwic3ltYm9sXCI6IFwiRVhQXCIsXG4gICAgXCJuYW1lXCI6IFwiRXhwYW5zZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZXhwYW5zZS50ZWNoXCJcbiAgfSxcbiAgXCI0MVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDI5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJFTUMyXCIsXG4gICAgXCJuYW1lXCI6IFwiRWluc3RlaW5pdW1cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5lbWMyLmZvdW5kYXRpb25cIlxuICB9LFxuICBcIjQyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwMmFcIixcbiAgICBcInN5bWJvbFwiOiBcIkRDUlwiLFxuICAgIFwibmFtZVwiOiBcIkRlY3JlZFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZGVjcmVkLm9yZ1wiXG4gIH0sXG4gIFwiNDNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0M1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDAyYlwiLFxuICAgIFwic3ltYm9sXCI6IFwiWEVNXCIsXG4gICAgXCJuYW1lXCI6IFwiTkVNXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL05lbVByb2plY3RcIlxuICB9LFxuICBcIjQ0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwMmNcIixcbiAgICBcInN5bWJvbFwiOiBcIlBBUlRcIixcbiAgICBcIm5hbWVcIjogXCJQYXJ0aWNsXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9wYXJ0aWNsLmlvXCJcbiAgfSxcbiAgXCI0NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQ1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDJkXCIsXG4gICAgXCJzeW1ib2xcIjogXCJBUkdcIixcbiAgICBcIm5hbWVcIjogXCJBcmdlbnR1bSAoZGVhZClcIlxuICB9LFxuICBcIjQ2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwMmVcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIkxpYmVydGFzXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2RhbmdlcnNob255L0xpYmVydGFzXCJcbiAgfSxcbiAgXCI0N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQ3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDJmXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJQb3N3IGNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3Bvc3dhbGxldC5jb21cIlxuICB9LFxuICBcIjQ4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwMzBcIixcbiAgICBcInN5bWJvbFwiOiBcIlNIUlwiLFxuICAgIFwibmFtZVwiOiBcIlNocmVlamlcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dpdGh1Yi5jb20vU01KQklUL1NIUkVFSklcIlxuICB9LFxuICBcIjQ5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwMzFcIixcbiAgICBcInN5bWJvbFwiOiBcIkdDUlwiLFxuICAgIFwibmFtZVwiOiBcIkdsb2JhbCBDdXJyZW5jeSBSZXNlcnZlIChHQ1Jjb2luKVwiXG4gIH0sXG4gIFwiNTBcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1MFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDAzMlwiLFxuICAgIFwic3ltYm9sXCI6IFwiTlZDXCIsXG4gICAgXCJuYW1lXCI6IFwiTm92YWNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dpdGh1Yi5jb20vbm92YWNvaW4tcHJvamVjdC9ub3ZhY29pblwiXG4gIH0sXG4gIFwiNTFcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1MVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDAzM1wiLFxuICAgIFwic3ltYm9sXCI6IFwiQUNcIixcbiAgICBcIm5hbWVcIjogXCJBc2lhY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9Bc2lhQ29pbi9Bc2lhQ29pbkZpeFwiXG4gIH0sXG4gIFwiNTJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1MlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDAzNFwiLFxuICAgIFwic3ltYm9sXCI6IFwiQlRDRFwiLFxuICAgIFwibmFtZVwiOiBcIkJpdGNvaW5EYXJrXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2psNzc3L2J0Y2RcIlxuICB9LFxuICBcIjUzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwMzVcIixcbiAgICBcInN5bWJvbFwiOiBcIkRPUEVcIixcbiAgICBcIm5hbWVcIjogXCJEb3BlY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9kb3BlY29pbi1kZXYvRG9wZUNvaW5WM1wiXG4gIH0sXG4gIFwiNTRcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDAzNlwiLFxuICAgIFwic3ltYm9sXCI6IFwiVFBDXCIsXG4gICAgXCJuYW1lXCI6IFwiVGVtcGxlY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS85Y2F0L3RlbXBsZWNvaW5cIlxuICB9LFxuICBcIjU1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwMzdcIixcbiAgICBcInN5bWJvbFwiOiBcIkFJQlwiLFxuICAgIFwibmFtZVwiOiBcIkFJQlwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9pb2JvbmQvYWliXCJcbiAgfSxcbiAgXCI1NlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDM4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJFRFJDXCIsXG4gICAgXCJuYW1lXCI6IFwiRURSQ29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9FRFJDb2luL0VEUmNvaW4tc3JjXCJcbiAgfSxcbiAgXCI1N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDM5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJTWVNcIixcbiAgICBcIm5hbWVcIjogXCJTeXNjb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3N5c2NvaW4vc3lzY29pbjJcIlxuICB9LFxuICBcIjU4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNThcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwM2FcIixcbiAgICBcInN5bWJvbFwiOiBcIlNMUlwiLFxuICAgIFwibmFtZVwiOiBcIlNvbGFyY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9vbnNpZ2h0aXQvc29sYXJjb2luXCJcbiAgfSxcbiAgXCI1OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDNiXCIsXG4gICAgXCJzeW1ib2xcIjogXCJTTUxZXCIsXG4gICAgXCJuYW1lXCI6IFwiU21pbGV5Y29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90dXRvci13ZWIvc21pbGV5Q29pblwiXG4gIH0sXG4gIFwiNjBcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2MFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDAzY1wiLFxuICAgIFwic3ltYm9sXCI6IFwiRVRIXCIsXG4gICAgXCJuYW1lXCI6IFwiRXRoZXJldW1cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2V0aGVyZXVtLm9yZ1wiXG4gIH0sXG4gIFwiNjFcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2MVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDAzZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiRVRDXCIsXG4gICAgXCJuYW1lXCI6IFwiRXRoZXIgQ2xhc3NpY1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZXRoZXJldW1jbGFzc2ljLmdpdGh1Yi5pb1wiXG4gIH0sXG4gIFwiNjJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2MlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDAzZVwiLFxuICAgIFwic3ltYm9sXCI6IFwiUFNCXCIsXG4gICAgXCJuYW1lXCI6IFwiUGVzb2JpdFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9wZXNvYml0cGgvcGVzb2JpdC1zb3VyY2VcIlxuICB9LFxuICBcIjYzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwM2ZcIixcbiAgICBcInN5bWJvbFwiOiBcIkxEQ05cIixcbiAgICBcIm5hbWVcIjogXCJMYW5kY29pbiAoZGVhZClcIlxuICB9LFxuICBcIjY0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwNDBcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIk9wZW4gQ2hhaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dpdGh1Yi5jb20vb3BlbmNoYWluXCJcbiAgfSxcbiAgXCI2NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDQxXCIsXG4gICAgXCJzeW1ib2xcIjogXCJYQkNcIixcbiAgICBcIm5hbWVcIjogXCJCaXRjb2lucGx1c1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYml0Y29pbnBsdXMub3JnXCJcbiAgfSxcbiAgXCI2NlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDQyXCIsXG4gICAgXCJzeW1ib2xcIjogXCJJT1BcIixcbiAgICBcIm5hbWVcIjogXCJJbnRlcm5ldCBvZiBQZW9wbGVcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2lvcC5nbG9iYWxcIlxuICB9LFxuICBcIjY3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwNDNcIixcbiAgICBcInN5bWJvbFwiOiBcIk5YU1wiLFxuICAgIFwibmFtZVwiOiBcIk5leHVzXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9uZXh1cy5pb1wiXG4gIH0sXG4gIFwiNjhcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA0NFwiLFxuICAgIFwic3ltYm9sXCI6IFwiSU5TTlwiLFxuICAgIFwibmFtZVwiOiBcIkluc2FuZUNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2luc2FuZS5uZXR3b3JrXCJcbiAgfSxcbiAgXCI2OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDQ1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJPS1wiLFxuICAgIFwibmFtZVwiOiBcIk9LQ2FzaFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9va2Nhc2hwcm9cIlxuICB9LFxuICBcIjcwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwNDZcIixcbiAgICBcInN5bWJvbFwiOiBcIkJSSVRcIixcbiAgICBcIm5hbWVcIjogXCJCcml0Q29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYnJpdGNvaW4uY29tXCJcbiAgfSxcbiAgXCI3MVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjcxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDQ3XCIsXG4gICAgXCJzeW1ib2xcIjogXCJDTVBcIixcbiAgICBcIm5hbWVcIjogXCJDb21wY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vY29tcGNvaW4uY29tXCJcbiAgfSxcbiAgXCI3MlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjcyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDQ4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJDUldcIixcbiAgICBcIm5hbWVcIjogXCJDcm93blwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmNyb3ducGxhdGZvcm0uY29tXCJcbiAgfSxcbiAgXCI3M1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjczXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDQ5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJCRUxBXCIsXG4gICAgXCJuYW1lXCI6IFwiQmVsYUNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwOi8vYmVsYWNvaW4ub3JnXCJcbiAgfSxcbiAgXCI3NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDRhXCIsXG4gICAgXCJzeW1ib2xcIjogXCJJQ1hcIixcbiAgICBcIm5hbWVcIjogXCJJQ09OXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9pY29uLmZvdW5kYXRpb25cIlxuICB9LFxuICBcIjc1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwNGJcIixcbiAgICBcInN5bWJvbFwiOiBcIkZKQ1wiLFxuICAgIFwibmFtZVwiOiBcIkZ1amlDb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9mdWppY29pbi5vcmdcIlxuICB9LFxuICBcIjc2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwNGNcIixcbiAgICBcInN5bWJvbFwiOiBcIk1JWFwiLFxuICAgIFwibmFtZVwiOiBcIk1JWFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3Lm1peC1ibG9ja2NoYWluLm9yZ1wiXG4gIH0sXG4gIFwiNzdcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA0ZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiWFZHXCIsXG4gICAgXCJuYW1lXCI6IFwiVmVyZ2UgQ3VycmVuY3lcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3ZlcmdlY3VycmVuY3kuY29tXCJcbiAgfSxcbiAgXCI3OFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDRlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJFRkxcIixcbiAgICBcIm5hbWVcIjogXCJFbGVjdHJvbmljIEd1bGRlblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZWd1bGRlbi5vcmdcIlxuICB9LFxuICBcIjc5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwNGZcIixcbiAgICBcInN5bWJvbFwiOiBcIkNMVUJcIixcbiAgICBcIm5hbWVcIjogXCJDbHViQ29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vY2x1YmNvaW4uY29cIlxuICB9LFxuICBcIjgwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiODBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwNTBcIixcbiAgICBcInN5bWJvbFwiOiBcIlJJQ0hYXCIsXG4gICAgXCJuYW1lXCI6IFwiUmljaENvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3JpY2hjb2luLnVzXCJcbiAgfSxcbiAgXCI4MVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjgxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDUxXCIsXG4gICAgXCJzeW1ib2xcIjogXCJQT1RcIixcbiAgICBcIm5hbWVcIjogXCJQb3Rjb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cucG90Y29pbi5jb21cIlxuICB9LFxuICBcIjgyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiODJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwNTJcIixcbiAgICBcInN5bWJvbFwiOiBcIlFSS1wiLFxuICAgIFwibmFtZVwiOiBcIlF1YXJrY29pblwiXG4gIH0sXG4gIFwiODNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4M1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA1M1wiLFxuICAgIFwic3ltYm9sXCI6IFwiVFJDXCIsXG4gICAgXCJuYW1lXCI6IFwiVGVycmFjb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly90ZXJyYWNvaW4uaW9cIlxuICB9LFxuICBcIjg0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiODRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwNTRcIixcbiAgICBcInN5bWJvbFwiOiBcIkdSQ1wiLFxuICAgIFwibmFtZVwiOiBcIkdyaWRjb2luXCJcbiAgfSxcbiAgXCI4NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjg1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDU1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJBVVJcIixcbiAgICBcIm5hbWVcIjogXCJBdXJvcmFjb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL2F1cm9yYWNvaW4uaXNcIlxuICB9LFxuICBcIjg2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiODZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwNTZcIixcbiAgICBcInN5bWJvbFwiOiBcIklYQ1wiLFxuICAgIFwibmFtZVwiOiBcIklYQ29pblwiXG4gIH0sXG4gIFwiODdcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA1N1wiLFxuICAgIFwic3ltYm9sXCI6IFwiTkxHXCIsXG4gICAgXCJuYW1lXCI6IFwiR3VsZGVuXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9HdWxkZW4uY29tXCJcbiAgfSxcbiAgXCI4OFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjg4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDU4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJCSVRCXCIsXG4gICAgXCJuYW1lXCI6IFwiQml0QmVhblwiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly9iaXRiZWFuLm9yZ1wiXG4gIH0sXG4gIFwiODlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4OVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA1OVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQlRBXCIsXG4gICAgXCJuYW1lXCI6IFwiQmF0YVwiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly9iYXRhLmlvXCJcbiAgfSxcbiAgXCI5MFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjkwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDVhXCIsXG4gICAgXCJzeW1ib2xcIjogXCJYTVlcIixcbiAgICBcIm5hbWVcIjogXCJNeXJpYWRjb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL215cmlhZGNvaW4ub3JnXCJcbiAgfSxcbiAgXCI5MVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjkxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDViXCIsXG4gICAgXCJzeW1ib2xcIjogXCJCU0RcIixcbiAgICBcIm5hbWVcIjogXCJCaXRTZW5kXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL2JpdHNlbmQuaW5mb1wiXG4gIH0sXG4gIFwiOTJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5MlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA1Y1wiLFxuICAgIFwic3ltYm9sXCI6IFwiVU5PXCIsXG4gICAgXCJuYW1lXCI6IFwiVW5vYnRhbml1bVwiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly9odHRwOi8vdW5vYnRhbml1bS51bm9cIlxuICB9LFxuICBcIjkzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwNWRcIixcbiAgICBcInN5bWJvbFwiOiBcIk1UUlwiLFxuICAgIFwibmFtZVwiOiBcIk1hc3RlclRyYWRlclwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9DcnlwdGljQXBwbGljYXRpb25zL01UUi1VcGRhdGVcIlxuICB9LFxuICBcIjk0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwNWVcIixcbiAgICBcInN5bWJvbFwiOiBcIkdCXCIsXG4gICAgXCJuYW1lXCI6IFwiR29sZEJsb2Nrc1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9nb2xkYmxvY2tzY29pbi9nb2xkYmxvY2tzXCJcbiAgfSxcbiAgXCI5NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjk1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDVmXCIsXG4gICAgXCJzeW1ib2xcIjogXCJTSE1cIixcbiAgICBcIm5hbWVcIjogXCJTYWhhbVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9TYWhhbURldi9TYWhhbURldlwiXG4gIH0sXG4gIFwiOTZcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5NlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA2MFwiLFxuICAgIFwic3ltYm9sXCI6IFwiQ1JYXCIsXG4gICAgXCJuYW1lXCI6IFwiQ2hyb25vc1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9jaHJvbm9zY29pbi9DaHJvbm9zY29pblwiXG4gIH0sXG4gIFwiOTdcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA2MVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQklRXCIsXG4gICAgXCJuYW1lXCI6IFwiVWJpcXVvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdWJpcXVvaW4vdWJpcVwiXG4gIH0sXG4gIFwiOThcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA2MlwiLFxuICAgIFwic3ltYm9sXCI6IFwiRVZPXCIsXG4gICAgXCJuYW1lXCI6IFwiRXZvdGlvblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9ldm9zaGl1bi9Fdm90aW9uXCJcbiAgfSxcbiAgXCI5OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjk5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDYzXCIsXG4gICAgXCJzeW1ib2xcIjogXCJTVE9cIixcbiAgICBcIm5hbWVcIjogXCJTYXZlVGhlT2NlYW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dpdGh1Yi5jb20vU2F2ZVRoZU9jZWFuTW92ZW1lbnQvU2F2ZVRoZU9jZWFuQ29pblwiXG4gIH0sXG4gIFwiMTAwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTAwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDY0XCIsXG4gICAgXCJzeW1ib2xcIjogXCJCSUdVUFwiLFxuICAgIFwibmFtZVwiOiBcIkJpZ1VwXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL0JpZ1Vwc1wiXG4gIH0sXG4gIFwiMTAxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTAxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDY1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJHQU1FXCIsXG4gICAgXCJuYW1lXCI6IFwiR2FtZUNyZWRpdHNcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dpdGh1Yi5jb20vZ2FtZWNyZWRpdHMtcHJvamVjdFwiXG4gIH0sXG4gIFwiMTAyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTAyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDY2XCIsXG4gICAgXCJzeW1ib2xcIjogXCJETENcIixcbiAgICBcIm5hbWVcIjogXCJEb2xsYXJjb2luc1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9kb2xsYXJjb2lucy9zb3VyY2VcIlxuICB9LFxuICBcIjEwM1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjEwM1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA2N1wiLFxuICAgIFwic3ltYm9sXCI6IFwiWllEXCIsXG4gICAgXCJuYW1lXCI6IFwiWmF5ZWRjb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL1pheWVkQ29pbi9aYXllZGNvaW5cIlxuICB9LFxuICBcIjEwNFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjEwNFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA2OFwiLFxuICAgIFwic3ltYm9sXCI6IFwiREJJQ1wiLFxuICAgIFwibmFtZVwiOiBcIkR1YmFpY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9EdWJhaUNvaW5EZXYvRHViYWlDb2luXCJcbiAgfSxcbiAgXCIxMDVcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMDVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwNjlcIixcbiAgICBcInN5bWJvbFwiOiBcIlNUUkFUXCIsXG4gICAgXCJuYW1lXCI6IFwiU3RyYXRpc1wiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly93d3cuc3RyYXRpc3BsYXRmb3JtLmNvbVwiXG4gIH0sXG4gIFwiMTA2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTA2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDZhXCIsXG4gICAgXCJzeW1ib2xcIjogXCJTSFwiLFxuICAgIFwibmFtZVwiOiBcIlNoaWxsaW5nXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3lhdndhL1NoaWxsaW5nXCJcbiAgfSxcbiAgXCIxMDdcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMDdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwNmJcIixcbiAgICBcInN5bWJvbFwiOiBcIk1BUlNcIixcbiAgICBcIm5hbWVcIjogXCJNYXJzQ29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly93d3cubWFyc2NvaW4ub3JnXCJcbiAgfSxcbiAgXCIxMDhcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMDhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwNmNcIixcbiAgICBcInN5bWJvbFwiOiBcIlVCUVwiLFxuICAgIFwibmFtZVwiOiBcIlViaXFcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dpdGh1Yi5jb20vVWJpcVwiXG4gIH0sXG4gIFwiMTA5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTA5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDZkXCIsXG4gICAgXCJzeW1ib2xcIjogXCJQVENcIixcbiAgICBcIm5hbWVcIjogXCJQZXNldGFjb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL3Blc2V0YWNvaW4uaW5mb1wiXG4gIH0sXG4gIFwiMTEwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTEwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDZlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJOUk9cIixcbiAgICBcIm5hbWVcIjogXCJOZXVyb2NvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL25ldXJvY29pbi5vcmdcIlxuICB9LFxuICBcIjExMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjExMVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA2ZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiQVJLXCIsXG4gICAgXCJuYW1lXCI6IFwiQVJLXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9hcmsuaW9cIlxuICB9LFxuICBcIjExMlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjExMlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA3MFwiLFxuICAgIFwic3ltYm9sXCI6IFwiVVNDXCIsXG4gICAgXCJuYW1lXCI6IFwiVWx0aW1hdGVTZWN1cmVDYXNoTWFpblwiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly91bHRpbWF0ZXNlY3VyZWNhc2guaW5mb1wiXG4gIH0sXG4gIFwiMTEzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTEzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDcxXCIsXG4gICAgXCJzeW1ib2xcIjogXCJUSENcIixcbiAgICBcIm5hbWVcIjogXCJIZW1wY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly9oZW1wY29pbi5vcmdcIlxuICB9LFxuICBcIjExNFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjExNFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA3MlwiLFxuICAgIFwic3ltYm9sXCI6IFwiTElOWFwiLFxuICAgIFwibmFtZVwiOiBcIkxpbnhcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL215bGlueC5pb1wiXG4gIH0sXG4gIFwiMTE1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTE1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDczXCIsXG4gICAgXCJzeW1ib2xcIjogXCJFQ05cIixcbiAgICBcIm5hbWVcIjogXCJFY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmVjb2luc291cmNlLmNvbVwiXG4gIH0sXG4gIFwiMTE2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTE2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDc0XCIsXG4gICAgXCJzeW1ib2xcIjogXCJETlJcIixcbiAgICBcIm5hbWVcIjogXCJEZW5hcml1c1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZGVuYXJpdXMuaW9cIlxuICB9LFxuICBcIjExN1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjExN1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA3NVwiLFxuICAgIFwic3ltYm9sXCI6IFwiUElOS1wiLFxuICAgIFwibmFtZVwiOiBcIlBpbmtjb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL2dldHN0YXJ0ZWQud2l0aC5waW5rXCJcbiAgfSxcbiAgXCIxMThcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMThcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwNzZcIixcbiAgICBcInN5bWJvbFwiOiBcIkFUT01cIixcbiAgICBcIm5hbWVcIjogXCJBdG9tXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9jb3Ntb3MubmV0d29ya1wiXG4gIH0sXG4gIFwiMTE5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTE5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDc3XCIsXG4gICAgXCJzeW1ib2xcIjogXCJQSVZYXCIsXG4gICAgXCJuYW1lXCI6IFwiUGl2eFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9QSVZYLVByb2plY3QvUElWWFwiXG4gIH0sXG4gIFwiMTIwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTIwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDc4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJGTEFTSFwiLFxuICAgIFwibmFtZVwiOiBcIkZsYXNoY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZmxhc2hjb2luLmlvXCJcbiAgfSxcbiAgXCIxMjFcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMjFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwNzlcIixcbiAgICBcInN5bWJvbFwiOiBcIlpFTlwiLFxuICAgIFwibmFtZVwiOiBcIlplbmNhc2hcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3plbnN5c3RlbS5pb1wiXG4gIH0sXG4gIFwiMTIyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTIyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDdhXCIsXG4gICAgXCJzeW1ib2xcIjogXCJQVVRcIixcbiAgICBcIm5hbWVcIjogXCJQdXRpbmNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3B1dGluY29pbi5pbmZvXCJcbiAgfSxcbiAgXCIxMjNcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMjNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwN2JcIixcbiAgICBcInN5bWJvbFwiOiBcIlpOWVwiLFxuICAgIFwibmFtZVwiOiBcIkJpdFplbnlcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2JpdHplbnkudGVjaFwiXG4gIH0sXG4gIFwiMTI0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTI0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDdjXCIsXG4gICAgXCJzeW1ib2xcIjogXCJVTklGWVwiLFxuICAgIFwibmFtZVwiOiBcIlVuaWZ5XCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL3VuaWZ5Y3J5cHRvY3VycmVuY3kuY29tXCJcbiAgfSxcbiAgXCIxMjVcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMjVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwN2RcIixcbiAgICBcInN5bWJvbFwiOiBcIlhTVFwiLFxuICAgIFwibmFtZVwiOiBcIlN0ZWFsdGhDb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL3d3dy5zdGVhbHRoY29pbi5jb21cIlxuICB9LFxuICBcIjEyNlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjEyNlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA3ZVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQlJLXCIsXG4gICAgXCJuYW1lXCI6IFwiQnJlYWtvdXQgQ29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly93d3cuYnJlYWtvdXRjb2luLmNvbVwiXG4gIH0sXG4gIFwiMTI3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTI3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDdmXCIsXG4gICAgXCJzeW1ib2xcIjogXCJWQ1wiLFxuICAgIFwibmFtZVwiOiBcIlZjYXNoXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly92Y2FzaC5pbmZvXCJcbiAgfSxcbiAgXCIxMjhcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMjhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwODBcIixcbiAgICBcInN5bWJvbFwiOiBcIlhNUlwiLFxuICAgIFwibmFtZVwiOiBcIk1vbmVyb1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2V0bW9uZXJvLm9yZ1wiXG4gIH0sXG4gIFwiMTI5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTI5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDgxXCIsXG4gICAgXCJzeW1ib2xcIjogXCJWT1hcIixcbiAgICBcIm5hbWVcIjogXCJWb3hlbHNcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy52b3hlbHVzLmNvbVwiXG4gIH0sXG4gIFwiMTMwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTMwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDgyXCIsXG4gICAgXCJzeW1ib2xcIjogXCJOQVZcIixcbiAgICBcIm5hbWVcIjogXCJOYXZDb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL25hdmNvaW5kZXYvbmF2Y29pbjJcIlxuICB9LFxuICBcIjEzMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjEzMVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA4M1wiLFxuICAgIFwic3ltYm9sXCI6IFwiRkNUXCIsXG4gICAgXCJuYW1lXCI6IFwiRmFjdG9tIEZhY3RvaWRzXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL0ZhY3RvbVByb2plY3QvRmFjdG9tRG9jcy9ibG9iL21hc3Rlci93YWxsZXRfaW5mby93YWxsZXRfdGVzdF92ZWN0b3JzLm1kXCJcbiAgfSxcbiAgXCIxMzJcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMzJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwODRcIixcbiAgICBcInN5bWJvbFwiOiBcIkVDXCIsXG4gICAgXCJuYW1lXCI6IFwiRmFjdG9tIEVudHJ5IENyZWRpdHNcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dpdGh1Yi5jb20vRmFjdG9tUHJvamVjdFwiXG4gIH0sXG4gIFwiMTMzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTMzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDg1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJaRUNcIixcbiAgICBcIm5hbWVcIjogXCJaY2FzaFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vei5jYXNoXCJcbiAgfSxcbiAgXCIxMzRcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMzRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwODZcIixcbiAgICBcInN5bWJvbFwiOiBcIkxTS1wiLFxuICAgIFwibmFtZVwiOiBcIkxpc2tcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2xpc2suaW9cIlxuICB9LFxuICBcIjEzNVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjEzNVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA4N1wiLFxuICAgIFwic3ltYm9sXCI6IFwiU1RFRU1cIixcbiAgICBcIm5hbWVcIjogXCJTdGVlbVwiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly9zdGVlbS5pb1wiXG4gIH0sXG4gIFwiMTM2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTM2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDg4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJYWkNcIixcbiAgICBcIm5hbWVcIjogXCJaQ29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vemNvaW4uaW9cIlxuICB9LFxuICBcIjEzN1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjEzN1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA4OVwiLFxuICAgIFwic3ltYm9sXCI6IFwiUkJUQ1wiLFxuICAgIFwibmFtZVwiOiBcIlJTS1wiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly93d3cucnNrLmNvXCJcbiAgfSxcbiAgXCIxMzhcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMzhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwOGFcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIkdpZnRibG9ja1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9neWZ0L2dpZnRibG9ja1wiXG4gIH0sXG4gIFwiMTM5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTM5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDhiXCIsXG4gICAgXCJzeW1ib2xcIjogXCJSUFRcIixcbiAgICBcIm5hbWVcIjogXCJSZWFsUG9pbnRDb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL01heFNtaWxlL1JlYWxQb2ludENvaW5RdFwiXG4gIH0sXG4gIFwiMTQwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTQwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDhjXCIsXG4gICAgXCJzeW1ib2xcIjogXCJMQkNcIixcbiAgICBcIm5hbWVcIjogXCJMQlJZIENyZWRpdHNcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2xicnkuaW9cIlxuICB9LFxuICBcIjE0MVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE0MVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA4ZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiS01EXCIsXG4gICAgXCJuYW1lXCI6IFwiS29tb2RvXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9rb21vZG9wbGF0Zm9ybS5jb21cIlxuICB9LFxuICBcIjE0MlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE0MlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA4ZVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQlNRXCIsXG4gICAgXCJuYW1lXCI6IFwiYmlzcSBUb2tlblwiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly9iaXNxLmlvXCJcbiAgfSxcbiAgXCIxNDNcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxNDNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwOGZcIixcbiAgICBcInN5bWJvbFwiOiBcIlJJQ1wiLFxuICAgIFwibmFtZVwiOiBcIlJpZWNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dpdGh1Yi5jb20vcmllY29pbi9yaWVjb2luXCJcbiAgfSxcbiAgXCIxNDRcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxNDRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwOTBcIixcbiAgICBcInN5bWJvbFwiOiBcIlhSUFwiLFxuICAgIFwibmFtZVwiOiBcIlJpcHBsZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vcmlwcGxlLmNvbVwiXG4gIH0sXG4gIFwiMTQ1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTQ1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDkxXCIsXG4gICAgXCJzeW1ib2xcIjogXCJCQ0hcIixcbiAgICBcIm5hbWVcIjogXCJCaXRjb2luIENhc2hcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5iaXRjb2luY2FzaC5vcmdcIlxuICB9LFxuICBcIjE0NlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE0NlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA5MlwiLFxuICAgIFwic3ltYm9sXCI6IFwiTkVCTFwiLFxuICAgIFwibmFtZVwiOiBcIk5lYmxpb1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbmVibC5pb1wiXG4gIH0sXG4gIFwiMTQ3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTQ3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDkzXCIsXG4gICAgXCJzeW1ib2xcIjogXCJaQ0xcIixcbiAgICBcIm5hbWVcIjogXCJaQ2xhc3NpY1wiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly96Y2xhc3NpYy5vcmdcIlxuICB9LFxuICBcIjE0OFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE0OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA5NFwiLFxuICAgIFwic3ltYm9sXCI6IFwiWExNXCIsXG4gICAgXCJuYW1lXCI6IFwiU3RlbGxhciBMdW1lbnNcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5zdGVsbGFyLm9yZ1wiXG4gIH0sXG4gIFwiMTQ5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTQ5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDk1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJOTEMyXCIsXG4gICAgXCJuYW1lXCI6IFwiTm9MaW1pdENvaW4yXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL3d3dy5ub2xpbWl0Y29pbi5vcmdcIlxuICB9LFxuICBcIjE1MFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE1MFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA5NlwiLFxuICAgIFwic3ltYm9sXCI6IFwiV0hMXCIsXG4gICAgXCJuYW1lXCI6IFwiV2hhbGVDb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93aGFsZWNvaW4ub3JnXCJcbiAgfSxcbiAgXCIxNTFcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxNTFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwOTdcIixcbiAgICBcInN5bWJvbFwiOiBcIkVSQ1wiLFxuICAgIFwibmFtZVwiOiBcIkV1cm9wZUNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5ldXJvcGVjb2luLmV1Lm9yZ1wiXG4gIH0sXG4gIFwiMTUyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTUyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDk4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJETURcIixcbiAgICBcIm5hbWVcIjogXCJEaWFtb25kXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL2JpdC5kaWFtb25kc1wiXG4gIH0sXG4gIFwiMTUzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTUzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMDk5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJCVE1cIixcbiAgICBcIm5hbWVcIjogXCJCeXRvbVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYnl0b20uaW9cIlxuICB9LFxuICBcIjE1NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE1NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA5YVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQklPXCIsXG4gICAgXCJuYW1lXCI6IFwiQmlvY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYmlvY29pbi5iaW9cIlxuICB9LFxuICBcIjE1NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE1NVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA5YlwiLFxuICAgIFwic3ltYm9sXCI6IFwiWFdDQ1wiLFxuICAgIFwibmFtZVwiOiBcIldoaXRlY29pbiBDbGFzc2ljXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9vbGQud2hpdGVjb2luLmluZm9cIlxuICB9LFxuICBcIjE1NlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE1NlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA5Y1wiLFxuICAgIFwic3ltYm9sXCI6IFwiQlRHXCIsXG4gICAgXCJuYW1lXCI6IFwiQml0Y29pbiBHb2xkXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL3d3dy5idGNncHUub3JnXCJcbiAgfSxcbiAgXCIxNTdcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxNTdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwOWRcIixcbiAgICBcInN5bWJvbFwiOiBcIkJUQzJYXCIsXG4gICAgXCJuYW1lXCI6IFwiQml0Y29pbiAyeFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbWVkaXVtLmNvbS9ARENHY28vYml0Y29pbi1zY2FsaW5nLWFncmVlbWVudC1hdC1jb25zZW5zdXMtMjAxNy0xMzM1MjFmZTlhNzdcIlxuICB9LFxuICBcIjE1OFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE1OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA5ZVwiLFxuICAgIFwic3ltYm9sXCI6IFwiU1NOXCIsXG4gICAgXCJuYW1lXCI6IFwiU3VwZXJTa3luZXRcIixcbiAgICBcImxpbmtcIjogXCJodHRwOi8vd3d3dy5zdXBlcnNreW5ldC5vcmdcIlxuICB9LFxuICBcIjE1OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE1OVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDA5ZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiVE9BXCIsXG4gICAgXCJuYW1lXCI6IFwiVE9BQ29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly93d3cudG9hY29pbi5jb21cIlxuICB9LFxuICBcIjE2MFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE2MFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBhMFwiLFxuICAgIFwic3ltYm9sXCI6IFwiQlRYXCIsXG4gICAgXCJuYW1lXCI6IFwiQml0Y29yZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYml0Y29yZS5jY1wiXG4gIH0sXG4gIFwiMTYxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTYxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGExXCIsXG4gICAgXCJzeW1ib2xcIjogXCJBQ0NcIixcbiAgICBcIm5hbWVcIjogXCJBZGNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5nZXRhZGNvaW4uY29tXCJcbiAgfSxcbiAgXCIxNjJcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxNjJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwYTJcIixcbiAgICBcInN5bWJvbFwiOiBcIkJDT1wiLFxuICAgIFwibmFtZVwiOiBcIkJyaWRnZWNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2JyaWRnZWNvaW4ub3JnXCJcbiAgfSxcbiAgXCIxNjNcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxNjNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwYTNcIixcbiAgICBcInN5bWJvbFwiOiBcIkVMTEFcIixcbiAgICBcIm5hbWVcIjogXCJFbGxhaXNtXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9lbGxhaXNtLm9yZ1wiXG4gIH0sXG4gIFwiMTY0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTY0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGE0XCIsXG4gICAgXCJzeW1ib2xcIjogXCJQSVJMXCIsXG4gICAgXCJuYW1lXCI6IFwiUGlybFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vcGlybC5pb1wiXG4gIH0sXG4gIFwiMTY1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTY1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGE1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJYTk9cIixcbiAgICBcIm5hbWVcIjogXCJOYW5vXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9uYW5vLm9yZ1wiXG4gIH0sXG4gIFwiMTY2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTY2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGE2XCIsXG4gICAgXCJzeW1ib2xcIjogXCJWSVZPXCIsXG4gICAgXCJuYW1lXCI6IFwiVml2b1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LnZpdm9jcnlwdG8uY29tXCJcbiAgfSxcbiAgXCIxNjdcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxNjdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwYTdcIixcbiAgICBcInN5bWJvbFwiOiBcIkZSU1RcIixcbiAgICBcIm5hbWVcIjogXCJGaXJzdGNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwOi8vZmlyc3Rjb2lucHJvamVjdC5jb21cIlxuICB9LFxuICBcIjE2OFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE2OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBhOFwiLFxuICAgIFwic3ltYm9sXCI6IFwiSE5DXCIsXG4gICAgXCJuYW1lXCI6IFwiSGVsbGVuaWNjb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL3d3dy5oZWxsZW5pY2NvaW4uZ3JcIlxuICB9LFxuICBcIjE2OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE2OVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBhOVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQlVaWlwiLFxuICAgIFwibmFtZVwiOiBcIkJVWlpcIixcbiAgICBcImxpbmtcIjogXCJodHRwOi8vd3d3LmJ1enpjb2luLmluZm9cIlxuICB9LFxuICBcIjE3MFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE3MFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBhYVwiLFxuICAgIFwic3ltYm9sXCI6IFwiTUJSU1wiLFxuICAgIFwibmFtZVwiOiBcIkVtYmVyXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuZW1iZXJjb2luLmlvXCJcbiAgfSxcbiAgXCIxNzFcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxNzFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwYWJcIixcbiAgICBcInN5bWJvbFwiOiBcIkhDXCIsXG4gICAgXCJuYW1lXCI6IFwiSGNhc2hcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2guY2FzaFwiXG4gIH0sXG4gIFwiMTcyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTcyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGFjXCIsXG4gICAgXCJzeW1ib2xcIjogXCJIVE1MXCIsXG4gICAgXCJuYW1lXCI6IFwiSFRNTENPSU5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2h0bWxjb2luLmNvbVwiXG4gIH0sXG4gIFwiMTczXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTczXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGFkXCIsXG4gICAgXCJzeW1ib2xcIjogXCJPRE5cIixcbiAgICBcIm5hbWVcIjogXCJPYnNpZGlhblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vb2JzaWRpYW5wbGF0Zm9ybS5jb21cIlxuICB9LFxuICBcIjE3NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE3NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBhZVwiLFxuICAgIFwic3ltYm9sXCI6IFwiT05YXCIsXG4gICAgXCJuYW1lXCI6IFwiT25peENvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5vbml4Y29pbi5jb21cIlxuICB9LFxuICBcIjE3NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE3NVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBhZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiUlZOXCIsXG4gICAgXCJuYW1lXCI6IFwiUmF2ZW5jb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9yYXZlbmNvaW4ub3JnXCJcbiAgfSxcbiAgXCIxNzZcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxNzZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwYjBcIixcbiAgICBcInN5bWJvbFwiOiBcIkdCWFwiLFxuICAgIFwibmFtZVwiOiBcIkdvQnl0ZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ29ieXRlLm5ldHdvcmtcIlxuICB9LFxuICBcIjE3N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE3N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBiMVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQlRDWlwiLFxuICAgIFwibmFtZVwiOiBcIkJpdGNvaW5aXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9idGN6LnJvY2tzL2VuXCJcbiAgfSxcbiAgXCIxNzhcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxNzhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwYjJcIixcbiAgICBcInN5bWJvbFwiOiBcIlBPQVwiLFxuICAgIFwibmFtZVwiOiBcIlBvYVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vcG9hLm5ldHdvcmtcIlxuICB9LFxuICBcIjE3OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE3OVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBiM1wiLFxuICAgIFwic3ltYm9sXCI6IFwiTllDXCIsXG4gICAgXCJuYW1lXCI6IFwiTmV3WW9ya0NvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwOi8vbnljb2luLm5ldFwiXG4gIH0sXG4gIFwiMTgwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTgwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGI0XCIsXG4gICAgXCJzeW1ib2xcIjogXCJNWFRcIixcbiAgICBcIm5hbWVcIjogXCJNYXJ0ZVhjb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL21hcnRleGNvaW4ub3JnXCJcbiAgfSxcbiAgXCIxODFcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxODFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwYjVcIixcbiAgICBcInN5bWJvbFwiOiBcIldDXCIsXG4gICAgXCJuYW1lXCI6IFwiV2luY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd2luY29pbi5jb1wiXG4gIH0sXG4gIFwiMTgyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTgyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGI2XCIsXG4gICAgXCJzeW1ib2xcIjogXCJNTlhcIixcbiAgICBcIm5hbWVcIjogXCJNaW5leGNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL21pbmV4Y29pbi5jb21cIlxuICB9LFxuICBcIjE4M1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE4M1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBiN1wiLFxuICAgIFwic3ltYm9sXCI6IFwiQlRDUFwiLFxuICAgIFwibmFtZVwiOiBcIkJpdGNvaW4gUHJpdmF0ZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYnRjcHJpdmF0ZS5vcmdcIlxuICB9LFxuICBcIjE4NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE4NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBiOFwiLFxuICAgIFwic3ltYm9sXCI6IFwiTVVTSUNcIixcbiAgICBcIm5hbWVcIjogXCJNdXNpY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3Lm11c2ljb2luLm9yZ1wiXG4gIH0sXG4gIFwiMTg1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTg1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGI5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJCQ0FcIixcbiAgICBcIm5hbWVcIjogXCJCaXRjb2luIEF0b21cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2JpdGNvaW5hdG9tLmlvXCJcbiAgfSxcbiAgXCIxODZcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxODZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwYmFcIixcbiAgICBcInN5bWJvbFwiOiBcIkNSQVZFXCIsXG4gICAgXCJuYW1lXCI6IFwiQ3JhdmVcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2NyYXZlcHJvamVjdC5uZXRcIlxuICB9LFxuICBcIjE4N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE4N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBiYlwiLFxuICAgIFwic3ltYm9sXCI6IFwiU1RBS1wiLFxuICAgIFwibmFtZVwiOiBcIlNUUkFLU1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vc3RyYWtzLmlvXCJcbiAgfSxcbiAgXCIxODhcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxODhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwYmNcIixcbiAgICBcInN5bWJvbFwiOiBcIldCVENcIixcbiAgICBcIm5hbWVcIjogXCJXb3JsZCBCaXRjb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL3d3dy53YnRjdGVhbS5vcmdcIlxuICB9LFxuICBcIjE4OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE4OVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBiZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiTENIXCIsXG4gICAgXCJuYW1lXCI6IFwiTGl0ZUNhc2hcIixcbiAgICBcImxpbmtcIjogXCJodHRwOi8vd3d3LmxpdGVjYXNoLmluZm9cIlxuICB9LFxuICBcIjE5MFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE5MFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBiZVwiLFxuICAgIFwic3ltYm9sXCI6IFwiRVhDTFwiLFxuICAgIFwibmFtZVwiOiBcIkV4Y2x1c2l2ZUNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2V4Y2x1c2l2ZWNvaW4ucHdcIlxuICB9LFxuICBcIjE5MVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE5MVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBiZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiTHlueFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2V0bHlueC5pb1wiXG4gIH0sXG4gIFwiMTkyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTkyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGMwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJMQ0NcIixcbiAgICBcIm5hbWVcIjogXCJMaXRlY29pbkNhc2hcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2xpdGVjb2luY2Euc2hcIlxuICB9LFxuICBcIjE5M1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE5M1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBjMVwiLFxuICAgIFwic3ltYm9sXCI6IFwiWEZFXCIsXG4gICAgXCJuYW1lXCI6IFwiRmVpcm1cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5mZWlybS5jb21cIlxuICB9LFxuICBcIjE5NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE5NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBjMlwiLFxuICAgIFwic3ltYm9sXCI6IFwiRU9TXCIsXG4gICAgXCJuYW1lXCI6IFwiRU9TXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9lb3MuaW9cIlxuICB9LFxuICBcIjE5NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE5NVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBjM1wiLFxuICAgIFwic3ltYm9sXCI6IFwiVFJYXCIsXG4gICAgXCJuYW1lXCI6IFwiVHJvblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vdHJvbi5uZXR3b3JrL2VuaW5kZXguaHRtbFwiXG4gIH0sXG4gIFwiMTk2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTk2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGM0XCIsXG4gICAgXCJzeW1ib2xcIjogXCJLT0JPXCIsXG4gICAgXCJuYW1lXCI6IFwiS29ib2NvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2tvYm9jb2luLmNvbVwiXG4gIH0sXG4gIFwiMTk3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTk3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGM1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJIVVNIXCIsXG4gICAgXCJuYW1lXCI6IFwiSFVTSFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbXlodXNoLm9yZ1wiXG4gIH0sXG4gIFwiMTk4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTk4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGM2XCIsXG4gICAgXCJzeW1ib2xcIjogXCJCQU5BTk9cIixcbiAgICBcIm5hbWVcIjogXCJCYW5hbm9zXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9iYW5hbm8uY28uaW5cIlxuICB9LFxuICBcIjE5OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE5OVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBjN1wiLFxuICAgIFwic3ltYm9sXCI6IFwiRVRGXCIsXG4gICAgXCJuYW1lXCI6IFwiRVRGXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL2V0aGVyZXVtZm9nLm9yZ1wiXG4gIH0sXG4gIFwiMjAwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjAwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGM4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJPTU5JXCIsXG4gICAgXCJuYW1lXCI6IFwiT21uaVwiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly93d3cub21uaWxheWVyLm9yZ1wiXG4gIH0sXG4gIFwiMjAxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjAxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGM5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJCSUZJXCIsXG4gICAgXCJuYW1lXCI6IFwiQml0Y29pbkZpbGVcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5iaXRjb2luZmlsZS5vcmdcIlxuICB9LFxuICBcIjIwMlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjIwMlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBjYVwiLFxuICAgIFwic3ltYm9sXCI6IFwiVUZPXCIsXG4gICAgXCJuYW1lXCI6IFwiVW5pZm9ybSBGaXNjYWwgT2JqZWN0XCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly91Zm9iamVjdC5jb21cIlxuICB9LFxuICBcIjIwM1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjIwM1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBjYlwiLFxuICAgIFwic3ltYm9sXCI6IFwiQ05NQ1wiLFxuICAgIFwibmFtZVwiOiBcIkNyeXB0b25vZGVzXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuY3J5cHRvbm9kZXMuY2hcIlxuICB9LFxuICBcIjIwNFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjIwNFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBjY1wiLFxuICAgIFwic3ltYm9sXCI6IFwiQkNOXCIsXG4gICAgXCJuYW1lXCI6IFwiQnl0ZWNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwOi8vYnl0ZWNvaW4ub3JnXCJcbiAgfSxcbiAgXCIyMDVcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyMDVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwY2RcIixcbiAgICBcInN5bWJvbFwiOiBcIlJJTlwiLFxuICAgIFwibmFtZVwiOiBcIlJpbmdvXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL2Rrd3pqdy5naXRodWIuaW8vcmluZ29cIlxuICB9LFxuICBcIjIwNlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjIwNlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBjZVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQVRQXCIsXG4gICAgXCJuYW1lXCI6IFwiUGxhdE9OXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cucGxhdG9uLm5ldHdvcmtcIlxuICB9LFxuICBcIjIwN1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjIwN1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBjZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiRVZUXCIsXG4gICAgXCJuYW1lXCI6IFwiZXZlcmlUb2tlblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZXZlcmlUb2tlbi5pb1wiXG4gIH0sXG4gIFwiMjA4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjA4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGQwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJBVE5cIixcbiAgICBcIm5hbWVcIjogXCJBVE5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2F0bi5pb1wiXG4gIH0sXG4gIFwiMjA5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjA5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGQxXCIsXG4gICAgXCJzeW1ib2xcIjogXCJCSVNcIixcbiAgICBcIm5hbWVcIjogXCJCaXNtdXRoXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL3d3dy5iaXNtdXRoLmN6XCJcbiAgfSxcbiAgXCIyMTBcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyMTBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwZDJcIixcbiAgICBcInN5bWJvbFwiOiBcIk5FRVRcIixcbiAgICBcIm5hbWVcIjogXCJORUVUQ09JTlwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbmVldGNvaW4uanBcIlxuICB9LFxuICBcIjIxMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjIxMVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBkM1wiLFxuICAgIFwic3ltYm9sXCI6IFwiQk9QT1wiLFxuICAgIFwibmFtZVwiOiBcIkJvcG9DaGFpblwiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly93d3cuYm9wb2NoYWluLm9yZ1wiXG4gIH0sXG4gIFwiMjEyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjEyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGQ0XCIsXG4gICAgXCJzeW1ib2xcIjogXCJPT1RcIixcbiAgICBcIm5hbWVcIjogXCJVdHJ1bVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vdXRydW0uaW8vb290Y29pblwiXG4gIH0sXG4gIFwiMjEzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjEzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGQ1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJBTElBU1wiLFxuICAgIFwibmFtZVwiOiBcIkFsaWFzXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9hbGlhcy5jYXNoXCJcbiAgfSxcbiAgXCIyMTRcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyMTRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwZDZcIixcbiAgICBcInN5bWJvbFwiOiBcIk1PTktcIixcbiAgICBcIm5hbWVcIjogXCJNb25rZXkgUHJvamVjdFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3Lm1vbmtleS52aXNpb25cIlxuICB9LFxuICBcIjIxNVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjIxNVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBkN1wiLFxuICAgIFwic3ltYm9sXCI6IFwiQk9YWVwiLFxuICAgIFwibmFtZVwiOiBcIkJveHlDb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL3d3dy5ib3h5Y29pbi5vcmdcIlxuICB9LFxuICBcIjIxNlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjIxNlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBkOFwiLFxuICAgIFwic3ltYm9sXCI6IFwiRkxPXCIsXG4gICAgXCJuYW1lXCI6IFwiRmxvXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuZmxvLmNhc2hcIlxuICB9LFxuICBcIjIxN1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjIxN1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBkOVwiLFxuICAgIFwic3ltYm9sXCI6IFwiTUVDXCIsXG4gICAgXCJuYW1lXCI6IFwiTWVnYWNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5tZWdhY29pbi5ldVwiXG4gIH0sXG4gIFwiMjE4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjE4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGRhXCIsXG4gICAgXCJzeW1ib2xcIjogXCJCVERYXCIsXG4gICAgXCJuYW1lXCI6IFwiQml0Q2xvdWRcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2JpdC1jbG91ZC5pbmZvXCJcbiAgfSxcbiAgXCIyMTlcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyMTlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwZGJcIixcbiAgICBcInN5bWJvbFwiOiBcIlhBWFwiLFxuICAgIFwibmFtZVwiOiBcIkFydGF4XCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuYXJ0YXhjb2luLm9yZ1wiXG4gIH0sXG4gIFwiMjIwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjIwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGRjXCIsXG4gICAgXCJzeW1ib2xcIjogXCJBTk9OXCIsXG4gICAgXCJuYW1lXCI6IFwiQU5PTlwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmFub25mb3JrLmlvXCJcbiAgfSxcbiAgXCIyMjFcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyMjFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwZGRcIixcbiAgICBcInN5bWJvbFwiOiBcIkxUWlwiLFxuICAgIFwibmFtZVwiOiBcIkxpdGVjb2luWlwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbGl0ZWNvaW56Lm9yZ1wiXG4gIH0sXG4gIFwiMjIyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjIyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGRlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJCSVRHXCIsXG4gICAgXCJuYW1lXCI6IFwiQml0Y29pbiBHcmVlblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vc2F2ZWJpdGNvaW4uaW9cIlxuICB9LFxuICBcIjIyM1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjIyM1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBkZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiSUNQXCIsXG4gICAgXCJuYW1lXCI6IFwiSW50ZXJuZXQgQ29tcHV0ZXIgKERGSU5JVFkpXCIsXG4gICAgXCJsaW5rXCI6IFwiREZJTklUWVwiXG4gIH0sXG4gIFwiMjI0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjI0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGUwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJTTUFSVFwiLFxuICAgIFwibmFtZVwiOiBcIlNtYXJ0Y2FzaFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vc21hcnRjYXNoLmNjXCJcbiAgfSxcbiAgXCIyMjVcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyMjVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwZTFcIixcbiAgICBcInN5bWJvbFwiOiBcIlhVRVpcIixcbiAgICBcIm5hbWVcIjogXCJYVUVaXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly94dWV6Y29pbi5jb21cIlxuICB9LFxuICBcIjIyNlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjIyNlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBlMlwiLFxuICAgIFwic3ltYm9sXCI6IFwiSExNXCIsXG4gICAgXCJuYW1lXCI6IFwiSGVsaXVtXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuaGVsaXVtbGFicy5vcmdcIlxuICB9LFxuICBcIjIyN1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjIyN1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBlM1wiLFxuICAgIFwic3ltYm9sXCI6IFwiV0VCXCIsXG4gICAgXCJuYW1lXCI6IFwiV2ViY2hhaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3dlYmNoYWluLm5ldHdvcmtcIlxuICB9LFxuICBcIjIyOFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjIyOFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBlNFwiLFxuICAgIFwic3ltYm9sXCI6IFwiQUNNXCIsXG4gICAgXCJuYW1lXCI6IFwiQWN0aW5pdW1cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2FjdGluaXVtLm9yZ1wiXG4gIH0sXG4gIFwiMjI5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjI5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGU1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJOT1NcIixcbiAgICBcIm5hbWVcIjogXCJOT1MgU3RhYmxlIENvaW5zXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9ub3MuY2FzaFwiXG4gIH0sXG4gIFwiMjMwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjMwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGU2XCIsXG4gICAgXCJzeW1ib2xcIjogXCJCSVRDXCIsXG4gICAgXCJuYW1lXCI6IFwiQml0Q2FzaFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmNob29zZWJpdGNhc2guY29tXCJcbiAgfSxcbiAgXCIyMzFcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyMzFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwZTdcIixcbiAgICBcInN5bWJvbFwiOiBcIkhUSFwiLFxuICAgIFwibmFtZVwiOiBcIkhlbHAgVGhlIEhvbWVsZXNzIENvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2h0aGNvaW4ud29ybGRcIlxuICB9LFxuICBcIjIzMlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjIzMlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBlOFwiLFxuICAgIFwic3ltYm9sXCI6IFwiVFpDXCIsXG4gICAgXCJuYW1lXCI6IFwiVHJlemFyY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vdHJlemFyY29pbi5jb21cIlxuICB9LFxuICBcIjIzM1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjIzM1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBlOVwiLFxuICAgIFwic3ltYm9sXCI6IFwiVkFSXCIsXG4gICAgXCJuYW1lXCI6IFwiVmFyZGFcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3ZhcmRhLmlvXCJcbiAgfSxcbiAgXCIyMzRcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyMzRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwZWFcIixcbiAgICBcInN5bWJvbFwiOiBcIklPVlwiLFxuICAgIFwibmFtZVwiOiBcIklPVlwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3Lmlvdi5vbmVcIlxuICB9LFxuICBcIjIzNVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjIzNVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBlYlwiLFxuICAgIFwic3ltYm9sXCI6IFwiRklPXCIsXG4gICAgXCJuYW1lXCI6IFwiRklPXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9maW9wcm90b2NvbC5pb1wiXG4gIH0sXG4gIFwiMjM2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjM2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGVjXCIsXG4gICAgXCJzeW1ib2xcIjogXCJCU1ZcIixcbiAgICBcIm5hbWVcIjogXCJCaXRjb2luU1ZcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2JpdGNvaW5zdi5pb1wiXG4gIH0sXG4gIFwiMjM3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjM3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGVkXCIsXG4gICAgXCJzeW1ib2xcIjogXCJEWE5cIixcbiAgICBcIm5hbWVcIjogXCJERVhPTlwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZGV4b24ub3JnXCJcbiAgfSxcbiAgXCIyMzhcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyMzhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwZWVcIixcbiAgICBcInN5bWJvbFwiOiBcIlFSTFwiLFxuICAgIFwibmFtZVwiOiBcIlF1YW50dW0gUmVzaXN0YW50IExlZGdlclwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LnRoZXFybC5vcmdcIlxuICB9LFxuICBcIjIzOVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjIzOVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBlZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiUENYXCIsXG4gICAgXCJuYW1lXCI6IFwiQ2hhaW5YXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2NoYWlueC1vcmcvQ2hhaW5YXCJcbiAgfSxcbiAgXCIyNDBcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyNDBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwZjBcIixcbiAgICBcInN5bWJvbFwiOiBcIkxPS0lcIixcbiAgICBcIm5hbWVcIjogXCJMb2tpXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2xva2ktcHJvamVjdC9sb2tpXCJcbiAgfSxcbiAgXCIyNDFcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyNDFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwZjFcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIkltYWdld2FsbGV0XCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9pbWFnZXdhbGxldC5pb1wiXG4gIH0sXG4gIFwiMjQyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjQyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGYyXCIsXG4gICAgXCJzeW1ib2xcIjogXCJOSU1cIixcbiAgICBcIm5hbWVcIjogXCJOaW1pcVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbmltaXEuY29tXCJcbiAgfSxcbiAgXCIyNDNcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyNDNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwZjNcIixcbiAgICBcInN5bWJvbFwiOiBcIlNPVlwiLFxuICAgIFwibmFtZVwiOiBcIlNvdmVyZWlnbiBDb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL3d3dy5zb3Zjb3JlLm9yZ1wiXG4gIH0sXG4gIFwiMjQ0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjQ0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGY0XCIsXG4gICAgXCJzeW1ib2xcIjogXCJKQ1RcIixcbiAgICBcIm5hbWVcIjogXCJKaWJpdGFsIENvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2ppYml0YWwuaXJcIlxuICB9LFxuICBcIjI0NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjI0NVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBmNVwiLFxuICAgIFwic3ltYm9sXCI6IFwiU0xQXCIsXG4gICAgXCJuYW1lXCI6IFwiU2ltcGxlIExlZGdlciBQcm90b2NvbFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vc2ltcGxlbGVkZ2VyLmNhc2hcIlxuICB9LFxuICBcIjI0NlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjI0NlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBmNlwiLFxuICAgIFwic3ltYm9sXCI6IFwiRVdUXCIsXG4gICAgXCJuYW1lXCI6IFwiRW5lcmd5IFdlYlwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZW5lcmd5d2ViLm9yZ1wiXG4gIH0sXG4gIFwiMjQ3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjQ3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGY3XCIsXG4gICAgXCJzeW1ib2xcIjogXCJVQ1wiLFxuICAgIFwibmFtZVwiOiBcIlVsb3JkXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL3Vsb3JkLm9uZVwiXG4gIH0sXG4gIFwiMjQ4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjQ4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGY4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJFWE9TXCIsXG4gICAgXCJuYW1lXCI6IFwiRVhPU1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZWNvbm9teS5vcGVuZXhvLmNvbVwiXG4gIH0sXG4gIFwiMjQ5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjQ5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGY5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJFQ0FcIixcbiAgICBcIm5hbWVcIjogXCJFbGVjdHJhXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuZWxlY3RyYXByb2plY3Qub3JnXCJcbiAgfSxcbiAgXCIyNTBcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyNTBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwZmFcIixcbiAgICBcInN5bWJvbFwiOiBcIlNPT01cIixcbiAgICBcIm5hbWVcIjogXCJTb29tXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL3d3dy5mb3VydGhibG9ja2NoYWluLm9yZ1wiXG4gIH0sXG4gIFwiMjUxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjUxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMGZiXCIsXG4gICAgXCJzeW1ib2xcIjogXCJYUkRcIixcbiAgICBcIm5hbWVcIjogXCJSZWRzdG9uZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LnJlZHN0b25lcGxhdGZvcm0uY29tXCJcbiAgfSxcbiAgXCIyNTJcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyNTJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwZmNcIixcbiAgICBcInN5bWJvbFwiOiBcIkZSRUVcIixcbiAgICBcIm5hbWVcIjogXCJGcmVlQ29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd2ViLmZyZWVwYXkuYml6XCJcbiAgfSxcbiAgXCIyNTNcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyNTNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwZmRcIixcbiAgICBcInN5bWJvbFwiOiBcIk5QV1wiLFxuICAgIFwibmFtZVwiOiBcIk5ld1Bvd2VyQ29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbnB3LmxpdmVcIlxuICB9LFxuICBcIjI1NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjI1NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDBmZVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQlNUXCIsXG4gICAgXCJuYW1lXCI6IFwiQmxvY2tTdGFtcFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYmxvY2tzdGFtcC5pbmZvXCJcbiAgfSxcbiAgXCIyNTVcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyNTVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAwZmZcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlNtYXJ0SG9sZGVtXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9zbWFydGhvbGRlbS5pb1wiXG4gIH0sXG4gIFwiMjU2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjU2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTAwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJOQU5PXCIsXG4gICAgXCJuYW1lXCI6IFwiQml0Y29pbiBOYW5vXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuYnRjbmFuby5vcmdcIlxuICB9LFxuICBcIjI1N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjI1N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDEwMVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQlRDQ1wiLFxuICAgIFwibmFtZVwiOiBcIkJpdGNvaW4gQ29yZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vdGhlYml0Y29pbmNvcmUub3JnXCJcbiAgfSxcbiAgXCIyNThcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyNThcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxMDJcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlplbiBQcm90b2NvbFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LnplbnByb3RvY29sLmNvbVwiXG4gIH0sXG4gIFwiMjU5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjU5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTAzXCIsXG4gICAgXCJzeW1ib2xcIjogXCJaRVNUXCIsXG4gICAgXCJuYW1lXCI6IFwiWmVzdFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3Lnplc3Rjb2luLmlvXCJcbiAgfSxcbiAgXCIyNjBcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyNjBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxMDRcIixcbiAgICBcInN5bWJvbFwiOiBcIkFCVFwiLFxuICAgIFwibmFtZVwiOiBcIkFyY0Jsb2NrXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9hcmNibG9jay5pb1wiXG4gIH0sXG4gIFwiMjYxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjYxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTA1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJQSU9OXCIsXG4gICAgXCJuYW1lXCI6IFwiUGlvblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vcGlvbmNvaW4ub3JnXCJcbiAgfSxcbiAgXCIyNjJcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyNjJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxMDZcIixcbiAgICBcInN5bWJvbFwiOiBcIkRUM1wiLFxuICAgIFwibmFtZVwiOiBcIkRyZWFtVGVhbTNcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2NyeXB0by1kcmVhbXRlYW0uY29tXCJcbiAgfSxcbiAgXCIyNjNcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyNjNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxMDdcIixcbiAgICBcInN5bWJvbFwiOiBcIlpCVVhcIixcbiAgICBcIm5hbWVcIjogXCJaYnV4XCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly96LWJ1eC5vcmdcIlxuICB9LFxuICBcIjI2NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjI2NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDEwOFwiLFxuICAgIFwic3ltYm9sXCI6IFwiS1BMXCIsXG4gICAgXCJuYW1lXCI6IFwiS2VwbGVyXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9rZXBsZXIuY2FzaFwiXG4gIH0sXG4gIFwiMjY1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjY1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTA5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJUUEFZXCIsXG4gICAgXCJuYW1lXCI6IFwiVG9rZW5QYXlcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3Rva2VucGF5LmNvbVwiXG4gIH0sXG4gIFwiMjY2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjY2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTBhXCIsXG4gICAgXCJzeW1ib2xcIjogXCJaSUxMQVwiLFxuICAgIFwibmFtZVwiOiBcIkNoYWluWmlsbGFcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5jaGFpbnppbGxhLmlvXCJcbiAgfSxcbiAgXCIyNjdcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyNjdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxMGJcIixcbiAgICBcInN5bWJvbFwiOiBcIkFOS1wiLFxuICAgIFwibmFtZVwiOiBcIkFua2VyXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9hbmtlcmlkLmNvbVwiXG4gIH0sXG4gIFwiMjY4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjY4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTBjXCIsXG4gICAgXCJzeW1ib2xcIjogXCJCQ0NcIixcbiAgICBcIm5hbWVcIjogXCJCQ0NoYWluXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2JjLWNoYWluL0JDQ1wiXG4gIH0sXG4gIFwiMjY5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjY5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTBkXCIsXG4gICAgXCJzeW1ib2xcIjogXCJIUEJcIixcbiAgICBcIm5hbWVcIjogXCJIUEJcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2hwYi5pb1wiXG4gIH0sXG4gIFwiMjcwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjcwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTBlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJPTkVcIixcbiAgICBcIm5hbWVcIjogXCJPTkVcIixcbiAgICBcImxpbmtcIjogXCJodHRwOi8vd3d3Lm9uZWNoYWluLm9uZVwiXG4gIH0sXG4gIFwiMjcxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjcxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTBmXCIsXG4gICAgXCJzeW1ib2xcIjogXCJTQkNcIixcbiAgICBcIm5hbWVcIjogXCJTQkNcIixcbiAgICBcImxpbmtcIjogXCJodHRwOi8vd3d3LnNtYXJ0Yml0Y29pbi5vbmVcIlxuICB9LFxuICBcIjI3MlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjI3MlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDExMFwiLFxuICAgIFwic3ltYm9sXCI6IFwiSVBDXCIsXG4gICAgXCJuYW1lXCI6IFwiSVBDaGFpblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmlwY2NoYWluLm9yZ1wiXG4gIH0sXG4gIFwiMjczXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjczXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTExXCIsXG4gICAgXCJzeW1ib2xcIjogXCJETVRDXCIsXG4gICAgXCJuYW1lXCI6IFwiRG9taW5hbnRjaGFpblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZG9taW5hbnRjaGFpbi5jb21cIlxuICB9LFxuICBcIjI3NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjI3NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDExMlwiLFxuICAgIFwic3ltYm9sXCI6IFwiT0dDXCIsXG4gICAgXCJuYW1lXCI6IFwiT25lZ3JhbVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vb25lZ3JhbS5vcmdcIlxuICB9LFxuICBcIjI3NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjI3NVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDExM1wiLFxuICAgIFwic3ltYm9sXCI6IFwiU0hJVFwiLFxuICAgIFwibmFtZVwiOiBcIlNoaXRjb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9zaGl0Y29pbi5vcmdcIlxuICB9LFxuICBcIjI3NlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjI3NlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDExNFwiLFxuICAgIFwic3ltYm9sXCI6IFwiQU5ERVNcIixcbiAgICBcIm5hbWVcIjogXCJBbmRlc2NvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2FuZGVzLWNvaW4uY29tXCJcbiAgfSxcbiAgXCIyNzdcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyNzdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxMTVcIixcbiAgICBcInN5bWJvbFwiOiBcIkFSRVBBXCIsXG4gICAgXCJuYW1lXCI6IFwiQXJlcGFjb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9hcmVwYWNvaW52ZS5pbmZvXCJcbiAgfSxcbiAgXCIyNzhcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyNzhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxMTZcIixcbiAgICBcInN5bWJvbFwiOiBcIkJPTElcIixcbiAgICBcIm5hbWVcIjogXCJCb2xpdmFyY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYm9saXMuaW5mb1wiXG4gIH0sXG4gIFwiMjc5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjc5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTE3XCIsXG4gICAgXCJzeW1ib2xcIjogXCJSSUxcIixcbiAgICBcIm5hbWVcIjogXCJSaWxjb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cucmlsY29pbmNyeXB0by5vcmdcIlxuICB9LFxuICBcIjI4MFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjI4MFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDExOFwiLFxuICAgIFwic3ltYm9sXCI6IFwiSFRSXCIsXG4gICAgXCJuYW1lXCI6IFwiSGF0aG9yIE5ldHdvcmtcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2hhdGhvci5uZXR3b3JrXCJcbiAgfSxcbiAgXCIyODFcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyODFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxMTlcIixcbiAgICBcInN5bWJvbFwiOiBcIkZDVElEXCIsXG4gICAgXCJuYW1lXCI6IFwiRmFjdG9tIElEXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL0ZhY3RvbVByb2plY3RcIlxuICB9LFxuICBcIjI4MlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjI4MlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDExYVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQlJBVk9cIixcbiAgICBcIm5hbWVcIjogXCJCUkFWT1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYnJhdm9jb2luLmNvbVwiXG4gIH0sXG4gIFwiMjgzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjgzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTFiXCIsXG4gICAgXCJzeW1ib2xcIjogXCJBTEdPXCIsXG4gICAgXCJuYW1lXCI6IFwiQWxnb3JhbmRcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5hbGdvcmFuZC5jb21cIlxuICB9LFxuICBcIjI4NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjI4NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDExY1wiLFxuICAgIFwic3ltYm9sXCI6IFwiQlpYXCIsXG4gICAgXCJuYW1lXCI6IFwiQml0Y29pbnplcm9cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2JpdGNvaW56ZXJveC5uZXRcIlxuICB9LFxuICBcIjI4NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjI4NVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDExZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiR1hYXCIsXG4gICAgXCJuYW1lXCI6IFwiR3Jhdml0eUNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5ncmF2aXR5Y29pbi5pb1wiXG4gIH0sXG4gIFwiMjg2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjg2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTFlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJIRUFUXCIsXG4gICAgXCJuYW1lXCI6IFwiSEVBVFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vaGVhdGxlZGdlci5jb21cIlxuICB9LFxuICBcIjI4N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjI4N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDExZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiWEROXCIsXG4gICAgXCJuYW1lXCI6IFwiRGlnaXRhbE5vdGVcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2RpZ2l0YWxub3RlLmJpelwiXG4gIH0sXG4gIFwiMjg4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjg4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTIwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJGU05cIixcbiAgICBcIm5hbWVcIjogXCJGVVNJT05cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5mdXNpb24ub3JnXCJcbiAgfSxcbiAgXCIyODlcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyODlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxMjFcIixcbiAgICBcInN5bWJvbFwiOiBcIkNQQ1wiLFxuICAgIFwibmFtZVwiOiBcIkNhcHJpY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vY2Fwcmljb2luLm9yZ1wiXG4gIH0sXG4gIFwiMjkwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjkwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTIyXCIsXG4gICAgXCJzeW1ib2xcIjogXCJCT0xEXCIsXG4gICAgXCJuYW1lXCI6IFwiQm9sZFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYm9sZHByaXZhdGUubmV0d29ya1wiXG4gIH0sXG4gIFwiMjkxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjkxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTIzXCIsXG4gICAgXCJzeW1ib2xcIjogXCJJT1NUXCIsXG4gICAgXCJuYW1lXCI6IFwiSU9TVFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vaW9zdC5pb1wiXG4gIH0sXG4gIFwiMjkyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjkyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTI0XCIsXG4gICAgXCJzeW1ib2xcIjogXCJUS0VZXCIsXG4gICAgXCJuYW1lXCI6IFwiVGtleWNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3RrZXljb2luLmNvbVwiXG4gIH0sXG4gIFwiMjkzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjkzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTI1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJVU0VcIixcbiAgICBcIm5hbWVcIjogXCJVc2VjaGFpblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vdXNlY2hhaW4ubmV0XCJcbiAgfSxcbiAgXCIyOTRcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyOTRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxMjZcIixcbiAgICBcInN5bWJvbFwiOiBcIkJDWlwiLFxuICAgIFwibmFtZVwiOiBcIkJpdGNvaW5DWlwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmJpdGNvaW5jei5vcmdcIlxuICB9LFxuICBcIjI5NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjI5NVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDEyN1wiLFxuICAgIFwic3ltYm9sXCI6IFwiSU9DXCIsXG4gICAgXCJuYW1lXCI6IFwiSW9jb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9pb2NvaW4uaW9cIlxuICB9LFxuICBcIjI5NlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjI5NlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDEyOFwiLFxuICAgIFwic3ltYm9sXCI6IFwiQVNGXCIsXG4gICAgXCJuYW1lXCI6IFwiQXNvZmVcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dpdGh1Yi5jb20vVGhlTGlnaHRTaWRlL2Fzb2ZlXCJcbiAgfSxcbiAgXCIyOTdcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyOTdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxMjlcIixcbiAgICBcInN5bWJvbFwiOiBcIk1BU1NcIixcbiAgICBcIm5hbWVcIjogXCJNQVNTXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cubWFzc25ldC5vcmdcIlxuICB9LFxuICBcIjI5OFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjI5OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDEyYVwiLFxuICAgIFwic3ltYm9sXCI6IFwiRkFJUlwiLFxuICAgIFwibmFtZVwiOiBcIkZhaXJDb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9mYWlyY29pbi53b3JsZFwiXG4gIH0sXG4gIFwiMjk5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjk5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTJiXCIsXG4gICAgXCJzeW1ib2xcIjogXCJOVUtPXCIsXG4gICAgXCJuYW1lXCI6IFwiTmVrb25pdW1cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL25la29uaXVtLmdpdGh1Yi5pb1wiXG4gIH0sXG4gIFwiMzAwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzAwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTJjXCIsXG4gICAgXCJzeW1ib2xcIjogXCJHTlhcIixcbiAgICBcIm5hbWVcIjogXCJHZW5hcm8gTmV0d29ya1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2VuYXJvLm5ldHdvcmtcIlxuICB9LFxuICBcIjMwMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjMwMVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDEyZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiRElWSVwiLFxuICAgIFwibmFtZVwiOiBcIkRpdmkgUHJvamVjdFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZGl2aXByb2plY3Qub3JnXCJcbiAgfSxcbiAgXCIzMDJcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzMDJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxMmVcIixcbiAgICBcInN5bWJvbFwiOiBcIkNNVFwiLFxuICAgIFwibmFtZVwiOiBcIkNvbW11bml0eVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vdGhlY3JpcHRvY29tbXVuaXR5LmNvbVwiXG4gIH0sXG4gIFwiMzAzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzAzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTJmXCIsXG4gICAgXCJzeW1ib2xcIjogXCJFVU5PXCIsXG4gICAgXCJuYW1lXCI6IFwiRVVOT1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZXVuby5jb1wiXG4gIH0sXG4gIFwiMzA0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzA0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTMwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJJT1RYXCIsXG4gICAgXCJuYW1lXCI6IFwiSW9UZVhcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2lvdGV4LmlvXCJcbiAgfSxcbiAgXCIzMDVcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzMDVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxMzFcIixcbiAgICBcInN5bWJvbFwiOiBcIk9OSU9OXCIsXG4gICAgXCJuYW1lXCI6IFwiRGVlcE9uaW9uXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9kZWVwb25pb24ub3JnXCJcbiAgfSxcbiAgXCIzMDZcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzMDZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxMzJcIixcbiAgICBcInN5bWJvbFwiOiBcIjhCSVRcIixcbiAgICBcIm5hbWVcIjogXCI4Qml0XCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly84Yml0LmNhc2hcIlxuICB9LFxuICBcIjMwN1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjMwN1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDEzM1wiLFxuICAgIFwic3ltYm9sXCI6IFwiQVRDXCIsXG4gICAgXCJuYW1lXCI6IFwiQVRva2VuIENvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5hdG9rZW4uY29tXCJcbiAgfSxcbiAgXCIzMDhcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzMDhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxMzRcIixcbiAgICBcInN5bWJvbFwiOiBcIkJUU1wiLFxuICAgIFwibmFtZVwiOiBcIkJpdHNoYXJlc1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYml0c2hhcmVzLm9yZ1wiXG4gIH0sXG4gIFwiMzA5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzA5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTM1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJDS0JcIixcbiAgICBcIm5hbWVcIjogXCJOZXJ2b3MgQ0tCXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cubmVydm9zLm9yZ1wiXG4gIH0sXG4gIFwiMzEwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzEwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTM2XCIsXG4gICAgXCJzeW1ib2xcIjogXCJVR0FTXCIsXG4gICAgXCJuYW1lXCI6IFwiVWx0cmFpblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LnVsdHJhaW4uaW9cIlxuICB9LFxuICBcIjMxMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjMxMVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDEzN1wiLFxuICAgIFwic3ltYm9sXCI6IFwiQURTXCIsXG4gICAgXCJuYW1lXCI6IFwiQWRzaGFyZXNcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2Fkc2hhcmVzLm5ldFwiXG4gIH0sXG4gIFwiMzEyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzEyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTM4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJBUkFcIixcbiAgICBcIm5hbWVcIjogXCJBdXJhXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9hdXJhbGVkZ2VyLmNvbVwiXG4gIH0sXG4gIFwiMzEzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzEzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTM5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJaSUxcIixcbiAgICBcIm5hbWVcIjogXCJaaWxsaXFhXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly96aWxsaXFhLmNvbVwiXG4gIH0sXG4gIFwiMzE0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzE0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTNhXCIsXG4gICAgXCJzeW1ib2xcIjogXCJNT0FDXCIsXG4gICAgXCJuYW1lXCI6IFwiTU9BQ1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbW9hYy5pb1wiXG4gIH0sXG4gIFwiMzE1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzE1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTNiXCIsXG4gICAgXCJzeW1ib2xcIjogXCJTV1RDXCIsXG4gICAgXCJuYW1lXCI6IFwiU1dUQ1wiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly9zd3RjLnRvcFwiXG4gIH0sXG4gIFwiMzE2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzE2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTNjXCIsXG4gICAgXCJzeW1ib2xcIjogXCJWTlNDXCIsXG4gICAgXCJuYW1lXCI6IFwidm5zY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly93d3cudm5zY29pbi5vcmdcIlxuICB9LFxuICBcIjMxN1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjMxN1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDEzZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiUExVR1wiLFxuICAgIFwibmFtZVwiOiBcIlBsXmdcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5wb3dlcmVkYnlwbHVnLmNvbVwiXG4gIH0sXG4gIFwiMzE4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzE4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTNlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJNQU5cIixcbiAgICBcIm5hbWVcIjogXCJNYXRyaXggQUkgTmV0d29ya1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3Lm1hdHJpeC5pb1wiXG4gIH0sXG4gIFwiMzE5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzE5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTNmXCIsXG4gICAgXCJzeW1ib2xcIjogXCJFQ0NcIixcbiAgICBcIm5hbWVcIjogXCJFQ0NvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2VjYy5uZXR3b3JrXCJcbiAgfSxcbiAgXCIzMjBcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzMjBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxNDBcIixcbiAgICBcInN5bWJvbFwiOiBcIlJQRFwiLFxuICAgIFwibmFtZVwiOiBcIlJhcGlkc1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LnJhcGlkc25ldHdvcmsuaW9cIlxuICB9LFxuICBcIjMyMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjMyMVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE0MVwiLFxuICAgIFwic3ltYm9sXCI6IFwiUkFQXCIsXG4gICAgXCJuYW1lXCI6IFwiUmFwdHVyZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vb3VyLXJhcHR1cmUuY29tXCJcbiAgfSxcbiAgXCIzMjJcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzMjJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxNDJcIixcbiAgICBcInN5bWJvbFwiOiBcIkdBUkRcIixcbiAgICBcIm5hbWVcIjogXCJIYXNoZ2FyZFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3Lmhhc2hnYXJkLmlvXCJcbiAgfSxcbiAgXCIzMjNcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzMjNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxNDNcIixcbiAgICBcInN5bWJvbFwiOiBcIlpFUlwiLFxuICAgIFwibmFtZVwiOiBcIlplcm9cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy56ZXJvY3VycmVuY3kuaW9cIlxuICB9LFxuICBcIjMyNFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjMyNFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE0NFwiLFxuICAgIFwic3ltYm9sXCI6IFwiRUJTVFwiLFxuICAgIFwibmFtZVwiOiBcImVCb29zdFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZWJvb3N0LmZ1blwiXG4gIH0sXG4gIFwiMzI1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzI1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTQ1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJTSEFSRFwiLFxuICAgIFwibmFtZVwiOiBcIlNoYXJkXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9zaGFyZGNvaW4uaW9cIlxuICB9LFxuICBcIjMyNlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjMyNlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE0NlwiLFxuICAgIFwic3ltYm9sXCI6IFwiTElOREFcIixcbiAgICBcIm5hbWVcIjogXCJMaW5kYSBDb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9saW5kYWNvaW4uY29tXCJcbiAgfSxcbiAgXCIzMjdcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzMjdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxNDdcIixcbiAgICBcInN5bWJvbFwiOiBcIkNNTVwiLFxuICAgIFwibmFtZVwiOiBcIkNvbW1lcmNpdW1cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5jb21tZXJjaXVtLm5ldFwiXG4gIH0sXG4gIFwiMzI4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzI4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTQ4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJCTE9DS1wiLFxuICAgIFwibmFtZVwiOiBcIkJsb2NrbmV0XCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9ibG9ja25ldC5jb1wiXG4gIH0sXG4gIFwiMzI5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzI5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTQ5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJBVURBWFwiLFxuICAgIFwibmFtZVwiOiBcIkFVREFYXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuYXVkYXhwcm9qZWN0LmlvXCJcbiAgfSxcbiAgXCIzMzBcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzMzBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxNGFcIixcbiAgICBcInN5bWJvbFwiOiBcIkxVTkFcIixcbiAgICBcIm5hbWVcIjogXCJUZXJyYVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vdGVycmEubW9uZXlcIlxuICB9LFxuICBcIjMzMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjMzMVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE0YlwiLFxuICAgIFwic3ltYm9sXCI6IFwiWlBNXCIsXG4gICAgXCJuYW1lXCI6IFwielByaW1lXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3pwcmltZWNvaW4venByaW1lXCJcbiAgfSxcbiAgXCIzMzJcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzMzJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxNGNcIixcbiAgICBcInN5bWJvbFwiOiBcIktVVkFcIixcbiAgICBcIm5hbWVcIjogXCJLdXZhIFV0aWxpdHkgTm90ZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3Lmt1dmFjYXNoLmNvbVwiXG4gIH0sXG4gIFwiMzMzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzMzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTRkXCIsXG4gICAgXCJzeW1ib2xcIjogXCJNRU1cIixcbiAgICBcIm5hbWVcIjogXCJNZW1Db2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9tZW1jb2luLm9yZ1wiXG4gIH0sXG4gIFwiMzM0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzM0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTRlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJDU1wiLFxuICAgIFwibmFtZVwiOiBcIkNyZWRpdHNcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2NyZWRpdHMuY29tXCJcbiAgfSxcbiAgXCIzMzVcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzMzVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxNGZcIixcbiAgICBcInN5bWJvbFwiOiBcIlNXSUZUXCIsXG4gICAgXCJuYW1lXCI6IFwiU3dpZnRDYXNoXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9zd2lmdGNhc2guY2NcIlxuICB9LFxuICBcIjMzNlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjMzNlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE1MFwiLFxuICAgIFwic3ltYm9sXCI6IFwiRklYXCIsXG4gICAgXCJuYW1lXCI6IFwiRklYXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9maXgubmV0d29ya1wiXG4gIH0sXG4gIFwiMzM3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzM3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTUxXCIsXG4gICAgXCJzeW1ib2xcIjogXCJDUENcIixcbiAgICBcIm5hbWVcIjogXCJDUENoYWluXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9jcGNoYWluLmlvXCJcbiAgfSxcbiAgXCIzMzhcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzMzhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxNTJcIixcbiAgICBcInN5bWJvbFwiOiBcIlZHT1wiLFxuICAgIFwibmFtZVwiOiBcIlZpcnR1YWxHb29kc1Rva2VuXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL3Znby5saWZlXCJcbiAgfSxcbiAgXCIzMzlcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzMzlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxNTNcIixcbiAgICBcInN5bWJvbFwiOiBcIkRWVFwiLFxuICAgIFwibmFtZVwiOiBcIkRlVmF1bHRcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2RldmF1bHQuY2NcIlxuICB9LFxuICBcIjM0MFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM0MFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE1NFwiLFxuICAgIFwic3ltYm9sXCI6IFwiTjhWXCIsXG4gICAgXCJuYW1lXCI6IFwiTjhWQ29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbjh2Y29pbi5pb1wiXG4gIH0sXG4gIFwiMzQxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzQxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTU1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJNVE5TXCIsXG4gICAgXCJuYW1lXCI6IFwiT21vdGVuYXNoaUNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwOi8vb21vdGVuYXNoaWNvaW4uc2l0ZVwiXG4gIH0sXG4gIFwiMzQyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzQyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTU2XCIsXG4gICAgXCJzeW1ib2xcIjogXCJCTEFTVFwiLFxuICAgIFwibmFtZVwiOiBcIkJMQVNUXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9ibGFzdGJsYXN0Ymxhc3QuY29tXCJcbiAgfSxcbiAgXCIzNDNcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzNDNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxNTdcIixcbiAgICBcInN5bWJvbFwiOiBcIkRDVFwiLFxuICAgIFwibmFtZVwiOiBcIkRFQ0VOVFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZGVjZW50LmNoXCJcbiAgfSxcbiAgXCIzNDRcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzNDRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxNThcIixcbiAgICBcInN5bWJvbFwiOiBcIkFVWFwiLFxuICAgIFwibmFtZVwiOiBcIkF1eGlsaXVtXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9hdXhpbGl1bS5nbG9iYWxcIlxuICB9LFxuICBcIjM0NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM0NVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE1OVwiLFxuICAgIFwic3ltYm9sXCI6IFwiVVNEUFwiLFxuICAgIFwibmFtZVwiOiBcIlVTRFBcIixcbiAgICBcImxpbmtcIjogXCJodHRwOi8vd3d3LnVzZHAucHJvXCJcbiAgfSxcbiAgXCIzNDZcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzNDZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxNWFcIixcbiAgICBcInN5bWJvbFwiOiBcIkhUREZcIixcbiAgICBcIm5hbWVcIjogXCJIVERGXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cub3JpZW50d2FsdC5jb21cIlxuICB9LFxuICBcIjM0N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM0N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE1YlwiLFxuICAgIFwic3ltYm9sXCI6IFwiWUVDXCIsXG4gICAgXCJuYW1lXCI6IFwiWWNhc2hcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy55Y2FzaC54eXpcIlxuICB9LFxuICBcIjM0OFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM0OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE1Y1wiLFxuICAgIFwic3ltYm9sXCI6IFwiUUxDXCIsXG4gICAgXCJuYW1lXCI6IFwiUUxDIENoYWluXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9xbGNjaGFpbi5vcmdcIlxuICB9LFxuICBcIjM0OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM0OVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE1ZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiVEVBXCIsXG4gICAgXCJuYW1lXCI6IFwiSWNldGVhIEJsb2NrY2hhaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2ljZXRlYS5pb1wiXG4gIH0sXG4gIFwiMzUwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzUwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTVlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJBUldcIixcbiAgICBcIm5hbWVcIjogXCJBcnJvd0NoYWluXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuYXJyb3djaGFpbi5pb1wiXG4gIH0sXG4gIFwiMzUxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzUxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTVmXCIsXG4gICAgXCJzeW1ib2xcIjogXCJNRE1cIixcbiAgICBcIm5hbWVcIjogXCJNZWRpdW1cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy50aGVtZWRpdW0uaW9cIlxuICB9LFxuICBcIjM1MlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM1MlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE2MFwiLFxuICAgIFwic3ltYm9sXCI6IFwiQ1lCXCIsXG4gICAgXCJuYW1lXCI6IFwiQ3liZXhcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2RleC5jeWJleC5pb1wiXG4gIH0sXG4gIFwiMzUzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzUzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTYxXCIsXG4gICAgXCJzeW1ib2xcIjogXCJMVE9cIixcbiAgICBcIm5hbWVcIjogXCJMVE8gTmV0d29ya1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbHRvLm5ldHdvcmtcIlxuICB9LFxuICBcIjM1NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM1NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE2MlwiLFxuICAgIFwic3ltYm9sXCI6IFwiRE9UXCIsXG4gICAgXCJuYW1lXCI6IFwiUG9sa2Fkb3RcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3BvbGthZG90Lm5ldHdvcmtcIlxuICB9LFxuICBcIjM1NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM1NVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE2M1wiLFxuICAgIFwic3ltYm9sXCI6IFwiQUVPTlwiLFxuICAgIFwibmFtZVwiOiBcIkFlb25cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5hZW9uLmNhc2hcIlxuICB9LFxuICBcIjM1NlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM1NlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE2NFwiLFxuICAgIFwic3ltYm9sXCI6IFwiUkVTXCIsXG4gICAgXCJuYW1lXCI6IFwiUmVzaXN0YW5jZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LnJlc2lzdGFuY2UuaW9cIlxuICB9LFxuICBcIjM1N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM1N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE2NVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQVlBXCIsXG4gICAgXCJuYW1lXCI6IFwiQXJ5YWNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2FyeWFjb2luLmlvXCJcbiAgfSxcbiAgXCIzNThcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzNThcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxNjZcIixcbiAgICBcInN5bWJvbFwiOiBcIkRBUFNcIixcbiAgICBcIm5hbWVcIjogXCJEYXBzY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vb2ZmaWNpYWxkYXBzY29pbi5jb21cIlxuICB9LFxuICBcIjM1OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM1OVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE2N1wiLFxuICAgIFwic3ltYm9sXCI6IFwiQ1NDXCIsXG4gICAgXCJuYW1lXCI6IFwiQ2FzaW5vQ29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vY2FzaW5vY29pbi5vcmdcIlxuICB9LFxuICBcIjM2MFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM2MFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE2OFwiLFxuICAgIFwic3ltYm9sXCI6IFwiVlNZU1wiLFxuICAgIFwibmFtZVwiOiBcIlYgU3lzdGVtc1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LnYuc3lzdGVtc1wiXG4gIH0sXG4gIFwiMzYxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzYxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTY5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJOT0xMQVJcIixcbiAgICBcIm5hbWVcIjogXCJOb2xsYXJcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL25vbGxhci5vcmdcIlxuICB9LFxuICBcIjM2MlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM2MlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE2YVwiLFxuICAgIFwic3ltYm9sXCI6IFwiWE5PU1wiLFxuICAgIFwibmFtZVwiOiBcIk5PU1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbm9zLmNhc2hcIlxuICB9LFxuICBcIjM2M1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM2M1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE2YlwiLFxuICAgIFwic3ltYm9sXCI6IFwiQ1BVXCIsXG4gICAgXCJuYW1lXCI6IFwiQ1BVY2hhaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2NwdWNoYWluLm9yZ1wiXG4gIH0sXG4gIFwiMzY0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzY0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTZjXCIsXG4gICAgXCJzeW1ib2xcIjogXCJMQU1CXCIsXG4gICAgXCJuYW1lXCI6IFwiTGFtYmRhIFN0b3JhZ2UgQ2hhaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2xhbWJkYS5pbVwiXG4gIH0sXG4gIFwiMzY1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzY1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTZkXCIsXG4gICAgXCJzeW1ib2xcIjogXCJWQ1RcIixcbiAgICBcIm5hbWVcIjogXCJWYWx1ZUN5YmVyXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly92YWx1ZWN5YmVyLm9yZ1wiXG4gIH0sXG4gIFwiMzY2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzY2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTZlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJDWlJcIixcbiAgICBcIm5hbWVcIjogXCJDYW5vbmNoYWluXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL3d3dy5jYW5vbmNoYWluLmNvbVwiXG4gIH0sXG4gIFwiMzY3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzY3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTZmXCIsXG4gICAgXCJzeW1ib2xcIjogXCJBQkJDXCIsXG4gICAgXCJuYW1lXCI6IFwiQUJCQ1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmFiYmNmb3VuZGF0aW9uLmNvbVwiXG4gIH0sXG4gIFwiMzY4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzY4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTcwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJIRVRcIixcbiAgICBcIm5hbWVcIjogXCJIRVRcIixcbiAgICBcImxpbmtcIjogXCJodHRwOi8vd3d3LmhldGNvaW4uaW5mb1wiXG4gIH0sXG4gIFwiMzY5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzY5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTcxXCIsXG4gICAgXCJzeW1ib2xcIjogXCJYQVNcIixcbiAgICBcIm5hbWVcIjogXCJBc2NoXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9hc2NoLmlvXCJcbiAgfSxcbiAgXCIzNzBcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzNzBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxNzJcIixcbiAgICBcInN5bWJvbFwiOiBcIlZETFwiLFxuICAgIFwibmFtZVwiOiBcIlZpZHVsdW1cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3ZpZHVsdW0uYXBwXCJcbiAgfSxcbiAgXCIzNzFcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzNzFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxNzNcIixcbiAgICBcInN5bWJvbFwiOiBcIk1FRFwiLFxuICAgIFwibmFtZVwiOiBcIk1lZGlCbG9jXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9tZWRpYmxvYy5vcmdcIlxuICB9LFxuICBcIjM3MlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM3MlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE3NFwiLFxuICAgIFwic3ltYm9sXCI6IFwiWlZDXCIsXG4gICAgXCJuYW1lXCI6IFwiWlZDaGFpblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3Lnp2Y2hhaW4uaW9cIlxuICB9LFxuICBcIjM3M1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM3M1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE3NVwiLFxuICAgIFwic3ltYm9sXCI6IFwiVkVTVFhcIixcbiAgICBcIm5hbWVcIjogXCJWZXN0eFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LnZlc3R4Y29pbi5jb21cIlxuICB9LFxuICBcIjM3NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM3NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE3NlwiLFxuICAgIFwic3ltYm9sXCI6IFwiREJUXCIsXG4gICAgXCJuYW1lXCI6IFwiRGFya0JpdFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LkRhcmtCaXRQYXkuY29tXCJcbiAgfSxcbiAgXCIzNzVcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzNzVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxNzdcIixcbiAgICBcInN5bWJvbFwiOiBcIlNFT1NcIixcbiAgICBcIm5hbWVcIjogXCJTdXBlckVPU1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9zdXBlcmVvc1wiXG4gIH0sXG4gIFwiMzc2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzc2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTc4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJNWFdcIixcbiAgICBcIm5hbWVcIjogXCJNYXhvbnJvd1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbWF4b25yb3cuY29tXCJcbiAgfSxcbiAgXCIzNzdcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzNzdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxNzlcIixcbiAgICBcInN5bWJvbFwiOiBcIlpOWlwiLFxuICAgIFwibmFtZVwiOiBcIlpFTlpPXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly96ZW56by5pb1wiXG4gIH0sXG4gIFwiMzc4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzc4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTdhXCIsXG4gICAgXCJzeW1ib2xcIjogXCJYQ1hcIixcbiAgICBcIm5hbWVcIjogXCJYQ2hhaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dpdGh1Yi5jb20veGNoYWlueGNoYWluXCJcbiAgfSxcbiAgXCIzNzlcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzNzlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxN2JcIixcbiAgICBcInN5bWJvbFwiOiBcIlNPWFwiLFxuICAgIFwibmFtZVwiOiBcIlNvbmljWFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vc29uaWN4Lm9yZ1wiXG4gIH0sXG4gIFwiMzgwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzgwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTdjXCIsXG4gICAgXCJzeW1ib2xcIjogXCJOWVpPXCIsXG4gICAgXCJuYW1lXCI6IFwiTnl6b1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbnl6by5jb1wiXG4gIH0sXG4gIFwiMzgxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzgxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTdkXCIsXG4gICAgXCJzeW1ib2xcIjogXCJVTENcIixcbiAgICBcIm5hbWVcIjogXCJVTENvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwOi8vd3d3LnVsd2FsbGV0LmlvXCJcbiAgfSxcbiAgXCIzODJcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzODJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxN2VcIixcbiAgICBcInN5bWJvbFwiOiBcIlJZT1wiLFxuICAgIFwibmFtZVwiOiBcIlJ5byBDdXJyZW5jeVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vcnlvLWN1cnJlbmN5LmNvbVwiXG4gIH0sXG4gIFwiMzgzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzgzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTdmXCIsXG4gICAgXCJzeW1ib2xcIjogXCJLQUxcIixcbiAgICBcIm5hbWVcIjogXCJLYWxlaWRvY2hhaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2thbGVpZG9jaGFpbi5pb1wiXG4gIH0sXG4gIFwiMzg0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzg0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTgwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJYU05cIixcbiAgICBcIm5hbWVcIjogXCJTdGFrZW5ldFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8veHNuY29pbi5pb1wiXG4gIH0sXG4gIFwiMzg1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzg1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTgxXCIsXG4gICAgXCJzeW1ib2xcIjogXCJET0dFQ1wiLFxuICAgIFwibmFtZVwiOiBcIkRvZ2VDYXNoXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9kb2dlYy5pb1wiXG4gIH0sXG4gIFwiMzg2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzg2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTgyXCIsXG4gICAgXCJzeW1ib2xcIjogXCJCTVZcIixcbiAgICBcIm5hbWVcIjogXCJCaXRjb2luIE1hdHRlbydzIFZpc2lvblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYnRjbXYub3JnXCJcbiAgfSxcbiAgXCIzODdcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzODdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxODNcIixcbiAgICBcInN5bWJvbFwiOiBcIlFCQ1wiLFxuICAgIFwibmFtZVwiOiBcIlF1ZWJlY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9RdWViZWNvaW5RQkMvcXVlYmVjb2luXCJcbiAgfSxcbiAgXCIzODhcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzODhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxODRcIixcbiAgICBcInN5bWJvbFwiOiBcIklNR1wiLFxuICAgIFwibmFtZVwiOiBcIkltYWdlQ29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vaW1hZ2Vjb2luLmltYWdlaG9zdHkuY29tXCJcbiAgfSxcbiAgXCIzODlcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzODlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxODVcIixcbiAgICBcInN5bWJvbFwiOiBcIlFPU1wiLFxuICAgIFwibmFtZVwiOiBcIlFPU1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9RT1NHcm91cC9xb3NcIlxuICB9LFxuICBcIjM5MFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM5MFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE4NlwiLFxuICAgIFwic3ltYm9sXCI6IFwiUEtUXCIsXG4gICAgXCJuYW1lXCI6IFwiUEtUXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3BrdC1jYXNoL3BrdGRcIlxuICB9LFxuICBcIjM5MVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM5MVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE4N1wiLFxuICAgIFwic3ltYm9sXCI6IFwiTEhEXCIsXG4gICAgXCJuYW1lXCI6IFwiTGl0ZWNvaW5IRFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbHRjaGQuaW9cIlxuICB9LFxuICBcIjM5MlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM5MlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE4OFwiLFxuICAgIFwic3ltYm9sXCI6IFwiQ0VOTlpcIixcbiAgICBcIm5hbWVcIjogXCJDRU5OWm5ldFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vY2VudHJhbGl0eS5haVwiXG4gIH0sXG4gIFwiMzkzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzkzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTg5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJIU05cIixcbiAgICBcIm5hbWVcIjogXCJIeXBlciBTcGVlZCBOZXR3b3JrXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuaHNuLmxpbmtcIlxuICB9LFxuICBcIjM5NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM5NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE4YVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQ1JPXCIsXG4gICAgXCJuYW1lXCI6IFwiQ3J5cHRvLm9yZyBDaGFpblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vY3J5cHRvLm9yZ1wiXG4gIH0sXG4gIFwiMzk1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzk1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMThiXCIsXG4gICAgXCJzeW1ib2xcIjogXCJVTUJSVVwiLFxuICAgIFwibmFtZVwiOiBcIlVtYnJ1XCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly91bWJydS5pb1wiXG4gIH0sXG4gIFwiMzk2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzk2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMThjXCIsXG4gICAgXCJzeW1ib2xcIjogXCJUT05cIixcbiAgICBcIm5hbWVcIjogXCJGcmVlIFRPTlwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZnJlZXRvbi5vcmdcIlxuICB9LFxuICBcIjM5N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM5N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE4ZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiTkVBUlwiLFxuICAgIFwibmFtZVwiOiBcIk5FQVIgUHJvdG9jb2xcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL25lYXJwcm90b2NvbC5jb21cIlxuICB9LFxuICBcIjM5OFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM5OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE4ZVwiLFxuICAgIFwic3ltYm9sXCI6IFwiWFBDXCIsXG4gICAgXCJuYW1lXCI6IFwiWFBDaGFpblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LnhwY2hhaW4uaW9cIlxuICB9LFxuICBcIjM5OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM5OVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE4ZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiWk9DXCIsXG4gICAgXCJuYW1lXCI6IFwiMDFjb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly8wMWNvaW4uaW9cIlxuICB9LFxuICBcIjQwMFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQwMFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE5MFwiLFxuICAgIFwic3ltYm9sXCI6IFwiTklYXCIsXG4gICAgXCJuYW1lXCI6IFwiTklYXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9uaXhwbGF0Zm9ybS5pb1wiXG4gIH0sXG4gIFwiNDAxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDAxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTkxXCIsXG4gICAgXCJzeW1ib2xcIjogXCJVQ1wiLFxuICAgIFwibmFtZVwiOiBcIlV0b3BpYWNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3V0b3BpYWNvaW4ub3JnXCJcbiAgfSxcbiAgXCI0MDJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0MDJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxOTJcIixcbiAgICBcInN5bWJvbFwiOiBcIkdBTElcIixcbiAgICBcIm5hbWVcIjogXCJHYWxpbGVsXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9nYWxpbGVsLm9yZ1wiXG4gIH0sXG4gIFwiNDAzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDAzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTkzXCIsXG4gICAgXCJzeW1ib2xcIjogXCJPTFRcIixcbiAgICBcIm5hbWVcIjogXCJPbmVsZWRnZXJcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5vbmVsZWRnZXIuaW9cIlxuICB9LFxuICBcIjQwNFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQwNFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE5NFwiLFxuICAgIFwic3ltYm9sXCI6IFwiWEJJXCIsXG4gICAgXCJuYW1lXCI6IFwiWEJJXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9iaXRjb2luaW5jb2duaXRvLm9yZ1wiXG4gIH0sXG4gIFwiNDA1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDA1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTk1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJET05VXCIsXG4gICAgXCJuYW1lXCI6IFwiRE9OVVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZG9udS5pb1wiXG4gIH0sXG4gIFwiNDA2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDA2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTk2XCIsXG4gICAgXCJzeW1ib2xcIjogXCJFQVJUSFNcIixcbiAgICBcIm5hbWVcIjogXCJFYXJ0aHNcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2VhcnRocy5nYVwiXG4gIH0sXG4gIFwiNDA3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDA3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTk3XCIsXG4gICAgXCJzeW1ib2xcIjogXCJIRERcIixcbiAgICBcIm5hbWVcIjogXCJIRERDYXNoXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9oZGQuY2FzaFwiXG4gIH0sXG4gIFwiNDA4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDA4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTk4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJTVUdBUlwiLFxuICAgIFwibmFtZVwiOiBcIlN1Z2FyY2hhaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3N1Z2FyY2hhaW4ub3JnXCJcbiAgfSxcbiAgXCI0MDlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0MDlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxOTlcIixcbiAgICBcInN5bWJvbFwiOiBcIkFJTEVcIixcbiAgICBcIm5hbWVcIjogXCJBaWxlQ29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYWlsZWNvaW4uY29tXCJcbiAgfSxcbiAgXCI0MTBcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0MTBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxOWFcIixcbiAgICBcInN5bWJvbFwiOiBcIlRFTlRcIixcbiAgICBcIm5hbWVcIjogXCJURU5UXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly90ZW50LmFwcFwiXG4gIH0sXG4gIFwiNDExXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDExXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTliXCIsXG4gICAgXCJzeW1ib2xcIjogXCJUQU5cIixcbiAgICBcIm5hbWVcIjogXCJUYW5nZXJpbmUgTmV0d29ya1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vdGFuZ2VyaW5lLW5ldHdvcmsuaW9cIlxuICB9LFxuICBcIjQxMlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQxMlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE5Y1wiLFxuICAgIFwic3ltYm9sXCI6IFwiQUlOXCIsXG4gICAgXCJuYW1lXCI6IFwiQUlOXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuYWluZXR3b3JrLmFpXCJcbiAgfSxcbiAgXCI0MTNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0MTNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxOWRcIixcbiAgICBcInN5bWJvbFwiOiBcIk1TUlwiLFxuICAgIFwibmFtZVwiOiBcIk1hc2FyaVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2V0bWFzYXJpLm9yZ1wiXG4gIH0sXG4gIFwiNDE0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDE0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMTllXCIsXG4gICAgXCJzeW1ib2xcIjogXCJTVU1PXCIsXG4gICAgXCJuYW1lXCI6IFwiU3Vtb2tvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5zdW1va29pbi5vcmdcIlxuICB9LFxuICBcIjQxNVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQxNVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDE5ZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiRVROXCIsXG4gICAgXCJuYW1lXCI6IFwiRWxlY3Ryb25ldW1cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2VsZWN0cm9uZXVtLmNvbVwiXG4gIH0sXG4gIFwiNDE2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDE2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWEwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJCWVRaXCIsXG4gICAgXCJuYW1lXCI6IFwiQllUWlwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYnl0ei5nZ1wiXG4gIH0sXG4gIFwiNDE3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDE3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWExXCIsXG4gICAgXCJzeW1ib2xcIjogXCJXT1dcIixcbiAgICBcIm5hbWVcIjogXCJXb3duZXJvXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL3dvd25lcm8ub3JnXCJcbiAgfSxcbiAgXCI0MThcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0MThcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxYTJcIixcbiAgICBcInN5bWJvbFwiOiBcIlhUTkNcIixcbiAgICBcIm5hbWVcIjogXCJYdGVuZENhc2hcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3h0ZW5kY2FzaC5jb21cIlxuICB9LFxuICBcIjQxOVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQxOVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFhM1wiLFxuICAgIFwic3ltYm9sXCI6IFwiTFRITlwiLFxuICAgIFwibmFtZVwiOiBcIkxldGhlYW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2xldGhlYW4uaW9cIlxuICB9LFxuICBcIjQyMFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQyMFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFhNFwiLFxuICAgIFwic3ltYm9sXCI6IFwiTk9ERVwiLFxuICAgIFwibmFtZVwiOiBcIk5vZGVIb3N0XCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9ub2RlaG9zdC5vbmxpbmVcIlxuICB9LFxuICBcIjQyMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQyMVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFhNVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQUdNXCIsXG4gICAgXCJuYW1lXCI6IFwiQXJnb25ldW1cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2FyZ29uZXVtLm5ldFwiXG4gIH0sXG4gIFwiNDIyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDIyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWE2XCIsXG4gICAgXCJzeW1ib2xcIjogXCJDQ1hcIixcbiAgICBcIm5hbWVcIjogXCJDb25jZWFsIE5ldHdvcmtcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2NvbmNlYWwubmV0d29ya1wiXG4gIH0sXG4gIFwiNDIzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDIzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWE3XCIsXG4gICAgXCJzeW1ib2xcIjogXCJUTkVUXCIsXG4gICAgXCJuYW1lXCI6IFwiVGl0bGUgTmV0d29ya1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vdGl0bGUubmV0d29ya1wiXG4gIH0sXG4gIFwiNDI0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDI0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWE4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJURUxPU1wiLFxuICAgIFwibmFtZVwiOiBcIlRlbG9zQ29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vdGVsb3Njb2luLm9yZ1wiXG4gIH0sXG4gIFwiNDI1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDI1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWE5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJBSU9OXCIsXG4gICAgXCJuYW1lXCI6IFwiQWlvblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYWlvbi5uZXR3b3JrXCJcbiAgfSxcbiAgXCI0MjZcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0MjZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxYWFcIixcbiAgICBcInN5bWJvbFwiOiBcIkJDXCIsXG4gICAgXCJuYW1lXCI6IFwiQml0Y29pbiBDb25maWRlbnRpYWxcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5iaXRjb2luY29uZmlkZW50aWFsLmNjXCJcbiAgfSxcbiAgXCI0MjdcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0MjdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxYWJcIixcbiAgICBcInN5bWJvbFwiOiBcIktUVlwiLFxuICAgIFwibmFtZVwiOiBcIkttdXNoaUNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3RpZXJyYXZpdmFwbGFuZXQuY29tXCJcbiAgfSxcbiAgXCI0MjhcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0MjhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxYWNcIixcbiAgICBcInN5bWJvbFwiOiBcIlpDUlwiLFxuICAgIFwibmFtZVwiOiBcIlpDb3JlXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly96Y29yZS5jYXNoXCJcbiAgfSxcbiAgXCI0MjlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0MjlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxYWRcIixcbiAgICBcInN5bWJvbFwiOiBcIkVSR1wiLFxuICAgIFwibmFtZVwiOiBcIkVyZ29cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2VyZ29wbGF0Zm9ybS5vcmdcIlxuICB9LFxuICBcIjQzMFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQzMFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFhZVwiLFxuICAgIFwic3ltYm9sXCI6IFwiUEVTT1wiLFxuICAgIFwibmFtZVwiOiBcIkNyaXB0b3Blc29cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2NyaXB0b3Blc28uaW9cIlxuICB9LFxuICBcIjQzMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQzMVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFhZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiQlRDMlwiLFxuICAgIFwibmFtZVwiOiBcIkJpdGNvaW4gMlwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmJpdGMyLm9yZ1wiXG4gIH0sXG4gIFwiNDMyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDMyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWIwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJYUlBIRFwiLFxuICAgIFwibmFtZVwiOiBcIlhSUEhEXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly94cnBoZC5vcmdcIlxuICB9LFxuICBcIjQzM1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQzM1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFiMVwiLFxuICAgIFwic3ltYm9sXCI6IFwiV0VcIixcbiAgICBcIm5hbWVcIjogXCJXRSBDb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93ZS1jb3JwLmlvXCJcbiAgfSxcbiAgXCI0MzRcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0MzRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxYjJcIixcbiAgICBcInN5bWJvbFwiOiBcIktTTVwiLFxuICAgIFwibmFtZVwiOiBcIkt1c2FtYVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8va3VzYW1hLm5ldHdvcmtcIlxuICB9LFxuICBcIjQzNVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQzNVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFiM1wiLFxuICAgIFwic3ltYm9sXCI6IFwiUENOXCIsXG4gICAgXCJuYW1lXCI6IFwiUGVlcGNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3B4bi5mb3VuZGF0aW9uL3BlZXBjb2luXCJcbiAgfSxcbiAgXCI0MzZcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0MzZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxYjRcIixcbiAgICBcInN5bWJvbFwiOiBcIk5DSFwiLFxuICAgIFwibmFtZVwiOiBcIk5ldENsb3RoXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cubmV0Y2xvdGgub3JnXCJcbiAgfSxcbiAgXCI0MzdcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0MzdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxYjVcIixcbiAgICBcInN5bWJvbFwiOiBcIklDVVwiLFxuICAgIFwibmFtZVwiOiBcIkNISVBPXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL3d3dy5jaGlwby5pY3VcIlxuICB9LFxuICBcIjQzOFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQzOFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFiNlwiLFxuICAgIFwic3ltYm9sXCI6IFwiTE5cIixcbiAgICBcIm5hbWVcIjogXCJMSU5LXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9saW5rLm5ldHdvcmtcIlxuICB9LFxuICBcIjQzOVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQzOVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFiN1wiLFxuICAgIFwic3ltYm9sXCI6IFwiRFRQXCIsXG4gICAgXCJuYW1lXCI6IFwiRGVWYXVsdCBUb2tlbiBQcm90b2NvbFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZGV2YXVsdC5jYy90b2tlbi1wcm90b2NvbC5odG1sXCJcbiAgfSxcbiAgXCI0NDBcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0NDBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxYjhcIixcbiAgICBcInN5bWJvbFwiOiBcIkJUQ1JcIixcbiAgICBcIm5hbWVcIjogXCJCaXRjb2luIFJveWFsZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYml0Y29pbnJveWFsZS5vcmdcIlxuICB9LFxuICBcIjQ0MVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQ0MVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFiOVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQUVSR09cIixcbiAgICBcIm5hbWVcIjogXCJBRVJHT1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmFlcmdvLmlvXCJcbiAgfSxcbiAgXCI0NDJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0NDJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxYmFcIixcbiAgICBcInN5bWJvbFwiOiBcIlhUSFwiLFxuICAgIFwibmFtZVwiOiBcIkRvdGhlcmV1bVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZG90aGVyZXVtLm5ldFwiXG4gIH0sXG4gIFwiNDQzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDQzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWJiXCIsXG4gICAgXCJzeW1ib2xcIjogXCJMVlwiLFxuICAgIFwibmFtZVwiOiBcIkxhdmFcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5sYXZhdGVjaC5vcmdcIlxuICB9LFxuICBcIjQ0NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQ0NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFiY1wiLFxuICAgIFwic3ltYm9sXCI6IFwiUEhSXCIsXG4gICAgXCJuYW1lXCI6IFwiUGhvcmVcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3Bob3JlLmlvXCJcbiAgfSxcbiAgXCI0NDVcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0NDVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxYmRcIixcbiAgICBcInN5bWJvbFwiOiBcIlZJVEFFXCIsXG4gICAgXCJuYW1lXCI6IFwiVml0YWVcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy52aXRhZXRva2VuLmlvXCJcbiAgfSxcbiAgXCI0NDZcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0NDZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxYmVcIixcbiAgICBcInN5bWJvbFwiOiBcIkNPQ09TXCIsXG4gICAgXCJuYW1lXCI6IFwiQ29jb3MtQkNYXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuY29jb3NiY3guaW9cIlxuICB9LFxuICBcIjQ0N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQ0N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFiZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiRElOXCIsXG4gICAgXCJuYW1lXCI6IFwiRGluZXJvXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9kaW5lcm9jb2luLm9yZ1wiXG4gIH0sXG4gIFwiNDQ4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDQ4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWMwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJTUExcIixcbiAgICBcIm5hbWVcIjogXCJTaW1wbGljaXR5XCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9zaW1wbGljaXR5LWNvaW4uY29tXCJcbiAgfSxcbiAgXCI0NDlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0NDlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxYzFcIixcbiAgICBcInN5bWJvbFwiOiBcIllDRVwiLFxuICAgIFwibmFtZVwiOiBcIk1ZQ0VcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL215Y2Uud29ybGRcIlxuICB9LFxuICBcIjQ1MFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQ1MFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFjMlwiLFxuICAgIFwic3ltYm9sXCI6IFwiWExSXCIsXG4gICAgXCJuYW1lXCI6IFwiU29sYXJpc1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vc29sYXJpc3BsYXRmb3JtLmNvbVwiXG4gIH0sXG4gIFwiNDUxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDUxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWMzXCIsXG4gICAgXCJzeW1ib2xcIjogXCJLVFNcIixcbiAgICBcIm5hbWVcIjogXCJLbGltYXRhc1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmtsaW1hdGFzLmNvbVwiXG4gIH0sXG4gIFwiNDUyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDUyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWM0XCIsXG4gICAgXCJzeW1ib2xcIjogXCJER0xEXCIsXG4gICAgXCJuYW1lXCI6IFwiREdMRFwiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly9kZ2xkLmNoXCJcbiAgfSxcbiAgXCI0NTNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0NTNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxYzVcIixcbiAgICBcInN5bWJvbFwiOiBcIlhOU1wiLFxuICAgIFwibmFtZVwiOiBcIkluc29sYXJcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2luc29sYXIuaW9cIlxuICB9LFxuICBcIjQ1NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQ1NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFjNlwiLFxuICAgIFwic3ltYm9sXCI6IFwiRU1cIixcbiAgICBcIm5hbWVcIjogXCJFTVBPV1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZW1wb3cuaW9cIlxuICB9LFxuICBcIjQ1NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQ1NVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFjN1wiLFxuICAgIFwic3ltYm9sXCI6IFwiU0hOXCIsXG4gICAgXCJuYW1lXCI6IFwiU2hpbmVCbG9ja3NcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5zaGluZWJsb2Nrcy5jb21cIlxuICB9LFxuICBcIjQ1NlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQ1NlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFjOFwiLFxuICAgIFwic3ltYm9sXCI6IFwiU0VFTEVcIixcbiAgICBcIm5hbWVcIjogXCJTZWVsZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vc2VlbGVuZXQuY29tXCJcbiAgfSxcbiAgXCI0NTdcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0NTdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxYzlcIixcbiAgICBcInN5bWJvbFwiOiBcIkFFXCIsXG4gICAgXCJuYW1lXCI6IFwiw6Z0ZXJuaXR5XCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9hZXRlcm5pdHkuY29tXCJcbiAgfSxcbiAgXCI0NThcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0NThcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxY2FcIixcbiAgICBcInN5bWJvbFwiOiBcIk9EWFwiLFxuICAgIFwibmFtZVwiOiBcIk9ic2lkaWFuWFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vb2JzaWRpYW5wcm9qZWN0Lm9yZ1wiXG4gIH0sXG4gIFwiNDU5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDU5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWNiXCIsXG4gICAgXCJzeW1ib2xcIjogXCJLQVZBXCIsXG4gICAgXCJuYW1lXCI6IFwiS2F2YVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8va2F2YS5pb1wiXG4gIH0sXG4gIFwiNDYwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDYwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWNjXCIsXG4gICAgXCJzeW1ib2xcIjogXCJHTEVFQ1wiLFxuICAgIFwibmFtZVwiOiBcIkdMRUVDXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9nbGVlY29pbi5jb21cIlxuICB9LFxuICBcIjQ2MVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQ2MVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFjZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiRklMXCIsXG4gICAgXCJuYW1lXCI6IFwiRmlsZWNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2ZpbGVjb2luLmlvXCJcbiAgfSxcbiAgXCI0NjJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0NjJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxY2VcIixcbiAgICBcInN5bWJvbFwiOiBcIlJVVEFcIixcbiAgICBcIm5hbWVcIjogXCJSdXRhbmlvXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9ydXRhbmlvLmNvbVwiXG4gIH0sXG4gIFwiNDYzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDYzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWNmXCIsXG4gICAgXCJzeW1ib2xcIjogXCJDU0RUXCIsXG4gICAgXCJuYW1lXCI6IFwiQ1NEVFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8veGFyLm5ldHdvcmtcIlxuICB9LFxuICBcIjQ2NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQ2NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFkMFwiLFxuICAgIFwic3ltYm9sXCI6IFwiRVRJXCIsXG4gICAgXCJuYW1lXCI6IFwiRXRoZXJJbmNcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2VpbmMuaW9cIlxuICB9LFxuICBcIjQ2NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQ2NVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFkMVwiLFxuICAgIFwic3ltYm9sXCI6IFwiWlNMUFwiLFxuICAgIFwibmFtZVwiOiBcIlpjbGFzc2ljIFNpbXBsZSBMZWRnZXIgUHJvdG9jb2xcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3pzbHAub3JnXCJcbiAgfSxcbiAgXCI0NjZcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0NjZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxZDJcIixcbiAgICBcInN5bWJvbFwiOiBcIkVSRVwiLFxuICAgIFwibmFtZVwiOiBcIkV0aGVyQ29yZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZXRoZXJjb3JlLm9yZ1wiXG4gIH0sXG4gIFwiNDY3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDY3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWQzXCIsXG4gICAgXCJzeW1ib2xcIjogXCJEWFwiLFxuICAgIFwibmFtZVwiOiBcIkR4Q2hhaW4gVG9rZW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2R4Y2hhaW4uY29tXCJcbiAgfSxcbiAgXCI0NjhcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0NjhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxZDRcIixcbiAgICBcInN5bWJvbFwiOiBcIkNQU1wiLFxuICAgIFwibmFtZVwiOiBcIkNhcHJpY29pbitcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2NhcHJpY29pbi5vcmdcIlxuICB9LFxuICBcIjQ2OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQ2OVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFkNVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQlRIXCIsXG4gICAgXCJuYW1lXCI6IFwiQml0aGVyZXVtXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9iaXRoZXJldW0ubmV0d29ya1wiXG4gIH0sXG4gIFwiNDcwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDcwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWQ2XCIsXG4gICAgXCJzeW1ib2xcIjogXCJNRVNHXCIsXG4gICAgXCJuYW1lXCI6IFwiTUVTR1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbWVzZy5jb21cIlxuICB9LFxuICBcIjQ3MVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQ3MVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFkN1wiLFxuICAgIFwic3ltYm9sXCI6IFwiRklNS1wiLFxuICAgIFwibmFtZVwiOiBcIkZJTUtcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3dhbGxldC5maW1rLmZpXCJcbiAgfSxcbiAgXCI0NzJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0NzJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxZDhcIixcbiAgICBcInN5bWJvbFwiOiBcIkFSXCIsXG4gICAgXCJuYW1lXCI6IFwiQXJ3ZWF2ZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYXJ3ZWF2ZS5vcmdcIlxuICB9LFxuICBcIjQ3M1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQ3M1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFkOVwiLFxuICAgIFwic3ltYm9sXCI6IFwiT0dPXCIsXG4gICAgXCJuYW1lXCI6IFwiT3JpZ29cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL29yaWdvLm5ldHdvcmtcIlxuICB9LFxuICBcIjQ3NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQ3NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFkYVwiLFxuICAgIFwic3ltYm9sXCI6IFwiUk9TRVwiLFxuICAgIFwibmFtZVwiOiBcIk9hc2lzIE5ldHdvcmtcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5vYXNpcy1wcm90b2NvbC5vcmdcIlxuICB9LFxuICBcIjQ3NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQ3NVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFkYlwiLFxuICAgIFwic3ltYm9sXCI6IFwiQkFSRVwiLFxuICAgIFwibmFtZVwiOiBcIkJBUkUgTmV0d29ya1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYmFyZS5uZXR3b3JrXCJcbiAgfSxcbiAgXCI0NzZcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0NzZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxZGNcIixcbiAgICBcInN5bWJvbFwiOiBcIkdMRUVDXCIsXG4gICAgXCJuYW1lXCI6IFwiR2xlZWNCVENcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dsZWVjYnRjLmNvbVwiXG4gIH0sXG4gIFwiNDc3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDc3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWRkXCIsXG4gICAgXCJzeW1ib2xcIjogXCJDTFJcIixcbiAgICBcIm5hbWVcIjogXCJDb2xvciBDb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9jb2xvci1wbGF0Zm9ybS5vcmdcIlxuICB9LFxuICBcIjQ3OFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQ3OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFkZVwiLFxuICAgIFwic3ltYm9sXCI6IFwiUk5HXCIsXG4gICAgXCJuYW1lXCI6IFwiUmluZ1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vcmluZ2NvaW4udGVjaFwiXG4gIH0sXG4gIFwiNDc5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDc5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWRmXCIsXG4gICAgXCJzeW1ib2xcIjogXCJPTE9cIixcbiAgICBcIm5hbWVcIjogXCJUb29sIEdsb2JhbFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vaWJkdC5pb1wiXG4gIH0sXG4gIFwiNDgwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDgwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWUwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJQRVhBXCIsXG4gICAgXCJuYW1lXCI6IFwiUGV4YVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vcGV4YXByb2plY3QuY29tXCJcbiAgfSxcbiAgXCI0ODFcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0ODFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxZTFcIixcbiAgICBcInN5bWJvbFwiOiBcIk1PT05cIixcbiAgICBcIm5hbWVcIjogXCJNb29uY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbW9vbmNvaW4uZWNvXCJcbiAgfSxcbiAgXCI0ODJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0ODJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxZTJcIixcbiAgICBcInN5bWJvbFwiOiBcIk9DRUFOXCIsXG4gICAgXCJuYW1lXCI6IFwiT2NlYW4gUHJvdG9jb2xcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL29jZWFucHJvdG9jb2wuY29tXCJcbiAgfSxcbiAgXCI0ODNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0ODNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxZTNcIixcbiAgICBcInN5bWJvbFwiOiBcIkJOVFwiLFxuICAgIFwibmFtZVwiOiBcIkJsdXplbGxlIE5hdGl2ZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYmx1emVsbGUuY29tXCJcbiAgfSxcbiAgXCI0ODRcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0ODRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxZTRcIixcbiAgICBcInN5bWJvbFwiOiBcIkFNT1wiLFxuICAgIFwibmFtZVwiOiBcIkFNTyBCbG9ja2NoYWluXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9hbW8uZm91bmRhdGlvblwiXG4gIH0sXG4gIFwiNDg1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDg1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWU1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJGQ0hcIixcbiAgICBcIm5hbWVcIjogXCJGcmVlQ2FzaFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmZyZWVjYXNoLm9yZ1wiXG4gIH0sXG4gIFwiNDg2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDg2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWU2XCIsXG4gICAgXCJzeW1ib2xcIjogXCJMQVRcIixcbiAgICBcIm5hbWVcIjogXCJMYXR0aWNlWFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbGF0dGljZXguZm91bmRhdGlvblwiXG4gIH0sXG4gIFwiNDg3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDg3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWU3XCIsXG4gICAgXCJzeW1ib2xcIjogXCJDT0lOXCIsXG4gICAgXCJuYW1lXCI6IFwiQml0Y29pbiBCYW5rXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2NvaW4tY29yZS9jb2luXCJcbiAgfSxcbiAgXCI0ODhcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0ODhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxZThcIixcbiAgICBcInN5bWJvbFwiOiBcIlZFT1wiLFxuICAgIFwibmFtZVwiOiBcIkFtb3Zlb1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS96YWNrLWJpdGNvaW4vYW1vdmVvXCJcbiAgfSxcbiAgXCI0ODlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0ODlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxZTlcIixcbiAgICBcInN5bWJvbFwiOiBcIkNDQVwiLFxuICAgIFwibmFtZVwiOiBcIkNvdW5vcyBDb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9jb3Vub3MuaW8vY291c25vY29pblwiXG4gIH0sXG4gIFwiNDkwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDkwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWVhXCIsXG4gICAgXCJzeW1ib2xcIjogXCJHRk5cIixcbiAgICBcIm5hbWVcIjogXCJHcmFwaGVuZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2V0Z3JhcGhlbmUuaW9cIlxuICB9LFxuICBcIjQ5MVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQ5MVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFlYlwiLFxuICAgIFwic3ltYm9sXCI6IFwiQklQXCIsXG4gICAgXCJuYW1lXCI6IFwiTWludGVyIE5ldHdvcmtcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL21pbnRlci5uZXR3b3JrXCJcbiAgfSxcbiAgXCI0OTJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0OTJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxZWNcIixcbiAgICBcInN5bWJvbFwiOiBcIktQR1wiLFxuICAgIFwibmFtZVwiOiBcIkt1bnBlbmcgTmV0d29ya1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8va3VucGVuZy5uZXR3b3JrXCJcbiAgfSxcbiAgXCI0OTNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0OTNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxZWRcIixcbiAgICBcInN5bWJvbFwiOiBcIkZJTlwiLFxuICAgIFwibmFtZVwiOiBcIkZJTkwgQ2hhaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwOi8vZmlubC5uZXR3b3JrXCJcbiAgfSxcbiAgXCI0OTRcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0OTRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxZWVcIixcbiAgICBcInN5bWJvbFwiOiBcIkJBTkRcIixcbiAgICBcIm5hbWVcIjogXCJCYW5kXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9iYW5kcHJvdG9jb2wuY29tXCJcbiAgfSxcbiAgXCI0OTVcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0OTVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxZWZcIixcbiAgICBcInN5bWJvbFwiOiBcIkRST1BcIixcbiAgICBcIm5hbWVcIjogXCJEcm9waWxcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2Ryb3BpbGNoYWluLmNvbVwiXG4gIH0sXG4gIFwiNDk2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDk2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWYwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJCSFRcIixcbiAgICBcIm5hbWVcIjogXCJCbHVlaGVsaXggQ2hhaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2JsdWVoZWxpeC5uZXR3b3JrXCJcbiAgfSxcbiAgXCI0OTdcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0OTdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxZjFcIixcbiAgICBcInN5bWJvbFwiOiBcIkxZUkFcIixcbiAgICBcIm5hbWVcIjogXCJTY3J5cHRhXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9zY3J5cHRhY2hhaW4ub3JnXCJcbiAgfSxcbiAgXCI0OThcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0OThcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxZjJcIixcbiAgICBcInN5bWJvbFwiOiBcIkNTXCIsXG4gICAgXCJuYW1lXCI6IFwiQ3JlZGl0c1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vY3JlZGl0cy5jb21cIlxuICB9LFxuICBcIjQ5OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQ5OVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFmM1wiLFxuICAgIFwic3ltYm9sXCI6IFwiUlVQWFwiLFxuICAgIFwibmFtZVwiOiBcIlJ1cGF5YVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vcnVweC5pb1wiXG4gIH0sXG4gIFwiNTAwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTAwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWY0XCIsXG4gICAgXCJzeW1ib2xcIjogXCJUSEVUQVwiLFxuICAgIFwibmFtZVwiOiBcIlRoZXRhXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cudGhldGF0b2tlbi5vcmdcIlxuICB9LFxuICBcIjUwMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjUwMVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFmNVwiLFxuICAgIFwic3ltYm9sXCI6IFwiU09MXCIsXG4gICAgXCJuYW1lXCI6IFwiU29sYW5hXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9zb2xhbmEuY29tXCJcbiAgfSxcbiAgXCI1MDJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1MDJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxZjZcIixcbiAgICBcInN5bWJvbFwiOiBcIlRIVFwiLFxuICAgIFwibmFtZVwiOiBcIlRob3VnaHRBSVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90aG91Z2h0bmV0d29yay90aG91Z2h0XCJcbiAgfSxcbiAgXCI1MDNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1MDNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxZjdcIixcbiAgICBcInN5bWJvbFwiOiBcIkNGWFwiLFxuICAgIFwibmFtZVwiOiBcIkNvbmZsdXhcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2NvbmZsdXhuZXR3b3JrLm9yZ1wiXG4gIH0sXG4gIFwiNTA0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTA0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWY4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJLVU1BXCIsXG4gICAgXCJuYW1lXCI6IFwiS3VtYWNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5rdW1hY29pbi5kZXZcIlxuICB9LFxuICBcIjUwNVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjUwNVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFmOVwiLFxuICAgIFwic3ltYm9sXCI6IFwiSEFTSFwiLFxuICAgIFwibmFtZVwiOiBcIlByb3ZlbmFuY2VcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3Byb3ZlbmFuY2UuaW9cIlxuICB9LFxuICBcIjUwNlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjUwNlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFmYVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQ1NQUlwiLFxuICAgIFwibmFtZVwiOiBcIkNhc3BlclwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vY2FzcGVyLm5ldHdvcmtcIlxuICB9LFxuICBcIjUwN1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjUwN1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFmYlwiLFxuICAgIFwic3ltYm9sXCI6IFwiRUFSVEhcIixcbiAgICBcIm5hbWVcIjogXCJFQVJUSFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmVhcnRoLmVuZ2luZWVyaW5nXCJcbiAgfSxcbiAgXCI1MDhcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1MDhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxZmNcIixcbiAgICBcInN5bWJvbFwiOiBcIkVSRFwiLFxuICAgIFwibmFtZVwiOiBcIkVscm9uZFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZWxyb25kLmNvbVwiXG4gIH0sXG4gIFwiNTA5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTA5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMWZkXCIsXG4gICAgXCJzeW1ib2xcIjogXCJDSElcIixcbiAgICBcIm5hbWVcIjogXCJYYXlhXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly94YXlhLmlvXCJcbiAgfSxcbiAgXCI1MTBcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1MTBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAxZmVcIixcbiAgICBcInN5bWJvbFwiOiBcIktPVE9cIixcbiAgICBcIm5hbWVcIjogXCJLb3RvXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9rby10by5vcmdcIlxuICB9LFxuICBcIjUxMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjUxMVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDFmZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiT1RDXCIsXG4gICAgXCJuYW1lXCI6IFwizrhcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL290Yy5uZXR3b3JrXCJcbiAgfSxcbiAgXCI1MTJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1MTJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyMDBcIixcbiAgICBcInN5bWJvbFwiOiBcIlhSRFwiLFxuICAgIFwibmFtZVwiOiBcIlJhZGlhbnRcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3JhZGlhbnQuY2FzaFwiXG4gIH0sXG4gIFwiNTEzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTEzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjAxXCIsXG4gICAgXCJzeW1ib2xcIjogXCJTRUVMRU5cIixcbiAgICBcIm5hbWVcIjogXCJTZWVsZS1OXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9zZWVsZW4ucHJvXCJcbiAgfSxcbiAgXCI1MTRcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1MTRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyMDJcIixcbiAgICBcInN5bWJvbFwiOiBcIkFFVEhcIixcbiAgICBcIm5hbWVcIjogXCJBRVRIXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9hZXRoLmlvXCJcbiAgfSxcbiAgXCI1MTVcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1MTVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyMDNcIixcbiAgICBcInN5bWJvbFwiOiBcIkROQVwiLFxuICAgIFwibmFtZVwiOiBcIklkZW5hXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9pZGVuYS5pb1wiXG4gIH0sXG4gIFwiNTE2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTE2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjA0XCIsXG4gICAgXCJzeW1ib2xcIjogXCJWRUVcIixcbiAgICBcIm5hbWVcIjogXCJWaXJ0dWFsIEVjb25vbXkgRXJhXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cudmVlLnRlY2hcIlxuICB9LFxuICBcIjUxN1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjUxN1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIwNVwiLFxuICAgIFwic3ltYm9sXCI6IFwiU0lFUlJBXCIsXG4gICAgXCJuYW1lXCI6IFwiU2llcnJhQ29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vc2llcnJhY29pbi5vcmdcIlxuICB9LFxuICBcIjUxOFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjUxOFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIwNlwiLFxuICAgIFwic3ltYm9sXCI6IFwiTEVUXCIsXG4gICAgXCJuYW1lXCI6IFwiTGlua2V5ZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmxpbmtleWUuY29tXCJcbiAgfSxcbiAgXCI1MTlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1MTlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyMDdcIixcbiAgICBcInN5bWJvbFwiOiBcIkJTQ1wiLFxuICAgIFwibmFtZVwiOiBcIkJpdGNvaW4gU21hcnQgQ29udHJhY3RcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2JzYy5uZXRcIlxuICB9LFxuICBcIjUyMFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjUyMFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIwOFwiLFxuICAgIFwic3ltYm9sXCI6IFwiQlRDVlwiLFxuICAgIFwibmFtZVwiOiBcIkJpdGNvaW5WSVBcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5iaXR2aXAub3JnXCJcbiAgfSxcbiAgXCI1MjFcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1MjFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyMDlcIixcbiAgICBcInN5bWJvbFwiOiBcIkFCQVwiLFxuICAgIFwibmFtZVwiOiBcIkRhYmFjdXNcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5kYWJhY3VzLm9yZ1wiXG4gIH0sXG4gIFwiNTIyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTIyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjBhXCIsXG4gICAgXCJzeW1ib2xcIjogXCJTQ0NcIixcbiAgICBcIm5hbWVcIjogXCJTdGFrZUN1YmVDb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9zdGFrZWN1YmUubmV0XCJcbiAgfSxcbiAgXCI1MjNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1MjNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyMGJcIixcbiAgICBcInN5bWJvbFwiOiBcIkVER1wiLFxuICAgIFwibmFtZVwiOiBcIkVkZ2V3YXJlXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9lZGdld2EucmVcIlxuICB9LFxuICBcIjUyNFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjUyNFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIwY1wiLFxuICAgIFwic3ltYm9sXCI6IFwiQU1TXCIsXG4gICAgXCJuYW1lXCI6IFwiQW1zdGVyZGFtQ29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmFtc3RlcmRhbWNvaW4uY29tXCJcbiAgfSxcbiAgXCI1MjVcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1MjVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyMGRcIixcbiAgICBcInN5bWJvbFwiOiBcIkdPU1NcIixcbiAgICBcIm5hbWVcIjogXCJHT1NTSVAgQ29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ29zc2lwY29pbi5uZXRcIlxuICB9LFxuICBcIjUyNlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjUyNlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIwZVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQlVcIixcbiAgICBcIm5hbWVcIjogXCJCVU1PXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuYnVtby5pb1wiXG4gIH0sXG4gIFwiNTI3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTI3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjBmXCIsXG4gICAgXCJzeW1ib2xcIjogXCJHUkFNXCIsXG4gICAgXCJuYW1lXCI6IFwiR1JBTVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90b25ncmFtXCJcbiAgfSxcbiAgXCI1MjhcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1MjhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyMTBcIixcbiAgICBcInN5bWJvbFwiOiBcIllBUFwiLFxuICAgIFwibmFtZVwiOiBcIllhcHN0b25lXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly95YXBzdG9uZS5wcm9cIlxuICB9LFxuICBcIjUyOVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjUyOVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIxMVwiLFxuICAgIFwic3ltYm9sXCI6IFwiU0NSVFwiLFxuICAgIFwibmFtZVwiOiBcIlNlY3JldCBOZXR3b3JrXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9zY3J0Lm5ldHdvcmtcIlxuICB9LFxuICBcIjUzMFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjUzMFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIxMlwiLFxuICAgIFwic3ltYm9sXCI6IFwiTk9WT1wiLFxuICAgIFwibmFtZVwiOiBcIk5vdm9cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL25vdm9jdXJyZW5jeS5jb21cIlxuICB9LFxuICBcIjUzMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjUzMVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIxM1wiLFxuICAgIFwic3ltYm9sXCI6IFwiR0hPU1RcIixcbiAgICBcIm5hbWVcIjogXCJHaG9zdFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2hvc3RieW1jYWZlZS5jb21cIlxuICB9LFxuICBcIjUzMlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjUzMlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIxNFwiLFxuICAgIFwic3ltYm9sXCI6IFwiSFNUXCIsXG4gICAgXCJuYW1lXCI6IFwiSFNUXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuaHNjaGFpbi5pb1wiXG4gIH0sXG4gIFwiNTMzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTMzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjE1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJQUkpcIixcbiAgICBcIm5hbWVcIjogXCJQcm9qZWN0Q29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vcHJvamVjdGNvaW4ubmV0XCJcbiAgfSxcbiAgXCI1MzRcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1MzRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyMTZcIixcbiAgICBcInN5bWJvbFwiOiBcIllPVVwiLFxuICAgIFwibmFtZVwiOiBcIllPVUNoYWluXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly95b3VjaGFpbi5jY1wiXG4gIH0sXG4gIFwiNTM1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTM1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjE3XCIsXG4gICAgXCJzeW1ib2xcIjogXCJYSFZcIixcbiAgICBcIm5hbWVcIjogXCJIYXZlbiBQcm90b2NvbFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vaGF2ZW5wcm90b2NvbC5vcmdcIlxuICB9LFxuICBcIjUzNlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjUzNlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIxOFwiLFxuICAgIFwic3ltYm9sXCI6IFwiQllORFwiLFxuICAgIFwibmFtZVwiOiBcIkJleW9uZGNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2JleW9uZGNvaW4uaW9cIlxuICB9LFxuICBcIjUzN1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjUzN1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIxOVwiLFxuICAgIFwic3ltYm9sXCI6IFwiSk9ZU1wiLFxuICAgIFwibmFtZVwiOiBcIkpveXMgRGlnaXRhbFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vam95cy5kaWdpdGFsXCJcbiAgfSxcbiAgXCI1MzhcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1MzhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyMWFcIixcbiAgICBcInN5bWJvbFwiOiBcIlZBTFwiLFxuICAgIFwibmFtZVwiOiBcIlZhbG9yYml0XCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly92YWxvcmJpdC5jb21cIlxuICB9LFxuICBcIjUzOVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjUzOVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIxYlwiLFxuICAgIFwic3ltYm9sXCI6IFwiRkxPV1wiLFxuICAgIFwibmFtZVwiOiBcIkZsb3dcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5vbmZsb3cub3JnXCJcbiAgfSxcbiAgXCI1NDBcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1NDBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyMWNcIixcbiAgICBcInN5bWJvbFwiOiBcIlNNRVNIXCIsXG4gICAgXCJuYW1lXCI6IFwiU3BhY2VtZXNoIENvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3NwYWNlbWVzaC5pb1wiXG4gIH0sXG4gIFwiNTQxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTQxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjFkXCIsXG4gICAgXCJzeW1ib2xcIjogXCJTQ0RPXCIsXG4gICAgXCJuYW1lXCI6IFwiU0NET1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vc2Nkb3Byb2plY3Qub3JnXCJcbiAgfSxcbiAgXCI1NDJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1NDJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyMWVcIixcbiAgICBcInN5bWJvbFwiOiBcIklRU1wiLFxuICAgIFwibmFtZVwiOiBcIklRLUNhc2hcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2lxLmNhc2hcIlxuICB9LFxuICBcIjU0M1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU0M1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIxZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiQklORFwiLFxuICAgIFwibmFtZVwiOiBcIkNvbXBlbmRpYVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vY29tcGVuZGlhLm9yZ1wiXG4gIH0sXG4gIFwiNTQ0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTQ0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjIwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJDT0lORVZPXCIsXG4gICAgXCJuYW1lXCI6IFwiQ29pbmV2b1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vY29pbmV2by50ZWNoXCJcbiAgfSxcbiAgXCI1NDVcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1NDVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyMjFcIixcbiAgICBcInN5bWJvbFwiOiBcIlNDUklCRVwiLFxuICAgIFwibmFtZVwiOiBcIlNjcmliZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vc2NyaWJlLm5ldHdvcmtcIlxuICB9LFxuICBcIjU0NlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU0NlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIyMlwiLFxuICAgIFwic3ltYm9sXCI6IFwiSFlOXCIsXG4gICAgXCJuYW1lXCI6IFwiSHlwZXJpb25cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5oeW4uc3BhY2VcIlxuICB9LFxuICBcIjU0N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU0N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIyM1wiLFxuICAgIFwic3ltYm9sXCI6IFwiQkhQXCIsXG4gICAgXCJuYW1lXCI6IFwiQkhQXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuYmhwYS5pb1wiXG4gIH0sXG4gIFwiNTQ4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTQ4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjI0XCIsXG4gICAgXCJzeW1ib2xcIjogXCJCQkNcIixcbiAgICBcIm5hbWVcIjogXCJCaWdCYW5nIENvcmVcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dpdGh1Yi5jb20vYmlnYmFuZ2NvcmVcIlxuICB9LFxuICBcIjU0OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU0OVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIyNVwiLFxuICAgIFwic3ltYm9sXCI6IFwiTUtGXCIsXG4gICAgXCJuYW1lXCI6IFwiTWFya2V0RmluYW5jZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbWtmLmlvXCJcbiAgfSxcbiAgXCI1NTBcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1NTBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyMjZcIixcbiAgICBcInN5bWJvbFwiOiBcIlhEQ1wiLFxuICAgIFwibmFtZVwiOiBcIlhpbkZpbi5OZXR3b3JrXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly94aW5maW4ubmV0d29ya1wiXG4gIH0sXG4gIFwiNTUxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTUxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjI3XCIsXG4gICAgXCJzeW1ib2xcIjogXCJTVFJcIixcbiAgICBcIm5hbWVcIjogXCJTdHJhaWdodGVkZ2VcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3N0cmFpZ2h0ZWQuZ2VcIlxuICB9LFxuICBcIjU1MlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU1MlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIyOFwiLFxuICAgIFwic3ltYm9sXCI6IFwiU1VNXCIsXG4gICAgXCJuYW1lXCI6IFwiU3VtY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vc3VtY29pbi5vcmdcIlxuICB9LFxuICBcIjU1M1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU1M1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIyOVwiLFxuICAgIFwic3ltYm9sXCI6IFwiSEJDXCIsXG4gICAgXCJuYW1lXCI6IFwiSHVvYmlDaGFpblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3Lmh1b2JpY2hhaW4uY29tXCJcbiAgfSxcbiAgXCI1NTRcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1NTRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyMmFcIixcbiAgICBcInN5bWJvbFwiOiBcIi0tLVwiLFxuICAgIFwibmFtZVwiOiBcInJlc2VydmVkXCJcbiAgfSxcbiAgXCI1NTVcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1NTVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyMmJcIixcbiAgICBcInN5bWJvbFwiOiBcIkJDU1wiLFxuICAgIFwibmFtZVwiOiBcIkJpdGNvaW4gU21hcnRcIixcbiAgICBcImxpbmtcIjogXCJodHRwOi8vYmNzLmluZm9cIlxuICB9LFxuICBcIjU1NlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU1NlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIyY1wiLFxuICAgIFwic3ltYm9sXCI6IFwiS1RTXCIsXG4gICAgXCJuYW1lXCI6IFwiS3JhdG9zXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL0t1Q2hhaW5OZXR3b3JrL2tyYXRvc1wiXG4gIH0sXG4gIFwiNTU3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTU3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjJkXCIsXG4gICAgXCJzeW1ib2xcIjogXCJMS1JcIixcbiAgICBcIm5hbWVcIjogXCJMa3Jjb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9sa3Jjb2luLmlvXCJcbiAgfSxcbiAgXCI1NThcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1NThcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyMmVcIixcbiAgICBcInN5bWJvbFwiOiBcIlRBT1wiLFxuICAgIFwibmFtZVwiOiBcIlRhb1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vdGFvLm5ldHdvcmtcIlxuICB9LFxuICBcIjU1OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU1OVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIyZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiWFdDXCIsXG4gICAgXCJuYW1lXCI6IFwiV2hpdGVjb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cud2hpdGVjb2luLmluZm9cIlxuICB9LFxuICBcIjU2MFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU2MFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIzMFwiLFxuICAgIFwic3ltYm9sXCI6IFwiREVBTFwiLFxuICAgIFwibmFtZVwiOiBcIkRFQUxcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2lkZWFsY2FzaC5pb1wiXG4gIH0sXG4gIFwiNTYxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTYxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjMxXCIsXG4gICAgXCJzeW1ib2xcIjogXCJOVFlcIixcbiAgICBcIm5hbWVcIjogXCJOZXh0eVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbmV4dHkuaW9cIlxuICB9LFxuICBcIjU2MlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU2MlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIzMlwiLFxuICAgIFwic3ltYm9sXCI6IFwiVE9QXCIsXG4gICAgXCJuYW1lXCI6IFwiVE9QIE5ldFdvcmtcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy50b3BuZXR3b3JrLm9yZ1wiXG4gIH0sXG4gIFwiNTYzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTYzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjMzXCIsXG4gICAgXCJzeW1ib2xcIjogXCJTVEFSU1wiLFxuICAgIFwibmFtZVwiOiBcIlN0YXJnYXplXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuc3RhcmdhemUuZmlcIlxuICB9LFxuICBcIjU2NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU2NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIzNFwiLFxuICAgIFwic3ltYm9sXCI6IFwiQUdcIixcbiAgICBcIm5hbWVcIjogXCJBZ29yaWNcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2Fnb3JpYy5jb21cIlxuICB9LFxuICBcIjU2NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU2NVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIzNVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQ0lDT1wiLFxuICAgIFwibmFtZVwiOiBcIkNvaW5pY2xlc1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9jb2luaWNsZXMvY2ljb1wiXG4gIH0sXG4gIFwiNTY2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTY2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjM2XCIsXG4gICAgXCJzeW1ib2xcIjogXCJJUklTXCIsXG4gICAgXCJuYW1lXCI6IFwiSXJpc25ldFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmlyaXNuZXQub3JnXCJcbiAgfSxcbiAgXCI1NjdcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1NjdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyMzdcIixcbiAgICBcInN5bWJvbFwiOiBcIk5DR1wiLFxuICAgIFwibmFtZVwiOiBcIk5pbmUgQ2hyb25pY2xlc1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbmluZS1jaHJvbmljbGVzLmNvbVwiXG4gIH0sXG4gIFwiNTY4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTY4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjM4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJMUkdcIixcbiAgICBcIm5hbWVcIjogXCJMYXJnZSBDb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cubGFyZ29jb2luLmlvXCJcbiAgfSxcbiAgXCI1NjlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1NjlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyMzlcIixcbiAgICBcInN5bWJvbFwiOiBcIlNFUk9cIixcbiAgICBcIm5hbWVcIjogXCJTdXBlciBaZXJvIFByb3RvY29sXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9zZXJvLmNhc2hcIlxuICB9LFxuICBcIjU3MFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU3MFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIzYVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQkRYXCIsXG4gICAgXCJuYW1lXCI6IFwiQmVsZGV4XCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuYmVsZGV4LmlvXCJcbiAgfSxcbiAgXCI1NzFcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1NzFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyM2JcIixcbiAgICBcInN5bWJvbFwiOiBcIkNDWFhcIixcbiAgICBcIm5hbWVcIjogXCJDb3Vub3MgWFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmNvdW5vcy5pby9Db3Vub3NYXCJcbiAgfSxcbiAgXCI1NzJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1NzJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyM2NcIixcbiAgICBcInN5bWJvbFwiOiBcIlNMU1wiLFxuICAgIFwibmFtZVwiOiBcIlNhbHVzY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vc2FsdXNjb2luLmluZm9cIlxuICB9LFxuICBcIjU3M1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU3M1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIzZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiU1JNXCIsXG4gICAgXCJuYW1lXCI6IFwiU2VydW1cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3Byb2plY3RzZXJ1bS5jb21cIlxuICB9LFxuICBcIjU3NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU3NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDIzZVwiLFxuICAgIFwic3ltYm9sXCI6IFwiVkxYXCIsXG4gICAgXCJuYW1lXCI6IFwiVmVsYXNcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3ZlbGFzLmNvbVwiXG4gIH0sXG4gIFwiNTc1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTc1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjNmXCIsXG4gICAgXCJzeW1ib2xcIjogXCJWSVZUXCIsXG4gICAgXCJuYW1lXCI6IFwiVklEVCBEYXRhbGlua1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYWJvdXQudi1pZC5vcmdcIlxuICB9LFxuICBcIjU3NlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU3NlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI0MFwiLFxuICAgIFwic3ltYm9sXCI6IFwiQlBTXCIsXG4gICAgXCJuYW1lXCI6IFwiQml0Y29pblBvU1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYml0Y29pbnBvcy5uZXRcIlxuICB9LFxuICBcIjU3N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU3N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI0MVwiLFxuICAgIFwic3ltYm9sXCI6IFwiTktOXCIsXG4gICAgXCJuYW1lXCI6IFwiTktOXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cubmtuLm9yZ1wiXG4gIH0sXG4gIFwiNTc4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTc4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjQyXCIsXG4gICAgXCJzeW1ib2xcIjogXCJJQ0xcIixcbiAgICBcIm5hbWVcIjogXCJJTENPSU5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2lsY29pbmNyeXB0by5jb21cIlxuICB9LFxuICBcIjU3OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU3OVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI0M1wiLFxuICAgIFwic3ltYm9sXCI6IFwiQk9OT1wiLFxuICAgIFwibmFtZVwiOiBcIkJvbm9ydW1cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5ib25vcnVtLmlvXCJcbiAgfSxcbiAgXCI1ODBcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1ODBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyNDRcIixcbiAgICBcInN5bWJvbFwiOiBcIlBMQ1wiLFxuICAgIFwibmFtZVwiOiBcIlBMQVRJTkNPSU5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3BsYXRpbmNvaW4uY29tL2VuXCJcbiAgfSxcbiAgXCI1ODFcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1ODFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyNDVcIixcbiAgICBcInN5bWJvbFwiOiBcIkRVTlwiLFxuICAgIFwibmFtZVwiOiBcIkR1bmVcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2R1bmUubmV0d29ya1wiXG4gIH0sXG4gIFwiNTgyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTgyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjQ2XCIsXG4gICAgXCJzeW1ib2xcIjogXCJETUNIXCIsXG4gICAgXCJuYW1lXCI6IFwiRGFybWFjYXNoXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuZGFybWFjYXNoLmNvbVwiXG4gIH0sXG4gIFwiNTgzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTgzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjQ3XCIsXG4gICAgXCJzeW1ib2xcIjogXCJDVENcIixcbiAgICBcIm5hbWVcIjogXCJDcmVkaXRjb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuY3JlZGl0Y29pbi5vcmdcIlxuICB9LFxuICBcIjU4NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU4NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI0OFwiLFxuICAgIFwic3ltYm9sXCI6IFwiS0VMUFwiLFxuICAgIFwibmFtZVwiOiBcIkhhaWRhaSBOZXR3b3JrXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9oYWlkYWkub25lXCJcbiAgfSxcbiAgXCI1ODVcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1ODVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyNDlcIixcbiAgICBcInN5bWJvbFwiOiBcIkdCQ1JcIixcbiAgICBcIm5hbWVcIjogXCJHb2xkQkNSXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9nb2xkYmNyLmlvXCJcbiAgfSxcbiAgXCI1ODZcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1ODZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyNGFcIixcbiAgICBcInN5bWJvbFwiOiBcIlhEQUdcIixcbiAgICBcIm5hbWVcIjogXCJYREFHXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly94ZGFnLmlvXCJcbiAgfSxcbiAgXCI1ODdcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1ODdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyNGJcIixcbiAgICBcInN5bWJvbFwiOiBcIlBSVlwiLFxuICAgIFwibmFtZVwiOiBcIkluY29nbml0byBQcml2YWN5XCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9pbmNvZ25pdG8ub3JnXCJcbiAgfSxcbiAgXCI1ODhcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1ODhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyNGNcIixcbiAgICBcInN5bWJvbFwiOiBcIlNDQVBcIixcbiAgICBcIm5hbWVcIjogXCJTYWZlQ2FwaXRhbFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LnNhZmVjYXBpdGFsLmlvXCJcbiAgfSxcbiAgXCI1ODlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1ODlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyNGRcIixcbiAgICBcInN5bWJvbFwiOiBcIlRGVUVMXCIsXG4gICAgXCJuYW1lXCI6IFwiVGhldGEgRnVlbFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vY29tbXVuaXR5LnRoZXRhLnR2L3RmdWVsLW9uLXNsaXZlci1mYXFcIlxuICB9LFxuICBcIjU5MFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU5MFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI0ZVwiLFxuICAgIFwic3ltYm9sXCI6IFwiR1RNXCIsXG4gICAgXCJuYW1lXCI6IFwiR2VudGFyaXVtXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9ndG1jb2luLmlvXCJcbiAgfSxcbiAgXCI1OTFcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1OTFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyNGZcIixcbiAgICBcInN5bWJvbFwiOiBcIlJOTFwiLFxuICAgIFwibmFtZVwiOiBcIlJlbnRhbENoYWluXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9yZW50YWxjaGFpbi5uZXRcIlxuICB9LFxuICBcIjU5MlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU5MlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI1MFwiLFxuICAgIFwic3ltYm9sXCI6IFwiR1JJTlwiLFxuICAgIFwibmFtZVwiOiBcIkdyaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dyaW4ubXdcIlxuICB9LFxuICBcIjU5M1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU5M1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI1MVwiLFxuICAgIFwic3ltYm9sXCI6IFwiTVdDXCIsXG4gICAgXCJuYW1lXCI6IFwiTWltYmxlV2ltYmxlQ29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3Lm13Yy5td1wiXG4gIH0sXG4gIFwiNTk0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTk0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjUyXCIsXG4gICAgXCJzeW1ib2xcIjogXCJET0NLXCIsXG4gICAgXCJuYW1lXCI6IFwiRG9ja1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZG9jay5pb1wiXG4gIH0sXG4gIFwiNTk1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTk1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjUzXCIsXG4gICAgXCJzeW1ib2xcIjogXCJQT0xZWFwiLFxuICAgIFwibmFtZVwiOiBcIlBvbHltZXNoXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9wb2x5bWF0aC5uZXR3b3JrXCJcbiAgfSxcbiAgXCI1OTZcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1OTZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyNTRcIixcbiAgICBcInN5bWJvbFwiOiBcIkRJVkVSXCIsXG4gICAgXCJuYW1lXCI6IFwiRGl2ZXJnZW50aVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmRpdmVyZ2VudGkuY2xcIlxuICB9LFxuICBcIjU5N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU5N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI1NVwiLFxuICAgIFwic3ltYm9sXCI6IFwiWEVQXCIsXG4gICAgXCJuYW1lXCI6IFwiRWxlY3RyYSBQcm90b2NvbFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmVsZWN0cmFwcm90b2NvbC5jb21cIlxuICB9LFxuICBcIjU5OFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU5OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI1NlwiLFxuICAgIFwic3ltYm9sXCI6IFwiQVBOXCIsXG4gICAgXCJuYW1lXCI6IFwiQXByb25cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2Fwcm9uLm5ldHdvcmtcIlxuICB9LFxuICBcIjU5OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU5OVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI1N1wiLFxuICAgIFwic3ltYm9sXCI6IFwiVEZDXCIsXG4gICAgXCJuYW1lXCI6IFwiVHVyYm8gRmlsZSBDb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL3R1cmJvZmlsLmNjXCJcbiAgfSxcbiAgXCI2MDBcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2MDBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyNThcIixcbiAgICBcInN5bWJvbFwiOiBcIlVURVwiLFxuICAgIFwibmFtZVwiOiBcIlVuaXQtZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZHRyLm9yZy91bml0LWVcIlxuICB9LFxuICBcIjYwMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjYwMVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI1OVwiLFxuICAgIFwic3ltYm9sXCI6IFwiTVRDXCIsXG4gICAgXCJuYW1lXCI6IFwiTWV0YWNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL21ldGFjb2luLm5ldHdvcmtcIlxuICB9LFxuICBcIjYwMlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjYwMlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI1YVwiLFxuICAgIFwic3ltYm9sXCI6IFwiTkNcIixcbiAgICBcIm5hbWVcIjogXCJOb2JvZHlDYXNoXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9ub2JvZHljYXNoLndvcmxkXCJcbiAgfSxcbiAgXCI2MDNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2MDNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyNWJcIixcbiAgICBcInN5bWJvbFwiOiBcIlhJTllcIixcbiAgICBcIm5hbWVcIjogXCJYaW55dWVodVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8veGlueXVlaHUueHl6XCJcbiAgfSxcbiAgXCI2MDRcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2MDRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyNWNcIixcbiAgICBcInN5bWJvbFwiOiBcIkRZTlwiLFxuICAgIFwibmFtZVwiOiBcIkR5bmFtb1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmR5bmFtb2NvaW4ub3JnXCJcbiAgfSxcbiAgXCI2MDVcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2MDVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyNWRcIixcbiAgICBcInN5bWJvbFwiOiBcIkJVRlNcIixcbiAgICBcIm5hbWVcIjogXCJCdWZmZXJcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2J1ZmZlcmJ1ZnMuY29tXCJcbiAgfSxcbiAgXCI2MDZcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2MDZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyNWVcIixcbiAgICBcInN5bWJvbFwiOiBcIlNUT1NcIixcbiAgICBcIm5hbWVcIjogXCJTdHJhdG9zXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly90aGVzdHJhdG9zLm9yZ1wiXG4gIH0sXG4gIFwiNjA3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjA3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjVmXCIsXG4gICAgXCJzeW1ib2xcIjogXCJUT05cIixcbiAgICBcIm5hbWVcIjogXCJUT05cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3RvbmNvaW4ub3JnXCJcbiAgfSxcbiAgXCI2MDhcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2MDhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyNjBcIixcbiAgICBcInN5bWJvbFwiOiBcIlRBRlRcIixcbiAgICBcIm5hbWVcIjogXCJUQUZUXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cudGFmY2hhaW4uY29tXCJcbiAgfSxcbiAgXCI2MDlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2MDlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyNjFcIixcbiAgICBcInN5bWJvbFwiOiBcIkhZRFJBXCIsXG4gICAgXCJuYW1lXCI6IFwiSFlEUkFcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2h5ZHJhY2hhaW4ub3JnXCJcbiAgfSxcbiAgXCI2MTBcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2MTBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyNjJcIixcbiAgICBcInN5bWJvbFwiOiBcIk5PUlwiLFxuICAgIFwibmFtZVwiOiBcIk5vaXJcIixcbiAgICBcImxpbmtcIjogXCJodHRwOi8vd3d3Lm5vaXJvZmZpY2lhbC5vcmdcIlxuICB9LFxuICBcIjYxMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjYxMVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI2M1wiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiTWFudGEgTmV0d29yayBQcml2YXRlIEFzc2V0XCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9tYW50YS5uZXR3b3JrXCJcbiAgfSxcbiAgXCI2MTJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2MTJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyNjRcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIkNhbGFtYXJpIE5ldHdvcmsgUHJpdmF0ZSBBc3NldFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vY2FsYW1hcmkubWFudGEubmV0d29ya1wiXG4gIH0sXG4gIFwiNjEzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjEzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjY1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJXQ05cIixcbiAgICBcIm5hbWVcIjogXCJXaWRlY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vV2lkZWNvaW4ub3JnXCJcbiAgfSxcbiAgXCI2MTRcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2MTRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyNjZcIixcbiAgICBcInN5bWJvbFwiOiBcIk9QVFwiLFxuICAgIFwibmFtZVwiOiBcIk9wdGltaXN0aWMgRXRoZXJldW1cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5vcHRpbWlzbS5pb1wiXG4gIH0sXG4gIFwiNjE1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjE1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjY3XCIsXG4gICAgXCJzeW1ib2xcIjogXCJQU1dBUFwiLFxuICAgIFwibmFtZVwiOiBcIlBvbGthU3dhcFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vcG9sa2Fzd2FwLmlvXCJcbiAgfSxcbiAgXCI2MTZcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2MTZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyNjhcIixcbiAgICBcInN5bWJvbFwiOiBcIlZBTFwiLFxuICAgIFwibmFtZVwiOiBcIlZhbGlkYXRvclwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vc29yYS5vcmcvc29yYXRva2Vuc1wiXG4gIH0sXG4gIFwiNjE3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjE3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjY5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJYT1JcIixcbiAgICBcIm5hbWVcIjogXCJTb3JhXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9zb3JhLm9yZy9zb3JhdG9rZW5zXCJcbiAgfSxcbiAgXCI2MThcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2MThcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyNmFcIixcbiAgICBcInN5bWJvbFwiOiBcIlNTUFwiLFxuICAgIFwibmFtZVwiOiBcIlNtYXJ0U2hhcmVcIixcbiAgICBcImxpbmtcIjogXCJodHRwOi8vd3d3LnNtYXJ0c2hhcmUudmlwXCJcbiAgfSxcbiAgXCI2MTlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2MTlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyNmJcIixcbiAgICBcInN5bWJvbFwiOiBcIkRFSVwiLFxuICAgIFwibmFtZVwiOiBcIkRlaW1vc1hcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2RlaW1vc3gub3JnXCJcbiAgfSxcbiAgXCI2MjBcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2MjBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyNmNcIixcbiAgICBcInN5bWJvbFwiOiBcIkFYTFwiLFxuICAgIFwibmFtZVwiOiBcIkF4ZWxhclwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYXhlbGFyLm5ldHdvcmtcIlxuICB9LFxuICBcIjYyMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjYyMVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI2ZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiWkVST1wiLFxuICAgIFwibmFtZVwiOiBcIlNpbmd1bGFyaXR5XCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuc2luZ3VsYXJpdHkuZ29sZFwiXG4gIH0sXG4gIFwiNjIyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjIyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjZlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjYyM1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjYyM1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI2ZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiQkRDQVNIXCIsXG4gICAgXCJuYW1lXCI6IFwiQkRDYXNoIFByb3RvY29sXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9iZGNhc2hwcm90b2NvbC5jb21cIlxuICB9LFxuICBcIjYyNFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjYyNFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI3MFwiLFxuICAgIFwic3ltYm9sXCI6IFwiTk9CTFwiLFxuICAgIFwibmFtZVwiOiBcIk5vYmlsaXR5XCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL25vYmlsaXR5c29jaWV0eVwiXG4gIH0sXG4gIFwiNjI1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjI1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjcxXCIsXG4gICAgXCJzeW1ib2xcIjogXCJFQVNUXCIsXG4gICAgXCJuYW1lXCI6IFwiRWFzdGNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwOi8vZWFzdGh1Yi5pb1wiXG4gIH0sXG4gIFwiNjI2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjI2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjcyXCIsXG4gICAgXCJzeW1ib2xcIjogXCJLREFcIixcbiAgICBcIm5hbWVcIjogXCJLYWRlbmFcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2thZGVuYS5pb1wiXG4gIH0sXG4gIFwiNjI3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjI3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjczXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjYyOFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjYyOFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI3NFwiLFxuICAgIFwic3ltYm9sXCI6IFwiTE9SRVwiLFxuICAgIFwibmFtZVwiOiBcIkdpdG9waWFcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dpdG9waWEuY29tXCJcbiAgfSxcbiAgXCI2MjlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2MjlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyNzVcIixcbiAgICBcInN5bWJvbFwiOiBcIkZOUlwiLFxuICAgIFwibmFtZVwiOiBcIkZpbmNvclwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZmluY29yLmlvXCJcbiAgfSxcbiAgXCI2MzBcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2MzBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyNzZcIixcbiAgICBcInN5bWJvbFwiOiBcIk5FWFVTXCIsXG4gICAgXCJuYW1lXCI6IFwiTmV4dXNcIixcbiAgICBcImxpbmtcIjogXCJodHRwOi8vd3d3LnRoZW5leHVzLmdhbWVcIlxuICB9LFxuICBcIjYzMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjYzMVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI3N1wiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI2MzJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2MzJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyNzhcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNjMzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjMzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjc5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjYzNFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjYzNFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI3YVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI2MzVcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2MzVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyN2JcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNjM2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjM2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjdjXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjYzN1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjYzN1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI3ZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI2MzhcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2MzhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyN2VcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNjM5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjM5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjdmXCIsXG4gICAgXCJzeW1ib2xcIjogXCJCVFNHXCIsXG4gICAgXCJuYW1lXCI6IFwiQml0U29uZ1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYml0c29uZy5pb1wiXG4gIH0sXG4gIFwiNjQwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjQwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjgwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJMRkNcIixcbiAgICBcIm5hbWVcIjogXCJMZW9mY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbGVvZmNvaW4ub3JnXCJcbiAgfSxcbiAgXCI2NDFcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2NDFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyODFcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNjQyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjQyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjgyXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjY0M1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY0M1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI4M1wiLFxuICAgIFwic3ltYm9sXCI6IFwiQVpFUk9cIixcbiAgICBcIm5hbWVcIjogXCJBbGVwaCBaZXJvXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9hbGVwaHplcm8ub3JnXCJcbiAgfSxcbiAgXCI2NDRcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2NDRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyODRcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNjQ1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjQ1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjg1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjY0NlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY0NlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI4NlwiLFxuICAgIFwic3ltYm9sXCI6IFwiWExOXCIsXG4gICAgXCJuYW1lXCI6IFwiTHVuYXJpdW1cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5sdW5hcml1bWNvaW4uY29tXCJcbiAgfSxcbiAgXCI2NDdcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2NDdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyODdcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNjQ4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjQ4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjg4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJaUkJcIixcbiAgICBcIm5hbWVcIjogXCJaYXJiXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly96YXJiLm5ldHdvcmtcIlxuICB9LFxuICBcIjY0OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY0OVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI4OVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI2NTBcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2NTBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyOGFcIixcbiAgICBcInN5bWJvbFwiOiBcIlVDT1wiLFxuICAgIFwibmFtZVwiOiBcIkFSQ0hFdGhpY1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYXJjaGV0aGljLm5ldFwiXG4gIH0sXG4gIFwiNjUxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjUxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjhiXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjY1MlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY1MlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI4Y1wiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI2NTNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2NTNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyOGRcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNjU0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjU0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjhlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjY1NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY1NVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI4ZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI2NTZcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2NTZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyOTBcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNjU3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjU3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjkxXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjY1OFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY1OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI5MlwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI2NTlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2NTlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyOTNcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNjYwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjYwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjk0XCIsXG4gICAgXCJzeW1ib2xcIjogXCJQSVJBVEVcIixcbiAgICBcIm5hbWVcIjogXCJQaXJhdGVDYXNoXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9waXJhdGVjYXNoLm5ldFwiXG4gIH0sXG4gIFwiNjYxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjYxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjk1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjY2MlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY2MlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI5NlwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI2NjNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2NjNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyOTdcIixcbiAgICBcInN5bWJvbFwiOiBcIlNGUlhcIixcbiAgICBcIm5hbWVcIjogXCJFdGhlckdlbSBTYXBwaGlyZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZWdlbS5pb1wiXG4gIH0sXG4gIFwiNjY0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjY0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMjk4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjY2NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY2NVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI5OVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI2NjZcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2NjZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyOWFcIixcbiAgICBcInN5bWJvbFwiOiBcIkFDVFwiLFxuICAgIFwibmFtZVwiOiBcIkFjaGFpblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmFjaGFpbi5jb21cIlxuICB9LFxuICBcIjY2N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY2N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI5YlwiLFxuICAgIFwic3ltYm9sXCI6IFwiUFJLTFwiLFxuICAgIFwibmFtZVwiOiBcIlBlcmtsZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZXNwcmV6em8uaW9cIlxuICB9LFxuICBcIjY2OFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY2OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI5Y1wiLFxuICAgIFwic3ltYm9sXCI6IFwiU1NDXCIsXG4gICAgXCJuYW1lXCI6IFwiU2VsZlNlbGxcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5zZWxmc2VsbC5jb21cIlxuICB9LFxuICBcIjY2OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY2OVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI5ZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiR0NcIixcbiAgICBcIm5hbWVcIjogXCJHYXRlQ2hhaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5nYXRlY2hhaW4uaW9cIlxuICB9LFxuICBcIjY3MFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY3MFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDI5ZVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI2NzFcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2NzFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyOWZcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNjcyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjcyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmEwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjY3M1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY3M1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJhMVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI2NzRcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2NzRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyYTJcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNjc1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjc1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmEzXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjY3NlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY3NlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJhNFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI2NzdcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2NzdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyYTVcIixcbiAgICBcInN5bWJvbFwiOiBcIllVTkdFXCIsXG4gICAgXCJuYW1lXCI6IFwiWXVuZ2VcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3l1bmdlLm9uZVwiXG4gIH0sXG4gIFwiNjc4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjc4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmE2XCIsXG4gICAgXCJzeW1ib2xcIjogXCJWb2tlblwiLFxuICAgIFwibmFtZVwiOiBcIlZva2VuXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly92b2tlbi5pb1wiXG4gIH0sXG4gIFwiNjc5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjc5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmE3XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjY4MFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY4MFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJhOFwiLFxuICAgIFwic3ltYm9sXCI6IFwiRXZyeW5ldFwiLFxuICAgIFwibmFtZVwiOiBcIkV2cnluZXRcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2V2cnluZXQuaW9cIlxuICB9LFxuICBcIjY4MVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY4MVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJhOVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI2ODJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2ODJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyYWFcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNjgzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjgzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmFiXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjY4NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY4NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJhY1wiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI2ODVcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2ODVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyYWRcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNjg2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjg2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmFlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJLQVJcIixcbiAgICBcIm5hbWVcIjogXCJLYXJ1cmEgTmV0d29ya1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8va2FydXJhLm5ldHdvcmtcIlxuICB9LFxuICBcIjY4N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY4N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJhZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI2ODhcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2ODhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyYjBcIixcbiAgICBcInN5bWJvbFwiOiBcIkNFVFwiLFxuICAgIFwibmFtZVwiOiBcIkNvaW5FeCBDaGFpblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmNvaW5leC5vcmdcIlxuICB9LFxuICBcIjY4OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY4OVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJiMVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI2OTBcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2OTBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyYjJcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNjkxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjkxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmIzXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjY5MlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY5MlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJiNFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI2OTNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2OTNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyYjVcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNjk0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjk0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmI2XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjY5NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY5NVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJiN1wiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI2OTZcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2OTZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyYjhcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNjk3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjk3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmI5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjY5OFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY5OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJiYVwiLFxuICAgIFwic3ltYm9sXCI6IFwiVkVJTFwiLFxuICAgIFwibmFtZVwiOiBcIlZlaWxcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy52ZWlsLXByb2plY3QuY29tXCJcbiAgfSxcbiAgXCI2OTlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2OTlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyYmJcIixcbiAgICBcInN5bWJvbFwiOiBcIkdJT1wiLFxuICAgIFwibmFtZVwiOiBcIkdpb1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9xR2lvXCJcbiAgfSxcbiAgXCI3MDBcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3MDBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyYmNcIixcbiAgICBcInN5bWJvbFwiOiBcIlhEQUlcIixcbiAgICBcIm5hbWVcIjogXCJ4RGFpXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9ibG9ja3Njb3V0LmNvbS9wb2EvZGFpXCJcbiAgfSxcbiAgXCI3MDFcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3MDFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyYmRcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzAyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzAyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmJlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjcwM1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjcwM1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJiZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3MDRcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3MDRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyYzBcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzA1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzA1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmMxXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjcwNlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjcwNlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJjMlwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3MDdcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3MDdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyYzNcIixcbiAgICBcInN5bWJvbFwiOiBcIk1DT0lOXCIsXG4gICAgXCJuYW1lXCI6IFwiTW9uZXRhIENvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL21vbmV0YS50b2RheS9tb25ldGFjb2luXCJcbiAgfSxcbiAgXCI3MDhcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3MDhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyYzRcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzA5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzA5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmM1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjcxMFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjcxMFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJjNlwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3MTFcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3MTFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyYzdcIixcbiAgICBcInN5bWJvbFwiOiBcIkNIQ1wiLFxuICAgIFwibmFtZVwiOiBcIkNoYWluY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmNoYWluY29pbi5vcmdcIlxuICB9LFxuICBcIjcxMlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjcxMlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJjOFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3MTNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3MTNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyYzlcIixcbiAgICBcInN5bWJvbFwiOiBcIlhUTFwiLFxuICAgIFwibmFtZVwiOiBcIkthdGFsIENoYWluXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9rYXRhbGNoYWluLmNvbVwiXG4gIH0sXG4gIFwiNzE0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzE0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmNhXCIsXG4gICAgXCJzeW1ib2xcIjogXCJCTkJcIixcbiAgICBcIm5hbWVcIjogXCJCaW5hbmNlXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuYmluYW5jZS5vcmdcIlxuICB9LFxuICBcIjcxNVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjcxNVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJjYlwiLFxuICAgIFwic3ltYm9sXCI6IFwiU0lOXCIsXG4gICAgXCJuYW1lXCI6IFwiU2lub3ZhdGVcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3Npbm92YXRlLmlvXCJcbiAgfSxcbiAgXCI3MTZcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3MTZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyY2NcIixcbiAgICBcInN5bWJvbFwiOiBcIkRMTlwiLFxuICAgIFwibmFtZVwiOiBcIkRlbGlvblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZGVsaW9uLm9ubGluZVwiXG4gIH0sXG4gIFwiNzE3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzE3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmNkXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjcxOFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjcxOFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJjZVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3MTlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3MTlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyY2ZcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzIwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzIwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmQwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjcyMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjcyMVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJkMVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3MjJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3MjJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyZDJcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzIzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzIzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmQzXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjcyNFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjcyNFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJkNFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3MjVcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3MjVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyZDVcIixcbiAgICBcInN5bWJvbFwiOiBcIk1DWFwiLFxuICAgIFwibmFtZVwiOiBcIk11bHRpQ2FzaFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbXVsdGljYXNoLmlvXCJcbiAgfSxcbiAgXCI3MjZcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3MjZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyZDZcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzI3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzI3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmQ3XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjcyOFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjcyOFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJkOFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3MjlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3MjlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyZDlcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzMwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzMwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmRhXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjczMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjczMVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJkYlwiLFxuICAgIFwic3ltYm9sXCI6IFwiQk1LXCIsXG4gICAgXCJuYW1lXCI6IFwiQml0bWFya1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYml0bWFyay5jb21cIlxuICB9LFxuICBcIjczMlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjczMlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJkY1wiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3MzNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3MzNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyZGRcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzM0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzM0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmRlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJERU5UWFwiLFxuICAgIFwibmFtZVwiOiBcIkRFTlROZXRcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5kZW50bmV0LmlvXCJcbiAgfSxcbiAgXCI3MzVcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3MzVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyZGZcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzM2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzM2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmUwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjczN1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjczN1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJlMVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQVRPUFwiLFxuICAgIFwibmFtZVwiOiBcIkZpbmFuY2lhbCBCbG9ja2NoYWluXCJcbiAgfSxcbiAgXCI3MzhcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3MzhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyZTJcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzM5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzM5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmUzXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjc0MFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc0MFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJlNFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3NDFcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3NDFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyZTVcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzQyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzQyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmU2XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjc0M1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc0M1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJlN1wiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3NDRcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3NDRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyZThcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzQ1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzQ1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmU5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjc0NlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc0NlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJlYVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3NDdcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3NDdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyZWJcIixcbiAgICBcInN5bWJvbFwiOiBcIlJBRFwiLFxuICAgIFwibmFtZVwiOiBcIkNlbnRyaWZ1Z2VcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2NlbnRyaWZ1Z2UuaW9cIlxuICB9LFxuICBcIjc0OFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc0OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJlY1wiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3NDlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3NDlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyZWRcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzUwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzUwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmVlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJYUFJUXCIsXG4gICAgXCJuYW1lXCI6IFwiUGVyc2lzdGVuY2VcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3BlcnNpc3RlbmNlLm9uZVwiXG4gIH0sXG4gIFwiNzUxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzUxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmVmXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjc1MlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc1MlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJmMFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3NTNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3NTNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyZjFcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzU0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzU0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmYyXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjc1NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc1NVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJmM1wiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3NTZcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3NTZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyZjRcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzU3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzU3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmY1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjc1OFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc1OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJmNlwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3NTlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3NTlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyZjdcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzYwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzYwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmY4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjc2MVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc2MVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJmOVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3NjJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3NjJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyZmFcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzYzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzYzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmZiXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjc2NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc2NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJmY1wiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3NjVcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3NjVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAyZmRcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzY2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzY2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMmZlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjc2N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc2N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDJmZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3NjhcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3NjhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzMDBcIixcbiAgICBcInN5bWJvbFwiOiBcIkJBTExaXCIsXG4gICAgXCJuYW1lXCI6IFwiQmFsbHpjb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9iYWxsemNvaW4ub3JnXCJcbiAgfSxcbiAgXCI3NjlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3NjlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzMDFcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzcwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzcwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzAyXCIsXG4gICAgXCJzeW1ib2xcIjogXCJDT1NBXCIsXG4gICAgXCJuYW1lXCI6IFwiQ29zYW50YVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9jb3NhbnRhXCJcbiAgfSxcbiAgXCI3NzFcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3NzFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzMDNcIixcbiAgICBcInN5bWJvbFwiOiBcIkJSXCIsXG4gICAgXCJuYW1lXCI6IFwiQlJcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2JvbHNhZGlnaXRhbC5jb20uYnJcIlxuICB9LFxuICBcIjc3MlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc3MlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDMwNFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3NzNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3NzNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzMDVcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzc0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzc0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzA2XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjc3NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc3NVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDMwN1wiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3NzZcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3NzZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzMDhcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzc3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzc3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzA5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJCVFdcIixcbiAgICBcIm5hbWVcIjogXCJCaXRjb2luIFdvcmxkXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL2J0dy5vbmVcIlxuICB9LFxuICBcIjc3OFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc3OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDMwYVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3NzlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3NzlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzMGJcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzgwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzgwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzBjXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjc4MVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc4MVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDMwZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3ODJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3ODJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzMGVcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzgzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzgzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzBmXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjc4NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc4NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDMxMFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3ODVcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3ODVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzMTFcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzg2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzg2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzEyXCIsXG4gICAgXCJzeW1ib2xcIjogXCJVSUREXCIsXG4gICAgXCJuYW1lXCI6IFwiVUlERFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9VSUREL1VJRERcIlxuICB9LFxuICBcIjc4N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc4N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDMxM1wiLFxuICAgIFwic3ltYm9sXCI6IFwiQUNBXCIsXG4gICAgXCJuYW1lXCI6IFwiQWNhbGFcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2FjYWxhLm5ldHdvcmtcIlxuICB9LFxuICBcIjc4OFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc4OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDMxNFwiLFxuICAgIFwic3ltYm9sXCI6IFwiQk5DXCIsXG4gICAgXCJuYW1lXCI6IFwiQmlmcm9zdFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYmlmcm9zdC5maW5hbmNlXCJcbiAgfSxcbiAgXCI3ODlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3ODlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzMTVcIixcbiAgICBcInN5bWJvbFwiOiBcIlRBVVwiLFxuICAgIFwibmFtZVwiOiBcIkxhbWRlblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbGFtZGVuLmlvXCJcbiAgfSxcbiAgXCI3OTBcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3OTBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzMTZcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzkxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzkxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzE3XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjc5MlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc5MlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDMxOFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3OTNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3OTNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzMTlcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzk0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzk0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzFhXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjc5NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc5NVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDMxYlwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3OTZcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3OTZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzMWNcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiNzk3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzk3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzFkXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjc5OFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc5OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDMxZVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI3OTlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3OTlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzMWZcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiODAwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiODAwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzIwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJCRUVUXCIsXG4gICAgXCJuYW1lXCI6IFwiQmVldGxlIENvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2JlZXRsZWNvaW4uaW9cIlxuICB9LFxuICBcIjgwMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjgwMVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDMyMVwiLFxuICAgIFwic3ltYm9sXCI6IFwiRFNUXCIsXG4gICAgXCJuYW1lXCI6IFwiRFNUUkFcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2RzdHJhLmlvXCJcbiAgfSxcbiAgXCI4MDJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4MDJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzMjJcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiODAzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiODAzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzIzXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjgwNFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjgwNFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDMyNFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI4MDVcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4MDVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzMjVcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiODA2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiODA2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzI2XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjgwN1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjgwN1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDMyN1wiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI4MDhcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4MDhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzMjhcIixcbiAgICBcInN5bWJvbFwiOiBcIlFWVFwiLFxuICAgIFwibmFtZVwiOiBcIlF2b2x0YVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vcXZvbHRhLmNvbVwiXG4gIH0sXG4gIFwiODA5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiODA5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzI5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjgxMFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjgxMFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDMyYVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI4MTFcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4MTFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzMmJcIixcbiAgICBcInN5bWJvbFwiOiBcIkRWUE5cIixcbiAgICBcIm5hbWVcIjogXCJTZW50aW5lbFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vc2VudGluZWwuY29cIlxuICB9LFxuICBcIjgxMlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjgxMlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDMyY1wiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI4MTNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4MTNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzMmRcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiODE0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiODE0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzJlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjgxNVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjgxNVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDMyZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI4MTZcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4MTZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzMzBcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiODE3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiODE3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzMxXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjgxOFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjgxOFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDMzMlwiLFxuICAgIFwic3ltYm9sXCI6IFwiVkVUXCIsXG4gICAgXCJuYW1lXCI6IFwiVmVDaGFpbiBUb2tlblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vdmVjaGFpbi5jb21cIlxuICB9LFxuICBcIjgxOVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjgxOVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDMzM1wiLFxuICAgIFwic3ltYm9sXCI6IFwiUkVFRlwiLFxuICAgIFwibmFtZVwiOiBcIlJlZWZcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3JlZWYuaW8vXCJcbiAgfSxcbiAgXCI4MjBcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4MjBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzMzRcIixcbiAgICBcInN5bWJvbFwiOiBcIkNMT1wiLFxuICAgIFwibmFtZVwiOiBcIkNhbGxpc3RvXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL2NhbGxpc3RvLm5ldHdvcmtcIlxuICB9LFxuICBcIjgyMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjgyMVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDMzNVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI4MjJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4MjJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzMzZcIixcbiAgICBcInN5bWJvbFwiOiBcIkJEQlwiLFxuICAgIFwibmFtZVwiOiBcIkJpZ2NoYWluREJcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dpdGh1Yi5jb20vYmlnY2hhaW5kYlwiXG4gIH0sXG4gIFwiODIzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiODIzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzM3XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjgyNFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjgyNFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDMzOFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI4MjVcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4MjVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzMzlcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiODI2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiODI2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzNhXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjgyN1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjgyN1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDMzYlwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI4MjhcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4MjhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzM2NcIixcbiAgICBcInN5bWJvbFwiOiBcIkNDTlwiLFxuICAgIFwibmFtZVwiOiBcIkNvbXB1dGVDb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9jb21wdXRlY29pbi5uZXR3b3JrXCJcbiAgfSxcbiAgXCI4MjlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4MjlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzM2RcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiODMwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiODMwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzNlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjgzMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjgzMVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDMzZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiQ1JVWlwiLFxuICAgIFwibmFtZVwiOiBcImNydXpiaXRcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dpdGh1Yi5jb20vY3J1emJpdC9jcnV6Yml0XCJcbiAgfSxcbiAgXCI4MzJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4MzJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzNDBcIixcbiAgICBcInN5bWJvbFwiOiBcIlNBUFBcIixcbiAgICBcIm5hbWVcIjogXCJTYXBwaGlyZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vc2FwcGNvaW4uY29tXCJcbiAgfSxcbiAgXCI4MzNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4MzNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzNDFcIixcbiAgICBcInN5bWJvbFwiOiBcIjc3N1wiLFxuICAgIFwibmFtZVwiOiBcIkphY2twb3RcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovLzc3N2NvaW4ud2luXCJcbiAgfSxcbiAgXCI4MzRcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4MzRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzNDJcIixcbiAgICBcInN5bWJvbFwiOiBcIktZQU5cIixcbiAgICBcIm5hbWVcIjogXCJLeWFuaXRlXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9reWFuY29pbi5uZXRcIlxuICB9LFxuICBcIjgzNVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjgzNVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM0M1wiLFxuICAgIFwic3ltYm9sXCI6IFwiQVpSXCIsXG4gICAgXCJuYW1lXCI6IFwiQXp6dXJlXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9henp1cmVjb2luLm5ldFwiXG4gIH0sXG4gIFwiODM2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiODM2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzQ0XCIsXG4gICAgXCJzeW1ib2xcIjogXCJDRkxcIixcbiAgICBcIm5hbWVcIjogXCJDcnlwdG9GbG93XCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9jcnlwdG9mbG93LmV1XCJcbiAgfSxcbiAgXCI4MzdcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4MzdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzNDVcIixcbiAgICBcInN5bWJvbFwiOiBcIkRBU0hEXCIsXG4gICAgXCJuYW1lXCI6IFwiRGFzaCBEaWFtb25kXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9kYXNoZGlhbW9uZC5uZXRcIlxuICB9LFxuICBcIjgzOFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjgzOFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM0NlwiLFxuICAgIFwic3ltYm9sXCI6IFwiVFJUVFwiLFxuICAgIFwibmFtZVwiOiBcIlRyaXR0aXVtXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL1RyaXR0aXVtL3RyaXR0aXVtXCJcbiAgfSxcbiAgXCI4MzlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4MzlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzNDdcIixcbiAgICBcInN5bWJvbFwiOiBcIlVDUlwiLFxuICAgIFwibmFtZVwiOiBcIlVsdHJhIENsZWFyXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly91Y3Jjb2luLm5ldFwiXG4gIH0sXG4gIFwiODQwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiODQwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzQ4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJQTllcIixcbiAgICBcIm5hbWVcIjogXCJQZW9ueVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9QZW9ueVRlYW0vcGVvbnlcIlxuICB9LFxuICBcIjg0MVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjg0MVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM0OVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQkVDTlwiLFxuICAgIFwibmFtZVwiOiBcIkJlYWNvblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9iZWFjb25jcnlwdG8vYmVhY29uXCJcbiAgfSxcbiAgXCI4NDJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4NDJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzNGFcIixcbiAgICBcInN5bWJvbFwiOiBcIk1PTktcIixcbiAgICBcIm5hbWVcIjogXCJNb25rXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9tb25rY29pbi5uZXRcIlxuICB9LFxuICBcIjg0M1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjg0M1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM0YlwiLFxuICAgIFwic3ltYm9sXCI6IFwiU0FHQVwiLFxuICAgIFwibmFtZVwiOiBcIkNyeXB0b1NhZ2FcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvc2FnYWNvaW4vU0FHQVwiXG4gIH0sXG4gIFwiODQ0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiODQ0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzRjXCIsXG4gICAgXCJzeW1ib2xcIjogXCJTVVZcIixcbiAgICBcIm5hbWVcIjogXCJTdXZlcmVub1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9kZWNlbm9teS9TVVZcIlxuICB9LFxuICBcIjg0NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjg0NVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM0ZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiRVNLXCIsXG4gICAgXCJuYW1lXCI6IFwiRXNrYUNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2Vza2Fjb2luLmNvbVwiXG4gIH0sXG4gIFwiODQ2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiODQ2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzRlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJPV09cIixcbiAgICBcIm5hbWVcIjogXCJPbmVXb3JsZCBDb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9vbmV3b3JsZGNvaW4uaW9cIlxuICB9LFxuICBcIjg0N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjg0N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM0ZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiUEVQU1wiLFxuICAgIFwibmFtZVwiOiBcIlBFUFMgQ29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vcHJvamVjdC5wZXBzLnRvZGF5XCJcbiAgfSxcbiAgXCI4NDhcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4NDhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzNTBcIixcbiAgICBcInN5bWJvbFwiOiBcIkJJUlwiLFxuICAgIFwibmFtZVwiOiBcIkJpcmFrZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYmlyYWtlLmNvbVwiXG4gIH0sXG4gIFwiODQ5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiODQ5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzUxXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjg1MFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjg1MFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM1MlwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI4NTFcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4NTFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzNTNcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiODUyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiODUyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzU0XCIsXG4gICAgXCJzeW1ib2xcIjogXCJEU01cIixcbiAgICBcIm5hbWVcIjogXCJEZXNtb3NcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2Rlc21vcy5uZXR3b3JrXCJcbiAgfSxcbiAgXCI4NTNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4NTNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzNTVcIixcbiAgICBcInN5bWJvbFwiOiBcIlBSQ1lcIixcbiAgICBcIm5hbWVcIjogXCJQUkNZIENvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3ByY3ljb2luLmNvbVwiXG4gIH0sXG4gIFwiODU0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiODU0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzU2XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjg1NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjg1NVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM1N1wiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI4NTZcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4NTZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzNThcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiODU3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiODU3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzU5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjg1OFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjg1OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM1YVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI4NTlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4NTlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzNWJcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiODYwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiODYwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzVjXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjg2MVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjg2MVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM1ZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI4NjJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4NjJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzNWVcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiODYzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiODYzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzVmXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjg2NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjg2NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM2MFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI4NjVcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4NjVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzNjFcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiODY2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiODY2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzYyXCIsXG4gICAgXCJzeW1ib2xcIjogXCJNT0JcIixcbiAgICBcIm5hbWVcIjogXCJNb2JpbGVDb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cubW9iaWxlY29pbi5jb21cIlxuICB9LFxuICBcIjg2N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjg2N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM2M1wiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI4NjhcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4NjhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzNjRcIixcbiAgICBcInN5bWJvbFwiOiBcIklGXCIsXG4gICAgXCJuYW1lXCI6IFwiSW5maW5pdGVmdXR1cmVcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2luZmluaXRlZnV0dXJlLnRvcFwiXG4gIH0sXG4gIFwiODY5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiODY5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzY1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjg3MFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjg3MFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM2NlwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI4NzFcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4NzFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzNjdcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiODcyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiODcyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzY4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjg3M1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjg3M1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM2OVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI4NzRcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4NzRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzNmFcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiODc1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiODc1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzZiXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjg3NlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjg3NlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM2Y1wiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI4NzdcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4NzdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzNmRcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiODc4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiODc4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzZlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjg3OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjg3OVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM2ZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI4ODBcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4ODBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzNzBcIixcbiAgICBcInN5bWJvbFwiOiBcIkxVTVwiLFxuICAgIFwibmFtZVwiOiBcIkx1bSBOZXR3b3JrXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9sdW0ubmV0d29ya1wiXG4gIH0sXG4gIFwiODgxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiODgxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzcxXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjg4MlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjg4MlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM3MlwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI4ODNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4ODNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzNzNcIixcbiAgICBcInN5bWJvbFwiOiBcIlpCQ1wiLFxuICAgIFwibmFtZVwiOiBcIlpvb0JDXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly96b29iYy5jb21cIlxuICB9LFxuICBcIjg4NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjg4NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM3NFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI4ODVcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4ODVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzNzVcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiODg2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiODg2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzc2XCIsXG4gICAgXCJzeW1ib2xcIjogXCJBREZcIixcbiAgICBcIm5hbWVcIjogXCJBRCBUb2tlblwiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly9hZGZ1bmRzLm9yZ1wiXG4gIH0sXG4gIFwiODg3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiODg3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzc3XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjg4OFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjg4OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM3OFwiLFxuICAgIFwic3ltYm9sXCI6IFwiTkVPXCIsXG4gICAgXCJuYW1lXCI6IFwiTkVPXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9uZW8ub3JnXCJcbiAgfSxcbiAgXCI4ODlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4ODlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzNzlcIixcbiAgICBcInN5bWJvbFwiOiBcIlRPTU9cIixcbiAgICBcIm5hbWVcIjogXCJUT01PXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly90b21vY2hhaW4uY29tXCJcbiAgfSxcbiAgXCI4OTBcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4OTBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzN2FcIixcbiAgICBcInN5bWJvbFwiOiBcIlhTRUxcIixcbiAgICBcIm5hbWVcIjogXCJTZWxuXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9zZWxueC5qcFwiXG4gIH0sXG4gIFwiODkxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiODkxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzdiXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjg5MlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjg5MlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM3Y1wiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI4OTNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4OTNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzN2RcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiODk0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiODk0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzdlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjg5NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjg5NVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM3ZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI4OTZcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4OTZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzODBcIixcbiAgICBcInN5bWJvbFwiOiBcIkxLU0NcIixcbiAgICBcIm5hbWVcIjogXCJMS1NDb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cubGtzY2hhaW4uaW9cIlxuICB9LFxuICBcIjg5N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjg5N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM4MVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI4OThcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4OThcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzODJcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiODk5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiODk5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzgzXCIsXG4gICAgXCJzeW1ib2xcIjogXCJYRUNcIixcbiAgICBcIm5hbWVcIjogXCJlQ2FzaFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZS5jYXNoXCJcbiAgfSxcbiAgXCI5MDBcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5MDBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzODRcIixcbiAgICBcInN5bWJvbFwiOiBcIkxNT1wiLFxuICAgIFwibmFtZVwiOiBcIkx1bWVuZW9cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2x1bWVuZW8ubmV0d29ya1wiXG4gIH0sXG4gIFwiOTAxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTAxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzg1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjkwMlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjkwMlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM4NlwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5MDNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5MDNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzODdcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiOTA0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTA0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzg4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJITlRcIixcbiAgICBcIm5hbWVcIjogXCJIZWxpdW1cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2hlbGl1bS5jb21cIlxuICB9LFxuICBcIjkwNVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjkwNVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM4OVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5MDZcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5MDZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzOGFcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiOTA3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTA3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzhiXCIsXG4gICAgXCJzeW1ib2xcIjogXCJGSVNcIixcbiAgICBcIm5hbWVcIjogXCJTdGFGaVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vc3RhZmkuaW9cIlxuICB9LFxuICBcIjkwOFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjkwOFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM4Y1wiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5MDlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5MDlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzOGRcIixcbiAgICBcInN5bWJvbFwiOiBcIlNBQUdFXCIsXG4gICAgXCJuYW1lXCI6IFwiU2FhZ2VcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3NhYWdlLmlvXCJcbiAgfSxcbiAgXCI5MTBcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5MTBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzOGVcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiOTExXCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTExXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzhmXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjkxMlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjkxMlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM5MFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5MTNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5MTNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzOTFcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiOTE0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTE0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzkyXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjkxNVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjkxNVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM5M1wiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5MTZcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5MTZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzOTRcIixcbiAgICBcInN5bWJvbFwiOiBcIk1FVEFcIixcbiAgICBcIm5hbWVcIjogXCJNZXRhZGl1bVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3Lm1ldGFkaXVtLmNvbVwiXG4gIH0sXG4gIFwiOTE3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTE3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzk1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJGUkFcIixcbiAgICBcIm5hbWVcIjogXCJGaW5kb3JhXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuZmluZG9yYS5vcmdcIlxuICB9LFxuICBcIjkxOFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjkxOFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM5NlwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5MTlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5MTlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzOTdcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiOTIwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTIwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzk4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjkyMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjkyMVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM5OVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5MjJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5MjJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzOWFcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiOTIzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTIzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwMzliXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjkyNFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjkyNFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM5Y1wiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5MjVcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5MjVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzOWRcIixcbiAgICBcInN5bWJvbFwiOiBcIkRJUFwiLFxuICAgIFwibmFtZVwiOiBcIkRpcHBlciBOZXR3b3JrXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuZGlwcGVybmV0d29yay5jb21cIlxuICB9LFxuICBcIjkyNlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjkyNlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDM5ZVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5MjdcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5MjdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzOWZcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiOTI4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTI4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2EwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjkyOVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjkyOVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDNhMVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5MzBcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5MzBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzYTJcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiOTMxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTMxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2EzXCIsXG4gICAgXCJzeW1ib2xcIjogXCJSVU5FXCIsXG4gICAgXCJuYW1lXCI6IFwiVEhPUkNoYWluIChSVU5FKVwiLFxuICAgIFwibGlua1wiOiBcIlJVTkVcIlxuICB9LFxuICBcIjkzMlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjkzMlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDNhNFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5MzNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5MzNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzYTVcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiOTM0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTM0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2E2XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjkzNVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjkzNVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDNhN1wiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5MzZcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5MzZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzYThcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiOTM3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTM3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2E5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjkzOFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjkzOFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDNhYVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5MzlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5MzlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzYWJcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiOTQwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTQwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2FjXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjk0MVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjk0MVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDNhZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5NDJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5NDJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzYWVcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiOTQzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTQzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2FmXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjk0NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjk0NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDNiMFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5NDVcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5NDVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzYjFcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiOTQ2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTQ2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2IyXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjk0N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjk0N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDNiM1wiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5NDhcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5NDhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzYjRcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiOTQ5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTQ5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2I1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjk1MFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjk1MFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDNiNlwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5NTFcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5NTFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzYjdcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiOTUyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTUyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2I4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjk1M1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjk1M1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDNiOVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5NTRcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5NTRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzYmFcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiOTU1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTU1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2JiXCIsXG4gICAgXCJzeW1ib2xcIjogXCJMVFBcIixcbiAgICBcIm5hbWVcIjogXCJMaWZldGlvbkNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2NvaW50b2JhbmtzLmNvbVwiXG4gIH0sXG4gIFwiOTU2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTU2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2JjXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjk1N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjk1N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDNiZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5NThcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5NThcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzYmVcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIktpY2tTb2NjZXJcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2tpY2tzb2NjZXJjb2luLmNvbVwiXG4gIH0sXG4gIFwiOTU5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTU5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2JmXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjk2MFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjk2MFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDNjMFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5NjFcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5NjFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzYzFcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiOTYyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTYyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2MyXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjk2M1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjk2M1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDNjM1wiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5NjRcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5NjRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzYzRcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiOTY1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTY1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2M1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjk2NlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjk2NlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDNjNlwiLFxuICAgIFwic3ltYm9sXCI6IFwiTUFUSUNcIixcbiAgICBcIm5hbWVcIjogXCJNYXRpY1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbWF0aWMubmV0d29ya1wiXG4gIH0sXG4gIFwiOTY3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTY3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2M3XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjk2OFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjk2OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDNjOFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5NjlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5NjlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzYzlcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiOTcwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTcwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2NhXCIsXG4gICAgXCJzeW1ib2xcIjogXCJUV0lOU1wiLFxuICAgIFwibmFtZVwiOiBcIlRXSU5TXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93aW4ud2luXCJcbiAgfSxcbiAgXCI5NzFcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5NzFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzY2JcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiOTcyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTcyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2NjXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjk3M1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjk3M1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDNjZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5NzRcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5NzRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzY2VcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiOTc1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTc1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2NmXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjk3NlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjk3NlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDNkMFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5NzdcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5NzdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzZDFcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiOTc4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTc4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2QyXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjk3OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjk3OVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDNkM1wiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5ODBcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5ODBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzZDRcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiOTgxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTgxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2Q1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjk4MlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjk4MlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDNkNlwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5ODNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5ODNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzZDdcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiOTg0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTg0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2Q4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjk4NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjk4NVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDNkOVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5ODZcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5ODZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzZGFcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiOTg3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTg3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2RiXCIsXG4gICAgXCJzeW1ib2xcIjogXCJWQ0dcIixcbiAgICBcIm5hbWVcIjogXCJWaXBDb2luLkdvbGRcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3ZpcGNvaW4uZ29sZFwiXG4gIH0sXG4gIFwiOTg4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTg4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2RjXCIsXG4gICAgXCJzeW1ib2xcIjogXCJYQVpBQlwiLFxuICAgIFwibmFtZVwiOiBcIlhhemFiIGNvcmVcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dpdGh1Yi5jb20veGF6YWJcIlxuICB9LFxuICBcIjk4OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjk4OVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDNkZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiQUlPWlwiLFxuICAgIFwibmFtZVwiOiBcIkFJT1pcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2Fpb3oubmV0d29ya1wiXG4gIH0sXG4gIFwiOTkwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTkwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2RlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjk5MVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjk5MVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDNkZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiUEVDXCIsXG4gICAgXCJuYW1lXCI6IFwiUGhvZW5peFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4Y2hhaW4vcGhvZW5peFwiXG4gIH0sXG4gIFwiOTkyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTkyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2UwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjk5M1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjk5M1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDNlMVwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiXCJcbiAgfSxcbiAgXCI5OTRcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5OTRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzZTJcIixcbiAgICBcInN5bWJvbFwiOiBcIlwiLFxuICAgIFwibmFtZVwiOiBcIlwiXG4gIH0sXG4gIFwiOTk1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTk1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2UzXCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJcIlxuICB9LFxuICBcIjk5NlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjk5NlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDNlNFwiLFxuICAgIFwic3ltYm9sXCI6IFwiT0tUXCIsXG4gICAgXCJuYW1lXCI6IFwiT0tDaGFpbiBUb2tlblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3Lm9rZXguY29tL29rY2hhaW5cIlxuICB9LFxuICBcIjk5N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjk5N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDNlNVwiLFxuICAgIFwic3ltYm9sXCI6IFwiU1VNXCIsXG4gICAgXCJuYW1lXCI6IFwiU29saWR1bVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vc29saWR1bS5uZXR3b3JrXCJcbiAgfSxcbiAgXCI5OThcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5OThcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzZTZcIixcbiAgICBcInN5bWJvbFwiOiBcIkxCVENcIixcbiAgICBcIm5hbWVcIjogXCJMaWdodG5pbmcgQml0Y29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly9sYnRjLmlvXCJcbiAgfSxcbiAgXCI5OTlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5OTlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzZTdcIixcbiAgICBcInN5bWJvbFwiOiBcIkJDRFwiLFxuICAgIFwibmFtZVwiOiBcIkJpdGNvaW4gRGlhbW9uZFwiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly9idGNkLmlvXCJcbiAgfSxcbiAgXCIxMDAwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTAwMFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDNlOFwiLFxuICAgIFwic3ltYm9sXCI6IFwiQlROXCIsXG4gICAgXCJuYW1lXCI6IFwiQml0Y29pbiBOZXdcIixcbiAgICBcImxpbmtcIjogXCJodHRwOi8vYml0Y29pbm5ldy5vcmdcIlxuICB9LFxuICBcIjEwMDFcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMDAxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2U5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJUVFwiLFxuICAgIFwibmFtZVwiOiBcIlRodW5kZXJDb3JlXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly90aHVuZGVyY29yZS5jb21cIlxuICB9LFxuICBcIjEwMDJcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMDAyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2VhXCIsXG4gICAgXCJzeW1ib2xcIjogXCJCS1RcIixcbiAgICBcIm5hbWVcIjogXCJCYW5LaXR0XCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuYmFua2l0dC5uZXR3b3JrXCJcbiAgfSxcbiAgXCIxMDAzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTAwM1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDNlYlwiLFxuICAgIFwic3ltYm9sXCI6IFwiTk9ETFwiLFxuICAgIFwibmFtZVwiOiBcIk5vZGxlXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9ub2RsZS5pb1wiXG4gIH0sXG4gIFwiMTAwN1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjEwMDdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzZWZcIixcbiAgICBcInN5bWJvbFwiOiBcIkZUTVwiLFxuICAgIFwibmFtZVwiOiBcIkZhbnRvbVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZmFudG9tLmZvdW5kYXRpb25cIlxuICB9LFxuICBcIjEwMDhcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMDA4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2YwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJSUEdcIixcbiAgICBcIm5hbWVcIjogXCJSUEdcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3JhbmdlcnNwcm90b2NvbC5jb21cIlxuICB9LFxuICBcIjEwMTBcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMDEwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2YyXCIsXG4gICAgXCJzeW1ib2xcIjogXCJIVFwiLFxuICAgIFwibmFtZVwiOiBcIkh1b2JpIEVDTyBDaGFpblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmhlY29jaGFpbi5jb21cIlxuICB9LFxuICBcIjEwMTFcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMDExXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2YzXCIsXG4gICAgXCJzeW1ib2xcIjogXCJFTFZcIixcbiAgICBcIm5hbWVcIjogXCJFbHV2aW9cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2VsdXYuaW9cIlxuICB9LFxuICBcIjEwMTNcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMDEzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwM2Y1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJCSUNcIixcbiAgICBcIm5hbWVcIjogXCJCZWluY3J5cHRvXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9iZWluY3J5cHRvLm9yZ1wiXG4gIH0sXG4gIFwiMTAyMFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjEwMjBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzZmNcIixcbiAgICBcInN5bWJvbFwiOiBcIkVWQ1wiLFxuICAgIFwibmFtZVwiOiBcIkV2cmljZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZXZyaWNlLmNvbVwiXG4gIH0sXG4gIFwiMTAyMlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjEwMjJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzZmVcIixcbiAgICBcInN5bWJvbFwiOiBcIlhSRFwiLFxuICAgIFwibmFtZVwiOiBcIlJhZGl4IERMVFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LnJhZGl4ZGx0LmNvbVwiXG4gIH0sXG4gIFwiMTAyM1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjEwMjNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDAzZmZcIixcbiAgICBcInN5bWJvbFwiOiBcIk9ORVwiLFxuICAgIFwibmFtZVwiOiBcIkhBUk1PTlktT05FXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9oYXJtb255Lm9uZVwiXG4gIH0sXG4gIFwiMTAyNFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjEwMjRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDA0MDBcIixcbiAgICBcInN5bWJvbFwiOiBcIk9OVFwiLFxuICAgIFwibmFtZVwiOiBcIk9udG9sb2d5XCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9vbnQuaW9cIlxuICB9LFxuICBcIjEwMjZcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMDI2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwNDAyXCIsXG4gICAgXCJzeW1ib2xcIjogXCJLRVhcIixcbiAgICBcIm5hbWVcIjogXCJLaXJhIEV4Y2hhbmdlIFRva2VuXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9raXJhZXguY29tXCJcbiAgfSxcbiAgXCIxMDI3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTAyN1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDQwM1wiLFxuICAgIFwic3ltYm9sXCI6IFwiTUNNXCIsXG4gICAgXCJuYW1lXCI6IFwiTW9jaGltb1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbW9jaGltby5vcmdcIlxuICB9LFxuICBcIjEwMzJcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMDMyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwNDA4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJCVENSXCIsXG4gICAgXCJuYW1lXCI6IFwiQlRDUlwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9kaWQtYnRjclwiXG4gIH0sXG4gIFwiMTExMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjExMTFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDA0NTdcIixcbiAgICBcInN5bWJvbFwiOiBcIkJCQ1wiLFxuICAgIFwibmFtZVwiOiBcIkJpZyBCaXRjb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL2JpZ2JpdGNvaW5zLm9yZ1wiXG4gIH0sXG4gIFwiMTEyMFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjExMjBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDA0NjBcIixcbiAgICBcInN5bWJvbFwiOiBcIlJJU0VcIixcbiAgICBcIm5hbWVcIjogXCJSSVNFXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9yaXNlLnZpc2lvblwiXG4gIH0sXG4gIFwiMTEyMlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjExMjJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDA0NjJcIixcbiAgICBcInN5bWJvbFwiOiBcIkNNVFwiLFxuICAgIFwibmFtZVwiOiBcIkN5YmVyTWlsZXMgVG9rZW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5jeWJlcm1pbGVzLmlvXCJcbiAgfSxcbiAgXCIxMTI4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTEyOFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDQ2OFwiLFxuICAgIFwic3ltYm9sXCI6IFwiRVRTQ1wiLFxuICAgIFwibmFtZVwiOiBcIkV0aGVyZXVtIFNvY2lhbFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZXRoZXJldW1zb2NpYWwua3JcIlxuICB9LFxuICBcIjExMjlcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMTI5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwNDY5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJERklcIixcbiAgICBcIm5hbWVcIjogXCJEZUZpQ2hhaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2RlZmljaGFpbi5jb21cIlxuICB9LFxuICBcIjExMzdcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMTM3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwNDcxXCIsXG4gICAgXCJzeW1ib2xcIjogXCIkREFHXCIsXG4gICAgXCJuYW1lXCI6IFwiQ29uc3RlbGxhdGlvbiBMYWJzXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9jb25zdGVsbGF0aW9ubmV0d29yay5pb1wiXG4gIH0sXG4gIFwiMTE0NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjExNDVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDA0NzlcIixcbiAgICBcInN5bWJvbFwiOiBcIkNEWVwiLFxuICAgIFwibmFtZVwiOiBcIkJpdGNvaW4gQ2FuZHlcIixcbiAgICBcImxpbmtcIjogXCJodHRwOi8vd3d3LmJpdGNvaW5jYW5keS5vbmVcIlxuICB9LFxuICBcIjExNzBcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMTcwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwNDkyXCIsXG4gICAgXCJzeW1ib2xcIjogXCJIT09cIixcbiAgICBcIm5hbWVcIjogXCJIb28gU21hcnQgQ2hhaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5ob29zbWFydGNoYWluLmNvbVwiXG4gIH0sXG4gIFwiMTIzNFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjEyMzRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDA0ZDJcIixcbiAgICBcInN5bWJvbFwiOiBcIkFMUEhcIixcbiAgICBcIm5hbWVcIjogXCJBbGVwaGl1bVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9hbGVwaGl1bS9hbGVwaGl1bVwiXG4gIH0sXG4gIFwiMTI4NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjEyODVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDA1MDVcIixcbiAgICBcInN5bWJvbFwiOiBcIk1PVlJcIixcbiAgICBcIm5hbWVcIjogXCJNb29ucml2ZXJcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dpdGh1Yi5jb20vUHVyZVN0YWtlL21vb25iZWFtXCJcbiAgfSxcbiAgXCIxMzM3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTMzN1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDUzOVwiLFxuICAgIFwic3ltYm9sXCI6IFwiREZDXCIsXG4gICAgXCJuYW1lXCI6IFwiRGVmY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly9kZWZjb2luLW5nLm9yZ1wiXG4gIH0sXG4gIFwiMTM5N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjEzOTdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDA1NzVcIixcbiAgICBcInN5bWJvbFwiOiBcIkhZQ1wiLFxuICAgIFwibmFtZVwiOiBcIkh5Y29uXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9oeWNvbi5pb1wiXG4gIH0sXG4gIFwiMTQxMFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE0MTBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDA1ODJcIixcbiAgICBcInN5bWJvbFwiOiBcIlRFTlRTTFBcIixcbiAgICBcIm5hbWVcIjogXCJURU5UIFNpbXBsZSBMZWRnZXIgUHJvdG9jb2xcIlxuICB9LFxuICBcIjE1MjRcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxNTI0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwNWY0XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJUYWxlclwiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly90YWxlci5zaXRlXCJcbiAgfSxcbiAgXCIxNTMzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTUzM1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDVmZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiQkVBTVwiLFxuICAgIFwibmFtZVwiOiBcIkJlYW1cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5iZWFtLm13XCJcbiAgfSxcbiAgXCIxNjE2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTYxNlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDY1MFwiLFxuICAgIFwic3ltYm9sXCI6IFwiRUxGXCIsXG4gICAgXCJuYW1lXCI6IFwiQUVMRlwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYWVsZi5pb1wiXG4gIH0sXG4gIFwiMTYxOFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE2MThcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDA2NTJcIixcbiAgICBcInN5bWJvbFwiOiBcIkFVRExcIixcbiAgICBcIm5hbWVcIjogXCJBVURMXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9hdWQub25lXCJcbiAgfSxcbiAgXCIxNjIwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTYyMFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDY1NFwiLFxuICAgIFwic3ltYm9sXCI6IFwiQVRIXCIsXG4gICAgXCJuYW1lXCI6IFwiQXRoZWlvc1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYXRoZWlvcy5jb21cIlxuICB9LFxuICBcIjE2NDJcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxNjQyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwNjZhXCIsXG4gICAgXCJzeW1ib2xcIjogXCJORVdcIixcbiAgICBcIm5hbWVcIjogXCJOZXd0b25cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5uZXd0b25wcm9qZWN0Lm9yZ1wiXG4gIH0sXG4gIFwiMTY1N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE2NTdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDA2NzlcIixcbiAgICBcInN5bWJvbFwiOiBcIkJUQVwiLFxuICAgIFwibmFtZVwiOiBcIkJ0YWNoYWluXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9iaXRjb2luYXNzZXQuaW9cIlxuICB9LFxuICBcIjE2ODhcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxNjg4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwNjk4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJCQ1hcIixcbiAgICBcIm5hbWVcIjogXCJCaXRjb2luWFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYmN4Lm9yZ1wiXG4gIH0sXG4gIFwiMTcyOVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE3MjlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDA2YzFcIixcbiAgICBcInN5bWJvbFwiOiBcIlhUWlwiLFxuICAgIFwibmFtZVwiOiBcIlRlem9zXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly90ZXpvcy5jb21cIlxuICB9LFxuICBcIjE3NzZcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxNzc2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwNmYwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJMQlRDXCIsXG4gICAgXCJuYW1lXCI6IFwiTGlxdWlkIEJUQ1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYmxvY2tzdHJlYW0uY29tL2xpcXVpZFwiXG4gIH0sXG4gIFwiMTc3N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE3NzdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDA2ZjFcIixcbiAgICBcInN5bWJvbFwiOiBcIkJCUFwiLFxuICAgIFwibmFtZVwiOiBcIkJpYmxlcGF5XCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuYmlibGVwYXkub3JnXCJcbiAgfSxcbiAgXCIxNzg0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTc4NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDZmOFwiLFxuICAgIFwic3ltYm9sXCI6IFwiSlBZU1wiLFxuICAgIFwibmFtZVwiOiBcIkpQWSBTdGFibGVjb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9zZXR0bGVuZXQuaW9cIlxuICB9LFxuICBcIjE3ODlcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxNzg5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwNmZkXCIsXG4gICAgXCJzeW1ib2xcIjogXCJWRUdBXCIsXG4gICAgXCJuYW1lXCI6IFwiVmVnYSBQcm90b2NvbFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vdmVnYS54eXpcIlxuICB9LFxuICBcIjE4MTVcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxODE1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwNzE3XCIsXG4gICAgXCJzeW1ib2xcIjogXCJBREFcIixcbiAgICBcIm5hbWVcIjogXCJDYXJkYW5vXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuY2FyZGFub2h1Yi5vcmcvZW4vaG9tZVwiXG4gIH0sXG4gIFwiMTg1NlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE4NTZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDA3NDNcIixcbiAgICBcInN5bWJvbFwiOiBcIlRFU1wiLFxuICAgIFwibmFtZVwiOiBcIlRlc2xhY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LnRlc2xhLWNvaW4uY29tXCJcbiAgfSxcbiAgXCIxODg4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTg4OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDc2MFwiLFxuICAgIFwic3ltYm9sXCI6IFwiWlRYXCIsXG4gICAgXCJuYW1lXCI6IFwiWmV0cml4XCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly96ZXRyaXguY29tL1wiXG4gIH0sXG4gIFwiMTg5OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE4OTlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDA3NmJcIixcbiAgICBcInN5bWJvbFwiOiBcIlhFQ1wiLFxuICAgIFwibmFtZVwiOiBcImVDYXNoIHRva2VuXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9lLmNhc2hcIlxuICB9LFxuICBcIjE5MDFcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxOTAxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwNzZkXCIsXG4gICAgXCJzeW1ib2xcIjogXCJDTENcIixcbiAgICBcIm5hbWVcIjogXCJDbGFzc2ljYVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9jbGFzc2ljYVwiXG4gIH0sXG4gIFwiMTkxOVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE5MTlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDA3N2ZcIixcbiAgICBcInN5bWJvbFwiOiBcIlZJUFNcIixcbiAgICBcIm5hbWVcIjogXCJWSVBTVEFSQ09JTlwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LnZpcHN0YXJjb2luLmpwXCJcbiAgfSxcbiAgXCIxOTI2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTkyNlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDc4NlwiLFxuICAgIFwic3ltYm9sXCI6IFwiQ0lUWVwiLFxuICAgIFwibmFtZVwiOiBcIkNpdHkgQ29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vY2l0eS1jaGFpbi5vcmdcIlxuICB9LFxuICBcIjE5NTVcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxOTU1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwN2EzXCIsXG4gICAgXCJzeW1ib2xcIjogXCJYWFwiLFxuICAgIFwibmFtZVwiOiBcInh4IGNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3h4Lm5ldHdvcmtcIlxuICB9LFxuICBcIjE5NzdcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxOTc3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwN2I5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJYTVhcIixcbiAgICBcIm5hbWVcIjogXCJYdW1hXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL3d3dy54dW1hY29pbi5vcmdcIlxuICB9LFxuICBcIjE5ODRcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxOTg0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwN2MwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJUUlRMXCIsXG4gICAgXCJuYW1lXCI6IFwiVHVydGxlQ29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vdHVydGxlY29pbi5sb2xcIlxuICB9LFxuICBcIjE5ODdcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxOTg3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwN2MzXCIsXG4gICAgXCJzeW1ib2xcIjogXCJFR0VNXCIsXG4gICAgXCJuYW1lXCI6IFwiRXRoZXJHZW1cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2VnZW0uaW9cIlxuICB9LFxuICBcIjE5ODlcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxOTg5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwN2M1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJIT0RMXCIsXG4gICAgXCJuYW1lXCI6IFwiSE9kbGNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2hvZGxjb2luLmNvbVwiXG4gIH0sXG4gIFwiMTk5MFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE5OTBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDA3YzZcIixcbiAgICBcInN5bWJvbFwiOiBcIlBITFwiLFxuICAgIFwibmFtZVwiOiBcIlBsYWNlaG9sZGVyc1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vcGxhY2VoLmlvXCJcbiAgfSxcbiAgXCIxOTkxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTk5MVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDdjN1wiLFxuICAgIFwic3ltYm9sXCI6IFwiU0NcIixcbiAgICBcIm5hbWVcIjogXCJTaWFcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3NpYS50ZWNoXCJcbiAgfSxcbiAgXCIxOTk2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTk5NlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDdjY1wiLFxuICAgIFwic3ltYm9sXCI6IFwiTVlUXCIsXG4gICAgXCJuYW1lXCI6IFwiTWluZXlvdXJ0aW1lXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9taW5leW91cnRpbWUuY29tXCJcbiAgfSxcbiAgXCIxOTk3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTk5N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDdjZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiUE9MSVNcIixcbiAgICBcIm5hbWVcIjogXCJQb2xpc1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vcG9saXNwYXkub3JnXCJcbiAgfSxcbiAgXCIxOTk4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTk5OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDdjZVwiLFxuICAgIFwic3ltYm9sXCI6IFwiWE1DQ1wiLFxuICAgIFwibmFtZVwiOiBcIk1vbm9lY2lcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL21vbm9lY2kuaW9cIlxuICB9LFxuICBcIjE5OTlcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxOTk5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwN2NmXCIsXG4gICAgXCJzeW1ib2xcIjogXCJDT0xYXCIsXG4gICAgXCJuYW1lXCI6IFwiQ29sb3NzdXNYVFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vY29sb3NzdXN4dC5pb1wiXG4gIH0sXG4gIFwiMjAwMFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjIwMDBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDA3ZDBcIixcbiAgICBcInN5bWJvbFwiOiBcIkdJTlwiLFxuICAgIFwibmFtZVwiOiBcIkdpbkNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dpbmNvaW4uaW9cIlxuICB9LFxuICBcIjIwMDFcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyMDAxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwN2QxXCIsXG4gICAgXCJzeW1ib2xcIjogXCJNTlBcIixcbiAgICBcIm5hbWVcIjogXCJNTlBDb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9tbnBjb2luLnByb1wiXG4gIH0sXG4gIFwiMjAxN1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjIwMTdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDA3ZTFcIixcbiAgICBcInN5bWJvbFwiOiBcIktJTlwiLFxuICAgIFwibmFtZVwiOiBcIktpblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmtpbmVjb3N5c3RlbS5vcmdcIlxuICB9LFxuICBcIjIwMThcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyMDE4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwN2UyXCIsXG4gICAgXCJzeW1ib2xcIjogXCJFT1NDXCIsXG4gICAgXCJuYW1lXCI6IFwiRU9TQ2xhc3NpY1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZW9zLWNsYXNzaWMuaW9cIlxuICB9LFxuICBcIjIwMTlcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyMDE5XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwN2UzXCIsXG4gICAgXCJzeW1ib2xcIjogXCJHQlRcIixcbiAgICBcIm5hbWVcIjogXCJHb2xkQmVhbiBUb2tlblwiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly93d3cuYWRmdW5kcy5vcmdcIlxuICB9LFxuICBcIjIwMjBcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyMDIwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwN2U0XCIsXG4gICAgXCJzeW1ib2xcIjogXCJQS0NcIixcbiAgICBcIm5hbWVcIjogXCJQS0NcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5wa2MuaW5rXCJcbiAgfSxcbiAgXCIyMDIxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjAyMVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDdlNVwiLFxuICAgIFwic3ltYm9sXCI6IFwiU0tUXCIsXG4gICAgXCJuYW1lXCI6IFwiU3VraGF2YXRpXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9zdWtoYXZhdGkuaW9cIlxuICB9LFxuICBcIjIwMjJcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyMDIyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwN2U2XCIsXG4gICAgXCJzeW1ib2xcIjogXCJYSFRcIixcbiAgICBcIm5hbWVcIjogXCJYaW5naHVvIFRva2VuXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly94aW5naHVvLnNwYWNlXCJcbiAgfSxcbiAgXCIyMDQ4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjA0OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDgwMFwiLFxuICAgIFwic3ltYm9sXCI6IFwiTUNBU0hcIixcbiAgICBcIm5hbWVcIjogXCJNQ2FzaENoYWluXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9tY2FzaC5uZXR3b3JrXCJcbiAgfSxcbiAgXCIyMDQ5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjA0OVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDgwMVwiLFxuICAgIFwic3ltYm9sXCI6IFwiVFJVRVwiLFxuICAgIFwibmFtZVwiOiBcIlRydWVDaGFpblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LnRydWVjaGFpbi5wcm9cIlxuICB9LFxuICBcIjIxMTJcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyMTEyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwODQwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJJb1RFXCIsXG4gICAgXCJuYW1lXCI6IFwiSW9URVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmlvdGUub25lXCJcbiAgfSxcbiAgXCIyMTM3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjEzN1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMDg1OVwiLFxuICAgIFwic3ltYm9sXCI6IFwiWFJHXCIsXG4gICAgXCJuYW1lXCI6IFwiRXJnb25cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2VyZ29uLm1vZVwiXG4gIH0sXG4gIFwiMjIyMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjIyMjFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDA4YWRcIixcbiAgICBcInN5bWJvbFwiOiBcIkFTS1wiLFxuICAgIFwibmFtZVwiOiBcIkFTS1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vcGVybWlzc2lvbi5pb1wiXG4gIH0sXG4gIFwiMjMwMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjIzMDFcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDA4ZmRcIixcbiAgICBcInN5bWJvbFwiOiBcIlFUVU1cIixcbiAgICBcIm5hbWVcIjogXCJRVFVNXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9xdHVtLm9yZy9lblwiXG4gIH0sXG4gIFwiMjMwMlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjIzMDJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDA4ZmVcIixcbiAgICBcInN5bWJvbFwiOiBcIkVUUFwiLFxuICAgIFwibmFtZVwiOiBcIk1ldGF2ZXJzZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbXZzLm9yZ1wiXG4gIH0sXG4gIFwiMjMwM1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjIzMDNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDA4ZmZcIixcbiAgICBcInN5bWJvbFwiOiBcIkdYQ1wiLFxuICAgIFwibmFtZVwiOiBcIkdYQ2hhaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5neGIuaW9cIlxuICB9LFxuICBcIjIzMDRcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyMzA0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwOTAwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJDUlBcIixcbiAgICBcIm5hbWVcIjogXCJDcmFuZVBheVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vY3JhbmVwYXkuaW9cIlxuICB9LFxuICBcIjIzMDVcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyMzA1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwOTAxXCIsXG4gICAgXCJzeW1ib2xcIjogXCJFTEFcIixcbiAgICBcIm5hbWVcIjogXCJFbGFzdG9zXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuZWxhc3Rvcy5vcmdcIlxuICB9LFxuICBcIjIzMzhcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyMzM4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwOTIyXCIsXG4gICAgXCJzeW1ib2xcIjogXCJTTk9XXCIsXG4gICAgXCJuYW1lXCI6IFwiU25vd2Jsb3Nzb21cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3Nub3dibG9zc29tLm9yZ1wiXG4gIH0sXG4gIFwiMjU3MFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjI1NzBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDBhMGFcIixcbiAgICBcInN5bWJvbFwiOiBcIkFPQVwiLFxuICAgIFwibmFtZVwiOiBcIkF1cm9yYVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmF1cm9yYWNoYWluLmlvXCJcbiAgfSxcbiAgXCIyNzE4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMjcxOFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMGE5ZVwiLFxuICAgIFwic3ltYm9sXCI6IFwiTkFTXCIsXG4gICAgXCJuYW1lXCI6IFwiTmVidWxhc1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbmVidWxhcy5pb1wiXG4gIH0sXG4gIFwiMjg5NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjI4OTRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDBiNGVcIixcbiAgICBcInN5bWJvbFwiOiBcIlJFT1NDXCIsXG4gICAgXCJuYW1lXCI6IFwiUkVPU0MgRWNvc3lzdGVtXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cucmVvc2MuaW9cIlxuICB9LFxuICBcIjI5NDFcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyOTQxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwYjdkXCIsXG4gICAgXCJzeW1ib2xcIjogXCJCTkRcIixcbiAgICBcIm5hbWVcIjogXCJCbG9ja25vZGVcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2Jsb2Nrbm9kZS50ZWNoXCJcbiAgfSxcbiAgXCIzMDAzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzAwM1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMGJiYlwiLFxuICAgIFwic3ltYm9sXCI6IFwiTFVYXCIsXG4gICAgXCJuYW1lXCI6IFwiTFVYXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9sdXhjb3JlLmlvXCJcbiAgfSxcbiAgXCIzMDMwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzAzMFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMGJkNlwiLFxuICAgIFwic3ltYm9sXCI6IFwiWEhCXCIsXG4gICAgXCJuYW1lXCI6IFwiSGVkZXJhIEhCQVJcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5oZWRlcmEuY29tXCJcbiAgfSxcbiAgXCIzMDc3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzA3N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMGMwNVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQ09TXCIsXG4gICAgXCJuYW1lXCI6IFwiQ29udGVudG9zXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuY29udGVudG9zLmlvXCJcbiAgfSxcbiAgXCIzMjc2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzI3NlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMGNjY1wiLFxuICAgIFwic3ltYm9sXCI6IFwiQ0NDXCIsXG4gICAgXCJuYW1lXCI6IFwiQ29kZUNoYWluXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9jb2RlY2hhaW4uaW9cIlxuICB9LFxuICBcIjMzNzdcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzMzc3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwZDMxXCIsXG4gICAgXCJzeW1ib2xcIjogXCJST0lcIixcbiAgICBcIm5hbWVcIjogXCJST0ljb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9yb2ktY29pbi5jb21cIlxuICB9LFxuICBcIjMzODFcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzMzgxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAwZDM1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJEWU5cIixcbiAgICBcIm5hbWVcIjogXCJEeW5hbWljXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9kdWFsaXR5LnNvbHV0aW9ucy9keW5hbWljXCJcbiAgfSxcbiAgXCIzMzgzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzM4M1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMGQzN1wiLFxuICAgIFwic3ltYm9sXCI6IFwiU0VRXCIsXG4gICAgXCJuYW1lXCI6IFwiU2VxdWVuY2VcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2R1YWxpdHkuc29sdXRpb25zL3NlcXVlbmNlXCJcbiAgfSxcbiAgXCIzNTUyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzU1MlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMGRlMFwiLFxuICAgIFwic3ltYm9sXCI6IFwiREVPXCIsXG4gICAgXCJuYW1lXCI6IFwiRGVzdG9jb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9kZXN0by5pb1wiXG4gIH0sXG4gIFwiMzU2NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM1NjRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDBkZWNcIixcbiAgICBcInN5bWJvbFwiOiBcIkRTVFwiLFxuICAgIFwibmFtZVwiOiBcIkRlU3RyZWFtXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9kZXN0cmVhbS5pb1wiXG4gIH0sXG4gIFwiNDA0MFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQwNDBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDBmYzhcIixcbiAgICBcInN5bWJvbFwiOiBcIkZDOFwiLFxuICAgIFwibmFtZVwiOiBcIkZDSCBOZXR3b3JrXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9mY2gubmV0d29ya1wiXG4gIH0sXG4gIFwiNDA5NlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQwOTZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDEwMDBcIixcbiAgICBcInN5bWJvbFwiOiBcIllFRVwiLFxuICAgIFwibmFtZVwiOiBcIlllZUNvXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cueWVlY28uaW9cIlxuICB9LFxuICBcIjQyMThcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0MjE4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAxMDdhXCIsXG4gICAgXCJzeW1ib2xcIjogXCJJT1RBXCIsXG4gICAgXCJuYW1lXCI6IFwiSU9UQVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmlvdGEub3JnXCJcbiAgfSxcbiAgXCI0MjQyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDI0MlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMTA5MlwiLFxuICAgIFwic3ltYm9sXCI6IFwiQVhFXCIsXG4gICAgXCJuYW1lXCI6IFwiQXhlXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL0FYRXJ1bm5lcnMvYXhlXCJcbiAgfSxcbiAgXCI0MzQzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDM0M1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMTBmN1wiLFxuICAgIFwic3ltYm9sXCI6IFwiWFlNXCIsXG4gICAgXCJuYW1lXCI6IFwiU3ltYm9sXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL25lbXRlY2gvY2F0YXB1bHQtc2VydmVyXCJcbiAgfSxcbiAgXCI1MjQ4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTI0OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMTQ4MFwiLFxuICAgIFwic3ltYm9sXCI6IFwiRklDXCIsXG4gICAgXCJuYW1lXCI6IFwiRklDXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9maWNuZXR3b3JrLmNvbVwiXG4gIH0sXG4gIFwiNTM1M1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjUzNTNcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDE0ZTlcIixcbiAgICBcInN5bWJvbFwiOiBcIkhOU1wiLFxuICAgIFwibmFtZVwiOiBcIkhhbmRzaGFrZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vaGFuZHNoYWtlLm9yZ1wiXG4gIH0sXG4gIFwiNTU1NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU1NTVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDE1YjNcIixcbiAgICBcInN5bWJvbFwiOiBcIkZVTkRcIixcbiAgICBcIm5hbWVcIjogXCJVbmlmaWNhdGlvblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vdW5pZmljYXRpb24uY29tXCJcbiAgfSxcbiAgXCI1NzU3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTc1N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMTY3ZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiU1RYXCIsXG4gICAgXCJuYW1lXCI6IFwiQmxvY2tzdGFja1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9ibG9ja3N0YWNrL2Jsb2Nrc3RhY2stY29yZVwiXG4gIH0sXG4gIFwiNTg5NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjU4OTVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDE3MDdcIixcbiAgICBcInN5bWJvbFwiOiBcIlZPV1wiLFxuICAgIFwibmFtZVwiOiBcIlZvd0NoYWluIFZPV1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vdm93Y2hhaW4ubmV0XCJcbiAgfSxcbiAgXCI1OTIwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTkyMFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMTcyMFwiLFxuICAgIFwic3ltYm9sXCI6IFwiU0xVXCIsXG4gICAgXCJuYW1lXCI6IFwiU0lMVUJJVU1cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dpdGh1Yi5jb20vU2lsdWJpdW1Qcm9qZWN0L3NsdWNvcmVcIlxuICB9LFxuICBcIjYwNjBcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2MDYwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAxN2FjXCIsXG4gICAgXCJzeW1ib2xcIjogXCJHT1wiLFxuICAgIFwibmFtZVwiOiBcIkdvQ2hhaW4gR09cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dvY2hhaW4uaW9cIlxuICB9LFxuICBcIjYxNzRcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2MTc0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAxODFlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJNT0lcIixcbiAgICBcIm5hbWVcIjogXCJNeSBPd24gSW50ZXJuZXRcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL21vaS1pZC5saWZlXCJcbiAgfSxcbiAgXCI2NjY2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjY2NlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMWEwYVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQlBBXCIsXG4gICAgXCJuYW1lXCI6IFwiQml0Y29pbiBQaXp6YVwiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly9wLnRvcFwiXG4gIH0sXG4gIFwiNjY4OFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY2ODhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDFhMjBcIixcbiAgICBcInN5bWJvbFwiOiBcIlNBRkVcIixcbiAgICBcIm5hbWVcIjogXCJTQUZFXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL3d3dy5hbndhbmcuY29tXCJcbiAgfSxcbiAgXCI2OTY5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjk2OVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMWIzOVwiLFxuICAgIFwic3ltYm9sXCI6IFwiUk9HRVJcIixcbiAgICBcIm5hbWVcIjogXCJUaGVIb2x5cm9nZXJDb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL1RoZUhvbHlSb2dlci9UaGVIb2x5Um9nZXJDb2luXCJcbiAgfSxcbiAgXCI3MDkxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzA5MVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMWJiM1wiLFxuICAgIFwic3ltYm9sXCI6IFwiVE9QTFwiLFxuICAgIFwibmFtZVwiOiBcIlRvcGxcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy50b3BsLmNvXCJcbiAgfSxcbiAgXCI3Nzc3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzc3N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMWU2MVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQlRWXCIsXG4gICAgXCJuYW1lXCI6IFwiQml0dm90ZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmJpdHZvdGUub25lXCJcbiAgfSxcbiAgXCI4MDAwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiODAwMFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMWY0MFwiLFxuICAgIFwic3ltYm9sXCI6IFwiU0tZXCIsXG4gICAgXCJuYW1lXCI6IFwiU2t5Y29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LnNreWNvaW4ubmV0XCJcbiAgfSxcbiAgXCI4MDgwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiODA4MFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMWY5MFwiLFxuICAgIFwic3ltYm9sXCI6IFwiXCIsXG4gICAgXCJuYW1lXCI6IFwiRFNSVlwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmRzcnZsYWJzLmNvbVwiXG4gIH0sXG4gIFwiODE5MlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjgxOTJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDIwMDBcIixcbiAgICBcInN5bWJvbFwiOiBcIlBBQ1wiLFxuICAgIFwibmFtZVwiOiBcInBhY3Byb3RvY29sXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cucGFjcHJvdG9jb2wuY29tXCJcbiAgfSxcbiAgXCI4MjE3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiODIxN1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMjAxOVwiLFxuICAgIFwic3ltYm9sXCI6IFwiS0xBWVwiLFxuICAgIFwibmFtZVwiOiBcIktMQVlcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5rbGF5dG4uY29tXCJcbiAgfSxcbiAgXCI4MzM5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiODMzOVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMjA5M1wiLFxuICAgIFwic3ltYm9sXCI6IFwiQlRRXCIsXG4gICAgXCJuYW1lXCI6IFwiQml0Y29pblF1YXJrXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuYml0Y29pbnF1YXJrLm9yZ1wiXG4gIH0sXG4gIFwiODQ0NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjg0NDRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDIwZmNcIixcbiAgICBcInN5bWJvbFwiOiBcIlhDSFwiLFxuICAgIFwibmFtZVwiOiBcIkNoaWFcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5jaGlhLm5ldFwiXG4gIH0sXG4gIFwiODUyMFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjg1MjBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDIxNDhcIixcbiAgICBcInN5bWJvbFwiOiBcIi0tLVwiLFxuICAgIFwibmFtZVwiOiBcInJlc2VydmVkXCJcbiAgfSxcbiAgXCI4ODg4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiODg4OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMjJiOFwiLFxuICAgIFwic3ltYm9sXCI6IFwiU0JUQ1wiLFxuICAgIFwibmFtZVwiOiBcIlN1cGVyIEJpdGNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5zdXBlcmJ0Yy5vcmdcIlxuICB9LFxuICBcIjg5NjRcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4OTY0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAyMzA0XCIsXG4gICAgXCJzeW1ib2xcIjogXCJOVUxTXCIsXG4gICAgXCJuYW1lXCI6IFwiTlVMU1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbnVscy5pb1wiXG4gIH0sXG4gIFwiODk5OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjg5OTlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDIzMjdcIixcbiAgICBcInN5bWJvbFwiOiBcIkJUUFwiLFxuICAgIFwibmFtZVwiOiBcIkJpdGNvaW4gUGF5XCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL3d3dy5idGNlYXN5cGF5LmNvbVwiXG4gIH0sXG4gIFwiOTAwMFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjkwMDBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDIzMjhcIixcbiAgICBcInN5bWJvbFwiOiBcIkFWQVhcIixcbiAgICBcIm5hbWVcIjogXCJBdmFsYW5jaGVcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5hdmF4Lm5ldHdvcmtcIlxuICB9LFxuICBcIjkwMDFcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5MDAxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAyMzI5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJBUkJcIixcbiAgICBcIm5hbWVcIjogXCJBcmJpdHJ1bVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYXJiaXRydW0uaW9cIlxuICB9LFxuICBcIjkwMDJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5MDAyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAyMzJhXCIsXG4gICAgXCJzeW1ib2xcIjogXCJCT0JBXCIsXG4gICAgXCJuYW1lXCI6IFwiQm9iYVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYm9iYS5uZXR3b3JrXCJcbiAgfSxcbiAgXCI5MDAzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTAwM1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMjMyYlwiLFxuICAgIFwic3ltYm9sXCI6IFwiTE9PUFwiLFxuICAgIFwibmFtZVwiOiBcIkxvb3ByaW5nXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9sb29wcmluZy5vcmdcIlxuICB9LFxuICBcIjkwMDRcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5MDA0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAyMzJjXCIsXG4gICAgXCJzeW1ib2xcIjogXCJTVEFSS1wiLFxuICAgIFwibmFtZVwiOiBcIlN0YXJrd2FyZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vc3Rhcmt3YXJlLmNvXCJcbiAgfSxcbiAgXCI5MDA1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTAwNVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMjMyZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiQVZBWENcIixcbiAgICBcIm5hbWVcIjogXCJBdmFsYW5jaGUgQy1DaGFpblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmF2YXgubmV0d29ya1wiXG4gIH0sXG4gIFwiOTAwNlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjkwMDZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDIzMmVcIixcbiAgICBcInN5bWJvbFwiOiBcIkJTQ1wiLFxuICAgIFwibmFtZVwiOiBcIkJpbmFuY2UgU21hcnQgQ2hhaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5iaW5hbmNlLm9yZy9lbi9zbWFydENoYWluXCJcbiAgfSxcbiAgXCI5Nzk3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTc5N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMjY0NVwiLFxuICAgIFwic3ltYm9sXCI6IFwiTlJHXCIsXG4gICAgXCJuYW1lXCI6IFwiRW5lcmdpXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuZW5lcmdpLndvcmxkXCJcbiAgfSxcbiAgXCI5ODg4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTg4OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMjZhMFwiLFxuICAgIFwic3ltYm9sXCI6IFwiQlRGXCIsXG4gICAgXCJuYW1lXCI6IFwiQml0Y29pbiBGYWl0aFwiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly9iaXRjb2luZmFpdGgub3JnXCJcbiAgfSxcbiAgXCI5OTk5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTk5OVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMjcwZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiR09EXCIsXG4gICAgXCJuYW1lXCI6IFwiQml0Y29pbiBHb2RcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5iaXRjb2luZ29kLm9yZ1wiXG4gIH0sXG4gIFwiMTAwMDBcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMDAwMFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMjcxMFwiLFxuICAgIFwic3ltYm9sXCI6IFwiRk9cIixcbiAgICBcIm5hbWVcIjogXCJGSUJPU1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZmlib3MuaW9cIlxuICB9LFxuICBcIjEwMjI2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTAyMjZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDI3ZjJcIixcbiAgICBcInN5bWJvbFwiOiBcIlJUTVwiLFxuICAgIFwibmFtZVwiOiBcIlJhcHRvcmV1bVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vcmFwdG9yZXVtLmNvbVwiXG4gIH0sXG4gIFwiMTAyOTFcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMDI5MVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMjgzM1wiLFxuICAgIFwic3ltYm9sXCI6IFwiWFJDXCIsXG4gICAgXCJuYW1lXCI6IFwiWFJob2RpdW1cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy54cmhvZGl1bS5vcmdcIlxuICB9LFxuICBcIjEwNjA1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTA2MDVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDI5NmRcIixcbiAgICBcInN5bWJvbFwiOiBcIlhQSVwiLFxuICAgIFwibmFtZVwiOiBcIkxvdHVzXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9naXZlbG90dXMub3JnXCJcbiAgfSxcbiAgXCIxMTExMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjExMTExXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAyYjY3XCIsXG4gICAgXCJzeW1ib2xcIjogXCJFU1NcIixcbiAgICBcIm5hbWVcIjogXCJFc3NlbnRpYSBPbmVcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2Vzc2VudGlhLm9uZVwiXG4gIH0sXG4gIFwiMTIzNDVcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMjM0NVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMzAzOVwiLFxuICAgIFwic3ltYm9sXCI6IFwiSVBPU1wiLFxuICAgIFwibmFtZVwiOiBcIklQT1NcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2lwb3NsYWIuY29tXCJcbiAgfSxcbiAgXCIxMjU4NlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjEyNTg2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAzMTJhXCIsXG4gICAgXCJzeW1ib2xcIjogXCJNSU5BXCIsXG4gICAgXCJuYW1lXCI6IFwiTWluYVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbWluYXByb3RvY29sLmNvbVwiXG4gIH0sXG4gIFwiMTMxMDdcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMzEwN1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwMzMzM1wiLFxuICAgIFwic3ltYm9sXCI6IFwiQlRZXCIsXG4gICAgXCJuYW1lXCI6IFwiQml0WXVhblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmJpdHl1YW4uY29tXCJcbiAgfSxcbiAgXCIxMzEwOFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjEzMTA4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAzMzM0XCIsXG4gICAgXCJzeW1ib2xcIjogXCJZQ0NcIixcbiAgICBcIm5hbWVcIjogXCJZdWFuIENoYWluIENvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy55dWFuLm9yZ1wiXG4gIH0sXG4gIFwiMTU4NDVcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxNTg0NVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwM2RlNVwiLFxuICAgIFwic3ltYm9sXCI6IFwiU0RHT1wiLFxuICAgIFwibmFtZVwiOiBcIlNhbkRlR29cIixcbiAgICBcImxpbmtcIjogXCJodHRwOi8vd3d3LnNhbmRlZ28ubmV0XCJcbiAgfSxcbiAgXCIxNjE4MVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE2MTgxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDAzZjM1XCIsXG4gICAgXCJzeW1ib2xcIjogXCJYVFhcIixcbiAgICBcIm5hbWVcIjogXCJUb3RlbSBMaXZlIE5ldHdvcmtcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3RvdGVtLmxpdmVcIlxuICB9LFxuICBcIjE2NzU0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTY3NTRcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDQxNzJcIixcbiAgICBcInN5bWJvbFwiOiBcIkFSRFJcIixcbiAgICBcIm5hbWVcIjogXCJBcmRvclwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LmplbHVyaWRhLmNvbVwiXG4gIH0sXG4gIFwiMTgwMDBcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxODAwMFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwNDY1MFwiLFxuICAgIFwic3ltYm9sXCI6IFwiTVRSXCIsXG4gICAgXCJuYW1lXCI6IFwiTWV0ZXJcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL01ldGVyLmlvXCJcbiAgfSxcbiAgXCIxOTE2NVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE5MTY1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDA0YWRkXCIsXG4gICAgXCJzeW1ib2xcIjogXCJTQUZFXCIsXG4gICAgXCJuYW1lXCI6IFwiU2FmZWNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5zYWZlY29pbi5vcmdcIlxuICB9LFxuICBcIjE5MTY3XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTkxNjdcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDRhZGZcIixcbiAgICBcInN5bWJvbFwiOiBcIkZMVVhcIixcbiAgICBcIm5hbWVcIjogXCJGbHV4XCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9ydW5vbmZsdXguaW9cIlxuICB9LFxuICBcIjE5MTY5XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTkxNjlcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDRhZTFcIixcbiAgICBcInN5bWJvbFwiOiBcIlJJVE9cIixcbiAgICBcIm5hbWVcIjogXCJSaXRvY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd3d3LnJpdG9jb2luLm9yZ1wiXG4gIH0sXG4gIFwiMjAwMzZcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyMDAzNlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwNGU0NFwiLFxuICAgIFwic3ltYm9sXCI6IFwiWE5EXCIsXG4gICAgXCJuYW1lXCI6IFwibmRhdVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbmRhdS5pb1wiXG4gIH0sXG4gIFwiMjI1MDRcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyMjUwNFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwNTdlOFwiLFxuICAgIFwic3ltYm9sXCI6IFwiUFdSXCIsXG4gICAgXCJuYW1lXCI6IFwiUFdSY29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9QbGFpbmtvaW4vUFdSY29pblwiXG4gIH0sXG4gIFwiMjUyNTJcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyNTI1MlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwNjJhNFwiLFxuICAgIFwic3ltYm9sXCI6IFwiQkVMTFwiLFxuICAgIFwibmFtZVwiOiBcIkJlbGxjb2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9iZWxsY29pbi53ZWI0dS5qcFwiXG4gIH0sXG4gIFwiMjU3MThcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyNTcxOFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwNjQ3NlwiLFxuICAgIFwic3ltYm9sXCI6IFwiQ0hYXCIsXG4gICAgXCJuYW1lXCI6IFwiT3duXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93YWxsZXQud2Vvd24uY29tXCJcbiAgfSxcbiAgXCIzMTEwMlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjMxMTAyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDA3OTdlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJFU05cIixcbiAgICBcIm5hbWVcIjogXCJFdGhlclNvY2lhbCBOZXR3b3JrXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9ldGhlcnNvY2lhbC5uZXR3b3JrXCJcbiAgfSxcbiAgXCIzMTMzN1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjMxMzM3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDA3YTY5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJcIixcbiAgICBcIm5hbWVcIjogXCJUaGVQb3dlci5pb1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vdGhlcG93ZXIuaW9cIlxuICB9LFxuICBcIjMzNDE2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzM0MTZcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDgyODhcIixcbiAgICBcInN5bWJvbFwiOiBcIlRFT1wiLFxuICAgIFwibmFtZVwiOiBcIlRydXN0IEV0aCByZU9yaWdpblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vdGFvLmZvdW5kYXRpb25cIlxuICB9LFxuICBcIjMzODc4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzM4NzhcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDg0NTZcIixcbiAgICBcInN5bWJvbFwiOiBcIkJUQ1NcIixcbiAgICBcIm5hbWVcIjogXCJCaXRjb2luIFN0YWtlXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL3d3dy5idGNzY29pbi5jb21cIlxuICB9LFxuICBcIjM0OTUyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzQ5NTJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMDg4ODhcIixcbiAgICBcInN5bWJvbFwiOiBcIkJUVFwiLFxuICAgIFwibmFtZVwiOiBcIkJ5dGVUcmFkZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYnl0ZXRyYWRlLmlvXCJcbiAgfSxcbiAgXCIzNzk5MlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM3OTkyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDA5NDY4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJGWFRDXCIsXG4gICAgXCJuYW1lXCI6IFwiRml4ZWRUcmFkZUNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2ZpeGVkdHJhZGVjb2luLm9yZ1wiXG4gIH0sXG4gIFwiMzkzMjFcIjoge1xuICAgIFwiaW5kZXhcIjogXCIzOTMyMVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwOTk5OVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQU1BXCIsXG4gICAgXCJuYW1lXCI6IFwiQW1hYmlnXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9hbWFiaWcuY29tXCJcbiAgfSxcbiAgXCI0MzAyOFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQzMDI4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDBhODE0XCIsXG4gICAgXCJzeW1ib2xcIjogXCJBWElWXCIsXG4gICAgXCJuYW1lXCI6IFwiQVhJVlwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vcGhvcmUuaW9cIlxuICB9LFxuICBcIjQ5MjYyXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDkyNjJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMGMwNmVcIixcbiAgICBcInN5bWJvbFwiOiBcIkVWRVwiLFxuICAgIFwibmFtZVwiOiBcImV2YW4ubmV0d29ya1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZXZhbi5uZXR3b3JrXCJcbiAgfSxcbiAgXCI0OTM0NFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjQ5MzQ0XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDBjMGMwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJTVEFTSFwiLFxuICAgIFwibmFtZVwiOiBcIlNUQVNIXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9zdGFzaHBheS5pb1wiXG4gIH0sXG4gIFwiNTI3NTJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1Mjc1MlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAwY2UxMFwiLFxuICAgIFwic3ltYm9sXCI6IFwiQ0VMT1wiLFxuICAgIFwibmFtZVwiOiBcIkNlbG9cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2NlbG8ub3JnXCJcbiAgfSxcbiAgXCI2NTUzNlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY1NTM2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDEwMDAwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJLRVRIXCIsXG4gICAgXCJuYW1lXCI6IFwiS3J5cHRvbiBXb3JsZFwiLFxuICAgIFwibGlua1wiOiBcImh0dHA6L2tyeXB0b24ud29ybGRcIlxuICB9LFxuICBcIjY5NDIwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjk0MjBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMTBmMmNcIixcbiAgICBcInN5bWJvbFwiOiBcIkdSTENcIixcbiAgICBcIm5hbWVcIjogXCJHYXJsaWNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dhcmxpY29pbi5pb1wiXG4gIH0sXG4gIFwiNzAwMDdcIjoge1xuICAgIFwiaW5kZXhcIjogXCI3MDAwN1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAxMTE3N1wiLFxuICAgIFwic3ltYm9sXCI6IFwiR1dMXCIsXG4gICAgXCJuYW1lXCI6IFwiR2V3ZWxcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dld2VsLmlvXCJcbiAgfSxcbiAgXCI3Nzc3N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc3Nzc3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDEyZmQxXCIsXG4gICAgXCJzeW1ib2xcIjogXCJaWU5cIixcbiAgICBcIm5hbWVcIjogXCJXZXRoaW9cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3dldGhpby5pb1wiXG4gIH0sXG4gIFwiODg4ODhcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4ODg4OFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAxNWIzOFwiLFxuICAgIFwic3ltYm9sXCI6IFwiUllPXCIsXG4gICAgXCJuYW1lXCI6IFwiYzBiYW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5jMGJhbi5jb1wiXG4gIH0sXG4gIFwiOTk5OTlcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5OTk5OVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAxODY5ZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiV0lDQ1wiLFxuICAgIFwibmFtZVwiOiBcIldheWtpY2hhaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwOi8vd3d3LndheWtpY2hhaW4uY29tXCJcbiAgfSxcbiAgXCIxMDA1MDBcIjoge1xuICAgIFwiaW5kZXhcIjogXCIxMDA1MDBcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMTg4OTRcIixcbiAgICBcInN5bWJvbFwiOiBcIkhPTUVcIixcbiAgICBcIm5hbWVcIjogXCJIb21lQ29pblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vaG9tZWNvaW4ucnVcIlxuICB9LFxuICBcIjEwMTAxMFwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjEwMTAxMFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAxOGE5MlwiLFxuICAgIFwic3ltYm9sXCI6IFwiU1RDXCIsXG4gICAgXCJuYW1lXCI6IFwiU3RhcmNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3N0YXJjb2luLm9yZ1wiXG4gIH0sXG4gIFwiMTA1MTA1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTA1MTA1XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDE5YTkxXCIsXG4gICAgXCJzeW1ib2xcIjogXCJTVFJBWFwiLFxuICAgIFwibmFtZVwiOiBcIlN0cmF4XCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL3d3dy5zdHJhdGlzcGxhdGZvcm0uY29tXCJcbiAgfSxcbiAgXCIyMDA2MjVcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyMDA2MjVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMzBmYjFcIixcbiAgICBcInN5bWJvbFwiOiBcIkFLQVwiLFxuICAgIFwibmFtZVwiOiBcIkFrcm9tYVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vYWtyb21hLmlvXCJcbiAgfSxcbiAgXCIyMDA2NjVcIjoge1xuICAgIFwiaW5kZXhcIjogXCIyMDA2NjVcIixcbiAgICBcImhleFwiOiBcIjB4ODAwMTEwMDBcIixcbiAgICBcInN5bWJvbFwiOiBcIkdFTk9NXCIsXG4gICAgXCJuYW1lXCI6IFwiR0VOT01cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dlbm9tLnRlY2hcIlxuICB9LFxuICBcIjI0NjUyOVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjI0NjUyOVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDAzYzMwMVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQVRTXCIsXG4gICAgXCJuYW1lXCI6IFwiQVJUSVMgc2lnbWExXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9hcnRpcy5lY29cIlxuICB9LFxuICBcIjMxNDE1OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjMxNDE1OVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDA0Y2IyZlwiLFxuICAgIFwic3ltYm9sXCI6IFwiUElcIixcbiAgICBcIm5hbWVcIjogXCJQaSBOZXR3b3JrXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL21pbmVwaS5jb21cIlxuICB9LFxuICBcIjMzMzMzMlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjMzMzMzMlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDA1MTYxNFwiLFxuICAgIFwic3ltYm9sXCI6IFwiVkFMVUVcIixcbiAgICBcIm5hbWVcIjogXCJWYWx1ZSBDaGFpblwiXG4gIH0sXG4gIFwiMzMzMzMzXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMzMzMzMzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwMDUxNjE1XCIsXG4gICAgXCJzeW1ib2xcIjogXCIzMzMzXCIsXG4gICAgXCJuYW1lXCI6IFwiUGkgVmFsdWUgQ29uc2Vuc3VzXCJcbiAgfSxcbiAgXCI0MjQyNDJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI0MjQyNDJcIixcbiAgICBcImhleFwiOiBcIjB4ODAwNjc5MzJcIixcbiAgICBcInN5bWJvbFwiOiBcIlg0MlwiLFxuICAgIFwibmFtZVwiOiBcIng0MlwiLFxuICAgIFwibGlua1wiOiBcImh0dHA6Ly93d3cueDQyLnRlY2hcIlxuICB9LFxuICBcIjY2NjY2NlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjY2NjY2NlwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDBhMmMyYVwiLFxuICAgIFwic3ltYm9sXCI6IFwiVklURVwiLFxuICAgIFwibmFtZVwiOiBcIlZpdGVcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy52aXRlLm9yZ1wiXG4gIH0sXG4gIFwiODg4ODg4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiODg4ODg4XCIsXG4gICAgXCJoZXhcIjogXCIweDgwMGQ5MDM4XCIsXG4gICAgXCJzeW1ib2xcIjogXCJTRUFcIixcbiAgICBcIm5hbWVcIjogXCJTZWNvbmQgRXhjaGFuZ2UgQWxsaWFuY2VcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5zZWFpby5jY1wiXG4gIH0sXG4gIFwiMTE3MTMzN1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjExNzEzMzdcIixcbiAgICBcImhleFwiOiBcIjB4ODAxMWRmODlcIixcbiAgICBcInN5bWJvbFwiOiBcIklMVFwiLFxuICAgIFwibmFtZVwiOiBcImlPbGl0ZVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vaW9saXRlLmlvXCJcbiAgfSxcbiAgXCIxMzEzMTE0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTMxMzExNFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDE0MDk1YVwiLFxuICAgIFwic3ltYm9sXCI6IFwiRVRIT1wiLFxuICAgIFwibmFtZVwiOiBcIkV0aGVyLTFcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5ldGhlcjEub3JnXCJcbiAgfSxcbiAgXCIxMzEzNTAwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTMxMzUwMFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDE0MGFkY1wiLFxuICAgIFwic3ltYm9sXCI6IFwiWEVST1wiLFxuICAgIFwibmFtZVwiOiBcIlhlcm9tXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cueGVyb20ub3JnXCJcbiAgfSxcbiAgXCIxNzEyMTQ0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiMTcxMjE0NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDFhMjAxMFwiLFxuICAgIFwic3ltYm9sXCI6IFwiTEFYXCIsXG4gICAgXCJuYW1lXCI6IFwiTEFQT1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vbGFwby5pb1wiXG4gIH0sXG4gIFwiMzkyNDAxMVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjM5MjQwMTFcIixcbiAgICBcImhleFwiOiBcIjB4ODAzYmUwMmJcIixcbiAgICBcInN5bWJvbFwiOiBcIkVQS1wiLFxuICAgIFwibmFtZVwiOiBcIkVQSUsgUHJvdG9jb2xcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5lcGlrLXByb3RvY29sLmlvXCJcbiAgfSxcbiAgXCI0NzQxNDQ0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNDc0MTQ0NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDQ4NTk0NFwiLFxuICAgIFwic3ltYm9sXCI6IFwiSFlEXCIsXG4gICAgXCJuYW1lXCI6IFwiSHlkcmEgVG9rZW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2lvcC5nbG9iYWwvaHlkcmEtdG9rZW5cIlxuICB9LFxuICBcIjUyNDkzNTNcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1MjQ5MzUzXCIsXG4gICAgXCJoZXhcIjogXCIweDgwNTAxOTQ5XCIsXG4gICAgXCJzeW1ib2xcIjogXCJCQ09cIixcbiAgICBcIm5hbWVcIjogXCJCaXRjb2luT3JlXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cDovL2JpdGNvaW5vcmUub3JnXCJcbiAgfSxcbiAgXCI1MjQ5MzU0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTI0OTM1NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDUwMTk0YVwiLFxuICAgIFwic3ltYm9sXCI6IFwiQkhEXCIsXG4gICAgXCJuYW1lXCI6IFwiQml0Y29pbkhEXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9idGNoZC5vcmdcIlxuICB9LFxuICBcIjUyNjQ0NjJcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1MjY0NDYyXCIsXG4gICAgXCJoZXhcIjogXCIweDgwNTA1NDRlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJQVE5cIixcbiAgICBcIm5hbWVcIjogXCJQYWxsZXRPbmVcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3BhbGxldC5vbmVcIlxuICB9LFxuICBcIjU3MTgzNTBcIjoge1xuICAgIFwiaW5kZXhcIjogXCI1NzE4MzUwXCIsXG4gICAgXCJoZXhcIjogXCIweDgwNTc0MTRlXCIsXG4gICAgXCJzeW1ib2xcIjogXCJXQU5cIixcbiAgICBcIm5hbWVcIjogXCJXYW5jaGFpblwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd2FuY2hhaW4ub3JnXCJcbiAgfSxcbiAgXCI1NzQxNTY0XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNTc0MTU2NFwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDU3OWJmY1wiLFxuICAgIFwic3ltYm9sXCI6IFwiV0FWRVNcIixcbiAgICBcIm5hbWVcIjogXCJXYXZlc1wiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd2F2ZXNwbGF0Zm9ybS5jb21cIlxuICB9LFxuICBcIjY1MTczNTdcIjoge1xuICAgIFwiaW5kZXhcIjogXCI2NTE3MzU3XCIsXG4gICAgXCJoZXhcIjogXCIweDgwNjM3MjZkXCIsXG4gICAgXCJzeW1ib2xcIjogXCJDUk1cIixcbiAgICBcIm5hbWVcIjogXCJDcmVhbWNvaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2V4cGxvcmVyLmNyZWFtY29pbi5jb20vXCJcbiAgfSxcbiAgXCI3NTYyNjA1XCI6IHtcbiAgICBcImluZGV4XCI6IFwiNzU2MjYwNVwiLFxuICAgIFwiaGV4XCI6IFwiMHg4MDczNjU2ZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiU0VNXCIsXG4gICAgXCJuYW1lXCI6IFwiU2VtdXhcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3NlbXV4Lm9yZ1wiXG4gIH0sXG4gIFwiNzU2NzczNlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc1Njc3MzZcIixcbiAgICBcImhleFwiOiBcIjB4ODA3Mzc5NzhcIixcbiAgICBcInN5bWJvbFwiOiBcIklPTlwiLFxuICAgIFwibmFtZVwiOiBcIklPTlwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vaW9ub215LmNvbVwiXG4gIH0sXG4gIFwiNzc3Nzc3N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc3Nzc3NzdcIixcbiAgICBcImhleFwiOiBcIjB4ODA3NmFkZjFcIixcbiAgICBcInN5bWJvbFwiOiBcIkZDVFwiLFxuICAgIFwibmFtZVwiOiBcIkZpcm1hQ2hhaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL3d3dy5maXJtYWNoYWluLm9yZ1wiXG4gIH0sXG4gIFwiNzgyNTI2NlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc4MjUyNjZcIixcbiAgICBcImhleFwiOiBcIjB4ODA3NzY3NzJcIixcbiAgICBcInN5bWJvbFwiOiBcIldHUlwiLFxuICAgIFwibmFtZVwiOiBcIldHUlwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vd2FnZXJyLmNvbVwiXG4gIH0sXG4gIFwiNzgyNTI2N1wiOiB7XG4gICAgXCJpbmRleFwiOiBcIjc4MjUyNjdcIixcbiAgICBcImhleFwiOiBcIjB4ODA3NzY3NzNcIixcbiAgICBcInN5bWJvbFwiOiBcIk9CU1JcIixcbiAgICBcIm5hbWVcIjogXCJPQlNlcnZlclwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vb2Jzci5vcmdcIlxuICB9LFxuICBcIjgxNjMyNzFcIjoge1xuICAgIFwiaW5kZXhcIjogXCI4MTYzMjcxXCIsXG4gICAgXCJoZXhcIjogXCIweDgwN2M4ZmM3XCIsXG4gICAgXCJzeW1ib2xcIjogXCJBRlNcIixcbiAgICBcIm5hbWVcIjogXCJBTkZTXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuYW5mcy5uZXR3b3JrXCJcbiAgfSxcbiAgXCIxNTExODk3NlwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjE1MTE4OTc2XCIsXG4gICAgXCJoZXhcIjogXCIweDgwZTZiMjgwXCIsXG4gICAgXCJzeW1ib2xcIjogXCJYRFNcIixcbiAgICBcIm5hbWVcIjogXCJYRFNcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2dpdGh1Yi5jb20veGRzLWRlY2VudHJhbGlzZWRcIlxuICB9LFxuICBcIjYxNzE3NTYxXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjE3MTc1NjFcIixcbiAgICBcImhleFwiOiBcIjB4ODNhZGJjMzlcIixcbiAgICBcInN5bWJvbFwiOiBcIkFRVUFcIixcbiAgICBcIm5hbWVcIjogXCJBcXVhY2hhaW5cIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2FxdWFjaGFpbi5naXRodWIuaW9cIlxuICB9LFxuICBcIjg4ODg4ODg4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiODg4ODg4ODhcIixcbiAgICBcImhleFwiOiBcIjB4ODU0YzU2MzhcIixcbiAgICBcInN5bWJvbFwiOiBcIkhBVENIXCIsXG4gICAgXCJuYW1lXCI6IFwiSGF0Y2hcIixcbiAgICBcImxpbmtcIjogXCJodHRwczovL2hhdGNoLmdhXCJcbiAgfSxcbiAgXCI5MTkyNzAwOVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjkxOTI3MDA5XCIsXG4gICAgXCJoZXhcIjogXCIweDg1N2FiMWUxXCIsXG4gICAgXCJzeW1ib2xcIjogXCJrVVNEXCIsXG4gICAgXCJuYW1lXCI6IFwia1VTRFwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8va293YWxhLnRlY2hcIlxuICB9LFxuICBcIjk5OTk5OTk2XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTk5OTk5OTZcIixcbiAgICBcImhleFwiOiBcIjB4ODVmNWUwZmNcIixcbiAgICBcInN5bWJvbFwiOiBcIkdFTlNcIixcbiAgICBcIm5hbWVcIjogXCJHRU5TXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9nZW5zaGlyby5lcXVpbGlicml1bS5pb1wiXG4gIH0sXG4gIFwiOTk5OTk5OTdcIjoge1xuICAgIFwiaW5kZXhcIjogXCI5OTk5OTk5N1wiLFxuICAgIFwiaGV4XCI6IFwiMHg4NWY1ZTBmZFwiLFxuICAgIFwic3ltYm9sXCI6IFwiRVFcIixcbiAgICBcIm5hbWVcIjogXCJFUVwiLFxuICAgIFwibGlua1wiOiBcImh0dHBzOi8vZXF1aWxpYnJpdW0uaW9cIlxuICB9LFxuICBcIjk5OTk5OTk4XCI6IHtcbiAgICBcImluZGV4XCI6IFwiOTk5OTk5OThcIixcbiAgICBcImhleFwiOiBcIjB4ODVmNWUwZmVcIixcbiAgICBcInN5bWJvbFwiOiBcIkZMVUlEXCIsXG4gICAgXCJuYW1lXCI6IFwiRmx1aWQgQ2hhaW5zXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cuZmx1aWRjaGFpbnMuY29tXCJcbiAgfSxcbiAgXCI5OTk5OTk5OVwiOiB7XG4gICAgXCJpbmRleFwiOiBcIjk5OTk5OTk5XCIsXG4gICAgXCJoZXhcIjogXCIweDg1ZjVlMGZmXCIsXG4gICAgXCJzeW1ib2xcIjogXCJRS0NcIixcbiAgICBcIm5hbWVcIjogXCJRdWFya0NoYWluXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly93d3cucXVhcmtjaGFpbi5pb1wiXG4gIH0sXG4gIFwiNjA4NTg5MzgwXCI6IHtcbiAgICBcImluZGV4XCI6IFwiNjA4NTg5MzgwXCIsXG4gICAgXCJoZXhcIjogXCIweGE0NDY1NjQ0XCIsXG4gICAgXCJzeW1ib2xcIjogXCJGVkRDXCIsXG4gICAgXCJuYW1lXCI6IFwiRm9ydW1Db2luXCIsXG4gICAgXCJsaW5rXCI6IFwiaHR0cHM6Ly9mdmQubmxcIlxuICB9XG59XG4iLCJleHBvcnQgY29uc3QgQUxFUlRfVFlQRVMgPSB7XG4gIHVuY29ubmVjdGVkQWNjb3VudDogJ3VuY29ubmVjdGVkQWNjb3VudCcsXG4gIHdlYjNTaGltVXNhZ2U6ICd3ZWIzU2hpbVVzYWdlJyxcbiAgaW52YWxpZEN1c3RvbU5ldHdvcms6ICdpbnZhbGlkQ3VzdG9tTmV0d29yaycsXG59O1xuXG4vKipcbiAqIEFsZXJ0cyB0aGF0IGNhbiBiZSBlbmFibGVkIG9yIGRpc2FibGVkIGJ5IHRoZSB1c2VyLlxuICovXG5leHBvcnQgY29uc3QgVE9HR0xFQUJMRV9BTEVSVF9UWVBFUyA9IFtcbiAgQUxFUlRfVFlQRVMudW5jb25uZWN0ZWRBY2NvdW50LFxuICBBTEVSVF9UWVBFUy53ZWIzU2hpbVVzYWdlLFxuXTtcblxuZXhwb3J0IGNvbnN0IFdFQjNfU0hJTV9VU0FHRV9BTEVSVF9TVEFURVMgPSB7XG4gIFJFQ09SREVEOiAxLFxuICBESVNNSVNTRUQ6IDIsXG59O1xuIiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5QdWJOdWI9dCgpOmUuUHViTnViPXQoKX0od2luZG93LGZ1bmN0aW9uKCl7cmV0dXJuIHI9e30saS5tPW49W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9e319LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9dm9pZCAwO3QuZGVmYXVsdD17UE5UaW1lT3BlcmF0aW9uOlwiUE5UaW1lT3BlcmF0aW9uXCIsUE5IaXN0b3J5T3BlcmF0aW9uOlwiUE5IaXN0b3J5T3BlcmF0aW9uXCIsUE5EZWxldGVNZXNzYWdlc09wZXJhdGlvbjpcIlBORGVsZXRlTWVzc2FnZXNPcGVyYXRpb25cIixQTkZldGNoTWVzc2FnZXNPcGVyYXRpb246XCJQTkZldGNoTWVzc2FnZXNPcGVyYXRpb25cIixQTk1lc3NhZ2VDb3VudHM6XCJQTk1lc3NhZ2VDb3VudHNPcGVyYXRpb25cIixQTlN1YnNjcmliZU9wZXJhdGlvbjpcIlBOU3Vic2NyaWJlT3BlcmF0aW9uXCIsUE5VbnN1YnNjcmliZU9wZXJhdGlvbjpcIlBOVW5zdWJzY3JpYmVPcGVyYXRpb25cIixQTlB1Ymxpc2hPcGVyYXRpb246XCJQTlB1Ymxpc2hPcGVyYXRpb25cIixQTlNpZ25hbE9wZXJhdGlvbjpcIlBOU2lnbmFsT3BlcmF0aW9uXCIsUE5BZGRNZXNzYWdlQWN0aW9uT3BlcmF0aW9uOlwiUE5BZGRBY3Rpb25PcGVyYXRpb25cIixQTlJlbW92ZU1lc3NhZ2VBY3Rpb25PcGVyYXRpb246XCJQTlJlbW92ZU1lc3NhZ2VBY3Rpb25PcGVyYXRpb25cIixQTkdldE1lc3NhZ2VBY3Rpb25zT3BlcmF0aW9uOlwiUE5HZXRNZXNzYWdlQWN0aW9uc09wZXJhdGlvblwiLFBOQ3JlYXRlVXNlck9wZXJhdGlvbjpcIlBOQ3JlYXRlVXNlck9wZXJhdGlvblwiLFBOVXBkYXRlVXNlck9wZXJhdGlvbjpcIlBOVXBkYXRlVXNlck9wZXJhdGlvblwiLFBORGVsZXRlVXNlck9wZXJhdGlvbjpcIlBORGVsZXRlVXNlck9wZXJhdGlvblwiLFBOR2V0VXNlck9wZXJhdGlvbjpcIlBOR2V0VXNlcnNPcGVyYXRpb25cIixQTkdldFVzZXJzT3BlcmF0aW9uOlwiUE5HZXRVc2Vyc09wZXJhdGlvblwiLFBOQ3JlYXRlU3BhY2VPcGVyYXRpb246XCJQTkNyZWF0ZVNwYWNlT3BlcmF0aW9uXCIsUE5VcGRhdGVTcGFjZU9wZXJhdGlvbjpcIlBOVXBkYXRlU3BhY2VPcGVyYXRpb25cIixQTkRlbGV0ZVNwYWNlT3BlcmF0aW9uOlwiUE5EZWxldGVTcGFjZU9wZXJhdGlvblwiLFBOR2V0U3BhY2VPcGVyYXRpb246XCJQTkdldFNwYWNlc09wZXJhdGlvblwiLFBOR2V0U3BhY2VzT3BlcmF0aW9uOlwiUE5HZXRTcGFjZXNPcGVyYXRpb25cIixQTkdldE1lbWJlcnNPcGVyYXRpb246XCJQTkdldE1lbWJlcnNPcGVyYXRpb25cIixQTlVwZGF0ZU1lbWJlcnNPcGVyYXRpb246XCJQTlVwZGF0ZU1lbWJlcnNPcGVyYXRpb25cIixQTkdldE1lbWJlcnNoaXBzT3BlcmF0aW9uOlwiUE5HZXRNZW1iZXJzaGlwc09wZXJhdGlvblwiLFBOVXBkYXRlTWVtYmVyc2hpcHNPcGVyYXRpb246XCJQTlVwZGF0ZU1lbWJlcnNoaXBzT3BlcmF0aW9uXCIsUE5QdXNoTm90aWZpY2F0aW9uRW5hYmxlZENoYW5uZWxzT3BlcmF0aW9uOlwiUE5QdXNoTm90aWZpY2F0aW9uRW5hYmxlZENoYW5uZWxzT3BlcmF0aW9uXCIsUE5SZW1vdmVBbGxQdXNoTm90aWZpY2F0aW9uc09wZXJhdGlvbjpcIlBOUmVtb3ZlQWxsUHVzaE5vdGlmaWNhdGlvbnNPcGVyYXRpb25cIixQTldoZXJlTm93T3BlcmF0aW9uOlwiUE5XaGVyZU5vd09wZXJhdGlvblwiLFBOU2V0U3RhdGVPcGVyYXRpb246XCJQTlNldFN0YXRlT3BlcmF0aW9uXCIsUE5IZXJlTm93T3BlcmF0aW9uOlwiUE5IZXJlTm93T3BlcmF0aW9uXCIsUE5HZXRTdGF0ZU9wZXJhdGlvbjpcIlBOR2V0U3RhdGVPcGVyYXRpb25cIixQTkhlYXJ0YmVhdE9wZXJhdGlvbjpcIlBOSGVhcnRiZWF0T3BlcmF0aW9uXCIsUE5DaGFubmVsR3JvdXBzT3BlcmF0aW9uOlwiUE5DaGFubmVsR3JvdXBzT3BlcmF0aW9uXCIsUE5SZW1vdmVHcm91cE9wZXJhdGlvbjpcIlBOUmVtb3ZlR3JvdXBPcGVyYXRpb25cIixQTkNoYW5uZWxzRm9yR3JvdXBPcGVyYXRpb246XCJQTkNoYW5uZWxzRm9yR3JvdXBPcGVyYXRpb25cIixQTkFkZENoYW5uZWxzVG9Hcm91cE9wZXJhdGlvbjpcIlBOQWRkQ2hhbm5lbHNUb0dyb3VwT3BlcmF0aW9uXCIsUE5SZW1vdmVDaGFubmVsc0Zyb21Hcm91cE9wZXJhdGlvbjpcIlBOUmVtb3ZlQ2hhbm5lbHNGcm9tR3JvdXBPcGVyYXRpb25cIixQTkFjY2Vzc01hbmFnZXJHcmFudDpcIlBOQWNjZXNzTWFuYWdlckdyYW50XCIsUE5BY2Nlc3NNYW5hZ2VyR3JhbnRUb2tlbjpcIlBOQWNjZXNzTWFuYWdlckdyYW50VG9rZW5cIixQTkFjY2Vzc01hbmFnZXJBdWRpdDpcIlBOQWNjZXNzTWFuYWdlckF1ZGl0XCJ9LGUuZXhwb3J0cz10LmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlbmNvZGVVUklDb21wb25lbnQoZSkucmVwbGFjZSgvWyF+KicoKV0vZyxmdW5jdGlvbihlKXtyZXR1cm5cIiVcIi5jb25jYXQoZS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKX0pfWZ1bmN0aW9uIGkoZSl7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciB0PVtdO3JldHVybiBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB0LnB1c2goZSl9KSx0fShlKS5zb3J0KCl9ZS5leHBvcnRzPXtzaWduUGFtRnJvbVBhcmFtczpmdW5jdGlvbih0KXtyZXR1cm4gaSh0KS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuXCJcIi5jb25jYXQoZSxcIj1cIikuY29uY2F0KHIodFtlXSkpfSkuam9pbihcIiZcIil9LGVuZHNXaXRoOmZ1bmN0aW9uKGUsdCl7cmV0dXJuLTEhPT1lLmluZGV4T2YodCx0aGlzLmxlbmd0aC10Lmxlbmd0aCl9LGNyZWF0ZVByb21pc2U6ZnVuY3Rpb24oKXt2YXIgbixyO3JldHVybntwcm9taXNlOm5ldyBQcm9taXNlKGZ1bmN0aW9uKGUsdCl7bj1lLHI9dH0pLHJlamVjdDpyLGZ1bGZpbGw6bn19LGVuY29kZVN0cmluZzpyfX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD12b2lkIDA7dmFyIHIsaT0ocj1uKDUpKSYmci5fX2VzTW9kdWxlP3I6e2RlZmF1bHQ6cn07bigwKTtmdW5jdGlvbiBvKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1mdW5jdGlvbiBzKGUsdCxuKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPW4sZX12YXIgYSx1LGMsZj0oYT1sLCh1PVt7a2V5OlwiZ2V0QXV0aEtleVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXV0aEtleX19LHtrZXk6XCJzZXRBdXRoS2V5XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYXV0aEtleT1lLHRoaXN9fSx7a2V5Olwic2V0Q2lwaGVyS2V5XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuY2lwaGVyS2V5PWUsdGhpc319LHtrZXk6XCJnZXRVVUlEXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5VVUlEfX0se2tleTpcInNldFVVSURcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fZGImJnRoaXMuX2RiLnNldCYmdGhpcy5fZGIuc2V0KFwiXCIuY29uY2F0KHRoaXMuc3Vic2NyaWJlS2V5LFwidXVpZFwiKSxlKSx0aGlzLlVVSUQ9ZSx0aGlzfX0se2tleTpcImdldEZpbHRlckV4cHJlc3Npb25cIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZpbHRlckV4cHJlc3Npb259fSx7a2V5Olwic2V0RmlsdGVyRXhwcmVzc2lvblwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmZpbHRlckV4cHJlc3Npb249ZSx0aGlzfX0se2tleTpcImdldFByZXNlbmNlVGltZW91dFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3ByZXNlbmNlVGltZW91dH19LHtrZXk6XCJzZXRQcmVzZW5jZVRpbWVvdXRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gMjA8PWU/dGhpcy5fcHJlc2VuY2VUaW1lb3V0PWU6KHRoaXMuX3ByZXNlbmNlVGltZW91dD0yMCxjb25zb2xlLmxvZyhcIldBUk5JTkc6IFByZXNlbmNlIHRpbWVvdXQgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtLiBVc2luZyBtaW5pbXVtIHZhbHVlOiBcIix0aGlzLl9wcmVzZW5jZVRpbWVvdXQpKSx0aGlzLnNldEhlYXJ0YmVhdEludGVydmFsKHRoaXMuX3ByZXNlbmNlVGltZW91dC8yLTEpLHRoaXN9fSx7a2V5Olwic2V0UHJveHlcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLnByb3h5PWV9fSx7a2V5OlwiZ2V0SGVhcnRiZWF0SW50ZXJ2YWxcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9oZWFydGJlYXRJbnRlcnZhbH19LHtrZXk6XCJzZXRIZWFydGJlYXRJbnRlcnZhbFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9oZWFydGJlYXRJbnRlcnZhbD1lLHRoaXN9fSx7a2V5OlwiZ2V0U3Vic2NyaWJlVGltZW91dFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N1YnNjcmliZVJlcXVlc3RUaW1lb3V0fX0se2tleTpcInNldFN1YnNjcmliZVRpbWVvdXRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fc3Vic2NyaWJlUmVxdWVzdFRpbWVvdXQ9ZSx0aGlzfX0se2tleTpcImdldFRyYW5zYWN0aW9uVGltZW91dFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9uYWxSZXF1ZXN0VGltZW91dH19LHtrZXk6XCJzZXRUcmFuc2FjdGlvblRpbWVvdXRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb25hbFJlcXVlc3RUaW1lb3V0PWUsdGhpc319LHtrZXk6XCJpc1NlbmRCZWFjb25FbmFibGVkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdXNlU2VuZEJlYWNvbn19LHtrZXk6XCJzZXRTZW5kQmVhY29uQ29uZmlnXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX3VzZVNlbmRCZWFjb249ZSx0aGlzfX0se2tleTpcImdldFZlcnNpb25cIix2YWx1ZTpmdW5jdGlvbigpe3JldHVyblwiNC4yNy4zXCJ9fSx7a2V5OlwiX2FkZFBuc2RrU3VmZml4XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0aGlzLl9QTlNES1N1ZmZpeFtlXT10fX0se2tleTpcIl9nZXRQbnNka1N1ZmZpeFwiLHZhbHVlOmZ1bmN0aW9uKG4pe3ZhciByPXRoaXM7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX1BOU0RLU3VmZml4KS5yZWR1Y2UoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZStuK3IuX1BOU0RLU3VmZml4W3RdfSxcIlwiKX19LHtrZXk6XCJfZGVjaWRlVVVJRFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBlfHwodGhpcy5fZGImJnRoaXMuX2RiLmdldCYmdGhpcy5fZGIuZ2V0KFwiXCIuY29uY2F0KHRoaXMuc3Vic2NyaWJlS2V5LFwidXVpZFwiKSk/dGhpcy5fZGIuZ2V0KFwiXCIuY29uY2F0KHRoaXMuc3Vic2NyaWJlS2V5LFwidXVpZFwiKSk6XCJwbi1cIi5jb25jYXQoaS5kZWZhdWx0LmNyZWF0ZVVVSUQoKSkpfX1dKSYmbyhhLnByb3RvdHlwZSx1KSx2b2lkKGMmJm8oYSxjKSksbCk7ZnVuY3Rpb24gbChlKXt2YXIgdD1lLnNldHVwLG49ZS5kYjshZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGwpLHModGhpcyxcIl9kYlwiLHZvaWQgMCkscyh0aGlzLFwic3Vic2NyaWJlS2V5XCIsdm9pZCAwKSxzKHRoaXMsXCJwdWJsaXNoS2V5XCIsdm9pZCAwKSxzKHRoaXMsXCJzZWNyZXRLZXlcIix2b2lkIDApLHModGhpcyxcImNpcGhlcktleVwiLHZvaWQgMCkscyh0aGlzLFwiYXV0aEtleVwiLHZvaWQgMCkscyh0aGlzLFwiVVVJRFwiLHZvaWQgMCkscyh0aGlzLFwicHJveHlcIix2b2lkIDApLHModGhpcyxcImluc3RhbmNlSWRcIix2b2lkIDApLHModGhpcyxcInNka05hbWVcIix2b2lkIDApLHModGhpcyxcInNka0ZhbWlseVwiLHZvaWQgMCkscyh0aGlzLFwicGFydG5lcklkXCIsdm9pZCAwKSxzKHRoaXMsXCJmaWx0ZXJFeHByZXNzaW9uXCIsdm9pZCAwKSxzKHRoaXMsXCJzdXBwcmVzc0xlYXZlRXZlbnRzXCIsdm9pZCAwKSxzKHRoaXMsXCJzZWN1cmVcIix2b2lkIDApLHModGhpcyxcIm9yaWdpblwiLHZvaWQgMCkscyh0aGlzLFwibG9nVmVyYm9zaXR5XCIsdm9pZCAwKSxzKHRoaXMsXCJ1c2VJbnN0YW5jZUlkXCIsdm9pZCAwKSxzKHRoaXMsXCJ1c2VSZXF1ZXN0SWRcIix2b2lkIDApLHModGhpcyxcImtlZXBBbGl2ZVwiLHZvaWQgMCkscyh0aGlzLFwia2VlcEFsaXZlU2V0dGluZ3NcIix2b2lkIDApLHModGhpcyxcImF1dG9OZXR3b3JrRGV0ZWN0aW9uXCIsdm9pZCAwKSxzKHRoaXMsXCJhbm5vdW5jZVN1Y2Nlc3NmdWxIZWFydGJlYXRzXCIsdm9pZCAwKSxzKHRoaXMsXCJhbm5vdW5jZUZhaWxlZEhlYXJ0YmVhdHNcIix2b2lkIDApLHModGhpcyxcIl9wcmVzZW5jZVRpbWVvdXRcIix2b2lkIDApLHModGhpcyxcIl9oZWFydGJlYXRJbnRlcnZhbFwiLHZvaWQgMCkscyh0aGlzLFwiX3N1YnNjcmliZVJlcXVlc3RUaW1lb3V0XCIsdm9pZCAwKSxzKHRoaXMsXCJfdHJhbnNhY3Rpb25hbFJlcXVlc3RUaW1lb3V0XCIsdm9pZCAwKSxzKHRoaXMsXCJfdXNlU2VuZEJlYWNvblwiLHZvaWQgMCkscyh0aGlzLFwiX1BOU0RLU3VmZml4XCIsdm9pZCAwKSxzKHRoaXMsXCJyZXF1ZXN0TWVzc2FnZUNvdW50VGhyZXNob2xkXCIsdm9pZCAwKSxzKHRoaXMsXCJyZXN0b3JlXCIsdm9pZCAwKSxzKHRoaXMsXCJkZWR1cGVPblN1YnNjcmliZVwiLHZvaWQgMCkscyh0aGlzLFwibWF4aW11bUNhY2hlU2l6ZVwiLHZvaWQgMCkscyh0aGlzLFwiY3VzdG9tRW5jcnlwdFwiLHZvaWQgMCkscyh0aGlzLFwiY3VzdG9tRGVjcnlwdFwiLHZvaWQgMCksdGhpcy5fUE5TREtTdWZmaXg9e30sdGhpcy5fZGI9bix0aGlzLmluc3RhbmNlSWQ9XCJwbi1cIi5jb25jYXQoaS5kZWZhdWx0LmNyZWF0ZVVVSUQoKSksdGhpcy5zZWNyZXRLZXk9dC5zZWNyZXRLZXl8fHQuc2VjcmV0X2tleSx0aGlzLnN1YnNjcmliZUtleT10LnN1YnNjcmliZUtleXx8dC5zdWJzY3JpYmVfa2V5LHRoaXMucHVibGlzaEtleT10LnB1Ymxpc2hLZXl8fHQucHVibGlzaF9rZXksdGhpcy5zZGtOYW1lPXQuc2RrTmFtZSx0aGlzLnNka0ZhbWlseT10LnNka0ZhbWlseSx0aGlzLnBhcnRuZXJJZD10LnBhcnRuZXJJZCx0aGlzLnNldEF1dGhLZXkodC5hdXRoS2V5KSx0aGlzLnNldENpcGhlcktleSh0LmNpcGhlcktleSksdGhpcy5zZXRGaWx0ZXJFeHByZXNzaW9uKHQuZmlsdGVyRXhwcmVzc2lvbiksdGhpcy5vcmlnaW49dC5vcmlnaW58fFwicHMucG5kc24uY29tXCIsdGhpcy5zZWN1cmU9dC5zc2x8fCExLHRoaXMucmVzdG9yZT10LnJlc3RvcmV8fCExLHRoaXMucHJveHk9dC5wcm94eSx0aGlzLmtlZXBBbGl2ZT10LmtlZXBBbGl2ZSx0aGlzLmtlZXBBbGl2ZVNldHRpbmdzPXQua2VlcEFsaXZlU2V0dGluZ3MsdGhpcy5hdXRvTmV0d29ya0RldGVjdGlvbj10LmF1dG9OZXR3b3JrRGV0ZWN0aW9ufHwhMSx0aGlzLmRlZHVwZU9uU3Vic2NyaWJlPXQuZGVkdXBlT25TdWJzY3JpYmV8fCExLHRoaXMubWF4aW11bUNhY2hlU2l6ZT10Lm1heGltdW1DYWNoZVNpemV8fDEwMCx0aGlzLmN1c3RvbUVuY3J5cHQ9dC5jdXN0b21FbmNyeXB0LHRoaXMuY3VzdG9tRGVjcnlwdD10LmN1c3RvbURlY3J5cHQsXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGxvY2F0aW9uJiZcImh0dHBzOlwiPT09bG9jYXRpb24ucHJvdG9jb2wmJih0aGlzLnNlY3VyZT0hMCksdGhpcy5sb2dWZXJib3NpdHk9dC5sb2dWZXJib3NpdHl8fCExLHRoaXMuc3VwcHJlc3NMZWF2ZUV2ZW50cz10LnN1cHByZXNzTGVhdmVFdmVudHN8fCExLHRoaXMuYW5ub3VuY2VGYWlsZWRIZWFydGJlYXRzPXQuYW5ub3VuY2VGYWlsZWRIZWFydGJlYXRzfHwhMCx0aGlzLmFubm91bmNlU3VjY2Vzc2Z1bEhlYXJ0YmVhdHM9dC5hbm5vdW5jZVN1Y2Nlc3NmdWxIZWFydGJlYXRzfHwhMSx0aGlzLnVzZUluc3RhbmNlSWQ9dC51c2VJbnN0YW5jZUlkfHwhMSx0aGlzLnVzZVJlcXVlc3RJZD10LnVzZVJlcXVlc3RJZHx8ITEsdGhpcy5yZXF1ZXN0TWVzc2FnZUNvdW50VGhyZXNob2xkPXQucmVxdWVzdE1lc3NhZ2VDb3VudFRocmVzaG9sZCx0aGlzLnNldFRyYW5zYWN0aW9uVGltZW91dCh0LnRyYW5zYWN0aW9uYWxSZXF1ZXN0VGltZW91dHx8MTVlMyksdGhpcy5zZXRTdWJzY3JpYmVUaW1lb3V0KHQuc3Vic2NyaWJlUmVxdWVzdFRpbWVvdXR8fDMxZTQpLHRoaXMuc2V0U2VuZEJlYWNvbkNvbmZpZyh0LnVzZVNlbmRCZWFjb258fCEwKSx0LnByZXNlbmNlVGltZW91dD90aGlzLnNldFByZXNlbmNlVGltZW91dCh0LnByZXNlbmNlVGltZW91dCk6dGhpcy5fcHJlc2VuY2VUaW1lb3V0PTMwMCxudWxsIT10LmhlYXJ0YmVhdEludGVydmFsJiZ0aGlzLnNldEhlYXJ0YmVhdEludGVydmFsKHQuaGVhcnRiZWF0SW50ZXJ2YWwpLHRoaXMuc2V0VVVJRCh0aGlzLl9kZWNpZGVVVUlEKHQudXVpZCkpfXQuZGVmYXVsdD1mLGUuZXhwb3J0cz10LmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9dm9pZCAwO3QuZGVmYXVsdD17UE5OZXR3b3JrVXBDYXRlZ29yeTpcIlBOTmV0d29ya1VwQ2F0ZWdvcnlcIixQTk5ldHdvcmtEb3duQ2F0ZWdvcnk6XCJQTk5ldHdvcmtEb3duQ2F0ZWdvcnlcIixQTk5ldHdvcmtJc3N1ZXNDYXRlZ29yeTpcIlBOTmV0d29ya0lzc3Vlc0NhdGVnb3J5XCIsUE5UaW1lb3V0Q2F0ZWdvcnk6XCJQTlRpbWVvdXRDYXRlZ29yeVwiLFBOQmFkUmVxdWVzdENhdGVnb3J5OlwiUE5CYWRSZXF1ZXN0Q2F0ZWdvcnlcIixQTkFjY2Vzc0RlbmllZENhdGVnb3J5OlwiUE5BY2Nlc3NEZW5pZWRDYXRlZ29yeVwiLFBOVW5rbm93bkNhdGVnb3J5OlwiUE5Vbmtub3duQ2F0ZWdvcnlcIixQTlJlY29ubmVjdGVkQ2F0ZWdvcnk6XCJQTlJlY29ubmVjdGVkQ2F0ZWdvcnlcIixQTkNvbm5lY3RlZENhdGVnb3J5OlwiUE5Db25uZWN0ZWRDYXRlZ29yeVwiLFBOUmVxdWVzdE1lc3NhZ2VDb3VudEV4Y2VlZGVkQ2F0ZWdvcnk6XCJQTlJlcXVlc3RNZXNzYWdlQ291bnRFeGNlZWRlZENhdGVnb3J5XCJ9LGUuZXhwb3J0cz10LmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9dm9pZCAwO3ZhciByLGk9KHI9bigxMykpJiZyLl9fZXNNb2R1bGU/cjp7ZGVmYXVsdDpyfTt2YXIgbz17Y3JlYXRlVVVJRDpmdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHQudXVpZD9pLmRlZmF1bHQudXVpZCgpOigwLGkuZGVmYXVsdCkoKX19O3QuZGVmYXVsdD1vLGUuZXhwb3J0cz10LmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9dm9pZCAwO3IobigzKSk7dmFyIHU9cihuKDE0KSk7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19ZnVuY3Rpb24gbyhlLHQsbil7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1uLGV9dmFyIHMsYSxjLGY9KHM9bCwoYT1be2tleTpcIkhNQUNTSEEyNTZcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdS5kZWZhdWx0LkhtYWNTSEEyNTYoZSx0aGlzLl9jb25maWcuc2VjcmV0S2V5KS50b1N0cmluZyh1LmRlZmF1bHQuZW5jLkJhc2U2NCl9fSx7a2V5OlwiU0hBMjU2XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHUuZGVmYXVsdC5TSEEyNTYoZSkudG9TdHJpbmcodS5kZWZhdWx0LmVuYy5IZXgpfX0se2tleTpcIl9wYXJzZU9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1lfHx7fTtyZXR1cm4gdC5oYXNPd25Qcm9wZXJ0eShcImVuY3J5cHRLZXlcIil8fCh0LmVuY3J5cHRLZXk9dGhpcy5fZGVmYXVsdE9wdGlvbnMuZW5jcnlwdEtleSksdC5oYXNPd25Qcm9wZXJ0eShcImtleUVuY29kaW5nXCIpfHwodC5rZXlFbmNvZGluZz10aGlzLl9kZWZhdWx0T3B0aW9ucy5rZXlFbmNvZGluZyksdC5oYXNPd25Qcm9wZXJ0eShcImtleUxlbmd0aFwiKXx8KHQua2V5TGVuZ3RoPXRoaXMuX2RlZmF1bHRPcHRpb25zLmtleUxlbmd0aCksdC5oYXNPd25Qcm9wZXJ0eShcIm1vZGVcIil8fCh0Lm1vZGU9dGhpcy5fZGVmYXVsdE9wdGlvbnMubW9kZSksLTE9PT10aGlzLl9hbGxvd2VkS2V5RW5jb2RpbmdzLmluZGV4T2YodC5rZXlFbmNvZGluZy50b0xvd2VyQ2FzZSgpKSYmKHQua2V5RW5jb2Rpbmc9dGhpcy5fZGVmYXVsdE9wdGlvbnMua2V5RW5jb2RpbmcpLC0xPT09dGhpcy5fYWxsb3dlZEtleUxlbmd0aHMuaW5kZXhPZihwYXJzZUludCh0LmtleUxlbmd0aCwxMCkpJiYodC5rZXlMZW5ndGg9dGhpcy5fZGVmYXVsdE9wdGlvbnMua2V5TGVuZ3RoKSwtMT09PXRoaXMuX2FsbG93ZWRNb2Rlcy5pbmRleE9mKHQubW9kZS50b0xvd2VyQ2FzZSgpKSYmKHQubW9kZT10aGlzLl9kZWZhdWx0T3B0aW9ucy5tb2RlKSx0fX0se2tleTpcIl9kZWNvZGVLZXlcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVyblwiYmFzZTY0XCI9PT10LmtleUVuY29kaW5nP3UuZGVmYXVsdC5lbmMuQmFzZTY0LnBhcnNlKGUpOlwiaGV4XCI9PT10LmtleUVuY29kaW5nP3UuZGVmYXVsdC5lbmMuSGV4LnBhcnNlKGUpOmV9fSx7a2V5OlwiX2dldFBhZGRlZEtleVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU9dGhpcy5fZGVjb2RlS2V5KGUsdCksdC5lbmNyeXB0S2V5P3UuZGVmYXVsdC5lbmMuVXRmOC5wYXJzZSh0aGlzLlNIQTI1NihlKS5zbGljZSgwLDMyKSk6ZX19LHtrZXk6XCJfZ2V0TW9kZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVyblwiZWNiXCI9PT1lLm1vZGU/dS5kZWZhdWx0Lm1vZGUuRUNCOnUuZGVmYXVsdC5tb2RlLkNCQ319LHtrZXk6XCJfZ2V0SVZcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm5cImNiY1wiPT09ZS5tb2RlP3UuZGVmYXVsdC5lbmMuVXRmOC5wYXJzZSh0aGlzLl9pdik6bnVsbH19LHtrZXk6XCJlbmNyeXB0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB0aGlzLl9jb25maWcuY3VzdG9tRW5jcnlwdD90aGlzLl9jb25maWcuY3VzdG9tRW5jcnlwdChlKTp0aGlzLnBuRW5jcnlwdChlLHQsbil9fSx7a2V5OlwiZGVjcnlwdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdGhpcy5fY29uZmlnLmN1c3RvbURlY3J5cHQ/dGhpcy5fY29uZmlnLmN1c3RvbURlY3J5cHQoZSk6dGhpcy5wbkRlY3J5cHQoZSx0LG4pfX0se2tleTpcInBuRW5jcnlwdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXtpZighdCYmIXRoaXMuX2NvbmZpZy5jaXBoZXJLZXkpcmV0dXJuIGU7bj10aGlzLl9wYXJzZU9wdGlvbnMobik7dmFyIHI9dGhpcy5fZ2V0SVYobiksaT10aGlzLl9nZXRNb2RlKG4pLG89dGhpcy5fZ2V0UGFkZGVkS2V5KHR8fHRoaXMuX2NvbmZpZy5jaXBoZXJLZXksbik7cmV0dXJuIHUuZGVmYXVsdC5BRVMuZW5jcnlwdChlLG8se2l2OnIsbW9kZTppfSkuY2lwaGVydGV4dC50b1N0cmluZyh1LmRlZmF1bHQuZW5jLkJhc2U2NCl8fGV9fSx7a2V5OlwicG5EZWNyeXB0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe2lmKCF0JiYhdGhpcy5fY29uZmlnLmNpcGhlcktleSlyZXR1cm4gZTtuPXRoaXMuX3BhcnNlT3B0aW9ucyhuKTt2YXIgcj10aGlzLl9nZXRJVihuKSxpPXRoaXMuX2dldE1vZGUobiksbz10aGlzLl9nZXRQYWRkZWRLZXkodHx8dGhpcy5fY29uZmlnLmNpcGhlcktleSxuKTt0cnl7dmFyIHM9dS5kZWZhdWx0LmVuYy5CYXNlNjQucGFyc2UoZSksYT11LmRlZmF1bHQuQUVTLmRlY3J5cHQoe2NpcGhlcnRleHQ6c30sbyx7aXY6cixtb2RlOml9KS50b1N0cmluZyh1LmRlZmF1bHQuZW5jLlV0ZjgpO3JldHVybiBKU09OLnBhcnNlKGEpfWNhdGNoKGUpe3JldHVybiBudWxsfX19XSkmJmkocy5wcm90b3R5cGUsYSksdm9pZChjJiZpKHMsYykpLGwpO2Z1bmN0aW9uIGwoZSl7dmFyIHQ9ZS5jb25maWc7IWZ1bmN0aW9uKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxsKSxvKHRoaXMsXCJfY29uZmlnXCIsdm9pZCAwKSxvKHRoaXMsXCJfaXZcIix2b2lkIDApLG8odGhpcyxcIl9hbGxvd2VkS2V5RW5jb2RpbmdzXCIsdm9pZCAwKSxvKHRoaXMsXCJfYWxsb3dlZEtleUxlbmd0aHNcIix2b2lkIDApLG8odGhpcyxcIl9hbGxvd2VkTW9kZXNcIix2b2lkIDApLG8odGhpcyxcIl9kZWZhdWx0T3B0aW9uc1wiLHZvaWQgMCksdGhpcy5fY29uZmlnPXQsdGhpcy5faXY9XCIwMTIzNDU2Nzg5MDEyMzQ1XCIsdGhpcy5fYWxsb3dlZEtleUVuY29kaW5ncz1bXCJoZXhcIixcInV0ZjhcIixcImJhc2U2NFwiLFwiYmluYXJ5XCJdLHRoaXMuX2FsbG93ZWRLZXlMZW5ndGhzPVsxMjgsMjU2XSx0aGlzLl9hbGxvd2VkTW9kZXM9W1wiZWNiXCIsXCJjYmNcIl0sdGhpcy5fZGVmYXVsdE9wdGlvbnM9e2VuY3J5cHRLZXk6ITAsa2V5RW5jb2Rpbmc6XCJ1dGY4XCIsa2V5TGVuZ3RoOjI1Nixtb2RlOlwiY2JjXCJ9fXQuZGVmYXVsdD1mLGUuZXhwb3J0cz10LmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9dm9pZCAwO24oMCk7dmFyIHIsaT0ocj1uKDQpKSYmci5fX2VzTW9kdWxlP3I6e2RlZmF1bHQ6cn07ZnVuY3Rpb24gbyhlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19dmFyIHMsYSx1LGM9KHM9ZiwoYT1be2tleTpcImFkZExpc3RlbmVyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5fbGlzdGVuZXJzLnB1c2goZSl9fSx7a2V5OlwicmVtb3ZlTGlzdGVuZXJcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgbj1bXTt0aGlzLl9saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbihlKXtlIT09dCYmbi5wdXNoKGUpfSksdGhpcy5fbGlzdGVuZXJzPW59fSx7a2V5OlwicmVtb3ZlQWxsTGlzdGVuZXJzXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9saXN0ZW5lcnM9W119fSx7a2V5OlwiYW5ub3VuY2VQcmVzZW5jZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UucHJlc2VuY2UmJmUucHJlc2VuY2UodCl9KX19LHtrZXk6XCJhbm5vdW5jZVN0YXR1c1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2Uuc3RhdHVzJiZlLnN0YXR1cyh0KX0pfX0se2tleTpcImFubm91bmNlTWVzc2FnZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UubWVzc2FnZSYmZS5tZXNzYWdlKHQpfSl9fSx7a2V5OlwiYW5ub3VuY2VTaWduYWxcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLl9saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbihlKXtlLnNpZ25hbCYmZS5zaWduYWwodCl9KX19LHtrZXk6XCJhbm5vdW5jZU1lc3NhZ2VBY3Rpb25cIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLl9saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbihlKXtlLm1lc3NhZ2VBY3Rpb24mJmUubWVzc2FnZUFjdGlvbih0KX0pfX0se2tleTpcImFubm91bmNlVXNlclwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UudXNlciYmZS51c2VyKHQpfSl9fSx7a2V5OlwiYW5ub3VuY2VTcGFjZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2Uuc3BhY2UmJmUuc3BhY2UodCl9KX19LHtrZXk6XCJhbm5vdW5jZU1lbWJlcnNoaXBcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLl9saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbihlKXtlLm1lbWJlcnNoaXAmJmUubWVtYmVyc2hpcCh0KX0pfX0se2tleTpcImFubm91bmNlTmV0d29ya1VwXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT17fTtlLmNhdGVnb3J5PWkuZGVmYXVsdC5QTk5ldHdvcmtVcENhdGVnb3J5LHRoaXMuYW5ub3VuY2VTdGF0dXMoZSl9fSx7a2V5OlwiYW5ub3VuY2VOZXR3b3JrRG93blwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9e307ZS5jYXRlZ29yeT1pLmRlZmF1bHQuUE5OZXR3b3JrRG93bkNhdGVnb3J5LHRoaXMuYW5ub3VuY2VTdGF0dXMoZSl9fV0pJiZvKHMucHJvdG90eXBlLGEpLHZvaWQodSYmbyhzLHUpKSxmKTtmdW5jdGlvbiBmKCl7IWZ1bmN0aW9uKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxmKSxmdW5jdGlvbihlLHQsbil7dCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPW59KHRoaXMsXCJfbGlzdGVuZXJzXCIsdm9pZCAwKSx0aGlzLl9saXN0ZW5lcnM9W119dC5kZWZhdWx0PWMsZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdC5QTlRpbWVPcGVyYXRpb259LHQuZ2V0VVJMPWZ1bmN0aW9uKCl7cmV0dXJuXCIvdGltZS8wXCJ9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oKXtyZXR1cm57fX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLHQpe3JldHVybnt0aW1ldG9rZW46dFswXX19LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oKXt9O24oMCk7dmFyIHIsaT0ocj1uKDEpKSYmci5fX2VzTW9kdWxlP3I6e2RlZmF1bHQ6cn19LGZ1bmN0aW9uKGUsSSxEKXtcInVzZSBzdHJpY3RcIjsoZnVuY3Rpb24oZSl7dmFyIHI9RCg3MSksbz1EKDcyKSxzPUQoNzMpO2Z1bmN0aW9uIG4oKXtyZXR1cm4gbC5UWVBFRF9BUlJBWV9TVVBQT1JUPzIxNDc0ODM2NDc6MTA3Mzc0MTgyM31mdW5jdGlvbiBhKGUsdCl7aWYobigpPHQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aFwiKTtyZXR1cm4gbC5UWVBFRF9BUlJBWV9TVVBQT1JUPyhlPW5ldyBVaW50OEFycmF5KHQpKS5fX3Byb3RvX189bC5wcm90b3R5cGU6KG51bGw9PT1lJiYoZT1uZXcgbCh0KSksZS5sZW5ndGg9dCksZX1mdW5jdGlvbiBsKGUsdCxuKXtpZighKGwuVFlQRURfQVJSQVlfU1VQUE9SVHx8dGhpcyBpbnN0YW5jZW9mIGwpKXJldHVybiBuZXcgbChlLHQsbik7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGUpcmV0dXJuIGkodGhpcyxlLHQsbik7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpdGhyb3cgbmV3IEVycm9yKFwiSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmdcIik7cmV0dXJuIGModGhpcyxlKX1mdW5jdGlvbiBpKGUsdCxuLHIpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpO3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBBcnJheUJ1ZmZlciYmdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyP2Z1bmN0aW9uKGUsdCxuLHIpe2lmKHQuYnl0ZUxlbmd0aCxuPDB8fHQuYnl0ZUxlbmd0aDxuKXRocm93IG5ldyBSYW5nZUVycm9yKFwiJ29mZnNldCcgaXMgb3V0IG9mIGJvdW5kc1wiKTtpZih0LmJ5dGVMZW5ndGg8bisocnx8MCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInbGVuZ3RoJyBpcyBvdXQgb2YgYm91bmRzXCIpO3Q9dm9pZCAwPT09biYmdm9pZCAwPT09cj9uZXcgVWludDhBcnJheSh0KTp2b2lkIDA9PT1yP25ldyBVaW50OEFycmF5KHQsbik6bmV3IFVpbnQ4QXJyYXkodCxuLHIpO2wuVFlQRURfQVJSQVlfU1VQUE9SVD8oZT10KS5fX3Byb3RvX189bC5wcm90b3R5cGU6ZT1mKGUsdCk7cmV0dXJuIGV9KGUsdCxuLHIpOlwic3RyaW5nXCI9PXR5cGVvZiB0P2Z1bmN0aW9uKGUsdCxuKXtcInN0cmluZ1wiPT10eXBlb2YgbiYmXCJcIiE9PW58fChuPVwidXRmOFwiKTtpZighbC5pc0VuY29kaW5nKG4pKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJyk7dmFyIHI9MHxwKHQsbiksaT0oZT1hKGUscikpLndyaXRlKHQsbik7aSE9PXImJihlPWUuc2xpY2UoMCxpKSk7cmV0dXJuIGV9KGUsdCxuKTpmdW5jdGlvbihlLHQpe2lmKGwuaXNCdWZmZXIodCkpe3ZhciBuPTB8aCh0Lmxlbmd0aCk7cmV0dXJuIDA9PT0oZT1hKGUsbikpLmxlbmd0aHx8dC5jb3B5KGUsMCwwLG4pLGV9aWYodCl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEFycmF5QnVmZmVyJiZ0LmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyfHxcImxlbmd0aFwiaW4gdClyZXR1cm5cIm51bWJlclwiIT10eXBlb2YgdC5sZW5ndGh8fGZ1bmN0aW9uKGUpe3JldHVybiBlIT1lfSh0Lmxlbmd0aCk/YShlLDApOmYoZSx0KTtpZihcIkJ1ZmZlclwiPT09dC50eXBlJiZzKHQuZGF0YSkpcmV0dXJuIGYoZSx0LmRhdGEpfXRocm93IG5ldyBUeXBlRXJyb3IoXCJGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuXCIpfShlLHQpfWZ1bmN0aW9uIHUoZSl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpO2lmKGU8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKX1mdW5jdGlvbiBjKGUsdCl7aWYodSh0KSxlPWEoZSx0PDA/MDowfGgodCkpLCFsLlRZUEVEX0FSUkFZX1NVUFBPUlQpZm9yKHZhciBuPTA7bjx0OysrbillW25dPTA7cmV0dXJuIGV9ZnVuY3Rpb24gZihlLHQpe3ZhciBuPXQubGVuZ3RoPDA/MDowfGgodC5sZW5ndGgpO2U9YShlLG4pO2Zvcih2YXIgcj0wO3I8bjtyKz0xKWVbcl09MjU1JnRbcl07cmV0dXJuIGV9ZnVuY3Rpb24gaChlKXtpZihlPj1uKCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtIHNpemU6IDB4XCIrbigpLnRvU3RyaW5nKDE2KStcIiBieXRlc1wiKTtyZXR1cm4gMHxlfWZ1bmN0aW9uIHAoZSx0KXtpZihsLmlzQnVmZmVyKGUpKXJldHVybiBlLmxlbmd0aDtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgQXJyYXlCdWZmZXImJlwiZnVuY3Rpb25cIj09dHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyYmKEFycmF5QnVmZmVyLmlzVmlldyhlKXx8ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSlyZXR1cm4gZS5ieXRlTGVuZ3RoO1wic3RyaW5nXCIhPXR5cGVvZiBlJiYoZT1cIlwiK2UpO3ZhciBuPWUubGVuZ3RoO2lmKDA9PT1uKXJldHVybiAwO2Zvcih2YXIgcj0hMTs7KXN3aXRjaCh0KXtjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBuO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOmNhc2Ugdm9pZCAwOnJldHVybiB4KGUpLmxlbmd0aDtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gMipuO2Nhc2VcImhleFwiOnJldHVybiBuPj4+MTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gVShlKS5sZW5ndGg7ZGVmYXVsdDppZihyKXJldHVybiB4KGUpLmxlbmd0aDt0PShcIlwiK3QpLnRvTG93ZXJDYXNlKCkscj0hMH19ZnVuY3Rpb24gZChlLHQsbil7dmFyIHI9ZVt0XTtlW3RdPWVbbl0sZVtuXT1yfWZ1bmN0aW9uIGcoZSx0LG4scixpKXtpZigwPT09ZS5sZW5ndGgpcmV0dXJuLTE7aWYoXCJzdHJpbmdcIj09dHlwZW9mIG4/KHI9bixuPTApOjIxNDc0ODM2NDc8bj9uPTIxNDc0ODM2NDc6bjwtMjE0NzQ4MzY0OCYmKG49LTIxNDc0ODM2NDgpLG49K24saXNOYU4obikmJihuPWk/MDplLmxlbmd0aC0xKSxuPDAmJihuPWUubGVuZ3RoK24pLG4+PWUubGVuZ3RoKXtpZihpKXJldHVybi0xO249ZS5sZW5ndGgtMX1lbHNlIGlmKG48MCl7aWYoIWkpcmV0dXJuLTE7bj0wfWlmKFwic3RyaW5nXCI9PXR5cGVvZiB0JiYodD1sLmZyb20odCxyKSksbC5pc0J1ZmZlcih0KSlyZXR1cm4gMD09PXQubGVuZ3RoPy0xOnkoZSx0LG4scixpKTtpZihcIm51bWJlclwiPT10eXBlb2YgdClyZXR1cm4gdCY9MjU1LGwuVFlQRURfQVJSQVlfU1VQUE9SVCYmXCJmdW5jdGlvblwiPT10eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZj9pP1VpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChlLHQsbik6VWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChlLHQsbik6eShlLFt0XSxuLHIsaSk7dGhyb3cgbmV3IFR5cGVFcnJvcihcInZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlclwiKX1mdW5jdGlvbiB5KGUsdCxuLHIsaSl7dmFyIG8scz0xLGE9ZS5sZW5ndGgsdT10Lmxlbmd0aDtpZih2b2lkIDAhPT1yJiYoXCJ1Y3MyXCI9PT0ocj1TdHJpbmcocikudG9Mb3dlckNhc2UoKSl8fFwidWNzLTJcIj09PXJ8fFwidXRmMTZsZVwiPT09cnx8XCJ1dGYtMTZsZVwiPT09cikpe2lmKGUubGVuZ3RoPDJ8fHQubGVuZ3RoPDIpcmV0dXJuLTE7YS89cz0yLHUvPTIsbi89Mn1mdW5jdGlvbiBjKGUsdCl7cmV0dXJuIDE9PT1zP2VbdF06ZS5yZWFkVUludDE2QkUodCpzKX1pZihpKXt2YXIgZj0tMTtmb3Iobz1uO288YTtvKyspaWYoYyhlLG8pPT09Yyh0LC0xPT09Zj8wOm8tZikpe2lmKC0xPT09ZiYmKGY9byksby1mKzE9PT11KXJldHVybiBmKnN9ZWxzZS0xIT09ZiYmKG8tPW8tZiksZj0tMX1lbHNlIGZvcihhPG4rdSYmKG49YS11KSxvPW47MDw9bztvLS0pe2Zvcih2YXIgbD0hMCxoPTA7aDx1O2grKylpZihjKGUsbytoKSE9PWModCxoKSl7bD0hMTticmVha31pZihsKXJldHVybiBvfXJldHVybi0xfWZ1bmN0aW9uIHYoZSx0LG4scil7bj1OdW1iZXIobil8fDA7dmFyIGk9ZS5sZW5ndGgtbjtyP2k8KHI9TnVtYmVyKHIpKSYmKHI9aSk6cj1pO3ZhciBvPXQubGVuZ3RoO2lmKG8lMiE9MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBoZXggc3RyaW5nXCIpO28vMjxyJiYocj1vLzIpO2Zvcih2YXIgcz0wO3M8cjsrK3Mpe3ZhciBhPXBhcnNlSW50KHQuc3Vic3RyKDIqcywyKSwxNik7aWYoaXNOYU4oYSkpcmV0dXJuIHM7ZVtuK3NdPWF9cmV0dXJuIHN9ZnVuY3Rpb24gYihlLHQsbixyKXtyZXR1cm4gQihmdW5jdGlvbihlKXtmb3IodmFyIHQ9W10sbj0wO248ZS5sZW5ndGg7KytuKXQucHVzaCgyNTUmZS5jaGFyQ29kZUF0KG4pKTtyZXR1cm4gdH0odCksZSxuLHIpfWZ1bmN0aW9uIG0oZSx0LG4pe3JldHVybiAwPT09dCYmbj09PWUubGVuZ3RoP3IuZnJvbUJ5dGVBcnJheShlKTpyLmZyb21CeXRlQXJyYXkoZS5zbGljZSh0LG4pKX1mdW5jdGlvbiBfKGUsdCxuKXtuPU1hdGgubWluKGUubGVuZ3RoLG4pO2Zvcih2YXIgcj1bXSxpPXQ7aTxuOyl7dmFyIG8scyxhLHUsYz1lW2ldLGY9bnVsbCxsPTIzOTxjPzQ6MjIzPGM/MzoxOTE8Yz8yOjE7aWYoaStsPD1uKXN3aXRjaChsKXtjYXNlIDE6YzwxMjgmJihmPWMpO2JyZWFrO2Nhc2UgMjoxMjg9PSgxOTImKG89ZVtpKzFdKSkmJjEyNzwodT0oMzEmYyk8PDZ8NjMmbykmJihmPXUpO2JyZWFrO2Nhc2UgMzpvPWVbaSsxXSxzPWVbaSsyXSwxMjg9PSgxOTImbykmJjEyOD09KDE5MiZzKSYmMjA0NzwodT0oMTUmYyk8PDEyfCg2MyZvKTw8Nnw2MyZzKSYmKHU8NTUyOTZ8fDU3MzQzPHUpJiYoZj11KTticmVhaztjYXNlIDQ6bz1lW2krMV0scz1lW2krMl0sYT1lW2krM10sMTI4PT0oMTkyJm8pJiYxMjg9PSgxOTImcykmJjEyOD09KDE5MiZhKSYmNjU1MzU8KHU9KDE1JmMpPDwxOHwoNjMmbyk8PDEyfCg2MyZzKTw8Nnw2MyZhKSYmdTwxMTE0MTEyJiYoZj11KX1udWxsPT09Zj8oZj02NTUzMyxsPTEpOjY1NTM1PGYmJihmLT02NTUzNixyLnB1c2goZj4+PjEwJjEwMjN8NTUyOTYpLGY9NTYzMjB8MTAyMyZmKSxyLnB1c2goZiksaSs9bH1yZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9ZS5sZW5ndGg7aWYodDw9aylyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsZSk7dmFyIG49XCJcIixyPTA7Zm9yKDtyPHQ7KW4rPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGUuc2xpY2UocixyKz1rKSk7cmV0dXJuIG59KHIpfUkuQnVmZmVyPWwsSS5TbG93QnVmZmVyPWZ1bmN0aW9uKGUpeytlIT1lJiYoZT0wKTtyZXR1cm4gbC5hbGxvYygrZSl9LEkuSU5TUEVDVF9NQVhfQllURVM9NTAsbC5UWVBFRF9BUlJBWV9TVVBQT1JUPXZvaWQgMCE9PWUuVFlQRURfQVJSQVlfU1VQUE9SVD9lLlRZUEVEX0FSUkFZX1NVUFBPUlQ6ZnVuY3Rpb24oKXt0cnl7dmFyIGU9bmV3IFVpbnQ4QXJyYXkoMSk7cmV0dXJuIGUuX19wcm90b19fPXtfX3Byb3RvX186VWludDhBcnJheS5wcm90b3R5cGUsZm9vOmZ1bmN0aW9uKCl7cmV0dXJuIDQyfX0sNDI9PT1lLmZvbygpJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnN1YmFycmF5JiYwPT09ZS5zdWJhcnJheSgxLDEpLmJ5dGVMZW5ndGh9Y2F0Y2goZSl7cmV0dXJuITF9fSgpLEkua01heExlbmd0aD1uKCksbC5wb29sU2l6ZT04MTkyLGwuX2F1Z21lbnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuX19wcm90b19fPWwucHJvdG90eXBlLGV9LGwuZnJvbT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGkobnVsbCxlLHQsbil9LGwuVFlQRURfQVJSQVlfU1VQUE9SVCYmKGwucHJvdG90eXBlLl9fcHJvdG9fXz1VaW50OEFycmF5LnByb3RvdHlwZSxsLl9fcHJvdG9fXz1VaW50OEFycmF5LFwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5zcGVjaWVzJiZsW1N5bWJvbC5zcGVjaWVzXT09PWwmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShsLFN5bWJvbC5zcGVjaWVzLHt2YWx1ZTpudWxsLGNvbmZpZ3VyYWJsZTohMH0pKSxsLmFsbG9jPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIHUodCksdDw9MD9hKGUsdCk6dm9pZCAwIT09bj9cInN0cmluZ1wiPT10eXBlb2Ygcj9hKGUsdCkuZmlsbChuLHIpOmEoZSx0KS5maWxsKG4pOmEoZSx0KX0obnVsbCxlLHQsbil9LGwuYWxsb2NVbnNhZmU9ZnVuY3Rpb24oZSl7cmV0dXJuIGMobnVsbCxlKX0sbC5hbGxvY1Vuc2FmZVNsb3c9ZnVuY3Rpb24oZSl7cmV0dXJuIGMobnVsbCxlKX0sbC5pc0J1ZmZlcj1mdW5jdGlvbihlKXtyZXR1cm4hKG51bGw9PWV8fCFlLl9pc0J1ZmZlcil9LGwuY29tcGFyZT1mdW5jdGlvbihlLHQpe2lmKCFsLmlzQnVmZmVyKGUpfHwhbC5pc0J1ZmZlcih0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnRzIG11c3QgYmUgQnVmZmVyc1wiKTtpZihlPT09dClyZXR1cm4gMDtmb3IodmFyIG49ZS5sZW5ndGgscj10Lmxlbmd0aCxpPTAsbz1NYXRoLm1pbihuLHIpO2k8bzsrK2kpaWYoZVtpXSE9PXRbaV0pe249ZVtpXSxyPXRbaV07YnJlYWt9cmV0dXJuIG48cj8tMTpyPG4/MTowfSxsLmlzRW5jb2Rpbmc9ZnVuY3Rpb24oZSl7c3dpdGNoKFN0cmluZyhlKS50b0xvd2VyQ2FzZSgpKXtjYXNlXCJoZXhcIjpjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOmNhc2VcImJhc2U2NFwiOmNhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fSxsLmNvbmNhdD1mdW5jdGlvbihlLHQpe2lmKCFzKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpO2lmKDA9PT1lLmxlbmd0aClyZXR1cm4gbC5hbGxvYygwKTt2YXIgbjtpZih2b2lkIDA9PT10KWZvcihuPXQ9MDtuPGUubGVuZ3RoOysrbil0Kz1lW25dLmxlbmd0aDt2YXIgcj1sLmFsbG9jVW5zYWZlKHQpLGk9MDtmb3Iobj0wO248ZS5sZW5ndGg7KytuKXt2YXIgbz1lW25dO2lmKCFsLmlzQnVmZmVyKG8pKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpO28uY29weShyLGkpLGkrPW8ubGVuZ3RofXJldHVybiByfSxsLmJ5dGVMZW5ndGg9cCxsLnByb3RvdHlwZS5faXNCdWZmZXI9ITAsbC5wcm90b3R5cGUuc3dhcDE2PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZSUyIT0wKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHNcIik7Zm9yKHZhciB0PTA7dDxlO3QrPTIpZCh0aGlzLHQsdCsxKTtyZXR1cm4gdGhpc30sbC5wcm90b3R5cGUuc3dhcDMyPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZSU0IT0wKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHNcIik7Zm9yKHZhciB0PTA7dDxlO3QrPTQpZCh0aGlzLHQsdCszKSxkKHRoaXMsdCsxLHQrMik7cmV0dXJuIHRoaXN9LGwucHJvdG90eXBlLnN3YXA2ND1mdW5jdGlvbigpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGUlOCE9MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzXCIpO2Zvcih2YXIgdD0wO3Q8ZTt0Kz04KWQodGhpcyx0LHQrNyksZCh0aGlzLHQrMSx0KzYpLGQodGhpcyx0KzIsdCs1KSxkKHRoaXMsdCszLHQrNCk7cmV0dXJuIHRoaXN9LGwucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGU9MHx0aGlzLmxlbmd0aDtyZXR1cm4gMD09ZT9cIlwiOjA9PT1hcmd1bWVudHMubGVuZ3RoP18odGhpcywwLGUpOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcj0hMTtpZigodm9pZCAwPT09dHx8dDwwKSYmKHQ9MCksdD50aGlzLmxlbmd0aClyZXR1cm5cIlwiO2lmKCh2b2lkIDA9PT1ufHxuPnRoaXMubGVuZ3RoKSYmKG49dGhpcy5sZW5ndGgpLG48PTApcmV0dXJuXCJcIjtpZigobj4+Pj0wKTw9KHQ+Pj49MCkpcmV0dXJuXCJcIjtmb3IoZT1lfHxcInV0ZjhcIjs7KXN3aXRjaChlKXtjYXNlXCJoZXhcIjpyZXR1cm4gVCh0aGlzLHQsbik7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIF8odGhpcyx0LG4pO2Nhc2VcImFzY2lpXCI6cmV0dXJuIFAodGhpcyx0LG4pO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiB3KHRoaXMsdCxuKTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gbSh0aGlzLHQsbik7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIE8odGhpcyx0LG4pO2RlZmF1bHQ6aWYocil0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrZSk7ZT0oZStcIlwiKS50b0xvd2VyQ2FzZSgpLHI9ITB9fS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGwucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbihlKXtpZighbC5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlclwiKTtyZXR1cm4gdGhpcz09PWV8fDA9PT1sLmNvbXBhcmUodGhpcyxlKX0sbC5wcm90b3R5cGUuaW5zcGVjdD1mdW5jdGlvbigpe3ZhciBlPVwiXCIsdD1JLklOU1BFQ1RfTUFYX0JZVEVTO3JldHVybiAwPHRoaXMubGVuZ3RoJiYoZT10aGlzLnRvU3RyaW5nKFwiaGV4XCIsMCx0KS5tYXRjaCgvLnsyfS9nKS5qb2luKFwiIFwiKSx0aGlzLmxlbmd0aD50JiYoZSs9XCIgLi4uIFwiKSksXCI8QnVmZmVyIFwiK2UrXCI+XCJ9LGwucHJvdG90eXBlLmNvbXBhcmU9ZnVuY3Rpb24oZSx0LG4scixpKXtpZighbC5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlclwiKTtpZih2b2lkIDA9PT10JiYodD0wKSx2b2lkIDA9PT1uJiYobj1lP2UubGVuZ3RoOjApLHZvaWQgMD09PXImJihyPTApLHZvaWQgMD09PWkmJihpPXRoaXMubGVuZ3RoKSx0PDB8fG4+ZS5sZW5ndGh8fHI8MHx8aT50aGlzLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm91dCBvZiByYW5nZSBpbmRleFwiKTtpZihpPD1yJiZuPD10KXJldHVybiAwO2lmKGk8PXIpcmV0dXJuLTE7aWYobjw9dClyZXR1cm4gMTtpZih0aGlzPT09ZSlyZXR1cm4gMDtmb3IodmFyIG89KGk+Pj49MCktKHI+Pj49MCkscz0obj4+Pj0wKS0odD4+Pj0wKSxhPU1hdGgubWluKG8scyksdT10aGlzLnNsaWNlKHIsaSksYz1lLnNsaWNlKHQsbiksZj0wO2Y8YTsrK2YpaWYodVtmXSE9PWNbZl0pe289dVtmXSxzPWNbZl07YnJlYWt9cmV0dXJuIG88cz8tMTpzPG8/MTowfSxsLnByb3RvdHlwZS5pbmNsdWRlcz1mdW5jdGlvbihlLHQsbil7cmV0dXJuLTEhPT10aGlzLmluZGV4T2YoZSx0LG4pfSxsLnByb3RvdHlwZS5pbmRleE9mPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZyh0aGlzLGUsdCxuLCEwKX0sbC5wcm90b3R5cGUubGFzdEluZGV4T2Y9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBnKHRoaXMsZSx0LG4sITEpfSxsLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbihlLHQsbixyKXtpZih2b2lkIDA9PT10KXI9XCJ1dGY4XCIsbj10aGlzLmxlbmd0aCx0PTA7ZWxzZSBpZih2b2lkIDA9PT1uJiZcInN0cmluZ1wiPT10eXBlb2YgdClyPXQsbj10aGlzLmxlbmd0aCx0PTA7ZWxzZXtpZighaXNGaW5pdGUodCkpdGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWRcIik7dHw9MCxpc0Zpbml0ZShuKT8obnw9MCx2b2lkIDA9PT1yJiYocj1cInV0ZjhcIikpOihyPW4sbj12b2lkIDApfXZhciBpPXRoaXMubGVuZ3RoLXQ7aWYoKHZvaWQgMD09PW58fGk8bikmJihuPWkpLDA8ZS5sZW5ndGgmJihuPDB8fHQ8MCl8fHQ+dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kc1wiKTtyPXJ8fFwidXRmOFwiO2Zvcih2YXIgbyxzLGEsdSxjLGYsbCxoLHAsZD0hMTs7KXN3aXRjaChyKXtjYXNlXCJoZXhcIjpyZXR1cm4gdih0aGlzLGUsdCxuKTtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gaD10LHA9bixCKHgoZSwobD10aGlzKS5sZW5ndGgtaCksbCxoLHApO2Nhc2VcImFzY2lpXCI6cmV0dXJuIGIodGhpcyxlLHQsbik7Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIGIodGhpcyxlLHQsbik7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIHU9dGhpcyxjPXQsZj1uLEIoVShlKSx1LGMsZik7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIHM9dCxhPW4sQihmdW5jdGlvbihlLHQpe2Zvcih2YXIgbixyLGksbz1bXSxzPTA7czxlLmxlbmd0aCYmISgodC09Mik8MCk7KytzKW49ZS5jaGFyQ29kZUF0KHMpLHI9bj4+OCxpPW4lMjU2LG8ucHVzaChpKSxvLnB1c2gocik7cmV0dXJuIG99KGUsKG89dGhpcykubGVuZ3RoLXMpLG8scyxhKTtkZWZhdWx0OmlmKGQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK3IpO3I9KFwiXCIrcikudG9Mb3dlckNhc2UoKSxkPSEwfX0sbC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6XCJCdWZmZXJcIixkYXRhOkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2Fycnx8dGhpcywwKX19O3ZhciBrPTQwOTY7ZnVuY3Rpb24gUChlLHQsbil7dmFyIHI9XCJcIjtuPU1hdGgubWluKGUubGVuZ3RoLG4pO2Zvcih2YXIgaT10O2k8bjsrK2kpcis9U3RyaW5nLmZyb21DaGFyQ29kZSgxMjcmZVtpXSk7cmV0dXJuIHJ9ZnVuY3Rpb24gdyhlLHQsbil7dmFyIHI9XCJcIjtuPU1hdGgubWluKGUubGVuZ3RoLG4pO2Zvcih2YXIgaT10O2k8bjsrK2kpcis9U3RyaW5nLmZyb21DaGFyQ29kZShlW2ldKTtyZXR1cm4gcn1mdW5jdGlvbiBUKGUsdCxuKXt2YXIgcj1lLmxlbmd0aDsoIXR8fHQ8MCkmJih0PTApLCghbnx8bjwwfHxyPG4pJiYobj1yKTtmb3IodmFyIGk9XCJcIixvPXQ7bzxuOysrbylpKz1OKGVbb10pO3JldHVybiBpfWZ1bmN0aW9uIE8oZSx0LG4pe2Zvcih2YXIgcj1lLnNsaWNlKHQsbiksaT1cIlwiLG89MDtvPHIubGVuZ3RoO28rPTIpaSs9U3RyaW5nLmZyb21DaGFyQ29kZShyW29dKzI1NipyW28rMV0pO3JldHVybiBpfWZ1bmN0aW9uIFMoZSx0LG4pe2lmKGUlMSE9MHx8ZTwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwib2Zmc2V0IGlzIG5vdCB1aW50XCIpO2lmKG48ZSt0KXRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKX1mdW5jdGlvbiBNKGUsdCxuLHIsaSxvKXtpZighbC5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTtpZihpPHR8fHQ8byl0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKTtpZihuK3I+ZS5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9ZnVuY3Rpb24gRShlLHQsbixyKXt0PDAmJih0PTY1NTM1K3QrMSk7Zm9yKHZhciBpPTAsbz1NYXRoLm1pbihlLmxlbmd0aC1uLDIpO2k8bzsrK2kpZVtuK2ldPSh0JjI1NTw8OCoocj9pOjEtaSkpPj4+OCoocj9pOjEtaSl9ZnVuY3Rpb24gQShlLHQsbixyKXt0PDAmJih0PTQyOTQ5NjcyOTUrdCsxKTtmb3IodmFyIGk9MCxvPU1hdGgubWluKGUubGVuZ3RoLW4sNCk7aTxvOysraSllW24raV09dD4+PjgqKHI/aTozLWkpJjI1NX1mdW5jdGlvbiBDKGUsdCxuLHIpe2lmKG4rcj5lLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtpZihuPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9ZnVuY3Rpb24gUihlLHQsbixyLGkpe3JldHVybiBpfHxDKGUsMCxuLDQpLG8ud3JpdGUoZSx0LG4sciwyMyw0KSxuKzR9ZnVuY3Rpb24gaihlLHQsbixyLGkpe3JldHVybiBpfHxDKGUsMCxuLDgpLG8ud3JpdGUoZSx0LG4sciw1Miw4KSxuKzh9bC5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24oZSx0KXt2YXIgbixyPXRoaXMubGVuZ3RoO2lmKChlPX5+ZSk8MD8oZSs9cik8MCYmKGU9MCk6cjxlJiYoZT1yKSwodD12b2lkIDA9PT10P3I6fn50KTwwPyh0Kz1yKTwwJiYodD0wKTpyPHQmJih0PXIpLHQ8ZSYmKHQ9ZSksbC5UWVBFRF9BUlJBWV9TVVBQT1JUKShuPXRoaXMuc3ViYXJyYXkoZSx0KSkuX19wcm90b19fPWwucHJvdG90eXBlO2Vsc2V7dmFyIGk9dC1lO249bmV3IGwoaSx2b2lkIDApO2Zvcih2YXIgbz0wO288aTsrK28pbltvXT10aGlzW28rZV19cmV0dXJuIG59LGwucHJvdG90eXBlLnJlYWRVSW50TEU9ZnVuY3Rpb24oZSx0LG4pe2V8PTAsdHw9MCxufHxTKGUsdCx0aGlzLmxlbmd0aCk7Zm9yKHZhciByPXRoaXNbZV0saT0xLG89MDsrK288dCYmKGkqPTI1Nik7KXIrPXRoaXNbZStvXSppO3JldHVybiByfSxsLnByb3RvdHlwZS5yZWFkVUludEJFPWZ1bmN0aW9uKGUsdCxuKXtlfD0wLHR8PTAsbnx8UyhlLHQsdGhpcy5sZW5ndGgpO2Zvcih2YXIgcj10aGlzW2UrLS10XSxpPTE7MDx0JiYoaSo9MjU2KTspcis9dGhpc1tlKy0tdF0qaTtyZXR1cm4gcn0sbC5wcm90b3R5cGUucmVhZFVJbnQ4PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR8fFMoZSwxLHRoaXMubGVuZ3RoKSx0aGlzW2VdfSxsLnByb3RvdHlwZS5yZWFkVUludDE2TEU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHx8UyhlLDIsdGhpcy5sZW5ndGgpLHRoaXNbZV18dGhpc1tlKzFdPDw4fSxsLnByb3RvdHlwZS5yZWFkVUludDE2QkU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHx8UyhlLDIsdGhpcy5sZW5ndGgpLHRoaXNbZV08PDh8dGhpc1tlKzFdfSxsLnByb3RvdHlwZS5yZWFkVUludDMyTEU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHx8UyhlLDQsdGhpcy5sZW5ndGgpLCh0aGlzW2VdfHRoaXNbZSsxXTw8OHx0aGlzW2UrMl08PDE2KSsxNjc3NzIxNip0aGlzW2UrM119LGwucHJvdG90eXBlLnJlYWRVSW50MzJCRT1mdW5jdGlvbihlLHQpe3JldHVybiB0fHxTKGUsNCx0aGlzLmxlbmd0aCksMTY3NzcyMTYqdGhpc1tlXSsodGhpc1tlKzFdPDwxNnx0aGlzW2UrMl08PDh8dGhpc1tlKzNdKX0sbC5wcm90b3R5cGUucmVhZEludExFPWZ1bmN0aW9uKGUsdCxuKXtlfD0wLHR8PTAsbnx8UyhlLHQsdGhpcy5sZW5ndGgpO2Zvcih2YXIgcj10aGlzW2VdLGk9MSxvPTA7KytvPHQmJihpKj0yNTYpOylyKz10aGlzW2Urb10qaTtyZXR1cm4oaSo9MTI4KTw9ciYmKHItPU1hdGgucG93KDIsOCp0KSkscn0sbC5wcm90b3R5cGUucmVhZEludEJFPWZ1bmN0aW9uKGUsdCxuKXtlfD0wLHR8PTAsbnx8UyhlLHQsdGhpcy5sZW5ndGgpO2Zvcih2YXIgcj10LGk9MSxvPXRoaXNbZSstLXJdOzA8ciYmKGkqPTI1Nik7KW8rPXRoaXNbZSstLXJdKmk7cmV0dXJuKGkqPTEyOCk8PW8mJihvLT1NYXRoLnBvdygyLDgqdCkpLG99LGwucHJvdG90eXBlLnJlYWRJbnQ4PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR8fFMoZSwxLHRoaXMubGVuZ3RoKSwxMjgmdGhpc1tlXT8tMSooMjU1LXRoaXNbZV0rMSk6dGhpc1tlXX0sbC5wcm90b3R5cGUucmVhZEludDE2TEU9ZnVuY3Rpb24oZSx0KXt0fHxTKGUsMix0aGlzLmxlbmd0aCk7dmFyIG49dGhpc1tlXXx0aGlzW2UrMV08PDg7cmV0dXJuIDMyNzY4Jm4/NDI5NDkwMTc2MHxuOm59LGwucHJvdG90eXBlLnJlYWRJbnQxNkJFPWZ1bmN0aW9uKGUsdCl7dHx8UyhlLDIsdGhpcy5sZW5ndGgpO3ZhciBuPXRoaXNbZSsxXXx0aGlzW2VdPDw4O3JldHVybiAzMjc2OCZuPzQyOTQ5MDE3NjB8bjpufSxsLnByb3RvdHlwZS5yZWFkSW50MzJMRT1mdW5jdGlvbihlLHQpe3JldHVybiB0fHxTKGUsNCx0aGlzLmxlbmd0aCksdGhpc1tlXXx0aGlzW2UrMV08PDh8dGhpc1tlKzJdPDwxNnx0aGlzW2UrM108PDI0fSxsLnByb3RvdHlwZS5yZWFkSW50MzJCRT1mdW5jdGlvbihlLHQpe3JldHVybiB0fHxTKGUsNCx0aGlzLmxlbmd0aCksdGhpc1tlXTw8MjR8dGhpc1tlKzFdPDwxNnx0aGlzW2UrMl08PDh8dGhpc1tlKzNdfSxsLnByb3RvdHlwZS5yZWFkRmxvYXRMRT1mdW5jdGlvbihlLHQpe3JldHVybiB0fHxTKGUsNCx0aGlzLmxlbmd0aCksby5yZWFkKHRoaXMsZSwhMCwyMyw0KX0sbC5wcm90b3R5cGUucmVhZEZsb2F0QkU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHx8UyhlLDQsdGhpcy5sZW5ndGgpLG8ucmVhZCh0aGlzLGUsITEsMjMsNCl9LGwucHJvdG90eXBlLnJlYWREb3VibGVMRT1mdW5jdGlvbihlLHQpe3JldHVybiB0fHxTKGUsOCx0aGlzLmxlbmd0aCksby5yZWFkKHRoaXMsZSwhMCw1Miw4KX0sbC5wcm90b3R5cGUucmVhZERvdWJsZUJFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR8fFMoZSw4LHRoaXMubGVuZ3RoKSxvLnJlYWQodGhpcyxlLCExLDUyLDgpfSxsLnByb3RvdHlwZS53cml0ZVVJbnRMRT1mdW5jdGlvbihlLHQsbixyKXtlPStlLHR8PTAsbnw9MCxyfHxNKHRoaXMsZSx0LG4sTWF0aC5wb3coMiw4Km4pLTEsMCk7dmFyIGk9MSxvPTA7Zm9yKHRoaXNbdF09MjU1JmU7KytvPG4mJihpKj0yNTYpOyl0aGlzW3Qrb109ZS9pJjI1NTtyZXR1cm4gdCtufSxsLnByb3RvdHlwZS53cml0ZVVJbnRCRT1mdW5jdGlvbihlLHQsbixyKXtlPStlLHR8PTAsbnw9MCxyfHxNKHRoaXMsZSx0LG4sTWF0aC5wb3coMiw4Km4pLTEsMCk7dmFyIGk9bi0xLG89MTtmb3IodGhpc1t0K2ldPTI1NSZlOzA8PS0taSYmKG8qPTI1Nik7KXRoaXNbdCtpXT1lL28mMjU1O3JldHVybiB0K259LGwucHJvdG90eXBlLndyaXRlVUludDg9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlPStlLHR8PTAsbnx8TSh0aGlzLGUsdCwxLDI1NSwwKSxsLlRZUEVEX0FSUkFZX1NVUFBPUlR8fChlPU1hdGguZmxvb3IoZSkpLHRoaXNbdF09MjU1JmUsdCsxfSxsLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZT0rZSx0fD0wLG58fE0odGhpcyxlLHQsMiw2NTUzNSwwKSxsLlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbdF09MjU1JmUsdGhpc1t0KzFdPWU+Pj44KTpFKHRoaXMsZSx0LCEwKSx0KzJ9LGwucHJvdG90eXBlLndyaXRlVUludDE2QkU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlPStlLHR8PTAsbnx8TSh0aGlzLGUsdCwyLDY1NTM1LDApLGwuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1t0XT1lPj4+OCx0aGlzW3QrMV09MjU1JmUpOkUodGhpcyxlLHQsITEpLHQrMn0sbC5wcm90b3R5cGUud3JpdGVVSW50MzJMRT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGU9K2UsdHw9MCxufHxNKHRoaXMsZSx0LDQsNDI5NDk2NzI5NSwwKSxsLlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbdCszXT1lPj4+MjQsdGhpc1t0KzJdPWU+Pj4xNix0aGlzW3QrMV09ZT4+PjgsdGhpc1t0XT0yNTUmZSk6QSh0aGlzLGUsdCwhMCksdCs0fSxsLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZT0rZSx0fD0wLG58fE0odGhpcyxlLHQsNCw0Mjk0OTY3Mjk1LDApLGwuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1t0XT1lPj4+MjQsdGhpc1t0KzFdPWU+Pj4xNix0aGlzW3QrMl09ZT4+PjgsdGhpc1t0KzNdPTI1NSZlKTpBKHRoaXMsZSx0LCExKSx0KzR9LGwucHJvdG90eXBlLndyaXRlSW50TEU9ZnVuY3Rpb24oZSx0LG4scil7aWYoZT0rZSx0fD0wLCFyKXt2YXIgaT1NYXRoLnBvdygyLDgqbi0xKTtNKHRoaXMsZSx0LG4saS0xLC1pKX12YXIgbz0wLHM9MSxhPTA7Zm9yKHRoaXNbdF09MjU1JmU7KytvPG4mJihzKj0yNTYpOyllPDAmJjA9PT1hJiYwIT09dGhpc1t0K28tMV0mJihhPTEpLHRoaXNbdCtvXT0oZS9zPj4wKS1hJjI1NTtyZXR1cm4gdCtufSxsLnByb3RvdHlwZS53cml0ZUludEJFPWZ1bmN0aW9uKGUsdCxuLHIpe2lmKGU9K2UsdHw9MCwhcil7dmFyIGk9TWF0aC5wb3coMiw4Km4tMSk7TSh0aGlzLGUsdCxuLGktMSwtaSl9dmFyIG89bi0xLHM9MSxhPTA7Zm9yKHRoaXNbdCtvXT0yNTUmZTswPD0tLW8mJihzKj0yNTYpOyllPDAmJjA9PT1hJiYwIT09dGhpc1t0K28rMV0mJihhPTEpLHRoaXNbdCtvXT0oZS9zPj4wKS1hJjI1NTtyZXR1cm4gdCtufSxsLnByb3RvdHlwZS53cml0ZUludDg9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlPStlLHR8PTAsbnx8TSh0aGlzLGUsdCwxLDEyNywtMTI4KSxsLlRZUEVEX0FSUkFZX1NVUFBPUlR8fChlPU1hdGguZmxvb3IoZSkpLGU8MCYmKGU9MjU1K2UrMSksdGhpc1t0XT0yNTUmZSx0KzF9LGwucHJvdG90eXBlLndyaXRlSW50MTZMRT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGU9K2UsdHw9MCxufHxNKHRoaXMsZSx0LDIsMzI3NjcsLTMyNzY4KSxsLlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbdF09MjU1JmUsdGhpc1t0KzFdPWU+Pj44KTpFKHRoaXMsZSx0LCEwKSx0KzJ9LGwucHJvdG90eXBlLndyaXRlSW50MTZCRT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGU9K2UsdHw9MCxufHxNKHRoaXMsZSx0LDIsMzI3NjcsLTMyNzY4KSxsLlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbdF09ZT4+PjgsdGhpc1t0KzFdPTI1NSZlKTpFKHRoaXMsZSx0LCExKSx0KzJ9LGwucHJvdG90eXBlLndyaXRlSW50MzJMRT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGU9K2UsdHw9MCxufHxNKHRoaXMsZSx0LDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCksbC5UWVBFRF9BUlJBWV9TVVBQT1JUPyh0aGlzW3RdPTI1NSZlLHRoaXNbdCsxXT1lPj4+OCx0aGlzW3QrMl09ZT4+PjE2LHRoaXNbdCszXT1lPj4+MjQpOkEodGhpcyxlLHQsITApLHQrNH0sbC5wcm90b3R5cGUud3JpdGVJbnQzMkJFPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZT0rZSx0fD0wLG58fE0odGhpcyxlLHQsNCwyMTQ3NDgzNjQ3LC0yMTQ3NDgzNjQ4KSxlPDAmJihlPTQyOTQ5NjcyOTUrZSsxKSxsLlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbdF09ZT4+PjI0LHRoaXNbdCsxXT1lPj4+MTYsdGhpc1t0KzJdPWU+Pj44LHRoaXNbdCszXT0yNTUmZSk6QSh0aGlzLGUsdCwhMSksdCs0fSxsLnByb3RvdHlwZS53cml0ZUZsb2F0TEU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBSKHRoaXMsZSx0LCEwLG4pfSxsLnByb3RvdHlwZS53cml0ZUZsb2F0QkU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBSKHRoaXMsZSx0LCExLG4pfSxsLnByb3RvdHlwZS53cml0ZURvdWJsZUxFPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gaih0aGlzLGUsdCwhMCxuKX0sbC5wcm90b3R5cGUud3JpdGVEb3VibGVCRT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGoodGhpcyxlLHQsITEsbil9LGwucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24oZSx0LG4scil7aWYobj1ufHwwLHJ8fDA9PT1yfHwocj10aGlzLmxlbmd0aCksdD49ZS5sZW5ndGgmJih0PWUubGVuZ3RoKSx0PXR8fDAsMDxyJiZyPG4mJihyPW4pLHI9PT1uKXJldHVybiAwO2lmKDA9PT1lLmxlbmd0aHx8MD09PXRoaXMubGVuZ3RoKXJldHVybiAwO2lmKHQ8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInRhcmdldFN0YXJ0IG91dCBvZiBib3VuZHNcIik7aWYobjwwfHxuPj10aGlzLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInNvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHNcIik7aWYocjwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwic291cmNlRW5kIG91dCBvZiBib3VuZHNcIik7cj50aGlzLmxlbmd0aCYmKHI9dGhpcy5sZW5ndGgpLGUubGVuZ3RoLXQ8ci1uJiYocj1lLmxlbmd0aC10K24pO3ZhciBpLG89ci1uO2lmKHRoaXM9PT1lJiZuPHQmJnQ8cilmb3IoaT1vLTE7MDw9aTstLWkpZVtpK3RdPXRoaXNbaStuXTtlbHNlIGlmKG88MWUzfHwhbC5UWVBFRF9BUlJBWV9TVVBQT1JUKWZvcihpPTA7aTxvOysraSllW2krdF09dGhpc1tpK25dO2Vsc2UgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoZSx0aGlzLnN1YmFycmF5KG4sbitvKSx0KTtyZXR1cm4gb30sbC5wcm90b3R5cGUuZmlsbD1mdW5jdGlvbihlLHQsbixyKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQ/KHI9dCx0PTAsbj10aGlzLmxlbmd0aCk6XCJzdHJpbmdcIj09dHlwZW9mIG4mJihyPW4sbj10aGlzLmxlbmd0aCksMT09PWUubGVuZ3RoKXt2YXIgaT1lLmNoYXJDb2RlQXQoMCk7aTwyNTYmJihlPWkpfWlmKHZvaWQgMCE9PXImJlwic3RyaW5nXCIhPXR5cGVvZiByKXRocm93IG5ldyBUeXBlRXJyb3IoXCJlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nXCIpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiByJiYhbC5pc0VuY29kaW5nKHIpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIityKX1lbHNlXCJudW1iZXJcIj09dHlwZW9mIGUmJihlJj0yNTUpO2lmKHQ8MHx8dGhpcy5sZW5ndGg8dHx8dGhpcy5sZW5ndGg8bil0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk91dCBvZiByYW5nZSBpbmRleFwiKTtpZihuPD10KXJldHVybiB0aGlzO3ZhciBvO2lmKHQ+Pj49MCxuPXZvaWQgMD09PW4/dGhpcy5sZW5ndGg6bj4+PjAsXCJudW1iZXJcIj09dHlwZW9mKGU9ZXx8MCkpZm9yKG89dDtvPG47KytvKXRoaXNbb109ZTtlbHNle3ZhciBzPWwuaXNCdWZmZXIoZSk/ZTp4KG5ldyBsKGUscikudG9TdHJpbmcoKSksYT1zLmxlbmd0aDtmb3Iobz0wO288bi10Oysrbyl0aGlzW28rdF09c1tvJWFdfXJldHVybiB0aGlzfTt2YXIgdD0vW14rXFwvMC05QS1aYS16LV9dL2c7ZnVuY3Rpb24gTihlKXtyZXR1cm4gZTwxNj9cIjBcIitlLnRvU3RyaW5nKDE2KTplLnRvU3RyaW5nKDE2KX1mdW5jdGlvbiB4KGUsdCl7dmFyIG47dD10fHwxLzA7Zm9yKHZhciByPWUubGVuZ3RoLGk9bnVsbCxvPVtdLHM9MDtzPHI7KytzKXtpZig1NTI5NTwobj1lLmNoYXJDb2RlQXQocykpJiZuPDU3MzQ0KXtpZighaSl7aWYoNTYzMTk8bil7LTE8KHQtPTMpJiZvLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfWlmKHMrMT09PXIpey0xPCh0LT0zKSYmby5wdXNoKDIzOSwxOTEsMTg5KTtjb250aW51ZX1pPW47Y29udGludWV9aWYobjw1NjMyMCl7LTE8KHQtPTMpJiZvLnB1c2goMjM5LDE5MSwxODkpLGk9bjtjb250aW51ZX1uPTY1NTM2KyhpLTU1Mjk2PDwxMHxuLTU2MzIwKX1lbHNlIGkmJi0xPCh0LT0zKSYmby5wdXNoKDIzOSwxOTEsMTg5KTtpZihpPW51bGwsbjwxMjgpe2lmKCh0LT0xKTwwKWJyZWFrO28ucHVzaChuKX1lbHNlIGlmKG48MjA0OCl7aWYoKHQtPTIpPDApYnJlYWs7by5wdXNoKG4+PjZ8MTkyLDYzJm58MTI4KX1lbHNlIGlmKG48NjU1MzYpe2lmKCh0LT0zKTwwKWJyZWFrO28ucHVzaChuPj4xMnwyMjQsbj4+NiY2M3wxMjgsNjMmbnwxMjgpfWVsc2V7aWYoIShuPDExMTQxMTIpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29kZSBwb2ludFwiKTtpZigodC09NCk8MClicmVhaztvLnB1c2gobj4+MTh8MjQwLG4+PjEyJjYzfDEyOCxuPj42JjYzfDEyOCw2MyZufDEyOCl9fXJldHVybiBvfWZ1bmN0aW9uIFUoZSl7cmV0dXJuIHIudG9CeXRlQXJyYXkoZnVuY3Rpb24oZSl7aWYoKGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGUudHJpbT9lLnRyaW0oKTplLnJlcGxhY2UoL15cXHMrfFxccyskL2csXCJcIil9KGUpLnJlcGxhY2UodCxcIlwiKSkubGVuZ3RoPDIpcmV0dXJuXCJcIjtmb3IoO2UubGVuZ3RoJTQhPTA7KWUrPVwiPVwiO3JldHVybiBlfShlKSl9ZnVuY3Rpb24gQihlLHQsbixyKXtmb3IodmFyIGk9MDtpPHImJiEoaStuPj10Lmxlbmd0aHx8aT49ZS5sZW5ndGgpOysraSl0W2krbl09ZVtpXTtyZXR1cm4gaX19KS5jYWxsKHRoaXMsRCg3MCkpfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBudWxsIT09ZSYmXCJvYmplY3RcIj09dHlwZW9mIGV9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PXZvaWQgMDt2YXIgcj11KG4oMTIpKSxpPXUobig2NykpLG89dShuKDY4KSkscz11KG4oNjkpKSxhPW4oNzUpO24oMCk7ZnVuY3Rpb24gdShlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gYyhlKXtyZXR1cm4oYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfSkoZSl9ZnVuY3Rpb24gZihlLHQpe3JldHVybiF0fHxcIm9iamVjdFwiIT09Yyh0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9mdW5jdGlvbihlKXtpZih2b2lkIDAhPT1lKXJldHVybiBlO3Rocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKX0oZSk6dH1mdW5jdGlvbiBsKGUpe3JldHVybihsPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSl9KShlKX1mdW5jdGlvbiBoKGUsdCl7cmV0dXJuKGg9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbihlLHQpe3JldHVybiBlLl9fcHJvdG9fXz10LGV9KShlLHQpfWZ1bmN0aW9uIHAoZSl7aWYoIW5hdmlnYXRvcnx8IW5hdmlnYXRvci5zZW5kQmVhY29uKXJldHVybiExO25hdmlnYXRvci5zZW5kQmVhY29uKGUpfXZhciBkPShmdW5jdGlvbihlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmaChlLHQpfShnLHIuZGVmYXVsdCksZyk7ZnVuY3Rpb24gZyhlKXt2YXIgdDshZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGcpO3ZhciBuPWUubGlzdGVuVG9Ccm93c2VyTmV0d29ya0V2ZW50cyxyPXZvaWQgMD09PW58fG47cmV0dXJuIGUuZGI9by5kZWZhdWx0LGUuY2Jvcj1uZXcgcy5kZWZhdWx0LGUuc2RrRmFtaWx5PVwiV2ViXCIsZS5uZXR3b3JraW5nPW5ldyBpLmRlZmF1bHQoe2RlbDphLmRlbCxnZXQ6YS5nZXQscG9zdDphLnBvc3QscGF0Y2g6YS5wYXRjaCxzZW5kQmVhY29uOnB9KSx0PWYodGhpcyxsKGcpLmNhbGwodGhpcyxlKSksciYmKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLGZ1bmN0aW9uKCl7dC5uZXR3b3JrRG93bkRldGVjdGVkKCl9KSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLGZ1bmN0aW9uKCl7dC5uZXR3b3JrVXBEZXRlY3RlZCgpfSkpLHR9dC5kZWZhdWx0PWQsZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHMoZSl7cmV0dXJuKHM9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX0pKGUpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD12b2lkIDA7dmFyIHk9ZihuKDMpKSx2PWYobig2KSksYj1mKG4oMTUpKSxyPWYobigxOCkpLG09ZihuKDcpKSxfPWYobigxOSkpLGs9ZihuKDIwKSksUD1jKG4oMjEpKSx3PWMobigyMikpLFQ9YyhuKDIzKSksTz1jKG4oMjQpKSxTPWMobigyNSkpLE09YyhuKDI2KSksRT1jKG4oMjcpKSxBPWMobigyOCkpLEM9YyhuKDI5KSksUj1jKG4oMzApKSxqPWMobigzMSkpLE49YyhuKDMyKSkseD1jKG4oMzMpKSxVPWMobigzNCkpLEI9YyhuKDM1KSksST1jKG4oMzYpKSxEPWMobigzNykpLEs9YyhuKDM4KSksTD1jKG4oMzkpKSxGPWMobig0MCkpLEc9YyhuKDQxKSksSD1jKG4oNDIpKSxxPWMobig0MykpLHo9YyhuKDQ0KSksWT1jKG4oNDUpKSwkPWMobig0NikpLFc9YyhuKDQ3KSksSj1jKG4oNDgpKSxYPWMobig0OSkpLFY9YyhuKDUwKSksUT1jKG4oNTEpKSxaPWMobig1MikpLGVlPWMobig1MykpLHRlPWMobig1NCkpLG5lPWMobig1NSkpLHJlPWMobig1NikpLGllPWMobig1NykpLG9lPWMobig1OCkpLHNlPWMobig1OSkpLGFlPWMobig2MCkpLHVlPWMobig2MSkpLGNlPWMobig2MikpLGZlPWMobig2MykpLGxlPWMobig2NCkpLGhlPWMobig2NSkpLHBlPWMobig4KSksZGU9YyhuKDY2KSksaT1mKG4oMSkpLG89ZihuKDQpKSxhPShuKDApLGYobig1KSkpO2Z1bmN0aW9uIHUoKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWFrTWFwKXJldHVybiBudWxsO3ZhciBlPW5ldyBXZWFrTWFwO3JldHVybiB1PWZ1bmN0aW9uKCl7cmV0dXJuIGV9LGV9ZnVuY3Rpb24gYyhlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7aWYobnVsbD09PWV8fFwib2JqZWN0XCIhPT1zKGUpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlKXJldHVybntkZWZhdWx0OmV9O3ZhciB0PXUoKTtpZih0JiZ0LmhhcyhlKSlyZXR1cm4gdC5nZXQoZSk7dmFyIG49e30scj1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7Zm9yKHZhciBpIGluIGUpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsaSkpe3ZhciBvPXI/T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLGkpOm51bGw7byYmKG8uZ2V0fHxvLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KG4saSxvKTpuW2ldPWVbaV19cmV0dXJuIG4uZGVmYXVsdD1lLHQmJnQuc2V0KGUsbiksbn1mdW5jdGlvbiBmKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBsKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1mdW5jdGlvbiBnZShlLHQsbil7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1uLGV9dmFyIGgscCxkLGc9KGg9eWUsZD1be2tleTpcIm5vdGlmaWNhdGlvblBheWxvYWRcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiBuZXcgci5kZWZhdWx0KGUsdCl9fSx7a2V5OlwiZ2VuZXJhdGVVVUlEXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gYS5kZWZhdWx0LmNyZWF0ZVVVSUQoKX19XSwocD1be2tleTpcImdldFZlcnNpb25cIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jb25maWcuZ2V0VmVyc2lvbigpfX0se2tleTpcIl9hZGRQbnNka1N1ZmZpeFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dGhpcy5fY29uZmlnLl9hZGRQbnNka1N1ZmZpeChlLHQpfX0se2tleTpcIm5ldHdvcmtEb3duRGV0ZWN0ZWRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX2xpc3RlbmVyTWFuYWdlci5hbm5vdW5jZU5ldHdvcmtEb3duKCksdGhpcy5fY29uZmlnLnJlc3RvcmU/dGhpcy5kaXNjb25uZWN0KCk6dGhpcy5kZXN0cm95KCEwKX19LHtrZXk6XCJuZXR3b3JrVXBEZXRlY3RlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fbGlzdGVuZXJNYW5hZ2VyLmFubm91bmNlTmV0d29ya1VwKCksdGhpcy5yZWNvbm5lY3QoKX19XSkmJmwoaC5wcm90b3R5cGUscCksdm9pZChkJiZsKGgsZCkpLHllKTtmdW5jdGlvbiB5ZShlKXt2YXIgbj10aGlzOyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMseWUpLGdlKHRoaXMsXCJfY29uZmlnXCIsdm9pZCAwKSxnZSh0aGlzLFwiX2xpc3RlbmVyTWFuYWdlclwiLHZvaWQgMCksZ2UodGhpcyxcIl90b2tlbk1hbmFnZXJcIix2b2lkIDApLGdlKHRoaXMsXCJ0aW1lXCIsdm9pZCAwKSxnZSh0aGlzLFwicHVibGlzaFwiLHZvaWQgMCksZ2UodGhpcyxcImZpcmVcIix2b2lkIDApLGdlKHRoaXMsXCJoaXN0b3J5XCIsdm9pZCAwKSxnZSh0aGlzLFwiZGVsZXRlTWVzc2FnZXNcIix2b2lkIDApLGdlKHRoaXMsXCJtZXNzYWdlQ291bnRzXCIsdm9pZCAwKSxnZSh0aGlzLFwiZmV0Y2hNZXNzYWdlc1wiLHZvaWQgMCksZ2UodGhpcyxcImNoYW5uZWxHcm91cHNcIix2b2lkIDApLGdlKHRoaXMsXCJwdXNoXCIsdm9pZCAwKSxnZSh0aGlzLFwiaGVyZU5vd1wiLHZvaWQgMCksZ2UodGhpcyxcIndoZXJlTm93XCIsdm9pZCAwKSxnZSh0aGlzLFwiZ2V0U3RhdGVcIix2b2lkIDApLGdlKHRoaXMsXCJzZXRTdGF0ZVwiLHZvaWQgMCksZ2UodGhpcyxcImdyYW50XCIsdm9pZCAwKSxnZSh0aGlzLFwiZ3JhbnRUb2tlblwiLHZvaWQgMCksZ2UodGhpcyxcImF1ZGl0XCIsdm9pZCAwKSxnZSh0aGlzLFwic3Vic2NyaWJlXCIsdm9pZCAwKSxnZSh0aGlzLFwic2lnbmFsXCIsdm9pZCAwKSxnZSh0aGlzLFwicHJlc2VuY2VcIix2b2lkIDApLGdlKHRoaXMsXCJ1bnN1YnNjcmliZVwiLHZvaWQgMCksZ2UodGhpcyxcInVuc3Vic2NyaWJlQWxsXCIsdm9pZCAwKSxnZSh0aGlzLFwiYWRkTWVzc2FnZUFjdGlvblwiLHZvaWQgMCksZ2UodGhpcyxcInJlbW92ZU1lc3NhZ2VBY3Rpb25cIix2b2lkIDApLGdlKHRoaXMsXCJnZXRNZXNzYWdlQWN0aW9uc1wiLHZvaWQgMCksZ2UodGhpcyxcImNyZWF0ZVVzZXJcIix2b2lkIDApLGdlKHRoaXMsXCJ1cGRhdGVVc2VyXCIsdm9pZCAwKSxnZSh0aGlzLFwiZGVsZXRlVXNlclwiLHZvaWQgMCksZ2UodGhpcyxcImdldFVzZXJcIix2b2lkIDApLGdlKHRoaXMsXCJnZXRVc2Vyc1wiLHZvaWQgMCksZ2UodGhpcyxcImNyZWF0ZVNwYWNlXCIsdm9pZCAwKSxnZSh0aGlzLFwidXBkYXRlU3BhY2VcIix2b2lkIDApLGdlKHRoaXMsXCJkZWxldGVTcGFjZVwiLHZvaWQgMCksZ2UodGhpcyxcImdldFNwYWNlc1wiLHZvaWQgMCksZ2UodGhpcyxcImdldFNwYWNlXCIsdm9pZCAwKSxnZSh0aGlzLFwiZ2V0TWVtYmVyc1wiLHZvaWQgMCksZ2UodGhpcyxcImFkZE1lbWJlcnNcIix2b2lkIDApLGdlKHRoaXMsXCJ1cGRhdGVNZW1iZXJzXCIsdm9pZCAwKSxnZSh0aGlzLFwicmVtb3ZlTWVtYmVyc1wiLHZvaWQgMCksZ2UodGhpcyxcImdldE1lbWJlcnNoaXBzXCIsdm9pZCAwKSxnZSh0aGlzLFwiam9pblNwYWNlc1wiLHZvaWQgMCksZ2UodGhpcyxcInVwZGF0ZU1lbWJlcnNoaXBzXCIsdm9pZCAwKSxnZSh0aGlzLFwibGVhdmVTcGFjZXNcIix2b2lkIDApLGdlKHRoaXMsXCJkaXNjb25uZWN0XCIsdm9pZCAwKSxnZSh0aGlzLFwicmVjb25uZWN0XCIsdm9pZCAwKSxnZSh0aGlzLFwiZGVzdHJveVwiLHZvaWQgMCksZ2UodGhpcyxcInN0b3BcIix2b2lkIDApLGdlKHRoaXMsXCJnZXRTdWJzY3JpYmVkQ2hhbm5lbHNcIix2b2lkIDApLGdlKHRoaXMsXCJnZXRTdWJzY3JpYmVkQ2hhbm5lbEdyb3Vwc1wiLHZvaWQgMCksZ2UodGhpcyxcImFkZExpc3RlbmVyXCIsdm9pZCAwKSxnZSh0aGlzLFwicmVtb3ZlTGlzdGVuZXJcIix2b2lkIDApLGdlKHRoaXMsXCJyZW1vdmVBbGxMaXN0ZW5lcnNcIix2b2lkIDApLGdlKHRoaXMsXCJwYXJzZVRva2VuXCIsdm9pZCAwKSxnZSh0aGlzLFwic2V0VG9rZW5cIix2b2lkIDApLGdlKHRoaXMsXCJzZXRUb2tlbnNcIix2b2lkIDApLGdlKHRoaXMsXCJnZXRUb2tlblwiLHZvaWQgMCksZ2UodGhpcyxcImdldFRva2Vuc1wiLHZvaWQgMCksZ2UodGhpcyxcImNsZWFyVG9rZW5zXCIsdm9pZCAwKSxnZSh0aGlzLFwiZ2V0QXV0aEtleVwiLHZvaWQgMCksZ2UodGhpcyxcInNldEF1dGhLZXlcIix2b2lkIDApLGdlKHRoaXMsXCJzZXRDaXBoZXJLZXlcIix2b2lkIDApLGdlKHRoaXMsXCJzZXRVVUlEXCIsdm9pZCAwKSxnZSh0aGlzLFwiZ2V0VVVJRFwiLHZvaWQgMCksZ2UodGhpcyxcImdldEZpbHRlckV4cHJlc3Npb25cIix2b2lkIDApLGdlKHRoaXMsXCJzZXRGaWx0ZXJFeHByZXNzaW9uXCIsdm9pZCAwKSxnZSh0aGlzLFwic2V0SGVhcnRiZWF0SW50ZXJ2YWxcIix2b2lkIDApLGdlKHRoaXMsXCJzZXRQcm94eVwiLHZvaWQgMCksZ2UodGhpcyxcImVuY3J5cHRcIix2b2lkIDApLGdlKHRoaXMsXCJkZWNyeXB0XCIsdm9pZCAwKTt2YXIgdD1lLmRiLHI9ZS5uZXR3b3JraW5nLGk9ZS5jYm9yLG89dGhpcy5fY29uZmlnPW5ldyB5LmRlZmF1bHQoe3NldHVwOmUsZGI6dH0pLHM9bmV3IHYuZGVmYXVsdCh7Y29uZmlnOm99KTtyLmluaXQobyk7dmFyIGE9dGhpcy5fdG9rZW5NYW5hZ2VyPW5ldyBfLmRlZmF1bHQobyxpKSx1PXtjb25maWc6byxuZXR3b3JraW5nOnIsY3J5cHRvOnMsdG9rZW5NYW5hZ2VyOmF9LGM9ay5kZWZhdWx0LmJpbmQodGhpcyx1LHBlKSxmPWsuZGVmYXVsdC5iaW5kKHRoaXMsdSxSKSxsPWsuZGVmYXVsdC5iaW5kKHRoaXMsdSxOKSxoPWsuZGVmYXVsdC5iaW5kKHRoaXMsdSxVKSxwPWsuZGVmYXVsdC5iaW5kKHRoaXMsdSxkZSksZD10aGlzLl9saXN0ZW5lck1hbmFnZXI9bmV3IG0uZGVmYXVsdCxnPW5ldyBiLmRlZmF1bHQoe3RpbWVFbmRwb2ludDpjLGxlYXZlRW5kcG9pbnQ6ZixoZWFydGJlYXRFbmRwb2ludDpsLHNldFN0YXRlRW5kcG9pbnQ6aCxzdWJzY3JpYmVFbmRwb2ludDpwLGNyeXB0bzp1LmNyeXB0byxjb25maWc6dS5jb25maWcsbGlzdGVuZXJNYW5hZ2VyOmR9KTt0aGlzLmFkZExpc3RlbmVyPWQuYWRkTGlzdGVuZXIuYmluZChkKSx0aGlzLnJlbW92ZUxpc3RlbmVyPWQucmVtb3ZlTGlzdGVuZXIuYmluZChkKSx0aGlzLnJlbW92ZUFsbExpc3RlbmVycz1kLnJlbW92ZUFsbExpc3RlbmVycy5iaW5kKGQpLHRoaXMucGFyc2VUb2tlbj1hLnBhcnNlVG9rZW4uYmluZChhKSx0aGlzLnNldFRva2VuPWEuc2V0VG9rZW4uYmluZChhKSx0aGlzLnNldFRva2Vucz1hLnNldFRva2Vucy5iaW5kKGEpLHRoaXMuZ2V0VG9rZW49YS5nZXRUb2tlbi5iaW5kKGEpLHRoaXMuZ2V0VG9rZW5zPWEuZ2V0VG9rZW5zLmJpbmQoYSksdGhpcy5jbGVhclRva2Vucz1hLmNsZWFyVG9rZW5zLmJpbmQoYSksdGhpcy5jaGFubmVsR3JvdXBzPXtsaXN0R3JvdXBzOmsuZGVmYXVsdC5iaW5kKHRoaXMsdSxPKSxsaXN0Q2hhbm5lbHM6ay5kZWZhdWx0LmJpbmQodGhpcyx1LFMpLGFkZENoYW5uZWxzOmsuZGVmYXVsdC5iaW5kKHRoaXMsdSxQKSxyZW1vdmVDaGFubmVsczprLmRlZmF1bHQuYmluZCh0aGlzLHUsdyksZGVsZXRlR3JvdXA6ay5kZWZhdWx0LmJpbmQodGhpcyx1LFQpfSx0aGlzLnB1c2g9e2FkZENoYW5uZWxzOmsuZGVmYXVsdC5iaW5kKHRoaXMsdSxNKSxyZW1vdmVDaGFubmVsczprLmRlZmF1bHQuYmluZCh0aGlzLHUsRSksZGVsZXRlRGV2aWNlOmsuZGVmYXVsdC5iaW5kKHRoaXMsdSxDKSxsaXN0Q2hhbm5lbHM6ay5kZWZhdWx0LmJpbmQodGhpcyx1LEEpfSx0aGlzLmhlcmVOb3c9ay5kZWZhdWx0LmJpbmQodGhpcyx1LEIpLHRoaXMud2hlcmVOb3c9ay5kZWZhdWx0LmJpbmQodGhpcyx1LGopLHRoaXMuZ2V0U3RhdGU9ay5kZWZhdWx0LmJpbmQodGhpcyx1LHgpLHRoaXMuc2V0U3RhdGU9Zy5hZGFwdFN0YXRlQ2hhbmdlLmJpbmQoZyksdGhpcy5ncmFudD1rLmRlZmF1bHQuYmluZCh0aGlzLHUsb2UpLHRoaXMuZ3JhbnRUb2tlbj1rLmRlZmF1bHQuYmluZCh0aGlzLHUsc2UpLHRoaXMuYXVkaXQ9ay5kZWZhdWx0LmJpbmQodGhpcyx1LGllKSx0aGlzLnB1Ymxpc2g9ay5kZWZhdWx0LmJpbmQodGhpcyx1LGFlKSx0aGlzLmZpcmU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5yZXBsaWNhdGU9ITEsZS5zdG9yZUluSGlzdG9yeT0hMSxuLnB1Ymxpc2goZSx0KX0sdGhpcy5zaWduYWw9ay5kZWZhdWx0LmJpbmQodGhpcyx1LHVlKSx0aGlzLmhpc3Rvcnk9ay5kZWZhdWx0LmJpbmQodGhpcyx1LGNlKSx0aGlzLmRlbGV0ZU1lc3NhZ2VzPWsuZGVmYXVsdC5iaW5kKHRoaXMsdSxmZSksdGhpcy5tZXNzYWdlQ291bnRzPWsuZGVmYXVsdC5iaW5kKHRoaXMsdSxsZSksdGhpcy5mZXRjaE1lc3NhZ2VzPWsuZGVmYXVsdC5iaW5kKHRoaXMsdSxoZSksdGhpcy5hZGRNZXNzYWdlQWN0aW9uPWsuZGVmYXVsdC5iaW5kKHRoaXMsdSxJKSx0aGlzLnJlbW92ZU1lc3NhZ2VBY3Rpb249ay5kZWZhdWx0LmJpbmQodGhpcyx1LEQpLHRoaXMuZ2V0TWVzc2FnZUFjdGlvbnM9ay5kZWZhdWx0LmJpbmQodGhpcyx1LEspLHRoaXMuY3JlYXRlVXNlcj1rLmRlZmF1bHQuYmluZCh0aGlzLHUsTCksdGhpcy51cGRhdGVVc2VyPWsuZGVmYXVsdC5iaW5kKHRoaXMsdSxGKSx0aGlzLmRlbGV0ZVVzZXI9ay5kZWZhdWx0LmJpbmQodGhpcyx1LEcpLHRoaXMuZ2V0VXNlcj1rLmRlZmF1bHQuYmluZCh0aGlzLHUsSCksdGhpcy5nZXRVc2Vycz1rLmRlZmF1bHQuYmluZCh0aGlzLHUscSksdGhpcy5jcmVhdGVTcGFjZT1rLmRlZmF1bHQuYmluZCh0aGlzLHUseiksdGhpcy51cGRhdGVTcGFjZT1rLmRlZmF1bHQuYmluZCh0aGlzLHUsWSksdGhpcy5kZWxldGVTcGFjZT1rLmRlZmF1bHQuYmluZCh0aGlzLHUsJCksdGhpcy5nZXRTcGFjZXM9ay5kZWZhdWx0LmJpbmQodGhpcyx1LFcpLHRoaXMuZ2V0U3BhY2U9ay5kZWZhdWx0LmJpbmQodGhpcyx1LEopLHRoaXMuYWRkTWVtYmVycz1rLmRlZmF1bHQuYmluZCh0aGlzLHUsViksdGhpcy51cGRhdGVNZW1iZXJzPWsuZGVmYXVsdC5iaW5kKHRoaXMsdSxRKSx0aGlzLnJlbW92ZU1lbWJlcnM9ay5kZWZhdWx0LmJpbmQodGhpcyx1LFopLHRoaXMuZ2V0TWVtYmVycz1rLmRlZmF1bHQuYmluZCh0aGlzLHUsWCksdGhpcy5nZXRNZW1iZXJzaGlwcz1rLmRlZmF1bHQuYmluZCh0aGlzLHUsZWUpLHRoaXMuam9pblNwYWNlcz1rLmRlZmF1bHQuYmluZCh0aGlzLHUsbmUpLHRoaXMudXBkYXRlTWVtYmVyc2hpcHM9ay5kZWZhdWx0LmJpbmQodGhpcyx1LHRlKSx0aGlzLmxlYXZlU3BhY2VzPWsuZGVmYXVsdC5iaW5kKHRoaXMsdSxyZSksdGhpcy50aW1lPWMsdGhpcy5zdWJzY3JpYmU9Zy5hZGFwdFN1YnNjcmliZUNoYW5nZS5iaW5kKGcpLHRoaXMucHJlc2VuY2U9Zy5hZGFwdFByZXNlbmNlQ2hhbmdlLmJpbmQoZyksdGhpcy51bnN1YnNjcmliZT1nLmFkYXB0VW5zdWJzY3JpYmVDaGFuZ2UuYmluZChnKSx0aGlzLmRpc2Nvbm5lY3Q9Zy5kaXNjb25uZWN0LmJpbmQoZyksdGhpcy5yZWNvbm5lY3Q9Zy5yZWNvbm5lY3QuYmluZChnKSx0aGlzLmRlc3Ryb3k9ZnVuY3Rpb24oZSl7Zy51bnN1YnNjcmliZUFsbChlKSxnLmRpc2Nvbm5lY3QoKX0sdGhpcy5zdG9wPXRoaXMuZGVzdHJveSx0aGlzLnVuc3Vic2NyaWJlQWxsPWcudW5zdWJzY3JpYmVBbGwuYmluZChnKSx0aGlzLmdldFN1YnNjcmliZWRDaGFubmVscz1nLmdldFN1YnNjcmliZWRDaGFubmVscy5iaW5kKGcpLHRoaXMuZ2V0U3Vic2NyaWJlZENoYW5uZWxHcm91cHM9Zy5nZXRTdWJzY3JpYmVkQ2hhbm5lbEdyb3Vwcy5iaW5kKGcpLHRoaXMuZW5jcnlwdD1zLmVuY3J5cHQuYmluZChzKSx0aGlzLmRlY3J5cHQ9cy5kZWNyeXB0LmJpbmQocyksdGhpcy5nZXRBdXRoS2V5PXUuY29uZmlnLmdldEF1dGhLZXkuYmluZCh1LmNvbmZpZyksdGhpcy5zZXRBdXRoS2V5PXUuY29uZmlnLnNldEF1dGhLZXkuYmluZCh1LmNvbmZpZyksdGhpcy5zZXRDaXBoZXJLZXk9dS5jb25maWcuc2V0Q2lwaGVyS2V5LmJpbmQodS5jb25maWcpLHRoaXMuZ2V0VVVJRD11LmNvbmZpZy5nZXRVVUlELmJpbmQodS5jb25maWcpLHRoaXMuc2V0VVVJRD11LmNvbmZpZy5zZXRVVUlELmJpbmQodS5jb25maWcpLHRoaXMuZ2V0RmlsdGVyRXhwcmVzc2lvbj11LmNvbmZpZy5nZXRGaWx0ZXJFeHByZXNzaW9uLmJpbmQodS5jb25maWcpLHRoaXMuc2V0RmlsdGVyRXhwcmVzc2lvbj11LmNvbmZpZy5zZXRGaWx0ZXJFeHByZXNzaW9uLmJpbmQodS5jb25maWcpLHRoaXMuc2V0SGVhcnRiZWF0SW50ZXJ2YWw9dS5jb25maWcuc2V0SGVhcnRiZWF0SW50ZXJ2YWwuYmluZCh1LmNvbmZpZyksci5oYXNNb2R1bGUoXCJwcm94eVwiKSYmKHRoaXMuc2V0UHJveHk9ZnVuY3Rpb24oZSl7dS5jb25maWcuc2V0UHJveHkoZSksbi5yZWNvbm5lY3QoKX0pfWdlKHQuZGVmYXVsdD1nLFwiT1BFUkFUSU9OU1wiLGkuZGVmYXVsdCksZ2UoZyxcIkNBVEVHT1JJRVNcIixvLmRlZmF1bHQpLGUuZXhwb3J0cz10LmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG87aT1bdF0sdm9pZCAwPT09KG89XCJmdW5jdGlvblwiPT10eXBlb2Yocj1mdW5jdGlvbihlKXt2YXIgcj17MzovXlswLTlBLUZdezh9LVswLTlBLUZdezR9LTNbMC05QS1GXXszfS1bMC05QS1GXXs0fS1bMC05QS1GXXsxMn0kL2ksNDovXlswLTlBLUZdezh9LVswLTlBLUZdezR9LTRbMC05QS1GXXszfS1bODlBQl1bMC05QS1GXXszfS1bMC05QS1GXXsxMn0kL2ksNTovXlswLTlBLUZdezh9LVswLTlBLUZdezR9LTVbMC05QS1GXXszfS1bODlBQl1bMC05QS1GXXszfS1bMC05QS1GXXsxMn0kL2ksYWxsOi9eWzAtOUEtRl17OH0tWzAtOUEtRl17NH0tWzAtOUEtRl17NH0tWzAtOUEtRl17NH0tWzAtOUEtRl17MTJ9JC9pfTtmdW5jdGlvbiB0KCl7dmFyIGUsdCxuPVwiXCI7Zm9yKGU9MDtlPDMyO2UrKyl0PTE2Kk1hdGgucmFuZG9tKCl8MCw4IT09ZSYmMTIhPT1lJiYxNiE9PWUmJjIwIT09ZXx8KG4rPVwiLVwiKSxuKz0oMTI9PT1lPzQ6MTY9PT1lPzMmdHw4OnQpLnRvU3RyaW5nKDE2KTtyZXR1cm4gbn1mdW5jdGlvbiBuKGUsdCl7dmFyIG49clt0fHxcImFsbFwiXTtyZXR1cm4gbiYmbi50ZXN0KGUpfHwhMX10LmlzVVVJRD1uLHQuVkVSU0lPTj1cIjAuMS4wXCIsZS51dWlkPXQsZS5pc1VVSUQ9bn0pP3IuYXBwbHkodCxpKTpyKXx8KGUuZXhwb3J0cz1vKX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciByLGMsaSx1LG8scyxhLGYsbCxoLEU9RXx8ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gbigpe312YXIgZT17fSx0PWUubGliPXt9LHI9dC5CYXNlPXtleHRlbmQ6ZnVuY3Rpb24oZSl7bi5wcm90b3R5cGU9dGhpczt2YXIgdD1uZXcgbjtyZXR1cm4gZSYmdC5taXhJbihlKSx0Lmhhc093blByb3BlcnR5KFwiaW5pdFwiKXx8KHQuaW5pdD1mdW5jdGlvbigpe3QuJHN1cGVyLmluaXQuYXBwbHkodGhpcyxhcmd1bWVudHMpfSksKHQuaW5pdC5wcm90b3R5cGU9dCkuJHN1cGVyPXRoaXMsdH0sY3JlYXRlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5leHRlbmQoKTtyZXR1cm4gZS5pbml0LmFwcGx5KGUsYXJndW1lbnRzKSxlfSxpbml0OmZ1bmN0aW9uKCl7fSxtaXhJbjpmdW5jdGlvbihlKXtmb3IodmFyIHQgaW4gZSllLmhhc093blByb3BlcnR5KHQpJiYodGhpc1t0XT1lW3RdKTtlLmhhc093blByb3BlcnR5KFwidG9TdHJpbmdcIikmJih0aGlzLnRvU3RyaW5nPWUudG9TdHJpbmcpfSxjbG9uZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmluaXQucHJvdG90eXBlLmV4dGVuZCh0aGlzKX19LHU9dC5Xb3JkQXJyYXk9ci5leHRlbmQoe2luaXQ6ZnVuY3Rpb24oZSx0KXtlPXRoaXMud29yZHM9ZXx8W10sdGhpcy5zaWdCeXRlcz1udWxsIT10P3Q6NCplLmxlbmd0aH0sdG9TdHJpbmc6ZnVuY3Rpb24oZSl7cmV0dXJuKGV8fG8pLnN0cmluZ2lmeSh0aGlzKX0sY29uY2F0OmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMud29yZHMsbj1lLndvcmRzLHI9dGhpcy5zaWdCeXRlcztpZihlPWUuc2lnQnl0ZXMsdGhpcy5jbGFtcCgpLHIlNClmb3IodmFyIGk9MDtpPGU7aSsrKXRbcitpPj4+Ml18PShuW2k+Pj4yXT4+PjI0LWklNCo4JjI1NSk8PDI0LShyK2kpJTQqODtlbHNlIGlmKDY1NTM1PG4ubGVuZ3RoKWZvcihpPTA7aTxlO2krPTQpdFtyK2k+Pj4yXT1uW2k+Pj4yXTtlbHNlIHQucHVzaC5hcHBseSh0LG4pO3JldHVybiB0aGlzLnNpZ0J5dGVzKz1lLHRoaXN9LGNsYW1wOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy53b3Jkcyx0PXRoaXMuc2lnQnl0ZXM7ZVt0Pj4+Ml0mPTQyOTQ5NjcyOTU8PDMyLXQlNCo4LGUubGVuZ3RoPWEuY2VpbCh0LzQpfSxjbG9uZTpmdW5jdGlvbigpe3ZhciBlPXIuY2xvbmUuY2FsbCh0aGlzKTtyZXR1cm4gZS53b3Jkcz10aGlzLndvcmRzLnNsaWNlKDApLGV9LHJhbmRvbTpmdW5jdGlvbihlKXtmb3IodmFyIHQ9W10sbj0wO248ZTtuKz00KXQucHVzaCg0Mjk0OTY3Mjk2KmEucmFuZG9tKCl8MCk7cmV0dXJuIG5ldyB1LmluaXQodCxlKX19KSxpPWUuZW5jPXt9LG89aS5IZXg9e3N0cmluZ2lmeTpmdW5jdGlvbihlKXt2YXIgdD1lLndvcmRzO2U9ZS5zaWdCeXRlcztmb3IodmFyIG49W10scj0wO3I8ZTtyKyspe3ZhciBpPXRbcj4+PjJdPj4+MjQtciU0KjgmMjU1O24ucHVzaCgoaT4+PjQpLnRvU3RyaW5nKDE2KSksbi5wdXNoKCgxNSZpKS50b1N0cmluZygxNikpfXJldHVybiBuLmpvaW4oXCJcIil9LHBhcnNlOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1lLmxlbmd0aCxuPVtdLHI9MDtyPHQ7cis9MiluW3I+Pj4zXXw9cGFyc2VJbnQoZS5zdWJzdHIociwyKSwxNik8PDI0LXIlOCo0O3JldHVybiBuZXcgdS5pbml0KG4sdC8yKX19LHM9aS5MYXRpbjE9e3N0cmluZ2lmeTpmdW5jdGlvbihlKXt2YXIgdD1lLndvcmRzO2U9ZS5zaWdCeXRlcztmb3IodmFyIG49W10scj0wO3I8ZTtyKyspbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUodFtyPj4+Ml0+Pj4yNC1yJTQqOCYyNTUpKTtyZXR1cm4gbi5qb2luKFwiXCIpfSxwYXJzZTpmdW5jdGlvbihlKXtmb3IodmFyIHQ9ZS5sZW5ndGgsbj1bXSxyPTA7cjx0O3IrKyluW3I+Pj4yXXw9KDI1NSZlLmNoYXJDb2RlQXQocikpPDwyNC1yJTQqODtyZXR1cm4gbmV3IHUuaW5pdChuLHQpfX0sYz1pLlV0Zjg9e3N0cmluZ2lmeTpmdW5jdGlvbihlKXt0cnl7cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUocy5zdHJpbmdpZnkoZSkpKX1jYXRjaChlKXt0aHJvdyBFcnJvcihcIk1hbGZvcm1lZCBVVEYtOCBkYXRhXCIpfX0scGFyc2U6ZnVuY3Rpb24oZSl7cmV0dXJuIHMucGFyc2UodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGUpKSl9fSxmPXQuQnVmZmVyZWRCbG9ja0FsZ29yaXRobT1yLmV4dGVuZCh7cmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9kYXRhPW5ldyB1LmluaXQsdGhpcy5fbkRhdGFCeXRlcz0wfSxfYXBwZW5kOmZ1bmN0aW9uKGUpe1wic3RyaW5nXCI9PXR5cGVvZiBlJiYoZT1jLnBhcnNlKGUpKSx0aGlzLl9kYXRhLmNvbmNhdChlKSx0aGlzLl9uRGF0YUJ5dGVzKz1lLnNpZ0J5dGVzfSxfcHJvY2VzczpmdW5jdGlvbihlKXt2YXIgdD10aGlzLl9kYXRhLG49dC53b3JkcyxyPXQuc2lnQnl0ZXMsaT10aGlzLmJsb2NrU2l6ZSxvPXIvKDQqaSk7aWYoZT0obz1lP2EuY2VpbChvKTphLm1heCgoMHxvKS10aGlzLl9taW5CdWZmZXJTaXplLDApKSppLHI9YS5taW4oNCplLHIpLGUpe2Zvcih2YXIgcz0wO3M8ZTtzKz1pKXRoaXMuX2RvUHJvY2Vzc0Jsb2NrKG4scyk7cz1uLnNwbGljZSgwLGUpLHQuc2lnQnl0ZXMtPXJ9cmV0dXJuIG5ldyB1LmluaXQocyxyKX0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgZT1yLmNsb25lLmNhbGwodGhpcyk7cmV0dXJuIGUuX2RhdGE9dGhpcy5fZGF0YS5jbG9uZSgpLGV9LF9taW5CdWZmZXJTaXplOjB9KTt0Lkhhc2hlcj1mLmV4dGVuZCh7Y2ZnOnIuZXh0ZW5kKCksaW5pdDpmdW5jdGlvbihlKXt0aGlzLmNmZz10aGlzLmNmZy5leHRlbmQoZSksdGhpcy5yZXNldCgpfSxyZXNldDpmdW5jdGlvbigpe2YucmVzZXQuY2FsbCh0aGlzKSx0aGlzLl9kb1Jlc2V0KCl9LHVwZGF0ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fYXBwZW5kKGUpLHRoaXMuX3Byb2Nlc3MoKSx0aGlzfSxmaW5hbGl6ZTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmdGhpcy5fYXBwZW5kKGUpLHRoaXMuX2RvRmluYWxpemUoKX0sYmxvY2tTaXplOjE2LF9jcmVhdGVIZWxwZXI6ZnVuY3Rpb24obil7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyBuLmluaXQodCkuZmluYWxpemUoZSl9fSxfY3JlYXRlSG1hY0hlbHBlcjpmdW5jdGlvbihuKXtyZXR1cm4gZnVuY3Rpb24oZSx0KXtyZXR1cm4gbmV3IGwuSE1BQy5pbml0KG4sdCkuZmluYWxpemUoZSl9fX0pO3ZhciBsPWUuYWxnbz17fTtyZXR1cm4gZX0oTWF0aCk7IWZ1bmN0aW9uKGkpe2Zvcih2YXIgZT1FLHQ9KHI9ZS5saWIpLldvcmRBcnJheSxuPXIuSGFzaGVyLHI9ZS5hbGdvLG89W10sZD1bXSxzPWZ1bmN0aW9uKGUpe3JldHVybiA0Mjk0OTY3Mjk2KihlLSgwfGUpKXwwfSxhPTIsdT0wO3U8NjQ7KXt2YXIgYztlOntjPWE7Zm9yKHZhciBmPWkuc3FydChjKSxsPTI7bDw9ZjtsKyspaWYoIShjJWwpKXtjPSExO2JyZWFrIGV9Yz0hMH1jJiYodTw4JiYob1t1XT1zKGkucG93KGEsLjUpKSksZFt1XT1zKGkucG93KGEsMS8zKSksdSsrKSxhKyt9dmFyIGc9W107cj1yLlNIQTI1Nj1uLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9oYXNoPW5ldyB0LmluaXQoby5zbGljZSgwKSl9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbihlLHQpe2Zvcih2YXIgbj10aGlzLl9oYXNoLndvcmRzLHI9blswXSxpPW5bMV0sbz1uWzJdLHM9blszXSxhPW5bNF0sdT1uWzVdLGM9bls2XSxmPW5bN10sbD0wO2w8NjQ7bCsrKXtpZihsPDE2KWdbbF09MHxlW3QrbF07ZWxzZXt2YXIgaD1nW2wtMTVdLHA9Z1tsLTJdO2dbbF09KChoPDwyNXxoPj4+NyleKGg8PDE0fGg+Pj4xOCleaD4+PjMpK2dbbC03XSsoKHA8PDE1fHA+Pj4xNyleKHA8PDEzfHA+Pj4xOSlecD4+PjEwKStnW2wtMTZdfWg9ZisoKGE8PDI2fGE+Pj42KV4oYTw8MjF8YT4+PjExKV4oYTw8N3xhPj4+MjUpKSsoYSZ1Xn5hJmMpK2RbbF0rZ1tsXSxwPSgocjw8MzB8cj4+PjIpXihyPDwxOXxyPj4+MTMpXihyPDwxMHxyPj4+MjIpKSsociZpXnImb15pJm8pLGY9YyxjPXUsdT1hLGE9cytofDAscz1vLG89aSxpPXIscj1oK3B8MH1uWzBdPW5bMF0rcnwwLG5bMV09blsxXStpfDAsblsyXT1uWzJdK298MCxuWzNdPW5bM10rc3wwLG5bNF09bls0XSthfDAsbls1XT1uWzVdK3V8MCxuWzZdPW5bNl0rY3wwLG5bN109bls3XStmfDB9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5fZGF0YSx0PWUud29yZHMsbj04KnRoaXMuX25EYXRhQnl0ZXMscj04KmUuc2lnQnl0ZXM7cmV0dXJuIHRbcj4+PjVdfD0xMjg8PDI0LXIlMzIsdFsxNCsoNjQrcj4+Pjk8PDQpXT1pLmZsb29yKG4vNDI5NDk2NzI5NiksdFsxNSsoNjQrcj4+Pjk8PDQpXT1uLGUuc2lnQnl0ZXM9NCp0Lmxlbmd0aCx0aGlzLl9wcm9jZXNzKCksdGhpcy5faGFzaH0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgZT1uLmNsb25lLmNhbGwodGhpcyk7cmV0dXJuIGUuX2hhc2g9dGhpcy5faGFzaC5jbG9uZSgpLGV9fSk7ZS5TSEEyNTY9bi5fY3JlYXRlSGVscGVyKHIpLGUuSG1hY1NIQTI1Nj1uLl9jcmVhdGVIbWFjSGVscGVyKHIpfShNYXRoKSxjPShyPUUpLmVuYy5VdGY4LHIuYWxnby5ITUFDPXIubGliLkJhc2UuZXh0ZW5kKHtpbml0OmZ1bmN0aW9uKGUsdCl7ZT10aGlzLl9oYXNoZXI9bmV3IGUuaW5pdCxcInN0cmluZ1wiPT10eXBlb2YgdCYmKHQ9Yy5wYXJzZSh0KSk7dmFyIG49ZS5ibG9ja1NpemUscj00Km47dC5zaWdCeXRlcz5yJiYodD1lLmZpbmFsaXplKHQpKSx0LmNsYW1wKCk7Zm9yKHZhciBpPXRoaXMuX29LZXk9dC5jbG9uZSgpLG89dGhpcy5faUtleT10LmNsb25lKCkscz1pLndvcmRzLGE9by53b3Jkcyx1PTA7dTxuO3UrKylzW3VdXj0xNTQ5NTU2ODI4LGFbdV1ePTkwOTUyMjQ4NjtpLnNpZ0J5dGVzPW8uc2lnQnl0ZXM9cix0aGlzLnJlc2V0KCl9LHJlc2V0OmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5faGFzaGVyO2UucmVzZXQoKSxlLnVwZGF0ZSh0aGlzLl9pS2V5KX0sdXBkYXRlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9oYXNoZXIudXBkYXRlKGUpLHRoaXN9LGZpbmFsaXplOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuX2hhc2hlcjtyZXR1cm4gZT10LmZpbmFsaXplKGUpLHQucmVzZXQoKSx0LmZpbmFsaXplKHRoaXMuX29LZXkuY2xvbmUoKS5jb25jYXQoZSkpfX0pLHU9KGk9RSkubGliLldvcmRBcnJheSxpLmVuYy5CYXNlNjQ9e3N0cmluZ2lmeTpmdW5jdGlvbihlKXt2YXIgdD1lLndvcmRzLG49ZS5zaWdCeXRlcyxyPXRoaXMuX21hcDtlLmNsYW1wKCksZT1bXTtmb3IodmFyIGk9MDtpPG47aSs9Mylmb3IodmFyIG89KHRbaT4+PjJdPj4+MjQtaSU0KjgmMjU1KTw8MTZ8KHRbaSsxPj4+Ml0+Pj4yNC0oaSsxKSU0KjgmMjU1KTw8OHx0W2krMj4+PjJdPj4+MjQtKGkrMiklNCo4JjI1NSxzPTA7czw0JiZpKy43NSpzPG47cysrKWUucHVzaChyLmNoYXJBdChvPj4+NiooMy1zKSY2MykpO2lmKHQ9ci5jaGFyQXQoNjQpKWZvcig7ZS5sZW5ndGglNDspZS5wdXNoKHQpO3JldHVybiBlLmpvaW4oXCJcIil9LHBhcnNlOmZ1bmN0aW9uKGUpe3ZhciB0PWUubGVuZ3RoLG49dGhpcy5fbWFwOyEocj1uLmNoYXJBdCg2NCkpfHwtMSE9KHI9ZS5pbmRleE9mKHIpKSYmKHQ9cik7Zm9yKHZhciByPVtdLGk9MCxvPTA7bzx0O28rKylpZihvJTQpe3ZhciBzPW4uaW5kZXhPZihlLmNoYXJBdChvLTEpKTw8byU0KjIsYT1uLmluZGV4T2YoZS5jaGFyQXQobykpPj4+Ni1vJTQqMjtyW2k+Pj4yXXw9KHN8YSk8PDI0LWklNCo4LGkrK31yZXR1cm4gdS5jcmVhdGUocixpKX0sX21hcDpcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCJ9LGZ1bmN0aW9uKG8pe2Z1bmN0aW9uIHcoZSx0LG4scixpLG8scyl7cmV0dXJuKChlPWUrKHQmbnx+dCZyKStpK3MpPDxvfGU+Pj4zMi1vKSt0fWZ1bmN0aW9uIFQoZSx0LG4scixpLG8scyl7cmV0dXJuKChlPWUrKHQmcnxuJn5yKStpK3MpPDxvfGU+Pj4zMi1vKSt0fWZ1bmN0aW9uIE8oZSx0LG4scixpLG8scyl7cmV0dXJuKChlPWUrKHRebl5yKStpK3MpPDxvfGU+Pj4zMi1vKSt0fWZ1bmN0aW9uIFMoZSx0LG4scixpLG8scyl7cmV0dXJuKChlPWUrKG5eKHR8fnIpKStpK3MpPDxvfGU+Pj4zMi1vKSt0fWZvcih2YXIgZT1FLHQ9KHI9ZS5saWIpLldvcmRBcnJheSxuPXIuSGFzaGVyLHI9ZS5hbGdvLE09W10saT0wO2k8NjQ7aSsrKU1baV09NDI5NDk2NzI5NipvLmFicyhvLnNpbihpKzEpKXwwO3I9ci5NRDU9bi5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5faGFzaD1uZXcgdC5pbml0KFsxNzMyNTg0MTkzLDQwMjMyMzM0MTcsMjU2MjM4MzEwMiwyNzE3MzM4NzhdKX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPTA7bjwxNjtuKyspe3ZhciByPWVbcz10K25dO2Vbc109MTY3MTE5MzUmKHI8PDh8cj4+PjI0KXw0Mjc4MjU1MzYwJihyPDwyNHxyPj4+OCl9bj10aGlzLl9oYXNoLndvcmRzO3ZhciBpLG8scz1lW3QrMF0sYT0ocj1lW3QrMV0sZVt0KzJdKSx1PWVbdCszXSxjPWVbdCs0XSxmPWVbdCs1XSxsPWVbdCs2XSxoPWVbdCs3XSxwPWVbdCs4XSxkPWVbdCs5XSxnPWVbdCsxMF0seT1lW3QrMTFdLHY9ZVt0KzEyXSxiPWVbdCsxM10sbT1lW3QrMTRdLF89ZVt0KzE1XSxrPW5bMF0sUD1TKFA9UyhQPVMoUD1TKFA9TyhQPU8oUD1PKFA9TyhQPVQoUD1UKFA9VChQPVQoUD13KFA9dyhQPXcoUD13KFA9blsxXSxvPXcobz1uWzJdLGk9dyhpPW5bM10saz13KGssUCxvLGkscyw3LE1bMF0pLFAsbyxyLDEyLE1bMV0pLGssUCxhLDE3LE1bMl0pLGksayx1LDIyLE1bM10pLG89dyhvLGk9dyhpLGs9dyhrLFAsbyxpLGMsNyxNWzRdKSxQLG8sZiwxMixNWzVdKSxrLFAsbCwxNyxNWzZdKSxpLGssaCwyMixNWzddKSxvPXcobyxpPXcoaSxrPXcoayxQLG8saSxwLDcsTVs4XSksUCxvLGQsMTIsTVs5XSksayxQLGcsMTcsTVsxMF0pLGksayx5LDIyLE1bMTFdKSxvPXcobyxpPXcoaSxrPXcoayxQLG8saSx2LDcsTVsxMl0pLFAsbyxiLDEyLE1bMTNdKSxrLFAsbSwxNyxNWzE0XSksaSxrLF8sMjIsTVsxNV0pLG89VChvLGk9VChpLGs9VChrLFAsbyxpLHIsNSxNWzE2XSksUCxvLGwsOSxNWzE3XSksayxQLHksMTQsTVsxOF0pLGksayxzLDIwLE1bMTldKSxvPVQobyxpPVQoaSxrPVQoayxQLG8saSxmLDUsTVsyMF0pLFAsbyxnLDksTVsyMV0pLGssUCxfLDE0LE1bMjJdKSxpLGssYywyMCxNWzIzXSksbz1UKG8saT1UKGksaz1UKGssUCxvLGksZCw1LE1bMjRdKSxQLG8sbSw5LE1bMjVdKSxrLFAsdSwxNCxNWzI2XSksaSxrLHAsMjAsTVsyN10pLG89VChvLGk9VChpLGs9VChrLFAsbyxpLGIsNSxNWzI4XSksUCxvLGEsOSxNWzI5XSksayxQLGgsMTQsTVszMF0pLGksayx2LDIwLE1bMzFdKSxvPU8obyxpPU8oaSxrPU8oayxQLG8saSxmLDQsTVszMl0pLFAsbyxwLDExLE1bMzNdKSxrLFAseSwxNixNWzM0XSksaSxrLG0sMjMsTVszNV0pLG89TyhvLGk9TyhpLGs9TyhrLFAsbyxpLHIsNCxNWzM2XSksUCxvLGMsMTEsTVszN10pLGssUCxoLDE2LE1bMzhdKSxpLGssZywyMyxNWzM5XSksbz1PKG8saT1PKGksaz1PKGssUCxvLGksYiw0LE1bNDBdKSxQLG8scywxMSxNWzQxXSksayxQLHUsMTYsTVs0Ml0pLGksayxsLDIzLE1bNDNdKSxvPU8obyxpPU8oaSxrPU8oayxQLG8saSxkLDQsTVs0NF0pLFAsbyx2LDExLE1bNDVdKSxrLFAsXywxNixNWzQ2XSksaSxrLGEsMjMsTVs0N10pLG89UyhvLGk9UyhpLGs9UyhrLFAsbyxpLHMsNixNWzQ4XSksUCxvLGgsMTAsTVs0OV0pLGssUCxtLDE1LE1bNTBdKSxpLGssZiwyMSxNWzUxXSksbz1TKG8saT1TKGksaz1TKGssUCxvLGksdiw2LE1bNTJdKSxQLG8sdSwxMCxNWzUzXSksayxQLGcsMTUsTVs1NF0pLGksayxyLDIxLE1bNTVdKSxvPVMobyxpPVMoaSxrPVMoayxQLG8saSxwLDYsTVs1Nl0pLFAsbyxfLDEwLE1bNTddKSxrLFAsbCwxNSxNWzU4XSksaSxrLGIsMjEsTVs1OV0pLG89UyhvLGk9UyhpLGs9UyhrLFAsbyxpLGMsNixNWzYwXSksUCxvLHksMTAsTVs2MV0pLGssUCxhLDE1LE1bNjJdKSxpLGssZCwyMSxNWzYzXSk7blswXT1uWzBdK2t8MCxuWzFdPW5bMV0rUHwwLG5bMl09blsyXStvfDAsblszXT1uWzNdK2l8MH0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLl9kYXRhLHQ9ZS53b3JkcyxuPTgqdGhpcy5fbkRhdGFCeXRlcyxyPTgqZS5zaWdCeXRlczt0W3I+Pj41XXw9MTI4PDwyNC1yJTMyO3ZhciBpPW8uZmxvb3Iobi80Mjk0OTY3Mjk2KTtmb3IodFsxNSsocis2ND4+Pjk8PDQpXT0xNjcxMTkzNSYoaTw8OHxpPj4+MjQpfDQyNzgyNTUzNjAmKGk8PDI0fGk+Pj44KSx0WzE0KyhyKzY0Pj4+OTw8NCldPTE2NzExOTM1JihuPDw4fG4+Pj4yNCl8NDI3ODI1NTM2MCYobjw8MjR8bj4+PjgpLGUuc2lnQnl0ZXM9NCoodC5sZW5ndGgrMSksdGhpcy5fcHJvY2VzcygpLHQ9KGU9dGhpcy5faGFzaCkud29yZHMsbj0wO248NDtuKyspcj10W25dLHRbbl09MTY3MTE5MzUmKHI8PDh8cj4+PjI0KXw0Mjc4MjU1MzYwJihyPDwyNHxyPj4+OCk7cmV0dXJuIGV9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIGU9bi5jbG9uZS5jYWxsKHRoaXMpO3JldHVybiBlLl9oYXNoPXRoaXMuX2hhc2guY2xvbmUoKSxlfX0pLGUuTUQ1PW4uX2NyZWF0ZUhlbHBlcihyKSxlLkhtYWNNRDU9bi5fY3JlYXRlSG1hY0hlbHBlcihyKX0oTWF0aCksYT0obz0ocz1FKS5saWIpLkJhc2UsZj1vLldvcmRBcnJheSxsPShvPXMuYWxnbykuRXZwS0RGPWEuZXh0ZW5kKHtjZmc6YS5leHRlbmQoe2tleVNpemU6NCxoYXNoZXI6by5NRDUsaXRlcmF0aW9uczoxfSksaW5pdDpmdW5jdGlvbihlKXt0aGlzLmNmZz10aGlzLmNmZy5leHRlbmQoZSl9LGNvbXB1dGU6ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49KHM9dGhpcy5jZmcpLmhhc2hlci5jcmVhdGUoKSxyPWYuY3JlYXRlKCksaT1yLndvcmRzLG89cy5rZXlTaXplLHM9cy5pdGVyYXRpb25zO2kubGVuZ3RoPG87KXthJiZuLnVwZGF0ZShhKTt2YXIgYT1uLnVwZGF0ZShlKS5maW5hbGl6ZSh0KTtuLnJlc2V0KCk7Zm9yKHZhciB1PTE7dTxzO3UrKylhPW4uZmluYWxpemUoYSksbi5yZXNldCgpO3IuY29uY2F0KGEpfXJldHVybiByLnNpZ0J5dGVzPTQqbyxyfX0pLHMuRXZwS0RGPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gbC5jcmVhdGUobikuY29tcHV0ZShlLHQpfSxFLmxpYi5DaXBoZXJ8fGZ1bmN0aW9uKCl7dmFyIGU9KGg9RSkubGliLHQ9ZS5CYXNlLHM9ZS5Xb3JkQXJyYXksbj1lLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0scj1oLmVuYy5CYXNlNjQsaT1oLmFsZ28uRXZwS0RGLG89ZS5DaXBoZXI9bi5leHRlbmQoe2NmZzp0LmV4dGVuZCgpLGNyZWF0ZUVuY3J5cHRvcjpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9FTkNfWEZPUk1fTU9ERSxlLHQpfSxjcmVhdGVEZWNyeXB0b3I6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5jcmVhdGUodGhpcy5fREVDX1hGT1JNX01PREUsZSx0KX0saW5pdDpmdW5jdGlvbihlLHQsbil7dGhpcy5jZmc9dGhpcy5jZmcuZXh0ZW5kKG4pLHRoaXMuX3hmb3JtTW9kZT1lLHRoaXMuX2tleT10LHRoaXMucmVzZXQoKX0scmVzZXQ6ZnVuY3Rpb24oKXtuLnJlc2V0LmNhbGwodGhpcyksdGhpcy5fZG9SZXNldCgpfSxwcm9jZXNzOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9hcHBlbmQoZSksdGhpcy5fcHJvY2VzcygpfSxmaW5hbGl6ZTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmdGhpcy5fYXBwZW5kKGUpLHRoaXMuX2RvRmluYWxpemUoKX0sa2V5U2l6ZTo0LGl2U2l6ZTo0LF9FTkNfWEZPUk1fTU9ERToxLF9ERUNfWEZPUk1fTU9ERToyLF9jcmVhdGVIZWxwZXI6ZnVuY3Rpb24ocil7cmV0dXJue2VuY3J5cHQ6ZnVuY3Rpb24oZSx0LG4pe3JldHVybihcInN0cmluZ1wiPT10eXBlb2YgdD9wOmwpLmVuY3J5cHQocixlLHQsbil9LGRlY3J5cHQ6ZnVuY3Rpb24oZSx0LG4pe3JldHVybihcInN0cmluZ1wiPT10eXBlb2YgdD9wOmwpLmRlY3J5cHQocixlLHQsbil9fX19KTtlLlN0cmVhbUNpcGhlcj1vLmV4dGVuZCh7X2RvRmluYWxpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcHJvY2VzcyghMCl9LGJsb2NrU2l6ZToxfSk7ZnVuY3Rpb24gYShlLHQsbil7dmFyIHI9dGhpcy5faXY7cj90aGlzLl9pdj12b2lkIDA6cj10aGlzLl9wcmV2QmxvY2s7Zm9yKHZhciBpPTA7aTxuO2krKyllW3QraV1ePXJbaV19dmFyIHU9aC5tb2RlPXt9LGM9KGUuQmxvY2tDaXBoZXJNb2RlPXQuZXh0ZW5kKHtjcmVhdGVFbmNyeXB0b3I6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5FbmNyeXB0b3IuY3JlYXRlKGUsdCl9LGNyZWF0ZURlY3J5cHRvcjpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLkRlY3J5cHRvci5jcmVhdGUoZSx0KX0saW5pdDpmdW5jdGlvbihlLHQpe3RoaXMuX2NpcGhlcj1lLHRoaXMuX2l2PXR9fSkpLmV4dGVuZCgpO2MuRW5jcnlwdG9yPWMuZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzLl9jaXBoZXIscj1uLmJsb2NrU2l6ZTthLmNhbGwodGhpcyxlLHQsciksbi5lbmNyeXB0QmxvY2soZSx0KSx0aGlzLl9wcmV2QmxvY2s9ZS5zbGljZSh0LHQrcil9fSksYy5EZWNyeXB0b3I9Yy5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMuX2NpcGhlcixyPW4uYmxvY2tTaXplLGk9ZS5zbGljZSh0LHQrcik7bi5kZWNyeXB0QmxvY2soZSx0KSxhLmNhbGwodGhpcyxlLHQsciksdGhpcy5fcHJldkJsb2NrPWl9fSksdT11LkNCQz1jLGM9KGgucGFkPXt9KS5Qa2NzNz17cGFkOmZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuLHI9KG49KG49NCp0KS1lLnNpZ0J5dGVzJW4pPDwyNHxuPDwxNnxuPDw4fG4saT1bXSxvPTA7bzxuO28rPTQpaS5wdXNoKHIpO249cy5jcmVhdGUoaSxuKSxlLmNvbmNhdChuKX0sdW5wYWQ6ZnVuY3Rpb24oZSl7ZS5zaWdCeXRlcy09MjU1JmUud29yZHNbZS5zaWdCeXRlcy0xPj4+Ml19fSxlLkJsb2NrQ2lwaGVyPW8uZXh0ZW5kKHtjZmc6by5jZmcuZXh0ZW5kKHttb2RlOnUscGFkZGluZzpjfSkscmVzZXQ6ZnVuY3Rpb24oKXtvLnJlc2V0LmNhbGwodGhpcyk7dmFyIGU9KHQ9dGhpcy5jZmcpLml2LHQ9dC5tb2RlO2lmKHRoaXMuX3hmb3JtTW9kZT09dGhpcy5fRU5DX1hGT1JNX01PREUpdmFyIG49dC5jcmVhdGVFbmNyeXB0b3I7ZWxzZSBuPXQuY3JlYXRlRGVjcnlwdG9yLHRoaXMuX21pbkJ1ZmZlclNpemU9MTt0aGlzLl9tb2RlPW4uY2FsbCh0LHRoaXMsZSYmZS53b3Jkcyl9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbihlLHQpe3RoaXMuX21vZGUucHJvY2Vzc0Jsb2NrKGUsdCl9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5jZmcucGFkZGluZztpZih0aGlzLl94Zm9ybU1vZGU9PXRoaXMuX0VOQ19YRk9STV9NT0RFKXtlLnBhZCh0aGlzLl9kYXRhLHRoaXMuYmxvY2tTaXplKTt2YXIgdD10aGlzLl9wcm9jZXNzKCEwKX1lbHNlIHQ9dGhpcy5fcHJvY2VzcyghMCksZS51bnBhZCh0KTtyZXR1cm4gdH0sYmxvY2tTaXplOjR9KTt2YXIgZj1lLkNpcGhlclBhcmFtcz10LmV4dGVuZCh7aW5pdDpmdW5jdGlvbihlKXt0aGlzLm1peEluKGUpfSx0b1N0cmluZzpmdW5jdGlvbihlKXtyZXR1cm4oZXx8dGhpcy5mb3JtYXR0ZXIpLnN0cmluZ2lmeSh0aGlzKX19KSxsPSh1PShoLmZvcm1hdD17fSkuT3BlblNTTD17c3RyaW5naWZ5OmZ1bmN0aW9uKGUpe3ZhciB0PWUuY2lwaGVydGV4dDtyZXR1cm4oKGU9ZS5zYWx0KT9zLmNyZWF0ZShbMTM5ODg5MzY4NCwxNzAxMDc2ODMxXSkuY29uY2F0KGUpLmNvbmNhdCh0KTp0KS50b1N0cmluZyhyKX0scGFyc2U6ZnVuY3Rpb24oZSl7dmFyIHQ9KGU9ci5wYXJzZShlKSkud29yZHM7aWYoMTM5ODg5MzY4ND09dFswXSYmMTcwMTA3NjgzMT09dFsxXSl7dmFyIG49cy5jcmVhdGUodC5zbGljZSgyLDQpKTt0LnNwbGljZSgwLDQpLGUuc2lnQnl0ZXMtPTE2fXJldHVybiBmLmNyZWF0ZSh7Y2lwaGVydGV4dDplLHNhbHQ6bn0pfX0sZS5TZXJpYWxpemFibGVDaXBoZXI9dC5leHRlbmQoe2NmZzp0LmV4dGVuZCh7Zm9ybWF0OnV9KSxlbmNyeXB0OmZ1bmN0aW9uKGUsdCxuLHIpe3I9dGhpcy5jZmcuZXh0ZW5kKHIpO3ZhciBpPWUuY3JlYXRlRW5jcnlwdG9yKG4scik7cmV0dXJuIHQ9aS5maW5hbGl6ZSh0KSxpPWkuY2ZnLGYuY3JlYXRlKHtjaXBoZXJ0ZXh0OnQsa2V5Om4saXY6aS5pdixhbGdvcml0aG06ZSxtb2RlOmkubW9kZSxwYWRkaW5nOmkucGFkZGluZyxibG9ja1NpemU6ZS5ibG9ja1NpemUsZm9ybWF0dGVyOnIuZm9ybWF0fSl9LGRlY3J5cHQ6ZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIHI9dGhpcy5jZmcuZXh0ZW5kKHIpLHQ9dGhpcy5fcGFyc2UodCxyLmZvcm1hdCksZS5jcmVhdGVEZWNyeXB0b3IobixyKS5maW5hbGl6ZSh0LmNpcGhlcnRleHQpfSxfcGFyc2U6ZnVuY3Rpb24oZSx0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZT90LnBhcnNlKGUsdGhpcyk6ZX19KSksaD0oaC5rZGY9e30pLk9wZW5TU0w9e2V4ZWN1dGU6ZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIHI9cnx8cy5yYW5kb20oOCksZT1pLmNyZWF0ZSh7a2V5U2l6ZTp0K259KS5jb21wdXRlKGUsciksbj1zLmNyZWF0ZShlLndvcmRzLnNsaWNlKHQpLDQqbiksZS5zaWdCeXRlcz00KnQsZi5jcmVhdGUoe2tleTplLGl2Om4sc2FsdDpyfSl9fSxwPWUuUGFzc3dvcmRCYXNlZENpcGhlcj1sLmV4dGVuZCh7Y2ZnOmwuY2ZnLmV4dGVuZCh7a2RmOmh9KSxlbmNyeXB0OmZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiBuPShyPXRoaXMuY2ZnLmV4dGVuZChyKSkua2RmLmV4ZWN1dGUobixlLmtleVNpemUsZS5pdlNpemUpLHIuaXY9bi5pdiwoZT1sLmVuY3J5cHQuY2FsbCh0aGlzLGUsdCxuLmtleSxyKSkubWl4SW4obiksZX0sZGVjcnlwdDpmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gcj10aGlzLmNmZy5leHRlbmQociksdD10aGlzLl9wYXJzZSh0LHIuZm9ybWF0KSxuPXIua2RmLmV4ZWN1dGUobixlLmtleVNpemUsZS5pdlNpemUsdC5zYWx0KSxyLml2PW4uaXYsbC5kZWNyeXB0LmNhbGwodGhpcyxlLHQsbi5rZXkscil9fSl9KCksZnVuY3Rpb24oKXtmb3IodmFyIGU9RSx0PWUubGliLkJsb2NrQ2lwaGVyLG49ZS5hbGdvLHM9W10scj1bXSxpPVtdLG89W10sYT1bXSx1PVtdLGM9W10sZj1bXSxsPVtdLGg9W10scD1bXSxkPTA7ZDwyNTY7ZCsrKXBbZF09ZDwxMjg/ZDw8MTpkPDwxXjI4Mzt2YXIgZz0wLHk9MDtmb3IoZD0wO2Q8MjU2O2QrKyl7dmFyIHY9KHY9eV55PDwxXnk8PDJeeTw8M155PDw0KT4+PjheMjU1JnZeOTk7c1tnXT12O3ZhciBiPXBbclt2XT1nXSxtPXBbYl0sXz1wW21dLGs9MjU3KnBbdl1eMTY4NDMwMDgqdjtpW2ddPWs8PDI0fGs+Pj44LG9bZ109azw8MTZ8az4+PjE2LGFbZ109azw8OHxrPj4+MjQsdVtnXT1rLGs9MTY4NDMwMDkqX142NTUzNyptXjI1NypiXjE2ODQzMDA4KmcsY1t2XT1rPDwyNHxrPj4+OCxmW3ZdPWs8PDE2fGs+Pj4xNixsW3ZdPWs8PDh8az4+PjI0LGhbdl09ayxnPyhnPWJecFtwW3BbX15iXV1dLHlePXBbcFt5XV0pOmc9eT0xfXZhciBQPVswLDEsMiw0LDgsMTYsMzIsNjQsMTI4LDI3LDU0XTtuPW4uQUVTPXQuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe2Zvcih2YXIgZT0obj10aGlzLl9rZXkpLndvcmRzLHQ9bi5zaWdCeXRlcy80LG49NCooKHRoaXMuX25Sb3VuZHM9dCs2KSsxKSxyPXRoaXMuX2tleVNjaGVkdWxlPVtdLGk9MDtpPG47aSsrKWlmKGk8dClyW2ldPWVbaV07ZWxzZXt2YXIgbz1yW2ktMV07aSV0PzY8dCYmND09aSV0JiYobz1zW28+Pj4yNF08PDI0fHNbbz4+PjE2JjI1NV08PDE2fHNbbz4+PjgmMjU1XTw8OHxzWzI1NSZvXSk6KG89c1sobz1vPDw4fG8+Pj4yNCk+Pj4yNF08PDI0fHNbbz4+PjE2JjI1NV08PDE2fHNbbz4+PjgmMjU1XTw8OHxzWzI1NSZvXSxvXj1QW2kvdHwwXTw8MjQpLHJbaV09cltpLXRdXm99Zm9yKGU9dGhpcy5faW52S2V5U2NoZWR1bGU9W10sdD0wO3Q8bjt0KyspaT1uLXQsbz10JTQ/cltpXTpyW2ktNF0sZVt0XT10PDR8fGk8PTQ/bzpjW3Nbbz4+PjI0XV1eZltzW28+Pj4xNiYyNTVdXV5sW3Nbbz4+PjgmMjU1XV1eaFtzWzI1NSZvXV19LGVuY3J5cHRCbG9jazpmdW5jdGlvbihlLHQpe3RoaXMuX2RvQ3J5cHRCbG9jayhlLHQsdGhpcy5fa2V5U2NoZWR1bGUsaSxvLGEsdSxzKX0sZGVjcnlwdEJsb2NrOmZ1bmN0aW9uKGUsdCl7dmFyIG49ZVt0KzFdO2VbdCsxXT1lW3QrM10sZVt0KzNdPW4sdGhpcy5fZG9DcnlwdEJsb2NrKGUsdCx0aGlzLl9pbnZLZXlTY2hlZHVsZSxjLGYsbCxoLHIpLG49ZVt0KzFdLGVbdCsxXT1lW3QrM10sZVt0KzNdPW59LF9kb0NyeXB0QmxvY2s6ZnVuY3Rpb24oZSx0LG4scixpLG8scyxhKXtmb3IodmFyIHU9dGhpcy5fblJvdW5kcyxjPWVbdF1eblswXSxmPWVbdCsxXV5uWzFdLGw9ZVt0KzJdXm5bMl0saD1lW3QrM11eblszXSxwPTQsZD0xO2Q8dTtkKyspe3ZhciBnPXJbYz4+PjI0XV5pW2Y+Pj4xNiYyNTVdXm9bbD4+PjgmMjU1XV5zWzI1NSZoXV5uW3ArK10seT1yW2Y+Pj4yNF1eaVtsPj4+MTYmMjU1XV5vW2g+Pj44JjI1NV1ec1syNTUmY11ebltwKytdLHY9cltsPj4+MjRdXmlbaD4+PjE2JjI1NV1eb1tjPj4+OCYyNTVdXnNbMjU1JmZdXm5bcCsrXTtoPXJbaD4+PjI0XV5pW2M+Pj4xNiYyNTVdXm9bZj4+PjgmMjU1XV5zWzI1NSZsXV5uW3ArK10sYz1nLGY9eSxsPXZ9Zz0oYVtjPj4+MjRdPDwyNHxhW2Y+Pj4xNiYyNTVdPDwxNnxhW2w+Pj44JjI1NV08PDh8YVsyNTUmaF0pXm5bcCsrXSx5PShhW2Y+Pj4yNF08PDI0fGFbbD4+PjE2JjI1NV08PDE2fGFbaD4+PjgmMjU1XTw8OHxhWzI1NSZjXSlebltwKytdLHY9KGFbbD4+PjI0XTw8MjR8YVtoPj4+MTYmMjU1XTw8MTZ8YVtjPj4+OCYyNTVdPDw4fGFbMjU1JmZdKV5uW3ArK10saD0oYVtoPj4+MjRdPDwyNHxhW2M+Pj4xNiYyNTVdPDwxNnxhW2Y+Pj44JjI1NV08PDh8YVsyNTUmbF0pXm5bcCsrXSxlW3RdPWcsZVt0KzFdPXksZVt0KzJdPXYsZVt0KzNdPWh9LGtleVNpemU6OH0pO2UuQUVTPXQuX2NyZWF0ZUhlbHBlcihuKX0oKSxFLm1vZGUuRUNCPSgoaD1FLmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCkpLkVuY3J5cHRvcj1oLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKGUsdCl7dGhpcy5fY2lwaGVyLmVuY3J5cHRCbG9jayhlLHQpfX0pLGguRGVjcnlwdG9yPWguZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24oZSx0KXt0aGlzLl9jaXBoZXIuZGVjcnlwdEJsb2NrKGUsdCl9fSksaCksZS5leHBvcnRzPUV9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9dm9pZCAwO3Iobig2KSkscihuKDMpKSxyKG4oNykpO3ZhciBjPXIobigxNikpLGY9cihuKDE3KSksbD1yKG4oMikpLGE9KG4oMCkscihuKDQpKSk7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gaShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19ZnVuY3Rpb24gaChlLHQsbil7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1uLGV9dmFyIG8scyx1LHA9KG89ZCwocz1be2tleTpcImFkYXB0U3RhdGVDaGFuZ2VcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMscj1lLnN0YXRlLGk9ZS5jaGFubmVscyxvPXZvaWQgMD09PWk/W106aSxzPWUuY2hhbm5lbEdyb3VwcyxhPXZvaWQgMD09PXM/W106cztyZXR1cm4gby5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UgaW4gbi5fY2hhbm5lbHMmJihuLl9jaGFubmVsc1tlXS5zdGF0ZT1yKX0pLGEuZm9yRWFjaChmdW5jdGlvbihlKXtlIGluIG4uX2NoYW5uZWxHcm91cHMmJihuLl9jaGFubmVsR3JvdXBzW2VdLnN0YXRlPXIpfSksdGhpcy5fc2V0U3RhdGVFbmRwb2ludCh7c3RhdGU6cixjaGFubmVsczpvLGNoYW5uZWxHcm91cHM6YX0sdCl9fSx7a2V5OlwiYWRhcHRQcmVzZW5jZUNoYW5nZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsbj1lLmNvbm5lY3RlZCxyPWUuY2hhbm5lbHMsaT12b2lkIDA9PT1yP1tdOnIsbz1lLmNoYW5uZWxHcm91cHMscz12b2lkIDA9PT1vP1tdOm87bj8oaS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3QuX2hlYXJ0YmVhdENoYW5uZWxzW2VdPXtzdGF0ZTp7fX19KSxzLmZvckVhY2goZnVuY3Rpb24oZSl7dC5faGVhcnRiZWF0Q2hhbm5lbEdyb3Vwc1tlXT17c3RhdGU6e319fSkpOihpLmZvckVhY2goZnVuY3Rpb24oZSl7ZSBpbiB0Ll9oZWFydGJlYXRDaGFubmVscyYmZGVsZXRlIHQuX2hlYXJ0YmVhdENoYW5uZWxzW2VdfSkscy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UgaW4gdC5faGVhcnRiZWF0Q2hhbm5lbEdyb3VwcyYmZGVsZXRlIHQuX2hlYXJ0YmVhdENoYW5uZWxHcm91cHNbZV19KSwhMT09PXRoaXMuX2NvbmZpZy5zdXBwcmVzc0xlYXZlRXZlbnRzJiZ0aGlzLl9sZWF2ZUVuZHBvaW50KHtjaGFubmVsczppLGNoYW5uZWxHcm91cHM6c30sZnVuY3Rpb24oZSl7dC5fbGlzdGVuZXJNYW5hZ2VyLmFubm91bmNlU3RhdHVzKGUpfSkpLHRoaXMucmVjb25uZWN0KCl9fSx7a2V5OlwiYWRhcHRTdWJzY3JpYmVDaGFuZ2VcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLG49ZS50aW1ldG9rZW4scj1lLmNoYW5uZWxzLGk9dm9pZCAwPT09cj9bXTpyLG89ZS5jaGFubmVsR3JvdXBzLHM9dm9pZCAwPT09bz9bXTpvLGE9ZS53aXRoUHJlc2VuY2UsdT12b2lkIDAhPT1hJiZhLGM9ZS53aXRoSGVhcnRiZWF0cyxmPXZvaWQgMCE9PWMmJmM7dGhpcy5fY29uZmlnLnN1YnNjcmliZUtleSYmXCJcIiE9PXRoaXMuX2NvbmZpZy5zdWJzY3JpYmVLZXk/KG4mJih0aGlzLl9sYXN0VGltZXRva2VuPXRoaXMuX2N1cnJlbnRUaW1ldG9rZW4sdGhpcy5fY3VycmVudFRpbWV0b2tlbj1uKSxcIjBcIiE9PXRoaXMuX2N1cnJlbnRUaW1ldG9rZW4mJjAhPT10aGlzLl9jdXJyZW50VGltZXRva2VuJiYodGhpcy5fc3RvcmVkVGltZXRva2VuPXRoaXMuX2N1cnJlbnRUaW1ldG9rZW4sdGhpcy5fY3VycmVudFRpbWV0b2tlbj0wKSxpLmZvckVhY2goZnVuY3Rpb24oZSl7dC5fY2hhbm5lbHNbZV09e3N0YXRlOnt9fSx1JiYodC5fcHJlc2VuY2VDaGFubmVsc1tlXT17fSksKGZ8fHQuX2NvbmZpZy5nZXRIZWFydGJlYXRJbnRlcnZhbCgpKSYmKHQuX2hlYXJ0YmVhdENoYW5uZWxzW2VdPXt9KSx0Ll9wZW5kaW5nQ2hhbm5lbFN1YnNjcmlwdGlvbnMucHVzaChlKX0pLHMuZm9yRWFjaChmdW5jdGlvbihlKXt0Ll9jaGFubmVsR3JvdXBzW2VdPXtzdGF0ZTp7fX0sdSYmKHQuX3ByZXNlbmNlQ2hhbm5lbEdyb3Vwc1tlXT17fSksKGZ8fHQuX2NvbmZpZy5nZXRIZWFydGJlYXRJbnRlcnZhbCgpKSYmKHQuX2hlYXJ0YmVhdENoYW5uZWxHcm91cHNbZV09e30pLHQuX3BlbmRpbmdDaGFubmVsR3JvdXBTdWJzY3JpcHRpb25zLnB1c2goZSl9KSx0aGlzLl9zdWJzY3JpcHRpb25TdGF0dXNBbm5vdW5jZWQ9ITEsdGhpcy5yZWNvbm5lY3QoKSk6Y29uc29sZSYmY29uc29sZS5sb2cmJmNvbnNvbGUubG9nKFwic3Vic2NyaWJlIGtleSBtaXNzaW5nOyBhYm9ydGluZyBzdWJzY3JpYmVcIil9fSx7a2V5OlwiYWRhcHRVbnN1YnNjcmliZUNoYW5nZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcyxyPWUuY2hhbm5lbHMsaT12b2lkIDA9PT1yP1tdOnIsbz1lLmNoYW5uZWxHcm91cHMscz12b2lkIDA9PT1vP1tdOm8sYT1bXSx1PVtdO2kuZm9yRWFjaChmdW5jdGlvbihlKXtlIGluIG4uX2NoYW5uZWxzJiYoZGVsZXRlIG4uX2NoYW5uZWxzW2VdLGEucHVzaChlKSxlIGluIG4uX2hlYXJ0YmVhdENoYW5uZWxzJiZkZWxldGUgbi5faGVhcnRiZWF0Q2hhbm5lbHNbZV0pLGUgaW4gbi5fcHJlc2VuY2VDaGFubmVscyYmKGRlbGV0ZSBuLl9wcmVzZW5jZUNoYW5uZWxzW2VdLGEucHVzaChlKSl9KSxzLmZvckVhY2goZnVuY3Rpb24oZSl7ZSBpbiBuLl9jaGFubmVsR3JvdXBzJiYoZGVsZXRlIG4uX2NoYW5uZWxHcm91cHNbZV0sdS5wdXNoKGUpLGUgaW4gbi5faGVhcnRiZWF0Q2hhbm5lbEdyb3VwcyYmZGVsZXRlIG4uX2hlYXJ0YmVhdENoYW5uZWxHcm91cHNbZV0pLGUgaW4gbi5fcHJlc2VuY2VDaGFubmVsR3JvdXBzJiYoZGVsZXRlIG4uX2NoYW5uZWxHcm91cHNbZV0sdS5wdXNoKGUpKX0pLDA9PT1hLmxlbmd0aCYmMD09PXUubGVuZ3RofHwoITEhPT10aGlzLl9jb25maWcuc3VwcHJlc3NMZWF2ZUV2ZW50c3x8dHx8dGhpcy5fbGVhdmVFbmRwb2ludCh7Y2hhbm5lbHM6YSxjaGFubmVsR3JvdXBzOnV9LGZ1bmN0aW9uKGUpe2UuYWZmZWN0ZWRDaGFubmVscz1hLGUuYWZmZWN0ZWRDaGFubmVsR3JvdXBzPXUsZS5jdXJyZW50VGltZXRva2VuPW4uX2N1cnJlbnRUaW1ldG9rZW4sZS5sYXN0VGltZXRva2VuPW4uX2xhc3RUaW1ldG9rZW4sbi5fbGlzdGVuZXJNYW5hZ2VyLmFubm91bmNlU3RhdHVzKGUpfSksMD09PU9iamVjdC5rZXlzKHRoaXMuX2NoYW5uZWxzKS5sZW5ndGgmJjA9PT1PYmplY3Qua2V5cyh0aGlzLl9wcmVzZW5jZUNoYW5uZWxzKS5sZW5ndGgmJjA9PT1PYmplY3Qua2V5cyh0aGlzLl9jaGFubmVsR3JvdXBzKS5sZW5ndGgmJjA9PT1PYmplY3Qua2V5cyh0aGlzLl9wcmVzZW5jZUNoYW5uZWxHcm91cHMpLmxlbmd0aCYmKHRoaXMuX2xhc3RUaW1ldG9rZW49MCx0aGlzLl9jdXJyZW50VGltZXRva2VuPTAsdGhpcy5fc3RvcmVkVGltZXRva2VuPW51bGwsdGhpcy5fcmVnaW9uPW51bGwsdGhpcy5fcmVjb25uZWN0aW9uTWFuYWdlci5zdG9wUG9sbGluZygpKSx0aGlzLnJlY29ubmVjdCgpKX19LHtrZXk6XCJ1bnN1YnNjcmliZUFsbFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuYWRhcHRVbnN1YnNjcmliZUNoYW5nZSh7Y2hhbm5lbHM6dGhpcy5nZXRTdWJzY3JpYmVkQ2hhbm5lbHMoKSxjaGFubmVsR3JvdXBzOnRoaXMuZ2V0U3Vic2NyaWJlZENoYW5uZWxHcm91cHMoKX0sZSl9fSx7a2V5OlwiZ2V0SGVhcnRiZWF0Q2hhbm5lbHNcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBPYmplY3Qua2V5cyh0aGlzLl9oZWFydGJlYXRDaGFubmVscyl9fSx7a2V5OlwiZ2V0SGVhcnRiZWF0Q2hhbm5lbEdyb3Vwc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2hlYXJ0YmVhdENoYW5uZWxHcm91cHMpfX0se2tleTpcImdldFN1YnNjcmliZWRDaGFubmVsc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2NoYW5uZWxzKX19LHtrZXk6XCJnZXRTdWJzY3JpYmVkQ2hhbm5lbEdyb3Vwc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2NoYW5uZWxHcm91cHMpfX0se2tleTpcInJlY29ubmVjdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fc3RhcnRTdWJzY3JpYmVMb29wKCksdGhpcy5fcmVnaXN0ZXJIZWFydGJlYXRUaW1lcigpfX0se2tleTpcImRpc2Nvbm5lY3RcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3N0b3BTdWJzY3JpYmVMb29wKCksdGhpcy5fc3RvcEhlYXJ0YmVhdFRpbWVyKCksdGhpcy5fcmVjb25uZWN0aW9uTWFuYWdlci5zdG9wUG9sbGluZygpfX0se2tleTpcIl9yZWdpc3RlckhlYXJ0YmVhdFRpbWVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9zdG9wSGVhcnRiZWF0VGltZXIoKSwwIT09dGhpcy5fY29uZmlnLmdldEhlYXJ0YmVhdEludGVydmFsKCkmJih0aGlzLl9wZXJmb3JtSGVhcnRiZWF0TG9vcCgpLHRoaXMuX2hlYXJ0YmVhdFRpbWVyPXNldEludGVydmFsKHRoaXMuX3BlcmZvcm1IZWFydGJlYXRMb29wLmJpbmQodGhpcyksMWUzKnRoaXMuX2NvbmZpZy5nZXRIZWFydGJlYXRJbnRlcnZhbCgpKSl9fSx7a2V5OlwiX3N0b3BIZWFydGJlYXRUaW1lclwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5faGVhcnRiZWF0VGltZXImJihjbGVhckludGVydmFsKHRoaXMuX2hlYXJ0YmVhdFRpbWVyKSx0aGlzLl9oZWFydGJlYXRUaW1lcj1udWxsKX19LHtrZXk6XCJfcGVyZm9ybUhlYXJ0YmVhdExvb3BcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBuPXRoaXMsZT10aGlzLmdldEhlYXJ0YmVhdENoYW5uZWxzKCksdD10aGlzLmdldEhlYXJ0YmVhdENoYW5uZWxHcm91cHMoKSxyPXt9OzA9PT1lLmxlbmd0aCYmMD09PXQubGVuZ3RofHwodGhpcy5nZXRTdWJzY3JpYmVkQ2hhbm5lbHMoKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PW4uX2NoYW5uZWxzW2VdLnN0YXRlO09iamVjdC5rZXlzKHQpLmxlbmd0aCYmKHJbZV09dCl9KSx0aGlzLmdldFN1YnNjcmliZWRDaGFubmVsR3JvdXBzKCkuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1uLl9jaGFubmVsR3JvdXBzW2VdLnN0YXRlO09iamVjdC5rZXlzKHQpLmxlbmd0aCYmKHJbZV09dCl9KSx0aGlzLl9oZWFydGJlYXRFbmRwb2ludCh7Y2hhbm5lbHM6ZSxjaGFubmVsR3JvdXBzOnQsc3RhdGU6cn0sZnVuY3Rpb24oZSl7ZS5lcnJvciYmbi5fY29uZmlnLmFubm91bmNlRmFpbGVkSGVhcnRiZWF0cyYmbi5fbGlzdGVuZXJNYW5hZ2VyLmFubm91bmNlU3RhdHVzKGUpLGUuZXJyb3ImJm4uX2NvbmZpZy5hdXRvTmV0d29ya0RldGVjdGlvbiYmbi5faXNPbmxpbmUmJihuLl9pc09ubGluZT0hMSxuLmRpc2Nvbm5lY3QoKSxuLl9saXN0ZW5lck1hbmFnZXIuYW5ub3VuY2VOZXR3b3JrRG93bigpLG4ucmVjb25uZWN0KCkpLCFlLmVycm9yJiZuLl9jb25maWcuYW5ub3VuY2VTdWNjZXNzZnVsSGVhcnRiZWF0cyYmbi5fbGlzdGVuZXJNYW5hZ2VyLmFubm91bmNlU3RhdHVzKGUpfS5iaW5kKHRoaXMpKSl9fSx7a2V5OlwiX3N0YXJ0U3Vic2NyaWJlTG9vcFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIG49dGhpczt0aGlzLl9zdG9wU3Vic2NyaWJlTG9vcCgpO3ZhciByPXt9LGk9W10sbz1bXTtpZihPYmplY3Qua2V5cyh0aGlzLl9jaGFubmVscykuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1uLl9jaGFubmVsc1tlXS5zdGF0ZTtPYmplY3Qua2V5cyh0KS5sZW5ndGgmJihyW2VdPXQpLGkucHVzaChlKX0pLE9iamVjdC5rZXlzKHRoaXMuX3ByZXNlbmNlQ2hhbm5lbHMpLmZvckVhY2goZnVuY3Rpb24oZSl7aS5wdXNoKFwiXCIuY29uY2F0KGUsXCItcG5wcmVzXCIpKX0pLE9iamVjdC5rZXlzKHRoaXMuX2NoYW5uZWxHcm91cHMpLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9bi5fY2hhbm5lbEdyb3Vwc1tlXS5zdGF0ZTtPYmplY3Qua2V5cyh0KS5sZW5ndGgmJihyW2VdPXQpLG8ucHVzaChlKX0pLE9iamVjdC5rZXlzKHRoaXMuX3ByZXNlbmNlQ2hhbm5lbEdyb3VwcykuZm9yRWFjaChmdW5jdGlvbihlKXtvLnB1c2goXCJcIi5jb25jYXQoZSxcIi1wbnByZXNcIikpfSksMCE9PWkubGVuZ3RofHwwIT09by5sZW5ndGgpe3ZhciBlPXtjaGFubmVsczppLGNoYW5uZWxHcm91cHM6byxzdGF0ZTpyLHRpbWV0b2tlbjp0aGlzLl9jdXJyZW50VGltZXRva2VuLGZpbHRlckV4cHJlc3Npb246dGhpcy5fY29uZmlnLmZpbHRlckV4cHJlc3Npb24scmVnaW9uOnRoaXMuX3JlZ2lvbn07dGhpcy5fc3Vic2NyaWJlQ2FsbD10aGlzLl9zdWJzY3JpYmVFbmRwb2ludChlLHRoaXMuX3Byb2Nlc3NTdWJzY3JpYmVSZXNwb25zZS5iaW5kKHRoaXMpKX19fSx7a2V5OlwiX3Byb2Nlc3NTdWJzY3JpYmVSZXNwb25zZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIGM9dGhpcztpZih0LmVycm9yKXQuY2F0ZWdvcnk9PT1hLmRlZmF1bHQuUE5UaW1lb3V0Q2F0ZWdvcnk/dGhpcy5fc3RhcnRTdWJzY3JpYmVMb29wKCk6KHQuY2F0ZWdvcnk9PT1hLmRlZmF1bHQuUE5OZXR3b3JrSXNzdWVzQ2F0ZWdvcnk/KHRoaXMuZGlzY29ubmVjdCgpLHQuZXJyb3ImJnRoaXMuX2NvbmZpZy5hdXRvTmV0d29ya0RldGVjdGlvbiYmdGhpcy5faXNPbmxpbmUmJih0aGlzLl9pc09ubGluZT0hMSx0aGlzLl9saXN0ZW5lck1hbmFnZXIuYW5ub3VuY2VOZXR3b3JrRG93bigpKSx0aGlzLl9yZWNvbm5lY3Rpb25NYW5hZ2VyLm9uUmVjb25uZWN0aW9uKGZ1bmN0aW9uKCl7Yy5fY29uZmlnLmF1dG9OZXR3b3JrRGV0ZWN0aW9uJiYhYy5faXNPbmxpbmUmJihjLl9pc09ubGluZT0hMCxjLl9saXN0ZW5lck1hbmFnZXIuYW5ub3VuY2VOZXR3b3JrVXAoKSksYy5yZWNvbm5lY3QoKSxjLl9zdWJzY3JpcHRpb25TdGF0dXNBbm5vdW5jZWQ9ITA7dmFyIGU9e2NhdGVnb3J5OmEuZGVmYXVsdC5QTlJlY29ubmVjdGVkQ2F0ZWdvcnksb3BlcmF0aW9uOnQub3BlcmF0aW9uLGxhc3RUaW1ldG9rZW46Yy5fbGFzdFRpbWV0b2tlbixjdXJyZW50VGltZXRva2VuOmMuX2N1cnJlbnRUaW1ldG9rZW59O2MuX2xpc3RlbmVyTWFuYWdlci5hbm5vdW5jZVN0YXR1cyhlKX0pLHRoaXMuX3JlY29ubmVjdGlvbk1hbmFnZXIuc3RhcnRQb2xsaW5nKCkpOnQuY2F0ZWdvcnk9PT1hLmRlZmF1bHQuUE5CYWRSZXF1ZXN0Q2F0ZWdvcnkmJnRoaXMuX3N0b3BIZWFydGJlYXRUaW1lcigpLHRoaXMuX2xpc3RlbmVyTWFuYWdlci5hbm5vdW5jZVN0YXR1cyh0KSk7ZWxzZXtpZih0aGlzLl9zdG9yZWRUaW1ldG9rZW4/KHRoaXMuX2N1cnJlbnRUaW1ldG9rZW49dGhpcy5fc3RvcmVkVGltZXRva2VuLHRoaXMuX3N0b3JlZFRpbWV0b2tlbj1udWxsKToodGhpcy5fbGFzdFRpbWV0b2tlbj10aGlzLl9jdXJyZW50VGltZXRva2VuLHRoaXMuX2N1cnJlbnRUaW1ldG9rZW49ZS5tZXRhZGF0YS50aW1ldG9rZW4pLCF0aGlzLl9zdWJzY3JpcHRpb25TdGF0dXNBbm5vdW5jZWQpe3ZhciBuPXt9O24uY2F0ZWdvcnk9YS5kZWZhdWx0LlBOQ29ubmVjdGVkQ2F0ZWdvcnksbi5vcGVyYXRpb249dC5vcGVyYXRpb24sbi5hZmZlY3RlZENoYW5uZWxzPXRoaXMuX3BlbmRpbmdDaGFubmVsU3Vic2NyaXB0aW9ucyxuLnN1YnNjcmliZWRDaGFubmVscz10aGlzLmdldFN1YnNjcmliZWRDaGFubmVscygpLG4uYWZmZWN0ZWRDaGFubmVsR3JvdXBzPXRoaXMuX3BlbmRpbmdDaGFubmVsR3JvdXBTdWJzY3JpcHRpb25zLG4ubGFzdFRpbWV0b2tlbj10aGlzLl9sYXN0VGltZXRva2VuLG4uY3VycmVudFRpbWV0b2tlbj10aGlzLl9jdXJyZW50VGltZXRva2VuLHRoaXMuX3N1YnNjcmlwdGlvblN0YXR1c0Fubm91bmNlZD0hMCx0aGlzLl9saXN0ZW5lck1hbmFnZXIuYW5ub3VuY2VTdGF0dXMobiksdGhpcy5fcGVuZGluZ0NoYW5uZWxTdWJzY3JpcHRpb25zPVtdLHRoaXMuX3BlbmRpbmdDaGFubmVsR3JvdXBTdWJzY3JpcHRpb25zPVtdfXZhciByPWUubWVzc2FnZXN8fFtdLGk9dGhpcy5fY29uZmlnLG89aS5yZXF1ZXN0TWVzc2FnZUNvdW50VGhyZXNob2xkLGY9aS5kZWR1cGVPblN1YnNjcmliZTtpZihvJiZyLmxlbmd0aD49byl7dmFyIHM9e307cy5jYXRlZ29yeT1hLmRlZmF1bHQuUE5SZXF1ZXN0TWVzc2FnZUNvdW50RXhjZWVkZWRDYXRlZ29yeSxzLm9wZXJhdGlvbj10Lm9wZXJhdGlvbix0aGlzLl9saXN0ZW5lck1hbmFnZXIuYW5ub3VuY2VTdGF0dXMocyl9ci5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PWUuY2hhbm5lbCxuPWUuc3Vic2NyaXB0aW9uTWF0Y2gscj1lLnB1Ymxpc2hNZXRhRGF0YTtpZih0PT09biYmKG49bnVsbCksZil7aWYoYy5fZGVkdXBpbmdNYW5hZ2VyLmlzRHVwbGljYXRlKGUpKXJldHVybjtjLl9kZWR1cGluZ01hbmFnZXIuYWRkRW50cnkoZSl9aWYobC5kZWZhdWx0LmVuZHNXaXRoKGUuY2hhbm5lbCxcIi1wbnByZXNcIikpe3ZhciBpPXtjaGFubmVsOm51bGwsc3Vic2NyaXB0aW9uOm51bGx9O2kuYWN0dWFsQ2hhbm5lbD1udWxsIT1uP3Q6bnVsbCxpLnN1YnNjcmliZWRDaGFubmVsPW51bGwhPW4/bjp0LHQmJihpLmNoYW5uZWw9dC5zdWJzdHJpbmcoMCx0Lmxhc3RJbmRleE9mKFwiLXBucHJlc1wiKSkpLG4mJihpLnN1YnNjcmlwdGlvbj1uLnN1YnN0cmluZygwLG4ubGFzdEluZGV4T2YoXCItcG5wcmVzXCIpKSksaS5hY3Rpb249ZS5wYXlsb2FkLmFjdGlvbixpLnN0YXRlPWUucGF5bG9hZC5kYXRhLGkudGltZXRva2VuPXIucHVibGlzaFRpbWV0b2tlbixpLm9jY3VwYW5jeT1lLnBheWxvYWQub2NjdXBhbmN5LGkudXVpZD1lLnBheWxvYWQudXVpZCxpLnRpbWVzdGFtcD1lLnBheWxvYWQudGltZXN0YW1wLGUucGF5bG9hZC5qb2luJiYoaS5qb2luPWUucGF5bG9hZC5qb2luKSxlLnBheWxvYWQubGVhdmUmJihpLmxlYXZlPWUucGF5bG9hZC5sZWF2ZSksZS5wYXlsb2FkLnRpbWVvdXQmJihpLnRpbWVvdXQ9ZS5wYXlsb2FkLnRpbWVvdXQpLGMuX2xpc3RlbmVyTWFuYWdlci5hbm5vdW5jZVByZXNlbmNlKGkpfWVsc2UgaWYoMT09PWUubWVzc2FnZVR5cGUpe3ZhciBvPXtjaGFubmVsOm51bGwsc3Vic2NyaXB0aW9uOm51bGx9O28uY2hhbm5lbD10LG8uc3Vic2NyaXB0aW9uPW4sby50aW1ldG9rZW49ci5wdWJsaXNoVGltZXRva2VuLG8ucHVibGlzaGVyPWUuaXNzdWluZ0NsaWVudElkLGUudXNlck1ldGFkYXRhJiYoby51c2VyTWV0YWRhdGE9ZS51c2VyTWV0YWRhdGEpLG8ubWVzc2FnZT1lLnBheWxvYWQsYy5fbGlzdGVuZXJNYW5hZ2VyLmFubm91bmNlU2lnbmFsKG8pfWVsc2UgaWYoMj09PWUubWVzc2FnZVR5cGUpe3ZhciBzPXtjaGFubmVsOm51bGwsc3Vic2NyaXB0aW9uOm51bGx9O3MuY2hhbm5lbD10LHMuc3Vic2NyaXB0aW9uPW4scy50aW1ldG9rZW49ci5wdWJsaXNoVGltZXRva2VuLHMucHVibGlzaGVyPWUuaXNzdWluZ0NsaWVudElkLGUudXNlck1ldGFkYXRhJiYocy51c2VyTWV0YWRhdGE9ZS51c2VyTWV0YWRhdGEpLHMubWVzc2FnZT17ZXZlbnQ6ZS5wYXlsb2FkLmV2ZW50LHR5cGU6ZS5wYXlsb2FkLnR5cGUsZGF0YTplLnBheWxvYWQuZGF0YX0sXCJ1c2VyXCI9PT1lLnBheWxvYWQudHlwZT9jLl9saXN0ZW5lck1hbmFnZXIuYW5ub3VuY2VVc2VyKHMpOlwic3BhY2VcIj09PWUucGF5bG9hZC50eXBlP2MuX2xpc3RlbmVyTWFuYWdlci5hbm5vdW5jZVNwYWNlKHMpOlwibWVtYmVyc2hpcFwiPT09ZS5wYXlsb2FkLnR5cGUmJmMuX2xpc3RlbmVyTWFuYWdlci5hbm5vdW5jZU1lbWJlcnNoaXAocyl9ZWxzZSBpZigzPT09ZS5tZXNzYWdlVHlwZSl7dmFyIGE9e307YS5jaGFubmVsPXQsYS5zdWJzY3JpcHRpb249bixhLnRpbWV0b2tlbj1yLnB1Ymxpc2hUaW1ldG9rZW4sYS5wdWJsaXNoZXI9ZS5pc3N1aW5nQ2xpZW50SWQsYS5kYXRhPXttZXNzYWdlVGltZXRva2VuOmUucGF5bG9hZC5kYXRhLm1lc3NhZ2VUaW1ldG9rZW4sYWN0aW9uVGltZXRva2VuOmUucGF5bG9hZC5kYXRhLmFjdGlvblRpbWV0b2tlbix0eXBlOmUucGF5bG9hZC5kYXRhLnR5cGUsdXVpZDplLmlzc3VpbmdDbGllbnRJZCx2YWx1ZTplLnBheWxvYWQuZGF0YS52YWx1ZX0sYS5ldmVudD1lLnBheWxvYWQuZXZlbnQsYy5fbGlzdGVuZXJNYW5hZ2VyLmFubm91bmNlTWVzc2FnZUFjdGlvbihhKX1lbHNle3ZhciB1PXtjaGFubmVsOm51bGwsc3Vic2NyaXB0aW9uOm51bGx9O3UuYWN0dWFsQ2hhbm5lbD1udWxsIT1uP3Q6bnVsbCx1LnN1YnNjcmliZWRDaGFubmVsPW51bGwhPW4/bjp0LHUuY2hhbm5lbD10LHUuc3Vic2NyaXB0aW9uPW4sdS50aW1ldG9rZW49ci5wdWJsaXNoVGltZXRva2VuLHUucHVibGlzaGVyPWUuaXNzdWluZ0NsaWVudElkLGUudXNlck1ldGFkYXRhJiYodS51c2VyTWV0YWRhdGE9ZS51c2VyTWV0YWRhdGEpLGMuX2NvbmZpZy5jaXBoZXJLZXk/dS5tZXNzYWdlPWMuX2NyeXB0by5kZWNyeXB0KGUucGF5bG9hZCk6dS5tZXNzYWdlPWUucGF5bG9hZCxjLl9saXN0ZW5lck1hbmFnZXIuYW5ub3VuY2VNZXNzYWdlKHUpfX0pLHRoaXMuX3JlZ2lvbj1lLm1ldGFkYXRhLnJlZ2lvbix0aGlzLl9zdGFydFN1YnNjcmliZUxvb3AoKX19fSx7a2V5OlwiX3N0b3BTdWJzY3JpYmVMb29wXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9zdWJzY3JpYmVDYWxsJiYoXCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5fc3Vic2NyaWJlQ2FsbC5hYm9ydCYmdGhpcy5fc3Vic2NyaWJlQ2FsbC5hYm9ydCgpLHRoaXMuX3N1YnNjcmliZUNhbGw9bnVsbCl9fV0pJiZpKG8ucHJvdG90eXBlLHMpLHZvaWQodSYmaShvLHUpKSxkKTtmdW5jdGlvbiBkKGUpe3ZhciB0PWUuc3Vic2NyaWJlRW5kcG9pbnQsbj1lLmxlYXZlRW5kcG9pbnQscj1lLmhlYXJ0YmVhdEVuZHBvaW50LGk9ZS5zZXRTdGF0ZUVuZHBvaW50LG89ZS50aW1lRW5kcG9pbnQscz1lLmNvbmZpZyxhPWUuY3J5cHRvLHU9ZS5saXN0ZW5lck1hbmFnZXI7IWZ1bmN0aW9uKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxkKSxoKHRoaXMsXCJfY3J5cHRvXCIsdm9pZCAwKSxoKHRoaXMsXCJfY29uZmlnXCIsdm9pZCAwKSxoKHRoaXMsXCJfbGlzdGVuZXJNYW5hZ2VyXCIsdm9pZCAwKSxoKHRoaXMsXCJfcmVjb25uZWN0aW9uTWFuYWdlclwiLHZvaWQgMCksaCh0aGlzLFwiX2xlYXZlRW5kcG9pbnRcIix2b2lkIDApLGgodGhpcyxcIl9oZWFydGJlYXRFbmRwb2ludFwiLHZvaWQgMCksaCh0aGlzLFwiX3NldFN0YXRlRW5kcG9pbnRcIix2b2lkIDApLGgodGhpcyxcIl9zdWJzY3JpYmVFbmRwb2ludFwiLHZvaWQgMCksaCh0aGlzLFwiX2NoYW5uZWxzXCIsdm9pZCAwKSxoKHRoaXMsXCJfcHJlc2VuY2VDaGFubmVsc1wiLHZvaWQgMCksaCh0aGlzLFwiX2hlYXJ0YmVhdENoYW5uZWxzXCIsdm9pZCAwKSxoKHRoaXMsXCJfaGVhcnRiZWF0Q2hhbm5lbEdyb3Vwc1wiLHZvaWQgMCksaCh0aGlzLFwiX2NoYW5uZWxHcm91cHNcIix2b2lkIDApLGgodGhpcyxcIl9wcmVzZW5jZUNoYW5uZWxHcm91cHNcIix2b2lkIDApLGgodGhpcyxcIl9jdXJyZW50VGltZXRva2VuXCIsdm9pZCAwKSxoKHRoaXMsXCJfbGFzdFRpbWV0b2tlblwiLHZvaWQgMCksaCh0aGlzLFwiX3N0b3JlZFRpbWV0b2tlblwiLHZvaWQgMCksaCh0aGlzLFwiX3JlZ2lvblwiLHZvaWQgMCksaCh0aGlzLFwiX3N1YnNjcmliZUNhbGxcIix2b2lkIDApLGgodGhpcyxcIl9oZWFydGJlYXRUaW1lclwiLHZvaWQgMCksaCh0aGlzLFwiX3N1YnNjcmlwdGlvblN0YXR1c0Fubm91bmNlZFwiLHZvaWQgMCksaCh0aGlzLFwiX2F1dG9OZXR3b3JrRGV0ZWN0aW9uXCIsdm9pZCAwKSxoKHRoaXMsXCJfaXNPbmxpbmVcIix2b2lkIDApLGgodGhpcyxcIl9wZW5kaW5nQ2hhbm5lbFN1YnNjcmlwdGlvbnNcIix2b2lkIDApLGgodGhpcyxcIl9wZW5kaW5nQ2hhbm5lbEdyb3VwU3Vic2NyaXB0aW9uc1wiLHZvaWQgMCksaCh0aGlzLFwiX2RlZHVwaW5nTWFuYWdlclwiLHZvaWQgMCksdGhpcy5fbGlzdGVuZXJNYW5hZ2VyPXUsdGhpcy5fY29uZmlnPXMsdGhpcy5fbGVhdmVFbmRwb2ludD1uLHRoaXMuX2hlYXJ0YmVhdEVuZHBvaW50PXIsdGhpcy5fc2V0U3RhdGVFbmRwb2ludD1pLHRoaXMuX3N1YnNjcmliZUVuZHBvaW50PXQsdGhpcy5fY3J5cHRvPWEsdGhpcy5fY2hhbm5lbHM9e30sdGhpcy5fcHJlc2VuY2VDaGFubmVscz17fSx0aGlzLl9oZWFydGJlYXRDaGFubmVscz17fSx0aGlzLl9oZWFydGJlYXRDaGFubmVsR3JvdXBzPXt9LHRoaXMuX2NoYW5uZWxHcm91cHM9e30sdGhpcy5fcHJlc2VuY2VDaGFubmVsR3JvdXBzPXt9LHRoaXMuX3BlbmRpbmdDaGFubmVsU3Vic2NyaXB0aW9ucz1bXSx0aGlzLl9wZW5kaW5nQ2hhbm5lbEdyb3VwU3Vic2NyaXB0aW9ucz1bXSx0aGlzLl9jdXJyZW50VGltZXRva2VuPTAsdGhpcy5fbGFzdFRpbWV0b2tlbj0wLHRoaXMuX3N0b3JlZFRpbWV0b2tlbj1udWxsLHRoaXMuX3N1YnNjcmlwdGlvblN0YXR1c0Fubm91bmNlZD0hMSx0aGlzLl9pc09ubGluZT0hMCx0aGlzLl9yZWNvbm5lY3Rpb25NYW5hZ2VyPW5ldyBjLmRlZmF1bHQoe3RpbWVFbmRwb2ludDpvfSksdGhpcy5fZGVkdXBpbmdNYW5hZ2VyPW5ldyBmLmRlZmF1bHQoe2NvbmZpZzpzfSl9dC5kZWZhdWx0PXAsZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD12b2lkIDA7dmFyIHI7KHI9big4KSkmJnIuX19lc01vZHVsZSxuKDApO2Z1bmN0aW9uIGkoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsci5rZXkscil9fWZ1bmN0aW9uIG8oZSx0LG4pe3JldHVybiB0IGluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbdF09bixlfXZhciBzLGEsdSxjPShzPWYsKGE9W3trZXk6XCJvblJlY29ubmVjdGlvblwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuX3JlY29ubmVjdGlvbkNhbGxiYWNrPWV9fSx7a2V5Olwic3RhcnRQb2xsaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl90aW1lVGltZXI9c2V0SW50ZXJ2YWwodGhpcy5fcGVyZm9ybVRpbWVMb29wLmJpbmQodGhpcyksM2UzKX19LHtrZXk6XCJzdG9wUG9sbGluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7Y2xlYXJJbnRlcnZhbCh0aGlzLl90aW1lVGltZXIpfX0se2tleTpcIl9wZXJmb3JtVGltZUxvb3BcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy5fdGltZUVuZHBvaW50KGZ1bmN0aW9uKGUpe2UuZXJyb3J8fChjbGVhckludGVydmFsKHQuX3RpbWVUaW1lciksdC5fcmVjb25uZWN0aW9uQ2FsbGJhY2soKSl9KX19XSkmJmkocy5wcm90b3R5cGUsYSksdm9pZCh1JiZpKHMsdSkpLGYpO2Z1bmN0aW9uIGYoZSl7dmFyIHQ9ZS50aW1lRW5kcG9pbnQ7IWZ1bmN0aW9uKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxmKSxvKHRoaXMsXCJfcmVjb25uZWN0aW9uQ2FsbGJhY2tcIix2b2lkIDApLG8odGhpcyxcIl90aW1lRW5kcG9pbnRcIix2b2lkIDApLG8odGhpcyxcIl90aW1lVGltZXJcIix2b2lkIDApLHRoaXMuX3RpbWVFbmRwb2ludD10fXQuZGVmYXVsdD1jLGUuZXhwb3J0cz10LmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9dm9pZCAwO3ZhciByOyhyPW4oMykpJiZyLl9fZXNNb2R1bGUsbigwKTtmdW5jdGlvbiBpKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1mdW5jdGlvbiBvKGUsdCxuKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPW4sZX12YXIgcyxhLHUsYz0ocz1mLChhPVt7a2V5OlwiZ2V0S2V5XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZnVuY3Rpb24oZSl7dmFyIHQ9MDtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIHQ7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKz0xKXQ9KHQ8PDUpLXQrZS5jaGFyQ29kZUF0KG4pLHQmPXQ7cmV0dXJuIHR9KEpTT04uc3RyaW5naWZ5KGUucGF5bG9hZCkpLnRvU3RyaW5nKCksbj1lLnB1Ymxpc2hNZXRhRGF0YS5wdWJsaXNoVGltZXRva2VuO3JldHVyblwiXCIuY29uY2F0KG4sXCItXCIpLmNvbmNhdCh0KX19LHtrZXk6XCJpc0R1cGxpY2F0ZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmhhc2hIaXN0b3J5LmluY2x1ZGVzKHRoaXMuZ2V0S2V5KGUpKX19LHtrZXk6XCJhZGRFbnRyeVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuaGFzaEhpc3RvcnkubGVuZ3RoPj10aGlzLl9jb25maWcubWF4aW11bUNhY2hlU2l6ZSYmdGhpcy5oYXNoSGlzdG9yeS5zaGlmdCgpLHRoaXMuaGFzaEhpc3RvcnkucHVzaCh0aGlzLmdldEtleShlKSl9fSx7a2V5OlwiY2xlYXJIaXN0b3J5XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmhhc2hIaXN0b3J5PVtdfX1dKSYmaShzLnByb3RvdHlwZSxhKSx2b2lkKHUmJmkocyx1KSksZik7ZnVuY3Rpb24gZihlKXt2YXIgdD1lLmNvbmZpZzshZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGYpLG8odGhpcyxcIl9jb25maWdcIix2b2lkIDApLG8odGhpcyxcImhhc2hIaXN0b3J5XCIsdm9pZCAwKSx0aGlzLmhhc2hIaXN0b3J5PVtdLHRoaXMuX2NvbmZpZz10fXQuZGVmYXVsdD1jLGUuZXhwb3J0cz10LmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9dC5GQ01Ob3RpZmljYXRpb25QYXlsb2FkPXQuTVBOU05vdGlmaWNhdGlvblBheWxvYWQ9dC5BUE5TTm90aWZpY2F0aW9uUGF5bG9hZD12b2lkIDA7bigwKTtmdW5jdGlvbiByKGUpe3JldHVybihyPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9KShlKX1mdW5jdGlvbiBpKGUsdCl7aWYobnVsbD09ZSlyZXR1cm57fTt2YXIgbixyLGk9ZnVuY3Rpb24oZSx0KXtpZihudWxsPT1lKXJldHVybnt9O3ZhciBuLHIsaT17fSxvPU9iamVjdC5rZXlzKGUpO2ZvcihyPTA7cjxvLmxlbmd0aDtyKyspbj1vW3JdLDA8PXQuaW5kZXhPZihuKXx8KGlbbl09ZVtuXSk7cmV0dXJuIGl9KGUsdCk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIG89T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtmb3Iocj0wO3I8by5sZW5ndGg7cisrKW49b1tyXSwwPD10LmluZGV4T2Yobil8fE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLG4pJiYoaVtuXT1lW25dKX1yZXR1cm4gaX1mdW5jdGlvbiBvKHQsZSl7dmFyIG49T2JqZWN0LmtleXModCk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIHI9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0KTtlJiYocj1yLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LGUpLmVudW1lcmFibGV9KSksbi5wdXNoLmFwcGx5KG4scil9cmV0dXJuIG59ZnVuY3Rpb24gcyh0KXtmb3IodmFyIGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXt2YXIgbj1udWxsIT1hcmd1bWVudHNbZV0/YXJndW1lbnRzW2VdOnt9O2UlMj9vKE9iamVjdChuKSwhMCkuZm9yRWFjaChmdW5jdGlvbihlKXtnKHQsZSxuW2VdKX0pOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobikpOm8oT2JqZWN0KG4pKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLGUpKX0pfXJldHVybiB0fWZ1bmN0aW9uIGEoZSx0KXtyZXR1cm4hdHx8XCJvYmplY3RcIiE9PXIodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/YyhlKTp0fWZ1bmN0aW9uIHUoZSl7cmV0dXJuKHU9T2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5nZXRQcm90b3R5cGVPZjpmdW5jdGlvbihlKXtyZXR1cm4gZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKX0pKGUpfWZ1bmN0aW9uIGMoZSl7aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIGV9ZnVuY3Rpb24gZihlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmbChlLHQpfWZ1bmN0aW9uIGwoZSx0KXtyZXR1cm4obD1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuX19wcm90b19fPXQsZX0pKGUsdCl9ZnVuY3Rpb24gaChlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gcChlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19ZnVuY3Rpb24gZChlLHQsbil7cmV0dXJuIHQmJnAoZS5wcm90b3R5cGUsdCksbiYmcChlLG4pLGV9ZnVuY3Rpb24gZyhlLHQsbil7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1uLGV9dmFyIHk9KGQodixbe2tleTpcInBheWxvYWRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcGF5bG9hZH19LHtrZXk6XCJ0aXRsZVwiLHNldDpmdW5jdGlvbihlKXt0aGlzLl90aXRsZT1lfX0se2tleTpcInN1YnRpdGxlXCIsc2V0OmZ1bmN0aW9uKGUpe3RoaXMuX3N1YnRpdGxlPWV9fSx7a2V5OlwiYm9keVwiLHNldDpmdW5jdGlvbihlKXt0aGlzLl9ib2R5PWV9fSx7a2V5OlwiYmFkZ2VcIixzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5fYmFkZ2U9ZX19LHtrZXk6XCJzb3VuZFwiLHNldDpmdW5jdGlvbihlKXt0aGlzLl9zb3VuZD1lfX1dKSxkKHYsW3trZXk6XCJfc2V0RGVmYXVsdFBheWxvYWRTdHJ1Y3R1cmVcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJ0b09iamVjdFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJue319fV0pLHYpO2Z1bmN0aW9uIHYoZSx0LG4pe2godGhpcyx2KSxnKHRoaXMsXCJfc3VidGl0bGVcIix2b2lkIDApLGcodGhpcyxcIl9wYXlsb2FkXCIsdm9pZCAwKSxnKHRoaXMsXCJfYmFkZ2VcIix2b2lkIDApLGcodGhpcyxcIl9zb3VuZFwiLHZvaWQgMCksZyh0aGlzLFwiX3RpdGxlXCIsdm9pZCAwKSxnKHRoaXMsXCJfYm9keVwiLHZvaWQgMCksdGhpcy5fcGF5bG9hZD1lLHRoaXMuX3NldERlZmF1bHRQYXlsb2FkU3RydWN0dXJlKCksdGhpcy50aXRsZT10LHRoaXMuYm9keT1ufXZhciBiPShmKG0seSksZChtLFt7a2V5OlwiX3NldERlZmF1bHRQYXlsb2FkU3RydWN0dXJlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9wYXlsb2FkLmFwcz17YWxlcnQ6e319fX0se2tleTpcInRvT2JqZWN0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9cyh7fSx0aGlzLl9wYXlsb2FkKSxuPWUuYXBzLHI9bi5hbGVydDtpZih0aGlzLl9pc1NpbGVudCYmKG5bXCJjb250ZW50LWF2YWlsYWJsZVwiXT0xKSxcImFwbnMyXCI9PT10aGlzLl9hcG5zUHVzaFR5cGUpe2lmKCF0aGlzLl9jb25maWd1cmF0aW9uc3x8IXRoaXMuX2NvbmZpZ3VyYXRpb25zLmxlbmd0aCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJBUE5TMiBjb25maWd1cmF0aW9uIGlzIG1pc3NpbmdcIik7dmFyIGk9W107dGhpcy5fY29uZmlndXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbihlKXtpLnB1c2godC5fb2JqZWN0RnJvbUFQTlMyQ29uZmlndXJhdGlvbihlKSl9KSxpLmxlbmd0aCYmKGUucG5fcHVzaD1pKX1yZXR1cm4gciYmT2JqZWN0LmtleXMocikubGVuZ3RofHxkZWxldGUgbi5hbGVydCx0aGlzLl9pc1NpbGVudCYmKGRlbGV0ZSBuLmFsZXJ0LGRlbGV0ZSBuLmJhZGdlLGRlbGV0ZSBuLnNvdW5kLHI9e30pLHRoaXMuX2lzU2lsZW50fHxPYmplY3Qua2V5cyhyKS5sZW5ndGg/ZTpudWxsfX0se2tleTpcIl9vYmplY3RGcm9tQVBOUzJDb25maWd1cmF0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztpZighZS50YXJnZXRzfHwhZS50YXJnZXRzLmxlbmd0aCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJBdCBsZWFzdCBvbmUgQVBOUzIgdGFyZ2V0IHNob3VsZCBiZSBwcm92aWRlZFwiKTt2YXIgbj1bXTtlLnRhcmdldHMuZm9yRWFjaChmdW5jdGlvbihlKXtuLnB1c2godC5fb2JqZWN0RnJvbUFQTlNUYXJnZXQoZSkpfSk7dmFyIHI9ZS5jb2xsYXBzZUlkLGk9ZS5leHBpcmF0aW9uRGF0ZSxvPXthdXRoX21ldGhvZDpcInRva2VuXCIsdGFyZ2V0czpuLHZlcnNpb246XCJ2MlwifTtyZXR1cm4gciYmci5sZW5ndGgmJihvLmNvbGxhcHNlX2lkPXIpLGkmJihvLmV4cGlyYXRpb249aS50b0lTT1N0cmluZygpKSxvfX0se2tleTpcIl9vYmplY3RGcm9tQVBOU1RhcmdldFwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKCFlLnRvcGljfHwhZS50b3BpYy5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRhcmdldCAndG9waWMnIHVuZGVmaW5lZC5cIik7dmFyIHQ9ZS50b3BpYyxuPWUuZW52aXJvbm1lbnQscj12b2lkIDA9PT1uP1wiZGV2ZWxvcG1lbnRcIjpuLGk9ZS5leGNsdWRlZERldmljZXMsbz12b2lkIDA9PT1pP1tdOmkscz17dG9waWM6dCxlbnZpcm9ubWVudDpyfTtyZXR1cm4gby5sZW5ndGgmJihzLmV4Y2x1ZGVkX2RldmljZXM9byksc319LHtrZXk6XCJjb25maWd1cmF0aW9uc1wiLHNldDpmdW5jdGlvbihlKXtlJiZlLmxlbmd0aCYmKHRoaXMuX2NvbmZpZ3VyYXRpb25zPWUpfX0se2tleTpcIm5vdGlmaWNhdGlvblwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9wYXlsb2FkLmFwc319LHtrZXk6XCJ0aXRsZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl90aXRsZX0sc2V0OmZ1bmN0aW9uKGUpe2UmJmUubGVuZ3RoJiYodGhpcy5fcGF5bG9hZC5hcHMuYWxlcnQudGl0bGU9ZSx0aGlzLl90aXRsZT1lKX19LHtrZXk6XCJzdWJ0aXRsZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zdWJ0aXRsZX0sc2V0OmZ1bmN0aW9uKGUpe2UmJmUubGVuZ3RoJiYodGhpcy5fcGF5bG9hZC5hcHMuYWxlcnQuc3VidGl0bGU9ZSx0aGlzLl9zdWJ0aXRsZT1lKX19LHtrZXk6XCJib2R5XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2JvZHl9LHNldDpmdW5jdGlvbihlKXtlJiZlLmxlbmd0aCYmKHRoaXMuX3BheWxvYWQuYXBzLmFsZXJ0LmJvZHk9ZSx0aGlzLl9ib2R5PWUpfX0se2tleTpcImJhZGdlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2JhZGdlfSxzZXQ6ZnVuY3Rpb24oZSl7bnVsbCE9ZSYmKHRoaXMuX3BheWxvYWQuYXBzLmJhZGdlPWUsdGhpcy5fYmFkZ2U9ZSl9fSx7a2V5Olwic291bmRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc291bmR9LHNldDpmdW5jdGlvbihlKXtlJiZlLmxlbmd0aCYmKHRoaXMuX3BheWxvYWQuYXBzLnNvdW5kPWUsdGhpcy5fc291bmQ9ZSl9fSx7a2V5Olwic2lsZW50XCIsc2V0OmZ1bmN0aW9uKGUpe3RoaXMuX2lzU2lsZW50PWV9fV0pLG0pO2Z1bmN0aW9uIG0oKXt2YXIgZSx0O2godGhpcyxtKTtmb3IodmFyIG49YXJndW1lbnRzLmxlbmd0aCxyPW5ldyBBcnJheShuKSxpPTA7aTxuO2krKylyW2ldPWFyZ3VtZW50c1tpXTtyZXR1cm4gZyhjKHQ9YSh0aGlzLChlPXUobSkpLmNhbGwuYXBwbHkoZSxbdGhpc10uY29uY2F0KHIpKSkpLFwiX2NvbmZpZ3VyYXRpb25zXCIsdm9pZCAwKSxnKGModCksXCJfYXBuc1B1c2hUeXBlXCIsdm9pZCAwKSxnKGModCksXCJfaXNTaWxlbnRcIix2b2lkIDApLHR9dC5BUE5TTm90aWZpY2F0aW9uUGF5bG9hZD1iO3ZhciBfPShmKGsseSksZChrLFt7a2V5OlwidG9PYmplY3RcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBPYmplY3Qua2V5cyh0aGlzLl9wYXlsb2FkKS5sZW5ndGg/cyh7fSx0aGlzLl9wYXlsb2FkKTpudWxsfX0se2tleTpcImJhY2tDb250ZW50XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2JhY2tDb250ZW50fSxzZXQ6ZnVuY3Rpb24oZSl7ZSYmZS5sZW5ndGgmJih0aGlzLl9wYXlsb2FkLmJhY2tfY29udGVudD1lLHRoaXMuX2JhY2tDb250ZW50PWUpfX0se2tleTpcImJhY2tUaXRsZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9iYWNrVGl0bGV9LHNldDpmdW5jdGlvbihlKXtlJiZlLmxlbmd0aCYmKHRoaXMuX3BheWxvYWQuYmFja190aXRsZT1lLHRoaXMuX2JhY2tUaXRsZT1lKX19LHtrZXk6XCJjb3VudFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jb3VudH0sc2V0OmZ1bmN0aW9uKGUpe251bGwhPWUmJih0aGlzLl9wYXlsb2FkLmNvdW50PWUsdGhpcy5fY291bnQ9ZSl9fSx7a2V5OlwidGl0bGVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdGl0bGV9LHNldDpmdW5jdGlvbihlKXtlJiZlLmxlbmd0aCYmKHRoaXMuX3BheWxvYWQudGl0bGU9ZSx0aGlzLl90aXRsZT1lKX19LHtrZXk6XCJ0eXBlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3R5cGV9LHNldDpmdW5jdGlvbihlKXtlJiZlLmxlbmd0aCYmKHRoaXMuX3BheWxvYWQudHlwZT1lLHRoaXMuX3R5cGU9ZSl9fSx7a2V5Olwic3VidGl0bGVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iYWNrVGl0bGV9LHNldDpmdW5jdGlvbihlKXt0aGlzLmJhY2tUaXRsZT1lfX0se2tleTpcImJvZHlcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iYWNrQ29udGVudH0sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuYmFja0NvbnRlbnQ9ZX19LHtrZXk6XCJiYWRnZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvdW50fSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5jb3VudD1lfX1dKSxrKTtmdW5jdGlvbiBrKCl7dmFyIGUsdDtoKHRoaXMsayk7Zm9yKHZhciBuPWFyZ3VtZW50cy5sZW5ndGgscj1uZXcgQXJyYXkobiksaT0wO2k8bjtpKyspcltpXT1hcmd1bWVudHNbaV07cmV0dXJuIGcoYyh0PWEodGhpcywoZT11KGspKS5jYWxsLmFwcGx5KGUsW3RoaXNdLmNvbmNhdChyKSkpKSxcIl9iYWNrQ29udGVudFwiLHZvaWQgMCksZyhjKHQpLFwiX2JhY2tUaXRsZVwiLHZvaWQgMCksZyhjKHQpLFwiX2NvdW50XCIsdm9pZCAwKSxnKGModCksXCJfdHlwZVwiLHZvaWQgMCksdH10Lk1QTlNOb3RpZmljYXRpb25QYXlsb2FkPV87dmFyIFA9KGYodyx5KSxkKHcsW3trZXk6XCJfc2V0RGVmYXVsdFBheWxvYWRTdHJ1Y3R1cmVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3BheWxvYWQubm90aWZpY2F0aW9uPXt9LHRoaXMuX3BheWxvYWQuZGF0YT17fX19LHtrZXk6XCJ0b09iamVjdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9cyh7fSx0aGlzLl9wYXlsb2FkLmRhdGEpLHQ9bnVsbCxuPXt9O2lmKDI8T2JqZWN0LmtleXModGhpcy5fcGF5bG9hZCkubGVuZ3RoKXt2YXIgcj10aGlzLl9wYXlsb2FkO3Iubm90aWZpY2F0aW9uLHIuZGF0YSxlPXMoe30sZSx7fSxpKHIsW1wibm90aWZpY2F0aW9uXCIsXCJkYXRhXCJdKSl9cmV0dXJuIHRoaXMuX2lzU2lsZW50P2Uubm90aWZpY2F0aW9uPXRoaXMuX3BheWxvYWQubm90aWZpY2F0aW9uOnQ9dGhpcy5fcGF5bG9hZC5ub3RpZmljYXRpb24sT2JqZWN0LmtleXMoZSkubGVuZ3RoJiYobi5kYXRhPWUpLHQmJk9iamVjdC5rZXlzKHQpLmxlbmd0aCYmKG4ubm90aWZpY2F0aW9uPXQpLE9iamVjdC5rZXlzKG4pLmxlbmd0aD9uOm51bGx9fSx7a2V5Olwibm90aWZpY2F0aW9uXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BheWxvYWQubm90aWZpY2F0aW9ufX0se2tleTpcImRhdGFcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcGF5bG9hZC5kYXRhfX0se2tleTpcInRpdGxlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3RpdGxlfSxzZXQ6ZnVuY3Rpb24oZSl7ZSYmZS5sZW5ndGgmJih0aGlzLl9wYXlsb2FkLm5vdGlmaWNhdGlvbi50aXRsZT1lLHRoaXMuX3RpdGxlPWUpfX0se2tleTpcImJvZHlcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYm9keX0sc2V0OmZ1bmN0aW9uKGUpe2UmJmUubGVuZ3RoJiYodGhpcy5fcGF5bG9hZC5ub3RpZmljYXRpb24uYm9keT1lLHRoaXMuX2JvZHk9ZSl9fSx7a2V5Olwic291bmRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc291bmR9LHNldDpmdW5jdGlvbihlKXtlJiZlLmxlbmd0aCYmKHRoaXMuX3BheWxvYWQubm90aWZpY2F0aW9uLnNvdW5kPWUsdGhpcy5fc291bmQ9ZSl9fSx7a2V5OlwiaWNvblwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pY29ufSxzZXQ6ZnVuY3Rpb24oZSl7ZSYmZS5sZW5ndGgmJih0aGlzLl9wYXlsb2FkLm5vdGlmaWNhdGlvbi5pY29uPWUsdGhpcy5faWNvbj1lKX19LHtrZXk6XCJ0YWdcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdGFnfSxzZXQ6ZnVuY3Rpb24oZSl7ZSYmZS5sZW5ndGgmJih0aGlzLl9wYXlsb2FkLm5vdGlmaWNhdGlvbi50YWc9ZSx0aGlzLl90YWc9ZSl9fSx7a2V5Olwic2lsZW50XCIsc2V0OmZ1bmN0aW9uKGUpe3RoaXMuX2lzU2lsZW50PWV9fV0pLHcpO2Z1bmN0aW9uIHcoKXt2YXIgZSx0O2godGhpcyx3KTtmb3IodmFyIG49YXJndW1lbnRzLmxlbmd0aCxyPW5ldyBBcnJheShuKSxpPTA7aTxuO2krKylyW2ldPWFyZ3VtZW50c1tpXTtyZXR1cm4gZyhjKHQ9YSh0aGlzLChlPXUodykpLmNhbGwuYXBwbHkoZSxbdGhpc10uY29uY2F0KHIpKSkpLFwiX2lzU2lsZW50XCIsdm9pZCAwKSxnKGModCksXCJfaWNvblwiLHZvaWQgMCksZyhjKHQpLFwiX3RhZ1wiLHZvaWQgMCksdH1mdW5jdGlvbiBUKGUsdCl7aCh0aGlzLFQpLGcodGhpcyxcIl9wYXlsb2FkXCIsdm9pZCAwKSxnKHRoaXMsXCJfZGVidWdnaW5nXCIsdm9pZCAwKSxnKHRoaXMsXCJfc3VidGl0bGVcIix2b2lkIDApLGcodGhpcyxcIl9iYWRnZVwiLHZvaWQgMCksZyh0aGlzLFwiX3NvdW5kXCIsdm9pZCAwKSxnKHRoaXMsXCJfdGl0bGVcIix2b2lkIDApLGcodGhpcyxcIl9ib2R5XCIsdm9pZCAwKSxnKHRoaXMsXCJhcG5zXCIsdm9pZCAwKSxnKHRoaXMsXCJtcG5zXCIsdm9pZCAwKSxnKHRoaXMsXCJmY21cIix2b2lkIDApLHRoaXMuX3BheWxvYWQ9e2FwbnM6e30sbXBuczp7fSxmY206e319LHRoaXMuX3RpdGxlPWUsdGhpcy5fYm9keT10LHRoaXMuYXBucz1uZXcgYih0aGlzLl9wYXlsb2FkLmFwbnMsZSx0KSx0aGlzLm1wbnM9bmV3IF8odGhpcy5fcGF5bG9hZC5tcG5zLGUsdCksdGhpcy5mY209bmV3IFAodGhpcy5fcGF5bG9hZC5mY20sZSx0KX10LkZDTU5vdGlmaWNhdGlvblBheWxvYWQ9UDt2YXIgTz0oZChULFt7a2V5OlwiZGVidWdnaW5nXCIsc2V0OmZ1bmN0aW9uKGUpe3RoaXMuX2RlYnVnZ2luZz1lfX0se2tleTpcInRpdGxlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3RpdGxlfX0se2tleTpcImJvZHlcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYm9keX19LHtrZXk6XCJzdWJ0aXRsZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zdWJ0aXRsZX0sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuX3N1YnRpdGxlPWUsdGhpcy5hcG5zLnN1YnRpdGxlPWUsdGhpcy5tcG5zLnN1YnRpdGxlPWUsdGhpcy5mY20uc3VidGl0bGU9ZX19LHtrZXk6XCJiYWRnZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9iYWRnZX0sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuX2JhZGdlPWUsdGhpcy5hcG5zLmJhZGdlPWUsdGhpcy5tcG5zLmJhZGdlPWUsdGhpcy5mY20uYmFkZ2U9ZX19LHtrZXk6XCJzb3VuZFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zb3VuZH0sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuX3NvdW5kPWUsdGhpcy5hcG5zLnNvdW5kPWUsdGhpcy5tcG5zLnNvdW5kPWUsdGhpcy5mY20uc291bmQ9ZX19XSksZChULFt7a2V5OlwiYnVpbGRQYXlsb2FkXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9e307aWYoZS5pbmNsdWRlcyhcImFwbnNcIil8fGUuaW5jbHVkZXMoXCJhcG5zMlwiKSl7dGhpcy5hcG5zLl9hcG5zUHVzaFR5cGU9ZS5pbmNsdWRlcyhcImFwbnNcIik/XCJhcG5zXCI6XCJhcG5zMlwiO3ZhciBuPXRoaXMuYXBucy50b09iamVjdCgpO24mJk9iamVjdC5rZXlzKG4pLmxlbmd0aCYmKHQucG5fYXBucz1uKX1pZihlLmluY2x1ZGVzKFwibXBuc1wiKSl7dmFyIHI9dGhpcy5tcG5zLnRvT2JqZWN0KCk7ciYmT2JqZWN0LmtleXMocikubGVuZ3RoJiYodC5wbl9tcG5zPXIpfWlmKGUuaW5jbHVkZXMoXCJmY21cIikpe3ZhciBpPXRoaXMuZmNtLnRvT2JqZWN0KCk7aSYmT2JqZWN0LmtleXMoaSkubGVuZ3RoJiYodC5wbl9nY209aSl9cmV0dXJuIE9iamVjdC5rZXlzKHQpLmxlbmd0aCYmdGhpcy5fZGVidWdnaW5nJiYodC5wbl9kZWJ1Zz0hMCksdH19XSksVCk7dC5kZWZhdWx0PU99LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9dm9pZCAwO3ZhciByOyhyPW4oMykpJiZyLl9fZXNNb2R1bGUsbigwKTtmdW5jdGlvbiBpKGUpe3JldHVybihpPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9KShlKX1mdW5jdGlvbiBvKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1mdW5jdGlvbiBzKGUsdCxuKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPW4sZX12YXIgYSx1LGMsZj0oYT1sLCh1PVt7a2V5OlwiX2luaXRpYWxpemVUb2tlbnNcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3VzZXJUb2tlbnM9e30sdGhpcy5fc3BhY2VUb2tlbnM9e30sdGhpcy5fdXNlclRva2VuPXZvaWQgMCx0aGlzLl9zcGFjZVRva2VuPXZvaWQgMH19LHtrZXk6XCJfc2V0VG9rZW5cIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgbj10aGlzLGU9dGhpcy5wYXJzZVRva2VuKHQpO2UmJmUucmVzb3VyY2VzJiYoZS5yZXNvdXJjZXMudXNlcnMmJk9iamVjdC5rZXlzKGUucmVzb3VyY2VzLnVzZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe24uX3VzZXJUb2tlbnNbZV09dH0pLGUucmVzb3VyY2VzLnNwYWNlcyYmT2JqZWN0LmtleXMoZS5yZXNvdXJjZXMuc3BhY2VzKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe24uX3NwYWNlVG9rZW5zW2VdPXR9KSksZSYmZS5wYXR0ZXJucyYmKGUucGF0dGVybnMudXNlcnMmJjA8T2JqZWN0LmtleXMoZS5wYXR0ZXJucy51c2VycykubGVuZ3RoJiYodGhpcy5fdXNlclRva2VuPXQpLGUucGF0dGVybnMuc3BhY2VzJiYwPE9iamVjdC5rZXlzKGUucGF0dGVybnMuc3BhY2VzKS5sZW5ndGgmJih0aGlzLl9zcGFjZVRva2VuPXQpKX19LHtrZXk6XCJzZXRUb2tlblwiLHZhbHVlOmZ1bmN0aW9uKGUpe2UmJjA8ZS5sZW5ndGgmJnRoaXMuX3NldFRva2VuKGUpfX0se2tleTpcInNldFRva2Vuc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7ZSYmZS5sZW5ndGgmJlwib2JqZWN0XCI9PT1pKGUpJiZlLmZvckVhY2goZnVuY3Rpb24oZSl7dC5zZXRUb2tlbihlKX0pfX0se2tleTpcImdldFRva2Vuc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsbj17dXNlcnM6e30sc3BhY2VzOnt9fTtyZXR1cm4gZT8oZS51c2VyJiYobi51c2VyPXRoaXMuX3VzZXJUb2tlbiksZS5zcGFjZSYmKG4uc3BhY2U9dGhpcy5fc3BhY2VUb2tlbiksZS51c2VycyYmZS51c2Vycy5mb3JFYWNoKGZ1bmN0aW9uKGUpe24udXNlcnNbZV09dC5fdXNlclRva2Vuc1tlXX0pLGUuc3BhY2UmJmUuc3BhY2VzLmZvckVhY2goZnVuY3Rpb24oZSl7bi5zcGFjZXNbZV09dC5fc3BhY2VUb2tlbnNbZV19KSk6KHRoaXMuX3VzZXJUb2tlbiYmKG4udXNlcj10aGlzLl91c2VyVG9rZW4pLHRoaXMuX3NwYWNlVG9rZW4mJihuLnNwYWNlPXRoaXMuX3NwYWNlVG9rZW4pLE9iamVjdC5rZXlzKHRoaXMuX3VzZXJUb2tlbnMpLmZvckVhY2goZnVuY3Rpb24oZSl7bi51c2Vyc1tlXT10Ll91c2VyVG9rZW5zW2VdfSksT2JqZWN0LmtleXModGhpcy5fc3BhY2VUb2tlbnMpLmZvckVhY2goZnVuY3Rpb24oZSl7bi5zcGFjZXNbZV09dC5fc3BhY2VUb2tlbnNbZV19KSksbn19LHtrZXk6XCJnZXRUb2tlblwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG47cmV0dXJuIHQ/XCJ1c2VyXCI9PT1lP249dGhpcy5fdXNlclRva2Vuc1t0XTpcInNwYWNlXCI9PT1lJiYobj10aGlzLl9zcGFjZVRva2Vuc1t0XSk6XCJ1c2VyXCI9PT1lP249dGhpcy5fdXNlclRva2VuOlwic3BhY2VcIj09PWUmJihuPXRoaXMuX3NwYWNlVG9rZW4pLG59fSx7a2V5OlwiZXh0cmFjdFBlcm1pc3Npb25zXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9e2NyZWF0ZTohMSxyZWFkOiExLHdyaXRlOiExLG1hbmFnZTohMSxkZWxldGU6ITF9O3JldHVybiAxNj09KDE2JmUpJiYodC5jcmVhdGU9ITApLDg9PSg4JmUpJiYodC5kZWxldGU9ITApLDQ9PSg0JmUpJiYodC5tYW5hZ2U9ITApLDI9PSgyJmUpJiYodC53cml0ZT0hMCksMT09KDEmZSkmJih0LnJlYWQ9ITApLHR9fSx7a2V5OlwicGFyc2VUb2tlblwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsbj10aGlzLl9jYm9yLmRlY29kZVRva2VuKGUpO2lmKHZvaWQgMCE9PW4pe3ZhciByPU9iamVjdC5rZXlzKG4ucmVzLnVzciksaT1PYmplY3Qua2V5cyhuLnJlcy5zcGMpLG89T2JqZWN0LmtleXMobi5wYXQudXNyKSxzPU9iamVjdC5rZXlzKG4ucGF0LnNwYyksYT17dmVyc2lvbjpuLnYsdGltZXN0YW1wOm4udCx0dGw6bi50dGx9LHU9MDxyLmxlbmd0aCxjPTA8aS5sZW5ndGg7KHV8fGMpJiYoYS5yZXNvdXJjZXM9e30sdSYmKGEucmVzb3VyY2VzLnVzZXJzPXt9LHIuZm9yRWFjaChmdW5jdGlvbihlKXthLnJlc291cmNlcy51c2Vyc1tlXT10LmV4dHJhY3RQZXJtaXNzaW9ucyhuLnJlcy51c3JbZV0pfSkpLGMmJihhLnJlc291cmNlcy5zcGFjZXM9e30saS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2EucmVzb3VyY2VzLnNwYWNlc1tlXT10LmV4dHJhY3RQZXJtaXNzaW9ucyhuLnJlcy5zcGNbZV0pfSkpKTt2YXIgZj0wPG8ubGVuZ3RoLGw9MDxzLmxlbmd0aDtyZXR1cm4oZnx8bCkmJihhLnBhdHRlcm5zPXt9LGYmJihhLnBhdHRlcm5zLnVzZXJzPXt9LG8uZm9yRWFjaChmdW5jdGlvbihlKXthLnBhdHRlcm5zLnVzZXJzW2VdPXQuZXh0cmFjdFBlcm1pc3Npb25zKG4ucGF0LnVzcltlXSl9KSksbCYmKGEucGF0dGVybnMuc3BhY2VzPXt9LHMuZm9yRWFjaChmdW5jdGlvbihlKXthLnBhdHRlcm5zLnNwYWNlc1tlXT10LmV4dHJhY3RQZXJtaXNzaW9ucyhuLnBhdC5zcGNbZV0pfSkpKSwwPE9iamVjdC5rZXlzKG4ubWV0YSkubGVuZ3RoJiYoYS5tZXRhPW4ubWV0YSksYS5zaWduYXR1cmU9bi5zaWcsYX19fSx7a2V5OlwiY2xlYXJUb2tlbnNcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX2luaXRpYWxpemVUb2tlbnMoKX19XSkmJm8oYS5wcm90b3R5cGUsdSksdm9pZChjJiZvKGEsYykpLGwpO2Z1bmN0aW9uIGwoZSx0KXshZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGwpLHModGhpcyxcIl9jb25maWdcIix2b2lkIDApLHModGhpcyxcIl9jYm9yXCIsdm9pZCAwKSxzKHRoaXMsXCJfdXNlclRva2Vuc1wiLHZvaWQgMCkscyh0aGlzLFwiX3NwYWNlVG9rZW5zXCIsdm9pZCAwKSxzKHRoaXMsXCJfdXNlclRva2VuXCIsdm9pZCAwKSxzKHRoaXMsXCJfc3BhY2VUb2tlblwiLHZvaWQgMCksdGhpcy5fY29uZmlnPWUsdGhpcy5fY2Jvcj10LHRoaXMuX2luaXRpYWxpemVUb2tlbnMoKX10LmRlZmF1bHQ9ZixlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PWZ1bmN0aW9uKHIsaSl7dmFyIGU9ci5uZXR3b3JraW5nLHQ9ci5jb25maWcsbz1udWxsLHM9bnVsbCxhPXt9O289aS5nZXRPcGVyYXRpb24oKT09PWIuZGVmYXVsdC5QTlRpbWVPcGVyYXRpb258fGkuZ2V0T3BlcmF0aW9uKCk9PT1iLmRlZmF1bHQuUE5DaGFubmVsR3JvdXBzT3BlcmF0aW9uP2FyZ3VtZW50cy5sZW5ndGg8PTI/dm9pZCAwOmFyZ3VtZW50c1syXTooYT1hcmd1bWVudHMubGVuZ3RoPD0yP3ZvaWQgMDphcmd1bWVudHNbMl0sYXJndW1lbnRzLmxlbmd0aDw9Mz92b2lkIDA6YXJndW1lbnRzWzNdKTtcInVuZGVmaW5lZFwiPT10eXBlb2YgUHJvbWlzZXx8b3x8KHM9di5kZWZhdWx0LmNyZWF0ZVByb21pc2UoKSk7dmFyIG49aS52YWxpZGF0ZVBhcmFtcyhyLGEpO2lmKG4pcmV0dXJuIG8/byhfKG4pKTpzPyhzLnJlamVjdChuZXcgbShcIlZhbGlkYXRpb24gZmFpbGVkLCBjaGVjayBzdGF0dXMgZm9yIGRldGFpbHNcIixfKG4pKSkscy5wcm9taXNlKTp2b2lkIDA7dmFyIHUsYz1pLnByZXBhcmVQYXJhbXMocixhKSxmPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZS51c2VQb3N0JiZlLnVzZVBvc3QodCxuKT9lLnBvc3RVUkwodCxuKTplLnVzZVBhdGNoJiZlLnVzZVBhdGNoKHQsbik/ZS5wYXRjaFVSTCh0LG4pOmUuZ2V0VVJMKHQsbil9KGkscixhKSxsPXt1cmw6ZixvcGVyYXRpb246aS5nZXRPcGVyYXRpb24oKSx0aW1lb3V0OmkuZ2V0UmVxdWVzdFRpbWVvdXQociksaGVhZGVyczppLmdldFJlcXVlc3RIZWFkZXJzP2kuZ2V0UmVxdWVzdEhlYWRlcnMoKTp7fX07Yy51dWlkPXQuVVVJRCxjLnBuc2RrPWZ1bmN0aW9uKGUpe2lmKGUuc2RrTmFtZSlyZXR1cm4gZS5zZGtOYW1lO3ZhciB0PVwiUHViTnViLUpTLVwiLmNvbmNhdChlLnNka0ZhbWlseSk7ZS5wYXJ0bmVySWQmJih0Kz1cIi1cIi5jb25jYXQoZS5wYXJ0bmVySWQpKTt0Kz1cIi9cIi5jb25jYXQoZS5nZXRWZXJzaW9uKCkpO3ZhciBuPWUuX2dldFBuc2RrU3VmZml4KFwiIFwiKTswPG4ubGVuZ3RoJiYodCs9bik7cmV0dXJuIHR9KHQpLHQudXNlSW5zdGFuY2VJZCYmKGMuaW5zdGFuY2VpZD10Lmluc3RhbmNlSWQpO3QudXNlUmVxdWVzdElkJiYoYy5yZXF1ZXN0aWQ9eS5kZWZhdWx0LmNyZWF0ZVVVSUQoKSk7aWYoaS5pc0F1dGhTdXBwb3J0ZWQoKSl7dmFyIGg9ZnVuY3Rpb24oZSx0LG4pe3ZhciByO2UuZ2V0QXV0aFRva2VuJiYocj1lLmdldEF1dGhUb2tlbih0LG4pKTtyZXR1cm4gcn0oaSxyLGEpfHx0LmdldEF1dGhLZXkoKTtoJiYoYy5hdXRoPWgpfXQuc2VjcmV0S2V5JiZmdW5jdGlvbihlLHQsbixyLGkpe3ZhciBvPWUuY29uZmlnLHM9ZS5jcnlwdG8sYT1rKGUsaSxyKTtuLnRpbWVzdGFtcD1NYXRoLmZsb29yKChuZXcgRGF0ZSkuZ2V0VGltZSgpLzFlMyk7dmFyIHU9XCJcIi5jb25jYXQoYSxcIlxcblwiKS5jb25jYXQoby5wdWJsaXNoS2V5LFwiXFxuXCIpLmNvbmNhdCh0LFwiXFxuXCIpLmNvbmNhdCh2LmRlZmF1bHQuc2lnblBhbUZyb21QYXJhbXMobiksXCJcXG5cIik7aWYoXCJQT1NUXCI9PT1hKXt2YXIgYz1pLnBvc3RQYXlsb2FkKGUscik7dSs9XCJzdHJpbmdcIj09dHlwZW9mIGM/YzpKU09OLnN0cmluZ2lmeShjKX1lbHNlIGlmKFwiUEFUQ0hcIj09PWEpe3ZhciBmPWkucGF0Y2hQYXlsb2FkKGUscik7dSs9XCJzdHJpbmdcIj09dHlwZW9mIGY/ZjpKU09OLnN0cmluZ2lmeShmKX12YXIgbD1cInYyLlwiLmNvbmNhdChzLkhNQUNTSEEyNTYodSkpO2w9KGw9KGw9bC5yZXBsYWNlKC9cXCsvZyxcIi1cIikpLnJlcGxhY2UoL1xcLy9nLFwiX1wiKSkucmVwbGFjZSgvPSskLyxcIlwiKSxuLnNpZ25hdHVyZT1sfShyLGYsYyxhLGkpO2Z1bmN0aW9uIHAoZSx0KXtpZihlLmVycm9yKW8/byhlKTpzJiZzLnJlamVjdChuZXcgbShcIlB1Yk51YiBjYWxsIGZhaWxlZCwgY2hlY2sgc3RhdHVzIGZvciBkZXRhaWxzXCIsZSkpO2Vsc2V7dmFyIG49aS5oYW5kbGVSZXNwb25zZShyLHQsYSk7bz9vKGUsbik6cyYmcy5mdWxmaWxsKG4pfX1pZihcIlBPU1RcIj09PWsocixpLGEpKXt2YXIgZD1pLnBvc3RQYXlsb2FkKHIsYSk7dT1lLlBPU1QoYyxkLGwscCl9ZWxzZSBpZihcIlBBVENIXCI9PT1rKHIsaSxhKSl7dmFyIGc9aS5wYXRjaFBheWxvYWQocixhKTt1PWUuUEFUQ0goYyxnLGwscCl9ZWxzZSB1PVwiREVMRVRFXCI9PT1rKHIsaSxhKT9lLkRFTEVURShjLGwscCk6ZS5HRVQoYyxsLHApO2lmKGkuZ2V0T3BlcmF0aW9uKCk9PT1iLmRlZmF1bHQuUE5TdWJzY3JpYmVPcGVyYXRpb24pcmV0dXJuIHU7aWYocylyZXR1cm4gcy5wcm9taXNlfTt2YXIgeT1yKG4oNSkpLHY9KG4oMCkscihuKDIpKSksYj0ocihuKDMpKSxyKG4oMSkpKTtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBpKGUpe3JldHVybihpPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9KShlKX1mdW5jdGlvbiBvKGUsdCl7cmV0dXJuIXR8fFwib2JqZWN0XCIhPT1pKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0P2Z1bmN0aW9uKGUpe2lmKHZvaWQgMCE9PWUpcmV0dXJuIGU7dGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpfShlKTp0fWZ1bmN0aW9uIHMoZSl7dmFyIG49XCJmdW5jdGlvblwiPT10eXBlb2YgTWFwP25ldyBNYXA6dm9pZCAwO3JldHVybihzPWZ1bmN0aW9uKGUpe2lmKG51bGw9PT1lfHwhZnVuY3Rpb24oZSl7cmV0dXJuLTEhPT1GdW5jdGlvbi50b1N0cmluZy5jYWxsKGUpLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpfShlKSlyZXR1cm4gZTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtpZih2b2lkIDAhPT1uKXtpZihuLmhhcyhlKSlyZXR1cm4gbi5nZXQoZSk7bi5zZXQoZSx0KX1mdW5jdGlvbiB0KCl7cmV0dXJuIGEoZSxhcmd1bWVudHMsYyh0aGlzKS5jb25zdHJ1Y3Rvcil9cmV0dXJuIHQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHUodCxlKX0pKGUpfWZ1bmN0aW9uIGEoZSx0LG4pe3JldHVybihhPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCFSZWZsZWN0LmNvbnN0cnVjdClyZXR1cm4hMTtpZihSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLFtdLGZ1bmN0aW9uKCl7fSkpLCEwfWNhdGNoKGUpe3JldHVybiExfX0oKT9SZWZsZWN0LmNvbnN0cnVjdDpmdW5jdGlvbihlLHQsbil7dmFyIHI9W251bGxdO3IucHVzaC5hcHBseShyLHQpO3ZhciBpPW5ldyhGdW5jdGlvbi5iaW5kLmFwcGx5KGUscikpO3JldHVybiBuJiZ1KGksbi5wcm90b3R5cGUpLGl9KS5hcHBseShudWxsLGFyZ3VtZW50cyl9ZnVuY3Rpb24gdShlLHQpe3JldHVybih1PU9iamVjdC5zZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5fX3Byb3RvX189dCxlfSkoZSx0KX1mdW5jdGlvbiBjKGUpe3JldHVybihjPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSl9KShlKX12YXIgbT0oZnVuY3Rpb24oZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHQmJnUoZSx0KX0oZixzKEVycm9yKSksZik7ZnVuY3Rpb24gZihlLHQpe3ZhciBuO3JldHVybiBmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZiksKG49byh0aGlzLGMoZikuY2FsbCh0aGlzLGUpKSkubmFtZT1uLmNvbnN0cnVjdG9yLm5hbWUsbi5zdGF0dXM9dCxuLm1lc3NhZ2U9ZSxufWZ1bmN0aW9uIF8oZSl7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUudHlwZT10LGUuZXJyb3I9ITAsZX0oe21lc3NhZ2U6ZX0sXCJ2YWxpZGF0aW9uRXJyb3JcIil9ZnVuY3Rpb24gayhlLHQsbil7cmV0dXJuIHQudXNlUG9zdCYmdC51c2VQb3N0KGUsbik/XCJQT1NUXCI6dC51c2VQYXRjaCYmdC51c2VQYXRjaChlLG4pP1wiUEFUQ0hcIjp0LnVzZURlbGV0ZSYmdC51c2VEZWxldGUoZSxuKT9cIkRFTEVURVwiOlwiR0VUXCJ9ZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHIuZGVmYXVsdC5QTkFkZENoYW5uZWxzVG9Hcm91cE9wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuY2hhbm5lbHMscj10LmNoYW5uZWxHcm91cCxpPWUuY29uZmlnO2lmKCFyKXJldHVyblwiTWlzc2luZyBDaGFubmVsIEdyb3VwXCI7aWYoIW58fDA9PT1uLmxlbmd0aClyZXR1cm5cIk1pc3NpbmcgQ2hhbm5lbHNcIjtpZighaS5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIn0sdC5nZXRVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmNoYW5uZWxHcm91cCxyPWUuY29uZmlnO3JldHVyblwiL3YxL2NoYW5uZWwtcmVnaXN0cmF0aW9uL3N1Yi1rZXkvXCIuY29uY2F0KHIuc3Vic2NyaWJlS2V5LFwiL2NoYW5uZWwtZ3JvdXAvXCIpLmNvbmNhdChpLmRlZmF1bHQuZW5jb2RlU3RyaW5nKG4pKX0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuY2hhbm5lbHM7cmV0dXJue2FkZDoodm9pZCAwPT09bj9bXTpuKS5qb2luKFwiLFwiKX19LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oKXtyZXR1cm57fX07bigwKTt2YXIgcj1vKG4oMSkpLGk9byhuKDIpKTtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiByLmRlZmF1bHQuUE5SZW1vdmVDaGFubmVsc0Zyb21Hcm91cE9wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuY2hhbm5lbHMscj10LmNoYW5uZWxHcm91cCxpPWUuY29uZmlnO2lmKCFyKXJldHVyblwiTWlzc2luZyBDaGFubmVsIEdyb3VwXCI7aWYoIW58fDA9PT1uLmxlbmd0aClyZXR1cm5cIk1pc3NpbmcgQ2hhbm5lbHNcIjtpZighaS5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIn0sdC5nZXRVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmNoYW5uZWxHcm91cCxyPWUuY29uZmlnO3JldHVyblwiL3YxL2NoYW5uZWwtcmVnaXN0cmF0aW9uL3N1Yi1rZXkvXCIuY29uY2F0KHIuc3Vic2NyaWJlS2V5LFwiL2NoYW5uZWwtZ3JvdXAvXCIpLmNvbmNhdChpLmRlZmF1bHQuZW5jb2RlU3RyaW5nKG4pKX0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuY2hhbm5lbHM7cmV0dXJue3JlbW92ZToodm9pZCAwPT09bj9bXTpuKS5qb2luKFwiLFwiKX19LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oKXtyZXR1cm57fX07bigwKTt2YXIgcj1vKG4oMSkpLGk9byhuKDIpKTtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiByLmRlZmF1bHQuUE5SZW1vdmVHcm91cE9wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuY2hhbm5lbEdyb3VwLHI9ZS5jb25maWc7aWYoIW4pcmV0dXJuXCJNaXNzaW5nIENoYW5uZWwgR3JvdXBcIjtpZighci5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIn0sdC5nZXRVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmNoYW5uZWxHcm91cCxyPWUuY29uZmlnO3JldHVyblwiL3YxL2NoYW5uZWwtcmVnaXN0cmF0aW9uL3N1Yi1rZXkvXCIuY29uY2F0KHIuc3Vic2NyaWJlS2V5LFwiL2NoYW5uZWwtZ3JvdXAvXCIpLmNvbmNhdChpLmRlZmF1bHQuZW5jb2RlU3RyaW5nKG4pLFwiL3JlbW92ZVwiKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbigpe3JldHVybnt9fSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKCl7cmV0dXJue319O24oMCk7dmFyIHI9byhuKDEpKSxpPW8obigyKSk7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0LlBOQ2hhbm5lbEdyb3Vwc09wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlKXtpZighZS5jb25maWcuc3Vic2NyaWJlS2V5KXJldHVyblwiTWlzc2luZyBTdWJzY3JpYmUgS2V5XCJ9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUpe3ZhciB0PWUuY29uZmlnO3JldHVyblwiL3YxL2NoYW5uZWwtcmVnaXN0cmF0aW9uL3N1Yi1rZXkvXCIuY29uY2F0KHQuc3Vic2NyaWJlS2V5LFwiL2NoYW5uZWwtZ3JvdXBcIil9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oKXtyZXR1cm57fX0sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLHQpe3JldHVybntncm91cHM6dC5wYXlsb2FkLmdyb3Vwc319O24oMCk7dmFyIHIsaT0ocj1uKDEpKSYmci5fX2VzTW9kdWxlP3I6e2RlZmF1bHQ6cn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiByLmRlZmF1bHQuUE5DaGFubmVsc0Zvckdyb3VwT3BlcmF0aW9ufSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5jaGFubmVsR3JvdXAscj1lLmNvbmZpZztpZighbilyZXR1cm5cIk1pc3NpbmcgQ2hhbm5lbCBHcm91cFwiO2lmKCFyLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwifSx0LmdldFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPXQuY2hhbm5lbEdyb3VwLHI9ZS5jb25maWc7cmV0dXJuXCIvdjEvY2hhbm5lbC1yZWdpc3RyYXRpb24vc3ViLWtleS9cIi5jb25jYXQoci5zdWJzY3JpYmVLZXksXCIvY2hhbm5lbC1ncm91cC9cIikuY29uY2F0KGkuZGVmYXVsdC5lbmNvZGVTdHJpbmcobikpfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKCl7cmV0dXJue319LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm57Y2hhbm5lbHM6dC5wYXlsb2FkLmNoYW5uZWxzfX07bigwKTt2YXIgcj1vKG4oMSkpLGk9byhuKDIpKTtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHQuUE5QdXNoTm90aWZpY2F0aW9uRW5hYmxlZENoYW5uZWxzT3BlcmF0aW9ufSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5kZXZpY2Uscj10LnB1c2hHYXRld2F5LGk9dC5jaGFubmVscyxvPXQudG9waWMscz1lLmNvbmZpZztpZighbilyZXR1cm5cIk1pc3NpbmcgRGV2aWNlIElEIChkZXZpY2UpXCI7aWYoIXIpcmV0dXJuXCJNaXNzaW5nIEdXIFR5cGUgKHB1c2hHYXRld2F5OiBnY20sIGFwbnMgb3IgYXBuczIpXCI7aWYoXCJhcG5zMlwiPT09ciYmIW8pcmV0dXJuXCJNaXNzaW5nIEFQTlMyIHRvcGljXCI7aWYoIWl8fDA9PT1pLmxlbmd0aClyZXR1cm5cIk1pc3NpbmcgQ2hhbm5lbHNcIjtpZighcy5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIn0sdC5nZXRVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmRldmljZSxyPXQucHVzaEdhdGV3YXksaT1lLmNvbmZpZztyZXR1cm5cImFwbnMyXCIhPT1yP1wiL3YxL3B1c2gvc3ViLWtleS9cIi5jb25jYXQoaS5zdWJzY3JpYmVLZXksXCIvZGV2aWNlcy9cIikuY29uY2F0KG4pOlwiL3YyL3B1c2gvc3ViLWtleS9cIi5jb25jYXQoaS5zdWJzY3JpYmVLZXksXCIvZGV2aWNlcy1hcG5zMi9cIikuY29uY2F0KG4pfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5wdXNoR2F0ZXdheSxyPXQuY2hhbm5lbHMsaT12b2lkIDA9PT1yP1tdOnIsbz10LmVudmlyb25tZW50LHM9dm9pZCAwPT09bz9cImRldmVsb3BtZW50XCI6byxhPXQudG9waWMsdT17dHlwZTpuLGFkZDppLmpvaW4oXCIsXCIpfTtcImFwbnMyXCI9PT1uJiZkZWxldGUodT1PYmplY3QuYXNzaWduKHt9LHUse2Vudmlyb25tZW50OnMsdG9waWM6YX0pKS50eXBlO3JldHVybiB1fSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKCl7cmV0dXJue319O24oMCk7dmFyIHIsaT0ocj1uKDEpKSYmci5fX2VzTW9kdWxlP3I6e2RlZmF1bHQ6cn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHQuUE5QdXNoTm90aWZpY2F0aW9uRW5hYmxlZENoYW5uZWxzT3BlcmF0aW9ufSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5kZXZpY2Uscj10LnB1c2hHYXRld2F5LGk9dC5jaGFubmVscyxvPXQudG9waWMscz1lLmNvbmZpZztpZighbilyZXR1cm5cIk1pc3NpbmcgRGV2aWNlIElEIChkZXZpY2UpXCI7aWYoIXIpcmV0dXJuXCJNaXNzaW5nIEdXIFR5cGUgKHB1c2hHYXRld2F5OiBnY20sIGFwbnMgb3IgYXBuczIpXCI7aWYoXCJhcG5zMlwiPT09ciYmIW8pcmV0dXJuXCJNaXNzaW5nIEFQTlMyIHRvcGljXCI7aWYoIWl8fDA9PT1pLmxlbmd0aClyZXR1cm5cIk1pc3NpbmcgQ2hhbm5lbHNcIjtpZighcy5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIn0sdC5nZXRVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmRldmljZSxyPXQucHVzaEdhdGV3YXksaT1lLmNvbmZpZztyZXR1cm5cImFwbnMyXCIhPT1yP1wiL3YxL3B1c2gvc3ViLWtleS9cIi5jb25jYXQoaS5zdWJzY3JpYmVLZXksXCIvZGV2aWNlcy9cIikuY29uY2F0KG4pOlwiL3YyL3B1c2gvc3ViLWtleS9cIi5jb25jYXQoaS5zdWJzY3JpYmVLZXksXCIvZGV2aWNlcy1hcG5zMi9cIikuY29uY2F0KG4pfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5wdXNoR2F0ZXdheSxyPXQuY2hhbm5lbHMsaT12b2lkIDA9PT1yP1tdOnIsbz10LmVudmlyb25tZW50LHM9dm9pZCAwPT09bz9cImRldmVsb3BtZW50XCI6byxhPXQudG9waWMsdT17dHlwZTpuLHJlbW92ZTppLmpvaW4oXCIsXCIpfTtcImFwbnMyXCI9PT1uJiZkZWxldGUodT1PYmplY3QuYXNzaWduKHt9LHUse2Vudmlyb25tZW50OnMsdG9waWM6YX0pKS50eXBlO3JldHVybiB1fSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKCl7cmV0dXJue319O24oMCk7dmFyIHIsaT0ocj1uKDEpKSYmci5fX2VzTW9kdWxlP3I6e2RlZmF1bHQ6cn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHQuUE5QdXNoTm90aWZpY2F0aW9uRW5hYmxlZENoYW5uZWxzT3BlcmF0aW9ufSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5kZXZpY2Uscj10LnB1c2hHYXRld2F5LGk9dC50b3BpYyxvPWUuY29uZmlnO2lmKCFuKXJldHVyblwiTWlzc2luZyBEZXZpY2UgSUQgKGRldmljZSlcIjtpZighcilyZXR1cm5cIk1pc3NpbmcgR1cgVHlwZSAocHVzaEdhdGV3YXk6IGdjbSwgYXBucyBvciBhcG5zMilcIjtpZihcImFwbnMyXCI9PT1yJiYhaSlyZXR1cm5cIk1pc3NpbmcgQVBOUzIgdG9waWNcIjtpZighby5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIn0sdC5nZXRVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmRldmljZSxyPXQucHVzaEdhdGV3YXksaT1lLmNvbmZpZztyZXR1cm5cImFwbnMyXCIhPT1yP1wiL3YxL3B1c2gvc3ViLWtleS9cIi5jb25jYXQoaS5zdWJzY3JpYmVLZXksXCIvZGV2aWNlcy9cIikuY29uY2F0KG4pOlwiL3YyL3B1c2gvc3ViLWtleS9cIi5jb25jYXQoaS5zdWJzY3JpYmVLZXksXCIvZGV2aWNlcy1hcG5zMi9cIikuY29uY2F0KG4pfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5wdXNoR2F0ZXdheSxyPXQuZW52aXJvbm1lbnQsaT12b2lkIDA9PT1yP1wiZGV2ZWxvcG1lbnRcIjpyLG89dC50b3BpYyxzPXt0eXBlOm59O1wiYXBuczJcIj09PW4mJmRlbGV0ZShzPU9iamVjdC5hc3NpZ24oe30scyx7ZW52aXJvbm1lbnQ6aSx0b3BpYzpvfSkpLnR5cGU7cmV0dXJuIHN9LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm57Y2hhbm5lbHM6dH19O24oMCk7dmFyIHIsaT0ocj1uKDEpKSYmci5fX2VzTW9kdWxlP3I6e2RlZmF1bHQ6cn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHQuUE5SZW1vdmVBbGxQdXNoTm90aWZpY2F0aW9uc09wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuZGV2aWNlLHI9dC5wdXNoR2F0ZXdheSxpPXQudG9waWMsbz1lLmNvbmZpZztpZighbilyZXR1cm5cIk1pc3NpbmcgRGV2aWNlIElEIChkZXZpY2UpXCI7aWYoIXIpcmV0dXJuXCJNaXNzaW5nIEdXIFR5cGUgKHB1c2hHYXRld2F5OiBnY20sIGFwbnMgb3IgYXBuczIpXCI7aWYoXCJhcG5zMlwiPT09ciYmIWkpcmV0dXJuXCJNaXNzaW5nIEFQTlMyIHRvcGljXCI7aWYoIW8uc3Vic2NyaWJlS2V5KXJldHVyblwiTWlzc2luZyBTdWJzY3JpYmUgS2V5XCJ9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5kZXZpY2Uscj10LnB1c2hHYXRld2F5LGk9ZS5jb25maWc7cmV0dXJuXCJhcG5zMlwiIT09cj9cIi92MS9wdXNoL3N1Yi1rZXkvXCIuY29uY2F0KGkuc3Vic2NyaWJlS2V5LFwiL2RldmljZXMvXCIpLmNvbmNhdChuLFwiL3JlbW92ZVwiKTpcIi92Mi9wdXNoL3N1Yi1rZXkvXCIuY29uY2F0KGkuc3Vic2NyaWJlS2V5LFwiL2RldmljZXMtYXBuczIvXCIpLmNvbmNhdChuLFwiL3JlbW92ZVwiKX0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQucHVzaEdhdGV3YXkscj10LmVudmlyb25tZW50LGk9dm9pZCAwPT09cj9cImRldmVsb3BtZW50XCI6cixvPXQudG9waWMscz17dHlwZTpufTtcImFwbnMyXCI9PT1uJiZkZWxldGUocz1PYmplY3QuYXNzaWduKHt9LHMse2Vudmlyb25tZW50OmksdG9waWM6b30pKS50eXBlO3JldHVybiBzfSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKCl7cmV0dXJue319O24oMCk7dmFyIHIsaT0ocj1uKDEpKSYmci5fX2VzTW9kdWxlP3I6e2RlZmF1bHQ6cn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiByLmRlZmF1bHQuUE5VbnN1YnNjcmliZU9wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlKXtpZighZS5jb25maWcuc3Vic2NyaWJlS2V5KXJldHVyblwiTWlzc2luZyBTdWJzY3JpYmUgS2V5XCJ9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWcscj10LmNoYW5uZWxzLGk9dm9pZCAwPT09cj9bXTpyLG89MDxpLmxlbmd0aD9pLmpvaW4oXCIsXCIpOlwiLFwiO3JldHVyblwiL3YyL3ByZXNlbmNlL3N1Yi1rZXkvXCIuY29uY2F0KG4uc3Vic2NyaWJlS2V5LFwiL2NoYW5uZWwvXCIpLmNvbmNhdChzLmRlZmF1bHQuZW5jb2RlU3RyaW5nKG8pLFwiL2xlYXZlXCIpfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5jaGFubmVsR3JvdXBzLHI9dm9pZCAwPT09bj9bXTpuLGk9e307MDxyLmxlbmd0aCYmKGlbXCJjaGFubmVsLWdyb3VwXCJdPXIuam9pbihcIixcIikpO3JldHVybiBpfSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKCl7cmV0dXJue319O24oMCk7dmFyIHI9aShuKDEpKSxzPWkobigyKSk7ZnVuY3Rpb24gaShlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0LlBOV2hlcmVOb3dPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSl7aWYoIWUuY29uZmlnLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwifSx0LmdldFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnLHI9dC51dWlkLGk9dm9pZCAwPT09cj9uLlVVSUQ6cjtyZXR1cm5cIi92Mi9wcmVzZW5jZS9zdWIta2V5L1wiLmNvbmNhdChuLnN1YnNjcmliZUtleSxcIi91dWlkL1wiKS5jb25jYXQoaSl9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oKXtyZXR1cm57fX0sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLHQpe3JldHVybiB0LnBheWxvYWQ/e2NoYW5uZWxzOnQucGF5bG9hZC5jaGFubmVsc306e2NoYW5uZWxzOltdfX07bigwKTt2YXIgcixpPShyPW4oMSkpJiZyLl9fZXNNb2R1bGU/cjp7ZGVmYXVsdDpyfX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHIuZGVmYXVsdC5QTkhlYXJ0YmVhdE9wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlKXtpZighZS5jb25maWcuc3Vic2NyaWJlS2V5KXJldHVyblwiTWlzc2luZyBTdWJzY3JpYmUgS2V5XCJ9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWcscj10LmNoYW5uZWxzLGk9dm9pZCAwPT09cj9bXTpyLG89MDxpLmxlbmd0aD9pLmpvaW4oXCIsXCIpOlwiLFwiO3JldHVyblwiL3YyL3ByZXNlbmNlL3N1Yi1rZXkvXCIuY29uY2F0KG4uc3Vic2NyaWJlS2V5LFwiL2NoYW5uZWwvXCIpLmNvbmNhdChzLmRlZmF1bHQuZW5jb2RlU3RyaW5nKG8pLFwiL2hlYXJ0YmVhdFwiKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuY2hhbm5lbEdyb3VwcyxyPXZvaWQgMD09PW4/W106bixpPXQuc3RhdGUsbz12b2lkIDA9PT1pP3t9Omkscz1lLmNvbmZpZyxhPXt9OzA8ci5sZW5ndGgmJihhW1wiY2hhbm5lbC1ncm91cFwiXT1yLmpvaW4oXCIsXCIpKTtyZXR1cm4gYS5zdGF0ZT1KU09OLnN0cmluZ2lmeShvKSxhLmhlYXJ0YmVhdD1zLmdldFByZXNlbmNlVGltZW91dCgpLGF9LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oKXtyZXR1cm57fX07bigwKTt2YXIgcj1pKG4oMSkpLHM9aShuKDIpKTtmdW5jdGlvbiBpKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiByLmRlZmF1bHQuUE5HZXRTdGF0ZU9wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlKXtpZighZS5jb25maWcuc3Vic2NyaWJlS2V5KXJldHVyblwiTWlzc2luZyBTdWJzY3JpYmUgS2V5XCJ9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWcscj10LnV1aWQsaT12b2lkIDA9PT1yP24uVVVJRDpyLG89dC5jaGFubmVscyxzPXZvaWQgMD09PW8/W106byxhPTA8cy5sZW5ndGg/cy5qb2luKFwiLFwiKTpcIixcIjtyZXR1cm5cIi92Mi9wcmVzZW5jZS9zdWIta2V5L1wiLmNvbmNhdChuLnN1YnNjcmliZUtleSxcIi9jaGFubmVsL1wiKS5jb25jYXQodS5kZWZhdWx0LmVuY29kZVN0cmluZyhhKSxcIi91dWlkL1wiKS5jb25jYXQoaSl9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmNoYW5uZWxHcm91cHMscj12b2lkIDA9PT1uP1tdOm4saT17fTswPHIubGVuZ3RoJiYoaVtcImNoYW5uZWwtZ3JvdXBcIl09ci5qb2luKFwiLFwiKSk7cmV0dXJuIGl9LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPW4uY2hhbm5lbHMsaT12b2lkIDA9PT1yP1tdOnIsbz1uLmNoYW5uZWxHcm91cHMscz12b2lkIDA9PT1vP1tdOm8sYT17fTsxPT09aS5sZW5ndGgmJjA9PT1zLmxlbmd0aD9hW2lbMF1dPXQucGF5bG9hZDphPXQucGF5bG9hZDtyZXR1cm57Y2hhbm5lbHM6YX19O24oMCk7dmFyIHI9aShuKDEpKSx1PWkobigyKSk7ZnVuY3Rpb24gaShlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gci5kZWZhdWx0LlBOU2V0U3RhdGVPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZyxyPXQuc3RhdGUsaT10LmNoYW5uZWxzLG89dm9pZCAwPT09aT9bXTppLHM9dC5jaGFubmVsR3JvdXBzLGE9dm9pZCAwPT09cz9bXTpzO2lmKCFyKXJldHVyblwiTWlzc2luZyBTdGF0ZVwiO2lmKCFuLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwiO2lmKDA9PT1vLmxlbmd0aCYmMD09PWEubGVuZ3RoKXJldHVyblwiUGxlYXNlIHByb3ZpZGUgYSBsaXN0IG9mIGNoYW5uZWxzIGFuZC9vciBjaGFubmVsLWdyb3Vwc1wifSx0LmdldFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnLHI9dC5jaGFubmVscyxpPXZvaWQgMD09PXI/W106cixvPTA8aS5sZW5ndGg/aS5qb2luKFwiLFwiKTpcIixcIjtyZXR1cm5cIi92Mi9wcmVzZW5jZS9zdWIta2V5L1wiLmNvbmNhdChuLnN1YnNjcmliZUtleSxcIi9jaGFubmVsL1wiKS5jb25jYXQocy5kZWZhdWx0LmVuY29kZVN0cmluZyhvKSxcIi91dWlkL1wiKS5jb25jYXQobi5VVUlELFwiL2RhdGFcIil9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LnN0YXRlLHI9dC5jaGFubmVsR3JvdXBzLGk9dm9pZCAwPT09cj9bXTpyLG89e307by5zdGF0ZT1KU09OLnN0cmluZ2lmeShuKSwwPGkubGVuZ3RoJiYob1tcImNoYW5uZWwtZ3JvdXBcIl09aS5qb2luKFwiLFwiKSk7cmV0dXJuIG99LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm57c3RhdGU6dC5wYXlsb2FkfX07bigwKTt2YXIgcj1pKG4oMSkpLHM9aShuKDIpKTtmdW5jdGlvbiBpKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiByLmRlZmF1bHQuUE5IZXJlTm93T3BlcmF0aW9ufSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUpe2lmKCFlLmNvbmZpZy5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIn0sdC5nZXRVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZyxyPXQuY2hhbm5lbHMsaT12b2lkIDA9PT1yP1tdOnIsbz10LmNoYW5uZWxHcm91cHMscz12b2lkIDA9PT1vP1tdOm8sYT1cIi92Mi9wcmVzZW5jZS9zdWIta2V5L1wiLmNvbmNhdChuLnN1YnNjcmliZUtleSk7aWYoMDxpLmxlbmd0aHx8MDxzLmxlbmd0aCl7dmFyIHU9MDxpLmxlbmd0aD9pLmpvaW4oXCIsXCIpOlwiLFwiO2ErPVwiL2NoYW5uZWwvXCIuY29uY2F0KGMuZGVmYXVsdC5lbmNvZGVTdHJpbmcodSkpfXJldHVybiBhfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5jaGFubmVsR3JvdXBzLHI9dm9pZCAwPT09bj9bXTpuLGk9dC5pbmNsdWRlVVVJRHMsbz12b2lkIDA9PT1pfHxpLHM9dC5pbmNsdWRlU3RhdGUsYT12b2lkIDAhPT1zJiZzLHU9e307b3x8KHUuZGlzYWJsZV91dWlkcz0xKTthJiYodS5zdGF0ZT0xKTswPHIubGVuZ3RoJiYodVtcImNoYW5uZWwtZ3JvdXBcIl09ci5qb2luKFwiLFwiKSk7cmV0dXJuIHV9LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oZSxpLHQpe3ZhciBuLHI9dC5jaGFubmVscyxvPXZvaWQgMD09PXI/W106cixzPXQuY2hhbm5lbEdyb3VwcyxhPXZvaWQgMD09PXM/W106cyx1PXQuaW5jbHVkZVVVSURzLGM9dm9pZCAwPT09dXx8dSxmPXQuaW5jbHVkZVN0YXRlLGw9dm9pZCAwIT09ZiYmZjtuPTE8by5sZW5ndGh8fDA8YS5sZW5ndGh8fDA9PT1hLmxlbmd0aCYmMD09PW8ubGVuZ3RoP2Z1bmN0aW9uKCl7dmFyIHI9e307cmV0dXJuIHIudG90YWxDaGFubmVscz1pLnBheWxvYWQudG90YWxfY2hhbm5lbHMsci50b3RhbE9jY3VwYW5jeT1pLnBheWxvYWQudG90YWxfb2NjdXBhbmN5LHIuY2hhbm5lbHM9e30sT2JqZWN0LmtleXMoaS5wYXlsb2FkLmNoYW5uZWxzKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PWkucGF5bG9hZC5jaGFubmVsc1tlXSxuPVtdO3JldHVybiByLmNoYW5uZWxzW2VdPXtvY2N1cGFudHM6bixuYW1lOmUsb2NjdXBhbmN5OnQub2NjdXBhbmN5fSxjJiZ0LnV1aWRzLmZvckVhY2goZnVuY3Rpb24oZSl7bD9uLnB1c2goe3N0YXRlOmUuc3RhdGUsdXVpZDplLnV1aWR9KTpuLnB1c2goe3N0YXRlOm51bGwsdXVpZDplfSl9KSxyfSkscn0oKTpmdW5jdGlvbigpe3ZhciBlPXt9LHQ9W107cmV0dXJuIGUudG90YWxDaGFubmVscz0xLGUudG90YWxPY2N1cGFuY3k9aS5vY2N1cGFuY3ksZS5jaGFubmVscz17fSxlLmNoYW5uZWxzW29bMF1dPXtvY2N1cGFudHM6dCxuYW1lOm9bMF0sb2NjdXBhbmN5Omkub2NjdXBhbmN5fSxjJiZpLnV1aWRzJiZpLnV1aWRzLmZvckVhY2goZnVuY3Rpb24oZSl7bD90LnB1c2goe3N0YXRlOmUuc3RhdGUsdXVpZDplLnV1aWR9KTp0LnB1c2goe3N0YXRlOm51bGwsdXVpZDplfSl9KSxlfSgpO3JldHVybiBufTtuKDApO3ZhciByPWkobigxKSksYz1pKG4oMikpO2Z1bmN0aW9uIGkoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdC5QTkFkZE1lc3NhZ2VBY3Rpb25PcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZyxyPXQuYWN0aW9uLGk9dC5jaGFubmVsO2lmKCF0Lm1lc3NhZ2VUaW1ldG9rZW4pcmV0dXJuXCJNaXNzaW5nIG1lc3NhZ2UgdGltZXRva2VuXCI7aWYoIW4uc3Vic2NyaWJlS2V5KXJldHVyblwiTWlzc2luZyBTdWJzY3JpYmUgS2V5XCI7aWYoIWkpcmV0dXJuXCJNaXNzaW5nIG1lc3NhZ2UgY2hhbm5lbFwiO2lmKCFyKXJldHVyblwiTWlzc2luZyBBY3Rpb25cIjtpZighci52YWx1ZSlyZXR1cm5cIk1pc3NpbmcgQWN0aW9uLnZhbHVlXCI7aWYoIXIudHlwZSlyZXR1cm5cIk1pc3NpbmcgQWN0aW9uLnR5cGVcIjtpZigxNTxyLnR5cGUubGVuZ3RoKXJldHVyblwiQWN0aW9uLnR5cGUgdmFsdWUgZXhjZWVkIG1heGltdW0gbGVuZ3RoIG9mIDE1XCJ9LHQudXNlUG9zdD1mdW5jdGlvbigpe3JldHVybiEwfSx0LnBvc3RVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZyxyPXQuY2hhbm5lbCxpPXQubWVzc2FnZVRpbWV0b2tlbjtyZXR1cm5cIi92MS9tZXNzYWdlLWFjdGlvbnMvXCIuY29uY2F0KG4uc3Vic2NyaWJlS2V5LFwiL2NoYW5uZWwvXCIpLmNvbmNhdChyLFwiL21lc3NhZ2UvXCIpLmNvbmNhdChpKX0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuZ2V0UmVxdWVzdEhlYWRlcnM9ZnVuY3Rpb24oKXtyZXR1cm57XCJDb250ZW50LVR5cGVcIjpcImFwcGxpY2F0aW9uL2pzb25cIn19LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbigpe3JldHVybnt9fSx0LnBvc3RQYXlsb2FkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQuYWN0aW9ufSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJue2RhdGE6dC5kYXRhfX07bigwKTt2YXIgcixpPShyPW4oMSkpJiZyLl9fZXNNb2R1bGU/cjp7ZGVmYXVsdDpyfX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdC5QTlJlbW92ZU1lc3NhZ2VBY3Rpb25PcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZyxyPXQuY2hhbm5lbCxpPXQuYWN0aW9uVGltZXRva2VuO2lmKCF0Lm1lc3NhZ2VUaW1ldG9rZW4pcmV0dXJuXCJNaXNzaW5nIG1lc3NhZ2UgdGltZXRva2VuXCI7aWYoIWkpcmV0dXJuXCJNaXNzaW5nIGFjdGlvbiB0aW1ldG9rZW5cIjtpZighbi5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIjtpZighcilyZXR1cm5cIk1pc3NpbmcgbWVzc2FnZSBjaGFubmVsXCJ9LHQudXNlRGVsZXRlPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWcscj10LmNoYW5uZWwsaT10LmFjdGlvblRpbWV0b2tlbixvPXQubWVzc2FnZVRpbWV0b2tlbjtyZXR1cm5cIi92MS9tZXNzYWdlLWFjdGlvbnMvXCIuY29uY2F0KG4uc3Vic2NyaWJlS2V5LFwiL2NoYW5uZWwvXCIpLmNvbmNhdChyLFwiL21lc3NhZ2UvXCIpLmNvbmNhdChvLFwiL2FjdGlvbi9cIikuY29uY2F0KGkpfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKCl7cmV0dXJue319LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm57ZGF0YTp0LmRhdGF9fTtuKDApO3ZhciByLGk9KHI9bigxKSkmJnIuX19lc01vZHVsZT9yOntkZWZhdWx0OnJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0LlBOR2V0TWVzc2FnZUFjdGlvbnNPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZyxyPXQuY2hhbm5lbDtpZighbi5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIjtpZighcilyZXR1cm5cIk1pc3NpbmcgbWVzc2FnZSBjaGFubmVsXCJ9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWcscj10LmNoYW5uZWw7cmV0dXJuXCIvdjEvbWVzc2FnZS1hY3Rpb25zL1wiLmNvbmNhdChuLnN1YnNjcmliZUtleSxcIi9jaGFubmVsL1wiKS5jb25jYXQocil9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmxpbWl0LHI9dC5zdGFydCxpPXQuZW5kLG89e307biYmKG8ubGltaXQ9bik7ciYmKG8uc3RhcnQ9cik7aSYmKG8uZW5kPWkpO3JldHVybiBvfSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKGUsdCl7dmFyIG49e2RhdGE6dC5kYXRhLHN0YXJ0Om51bGwsZW5kOm51bGx9O24uZGF0YS5sZW5ndGgmJihuLmVuZD1uLmRhdGFbbi5kYXRhLmxlbmd0aC0xXS5hY3Rpb25UaW1ldG9rZW4sbi5zdGFydD1uLmRhdGFbMF0uYWN0aW9uVGltZXRva2VuKTtyZXR1cm4gbn07bigwKTt2YXIgcixpPShyPW4oMSkpJiZyLl9fZXNNb2R1bGU/cjp7ZGVmYXVsdDpyfX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdC5QTkNyZWF0ZVVzZXJPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZyxyPXQuaWQsaT10Lm5hbWUsbz10LmN1c3RvbTtpZighcilyZXR1cm5cIk1pc3NpbmcgVXNlci5pZFwiO2lmKCFpKXJldHVyblwiTWlzc2luZyBVc2VyLm5hbWVcIjtpZighbi5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIjtpZihvJiYhT2JqZWN0LnZhbHVlcyhvKS5ldmVyeShmdW5jdGlvbihlKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZXx8XCJudW1iZXJcIj09dHlwZW9mIGV8fFwiYm9vbGVhblwiPT10eXBlb2YgZX0pKXJldHVyblwiSW52YWxpZCBjdXN0b20gdHlwZSwgb25seSBzdHJpbmcsIG51bWJlciBhbmQgYm9vbGVhbiB2YWx1ZXMgYXJlIGFsbG93ZWQuXCJ9LHQudXNlUG9zdD1mdW5jdGlvbigpe3JldHVybiEwfSx0LmdldFVSTD1mdW5jdGlvbihlKXt2YXIgdD1lLmNvbmZpZztyZXR1cm5cIi92MS9vYmplY3RzL1wiLmNvbmNhdCh0LnN1YnNjcmliZUtleSxcIi91c2Vyc1wiKX0sdC5wb3N0VVJMPWZ1bmN0aW9uKGUpe3ZhciB0PWUuY29uZmlnO3JldHVyblwiL3YxL29iamVjdHMvXCIuY29uY2F0KHQuc3Vic2NyaWJlS2V5LFwiL3VzZXJzXCIpfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5nZXRBdXRoVG9rZW49ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS50b2tlbk1hbmFnZXIuZ2V0VG9rZW4oXCJ1c2VyXCIsdC5pZCl8fGUudG9rZW5NYW5hZ2VyLmdldFRva2VuKFwidXNlclwiKX0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5pbmNsdWRlLHI9e307bj92b2lkIDA9PT1uLmN1c3RvbUZpZWxkcyYmKG4uY3VzdG9tRmllbGRzPSEwKTpuPXtjdXN0b21GaWVsZHM6ITB9O2lmKG4pe3ZhciBpPVtdO24uY3VzdG9tRmllbGRzJiZpLnB1c2goXCJjdXN0b21cIik7dmFyIG89aS5qb2luKFwiLFwiKTswPG8ubGVuZ3RoJiYoci5pbmNsdWRlPW8pfXJldHVybiByfSx0LnBvc3RQYXlsb2FkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR9KDAsdCl9LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdH07bigwKTt2YXIgcixpPShyPW4oMSkpJiZyLl9fZXNNb2R1bGU/cjp7ZGVmYXVsdDpyfX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdC5QTlVwZGF0ZVVzZXJPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZyxyPXQuaWQsaT10Lm5hbWUsbz10LmN1c3RvbTtpZighcilyZXR1cm5cIk1pc3NpbmcgVXNlci5pZFwiO2lmKCFpKXJldHVyblwiTWlzc2luZyBVc2VyLm5hbWVcIjtpZighbi5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIjtpZihvJiYhT2JqZWN0LnZhbHVlcyhvKS5ldmVyeShmdW5jdGlvbihlKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZXx8XCJudW1iZXJcIj09dHlwZW9mIGV8fFwiYm9vbGVhblwiPT10eXBlb2YgZX0pKXJldHVyblwiSW52YWxpZCBjdXN0b20gdHlwZSwgb25seSBzdHJpbmcsIG51bWJlciBhbmQgYm9vbGVhbiB2YWx1ZXMgYXJlIGFsbG93ZWQuXCJ9LHQudXNlUGF0Y2g9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5nZXRVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZyxyPXQuaWQ7cmV0dXJuXCIvdjEvb2JqZWN0cy9cIi5jb25jYXQobi5zdWJzY3JpYmVLZXksXCIvdXNlcnMvXCIpLmNvbmNhdChyKX0sdC5wYXRjaFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnLHI9dC5pZDtyZXR1cm5cIi92MS9vYmplY3RzL1wiLmNvbmNhdChuLnN1YnNjcmliZUtleSxcIi91c2Vycy9cIikuY29uY2F0KHIpfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5nZXRBdXRoVG9rZW49ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS50b2tlbk1hbmFnZXIuZ2V0VG9rZW4oXCJ1c2VyXCIsdC5pZCl8fGUudG9rZW5NYW5hZ2VyLmdldFRva2VuKFwidXNlclwiKX0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5pbmNsdWRlLHI9e307bj92b2lkIDA9PT1uLmN1c3RvbUZpZWxkcyYmKG4uY3VzdG9tRmllbGRzPSEwKTpuPXtjdXN0b21GaWVsZHM6ITB9O2lmKG4pe3ZhciBpPVtdO24uY3VzdG9tRmllbGRzJiZpLnB1c2goXCJjdXN0b21cIik7dmFyIG89aS5qb2luKFwiLFwiKTswPG8ubGVuZ3RoJiYoci5pbmNsdWRlPW8pfXJldHVybiByfSx0LnBhdGNoUGF5bG9hZD1mdW5jdGlvbihlLHQpe3JldHVybiBmdW5jdGlvbihlLHQpe3JldHVybiB0fSgwLHQpfSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR9O24oMCk7dmFyIHIsaT0ocj1uKDEpKSYmci5fX2VzTW9kdWxlP3I6e2RlZmF1bHQ6cn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHQuUE5EZWxldGVVc2VyT3BlcmF0aW9ufSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWc7aWYoIXQpcmV0dXJuXCJNaXNzaW5nIFVzZXJJZFwiO2lmKCFuLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwifSx0LnVzZURlbGV0ZT1mdW5jdGlvbigpe3JldHVybiEwfSx0LmdldFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnO3JldHVyblwiL3YxL29iamVjdHMvXCIuY29uY2F0KG4uc3Vic2NyaWJlS2V5LFwiL3VzZXJzL1wiKS5jb25jYXQodCl9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LmdldEF1dGhUb2tlbj1mdW5jdGlvbihlLHQpe3JldHVybiBlLnRva2VuTWFuYWdlci5nZXRUb2tlbihcInVzZXJcIix0KXx8ZS50b2tlbk1hbmFnZXIuZ2V0VG9rZW4oXCJ1c2VyXCIpfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oKXtyZXR1cm57fX0sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLHQpe3JldHVybiB0fTtuKDApO3ZhciByLGk9KHI9bigxKSkmJnIuX19lc01vZHVsZT9yOntkZWZhdWx0OnJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0LlBOR2V0VXNlck9wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlLHQpe2lmKCF0LnVzZXJJZClyZXR1cm5cIk1pc3NpbmcgdXNlcklkXCJ9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWc7cmV0dXJuXCIvdjEvb2JqZWN0cy9cIi5jb25jYXQobi5zdWJzY3JpYmVLZXksXCIvdXNlcnMvXCIpLmNvbmNhdCh0LnVzZXJJZCl9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LmdldEF1dGhUb2tlbj1mdW5jdGlvbihlLHQpe3JldHVybiBlLnRva2VuTWFuYWdlci5nZXRUb2tlbihcInVzZXJcIix0LnVzZXJJZCl8fGUudG9rZW5NYW5hZ2VyLmdldFRva2VuKFwidXNlclwiKX0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5pbmNsdWRlLHI9e307bj92b2lkIDA9PT1uLmN1c3RvbUZpZWxkcyYmKG4uY3VzdG9tRmllbGRzPSEwKTpuPXtjdXN0b21GaWVsZHM6ITB9O2lmKG4pe3ZhciBpPVtdO24uY3VzdG9tRmllbGRzJiZpLnB1c2goXCJjdXN0b21cIik7dmFyIG89aS5qb2luKFwiLFwiKTswPG8ubGVuZ3RoJiYoci5pbmNsdWRlPW8pfXJldHVybiByfSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR9O24oMCk7dmFyIHIsaT0ocj1uKDEpKSYmci5fX2VzTW9kdWxlP3I6e2RlZmF1bHQ6cn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHQuUE5HZXRVc2Vyc09wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbigpe30sdC5nZXRVUkw9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jb25maWc7cmV0dXJuXCIvdjEvb2JqZWN0cy9cIi5jb25jYXQodC5zdWJzY3JpYmVLZXksXCIvdXNlcnNcIil9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LmdldEF1dGhUb2tlbj1mdW5jdGlvbihlKXtyZXR1cm4gZS50b2tlbk1hbmFnZXIuZ2V0VG9rZW4oXCJ1c2VyXCIpfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmluY2x1ZGUscj10LmxpbWl0LGk9dC5wYWdlLG89e307ciYmKG8ubGltaXQ9cik7aWYobil7dmFyIHM9W107bi50b3RhbENvdW50JiYoby5jb3VudD0hMCksbi5jdXN0b21GaWVsZHMmJnMucHVzaChcImN1c3RvbVwiKTt2YXIgYT1zLmpvaW4oXCIsXCIpOzA8YS5sZW5ndGgmJihvLmluY2x1ZGU9YSl9aSYmKGkubmV4dCYmKG8uc3RhcnQ9aS5uZXh0KSxpLnByZXYmJihvLmVuZD1pLnByZXYpKTtyZXR1cm4gb30sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLHQpe3JldHVybiB0fTtuKDApO3ZhciByLGk9KHI9bigxKSkmJnIuX19lc01vZHVsZT9yOntkZWZhdWx0OnJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0LlBOQ3JlYXRlU3BhY2VPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZyxyPXQuaWQsaT10Lm5hbWUsbz10LmN1c3RvbTtpZighcilyZXR1cm5cIk1pc3NpbmcgU3BhY2UuaWRcIjtpZighaSlyZXR1cm5cIk1pc3NpbmcgU3BhY2UubmFtZVwiO2lmKCFuLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwiO2lmKG8mJiFPYmplY3QudmFsdWVzKG8pLmV2ZXJ5KGZ1bmN0aW9uKGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlfHxcIm51bWJlclwiPT10eXBlb2YgZXx8XCJib29sZWFuXCI9PXR5cGVvZiBlfSkpcmV0dXJuXCJJbnZhbGlkIGN1c3RvbSB0eXBlLCBvbmx5IHN0cmluZywgbnVtYmVyIGFuZCBib29sZWFuIHZhbHVlcyBhcmUgYWxsb3dlZC5cIn0sdC51c2VQb3N0PWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUpe3ZhciB0PWUuY29uZmlnO3JldHVyblwiL3YxL29iamVjdHMvXCIuY29uY2F0KHQuc3Vic2NyaWJlS2V5LFwiL3NwYWNlc1wiKX0sdC5wb3N0VVJMPWZ1bmN0aW9uKGUpe3ZhciB0PWUuY29uZmlnO3JldHVyblwiL3YxL29iamVjdHMvXCIuY29uY2F0KHQuc3Vic2NyaWJlS2V5LFwiL3NwYWNlc1wiKX0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQuZ2V0QXV0aFRva2VuPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUudG9rZW5NYW5hZ2VyLmdldFRva2VuKFwic3BhY2VcIix0LmlkKXx8ZS50b2tlbk1hbmFnZXIuZ2V0VG9rZW4oXCJzcGFjZVwiKX0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5pbmNsdWRlLHI9e307bj92b2lkIDA9PT1uLmN1c3RvbUZpZWxkcyYmKG4uY3VzdG9tRmllbGRzPSEwKTpuPXtjdXN0b21GaWVsZHM6ITB9O2lmKG4pe3ZhciBpPVtdO24uY3VzdG9tRmllbGRzJiZpLnB1c2goXCJjdXN0b21cIik7dmFyIG89aS5qb2luKFwiLFwiKTswPG8ubGVuZ3RoJiYoci5pbmNsdWRlPW8pfXJldHVybiByfSx0LnBvc3RQYXlsb2FkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR9KDAsdCl9LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdH07bigwKTt2YXIgcixpPShyPW4oMSkpJiZyLl9fZXNNb2R1bGU/cjp7ZGVmYXVsdDpyfX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdC5QTlVwZGF0ZVNwYWNlT3BlcmF0aW9ufSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWcscj10LmlkLGk9dC5uYW1lLG89dC5jdXN0b207aWYoIXIpcmV0dXJuXCJNaXNzaW5nIFNwYWNlLmlkXCI7aWYoIWkpcmV0dXJuXCJNaXNzaW5nIFNwYWNlLm5hbWVcIjtpZighbi5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIjtpZihvJiYhT2JqZWN0LnZhbHVlcyhvKS5ldmVyeShmdW5jdGlvbihlKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZXx8XCJudW1iZXJcIj09dHlwZW9mIGV8fFwiYm9vbGVhblwiPT10eXBlb2YgZX0pKXJldHVyblwiSW52YWxpZCBjdXN0b20gdHlwZSwgb25seSBzdHJpbmcsIG51bWJlciBhbmQgYm9vbGVhbiB2YWx1ZXMgYXJlIGFsbG93ZWQuXCJ9LHQudXNlUGF0Y2g9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5nZXRVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZyxyPXQuaWQ7cmV0dXJuXCIvdjEvb2JqZWN0cy9cIi5jb25jYXQobi5zdWJzY3JpYmVLZXksXCIvc3BhY2VzL1wiKS5jb25jYXQocil9LHQucGF0Y2hVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZyxyPXQuaWQ7cmV0dXJuXCIvdjEvb2JqZWN0cy9cIi5jb25jYXQobi5zdWJzY3JpYmVLZXksXCIvc3BhY2VzL1wiKS5jb25jYXQocil9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LmdldEF1dGhUb2tlbj1mdW5jdGlvbihlLHQpe3JldHVybiBlLnRva2VuTWFuYWdlci5nZXRUb2tlbihcInNwYWNlXCIsdC5pZCl8fGUudG9rZW5NYW5hZ2VyLmdldFRva2VuKFwic3BhY2VcIil9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuaW5jbHVkZSxyPXt9O24/dm9pZCAwPT09bi5jdXN0b21GaWVsZHMmJihuLmN1c3RvbUZpZWxkcz0hMCk6bj17Y3VzdG9tRmllbGRzOiEwfTtpZihuKXt2YXIgaT1bXTtuLmN1c3RvbUZpZWxkcyYmaS5wdXNoKFwiY3VzdG9tXCIpO3ZhciBvPWkuam9pbihcIixcIik7MDxvLmxlbmd0aCYmKHIuaW5jbHVkZT1vKX1yZXR1cm4gcn0sdC5wYXRjaFBheWxvYWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oZSx0KXtyZXR1cm4gdH0oMCx0KX0sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLHQpe3JldHVybiB0fTtuKDApO3ZhciByLGk9KHI9bigxKSkmJnIuX19lc01vZHVsZT9yOntkZWZhdWx0OnJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0LlBORGVsZXRlU3BhY2VPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZztpZighdClyZXR1cm5cIk1pc3NpbmcgU3BhY2VJZFwiO2lmKCFuLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwifSx0LnVzZURlbGV0ZT1mdW5jdGlvbigpe3JldHVybiEwfSx0LmdldFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnO3JldHVyblwiL3YxL29iamVjdHMvXCIuY29uY2F0KG4uc3Vic2NyaWJlS2V5LFwiL3NwYWNlcy9cIikuY29uY2F0KHQpfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5nZXRBdXRoVG9rZW49ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS50b2tlbk1hbmFnZXIuZ2V0VG9rZW4oXCJzcGFjZVwiLHQpfHxlLnRva2VuTWFuYWdlci5nZXRUb2tlbihcInNwYWNlXCIpfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oKXtyZXR1cm57fX0sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLHQpe3JldHVybiB0fTtuKDApO3ZhciByLGk9KHI9bigxKSkmJnIuX19lc01vZHVsZT9yOntkZWZhdWx0OnJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0LlBOR2V0U3BhY2VzT3BlcmF0aW9ufSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKCl7fSx0LmdldFVSTD1mdW5jdGlvbihlKXt2YXIgdD1lLmNvbmZpZztyZXR1cm5cIi92MS9vYmplY3RzL1wiLmNvbmNhdCh0LnN1YnNjcmliZUtleSxcIi9zcGFjZXNcIil9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LmdldEF1dGhUb2tlbj1mdW5jdGlvbihlKXtyZXR1cm4gZS50b2tlbk1hbmFnZXIuZ2V0VG9rZW4oXCJzcGFjZVwiKX0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5pbmNsdWRlLHI9dC5saW1pdCxpPXQucGFnZSxvPXt9O3ImJihvLmxpbWl0PXIpO2lmKG4pe3ZhciBzPVtdO24udG90YWxDb3VudCYmKG8uY291bnQ9ITApLG4uY3VzdG9tRmllbGRzJiZzLnB1c2goXCJjdXN0b21cIik7dmFyIGE9cy5qb2luKFwiLFwiKTswPGEubGVuZ3RoJiYoby5pbmNsdWRlPWEpfWkmJihpLm5leHQmJihvLnN0YXJ0PWkubmV4dCksaS5wcmV2JiYoby5lbmQ9aS5wcmV2KSk7cmV0dXJuIG99LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdH07bigwKTt2YXIgcixpPShyPW4oMSkpJiZyLl9fZXNNb2R1bGU/cjp7ZGVmYXVsdDpyfX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdC5QTkdldFNwYWNlT3BlcmF0aW9ufSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7aWYoIXQuc3BhY2VJZClyZXR1cm5cIk1pc3Npbmcgc3BhY2VJZFwifSx0LmdldFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnO3JldHVyblwiL3YxL29iamVjdHMvXCIuY29uY2F0KG4uc3Vic2NyaWJlS2V5LFwiL3NwYWNlcy9cIikuY29uY2F0KHQuc3BhY2VJZCl9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LmdldEF1dGhUb2tlbj1mdW5jdGlvbihlLHQpe3JldHVybiBlLnRva2VuTWFuYWdlci5nZXRUb2tlbihcInNwYWNlXCIsdC5zcGFjZUlkKXx8ZS50b2tlbk1hbmFnZXIuZ2V0VG9rZW4oXCJzcGFjZVwiKX0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5pbmNsdWRlLHI9e307bj92b2lkIDA9PT1uLmN1c3RvbUZpZWxkcyYmKG4uY3VzdG9tRmllbGRzPSEwKTpuPXtjdXN0b21GaWVsZHM6ITB9O2lmKG4pe3ZhciBpPVtdO24uY3VzdG9tRmllbGRzJiZpLnB1c2goXCJjdXN0b21cIik7dmFyIG89aS5qb2luKFwiLFwiKTswPG8ubGVuZ3RoJiYoci5pbmNsdWRlPW8pfXJldHVybiByfSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR9O24oMCk7dmFyIHIsaT0ocj1uKDEpKSYmci5fX2VzTW9kdWxlP3I6e2RlZmF1bHQ6cn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHQuUE5HZXRNZW1iZXJzT3BlcmF0aW9ufSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7aWYoIXQuc3BhY2VJZClyZXR1cm5cIk1pc3Npbmcgc3BhY2VJZFwifSx0LmdldFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnO3JldHVyblwiL3YxL29iamVjdHMvXCIuY29uY2F0KG4uc3Vic2NyaWJlS2V5LFwiL3NwYWNlcy9cIikuY29uY2F0KHQuc3BhY2VJZCxcIi91c2Vyc1wiKX0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQuZ2V0QXV0aFRva2VuPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUudG9rZW5NYW5hZ2VyLmdldFRva2VuKFwic3BhY2VcIix0LnNwYWNlSWQpfHxlLnRva2VuTWFuYWdlci5nZXRUb2tlbihcInNwYWNlXCIpfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmluY2x1ZGUscj10LmxpbWl0LGk9dC5wYWdlLG89e307ciYmKG8ubGltaXQ9cik7aWYobil7dmFyIHM9W107bi50b3RhbENvdW50JiYoby5jb3VudD0hMCksbi5jdXN0b21GaWVsZHMmJnMucHVzaChcImN1c3RvbVwiKSxuLnVzZXJGaWVsZHMmJnMucHVzaChcInVzZXJcIiksbi5jdXN0b21Vc2VyRmllbGRzJiZzLnB1c2goXCJ1c2VyLmN1c3RvbVwiKTt2YXIgYT1zLmpvaW4oXCIsXCIpOzA8YS5sZW5ndGgmJihvLmluY2x1ZGU9YSl9aSYmKGkubmV4dCYmKG8uc3RhcnQ9aS5uZXh0KSxpLnByZXYmJihvLmVuZD1pLnByZXYpKTtyZXR1cm4gb30sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLHQpe3JldHVybiB0fTtuKDApO3ZhciByLGk9KHI9bigxKSkmJnIuX19lc01vZHVsZT9yOntkZWZhdWx0OnJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0LlBOVXBkYXRlTWVtYmVyc09wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuc3BhY2VJZCxyPXQudXNlcnM7aWYoIW4pcmV0dXJuXCJNaXNzaW5nIHNwYWNlSWRcIjtpZighcilyZXR1cm5cIk1pc3NpbmcgdXNlcnNcIn0sdC5nZXRVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZztyZXR1cm5cIi92MS9vYmplY3RzL1wiLmNvbmNhdChuLnN1YnNjcmliZUtleSxcIi9zcGFjZXMvXCIpLmNvbmNhdCh0LnNwYWNlSWQsXCIvdXNlcnNcIil9LHQucGF0Y2hVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZztyZXR1cm5cIi92MS9vYmplY3RzL1wiLmNvbmNhdChuLnN1YnNjcmliZUtleSxcIi9zcGFjZXMvXCIpLmNvbmNhdCh0LnNwYWNlSWQsXCIvdXNlcnNcIil9LHQudXNlUGF0Y2g9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQuZ2V0QXV0aFRva2VuPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUudG9rZW5NYW5hZ2VyLmdldFRva2VuKFwic3BhY2VcIix0LnNwYWNlSWQpfHxlLnRva2VuTWFuYWdlci5nZXRUb2tlbihcInNwYWNlXCIpfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmluY2x1ZGUscj10LmxpbWl0LGk9dC5wYWdlLG89e307ciYmKG8ubGltaXQ9cik7aWYobil7dmFyIHM9W107bi50b3RhbENvdW50JiYoby5jb3VudD0hMCksbi5jdXN0b21GaWVsZHMmJnMucHVzaChcImN1c3RvbVwiKSxuLnNwYWNlRmllbGRzJiZzLnB1c2goXCJzcGFjZVwiKSxuLmN1c3RvbVNwYWNlRmllbGRzJiZzLnB1c2goXCJzcGFjZS5jdXN0b21cIik7dmFyIGE9cy5qb2luKFwiLFwiKTswPGEubGVuZ3RoJiYoby5pbmNsdWRlPWEpfWkmJihpLm5leHQmJihvLnN0YXJ0PWkubmV4dCksaS5wcmV2JiYoby5lbmQ9aS5wcmV2KSk7cmV0dXJuIG99LHQucGF0Y2hQYXlsb2FkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7dmFyIG49dC51c2VycyxyPXt9O24mJjA8bi5sZW5ndGgmJihyLmFkZD1bXSxuLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9e2lkOmUuaWR9O2UuY3VzdG9tJiYodC5jdXN0b209ZS5jdXN0b20pLHIuYWRkLnB1c2godCl9KSk7cmV0dXJuIHJ9KDAsdCl9LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdH07bigwKTt2YXIgcixpPShyPW4oMSkpJiZyLl9fZXNNb2R1bGU/cjp7ZGVmYXVsdDpyfX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdC5QTlVwZGF0ZU1lbWJlcnNPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LnNwYWNlSWQscj10LnVzZXJzO2lmKCFuKXJldHVyblwiTWlzc2luZyBzcGFjZUlkXCI7aWYoIXIpcmV0dXJuXCJNaXNzaW5nIHVzZXJzXCJ9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWc7cmV0dXJuXCIvdjEvb2JqZWN0cy9cIi5jb25jYXQobi5zdWJzY3JpYmVLZXksXCIvc3BhY2VzL1wiKS5jb25jYXQodC5zcGFjZUlkLFwiL3VzZXJzXCIpfSx0LnBhdGNoVVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWc7cmV0dXJuXCIvdjEvb2JqZWN0cy9cIi5jb25jYXQobi5zdWJzY3JpYmVLZXksXCIvc3BhY2VzL1wiKS5jb25jYXQodC5zcGFjZUlkLFwiL3VzZXJzXCIpfSx0LnVzZVBhdGNoPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LmdldEF1dGhUb2tlbj1mdW5jdGlvbihlLHQpe3JldHVybiBlLnRva2VuTWFuYWdlci5nZXRUb2tlbihcInNwYWNlXCIsdC5zcGFjZUlkKXx8ZS50b2tlbk1hbmFnZXIuZ2V0VG9rZW4oXCJzcGFjZVwiKX0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5pbmNsdWRlLHI9dC5saW1pdCxpPXQucGFnZSxvPXt9O3ImJihvLmxpbWl0PXIpO2lmKG4pe3ZhciBzPVtdO24udG90YWxDb3VudCYmKG8uY291bnQ9ITApLG4uY3VzdG9tRmllbGRzJiZzLnB1c2goXCJjdXN0b21cIiksbi5zcGFjZUZpZWxkcyYmcy5wdXNoKFwic3BhY2VcIiksbi5jdXN0b21TcGFjZUZpZWxkcyYmcy5wdXNoKFwic3BhY2UuY3VzdG9tXCIpO3ZhciBhPXMuam9pbihcIixcIik7MDxhLmxlbmd0aCYmKG8uaW5jbHVkZT1hKX1pJiYoaS5uZXh0JiYoby5zdGFydD1pLm5leHQpLGkucHJldiYmKG8uZW5kPWkucHJldikpO3JldHVybiBvfSx0LnBhdGNoUGF5bG9hZD1mdW5jdGlvbihlLHQpe3JldHVybiBmdW5jdGlvbihlLHQpe3ZhciBuPXQuYWRkTWVtYmVycyxyPXQudXBkYXRlTWVtYmVycyxpPXQucmVtb3ZlTWVtYmVycyxvPXQudXNlcnMscz17fTtuJiYwPG4ubGVuZ3RoJiYocy5hZGQ9W10sbi5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PXtpZDplLmlkfTtlLmN1c3RvbSYmKHQuY3VzdG9tPWUuY3VzdG9tKSxzLmFkZC5wdXNoKHQpfSkpO3ImJjA8ci5sZW5ndGgmJihzLnVwZGF0ZT1bXSxyLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9e2lkOmUuaWR9O2UuY3VzdG9tJiYodC5jdXN0b209ZS5jdXN0b20pLHMudXBkYXRlLnB1c2godCl9KSk7byYmMDxvLmxlbmd0aCYmKHMudXBkYXRlPXMudXBkYXRlfHxbXSxvLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9e2lkOmUuaWR9O2UuY3VzdG9tJiYodC5jdXN0b209ZS5jdXN0b20pLHMudXBkYXRlLnB1c2godCl9KSk7aSYmMDxpLmxlbmd0aCYmKHMucmVtb3ZlPVtdLGkuZm9yRWFjaChmdW5jdGlvbihlKXtzLnJlbW92ZS5wdXNoKHtpZDplfSl9KSk7cmV0dXJuIHN9KDAsdCl9LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdH07bigwKTt2YXIgcixpPShyPW4oMSkpJiZyLl9fZXNNb2R1bGU/cjp7ZGVmYXVsdDpyfX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdC5QTlVwZGF0ZU1lbWJlcnNPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LnNwYWNlSWQscj10LnVzZXJzO2lmKCFuKXJldHVyblwiTWlzc2luZyBzcGFjZUlkXCI7aWYoIXIpcmV0dXJuXCJNaXNzaW5nIHVzZXJzXCJ9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWc7cmV0dXJuXCIvdjEvb2JqZWN0cy9cIi5jb25jYXQobi5zdWJzY3JpYmVLZXksXCIvc3BhY2VzL1wiKS5jb25jYXQodC5zcGFjZUlkLFwiL3VzZXJzXCIpfSx0LnBhdGNoVVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWc7cmV0dXJuXCIvdjEvb2JqZWN0cy9cIi5jb25jYXQobi5zdWJzY3JpYmVLZXksXCIvc3BhY2VzL1wiKS5jb25jYXQodC5zcGFjZUlkLFwiL3VzZXJzXCIpfSx0LnVzZVBhdGNoPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LmdldEF1dGhUb2tlbj1mdW5jdGlvbihlLHQpe3JldHVybiBlLnRva2VuTWFuYWdlci5nZXRUb2tlbihcInNwYWNlXCIsdC5zcGFjZUlkKXx8ZS50b2tlbk1hbmFnZXIuZ2V0VG9rZW4oXCJzcGFjZVwiKX0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5pbmNsdWRlLHI9dC5saW1pdCxpPXQucGFnZSxvPXt9O3ImJihvLmxpbWl0PXIpO2lmKG4pe3ZhciBzPVtdO24udG90YWxDb3VudCYmKG8uY291bnQ9ITApLG4uY3VzdG9tRmllbGRzJiZzLnB1c2goXCJjdXN0b21cIiksbi5zcGFjZUZpZWxkcyYmcy5wdXNoKFwic3BhY2VcIiksbi5jdXN0b21TcGFjZUZpZWxkcyYmcy5wdXNoKFwic3BhY2UuY3VzdG9tXCIpO3ZhciBhPXMuam9pbihcIixcIik7MDxhLmxlbmd0aCYmKG8uaW5jbHVkZT1hKX1pJiYoaS5uZXh0JiYoby5zdGFydD1pLm5leHQpLGkucHJldiYmKG8uZW5kPWkucHJldikpO3JldHVybiBvfSx0LnBhdGNoUGF5bG9hZD1mdW5jdGlvbihlLHQpe3JldHVybiBmdW5jdGlvbihlLHQpe3ZhciBuPXQudXNlcnMscj17fTtuJiYwPG4ubGVuZ3RoJiYoci5yZW1vdmU9W10sbi5mb3JFYWNoKGZ1bmN0aW9uKGUpe3IucmVtb3ZlLnB1c2goe2lkOmV9KX0pKTtyZXR1cm4gcn0oMCx0KX0sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLHQpe3JldHVybiB0fTtuKDApO3ZhciByLGk9KHI9bigxKSkmJnIuX19lc01vZHVsZT9yOntkZWZhdWx0OnJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0LlBOR2V0TWVtYmVyc2hpcHNPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXtpZighdC51c2VySWQpcmV0dXJuXCJNaXNzaW5nIHVzZXJJZFwifSx0LmdldFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnO3JldHVyblwiL3YxL29iamVjdHMvXCIuY29uY2F0KG4uc3Vic2NyaWJlS2V5LFwiL3VzZXJzL1wiKS5jb25jYXQodC51c2VySWQsXCIvc3BhY2VzXCIpfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5nZXRBdXRoVG9rZW49ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS50b2tlbk1hbmFnZXIuZ2V0VG9rZW4oXCJ1c2VyXCIsdC51c2VySWQpfHxlLnRva2VuTWFuYWdlci5nZXRUb2tlbihcInVzZXJcIil9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuaW5jbHVkZSxyPXQubGltaXQsaT10LnBhZ2Usbz17fTtyJiYoby5saW1pdD1yKTtpZihuKXt2YXIgcz1bXTtuLnRvdGFsQ291bnQmJihvLmNvdW50PSEwKSxuLmN1c3RvbUZpZWxkcyYmcy5wdXNoKFwiY3VzdG9tXCIpLG4uc3BhY2VGaWVsZHMmJnMucHVzaChcInNwYWNlXCIpLG4uY3VzdG9tU3BhY2VGaWVsZHMmJnMucHVzaChcInNwYWNlLmN1c3RvbVwiKTt2YXIgYT1zLmpvaW4oXCIsXCIpOzA8YS5sZW5ndGgmJihvLmluY2x1ZGU9YSl9aSYmKGkubmV4dCYmKG8uc3RhcnQ9aS5uZXh0KSxpLnByZXYmJihvLmVuZD1pLnByZXYpKTtyZXR1cm4gb30sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLHQpe3JldHVybiB0fTtuKDApO3ZhciByLGk9KHI9bigxKSkmJnIuX19lc01vZHVsZT9yOntkZWZhdWx0OnJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0LlBOVXBkYXRlTWVtYmVyc2hpcHNPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LnVzZXJJZCxyPXQuc3BhY2VzO2lmKCFuKXJldHVyblwiTWlzc2luZyB1c2VySWRcIjtpZighcilyZXR1cm5cIk1pc3Npbmcgc3BhY2VzXCJ9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWc7cmV0dXJuXCIvdjEvb2JqZWN0cy9cIi5jb25jYXQobi5zdWJzY3JpYmVLZXksXCIvdXNlcnMvXCIpLmNvbmNhdCh0LnVzZXJJZCxcIi9zcGFjZXNcIil9LHQucGF0Y2hVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZztyZXR1cm5cIi92MS9vYmplY3RzL1wiLmNvbmNhdChuLnN1YnNjcmliZUtleSxcIi91c2Vycy9cIikuY29uY2F0KHQudXNlcklkLFwiL3NwYWNlc1wiKX0sdC51c2VQYXRjaD1mdW5jdGlvbigpe3JldHVybiEwfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5nZXRBdXRoVG9rZW49ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS50b2tlbk1hbmFnZXIuZ2V0VG9rZW4oXCJ1c2VyXCIsdC51c2VySWQpfHxlLnRva2VuTWFuYWdlci5nZXRUb2tlbihcInVzZXJcIil9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuaW5jbHVkZSxyPXQubGltaXQsaT10LnBhZ2Usbz17fTtyJiYoby5saW1pdD1yKTtpZihuKXt2YXIgcz1bXTtuLnRvdGFsQ291bnQmJihvLmNvdW50PSEwKSxuLmN1c3RvbUZpZWxkcyYmcy5wdXNoKFwiY3VzdG9tXCIpLG4uc3BhY2VGaWVsZHMmJnMucHVzaChcInNwYWNlXCIpLG4uY3VzdG9tU3BhY2VGaWVsZHMmJnMucHVzaChcInNwYWNlLmN1c3RvbVwiKTt2YXIgYT1zLmpvaW4oXCIsXCIpOzA8YS5sZW5ndGgmJihvLmluY2x1ZGU9YSl9aSYmKGkubmV4dCYmKG8uc3RhcnQ9aS5uZXh0KSxpLnByZXYmJihvLmVuZD1pLnByZXYpKTtyZXR1cm4gb30sdC5wYXRjaFBheWxvYWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oZSx0KXt2YXIgbj10LmFkZE1lbWJlcnNoaXBzLHI9dC51cGRhdGVNZW1iZXJzaGlwcyxpPXQucmVtb3ZlTWVtYmVyc2hpcHMsbz10LnNwYWNlcyxzPXt9O24mJjA8bi5sZW5ndGgmJihzLmFkZD1bXSxuLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9e2lkOmUuaWR9O2UuY3VzdG9tJiYodC5jdXN0b209ZS5jdXN0b20pLHMuYWRkLnB1c2godCl9KSk7ciYmMDxyLmxlbmd0aCYmKHMudXBkYXRlPVtdLHIuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD17aWQ6ZS5pZH07ZS5jdXN0b20mJih0LmN1c3RvbT1lLmN1c3RvbSkscy51cGRhdGUucHVzaCh0KX0pKTtvJiYwPG8ubGVuZ3RoJiYocy51cGRhdGU9cy51cGRhdGV8fFtdLG8uZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD17aWQ6ZS5pZH07ZS5jdXN0b20mJih0LmN1c3RvbT1lLmN1c3RvbSkscy51cGRhdGUucHVzaCh0KX0pKTtpJiYwPGkubGVuZ3RoJiYocy5yZW1vdmU9W10saS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3MucmVtb3ZlLnB1c2goe2lkOmV9KX0pKTtyZXR1cm4gc30oMCx0KX0sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLHQpe3JldHVybiB0fTtuKDApO3ZhciByLGk9KHI9bigxKSkmJnIuX19lc01vZHVsZT9yOntkZWZhdWx0OnJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0LlBOVXBkYXRlTWVtYmVyc2hpcHNPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LnVzZXJJZCxyPXQuc3BhY2VzO2lmKCFuKXJldHVyblwiTWlzc2luZyB1c2VySWRcIjtpZighcilyZXR1cm5cIk1pc3Npbmcgc3BhY2VzXCJ9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWc7cmV0dXJuXCIvdjEvb2JqZWN0cy9cIi5jb25jYXQobi5zdWJzY3JpYmVLZXksXCIvdXNlcnMvXCIpLmNvbmNhdCh0LnVzZXJJZCxcIi9zcGFjZXNcIil9LHQucGF0Y2hVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZztyZXR1cm5cIi92MS9vYmplY3RzL1wiLmNvbmNhdChuLnN1YnNjcmliZUtleSxcIi91c2Vycy9cIikuY29uY2F0KHQudXNlcklkLFwiL3NwYWNlc1wiKX0sdC51c2VQYXRjaD1mdW5jdGlvbigpe3JldHVybiEwfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5nZXRBdXRoVG9rZW49ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS50b2tlbk1hbmFnZXIuZ2V0VG9rZW4oXCJ1c2VyXCIsdC51c2VySWQpfHxlLnRva2VuTWFuYWdlci5nZXRUb2tlbihcInVzZXJcIil9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuaW5jbHVkZSxyPXQubGltaXQsaT10LnBhZ2Usbz17fTtyJiYoby5saW1pdD1yKTtpZihuKXt2YXIgcz1bXTtuLnRvdGFsQ291bnQmJihvLmNvdW50PSEwKSxuLmN1c3RvbUZpZWxkcyYmcy5wdXNoKFwiY3VzdG9tXCIpLG4uc3BhY2VGaWVsZHMmJnMucHVzaChcInNwYWNlXCIpLG4uY3VzdG9tU3BhY2VGaWVsZHMmJnMucHVzaChcInNwYWNlLmN1c3RvbVwiKTt2YXIgYT1zLmpvaW4oXCIsXCIpOzA8YS5sZW5ndGgmJihvLmluY2x1ZGU9YSl9aSYmKGkubmV4dCYmKG8uc3RhcnQ9aS5uZXh0KSxpLnByZXYmJihvLmVuZD1pLnByZXYpKTtyZXR1cm4gb30sdC5wYXRjaFBheWxvYWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oZSx0KXt2YXIgbj10LnNwYWNlcyxyPXt9O24mJjA8bi5sZW5ndGgmJihyLmFkZD1bXSxuLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9e2lkOmUuaWR9O2UuY3VzdG9tJiYodC5jdXN0b209ZS5jdXN0b20pLHIuYWRkLnB1c2godCl9KSk7cmV0dXJuIHJ9KDAsdCl9LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdH07bigwKTt2YXIgcixpPShyPW4oMSkpJiZyLl9fZXNNb2R1bGU/cjp7ZGVmYXVsdDpyfX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdC5QTlVwZGF0ZU1lbWJlcnNoaXBzT3BlcmF0aW9ufSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC51c2VySWQscj10LnNwYWNlcztpZighbilyZXR1cm5cIk1pc3NpbmcgdXNlcklkXCI7aWYoIXIpcmV0dXJuXCJNaXNzaW5nIHNwYWNlc1wifSx0LmdldFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnO3JldHVyblwiL3YxL29iamVjdHMvXCIuY29uY2F0KG4uc3Vic2NyaWJlS2V5LFwiL3VzZXJzL1wiKS5jb25jYXQodC51c2VySWQsXCIvc3BhY2VzXCIpfSx0LnBhdGNoVVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWc7cmV0dXJuXCIvdjEvb2JqZWN0cy9cIi5jb25jYXQobi5zdWJzY3JpYmVLZXksXCIvdXNlcnMvXCIpLmNvbmNhdCh0LnVzZXJJZCxcIi9zcGFjZXNcIil9LHQudXNlUGF0Y2g9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQuZ2V0QXV0aFRva2VuPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUudG9rZW5NYW5hZ2VyLmdldFRva2VuKFwidXNlclwiLHQudXNlcklkKXx8ZS50b2tlbk1hbmFnZXIuZ2V0VG9rZW4oXCJ1c2VyXCIpfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmluY2x1ZGUscj10LmxpbWl0LGk9dC5wYWdlLG89e307ciYmKG8ubGltaXQ9cik7aWYobil7dmFyIHM9W107bi50b3RhbENvdW50JiYoby5jb3VudD0hMCksbi5jdXN0b21GaWVsZHMmJnMucHVzaChcImN1c3RvbVwiKSxuLnNwYWNlRmllbGRzJiZzLnB1c2goXCJzcGFjZVwiKSxuLmN1c3RvbVNwYWNlRmllbGRzJiZzLnB1c2goXCJzcGFjZS5jdXN0b21cIik7dmFyIGE9cy5qb2luKFwiLFwiKTswPGEubGVuZ3RoJiYoby5pbmNsdWRlPWEpfWkmJihpLm5leHQmJihvLnN0YXJ0PWkubmV4dCksaS5wcmV2JiYoby5lbmQ9aS5wcmV2KSk7cmV0dXJuIG99LHQucGF0Y2hQYXlsb2FkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7dmFyIG49dC5zcGFjZXMscj17fTtuJiYwPG4ubGVuZ3RoJiYoci5yZW1vdmU9W10sbi5mb3JFYWNoKGZ1bmN0aW9uKGUpe3IucmVtb3ZlLnB1c2goe2lkOmV9KX0pKTtyZXR1cm4gcn0oMCx0KX0sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLHQpe3JldHVybiB0fTtuKDApO3ZhciByLGk9KHI9bigxKSkmJnIuX19lc01vZHVsZT9yOntkZWZhdWx0OnJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0LlBOQWNjZXNzTWFuYWdlckF1ZGl0fSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUpe2lmKCFlLmNvbmZpZy5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIn0sdC5nZXRVUkw9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jb25maWc7cmV0dXJuXCIvdjIvYXV0aC9hdWRpdC9zdWIta2V5L1wiLmNvbmNhdCh0LnN1YnNjcmliZUtleSl9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiExfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmNoYW5uZWwscj10LmNoYW5uZWxHcm91cCxpPXQuYXV0aEtleXMsbz12b2lkIDA9PT1pP1tdOmkscz17fTtuJiYocy5jaGFubmVsPW4pO3ImJihzW1wiY2hhbm5lbC1ncm91cFwiXT1yKTswPG8ubGVuZ3RoJiYocy5hdXRoPW8uam9pbihcIixcIikpO3JldHVybiBzfSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQucGF5bG9hZH07bigwKTt2YXIgcixpPShyPW4oMSkpJiZyLl9fZXNNb2R1bGU/cjp7ZGVmYXVsdDpyfX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdC5QTkFjY2Vzc01hbmFnZXJHcmFudH0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlKXt2YXIgdD1lLmNvbmZpZztpZighdC5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIjtpZighdC5wdWJsaXNoS2V5KXJldHVyblwiTWlzc2luZyBQdWJsaXNoIEtleVwiO2lmKCF0LnNlY3JldEtleSlyZXR1cm5cIk1pc3NpbmcgU2VjcmV0IEtleVwifSx0LmdldFVSTD1mdW5jdGlvbihlKXt2YXIgdD1lLmNvbmZpZztyZXR1cm5cIi92Mi9hdXRoL2dyYW50L3N1Yi1rZXkvXCIuY29uY2F0KHQuc3Vic2NyaWJlS2V5KX0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITF9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuY2hhbm5lbHMscj12b2lkIDA9PT1uP1tdOm4saT10LmNoYW5uZWxHcm91cHMsbz12b2lkIDA9PT1pP1tdOmkscz10LnR0bCxhPXQucmVhZCx1PXZvaWQgMCE9PWEmJmEsYz10LndyaXRlLGY9dm9pZCAwIT09YyYmYyxsPXQubWFuYWdlLGg9dm9pZCAwIT09bCYmbCxwPXQuYXV0aEtleXMsZD12b2lkIDA9PT1wP1tdOnAsZz17fTtnLnI9dT9cIjFcIjpcIjBcIixnLnc9Zj9cIjFcIjpcIjBcIixnLm09aD9cIjFcIjpcIjBcIiwwPHIubGVuZ3RoJiYoZy5jaGFubmVsPXIuam9pbihcIixcIikpOzA8by5sZW5ndGgmJihnW1wiY2hhbm5lbC1ncm91cFwiXT1vLmpvaW4oXCIsXCIpKTswPGQubGVuZ3RoJiYoZy5hdXRoPWQuam9pbihcIixcIikpOyFzJiYwIT09c3x8KGcudHRsPXMpO3JldHVybiBnfSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKCl7cmV0dXJue319O24oMCk7dmFyIHIsaT0ocj1uKDEpKSYmci5fX2VzTW9kdWxlP3I6e2RlZmF1bHQ6cn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHQuUE5BY2Nlc3NNYW5hZ2VyR3JhbnRUb2tlbn0sdC5leHRyYWN0UGVybWlzc2lvbnM9bCx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWc7aWYoIW4uc3Vic2NyaWJlS2V5KXJldHVyblwiTWlzc2luZyBTdWJzY3JpYmUgS2V5XCI7aWYoIW4ucHVibGlzaEtleSlyZXR1cm5cIk1pc3NpbmcgUHVibGlzaCBLZXlcIjtpZighbi5zZWNyZXRLZXkpcmV0dXJuXCJNaXNzaW5nIFNlY3JldCBLZXlcIjtpZighdC5yZXNvdXJjZXMmJiF0LnBhdHRlcm5zKXJldHVyblwiTWlzc2luZyBlaXRoZXIgUmVzb3VyY2VzIG9yIFBhdHRlcm5zLlwiO2lmKHQucmVzb3VyY2VzJiYoIXQucmVzb3VyY2VzLnVzZXJzfHwwPT09T2JqZWN0LmtleXModC5yZXNvdXJjZXMudXNlcnMpLmxlbmd0aCkmJighdC5yZXNvdXJjZXMuc3BhY2VzfHwwPT09T2JqZWN0LmtleXModC5yZXNvdXJjZXMuc3BhY2VzKS5sZW5ndGgpfHx0LnBhdHRlcm5zJiYoIXQucGF0dGVybnMudXNlcnN8fDA9PT1PYmplY3Qua2V5cyh0LnBhdHRlcm5zLnVzZXJzKS5sZW5ndGgpJiYoIXQucGF0dGVybnMuc3BhY2VzfHwwPT09T2JqZWN0LmtleXModC5wYXR0ZXJucy5zcGFjZXMpLmxlbmd0aCkpcmV0dXJuXCJNaXNzaW5nIHZhbHVlcyBmb3IgZWl0aGVyIFJlc291cmNlcyBvciBQYXR0ZXJucy5cIn0sdC5wb3N0VVJMPWZ1bmN0aW9uKGUpe3ZhciB0PWUuY29uZmlnO3JldHVyblwiL3YzL3BhbS9cIi5jb25jYXQodC5zdWJzY3JpYmVLZXksXCIvZ3JhbnRcIil9LHQudXNlUG9zdD1mdW5jdGlvbigpe3JldHVybiEwfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKCl7cmV0dXJue319LHQucG9zdFBheWxvYWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oZSx0KXt2YXIgbj10LnR0bCxyPXQucmVzb3VyY2VzLGk9dC5wYXR0ZXJucyxvPXQubWV0YSxzPXt0dGw6MCxwZXJtaXNzaW9uczp7cmVzb3VyY2VzOntjaGFubmVsczp7fSxncm91cHM6e30sdXNlcnM6e30sc3BhY2VzOnt9fSxwYXR0ZXJuczp7Y2hhbm5lbHM6e30sZ3JvdXBzOnt9LHVzZXJzOnt9LHNwYWNlczp7fX0sbWV0YTp7fX19O2lmKHIpe3ZhciBhPXIudXNlcnMsdT1yLnNwYWNlczthJiZPYmplY3Qua2V5cyhhKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3MucGVybWlzc2lvbnMucmVzb3VyY2VzLnVzZXJzW2VdPWwoYVtlXSl9KSx1JiZPYmplY3Qua2V5cyh1KS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3MucGVybWlzc2lvbnMucmVzb3VyY2VzLnNwYWNlc1tlXT1sKHVbZV0pfSl9aWYoaSl7dmFyIGM9aS51c2VycyxmPWkuc3BhY2VzO2MmJk9iamVjdC5rZXlzKGMpLmZvckVhY2goZnVuY3Rpb24oZSl7cy5wZXJtaXNzaW9ucy5wYXR0ZXJucy51c2Vyc1tlXT1sKGNbZV0pfSksZiYmT2JqZWN0LmtleXMoZikuZm9yRWFjaChmdW5jdGlvbihlKXtzLnBlcm1pc3Npb25zLnBhdHRlcm5zLnNwYWNlc1tlXT1sKGZbZV0pfSl9IW4mJjAhPT1ufHwocy50dGw9bik7byYmKHMucGVybWlzc2lvbnMubWV0YT1vKTtyZXR1cm4gc30oMCx0KX0sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLHQpe3JldHVybiB0LmRhdGEudG9rZW59O24oMCk7dmFyIHIsaT0ocj1uKDEpKSYmci5fX2VzTW9kdWxlP3I6e2RlZmF1bHQ6cn07ZnVuY3Rpb24gbChlKXt2YXIgdD0wO3JldHVybiBlLmNyZWF0ZSYmKHR8PTE2KSxlLmRlbGV0ZSYmKHR8PTgpLGUubWFuYWdlJiYodHw9NCksZS53cml0ZSYmKHR8PTIpLGUucmVhZCYmKHR8PTEpLHR9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gci5kZWZhdWx0LlBOUHVibGlzaE9wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnLHI9dC5tZXNzYWdlO2lmKCF0LmNoYW5uZWwpcmV0dXJuXCJNaXNzaW5nIENoYW5uZWxcIjtpZighcilyZXR1cm5cIk1pc3NpbmcgTWVzc2FnZVwiO2lmKCFuLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwifSx0LnVzZVBvc3Q9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LnNlbmRCeVBvc3Q7cmV0dXJuIHZvaWQgMCE9PW4mJm59LHQuZ2V0VVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWcscj10LmNoYW5uZWwsaT10Lm1lc3NhZ2Usbz1hKGUsaSk7cmV0dXJuXCIvcHVibGlzaC9cIi5jb25jYXQobi5wdWJsaXNoS2V5LFwiL1wiKS5jb25jYXQobi5zdWJzY3JpYmVLZXksXCIvMC9cIikuY29uY2F0KHMuZGVmYXVsdC5lbmNvZGVTdHJpbmcociksXCIvMC9cIikuY29uY2F0KHMuZGVmYXVsdC5lbmNvZGVTdHJpbmcobykpfSx0LnBvc3RVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZyxyPXQuY2hhbm5lbDtyZXR1cm5cIi9wdWJsaXNoL1wiLmNvbmNhdChuLnB1Ymxpc2hLZXksXCIvXCIpLmNvbmNhdChuLnN1YnNjcmliZUtleSxcIi8wL1wiKS5jb25jYXQocy5kZWZhdWx0LmVuY29kZVN0cmluZyhyKSxcIi8wXCIpfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5wb3N0UGF5bG9hZD1mdW5jdGlvbihlLHQpe3ZhciBuPXQubWVzc2FnZTtyZXR1cm4gYShlLG4pfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10Lm1ldGEscj10LnJlcGxpY2F0ZSxpPXZvaWQgMD09PXJ8fHIsbz10LnN0b3JlSW5IaXN0b3J5LHM9dC50dGwsYT17fTtudWxsIT1vJiYoYS5zdG9yZT1vP1wiMVwiOlwiMFwiKTtzJiYoYS50dGw9cyk7ITE9PT1pJiYoYS5ub3JlcD1cInRydWVcIik7biYmXCJvYmplY3RcIj09PXUobikmJihhLm1ldGE9SlNPTi5zdHJpbmdpZnkobikpO3JldHVybiBhfSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJue3RpbWV0b2tlbjp0WzJdfX07bigwKTt2YXIgcj1pKG4oMSkpLHM9aShuKDIpKTtmdW5jdGlvbiBpKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiB1KGUpe3JldHVybih1PVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9KShlKX1mdW5jdGlvbiBhKGUsdCl7dmFyIG49ZS5jcnlwdG8scj1lLmNvbmZpZyxpPUpTT04uc3RyaW5naWZ5KHQpO3JldHVybiByLmNpcGhlcktleSYmKGk9bi5lbmNyeXB0KGkpLGk9SlNPTi5zdHJpbmdpZnkoaSkpLGl9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gci5kZWZhdWx0LlBOU2lnbmFsT3BlcmF0aW9ufSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWcscj10Lm1lc3NhZ2U7aWYoIXQuY2hhbm5lbClyZXR1cm5cIk1pc3NpbmcgQ2hhbm5lbFwiO2lmKCFyKXJldHVyblwiTWlzc2luZyBNZXNzYWdlXCI7aWYoIW4uc3Vic2NyaWJlS2V5KXJldHVyblwiTWlzc2luZyBTdWJzY3JpYmUgS2V5XCJ9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWcscj10LmNoYW5uZWwsaT10Lm1lc3NhZ2Usbz1mdW5jdGlvbihlLHQpe3JldHVybiBKU09OLnN0cmluZ2lmeSh0KX0oMCxpKTtyZXR1cm5cIi9zaWduYWwvXCIuY29uY2F0KG4ucHVibGlzaEtleSxcIi9cIikuY29uY2F0KG4uc3Vic2NyaWJlS2V5LFwiLzAvXCIpLmNvbmNhdChzLmRlZmF1bHQuZW5jb2RlU3RyaW5nKHIpLFwiLzAvXCIpLmNvbmNhdChzLmRlZmF1bHQuZW5jb2RlU3RyaW5nKG8pKX0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbigpe3JldHVybnt9fSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJue3RpbWV0b2tlbjp0WzJdfX07bigwKTt2YXIgcj1pKG4oMSkpLHM9aShuKDIpKTtmdW5jdGlvbiBpKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiByLmRlZmF1bHQuUE5IaXN0b3J5T3BlcmF0aW9ufSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5jaGFubmVsLHI9ZS5jb25maWc7aWYoIW4pcmV0dXJuXCJNaXNzaW5nIGNoYW5uZWxcIjtpZighci5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIn0sdC5nZXRVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmNoYW5uZWwscj1lLmNvbmZpZztyZXR1cm5cIi92Mi9oaXN0b3J5L3N1Yi1rZXkvXCIuY29uY2F0KHIuc3Vic2NyaWJlS2V5LFwiL2NoYW5uZWwvXCIpLmNvbmNhdChpLmRlZmF1bHQuZW5jb2RlU3RyaW5nKG4pKX0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuc3RhcnQscj10LmVuZCxpPXQucmV2ZXJzZSxvPXQuY291bnQscz12b2lkIDA9PT1vPzEwMDpvLGE9dC5zdHJpbmdpZmllZFRpbWVUb2tlbix1PXZvaWQgMCE9PWEmJmEsYz10LmluY2x1ZGVNZXRhLGY9dm9pZCAwIT09YyYmYyxsPXtpbmNsdWRlX3Rva2VuOlwidHJ1ZVwifTtsLmNvdW50PXMsbiYmKGwuc3RhcnQ9bik7ciYmKGwuZW5kPXIpO3UmJihsLnN0cmluZ19tZXNzYWdlX3Rva2VuPVwidHJ1ZVwiKTtudWxsIT1pJiYobC5yZXZlcnNlPWkudG9TdHJpbmcoKSk7ZiYmKGwuaW5jbHVkZV9tZXRhPVwidHJ1ZVwiKTtyZXR1cm4gbH0sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihuLGUpe3ZhciByPXttZXNzYWdlczpbXSxzdGFydFRpbWVUb2tlbjplWzFdLGVuZFRpbWVUb2tlbjplWzJdfTtBcnJheS5pc0FycmF5KGVbMF0pJiZlWzBdLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9e3RpbWV0b2tlbjplLnRpbWV0b2tlbixlbnRyeTpmdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnLHI9ZS5jcnlwdG87aWYoIW4uY2lwaGVyS2V5KXJldHVybiB0O3RyeXtyZXR1cm4gci5kZWNyeXB0KHQpfWNhdGNoKGUpe3JldHVybiB0fX0obixlLm1lc3NhZ2UpfTtlLm1ldGEmJih0Lm1ldGE9ZS5tZXRhKSxyLm1lc3NhZ2VzLnB1c2godCl9KTtyZXR1cm4gcn07bigwKTt2YXIgcj1vKG4oMSkpLGk9byhuKDIpKTtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiByLmRlZmF1bHQuUE5EZWxldGVNZXNzYWdlc09wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuY2hhbm5lbCxyPWUuY29uZmlnO2lmKCFuKXJldHVyblwiTWlzc2luZyBjaGFubmVsXCI7aWYoIXIuc3Vic2NyaWJlS2V5KXJldHVyblwiTWlzc2luZyBTdWJzY3JpYmUgS2V5XCJ9LHQudXNlRGVsZXRlPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5jaGFubmVsLHI9ZS5jb25maWc7cmV0dXJuXCIvdjMvaGlzdG9yeS9zdWIta2V5L1wiLmNvbmNhdChyLnN1YnNjcmliZUtleSxcIi9jaGFubmVsL1wiKS5jb25jYXQoaS5kZWZhdWx0LmVuY29kZVN0cmluZyhuKSl9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LnN0YXJ0LHI9dC5lbmQsaT17fTtuJiYoaS5zdGFydD1uKTtyJiYoaS5lbmQ9cik7cmV0dXJuIGl9LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdC5wYXlsb2FkfTtuKDApO3ZhciByPW8obigxKSksaT1vKG4oMikpO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHIuZGVmYXVsdC5QTk1lc3NhZ2VDb3VudHN9LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmNoYW5uZWxzLHI9dC50aW1ldG9rZW4saT10LmNoYW5uZWxUaW1ldG9rZW5zLG89ZS5jb25maWc7aWYoIW4pcmV0dXJuXCJNaXNzaW5nIGNoYW5uZWxcIjtpZihyJiZpKXJldHVyblwidGltZXRva2VuIGFuZCBjaGFubmVsVGltZXRva2VucyBhcmUgaW5jb21wYXRpYmxlIHRvZ2V0aGVyXCI7aWYociYmaSYmMTxpLmxlbmd0aCYmbi5sZW5ndGghPT1pLmxlbmd0aClyZXR1cm5cIkxlbmd0aCBvZiBjaGFubmVsVGltZXRva2VucyBhbmQgY2hhbm5lbHMgZG8gbm90IG1hdGNoXCI7aWYoIW8uc3Vic2NyaWJlS2V5KXJldHVyblwiTWlzc2luZyBTdWJzY3JpYmUgS2V5XCJ9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5jaGFubmVscyxyPWUuY29uZmlnLGk9bi5qb2luKFwiLFwiKTtyZXR1cm5cIi92My9oaXN0b3J5L3N1Yi1rZXkvXCIuY29uY2F0KHIuc3Vic2NyaWJlS2V5LFwiL21lc3NhZ2UtY291bnRzL1wiKS5jb25jYXQoby5kZWZhdWx0LmVuY29kZVN0cmluZyhpKSl9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LnRpbWV0b2tlbixyPXQuY2hhbm5lbFRpbWV0b2tlbnMsaT17fTtpZihyJiYxPT09ci5sZW5ndGgpe3ZhciBvPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGV9KGUpfHxmdW5jdGlvbihlLHQpe2lmKCEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChlKXx8XCJbb2JqZWN0IEFyZ3VtZW50c11cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKSkpcmV0dXJuO3ZhciBuPVtdLHI9ITAsaT0hMSxvPXZvaWQgMDt0cnl7Zm9yKHZhciBzLGE9ZVtTeW1ib2wuaXRlcmF0b3JdKCk7IShyPShzPWEubmV4dCgpKS5kb25lKSYmKG4ucHVzaChzLnZhbHVlKSwhdHx8bi5sZW5ndGghPT10KTtyPSEwKTt9Y2F0Y2goZSl7aT0hMCxvPWV9ZmluYWxseXt0cnl7cnx8bnVsbD09YS5yZXR1cm58fGEucmV0dXJuKCl9ZmluYWxseXtpZihpKXRocm93IG99fXJldHVybiBufShlLHQpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpfSgpfShyLDEpWzBdO2kudGltZXRva2VuPW99ZWxzZSByP2kuY2hhbm5lbHNUaW1ldG9rZW49ci5qb2luKFwiLFwiKTpuJiYoaS50aW1ldG9rZW49bik7cmV0dXJuIGl9LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm57Y2hhbm5lbHM6dC5jaGFubmVsc319O3ZhciByPWkobigxKSksbz1pKG4oMikpO2Z1bmN0aW9uIGkoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHIuZGVmYXVsdC5QTkZldGNoTWVzc2FnZXNPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmNoYW5uZWxzLHI9dC5pbmNsdWRlTWVzc2FnZUFjdGlvbnMsaT12b2lkIDAhPT1yJiZyLG89ZS5jb25maWc7aWYoIW58fDA9PT1uLmxlbmd0aClyZXR1cm5cIk1pc3NpbmcgY2hhbm5lbHNcIjtpZighby5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIjtpZihpJiYxPG4ubGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoXCJIaXN0b3J5IGNhbiByZXR1cm4gYWN0aW9ucyBkYXRhIGZvciBhIHNpbmdsZSBjaGFubmVsIG9ubHkuIEVpdGhlciBwYXNzIGEgc2luZ2xlIGNoYW5uZWwgb3IgZGlzYWJsZSB0aGUgaW5jbHVkZU1lc3NhZ2VBY3Rpb25zIGZsYWcuXCIpfSx0LmdldFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPXQuY2hhbm5lbHMscj12b2lkIDA9PT1uP1tdOm4saT10LmluY2x1ZGVNZXNzYWdlQWN0aW9ucyxvPXZvaWQgMCE9PWkmJmkscz1lLmNvbmZpZyxhPW8/XCJoaXN0b3J5LXdpdGgtYWN0aW9uc1wiOlwiaGlzdG9yeVwiLHU9MDxyLmxlbmd0aD9yLmpvaW4oXCIsXCIpOlwiLFwiO3JldHVyblwiL3YzL1wiLmNvbmNhdChhLFwiL3N1Yi1rZXkvXCIpLmNvbmNhdChzLnN1YnNjcmliZUtleSxcIi9jaGFubmVsL1wiKS5jb25jYXQoYy5kZWZhdWx0LmVuY29kZVN0cmluZyh1KSl9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LnN0YXJ0LHI9dC5lbmQsaT10LmNvdW50LG89dC5zdHJpbmdpZmllZFRpbWVUb2tlbixzPXZvaWQgMCE9PW8mJm8sYT10LmluY2x1ZGVNZXRhLHU9dm9pZCAwIT09YSYmYSxjPXt9O2kmJihjLm1heD1pKTtuJiYoYy5zdGFydD1uKTtyJiYoYy5lbmQ9cik7cyYmKGMuc3RyaW5nX21lc3NhZ2VfdG9rZW49XCJ0cnVlXCIpO3UmJihjLmluY2x1ZGVfbWV0YT1cInRydWVcIik7cmV0dXJuIGN9LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24ocixlKXt2YXIgaT17Y2hhbm5lbHM6e319O3JldHVybiBPYmplY3Qua2V5cyhlLmNoYW5uZWxzfHx7fSkuZm9yRWFjaChmdW5jdGlvbihuKXtpLmNoYW5uZWxzW25dPVtdLChlLmNoYW5uZWxzW25dfHxbXSkuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD17fTt0LmNoYW5uZWw9bix0LnRpbWV0b2tlbj1lLnRpbWV0b2tlbix0Lm1lc3NhZ2U9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZyxyPWUuY3J5cHRvO2lmKCFuLmNpcGhlcktleSlyZXR1cm4gdDt0cnl7cmV0dXJuIHIuZGVjcnlwdCh0KX1jYXRjaChlKXtyZXR1cm4gdH19KHIsZS5tZXNzYWdlKSxlLmFjdGlvbnMmJih0LmFjdGlvbnM9ZS5hY3Rpb25zLHQuZGF0YT1lLmFjdGlvbnMpLGUubWV0YSYmKHQubWV0YT1lLm1ldGEpLGkuY2hhbm5lbHNbbl0ucHVzaCh0KX0pfSksaX07bigwKTt2YXIgcj1pKG4oMSkpLGM9aShuKDIpKTtmdW5jdGlvbiBpKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiByLmRlZmF1bHQuUE5TdWJzY3JpYmVPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSl7aWYoIWUuY29uZmlnLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwifSx0LmdldFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnLHI9dC5jaGFubmVscyxpPXZvaWQgMD09PXI/W106cixvPTA8aS5sZW5ndGg/aS5qb2luKFwiLFwiKTpcIixcIjtyZXR1cm5cIi92Mi9zdWJzY3JpYmUvXCIuY29uY2F0KG4uc3Vic2NyaWJlS2V5LFwiL1wiKS5jb25jYXQocy5kZWZhdWx0LmVuY29kZVN0cmluZyhvKSxcIi8wXCIpfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRTdWJzY3JpYmVUaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnLHI9dC5zdGF0ZSxpPXQuY2hhbm5lbEdyb3VwcyxvPXZvaWQgMD09PWk/W106aSxzPXQudGltZXRva2VuLGE9dC5maWx0ZXJFeHByZXNzaW9uLHU9dC5yZWdpb24sYz17aGVhcnRiZWF0Om4uZ2V0UHJlc2VuY2VUaW1lb3V0KCl9OzA8by5sZW5ndGgmJihjW1wiY2hhbm5lbC1ncm91cFwiXT1vLmpvaW4oXCIsXCIpKTthJiYwPGEubGVuZ3RoJiYoY1tcImZpbHRlci1leHByXCJdPWEpO09iamVjdC5rZXlzKHIpLmxlbmd0aCYmKGMuc3RhdGU9SlNPTi5zdHJpbmdpZnkocikpO3MmJihjLnR0PXMpO3UmJihjLnRyPXUpO3JldHVybiBjfSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKGUsdCl7dmFyIHI9W107dC5tLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9e3B1Ymxpc2hUaW1ldG9rZW46ZS5wLnQscmVnaW9uOmUucC5yfSxuPXtzaGFyZDpwYXJzZUludChlLmEsMTApLHN1YnNjcmlwdGlvbk1hdGNoOmUuYixjaGFubmVsOmUuYyxtZXNzYWdlVHlwZTplLmUscGF5bG9hZDplLmQsZmxhZ3M6ZS5mLGlzc3VpbmdDbGllbnRJZDplLmksc3Vic2NyaWJlS2V5OmUuayxvcmlnaW5hdGlvblRpbWV0b2tlbjplLm8sdXNlck1ldGFkYXRhOmUudSxwdWJsaXNoTWV0YURhdGE6dH07ci5wdXNoKG4pfSk7dmFyIG49e3RpbWV0b2tlbjp0LnQudCxyZWdpb246dC50LnJ9O3JldHVybnttZXNzYWdlczpyLG1ldGFkYXRhOm59fTtuKDApO3ZhciByPWkobigxKSkscz1pKG4oMikpO2Z1bmN0aW9uIGkoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD12b2lkIDA7aShuKDMpKTt2YXIgcj1pKG4oNCkpO24oMCk7ZnVuY3Rpb24gaShlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gbyhlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19ZnVuY3Rpb24gcyhlLHQsbil7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1uLGV9dmFyIGEsdSxjLGY9KGE9bCwodT1be2tleTpcImluaXRcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLl9jb25maWc9ZSx0aGlzLl9tYXhTdWJEb21haW49MjAsdGhpcy5fY3VycmVudFN1YkRvbWFpbj1NYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqdGhpcy5fbWF4U3ViRG9tYWluKSx0aGlzLl9wcm92aWRlZEZRRE49KHRoaXMuX2NvbmZpZy5zZWN1cmU/XCJodHRwczovL1wiOlwiaHR0cDovL1wiKSt0aGlzLl9jb25maWcub3JpZ2luLHRoaXMuX2NvcmVQYXJhbXM9e30sdGhpcy5zaGlmdFN0YW5kYXJkT3JpZ2luKCl9fSx7a2V5OlwibmV4dE9yaWdpblwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Byb3ZpZGVkRlFETi5tYXRjaCgvcHNcXC5wbmRzblxcLmNvbSQvaSk/KHRoaXMuX2N1cnJlbnRTdWJEb21haW49dGhpcy5fY3VycmVudFN1YkRvbWFpbisxLHRoaXMuX2N1cnJlbnRTdWJEb21haW4+PXRoaXMuX21heFN1YkRvbWFpbiYmKHRoaXMuX2N1cnJlbnRTdWJEb21haW49MSksZT10aGlzLl9jdXJyZW50U3ViRG9tYWluLnRvU3RyaW5nKCksdGhpcy5fcHJvdmlkZWRGUUROLnJlcGxhY2UoXCJwcy5wbmRzbi5jb21cIixcInBzXCIuY29uY2F0KGUsXCIucG5kc24uY29tXCIpKSk6dGhpcy5fcHJvdmlkZWRGUUROO3ZhciBlfX0se2tleTpcImhhc01vZHVsZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBlIGluIHRoaXMuX21vZHVsZXN9fSx7a2V5Olwic2hpZnRTdGFuZGFyZE9yaWdpblwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N0YW5kYXJkT3JpZ2luPXRoaXMubmV4dE9yaWdpbigpLHRoaXMuX3N0YW5kYXJkT3JpZ2lufX0se2tleTpcImdldFN0YW5kYXJkT3JpZ2luXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3RhbmRhcmRPcmlnaW59fSx7a2V5OlwiUE9TVFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiB0aGlzLl9tb2R1bGVzLnBvc3QoZSx0LG4scil9fSx7a2V5OlwiUEFUQ0hcIix2YWx1ZTpmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gdGhpcy5fbW9kdWxlcy5wYXRjaChlLHQsbixyKX19LHtrZXk6XCJHRVRcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIHRoaXMuX21vZHVsZXMuZ2V0KGUsdCxuKX19LHtrZXk6XCJERUxFVEVcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIHRoaXMuX21vZHVsZXMuZGVsKGUsdCxuKX19LHtrZXk6XCJfZGV0ZWN0RXJyb3JDYXRlZ29yeVwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKFwiRU5PVEZPVU5EXCI9PT1lLmNvZGUpcmV0dXJuIHIuZGVmYXVsdC5QTk5ldHdvcmtJc3N1ZXNDYXRlZ29yeTtpZihcIkVDT05OUkVGVVNFRFwiPT09ZS5jb2RlKXJldHVybiByLmRlZmF1bHQuUE5OZXR3b3JrSXNzdWVzQ2F0ZWdvcnk7aWYoXCJFQ09OTlJFU0VUXCI9PT1lLmNvZGUpcmV0dXJuIHIuZGVmYXVsdC5QTk5ldHdvcmtJc3N1ZXNDYXRlZ29yeTtpZihcIkVBSV9BR0FJTlwiPT09ZS5jb2RlKXJldHVybiByLmRlZmF1bHQuUE5OZXR3b3JrSXNzdWVzQ2F0ZWdvcnk7aWYoMD09PWUuc3RhdHVzfHxlLmhhc093blByb3BlcnR5KFwic3RhdHVzXCIpJiZ2b2lkIDA9PT1lLnN0YXR1cylyZXR1cm4gci5kZWZhdWx0LlBOTmV0d29ya0lzc3Vlc0NhdGVnb3J5O2lmKGUudGltZW91dClyZXR1cm4gci5kZWZhdWx0LlBOVGltZW91dENhdGVnb3J5O2lmKFwiRVRJTUVET1VUXCI9PT1lLmNvZGUpcmV0dXJuIHIuZGVmYXVsdC5QTk5ldHdvcmtJc3N1ZXNDYXRlZ29yeTtpZihlLnJlc3BvbnNlKXtpZihlLnJlc3BvbnNlLmJhZFJlcXVlc3QpcmV0dXJuIHIuZGVmYXVsdC5QTkJhZFJlcXVlc3RDYXRlZ29yeTtpZihlLnJlc3BvbnNlLmZvcmJpZGRlbilyZXR1cm4gci5kZWZhdWx0LlBOQWNjZXNzRGVuaWVkQ2F0ZWdvcnl9cmV0dXJuIHIuZGVmYXVsdC5QTlVua25vd25DYXRlZ29yeX19XSkmJm8oYS5wcm90b3R5cGUsdSksdm9pZChjJiZvKGEsYykpLGwpO2Z1bmN0aW9uIGwodCl7dmFyIG49dGhpczshZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGwpLHModGhpcyxcIl9tb2R1bGVzXCIsdm9pZCAwKSxzKHRoaXMsXCJfY29uZmlnXCIsdm9pZCAwKSxzKHRoaXMsXCJfbWF4U3ViRG9tYWluXCIsdm9pZCAwKSxzKHRoaXMsXCJfY3VycmVudFN1YkRvbWFpblwiLHZvaWQgMCkscyh0aGlzLFwiX3N0YW5kYXJkT3JpZ2luXCIsdm9pZCAwKSxzKHRoaXMsXCJfc3Vic2NyaWJlT3JpZ2luXCIsdm9pZCAwKSxzKHRoaXMsXCJfcHJvdmlkZWRGUUROXCIsdm9pZCAwKSxzKHRoaXMsXCJfcmVxdWVzdFRpbWVvdXRcIix2b2lkIDApLHModGhpcyxcIl9jb3JlUGFyYW1zXCIsdm9pZCAwKSx0aGlzLl9tb2R1bGVzPXt9LE9iamVjdC5rZXlzKHQpLmZvckVhY2goZnVuY3Rpb24oZSl7bi5fbW9kdWxlc1tlXT10W2VdLmJpbmQobil9KX10LmRlZmF1bHQ9ZixlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PXZvaWQgMDt2YXIgcj17Z2V0OmZ1bmN0aW9uKGUpe3RyeXtyZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oZSl9Y2F0Y2goZSl7cmV0dXJuIG51bGx9fSxzZXQ6ZnVuY3Rpb24oZSx0KXt0cnl7cmV0dXJuIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGUsdCl9Y2F0Y2goZSl7cmV0dXJuIG51bGx9fX07dC5kZWZhdWx0PXIsZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZixsLGgpe1widXNlIHN0cmljdFwiOyhmdW5jdGlvbihpKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxsLmRlZmF1bHQ9dm9pZCAwO3ZhciBlLG89KGU9aCg3NCkpJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfTtmdW5jdGlvbiBzKGUpe3JldHVybihzPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9KShlKX1mdW5jdGlvbiB0KGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX12YXIgbixyLGEsdT0obj1jLChyPVt7a2V5OlwiZGVjb2RlVG9rZW5cIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1cIlwiO2UubGVuZ3RoJTQ9PTM/dD1cIj1cIjplLmxlbmd0aCU0PT0yJiYodD1cIj09XCIpO3ZhciBuPWUucmVwbGFjZShcIi1cIixcIitcIikucmVwbGFjZShcIl9cIixcIi9cIikrdCxyPW8uZGVmYXVsdC5kZWNvZGUobmV3IGkuZnJvbShuLFwiYmFzZTY0XCIpKTtpZihcIm9iamVjdFwiPT09cyhyKSlyZXR1cm4gcn19XSkmJnQobi5wcm90b3R5cGUsciksdm9pZChhJiZ0KG4sYSkpLGMpO2Z1bmN0aW9uIGMoKXshZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGMpfWwuZGVmYXVsdD11LGYuZXhwb3J0cz1sLmRlZmF1bHR9KS5jYWxsKHRoaXMsaCg5KS5CdWZmZXIpfSxmdW5jdGlvbihlLHQpe3ZhciBuO249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30oKTt0cnl7bj1ufHxuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpfWNhdGNoKGUpe1wib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cmJihuPXdpbmRvdyl9ZS5leHBvcnRzPW59LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt0LmJ5dGVMZW5ndGg9ZnVuY3Rpb24oZSl7dmFyIHQ9bChlKSxuPXRbMF0scj10WzFdO3JldHVybiAzKihuK3IpLzQtcn0sdC50b0J5dGVBcnJheT1mdW5jdGlvbihlKXt2YXIgdCxuLHI9bChlKSxpPXJbMF0sbz1yWzFdLHM9bmV3IGYoZnVuY3Rpb24oZSx0LG4pe3JldHVybiAzKih0K24pLzQtbn0oMCxpLG8pKSxhPTAsdT0wPG8/aS00Omk7Zm9yKG49MDtuPHU7bis9NCl0PWNbZS5jaGFyQ29kZUF0KG4pXTw8MTh8Y1tlLmNoYXJDb2RlQXQobisxKV08PDEyfGNbZS5jaGFyQ29kZUF0KG4rMildPDw2fGNbZS5jaGFyQ29kZUF0KG4rMyldLHNbYSsrXT10Pj4xNiYyNTUsc1thKytdPXQ+PjgmMjU1LHNbYSsrXT0yNTUmdDsyPT09byYmKHQ9Y1tlLmNoYXJDb2RlQXQobildPDwyfGNbZS5jaGFyQ29kZUF0KG4rMSldPj40LHNbYSsrXT0yNTUmdCk7MT09PW8mJih0PWNbZS5jaGFyQ29kZUF0KG4pXTw8MTB8Y1tlLmNoYXJDb2RlQXQobisxKV08PDR8Y1tlLmNoYXJDb2RlQXQobisyKV0+PjIsc1thKytdPXQ+PjgmMjU1LHNbYSsrXT0yNTUmdCk7cmV0dXJuIHN9LHQuZnJvbUJ5dGVBcnJheT1mdW5jdGlvbihlKXtmb3IodmFyIHQsbj1lLmxlbmd0aCxyPW4lMyxpPVtdLG89MCxzPW4tcjtvPHM7bys9MTYzODMpaS5wdXNoKHUoZSxvLHM8bysxNjM4Mz9zOm8rMTYzODMpKTsxPT1yPyh0PWVbbi0xXSxpLnB1c2goYVt0Pj4yXSthW3Q8PDQmNjNdK1wiPT1cIikpOjI9PXImJih0PShlW24tMl08PDgpK2Vbbi0xXSxpLnB1c2goYVt0Pj4xMF0rYVt0Pj40JjYzXSthW3Q8PDImNjNdK1wiPVwiKSk7cmV0dXJuIGkuam9pbihcIlwiKX07Zm9yKHZhciBhPVtdLGM9W10sZj1cInVuZGVmaW5lZFwiIT10eXBlb2YgVWludDhBcnJheT9VaW50OEFycmF5OkFycmF5LHI9XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCIsaT0wLG89ci5sZW5ndGg7aTxvOysraSlhW2ldPXJbaV0sY1tyLmNoYXJDb2RlQXQoaSldPWk7ZnVuY3Rpb24gbChlKXt2YXIgdD1lLmxlbmd0aDtpZigwPHQlNCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0XCIpO3ZhciBuPWUuaW5kZXhPZihcIj1cIik7cmV0dXJuLTE9PT1uJiYobj10KSxbbixuPT09dD8wOjQtbiU0XX1mdW5jdGlvbiB1KGUsdCxuKXtmb3IodmFyIHIsaSxvPVtdLHM9dDtzPG47cys9MylyPShlW3NdPDwxNiYxNjcxMTY4MCkrKGVbcysxXTw8OCY2NTI4MCkrKDI1NSZlW3MrMl0pLG8ucHVzaChhWyhpPXIpPj4xOCY2M10rYVtpPj4xMiY2M10rYVtpPj42JjYzXSthWzYzJmldKTtyZXR1cm4gby5qb2luKFwiXCIpfWNbXCItXCIuY2hhckNvZGVBdCgwKV09NjIsY1tcIl9cIi5jaGFyQ29kZUF0KDApXT02M30sZnVuY3Rpb24oZSx0KXt0LnJlYWQ9ZnVuY3Rpb24oZSx0LG4scixpKXt2YXIgbyxzLGE9OCppLXItMSx1PSgxPDxhKS0xLGM9dT4+MSxmPS03LGw9bj9pLTE6MCxoPW4/LTE6MSxwPWVbdCtsXTtmb3IobCs9aCxvPXAmKDE8PC1mKS0xLHA+Pj0tZixmKz1hOzA8ZjtvPTI1NipvK2VbdCtsXSxsKz1oLGYtPTgpO2ZvcihzPW8mKDE8PC1mKS0xLG8+Pj0tZixmKz1yOzA8ZjtzPTI1NipzK2VbdCtsXSxsKz1oLGYtPTgpO2lmKDA9PT1vKW89MS1jO2Vsc2V7aWYobz09PXUpcmV0dXJuIHM/TmFOOjEvMCoocD8tMToxKTtzKz1NYXRoLnBvdygyLHIpLG8tPWN9cmV0dXJuKHA/LTE6MSkqcypNYXRoLnBvdygyLG8tcil9LHQud3JpdGU9ZnVuY3Rpb24oZSx0LG4scixpLG8pe3ZhciBzLGEsdSxjPTgqby1pLTEsZj0oMTw8YyktMSxsPWY+PjEsaD0yMz09PWk/TWF0aC5wb3coMiwtMjQpLU1hdGgucG93KDIsLTc3KTowLHA9cj8wOm8tMSxkPXI/MTotMSxnPXQ8MHx8MD09PXQmJjEvdDwwPzE6MDtmb3IodD1NYXRoLmFicyh0KSxpc05hTih0KXx8dD09PTEvMD8oYT1pc05hTih0KT8xOjAscz1mKToocz1NYXRoLmZsb29yKE1hdGgubG9nKHQpL01hdGguTE4yKSx0Kih1PU1hdGgucG93KDIsLXMpKTwxJiYocy0tLHUqPTIpLDI8PSh0Kz0xPD1zK2w/aC91OmgqTWF0aC5wb3coMiwxLWwpKSp1JiYocysrLHUvPTIpLGY8PXMrbD8oYT0wLHM9Zik6MTw9cytsPyhhPSh0KnUtMSkqTWF0aC5wb3coMixpKSxzKz1sKTooYT10Kk1hdGgucG93KDIsbC0xKSpNYXRoLnBvdygyLGkpLHM9MCkpOzg8PWk7ZVtuK3BdPTI1NSZhLHArPWQsYS89MjU2LGktPTgpO2ZvcihzPXM8PGl8YSxjKz1pOzA8YztlW24rcF09MjU1JnMscCs9ZCxzLz0yNTYsYy09OCk7ZVtuK3AtZF18PTEyOCpnfX0sZnVuY3Rpb24oZSx0KXt2YXIgbj17fS50b1N0cmluZztlLmV4cG9ydHM9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oZSl7cmV0dXJuXCJbb2JqZWN0IEFycmF5XVwiPT1uLmNhbGwoZSl9fSxmdW5jdGlvbihyLGksZSl7KGZ1bmN0aW9uKGIpe3ZhciBlLHQsbjt0PVtdLHZvaWQgMD09PShuPVwiZnVuY3Rpb25cIj09dHlwZW9mKGU9ZnVuY3Rpb24oKXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIG8oZSl7dGhpcy4kaGV4PWV9by5wcm90b3R5cGU9e2xlbmd0aDpmdW5jdGlvbigpe3JldHVybiB0aGlzLiRoZXgubGVuZ3RoLzJ9LHRvU3RyaW5nOmZ1bmN0aW9uKGUpe2lmKCFlfHxcImhleFwiPT09ZXx8MTY9PT1lKXJldHVybiB0aGlzLiRoZXg7aWYoXCJ1dGYtOFwiPT09ZSl7Zm9yKHZhciB0PVwiXCIsbj0wO248dGhpcy4kaGV4Lmxlbmd0aDtuKz0yKXQrPVwiJVwiK3RoaXMuJGhleC5zdWJzdHJpbmcobixuKzIpO3JldHVybiBkZWNvZGVVUklDb21wb25lbnQodCl9aWYoXCJsYXRpblwiIT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbmlzZWQgZm9ybWF0OiBcIitlKTtmb3IodmFyIHQ9W10sbj0wO248dGhpcy4kaGV4Lmxlbmd0aDtuKz0yKXQucHVzaChwYXJzZUludCh0aGlzLiRoZXguc3Vic3RyaW5nKG4sbisyKSwxNikpO3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyx0KX19LG8uZnJvbUxhdGluU3RyaW5nPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1cIlwiLG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZS5jaGFyQ29kZUF0KG4pLnRvU3RyaW5nKDE2KTsxPT09ci5sZW5ndGgmJihyPVwiMFwiK3IpLHQrPXJ9cmV0dXJuIG5ldyBvKHQpfSxvLmZyb21VdGY4U3RyaW5nPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1lbmNvZGVVUklDb21wb25lbnQoZSksbj1cIlwiLHI9MDtyPHQubGVuZ3RoO3IrKylpZihcIiVcIj09PXQuY2hhckF0KHIpKW4rPXQuc3Vic3RyaW5nKHIrMSxyKzMpLHIrPTI7ZWxzZXt2YXIgaT10LmNoYXJDb2RlQXQocikudG9TdHJpbmcoMTYpO2kubGVuZ3RoPDImJihpPVwiMFwiK2kpLG4rPWl9cmV0dXJuIG5ldyBvKG4pfTt2YXIgcz1bXSxmPXt9LHI9ZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKGUrXCIgbm90IGltcGxlbWVudGVkXCIpfX07ZnVuY3Rpb24gZSgpe31mdW5jdGlvbiB0KCl7fWZ1bmN0aW9uIGwoZSx0KXt2YXIgbj1lLnZhbHVlO3JldHVybiBuPDI0P246MjQ9PW4/dC5yZWFkQnl0ZSgpOjI1PT1uP3QucmVhZFVpbnQxNigpOjI2PT1uP3QucmVhZFVpbnQzMigpOjI3PT1uP3QucmVhZFVpbnQ2NCgpOjMxPT1uP251bGw6dm9pZCByKFwiQWRkaXRpb25hbCBpbmZvOiBcIituKSgpfWZ1bmN0aW9uIGEoZSx0LG4pe3ZhciByPWU8PDU7dDwyND9uLndyaXRlQnl0ZShyfHQpOnQ8MjU2PyhuLndyaXRlQnl0ZSgyNHxyKSxuLndyaXRlQnl0ZSh0KSk6dDw2NTUzNj8obi53cml0ZUJ5dGUoMjV8ciksbi53cml0ZVVpbnQxNih0KSk6dDw0Mjk0OTY3Mjk2PyhuLndyaXRlQnl0ZSgyNnxyKSxuLndyaXRlVWludDMyKHQpKToobi53cml0ZUJ5dGUoMjd8ciksbi53cml0ZVVpbnQ2NCh0KSl9ZS5wcm90b3R5cGU9e3BlZWtCeXRlOnIoXCJwZWVrQnl0ZVwiKSxyZWFkQnl0ZTpyKFwicmVhZEJ5dGVcIikscmVhZENodW5rOnIoXCJyZWFkQ2h1bmtcIikscmVhZEZsb2F0MTY6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnJlYWRVaW50MTYoKSx0PSgzMjc2NyZlKT4+MTAsbj0xMDIzJmUscj0zMjc2OCZlO2lmKDMxPT10KXJldHVybiAwPT1uP3I/LTEvMDoxLzA6TmFOO3ZhciBpPXQ/TWF0aC5wb3coMix0LTI1KSooMTAyNCtuKTpNYXRoLnBvdygyLC0yNCkqbjtyZXR1cm4gcj8taTppfSxyZWFkRmxvYXQzMjpmdW5jdGlvbigpe3ZhciBlPXRoaXMucmVhZFVpbnQzMigpLHQ9KDIxNDc0ODM2NDcmZSk+PjIzLG49ODM4ODYwNyZlLHI9MjE0NzQ4MzY0OCZlO2lmKDI1NT09dClyZXR1cm4gMD09bj9yPy0xLzA6MS8wOk5hTjt2YXIgaT10P01hdGgucG93KDIsdC0yMy0xMjcpKig4Mzg4NjA4K24pOk1hdGgucG93KDIsLTE0OSkqbjtyZXR1cm4gcj8taTppfSxyZWFkRmxvYXQ2NDpmdW5jdGlvbigpe3ZhciBlPXRoaXMucmVhZFVpbnQzMigpLHQ9dGhpcy5yZWFkVWludDMyKCksbj1lPj4yMCYyMDQ3LHI9NDI5NDk2NzI5NiooMTA0ODU3NSZlKSt0LGk9MjE0NzQ4MzY0OCZlO2lmKDIwNDc9PW4pcmV0dXJuIDA9PT1yP2k/LTEvMDoxLzA6TmFOO3ZhciBvPW4/TWF0aC5wb3coMixuLTUyLTEwMjMpKig0NTAzNTk5NjI3MzcwNDk2K3IpOk1hdGgucG93KDIsLTEwNzQpKnI7cmV0dXJuIGk/LW86b30scmVhZFVpbnQxNjpmdW5jdGlvbigpe3JldHVybiAyNTYqdGhpcy5yZWFkQnl0ZSgpK3RoaXMucmVhZEJ5dGUoKX0scmVhZFVpbnQzMjpmdW5jdGlvbigpe3JldHVybiA2NTUzNip0aGlzLnJlYWRVaW50MTYoKSt0aGlzLnJlYWRVaW50MTYoKX0scmVhZFVpbnQ2NDpmdW5jdGlvbigpe3JldHVybiA0Mjk0OTY3Mjk2KnRoaXMucmVhZFVpbnQzMigpK3RoaXMucmVhZFVpbnQzMigpfX0sdC5wcm90b3R5cGU9e3dyaXRlQnl0ZTpyKFwid3JpdGVCeXRlXCIpLHJlc3VsdDpyKFwicmVzdWx0XCIpLHdyaXRlRmxvYXQxNjpyKFwid3JpdGVGbG9hdDE2XCIpLHdyaXRlRmxvYXQzMjpyKFwid3JpdGVGbG9hdDMyXCIpLHdyaXRlRmxvYXQ2NDpyKFwid3JpdGVGbG9hdDY0XCIpLHdyaXRlVWludDE2OmZ1bmN0aW9uKGUpe3RoaXMud3JpdGVCeXRlKGU+PjgmMjU1KSx0aGlzLndyaXRlQnl0ZSgyNTUmZSl9LHdyaXRlVWludDMyOmZ1bmN0aW9uKGUpe3RoaXMud3JpdGVVaW50MTYoZT4+MTYmNjU1MzUpLHRoaXMud3JpdGVVaW50MTYoNjU1MzUmZSl9LHdyaXRlVWludDY0OmZ1bmN0aW9uKGUpe2lmKDkwMDcxOTkyNTQ3NDA5OTI8PWV8fGU8PS05MDA3MTk5MjU0NzQwOTkyKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBlbmNvZGUgVWludDY0IG9mOiBcIitlK1wiIG1hZ25pdHVkZSB0byBiaWcgKGZsb2F0aW5nIHBvaW50IGVycm9ycylcIik7dGhpcy53cml0ZVVpbnQzMihNYXRoLmZsb29yKGUvNDI5NDk2NzI5NikpLHRoaXMud3JpdGVVaW50MzIoZSU0Mjk0OTY3Mjk2KX0sd3JpdGVTdHJpbmc6cihcIndyaXRlU3RyaW5nXCIpLGNhbldyaXRlQmluYXJ5OmZ1bmN0aW9uKGUpe3JldHVybiExfSx3cml0ZUJpbmFyeTpyKFwid3JpdGVDaHVua1wiKX07dmFyIGg9bmV3IEVycm9yO2Z1bmN0aW9uIHAoZSl7dmFyIHQ9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5yZWFkQnl0ZSgpO3JldHVybnt0eXBlOnQ+PjUsdmFsdWU6MzEmdH19KGUpO3N3aXRjaCh0LnR5cGUpe2Nhc2UgMDpyZXR1cm4gbCh0LGUpO2Nhc2UgMTpyZXR1cm4tMS1sKHQsZSk7Y2FzZSAyOnJldHVybiBlLnJlYWRDaHVuayhsKHQsZSkpO2Nhc2UgMzp2YXIgbj1lLnJlYWRDaHVuayhsKHQsZSkpO3JldHVybiBuLnRvU3RyaW5nKFwidXRmLThcIik7Y2FzZSA0OmNhc2UgNTp2YXIgcj1sKHQsZSksaT1bXTtpZihudWxsIT09cil7NT09PXQudHlwZSYmKHIqPTIpO2Zvcih2YXIgbz0wO288cjtvKyspaVtvXT1wKGUpfWVsc2UgZm9yKHZhciBzOyhzPXAoZSkpIT09aDspaS5wdXNoKHMpO2lmKDUhPT10LnR5cGUpcmV0dXJuIGk7Zm9yKHZhciBhPXt9LG89MDtvPGkubGVuZ3RoO28rPTIpYVtpW29dXT1pW28rMV07cmV0dXJuIGE7Y2FzZSA2OnZhciB1PWwodCxlKSxjPWZbdV0saT1wKGUpO3JldHVybiBjP2MoaSk6aTtjYXNlIDc6aWYoMjU9PT10LnZhbHVlKXJldHVybiBlLnJlYWRGbG9hdDE2KCk7aWYoMjY9PT10LnZhbHVlKXJldHVybiBlLnJlYWRGbG9hdDMyKCk7aWYoMjc9PT10LnZhbHVlKXJldHVybiBlLnJlYWRGbG9hdDY0KCk7c3dpdGNoKGwodCxlKSl7Y2FzZSAyMDpyZXR1cm4hMTtjYXNlIDIxOnJldHVybiEwO2Nhc2UgMjI6cmV0dXJuIG51bGw7Y2FzZSAyMzpyZXR1cm47Y2FzZSBudWxsOnJldHVybiBoO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBmaXhlZCB2YWx1ZTogXCIrdC52YWx1ZSl9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBoZWFkZXI6IFwiK0pTT04uc3RyaW5naWZ5KHQpKX10aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWQgeWV0XCIpfWZ1bmN0aW9uIHUoZSx0KXtmb3IodmFyIG49MDtuPHMubGVuZ3RoO24rKyl7dmFyIHI9c1tuXS5mbihlKTtpZih2b2lkIDAhPT1yKXJldHVybiBhKDYsc1tuXS50YWcsdCksdShyLHQpfWlmKGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUudG9DQk9SJiYoZT1lLnRvQ0JPUigpKSwhMT09PWUpYSg3LDIwLHQpO2Vsc2UgaWYoITA9PT1lKWEoNywyMSx0KTtlbHNlIGlmKG51bGw9PT1lKWEoNywyMix0KTtlbHNlIGlmKHZvaWQgMD09PWUpYSg3LDIzLHQpO2Vsc2UgaWYoXCJudW1iZXJcIj09dHlwZW9mIGUpTWF0aC5mbG9vcihlKT09PWUmJmU8OTAwNzE5OTI1NDc0MDk5MiYmLTkwMDcxOTkyNTQ3NDA5OTI8ZT9lPDA/YSgxLC0xLWUsdCk6YSgwLGUsdCk6KGZ1bmN0aW9uKGUsdCxuKXtuLndyaXRlQnl0ZShlPDw1fHQpfSg3LDI3LHQpLHQud3JpdGVGbG9hdDY0KGUpKTtlbHNlIGlmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXQud3JpdGVTdHJpbmcoZSxmdW5jdGlvbihlKXthKDMsZSx0KX0pO2Vsc2UgaWYodC5jYW5Xcml0ZUJpbmFyeShlKSl0LndyaXRlQmluYXJ5KGUsZnVuY3Rpb24oZSl7YSgyLGUsdCl9KTtlbHNle2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlKXRocm93IG5ldyBFcnJvcihcIkNCT1IgZW5jb2Rpbmcgbm90IHN1cHBvcnRlZDogXCIrZSk7aWYoZy5jb25maWcudXNlVG9KU09OJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnRvSlNPTiYmKGU9ZS50b0pTT04oKSksQXJyYXkuaXNBcnJheShlKSl7YSg0LGUubGVuZ3RoLHQpO2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXUoZVtuXSx0KX1lbHNle3ZhciBpPU9iamVjdC5rZXlzKGUpO2EoNSxpLmxlbmd0aCx0KTtmb3IodmFyIG49MDtuPGkubGVuZ3RoO24rKyl1KGlbbl0sdCksdShlW2lbbl1dLHQpfX19dmFyIGM9W10sZD1bXSxnPXtjb25maWc6e3VzZVRvSlNPTjohMH0sYWRkV3JpdGVyOmZ1bmN0aW9uKHQsbil7XCJzdHJpbmdcIj09dHlwZW9mIHQ/ZC5wdXNoKGZ1bmN0aW9uKGUpe2lmKHQ9PT1lKXJldHVybiBuKGUpfSk6ZC5wdXNoKHQpfSxhZGRSZWFkZXI6ZnVuY3Rpb24obixyKXtcInN0cmluZ1wiPT10eXBlb2Ygbj9jLnB1c2goZnVuY3Rpb24oZSx0KXtpZihuPT09dClyZXR1cm4gcihlLHQpfSk6Yy5wdXNoKG4pfSxlbmNvZGU6ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49MDtuPGQubGVuZ3RoO24rKyl7dmFyIHI9ZFtuXSxpPXIodCk7aWYoaSlyZXR1cm4gdShlLGkpLGkucmVzdWx0KCl9dGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgb3V0cHV0IGZvcm1hdDogXCIrdCl9LGRlY29kZTpmdW5jdGlvbihlLHQpe2Zvcih2YXIgbj0wO248Yy5sZW5ndGg7bisrKXt2YXIgcj1jW25dLGk9cihlLHQpO2lmKGkpcmV0dXJuIHAoaSl9dGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgaW5wdXQgZm9ybWF0OiBcIit0KX0sYWRkU2VtYW50aWNFbmNvZGU6ZnVuY3Rpb24oZSx0KXtpZihcIm51bWJlclwiIT10eXBlb2YgZXx8ZSUxIT0wfHxlPDApdGhyb3cgbmV3IEVycm9yKFwiVGFnIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXCIpO3JldHVybiBzLnB1c2goe3RhZzplLGZuOnR9KSx0aGlzfSxhZGRTZW1hbnRpY0RlY29kZTpmdW5jdGlvbihlLHQpe2lmKFwibnVtYmVyXCIhPXR5cGVvZiBlfHxlJTEhPTB8fGU8MCl0aHJvdyBuZXcgRXJyb3IoXCJUYWcgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJcIik7cmV0dXJuIGZbZV09dCx0aGlzfSxSZWFkZXI6ZSxXcml0ZXI6dH07ZnVuY3Rpb24gaShlKXt0aGlzLmJ1ZmZlcj1lLHRoaXMucG9zPTB9ZnVuY3Rpb24gbihlKXt0aGlzLmJ5dGVMZW5ndGg9MCx0aGlzLmRlZmF1bHRCdWZmZXJMZW5ndGg9MTYzODQsdGhpcy5sYXRlc3RCdWZmZXI9Yi5hbGxvYyh0aGlzLmRlZmF1bHRCdWZmZXJMZW5ndGgpLHRoaXMubGF0ZXN0QnVmZmVyT2Zmc2V0PTAsdGhpcy5jb21wbGV0ZUJ1ZmZlcnM9W10sdGhpcy5zdHJpbmdGb3JtYXQ9ZX1mdW5jdGlvbiB5KGUpe3RoaXMuaGV4PWUsdGhpcy5wb3M9MH1mdW5jdGlvbiB2KGUpe3RoaXMuJGhleD1cIlwiLHRoaXMuZmluYWxGb3JtYXQ9ZXx8XCJoZXhcIn1yZXR1cm4oaS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlLnByb3RvdHlwZSkpLnBlZWtCeXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMucG9zXX0saS5wcm90b3R5cGUucmVhZEJ5dGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5wb3MrK119LGkucHJvdG90eXBlLnJlYWRVaW50MTY9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmJ1ZmZlci5yZWFkVUludDE2QkUodGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9MixlfSxpLnByb3RvdHlwZS5yZWFkVWludDMyPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5idWZmZXIucmVhZFVJbnQzMkJFKHRoaXMucG9zKTtyZXR1cm4gdGhpcy5wb3MrPTQsZX0saS5wcm90b3R5cGUucmVhZEZsb2F0MzI9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmJ1ZmZlci5yZWFkRmxvYXRCRSh0aGlzLnBvcyk7cmV0dXJuIHRoaXMucG9zKz00LGV9LGkucHJvdG90eXBlLnJlYWRGbG9hdDY0PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5idWZmZXIucmVhZERvdWJsZUJFKHRoaXMucG9zKTtyZXR1cm4gdGhpcy5wb3MrPTgsZX0saS5wcm90b3R5cGUucmVhZENodW5rPWZ1bmN0aW9uKGUpe3ZhciB0PWIuYWxsb2MoZSk7cmV0dXJuIHRoaXMuYnVmZmVyLmNvcHkodCwwLHRoaXMucG9zLHRoaXMucG9zKz1lKSx0fSwobi5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0LnByb3RvdHlwZSkpLndyaXRlQnl0ZT1mdW5jdGlvbihlKXt0aGlzLmxhdGVzdEJ1ZmZlclt0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldCsrXT1lLHRoaXMubGF0ZXN0QnVmZmVyT2Zmc2V0Pj10aGlzLmxhdGVzdEJ1ZmZlci5sZW5ndGgmJih0aGlzLmNvbXBsZXRlQnVmZmVycy5wdXNoKHRoaXMubGF0ZXN0QnVmZmVyKSx0aGlzLmxhdGVzdEJ1ZmZlcj1iLmFsbG9jKHRoaXMuZGVmYXVsdEJ1ZmZlckxlbmd0aCksdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQ9MCksdGhpcy5ieXRlTGVuZ3RoKyt9LG4ucHJvdG90eXBlLndyaXRlRmxvYXQzMj1mdW5jdGlvbihlKXt2YXIgdD1iLmFsbG9jKDQpO3Qud3JpdGVGbG9hdEJFKGUsMCksdGhpcy53cml0ZUJ1ZmZlcih0KX0sbi5wcm90b3R5cGUud3JpdGVGbG9hdDY0PWZ1bmN0aW9uKGUpe3ZhciB0PWIuYWxsb2MoOCk7dC53cml0ZURvdWJsZUJFKGUsMCksdGhpcy53cml0ZUJ1ZmZlcih0KX0sbi5wcm90b3R5cGUud3JpdGVTdHJpbmc9ZnVuY3Rpb24oZSx0KXt2YXIgbj1iLmZyb20oZSxcInV0Zi04XCIpO3Qobi5sZW5ndGgpLHRoaXMud3JpdGVCdWZmZXIobil9LG4ucHJvdG90eXBlLmNhbldyaXRlQmluYXJ5PWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgYn0sbi5wcm90b3R5cGUud3JpdGVCaW5hcnk9ZnVuY3Rpb24oZSx0KXt0KGUubGVuZ3RoKSx0aGlzLndyaXRlQnVmZmVyKGUpfSxuLnByb3RvdHlwZS53cml0ZUJ1ZmZlcj1mdW5jdGlvbihlKXtpZighKGUgaW5zdGFuY2VvZiBiKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQnVmZmVyV3JpdGVyIG9ubHkgYWNjZXB0cyBCdWZmZXJzXCIpO3RoaXMubGF0ZXN0QnVmZmVyT2Zmc2V0P3RoaXMubGF0ZXN0QnVmZmVyLmxlbmd0aC10aGlzLmxhdGVzdEJ1ZmZlck9mZnNldD49ZS5sZW5ndGg/KGUuY29weSh0aGlzLmxhdGVzdEJ1ZmZlcix0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldCksdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQrPWUubGVuZ3RoLHRoaXMubGF0ZXN0QnVmZmVyT2Zmc2V0Pj10aGlzLmxhdGVzdEJ1ZmZlci5sZW5ndGgmJih0aGlzLmNvbXBsZXRlQnVmZmVycy5wdXNoKHRoaXMubGF0ZXN0QnVmZmVyKSx0aGlzLmxhdGVzdEJ1ZmZlcj1iLmFsbG9jKHRoaXMuZGVmYXVsdEJ1ZmZlckxlbmd0aCksdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQ9MCkpOih0aGlzLmNvbXBsZXRlQnVmZmVycy5wdXNoKHRoaXMubGF0ZXN0QnVmZmVyLnNsaWNlKDAsdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQpKSx0aGlzLmNvbXBsZXRlQnVmZmVycy5wdXNoKGUpLHRoaXMubGF0ZXN0QnVmZmVyPWIuYWxsb2ModGhpcy5kZWZhdWx0QnVmZmVyTGVuZ3RoKSx0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldD0wKTp0aGlzLmNvbXBsZXRlQnVmZmVycy5wdXNoKGUpLHRoaXMuYnl0ZUxlbmd0aCs9ZS5sZW5ndGh9LG4ucHJvdG90eXBlLnJlc3VsdD1mdW5jdGlvbigpe2Zvcih2YXIgZT1iLmFsbG9jKHRoaXMuYnl0ZUxlbmd0aCksdD0wLG49MDtuPHRoaXMuY29tcGxldGVCdWZmZXJzLmxlbmd0aDtuKyspe3ZhciByPXRoaXMuY29tcGxldGVCdWZmZXJzW25dO3IuY29weShlLHQsMCxyLmxlbmd0aCksdCs9ci5sZW5ndGh9cmV0dXJuIHRoaXMubGF0ZXN0QnVmZmVyT2Zmc2V0JiZ0aGlzLmxhdGVzdEJ1ZmZlci5jb3B5KGUsdCwwLHRoaXMubGF0ZXN0QnVmZmVyT2Zmc2V0KSx0aGlzLnN0cmluZ0Zvcm1hdD9lLnRvU3RyaW5nKHRoaXMuc3RyaW5nRm9ybWF0KTplfSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBiJiYoZy5hZGRSZWFkZXIoZnVuY3Rpb24oZSx0KXtpZihlIGluc3RhbmNlb2YgYilyZXR1cm4gbmV3IGkoZSk7aWYoXCJoZXhcIj09PXR8fFwiYmFzZTY0XCI9PT10KXt2YXIgbj1iLmZyb20oZSx0KTtyZXR1cm4gbmV3IGkobil9fSksZy5hZGRXcml0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiYnVmZmVyXCIhPT1lP1wiaGV4XCI9PT1lfHxcImJhc2U2NFwiPT09ZT9uZXcgbihlKTp2b2lkIDA6bmV3IG59KSksKHkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZS5wcm90b3R5cGUpKS5wZWVrQnl0ZT1mdW5jdGlvbigpe3ZhciBlPXRoaXMuaGV4LnN1YnN0cmluZyh0aGlzLnBvcywyKTtyZXR1cm4gcGFyc2VJbnQoZSwxNil9LHkucHJvdG90eXBlLnJlYWRCeXRlPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5oZXguc3Vic3RyaW5nKHRoaXMucG9zLHRoaXMucG9zKzIpO3JldHVybiB0aGlzLnBvcys9MixwYXJzZUludChlLDE2KX0seS5wcm90b3R5cGUucmVhZENodW5rPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuaGV4LnN1YnN0cmluZyh0aGlzLnBvcyx0aGlzLnBvcysyKmUpO3JldHVybiB0aGlzLnBvcys9MiplLFwiZnVuY3Rpb25cIj09dHlwZW9mIGI/Yi5mcm9tKHQsXCJoZXhcIik6bmV3IG8odCl9LCh2LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQucHJvdG90eXBlKSkud3JpdGVCeXRlPWZ1bmN0aW9uKGUpe2lmKGU8MHx8MjU1PGUpdGhyb3cgbmV3IEVycm9yKFwiQnl0ZSB2YWx1ZSBvdXQgb2YgcmFuZ2U6IFwiK2UpO3ZhciB0PWUudG9TdHJpbmcoMTYpOzE9PXQubGVuZ3RoJiYodD1cIjBcIit0KSx0aGlzLiRoZXgrPXR9LHYucHJvdG90eXBlLmNhbldyaXRlQmluYXJ5PWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2Ygb3x8XCJmdW5jdGlvblwiPT10eXBlb2YgYiYmZSBpbnN0YW5jZW9mIGJ9LHYucHJvdG90eXBlLndyaXRlQmluYXJ5PWZ1bmN0aW9uKGUsdCl7aWYoZSBpbnN0YW5jZW9mIG8pdChlLmxlbmd0aCgpKSx0aGlzLiRoZXgrPWUuJGhleDtlbHNle2lmKCEoXCJmdW5jdGlvblwiPT10eXBlb2YgYiYmZSBpbnN0YW5jZW9mIGIpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJIZXhXcml0ZXIgb25seSBhY2NlcHRzIEJpbmFyeUhleCBvciBCdWZmZXJzXCIpO3QoZS5sZW5ndGgpLHRoaXMuJGhleCs9ZS50b1N0cmluZyhcImhleFwiKX19LHYucHJvdG90eXBlLnJlc3VsdD1mdW5jdGlvbigpe3JldHVyblwiYnVmZmVyXCI9PT10aGlzLmZpbmFsRm9ybWF0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBiP2IuZnJvbSh0aGlzLiRoZXgsXCJoZXhcIik6bmV3IG8odGhpcy4kaGV4KS50b1N0cmluZyh0aGlzLmZpbmFsRm9ybWF0KX0sdi5wcm90b3R5cGUud3JpdGVTdHJpbmc9ZnVuY3Rpb24oZSx0KXt2YXIgbj1vLmZyb21VdGY4U3RyaW5nKGUpO3Qobi5sZW5ndGgoKSksdGhpcy4kaGV4Kz1uLiRoZXh9LGcuYWRkUmVhZGVyKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUgaW5zdGFuY2VvZiBvfHxlLiRoZXg/bmV3IHkoZS4kaGV4KTpcImhleFwiPT09dD9uZXcgeShlKTp2b2lkIDB9KSxnLmFkZFdyaXRlcihmdW5jdGlvbihlKXtpZihcImhleFwiPT09ZSlyZXR1cm4gbmV3IHZ9KSxnfSgpO3JldHVybiBlLmFkZFNlbWFudGljRW5jb2RlKDAsZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIERhdGUpcmV0dXJuIGUudG9JU09TdHJpbmcoKX0pLmFkZFNlbWFudGljRGVjb2RlKDAsZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBEYXRlKGUpfSkuYWRkU2VtYW50aWNEZWNvZGUoMSxmdW5jdGlvbihlKXtyZXR1cm4gbmV3IERhdGUoZSl9KSxlfSk/ZS5hcHBseShpLHQpOmUpfHwoci5leHBvcnRzPW4pfSkuY2FsbCh0aGlzLGUoOSkuQnVmZmVyKX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0PWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1vLmRlZmF1bHQuZ2V0KHRoaXMuZ2V0U3RhbmRhcmRPcmlnaW4oKSt0LnVybCkuc2V0KHQuaGVhZGVycykucXVlcnkoZSk7cmV0dXJuIHMuY2FsbCh0aGlzLHIsdCxuKX0sdC5wb3N0PWZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBpPW8uZGVmYXVsdC5wb3N0KHRoaXMuZ2V0U3RhbmRhcmRPcmlnaW4oKStuLnVybCkucXVlcnkoZSkuc2V0KG4uaGVhZGVycykuc2VuZCh0KTtyZXR1cm4gcy5jYWxsKHRoaXMsaSxuLHIpfSx0LnBhdGNoPWZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBpPW8uZGVmYXVsdC5wYXRjaCh0aGlzLmdldFN0YW5kYXJkT3JpZ2luKCkrbi51cmwpLnF1ZXJ5KGUpLnNldChuLmhlYWRlcnMpLnNlbmQodCk7cmV0dXJuIHMuY2FsbCh0aGlzLGksbixyKX0sdC5kZWw9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPW8uZGVmYXVsdC5kZWxldGUodGhpcy5nZXRTdGFuZGFyZE9yaWdpbigpK3QudXJsKS5zZXQodC5oZWFkZXJzKS5xdWVyeShlKTtyZXR1cm4gcy5jYWxsKHRoaXMscix0LG4pfTt2YXIgcixvPShyPW4oNzYpKSYmci5fX2VzTW9kdWxlP3I6e2RlZmF1bHQ6cn07bigwKTtmdW5jdGlvbiBhKHIpe3ZhciBpPShuZXcgRGF0ZSkuZ2V0VGltZSgpLGU9KG5ldyBEYXRlKS50b0lTT1N0cmluZygpLG89Y29uc29sZSYmY29uc29sZS5sb2c/Y29uc29sZTp3aW5kb3cmJndpbmRvdy5jb25zb2xlJiZ3aW5kb3cuY29uc29sZS5sb2c/d2luZG93LmNvbnNvbGU6Y29uc29sZTtvLmxvZyhcIjw8PDw8XCIpLG8ubG9nKFwiW1wiLmNvbmNhdChlLFwiXVwiKSxcIlxcblwiLHIudXJsLFwiXFxuXCIsci5xcyksby5sb2coXCItLS0tLVwiKSxyLm9uKFwicmVzcG9uc2VcIixmdW5jdGlvbihlKXt2YXIgdD0obmV3IERhdGUpLmdldFRpbWUoKS1pLG49KG5ldyBEYXRlKS50b0lTT1N0cmluZygpO28ubG9nKFwiPj4+Pj4+XCIpLG8ubG9nKFwiW1wiLmNvbmNhdChuLFwiIC8gXCIpLmNvbmNhdCh0LFwiXVwiKSxcIlxcblwiLHIudXJsLFwiXFxuXCIsci5xcyxcIlxcblwiLGUudGV4dCksby5sb2coXCItLS0tLVwiKX0pfWZ1bmN0aW9uIHMoZSxpLG8pe3ZhciBzPXRoaXM7cmV0dXJuIHRoaXMuX2NvbmZpZy5sb2dWZXJib3NpdHkmJihlPWUudXNlKGEpKSx0aGlzLl9jb25maWcucHJveHkmJnRoaXMuX21vZHVsZXMucHJveHkmJihlPXRoaXMuX21vZHVsZXMucHJveHkuY2FsbCh0aGlzLGUpKSx0aGlzLl9jb25maWcua2VlcEFsaXZlJiZ0aGlzLl9tb2R1bGVzLmtlZXBBbGl2ZSYmKGU9dGhpcy5fbW9kdWxlcy5rZWVwQWxpdmUoZSkpLGUudGltZW91dChpLnRpbWVvdXQpLmVuZChmdW5jdGlvbih0LG4pe3ZhciBlLHI9e307aWYoci5lcnJvcj1udWxsIT09dCxyLm9wZXJhdGlvbj1pLm9wZXJhdGlvbixuJiZuLnN0YXR1cyYmKHIuc3RhdHVzQ29kZT1uLnN0YXR1cyksdCl7aWYodC5yZXNwb25zZSYmdC5yZXNwb25zZS50ZXh0JiYhcy5fY29uZmlnLmxvZ1ZlcmJvc2l0eSl0cnl7ci5lcnJvckRhdGE9SlNPTi5wYXJzZSh0LnJlc3BvbnNlLnRleHQpfWNhdGNoKGUpe3IuZXJyb3JEYXRhPXR9ZWxzZSByLmVycm9yRGF0YT10O3JldHVybiByLmNhdGVnb3J5PXMuX2RldGVjdEVycm9yQ2F0ZWdvcnkodCksbyhyLG51bGwpfXRyeXtlPUpTT04ucGFyc2Uobi50ZXh0KX1jYXRjaChlKXtyZXR1cm4gci5lcnJvckRhdGE9bixyLmVycm9yPSEwLG8ocixudWxsKX1yZXR1cm4gZS5lcnJvciYmMT09PWUuZXJyb3ImJmUuc3RhdHVzJiZlLm1lc3NhZ2UmJmUuc2VydmljZT8oci5lcnJvckRhdGE9ZSxyLnN0YXR1c0NvZGU9ZS5zdGF0dXMsci5lcnJvcj0hMCxyLmNhdGVnb3J5PXMuX2RldGVjdEVycm9yQ2F0ZWdvcnkociksbyhyLG51bGwpKTooZS5lcnJvciYmZS5lcnJvci5tZXNzYWdlJiYoci5lcnJvckRhdGE9ZS5lcnJvciksbyhyLGUpKX0pfX0sZnVuY3Rpb24oZSxuLHQpe3ZhciByO3I9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjooY29uc29sZS53YXJuKFwiVXNpbmcgYnJvd3Nlci1vbmx5IHZlcnNpb24gb2Ygc3VwZXJhZ2VudCBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKSx0aGlzKTt2YXIgaT10KDc3KSxvPXQoNzgpLHM9dCgxMCksYT10KDc5KSx1PXQoODEpO2Z1bmN0aW9uIGMoKXt9dmFyIGY9bj1lLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0P25ldyBuLlJlcXVlc3QoXCJHRVRcIixlKS5lbmQodCk6MT09YXJndW1lbnRzLmxlbmd0aD9uZXcgbi5SZXF1ZXN0KFwiR0VUXCIsZSk6bmV3IG4uUmVxdWVzdChlLHQpfTtuLlJlcXVlc3Q9dixmLmdldFhIUj1mdW5jdGlvbigpe2lmKCEoIXIuWE1MSHR0cFJlcXVlc3R8fHIubG9jYXRpb24mJlwiZmlsZTpcIj09ci5sb2NhdGlvbi5wcm90b2NvbCYmci5BY3RpdmVYT2JqZWN0KSlyZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0O3RyeXtyZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKX1jYXRjaChlKXt9dHJ5e3JldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1zeG1sMi5YTUxIVFRQLjYuMFwiKX1jYXRjaChlKXt9dHJ5e3JldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1zeG1sMi5YTUxIVFRQLjMuMFwiKX1jYXRjaChlKXt9dHJ5e3JldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1zeG1sMi5YTUxIVFRQXCIpfWNhdGNoKGUpe310aHJvdyBFcnJvcihcIkJyb3dzZXItb25seSB2ZXJzaW9uIG9mIHN1cGVyYWdlbnQgY291bGQgbm90IGZpbmQgWEhSXCIpfTt2YXIgbD1cIlwiLnRyaW0/ZnVuY3Rpb24oZSl7cmV0dXJuIGUudHJpbSgpfTpmdW5jdGlvbihlKXtyZXR1cm4gZS5yZXBsYWNlKC8oXlxccyp8XFxzKiQpL2csXCJcIil9O2Z1bmN0aW9uIGgoZSl7aWYoIXMoZSkpcmV0dXJuIGU7dmFyIHQ9W107Zm9yKHZhciBuIGluIGUpcCh0LG4sZVtuXSk7cmV0dXJuIHQuam9pbihcIiZcIil9ZnVuY3Rpb24gcCh0LG4sZSl7aWYobnVsbCE9ZSlpZihBcnJheS5pc0FycmF5KGUpKWUuZm9yRWFjaChmdW5jdGlvbihlKXtwKHQsbixlKX0pO2Vsc2UgaWYocyhlKSlmb3IodmFyIHIgaW4gZSlwKHQsbitcIltcIityK1wiXVwiLGVbcl0pO2Vsc2UgdC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChuKStcIj1cIitlbmNvZGVVUklDb21wb25lbnQoZSkpO2Vsc2UgbnVsbD09PWUmJnQucHVzaChlbmNvZGVVUklDb21wb25lbnQobikpfWZ1bmN0aW9uIGQoZSl7Zm9yKHZhciB0LG4scj17fSxpPWUuc3BsaXQoXCImXCIpLG89MCxzPWkubGVuZ3RoO288czsrK28pLTE9PShuPSh0PWlbb10pLmluZGV4T2YoXCI9XCIpKT9yW2RlY29kZVVSSUNvbXBvbmVudCh0KV09XCJcIjpyW2RlY29kZVVSSUNvbXBvbmVudCh0LnNsaWNlKDAsbikpXT1kZWNvZGVVUklDb21wb25lbnQodC5zbGljZShuKzEpKTtyZXR1cm4gcn1mdW5jdGlvbiBnKGUpe3JldHVybi9bXFwvK11qc29uKCR8W14tXFx3XSkvLnRlc3QoZSl9ZnVuY3Rpb24geShlKXt0aGlzLnJlcT1lLHRoaXMueGhyPXRoaXMucmVxLnhocix0aGlzLnRleHQ9XCJIRUFEXCIhPXRoaXMucmVxLm1ldGhvZCYmKFwiXCI9PT10aGlzLnhoci5yZXNwb25zZVR5cGV8fFwidGV4dFwiPT09dGhpcy54aHIucmVzcG9uc2VUeXBlKXx8dm9pZCAwPT09dGhpcy54aHIucmVzcG9uc2VUeXBlP3RoaXMueGhyLnJlc3BvbnNlVGV4dDpudWxsLHRoaXMuc3RhdHVzVGV4dD10aGlzLnJlcS54aHIuc3RhdHVzVGV4dDt2YXIgdD10aGlzLnhoci5zdGF0dXM7MTIyMz09PXQmJih0PTIwNCksdGhpcy5fc2V0U3RhdHVzUHJvcGVydGllcyh0KSx0aGlzLmhlYWRlcj10aGlzLmhlYWRlcnM9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0LG4scixpLG89ZS5zcGxpdCgvXFxyP1xcbi8pLHM9e30sYT0wLHU9by5sZW5ndGg7YTx1OysrYSktMSE9PSh0PShuPW9bYV0pLmluZGV4T2YoXCI6XCIpKSYmKHI9bi5zbGljZSgwLHQpLnRvTG93ZXJDYXNlKCksaT1sKG4uc2xpY2UodCsxKSksc1tyXT1pKTtyZXR1cm4gc30odGhpcy54aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpLHRoaXMuaGVhZGVyW1wiY29udGVudC10eXBlXCJdPXRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiY29udGVudC10eXBlXCIpLHRoaXMuX3NldEhlYWRlclByb3BlcnRpZXModGhpcy5oZWFkZXIpLG51bGw9PT10aGlzLnRleHQmJmUuX3Jlc3BvbnNlVHlwZT90aGlzLmJvZHk9dGhpcy54aHIucmVzcG9uc2U6dGhpcy5ib2R5PVwiSEVBRFwiIT10aGlzLnJlcS5tZXRob2Q/dGhpcy5fcGFyc2VCb2R5KHRoaXMudGV4dD90aGlzLnRleHQ6dGhpcy54aHIucmVzcG9uc2UpOm51bGx9ZnVuY3Rpb24gdihlLHQpe3ZhciByPXRoaXM7dGhpcy5fcXVlcnk9dGhpcy5fcXVlcnl8fFtdLHRoaXMubWV0aG9kPWUsdGhpcy51cmw9dCx0aGlzLmhlYWRlcj17fSx0aGlzLl9oZWFkZXI9e30sdGhpcy5vbihcImVuZFwiLGZ1bmN0aW9uKCl7dmFyIHQsbj1udWxsLGU9bnVsbDt0cnl7ZT1uZXcgeShyKX1jYXRjaChlKXtyZXR1cm4obj1uZXcgRXJyb3IoXCJQYXJzZXIgaXMgdW5hYmxlIHRvIHBhcnNlIHRoZSByZXNwb25zZVwiKSkucGFyc2U9ITAsbi5vcmlnaW5hbD1lLHIueGhyPyhuLnJhd1Jlc3BvbnNlPXZvaWQgMD09PXIueGhyLnJlc3BvbnNlVHlwZT9yLnhoci5yZXNwb25zZVRleHQ6ci54aHIucmVzcG9uc2Usbi5zdGF0dXM9ci54aHIuc3RhdHVzP3IueGhyLnN0YXR1czpudWxsLG4uc3RhdHVzQ29kZT1uLnN0YXR1cyk6KG4ucmF3UmVzcG9uc2U9bnVsbCxuLnN0YXR1cz1udWxsKSxyLmNhbGxiYWNrKG4pfXIuZW1pdChcInJlc3BvbnNlXCIsZSk7dHJ5e3IuX2lzUmVzcG9uc2VPSyhlKXx8KHQ9bmV3IEVycm9yKGUuc3RhdHVzVGV4dHx8XCJVbnN1Y2Nlc3NmdWwgSFRUUCByZXNwb25zZVwiKSl9Y2F0Y2goZSl7dD1lfXQ/KHQub3JpZ2luYWw9bix0LnJlc3BvbnNlPWUsdC5zdGF0dXM9ZS5zdGF0dXMsci5jYWxsYmFjayh0LGUpKTpyLmNhbGxiYWNrKG51bGwsZSl9KX1mdW5jdGlvbiBiKGUsdCxuKXt2YXIgcj1mKFwiREVMRVRFXCIsZSk7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdCYmKG49dCx0PW51bGwpLHQmJnIuc2VuZCh0KSxuJiZyLmVuZChuKSxyfWYuc2VyaWFsaXplT2JqZWN0PWgsZi5wYXJzZVN0cmluZz1kLGYudHlwZXM9e2h0bWw6XCJ0ZXh0L2h0bWxcIixqc29uOlwiYXBwbGljYXRpb24vanNvblwiLHhtbDpcInRleHQveG1sXCIsdXJsZW5jb2RlZDpcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLGZvcm06XCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIixcImZvcm0tZGF0YVwiOlwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJ9LGYuc2VyaWFsaXplPXtcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiOmgsXCJhcHBsaWNhdGlvbi9qc29uXCI6SlNPTi5zdHJpbmdpZnl9LGYucGFyc2U9e1wiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI6ZCxcImFwcGxpY2F0aW9uL2pzb25cIjpKU09OLnBhcnNlfSxhKHkucHJvdG90eXBlKSx5LnByb3RvdHlwZS5fcGFyc2VCb2R5PWZ1bmN0aW9uKGUpe3ZhciB0PWYucGFyc2VbdGhpcy50eXBlXTtyZXR1cm4gdGhpcy5yZXEuX3BhcnNlcj90aGlzLnJlcS5fcGFyc2VyKHRoaXMsZSk6KCF0JiZnKHRoaXMudHlwZSkmJih0PWYucGFyc2VbXCJhcHBsaWNhdGlvbi9qc29uXCJdKSx0JiZlJiYoZS5sZW5ndGh8fGUgaW5zdGFuY2VvZiBPYmplY3QpP3QoZSk6bnVsbCl9LHkucHJvdG90eXBlLnRvRXJyb3I9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnJlcSx0PWUubWV0aG9kLG49ZS51cmwscj1cImNhbm5vdCBcIit0K1wiIFwiK24rXCIgKFwiK3RoaXMuc3RhdHVzK1wiKVwiLGk9bmV3IEVycm9yKHIpO3JldHVybiBpLnN0YXR1cz10aGlzLnN0YXR1cyxpLm1ldGhvZD10LGkudXJsPW4saX0sZi5SZXNwb25zZT15LGkodi5wcm90b3R5cGUpLG8odi5wcm90b3R5cGUpLHYucHJvdG90eXBlLnR5cGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuc2V0KFwiQ29udGVudC1UeXBlXCIsZi50eXBlc1tlXXx8ZSksdGhpc30sdi5wcm90b3R5cGUuYWNjZXB0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnNldChcIkFjY2VwdFwiLGYudHlwZXNbZV18fGUpLHRoaXN9LHYucHJvdG90eXBlLmF1dGg9ZnVuY3Rpb24oZSx0LG4pezE9PT1hcmd1bWVudHMubGVuZ3RoJiYodD1cIlwiKSxcIm9iamVjdFwiPT10eXBlb2YgdCYmbnVsbCE9PXQmJihuPXQsdD1cIlwiKSxuPW58fHt0eXBlOlwiZnVuY3Rpb25cIj09dHlwZW9mIGJ0b2E/XCJiYXNpY1wiOlwiYXV0b1wifTtyZXR1cm4gdGhpcy5fYXV0aChlLHQsbixmdW5jdGlvbihlKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBidG9hKXJldHVybiBidG9hKGUpO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgYmFzaWMgYXV0aCwgYnRvYSBpcyBub3QgYSBmdW5jdGlvblwiKX0pfSx2LnByb3RvdHlwZS5xdWVyeT1mdW5jdGlvbihlKXtyZXR1cm5cInN0cmluZ1wiIT10eXBlb2YgZSYmKGU9aChlKSksZSYmdGhpcy5fcXVlcnkucHVzaChlKSx0aGlzfSx2LnByb3RvdHlwZS5hdHRhY2g9ZnVuY3Rpb24oZSx0LG4pe2lmKHQpe2lmKHRoaXMuX2RhdGEpdGhyb3cgRXJyb3IoXCJzdXBlcmFnZW50IGNhbid0IG1peCAuc2VuZCgpIGFuZCAuYXR0YWNoKClcIik7dGhpcy5fZ2V0Rm9ybURhdGEoKS5hcHBlbmQoZSx0LG58fHQubmFtZSl9cmV0dXJuIHRoaXN9LHYucHJvdG90eXBlLl9nZXRGb3JtRGF0YT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9mb3JtRGF0YXx8KHRoaXMuX2Zvcm1EYXRhPW5ldyByLkZvcm1EYXRhKSx0aGlzLl9mb3JtRGF0YX0sdi5wcm90b3R5cGUuY2FsbGJhY2s9ZnVuY3Rpb24oZSx0KXtpZih0aGlzLl9zaG91bGRSZXRyeShlLHQpKXJldHVybiB0aGlzLl9yZXRyeSgpO3ZhciBuPXRoaXMuX2NhbGxiYWNrO3RoaXMuY2xlYXJUaW1lb3V0KCksZSYmKHRoaXMuX21heFJldHJpZXMmJihlLnJldHJpZXM9dGhpcy5fcmV0cmllcy0xKSx0aGlzLmVtaXQoXCJlcnJvclwiLGUpKSxuKGUsdCl9LHYucHJvdG90eXBlLmNyb3NzRG9tYWluRXJyb3I9ZnVuY3Rpb24oKXt2YXIgZT1uZXcgRXJyb3IoXCJSZXF1ZXN0IGhhcyBiZWVuIHRlcm1pbmF0ZWRcXG5Qb3NzaWJsZSBjYXVzZXM6IHRoZSBuZXR3b3JrIGlzIG9mZmxpbmUsIE9yaWdpbiBpcyBub3QgYWxsb3dlZCBieSBBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4sIHRoZSBwYWdlIGlzIGJlaW5nIHVubG9hZGVkLCBldGMuXCIpO2UuY3Jvc3NEb21haW49ITAsZS5zdGF0dXM9dGhpcy5zdGF0dXMsZS5tZXRob2Q9dGhpcy5tZXRob2QsZS51cmw9dGhpcy51cmwsdGhpcy5jYWxsYmFjayhlKX0sdi5wcm90b3R5cGUuYnVmZmVyPXYucHJvdG90eXBlLmNhPXYucHJvdG90eXBlLmFnZW50PWZ1bmN0aW9uKCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlRoaXMgaXMgbm90IHN1cHBvcnRlZCBpbiBicm93c2VyIHZlcnNpb24gb2Ygc3VwZXJhZ2VudFwiKSx0aGlzfSx2LnByb3RvdHlwZS5waXBlPXYucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKCl7dGhyb3cgRXJyb3IoXCJTdHJlYW1pbmcgaXMgbm90IHN1cHBvcnRlZCBpbiBicm93c2VyIHZlcnNpb24gb2Ygc3VwZXJhZ2VudFwiKX0sdi5wcm90b3R5cGUuX2lzSG9zdD1mdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJvYmplY3RcIj09dHlwZW9mIGUmJiFBcnJheS5pc0FycmF5KGUpJiZcIltvYmplY3QgT2JqZWN0XVwiIT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpfSx2LnByb3RvdHlwZS5lbmQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX2VuZENhbGxlZCYmY29uc29sZS53YXJuKFwiV2FybmluZzogLmVuZCgpIHdhcyBjYWxsZWQgdHdpY2UuIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBpbiBzdXBlcmFnZW50XCIpLHRoaXMuX2VuZENhbGxlZD0hMCx0aGlzLl9jYWxsYmFjaz1lfHxjLHRoaXMuX2ZpbmFsaXplUXVlcnlTdHJpbmcoKSx0aGlzLl9lbmQoKX0sdi5wcm90b3R5cGUuX2VuZD1mdW5jdGlvbigpe3ZhciBuPXRoaXMscj10aGlzLnhocj1mLmdldFhIUigpLGU9dGhpcy5fZm9ybURhdGF8fHRoaXMuX2RhdGE7dGhpcy5fc2V0VGltZW91dHMoKSxyLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe3ZhciBlPXIucmVhZHlTdGF0ZTtpZigyPD1lJiZuLl9yZXNwb25zZVRpbWVvdXRUaW1lciYmY2xlYXJUaW1lb3V0KG4uX3Jlc3BvbnNlVGltZW91dFRpbWVyKSw0PT1lKXt2YXIgdDt0cnl7dD1yLnN0YXR1c31jYXRjaChlKXt0PTB9aWYoIXQpe2lmKG4udGltZWRvdXR8fG4uX2Fib3J0ZWQpcmV0dXJuO3JldHVybiBuLmNyb3NzRG9tYWluRXJyb3IoKX1uLmVtaXQoXCJlbmRcIil9fTtmdW5jdGlvbiB0KGUsdCl7MDx0LnRvdGFsJiYodC5wZXJjZW50PXQubG9hZGVkL3QudG90YWwqMTAwKSx0LmRpcmVjdGlvbj1lLG4uZW1pdChcInByb2dyZXNzXCIsdCl9aWYodGhpcy5oYXNMaXN0ZW5lcnMoXCJwcm9ncmVzc1wiKSl0cnl7ci5vbnByb2dyZXNzPXQuYmluZChudWxsLFwiZG93bmxvYWRcIiksci51cGxvYWQmJihyLnVwbG9hZC5vbnByb2dyZXNzPXQuYmluZChudWxsLFwidXBsb2FkXCIpKX1jYXRjaChlKXt9dHJ5e3RoaXMudXNlcm5hbWUmJnRoaXMucGFzc3dvcmQ/ci5vcGVuKHRoaXMubWV0aG9kLHRoaXMudXJsLCEwLHRoaXMudXNlcm5hbWUsdGhpcy5wYXNzd29yZCk6ci5vcGVuKHRoaXMubWV0aG9kLHRoaXMudXJsLCEwKX1jYXRjaChlKXtyZXR1cm4gdGhpcy5jYWxsYmFjayhlKX1pZih0aGlzLl93aXRoQ3JlZGVudGlhbHMmJihyLndpdGhDcmVkZW50aWFscz0hMCksIXRoaXMuX2Zvcm1EYXRhJiZcIkdFVFwiIT10aGlzLm1ldGhvZCYmXCJIRUFEXCIhPXRoaXMubWV0aG9kJiZcInN0cmluZ1wiIT10eXBlb2YgZSYmIXRoaXMuX2lzSG9zdChlKSl7dmFyIGk9dGhpcy5faGVhZGVyW1wiY29udGVudC10eXBlXCJdLG89dGhpcy5fc2VyaWFsaXplcnx8Zi5zZXJpYWxpemVbaT9pLnNwbGl0KFwiO1wiKVswXTpcIlwiXTshbyYmZyhpKSYmKG89Zi5zZXJpYWxpemVbXCJhcHBsaWNhdGlvbi9qc29uXCJdKSxvJiYoZT1vKGUpKX1mb3IodmFyIHMgaW4gdGhpcy5oZWFkZXIpbnVsbCE9dGhpcy5oZWFkZXJbc10mJnRoaXMuaGVhZGVyLmhhc093blByb3BlcnR5KHMpJiZyLnNldFJlcXVlc3RIZWFkZXIocyx0aGlzLmhlYWRlcltzXSk7cmV0dXJuIHRoaXMuX3Jlc3BvbnNlVHlwZSYmKHIucmVzcG9uc2VUeXBlPXRoaXMuX3Jlc3BvbnNlVHlwZSksdGhpcy5lbWl0KFwicmVxdWVzdFwiLHRoaXMpLHIuc2VuZCh2b2lkIDAhPT1lP2U6bnVsbCksdGhpc30sZi5hZ2VudD1mdW5jdGlvbigpe3JldHVybiBuZXcgdX0sW1wiR0VUXCIsXCJQT1NUXCIsXCJPUFRJT05TXCIsXCJQQVRDSFwiLFwiUFVUXCIsXCJERUxFVEVcIl0uZm9yRWFjaChmdW5jdGlvbihyKXt1LnByb3RvdHlwZVtyLnRvTG93ZXJDYXNlKCldPWZ1bmN0aW9uKGUsdCl7dmFyIG49bmV3IGYuUmVxdWVzdChyLGUpO3JldHVybiB0aGlzLl9zZXREZWZhdWx0cyhuKSx0JiZuLmVuZCh0KSxufX0pLHUucHJvdG90eXBlLmRlbD11LnByb3RvdHlwZS5kZWxldGUsZi5nZXQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPWYoXCJHRVRcIixlKTtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0JiYobj10LHQ9bnVsbCksdCYmci5xdWVyeSh0KSxuJiZyLmVuZChuKSxyfSxmLmhlYWQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPWYoXCJIRUFEXCIsZSk7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdCYmKG49dCx0PW51bGwpLHQmJnIucXVlcnkodCksbiYmci5lbmQobikscn0sZi5vcHRpb25zPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1mKFwiT1BUSU9OU1wiLGUpO3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHQmJihuPXQsdD1udWxsKSx0JiZyLnNlbmQodCksbiYmci5lbmQobikscn0sZi5kZWw9YixmLmRlbGV0ZT1iLGYucGF0Y2g9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPWYoXCJQQVRDSFwiLGUpO3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHQmJihuPXQsdD1udWxsKSx0JiZyLnNlbmQodCksbiYmci5lbmQobikscn0sZi5wb3N0PWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1mKFwiUE9TVFwiLGUpO3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHQmJihuPXQsdD1udWxsKSx0JiZyLnNlbmQodCksbiYmci5lbmQobikscn0sZi5wdXQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPWYoXCJQVVRcIixlKTtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0JiYobj10LHQ9bnVsbCksdCYmci5zZW5kKHQpLG4mJnIuZW5kKG4pLHJ9fSxmdW5jdGlvbihlLHQsbil7ZnVuY3Rpb24gcihlKXtpZihlKXJldHVybiBmdW5jdGlvbihlKXtmb3IodmFyIHQgaW4gci5wcm90b3R5cGUpZVt0XT1yLnByb3RvdHlwZVt0XTtyZXR1cm4gZX0oZSl9KGUuZXhwb3J0cz1yKS5wcm90b3R5cGUub249ci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLl9jYWxsYmFja3M9dGhpcy5fY2FsbGJhY2tzfHx7fSwodGhpcy5fY2FsbGJhY2tzW1wiJFwiK2VdPXRoaXMuX2NhbGxiYWNrc1tcIiRcIitlXXx8W10pLnB1c2godCksdGhpc30sci5wcm90b3R5cGUub25jZT1mdW5jdGlvbihlLHQpe2Z1bmN0aW9uIG4oKXt0aGlzLm9mZihlLG4pLHQuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBuLmZuPXQsdGhpcy5vbihlLG4pLHRoaXN9LHIucHJvdG90eXBlLm9mZj1yLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcj1yLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnM9ci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihlLHQpe2lmKHRoaXMuX2NhbGxiYWNrcz10aGlzLl9jYWxsYmFja3N8fHt9LDA9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuX2NhbGxiYWNrcz17fSx0aGlzO3ZhciBuLHI9dGhpcy5fY2FsbGJhY2tzW1wiJFwiK2VdO2lmKCFyKXJldHVybiB0aGlzO2lmKDE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbXCIkXCIrZV0sdGhpcztmb3IodmFyIGk9MDtpPHIubGVuZ3RoO2krKylpZigobj1yW2ldKT09PXR8fG4uZm49PT10KXtyLnNwbGljZShpLDEpO2JyZWFrfXJldHVybiAwPT09ci5sZW5ndGgmJmRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbXCIkXCIrZV0sdGhpc30sci5wcm90b3R5cGUuZW1pdD1mdW5jdGlvbihlKXt0aGlzLl9jYWxsYmFja3M9dGhpcy5fY2FsbGJhY2tzfHx7fTtmb3IodmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSksbj10aGlzLl9jYWxsYmFja3NbXCIkXCIrZV0scj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspdFtyLTFdPWFyZ3VtZW50c1tyXTtpZihuKXtyPTA7Zm9yKHZhciBpPShuPW4uc2xpY2UoMCkpLmxlbmd0aDtyPGk7KytyKW5bcl0uYXBwbHkodGhpcyx0KX1yZXR1cm4gdGhpc30sci5wcm90b3R5cGUubGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9jYWxsYmFja3M9dGhpcy5fY2FsbGJhY2tzfHx7fSx0aGlzLl9jYWxsYmFja3NbXCIkXCIrZV18fFtdfSxyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuISF0aGlzLmxpc3RlbmVycyhlKS5sZW5ndGh9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9bigxMCk7ZnVuY3Rpb24gcihlKXtpZihlKXJldHVybiBmdW5jdGlvbihlKXtmb3IodmFyIHQgaW4gci5wcm90b3R5cGUpZVt0XT1yLnByb3RvdHlwZVt0XTtyZXR1cm4gZX0oZSl9KGUuZXhwb3J0cz1yKS5wcm90b3R5cGUuY2xlYXJUaW1lb3V0PWZ1bmN0aW9uKCl7cmV0dXJuIGNsZWFyVGltZW91dCh0aGlzLl90aW1lciksY2xlYXJUaW1lb3V0KHRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyKSxkZWxldGUgdGhpcy5fdGltZXIsZGVsZXRlIHRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyLHRoaXN9LHIucHJvdG90eXBlLnBhcnNlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9wYXJzZXI9ZSx0aGlzfSxyLnByb3RvdHlwZS5yZXNwb25zZVR5cGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX3Jlc3BvbnNlVHlwZT1lLHRoaXN9LHIucHJvdG90eXBlLnNlcmlhbGl6ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fc2VyaWFsaXplcj1lLHRoaXN9LHIucHJvdG90eXBlLnRpbWVvdXQ9ZnVuY3Rpb24oZSl7aWYoIWV8fFwib2JqZWN0XCIhPXR5cGVvZiBlKXJldHVybiB0aGlzLl90aW1lb3V0PWUsdGhpcy5fcmVzcG9uc2VUaW1lb3V0PTAsdGhpcztmb3IodmFyIHQgaW4gZSlzd2l0Y2godCl7Y2FzZVwiZGVhZGxpbmVcIjp0aGlzLl90aW1lb3V0PWUuZGVhZGxpbmU7YnJlYWs7Y2FzZVwicmVzcG9uc2VcIjp0aGlzLl9yZXNwb25zZVRpbWVvdXQ9ZS5yZXNwb25zZTticmVhaztkZWZhdWx0OmNvbnNvbGUud2FybihcIlVua25vd24gdGltZW91dCBvcHRpb25cIix0KX1yZXR1cm4gdGhpc30sci5wcm90b3R5cGUucmV0cnk9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMCE9PWFyZ3VtZW50cy5sZW5ndGgmJiEwIT09ZXx8KGU9MSksZTw9MCYmKGU9MCksdGhpcy5fbWF4UmV0cmllcz1lLHRoaXMuX3JldHJpZXM9MCx0aGlzLl9yZXRyeUNhbGxiYWNrPXQsdGhpc307dmFyIG89W1wiRUNPTk5SRVNFVFwiLFwiRVRJTUVET1VUXCIsXCJFQUREUklORk9cIixcIkVTT0NLRVRUSU1FRE9VVFwiXTtyLnByb3RvdHlwZS5fc2hvdWxkUmV0cnk9ZnVuY3Rpb24oZSx0KXtpZighdGhpcy5fbWF4UmV0cmllc3x8dGhpcy5fcmV0cmllcysrPj10aGlzLl9tYXhSZXRyaWVzKXJldHVybiExO2lmKHRoaXMuX3JldHJ5Q2FsbGJhY2spdHJ5e3ZhciBuPXRoaXMuX3JldHJ5Q2FsbGJhY2soZSx0KTtpZighMD09PW4pcmV0dXJuITA7aWYoITE9PT1uKXJldHVybiExfWNhdGNoKGUpe2NvbnNvbGUuZXJyb3IoZSl9aWYodCYmdC5zdGF0dXMmJjUwMDw9dC5zdGF0dXMmJjUwMSE9dC5zdGF0dXMpcmV0dXJuITA7aWYoZSl7aWYoZS5jb2RlJiZ+by5pbmRleE9mKGUuY29kZSkpcmV0dXJuITA7aWYoZS50aW1lb3V0JiZcIkVDT05OQUJPUlRFRFwiPT1lLmNvZGUpcmV0dXJuITA7aWYoZS5jcm9zc0RvbWFpbilyZXR1cm4hMH1yZXR1cm4hMX0sci5wcm90b3R5cGUuX3JldHJ5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2xlYXJUaW1lb3V0KCksdGhpcy5yZXEmJih0aGlzLnJlcT1udWxsLHRoaXMucmVxPXRoaXMucmVxdWVzdCgpKSx0aGlzLl9hYm9ydGVkPSExLHRoaXMudGltZWRvdXQ9ITEsdGhpcy5fZW5kKCl9LHIucHJvdG90eXBlLnRoZW49ZnVuY3Rpb24oZSx0KXtpZighdGhpcy5fZnVsbGZpbGxlZFByb21pc2Upe3ZhciBpPXRoaXM7dGhpcy5fZW5kQ2FsbGVkJiZjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBzdXBlcmFnZW50IHJlcXVlc3Qgd2FzIHNlbnQgdHdpY2UsIGJlY2F1c2UgYm90aCAuZW5kKCkgYW5kIC50aGVuKCkgd2VyZSBjYWxsZWQuIE5ldmVyIGNhbGwgLmVuZCgpIGlmIHlvdSB1c2UgcHJvbWlzZXNcIiksdGhpcy5fZnVsbGZpbGxlZFByb21pc2U9bmV3IFByb21pc2UoZnVuY3Rpb24obixyKXtpLmVuZChmdW5jdGlvbihlLHQpe2U/cihlKTpuKHQpfSl9KX1yZXR1cm4gdGhpcy5fZnVsbGZpbGxlZFByb21pc2UudGhlbihlLHQpfSxyLnByb3RvdHlwZS5jYXRjaD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aGVuKHZvaWQgMCxlKX0sci5wcm90b3R5cGUudXNlPWZ1bmN0aW9uKGUpe3JldHVybiBlKHRoaXMpLHRoaXN9LHIucHJvdG90eXBlLm9rPWZ1bmN0aW9uKGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpdGhyb3cgRXJyb3IoXCJDYWxsYmFjayByZXF1aXJlZFwiKTtyZXR1cm4gdGhpcy5fb2tDYWxsYmFjaz1lLHRoaXN9LHIucHJvdG90eXBlLl9pc1Jlc3BvbnNlT0s9ZnVuY3Rpb24oZSl7cmV0dXJuISFlJiYodGhpcy5fb2tDYWxsYmFjaz90aGlzLl9va0NhbGxiYWNrKGUpOjIwMDw9ZS5zdGF0dXMmJmUuc3RhdHVzPDMwMCl9LHIucHJvdG90eXBlLmdldEhlYWRlcj1yLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX2hlYWRlcltlLnRvTG93ZXJDYXNlKCldfSxyLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oZSx0KXtpZihpKGUpKXtmb3IodmFyIG4gaW4gZSl0aGlzLnNldChuLGVbbl0pO3JldHVybiB0aGlzfXJldHVybiB0aGlzLl9oZWFkZXJbZS50b0xvd2VyQ2FzZSgpXT10LHRoaXMuaGVhZGVyW2VdPXQsdGhpc30sci5wcm90b3R5cGUudW5zZXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGRlbGV0ZSB0aGlzLl9oZWFkZXJbZS50b0xvd2VyQ2FzZSgpXSxkZWxldGUgdGhpcy5oZWFkZXJbZV0sdGhpc30sci5wcm90b3R5cGUuZmllbGQ9ZnVuY3Rpb24oZSx0KXtpZihudWxsPT1lKXRocm93IG5ldyBFcnJvcihcIi5maWVsZChuYW1lLCB2YWwpIG5hbWUgY2FuIG5vdCBiZSBlbXB0eVwiKTtpZih0aGlzLl9kYXRhJiZjb25zb2xlLmVycm9yKFwiLmZpZWxkKCkgY2FuJ3QgYmUgdXNlZCBpZiAuc2VuZCgpIGlzIHVzZWQuIFBsZWFzZSB1c2Ugb25seSAuc2VuZCgpIG9yIG9ubHkgLmZpZWxkKCkgJiAuYXR0YWNoKClcIiksaShlKSl7Zm9yKHZhciBuIGluIGUpdGhpcy5maWVsZChuLGVbbl0pO3JldHVybiB0aGlzfWlmKEFycmF5LmlzQXJyYXkodCkpe2Zvcih2YXIgciBpbiB0KXRoaXMuZmllbGQoZSx0W3JdKTtyZXR1cm4gdGhpc31pZihudWxsPT10KXRocm93IG5ldyBFcnJvcihcIi5maWVsZChuYW1lLCB2YWwpIHZhbCBjYW4gbm90IGJlIGVtcHR5XCIpO3JldHVyblwiYm9vbGVhblwiPT10eXBlb2YgdCYmKHQ9XCJcIit0KSx0aGlzLl9nZXRGb3JtRGF0YSgpLmFwcGVuZChlLHQpLHRoaXN9LHIucHJvdG90eXBlLmFib3J0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2Fib3J0ZWR8fCh0aGlzLl9hYm9ydGVkPSEwLHRoaXMueGhyJiZ0aGlzLnhoci5hYm9ydCgpLHRoaXMucmVxJiZ0aGlzLnJlcS5hYm9ydCgpLHRoaXMuY2xlYXJUaW1lb3V0KCksdGhpcy5lbWl0KFwiYWJvcnRcIikpLHRoaXN9LHIucHJvdG90eXBlLl9hdXRoPWZ1bmN0aW9uKGUsdCxuLHIpe3N3aXRjaChuLnR5cGUpe2Nhc2VcImJhc2ljXCI6dGhpcy5zZXQoXCJBdXRob3JpemF0aW9uXCIsXCJCYXNpYyBcIityKGUrXCI6XCIrdCkpO2JyZWFrO2Nhc2VcImF1dG9cIjp0aGlzLnVzZXJuYW1lPWUsdGhpcy5wYXNzd29yZD10O2JyZWFrO2Nhc2VcImJlYXJlclwiOnRoaXMuc2V0KFwiQXV0aG9yaXphdGlvblwiLFwiQmVhcmVyIFwiK2UpfXJldHVybiB0aGlzfSxyLnByb3RvdHlwZS53aXRoQ3JlZGVudGlhbHM9ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWUmJihlPSEwKSx0aGlzLl93aXRoQ3JlZGVudGlhbHM9ZSx0aGlzfSxyLnByb3RvdHlwZS5yZWRpcmVjdHM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX21heFJlZGlyZWN0cz1lLHRoaXN9LHIucHJvdG90eXBlLm1heFJlc3BvbnNlU2l6ZT1mdW5jdGlvbihlKXtpZihcIm51bWJlclwiIT10eXBlb2YgZSl0aHJvdyBUeXBlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50XCIpO3JldHVybiB0aGlzLl9tYXhSZXNwb25zZVNpemU9ZSx0aGlzfSxyLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm57bWV0aG9kOnRoaXMubWV0aG9kLHVybDp0aGlzLnVybCxkYXRhOnRoaXMuX2RhdGEsaGVhZGVyczp0aGlzLl9oZWFkZXJ9fSxyLnByb3RvdHlwZS5zZW5kPWZ1bmN0aW9uKGUpe3ZhciB0PWkoZSksbj10aGlzLl9oZWFkZXJbXCJjb250ZW50LXR5cGVcIl07aWYodGhpcy5fZm9ybURhdGEmJmNvbnNvbGUuZXJyb3IoXCIuc2VuZCgpIGNhbid0IGJlIHVzZWQgaWYgLmF0dGFjaCgpIG9yIC5maWVsZCgpIGlzIHVzZWQuIFBsZWFzZSB1c2Ugb25seSAuc2VuZCgpIG9yIG9ubHkgLmZpZWxkKCkgJiAuYXR0YWNoKClcIiksdCYmIXRoaXMuX2RhdGEpQXJyYXkuaXNBcnJheShlKT90aGlzLl9kYXRhPVtdOnRoaXMuX2lzSG9zdChlKXx8KHRoaXMuX2RhdGE9e30pO2Vsc2UgaWYoZSYmdGhpcy5fZGF0YSYmdGhpcy5faXNIb3N0KHRoaXMuX2RhdGEpKXRocm93IEVycm9yKFwiQ2FuJ3QgbWVyZ2UgdGhlc2Ugc2VuZCBjYWxsc1wiKTtpZih0JiZpKHRoaXMuX2RhdGEpKWZvcih2YXIgciBpbiBlKXRoaXMuX2RhdGFbcl09ZVtyXTtlbHNlXCJzdHJpbmdcIj09dHlwZW9mIGU/KG58fHRoaXMudHlwZShcImZvcm1cIiksbj10aGlzLl9oZWFkZXJbXCJjb250ZW50LXR5cGVcIl0sdGhpcy5fZGF0YT1cImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiPT1uP3RoaXMuX2RhdGE/dGhpcy5fZGF0YStcIiZcIitlOmU6KHRoaXMuX2RhdGF8fFwiXCIpK2UpOnRoaXMuX2RhdGE9ZTtyZXR1cm4hdHx8dGhpcy5faXNIb3N0KGUpfHxufHx0aGlzLnR5cGUoXCJqc29uXCIpLHRoaXN9LHIucHJvdG90eXBlLnNvcnRRdWVyeT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fc29ydD12b2lkIDA9PT1lfHxlLHRoaXN9LHIucHJvdG90eXBlLl9maW5hbGl6ZVF1ZXJ5U3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5fcXVlcnkuam9pbihcIiZcIik7aWYoZSYmKHRoaXMudXJsKz0oMDw9dGhpcy51cmwuaW5kZXhPZihcIj9cIik/XCImXCI6XCI/XCIpK2UpLHRoaXMuX3F1ZXJ5Lmxlbmd0aD0wLHRoaXMuX3NvcnQpe3ZhciB0PXRoaXMudXJsLmluZGV4T2YoXCI/XCIpO2lmKDA8PXQpe3ZhciBuPXRoaXMudXJsLnN1YnN0cmluZyh0KzEpLnNwbGl0KFwiJlwiKTtcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLl9zb3J0P24uc29ydCh0aGlzLl9zb3J0KTpuLnNvcnQoKSx0aGlzLnVybD10aGlzLnVybC5zdWJzdHJpbmcoMCx0KStcIj9cIituLmpvaW4oXCImXCIpfX19LHIucHJvdG90eXBlLl9hcHBlbmRRdWVyeVN0cmluZz1mdW5jdGlvbigpe2NvbnNvbGUudHJhY2UoXCJVbnN1cHBvcnRlZFwiKX0sci5wcm90b3R5cGUuX3RpbWVvdXRFcnJvcj1mdW5jdGlvbihlLHQsbil7aWYoIXRoaXMuX2Fib3J0ZWQpe3ZhciByPW5ldyBFcnJvcihlK3QrXCJtcyBleGNlZWRlZFwiKTtyLnRpbWVvdXQ9dCxyLmNvZGU9XCJFQ09OTkFCT1JURURcIixyLmVycm5vPW4sdGhpcy50aW1lZG91dD0hMCx0aGlzLmFib3J0KCksdGhpcy5jYWxsYmFjayhyKX19LHIucHJvdG90eXBlLl9zZXRUaW1lb3V0cz1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5fdGltZW91dCYmIXRoaXMuX3RpbWVyJiYodGhpcy5fdGltZXI9c2V0VGltZW91dChmdW5jdGlvbigpe2UuX3RpbWVvdXRFcnJvcihcIlRpbWVvdXQgb2YgXCIsZS5fdGltZW91dCxcIkVUSU1FXCIpfSx0aGlzLl90aW1lb3V0KSksdGhpcy5fcmVzcG9uc2VUaW1lb3V0JiYhdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXImJih0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lcj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5fdGltZW91dEVycm9yKFwiUmVzcG9uc2UgdGltZW91dCBvZiBcIixlLl9yZXNwb25zZVRpbWVvdXQsXCJFVElNRURPVVRcIil9LHRoaXMuX3Jlc3BvbnNlVGltZW91dCkpfX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBpPW4oODApO2Z1bmN0aW9uIHIoZSl7aWYoZSlyZXR1cm4gZnVuY3Rpb24oZSl7Zm9yKHZhciB0IGluIHIucHJvdG90eXBlKWVbdF09ci5wcm90b3R5cGVbdF07cmV0dXJuIGV9KGUpfShlLmV4cG9ydHM9cikucHJvdG90eXBlLmdldD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5oZWFkZXJbZS50b0xvd2VyQ2FzZSgpXX0sci5wcm90b3R5cGUuX3NldEhlYWRlclByb3BlcnRpZXM9ZnVuY3Rpb24oZSl7dmFyIHQ9ZVtcImNvbnRlbnQtdHlwZVwiXXx8XCJcIjt0aGlzLnR5cGU9aS50eXBlKHQpO3ZhciBuPWkucGFyYW1zKHQpO2Zvcih2YXIgciBpbiBuKXRoaXNbcl09bltyXTt0aGlzLmxpbmtzPXt9O3RyeXtlLmxpbmsmJih0aGlzLmxpbmtzPWkucGFyc2VMaW5rcyhlLmxpbmspKX1jYXRjaChlKXt9fSxyLnByb3RvdHlwZS5fc2V0U3RhdHVzUHJvcGVydGllcz1mdW5jdGlvbihlKXt2YXIgdD1lLzEwMHwwO3RoaXMuc3RhdHVzPXRoaXMuc3RhdHVzQ29kZT1lLHRoaXMuc3RhdHVzVHlwZT10LHRoaXMuaW5mbz0xPT10LHRoaXMub2s9Mj09dCx0aGlzLnJlZGlyZWN0PTM9PXQsdGhpcy5jbGllbnRFcnJvcj00PT10LHRoaXMuc2VydmVyRXJyb3I9NT09dCx0aGlzLmVycm9yPSg0PT10fHw1PT10KSYmdGhpcy50b0Vycm9yKCksdGhpcy5jcmVhdGVkPTIwMT09ZSx0aGlzLmFjY2VwdGVkPTIwMj09ZSx0aGlzLm5vQ29udGVudD0yMDQ9PWUsdGhpcy5iYWRSZXF1ZXN0PTQwMD09ZSx0aGlzLnVuYXV0aG9yaXplZD00MDE9PWUsdGhpcy5ub3RBY2NlcHRhYmxlPTQwNj09ZSx0aGlzLmZvcmJpZGRlbj00MDM9PWUsdGhpcy5ub3RGb3VuZD00MDQ9PWUsdGhpcy51bnByb2Nlc3NhYmxlRW50aXR5PTQyMj09ZX19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt0LnR5cGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuc3BsaXQoLyAqOyAqLykuc2hpZnQoKX0sdC5wYXJhbXM9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuc3BsaXQoLyAqOyAqLykucmVkdWNlKGZ1bmN0aW9uKGUsdCl7dmFyIG49dC5zcGxpdCgvICo9ICovKSxyPW4uc2hpZnQoKSxpPW4uc2hpZnQoKTtyZXR1cm4gciYmaSYmKGVbcl09aSksZX0se30pfSx0LnBhcnNlTGlua3M9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuc3BsaXQoLyAqLCAqLykucmVkdWNlKGZ1bmN0aW9uKGUsdCl7dmFyIG49dC5zcGxpdCgvICo7ICovKSxyPW5bMF0uc2xpY2UoMSwtMSk7cmV0dXJuIGVbblsxXS5zcGxpdCgvICo9ICovKVsxXS5zbGljZSgxLC0xKV09cixlfSx7fSl9LHQuY2xlYW5IZWFkZXI9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZGVsZXRlIGVbXCJjb250ZW50LXR5cGVcIl0sZGVsZXRlIGVbXCJjb250ZW50LWxlbmd0aFwiXSxkZWxldGUgZVtcInRyYW5zZmVyLWVuY29kaW5nXCJdLGRlbGV0ZSBlLmhvc3QsdCYmKGRlbGV0ZSBlLmF1dGhvcml6YXRpb24sZGVsZXRlIGUuY29va2llKSxlfX0sZnVuY3Rpb24oZSx0KXtmdW5jdGlvbiBuKCl7dGhpcy5fZGVmYXVsdHM9W119W1widXNlXCIsXCJvblwiLFwib25jZVwiLFwic2V0XCIsXCJxdWVyeVwiLFwidHlwZVwiLFwiYWNjZXB0XCIsXCJhdXRoXCIsXCJ3aXRoQ3JlZGVudGlhbHNcIixcInNvcnRRdWVyeVwiLFwicmV0cnlcIixcIm9rXCIsXCJyZWRpcmVjdHNcIixcInRpbWVvdXRcIixcImJ1ZmZlclwiLFwic2VyaWFsaXplXCIsXCJwYXJzZVwiLFwiY2FcIixcImtleVwiLFwicGZ4XCIsXCJjZXJ0XCJdLmZvckVhY2goZnVuY3Rpb24oZSl7bi5wcm90b3R5cGVbZV09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZGVmYXVsdHMucHVzaCh7Zm46ZSxhcmd1bWVudHM6YXJndW1lbnRzfSksdGhpc319KSxuLnByb3RvdHlwZS5fc2V0RGVmYXVsdHM9ZnVuY3Rpb24odCl7dGhpcy5fZGVmYXVsdHMuZm9yRWFjaChmdW5jdGlvbihlKXt0W2UuZm5dLmFwcGx5KHQsZS5hcmd1bWVudHMpfSl9LGUuZXhwb3J0cz1ufV0saS5jPXIsaS5kPWZ1bmN0aW9uKGUsdCxuKXtpLm8oZSx0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7ZW51bWVyYWJsZTohMCxnZXQ6bn0pfSxpLnI9ZnVuY3Rpb24oZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0saS50PWZ1bmN0aW9uKHQsZSl7aWYoMSZlJiYodD1pKHQpKSw4JmUpcmV0dXJuIHQ7aWYoNCZlJiZcIm9iamVjdFwiPT10eXBlb2YgdCYmdCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBuPU9iamVjdC5jcmVhdGUobnVsbCk7aWYoaS5yKG4pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOnR9KSwyJmUmJlwic3RyaW5nXCIhPXR5cGVvZiB0KWZvcih2YXIgciBpbiB0KWkuZChuLHIsZnVuY3Rpb24oZSl7cmV0dXJuIHRbZV19LmJpbmQobnVsbCxyKSk7cmV0dXJuIG59LGkubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gaS5kKHQsXCJhXCIsdCksdH0saS5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSxpLnA9XCJcIixpKGkucz0xMSk7ZnVuY3Rpb24gaShlKXtpZihyW2VdKXJldHVybiByW2VdLmV4cG9ydHM7dmFyIHQ9cltlXT17aTplLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIG5bZV0uY2FsbCh0LmV4cG9ydHMsdCx0LmV4cG9ydHMsaSksdC5sPSEwLHQuZXhwb3J0c312YXIgbixyfSk7IiwidmFyIFdlYjMgPSByZXF1aXJlKCcuL2xpYi93ZWIzJyk7XG5cbi8vIGRvbnQgb3ZlcnJpZGUgZ2xvYmFsIHZhcmlhYmxlXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5XZWIzID09PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5XZWIzID0gV2ViMztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBXZWIzO1xuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgICB7XG4gICAgIFwicGF5YWJsZVwiOiB0cnVlLFxuICAgICBcInN0YXRlTXV0YWJpbGl0eVwiOiBcInBheWFibGVcIixcbiAgICAgXCJ0eXBlXCI6IFwiZmFsbGJhY2tcIlxuICAgIH0sXG4gICAge1xuICAgICBcImNvbnN0YW50XCI6IHRydWUsXG4gICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICBcIm5hbWVcIjogXCJ1c2VyXCIsXG4gICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgIFwibmFtZVwiOiBcInRva2VuXCIsXG4gICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgIF0sXG4gICAgIFwibmFtZVwiOiBcInRva2VuQmFsYW5jZVwiLFxuICAgICBcIm91dHB1dHNcIjogW1xuICAgICAge1xuICAgICAgIFwibmFtZVwiOiBcIlwiLFxuICAgICAgIFwidHlwZVwiOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgICBdLFxuICAgICBcInBheWFibGVcIjogZmFsc2UsXG4gICAgIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwidmlld1wiLFxuICAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICB7XG4gICAgIFwiY29uc3RhbnRcIjogdHJ1ZSxcbiAgICAgXCJpbnB1dHNcIjogW1xuICAgICAge1xuICAgICAgIFwibmFtZVwiOiBcInVzZXJzXCIsXG4gICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1tdXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgXCJuYW1lXCI6IFwidG9rZW5zXCIsXG4gICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1tdXCJcbiAgICAgIH1cbiAgICAgXSxcbiAgICAgXCJuYW1lXCI6IFwiYmFsYW5jZXNcIixcbiAgICAgXCJvdXRwdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICBcIm5hbWVcIjogXCJcIixcbiAgICAgICBcInR5cGVcIjogXCJ1aW50MjU2W11cIlxuICAgICAgfVxuICAgICBdLFxuICAgICBcInBheWFibGVcIjogZmFsc2UsXG4gICAgIFwic3RhdGVNdXRhYmlsaXR5XCI6IFwidmlld1wiLFxuICAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gICAgfVxuICAgXVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVjb3ZlclR5cGVkU2lnbmF0dXJlX3Y0ID0gZXhwb3J0cy5yZWNvdmVyVHlwZWRTaWduYXR1cmUgPSBleHBvcnRzLnNpZ25UeXBlZERhdGFfdjQgPSBleHBvcnRzLnNpZ25UeXBlZERhdGEgPSBleHBvcnRzLnJlY292ZXJUeXBlZE1lc3NhZ2UgPSBleHBvcnRzLnNpZ25UeXBlZE1lc3NhZ2UgPSBleHBvcnRzLmdldEVuY3J5cHRpb25QdWJsaWNLZXkgPSBleHBvcnRzLmRlY3J5cHRTYWZlbHkgPSBleHBvcnRzLmRlY3J5cHQgPSBleHBvcnRzLmVuY3J5cHRTYWZlbHkgPSBleHBvcnRzLmVuY3J5cHQgPSBleHBvcnRzLnJlY292ZXJUeXBlZFNpZ25hdHVyZUxlZ2FjeSA9IGV4cG9ydHMuc2lnblR5cGVkRGF0YUxlZ2FjeSA9IGV4cG9ydHMudHlwZWRTaWduYXR1cmVIYXNoID0gZXhwb3J0cy5leHRyYWN0UHVibGljS2V5ID0gZXhwb3J0cy5yZWNvdmVyUGVyc29uYWxTaWduYXR1cmUgPSBleHBvcnRzLnBlcnNvbmFsU2lnbiA9IGV4cG9ydHMubm9ybWFsaXplID0gZXhwb3J0cy5jb25jYXRTaWcgPSBleHBvcnRzLlR5cGVkRGF0YVV0aWxzID0gZXhwb3J0cy5UWVBFRF9NRVNTQUdFX1NDSEVNQSA9IHZvaWQgMDtcbmNvbnN0IGV0aFV0aWwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImV0aGVyZXVtanMtdXRpbFwiKSk7XG5jb25zdCBldGhBYmkgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImV0aGVyZXVtanMtYWJpXCIpKTtcbmNvbnN0IG5hY2wgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInR3ZWV0bmFjbFwiKSk7XG5jb25zdCBuYWNsVXRpbCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwidHdlZXRuYWNsLXV0aWxcIikpO1xuY29uc3QgVFlQRURfTUVTU0FHRV9TQ0hFTUEgPSB7XG4gICAgdHlwZTogJ29iamVjdCcsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICB0eXBlczoge1xuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFsnbmFtZScsICd0eXBlJ10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHByaW1hcnlUeXBlOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgIGRvbWFpbjogeyB0eXBlOiAnb2JqZWN0JyB9LFxuICAgICAgICBtZXNzYWdlOiB7IHR5cGU6ICdvYmplY3QnIH0sXG4gICAgfSxcbiAgICByZXF1aXJlZDogWyd0eXBlcycsICdwcmltYXJ5VHlwZScsICdkb21haW4nLCAnbWVzc2FnZSddLFxufTtcbmV4cG9ydHMuVFlQRURfTUVTU0FHRV9TQ0hFTUEgPSBUWVBFRF9NRVNTQUdFX1NDSEVNQTtcbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIHV0aWxpdHkgZnVuY3Rpb25zIHVzZWQgZm9yIHNpZ25pbmcgdHlwZWQgZGF0YVxuICovXG5jb25zdCBUeXBlZERhdGFVdGlscyA9IHtcbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIGFuIG9iamVjdCBieSBlbmNvZGluZyBhbmQgY29uY2F0ZW5hdGluZyBlYWNoIG9mIGl0cyBtZW1iZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJpbWFyeVR5cGUgLSBSb290IHR5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIE9iamVjdCB0byBlbmNvZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZXMgLSBUeXBlIGRlZmluaXRpb25zXG4gICAgICogQHJldHVybnMge0J1ZmZlcn0gLSBFbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9iamVjdFxuICAgICAqL1xuICAgIGVuY29kZURhdGEocHJpbWFyeVR5cGUsIGRhdGEsIHR5cGVzLCB1c2VWNCA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlZFR5cGVzID0gWydieXRlczMyJ107XG4gICAgICAgIGNvbnN0IGVuY29kZWRWYWx1ZXMgPSBbdGhpcy5oYXNoVHlwZShwcmltYXJ5VHlwZSwgdHlwZXMpXTtcbiAgICAgICAgaWYgKHVzZVY0KSB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVGaWVsZCA9IChuYW1lLCB0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlc1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYnl0ZXMzMicsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9PSBudWxsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXEtbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGV0aFV0aWwua2VjY2FrKHRoaXMuZW5jb2RlRGF0YSh0eXBlLCB2YWx1ZSwgdHlwZXMsIHVzZVY0KSksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyB2YWx1ZSBmb3IgZmllbGQgJHtuYW1lfSBvZiB0eXBlICR7dHlwZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdieXRlcycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnYnl0ZXMzMicsIGV0aFV0aWwua2VjY2FrKHZhbHVlKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHN0cmluZyB0byBidWZmZXIgLSBwcmV2ZW50cyBldGhVdGlsIGZyb20gaW50ZXJwcmV0aW5nIHN0cmluZ3MgbGlrZSAnMHhhYmNkJyBhcyBoZXhcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gQnVmZmVyLmZyb20odmFsdWUsICd1dGY4Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnYnl0ZXMzMicsIGV0aFV0aWwua2VjY2FrKHZhbHVlKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlLmxhc3RJbmRleE9mKCddJykgPT09IHR5cGUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdHlwZS5zbGljZSgwLCB0eXBlLmxhc3RJbmRleE9mKCdbJykpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlVmFsdWVQYWlycyA9IHZhbHVlLm1hcCgoaXRlbSkgPT4gZW5jb2RlRmllbGQobmFtZSwgcGFyc2VkVHlwZSwgaXRlbSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2J5dGVzMzInLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXRoVXRpbC5rZWNjYWsoZXRoQWJpLnJhd0VuY29kZSh0eXBlVmFsdWVQYWlycy5tYXAoKFt0XSkgPT4gdCksIHR5cGVWYWx1ZVBhaXJzLm1hcCgoWywgdl0pID0+IHYpKSksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbdHlwZSwgdmFsdWVdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZXNbcHJpbWFyeVR5cGVdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3R5cGUsIHZhbHVlXSA9IGVuY29kZUZpZWxkKGZpZWxkLm5hbWUsIGZpZWxkLnR5cGUsIGRhdGFbZmllbGQubmFtZV0pO1xuICAgICAgICAgICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgICAgIGVuY29kZWRWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVzW3ByaW1hcnlUeXBlXSkge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGRhdGFbZmllbGQubmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLnR5cGUgPT09ICdieXRlcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKCdieXRlczMyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGV0aFV0aWwua2VjY2FrKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZWRWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKCdieXRlczMyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHN0cmluZyB0byBidWZmZXIgLSBwcmV2ZW50cyBldGhVdGlsIGZyb20gaW50ZXJwcmV0aW5nIHN0cmluZ3MgbGlrZSAnMHhhYmNkJyBhcyBoZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZSwgJ3V0ZjgnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZXRoVXRpbC5rZWNjYWsodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlc1tmaWVsZC50eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVkVHlwZXMucHVzaCgnYnl0ZXMzMicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBldGhVdGlsLmtlY2Nhayh0aGlzLmVuY29kZURhdGEoZmllbGQudHlwZSwgdmFsdWUsIHR5cGVzLCB1c2VWNCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZC50eXBlLmxhc3RJbmRleE9mKCddJykgPT09IGZpZWxkLnR5cGUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcnJheXMgYXJlIHVuaW1wbGVtZW50ZWQgaW4gZW5jb2RlRGF0YTsgdXNlIFY0IGV4dGVuc2lvbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlZFR5cGVzLnB1c2goZmllbGQudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVkVmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldGhBYmkucmF3RW5jb2RlKGVuY29kZWRUeXBlcywgZW5jb2RlZFZhbHVlcyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHRoZSB0eXBlIG9mIGFuIG9iamVjdCBieSBlbmNvZGluZyBhIGNvbW1hIGRlbGltaXRlZCBsaXN0IG9mIGl0cyBtZW1iZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJpbWFyeVR5cGUgLSBSb290IHR5cGUgdG8gZW5jb2RlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVzIC0gVHlwZSBkZWZpbml0aW9uc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gRW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKi9cbiAgICBlbmNvZGVUeXBlKHByaW1hcnlUeXBlLCB0eXBlcykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICAgIGxldCBkZXBzID0gdGhpcy5maW5kVHlwZURlcGVuZGVuY2llcyhwcmltYXJ5VHlwZSwgdHlwZXMpLmZpbHRlcigoZGVwKSA9PiBkZXAgIT09IHByaW1hcnlUeXBlKTtcbiAgICAgICAgZGVwcyA9IFtwcmltYXJ5VHlwZV0uY29uY2F0KGRlcHMuc29ydCgpKTtcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIGRlcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdHlwZXNbdHlwZV07XG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyB0eXBlIGRlZmluaXRpb24gc3BlY2lmaWVkOiAke3R5cGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gYCR7dHlwZX0oJHt0eXBlc1t0eXBlXVxuICAgICAgICAgICAgICAgIC5tYXAoKHsgbmFtZSwgdHlwZTogdCB9KSA9PiBgJHt0fSAke25hbWV9YClcbiAgICAgICAgICAgICAgICAuam9pbignLCcpfSlgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBGaW5kcyBhbGwgdHlwZXMgd2l0aGluIGEgdHlwZSBkZWZpbml0aW9uIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByaW1hcnlUeXBlIC0gUm9vdCB0eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVzIC0gVHlwZSBkZWZpbml0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IHJlc3VsdHMgLSBjdXJyZW50IHNldCBvZiBhY2N1bXVsYXRlZCB0eXBlc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX0gLSBTZXQgb2YgYWxsIHR5cGVzIGZvdW5kIGluIHRoZSB0eXBlIGRlZmluaXRpb25cbiAgICAgKi9cbiAgICBmaW5kVHlwZURlcGVuZGVuY2llcyhwcmltYXJ5VHlwZSwgdHlwZXMsIHJlc3VsdHMgPSBbXSkge1xuICAgICAgICBbcHJpbWFyeVR5cGVdID0gcHJpbWFyeVR5cGUubWF0Y2goL15cXHcqL3UpO1xuICAgICAgICBpZiAocmVzdWx0cy5pbmNsdWRlcyhwcmltYXJ5VHlwZSkgfHwgdHlwZXNbcHJpbWFyeVR5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdHMucHVzaChwcmltYXJ5VHlwZSk7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZXNbcHJpbWFyeVR5cGVdKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRlcCBvZiB0aGlzLmZpbmRUeXBlRGVwZW5kZW5jaWVzKGZpZWxkLnR5cGUsIHR5cGVzLCByZXN1bHRzKSkge1xuICAgICAgICAgICAgICAgICFyZXN1bHRzLmluY2x1ZGVzKGRlcCkgJiYgcmVzdWx0cy5wdXNoKGRlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBIYXNoZXMgYW4gb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJpbWFyeVR5cGUgLSBSb290IHR5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIE9iamVjdCB0byBoYXNoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVzIC0gVHlwZSBkZWZpbml0aW9uc1xuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9IC0gSGFzaCBvZiBhbiBvYmplY3RcbiAgICAgKi9cbiAgICBoYXNoU3RydWN0KHByaW1hcnlUeXBlLCBkYXRhLCB0eXBlcywgdXNlVjQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBldGhVdGlsLmtlY2Nhayh0aGlzLmVuY29kZURhdGEocHJpbWFyeVR5cGUsIGRhdGEsIHR5cGVzLCB1c2VWNCkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSGFzaGVzIHRoZSB0eXBlIG9mIGFuIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByaW1hcnlUeXBlIC0gUm9vdCB0eXBlIHRvIGhhc2hcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZXMgLSBUeXBlIGRlZmluaXRpb25zXG4gICAgICogQHJldHVybnMge0J1ZmZlcn0gLSBIYXNoIG9mIGFuIG9iamVjdFxuICAgICAqL1xuICAgIGhhc2hUeXBlKHByaW1hcnlUeXBlLCB0eXBlcykge1xuICAgICAgICByZXR1cm4gZXRoVXRpbC5rZWNjYWsodGhpcy5lbmNvZGVUeXBlKHByaW1hcnlUeXBlLCB0eXBlcykpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBwcm9wZXJ0aWVzIGZyb20gYSBtZXNzYWdlIG9iamVjdCB0aGF0IGFyZSBub3QgZGVmaW5lZCBwZXIgRUlQLTcxMlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSB0eXBlZCBtZXNzYWdlIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IC0gdHlwZWQgbWVzc2FnZSBvYmplY3Qgd2l0aCBvbmx5IGFsbG93ZWQgZmllbGRzXG4gICAgICovXG4gICAgc2FuaXRpemVEYXRhKGRhdGEpIHtcbiAgICAgICAgY29uc3Qgc2FuaXRpemVkRGF0YSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBUWVBFRF9NRVNTQUdFX1NDSEVNQS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAoZGF0YVtrZXldKSB7XG4gICAgICAgICAgICAgICAgc2FuaXRpemVkRGF0YVtrZXldID0gZGF0YVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgndHlwZXMnIGluIHNhbml0aXplZERhdGEpIHtcbiAgICAgICAgICAgIHNhbml0aXplZERhdGEudHlwZXMgPSBPYmplY3QuYXNzaWduKHsgRUlQNzEyRG9tYWluOiBbXSB9LCBzYW5pdGl6ZWREYXRhLnR5cGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2FuaXRpemVkRGF0YTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNpZ25zIGEgdHlwZWQgbWVzc2FnZSBhcyBwZXIgRUlQLTcxMiBhbmQgcmV0dXJucyBpdHMga2VjY2FrIGhhc2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZERhdGEgLSBUeXBlcyBtZXNzYWdlIGRhdGEgdG8gc2lnblxuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9IC0ga2VjY2FrIGhhc2ggb2YgdGhlIHJlc3VsdGluZyBzaWduZWQgbWVzc2FnZVxuICAgICAqL1xuICAgIHNpZ24odHlwZWREYXRhLCB1c2VWNCA9IHRydWUpIHtcbiAgICAgICAgY29uc3Qgc2FuaXRpemVkRGF0YSA9IHRoaXMuc2FuaXRpemVEYXRhKHR5cGVkRGF0YSk7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gW0J1ZmZlci5mcm9tKCcxOTAxJywgJ2hleCcpXTtcbiAgICAgICAgcGFydHMucHVzaCh0aGlzLmhhc2hTdHJ1Y3QoJ0VJUDcxMkRvbWFpbicsIHNhbml0aXplZERhdGEuZG9tYWluLCBzYW5pdGl6ZWREYXRhLnR5cGVzLCB1c2VWNCkpO1xuICAgICAgICBpZiAoc2FuaXRpemVkRGF0YS5wcmltYXJ5VHlwZSAhPT0gJ0VJUDcxMkRvbWFpbicpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5oYXNoU3RydWN0KHNhbml0aXplZERhdGEucHJpbWFyeVR5cGUsIHNhbml0aXplZERhdGEubWVzc2FnZSwgc2FuaXRpemVkRGF0YS50eXBlcywgdXNlVjQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXRoVXRpbC5rZWNjYWsoQnVmZmVyLmNvbmNhdChwYXJ0cykpO1xuICAgIH0sXG59O1xuZXhwb3J0cy5UeXBlZERhdGFVdGlscyA9IFR5cGVkRGF0YVV0aWxzO1xuZnVuY3Rpb24gY29uY2F0U2lnKHYsIHIsIHMpIHtcbiAgICBjb25zdCByU2lnID0gZXRoVXRpbC5mcm9tU2lnbmVkKHIpO1xuICAgIGNvbnN0IHNTaWcgPSBldGhVdGlsLmZyb21TaWduZWQocyk7XG4gICAgY29uc3QgdlNpZyA9IGV0aFV0aWwuYnVmZmVyVG9JbnQodik7XG4gICAgY29uc3QgclN0ciA9IHBhZFdpdGhaZXJvZXMoZXRoVXRpbC50b1Vuc2lnbmVkKHJTaWcpLnRvU3RyaW5nKCdoZXgnKSwgNjQpO1xuICAgIGNvbnN0IHNTdHIgPSBwYWRXaXRoWmVyb2VzKGV0aFV0aWwudG9VbnNpZ25lZChzU2lnKS50b1N0cmluZygnaGV4JyksIDY0KTtcbiAgICBjb25zdCB2U3RyID0gZXRoVXRpbC5zdHJpcEhleFByZWZpeChldGhVdGlsLmludFRvSGV4KHZTaWcpKTtcbiAgICByZXR1cm4gZXRoVXRpbC5hZGRIZXhQcmVmaXgoclN0ci5jb25jYXQoc1N0ciwgdlN0cikpLnRvU3RyaW5nKCdoZXgnKTtcbn1cbmV4cG9ydHMuY29uY2F0U2lnID0gY29uY2F0U2lnO1xuZnVuY3Rpb24gbm9ybWFsaXplKGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBldGhVdGlsLnRvQnVmZmVyKGlucHV0KTtcbiAgICAgICAgaW5wdXQgPSBldGhVdGlsLmJ1ZmZlclRvSGV4KGJ1ZmZlcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGxldCBtc2cgPSAnZXRoLXNpZy11dGlsLm5vcm1hbGl6ZSgpIHJlcXVpcmVzIGhleCBzdHJpbmcgb3IgaW50ZWdlciBpbnB1dC4nO1xuICAgICAgICBtc2cgKz0gYCByZWNlaXZlZCAke3R5cGVvZiBpbnB1dH06ICR7aW5wdXR9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICAgIHJldHVybiBldGhVdGlsLmFkZEhleFByZWZpeChpbnB1dC50b0xvd2VyQ2FzZSgpKTtcbn1cbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuZnVuY3Rpb24gcGVyc29uYWxTaWduKHByaXZhdGVLZXksIG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBldGhVdGlsLnRvQnVmZmVyKG1zZ1BhcmFtcy5kYXRhKTtcbiAgICBjb25zdCBtc2dIYXNoID0gZXRoVXRpbC5oYXNoUGVyc29uYWxNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIGNvbnN0IHNpZyA9IGV0aFV0aWwuZWNzaWduKG1zZ0hhc2gsIHByaXZhdGVLZXkpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBldGhVdGlsLmJ1ZmZlclRvSGV4KGNvbmNhdFNpZyhzaWcudiwgc2lnLnIsIHNpZy5zKSk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59XG5leHBvcnRzLnBlcnNvbmFsU2lnbiA9IHBlcnNvbmFsU2lnbjtcbmZ1bmN0aW9uIHJlY292ZXJQZXJzb25hbFNpZ25hdHVyZShtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXlGb3IobXNnUGFyYW1zKTtcbiAgICBjb25zdCBzZW5kZXIgPSBldGhVdGlsLnB1YmxpY1RvQWRkcmVzcyhwdWJsaWNLZXkpO1xuICAgIGNvbnN0IHNlbmRlckhleCA9IGV0aFV0aWwuYnVmZmVyVG9IZXgoc2VuZGVyKTtcbiAgICByZXR1cm4gc2VuZGVySGV4O1xufVxuZXhwb3J0cy5yZWNvdmVyUGVyc29uYWxTaWduYXR1cmUgPSByZWNvdmVyUGVyc29uYWxTaWduYXR1cmU7XG5mdW5jdGlvbiBleHRyYWN0UHVibGljS2V5KG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGdldFB1YmxpY0tleUZvcihtc2dQYXJhbXMpO1xuICAgIHJldHVybiBgMHgke3B1YmxpY0tleS50b1N0cmluZygnaGV4Jyl9YDtcbn1cbmV4cG9ydHMuZXh0cmFjdFB1YmxpY0tleSA9IGV4dHJhY3RQdWJsaWNLZXk7XG5mdW5jdGlvbiBleHRlcm5hbFR5cGVkU2lnbmF0dXJlSGFzaCh0eXBlZERhdGEpIHtcbiAgICBjb25zdCBoYXNoQnVmZmVyID0gdHlwZWRTaWduYXR1cmVIYXNoKHR5cGVkRGF0YSk7XG4gICAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgoaGFzaEJ1ZmZlcik7XG59XG5leHBvcnRzLnR5cGVkU2lnbmF0dXJlSGFzaCA9IGV4dGVybmFsVHlwZWRTaWduYXR1cmVIYXNoO1xuZnVuY3Rpb24gc2lnblR5cGVkRGF0YUxlZ2FjeShwcml2YXRlS2V5LCBtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBtc2dIYXNoID0gdHlwZWRTaWduYXR1cmVIYXNoKG1zZ1BhcmFtcy5kYXRhKTtcbiAgICBjb25zdCBzaWcgPSBldGhVdGlsLmVjc2lnbihtc2dIYXNoLCBwcml2YXRlS2V5KTtcbiAgICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleChjb25jYXRTaWcoc2lnLnYsIHNpZy5yLCBzaWcucykpO1xufVxuZXhwb3J0cy5zaWduVHlwZWREYXRhTGVnYWN5ID0gc2lnblR5cGVkRGF0YUxlZ2FjeTtcbmZ1bmN0aW9uIHJlY292ZXJUeXBlZFNpZ25hdHVyZUxlZ2FjeShtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBtc2dIYXNoID0gdHlwZWRTaWduYXR1cmVIYXNoKG1zZ1BhcmFtcy5kYXRhKTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gsIG1zZ1BhcmFtcy5zaWcpO1xuICAgIGNvbnN0IHNlbmRlciA9IGV0aFV0aWwucHVibGljVG9BZGRyZXNzKHB1YmxpY0tleSk7XG4gICAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgoc2VuZGVyKTtcbn1cbmV4cG9ydHMucmVjb3ZlclR5cGVkU2lnbmF0dXJlTGVnYWN5ID0gcmVjb3ZlclR5cGVkU2lnbmF0dXJlTGVnYWN5O1xuZnVuY3Rpb24gZW5jcnlwdChyZWNlaXZlclB1YmxpY0tleSwgbXNnUGFyYW1zLCB2ZXJzaW9uKSB7XG4gICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgICAgIGNhc2UgJ3gyNTUxOS14c2Fsc2EyMC1wb2x5MTMwNSc6IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbXNnUGFyYW1zLmRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGV0ZWN0IHNlY3JldCBtZXNzYWdlLCBtZXNzYWdlIHBhcmFtcyBzaG91bGQgYmUgb2YgdGhlIGZvcm0ge2RhdGE6IFwic2VjcmV0IG1lc3NhZ2VcIn0gJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSBlcGhlbWVyYWwga2V5cGFpclxuICAgICAgICAgICAgY29uc3QgZXBoZW1lcmFsS2V5UGFpciA9IG5hY2wuYm94LmtleVBhaXIoKTtcbiAgICAgICAgICAgIC8vIGFzc2VtYmxlIGVuY3J5cHRpb24gcGFyYW1ldGVycyAtIGZyb20gc3RyaW5nIHRvIFVJbnQ4XG4gICAgICAgICAgICBsZXQgcHViS2V5VUludDhBcnJheTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHViS2V5VUludDhBcnJheSA9IG5hY2xVdGlsLmRlY29kZUJhc2U2NChyZWNlaXZlclB1YmxpY0tleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgcHVibGljIGtleScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbXNnUGFyYW1zVUludDhBcnJheSA9IG5hY2xVdGlsLmRlY29kZVVURjgobXNnUGFyYW1zLmRhdGEpO1xuICAgICAgICAgICAgY29uc3Qgbm9uY2UgPSBuYWNsLnJhbmRvbUJ5dGVzKG5hY2wuYm94Lm5vbmNlTGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIGVuY3J5cHRcbiAgICAgICAgICAgIGNvbnN0IGVuY3J5cHRlZE1lc3NhZ2UgPSBuYWNsLmJveChtc2dQYXJhbXNVSW50OEFycmF5LCBub25jZSwgcHViS2V5VUludDhBcnJheSwgZXBoZW1lcmFsS2V5UGFpci5zZWNyZXRLZXkpO1xuICAgICAgICAgICAgLy8gaGFuZGxlIGVuY3J5cHRlZCBkYXRhXG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogJ3gyNTUxOS14c2Fsc2EyMC1wb2x5MTMwNScsXG4gICAgICAgICAgICAgICAgbm9uY2U6IG5hY2xVdGlsLmVuY29kZUJhc2U2NChub25jZSksXG4gICAgICAgICAgICAgICAgZXBoZW1QdWJsaWNLZXk6IG5hY2xVdGlsLmVuY29kZUJhc2U2NChlcGhlbWVyYWxLZXlQYWlyLnB1YmxpY0tleSksXG4gICAgICAgICAgICAgICAgY2lwaGVydGV4dDogbmFjbFV0aWwuZW5jb2RlQmFzZTY0KGVuY3J5cHRlZE1lc3NhZ2UpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIHJldHVybiBlbmNyeXB0ZWQgbXNnIGRhdGFcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiB0eXBlL3ZlcnNpb24gbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbn1cbmV4cG9ydHMuZW5jcnlwdCA9IGVuY3J5cHQ7XG5mdW5jdGlvbiBlbmNyeXB0U2FmZWx5KHJlY2VpdmVyUHVibGljS2V5LCBtc2dQYXJhbXMsIHZlcnNpb24pIHtcbiAgICBjb25zdCBERUZBVUxUX1BBRERJTkdfTEVOR1RIID0gMiAqKiAxMTtcbiAgICBjb25zdCBOQUNMX0VYVFJBX0JZVEVTID0gMTY7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBtc2dQYXJhbXM7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGVuY3J5cHQgZW1wdHkgbXNnLmRhdGEnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiAndG9KU09OJyBpbiBkYXRhKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0b0pTT04gYXR0YWNrIHZlY3RvclxuICAgICAgICAvLyBUT0RPLCBjaGVjayBhbGwgcG9zc2libGUgY2hpbGRyZW5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZW5jcnlwdCB3aXRoIHRvSlNPTiBwcm9wZXJ0eS4gIFBsZWFzZSByZW1vdmUgdG9KU09OIHByb3BlcnR5Jyk7XG4gICAgfVxuICAgIC8vIGFkZCBwYWRkaW5nXG4gICAgY29uc3QgZGF0YVdpdGhQYWRkaW5nID0ge1xuICAgICAgICBkYXRhLFxuICAgICAgICBwYWRkaW5nOiAnJyxcbiAgICB9O1xuICAgIC8vIGNhbGN1bGF0ZSBwYWRkaW5nXG4gICAgY29uc3QgZGF0YUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKEpTT04uc3RyaW5naWZ5KGRhdGFXaXRoUGFkZGluZyksICd1dGYtOCcpO1xuICAgIGNvbnN0IG1vZFZhbCA9IGRhdGFMZW5ndGggJSBERUZBVUxUX1BBRERJTkdfTEVOR1RIO1xuICAgIGxldCBwYWRMZW5ndGggPSAwO1xuICAgIC8vIE9ubHkgcGFkIGlmIG5lY2Vzc2FyeVxuICAgIGlmIChtb2RWYWwgPiAwKSB7XG4gICAgICAgIHBhZExlbmd0aCA9IERFRkFVTFRfUEFERElOR19MRU5HVEggLSBtb2RWYWwgLSBOQUNMX0VYVFJBX0JZVEVTOyAvLyBuYWNsIGV4dHJhIGJ5dGVzXG4gICAgfVxuICAgIGRhdGFXaXRoUGFkZGluZy5wYWRkaW5nID0gJzAnLnJlcGVhdChwYWRMZW5ndGgpO1xuICAgIGNvbnN0IHBhZGRlZE1zZ1BhcmFtcyA9IHsgZGF0YTogSlNPTi5zdHJpbmdpZnkoZGF0YVdpdGhQYWRkaW5nKSB9O1xuICAgIHJldHVybiBlbmNyeXB0KHJlY2VpdmVyUHVibGljS2V5LCBwYWRkZWRNc2dQYXJhbXMsIHZlcnNpb24pO1xufVxuZXhwb3J0cy5lbmNyeXB0U2FmZWx5ID0gZW5jcnlwdFNhZmVseTtcbmZ1bmN0aW9uIGRlY3J5cHQoZW5jcnlwdGVkRGF0YSwgcmVjZWl2ZXJQcml2YXRlS2V5KSB7XG4gICAgc3dpdGNoIChlbmNyeXB0ZWREYXRhLnZlcnNpb24pIHtcbiAgICAgICAgY2FzZSAneDI1NTE5LXhzYWxzYTIwLXBvbHkxMzA1Jzoge1xuICAgICAgICAgICAgLy8gc3RyaW5nIHRvIGJ1ZmZlciB0byBVSW50OEFycmF5XG4gICAgICAgICAgICBjb25zdCByZWNpZXZlclByaXZhdGVLZXlVaW50OEFycmF5ID0gbmFjbF9kZWNvZGVIZXgocmVjZWl2ZXJQcml2YXRlS2V5KTtcbiAgICAgICAgICAgIGNvbnN0IHJlY2lldmVyRW5jcnlwdGlvblByaXZhdGVLZXkgPSBuYWNsLmJveC5rZXlQYWlyLmZyb21TZWNyZXRLZXkocmVjaWV2ZXJQcml2YXRlS2V5VWludDhBcnJheSkuc2VjcmV0S2V5O1xuICAgICAgICAgICAgLy8gYXNzZW1ibGUgZGVjcnlwdGlvbiBwYXJhbWV0ZXJzXG4gICAgICAgICAgICBjb25zdCBub25jZSA9IG5hY2xVdGlsLmRlY29kZUJhc2U2NChlbmNyeXB0ZWREYXRhLm5vbmNlKTtcbiAgICAgICAgICAgIGNvbnN0IGNpcGhlcnRleHQgPSBuYWNsVXRpbC5kZWNvZGVCYXNlNjQoZW5jcnlwdGVkRGF0YS5jaXBoZXJ0ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IGVwaGVtUHVibGljS2V5ID0gbmFjbFV0aWwuZGVjb2RlQmFzZTY0KGVuY3J5cHRlZERhdGEuZXBoZW1QdWJsaWNLZXkpO1xuICAgICAgICAgICAgLy8gZGVjcnlwdFxuICAgICAgICAgICAgY29uc3QgZGVjcnlwdGVkTWVzc2FnZSA9IG5hY2wuYm94Lm9wZW4oY2lwaGVydGV4dCwgbm9uY2UsIGVwaGVtUHVibGljS2V5LCByZWNpZXZlckVuY3J5cHRpb25Qcml2YXRlS2V5KTtcbiAgICAgICAgICAgIC8vIHJldHVybiBkZWNyeXB0ZWQgbXNnIGRhdGFcbiAgICAgICAgICAgIGxldCBvdXRwdXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG5hY2xVdGlsLmVuY29kZVVURjgoZGVjcnlwdGVkTWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNyeXB0aW9uIGZhaWxlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNyeXB0aW9uIGZhaWxlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIHR5cGUvdmVyc2lvbiBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVjcnlwdCA9IGRlY3J5cHQ7XG5mdW5jdGlvbiBkZWNyeXB0U2FmZWx5KGVuY3J5cHRlZERhdGEsIHJlY2VpdmVyUHJpdmF0ZUtleSkge1xuICAgIGNvbnN0IGRhdGFXaXRoUGFkZGluZyA9IEpTT04ucGFyc2UoZGVjcnlwdChlbmNyeXB0ZWREYXRhLCByZWNlaXZlclByaXZhdGVLZXkpKTtcbiAgICByZXR1cm4gZGF0YVdpdGhQYWRkaW5nLmRhdGE7XG59XG5leHBvcnRzLmRlY3J5cHRTYWZlbHkgPSBkZWNyeXB0U2FmZWx5O1xuZnVuY3Rpb24gZ2V0RW5jcnlwdGlvblB1YmxpY0tleShwcml2YXRlS2V5KSB7XG4gICAgY29uc3QgcHJpdmF0ZUtleVVpbnQ4QXJyYXkgPSBuYWNsX2RlY29kZUhleChwcml2YXRlS2V5KTtcbiAgICBjb25zdCBlbmNyeXB0aW9uUHVibGljS2V5ID0gbmFjbC5ib3gua2V5UGFpci5mcm9tU2VjcmV0S2V5KHByaXZhdGVLZXlVaW50OEFycmF5KS5wdWJsaWNLZXk7XG4gICAgcmV0dXJuIG5hY2xVdGlsLmVuY29kZUJhc2U2NChlbmNyeXB0aW9uUHVibGljS2V5KTtcbn1cbmV4cG9ydHMuZ2V0RW5jcnlwdGlvblB1YmxpY0tleSA9IGdldEVuY3J5cHRpb25QdWJsaWNLZXk7XG4vKipcbiAqIEEgZ2VuZXJpYyBlbnRyeSBwb2ludCBmb3IgYWxsIHR5cGVkIGRhdGEgbWV0aG9kcyB0byBiZSBwYXNzZWQsIGluY2x1ZGVzIGEgdmVyc2lvbiBwYXJhbWV0ZXIuXG4gKi9cbmZ1bmN0aW9uIHNpZ25UeXBlZE1lc3NhZ2UocHJpdmF0ZUtleSwgbXNnUGFyYW1zLCB2ZXJzaW9uID0gJ1Y0Jykge1xuICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgICAgICBjYXNlICdWMSc6XG4gICAgICAgICAgICByZXR1cm4gc2lnblR5cGVkRGF0YUxlZ2FjeShwcml2YXRlS2V5LCBtc2dQYXJhbXMpO1xuICAgICAgICBjYXNlICdWMyc6XG4gICAgICAgICAgICByZXR1cm4gc2lnblR5cGVkRGF0YShwcml2YXRlS2V5LCBtc2dQYXJhbXMpO1xuICAgICAgICBjYXNlICdWNCc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc2lnblR5cGVkRGF0YV92NChwcml2YXRlS2V5LCBtc2dQYXJhbXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuc2lnblR5cGVkTWVzc2FnZSA9IHNpZ25UeXBlZE1lc3NhZ2U7XG5mdW5jdGlvbiByZWNvdmVyVHlwZWRNZXNzYWdlKG1zZ1BhcmFtcywgdmVyc2lvbiA9ICdWNCcpIHtcbiAgICBzd2l0Y2ggKHZlcnNpb24pIHtcbiAgICAgICAgY2FzZSAnVjEnOlxuICAgICAgICAgICAgcmV0dXJuIHJlY292ZXJUeXBlZFNpZ25hdHVyZUxlZ2FjeShtc2dQYXJhbXMpO1xuICAgICAgICBjYXNlICdWMyc6XG4gICAgICAgICAgICByZXR1cm4gcmVjb3ZlclR5cGVkU2lnbmF0dXJlKG1zZ1BhcmFtcyk7XG4gICAgICAgIGNhc2UgJ1Y0JzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiByZWNvdmVyVHlwZWRTaWduYXR1cmVfdjQobXNnUGFyYW1zKTtcbiAgICB9XG59XG5leHBvcnRzLnJlY292ZXJUeXBlZE1lc3NhZ2UgPSByZWNvdmVyVHlwZWRNZXNzYWdlO1xuZnVuY3Rpb24gc2lnblR5cGVkRGF0YShwcml2YXRlS2V5LCBtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gVHlwZWREYXRhVXRpbHMuc2lnbihtc2dQYXJhbXMuZGF0YSwgZmFsc2UpO1xuICAgIGNvbnN0IHNpZyA9IGV0aFV0aWwuZWNzaWduKG1lc3NhZ2UsIHByaXZhdGVLZXkpO1xuICAgIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KGNvbmNhdFNpZyhzaWcudiwgc2lnLnIsIHNpZy5zKSk7XG59XG5leHBvcnRzLnNpZ25UeXBlZERhdGEgPSBzaWduVHlwZWREYXRhO1xuZnVuY3Rpb24gc2lnblR5cGVkRGF0YV92NChwcml2YXRlS2V5LCBtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gVHlwZWREYXRhVXRpbHMuc2lnbihtc2dQYXJhbXMuZGF0YSk7XG4gICAgY29uc3Qgc2lnID0gZXRoVXRpbC5lY3NpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSk7XG4gICAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgoY29uY2F0U2lnKHNpZy52LCBzaWcuciwgc2lnLnMpKTtcbn1cbmV4cG9ydHMuc2lnblR5cGVkRGF0YV92NCA9IHNpZ25UeXBlZERhdGFfdjQ7XG5mdW5jdGlvbiByZWNvdmVyVHlwZWRTaWduYXR1cmUobXNnUGFyYW1zKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IFR5cGVkRGF0YVV0aWxzLnNpZ24obXNnUGFyYW1zLmRhdGEsIGZhbHNlKTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSByZWNvdmVyUHVibGljS2V5KG1lc3NhZ2UsIG1zZ1BhcmFtcy5zaWcpO1xuICAgIGNvbnN0IHNlbmRlciA9IGV0aFV0aWwucHVibGljVG9BZGRyZXNzKHB1YmxpY0tleSk7XG4gICAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgoc2VuZGVyKTtcbn1cbmV4cG9ydHMucmVjb3ZlclR5cGVkU2lnbmF0dXJlID0gcmVjb3ZlclR5cGVkU2lnbmF0dXJlO1xuZnVuY3Rpb24gcmVjb3ZlclR5cGVkU2lnbmF0dXJlX3Y0KG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBUeXBlZERhdGFVdGlscy5zaWduKG1zZ1BhcmFtcy5kYXRhKTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSByZWNvdmVyUHVibGljS2V5KG1lc3NhZ2UsIG1zZ1BhcmFtcy5zaWcpO1xuICAgIGNvbnN0IHNlbmRlciA9IGV0aFV0aWwucHVibGljVG9BZGRyZXNzKHB1YmxpY0tleSk7XG4gICAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgoc2VuZGVyKTtcbn1cbmV4cG9ydHMucmVjb3ZlclR5cGVkU2lnbmF0dXJlX3Y0ID0gcmVjb3ZlclR5cGVkU2lnbmF0dXJlX3Y0O1xuLyoqXG4gKiBAcGFyYW0gdHlwZWREYXRhIC0gQXJyYXkgb2YgZGF0YSBhbG9uZyB3aXRoIHR5cGVzLCBhcyBwZXIgRUlQNzEyLlxuICogQHJldHVybnMgQnVmZmVyXG4gKi9cbmZ1bmN0aW9uIHR5cGVkU2lnbmF0dXJlSGFzaCh0eXBlZERhdGEpIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignRXhwZWN0IGFyZ3VtZW50IHRvIGJlIG5vbi1lbXB0eSBhcnJheScpO1xuICAgIGlmICh0eXBlb2YgdHlwZWREYXRhICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAhKCdsZW5ndGgnIGluIHR5cGVkRGF0YSkgfHxcbiAgICAgICAgIXR5cGVkRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB0eXBlZERhdGEubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLnR5cGUgPT09ICdieXRlcycgPyBldGhVdGlsLnRvQnVmZmVyKGUudmFsdWUpIDogZS52YWx1ZTtcbiAgICB9KTtcbiAgICBjb25zdCB0eXBlcyA9IHR5cGVkRGF0YS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUudHlwZTtcbiAgICB9KTtcbiAgICBjb25zdCBzY2hlbWEgPSB0eXBlZERhdGEubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghZS5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7ZS50eXBlfSAke2UubmFtZX1gO1xuICAgIH0pO1xuICAgIHJldHVybiBldGhBYmkuc29saWRpdHlTSEEzKFsnYnl0ZXMzMicsICdieXRlczMyJ10sIFtcbiAgICAgICAgZXRoQWJpLnNvbGlkaXR5U0hBMyhuZXcgQXJyYXkodHlwZWREYXRhLmxlbmd0aCkuZmlsbCgnc3RyaW5nJyksIHNjaGVtYSksXG4gICAgICAgIGV0aEFiaS5zb2xpZGl0eVNIQTModHlwZXMsIGRhdGEpLFxuICAgIF0pO1xufVxuZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleShoYXNoLCBzaWcpIHtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBldGhVdGlsLnRvQnVmZmVyKHNpZyk7XG4gICAgY29uc3Qgc2lnUGFyYW1zID0gZXRoVXRpbC5mcm9tUnBjU2lnKHNpZ25hdHVyZSk7XG4gICAgcmV0dXJuIGV0aFV0aWwuZWNyZWNvdmVyKGhhc2gsIHNpZ1BhcmFtcy52LCBzaWdQYXJhbXMuciwgc2lnUGFyYW1zLnMpO1xufVxuZnVuY3Rpb24gZ2V0UHVibGljS2V5Rm9yKG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBldGhVdGlsLnRvQnVmZmVyKG1zZ1BhcmFtcy5kYXRhKTtcbiAgICBjb25zdCBtc2dIYXNoID0gZXRoVXRpbC5oYXNoUGVyc29uYWxNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIHJldHVybiByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gsIG1zZ1BhcmFtcy5zaWcpO1xufVxuZnVuY3Rpb24gcGFkV2l0aFplcm9lcyhudW1iZXIsIGxlbmd0aCkge1xuICAgIGxldCBteVN0cmluZyA9IGAke251bWJlcn1gO1xuICAgIHdoaWxlIChteVN0cmluZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgbXlTdHJpbmcgPSBgMCR7bXlTdHJpbmd9YDtcbiAgICB9XG4gICAgcmV0dXJuIG15U3RyaW5nO1xufVxuLy8gY29udmVydHMgaGV4IHN0cmluZ3MgdG8gdGhlIFVpbnQ4QXJyYXkgZm9ybWF0IHVzZWQgYnkgbmFjbFxuZnVuY3Rpb24gbmFjbF9kZWNvZGVIZXgobXNnSGV4KSB7XG4gICAgY29uc3QgbXNnQmFzZTY0ID0gQnVmZmVyLmZyb20obXNnSGV4LCAnaGV4JykudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIHJldHVybiBuYWNsVXRpbC5kZWNvZGVCYXNlNjQobXNnQmFzZTY0KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxudmFyIG9iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuLy8gY29tcGFyZSBhbmQgaXNCdWZmZXIgdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iLzY4MGU5ZTVlNDg4ZjIyYWFjMjc1OTlhNTdkYzg0NGE2MzE1OTI4ZGQvaW5kZXguanNcbi8vIG9yaWdpbmFsIG5vdGljZTpcblxuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgeCA9IGEubGVuZ3RoO1xuICB2YXIgeSA9IGIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldO1xuICAgICAgeSA9IGJbaV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHkgPCB4KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBpc0J1ZmZlcihiKSB7XG4gIGlmIChnbG9iYWwuQnVmZmVyICYmIHR5cGVvZiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIoYik7XG4gIH1cbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcik7XG59XG5cbi8vIGJhc2VkIG9uIG5vZGUgYXNzZXJ0LCBvcmlnaW5hbCBub3RpY2U6XG4vLyBOQjogVGhlIFVSTCB0byB0aGUgQ29tbW9uSlMgc3BlYyBpcyBrZXB0IGp1c3QgZm9yIHRyYWRpdGlvbi5cbi8vICAgICBub2RlLWFzc2VydCBoYXMgZXZvbHZlZCBhIGxvdCBzaW5jZSB0aGVuLCBib3RoIGluIEFQSSBhbmQgYmVoYXZpb3IuXG5cbi8vIGh0dHA6Ly93aWtpLmNvbW1vbmpzLm9yZy93aWtpL1VuaXRfVGVzdGluZy8xLjBcbi8vXG4vLyBUSElTIElTIE5PVCBURVNURUQgTk9SIExJS0VMWSBUTyBXT1JLIE9VVFNJREUgVjghXG4vL1xuLy8gT3JpZ2luYWxseSBmcm9tIG5hcndoYWwuanMgKGh0dHA6Ly9uYXJ3aGFsanMub3JnKVxuLy8gQ29weXJpZ2h0IChjKSAyMDA5IFRob21hcyBSb2JpbnNvbiA8Mjgwbm9ydGguY29tPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlICdTb2Z0d2FyZScpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnQVMgSVMnLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbi8vIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwvJyk7XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgZnVuY3Rpb25zSGF2ZU5hbWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbygpIHt9Lm5hbWUgPT09ICdmb28nO1xufSgpKTtcbmZ1bmN0aW9uIHBUb1N0cmluZyAob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbn1cbmZ1bmN0aW9uIGlzVmlldyhhcnJidWYpIHtcbiAgaWYgKGlzQnVmZmVyKGFycmJ1ZikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBnbG9iYWwuQXJyYXlCdWZmZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KGFycmJ1Zik7XG4gIH1cbiAgaWYgKCFhcnJidWYpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFycmJ1ZiBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGFycmJ1Zi5idWZmZXIgJiYgYXJyYnVmLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxudmFyIHJlZ2V4ID0gL1xccypmdW5jdGlvblxccysoW15cXChcXHNdKilcXHMqLztcbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvZnVuY3Rpb24ucHJvdG90eXBlLm5hbWUvYmxvYi9hZGVlZWVjOGJmY2M2MDY4YjE4N2Q3ZDlmYjNkNWJiMWQzYTMwODk5L2ltcGxlbWVudGF0aW9uLmpzXG5mdW5jdGlvbiBnZXROYW1lKGZ1bmMpIHtcbiAgaWYgKCF1dGlsLmlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcykge1xuICAgIHJldHVybiBmdW5jLm5hbWU7XG4gIH1cbiAgdmFyIHN0ciA9IGZ1bmMudG9TdHJpbmcoKTtcbiAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKHJlZ2V4KTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdO1xufVxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIG5vbiB2OCBicm93c2VycyBzbyB3ZSBjYW4gaGF2ZSBhIHN0YWNrdHJhY2VcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgdmFyIG91dCA9IGVyci5zdGFjaztcblxuICAgICAgLy8gdHJ5IHRvIHN0cmlwIHVzZWxlc3MgZnJhbWVzXG4gICAgICB2YXIgZm5fbmFtZSA9IGdldE5hbWUoc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgICAgIHZhciBpZHggPSBvdXQuaW5kZXhPZignXFxuJyArIGZuX25hbWUpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIC8vIG9uY2Ugd2UgaGF2ZSBsb2NhdGVkIHRoZSBmdW5jdGlvbiBmcmFtZVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHN0cmlwIG91dCBldmVyeXRoaW5nIGJlZm9yZSBpdCAoYW5kIGl0cyBsaW5lKVxuICAgICAgICB2YXIgbmV4dF9saW5lID0gb3V0LmluZGV4T2YoJ1xcbicsIGlkeCArIDEpO1xuICAgICAgICBvdXQgPSBvdXQuc3Vic3RyaW5nKG5leHRfbGluZSArIDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YWNrID0gb3V0O1xuICAgIH1cbiAgfVxufTtcblxuLy8gYXNzZXJ0LkFzc2VydGlvbkVycm9yIGluc3RhbmNlb2YgRXJyb3JcbnV0aWwuaW5oZXJpdHMoYXNzZXJ0LkFzc2VydGlvbkVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHtcbiAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzLmxlbmd0aCA8IG4gPyBzIDogcy5zbGljZSgwLCBuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuZnVuY3Rpb24gaW5zcGVjdChzb21ldGhpbmcpIHtcbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcyB8fCAhdXRpbC5pc0Z1bmN0aW9uKHNvbWV0aGluZykpIHtcbiAgICByZXR1cm4gdXRpbC5pbnNwZWN0KHNvbWV0aGluZyk7XG4gIH1cbiAgdmFyIHJhd25hbWUgPSBnZXROYW1lKHNvbWV0aGluZyk7XG4gIHZhciBuYW1lID0gcmF3bmFtZSA/ICc6ICcgKyByYXduYW1lIDogJyc7XG4gIHJldHVybiAnW0Z1bmN0aW9uJyArICBuYW1lICsgJ10nO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKSB7XG4gIHJldHVybiB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuYWN0dWFsKSwgMTI4KSArICcgJyArXG4gICAgICAgICBzZWxmLm9wZXJhdG9yICsgJyAnICtcbiAgICAgICAgIHRydW5jYXRlKGluc3BlY3Qoc2VsZi5leHBlY3RlZCksIDEyOCk7XG59XG5cbi8vIEF0IHByZXNlbnQgb25seSB0aGUgdGhyZWUga2V5cyBtZW50aW9uZWQgYWJvdmUgYXJlIHVzZWQgYW5kXG4vLyB1bmRlcnN0b29kIGJ5IHRoZSBzcGVjLiBJbXBsZW1lbnRhdGlvbnMgb3Igc3ViIG1vZHVsZXMgY2FuIHBhc3Ncbi8vIG90aGVyIGtleXMgdG8gdGhlIEFzc2VydGlvbkVycm9yJ3MgY29uc3RydWN0b3IgLSB0aGV5IHdpbGwgYmVcbi8vIGlnbm9yZWQuXG5cbi8vIDMuIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuICBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3Jcbi8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGdW5jdGlvbikge1xuICB0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBzdGFja1N0YXJ0RnVuY3Rpb25cbiAgfSk7XG59XG5cbi8vIEVYVEVOU0lPTiEgYWxsb3dzIGZvciB3ZWxsIGJlaGF2ZWQgZXJyb3JzIGRlZmluZWQgZWxzZXdoZXJlLlxuYXNzZXJ0LmZhaWwgPSBmYWlsO1xuXG4vLyA0LiBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIWd1YXJkLlxuLy8gYXNzZXJ0Lm9rKGd1YXJkLCBtZXNzYWdlX29wdCk7XG4vLyBUaGlzIHN0YXRlbWVudCBpcyBlcXVpdmFsZW50IHRvIGFzc2VydC5lcXVhbCh0cnVlLCAhIWd1YXJkLFxuLy8gbWVzc2FnZV9vcHQpOy4gVG8gdGVzdCBzdHJpY3RseSBmb3IgdGhlIHZhbHVlIHRydWUsIHVzZVxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKHRydWUsIGd1YXJkLCBtZXNzYWdlX29wdCk7LlxuXG5mdW5jdGlvbiBvayh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQub2spO1xufVxuYXNzZXJ0Lm9rID0gb2s7XG5cbi8vIDUuIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aFxuLy8gPT0uXG4vLyBhc3NlcnQuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09JywgYXNzZXJ0LmVxdWFsKTtcbn07XG5cbi8vIDYuIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3QgZXF1YWxcbi8vIHdpdGggIT0gYXNzZXJ0Lm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT0nLCBhc3NlcnQubm90RXF1YWwpO1xuICB9XG59O1xuXG4vLyA3LiBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cbi8vIGFzc2VydC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZhbHNlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5hc3NlcnQuZGVlcFN0cmljdEVxdWFsID0gZnVuY3Rpb24gZGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcFN0cmljdEVxdWFsJywgYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0LCBtZW1vcykge1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICYmIGlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBjb21wYXJlKGFjdHVhbCwgZXhwZWN0ZWQpID09PSAwO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzRGF0ZShhY3R1YWwpICYmIHV0aWwuaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzUmVnRXhwKGFjdHVhbCkgJiYgdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLnNvdXJjZSA9PT0gZXhwZWN0ZWQuc291cmNlICYmXG4gICAgICAgICAgIGFjdHVhbC5nbG9iYWwgPT09IGV4cGVjdGVkLmdsb2JhbCAmJlxuICAgICAgICAgICBhY3R1YWwubXVsdGlsaW5lID09PSBleHBlY3RlZC5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgYWN0dWFsLmxhc3RJbmRleCA9PT0gZXhwZWN0ZWQubGFzdEluZGV4ICYmXG4gICAgICAgICAgIGFjdHVhbC5pZ25vcmVDYXNlID09PSBleHBlY3RlZC5pZ25vcmVDYXNlO1xuXG4gIC8vIDcuNC4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICgoYWN0dWFsID09PSBudWxsIHx8IHR5cGVvZiBhY3R1YWwgIT09ICdvYmplY3QnKSAmJlxuICAgICAgICAgICAgIChleHBlY3RlZCA9PT0gbnVsbCB8fCB0eXBlb2YgZXhwZWN0ZWQgIT09ICdvYmplY3QnKSkge1xuICAgIHJldHVybiBzdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIElmIGJvdGggdmFsdWVzIGFyZSBpbnN0YW5jZXMgb2YgdHlwZWQgYXJyYXlzLCB3cmFwIHRoZWlyIHVuZGVybHlpbmdcbiAgLy8gQXJyYXlCdWZmZXJzIGluIGEgQnVmZmVyIGVhY2ggdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2VcbiAgLy8gVGhpcyBvcHRpbWl6YXRpb24gcmVxdWlyZXMgdGhlIGFycmF5cyB0byBoYXZlIHRoZSBzYW1lIHR5cGUgYXMgY2hlY2tlZCBieVxuICAvLyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nIChha2EgcFRvU3RyaW5nKS4gTmV2ZXIgcGVyZm9ybSBiaW5hcnlcbiAgLy8gY29tcGFyaXNvbnMgZm9yIEZsb2F0KkFycmF5cywgdGhvdWdoLCBzaW5jZSBlLmcuICswID09PSAtMCBidXQgdGhlaXJcbiAgLy8gYml0IHBhdHRlcm5zIGFyZSBub3QgaWRlbnRpY2FsLlxuICB9IGVsc2UgaWYgKGlzVmlldyhhY3R1YWwpICYmIGlzVmlldyhleHBlY3RlZCkgJiZcbiAgICAgICAgICAgICBwVG9TdHJpbmcoYWN0dWFsKSA9PT0gcFRvU3RyaW5nKGV4cGVjdGVkKSAmJlxuICAgICAgICAgICAgICEoYWN0dWFsIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8XG4gICAgICAgICAgICAgICBhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYWN0dWFsLmJ1ZmZlciksXG4gICAgICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZXhwZWN0ZWQuYnVmZmVyKSkgPT09IDA7XG5cbiAgLy8gNy41IEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICE9PSBpc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgbWVtb3MgPSBtZW1vcyB8fCB7YWN0dWFsOiBbXSwgZXhwZWN0ZWQ6IFtdfTtcblxuICAgIHZhciBhY3R1YWxJbmRleCA9IG1lbW9zLmFjdHVhbC5pbmRleE9mKGFjdHVhbCk7XG4gICAgaWYgKGFjdHVhbEluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGFjdHVhbEluZGV4ID09PSBtZW1vcy5leHBlY3RlZC5pbmRleE9mKGV4cGVjdGVkKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vcy5hY3R1YWwucHVzaChhY3R1YWwpO1xuICAgIG1lbW9zLmV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xuXG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdCwgbWVtb3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIHN0cmljdCwgYWN0dWFsVmlzaXRlZE9iamVjdHMpIHtcbiAgaWYgKGEgPT09IG51bGwgfHwgYSA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IG51bGwgfHwgYiA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gaWYgb25lIGlzIGEgcHJpbWl0aXZlLCB0aGUgb3RoZXIgbXVzdCBiZSBzYW1lXG4gIGlmICh1dGlsLmlzUHJpbWl0aXZlKGEpIHx8IHV0aWwuaXNQcmltaXRpdmUoYikpXG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIGlmIChzdHJpY3QgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGEpICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB2YXIgYUlzQXJncyA9IGlzQXJndW1lbnRzKGEpO1xuICB2YXIgYklzQXJncyA9IGlzQXJndW1lbnRzKGIpO1xuICBpZiAoKGFJc0FyZ3MgJiYgIWJJc0FyZ3MpIHx8ICghYUlzQXJncyAmJiBiSXNBcmdzKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChhSXNBcmdzKSB7XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gX2RlZXBFcXVhbChhLCBiLCBzdHJpY3QpO1xuICB9XG4gIHZhciBrYSA9IG9iamVjdEtleXMoYSk7XG4gIHZhciBrYiA9IG9iamVjdEtleXMoYik7XG4gIHZhciBrZXksIGk7XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT09IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9PSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgc3RyaWN0LCBhY3R1YWxWaXNpdGVkT2JqZWN0cykpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwRXF1YWwnLCBhc3NlcnQubm90RGVlcEVxdWFsKTtcbiAgfVxufTtcblxuYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbCA9IG5vdERlZXBTdHJpY3RFcXVhbDtcbmZ1bmN0aW9uIG5vdERlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcFN0cmljdEVxdWFsJywgbm90RGVlcFN0cmljdEVxdWFsKTtcbiAgfVxufVxuXG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJZ25vcmUuICBUaGUgaW5zdGFuY2VvZiBjaGVjayBkb2Vzbid0IHdvcmsgZm9yIGFycm93IGZ1bmN0aW9ucy5cbiAgfVxuXG4gIGlmIChFcnJvci5pc1Byb3RvdHlwZU9mKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlO1xufVxuXG5mdW5jdGlvbiBfdHJ5QmxvY2soYmxvY2spIHtcbiAgdmFyIGVycm9yO1xuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvciA9IGU7XG4gIH1cbiAgcmV0dXJuIGVycm9yO1xufVxuXG5mdW5jdGlvbiBfdGhyb3dzKHNob3VsZFRocm93LCBibG9jaywgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGFjdHVhbDtcblxuICBpZiAodHlwZW9mIGJsb2NrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJibG9ja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gZXhwZWN0ZWQ7XG4gICAgZXhwZWN0ZWQgPSBudWxsO1xuICB9XG5cbiAgYWN0dWFsID0gX3RyeUJsb2NrKGJsb2NrKTtcblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIHZhciB1c2VyUHJvdmlkZWRNZXNzYWdlID0gdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnO1xuICB2YXIgaXNVbndhbnRlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiB1dGlsLmlzRXJyb3IoYWN0dWFsKTtcbiAgdmFyIGlzVW5leHBlY3RlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgIWV4cGVjdGVkO1xuXG4gIGlmICgoaXNVbndhbnRlZEV4Y2VwdGlvbiAmJlxuICAgICAgdXNlclByb3ZpZGVkTWVzc2FnZSAmJlxuICAgICAgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8XG4gICAgICBpc1VuZXhwZWN0ZWRFeGNlcHRpb24pIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3ModHJ1ZSwgYmxvY2ssIGVycm9yLCBtZXNzYWdlKTtcbn07XG5cbi8vIEVYVEVOU0lPTiEgVGhpcyBpcyBhbm5veWluZyB0byB3cml0ZSBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzKGZhbHNlLCBibG9jaywgZXJyb3IsIG1lc3NhZ2UpO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbihlcnIpIHsgaWYgKGVycikgdGhyb3cgZXJyOyB9O1xuXG4vLyBFeHBvc2UgYSBzdHJpY3Qgb25seSB2YXJpYW50IG9mIGFzc2VydFxuZnVuY3Rpb24gc3RyaWN0KHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIGZhaWwodmFsdWUsIHRydWUsIG1lc3NhZ2UsICc9PScsIHN0cmljdCk7XG59XG5hc3NlcnQuc3RyaWN0ID0gb2JqZWN0QXNzaWduKHN0cmljdCwgYXNzZXJ0LCB7XG4gIGVxdWFsOiBhc3NlcnQuc3RyaWN0RXF1YWwsXG4gIGRlZXBFcXVhbDogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCxcbiAgbm90RXF1YWw6IGFzc2VydC5ub3RTdHJpY3RFcXVhbCxcbiAgbm90RGVlcEVxdWFsOiBhc3NlcnQubm90RGVlcFN0cmljdEVxdWFsXG59KTtcbmFzc2VydC5zdHJpY3Quc3RyaWN0ID0gYXNzZXJ0LnN0cmljdDtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWYWxpZGF0b3IgPSBtb2R1bGUuZXhwb3J0cy5WYWxpZGF0b3IgPSByZXF1aXJlKCcuL3ZhbGlkYXRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cy5WYWxpZGF0b3JSZXN1bHQgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5WYWxpZGF0b3JSZXN1bHQ7XG5tb2R1bGUuZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5WYWxpZGF0aW9uRXJyb3I7XG5tb2R1bGUuZXhwb3J0cy5TY2hlbWFFcnJvciA9IHJlcXVpcmUoJy4vaGVscGVycycpLlNjaGVtYUVycm9yO1xubW9kdWxlLmV4cG9ydHMuU2NoZW1hU2NhblJlc3VsdCA9IHJlcXVpcmUoJy4vc2NhbicpLlNjaGVtYVNjYW5SZXN1bHQ7XG5tb2R1bGUuZXhwb3J0cy5zY2FuID0gcmVxdWlyZSgnLi9zY2FuJykuc2NhbjtcblxubW9kdWxlLmV4cG9ydHMudmFsaWRhdGUgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucykge1xuICB2YXIgdiA9IG5ldyBWYWxpZGF0b3IoKTtcbiAgcmV0dXJuIHYudmFsaWRhdGUoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucyk7XG59O1xuIiwiZXhwb3J0IGNvbnN0IHJlYWRBZGRyZXNzQXNDb250cmFjdCA9IGFzeW5jIChldGhRdWVyeSwgYWRkcmVzcykgPT4ge1xuICBsZXQgY29udHJhY3RDb2RlO1xuICB0cnkge1xuICAgIGNvbnRyYWN0Q29kZSA9IGF3YWl0IGV0aFF1ZXJ5LmdldENvZGUoYWRkcmVzcyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb250cmFjdENvZGUgPSBudWxsO1xuICB9XG5cbiAgY29uc3QgaXNDb250cmFjdEFkZHJlc3MgPVxuICAgIGNvbnRyYWN0Q29kZSAmJiBjb250cmFjdENvZGUgIT09ICcweCcgJiYgY29udHJhY3RDb2RlICE9PSAnMHgwJztcbiAgcmV0dXJuIHsgY29udHJhY3RDb2RlLCBpc0NvbnRyYWN0QWRkcmVzcyB9O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldvcmRsaXN0ID0gZXhwb3J0cy52ZXJzaW9uID0gZXhwb3J0cy53b3JkbGlzdHMgPSBleHBvcnRzLnV0aWxzID0gZXhwb3J0cy5sb2dnZXIgPSBleHBvcnRzLmVycm9ycyA9IGV4cG9ydHMuY29uc3RhbnRzID0gZXhwb3J0cy5GaXhlZE51bWJlciA9IGV4cG9ydHMuQmlnTnVtYmVyID0gZXhwb3J0cy5Db250cmFjdEZhY3RvcnkgPSBleHBvcnRzLkNvbnRyYWN0ID0gZXhwb3J0cy5CYXNlQ29udHJhY3QgPSBleHBvcnRzLnByb3ZpZGVycyA9IGV4cG9ydHMuZ2V0RGVmYXVsdFByb3ZpZGVyID0gZXhwb3J0cy5Wb2lkU2lnbmVyID0gZXhwb3J0cy5XYWxsZXQgPSBleHBvcnRzLlNpZ25lciA9IGV4cG9ydHMuZXRoZXJzID0gdm9pZCAwO1xuLy8gVG8gbW9kaWZ5IHRoaXMgZmlsZSwgeW91IG11c3QgdXBkYXRlIC4vbWlzYy9hZG1pbi9saWIvY21kcy91cGRhdGUtZXhwb3J0cy5qc1xudmFyIGV0aGVycyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9ldGhlcnNcIikpO1xuZXhwb3J0cy5ldGhlcnMgPSBldGhlcnM7XG50cnkge1xuICAgIHZhciBhbnlHbG9iYWwgPSB3aW5kb3c7XG4gICAgaWYgKGFueUdsb2JhbC5fZXRoZXJzID09IG51bGwpIHtcbiAgICAgICAgYW55R2xvYmFsLl9ldGhlcnMgPSBldGhlcnM7XG4gICAgfVxufVxuY2F0Y2ggKGVycm9yKSB7IH1cbnZhciBldGhlcnNfMSA9IHJlcXVpcmUoXCIuL2V0aGVyc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNpZ25lclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXRoZXJzXzEuU2lnbmVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV2FsbGV0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldGhlcnNfMS5XYWxsZXQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWb2lkU2lnbmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldGhlcnNfMS5Wb2lkU2lnbmVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0RGVmYXVsdFByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldGhlcnNfMS5nZXREZWZhdWx0UHJvdmlkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwcm92aWRlcnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV0aGVyc18xLnByb3ZpZGVyczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJhc2VDb250cmFjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXRoZXJzXzEuQmFzZUNvbnRyYWN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29udHJhY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV0aGVyc18xLkNvbnRyYWN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29udHJhY3RGYWN0b3J5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldGhlcnNfMS5Db250cmFjdEZhY3Rvcnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCaWdOdW1iZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV0aGVyc18xLkJpZ051bWJlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZpeGVkTnVtYmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldGhlcnNfMS5GaXhlZE51bWJlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbnN0YW50c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXRoZXJzXzEuY29uc3RhbnRzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXJyb3JzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldGhlcnNfMS5lcnJvcnM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsb2dnZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV0aGVyc18xLmxvZ2dlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInV0aWxzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldGhlcnNfMS51dGlsczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIndvcmRsaXN0c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXRoZXJzXzEud29yZGxpc3RzOyB9IH0pO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBDb21waWxlLVRpbWUgQ29uc3RhbnRzXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2ZXJzaW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldGhlcnNfMS52ZXJzaW9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29yZGxpc3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV0aGVyc18xLldvcmRsaXN0OyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1ldGhvZFJlZ2lzdHJ5ID0gdm9pZCAwO1xuY29uc3QgZXRoanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZXRoanNcIikpO1xuY29uc3QgcmVnaXN0cnlfbWFwX2pzb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9yZWdpc3RyeS1tYXAuanNvblwiKSk7XG5jb25zdCBhYmlfanNvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FiaS5qc29uXCIpKTtcbmNsYXNzIE1ldGhvZFJlZ2lzdHJ5IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIGlmICghb3B0cy5wcm92aWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCAncHJvdmlkZXInIG9wdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb3ZpZGVyID0gb3B0cy5wcm92aWRlcjtcbiAgICAgICAgdGhpcy5ldGggPSBuZXcgZXRoanNfMS5kZWZhdWx0KHRoaXMucHJvdmlkZXIpO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gcmVnaXN0cnlfbWFwX2pzb25fMS5kZWZhdWx0W29wdHMubmV0d29yayB8fCAnMSddO1xuICAgICAgICBpZiAoIWFkZHJlc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gbWV0aG9kIHJlZ2lzdHJ5IGZvdW5kIG9uIHRoZSByZXF1ZXN0ZWQgbmV0d29yay4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZ2lzdHJ5ID0gdGhpcy5ldGguY29udHJhY3QoYWJpX2pzb25fMS5kZWZhdWx0KS5hdChhZGRyZXNzKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEBwYXJhbSBieXRlcyAtIFRoZSBgMHhgLXByZWZpeGVkIGhleGFkZWNpbWFsIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGZvdXItYnl0ZSBzaWduYXR1cmUgb2YgdGhlIGNvbnRyYWN0IG1ldGhvZCB0byBsb29rdXAuXG4gICAqL1xuICAgIGFzeW5jIGxvb2t1cChieXRlcykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlZ2lzdHJ5LmVudHJpZXMoYnl0ZXMpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0WzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHBhcnNlKHNpZ25hdHVyZSkge1xuICAgICAgICBjb25zdCByYXdOYW1lID0gc2lnbmF0dXJlLm1hdGNoKC9eKFteKShdKilcXCgoLiopXFwpKFteKShdKikkL3UpO1xuICAgICAgICBsZXQgcGFyc2VkTmFtZTtcbiAgICAgICAgaWYgKHJhd05hbWUpIHtcbiAgICAgICAgICAgIHBhcnNlZE5hbWUgPSByYXdOYW1lWzFdLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcmF3TmFtZVsxXS5zbGljZSgxKS5zcGxpdCgvKD89W0EtWl0pL3UpLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlZE5hbWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmF3TmFtZSkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBzaWduYXR1cmUubWF0Y2gobmV3IFJlZ0V4cChgJHtyYXdOYW1lWzFdfVxcXFwoKyhbYS16MS05LCgpXFxcXFtcXFxcXV0rKVxcXFwpYCwgJ3UnKSk7XG4gICAgICAgICAgICBsZXQgbWF0Y2hlcztcbiAgICAgICAgICAgIGxldCBhcmdzID0gW107XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVzID0gbWF0Y2hbMV0ubWF0Y2goL1tBLXoxLTldKy9ndSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IG1hdGNoZXMubWFwKChhcmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IGFyZyB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcnNlZE5hbWUsXG4gICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbn1cbmV4cG9ydHMuTWV0aG9kUmVnaXN0cnkgPSBNZXRob2RSZWdpc3RyeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IE1JTlVURSwgU0VDT05EIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90aW1lJztcbmltcG9ydCBnZXRGZXRjaFdpdGhUaW1lb3V0IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL2ZldGNoLXdpdGgtdGltZW91dCc7XG5pbXBvcnQgeyBnZXRTdG9yYWdlSXRlbSwgc2V0U3RvcmFnZUl0ZW0gfSBmcm9tICcuL3N0b3JhZ2UtaGVscGVycyc7XG5cbmNvbnN0IGZldGNoV2l0aENhY2hlID0gYXN5bmMgKFxuICB1cmwsXG4gIGZldGNoT3B0aW9ucyA9IHt9LFxuICB7IGNhY2hlUmVmcmVzaFRpbWUgPSBNSU5VVEUgKiA2LCB0aW1lb3V0ID0gU0VDT05EICogMzAgfSA9IHt9LFxuKSA9PiB7XG4gIGlmIChcbiAgICBmZXRjaE9wdGlvbnMuYm9keSB8fFxuICAgIChmZXRjaE9wdGlvbnMubWV0aG9kICYmIGZldGNoT3B0aW9ucy5tZXRob2QgIT09ICdHRVQnKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZldGNoV2l0aENhY2hlIG9ubHkgc3VwcG9ydHMgR0VUIHJlcXVlc3RzJyk7XG4gIH1cbiAgaWYgKCEoZmV0Y2hPcHRpb25zLmhlYWRlcnMgaW5zdGFuY2VvZiB3aW5kb3cuSGVhZGVycykpIHtcbiAgICBmZXRjaE9wdGlvbnMuaGVhZGVycyA9IG5ldyB3aW5kb3cuSGVhZGVycyhmZXRjaE9wdGlvbnMuaGVhZGVycyk7XG4gIH1cbiAgaWYgKFxuICAgIGZldGNoT3B0aW9ucy5oZWFkZXJzLmhhcygnQ29udGVudC1UeXBlJykgJiZcbiAgICBmZXRjaE9wdGlvbnMuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpICE9PSAnYXBwbGljYXRpb24vanNvbidcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmZXRjaFdpdGhDYWNoZSBvbmx5IHN1cHBvcnRzIEpTT04gcmVzcG9uc2VzJyk7XG4gIH1cblxuICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gIGNvbnN0IGNhY2hlS2V5ID0gYGNhY2hlZEZldGNoOiR7dXJsfWA7XG4gIGNvbnN0IHsgY2FjaGVkUmVzcG9uc2UsIGNhY2hlZFRpbWUgfSA9IChhd2FpdCBnZXRTdG9yYWdlSXRlbShjYWNoZUtleSkpIHx8IHt9O1xuICBpZiAoY2FjaGVkUmVzcG9uc2UgJiYgY3VycmVudFRpbWUgLSBjYWNoZWRUaW1lIDwgY2FjaGVSZWZyZXNoVGltZSkge1xuICAgIHJldHVybiBjYWNoZWRSZXNwb25zZTtcbiAgfVxuICBmZXRjaE9wdGlvbnMuaGVhZGVycy5zZXQoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gIGNvbnN0IGZldGNoV2l0aFRpbWVvdXQgPSBnZXRGZXRjaFdpdGhUaW1lb3V0KHRpbWVvdXQpO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFRpbWVvdXQodXJsLCB7XG4gICAgcmVmZXJyZXJQb2xpY3k6ICduby1yZWZlcnJlci13aGVuLWRvd25ncmFkZScsXG4gICAgYm9keTogbnVsbCxcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIG1vZGU6ICdjb3JzJyxcbiAgICAuLi5mZXRjaE9wdGlvbnMsXG4gIH0pO1xuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEZldGNoIGZhaWxlZCB3aXRoIHN0YXR1cyAnJHtyZXNwb25zZS5zdGF0dXN9JzogJyR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0nYCxcbiAgICApO1xuICB9XG4gIGNvbnN0IHJlc3BvbnNlSnNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgY29uc3QgY2FjaGVFbnRyeSA9IHtcbiAgICBjYWNoZWRSZXNwb25zZTogcmVzcG9uc2VKc29uLFxuICAgIGNhY2hlZFRpbWU6IGN1cnJlbnRUaW1lLFxuICB9O1xuXG4gIGF3YWl0IHNldFN0b3JhZ2VJdGVtKGNhY2hlS2V5LCBjYWNoZUVudHJ5KTtcbiAgcmV0dXJuIHJlc3BvbnNlSnNvbjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZldGNoV2l0aENhY2hlO1xuIiwiaW1wb3J0IHsgYWRkSGV4UHJlZml4IH0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcbmltcG9ydCB7IE1JTl9HQVNfTElNSVRfSEVYIH0gZnJvbSAnLi4vLi4vdWkvcGFnZXMvc2VuZC9zZW5kLmNvbnN0YW50cyc7XG5cbmNvbnN0IE9ORV9IVU5EUkVEX1RIT1VTQU5EID0gMTAwMDAwO1xuXG5leHBvcnQgY29uc3QgR0FTX0xJTUlUUyA9IHtcbiAgLy8gbWF4aW11bSBnYXNMaW1pdCBvZiBhIHNpbXBsZSBzZW5kXG4gIFNJTVBMRTogYWRkSGV4UHJlZml4KE1JTl9HQVNfTElNSVRfSEVYKSxcbiAgLy8gYSBiYXNlIGVzdGltYXRlIGZvciB0b2tlbiB0cmFuc2ZlcnMuXG4gIEJBU0VfVE9LRU5fRVNUSU1BVEU6IGFkZEhleFByZWZpeChPTkVfSFVORFJFRF9USE9VU0FORC50b1N0cmluZygxNikpLFxufTtcblxuLyoqXG4gKiBUaGVzZSBhcmUgYWxyZWFkeSBkZWNsYXJlZCBpbiBAbWV0YW1hc2svY29udHJvbGxlcnMgYnV0IGltcG9ydGluZyB0aGVtIGZyb21cbiAqIHRoYXQgbW9kdWxlIGFuZCByZS1leHBvcnRpbmcgY2F1c2VzIHRoZSBVSSBidW5kbGUgc2l6ZSB0byBleHBhbmQgYmV5b25kIDRNQlxuICovXG5leHBvcnQgY29uc3QgR0FTX0VTVElNQVRFX1RZUEVTID0ge1xuICBGRUVfTUFSS0VUOiAnZmVlLW1hcmtldCcsXG4gIExFR0FDWTogJ2xlZ2FjeScsXG4gIEVUSF9HQVNQUklDRTogJ2V0aF9nYXNQcmljZScsXG4gIE5PTkU6ICdub25lJyxcbn07XG5cbi8qKlxuICogVGhlc2UgcmVwcmVzZW50IGdhcyByZWNvbW1lbmRhdGlvbiBsZXZlbHMgcHJlc2VudGVkIGluIHRoZSBVSVxuICovXG5leHBvcnQgY29uc3QgR0FTX1JFQ09NTUVOREFUSU9OUyA9IHtcbiAgTE9XOiAnbG93JyxcbiAgTUVESVVNOiAnbWVkaXVtJyxcbiAgSElHSDogJ2hpZ2gnLFxufTtcblxuLyoqXG4gKiBUaGVzZSByZXByZXNlbnQgdHlwZXMgb2YgZ2FzIGVzdGltYXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IFBSSU9SSVRZX0xFVkVMUyA9IHtcbiAgVEVOX1BFUkNFTlRfSU5DUkVBU0VEOiAndGVuUGVyY2VudEluY3JlYXNlZCcsXG4gIExPVzogJ2xvdycsXG4gIE1FRElVTTogJ21lZGl1bScsXG4gIEhJR0g6ICdoaWdoJyxcbiAgQ1VTVE9NOiAnY3VzdG9tJyxcbiAgREFQUF9TVUdHRVNURUQ6ICdkYXBwU3VnZ2VzdGVkJyxcbn07XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgdXNlciBjdXN0b21pemluZyB0aGVpciBnYXMgcHJlZmVyZW5jZVxuICovXG5leHBvcnQgY29uc3QgQ1VTVE9NX0dBU19FU1RJTUFURSA9ICdjdXN0b20nO1xuXG4vKipcbiAqIFRoZXNlIHJlcHJlc2VudCB0aGUgZGlmZmVyZW50IGVkaXQgbW9kZXMgcHJlc2VudGVkIGluIHRoZSBVSVxuICovXG5leHBvcnQgY29uc3QgRURJVF9HQVNfTU9ERVMgPSB7XG4gIFNQRUVEX1VQOiAnc3BlZWQtdXAnLFxuICBDQU5DRUw6ICdjYW5jZWwnLFxuICBNT0RJRllfSU5fUExBQ0U6ICdtb2RpZnktaW4tcGxhY2UnLFxuICBTV0FQUzogJ3N3YXBzJyxcbn07XG5cbi8qKlxuICogUmVwcmVzZW50cyBsZXZlbHMgZm9yIGBuZXR3b3JrQ29uZ2VzdGlvbmAgKGNhbGN1bGF0ZWQgYWxvbmcgd2l0aCBnYXMgZmVlXG4gKiBlc3RpbWF0ZXM7IHJlcHJlc2VudHMgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxKSB0aGF0IHdlIHVzZSB0byByZW5kZXIgdGhlXG4gKiBuZXR3b3JrIHN0YXR1cyBzbGlkZXIgb24gdGhlIHNlbmQgdHJhbnNhY3Rpb24gc2NyZWVuIGFuZCBpbmZvcm0gdXNlcnMgd2hlblxuICogZ2FzIGZlZXMgYXJlIGhpZ2hcbiAqL1xuZXhwb3J0IGNvbnN0IE5FVFdPUktfQ09OR0VTVElPTl9USFJFU0hPTERTID0ge1xuICBOT1RfQlVTWTogMCxcbiAgU1RBQkxFOiAwLjMzLFxuICBCVVNZOiAwLjY2LFxufTtcbiIsImltcG9ydCB7IGlzSGV4U3RyaW5nIH0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zYWN0aW9uTWF0Y2hlc05ldHdvcmsodHJhbnNhY3Rpb24sIGNoYWluSWQsIG5ldHdvcmtJZCkge1xuICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uLmNoYWluSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmNoYWluSWQgPT09IGNoYWluSWQ7XG4gIH1cbiAgcmV0dXJuIHRyYW5zYWN0aW9uLm1ldGFtYXNrTmV0d29ya0lkID09PSBuZXR3b3JrSWQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgbWF4RmVlUGVyR2FzIGFuZCBtYXhQcmlvcml0eUZlZVBlckdhcyBmaWVsZHMgYXJlIHN1cHBsaWVkXG4gKiBhbmQgdmFsaWQgaW5wdXRzLiBUaGlzIHdpbGwgcmV0dXJuIGZhbHNlIGZvciBub24gaGV4IHN0cmluZyBpbnB1dHMuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb25zdGFudHMvdHJhbnNhY3Rpb25cIikuVHJhbnNhY3Rpb25NZXRhfSB0cmFuc2FjdGlvbiAtXG4gKiAgdGhlIHRyYW5zYWN0aW9uIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0cmFuc2FjdGlvbiB1c2VzIHZhbGlkIEVJUDE1NTkgZmllbGRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VJUDE1NTlUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICByZXR1cm4gKFxuICAgIGlzSGV4U3RyaW5nKHRyYW5zYWN0aW9uPy50eFBhcmFtcz8ubWF4RmVlUGVyR2FzKSAmJlxuICAgIGlzSGV4U3RyaW5nKHRyYW5zYWN0aW9uPy50eFBhcmFtcz8ubWF4UHJpb3JpdHlGZWVQZXJHYXMpXG4gICk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBtYXhGZWVQZXJHYXMgYW5kIG1heFByaW9yaXR5RmVlUGVyR2FzIGZpZWxkcyBhcmUgbm90XG4gKiBzdXBwbGllZCBhbmQgdGhhdCB0aGUgZ2FzUHJpY2UgZmllbGQgaXMgdmFsaWQgaWYgaXQgaXMgcHJvdmlkZWQuIFRoaXMgd2lsbFxuICogcmV0dXJuIGZhbHNlIGlmIGdhc1ByaWNlIGlzIGEgbm9uIGhleCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb25zdGFudHMvdHJhbnNhY3Rpb25cIikuVHJhbnNhY3Rpb25NZXRhfSB0cmFuc2FjdGlvbiAtXG4gKiAgdGhlIHRyYW5zYWN0aW9uIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0cmFuc2FjdGlvbiB1c2VzIHZhbGlkIExlZ2FjeSBmaWVsZHMgT1IgbGFja3NcbiAqICBFSVAxNTU5IGZpZWxkc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNMZWdhY3lUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB0cmFuc2FjdGlvbi50eFBhcmFtcy5tYXhGZWVQZXJHYXMgPT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIHRyYW5zYWN0aW9uLnR4UGFyYW1zLm1heFByaW9yaXR5RmVlUGVyR2FzID09PSAndW5kZWZpbmVkJyAmJlxuICAgICh0eXBlb2YgdHJhbnNhY3Rpb24udHhQYXJhbXMuZ2FzUHJpY2UgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICBpc0hleFN0cmluZyh0cmFuc2FjdGlvbi50eFBhcmFtcy5nYXNQcmljZSkpXG4gICk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdHJhbnNhY3Rpb25zIGdhcyBmZWVzIGluIHR4UGFyYW1zIG1hdGNoIHRob3NlIGluIGl0cyBkYXBwU3VnZ2VzdGVkR2FzRmVlcyBwcm9wZXJ0eVxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29uc3RhbnRzL3RyYW5zYWN0aW9uXCIpLlRyYW5zYWN0aW9uTWV0YX0gdHJhbnNhY3Rpb24gLVxuICogIHRoZSB0cmFuc2FjdGlvbiB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgYm90aCB0aGUgdHhQYXJhbXMgYW5kIGRhcHBTdWdnZXN0ZWRHYXNGZWVzIGFyZSBvYmplY3RzIHdpdGggdHJ1dGh5IGdhcyBmZWUgcHJvcGVydGllcyxcbiAqICAgYW5kIHRob3NlIHByb3BlcnRpZXMgYXJlIHN0cmljdGx5IGVxdWFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0eFBhcmFtc0FyZURhcHBTdWdnZXN0ZWQodHJhbnNhY3Rpb24pIHtcbiAgY29uc3QgeyBnYXNQcmljZSwgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIG1heEZlZVBlckdhcyB9ID1cbiAgICB0cmFuc2FjdGlvbj8udHhQYXJhbXMgfHwge307XG4gIHJldHVybiAoXG4gICAgKGdhc1ByaWNlICYmIGdhc1ByaWNlID09PSB0cmFuc2FjdGlvbj8uZGFwcFN1Z2dlc3RlZEdhc0ZlZXM/Lmdhc1ByaWNlKSB8fFxuICAgIChtYXhQcmlvcml0eUZlZVBlckdhcyAmJlxuICAgICAgbWF4RmVlUGVyR2FzICYmXG4gICAgICB0cmFuc2FjdGlvbj8uZGFwcFN1Z2dlc3RlZEdhc0ZlZXM/Lm1heFByaW9yaXR5RmVlUGVyR2FzID09PVxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyAmJlxuICAgICAgdHJhbnNhY3Rpb24/LmRhcHBTdWdnZXN0ZWRHYXNGZWVzPy5tYXhGZWVQZXJHYXMgPT09IG1heEZlZVBlckdhcylcbiAgKTtcbn1cbiIsImltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IGFiaSBmcm9tICdodW1hbi1zdGFuZGFyZC10b2tlbi1hYmknO1xuaW1wb3J0IHtcbiAgU1dBUFNfQ0hBSU5JRF9ERUZBVUxUX1RPS0VOX01BUCxcbiAgQUxMT1dFRF9DT05UUkFDVF9BRERSRVNTRVMsXG4gIFNXQVBTX1dSQVBQRURfVE9LRU5TX0FERFJFU1NFUyxcbiAgRVRIRVJFVU0sXG4gIFBPTFlHT04sXG4gIEJTQyxcbiAgUklOS0VCWSxcbiAgQVZBTEFOQ0hFLFxuICBTV0FQU19BUElfVjJfQkFTRV9VUkwsXG4gIFNXQVBTX0RFVl9BUElfVjJfQkFTRV9VUkwsXG4gIEdBU19BUElfQkFTRV9VUkwsXG4gIEdBU19ERVZfQVBJX0JBU0VfVVJMLFxuICBTV0FQU19DTElFTlRfSUQsXG59IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvc3dhcHMnO1xuaW1wb3J0IHsgVFJBTlNBQ1RJT05fRU5WRUxPUEVfVFlQRVMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7XG4gIGlzU3dhcHNEZWZhdWx0VG9rZW5BZGRyZXNzLFxuICBpc1N3YXBzRGVmYXVsdFRva2VuU3ltYm9sLFxufSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9zd2Fwcy51dGlscyc7XG5pbXBvcnQge1xuICBNQUlOTkVUX0NIQUlOX0lELFxuICBCU0NfQ0hBSU5fSUQsXG4gIFBPTFlHT05fQ0hBSU5fSUQsXG4gIExPQ0FMSE9TVF9DSEFJTl9JRCxcbiAgUklOS0VCWV9DSEFJTl9JRCxcbiAgRVRIX1NZTUJPTCxcbiAgQVZBTEFOQ0hFX0NIQUlOX0lELFxufSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL25ldHdvcmsnO1xuaW1wb3J0IHsgU0VDT05EIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90aW1lJztcbmltcG9ydCB7XG4gIGNhbGNUb2tlblZhbHVlLFxuICBjYWxjVG9rZW5BbW91bnQsXG59IGZyb20gJy4uLy4uL2hlbHBlcnMvdXRpbHMvdG9rZW4tdXRpbCc7XG5pbXBvcnQge1xuICBjb25zdHJ1Y3RUeFBhcmFtcyxcbiAgdG9QcmVjaXNpb25XaXRob3V0VHJhaWxpbmdaZXJvcyxcbn0gZnJvbSAnLi4vLi4vaGVscGVycy91dGlscy91dGlsJztcbmltcG9ydCB7XG4gIGRlY2ltYWxUb0hleCxcbiAgZ2V0VmFsdWVGcm9tV2VpSGV4LFxufSBmcm9tICcuLi8uLi9oZWxwZXJzL3V0aWxzL2NvbnZlcnNpb25zLnV0aWwnO1xuXG5pbXBvcnQgeyBzdWJ0cmFjdEN1cnJlbmNpZXMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9jb252ZXJzaW9uLnV0aWxzJztcbmltcG9ydCB7IGZvcm1hdEN1cnJlbmN5IH0gZnJvbSAnLi4vLi4vaGVscGVycy91dGlscy9jb25maXJtLXR4LnV0aWwnO1xuaW1wb3J0IGZldGNoV2l0aENhY2hlIGZyb20gJy4uLy4uL2hlbHBlcnMvdXRpbHMvZmV0Y2gtd2l0aC1jYWNoZSc7XG5cbmltcG9ydCB7IGNhbGNHYXNUb3RhbCB9IGZyb20gJy4uL3NlbmQvc2VuZC51dGlscyc7XG5pbXBvcnQgeyBpc1ZhbGlkSGV4QWRkcmVzcyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL2hleHN0cmluZy11dGlscyc7XG5cbmNvbnN0IFRPS0VOX1RSQU5TRkVSX0xPR19UT1BJQ19IQVNIID1cbiAgJzB4ZGRmMjUyYWQxYmUyYzg5YjY5YzJiMDY4ZmMzNzhkYWE5NTJiYTdmMTYzYzRhMTE2MjhmNTVhNGRmNTIzYjNlZic7XG5cbmNvbnN0IENBQ0hFX1JFRlJFU0hfRklWRV9NSU5VVEVTID0gMzAwMDAwO1xuXG5jb25zdCBjbGllbnRJZEhlYWRlciA9IHsgJ1gtQ2xpZW50LUlkJzogU1dBUFNfQ0xJRU5UX0lEIH07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUeXBlIG9mIGFuIEFQSSBjYWxsLCBlLmcuIFwidG9rZW5zXCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFpbklkXG4gKiBAcmV0dXJucyBzdHJpbmdcbiAqL1xuY29uc3QgZ2V0QmFzZVVybEZvck5ld1N3YXBzQXBpID0gKHR5cGUsIGNoYWluSWQpID0+IHtcbiAgY29uc3QgdXNlRGV2QXBpcyA9IHByb2Nlc3MuZW52LlNXQVBTX1VTRV9ERVZfQVBJUztcbiAgY29uc3QgdjJBcGlCYXNlVXJsID0gdXNlRGV2QXBpc1xuICAgID8gU1dBUFNfREVWX0FQSV9WMl9CQVNFX1VSTFxuICAgIDogU1dBUFNfQVBJX1YyX0JBU0VfVVJMO1xuICBjb25zdCBnYXNBcGlCYXNlVXJsID0gdXNlRGV2QXBpcyA/IEdBU19ERVZfQVBJX0JBU0VfVVJMIDogR0FTX0FQSV9CQVNFX1VSTDtcbiAgY29uc3Qgbm9OZXR3b3JrU3BlY2lmaWNUeXBlcyA9IFsncmVmcmVzaFRpbWUnXTsgLy8gVGhlc2UgdHlwZXMgZG9uJ3QgbmVlZCBuZXR3b3JrIGluZm8gaW4gdGhlIFVSTC5cbiAgaWYgKG5vTmV0d29ya1NwZWNpZmljVHlwZXMuaW5jbHVkZXModHlwZSkpIHtcbiAgICByZXR1cm4gdjJBcGlCYXNlVXJsO1xuICB9XG4gIGNvbnN0IGNoYWluSWREZWNpbWFsID0gY2hhaW5JZCAmJiBwYXJzZUludChjaGFpbklkLCAxNik7XG4gIGNvbnN0IGdhc0FwaVR5cGVzID0gWydnYXNQcmljZXMnXTtcbiAgaWYgKGdhc0FwaVR5cGVzLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgcmV0dXJuIGAke2dhc0FwaUJhc2VVcmx9L25ldHdvcmtzLyR7Y2hhaW5JZERlY2ltYWx9YDsgLy8gR2FzIGNhbGN1bGF0aW9ucyBhcmUgaW4gaXRzIG93biByZXBvLlxuICB9XG4gIHJldHVybiBgJHt2MkFwaUJhc2VVcmx9L25ldHdvcmtzLyR7Y2hhaW5JZERlY2ltYWx9YDtcbn07XG5cbmNvbnN0IFRFU1RfQ0hBSU5fSURTID0gW1JJTktFQllfQ0hBSU5fSUQsIExPQ0FMSE9TVF9DSEFJTl9JRF07XG5cbmV4cG9ydCBjb25zdCBnZXRCYXNlQXBpID0gZnVuY3Rpb24gKHR5cGUsIGNoYWluSWQgPSBNQUlOTkVUX0NIQUlOX0lEKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBjaGFpbklkID0gVEVTVF9DSEFJTl9JRFMuaW5jbHVkZXMoY2hhaW5JZCkgPyBNQUlOTkVUX0NIQUlOX0lEIDogY2hhaW5JZDtcbiAgY29uc3QgYmFzZVVybCA9IGdldEJhc2VVcmxGb3JOZXdTd2Fwc0FwaSh0eXBlLCBjaGFpbklkKTtcbiAgY29uc3QgY2hhaW5JZERlY2ltYWwgPSBjaGFpbklkICYmIHBhcnNlSW50KGNoYWluSWQsIDE2KTtcbiAgaWYgKCFiYXNlVXJsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBTd2FwcyBBUEkgY2FsbHMgYXJlIGRpc2FibGVkIGZvciBjaGFpbklkOiAke2NoYWluSWR9YCk7XG4gIH1cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAndHJhZGUnOlxuICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9L3RyYWRlcz9gO1xuICAgIGNhc2UgJ3Rva2Vucyc6XG4gICAgICByZXR1cm4gYCR7YmFzZVVybH0vdG9rZW5zYDtcbiAgICBjYXNlICd0b2tlbic6XG4gICAgICByZXR1cm4gYCR7YmFzZVVybH0vdG9rZW5gO1xuICAgIGNhc2UgJ3RvcEFzc2V0cyc6XG4gICAgICByZXR1cm4gYCR7YmFzZVVybH0vdG9wQXNzZXRzYDtcbiAgICBjYXNlICdhZ2dyZWdhdG9yTWV0YWRhdGEnOlxuICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9L2FnZ3JlZ2F0b3JNZXRhZGF0YWA7XG4gICAgY2FzZSAnZ2FzUHJpY2VzJzpcbiAgICAgIHJldHVybiBgJHtiYXNlVXJsfS9nYXNQcmljZXNgO1xuICAgIGNhc2UgJ25ldHdvcmsnOlxuICAgICAgLy8gT25seSB1c2UgdjIgZm9yIHRoaXMgZW5kcG9pbnQuXG4gICAgICByZXR1cm4gYCR7U1dBUFNfQVBJX1YyX0JBU0VfVVJMfS9uZXR3b3Jrcy8ke2NoYWluSWREZWNpbWFsfWA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ2V0QmFzZUFwaSByZXF1aXJlcyBhbiBhcGkgY2FsbCB0eXBlJyk7XG4gIH1cbn07XG5cbmNvbnN0IHZhbGlkSGV4ID0gKHN0cmluZykgPT4gQm9vbGVhbihzdHJpbmc/Lm1hdGNoKC9eMHhbYS1mMC05XSskL3UpKTtcbmNvbnN0IHRydXRoeVN0cmluZyA9IChzdHJpbmcpID0+IEJvb2xlYW4oc3RyaW5nPy5sZW5ndGgpO1xuY29uc3QgdHJ1dGh5RGlnaXRTdHJpbmcgPSAoc3RyaW5nKSA9PlxuICB0cnV0aHlTdHJpbmcoc3RyaW5nKSAmJiBCb29sZWFuKHN0cmluZy5tYXRjaCgvXlxcZCskL3UpKTtcblxuY29uc3QgUVVPVEVfVkFMSURBVE9SUyA9IFtcbiAge1xuICAgIHByb3BlcnR5OiAndHJhZGUnLFxuICAgIHR5cGU6ICdvYmplY3QnLFxuICAgIHZhbGlkYXRvcjogKHRyYWRlKSA9PlxuICAgICAgdHJhZGUgJiZcbiAgICAgIHZhbGlkSGV4KHRyYWRlLmRhdGEpICYmXG4gICAgICBpc1ZhbGlkSGV4QWRkcmVzcyh0cmFkZS50bywgeyBhbGxvd05vblByZWZpeGVkOiBmYWxzZSB9KSAmJlxuICAgICAgaXNWYWxpZEhleEFkZHJlc3ModHJhZGUuZnJvbSwgeyBhbGxvd05vblByZWZpeGVkOiBmYWxzZSB9KSAmJlxuICAgICAgdHJ1dGh5U3RyaW5nKHRyYWRlLnZhbHVlKSxcbiAgfSxcbiAge1xuICAgIHByb3BlcnR5OiAnYXBwcm92YWxOZWVkZWQnLFxuICAgIHR5cGU6ICdvYmplY3QnLFxuICAgIHZhbGlkYXRvcjogKGFwcHJvdmFsVHgpID0+XG4gICAgICBhcHByb3ZhbFR4ID09PSBudWxsIHx8XG4gICAgICAoYXBwcm92YWxUeCAmJlxuICAgICAgICB2YWxpZEhleChhcHByb3ZhbFR4LmRhdGEpICYmXG4gICAgICAgIGlzVmFsaWRIZXhBZGRyZXNzKGFwcHJvdmFsVHgudG8sIHsgYWxsb3dOb25QcmVmaXhlZDogZmFsc2UgfSkgJiZcbiAgICAgICAgaXNWYWxpZEhleEFkZHJlc3MoYXBwcm92YWxUeC5mcm9tLCB7IGFsbG93Tm9uUHJlZml4ZWQ6IGZhbHNlIH0pKSxcbiAgfSxcbiAge1xuICAgIHByb3BlcnR5OiAnc291cmNlQW1vdW50JyxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICB2YWxpZGF0b3I6IHRydXRoeURpZ2l0U3RyaW5nLFxuICB9LFxuICB7XG4gICAgcHJvcGVydHk6ICdkZXN0aW5hdGlvbkFtb3VudCcsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgdmFsaWRhdG9yOiB0cnV0aHlEaWdpdFN0cmluZyxcbiAgfSxcbiAge1xuICAgIHByb3BlcnR5OiAnc291cmNlVG9rZW4nLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIHZhbGlkYXRvcjogKGlucHV0KSA9PiBpc1ZhbGlkSGV4QWRkcmVzcyhpbnB1dCwgeyBhbGxvd05vblByZWZpeGVkOiBmYWxzZSB9KSxcbiAgfSxcbiAge1xuICAgIHByb3BlcnR5OiAnZGVzdGluYXRpb25Ub2tlbicsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgdmFsaWRhdG9yOiAoaW5wdXQpID0+IGlzVmFsaWRIZXhBZGRyZXNzKGlucHV0LCB7IGFsbG93Tm9uUHJlZml4ZWQ6IGZhbHNlIH0pLFxuICB9LFxuICB7XG4gICAgcHJvcGVydHk6ICdhZ2dyZWdhdG9yJyxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICB2YWxpZGF0b3I6IHRydXRoeVN0cmluZyxcbiAgfSxcbiAge1xuICAgIHByb3BlcnR5OiAnYWdnVHlwZScsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgdmFsaWRhdG9yOiB0cnV0aHlTdHJpbmcsXG4gIH0sXG4gIHtcbiAgICBwcm9wZXJ0eTogJ2Vycm9yJyxcbiAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICB2YWxpZGF0b3I6IChlcnJvcikgPT4gZXJyb3IgPT09IG51bGwgfHwgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyxcbiAgfSxcbiAge1xuICAgIHByb3BlcnR5OiAnYXZlcmFnZUdhcycsXG4gICAgdHlwZTogJ251bWJlcicsXG4gIH0sXG4gIHtcbiAgICBwcm9wZXJ0eTogJ21heEdhcycsXG4gICAgdHlwZTogJ251bWJlcicsXG4gIH0sXG4gIHtcbiAgICBwcm9wZXJ0eTogJ2dhc0VzdGltYXRlJyxcbiAgICB0eXBlOiAnbnVtYmVyfHVuZGVmaW5lZCcsXG4gICAgdmFsaWRhdG9yOiAoZ2FzRXN0aW1hdGUpID0+IGdhc0VzdGltYXRlID09PSB1bmRlZmluZWQgfHwgZ2FzRXN0aW1hdGUgPiAwLFxuICB9LFxuICB7XG4gICAgcHJvcGVydHk6ICdmZWUnLFxuICAgIHR5cGU6ICdudW1iZXInLFxuICB9LFxuXTtcblxuY29uc3QgVE9LRU5fVkFMSURBVE9SUyA9IFtcbiAge1xuICAgIHByb3BlcnR5OiAnYWRkcmVzcycsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgdmFsaWRhdG9yOiAoaW5wdXQpID0+IGlzVmFsaWRIZXhBZGRyZXNzKGlucHV0LCB7IGFsbG93Tm9uUHJlZml4ZWQ6IGZhbHNlIH0pLFxuICB9LFxuICB7XG4gICAgcHJvcGVydHk6ICdzeW1ib2wnLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIHZhbGlkYXRvcjogKHN0cmluZykgPT4gdHJ1dGh5U3RyaW5nKHN0cmluZykgJiYgc3RyaW5nLmxlbmd0aCA8PSAxMixcbiAgfSxcbiAge1xuICAgIHByb3BlcnR5OiAnZGVjaW1hbHMnLFxuICAgIHR5cGU6ICdzdHJpbmd8bnVtYmVyJyxcbiAgICB2YWxpZGF0b3I6IChzdHJpbmcpID0+IE51bWJlcihzdHJpbmcpID49IDAgJiYgTnVtYmVyKHN0cmluZykgPD0gMzYsXG4gIH0sXG5dO1xuXG5jb25zdCBUT1BfQVNTRVRfVkFMSURBVE9SUyA9IFRPS0VOX1ZBTElEQVRPUlMuc2xpY2UoMCwgMik7XG5cbmNvbnN0IEFHR1JFR0FUT1JfTUVUQURBVEFfVkFMSURBVE9SUyA9IFtcbiAge1xuICAgIHByb3BlcnR5OiAnY29sb3InLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIHZhbGlkYXRvcjogKHN0cmluZykgPT4gQm9vbGVhbihzdHJpbmcubWF0Y2goL14jW0EtRmEtZjAtOV0rJC91KSksXG4gIH0sXG4gIHtcbiAgICBwcm9wZXJ0eTogJ3RpdGxlJyxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICB2YWxpZGF0b3I6IHRydXRoeVN0cmluZyxcbiAgfSxcbiAge1xuICAgIHByb3BlcnR5OiAnaWNvbicsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgdmFsaWRhdG9yOiAoc3RyaW5nKSA9PiBCb29sZWFuKHN0cmluZy5tYXRjaCgvXmRhdGE6aW1hZ2UvdSkpLFxuICB9LFxuXTtcblxuY29uc3QgaXNWYWxpZERlY2ltYWxOdW1iZXIgPSAoc3RyaW5nKSA9PlxuICAhaXNOYU4oc3RyaW5nKSAmJiBzdHJpbmcubWF0Y2goL15bLjAtOV0rJC91KSAmJiAhaXNOYU4ocGFyc2VGbG9hdChzdHJpbmcpKTtcblxuY29uc3QgU1dBUF9HQVNfUFJJQ0VfVkFMSURBVE9SID0gW1xuICB7XG4gICAgcHJvcGVydHk6ICdTYWZlR2FzUHJpY2UnLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIHZhbGlkYXRvcjogaXNWYWxpZERlY2ltYWxOdW1iZXIsXG4gIH0sXG4gIHtcbiAgICBwcm9wZXJ0eTogJ1Byb3Bvc2VHYXNQcmljZScsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgdmFsaWRhdG9yOiBpc1ZhbGlkRGVjaW1hbE51bWJlcixcbiAgfSxcbiAge1xuICAgIHByb3BlcnR5OiAnRmFzdEdhc1ByaWNlJyxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICB2YWxpZGF0b3I6IGlzVmFsaWREZWNpbWFsTnVtYmVyLFxuICB9LFxuXTtcblxuZnVuY3Rpb24gdmFsaWRhdGVEYXRhKHZhbGlkYXRvcnMsIG9iamVjdCwgdXJsVXNlZCkge1xuICByZXR1cm4gdmFsaWRhdG9ycy5ldmVyeSgoeyBwcm9wZXJ0eSwgdHlwZSwgdmFsaWRhdG9yIH0pID0+IHtcbiAgICBjb25zdCB0eXBlcyA9IHR5cGUuc3BsaXQoJ3wnKTtcblxuICAgIGNvbnN0IHZhbGlkID1cbiAgICAgIHR5cGVzLnNvbWUoKF90eXBlKSA9PiB0eXBlb2Ygb2JqZWN0W3Byb3BlcnR5XSA9PT0gX3R5cGUpICYmXG4gICAgICAoIXZhbGlkYXRvciB8fCB2YWxpZGF0b3Iob2JqZWN0W3Byb3BlcnR5XSkpO1xuICAgIGlmICghdmFsaWQpIHtcbiAgICAgIGxvZy5lcnJvcihcbiAgICAgICAgYHJlc3BvbnNlIHRvIEdFVCAke3VybFVzZWR9IGludmFsaWQgZm9yIHByb3BlcnR5ICR7cHJvcGVydHl9OyB2YWx1ZSB3YXM6YCxcbiAgICAgICAgb2JqZWN0W3Byb3BlcnR5XSxcbiAgICAgICAgJ3wgdHlwZSB3YXM6ICcsXG4gICAgICAgIHR5cGVvZiBvYmplY3RbcHJvcGVydHldLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkO1xuICB9KTtcbn1cblxuZXhwb3J0IGNvbnN0IHNob3VsZEVuYWJsZURpcmVjdFdyYXBwaW5nID0gKFxuICBjaGFpbklkLFxuICBzb3VyY2VUb2tlbixcbiAgZGVzdGluYXRpb25Ub2tlbixcbikgPT4ge1xuICBpZiAoIXNvdXJjZVRva2VuIHx8ICFkZXN0aW5hdGlvblRva2VuKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHdyYXBwZWRUb2tlbiA9IFNXQVBTX1dSQVBQRURfVE9LRU5TX0FERFJFU1NFU1tjaGFpbklkXTtcbiAgY29uc3QgbmF0aXZlVG9rZW4gPSBTV0FQU19DSEFJTklEX0RFRkFVTFRfVE9LRU5fTUFQW2NoYWluSWRdPy5hZGRyZXNzO1xuICBjb25zdCBzb3VyY2VUb2tlbkxvd2VyQ2FzZSA9IHNvdXJjZVRva2VuLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IGRlc3RpbmF0aW9uVG9rZW5Mb3dlckNhc2UgPSBkZXN0aW5hdGlvblRva2VuLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiAoXG4gICAgKHNvdXJjZVRva2VuTG93ZXJDYXNlID09PSB3cmFwcGVkVG9rZW4gJiZcbiAgICAgIGRlc3RpbmF0aW9uVG9rZW5Mb3dlckNhc2UgPT09IG5hdGl2ZVRva2VuKSB8fFxuICAgIChzb3VyY2VUb2tlbkxvd2VyQ2FzZSA9PT0gbmF0aXZlVG9rZW4gJiZcbiAgICAgIGRlc3RpbmF0aW9uVG9rZW5Mb3dlckNhc2UgPT09IHdyYXBwZWRUb2tlbilcbiAgKTtcbn07XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFRyYWRlc0luZm8oXG4gIHtcbiAgICBzbGlwcGFnZSxcbiAgICBzb3VyY2VUb2tlbixcbiAgICBzb3VyY2VEZWNpbWFscyxcbiAgICBkZXN0aW5hdGlvblRva2VuLFxuICAgIHZhbHVlLFxuICAgIGZyb21BZGRyZXNzLFxuICAgIGV4Y2hhbmdlTGlzdCxcbiAgfSxcbiAgeyBjaGFpbklkIH0sXG4pIHtcbiAgY29uc3QgdXJsUGFyYW1zID0ge1xuICAgIGRlc3RpbmF0aW9uVG9rZW4sXG4gICAgc291cmNlVG9rZW4sXG4gICAgc291cmNlQW1vdW50OiBjYWxjVG9rZW5WYWx1ZSh2YWx1ZSwgc291cmNlRGVjaW1hbHMpLnRvU3RyaW5nKDEwKSxcbiAgICBzbGlwcGFnZSxcbiAgICB0aW1lb3V0OiBTRUNPTkQgKiAxMCxcbiAgICB3YWxsZXRBZGRyZXNzOiBmcm9tQWRkcmVzcyxcbiAgfTtcblxuICBpZiAoZXhjaGFuZ2VMaXN0KSB7XG4gICAgdXJsUGFyYW1zLmV4Y2hhbmdlTGlzdCA9IGV4Y2hhbmdlTGlzdDtcbiAgfVxuICBpZiAoc2hvdWxkRW5hYmxlRGlyZWN0V3JhcHBpbmcoY2hhaW5JZCwgc291cmNlVG9rZW4sIGRlc3RpbmF0aW9uVG9rZW4pKSB7XG4gICAgdXJsUGFyYW1zLmVuYWJsZURpcmVjdFdyYXBwaW5nID0gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IHF1ZXJ5U3RyaW5nID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh1cmxQYXJhbXMpLnRvU3RyaW5nKCk7XG4gIGNvbnN0IHRyYWRlVVJMID0gYCR7Z2V0QmFzZUFwaSgndHJhZGUnLCBjaGFpbklkKX0ke3F1ZXJ5U3RyaW5nfWA7XG4gIGNvbnN0IHRyYWRlc1Jlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoQ2FjaGUoXG4gICAgdHJhZGVVUkwsXG4gICAgeyBtZXRob2Q6ICdHRVQnLCBoZWFkZXJzOiBjbGllbnRJZEhlYWRlciB9LFxuICAgIHsgY2FjaGVSZWZyZXNoVGltZTogMCwgdGltZW91dDogU0VDT05EICogMTUgfSxcbiAgKTtcbiAgY29uc3QgbmV3UXVvdGVzID0gdHJhZGVzUmVzcG9uc2UucmVkdWNlKChhZ2dJZFRyYWRlTWFwLCBxdW90ZSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHF1b3RlLnRyYWRlICYmXG4gICAgICAhcXVvdGUuZXJyb3IgJiZcbiAgICAgIHZhbGlkYXRlRGF0YShRVU9URV9WQUxJREFUT1JTLCBxdW90ZSwgdHJhZGVVUkwpXG4gICAgKSB7XG4gICAgICBjb25zdCBjb25zdHJ1Y3RlZFRyYWRlID0gY29uc3RydWN0VHhQYXJhbXMoe1xuICAgICAgICB0bzogcXVvdGUudHJhZGUudG8sXG4gICAgICAgIGZyb206IHF1b3RlLnRyYWRlLmZyb20sXG4gICAgICAgIGRhdGE6IHF1b3RlLnRyYWRlLmRhdGEsXG4gICAgICAgIGFtb3VudDogZGVjaW1hbFRvSGV4KHF1b3RlLnRyYWRlLnZhbHVlKSxcbiAgICAgICAgZ2FzOiBkZWNpbWFsVG9IZXgocXVvdGUubWF4R2FzKSxcbiAgICAgIH0pO1xuXG4gICAgICBsZXQgeyBhcHByb3ZhbE5lZWRlZCB9ID0gcXVvdGU7XG5cbiAgICAgIGlmIChhcHByb3ZhbE5lZWRlZCkge1xuICAgICAgICBhcHByb3ZhbE5lZWRlZCA9IGNvbnN0cnVjdFR4UGFyYW1zKHtcbiAgICAgICAgICAuLi5hcHByb3ZhbE5lZWRlZCxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFnZ0lkVHJhZGVNYXAsXG4gICAgICAgIFtxdW90ZS5hZ2dyZWdhdG9yXToge1xuICAgICAgICAgIC4uLnF1b3RlLFxuICAgICAgICAgIHNsaXBwYWdlLFxuICAgICAgICAgIHRyYWRlOiBjb25zdHJ1Y3RlZFRyYWRlLFxuICAgICAgICAgIGFwcHJvdmFsTmVlZGVkLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGFnZ0lkVHJhZGVNYXA7XG4gIH0sIHt9KTtcblxuICByZXR1cm4gbmV3UXVvdGVzO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hUb2tlbihjb250cmFjdEFkZHJlc3MsIGNoYWluSWQpIHtcbiAgY29uc3QgdG9rZW5VcmwgPSBnZXRCYXNlQXBpKCd0b2tlbicsIGNoYWluSWQpO1xuICBjb25zdCB0b2tlbiA9IGF3YWl0IGZldGNoV2l0aENhY2hlKFxuICAgIGAke3Rva2VuVXJsfT9hZGRyZXNzPSR7Y29udHJhY3RBZGRyZXNzfWAsXG4gICAgeyBtZXRob2Q6ICdHRVQnLCBoZWFkZXJzOiBjbGllbnRJZEhlYWRlciB9LFxuICAgIHsgY2FjaGVSZWZyZXNoVGltZTogQ0FDSEVfUkVGUkVTSF9GSVZFX01JTlVURVMgfSxcbiAgKTtcbiAgcmV0dXJuIHRva2VuO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hUb2tlbnMoY2hhaW5JZCkge1xuICBjb25zdCB0b2tlbnNVcmwgPSBnZXRCYXNlQXBpKCd0b2tlbnMnLCBjaGFpbklkKTtcbiAgY29uc3QgdG9rZW5zID0gYXdhaXQgZmV0Y2hXaXRoQ2FjaGUoXG4gICAgdG9rZW5zVXJsLFxuICAgIHsgbWV0aG9kOiAnR0VUJywgaGVhZGVyczogY2xpZW50SWRIZWFkZXIgfSxcbiAgICB7IGNhY2hlUmVmcmVzaFRpbWU6IENBQ0hFX1JFRlJFU0hfRklWRV9NSU5VVEVTIH0sXG4gICk7XG4gIGNvbnN0IGZpbHRlcmVkVG9rZW5zID0gW1xuICAgIFNXQVBTX0NIQUlOSURfREVGQVVMVF9UT0tFTl9NQVBbY2hhaW5JZF0sXG4gICAgLi4udG9rZW5zLmZpbHRlcigodG9rZW4pID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHZhbGlkYXRlRGF0YShUT0tFTl9WQUxJREFUT1JTLCB0b2tlbiwgdG9rZW5zVXJsKSAmJlxuICAgICAgICAhKFxuICAgICAgICAgIGlzU3dhcHNEZWZhdWx0VG9rZW5TeW1ib2wodG9rZW4uc3ltYm9sLCBjaGFpbklkKSB8fFxuICAgICAgICAgIGlzU3dhcHNEZWZhdWx0VG9rZW5BZGRyZXNzKHRva2VuLmFkZHJlc3MsIGNoYWluSWQpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSksXG4gIF07XG4gIHJldHVybiBmaWx0ZXJlZFRva2Vucztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoQWdncmVnYXRvck1ldGFkYXRhKGNoYWluSWQpIHtcbiAgY29uc3QgYWdncmVnYXRvck1ldGFkYXRhVXJsID0gZ2V0QmFzZUFwaSgnYWdncmVnYXRvck1ldGFkYXRhJywgY2hhaW5JZCk7XG4gIGNvbnN0IGFnZ3JlZ2F0b3JzID0gYXdhaXQgZmV0Y2hXaXRoQ2FjaGUoXG4gICAgYWdncmVnYXRvck1ldGFkYXRhVXJsLFxuICAgIHsgbWV0aG9kOiAnR0VUJywgaGVhZGVyczogY2xpZW50SWRIZWFkZXIgfSxcbiAgICB7IGNhY2hlUmVmcmVzaFRpbWU6IENBQ0hFX1JFRlJFU0hfRklWRV9NSU5VVEVTIH0sXG4gICk7XG4gIGNvbnN0IGZpbHRlcmVkQWdncmVnYXRvcnMgPSB7fTtcbiAgZm9yIChjb25zdCBhZ2dLZXkgaW4gYWdncmVnYXRvcnMpIHtcbiAgICBpZiAoXG4gICAgICB2YWxpZGF0ZURhdGEoXG4gICAgICAgIEFHR1JFR0FUT1JfTUVUQURBVEFfVkFMSURBVE9SUyxcbiAgICAgICAgYWdncmVnYXRvcnNbYWdnS2V5XSxcbiAgICAgICAgYWdncmVnYXRvck1ldGFkYXRhVXJsLFxuICAgICAgKVxuICAgICkge1xuICAgICAgZmlsdGVyZWRBZ2dyZWdhdG9yc1thZ2dLZXldID0gYWdncmVnYXRvcnNbYWdnS2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbHRlcmVkQWdncmVnYXRvcnM7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFRvcEFzc2V0cyhjaGFpbklkKSB7XG4gIGNvbnN0IHRvcEFzc2V0c1VybCA9IGdldEJhc2VBcGkoJ3RvcEFzc2V0cycsIGNoYWluSWQpO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aENhY2hlKFxuICAgIHRvcEFzc2V0c1VybCxcbiAgICB7IG1ldGhvZDogJ0dFVCcsIGhlYWRlcnM6IGNsaWVudElkSGVhZGVyIH0sXG4gICAgeyBjYWNoZVJlZnJlc2hUaW1lOiBDQUNIRV9SRUZSRVNIX0ZJVkVfTUlOVVRFUyB9LFxuICApO1xuICBjb25zdCB0b3BBc3NldHNNYXAgPSByZXNwb25zZS5yZWR1Y2UoKF90b3BBc3NldHNNYXAsIGFzc2V0LCBpbmRleCkgPT4ge1xuICAgIGlmICh2YWxpZGF0ZURhdGEoVE9QX0FTU0VUX1ZBTElEQVRPUlMsIGFzc2V0LCB0b3BBc3NldHNVcmwpKSB7XG4gICAgICByZXR1cm4geyAuLi5fdG9wQXNzZXRzTWFwLCBbYXNzZXQuYWRkcmVzc106IHsgaW5kZXg6IFN0cmluZyhpbmRleCkgfSB9O1xuICAgIH1cbiAgICByZXR1cm4gX3RvcEFzc2V0c01hcDtcbiAgfSwge30pO1xuICByZXR1cm4gdG9wQXNzZXRzTWFwO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hTd2Fwc0ZlYXR1cmVGbGFncygpIHtcbiAgY29uc3QgdjJBcGlCYXNlVXJsID0gcHJvY2Vzcy5lbnYuU1dBUFNfVVNFX0RFVl9BUElTXG4gICAgPyBTV0FQU19ERVZfQVBJX1YyX0JBU0VfVVJMXG4gICAgOiBTV0FQU19BUElfVjJfQkFTRV9VUkw7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoQ2FjaGUoXG4gICAgYCR7djJBcGlCYXNlVXJsfS9mZWF0dXJlRmxhZ3NgLFxuICAgIHsgbWV0aG9kOiAnR0VUJywgaGVhZGVyczogY2xpZW50SWRIZWFkZXIgfSxcbiAgICB7IGNhY2hlUmVmcmVzaFRpbWU6IDYwMDAwMCB9LFxuICApO1xuICByZXR1cm4gcmVzcG9uc2U7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFRva2VuUHJpY2UoYWRkcmVzcykge1xuICBjb25zdCBxdWVyeSA9IGBjb250cmFjdF9hZGRyZXNzZXM9JHthZGRyZXNzfSZ2c19jdXJyZW5jaWVzPWV0aGA7XG5cbiAgY29uc3QgcHJpY2VzID0gYXdhaXQgZmV0Y2hXaXRoQ2FjaGUoXG4gICAgYGh0dHBzOi8vYXBpLmNvaW5nZWNrby5jb20vYXBpL3YzL3NpbXBsZS90b2tlbl9wcmljZS9ldGhlcmV1bT8ke3F1ZXJ5fWAsXG4gICAgeyBtZXRob2Q6ICdHRVQnIH0sXG4gICAgeyBjYWNoZVJlZnJlc2hUaW1lOiA2MDAwMCB9LFxuICApO1xuICByZXR1cm4gcHJpY2VzICYmIHByaWNlc1thZGRyZXNzXT8uZXRoO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hUb2tlbkJhbGFuY2UoYWRkcmVzcywgdXNlckFkZHJlc3MpIHtcbiAgY29uc3QgdG9rZW5Db250cmFjdCA9IGdsb2JhbC5ldGguY29udHJhY3QoYWJpKS5hdChhZGRyZXNzKTtcbiAgY29uc3QgdG9rZW5CYWxhbmNlUHJvbWlzZSA9IHRva2VuQ29udHJhY3RcbiAgICA/IHRva2VuQ29udHJhY3QuYmFsYW5jZU9mKHVzZXJBZGRyZXNzKVxuICAgIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gIGNvbnN0IHVzZXJzVG9rZW4gPSBhd2FpdCB0b2tlbkJhbGFuY2VQcm9taXNlO1xuICByZXR1cm4gdXNlcnNUb2tlbjtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoU3dhcHNHYXNQcmljZXMoY2hhaW5JZCkge1xuICBjb25zdCBnYXNQcmljZXNVcmwgPSBnZXRCYXNlQXBpKCdnYXNQcmljZXMnLCBjaGFpbklkKTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhDYWNoZShcbiAgICBnYXNQcmljZXNVcmwsXG4gICAgeyBtZXRob2Q6ICdHRVQnLCBoZWFkZXJzOiBjbGllbnRJZEhlYWRlciB9LFxuICAgIHsgY2FjaGVSZWZyZXNoVGltZTogMzAwMDAgfSxcbiAgKTtcbiAgY29uc3QgcmVzcG9uc2VJc1ZhbGlkID0gdmFsaWRhdGVEYXRhKFxuICAgIFNXQVBfR0FTX1BSSUNFX1ZBTElEQVRPUixcbiAgICByZXNwb25zZSxcbiAgICBnYXNQcmljZXNVcmwsXG4gICk7XG5cbiAgaWYgKCFyZXNwb25zZUlzVmFsaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Z2FzUHJpY2VzVXJsfSByZXNwb25zZSBpcyBpbnZhbGlkYCk7XG4gIH1cblxuICBjb25zdCB7XG4gICAgU2FmZUdhc1ByaWNlOiBzYWZlTG93LFxuICAgIFByb3Bvc2VHYXNQcmljZTogYXZlcmFnZSxcbiAgICBGYXN0R2FzUHJpY2U6IGZhc3QsXG4gIH0gPSByZXNwb25zZTtcblxuICByZXR1cm4ge1xuICAgIHNhZmVMb3csXG4gICAgYXZlcmFnZSxcbiAgICBmYXN0LFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgZ2V0RmVlRm9yU21hcnRUcmFuc2FjdGlvbiA9ICh7XG4gIGNoYWluSWQsXG4gIGN1cnJlbnRDdXJyZW5jeSxcbiAgY29udmVyc2lvblJhdGUsXG4gIG5hdGl2ZUN1cnJlbmN5U3ltYm9sLFxuICBmZWVJbldlaURlYyxcbn0pID0+IHtcbiAgY29uc3QgZmVlSW5XZWlIZXggPSBkZWNpbWFsVG9IZXgoZmVlSW5XZWlEZWMpO1xuICBjb25zdCBldGhGZWUgPSBnZXRWYWx1ZUZyb21XZWlIZXgoe1xuICAgIHZhbHVlOiBmZWVJbldlaUhleCxcbiAgICB0b0Rlbm9taW5hdGlvbjogRVRIX1NZTUJPTCxcbiAgICBudW1iZXJPZkRlY2ltYWxzOiA1LFxuICB9KTtcbiAgY29uc3QgcmF3TmV0d29ya0ZlZXMgPSBnZXRWYWx1ZUZyb21XZWlIZXgoe1xuICAgIHZhbHVlOiBmZWVJbldlaUhleCxcbiAgICB0b0N1cnJlbmN5OiBjdXJyZW50Q3VycmVuY3ksXG4gICAgY29udmVyc2lvblJhdGUsXG4gICAgbnVtYmVyT2ZEZWNpbWFsczogMixcbiAgfSk7XG4gIGNvbnN0IGZvcm1hdHRlZE5ldHdvcmtGZWUgPSBmb3JtYXRDdXJyZW5jeShyYXdOZXR3b3JrRmVlcywgY3VycmVudEN1cnJlbmN5KTtcbiAgY29uc3QgY2hhaW5DdXJyZW5jeVN5bWJvbFRvVXNlID1cbiAgICBuYXRpdmVDdXJyZW5jeVN5bWJvbCB8fCBTV0FQU19DSEFJTklEX0RFRkFVTFRfVE9LRU5fTUFQW2NoYWluSWRdLnN5bWJvbDtcbiAgcmV0dXJuIHtcbiAgICBmZWVJbkZpYXQ6IGZvcm1hdHRlZE5ldHdvcmtGZWUsXG4gICAgZmVlSW5FdGg6IGAke2V0aEZlZX0gJHtjaGFpbkN1cnJlbmN5U3ltYm9sVG9Vc2V9YCxcbiAgfTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZW5kZXJhYmxlTmV0d29ya0ZlZXNGb3JRdW90ZSh7XG4gIHRyYWRlR2FzLFxuICBhcHByb3ZlR2FzLFxuICBnYXNQcmljZSxcbiAgY3VycmVudEN1cnJlbmN5LFxuICBjb252ZXJzaW9uUmF0ZSxcbiAgdHJhZGVWYWx1ZSxcbiAgc291cmNlU3ltYm9sLFxuICBzb3VyY2VBbW91bnQsXG4gIGNoYWluSWQsXG4gIG5hdGl2ZUN1cnJlbmN5U3ltYm9sLFxufSkge1xuICBjb25zdCB0b3RhbEdhc0xpbWl0Rm9yQ2FsY3VsYXRpb24gPSBuZXcgQmlnTnVtYmVyKHRyYWRlR2FzIHx8ICcweDAnLCAxNilcbiAgICAucGx1cyhhcHByb3ZlR2FzIHx8ICcweDAnLCAxNilcbiAgICAudG9TdHJpbmcoMTYpO1xuICBjb25zdCBnYXNUb3RhbEluV2VpSGV4ID0gY2FsY0dhc1RvdGFsKHRvdGFsR2FzTGltaXRGb3JDYWxjdWxhdGlvbiwgZ2FzUHJpY2UpO1xuXG4gIGNvbnN0IG5vbkdhc0ZlZSA9IG5ldyBCaWdOdW1iZXIodHJhZGVWYWx1ZSwgMTYpXG4gICAgLm1pbnVzKFxuICAgICAgaXNTd2Fwc0RlZmF1bHRUb2tlblN5bWJvbChzb3VyY2VTeW1ib2wsIGNoYWluSWQpID8gc291cmNlQW1vdW50IDogMCxcbiAgICAgIDEwLFxuICAgIClcbiAgICAudG9TdHJpbmcoMTYpO1xuXG4gIGNvbnN0IHRvdGFsV2VpQ29zdCA9IG5ldyBCaWdOdW1iZXIoZ2FzVG90YWxJbldlaUhleCwgMTYpXG4gICAgLnBsdXMobm9uR2FzRmVlLCAxNilcbiAgICAudG9TdHJpbmcoMTYpO1xuXG4gIGNvbnN0IGV0aEZlZSA9IGdldFZhbHVlRnJvbVdlaUhleCh7XG4gICAgdmFsdWU6IHRvdGFsV2VpQ29zdCxcbiAgICB0b0Rlbm9taW5hdGlvbjogJ0VUSCcsXG4gICAgbnVtYmVyT2ZEZWNpbWFsczogNSxcbiAgfSk7XG4gIGNvbnN0IHJhd05ldHdvcmtGZWVzID0gZ2V0VmFsdWVGcm9tV2VpSGV4KHtcbiAgICB2YWx1ZTogdG90YWxXZWlDb3N0LFxuICAgIHRvQ3VycmVuY3k6IGN1cnJlbnRDdXJyZW5jeSxcbiAgICBjb252ZXJzaW9uUmF0ZSxcbiAgICBudW1iZXJPZkRlY2ltYWxzOiAyLFxuICB9KTtcbiAgY29uc3QgZm9ybWF0dGVkTmV0d29ya0ZlZSA9IGZvcm1hdEN1cnJlbmN5KHJhd05ldHdvcmtGZWVzLCBjdXJyZW50Q3VycmVuY3kpO1xuXG4gIGNvbnN0IGNoYWluQ3VycmVuY3lTeW1ib2xUb1VzZSA9XG4gICAgbmF0aXZlQ3VycmVuY3lTeW1ib2wgfHwgU1dBUFNfQ0hBSU5JRF9ERUZBVUxUX1RPS0VOX01BUFtjaGFpbklkXS5zeW1ib2w7XG5cbiAgcmV0dXJuIHtcbiAgICByYXdOZXR3b3JrRmVlcyxcbiAgICByYXdFdGhGZWU6IGV0aEZlZSxcbiAgICBmZWVJbkZpYXQ6IGZvcm1hdHRlZE5ldHdvcmtGZWUsXG4gICAgZmVlSW5FdGg6IGAke2V0aEZlZX0gJHtjaGFpbkN1cnJlbmN5U3ltYm9sVG9Vc2V9YCxcbiAgICBub25HYXNGZWUsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBxdW90ZXNUb1JlbmRlcmFibGVEYXRhKFxuICBxdW90ZXMsXG4gIGdhc1ByaWNlLFxuICBjb252ZXJzaW9uUmF0ZSxcbiAgY3VycmVudEN1cnJlbmN5LFxuICBhcHByb3ZlR2FzLFxuICB0b2tlbkNvbnZlcnNpb25SYXRlcyxcbiAgY2hhaW5JZCxcbiAgc21hcnRUcmFuc2FjdGlvbkVzdGltYXRlZEdhcyxcbiAgbmF0aXZlQ3VycmVuY3lTeW1ib2wsXG4pIHtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMocXVvdGVzKS5tYXAoKHF1b3RlKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgZGVzdGluYXRpb25BbW91bnQgPSAwLFxuICAgICAgc291cmNlQW1vdW50ID0gMCxcbiAgICAgIHNvdXJjZVRva2VuSW5mbyxcbiAgICAgIGRlc3RpbmF0aW9uVG9rZW5JbmZvLFxuICAgICAgc2xpcHBhZ2UsXG4gICAgICBhZ2dUeXBlLFxuICAgICAgYWdncmVnYXRvcixcbiAgICAgIGdhc0VzdGltYXRlV2l0aFJlZnVuZCxcbiAgICAgIGF2ZXJhZ2VHYXMsXG4gICAgICBmZWUsXG4gICAgICB0cmFkZSxcbiAgICB9ID0gcXVvdGU7XG4gICAgY29uc3Qgc291cmNlVmFsdWUgPSBjYWxjVG9rZW5BbW91bnQoXG4gICAgICBzb3VyY2VBbW91bnQsXG4gICAgICBzb3VyY2VUb2tlbkluZm8uZGVjaW1hbHMsXG4gICAgKS50b1N0cmluZygxMCk7XG4gICAgY29uc3QgZGVzdGluYXRpb25WYWx1ZSA9IGNhbGNUb2tlbkFtb3VudChcbiAgICAgIGRlc3RpbmF0aW9uQW1vdW50LFxuICAgICAgZGVzdGluYXRpb25Ub2tlbkluZm8uZGVjaW1hbHMsXG4gICAgKS50b1ByZWNpc2lvbig4KTtcblxuICAgIGxldCBmZWVJbkZpYXQgPSBudWxsO1xuICAgIGxldCBmZWVJbkV0aCA9IG51bGw7XG4gICAgbGV0IHJhd05ldHdvcmtGZWVzID0gbnVsbDtcbiAgICBsZXQgcmF3RXRoRmVlID0gbnVsbDtcblxuICAgICh7XG4gICAgICBmZWVJbkZpYXQsXG4gICAgICBmZWVJbkV0aCxcbiAgICAgIHJhd05ldHdvcmtGZWVzLFxuICAgICAgcmF3RXRoRmVlLFxuICAgIH0gPSBnZXRSZW5kZXJhYmxlTmV0d29ya0ZlZXNGb3JRdW90ZSh7XG4gICAgICB0cmFkZUdhczogZ2FzRXN0aW1hdGVXaXRoUmVmdW5kIHx8IGRlY2ltYWxUb0hleChhdmVyYWdlR2FzIHx8IDgwMDAwMCksXG4gICAgICBhcHByb3ZlR2FzLFxuICAgICAgZ2FzUHJpY2UsXG4gICAgICBjdXJyZW50Q3VycmVuY3ksXG4gICAgICBjb252ZXJzaW9uUmF0ZSxcbiAgICAgIHRyYWRlVmFsdWU6IHRyYWRlLnZhbHVlLFxuICAgICAgc291cmNlU3ltYm9sOiBzb3VyY2VUb2tlbkluZm8uc3ltYm9sLFxuICAgICAgc291cmNlQW1vdW50LFxuICAgICAgY2hhaW5JZCxcbiAgICB9KSk7XG5cbiAgICBpZiAoc21hcnRUcmFuc2FjdGlvbkVzdGltYXRlZEdhcykge1xuICAgICAgKHsgZmVlSW5GaWF0LCBmZWVJbkV0aCB9ID0gZ2V0RmVlRm9yU21hcnRUcmFuc2FjdGlvbih7XG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIGN1cnJlbnRDdXJyZW5jeSxcbiAgICAgICAgY29udmVyc2lvblJhdGUsXG4gICAgICAgIG5hdGl2ZUN1cnJlbmN5U3ltYm9sLFxuICAgICAgICBlc3RpbWF0ZWRGZWVJbldlaURlYzogc21hcnRUcmFuc2FjdGlvbkVzdGltYXRlZEdhcy5mZWVFc3RpbWF0ZSxcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBjb25zdCBzbGlwcGFnZU11bHRpcGxpZXIgPSBuZXcgQmlnTnVtYmVyKDEwMCAtIHNsaXBwYWdlKS5kaXYoMTAwKTtcbiAgICBjb25zdCBtaW5pbXVtQW1vdW50UmVjZWl2ZWQgPSBuZXcgQmlnTnVtYmVyKGRlc3RpbmF0aW9uVmFsdWUpXG4gICAgICAudGltZXMoc2xpcHBhZ2VNdWx0aXBsaWVyKVxuICAgICAgLnRvRml4ZWQoNik7XG5cbiAgICBjb25zdCB0b2tlbkNvbnZlcnNpb25SYXRlID1cbiAgICAgIHRva2VuQ29udmVyc2lvblJhdGVzW2Rlc3RpbmF0aW9uVG9rZW5JbmZvLmFkZHJlc3NdO1xuICAgIGNvbnN0IGV0aFZhbHVlT2ZUcmFkZSA9IGlzU3dhcHNEZWZhdWx0VG9rZW5TeW1ib2woXG4gICAgICBkZXN0aW5hdGlvblRva2VuSW5mby5zeW1ib2wsXG4gICAgICBjaGFpbklkLFxuICAgIClcbiAgICAgID8gY2FsY1Rva2VuQW1vdW50KGRlc3RpbmF0aW9uQW1vdW50LCBkZXN0aW5hdGlvblRva2VuSW5mby5kZWNpbWFscykubWludXMoXG4gICAgICAgICAgcmF3RXRoRmVlLFxuICAgICAgICAgIDEwLFxuICAgICAgICApXG4gICAgICA6IG5ldyBCaWdOdW1iZXIodG9rZW5Db252ZXJzaW9uUmF0ZSB8fCAwLCAxMClcbiAgICAgICAgICAudGltZXMoXG4gICAgICAgICAgICBjYWxjVG9rZW5BbW91bnQoZGVzdGluYXRpb25BbW91bnQsIGRlc3RpbmF0aW9uVG9rZW5JbmZvLmRlY2ltYWxzKSxcbiAgICAgICAgICAgIDEwLFxuICAgICAgICAgIClcbiAgICAgICAgICAubWludXMocmF3RXRoRmVlLCAxMCk7XG5cbiAgICBsZXQgbGlxdWlkaXR5U291cmNlS2V5O1xuICAgIGxldCByZW5kZXJlZFNsaXBwYWdlID0gc2xpcHBhZ2U7XG5cbiAgICBpZiAoYWdnVHlwZSA9PT0gJ0FHRycpIHtcbiAgICAgIGxpcXVpZGl0eVNvdXJjZUtleSA9ICdzd2FwQWdncmVnYXRvcic7XG4gICAgfSBlbHNlIGlmIChhZ2dUeXBlID09PSAnUkZRJykge1xuICAgICAgbGlxdWlkaXR5U291cmNlS2V5ID0gJ3N3YXBSZXF1ZXN0Rm9yUXVvdGF0aW9uJztcbiAgICAgIHJlbmRlcmVkU2xpcHBhZ2UgPSAwO1xuICAgIH0gZWxzZSBpZiAoYWdnVHlwZSA9PT0gJ0RFWCcpIHtcbiAgICAgIGxpcXVpZGl0eVNvdXJjZUtleSA9ICdzd2FwRGVjZW50cmFsaXplZEV4Y2hhbmdlJztcbiAgICB9IGVsc2UgaWYgKGFnZ1R5cGUgPT09ICdDT05UUkFDVCcpIHtcbiAgICAgIGxpcXVpZGl0eVNvdXJjZUtleSA9ICdzd2FwRGlyZWN0Q29udHJhY3QnO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXF1aWRpdHlTb3VyY2VLZXkgPSAnc3dhcFVua25vd24nO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhZ2dJZDogYWdncmVnYXRvcixcbiAgICAgIGFtb3VudFJlY2VpdmluZzogYCR7ZGVzdGluYXRpb25WYWx1ZX0gJHtkZXN0aW5hdGlvblRva2VuSW5mby5zeW1ib2x9YCxcbiAgICAgIGRlc3RpbmF0aW9uVG9rZW5EZWNpbWFsczogZGVzdGluYXRpb25Ub2tlbkluZm8uZGVjaW1hbHMsXG4gICAgICBkZXN0aW5hdGlvblRva2VuU3ltYm9sOiBkZXN0aW5hdGlvblRva2VuSW5mby5zeW1ib2wsXG4gICAgICBkZXN0aW5hdGlvblRva2VuVmFsdWU6IGZvcm1hdFN3YXBzVmFsdWVGb3JEaXNwbGF5KGRlc3RpbmF0aW9uVmFsdWUpLFxuICAgICAgZGVzdGluYXRpb25JY29uVXJsOiBkZXN0aW5hdGlvblRva2VuSW5mby5pY29uVXJsLFxuICAgICAgaXNCZXN0UXVvdGU6IHF1b3RlLmlzQmVzdFF1b3RlLFxuICAgICAgbGlxdWlkaXR5U291cmNlS2V5LFxuICAgICAgZmVlSW5FdGgsXG4gICAgICBkZXRhaWxlZE5ldHdvcmtGZWVzOiBgJHtmZWVJbkV0aH0gKCR7ZmVlSW5GaWF0fSlgLFxuICAgICAgbmV0d29ya0ZlZXM6IGZlZUluRmlhdCxcbiAgICAgIHF1b3RlU291cmNlOiBhZ2dUeXBlLFxuICAgICAgcmF3TmV0d29ya0ZlZXMsXG4gICAgICBzbGlwcGFnZTogcmVuZGVyZWRTbGlwcGFnZSxcbiAgICAgIHNvdXJjZVRva2VuRGVjaW1hbHM6IHNvdXJjZVRva2VuSW5mby5kZWNpbWFscyxcbiAgICAgIHNvdXJjZVRva2VuU3ltYm9sOiBzb3VyY2VUb2tlbkluZm8uc3ltYm9sLFxuICAgICAgc291cmNlVG9rZW5WYWx1ZTogc291cmNlVmFsdWUsXG4gICAgICBzb3VyY2VUb2tlbkljb25Vcmw6IHNvdXJjZVRva2VuSW5mby5pY29uVXJsLFxuICAgICAgZXRoVmFsdWVPZlRyYWRlLFxuICAgICAgbWluaW11bUFtb3VudFJlY2VpdmVkLFxuICAgICAgbWV0YU1hc2tGZWU6IGZlZSxcbiAgICB9O1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFN3YXBzVG9rZW5zUmVjZWl2ZWRGcm9tVHhNZXRhKFxuICB0b2tlblN5bWJvbCxcbiAgdHhNZXRhLFxuICB0b2tlbkFkZHJlc3MsXG4gIGFjY291bnRBZGRyZXNzLFxuICB0b2tlbkRlY2ltYWxzLFxuICBhcHByb3ZhbFR4TWV0YSxcbiAgY2hhaW5JZCxcbikge1xuICBjb25zdCB0eFJlY2VpcHQgPSB0eE1ldGE/LnR4UmVjZWlwdDtcbiAgY29uc3QgbmV0d29ya0FuZEFjY291bnRTdXBwb3J0czE1NTkgPVxuICAgIHR4TWV0YT8udHhSZWNlaXB0Py50eXBlID09PSBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFUy5GRUVfTUFSS0VUO1xuICBpZiAoaXNTd2Fwc0RlZmF1bHRUb2tlblN5bWJvbCh0b2tlblN5bWJvbCwgY2hhaW5JZCkpIHtcbiAgICBpZiAoXG4gICAgICAhdHhSZWNlaXB0IHx8XG4gICAgICAhdHhNZXRhIHx8XG4gICAgICAhdHhNZXRhLnBvc3RUeEJhbGFuY2UgfHxcbiAgICAgICF0eE1ldGEucHJlVHhCYWxhbmNlXG4gICAgKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgYXBwcm92YWxUeEdhc0Nvc3QgPSAnMHgwJztcbiAgICBpZiAoYXBwcm92YWxUeE1ldGEgJiYgYXBwcm92YWxUeE1ldGEudHhSZWNlaXB0KSB7XG4gICAgICBhcHByb3ZhbFR4R2FzQ29zdCA9IGNhbGNHYXNUb3RhbChcbiAgICAgICAgYXBwcm92YWxUeE1ldGEudHhSZWNlaXB0Lmdhc1VzZWQsXG4gICAgICAgIG5ldHdvcmtBbmRBY2NvdW50U3VwcG9ydHMxNTU5XG4gICAgICAgICAgPyBhcHByb3ZhbFR4TWV0YS50eFJlY2VpcHQuZWZmZWN0aXZlR2FzUHJpY2UgLy8gQmFzZSBmZWUgKyBwcmlvcml0eSBmZWUuXG4gICAgICAgICAgOiBhcHByb3ZhbFR4TWV0YS50eFBhcmFtcy5nYXNQcmljZSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgZ2FzQ29zdCA9IGNhbGNHYXNUb3RhbChcbiAgICAgIHR4UmVjZWlwdC5nYXNVc2VkLFxuICAgICAgbmV0d29ya0FuZEFjY291bnRTdXBwb3J0czE1NTlcbiAgICAgICAgPyB0eFJlY2VpcHQuZWZmZWN0aXZlR2FzUHJpY2VcbiAgICAgICAgOiB0eE1ldGEudHhQYXJhbXMuZ2FzUHJpY2UsXG4gICAgKTtcbiAgICBjb25zdCB0b3RhbEdhc0Nvc3QgPSBuZXcgQmlnTnVtYmVyKGdhc0Nvc3QsIDE2KVxuICAgICAgLnBsdXMoYXBwcm92YWxUeEdhc0Nvc3QsIDE2KVxuICAgICAgLnRvU3RyaW5nKDE2KTtcblxuICAgIGNvbnN0IHByZVR4QmFsYW5jZUxlc3NHYXNDb3N0ID0gc3VidHJhY3RDdXJyZW5jaWVzKFxuICAgICAgdHhNZXRhLnByZVR4QmFsYW5jZSxcbiAgICAgIHRvdGFsR2FzQ29zdCxcbiAgICAgIHtcbiAgICAgICAgYUJhc2U6IDE2LFxuICAgICAgICBiQmFzZTogMTYsXG4gICAgICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxuICAgICAgfSxcbiAgICApO1xuXG4gICAgY29uc3QgZXRoUmVjZWl2ZWQgPSBzdWJ0cmFjdEN1cnJlbmNpZXMoXG4gICAgICB0eE1ldGEucG9zdFR4QmFsYW5jZSxcbiAgICAgIHByZVR4QmFsYW5jZUxlc3NHYXNDb3N0LFxuICAgICAge1xuICAgICAgICBhQmFzZTogMTYsXG4gICAgICAgIGJCYXNlOiAxNixcbiAgICAgICAgZnJvbURlbm9taW5hdGlvbjogJ1dFSScsXG4gICAgICAgIHRvRGVub21pbmF0aW9uOiAnRVRIJyxcbiAgICAgICAgdG9OdW1lcmljQmFzZTogJ2RlYycsXG4gICAgICAgIG51bWJlck9mRGVjaW1hbHM6IDYsXG4gICAgICB9LFxuICAgICk7XG4gICAgcmV0dXJuIGV0aFJlY2VpdmVkO1xuICB9XG4gIGNvbnN0IHR4UmVjZWlwdExvZ3MgPSB0eFJlY2VpcHQ/LmxvZ3M7XG4gIGlmICh0eFJlY2VpcHRMb2dzICYmIHR4UmVjZWlwdD8uc3RhdHVzICE9PSAnMHgwJykge1xuICAgIGNvbnN0IHRva2VuVHJhbnNmZXJMb2cgPSB0eFJlY2VpcHRMb2dzLmZpbmQoKHR4UmVjZWlwdExvZykgPT4ge1xuICAgICAgY29uc3QgaXNUb2tlblRyYW5zZmVyID1cbiAgICAgICAgdHhSZWNlaXB0TG9nLnRvcGljcyAmJlxuICAgICAgICB0eFJlY2VpcHRMb2cudG9waWNzWzBdID09PSBUT0tFTl9UUkFOU0ZFUl9MT0dfVE9QSUNfSEFTSDtcbiAgICAgIGNvbnN0IGlzVHJhbnNmZXJGcm9tR2l2ZW5Ub2tlbiA9IHR4UmVjZWlwdExvZy5hZGRyZXNzID09PSB0b2tlbkFkZHJlc3M7XG4gICAgICBjb25zdCBpc1RyYW5zZmVyRnJvbUdpdmVuQWRkcmVzcyA9XG4gICAgICAgIHR4UmVjZWlwdExvZy50b3BpY3MgJiZcbiAgICAgICAgdHhSZWNlaXB0TG9nLnRvcGljc1syXSAmJlxuICAgICAgICB0eFJlY2VpcHRMb2cudG9waWNzWzJdLm1hdGNoKGFjY291bnRBZGRyZXNzLnNsaWNlKDIpKTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGlzVG9rZW5UcmFuc2ZlciAmJlxuICAgICAgICBpc1RyYW5zZmVyRnJvbUdpdmVuVG9rZW4gJiZcbiAgICAgICAgaXNUcmFuc2ZlckZyb21HaXZlbkFkZHJlc3NcbiAgICAgICk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRva2VuVHJhbnNmZXJMb2dcbiAgICAgID8gdG9QcmVjaXNpb25XaXRob3V0VHJhaWxpbmdaZXJvcyhcbiAgICAgICAgICBjYWxjVG9rZW5BbW91bnQodG9rZW5UcmFuc2ZlckxvZy5kYXRhLCB0b2tlbkRlY2ltYWxzKS50b1N0cmluZygxMCksXG4gICAgICAgICAgNixcbiAgICAgICAgKVxuICAgICAgOiAnJztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFN3YXBzVmFsdWVGb3JEaXNwbGF5KGRlc3RpbmF0aW9uQW1vdW50KSB7XG4gIGxldCBhbW91bnRUb0Rpc3BsYXkgPSB0b1ByZWNpc2lvbldpdGhvdXRUcmFpbGluZ1plcm9zKGRlc3RpbmF0aW9uQW1vdW50LCAxMik7XG4gIGlmIChhbW91bnRUb0Rpc3BsYXkubWF0Y2goL2VbKy1dL3UpKSB7XG4gICAgYW1vdW50VG9EaXNwbGF5ID0gbmV3IEJpZ051bWJlcihhbW91bnRUb0Rpc3BsYXkpLnRvRml4ZWQoKTtcbiAgfVxuICByZXR1cm4gYW1vdW50VG9EaXNwbGF5O1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgY29udHJhY3QgYWRkcmVzcyBpcyB2YWxpZCBiZWZvcmUgc3dhcHBpbmcgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEFkZHJlc3MgLSBFLmcuIFwiMHg4ODFkNDAyMzc2NTljMjUxODExY2VjOWMzNjRlZjkxZGMwOGQzMDBjXCIgZm9yIG1haW5uZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFpbklkIC0gVGhlIGhleCBlbmNvZGVkIGNoYWluIElEIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBhIGNvbnRyYWN0IGFkZHJlc3MgaXMgdmFsaWQgb3Igbm90XG4gKi9cbmV4cG9ydCBjb25zdCBpc0NvbnRyYWN0QWRkcmVzc1ZhbGlkID0gKFxuICBjb250cmFjdEFkZHJlc3MsXG4gIGNoYWluSWQgPSBNQUlOTkVUX0NIQUlOX0lELFxuKSA9PiB7XG4gIGlmICghY29udHJhY3RBZGRyZXNzIHx8ICFBTExPV0VEX0NPTlRSQUNUX0FERFJFU1NFU1tjaGFpbklkXSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gQUxMT1dFRF9DT05UUkFDVF9BRERSRVNTRVNbY2hhaW5JZF0uc29tZShcbiAgICAvLyBTb21ldGltZXMgd2UgZ2V0IGEgY29udHJhY3QgYWRkcmVzcyB3aXRoIGEgZmV3IHVwcGVyLWNhc2UgY2hhcnMgYW5kIHNpbmNlIGFkZHJlc3NlcyBhcmVcbiAgICAvLyBjYXNlLWluc2Vuc2l0aXZlLCB3ZSBjb21wYXJlIGxvd2VyY2FzZSB2ZXJzaW9ucyBmb3IgdmFsaWRpdHkuXG4gICAgKGFsbG93ZWRDb250cmFjdEFkZHJlc3MpID0+XG4gICAgICBjb250cmFjdEFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYWxsb3dlZENvbnRyYWN0QWRkcmVzcy50b0xvd2VyQ2FzZSgpLFxuICApO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhaW5JZFxuICogQHJldHVybnMgc3RyaW5nIGUuZy4gZXRoZXJldW0sIGJzYyBvciBwb2x5Z29uXG4gKi9cbmV4cG9ydCBjb25zdCBnZXROZXR3b3JrTmFtZUJ5Q2hhaW5JZCA9IChjaGFpbklkKSA9PiB7XG4gIHN3aXRjaCAoY2hhaW5JZCkge1xuICAgIGNhc2UgTUFJTk5FVF9DSEFJTl9JRDpcbiAgICAgIHJldHVybiBFVEhFUkVVTTtcbiAgICBjYXNlIEJTQ19DSEFJTl9JRDpcbiAgICAgIHJldHVybiBCU0M7XG4gICAgY2FzZSBQT0xZR09OX0NIQUlOX0lEOlxuICAgICAgcmV0dXJuIFBPTFlHT047XG4gICAgY2FzZSBSSU5LRUJZX0NIQUlOX0lEOlxuICAgICAgcmV0dXJuIFJJTktFQlk7XG4gICAgY2FzZSBBVkFMQU5DSEVfQ0hBSU5fSUQ6XG4gICAgICByZXR1cm4gQVZBTEFOQ0hFO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbi8qKlxuICogSXQgcmV0dXJucyBpbmZvIGFib3V0IGlmIFN3YXBzIGFyZSBlbmFibGVkIGFuZCBpZiB3ZSBzaG91bGQgdXNlIG91ciBuZXcgQVBJcyBmb3IgaXQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHN3YXBzRmVhdHVyZUZsYWdzXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhaW5JZFxuICogQHJldHVybnMgb2JqZWN0IHdpdGggMiBpdGVtczogXCJzd2Fwc0ZlYXR1cmVJc0xpdmVcIlxuICovXG5leHBvcnQgY29uc3QgZ2V0U3dhcHNMaXZlbmVzc0Zvck5ldHdvcmsgPSAoc3dhcHNGZWF0dXJlRmxhZ3MgPSB7fSwgY2hhaW5JZCkgPT4ge1xuICBjb25zdCBuZXR3b3JrTmFtZSA9IGdldE5ldHdvcmtOYW1lQnlDaGFpbklkKGNoYWluSWQpO1xuICAvLyBVc2Ugb2xkIEFQSXMgZm9yIHRlc3RuZXQgYW5kIFJpbmtlYnkuXG4gIGlmIChbTE9DQUxIT1NUX0NIQUlOX0lELCBSSU5LRUJZX0NIQUlOX0lEXS5pbmNsdWRlcyhjaGFpbklkKSkge1xuICAgIHJldHVybiB7XG4gICAgICBzd2Fwc0ZlYXR1cmVJc0xpdmU6IHRydWUsXG4gICAgfTtcbiAgfVxuICAvLyBJZiBhIG5ldHdvcmsgbmFtZSBpcyBub3QgZm91bmQgaW4gdGhlIGxpc3Qgb2YgZmVhdHVyZSBmbGFncywgZGlzYWJsZSBTd2Fwcy5cbiAgaWYgKCFzd2Fwc0ZlYXR1cmVGbGFnc1tuZXR3b3JrTmFtZV0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3dhcHNGZWF0dXJlSXNMaXZlOiBmYWxzZSxcbiAgICB9O1xuICB9XG4gIGNvbnN0IGlzTmV0d29ya0VuYWJsZWRGb3JOZXdBcGkgPVxuICAgIHN3YXBzRmVhdHVyZUZsYWdzW25ldHdvcmtOYW1lXS5leHRlbnNpb25fYWN0aXZlO1xuICBpZiAoaXNOZXR3b3JrRW5hYmxlZEZvck5ld0FwaSkge1xuICAgIHJldHVybiB7XG4gICAgICBzd2Fwc0ZlYXR1cmVJc0xpdmU6IHRydWUsXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN3YXBzRmVhdHVyZUlzTGl2ZTogc3dhcHNGZWF0dXJlRmxhZ3NbbmV0d29ya05hbWVdLmZhbGxiYWNrX3RvX3YxLFxuICB9O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEByZXR1cm5zIG51bWJlclxuICovXG5leHBvcnQgY29uc3QgY291bnREZWNpbWFscyA9ICh2YWx1ZSkgPT4ge1xuICBpZiAoIXZhbHVlIHx8IE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiB2YWx1ZS50b1N0cmluZygpLnNwbGl0KCcuJylbMV0/Lmxlbmd0aCB8fCAwO1xufTtcblxuZXhwb3J0IGNvbnN0IHNob3dSZW1haW5pbmdUaW1lSW5NaW5BbmRTZWMgPSAocmVtYWluaW5nVGltZUluU2VjKSA9PiB7XG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihyZW1haW5pbmdUaW1lSW5TZWMpKSB7XG4gICAgcmV0dXJuICcwOjAwJztcbiAgfVxuICBjb25zdCBtaW51dGVzID0gTWF0aC5mbG9vcihyZW1haW5pbmdUaW1lSW5TZWMgLyA2MCk7XG4gIGNvbnN0IHNlY29uZHMgPSByZW1haW5pbmdUaW1lSW5TZWMgJSA2MDtcbiAgcmV0dXJuIGAke21pbnV0ZXN9OiR7c2Vjb25kcy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9YDtcbn07XG5cbmV4cG9ydCBjb25zdCBzdHhFcnJvclR5cGVzID0gWyd1bmF2YWlsYWJsZScsICdub3RfZW5vdWdoX2Z1bmRzJ107XG5cbmNvbnN0IHNtYXJ0VHJhbnNhY3Rpb25zRXJyb3JNYXAgPSB7XG4gIHVuYXZhaWxhYmxlOiAnU21hcnQgVHJhbnNhY3Rpb25zIGFyZSB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZS4nLFxuICBub3RfZW5vdWdoX2Z1bmRzOiAnTm90IGVub3VnaCBmdW5kcyBmb3IgYSBzbWFydCB0cmFuc2FjdGlvbi4nLFxufTtcblxuZXhwb3J0IGNvbnN0IHNtYXJ0VHJhbnNhY3Rpb25zRXJyb3JNZXNzYWdlcyA9IChlcnJvclR5cGUpID0+IHtcbiAgcmV0dXJuIChcbiAgICBzbWFydFRyYW5zYWN0aW9uc0Vycm9yTWFwW2Vycm9yVHlwZV0gfHxcbiAgICBzbWFydFRyYW5zYWN0aW9uc0Vycm9yTWFwLnVuYXZhaWxhYmxlXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VTbWFydFRyYW5zYWN0aW9uc0Vycm9yID0gKGVycm9yTWVzc2FnZSkgPT4ge1xuICBjb25zdCBlcnJvckpzb24gPSBlcnJvck1lc3NhZ2Uuc2xpY2UoMTIpO1xuICByZXR1cm4gSlNPTi5wYXJzZShlcnJvckpzb24udHJpbSgpKTtcbn07XG4iLCJleHBvcnQgY29uc3QgSU5TVUZGSUNJRU5UX0ZVTkRTX0VSUk9SX0tFWSA9ICdpbnN1ZmZpY2llbnRGdW5kcyc7XG5leHBvcnQgY29uc3QgR0FTX0xJTUlUX1RPT19MT1dfRVJST1JfS0VZID0gJ2dhc0xpbWl0VG9vTG93JztcbmV4cG9ydCBjb25zdCBUUkFOU0FDVElPTl9FUlJPUl9LRVkgPSAndHJhbnNhY3Rpb25FcnJvcic7XG5leHBvcnQgY29uc3QgVFJBTlNBQ1RJT05fTk9fQ09OVFJBQ1RfRVJST1JfS0VZID0gJ3RyYW5zYWN0aW9uRXJyb3JOb0NvbnRyYWN0JztcbmV4cG9ydCBjb25zdCBFVEhfR0FTX1BSSUNFX0ZFVENIX1dBUk5JTkdfS0VZID0gJ2V0aEdhc1ByaWNlRmV0Y2hXYXJuaW5nJztcbmV4cG9ydCBjb25zdCBHQVNfUFJJQ0VfRkVUQ0hfRkFJTFVSRV9FUlJPUl9LRVkgPSAnZ2FzUHJpY2VGZXRjaEZhaWxlZCc7XG5leHBvcnQgY29uc3QgR0FTX1BSSUNFX0VYQ0VTU0lWRV9FUlJPUl9LRVkgPSAnZ2FzUHJpY2VFeGNlc3NpdmUnO1xuZXhwb3J0IGNvbnN0IFVOU0VOREFCTEVfQVNTRVRfRVJST1JfS0VZID0gJ3Vuc2VuZGFibGVBc3NldCc7XG5leHBvcnQgY29uc3QgSU5TVUZGSUNJRU5UX0ZVTkRTX0ZPUl9HQVNfRVJST1JfS0VZID0gJ2luc3VmZmljaWVudEZ1bmRzRm9yR2FzJztcbmV4cG9ydCBjb25zdCBJTlZBTElEX0FTU0VUX1RZUEUgPSAnaW52YWxpZEFzc2V0VHlwZSc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSGFyZGZvcmsgPSBleHBvcnRzLkNoYWluID0gZXhwb3J0cy5DdXN0b21DaGFpbiA9IHZvaWQgMDtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG52YXIgY3JjXzMyXzEgPSByZXF1aXJlKFwiY3JjLTMyXCIpO1xudmFyIGV0aGVyZXVtanNfdXRpbF8xID0gcmVxdWlyZShcImV0aGVyZXVtanMtdXRpbFwiKTtcbnZhciBjaGFpbnNfMSA9IHJlcXVpcmUoXCIuL2NoYWluc1wiKTtcbnZhciBoYXJkZm9ya3NfMSA9IHJlcXVpcmUoXCIuL2hhcmRmb3Jrc1wiKTtcbnZhciBlaXBzXzEgPSByZXF1aXJlKFwiLi9laXBzXCIpO1xudmFyIEN1c3RvbUNoYWluO1xuKGZ1bmN0aW9uIChDdXN0b21DaGFpbikge1xuICAgIC8qKlxuICAgICAqIFBvbHlnb24gKE1hdGljKSBNYWlubmV0XG4gICAgICpcbiAgICAgKiAtIFtEb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubWF0aWMubmV0d29yay9kb2NzL2RldmVsb3AvbmV0d29yay1kZXRhaWxzL25ldHdvcmspXG4gICAgICovXG4gICAgQ3VzdG9tQ2hhaW5bXCJQb2x5Z29uTWFpbm5ldFwiXSA9IFwicG9seWdvbi1tYWlubmV0XCI7XG4gICAgLyoqXG4gICAgICogUG9seWdvbiAoTWF0aWMpIE11bWJhaSBUZXN0bmV0XG4gICAgICpcbiAgICAgKiAtIFtEb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MubWF0aWMubmV0d29yay9kb2NzL2RldmVsb3AvbmV0d29yay1kZXRhaWxzL25ldHdvcmspXG4gICAgICovXG4gICAgQ3VzdG9tQ2hhaW5bXCJQb2x5Z29uTXVtYmFpXCJdID0gXCJwb2x5Z29uLW11bWJhaVwiO1xuICAgIC8qKlxuICAgICAqIEFyYml0cnVtIFJpbmtlYnkgVGVzdG5ldFxuICAgICAqXG4gICAgICogLSBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIub2ZmY2hhaW5sYWJzLmNvbS9kb2NzL3B1YmxpY190ZXN0bmV0KVxuICAgICAqL1xuICAgIEN1c3RvbUNoYWluW1wiQXJiaXRydW1SaW5rZWJ5VGVzdG5ldFwiXSA9IFwiYXJiaXRydW0tcmlua2VieS10ZXN0bmV0XCI7XG4gICAgLyoqXG4gICAgICogeERhaSBFVk0gc2lkZWNoYWluIHdpdGggYSBuYXRpdmUgc3RhYmxlIHRva2VuXG4gICAgICpcbiAgICAgKiAtIFtEb2N1bWVudGF0aW9uXShodHRwczovL3d3dy54ZGFpY2hhaW4uY29tLylcbiAgICAgKi9cbiAgICBDdXN0b21DaGFpbltcInhEYWlDaGFpblwiXSA9IFwieC1kYWktY2hhaW5cIjtcbn0pKEN1c3RvbUNoYWluID0gZXhwb3J0cy5DdXN0b21DaGFpbiB8fCAoZXhwb3J0cy5DdXN0b21DaGFpbiA9IHt9KSk7XG52YXIgQ2hhaW47XG4oZnVuY3Rpb24gKENoYWluKSB7XG4gICAgQ2hhaW5bQ2hhaW5bXCJNYWlubmV0XCJdID0gMV0gPSBcIk1haW5uZXRcIjtcbiAgICBDaGFpbltDaGFpbltcIlJvcHN0ZW5cIl0gPSAzXSA9IFwiUm9wc3RlblwiO1xuICAgIENoYWluW0NoYWluW1wiUmlua2VieVwiXSA9IDRdID0gXCJSaW5rZWJ5XCI7XG4gICAgQ2hhaW5bQ2hhaW5bXCJLb3ZhblwiXSA9IDQyXSA9IFwiS292YW5cIjtcbiAgICBDaGFpbltDaGFpbltcIkdvZXJsaVwiXSA9IDVdID0gXCJHb2VybGlcIjtcbiAgICBDaGFpbltDaGFpbltcIkNhbGF2ZXJhc1wiXSA9IDEyM10gPSBcIkNhbGF2ZXJhc1wiO1xufSkoQ2hhaW4gPSBleHBvcnRzLkNoYWluIHx8IChleHBvcnRzLkNoYWluID0ge30pKTtcbnZhciBIYXJkZm9yaztcbihmdW5jdGlvbiAoSGFyZGZvcmspIHtcbiAgICBIYXJkZm9ya1tcIkNoYWluc3RhcnRcIl0gPSBcImNoYWluc3RhcnRcIjtcbiAgICBIYXJkZm9ya1tcIkhvbWVzdGVhZFwiXSA9IFwiaG9tZXN0ZWFkXCI7XG4gICAgSGFyZGZvcmtbXCJEYW9cIl0gPSBcImRhb1wiO1xuICAgIEhhcmRmb3JrW1wiVGFuZ2VyaW5lV2hpc3RsZVwiXSA9IFwidGFuZ2VyaW5lV2hpc3RsZVwiO1xuICAgIEhhcmRmb3JrW1wiU3B1cmlvdXNEcmFnb25cIl0gPSBcInNwdXJpb3VzRHJhZ29uXCI7XG4gICAgSGFyZGZvcmtbXCJCeXphbnRpdW1cIl0gPSBcImJ5emFudGl1bVwiO1xuICAgIEhhcmRmb3JrW1wiQ29uc3RhbnRpbm9wbGVcIl0gPSBcImNvbnN0YW50aW5vcGxlXCI7XG4gICAgSGFyZGZvcmtbXCJQZXRlcnNidXJnXCJdID0gXCJwZXRlcnNidXJnXCI7XG4gICAgSGFyZGZvcmtbXCJJc3RhbmJ1bFwiXSA9IFwiaXN0YW5idWxcIjtcbiAgICBIYXJkZm9ya1tcIk11aXJHbGFjaWVyXCJdID0gXCJtdWlyR2xhY2llclwiO1xuICAgIEhhcmRmb3JrW1wiQmVybGluXCJdID0gXCJiZXJsaW5cIjtcbiAgICBIYXJkZm9ya1tcIkxvbmRvblwiXSA9IFwibG9uZG9uXCI7XG59KShIYXJkZm9yayA9IGV4cG9ydHMuSGFyZGZvcmsgfHwgKGV4cG9ydHMuSGFyZGZvcmsgPSB7fSkpO1xuLyoqXG4gKiBDb21tb24gY2xhc3MgdG8gYWNjZXNzIGNoYWluIGFuZCBoYXJkZm9yayBwYXJhbWV0ZXJzIGFuZCB0byBwcm92aWRlXG4gKiBhIHVuaWZpZWQgYW5kIHNoYXJlZCB2aWV3IG9uIHRoZSBuZXR3b3JrIGFuZCBoYXJkZm9yayBzdGF0ZS5cbiAqXG4gKiBVc2UgdGhlIHtAbGluayBDb21tb24uY3VzdG9tfSBzdGF0aWMgY29uc3RydWN0b3IgZm9yIGNyZWF0aW5nIHNpbXBsZVxuICogY3VzdG9tIGNoYWluIHtAbGluayBDb21tb259IG9iamVjdHMgKG1vcmUgY29tcGxldGUgY3VzdG9tIGNoYWluIHNldHVwc1xuICogY2FuIGJlIGNyZWF0ZWQgdmlhIHRoZSBtYWluIGNvbnN0cnVjdG9yIGFuZCB0aGUge0BsaW5rIENvbW1vbk9wdHMuY3VzdG9tQ2hhaW5zfSBwYXJhbWV0ZXIpLlxuICovXG52YXIgQ29tbW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21tb24sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tbW9uKG9wdHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3N1cHBvcnRlZEhhcmRmb3JrcyA9IFtdO1xuICAgICAgICBfdGhpcy5fZWlwcyA9IFtdO1xuICAgICAgICBfdGhpcy5fY3VzdG9tQ2hhaW5zID0gKF9hID0gb3B0cy5jdXN0b21DaGFpbnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICBfdGhpcy5fY2hhaW5QYXJhbXMgPSBfdGhpcy5zZXRDaGFpbihvcHRzLmNoYWluKTtcbiAgICAgICAgX3RoaXMuREVGQVVMVF9IQVJERk9SSyA9IChfYiA9IF90aGlzLl9jaGFpblBhcmFtcy5kZWZhdWx0SGFyZGZvcmspICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IEhhcmRmb3JrLklzdGFuYnVsO1xuICAgICAgICBfdGhpcy5faGFyZGZvcmsgPSBfdGhpcy5ERUZBVUxUX0hBUkRGT1JLO1xuICAgICAgICBpZiAob3B0cy5zdXBwb3J0ZWRIYXJkZm9ya3MpIHtcbiAgICAgICAgICAgIF90aGlzLl9zdXBwb3J0ZWRIYXJkZm9ya3MgPSBvcHRzLnN1cHBvcnRlZEhhcmRmb3JrcztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5oYXJkZm9yaykge1xuICAgICAgICAgICAgX3RoaXMuc2V0SGFyZGZvcmsob3B0cy5oYXJkZm9yayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuZWlwcykge1xuICAgICAgICAgICAgX3RoaXMuc2V0RUlQcyhvcHRzLmVpcHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHtAbGluayBDb21tb259IG9iamVjdCBmb3IgYSBjdXN0b20gY2hhaW4sIGJhc2VkIG9uIGEgc3RhbmRhcmQgb25lLlxuICAgICAqXG4gICAgICogSXQgdXNlcyBhbGwgdGhlIHtAbGluayBDaGFpbn0gcGFyYW1ldGVycyBmcm9tIHRoZSB7QGxpbmsgYmFzZUNoYWlufSBvcHRpb24gZXhjZXB0IHRoZSBvbmVzIG92ZXJyaWRkZW5cbiAgICAgKiBpbiBhIHByb3ZpZGVkIHtAbGluayBjaGFpblBhcmFtc09yTmFtZX0gZGljdGlvbmFyeS4gU29tZSB1c2FnZSBleGFtcGxlOlxuICAgICAqXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIENvbW1vbi5jdXN0b20oe2NoYWluSWQ6IDEyM30pXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGVyZSBhcmUgYWxzbyBzZWxlY3RlZCBzdXBwb3J0ZWQgY3VzdG9tIGNoYWlucyB3aGljaCBjYW4gYmUgaW5pdGlhbGl6ZWQgYnkgdXNpbmcgb25lIG9mIHRoZVxuICAgICAqIHtAbGluayBDdXN0b21DaGFpbnN9IGZvciB7QGxpbmsgY2hhaW5QYXJhbXNPck5hbWV9LCBlLmcuOlxuICAgICAqXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIENvbW1vbi5jdXN0b20oQ3VzdG9tQ2hhaW5zLk1hdGljTXVtYmFpKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoZXNlIHN1cHBvcnRlZCBjdXN0b20gY2hhaW5zIG9ubHkgcHJvdmlkZSBzb21lIGJhc2UgcGFyYW1ldGVycyAodXN1YWxseSB0aGUgY2hhaW4gYW5kXG4gICAgICogbmV0d29yayBJRCBhbmQgYSBuYW1lKSBhbmQgY2FuIG9ubHkgYmUgdXNlZCBmb3Igc2VsZWN0ZWQgdXNlIGNhc2VzIChlLmcuIHNlbmRpbmcgYSB0eCB3aXRoXG4gICAgICogdGhlIGBAZXRoZXJldW1qcy90eGAgbGlicmFyeSB0byBhIExheWVyLTIgY2hhaW4pLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYWluUGFyYW1zT3JOYW1lIEN1c3RvbSBwYXJhbWV0ZXIgZGljdCAoYG5hbWVgIHdpbGwgZGVmYXVsdCB0byBgY3VzdG9tLWNoYWluYCkgb3Igc3RyaW5nIHdpdGggbmFtZSBvZiBhIHN1cHBvcnRlZCBjdXN0b20gY2hhaW5cbiAgICAgKiBAcGFyYW0gb3B0cyBDdXN0b20gY2hhaW4gb3B0aW9ucyB0byBzZXQgdGhlIHtAbGluayBDdXN0b21Db21tb25PcHRzLmJhc2VDaGFpbn0sIHNlbGVjdGVkIHtAbGluayBDdXN0b21Db21tb25PcHRzLmhhcmRmb3JrfSBhbmQgb3RoZXJzXG4gICAgICovXG4gICAgQ29tbW9uLmN1c3RvbSA9IGZ1bmN0aW9uIChjaGFpblBhcmFtc09yTmFtZSwgb3B0cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIHsgb3B0cyA9IHt9OyB9XG4gICAgICAgIHZhciBiYXNlQ2hhaW4gPSAoX2EgPSBvcHRzLmJhc2VDaGFpbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ21haW5uZXQnO1xuICAgICAgICB2YXIgc3RhbmRhcmRDaGFpblBhcmFtcyA9IF9fYXNzaWduKHt9LCBDb21tb24uX2dldENoYWluUGFyYW1zKGJhc2VDaGFpbikpO1xuICAgICAgICBzdGFuZGFyZENoYWluUGFyYW1zWyduYW1lJ10gPSAnY3VzdG9tLWNoYWluJztcbiAgICAgICAgaWYgKHR5cGVvZiBjaGFpblBhcmFtc09yTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tbW9uKF9fYXNzaWduKHsgY2hhaW46IF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdGFuZGFyZENoYWluUGFyYW1zKSwgY2hhaW5QYXJhbXNPck5hbWUpIH0sIG9wdHMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjaGFpblBhcmFtc09yTmFtZSA9PT0gQ3VzdG9tQ2hhaW4uUG9seWdvbk1haW5uZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29tbW9uLmN1c3RvbSh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IEN1c3RvbUNoYWluLlBvbHlnb25NYWlubmV0LFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiAxMzcsXG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcmtJZDogMTM3LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYWluUGFyYW1zT3JOYW1lID09PSBDdXN0b21DaGFpbi5Qb2x5Z29uTXVtYmFpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbW1vbi5jdXN0b20oe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBDdXN0b21DaGFpbi5Qb2x5Z29uTXVtYmFpLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiA4MDAwMSxcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya0lkOiA4MDAwMSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFpblBhcmFtc09yTmFtZSA9PT0gQ3VzdG9tQ2hhaW4uQXJiaXRydW1SaW5rZWJ5VGVzdG5ldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb21tb24uY3VzdG9tKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogQ3VzdG9tQ2hhaW4uQXJiaXRydW1SaW5rZWJ5VGVzdG5ldCxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogNDIxNjExLFxuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrSWQ6IDQyMTYxMSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFpblBhcmFtc09yTmFtZSA9PT0gQ3VzdG9tQ2hhaW4ueERhaUNoYWluKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbW1vbi5jdXN0b20oe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBDdXN0b21DaGFpbi54RGFpQ2hhaW4sXG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya0lkOiAxMDAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDdXN0b20gY2hhaW4gXCIgKyBjaGFpblBhcmFtc09yTmFtZSArIFwiIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB7QGxpbmsgQ29tbW9ufSBvYmplY3QgZm9yIGEgY3VzdG9tIGNoYWluLCBiYXNlZCBvbiBhIHN0YW5kYXJkIG9uZS4gSXQgdXNlcyBhbGwgdGhlIGBDaGFpbmBcbiAgICAgKiBwYXJhbXMgZnJvbSB7QGxpbmsgYmFzZUNoYWlufSBleGNlcHQgdGhlIG9uZXMgb3ZlcnJpZGRlbiBpbiB7QGxpbmsgY3VzdG9tQ2hhaW5QYXJhbXN9LlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBDb21tb24uY3VzdG9tfSBpbnN0ZWFkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYmFzZUNoYWluIFRoZSBuYW1lIChgbWFpbm5ldGApIG9yIGlkIChgMWApIG9mIGEgc3RhbmRhcmQgY2hhaW4gdXNlZCB0byBiYXNlIHRoZSBjdXN0b21cbiAgICAgKiBjaGFpbiBwYXJhbXMgb24uXG4gICAgICogQHBhcmFtIGN1c3RvbUNoYWluUGFyYW1zIFRoZSBjdXN0b20gcGFyYW1ldGVycyBvZiB0aGUgY2hhaW4uXG4gICAgICogQHBhcmFtIGhhcmRmb3JrIFN0cmluZyBpZGVudGlmaWVyICgnYnl6YW50aXVtJykgZm9yIGhhcmRmb3JrIChvcHRpb25hbClcbiAgICAgKiBAcGFyYW0gc3VwcG9ydGVkSGFyZGZvcmtzIExpbWl0IHBhcmFtZXRlciByZXR1cm5zIHRvIHRoZSBnaXZlbiBoYXJkZm9ya3MgKG9wdGlvbmFsKVxuICAgICAqL1xuICAgIENvbW1vbi5mb3JDdXN0b21DaGFpbiA9IGZ1bmN0aW9uIChiYXNlQ2hhaW4sIGN1c3RvbUNoYWluUGFyYW1zLCBoYXJkZm9yaywgc3VwcG9ydGVkSGFyZGZvcmtzKSB7XG4gICAgICAgIHZhciBzdGFuZGFyZENoYWluUGFyYW1zID0gQ29tbW9uLl9nZXRDaGFpblBhcmFtcyhiYXNlQ2hhaW4pO1xuICAgICAgICByZXR1cm4gbmV3IENvbW1vbih7XG4gICAgICAgICAgICBjaGFpbjogX19hc3NpZ24oX19hc3NpZ24oe30sIHN0YW5kYXJkQ2hhaW5QYXJhbXMpLCBjdXN0b21DaGFpblBhcmFtcyksXG4gICAgICAgICAgICBoYXJkZm9yazogaGFyZGZvcmssXG4gICAgICAgICAgICBzdXBwb3J0ZWRIYXJkZm9ya3M6IHN1cHBvcnRlZEhhcmRmb3JrcyxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGF0aWMgbWV0aG9kIHRvIGRldGVybWluZSBpZiBhIHtAbGluayBjaGFpbklkfSBpcyBzdXBwb3J0ZWQgYXMgYSBzdGFuZGFyZCBjaGFpblxuICAgICAqIEBwYXJhbSBjaGFpbklkIEJOIGlkIChgMWApIG9mIGEgc3RhbmRhcmQgY2hhaW5cbiAgICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAgICovXG4gICAgQ29tbW9uLmlzU3VwcG9ydGVkQ2hhaW5JZCA9IGZ1bmN0aW9uIChjaGFpbklkKSB7XG4gICAgICAgIHZhciBpbml0aWFsaXplZENoYWlucyA9IGNoYWluc18xLl9nZXRJbml0aWFsaXplZENoYWlucygpO1xuICAgICAgICByZXR1cm4gQm9vbGVhbihpbml0aWFsaXplZENoYWluc1snbmFtZXMnXVtjaGFpbklkLnRvU3RyaW5nKCldKTtcbiAgICB9O1xuICAgIENvbW1vbi5fZ2V0Q2hhaW5QYXJhbXMgPSBmdW5jdGlvbiAoY2hhaW4sIGN1c3RvbUNoYWlucykge1xuICAgICAgICB2YXIgaW5pdGlhbGl6ZWRDaGFpbnMgPSBjaGFpbnNfMS5fZ2V0SW5pdGlhbGl6ZWRDaGFpbnMoY3VzdG9tQ2hhaW5zKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGFpbiA9PT0gJ251bWJlcicgfHwgZXRoZXJldW1qc191dGlsXzEuQk4uaXNCTihjaGFpbikpIHtcbiAgICAgICAgICAgIGNoYWluID0gY2hhaW4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChpbml0aWFsaXplZENoYWluc1snbmFtZXMnXVtjaGFpbl0pIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZV8xID0gaW5pdGlhbGl6ZWRDaGFpbnNbJ25hbWVzJ11bY2hhaW5dO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbml0aWFsaXplZENoYWluc1tuYW1lXzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hhaW4gd2l0aCBJRCBcIiArIGNoYWluICsgXCIgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdGlhbGl6ZWRDaGFpbnNbY2hhaW5dKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6ZWRDaGFpbnNbY2hhaW5dO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNoYWluIHdpdGggbmFtZSBcIiArIGNoYWluICsgXCIgbm90IHN1cHBvcnRlZFwiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNoYWluXG4gICAgICogQHBhcmFtIGNoYWluIFN0cmluZyAoJ21haW5uZXQnKSBvciBOdW1iZXIgKDEpIGNoYWluXG4gICAgICogICAgIHJlcHJlc2VudGF0aW9uLiBPciwgYSBEaWN0aW9uYXJ5IG9mIGNoYWluIHBhcmFtZXRlcnMgZm9yIGEgcHJpdmF0ZSBuZXR3b3JrLlxuICAgICAqIEByZXR1cm5zIFRoZSBkaWN0aW9uYXJ5IHdpdGggcGFyYW1ldGVycyBzZXQgYXMgY2hhaW5cbiAgICAgKi9cbiAgICBDb21tb24ucHJvdG90eXBlLnNldENoYWluID0gZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICBpZiAodHlwZW9mIGNoYWluID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgY2hhaW4gPT09ICdzdHJpbmcnIHx8IGV0aGVyZXVtanNfdXRpbF8xLkJOLmlzQk4oY2hhaW4pKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFpblBhcmFtcyA9IENvbW1vbi5fZ2V0Q2hhaW5QYXJhbXMoY2hhaW4sIHRoaXMuX2N1c3RvbUNoYWlucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNoYWluID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N1c3RvbUNoYWlucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGFpbiBtdXN0IGJlIGEgc3RyaW5nLCBudW1iZXIsIG9yIEJOIHdoZW4gaW5pdGlhbGl6ZWQgd2l0aCBjdXN0b21DaGFpbnMgcGFzc2VkIGluJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVxdWlyZWQgPSBbJ25ldHdvcmtJZCcsICdnZW5lc2lzJywgJ2hhcmRmb3JrcycsICdib290c3RyYXBOb2RlcyddO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciByZXF1aXJlZF8xID0gX192YWx1ZXMocmVxdWlyZWQpLCByZXF1aXJlZF8xXzEgPSByZXF1aXJlZF8xLm5leHQoKTsgIXJlcXVpcmVkXzFfMS5kb25lOyByZXF1aXJlZF8xXzEgPSByZXF1aXJlZF8xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW0gPSByZXF1aXJlZF8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFpbltwYXJhbV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBjaGFpbiBwYXJhbWV0ZXI6IFwiICsgcGFyYW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1aXJlZF8xXzEgJiYgIXJlcXVpcmVkXzFfMS5kb25lICYmIChfYSA9IHJlcXVpcmVkXzEucmV0dXJuKSkgX2EuY2FsbChyZXF1aXJlZF8xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2hhaW5QYXJhbXMgPSBjaGFpbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgaW5wdXQgZm9ybWF0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYWluUGFyYW1zO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGFyZGZvcmsgdG8gZ2V0IHBhcmFtcyBmb3JcbiAgICAgKiBAcGFyYW0gaGFyZGZvcmsgU3RyaW5nIGlkZW50aWZpZXIgKGUuZy4gJ2J5emFudGl1bScpXG4gICAgICovXG4gICAgQ29tbW9uLnByb3RvdHlwZS5zZXRIYXJkZm9yayA9IGZ1bmN0aW9uIChoYXJkZm9yaykge1xuICAgICAgICB2YXIgZV8yLCBfYTtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1N1cHBvcnRlZEhhcmRmb3JrKGhhcmRmb3JrKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGFyZGZvcmsgXCIgKyBoYXJkZm9yayArIFwiIG5vdCBzZXQgYXMgc3VwcG9ydGVkIGluIHN1cHBvcnRlZEhhcmRmb3Jrc1wiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXhpc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIEhBUkRGT1JLX0NIQU5HRVNfMSA9IF9fdmFsdWVzKGhhcmRmb3Jrc18xLmhhcmRmb3JrcyksIEhBUkRGT1JLX0NIQU5HRVNfMV8xID0gSEFSREZPUktfQ0hBTkdFU18xLm5leHQoKTsgIUhBUkRGT1JLX0NIQU5HRVNfMV8xLmRvbmU7IEhBUkRGT1JLX0NIQU5HRVNfMV8xID0gSEFSREZPUktfQ0hBTkdFU18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBoZkNoYW5nZXMgPSBIQVJERk9SS19DSEFOR0VTXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaGZDaGFuZ2VzWzBdID09PSBoYXJkZm9yaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faGFyZGZvcmsgIT09IGhhcmRmb3JrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYXJkZm9yayA9IGhhcmRmb3JrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdoYXJkZm9ya0NoYW5nZWQnLCBoYXJkZm9yayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKEhBUkRGT1JLX0NIQU5HRVNfMV8xICYmICFIQVJERk9SS19DSEFOR0VTXzFfMS5kb25lICYmIChfYSA9IEhBUkRGT1JLX0NIQU5HRVNfMS5yZXR1cm4pKSBfYS5jYWxsKEhBUkRGT1JLX0NIQU5HRVNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFleGlzdGluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGFyZGZvcmsgd2l0aCBuYW1lIFwiICsgaGFyZGZvcmsgKyBcIiBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoYXJkZm9yayBiYXNlZCBvbiB0aGUgYmxvY2sgbnVtYmVyIHByb3ZpZGVkXG4gICAgICogQHBhcmFtIGJsb2NrTnVtYmVyXG4gICAgICogQHJldHVybnMgVGhlIG5hbWUgb2YgdGhlIEhGXG4gICAgICovXG4gICAgQ29tbW9uLnByb3RvdHlwZS5nZXRIYXJkZm9ya0J5QmxvY2tOdW1iZXIgPSBmdW5jdGlvbiAoYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgdmFyIGVfMywgX2E7XG4gICAgICAgIGJsb2NrTnVtYmVyID0gZXRoZXJldW1qc191dGlsXzEudG9UeXBlKGJsb2NrTnVtYmVyLCBldGhlcmV1bWpzX3V0aWxfMS5UeXBlT3V0cHV0LkJOKTtcbiAgICAgICAgdmFyIGhhcmRmb3JrID0gSGFyZGZvcmsuQ2hhaW5zdGFydDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5oYXJkZm9ya3MoKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGYgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGNvbXBhcmlzb24gZm9yIG5vdCBhcHBsaWVkIEhGc1xuICAgICAgICAgICAgICAgIGlmIChoZi5ibG9jayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyLmd0ZShuZXcgZXRoZXJldW1qc191dGlsXzEuQk4oaGYuYmxvY2spKSkge1xuICAgICAgICAgICAgICAgICAgICBoYXJkZm9yayA9IGhmLm5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhcmRmb3JrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG5ldyBoYXJkZm9yayBiYXNlZCBvbiB0aGUgYmxvY2sgbnVtYmVyIHByb3ZpZGVkXG4gICAgICogQHBhcmFtIGJsb2NrTnVtYmVyXG4gICAgICogQHJldHVybnMgVGhlIG5hbWUgb2YgdGhlIEhGIHNldFxuICAgICAqL1xuICAgIENvbW1vbi5wcm90b3R5cGUuc2V0SGFyZGZvcmtCeUJsb2NrTnVtYmVyID0gZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIGJsb2NrTnVtYmVyID0gZXRoZXJldW1qc191dGlsXzEudG9UeXBlKGJsb2NrTnVtYmVyLCBldGhlcmV1bWpzX3V0aWxfMS5UeXBlT3V0cHV0LkJOKTtcbiAgICAgICAgdmFyIGhhcmRmb3JrID0gdGhpcy5nZXRIYXJkZm9ya0J5QmxvY2tOdW1iZXIoYmxvY2tOdW1iZXIpO1xuICAgICAgICB0aGlzLnNldEhhcmRmb3JrKGhhcmRmb3JrKTtcbiAgICAgICAgcmV0dXJuIGhhcmRmb3JrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uIHRvIGNob29zZSBiZXR3ZWVuIGhhcmRmb3JrIHNldCBhbmQgaGFyZGZvcmsgcHJvdmlkZWQgYXMgcGFyYW1cbiAgICAgKiBAcGFyYW0gaGFyZGZvcmsgSGFyZGZvcmsgZ2l2ZW4gdG8gZnVuY3Rpb24gYXMgYSBwYXJhbWV0ZXJcbiAgICAgKiBAcmV0dXJucyBIYXJkZm9yayBjaG9zZW4gdG8gYmUgdXNlZFxuICAgICAqL1xuICAgIENvbW1vbi5wcm90b3R5cGUuX2Nob29zZUhhcmRmb3JrID0gZnVuY3Rpb24gKGhhcmRmb3JrLCBvbmx5U3VwcG9ydGVkKSB7XG4gICAgICAgIGlmIChvbmx5U3VwcG9ydGVkID09PSB2b2lkIDApIHsgb25seVN1cHBvcnRlZCA9IHRydWU7IH1cbiAgICAgICAgaWYgKCFoYXJkZm9yaykge1xuICAgICAgICAgICAgaGFyZGZvcmsgPSB0aGlzLl9oYXJkZm9yaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvbmx5U3VwcG9ydGVkICYmICF0aGlzLl9pc1N1cHBvcnRlZEhhcmRmb3JrKGhhcmRmb3JrKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGFyZGZvcmsgXCIgKyBoYXJkZm9yayArIFwiIG5vdCBzZXQgYXMgc3VwcG9ydGVkIGluIHN1cHBvcnRlZEhhcmRmb3Jrc1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFyZGZvcms7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24sIHJldHVybnMgdGhlIHBhcmFtcyBmb3IgdGhlIGdpdmVuIGhhcmRmb3JrIGZvciB0aGUgY2hhaW4gc2V0XG4gICAgICogQHBhcmFtIGhhcmRmb3JrIEhhcmRmb3JrIG5hbWVcbiAgICAgKiBAcmV0dXJucyBEaWN0aW9uYXJ5IHdpdGggaGFyZGZvcmsgcGFyYW1zXG4gICAgICovXG4gICAgQ29tbW9uLnByb3RvdHlwZS5fZ2V0SGFyZGZvcmsgPSBmdW5jdGlvbiAoaGFyZGZvcmspIHtcbiAgICAgICAgdmFyIGVfNCwgX2E7XG4gICAgICAgIHZhciBoZnMgPSB0aGlzLmhhcmRmb3JrcygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgaGZzXzEgPSBfX3ZhbHVlcyhoZnMpLCBoZnNfMV8xID0gaGZzXzEubmV4dCgpOyAhaGZzXzFfMS5kb25lOyBoZnNfMV8xID0gaGZzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhmID0gaGZzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaGZbJ25hbWUnXSA9PT0gaGFyZGZvcmspXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV80XzEpIHsgZV80ID0geyBlcnJvcjogZV80XzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGhmc18xXzEgJiYgIWhmc18xXzEuZG9uZSAmJiAoX2EgPSBoZnNfMS5yZXR1cm4pKSBfYS5jYWxsKGhmc18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV80KSB0aHJvdyBlXzQuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIYXJkZm9yayBcIiArIGhhcmRmb3JrICsgXCIgbm90IGRlZmluZWQgZm9yIGNoYWluIFwiICsgdGhpcy5jaGFpbk5hbWUoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gdG8gY2hlY2sgaWYgYSBoYXJkZm9yayBpcyBzZXQgdG8gYmUgc3VwcG9ydGVkIGJ5IHRoZSBsaWJyYXJ5XG4gICAgICogQHBhcmFtIGhhcmRmb3JrIEhhcmRmb3JrIG5hbWVcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIGhhcmRmb3JrIGlzIHN1cHBvcnRlZFxuICAgICAqL1xuICAgIENvbW1vbi5wcm90b3R5cGUuX2lzU3VwcG9ydGVkSGFyZGZvcmsgPSBmdW5jdGlvbiAoaGFyZGZvcmspIHtcbiAgICAgICAgdmFyIGVfNSwgX2E7XG4gICAgICAgIGlmICh0aGlzLl9zdXBwb3J0ZWRIYXJkZm9ya3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKHRoaXMuX3N1cHBvcnRlZEhhcmRmb3JrcyksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1cHBvcnRlZEhmID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXJkZm9yayA9PT0gc3VwcG9ydGVkSGYpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV81XzEpIHsgZV81ID0geyBlcnJvcjogZV81XzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNSkgdGhyb3cgZV81LmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhY3RpdmUgRUlQc1xuICAgICAqIEBwYXJhbSBlaXBzXG4gICAgICovXG4gICAgQ29tbW9uLnByb3RvdHlwZS5zZXRFSVBzID0gZnVuY3Rpb24gKGVpcHMpIHtcbiAgICAgICAgdmFyIGVfNiwgX2E7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChlaXBzID09PSB2b2lkIDApIHsgZWlwcyA9IFtdOyB9XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGVpcCkge1xuICAgICAgICAgICAgaWYgKCEoZWlwIGluIGVpcHNfMS5FSVBzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlaXAgKyBcIiBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1pbkhGID0gdGhpc18xLmd0ZUhhcmRmb3JrKGVpcHNfMS5FSVBzW2VpcF1bJ21pbmltdW1IYXJkZm9yayddKTtcbiAgICAgICAgICAgIGlmICghbWluSEYpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZWlwICsgXCIgY2Fubm90IGJlIGFjdGl2YXRlZCBvbiBoYXJkZm9yayBcIiArIHRoaXNfMS5oYXJkZm9yaygpICsgXCIsIG1pbmltdW1IYXJkZm9yazogXCIgKyBtaW5IRik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWlwc18xLkVJUHNbZWlwXS5yZXF1aXJlZEVJUHMpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJldHRpZXIvcHJldHRpZXJcbiAgICAgICAgICAgICAgICBlaXBzXzEuRUlQc1tlaXBdLnJlcXVpcmVkRUlQcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGVpcHMuaW5jbHVkZXMoZWxlbSkgfHwgX3RoaXMuaXNBY3RpdmF0ZWRFSVAoZWxlbSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZWlwICsgXCIgcmVxdWlyZXMgRUlQIFwiICsgZWxlbSArIFwiLCBidXQgaXMgbm90IGluY2x1ZGVkIGluIHRoZSBFSVAgbGlzdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIGVpcHNfMiA9IF9fdmFsdWVzKGVpcHMpLCBlaXBzXzJfMSA9IGVpcHNfMi5uZXh0KCk7ICFlaXBzXzJfMS5kb25lOyBlaXBzXzJfMSA9IGVpcHNfMi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWlwID0gZWlwc18yXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgX2xvb3BfMShlaXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzZfMSkgeyBlXzYgPSB7IGVycm9yOiBlXzZfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoZWlwc18yXzEgJiYgIWVpcHNfMl8xLmRvbmUgJiYgKF9hID0gZWlwc18yLnJldHVybikpIF9hLmNhbGwoZWlwc18yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV82KSB0aHJvdyBlXzYuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9laXBzID0gZWlwcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwYXJhbWV0ZXIgZm9yIHRoZSBjdXJyZW50IGNoYWluIHNldHVwXG4gICAgICpcbiAgICAgKiBJZiB0aGUgcGFyYW1ldGVyIGlzIHByZXNlbnQgaW4gYW4gRUlQLCB0aGUgRUlQIGFsd2F5cyB0YWtlcyBwcmVjZW5kZW5jZS5cbiAgICAgKiBPdGhlcndpc2UgdGhlIHBhcmFtZXRlciBpZiB0YWtlbiBmcm9tIHRoZSBsYXRlc3QgYXBwbGllZCBIRiB3aXRoXG4gICAgICogYSBjaGFuZ2Ugb24gdGhlIHJlc3BlY3RpdmUgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRvcGljIFBhcmFtZXRlciB0b3BpYyAoJ2dhc0NvbmZpZycsICdnYXNQcmljZXMnLCAndm0nLCAncG93JylcbiAgICAgKiBAcGFyYW0gbmFtZSBQYXJhbWV0ZXIgbmFtZSAoZS5nLiAnbWluR2FzTGltaXQnIGZvciAnZ2FzQ29uZmlnJyB0b3BpYylcbiAgICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgcmVxdWVzdGVkIG9yIGBudWxsYCBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBDb21tb24ucHJvdG90eXBlLnBhcmFtID0gZnVuY3Rpb24gKHRvcGljLCBuYW1lKSB7XG4gICAgICAgIHZhciBlXzcsIF9hO1xuICAgICAgICAvLyBUT0RPOiBjb25zaWRlciB0aGUgY2FzZSB0aGF0IGRpZmZlcmVudCBhY3RpdmUgRUlQc1xuICAgICAgICAvLyBjYW4gY2hhbmdlIHRoZSBzYW1lIHBhcmFtZXRlclxuICAgICAgICB2YXIgdmFsdWUgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzLl9laXBzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBlaXAgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyYW1CeUVJUCh0b3BpYywgbmFtZSwgZWlwKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV83XzEpIHsgZV83ID0geyBlcnJvcjogZV83XzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzcpIHRocm93IGVfNy5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtQnlIYXJkZm9yayh0b3BpYywgbmFtZSwgdGhpcy5faGFyZGZvcmspO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGFyYW1ldGVyIGNvcnJlc3BvbmRpbmcgdG8gYSBoYXJkZm9ya1xuICAgICAqIEBwYXJhbSB0b3BpYyBQYXJhbWV0ZXIgdG9waWMgKCdnYXNDb25maWcnLCAnZ2FzUHJpY2VzJywgJ3ZtJywgJ3BvdycpXG4gICAgICogQHBhcmFtIG5hbWUgUGFyYW1ldGVyIG5hbWUgKGUuZy4gJ21pbkdhc0xpbWl0JyBmb3IgJ2dhc0NvbmZpZycgdG9waWMpXG4gICAgICogQHBhcmFtIGhhcmRmb3JrIEhhcmRmb3JrIG5hbWVcbiAgICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgcmVxdWVzdGVkIG9yIGBudWxsYCBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBDb21tb24ucHJvdG90eXBlLnBhcmFtQnlIYXJkZm9yayA9IGZ1bmN0aW9uICh0b3BpYywgbmFtZSwgaGFyZGZvcmspIHtcbiAgICAgICAgdmFyIGVfOCwgX2EsIGVfOSwgX2I7XG4gICAgICAgIGhhcmRmb3JrID0gdGhpcy5fY2hvb3NlSGFyZGZvcmsoaGFyZGZvcmspO1xuICAgICAgICB2YXIgdmFsdWUgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgSEFSREZPUktfQ0hBTkdFU18yID0gX192YWx1ZXMoaGFyZGZvcmtzXzEuaGFyZGZvcmtzKSwgSEFSREZPUktfQ0hBTkdFU18yXzEgPSBIQVJERk9SS19DSEFOR0VTXzIubmV4dCgpOyAhSEFSREZPUktfQ0hBTkdFU18yXzEuZG9uZTsgSEFSREZPUktfQ0hBTkdFU18yXzEgPSBIQVJERk9SS19DSEFOR0VTXzIubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhmQ2hhbmdlcyA9IEhBUkRGT1JLX0NIQU5HRVNfMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIEVJUC1yZWZlcmVuY2luZyBIRiBmaWxlIChlLmcuIGJlcmxpbi5qc29uKVxuICAgICAgICAgICAgICAgIGlmIChoZkNoYW5nZXNbMV0uaGFzT3duUHJvcGVydHkoJ2VpcHMnKSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgICAgICAgICAgIHZhciBoZkVJUHMgPSBoZkNoYW5nZXNbMV1bJ2VpcHMnXTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGhmRUlQc18xID0gKGVfOSA9IHZvaWQgMCwgX192YWx1ZXMoaGZFSVBzKSksIGhmRUlQc18xXzEgPSBoZkVJUHNfMS5uZXh0KCk7ICFoZkVJUHNfMV8xLmRvbmU7IGhmRUlQc18xXzEgPSBoZkVJUHNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWlwID0gaGZFSVBzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVFSVAgPSB0aGlzLnBhcmFtQnlFSVAodG9waWMsIG5hbWUsIGVpcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZUVJUCAhPT0gbnVsbCA/IHZhbHVlRUlQIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfOV8xKSB7IGVfOSA9IHsgZXJyb3I6IGVfOV8xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoZkVJUHNfMV8xICYmICFoZkVJUHNfMV8xLmRvbmUgJiYgKF9iID0gaGZFSVBzXzEucmV0dXJuKSkgX2IuY2FsbChoZkVJUHNfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfOSkgdGhyb3cgZV85LmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyYW1hdGVyLWlubGluaW5nIEhGIGZpbGUgKGUuZy4gaXN0YW5idWwuanNvbilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGZDaGFuZ2VzWzFdW3RvcGljXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG9waWMgXCIgKyB0b3BpYyArIFwiIG5vdCBkZWZpbmVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChoZkNoYW5nZXNbMV1bdG9waWNdW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaGZDaGFuZ2VzWzFdW3RvcGljXVtuYW1lXS52O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoZkNoYW5nZXNbMF0gPT09IGhhcmRmb3JrKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV84XzEpIHsgZV84ID0geyBlcnJvcjogZV84XzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKEhBUkRGT1JLX0NIQU5HRVNfMl8xICYmICFIQVJERk9SS19DSEFOR0VTXzJfMS5kb25lICYmIChfYSA9IEhBUkRGT1JLX0NIQU5HRVNfMi5yZXR1cm4pKSBfYS5jYWxsKEhBUkRGT1JLX0NIQU5HRVNfMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfOCkgdGhyb3cgZV84LmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHBhcmFtZXRlciBjb3JyZXNwb25kaW5nIHRvIGFuIEVJUFxuICAgICAqIEBwYXJhbSB0b3BpYyBQYXJhbWV0ZXIgdG9waWMgKCdnYXNDb25maWcnLCAnZ2FzUHJpY2VzJywgJ3ZtJywgJ3BvdycpXG4gICAgICogQHBhcmFtIG5hbWUgUGFyYW1ldGVyIG5hbWUgKGUuZy4gJ21pbkdhc0xpbWl0JyBmb3IgJ2dhc0NvbmZpZycgdG9waWMpXG4gICAgICogQHBhcmFtIGVpcCBOdW1iZXIgb2YgdGhlIEVJUFxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSByZXF1ZXN0ZWQgb3IgYG51bGxgIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICAgIENvbW1vbi5wcm90b3R5cGUucGFyYW1CeUVJUCA9IGZ1bmN0aW9uICh0b3BpYywgbmFtZSwgZWlwKSB7XG4gICAgICAgIGlmICghKGVpcCBpbiBlaXBzXzEuRUlQcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlaXAgKyBcIiBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlaXBQYXJhbXMgPSBlaXBzXzEuRUlQc1tlaXBdO1xuICAgICAgICBpZiAoISh0b3BpYyBpbiBlaXBQYXJhbXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb3BpYyBcIiArIHRvcGljICsgXCIgbm90IGRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVpcFBhcmFtc1t0b3BpY11bbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gZWlwUGFyYW1zW3RvcGljXVtuYW1lXS52O1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcGFyYW1ldGVyIGZvciB0aGUgaGFyZGZvcmsgYWN0aXZlIG9uIGJsb2NrIG51bWJlclxuICAgICAqIEBwYXJhbSB0b3BpYyBQYXJhbWV0ZXIgdG9waWNcbiAgICAgKiBAcGFyYW0gbmFtZSBQYXJhbWV0ZXIgbmFtZVxuICAgICAqIEBwYXJhbSBibG9ja051bWJlciBCbG9jayBudW1iZXJcbiAgICAgKi9cbiAgICBDb21tb24ucHJvdG90eXBlLnBhcmFtQnlCbG9jayA9IGZ1bmN0aW9uICh0b3BpYywgbmFtZSwgYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgdmFyIGFjdGl2ZUhmcyA9IHRoaXMuYWN0aXZlSGFyZGZvcmtzKGJsb2NrTnVtYmVyKTtcbiAgICAgICAgdmFyIGhhcmRmb3JrID0gYWN0aXZlSGZzW2FjdGl2ZUhmcy5sZW5ndGggLSAxXVsnbmFtZSddO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbUJ5SGFyZGZvcmsodG9waWMsIG5hbWUsIGhhcmRmb3JrKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhbiBFSVAgaXMgYWN0aXZhdGVkIGJ5IGVpdGhlciBiZWluZyBpbmNsdWRlZCBpbiB0aGUgRUlQc1xuICAgICAqIG1hbnVhbGx5IHBhc3NlZCBpbiB3aXRoIHRoZSB7QGxpbmsgQ29tbW9uT3B0cy5laXBzfSBvciBpbiBhXG4gICAgICogaGFyZGZvcmsgY3VycmVudGx5IGJlaW5nIGFjdGl2ZVxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2Qgb25seSB3b3JrcyBmb3IgRUlQcyBiZWluZyBzdXBwb3J0ZWRcbiAgICAgKiBieSB0aGUge0BsaW5rIENvbW1vbk9wdHMuZWlwc30gY29uc3RydWN0b3Igb3B0aW9uXG4gICAgICogQHBhcmFtIGVpcFxuICAgICAqL1xuICAgIENvbW1vbi5wcm90b3R5cGUuaXNBY3RpdmF0ZWRFSVAgPSBmdW5jdGlvbiAoZWlwKSB7XG4gICAgICAgIHZhciBlXzEwLCBfYTtcbiAgICAgICAgaWYgKHRoaXMuZWlwcygpLmluY2x1ZGVzKGVpcCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBIQVJERk9SS19DSEFOR0VTXzMgPSBfX3ZhbHVlcyhoYXJkZm9ya3NfMS5oYXJkZm9ya3MpLCBIQVJERk9SS19DSEFOR0VTXzNfMSA9IEhBUkRGT1JLX0NIQU5HRVNfMy5uZXh0KCk7ICFIQVJERk9SS19DSEFOR0VTXzNfMS5kb25lOyBIQVJERk9SS19DSEFOR0VTXzNfMSA9IEhBUkRGT1JLX0NIQU5HRVNfMy5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGZDaGFuZ2VzID0gSEFSREZPUktfQ0hBTkdFU18zXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIGhmID0gaGZDaGFuZ2VzWzFdO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmd0ZUhhcmRmb3JrKGhmWyduYW1lJ10pICYmICdlaXBzJyBpbiBoZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGZbJ2VpcHMnXS5pbmNsdWRlcyhlaXApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xMF8xKSB7IGVfMTAgPSB7IGVycm9yOiBlXzEwXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKEhBUkRGT1JLX0NIQU5HRVNfM18xICYmICFIQVJERk9SS19DSEFOR0VTXzNfMS5kb25lICYmIChfYSA9IEhBUkRGT1JLX0NIQU5HRVNfMy5yZXR1cm4pKSBfYS5jYWxsKEhBUkRGT1JLX0NIQU5HRVNfMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMTApIHRocm93IGVfMTAuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgc2V0IG9yIHByb3ZpZGVkIGhhcmRmb3JrIGlzIGFjdGl2ZSBvbiBibG9jayBudW1iZXJcbiAgICAgKiBAcGFyYW0gaGFyZGZvcmsgSGFyZGZvcmsgbmFtZSBvciBudWxsIChmb3IgSEYgc2V0KVxuICAgICAqIEBwYXJhbSBibG9ja051bWJlclxuICAgICAqIEBwYXJhbSBvcHRzIEhhcmRmb3JrIG9wdGlvbnMgKG9ubHlBY3RpdmUgdW51c2VkKVxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgSEYgaXMgYWN0aXZlIG9uIGJsb2NrIG51bWJlclxuICAgICAqL1xuICAgIENvbW1vbi5wcm90b3R5cGUuaGFyZGZvcmtJc0FjdGl2ZU9uQmxvY2sgPSBmdW5jdGlvbiAoaGFyZGZvcmssIGJsb2NrTnVtYmVyLCBvcHRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgeyBvcHRzID0ge307IH1cbiAgICAgICAgYmxvY2tOdW1iZXIgPSBldGhlcmV1bWpzX3V0aWxfMS50b1R5cGUoYmxvY2tOdW1iZXIsIGV0aGVyZXVtanNfdXRpbF8xLlR5cGVPdXRwdXQuQk4pO1xuICAgICAgICB2YXIgb25seVN1cHBvcnRlZCA9IChfYSA9IG9wdHMub25seVN1cHBvcnRlZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgICAgIGhhcmRmb3JrID0gdGhpcy5fY2hvb3NlSGFyZGZvcmsoaGFyZGZvcmssIG9ubHlTdXBwb3J0ZWQpO1xuICAgICAgICB2YXIgaGZCbG9jayA9IHRoaXMuaGFyZGZvcmtCbG9ja0JOKGhhcmRmb3JrKTtcbiAgICAgICAgaWYgKGhmQmxvY2sgJiYgYmxvY2tOdW1iZXIuZ3RlKGhmQmxvY2spKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbGlhcyB0byBoYXJkZm9ya0lzQWN0aXZlT25CbG9jayB3aGVuIGhhcmRmb3JrIGlzIHNldFxuICAgICAqIEBwYXJhbSBibG9ja051bWJlclxuICAgICAqIEBwYXJhbSBvcHRzIEhhcmRmb3JrIG9wdGlvbnMgKG9ubHlBY3RpdmUgdW51c2VkKVxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgSEYgaXMgYWN0aXZlIG9uIGJsb2NrIG51bWJlclxuICAgICAqL1xuICAgIENvbW1vbi5wcm90b3R5cGUuYWN0aXZlT25CbG9jayA9IGZ1bmN0aW9uIChibG9ja051bWJlciwgb3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXJkZm9ya0lzQWN0aXZlT25CbG9jayhudWxsLCBibG9ja051bWJlciwgb3B0cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXF1ZW5jZSBiYXNlZCBjaGVjayBpZiBnaXZlbiBvciBzZXQgSEYxIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCBIRjJcbiAgICAgKiBAcGFyYW0gaGFyZGZvcmsxIEhhcmRmb3JrIG5hbWUgb3IgbnVsbCAoaWYgc2V0KVxuICAgICAqIEBwYXJhbSBoYXJkZm9yazIgSGFyZGZvcmsgbmFtZVxuICAgICAqIEBwYXJhbSBvcHRzIEhhcmRmb3JrIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIEhGMSBndGUgSEYyXG4gICAgICovXG4gICAgQ29tbW9uLnByb3RvdHlwZS5oYXJkZm9ya0d0ZUhhcmRmb3JrID0gZnVuY3Rpb24gKGhhcmRmb3JrMSwgaGFyZGZvcmsyLCBvcHRzKSB7XG4gICAgICAgIHZhciBlXzExLCBfYTtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgeyBvcHRzID0ge307IH1cbiAgICAgICAgdmFyIG9ubHlBY3RpdmUgPSBvcHRzLm9ubHlBY3RpdmUgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogb3B0cy5vbmx5QWN0aXZlO1xuICAgICAgICBoYXJkZm9yazEgPSB0aGlzLl9jaG9vc2VIYXJkZm9yayhoYXJkZm9yazEsIG9wdHMub25seVN1cHBvcnRlZCk7XG4gICAgICAgIHZhciBoYXJkZm9ya3M7XG4gICAgICAgIGlmIChvbmx5QWN0aXZlKSB7XG4gICAgICAgICAgICBoYXJkZm9ya3MgPSB0aGlzLmFjdGl2ZUhhcmRmb3JrcyhudWxsLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhhcmRmb3JrcyA9IHRoaXMuaGFyZGZvcmtzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBvc0hmMSA9IC0xLCBwb3NIZjIgPSAtMTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIGhhcmRmb3Jrc18yID0gX192YWx1ZXMoaGFyZGZvcmtzKSwgaGFyZGZvcmtzXzJfMSA9IGhhcmRmb3Jrc18yLm5leHQoKTsgIWhhcmRmb3Jrc18yXzEuZG9uZTsgaGFyZGZvcmtzXzJfMSA9IGhhcmRmb3Jrc18yLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBoZiA9IGhhcmRmb3Jrc18yXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGhmWyduYW1lJ10gPT09IGhhcmRmb3JrMSlcbiAgICAgICAgICAgICAgICAgICAgcG9zSGYxID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKGhmWyduYW1lJ10gPT09IGhhcmRmb3JrMilcbiAgICAgICAgICAgICAgICAgICAgcG9zSGYyID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xMV8xKSB7IGVfMTEgPSB7IGVycm9yOiBlXzExXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhcmRmb3Jrc18yXzEgJiYgIWhhcmRmb3Jrc18yXzEuZG9uZSAmJiAoX2EgPSBoYXJkZm9ya3NfMi5yZXR1cm4pKSBfYS5jYWxsKGhhcmRmb3Jrc18yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xMSkgdGhyb3cgZV8xMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3NIZjEgPj0gcG9zSGYyICYmIHBvc0hmMiAhPT0gLTE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbGlhcyB0byBoYXJkZm9ya0d0ZUhhcmRmb3JrIHdoZW4gaGFyZGZvcmsgaXMgc2V0XG4gICAgICogQHBhcmFtIGhhcmRmb3JrIEhhcmRmb3JrIG5hbWVcbiAgICAgKiBAcGFyYW0gb3B0cyBIYXJkZm9yayBvcHRpb25zXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBoYXJkZm9yayBzZXQgaXMgZ3JlYXRlciB0aGFuIGhhcmRmb3JrIHByb3ZpZGVkXG4gICAgICovXG4gICAgQ29tbW9uLnByb3RvdHlwZS5ndGVIYXJkZm9yayA9IGZ1bmN0aW9uIChoYXJkZm9yaywgb3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXJkZm9ya0d0ZUhhcmRmb3JrKG51bGwsIGhhcmRmb3JrLCBvcHRzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBnaXZlbiBvciBzZXQgaGFyZGZvcmsgaXMgYWN0aXZlIG9uIHRoZSBjaGFpblxuICAgICAqIEBwYXJhbSBoYXJkZm9yayBIYXJkZm9yayBuYW1lLCBvcHRpb25hbCBpZiBIRiBzZXRcbiAgICAgKiBAcGFyYW0gb3B0cyBIYXJkZm9yayBvcHRpb25zIChvbmx5QWN0aXZlIHVudXNlZClcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIGhhcmRmb3JrIGlzIGFjdGl2ZSBvbiB0aGUgY2hhaW5cbiAgICAgKi9cbiAgICBDb21tb24ucHJvdG90eXBlLmhhcmRmb3JrSXNBY3RpdmVPbkNoYWluID0gZnVuY3Rpb24gKGhhcmRmb3JrLCBvcHRzKSB7XG4gICAgICAgIHZhciBlXzEyLCBfYTtcbiAgICAgICAgdmFyIF9iO1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7IG9wdHMgPSB7fTsgfVxuICAgICAgICB2YXIgb25seVN1cHBvcnRlZCA9IChfYiA9IG9wdHMub25seVN1cHBvcnRlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgICAgIGhhcmRmb3JrID0gdGhpcy5fY2hvb3NlSGFyZGZvcmsoaGFyZGZvcmssIG9ubHlTdXBwb3J0ZWQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyh0aGlzLmhhcmRmb3JrcygpKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBoZiA9IF9kLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChoZlsnbmFtZSddID09PSBoYXJkZm9yayAmJiBoZlsnYmxvY2snXSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMTJfMSkgeyBlXzEyID0geyBlcnJvcjogZV8xMl8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSBfYS5jYWxsKF9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xMikgdGhyb3cgZV8xMi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFjdGl2ZSBoYXJkZm9yayBzd2l0Y2hlcyBmb3IgdGhlIGN1cnJlbnQgY2hhaW5cbiAgICAgKiBAcGFyYW0gYmxvY2tOdW1iZXIgdXAgdG8gYmxvY2sgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSBmb3IgdGhlIHdob2xlIGNoYWluXG4gICAgICogQHBhcmFtIG9wdHMgSGFyZGZvcmsgb3B0aW9ucyAob25seUFjdGl2ZSB1bnVzZWQpXG4gICAgICogQHJldHVybiBBcnJheSB3aXRoIGhhcmRmb3JrIGFycmF5c1xuICAgICAqL1xuICAgIENvbW1vbi5wcm90b3R5cGUuYWN0aXZlSGFyZGZvcmtzID0gZnVuY3Rpb24gKGJsb2NrTnVtYmVyLCBvcHRzKSB7XG4gICAgICAgIHZhciBlXzEzLCBfYTtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgeyBvcHRzID0ge307IH1cbiAgICAgICAgdmFyIGFjdGl2ZUhhcmRmb3JrcyA9IFtdO1xuICAgICAgICB2YXIgaGZzID0gdGhpcy5oYXJkZm9ya3MoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIGhmc18yID0gX192YWx1ZXMoaGZzKSwgaGZzXzJfMSA9IGhmc18yLm5leHQoKTsgIWhmc18yXzEuZG9uZTsgaGZzXzJfMSA9IGhmc18yLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBoZiA9IGhmc18yXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGhmWydibG9jayddID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgIT09IHVuZGVmaW5lZCAmJiBibG9ja051bWJlciAhPT0gbnVsbCAmJiBibG9ja051bWJlciA8IGhmWydibG9jayddKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5vbmx5U3VwcG9ydGVkICYmICF0aGlzLl9pc1N1cHBvcnRlZEhhcmRmb3JrKGhmWyduYW1lJ10pKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBhY3RpdmVIYXJkZm9ya3MucHVzaChoZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMTNfMSkgeyBlXzEzID0geyBlcnJvcjogZV8xM18xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChoZnNfMl8xICYmICFoZnNfMl8xLmRvbmUgJiYgKF9hID0gaGZzXzIucmV0dXJuKSkgX2EuY2FsbChoZnNfMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMTMpIHRocm93IGVfMTMuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aXZlSGFyZGZvcmtzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGF0ZXN0IGFjdGl2ZSBoYXJkZm9yayBuYW1lIGZvciBjaGFpbiBvciBibG9jayBvciB0aHJvd3MgaWYgdW5hdmFpbGFibGVcbiAgICAgKiBAcGFyYW0gYmxvY2tOdW1iZXIgdXAgdG8gYmxvY2sgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSBmb3IgdGhlIHdob2xlIGNoYWluXG4gICAgICogQHBhcmFtIG9wdHMgSGFyZGZvcmsgb3B0aW9ucyAob25seUFjdGl2ZSB1bnVzZWQpXG4gICAgICogQHJldHVybiBIYXJkZm9yayBuYW1lXG4gICAgICovXG4gICAgQ29tbW9uLnByb3RvdHlwZS5hY3RpdmVIYXJkZm9yayA9IGZ1bmN0aW9uIChibG9ja051bWJlciwgb3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7IG9wdHMgPSB7fTsgfVxuICAgICAgICB2YXIgYWN0aXZlSGFyZGZvcmtzID0gdGhpcy5hY3RpdmVIYXJkZm9ya3MoYmxvY2tOdW1iZXIsIG9wdHMpO1xuICAgICAgICBpZiAoYWN0aXZlSGFyZGZvcmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBhY3RpdmVIYXJkZm9ya3NbYWN0aXZlSGFyZGZvcmtzLmxlbmd0aCAtIDFdWyduYW1lJ107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyAoc3VwcG9ydGVkKSBhY3RpdmUgaGFyZGZvcmsgZm91bmRcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhhcmRmb3JrIGNoYW5nZSBibG9jayBmb3IgaGFyZGZvcmsgcHJvdmlkZWQgb3Igc2V0XG4gICAgICogQHBhcmFtIGhhcmRmb3JrIEhhcmRmb3JrIG5hbWUsIG9wdGlvbmFsIGlmIEhGIHNldFxuICAgICAqIEByZXR1cm5zIEJsb2NrIG51bWJlclxuICAgICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgaGFyZGZvcmtCbG9ja0JOKCkgZm9yIGxhcmdlIG51bWJlciBzdXBwb3J0XG4gICAgICovXG4gICAgQ29tbW9uLnByb3RvdHlwZS5oYXJkZm9ya0Jsb2NrID0gZnVuY3Rpb24gKGhhcmRmb3JrKSB7XG4gICAgICAgIHJldHVybiBldGhlcmV1bWpzX3V0aWxfMS50b1R5cGUodGhpcy5oYXJkZm9ya0Jsb2NrQk4oaGFyZGZvcmspLCBldGhlcmV1bWpzX3V0aWxfMS5UeXBlT3V0cHV0Lk51bWJlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoYXJkZm9yayBjaGFuZ2UgYmxvY2sgZm9yIGhhcmRmb3JrIHByb3ZpZGVkIG9yIHNldFxuICAgICAqIEBwYXJhbSBoYXJkZm9yayBIYXJkZm9yayBuYW1lLCBvcHRpb25hbCBpZiBIRiBzZXRcbiAgICAgKiBAcmV0dXJucyBCbG9jayBudW1iZXJcbiAgICAgKi9cbiAgICBDb21tb24ucHJvdG90eXBlLmhhcmRmb3JrQmxvY2tCTiA9IGZ1bmN0aW9uIChoYXJkZm9yaykge1xuICAgICAgICBoYXJkZm9yayA9IHRoaXMuX2Nob29zZUhhcmRmb3JrKGhhcmRmb3JrLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4odGhpcy5fZ2V0SGFyZGZvcmsoaGFyZGZvcmspWydibG9jayddKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRydWUgaWYgYmxvY2sgbnVtYmVyIHByb3ZpZGVkIGlzIHRoZSBoYXJkZm9yayAoZ2l2ZW4gb3Igc2V0KSBjaGFuZ2UgYmxvY2tcbiAgICAgKiBAcGFyYW0gYmxvY2tOdW1iZXIgTnVtYmVyIG9mIHRoZSBibG9jayB0byBjaGVja1xuICAgICAqIEBwYXJhbSBoYXJkZm9yayBIYXJkZm9yayBuYW1lLCBvcHRpb25hbCBpZiBIRiBzZXRcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIGJsb2NrTnVtYmVyIGlzIEhGIGJsb2NrXG4gICAgICovXG4gICAgQ29tbW9uLnByb3RvdHlwZS5pc0hhcmRmb3JrQmxvY2sgPSBmdW5jdGlvbiAoYmxvY2tOdW1iZXIsIGhhcmRmb3JrKSB7XG4gICAgICAgIGJsb2NrTnVtYmVyID0gZXRoZXJldW1qc191dGlsXzEudG9UeXBlKGJsb2NrTnVtYmVyLCBldGhlcmV1bWpzX3V0aWxfMS5UeXBlT3V0cHV0LkJOKTtcbiAgICAgICAgaGFyZGZvcmsgPSB0aGlzLl9jaG9vc2VIYXJkZm9yayhoYXJkZm9yaywgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5oYXJkZm9ya0Jsb2NrQk4oaGFyZGZvcmspLmVxKGJsb2NrTnVtYmVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNoYW5nZSBibG9jayBmb3IgdGhlIG5leHQgaGFyZGZvcmsgYWZ0ZXIgdGhlIGhhcmRmb3JrIHByb3ZpZGVkIG9yIHNldFxuICAgICAqIEBwYXJhbSBoYXJkZm9yayBIYXJkZm9yayBuYW1lLCBvcHRpb25hbCBpZiBIRiBzZXRcbiAgICAgKiBAcmV0dXJucyBCbG9jayBudW1iZXIgb3IgbnVsbCBpZiBub3QgYXZhaWxhYmxlXG4gICAgICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBuZXh0SGFyZGZvcmtCbG9ja0JOKCkgZm9yIGxhcmdlIG51bWJlciBzdXBwb3J0XG4gICAgICovXG4gICAgQ29tbW9uLnByb3RvdHlwZS5uZXh0SGFyZGZvcmtCbG9jayA9IGZ1bmN0aW9uIChoYXJkZm9yaykge1xuICAgICAgICB2YXIgYmxvY2sgPSB0aGlzLm5leHRIYXJkZm9ya0Jsb2NrQk4oaGFyZGZvcmspO1xuICAgICAgICByZXR1cm4gYmxvY2sgPT09IG51bGwgPyBudWxsIDogZXRoZXJldW1qc191dGlsXzEudG9UeXBlKGJsb2NrLCBldGhlcmV1bWpzX3V0aWxfMS5UeXBlT3V0cHV0Lk51bWJlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjaGFuZ2UgYmxvY2sgZm9yIHRoZSBuZXh0IGhhcmRmb3JrIGFmdGVyIHRoZSBoYXJkZm9yayBwcm92aWRlZCBvciBzZXRcbiAgICAgKiBAcGFyYW0gaGFyZGZvcmsgSGFyZGZvcmsgbmFtZSwgb3B0aW9uYWwgaWYgSEYgc2V0XG4gICAgICogQHJldHVybnMgQmxvY2sgbnVtYmVyIG9yIG51bGwgaWYgbm90IGF2YWlsYWJsZVxuICAgICAqL1xuICAgIENvbW1vbi5wcm90b3R5cGUubmV4dEhhcmRmb3JrQmxvY2tCTiA9IGZ1bmN0aW9uIChoYXJkZm9yaykge1xuICAgICAgICBoYXJkZm9yayA9IHRoaXMuX2Nob29zZUhhcmRmb3JrKGhhcmRmb3JrLCBmYWxzZSk7XG4gICAgICAgIHZhciBoZkJsb2NrID0gdGhpcy5oYXJkZm9ya0Jsb2NrQk4oaGFyZGZvcmspO1xuICAgICAgICAvLyBOZXh0IGZvcmsgYmxvY2sgbnVtYmVyIG9yIG51bGwgaWYgbm9uZSBhdmFpbGFibGVcbiAgICAgICAgLy8gTG9naWM6IGlmIGFjY3VtdWxhdG9yIGlzIHN0aWxsIG51bGwgYW5kIG9uIHRoZSBmaXJzdCBvY2N1cmVuY2Ugb2ZcbiAgICAgICAgLy8gYSBibG9jayBncmVhdGVyIHRoYW4gdGhlIGN1cnJlbnQgaGZCbG9jayBzZXQgdGhlIGFjY3VtdWxhdG9yLFxuICAgICAgICAvLyBwYXNzIG9uIHRoZSBhY2N1bXVsYXRvciBhcyB0aGUgZmluYWwgcmVzdWx0IGZyb20gdGhpcyB0aW1lIG9uXG4gICAgICAgIHZhciBuZXh0SGZCbG9jayA9IHRoaXMuaGFyZGZvcmtzKCkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGhmKSB7XG4gICAgICAgICAgICB2YXIgYmxvY2sgPSBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4oaGYuYmxvY2spO1xuICAgICAgICAgICAgcmV0dXJuIGJsb2NrLmd0KGhmQmxvY2spICYmIGFjYyA9PT0gbnVsbCA/IGJsb2NrIDogYWNjO1xuICAgICAgICB9LCBudWxsKTtcbiAgICAgICAgcmV0dXJuIG5leHRIZkJsb2NrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiBibG9jayBudW1iZXIgcHJvdmlkZWQgaXMgdGhlIGhhcmRmb3JrIGNoYW5nZSBibG9jayBmb2xsb3dpbmcgdGhlIGhhcmRmb3JrIGdpdmVuIG9yIHNldFxuICAgICAqIEBwYXJhbSBibG9ja051bWJlciBOdW1iZXIgb2YgdGhlIGJsb2NrIHRvIGNoZWNrXG4gICAgICogQHBhcmFtIGhhcmRmb3JrIEhhcmRmb3JrIG5hbWUsIG9wdGlvbmFsIGlmIEhGIHNldFxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgYmxvY2tOdW1iZXIgaXMgSEYgYmxvY2tcbiAgICAgKi9cbiAgICBDb21tb24ucHJvdG90eXBlLmlzTmV4dEhhcmRmb3JrQmxvY2sgPSBmdW5jdGlvbiAoYmxvY2tOdW1iZXIsIGhhcmRmb3JrKSB7XG4gICAgICAgIGJsb2NrTnVtYmVyID0gZXRoZXJldW1qc191dGlsXzEudG9UeXBlKGJsb2NrTnVtYmVyLCBldGhlcmV1bWpzX3V0aWxfMS5UeXBlT3V0cHV0LkJOKTtcbiAgICAgICAgaGFyZGZvcmsgPSB0aGlzLl9jaG9vc2VIYXJkZm9yayhoYXJkZm9yaywgZmFsc2UpO1xuICAgICAgICB2YXIgbmV4dEhhcmRmb3JrQmxvY2sgPSB0aGlzLm5leHRIYXJkZm9ya0Jsb2NrQk4oaGFyZGZvcmspO1xuICAgICAgICByZXR1cm4gbmV4dEhhcmRmb3JrQmxvY2sgPT09IG51bGwgPyBmYWxzZSA6IG5leHRIYXJkZm9ya0Jsb2NrLmVxKGJsb2NrTnVtYmVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiB0byBjYWxjdWxhdGUgYSBmb3JrIGhhc2hcbiAgICAgKiBAcGFyYW0gaGFyZGZvcmsgSGFyZGZvcmsgbmFtZVxuICAgICAqIEByZXR1cm5zIEZvcmsgaGFzaCBhcyBoZXggc3RyaW5nXG4gICAgICovXG4gICAgQ29tbW9uLnByb3RvdHlwZS5fY2FsY0ZvcmtIYXNoID0gZnVuY3Rpb24gKGhhcmRmb3JrKSB7XG4gICAgICAgIHZhciBlXzE0LCBfYTtcbiAgICAgICAgdmFyIGdlbmVzaXMgPSBCdWZmZXIuZnJvbSh0aGlzLmdlbmVzaXMoKS5oYXNoLnN1YnN0cigyKSwgJ2hleCcpO1xuICAgICAgICB2YXIgaGZCdWZmZXIgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgIHZhciBwcmV2QmxvY2sgPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzLmhhcmRmb3JrcygpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBoZiA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBibG9jayA9IGhmLmJsb2NrO1xuICAgICAgICAgICAgICAgIC8vIFNraXAgZm9yIGNoYWluc3RhcnQgKDApLCBub3QgYXBwbGllZCBIRnMgKG51bGwpIGFuZFxuICAgICAgICAgICAgICAgIC8vIHdoZW4gYWxyZWFkeSBhcHBsaWVkIG9uIHNhbWUgYmxvY2sgbnVtYmVyIEhGc1xuICAgICAgICAgICAgICAgIGlmIChibG9jayAhPT0gMCAmJiBibG9jayAhPT0gbnVsbCAmJiBibG9jayAhPT0gcHJldkJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZkJsb2NrQnVmZmVyID0gQnVmZmVyLmZyb20oYmxvY2sudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDE2LCAnMCcpLCAnaGV4Jyk7XG4gICAgICAgICAgICAgICAgICAgIGhmQnVmZmVyID0gQnVmZmVyLmNvbmNhdChbaGZCdWZmZXIsIGhmQmxvY2tCdWZmZXJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhmLm5hbWUgPT09IGhhcmRmb3JrKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBwcmV2QmxvY2sgPSBibG9jaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xNF8xKSB7IGVfMTQgPSB7IGVycm9yOiBlXzE0XzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzE0KSB0aHJvdyBlXzE0LmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0QnVmZmVyID0gQnVmZmVyLmNvbmNhdChbZ2VuZXNpcywgaGZCdWZmZXJdKTtcbiAgICAgICAgLy8gQ1JDMzIgZGVsaXZlcnMgcmVzdWx0IGFzIHNpZ25lZCAobmVnYXRpdmUpIDMyLWJpdCBpbnRlZ2VyLFxuICAgICAgICAvLyBjb252ZXJ0IHRvIGhleCBzdHJpbmdcbiAgICAgICAgdmFyIGZvcmtoYXNoID0gZXRoZXJldW1qc191dGlsXzEuaW50VG9CdWZmZXIoY3JjXzMyXzEuYnVmKGlucHV0QnVmZmVyKSA+Pj4gMCkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICByZXR1cm4gXCIweFwiICsgZm9ya2hhc2g7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGV0aC82NCBjb21wbGlhbnQgZm9yayBoYXNoIChFSVAtMjEyNClcbiAgICAgKiBAcGFyYW0gaGFyZGZvcmsgSGFyZGZvcmsgbmFtZSwgb3B0aW9uYWwgaWYgSEYgc2V0XG4gICAgICovXG4gICAgQ29tbW9uLnByb3RvdHlwZS5mb3JrSGFzaCA9IGZ1bmN0aW9uIChoYXJkZm9yaykge1xuICAgICAgICBoYXJkZm9yayA9IHRoaXMuX2Nob29zZUhhcmRmb3JrKGhhcmRmb3JrLCBmYWxzZSk7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZ2V0SGFyZGZvcmsoaGFyZGZvcmspO1xuICAgICAgICBpZiAoZGF0YVsnYmxvY2snXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG1zZyA9ICdObyBmb3JrIGhhc2ggY2FsY3VsYXRpb24gcG9zc2libGUgZm9yIG5vbi1hcHBsaWVkIG9yIGZ1dHVyZSBoYXJkZm9yayc7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YVsnZm9ya0hhc2gnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVsnZm9ya0hhc2gnXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FsY0ZvcmtIYXNoKGhhcmRmb3JrKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcmtIYXNoIEZvcmsgaGFzaCBhcyBhIGhleCBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyBBcnJheSB3aXRoIGhhcmRmb3JrIGRhdGEgKG5hbWUsIGJsb2NrLCBmb3JrSGFzaClcbiAgICAgKi9cbiAgICBDb21tb24ucHJvdG90eXBlLmhhcmRmb3JrRm9yRm9ya0hhc2ggPSBmdW5jdGlvbiAoZm9ya0hhc2gpIHtcbiAgICAgICAgdmFyIHJlc0FycmF5ID0gdGhpcy5oYXJkZm9ya3MoKS5maWx0ZXIoZnVuY3Rpb24gKGhmKSB7XG4gICAgICAgICAgICByZXR1cm4gaGYuZm9ya0hhc2ggPT09IGZvcmtIYXNoO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc0FycmF5Lmxlbmd0aCA+PSAxID8gcmVzQXJyYXlbcmVzQXJyYXkubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgR2VuZXNpcyBwYXJhbWV0ZXJzIG9mIGN1cnJlbnQgY2hhaW5cbiAgICAgKiBAcmV0dXJucyBHZW5lc2lzIGRpY3Rpb25hcnlcbiAgICAgKi9cbiAgICBDb21tb24ucHJvdG90eXBlLmdlbmVzaXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFpblBhcmFtc1snZ2VuZXNpcyddO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGFyZGZvcmtzIGZvciBjdXJyZW50IGNoYWluXG4gICAgICogQHJldHVybnMge0FycmF5fSBBcnJheSB3aXRoIGFycmF5cyBvZiBoYXJkZm9ya3NcbiAgICAgKi9cbiAgICBDb21tb24ucHJvdG90eXBlLmhhcmRmb3JrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYWluUGFyYW1zWydoYXJkZm9ya3MnXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYm9vdHN0cmFwIG5vZGVzIGZvciB0aGUgY3VycmVudCBjaGFpblxuICAgICAqIEByZXR1cm5zIHtEaWN0aW9uYXJ5fSBEaWN0IHdpdGggYm9vdHN0cmFwIG5vZGVzXG4gICAgICovXG4gICAgQ29tbW9uLnByb3RvdHlwZS5ib290c3RyYXBOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYWluUGFyYW1zWydib290c3RyYXBOb2RlcyddO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBETlMgbmV0d29ya3MgZm9yIHRoZSBjdXJyZW50IGNoYWluXG4gICAgICogQHJldHVybnMge1N0cmluZ1tdfSBBcnJheSBvZiBETlMgRU5SIHVybHNcbiAgICAgKi9cbiAgICBDb21tb24ucHJvdG90eXBlLmRuc05ldHdvcmtzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhaW5QYXJhbXNbJ2Ruc05ldHdvcmtzJ107XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoYXJkZm9yayBzZXRcbiAgICAgKiBAcmV0dXJucyBIYXJkZm9yayBuYW1lXG4gICAgICovXG4gICAgQ29tbW9uLnByb3RvdHlwZS5oYXJkZm9yayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhcmRmb3JrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSWQgb2YgY3VycmVudCBjaGFpblxuICAgICAqIEByZXR1cm5zIGNoYWluIElkXG4gICAgICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBjaGFpbklkQk4oKSBmb3IgbGFyZ2UgbnVtYmVyIHN1cHBvcnRcbiAgICAgKi9cbiAgICBDb21tb24ucHJvdG90eXBlLmNoYWluSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBldGhlcmV1bWpzX3V0aWxfMS50b1R5cGUodGhpcy5jaGFpbklkQk4oKSwgZXRoZXJldW1qc191dGlsXzEuVHlwZU91dHB1dC5OdW1iZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSWQgb2YgY3VycmVudCBjaGFpblxuICAgICAqIEByZXR1cm5zIGNoYWluIElkXG4gICAgICovXG4gICAgQ29tbW9uLnByb3RvdHlwZS5jaGFpbklkQk4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4odGhpcy5fY2hhaW5QYXJhbXNbJ2NoYWluSWQnXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIGN1cnJlbnQgY2hhaW5cbiAgICAgKiBAcmV0dXJucyBjaGFpbiBuYW1lIChsb3dlciBjYXNlKVxuICAgICAqL1xuICAgIENvbW1vbi5wcm90b3R5cGUuY2hhaW5OYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhaW5QYXJhbXNbJ25hbWUnXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIElkIG9mIGN1cnJlbnQgbmV0d29ya1xuICAgICAqIEByZXR1cm5zIG5ldHdvcmsgSWRcbiAgICAgKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIG5ldHdvcmtJZEJOKCkgZm9yIGxhcmdlIG51bWJlciBzdXBwb3J0XG4gICAgICovXG4gICAgQ29tbW9uLnByb3RvdHlwZS5uZXR3b3JrSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBldGhlcmV1bWpzX3V0aWxfMS50b1R5cGUodGhpcy5uZXR3b3JrSWRCTigpLCBldGhlcmV1bWpzX3V0aWxfMS5UeXBlT3V0cHV0Lk51bWJlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBJZCBvZiBjdXJyZW50IG5ldHdvcmtcbiAgICAgKiBAcmV0dXJucyBuZXR3b3JrIElkXG4gICAgICovXG4gICAgQ29tbW9uLnByb3RvdHlwZS5uZXR3b3JrSWRCTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTih0aGlzLl9jaGFpblBhcmFtc1snbmV0d29ya0lkJ10pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYWN0aXZlIEVJUHNcbiAgICAgKiBAcmV0dXJucyBMaXN0IG9mIEVJUHNcbiAgICAgKi9cbiAgICBDb21tb24ucHJvdG90eXBlLmVpcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9laXBzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29uc2Vuc3VzIHR5cGUgb2YgdGhlIG5ldHdvcmtcbiAgICAgKiBQb3NzaWJsZSB2YWx1ZXM6IFwicG93XCJ8XCJwb2FcIlxuICAgICAqL1xuICAgIENvbW1vbi5wcm90b3R5cGUuY29uc2Vuc3VzVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYWluUGFyYW1zWydjb25zZW5zdXMnXVsndHlwZSddO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29uY3JldGUgY29uc2Vuc3VzIGltcGxlbWVudGF0aW9uXG4gICAgICogYWxnb3JpdGhtIG9yIHByb3RvY29sIGZvciB0aGUgbmV0d29ya1xuICAgICAqIGUuZy4gXCJldGhhc2hcIiBmb3IgXCJwb3dcIiBjb25zZW5zdXMgdHlwZSBvclxuICAgICAqIFwiY2xpcXVlXCIgZm9yIFwicG9hXCIgY29uc2Vuc3VzIHR5cGVcbiAgICAgKi9cbiAgICBDb21tb24ucHJvdG90eXBlLmNvbnNlbnN1c0FsZ29yaXRobSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYWluUGFyYW1zWydjb25zZW5zdXMnXVsnYWxnb3JpdGhtJ107XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZGljdGlvbmFyeSB3aXRoIGNvbnNlbnN1cyBjb25maWd1cmF0aW9uXG4gICAgICogcGFyYW1ldGVycyBiYXNlZCBvbiB0aGUgY29uc2Vuc3VzIGFsZ29yaXRobVxuICAgICAqXG4gICAgICogRXhwZWN0ZWQgcmV0dXJucyAocGFyYW1ldGVycyBtdXN0IGJlIHByZXNlbnQgaW5cbiAgICAgKiB0aGUgcmVzcGVjdGl2ZSBjaGFpbiBqc29uIGZpbGVzKTpcbiAgICAgKlxuICAgICAqIGV0aGFzaDogLVxuICAgICAqIGNsaXF1ZTogcGVyaW9kLCBlcG9jaFxuICAgICAqIGF1cmE6IC1cbiAgICAgKi9cbiAgICBDb21tb24ucHJvdG90eXBlLmNvbnNlbnN1c0NvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYWluUGFyYW1zWydjb25zZW5zdXMnXVt0aGlzLmNvbnNlbnN1c0FsZ29yaXRobSgpXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBkZWVwIGNvcHkgb2YgdGhpcyB7QGxpbmsgQ29tbW9ufSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBDb21tb24ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpKSwgdGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29tbW9uO1xufShldmVudHNfMS5FdmVudEVtaXR0ZXIpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENvbW1vbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGxlZ2FjeVRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiLi9sZWdhY3lUcmFuc2FjdGlvblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYW5zYWN0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsZWdhY3lUcmFuc2FjdGlvbl8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgZWlwMjkzMFRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiLi9laXAyOTMwVHJhbnNhY3Rpb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBY2Nlc3NMaXN0RUlQMjkzMFRyYW5zYWN0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlaXAyOTMwVHJhbnNhY3Rpb25fMS5kZWZhdWx0OyB9IH0pO1xudmFyIHRyYW5zYWN0aW9uRmFjdG9yeV8xID0gcmVxdWlyZShcIi4vdHJhbnNhY3Rpb25GYWN0b3J5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhbnNhY3Rpb25GYWN0b3J5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cmFuc2FjdGlvbkZhY3RvcnlfMS5kZWZhdWx0OyB9IH0pO1xudmFyIGVpcDE1NTlUcmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIi4vZWlwMTU1OVRyYW5zYWN0aW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmVlTWFya2V0RUlQMTU1OVRyYW5zYWN0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlaXAxNTU5VHJhbnNhY3Rpb25fMS5kZWZhdWx0OyB9IH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVzXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7XG4gIFRSQU5TQUNUSU9OX1RZUEVTLFxuICBUUkFOU0FDVElPTl9TVEFUVVNFUyxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5cbmV4cG9ydCBjb25zdCBQRU5ESU5HX1NUQVRVU19IQVNIID0ge1xuICBbVFJBTlNBQ1RJT05fU1RBVFVTRVMuVU5BUFBST1ZFRF06IHRydWUsXG4gIFtUUkFOU0FDVElPTl9TVEFUVVNFUy5BUFBST1ZFRF06IHRydWUsXG4gIFtUUkFOU0FDVElPTl9TVEFUVVNFUy5TVUJNSVRURURdOiB0cnVlLFxuICBbVFJBTlNBQ1RJT05fU1RBVFVTRVMuUEVORElOR106IHRydWUsXG59O1xuXG5leHBvcnQgY29uc3QgUFJJT1JJVFlfU1RBVFVTX0hBU0ggPSB7XG4gIC4uLlBFTkRJTkdfU1RBVFVTX0hBU0gsXG4gIFtUUkFOU0FDVElPTl9TVEFUVVNFUy5DT05GSVJNRURdOiB0cnVlLFxufTtcblxuZXhwb3J0IGNvbnN0IFRPS0VOX0NBVEVHT1JZX0hBU0ggPSB7XG4gIFtUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfQVBQUk9WRV06IHRydWUsXG4gIFtUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfVFJBTlNGRVJdOiB0cnVlLFxuICBbVFJBTlNBQ1RJT05fVFlQRVMuVE9LRU5fTUVUSE9EX1RSQU5TRkVSX0ZST01dOiB0cnVlLFxufTtcblxuZXhwb3J0IGNvbnN0IFRSQU5TQUNUSU9OX0VOVkVMT1BFX1RZUEVfTkFNRVMgPSB7XG4gIEZFRV9NQVJLRVQ6ICdmZWUtbWFya2V0JyxcbiAgTEVHQUNZOiAnbGVnYWN5Jyxcbn07XG4iLCJpbXBvcnQgeyBTV0FQU19DSEFJTklEX0RFRkFVTFRfVE9LRU5fTUFQIH0gZnJvbSAnLi4vY29uc3RhbnRzL3N3YXBzJztcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgcHJvdmlkZWQgYWRkcmVzcyBpcyBzdHJpY3RseSBlcXVhbCB0byB0aGUgYWRkcmVzcyBmb3JcbiAqIHRoZSBkZWZhdWx0IHN3YXBzIHRva2VuIG9mIHRoZSBwcm92aWRlZCBjaGFpbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIFRoZSBzdHJpbmcgdG8gY29tcGFyZSB0byB0aGUgZGVmYXVsdCB0b2tlbiBhZGRyZXNzXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhaW5JZCAtIFRoZSBoZXggZW5jb2RlZCBjaGFpbiBJRCBvZiB0aGUgZGVmYXVsdCBzd2FwcyB0b2tlbiB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGFkZHJlc3MgaXMgdGhlIHByb3ZpZGVkIGNoYWluJ3MgZGVmYXVsdCB0b2tlbiBhZGRyZXNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1N3YXBzRGVmYXVsdFRva2VuQWRkcmVzcyhhZGRyZXNzLCBjaGFpbklkKSB7XG4gIGlmICghYWRkcmVzcyB8fCAhY2hhaW5JZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBhZGRyZXNzID09PSBTV0FQU19DSEFJTklEX0RFRkFVTFRfVE9LRU5fTUFQW2NoYWluSWRdPy5hZGRyZXNzO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBwcm92aWRlZCBzeW1ib2wgaXMgc3RyaWN0bHkgZXF1YWwgdG8gdGhlIHN5bWJvbCBmb3JcbiAqIHRoZSBkZWZhdWx0IHN3YXBzIHRva2VuIG9mIHRoZSBwcm92aWRlZCBjaGFpbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIC0gVGhlIHN0cmluZyB0byBjb21wYXJlIHRvIHRoZSBkZWZhdWx0IHRva2VuIHN5bWJvbFxuICogQHBhcmFtIHtzdHJpbmd9IGNoYWluSWQgLSBUaGUgaGV4IGVuY29kZWQgY2hhaW4gSUQgb2YgdGhlIGRlZmF1bHQgc3dhcHMgdG9rZW4gdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBzeW1ibCBpcyB0aGUgcHJvdmlkZWQgY2hhaW4ncyBkZWZhdWx0IHRva2VuIHN5bWJvbFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTd2Fwc0RlZmF1bHRUb2tlblN5bWJvbChzeW1ib2wsIGNoYWluSWQpIHtcbiAgaWYgKCFzeW1ib2wgfHwgIWNoYWluSWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gc3ltYm9sID09PSBTV0FQU19DSEFJTklEX0RFRkFVTFRfVE9LRU5fTUFQW2NoYWluSWRdPy5zeW1ib2w7XG59XG4iLCJpbXBvcnQgYWJpIGZyb20gJ2V0aGVyZXVtanMtYWJpJztcbmltcG9ydCB7XG4gIGFkZEN1cnJlbmNpZXMsXG4gIGNvbnZlcnNpb25VdGlsLFxuICBjb252ZXJzaW9uR1RFLFxuICBtdWx0aXBseUN1cnJlbmNpZXMsXG4gIGNvbnZlcnNpb25HcmVhdGVyVGhhbixcbiAgY29udmVyc2lvbkxlc3NUaGFuLFxufSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9jb252ZXJzaW9uLnV0aWxzJztcblxuaW1wb3J0IHsgY2FsY1Rva2VuQW1vdW50IH0gZnJvbSAnLi4vLi4vaGVscGVycy91dGlscy90b2tlbi11dGlsJztcbmltcG9ydCB7IGFkZEhleFByZWZpeCB9IGZyb20gJy4uLy4uLy4uL2FwcC9zY3JpcHRzL2xpYi91dGlsJztcbmltcG9ydCB7IEVSQzIwLCBFUkM3MjEgfSBmcm9tICcuLi8uLi9oZWxwZXJzL2NvbnN0YW50cy9jb21tb24nO1xuaW1wb3J0IHtcbiAgVE9LRU5fVFJBTlNGRVJfRlVOQ1RJT05fU0lHTkFUVVJFLFxuICBDT0xMRUNUSUJMRV9UUkFOU0ZFUl9GUk9NX0ZVTkNUSU9OX1NJR05BVFVSRSxcbn0gZnJvbSAnLi9zZW5kLmNvbnN0YW50cyc7XG5cbmV4cG9ydCB7XG4gIGFkZEdhc0J1ZmZlcixcbiAgY2FsY0dhc1RvdGFsLFxuICBnZXRBc3NldFRyYW5zZmVyRGF0YSxcbiAgZ2VuZXJhdGVFUkMyMFRyYW5zZmVyRGF0YSxcbiAgZ2VuZXJhdGVFUkM3MjFUcmFuc2ZlckRhdGEsXG4gIGlzQmFsYW5jZVN1ZmZpY2llbnQsXG4gIGlzVG9rZW5CYWxhbmNlU3VmZmljaWVudCxcbiAgZWxsaXBzaWZ5LFxufTtcblxuZnVuY3Rpb24gY2FsY0dhc1RvdGFsKGdhc0xpbWl0ID0gJzAnLCBnYXNQcmljZSA9ICcwJykge1xuICByZXR1cm4gbXVsdGlwbHlDdXJyZW5jaWVzKGdhc0xpbWl0LCBnYXNQcmljZSwge1xuICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxuICAgIG11bHRpcGxpY2FuZEJhc2U6IDE2LFxuICAgIG11bHRpcGxpZXJCYXNlOiAxNixcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzQmFsYW5jZVN1ZmZpY2llbnQoe1xuICBhbW91bnQgPSAnMHgwJyxcbiAgYmFsYW5jZSA9ICcweDAnLFxuICBjb252ZXJzaW9uUmF0ZSA9IDEsXG4gIGdhc1RvdGFsID0gJzB4MCcsXG4gIHByaW1hcnlDdXJyZW5jeSxcbn0pIHtcbiAgY29uc3QgdG90YWxBbW91bnQgPSBhZGRDdXJyZW5jaWVzKGFtb3VudCwgZ2FzVG90YWwsIHtcbiAgICBhQmFzZTogMTYsXG4gICAgYkJhc2U6IDE2LFxuICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxuICB9KTtcblxuICBjb25zdCBiYWxhbmNlSXNTdWZmaWNpZW50ID0gY29udmVyc2lvbkdURShcbiAgICB7XG4gICAgICB2YWx1ZTogYmFsYW5jZSxcbiAgICAgIGZyb21OdW1lcmljQmFzZTogJ2hleCcsXG4gICAgICBmcm9tQ3VycmVuY3k6IHByaW1hcnlDdXJyZW5jeSxcbiAgICAgIGNvbnZlcnNpb25SYXRlLFxuICAgIH0sXG4gICAge1xuICAgICAgdmFsdWU6IHRvdGFsQW1vdW50LFxuICAgICAgZnJvbU51bWVyaWNCYXNlOiAnaGV4JyxcbiAgICAgIGNvbnZlcnNpb25SYXRlLFxuICAgICAgZnJvbUN1cnJlbmN5OiBwcmltYXJ5Q3VycmVuY3ksXG4gICAgfSxcbiAgKTtcblxuICByZXR1cm4gYmFsYW5jZUlzU3VmZmljaWVudDtcbn1cblxuZnVuY3Rpb24gaXNUb2tlbkJhbGFuY2VTdWZmaWNpZW50KHsgYW1vdW50ID0gJzB4MCcsIHRva2VuQmFsYW5jZSwgZGVjaW1hbHMgfSkge1xuICBjb25zdCBhbW91bnRJbkRlYyA9IGNvbnZlcnNpb25VdGlsKGFtb3VudCwge1xuICAgIGZyb21OdW1lcmljQmFzZTogJ2hleCcsXG4gIH0pO1xuXG4gIGNvbnN0IHRva2VuQmFsYW5jZUlzU3VmZmljaWVudCA9IGNvbnZlcnNpb25HVEUoXG4gICAge1xuICAgICAgdmFsdWU6IHRva2VuQmFsYW5jZSxcbiAgICAgIGZyb21OdW1lcmljQmFzZTogJ2hleCcsXG4gICAgfSxcbiAgICB7XG4gICAgICB2YWx1ZTogY2FsY1Rva2VuQW1vdW50KGFtb3VudEluRGVjLCBkZWNpbWFscyksXG4gICAgfSxcbiAgKTtcblxuICByZXR1cm4gdG9rZW5CYWxhbmNlSXNTdWZmaWNpZW50O1xufVxuXG5mdW5jdGlvbiBhZGRHYXNCdWZmZXIoXG4gIGluaXRpYWxHYXNMaW1pdEhleCxcbiAgYmxvY2tHYXNMaW1pdEhleCxcbiAgYnVmZmVyTXVsdGlwbGllciA9IDEuNSxcbikge1xuICBjb25zdCB1cHBlckdhc0xpbWl0ID0gbXVsdGlwbHlDdXJyZW5jaWVzKGJsb2NrR2FzTGltaXRIZXgsIDAuOSwge1xuICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxuICAgIG11bHRpcGxpY2FuZEJhc2U6IDE2LFxuICAgIG11bHRpcGxpZXJCYXNlOiAxMCxcbiAgICBudW1iZXJPZkRlY2ltYWxzOiAnMCcsXG4gIH0pO1xuICBjb25zdCBidWZmZXJlZEdhc0xpbWl0ID0gbXVsdGlwbHlDdXJyZW5jaWVzKFxuICAgIGluaXRpYWxHYXNMaW1pdEhleCxcbiAgICBidWZmZXJNdWx0aXBsaWVyLFxuICAgIHtcbiAgICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxuICAgICAgbXVsdGlwbGljYW5kQmFzZTogMTYsXG4gICAgICBtdWx0aXBsaWVyQmFzZTogMTAsXG4gICAgICBudW1iZXJPZkRlY2ltYWxzOiAnMCcsXG4gICAgfSxcbiAgKTtcblxuICAvLyBpZiBpbml0aWFsR2FzTGltaXQgaXMgYWJvdmUgYmxvY2tHYXNMaW1pdCwgZG9udCBtb2RpZnkgaXRcbiAgaWYgKFxuICAgIGNvbnZlcnNpb25HcmVhdGVyVGhhbihcbiAgICAgIHsgdmFsdWU6IGluaXRpYWxHYXNMaW1pdEhleCwgZnJvbU51bWVyaWNCYXNlOiAnaGV4JyB9LFxuICAgICAgeyB2YWx1ZTogdXBwZXJHYXNMaW1pdCwgZnJvbU51bWVyaWNCYXNlOiAnaGV4JyB9LFxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuIGluaXRpYWxHYXNMaW1pdEhleDtcbiAgfVxuICAvLyBpZiBidWZmZXJlZEdhc0xpbWl0IGlzIGJlbG93IGJsb2NrR2FzTGltaXQsIHVzZSBidWZmZXJlZEdhc0xpbWl0XG4gIGlmIChcbiAgICBjb252ZXJzaW9uTGVzc1RoYW4oXG4gICAgICB7IHZhbHVlOiBidWZmZXJlZEdhc0xpbWl0LCBmcm9tTnVtZXJpY0Jhc2U6ICdoZXgnIH0sXG4gICAgICB7IHZhbHVlOiB1cHBlckdhc0xpbWl0LCBmcm9tTnVtZXJpY0Jhc2U6ICdoZXgnIH0sXG4gICAgKVxuICApIHtcbiAgICByZXR1cm4gYnVmZmVyZWRHYXNMaW1pdDtcbiAgfVxuICAvLyBvdGhlcndpc2UgdXNlIGJsb2NrR2FzTGltaXRcbiAgcmV0dXJuIHVwcGVyR2FzTGltaXQ7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlRVJDMjBUcmFuc2ZlckRhdGEoe1xuICB0b0FkZHJlc3MgPSAnMHgwJyxcbiAgYW1vdW50ID0gJzB4MCcsXG4gIHNlbmRUb2tlbixcbn0pIHtcbiAgaWYgKCFzZW5kVG9rZW4pIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiAoXG4gICAgVE9LRU5fVFJBTlNGRVJfRlVOQ1RJT05fU0lHTkFUVVJFICtcbiAgICBBcnJheS5wcm90b3R5cGUubWFwXG4gICAgICAuY2FsbChcbiAgICAgICAgYWJpLnJhd0VuY29kZShcbiAgICAgICAgICBbJ2FkZHJlc3MnLCAndWludDI1NiddLFxuICAgICAgICAgIFt0b0FkZHJlc3MsIGFkZEhleFByZWZpeChhbW91bnQpXSxcbiAgICAgICAgKSxcbiAgICAgICAgKHgpID0+IGAwMCR7eC50b1N0cmluZygxNil9YC5zbGljZSgtMiksXG4gICAgICApXG4gICAgICAuam9pbignJylcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVFUkM3MjFUcmFuc2ZlckRhdGEoe1xuICB0b0FkZHJlc3MgPSAnMHgwJyxcbiAgZnJvbUFkZHJlc3MgPSAnMHgwJyxcbiAgdG9rZW5JZCxcbn0pIHtcbiAgaWYgKCF0b2tlbklkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gKFxuICAgIENPTExFQ1RJQkxFX1RSQU5TRkVSX0ZST01fRlVOQ1RJT05fU0lHTkFUVVJFICtcbiAgICBBcnJheS5wcm90b3R5cGUubWFwXG4gICAgICAuY2FsbChcbiAgICAgICAgYWJpLnJhd0VuY29kZShcbiAgICAgICAgICBbJ2FkZHJlc3MnLCAnYWRkcmVzcycsICd1aW50MjU2J10sXG4gICAgICAgICAgW2Zyb21BZGRyZXNzLCB0b0FkZHJlc3MsIHRva2VuSWRdLFxuICAgICAgICApLFxuICAgICAgICAoeCkgPT4gYDAwJHt4LnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSxcbiAgICAgIClcbiAgICAgIC5qb2luKCcnKVxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRBc3NldFRyYW5zZmVyRGF0YSh7IHNlbmRUb2tlbiwgZnJvbUFkZHJlc3MsIHRvQWRkcmVzcywgYW1vdW50IH0pIHtcbiAgc3dpdGNoIChzZW5kVG9rZW4uc3RhbmRhcmQpIHtcbiAgICBjYXNlIEVSQzcyMTpcbiAgICAgIHJldHVybiBnZW5lcmF0ZUVSQzcyMVRyYW5zZmVyRGF0YSh7XG4gICAgICAgIHRvQWRkcmVzcyxcbiAgICAgICAgZnJvbUFkZHJlc3MsXG4gICAgICAgIHRva2VuSWQ6IHNlbmRUb2tlbi50b2tlbklkLFxuICAgICAgfSk7XG4gICAgY2FzZSBFUkMyMDpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGdlbmVyYXRlRVJDMjBUcmFuc2ZlckRhdGEoe1xuICAgICAgICB0b0FkZHJlc3MsXG4gICAgICAgIGFtb3VudCxcbiAgICAgICAgc2VuZFRva2VuLFxuICAgICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZWxsaXBzaWZ5KHRleHQsIGZpcnN0ID0gNiwgbGFzdCA9IDQpIHtcbiAgcmV0dXJuIGAke3RleHQuc2xpY2UoMCwgZmlyc3QpfS4uLiR7dGV4dC5zbGljZSgtbGFzdCl9YDtcbn1cbiIsIi8vIHRoZSB3aGF0d2ctZmV0Y2ggcG9seWZpbGwgaW5zdGFsbHMgdGhlIGZldGNoKCkgZnVuY3Rpb25cbi8vIG9uIHRoZSBnbG9iYWwgb2JqZWN0ICh3aW5kb3cgb3Igc2VsZilcbi8vXG4vLyBSZXR1cm4gdGhhdCBhcyB0aGUgZXhwb3J0IGZvciB1c2UgaW4gV2VicGFjaywgQnJvd3NlcmlmeSBldGMuXG5yZXF1aXJlKCd3aGF0d2ctZmV0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gc2VsZi5mZXRjaC5iaW5kKHNlbGYpO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBleHBvcnRzLnJuZyA9IGV4cG9ydHMucHNldWRvUmFuZG9tQnl0ZXMgPSBleHBvcnRzLnBybmcgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpXG5leHBvcnRzLmNyZWF0ZUhhc2ggPSBleHBvcnRzLkhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpXG5leHBvcnRzLmNyZWF0ZUhtYWMgPSBleHBvcnRzLkhtYWMgPSByZXF1aXJlKCdjcmVhdGUtaG1hYycpXG5cbnZhciBhbGdvcyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktc2lnbi9hbGdvcycpXG52YXIgYWxnb0tleXMgPSBPYmplY3Qua2V5cyhhbGdvcylcbnZhciBoYXNoZXMgPSBbJ3NoYTEnLCAnc2hhMjI0JywgJ3NoYTI1NicsICdzaGEzODQnLCAnc2hhNTEyJywgJ21kNScsICdybWQxNjAnXS5jb25jYXQoYWxnb0tleXMpXG5leHBvcnRzLmdldEhhc2hlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGhhc2hlc1xufVxuXG52YXIgcCA9IHJlcXVpcmUoJ3Bia2RmMicpXG5leHBvcnRzLnBia2RmMiA9IHAucGJrZGYyXG5leHBvcnRzLnBia2RmMlN5bmMgPSBwLnBia2RmMlN5bmNcblxudmFyIGFlcyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktY2lwaGVyJylcblxuZXhwb3J0cy5DaXBoZXIgPSBhZXMuQ2lwaGVyXG5leHBvcnRzLmNyZWF0ZUNpcGhlciA9IGFlcy5jcmVhdGVDaXBoZXJcbmV4cG9ydHMuQ2lwaGVyaXYgPSBhZXMuQ2lwaGVyaXZcbmV4cG9ydHMuY3JlYXRlQ2lwaGVyaXYgPSBhZXMuY3JlYXRlQ2lwaGVyaXZcbmV4cG9ydHMuRGVjaXBoZXIgPSBhZXMuRGVjaXBoZXJcbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXIgPSBhZXMuY3JlYXRlRGVjaXBoZXJcbmV4cG9ydHMuRGVjaXBoZXJpdiA9IGFlcy5EZWNpcGhlcml2XG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyaXYgPSBhZXMuY3JlYXRlRGVjaXBoZXJpdlxuZXhwb3J0cy5nZXRDaXBoZXJzID0gYWVzLmdldENpcGhlcnNcbmV4cG9ydHMubGlzdENpcGhlcnMgPSBhZXMubGlzdENpcGhlcnNcblxudmFyIGRoID0gcmVxdWlyZSgnZGlmZmllLWhlbGxtYW4nKVxuXG5leHBvcnRzLkRpZmZpZUhlbGxtYW5Hcm91cCA9IGRoLkRpZmZpZUhlbGxtYW5Hcm91cFxuZXhwb3J0cy5jcmVhdGVEaWZmaWVIZWxsbWFuR3JvdXAgPSBkaC5jcmVhdGVEaWZmaWVIZWxsbWFuR3JvdXBcbmV4cG9ydHMuZ2V0RGlmZmllSGVsbG1hbiA9IGRoLmdldERpZmZpZUhlbGxtYW5cbmV4cG9ydHMuY3JlYXRlRGlmZmllSGVsbG1hbiA9IGRoLmNyZWF0ZURpZmZpZUhlbGxtYW5cbmV4cG9ydHMuRGlmZmllSGVsbG1hbiA9IGRoLkRpZmZpZUhlbGxtYW5cblxudmFyIHNpZ24gPSByZXF1aXJlKCdicm93c2VyaWZ5LXNpZ24nKVxuXG5leHBvcnRzLmNyZWF0ZVNpZ24gPSBzaWduLmNyZWF0ZVNpZ25cbmV4cG9ydHMuU2lnbiA9IHNpZ24uU2lnblxuZXhwb3J0cy5jcmVhdGVWZXJpZnkgPSBzaWduLmNyZWF0ZVZlcmlmeVxuZXhwb3J0cy5WZXJpZnkgPSBzaWduLlZlcmlmeVxuXG5leHBvcnRzLmNyZWF0ZUVDREggPSByZXF1aXJlKCdjcmVhdGUtZWNkaCcpXG5cbnZhciBwdWJsaWNFbmNyeXB0ID0gcmVxdWlyZSgncHVibGljLWVuY3J5cHQnKVxuXG5leHBvcnRzLnB1YmxpY0VuY3J5cHQgPSBwdWJsaWNFbmNyeXB0LnB1YmxpY0VuY3J5cHRcbmV4cG9ydHMucHJpdmF0ZUVuY3J5cHQgPSBwdWJsaWNFbmNyeXB0LnByaXZhdGVFbmNyeXB0XG5leHBvcnRzLnB1YmxpY0RlY3J5cHQgPSBwdWJsaWNFbmNyeXB0LnB1YmxpY0RlY3J5cHRcbmV4cG9ydHMucHJpdmF0ZURlY3J5cHQgPSBwdWJsaWNFbmNyeXB0LnByaXZhdGVEZWNyeXB0XG5cbi8vIHRoZSBsZWFzdCBJIGNhbiBkbyBpcyBtYWtlIGVycm9yIG1lc3NhZ2VzIGZvciB0aGUgcmVzdCBvZiB0aGUgbm9kZS5qcy9jcnlwdG8gYXBpLlxuLy8gO1tcbi8vICAgJ2NyZWF0ZUNyZWRlbnRpYWxzJ1xuLy8gXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4vLyAgIGV4cG9ydHNbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4vLyAgICAgdGhyb3cgbmV3IEVycm9yKFtcbi8vICAgICAgICdzb3JyeSwgJyArIG5hbWUgKyAnIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQnLFxuLy8gICAgICAgJ3dlIGFjY2VwdCBwdWxsIHJlcXVlc3RzJyxcbi8vICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvLWJyb3dzZXJpZnkvY3J5cHRvLWJyb3dzZXJpZnknXG4vLyAgICAgXS5qb2luKCdcXG4nKSlcbi8vICAgfVxuLy8gfSlcblxudmFyIHJmID0gcmVxdWlyZSgncmFuZG9tZmlsbCcpXG5cbmV4cG9ydHMucmFuZG9tRmlsbCA9IHJmLnJhbmRvbUZpbGxcbmV4cG9ydHMucmFuZG9tRmlsbFN5bmMgPSByZi5yYW5kb21GaWxsU3luY1xuXG5leHBvcnRzLmNyZWF0ZUNyZWRlbnRpYWxzID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoW1xuICAgICdzb3JyeSwgY3JlYXRlQ3JlZGVudGlhbHMgaXMgbm90IGltcGxlbWVudGVkIHlldCcsXG4gICAgJ3dlIGFjY2VwdCBwdWxsIHJlcXVlc3RzJyxcbiAgICAnaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0by1icm93c2VyaWZ5L2NyeXB0by1icm93c2VyaWZ5J1xuICBdLmpvaW4oJ1xcbicpKVxufVxuXG5leHBvcnRzLmNvbnN0YW50cyA9IHtcbiAgJ0RIX0NIRUNLX1BfTk9UX1NBRkVfUFJJTUUnOiAyLFxuICAnREhfQ0hFQ0tfUF9OT1RfUFJJTUUnOiAxLFxuICAnREhfVU5BQkxFX1RPX0NIRUNLX0dFTkVSQVRPUic6IDQsXG4gICdESF9OT1RfU1VJVEFCTEVfR0VORVJBVE9SJzogOCxcbiAgJ05QTl9FTkFCTEVEJzogMSxcbiAgJ0FMUE5fRU5BQkxFRCc6IDEsXG4gICdSU0FfUEtDUzFfUEFERElORyc6IDEsXG4gICdSU0FfU1NMVjIzX1BBRERJTkcnOiAyLFxuICAnUlNBX05PX1BBRERJTkcnOiAzLFxuICAnUlNBX1BLQ1MxX09BRVBfUEFERElORyc6IDQsXG4gICdSU0FfWDkzMV9QQURESU5HJzogNSxcbiAgJ1JTQV9QS0NTMV9QU1NfUEFERElORyc6IDYsXG4gICdQT0lOVF9DT05WRVJTSU9OX0NPTVBSRVNTRUQnOiAyLFxuICAnUE9JTlRfQ09OVkVSU0lPTl9VTkNPTVBSRVNTRUQnOiA0LFxuICAnUE9JTlRfQ09OVkVSU0lPTl9IWUJSSUQnOiA2XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWRkcmVzcyA9IHZvaWQgMDtcbnZhciBhc3NlcnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXNzZXJ0XCIpKTtcbnZhciBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG52YXIgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xudmFyIGFjY291bnRfMSA9IHJlcXVpcmUoXCIuL2FjY291bnRcIik7XG52YXIgQWRkcmVzcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBZGRyZXNzKGJ1Zikge1xuICAgICAgICBhc3NlcnRfMS5kZWZhdWx0KGJ1Zi5sZW5ndGggPT09IDIwLCAnSW52YWxpZCBhZGRyZXNzIGxlbmd0aCcpO1xuICAgICAgICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgemVybyBhZGRyZXNzLlxuICAgICAqL1xuICAgIEFkZHJlc3MuemVybyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKGJ5dGVzXzEuemVyb3MoMjApKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gQWRkcmVzcyBvYmplY3QgZnJvbSBhIGhleC1lbmNvZGVkIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gc3RyIC0gSGV4LWVuY29kZWQgYWRkcmVzc1xuICAgICAqL1xuICAgIEFkZHJlc3MuZnJvbVN0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgYXNzZXJ0XzEuZGVmYXVsdChhY2NvdW50XzEuaXNWYWxpZEFkZHJlc3Moc3RyKSwgJ0ludmFsaWQgYWRkcmVzcycpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoYnl0ZXNfMS50b0J1ZmZlcihzdHIpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYWRkcmVzcyBmb3IgYSBnaXZlbiBwdWJsaWMga2V5LlxuICAgICAqIEBwYXJhbSBwdWJLZXkgVGhlIHR3byBwb2ludHMgb2YgYW4gdW5jb21wcmVzc2VkIGtleVxuICAgICAqL1xuICAgIEFkZHJlc3MuZnJvbVB1YmxpY0tleSA9IGZ1bmN0aW9uIChwdWJLZXkpIHtcbiAgICAgICAgYXNzZXJ0XzEuZGVmYXVsdChCdWZmZXIuaXNCdWZmZXIocHViS2V5KSwgJ1B1YmxpYyBrZXkgc2hvdWxkIGJlIEJ1ZmZlcicpO1xuICAgICAgICB2YXIgYnVmID0gYWNjb3VudF8xLnB1YlRvQWRkcmVzcyhwdWJLZXkpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoYnVmKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYWRkcmVzcyBmb3IgYSBnaXZlbiBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBBIHByaXZhdGUga2V5IG11c3QgYmUgMjU2IGJpdHMgd2lkZVxuICAgICAqL1xuICAgIEFkZHJlc3MuZnJvbVByaXZhdGVLZXkgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgICAgICBhc3NlcnRfMS5kZWZhdWx0KEJ1ZmZlci5pc0J1ZmZlcihwcml2YXRlS2V5KSwgJ1ByaXZhdGUga2V5IHNob3VsZCBiZSBCdWZmZXInKTtcbiAgICAgICAgdmFyIGJ1ZiA9IGFjY291bnRfMS5wcml2YXRlVG9BZGRyZXNzKHByaXZhdGVLZXkpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoYnVmKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhbiBhZGRyZXNzIGZvciBhIG5ld2x5IGNyZWF0ZWQgY29udHJhY3QuXG4gICAgICogQHBhcmFtIGZyb20gVGhlIGFkZHJlc3Mgd2hpY2ggaXMgY3JlYXRpbmcgdGhpcyBuZXcgYWRkcmVzc1xuICAgICAqIEBwYXJhbSBub25jZSBUaGUgbm9uY2Ugb2YgdGhlIGZyb20gYWNjb3VudFxuICAgICAqL1xuICAgIEFkZHJlc3MuZ2VuZXJhdGUgPSBmdW5jdGlvbiAoZnJvbSwgbm9uY2UpIHtcbiAgICAgICAgYXNzZXJ0XzEuZGVmYXVsdChibl9qc18xLmRlZmF1bHQuaXNCTihub25jZSkpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoYWNjb3VudF8xLmdlbmVyYXRlQWRkcmVzcyhmcm9tLmJ1Ziwgbm9uY2UudG9BcnJheUxpa2UoQnVmZmVyKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGFuIGFkZHJlc3MgZm9yIGEgY29udHJhY3QgY3JlYXRlZCB1c2luZyBDUkVBVEUyLlxuICAgICAqIEBwYXJhbSBmcm9tIFRoZSBhZGRyZXNzIHdoaWNoIGlzIGNyZWF0aW5nIHRoaXMgbmV3IGFkZHJlc3NcbiAgICAgKiBAcGFyYW0gc2FsdCBBIHNhbHRcbiAgICAgKiBAcGFyYW0gaW5pdENvZGUgVGhlIGluaXQgY29kZSBvZiB0aGUgY29udHJhY3QgYmVpbmcgY3JlYXRlZFxuICAgICAqL1xuICAgIEFkZHJlc3MuZ2VuZXJhdGUyID0gZnVuY3Rpb24gKGZyb20sIHNhbHQsIGluaXRDb2RlKSB7XG4gICAgICAgIGFzc2VydF8xLmRlZmF1bHQoQnVmZmVyLmlzQnVmZmVyKHNhbHQpKTtcbiAgICAgICAgYXNzZXJ0XzEuZGVmYXVsdChCdWZmZXIuaXNCdWZmZXIoaW5pdENvZGUpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKGFjY291bnRfMS5nZW5lcmF0ZUFkZHJlc3MyKGZyb20uYnVmLCBzYWx0LCBpbml0Q29kZSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSXMgYWRkcmVzcyBlcXVhbCB0byBhbm90aGVyLlxuICAgICAqL1xuICAgIEFkZHJlc3MucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi5lcXVhbHMoYWRkcmVzcy5idWYpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSXMgYWRkcmVzcyB6ZXJvLlxuICAgICAqL1xuICAgIEFkZHJlc3MucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKEFkZHJlc3MuemVybygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRydWUgaWYgYWRkcmVzcyBpcyBpbiB0aGUgYWRkcmVzcyByYW5nZSBkZWZpbmVkXG4gICAgICogYnkgRUlQLTEzNTJcbiAgICAgKi9cbiAgICBBZGRyZXNzLnByb3RvdHlwZS5pc1ByZWNvbXBpbGVPclN5c3RlbUFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhZGRyZXNzQk4gPSBuZXcgYm5fanNfMS5kZWZhdWx0KHRoaXMuYnVmKTtcbiAgICAgICAgdmFyIHJhbmdlTWluID0gbmV3IGJuX2pzXzEuZGVmYXVsdCgwKTtcbiAgICAgICAgdmFyIHJhbmdlTWF4ID0gbmV3IGJuX2pzXzEuZGVmYXVsdCgnZmZmZicsICdoZXgnKTtcbiAgICAgICAgcmV0dXJuIGFkZHJlc3NCTi5ndGUocmFuZ2VNaW4pICYmIGFkZHJlc3NCTi5sdGUocmFuZ2VNYXgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBoZXggZW5jb2Rpbmcgb2YgYWRkcmVzcy5cbiAgICAgKi9cbiAgICBBZGRyZXNzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcweCcgKyB0aGlzLmJ1Zi50b1N0cmluZygnaGV4Jyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIEJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiBhZGRyZXNzLlxuICAgICAqL1xuICAgIEFkZHJlc3MucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5idWYpO1xuICAgIH07XG4gICAgcmV0dXJuIEFkZHJlc3M7XG59KCkpO1xuZXhwb3J0cy5BZGRyZXNzID0gQWRkcmVzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZHJlc3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRvVHlwZSA9IGV4cG9ydHMuVHlwZU91dHB1dCA9IGV4cG9ydHMuYm5Ub1JscCA9IGV4cG9ydHMuYm5Ub1VucGFkZGVkQnVmZmVyID0gZXhwb3J0cy5iblRvSGV4ID0gdm9pZCAwO1xudmFyIGJuX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJuLmpzXCIpKTtcbnZhciBldGhqc191dGlsXzEgPSByZXF1aXJlKFwiZXRoanMtdXRpbFwiKTtcbnZhciBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG4vKipcbiAqIENvbnZlcnQgQk4gdG8gMHgtcHJlZml4ZWQgaGV4IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYm5Ub0hleCh2YWx1ZSkge1xuICAgIHJldHVybiBcIjB4XCIgKyB2YWx1ZS50b1N0cmluZygxNik7XG59XG5leHBvcnRzLmJuVG9IZXggPSBiblRvSGV4O1xuLyoqXG4gKiBDb252ZXJ0IHZhbHVlIGZyb20gQk4gdG8gYW4gdW5wYWRkZWQgQnVmZmVyXG4gKiAodXNlZnVsIGZvciBSTFAgdHJhbnNwb3J0KVxuICogQHBhcmFtIHZhbHVlIHZhbHVlIHRvIGNvbnZlcnRcbiAqL1xuZnVuY3Rpb24gYm5Ub1VucGFkZGVkQnVmZmVyKHZhbHVlKSB7XG4gICAgLy8gVXNpbmcgYGJuLnRvQXJyYXlMaWtlKEJ1ZmZlcilgIGluc3RlYWQgb2YgYGJuLnRvQnVmZmVyKClgXG4gICAgLy8gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBicm93c2VyaWZ5IGFuZCBzaW1pbGFyIHRvb2xzXG4gICAgcmV0dXJuIGJ5dGVzXzEudW5wYWRCdWZmZXIodmFsdWUudG9BcnJheUxpa2UoQnVmZmVyKSk7XG59XG5leHBvcnRzLmJuVG9VbnBhZGRlZEJ1ZmZlciA9IGJuVG9VbnBhZGRlZEJ1ZmZlcjtcbi8qKlxuICogRGVwcmVjYXRlZCBhbGlhcyBmb3Ige0BsaW5rIGJuVG9VbnBhZGRlZEJ1ZmZlcn1cbiAqIEBkZXByZWNhdGVkXG4gKi9cbmZ1bmN0aW9uIGJuVG9SbHAodmFsdWUpIHtcbiAgICByZXR1cm4gYm5Ub1VucGFkZGVkQnVmZmVyKHZhbHVlKTtcbn1cbmV4cG9ydHMuYm5Ub1JscCA9IGJuVG9SbHA7XG4vKipcbiAqIFR5cGUgb3V0cHV0IG9wdGlvbnNcbiAqL1xudmFyIFR5cGVPdXRwdXQ7XG4oZnVuY3Rpb24gKFR5cGVPdXRwdXQpIHtcbiAgICBUeXBlT3V0cHV0W1R5cGVPdXRwdXRbXCJOdW1iZXJcIl0gPSAwXSA9IFwiTnVtYmVyXCI7XG4gICAgVHlwZU91dHB1dFtUeXBlT3V0cHV0W1wiQk5cIl0gPSAxXSA9IFwiQk5cIjtcbiAgICBUeXBlT3V0cHV0W1R5cGVPdXRwdXRbXCJCdWZmZXJcIl0gPSAyXSA9IFwiQnVmZmVyXCI7XG4gICAgVHlwZU91dHB1dFtUeXBlT3V0cHV0W1wiUHJlZml4ZWRIZXhTdHJpbmdcIl0gPSAzXSA9IFwiUHJlZml4ZWRIZXhTdHJpbmdcIjtcbn0pKFR5cGVPdXRwdXQgPSBleHBvcnRzLlR5cGVPdXRwdXQgfHwgKGV4cG9ydHMuVHlwZU91dHB1dCA9IHt9KSk7XG4vKipcbiAqIENvbnZlcnQgYW4gaW5wdXQgdG8gYSBzcGVjaWZpZWQgdHlwZVxuICogQHBhcmFtIGlucHV0IHZhbHVlIHRvIGNvbnZlcnRcbiAqIEBwYXJhbSBvdXRwdXRUeXBlIHR5cGUgdG8gb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIHRvVHlwZShpbnB1dCwgb3V0cHV0VHlwZSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnICYmICFldGhqc191dGlsXzEuaXNIZXhTdHJpbmcoaW5wdXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgc3RyaW5nIG11c3QgYmUgcHJvdmlkZWQgd2l0aCBhIDB4LXByZWZpeCwgZ2l2ZW46IFwiICsgaW5wdXQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInICYmICFOdW1iZXIuaXNTYWZlSW50ZWdlcihpbnB1dCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgbnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiBNQVhfU0FGRV9JTlRFR0VSIChwbGVhc2UgdXNlIGFuIGFsdGVybmF0aXZlIGlucHV0IHR5cGUpJyk7XG4gICAgfVxuICAgIGlucHV0ID0gYnl0ZXNfMS50b0J1ZmZlcihpbnB1dCk7XG4gICAgaWYgKG91dHB1dFR5cGUgPT09IFR5cGVPdXRwdXQuQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgZWxzZSBpZiAob3V0cHV0VHlwZSA9PT0gVHlwZU91dHB1dC5CTikge1xuICAgICAgICByZXR1cm4gbmV3IGJuX2pzXzEuZGVmYXVsdChpbnB1dCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG91dHB1dFR5cGUgPT09IFR5cGVPdXRwdXQuTnVtYmVyKSB7XG4gICAgICAgIHZhciBibiA9IG5ldyBibl9qc18xLmRlZmF1bHQoaW5wdXQpO1xuICAgICAgICB2YXIgbWF4ID0gbmV3IGJuX2pzXzEuZGVmYXVsdChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUi50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKGJuLmd0KG1heCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHByb3ZpZGVkIG51bWJlciBpcyBncmVhdGVyIHRoYW4gTUFYX1NBRkVfSU5URUdFUiAocGxlYXNlIHVzZSBhbiBhbHRlcm5hdGl2ZSBvdXRwdXQgdHlwZSknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm4udG9OdW1iZXIoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIG91dHB1dFR5cGUgPT09IFR5cGVPdXRwdXQuUHJlZml4ZWRIZXhTdHJpbmdcbiAgICAgICAgcmV0dXJuIFwiMHhcIiArIGlucHV0LnRvU3RyaW5nKCdoZXgnKTtcbiAgICB9XG59XG5leHBvcnRzLnRvVHlwZSA9IHRvVHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5iYVRvSlNPTiA9IGV4cG9ydHMuYWRkSGV4UHJlZml4ID0gZXhwb3J0cy50b1Vuc2lnbmVkID0gZXhwb3J0cy5mcm9tU2lnbmVkID0gZXhwb3J0cy5idWZmZXJUb0hleCA9IGV4cG9ydHMuYnVmZmVyVG9JbnQgPSBleHBvcnRzLnRvQnVmZmVyID0gZXhwb3J0cy51bnBhZEhleFN0cmluZyA9IGV4cG9ydHMudW5wYWRBcnJheSA9IGV4cG9ydHMudW5wYWRCdWZmZXIgPSBleHBvcnRzLnNldExlbmd0aFJpZ2h0ID0gZXhwb3J0cy5zZXRMZW5ndGhMZWZ0ID0gZXhwb3J0cy56ZXJvcyA9IHZvaWQgMDtcbnZhciBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG52YXIgZXRoanNfdXRpbF8xID0gcmVxdWlyZShcImV0aGpzLXV0aWxcIik7XG52YXIgaGVscGVyc18xID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcbi8qKlxuICogUmV0dXJucyBhIGJ1ZmZlciBmaWxsZWQgd2l0aCAwcy5cbiAqIEBwYXJhbSBieXRlcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBidWZmZXIgc2hvdWxkIGJlXG4gKi9cbmV4cG9ydHMuemVyb3MgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKGJ5dGVzKS5maWxsKDApO1xufTtcbi8qKlxuICogUGFkcyBhIGBCdWZmZXJgIHdpdGggemVyb3MgdGlsbCBpdCBoYXMgYGxlbmd0aGAgYnl0ZXMuXG4gKiBUcnVuY2F0ZXMgdGhlIGJlZ2lubmluZyBvciBlbmQgb2YgaW5wdXQgaWYgaXRzIGxlbmd0aCBleGNlZWRzIGBsZW5ndGhgLlxuICogQHBhcmFtIG1zZyB0aGUgdmFsdWUgdG8gcGFkIChCdWZmZXIpXG4gKiBAcGFyYW0gbGVuZ3RoIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIG91dHB1dCBzaG91bGQgYmVcbiAqIEBwYXJhbSByaWdodCB3aGV0aGVyIHRvIHN0YXJ0IHBhZGRpbmcgZm9ybSB0aGUgbGVmdCBvciByaWdodFxuICogQHJldHVybiAoQnVmZmVyKVxuICovXG52YXIgc2V0TGVuZ3RoID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoLCByaWdodCkge1xuICAgIHZhciBidWYgPSBleHBvcnRzLnplcm9zKGxlbmd0aCk7XG4gICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgIGlmIChtc2cubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBtc2cuY29weShidWYpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXNnLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobXNnLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgbXNnLmNvcHkoYnVmLCBsZW5ndGggLSBtc2cubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBidWY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1zZy5zbGljZSgtbGVuZ3RoKTtcbiAgICB9XG59O1xuLyoqXG4gKiBMZWZ0IFBhZHMgYSBgQnVmZmVyYCB3aXRoIGxlYWRpbmcgemVyb3MgdGlsbCBpdCBoYXMgYGxlbmd0aGAgYnl0ZXMuXG4gKiBPciBpdCB0cnVuY2F0ZXMgdGhlIGJlZ2lubmluZyBpZiBpdCBleGNlZWRzLlxuICogQHBhcmFtIG1zZyB0aGUgdmFsdWUgdG8gcGFkIChCdWZmZXIpXG4gKiBAcGFyYW0gbGVuZ3RoIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIG91dHB1dCBzaG91bGQgYmVcbiAqIEByZXR1cm4gKEJ1ZmZlcilcbiAqL1xuZXhwb3J0cy5zZXRMZW5ndGhMZWZ0ID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoKSB7XG4gICAgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKG1zZyk7XG4gICAgcmV0dXJuIHNldExlbmd0aChtc2csIGxlbmd0aCwgZmFsc2UpO1xufTtcbi8qKlxuICogUmlnaHQgUGFkcyBhIGBCdWZmZXJgIHdpdGggdHJhaWxpbmcgemVyb3MgdGlsbCBpdCBoYXMgYGxlbmd0aGAgYnl0ZXMuXG4gKiBpdCB0cnVuY2F0ZXMgdGhlIGVuZCBpZiBpdCBleGNlZWRzLlxuICogQHBhcmFtIG1zZyB0aGUgdmFsdWUgdG8gcGFkIChCdWZmZXIpXG4gKiBAcGFyYW0gbGVuZ3RoIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIG91dHB1dCBzaG91bGQgYmVcbiAqIEByZXR1cm4gKEJ1ZmZlcilcbiAqL1xuZXhwb3J0cy5zZXRMZW5ndGhSaWdodCA9IGZ1bmN0aW9uIChtc2csIGxlbmd0aCkge1xuICAgIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcihtc2cpO1xuICAgIHJldHVybiBzZXRMZW5ndGgobXNnLCBsZW5ndGgsIHRydWUpO1xufTtcbi8qKlxuICogVHJpbXMgbGVhZGluZyB6ZXJvcyBmcm9tIGEgYEJ1ZmZlcmAsIGBTdHJpbmdgIG9yIGBOdW1iZXJbXWAuXG4gKiBAcGFyYW0gYSAoQnVmZmVyfEFycmF5fFN0cmluZylcbiAqIEByZXR1cm4gKEJ1ZmZlcnxBcnJheXxTdHJpbmcpXG4gKi9cbnZhciBzdHJpcFplcm9zID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgZmlyc3QgPSBhWzBdO1xuICAgIHdoaWxlIChhLmxlbmd0aCA+IDAgJiYgZmlyc3QudG9TdHJpbmcoKSA9PT0gJzAnKSB7XG4gICAgICAgIGEgPSBhLnNsaWNlKDEpO1xuICAgICAgICBmaXJzdCA9IGFbMF07XG4gICAgfVxuICAgIHJldHVybiBhO1xufTtcbi8qKlxuICogVHJpbXMgbGVhZGluZyB6ZXJvcyBmcm9tIGEgYEJ1ZmZlcmAuXG4gKiBAcGFyYW0gYSAoQnVmZmVyKVxuICogQHJldHVybiAoQnVmZmVyKVxuICovXG5leHBvcnRzLnVucGFkQnVmZmVyID0gZnVuY3Rpb24gKGEpIHtcbiAgICBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIoYSk7XG4gICAgcmV0dXJuIHN0cmlwWmVyb3MoYSk7XG59O1xuLyoqXG4gKiBUcmltcyBsZWFkaW5nIHplcm9zIGZyb20gYW4gYEFycmF5YCAob2YgbnVtYmVycykuXG4gKiBAcGFyYW0gYSAobnVtYmVyW10pXG4gKiBAcmV0dXJuIChudW1iZXJbXSlcbiAqL1xuZXhwb3J0cy51bnBhZEFycmF5ID0gZnVuY3Rpb24gKGEpIHtcbiAgICBoZWxwZXJzXzEuYXNzZXJ0SXNBcnJheShhKTtcbiAgICByZXR1cm4gc3RyaXBaZXJvcyhhKTtcbn07XG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhIGhleC1wcmVmaXhlZCBgU3RyaW5nYC5cbiAqIEBwYXJhbSBhIChTdHJpbmcpXG4gKiBAcmV0dXJuIChTdHJpbmcpXG4gKi9cbmV4cG9ydHMudW5wYWRIZXhTdHJpbmcgPSBmdW5jdGlvbiAoYSkge1xuICAgIGhlbHBlcnNfMS5hc3NlcnRJc0hleFN0cmluZyhhKTtcbiAgICBhID0gZXRoanNfdXRpbF8xLnN0cmlwSGV4UHJlZml4KGEpO1xuICAgIHJldHVybiBzdHJpcFplcm9zKGEpO1xufTtcbi8qKlxuICogQXR0ZW1wdHMgdG8gdHVybiBhIHZhbHVlIGludG8gYSBgQnVmZmVyYC5cbiAqIElucHV0cyBzdXBwb3J0ZWQ6IGBCdWZmZXJgLCBgU3RyaW5nYCAoaGV4LXByZWZpeGVkKSwgYE51bWJlcmAsIG51bGwvdW5kZWZpbmVkLCBgQk5gIGFuZCBvdGhlciBvYmplY3RzXG4gKiB3aXRoIGEgYHRvQXJyYXkoKWAgb3IgYHRvQnVmZmVyKClgIG1ldGhvZC5cbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZVxuICovXG5leHBvcnRzLnRvQnVmZmVyID0gZnVuY3Rpb24gKHYpIHtcbiAgICBpZiAodiA9PT0gbnVsbCB8fCB2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKTtcbiAgICB9XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2KSkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odik7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHYpIHx8IHYgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoIWV0aGpzX3V0aWxfMS5pc0hleFN0cmluZyh2KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnZlcnQgc3RyaW5nIHRvIGJ1ZmZlci4gdG9CdWZmZXIgb25seSBzdXBwb3J0cyAweC1wcmVmaXhlZCBoZXggc3RyaW5ncyBhbmQgdGhpcyBzdHJpbmcgd2FzIGdpdmVuOiBcIiArIHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShldGhqc191dGlsXzEucGFkVG9FdmVuKGV0aGpzX3V0aWxfMS5zdHJpcEhleFByZWZpeCh2KSksICdoZXgnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gZXRoanNfdXRpbF8xLmludFRvQnVmZmVyKHYpO1xuICAgIH1cbiAgICBpZiAoYm5fanNfMS5kZWZhdWx0LmlzQk4odikpIHtcbiAgICAgICAgcmV0dXJuIHYudG9BcnJheUxpa2UoQnVmZmVyKTtcbiAgICB9XG4gICAgaWYgKHYudG9BcnJheSkge1xuICAgICAgICAvLyBjb252ZXJ0cyBhIEJOIHRvIGEgQnVmZmVyXG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2LnRvQXJyYXkoKSk7XG4gICAgfVxuICAgIGlmICh2LnRvQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2LnRvQnVmZmVyKCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdHlwZScpO1xufTtcbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCB0byBhIGBOdW1iZXJgLlxuICogQHBhcmFtIGJ1ZiBgQnVmZmVyYCBvYmplY3QgdG8gY29udmVydFxuICogQHRocm93cyBJZiB0aGUgaW5wdXQgbnVtYmVyIGV4Y2VlZHMgNTMgYml0cy5cbiAqL1xuZXhwb3J0cy5idWZmZXJUb0ludCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICByZXR1cm4gbmV3IGJuX2pzXzEuZGVmYXVsdChleHBvcnRzLnRvQnVmZmVyKGJ1ZikpLnRvTnVtYmVyKCk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIGludG8gYSBgMHhgLXByZWZpeGVkIGhleCBgU3RyaW5nYC5cbiAqIEBwYXJhbSBidWYgYEJ1ZmZlcmAgb2JqZWN0IHRvIGNvbnZlcnRcbiAqL1xuZXhwb3J0cy5idWZmZXJUb0hleCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICBidWYgPSBleHBvcnRzLnRvQnVmZmVyKGJ1Zik7XG4gICAgcmV0dXJuICcweCcgKyBidWYudG9TdHJpbmcoJ2hleCcpO1xufTtcbi8qKlxuICogSW50ZXJwcmV0cyBhIGBCdWZmZXJgIGFzIGEgc2lnbmVkIGludGVnZXIgYW5kIHJldHVybnMgYSBgQk5gLiBBc3N1bWVzIDI1Ni1iaXQgbnVtYmVycy5cbiAqIEBwYXJhbSBudW0gU2lnbmVkIGludGVnZXIgdmFsdWVcbiAqL1xuZXhwb3J0cy5mcm9tU2lnbmVkID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHJldHVybiBuZXcgYm5fanNfMS5kZWZhdWx0KG51bSkuZnJvbVR3b3MoMjU2KTtcbn07XG4vKipcbiAqIENvbnZlcnRzIGEgYEJOYCB0byBhbiB1bnNpZ25lZCBpbnRlZ2VyIGFuZCByZXR1cm5zIGl0IGFzIGEgYEJ1ZmZlcmAuIEFzc3VtZXMgMjU2LWJpdCBudW1iZXJzLlxuICogQHBhcmFtIG51bVxuICovXG5leHBvcnRzLnRvVW5zaWduZWQgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG51bS50b1R3b3MoMjU2KS50b0FycmF5KCkpO1xufTtcbi8qKlxuICogQWRkcyBcIjB4XCIgdG8gYSBnaXZlbiBgU3RyaW5nYCBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IHN0YXJ0IHdpdGggXCIweFwiLlxuICovXG5leHBvcnRzLmFkZEhleFByZWZpeCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIGV0aGpzX3V0aWxfMS5pc0hleFByZWZpeGVkKHN0cikgPyBzdHIgOiAnMHgnICsgc3RyO1xufTtcbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCBvciBgQXJyYXlgIHRvIEpTT04uXG4gKiBAcGFyYW0gYmEgKEJ1ZmZlcnxBcnJheSlcbiAqIEByZXR1cm4gKEFycmF5fFN0cmluZ3xudWxsKVxuICovXG5leHBvcnRzLmJhVG9KU09OID0gZnVuY3Rpb24gKGJhKSB7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihiYSkpIHtcbiAgICAgICAgcmV0dXJuIFwiMHhcIiArIGJhLnRvU3RyaW5nKCdoZXgnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYmEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJyYXkucHVzaChleHBvcnRzLmJhVG9KU09OKGJhW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogUmUtZXhwb3J0cyBjb21tb25seSB1c2VkIG1vZHVsZXM6XG4gKiAqIEV4cG9ydHMgW2BCTmBdKGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzKSwgW2BybHBgXShodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW1qcy9ybHApLlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJscCA9IGV4cG9ydHMuQk4gPSB2b2lkIDA7XG52YXIgYm5fanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYm4uanNcIikpO1xuZXhwb3J0cy5CTiA9IGJuX2pzXzEuZGVmYXVsdDtcbnZhciBybHAgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJscFwiKSk7XG5leHBvcnRzLnJscCA9IHJscDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dGVybmFscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmluZVByb3BlcnRpZXMgPSB2b2lkIDA7XG52YXIgYXNzZXJ0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFzc2VydFwiKSk7XG52YXIgZXRoanNVdGlsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJldGhqcy11dGlsXCIpKTtcbnZhciBybHAgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJscFwiKSk7XG52YXIgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xuLyoqXG4gKiBEZWZpbmVzIHByb3BlcnRpZXMgb24gYSBgT2JqZWN0YC4gSXQgbWFrZSB0aGUgYXNzdW1wdGlvbiB0aGF0IHVuZGVybHlpbmcgZGF0YSBpcyBiaW5hcnkuXG4gKiBAcGFyYW0gc2VsZiB0aGUgYE9iamVjdGAgdG8gZGVmaW5lIHByb3BlcnRpZXMgb25cbiAqIEBwYXJhbSBmaWVsZHMgYW4gYXJyYXkgZmllbGRzIHRvIGRlZmluZS4gRmllbGRzIGNhbiBjb250YWluOlxuICogKiBgbmFtZWAgLSB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydGllc1xuICogKiBgbGVuZ3RoYCAtIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIGZpZWxkIGNhbiBoYXZlXG4gKiAqIGBhbGxvd0xlc3NgIC0gaWYgdGhlIGZpZWxkIGNhbiBiZSBsZXNzIHRoYW4gdGhlIGxlbmd0aFxuICogKiBgYWxsb3dFbXB0eWBcbiAqIEBwYXJhbSBkYXRhIGRhdGEgdG8gYmUgdmFsaWRhdGVkIGFnYWluc3QgdGhlIGRlZmluaXRpb25zXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnRzLmRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoc2VsZiwgZmllbGRzLCBkYXRhKSB7XG4gICAgc2VsZi5yYXcgPSBbXTtcbiAgICBzZWxmLl9maWVsZHMgPSBbXTtcbiAgICAvLyBhdHRhY2ggdGhlIGB0b0pTT05gXG4gICAgc2VsZi50b0pTT04gPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgICAgaWYgKGxhYmVsID09PSB2b2lkIDApIHsgbGFiZWwgPSBmYWxzZTsgfVxuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgIHZhciBvYmpfMSA9IHt9O1xuICAgICAgICAgICAgc2VsZi5fZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgb2JqXzFbZmllbGRdID0gXCIweFwiICsgc2VsZltmaWVsZF0udG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb2JqXzE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ5dGVzXzEuYmFUb0pTT04oc2VsZi5yYXcpO1xuICAgIH07XG4gICAgc2VsZi5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiBybHAuZW5jb2RlKHNlbGYucmF3KTtcbiAgICB9O1xuICAgIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCwgaSkge1xuICAgICAgICBzZWxmLl9maWVsZHMucHVzaChmaWVsZC5uYW1lKTtcbiAgICAgICAgZnVuY3Rpb24gZ2V0dGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYucmF3W2ldO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldHRlcih2KSB7XG4gICAgICAgICAgICB2ID0gYnl0ZXNfMS50b0J1ZmZlcih2KTtcbiAgICAgICAgICAgIGlmICh2LnRvU3RyaW5nKCdoZXgnKSA9PT0gJzAwJyAmJiAhZmllbGQuYWxsb3daZXJvKSB7XG4gICAgICAgICAgICAgICAgdiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWVsZC5hbGxvd0xlc3MgJiYgZmllbGQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdiA9IGJ5dGVzXzEudW5wYWRCdWZmZXIodik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0XzEuZGVmYXVsdChmaWVsZC5sZW5ndGggPj0gdi5sZW5ndGgsIFwiVGhlIGZpZWxkIFwiICsgZmllbGQubmFtZSArIFwiIG11c3Qgbm90IGhhdmUgbW9yZSBcIiArIGZpZWxkLmxlbmd0aCArIFwiIGJ5dGVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIShmaWVsZC5hbGxvd1plcm8gJiYgdi5sZW5ndGggPT09IDApICYmIGZpZWxkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFzc2VydF8xLmRlZmF1bHQoZmllbGQubGVuZ3RoID09PSB2Lmxlbmd0aCwgXCJUaGUgZmllbGQgXCIgKyBmaWVsZC5uYW1lICsgXCIgbXVzdCBoYXZlIGJ5dGUgbGVuZ3RoIG9mIFwiICsgZmllbGQubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYucmF3W2ldID0gdjtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgZmllbGQubmFtZSwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZ2V0dGVyLFxuICAgICAgICAgICAgc2V0OiBzZXR0ZXIsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZmllbGQuZGVmYXVsdCkge1xuICAgICAgICAgICAgc2VsZltmaWVsZC5uYW1lXSA9IGZpZWxkLmRlZmF1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXR0YWNoIGFsaWFzXG4gICAgICAgIGlmIChmaWVsZC5hbGlhcykge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGZpZWxkLmFsaWFzLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNldDogc2V0dGVyLFxuICAgICAgICAgICAgICAgIGdldDogZ2V0dGVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBpZiB0aGUgY29uc3R1Y3RvciBpcyBwYXNzZWQgZGF0YVxuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShldGhqc1V0aWwuc3RyaXBIZXhQcmVmaXgoZGF0YSksICdoZXgnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgICBkYXRhID0gcmxwLmRlY29kZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gc2VsZi5fZmllbGRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignd3JvbmcgbnVtYmVyIG9mIGZpZWxkcyBpbiBkYXRhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgYWxsIHRoZSBpdGVtcyBhcmUgYnVmZmVyc1xuICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgc2VsZltzZWxmLl9maWVsZHNbaV1dID0gYnl0ZXNfMS50b0J1ZmZlcihkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdmFyIGtleXNfMSA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgICAgICAgICAgZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleXNfMS5pbmRleE9mKGZpZWxkLm5hbWUpICE9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgc2VsZltmaWVsZC5uYW1lXSA9IGRhdGFbZmllbGQubmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGtleXNfMS5pbmRleE9mKGZpZWxkLmFsaWFzKSAhPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHNlbGZbZmllbGQuYWxpYXNdID0gZGF0YVtmaWVsZC5hbGlhc107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBkYXRhJyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNaZXJvQWRkcmVzcyA9IGV4cG9ydHMuemVyb0FkZHJlc3MgPSBleHBvcnRzLmltcG9ydFB1YmxpYyA9IGV4cG9ydHMucHJpdmF0ZVRvQWRkcmVzcyA9IGV4cG9ydHMucHJpdmF0ZVRvUHVibGljID0gZXhwb3J0cy5wdWJsaWNUb0FkZHJlc3MgPSBleHBvcnRzLnB1YlRvQWRkcmVzcyA9IGV4cG9ydHMuaXNWYWxpZFB1YmxpYyA9IGV4cG9ydHMuaXNWYWxpZFByaXZhdGUgPSBleHBvcnRzLmdlbmVyYXRlQWRkcmVzczIgPSBleHBvcnRzLmdlbmVyYXRlQWRkcmVzcyA9IGV4cG9ydHMuaXNWYWxpZENoZWNrc3VtQWRkcmVzcyA9IGV4cG9ydHMudG9DaGVja3N1bUFkZHJlc3MgPSBleHBvcnRzLmlzVmFsaWRBZGRyZXNzID0gZXhwb3J0cy5BY2NvdW50ID0gdm9pZCAwO1xudmFyIGFzc2VydF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhc3NlcnRcIikpO1xudmFyIGJuX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJuLmpzXCIpKTtcbnZhciBybHAgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJscFwiKSk7XG52YXIgc2VjcDI1NmsxXzEgPSByZXF1aXJlKFwiZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3NlY3AyNTZrMVwiKTtcbnZhciBldGhqc191dGlsXzEgPSByZXF1aXJlKFwiZXRoanMtdXRpbFwiKTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbnZhciBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG52YXIgaGFzaF8xID0gcmVxdWlyZShcIi4vaGFzaFwiKTtcbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbnZhciBBY2NvdW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIFRoaXMgY29uc3RydWN0b3IgYXNzaWducyBhbmQgdmFsaWRhdGVzIHRoZSB2YWx1ZXMuXG4gICAgICogVXNlIHRoZSBzdGF0aWMgZmFjdG9yeSBtZXRob2RzIHRvIGFzc2lzdCBpbiBjcmVhdGluZyBhbiBBY2NvdW50IGZyb20gdmFyeWluZyBkYXRhIHR5cGVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFjY291bnQobm9uY2UsIGJhbGFuY2UsIHN0YXRlUm9vdCwgY29kZUhhc2gpIHtcbiAgICAgICAgaWYgKG5vbmNlID09PSB2b2lkIDApIHsgbm9uY2UgPSBuZXcgYm5fanNfMS5kZWZhdWx0KDApOyB9XG4gICAgICAgIGlmIChiYWxhbmNlID09PSB2b2lkIDApIHsgYmFsYW5jZSA9IG5ldyBibl9qc18xLmRlZmF1bHQoMCk7IH1cbiAgICAgICAgaWYgKHN0YXRlUm9vdCA9PT0gdm9pZCAwKSB7IHN0YXRlUm9vdCA9IGNvbnN0YW50c18xLktFQ0NBSzI1Nl9STFA7IH1cbiAgICAgICAgaWYgKGNvZGVIYXNoID09PSB2b2lkIDApIHsgY29kZUhhc2ggPSBjb25zdGFudHNfMS5LRUNDQUsyNTZfTlVMTDsgfVxuICAgICAgICB0aGlzLm5vbmNlID0gbm9uY2U7XG4gICAgICAgIHRoaXMuYmFsYW5jZSA9IGJhbGFuY2U7XG4gICAgICAgIHRoaXMuc3RhdGVSb290ID0gc3RhdGVSb290O1xuICAgICAgICB0aGlzLmNvZGVIYXNoID0gY29kZUhhc2g7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlKCk7XG4gICAgfVxuICAgIEFjY291bnQuZnJvbUFjY291bnREYXRhID0gZnVuY3Rpb24gKGFjY291bnREYXRhKSB7XG4gICAgICAgIHZhciBub25jZSA9IGFjY291bnREYXRhLm5vbmNlLCBiYWxhbmNlID0gYWNjb3VudERhdGEuYmFsYW5jZSwgc3RhdGVSb290ID0gYWNjb3VudERhdGEuc3RhdGVSb290LCBjb2RlSGFzaCA9IGFjY291bnREYXRhLmNvZGVIYXNoO1xuICAgICAgICByZXR1cm4gbmV3IEFjY291bnQobm9uY2UgPyBuZXcgYm5fanNfMS5kZWZhdWx0KGJ5dGVzXzEudG9CdWZmZXIobm9uY2UpKSA6IHVuZGVmaW5lZCwgYmFsYW5jZSA/IG5ldyBibl9qc18xLmRlZmF1bHQoYnl0ZXNfMS50b0J1ZmZlcihiYWxhbmNlKSkgOiB1bmRlZmluZWQsIHN0YXRlUm9vdCA/IGJ5dGVzXzEudG9CdWZmZXIoc3RhdGVSb290KSA6IHVuZGVmaW5lZCwgY29kZUhhc2ggPyBieXRlc18xLnRvQnVmZmVyKGNvZGVIYXNoKSA6IHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgICBBY2NvdW50LmZyb21SbHBTZXJpYWxpemVkQWNjb3VudCA9IGZ1bmN0aW9uIChzZXJpYWxpemVkKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBybHAuZGVjb2RlKHNlcmlhbGl6ZWQpO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcmlhbGl6ZWQgYWNjb3VudCBpbnB1dC4gTXVzdCBiZSBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21WYWx1ZXNBcnJheSh2YWx1ZXMpO1xuICAgIH07XG4gICAgQWNjb3VudC5mcm9tVmFsdWVzQXJyYXkgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHZhciBfYSA9IF9fcmVhZCh2YWx1ZXMsIDQpLCBub25jZSA9IF9hWzBdLCBiYWxhbmNlID0gX2FbMV0sIHN0YXRlUm9vdCA9IF9hWzJdLCBjb2RlSGFzaCA9IF9hWzNdO1xuICAgICAgICByZXR1cm4gbmV3IEFjY291bnQobmV3IGJuX2pzXzEuZGVmYXVsdChub25jZSksIG5ldyBibl9qc18xLmRlZmF1bHQoYmFsYW5jZSksIHN0YXRlUm9vdCwgY29kZUhhc2gpO1xuICAgIH07XG4gICAgQWNjb3VudC5wcm90b3R5cGUuX3ZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5ub25jZS5sdChuZXcgYm5fanNfMS5kZWZhdWx0KDApKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub25jZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYmFsYW5jZS5sdChuZXcgYm5fanNfMS5kZWZhdWx0KDApKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWxhbmNlIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZVJvb3QubGVuZ3RoICE9PSAzMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGF0ZVJvb3QgbXVzdCBoYXZlIGEgbGVuZ3RoIG9mIDMyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29kZUhhc2gubGVuZ3RoICE9PSAzMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb2RlSGFzaCBtdXN0IGhhdmUgYSBsZW5ndGggb2YgMzInKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEJ1ZmZlciBBcnJheSBvZiB0aGUgcmF3IEJ1ZmZlcnMgZm9yIHRoZSBhY2NvdW50LCBpbiBvcmRlci5cbiAgICAgKi9cbiAgICBBY2NvdW50LnByb3RvdHlwZS5yYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0eXBlc18xLmJuVG9VbnBhZGRlZEJ1ZmZlcih0aGlzLm5vbmNlKSxcbiAgICAgICAgICAgIHR5cGVzXzEuYm5Ub1VucGFkZGVkQnVmZmVyKHRoaXMuYmFsYW5jZSksXG4gICAgICAgICAgICB0aGlzLnN0YXRlUm9vdCxcbiAgICAgICAgICAgIHRoaXMuY29kZUhhc2gsXG4gICAgICAgIF07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBSTFAgc2VyaWFsaXphdGlvbiBvZiB0aGUgYWNjb3VudCBhcyBhIGBCdWZmZXJgLlxuICAgICAqL1xuICAgIEFjY291bnQucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJscC5lbmNvZGUodGhpcy5yYXcoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYEJvb2xlYW5gIGRldGVybWluaW5nIGlmIHRoZSBhY2NvdW50IGlzIGEgY29udHJhY3QuXG4gICAgICovXG4gICAgQWNjb3VudC5wcm90b3R5cGUuaXNDb250cmFjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvZGVIYXNoLmVxdWFscyhjb25zdGFudHNfMS5LRUNDQUsyNTZfTlVMTCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYEJvb2xlYW5gIGRldGVybWluaW5nIGlmIHRoZSBhY2NvdW50IGlzIGVtcHR5IGNvbXBseWluZyB0byB0aGUgZGVmaW5pdGlvbiBvZlxuICAgICAqIGFjY291bnQgZW1wdGluZXNzIGluIFtFSVAtMTYxXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTE2MSk6XG4gICAgICogXCJBbiBhY2NvdW50IGlzIGNvbnNpZGVyZWQgZW1wdHkgd2hlbiBpdCBoYXMgbm8gY29kZSBhbmQgemVybyBub25jZSBhbmQgemVybyBiYWxhbmNlLlwiXG4gICAgICovXG4gICAgQWNjb3VudC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZS5pc1plcm8oKSAmJiB0aGlzLm5vbmNlLmlzWmVybygpICYmIHRoaXMuY29kZUhhc2guZXF1YWxzKGNvbnN0YW50c18xLktFQ0NBSzI1Nl9OVUxMKTtcbiAgICB9O1xuICAgIHJldHVybiBBY2NvdW50O1xufSgpKTtcbmV4cG9ydHMuQWNjb3VudCA9IEFjY291bnQ7XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgYWRkcmVzcyBpcyBhIHZhbGlkLiBBY2NlcHRzIGNoZWNrc3VtbWVkIGFkZHJlc3NlcyB0b28uXG4gKi9cbmV4cG9ydHMuaXNWYWxpZEFkZHJlc3MgPSBmdW5jdGlvbiAoaGV4QWRkcmVzcykge1xuICAgIHRyeSB7XG4gICAgICAgIGhlbHBlcnNfMS5hc3NlcnRJc1N0cmluZyhoZXhBZGRyZXNzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gL14weFswLTlhLWZBLUZdezQwfSQvLnRlc3QoaGV4QWRkcmVzcyk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIGEgY2hlY2tzdW1tZWQgYWRkcmVzcy5cbiAqXG4gKiBJZiBhIGVpcDExOTFDaGFpbklkIGlzIHByb3ZpZGVkLCB0aGUgY2hhaW5JZCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBjaGVja3N1bSBjYWxjdWxhdGlvbi4gVGhpc1xuICogaGFzIHRoZSBlZmZlY3Qgb2YgY2hlY2tzdW1tZWQgYWRkcmVzc2VzIGZvciBvbmUgY2hhaW4gaGF2aW5nIGludmFsaWQgY2hlY2tzdW1zIGZvciBvdGhlcnMuXG4gKiBGb3IgbW9yZSBkZXRhaWxzIHNlZSBbRUlQLTExOTFdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTE5MSkuXG4gKlxuICogV0FSTklORzogQ2hlY2tzdW1zIHdpdGggYW5kIHdpdGhvdXQgdGhlIGNoYWluSWQgd2lsbCBkaWZmZXIuIEFzIG9mIDIwMTktMDYtMjYsIHRoZSBtb3N0IGNvbW1vbmx5XG4gKiB1c2VkIHZhcmlhdGlvbiBpbiBFdGhlcmV1bSB3YXMgd2l0aG91dCB0aGUgY2hhaW5JZC4gVGhpcyBtYXkgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG4gKi9cbmV4cG9ydHMudG9DaGVja3N1bUFkZHJlc3MgPSBmdW5jdGlvbiAoaGV4QWRkcmVzcywgZWlwMTE5MUNoYWluSWQpIHtcbiAgICBoZWxwZXJzXzEuYXNzZXJ0SXNIZXhTdHJpbmcoaGV4QWRkcmVzcyk7XG4gICAgdmFyIGFkZHJlc3MgPSBldGhqc191dGlsXzEuc3RyaXBIZXhQcmVmaXgoaGV4QWRkcmVzcykudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgcHJlZml4ID0gJyc7XG4gICAgaWYgKGVpcDExOTFDaGFpbklkKSB7XG4gICAgICAgIHZhciBjaGFpbklkID0gdHlwZXNfMS50b1R5cGUoZWlwMTE5MUNoYWluSWQsIHR5cGVzXzEuVHlwZU91dHB1dC5CTik7XG4gICAgICAgIHByZWZpeCA9IGNoYWluSWQudG9TdHJpbmcoKSArICcweCc7XG4gICAgfVxuICAgIHZhciBoYXNoID0gaGFzaF8xLmtlY2Nha0Zyb21TdHJpbmcocHJlZml4ICsgYWRkcmVzcykudG9TdHJpbmcoJ2hleCcpO1xuICAgIHZhciByZXQgPSAnMHgnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWRkcmVzcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocGFyc2VJbnQoaGFzaFtpXSwgMTYpID49IDgpIHtcbiAgICAgICAgICAgIHJldCArPSBhZGRyZXNzW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXQgKz0gYWRkcmVzc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBhZGRyZXNzIGlzIGEgdmFsaWQgY2hlY2tzdW1tZWQgYWRkcmVzcy5cbiAqXG4gKiBTZWUgdG9DaGVja3N1bUFkZHJlc3MnIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMgYWJvdXQgdGhlIGVpcDExOTFDaGFpbklkIHBhcmFtZXRlci5cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGhleEFkZHJlc3MsIGVpcDExOTFDaGFpbklkKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuaXNWYWxpZEFkZHJlc3MoaGV4QWRkcmVzcykgJiYgZXhwb3J0cy50b0NoZWNrc3VtQWRkcmVzcyhoZXhBZGRyZXNzLCBlaXAxMTkxQ2hhaW5JZCkgPT09IGhleEFkZHJlc3M7XG59O1xuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gYWRkcmVzcyBvZiBhIG5ld2x5IGNyZWF0ZWQgY29udHJhY3QuXG4gKiBAcGFyYW0gZnJvbSBUaGUgYWRkcmVzcyB3aGljaCBpcyBjcmVhdGluZyB0aGlzIG5ldyBhZGRyZXNzXG4gKiBAcGFyYW0gbm9uY2UgVGhlIG5vbmNlIG9mIHRoZSBmcm9tIGFjY291bnRcbiAqL1xuZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MgPSBmdW5jdGlvbiAoZnJvbSwgbm9uY2UpIHtcbiAgICBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIoZnJvbSk7XG4gICAgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKG5vbmNlKTtcbiAgICB2YXIgbm9uY2VCTiA9IG5ldyBibl9qc18xLmRlZmF1bHQobm9uY2UpO1xuICAgIGlmIChub25jZUJOLmlzWmVybygpKSB7XG4gICAgICAgIC8vIGluIFJMUCB3ZSB3YW50IHRvIGVuY29kZSBudWxsIGluIHRoZSBjYXNlIG9mIHplcm8gbm9uY2VcbiAgICAgICAgLy8gcmVhZCB0aGUgUkxQIGRvY3VtZW50YXRpb24gZm9yIGFuIGFuc3dlciBpZiB5b3UgZGFyZVxuICAgICAgICByZXR1cm4gaGFzaF8xLnJscGhhc2goW2Zyb20sIG51bGxdKS5zbGljZSgtMjApO1xuICAgIH1cbiAgICAvLyBPbmx5IHRha2UgdGhlIGxvd2VyIDE2MGJpdHMgb2YgdGhlIGhhc2hcbiAgICByZXR1cm4gaGFzaF8xLnJscGhhc2goW2Zyb20sIEJ1ZmZlci5mcm9tKG5vbmNlQk4udG9BcnJheSgpKV0pLnNsaWNlKC0yMCk7XG59O1xuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gYWRkcmVzcyBmb3IgYSBjb250cmFjdCBjcmVhdGVkIHVzaW5nIENSRUFURTIuXG4gKiBAcGFyYW0gZnJvbSBUaGUgYWRkcmVzcyB3aGljaCBpcyBjcmVhdGluZyB0aGlzIG5ldyBhZGRyZXNzXG4gKiBAcGFyYW0gc2FsdCBBIHNhbHRcbiAqIEBwYXJhbSBpbml0Q29kZSBUaGUgaW5pdCBjb2RlIG9mIHRoZSBjb250cmFjdCBiZWluZyBjcmVhdGVkXG4gKi9cbmV4cG9ydHMuZ2VuZXJhdGVBZGRyZXNzMiA9IGZ1bmN0aW9uIChmcm9tLCBzYWx0LCBpbml0Q29kZSkge1xuICAgIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcihmcm9tKTtcbiAgICBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIoc2FsdCk7XG4gICAgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKGluaXRDb2RlKTtcbiAgICBhc3NlcnRfMS5kZWZhdWx0KGZyb20ubGVuZ3RoID09PSAyMCk7XG4gICAgYXNzZXJ0XzEuZGVmYXVsdChzYWx0Lmxlbmd0aCA9PT0gMzIpO1xuICAgIHZhciBhZGRyZXNzID0gaGFzaF8xLmtlY2NhazI1NihCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbSgnZmYnLCAnaGV4JyksIGZyb20sIHNhbHQsIGhhc2hfMS5rZWNjYWsyNTYoaW5pdENvZGUpXSkpO1xuICAgIHJldHVybiBhZGRyZXNzLnNsaWNlKC0yMCk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByaXZhdGUga2V5IHNhdGlzZmllcyB0aGUgcnVsZXMgb2YgdGhlIGN1cnZlIHNlY3AyNTZrMS5cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkUHJpdmF0ZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIHNlY3AyNTZrMV8xLnByaXZhdGVLZXlWZXJpZnkocHJpdmF0ZUtleSk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHB1YmxpYyBrZXkgc2F0aXNmaWVzIHRoZSBydWxlcyBvZiB0aGUgY3VydmUgc2VjcDI1NmsxXG4gKiBhbmQgdGhlIHJlcXVpcmVtZW50cyBvZiBFdGhlcmV1bS5cbiAqIEBwYXJhbSBwdWJsaWNLZXkgVGhlIHR3byBwb2ludHMgb2YgYW4gdW5jb21wcmVzc2VkIGtleSwgdW5sZXNzIHNhbml0aXplIGlzIGVuYWJsZWRcbiAqIEBwYXJhbSBzYW5pdGl6ZSBBY2NlcHQgcHVibGljIGtleXMgaW4gb3RoZXIgZm9ybWF0c1xuICovXG5leHBvcnRzLmlzVmFsaWRQdWJsaWMgPSBmdW5jdGlvbiAocHVibGljS2V5LCBzYW5pdGl6ZSkge1xuICAgIGlmIChzYW5pdGl6ZSA9PT0gdm9pZCAwKSB7IHNhbml0aXplID0gZmFsc2U7IH1cbiAgICBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIocHVibGljS2V5KTtcbiAgICBpZiAocHVibGljS2V5Lmxlbmd0aCA9PT0gNjQpIHtcbiAgICAgICAgLy8gQ29udmVydCB0byBTRUMxIGZvciBzZWNwMjU2azFcbiAgICAgICAgcmV0dXJuIHNlY3AyNTZrMV8xLnB1YmxpY0tleVZlcmlmeShCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbNF0pLCBwdWJsaWNLZXldKSk7XG4gICAgfVxuICAgIGlmICghc2FuaXRpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc2VjcDI1NmsxXzEucHVibGljS2V5VmVyaWZ5KHB1YmxpY0tleSk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBhZGRyZXNzIG9mIGEgZ2l2ZW4gcHVibGljIGtleS5cbiAqIEFjY2VwdHMgXCJFdGhlcmV1bSBwdWJsaWMga2V5c1wiIGFuZCBTRUMxIGVuY29kZWQga2V5cy5cbiAqIEBwYXJhbSBwdWJLZXkgVGhlIHR3byBwb2ludHMgb2YgYW4gdW5jb21wcmVzc2VkIGtleSwgdW5sZXNzIHNhbml0aXplIGlzIGVuYWJsZWRcbiAqIEBwYXJhbSBzYW5pdGl6ZSBBY2NlcHQgcHVibGljIGtleXMgaW4gb3RoZXIgZm9ybWF0c1xuICovXG5leHBvcnRzLnB1YlRvQWRkcmVzcyA9IGZ1bmN0aW9uIChwdWJLZXksIHNhbml0aXplKSB7XG4gICAgaWYgKHNhbml0aXplID09PSB2b2lkIDApIHsgc2FuaXRpemUgPSBmYWxzZTsgfVxuICAgIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcihwdWJLZXkpO1xuICAgIGlmIChzYW5pdGl6ZSAmJiBwdWJLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgICAgICBwdWJLZXkgPSBCdWZmZXIuZnJvbShzZWNwMjU2azFfMS5wdWJsaWNLZXlDb252ZXJ0KHB1YktleSwgZmFsc2UpLnNsaWNlKDEpKTtcbiAgICB9XG4gICAgYXNzZXJ0XzEuZGVmYXVsdChwdWJLZXkubGVuZ3RoID09PSA2NCk7XG4gICAgLy8gT25seSB0YWtlIHRoZSBsb3dlciAxNjBiaXRzIG9mIHRoZSBoYXNoXG4gICAgcmV0dXJuIGhhc2hfMS5rZWNjYWsocHViS2V5KS5zbGljZSgtMjApO1xufTtcbmV4cG9ydHMucHVibGljVG9BZGRyZXNzID0gZXhwb3J0cy5wdWJUb0FkZHJlc3M7XG4vKipcbiAqIFJldHVybnMgdGhlIGV0aGVyZXVtIHB1YmxpYyBrZXkgb2YgYSBnaXZlbiBwcml2YXRlIGtleS5cbiAqIEBwYXJhbSBwcml2YXRlS2V5IEEgcHJpdmF0ZSBrZXkgbXVzdCBiZSAyNTYgYml0cyB3aWRlXG4gKi9cbmV4cG9ydHMucHJpdmF0ZVRvUHVibGljID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIocHJpdmF0ZUtleSk7XG4gICAgLy8gc2tpcCB0aGUgdHlwZSBmbGFnIGFuZCB1c2UgdGhlIFgsIFkgcG9pbnRzXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMV8xLnB1YmxpY0tleUNyZWF0ZShwcml2YXRlS2V5LCBmYWxzZSkpLnNsaWNlKDEpO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgZXRoZXJldW0gYWRkcmVzcyBvZiBhIGdpdmVuIHByaXZhdGUga2V5LlxuICogQHBhcmFtIHByaXZhdGVLZXkgQSBwcml2YXRlIGtleSBtdXN0IGJlIDI1NiBiaXRzIHdpZGVcbiAqL1xuZXhwb3J0cy5wcml2YXRlVG9BZGRyZXNzID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5wdWJsaWNUb0FkZHJlc3MoZXhwb3J0cy5wcml2YXRlVG9QdWJsaWMocHJpdmF0ZUtleSkpO1xufTtcbi8qKlxuICogQ29udmVydHMgYSBwdWJsaWMga2V5IHRvIHRoZSBFdGhlcmV1bSBmb3JtYXQuXG4gKi9cbmV4cG9ydHMuaW1wb3J0UHVibGljID0gZnVuY3Rpb24gKHB1YmxpY0tleSkge1xuICAgIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcihwdWJsaWNLZXkpO1xuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgICAgICBwdWJsaWNLZXkgPSBCdWZmZXIuZnJvbShzZWNwMjU2azFfMS5wdWJsaWNLZXlDb252ZXJ0KHB1YmxpY0tleSwgZmFsc2UpLnNsaWNlKDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHB1YmxpY0tleTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIHplcm8gYWRkcmVzcy5cbiAqL1xuZXhwb3J0cy56ZXJvQWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWRkcmVzc0xlbmd0aCA9IDIwO1xuICAgIHZhciBhZGRyID0gYnl0ZXNfMS56ZXJvcyhhZGRyZXNzTGVuZ3RoKTtcbiAgICByZXR1cm4gYnl0ZXNfMS5idWZmZXJUb0hleChhZGRyKTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGFkZHJlc3MgaXMgdGhlIHplcm8gYWRkcmVzcy5cbiAqL1xuZXhwb3J0cy5pc1plcm9BZGRyZXNzID0gZnVuY3Rpb24gKGhleEFkZHJlc3MpIHtcbiAgICB0cnkge1xuICAgICAgICBoZWxwZXJzXzEuYXNzZXJ0SXNTdHJpbmcoaGV4QWRkcmVzcyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHplcm9BZGRyID0gZXhwb3J0cy56ZXJvQWRkcmVzcygpO1xuICAgIHJldHVybiB6ZXJvQWRkciA9PT0gaGV4QWRkcmVzcztcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY2NvdW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVkgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X05VTEwgPSBleHBvcnRzLktFQ0NBSzI1Nl9OVUxMX1MgPSBleHBvcnRzLlRXT19QT1cyNTYgPSBleHBvcnRzLk1BWF9JTlRFR0VSID0gdm9pZCAwO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbnZhciBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG4vKipcbiAqIFRoZSBtYXggaW50ZWdlciB0aGF0IHRoaXMgVk0gY2FuIGhhbmRsZVxuICovXG5leHBvcnRzLk1BWF9JTlRFR0VSID0gbmV3IGJuX2pzXzEuZGVmYXVsdCgnZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicsIDE2KTtcbi8qKlxuICogMl4yNTZcbiAqL1xuZXhwb3J0cy5UV09fUE9XMjU2ID0gbmV3IGJuX2pzXzEuZGVmYXVsdCgnMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCAxNik7XG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiBudWxsXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUyA9ICdjNWQyNDYwMTg2ZjcyMzNjOTI3ZTdkYjJkY2M3MDNjMGU1MDBiNjUzY2E4MjI3M2I3YmZhZDgwNDVkODVhNDcwJztcbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIG51bGxcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfTlVMTCA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUywgJ2hleCcpO1xuLyoqXG4gKiBLZWNjYWstMjU2IG9mIGFuIFJMUCBvZiBhbiBlbXB0eSBhcnJheVxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUyA9ICcxZGNjNGRlOGRlYzc1ZDdhYWI4NWI1NjdiNmNjZDQxYWQzMTI0NTFiOTQ4YTc0MTNmMGExNDJmZDQwZDQ5MzQ3Jztcbi8qKlxuICogS2VjY2FrLTI1NiBvZiBhbiBSTFAgb2YgYW4gZW1wdHkgYXJyYXlcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZID0gQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MsICdoZXgnKTtcbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBSTFAgb2YgbnVsbFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfUyA9ICc1NmU4MWYxNzFiY2M1NWE2ZmY4MzQ1ZTY5MmMwZjg2ZTViNDhlMDFiOTk2Y2FkYzAwMTYyMmZiNWUzNjNiNDIxJztcbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBSTFAgb2YgbnVsbFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFAgPSBCdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9STFBfUywgJ2hleCcpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzSGV4UHJlZml4ZWQgPSByZXF1aXJlKCdpcy1oZXgtcHJlZml4ZWQnKTtcbnZhciBzdHJpcEhleFByZWZpeCA9IHJlcXVpcmUoJ3N0cmlwLWhleC1wcmVmaXgnKTtcblxuLyoqXG4gKiBQYWRzIGEgYFN0cmluZ2AgdG8gaGF2ZSBhbiBldmVuIGxlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IG91dHB1dFxuICovXG5mdW5jdGlvbiBwYWRUb0V2ZW4odmFsdWUpIHtcbiAgdmFyIGEgPSB2YWx1ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGlmICh0eXBlb2YgYSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSB3aGlsZSBwYWRkaW5nIHRvIGV2ZW4sIHZhbHVlIG11c3QgYmUgc3RyaW5nLCBpcyBjdXJyZW50bHkgJyArIHR5cGVvZiBhICsgJywgd2hpbGUgcGFkVG9FdmVuLicpO1xuICB9XG5cbiAgaWYgKGEubGVuZ3RoICUgMikge1xuICAgIGEgPSAnMCcgKyBhO1xuICB9XG5cbiAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBgTnVtYmVyYCBpbnRvIGEgaGV4IGBTdHJpbmdgXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBpbnRUb0hleChpKSB7XG4gIHZhciBoZXggPSBpLnRvU3RyaW5nKDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIHJldHVybiAnMHgnICsgaGV4O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIGBOdW1iZXJgIHRvIGEgYEJ1ZmZlcmBcbiAqIEBwYXJhbSB7TnVtYmVyfSBpXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIGludFRvQnVmZmVyKGkpIHtcbiAgdmFyIGhleCA9IGludFRvSGV4KGkpO1xuXG4gIHJldHVybiBuZXcgQnVmZmVyKHBhZFRvRXZlbihoZXguc2xpY2UoMikpLCAnaGV4Jyk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBiaW5hcnkgc2l6ZSBvZiBhIHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRCaW5hcnlTaXplKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSB3aGlsZSBnZXR0aW5nIGJpbmFyeSBzaXplLCBtZXRob2QgZ2V0QmluYXJ5U2l6ZSByZXF1aXJlcyBpbnB1dCBcXCdzdHJcXCcgdG8gYmUgdHlwZSBTdHJpbmcsIGdvdCBcXCcnICsgdHlwZW9mIHN0ciArICdcXCcuJyk7XG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyLCAndXRmOCcpO1xufVxuXG4vKipcbiAqIFJldHVybnMgVFJVRSBpZiB0aGUgZmlyc3Qgc3BlY2lmaWVkIGFycmF5IGNvbnRhaW5zIGFsbCBlbGVtZW50c1xuICogZnJvbSB0aGUgc2Vjb25kIG9uZS4gRkFMU0Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IHN1cGVyc2V0XG4gKiBAcGFyYW0ge2FycmF5fSBzdWJzZXRcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gYXJyYXlDb250YWluc0FycmF5KHN1cGVyc2V0LCBzdWJzZXQsIHNvbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3VwZXJzZXQpICE9PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGFycmF5Q29udGFpbnNBcnJheSByZXF1aXJlcyBpbnB1dCBcXCdzdXBlcnNldFxcJyB0byBiZSBhbiBhcnJheSBnb3QgdHlwZSBcXCcnICsgdHlwZW9mIHN1cGVyc2V0ICsgJ1xcJycpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHN1YnNldCkgIT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgYXJyYXlDb250YWluc0FycmF5IHJlcXVpcmVzIGlucHV0IFxcJ3N1YnNldFxcJyB0byBiZSBhbiBhcnJheSBnb3QgdHlwZSBcXCcnICsgdHlwZW9mIHN1YnNldCArICdcXCcnKTtcbiAgfVxuXG4gIHJldHVybiBzdWJzZXRbQm9vbGVhbihzb21lKSAmJiAnc29tZScgfHwgJ2V2ZXJ5J10oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHN1cGVyc2V0LmluZGV4T2YodmFsdWUpID49IDA7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IHV0ZjggZnJvbSBpdCdzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2QgdG9VdGY4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIGluIGhleFxuICogQHJldHVybnMge1N0cmluZ30gYXNjaWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGhleCB2YWx1ZVxuICovXG5mdW5jdGlvbiB0b1V0ZjgoaGV4KSB7XG4gIHZhciBidWZmZXJWYWx1ZSA9IG5ldyBCdWZmZXIocGFkVG9FdmVuKHN0cmlwSGV4UHJlZml4KGhleCkucmVwbGFjZSgvXjArfDArJC9nLCAnJykpLCAnaGV4Jyk7XG5cbiAgcmV0dXJuIGJ1ZmZlclZhbHVlLnRvU3RyaW5nKCd1dGY4Jyk7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgYXNjaWkgZnJvbSBpdCdzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2QgdG9Bc2NpaVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBpbiBoZXhcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGFzY2lpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBoZXggdmFsdWVcbiAqL1xuZnVuY3Rpb24gdG9Bc2NpaShoZXgpIHtcbiAgdmFyIHN0ciA9ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIHZhciBpID0gMCxcbiAgICAgIGwgPSBoZXgubGVuZ3RoOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgaWYgKGhleC5zdWJzdHJpbmcoMCwgMikgPT09ICcweCcpIHtcbiAgICBpID0gMjtcbiAgfVxuXG4gIGZvciAoOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgdmFyIGNvZGUgPSBwYXJzZUludChoZXguc3Vic3RyKGksIDIpLCAxNik7XG4gICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIHV0Zjggc3RyaW5nXG4gKlxuICogQG1ldGhvZCBmcm9tVXRmOFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbmFsIHBhZGRpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZnJvbVV0Zjgoc3RyaW5nVmFsdWUpIHtcbiAgdmFyIHN0ciA9IG5ldyBCdWZmZXIoc3RyaW5nVmFsdWUsICd1dGY4Jyk7XG5cbiAgcmV0dXJuICcweCcgKyBwYWRUb0V2ZW4oc3RyLnRvU3RyaW5nKCdoZXgnKSkucmVwbGFjZSgvXjArfDArJC9nLCAnJyk7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgYXNjaWkgc3RyaW5nXG4gKlxuICogQG1ldGhvZCBmcm9tQXNjaWlcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25hbCBwYWRkaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGZyb21Bc2NpaShzdHJpbmdWYWx1ZSkge1xuICB2YXIgaGV4ID0gJyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmdWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB2YXIgY29kZSA9IHN0cmluZ1ZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgdmFyIG4gPSBjb2RlLnRvU3RyaW5nKDE2KTtcbiAgICBoZXggKz0gbi5sZW5ndGggPCAyID8gJzAnICsgbiA6IG47XG4gIH1cblxuICByZXR1cm4gJzB4JyArIGhleDtcbn1cblxuLyoqXG4gKiBnZXRLZXlzKFt7YTogMSwgYjogMn0sIHthOiAzLCBiOiA0fV0sICdhJykgPT4gWzEsIDNdXG4gKlxuICogQG1ldGhvZCBnZXRLZXlzIGdldCBzcGVjaWZpYyBrZXkgZnJvbSBpbm5lciBvYmplY3QgYXJyYXkgb2Ygb2JqZWN0c1xuICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtc1xuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtCb29sZWFufSBhbGxvd0VtcHR5XG4gKiBAcmV0dXJucyB7QXJyYXl9IG91dHB1dCBqdXN0IGEgc2ltcGxlIGFycmF5IG9mIG91dHB1dCBrZXlzXG4gKi9cbmZ1bmN0aW9uIGdldEtleXMocGFyYW1zLCBrZXksIGFsbG93RW1wdHkpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgZ2V0S2V5cyBleHBlY3RpbmcgdHlwZSBBcnJheSBhcyBcXCdwYXJhbXNcXCcgaW5wdXQsIGdvdCBcXCcnICsgdHlwZW9mIHBhcmFtcyArICdcXCcnKTtcbiAgfVxuICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgZ2V0S2V5cyBleHBlY3RpbmcgdHlwZSBTdHJpbmcgZm9yIGlucHV0IFxcJ2tleVxcJyBnb3QgXFwnJyArIHR5cGVvZiBrZXkgKyAnXFwnLicpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdmFyIHZhbHVlID0gcGFyYW1zW2ldW2tleV07IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBpZiAoYWxsb3dFbXB0eSAmJiAhdmFsdWUpIHtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWJpJyk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogSXMgdGhlIHN0cmluZyBhIGhleCBzdHJpbmcuXG4gKlxuICogQG1ldGhvZCBjaGVjayBpZiBzdHJpbmcgaXMgaGV4IHN0cmluZyBvZiBzcGVjaWZpYyBsZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxuICogQHJldHVybnMge0Jvb2xlYW59IG91dHB1dCB0aGUgc3RyaW5nIGlzIGEgaGV4IHN0cmluZ1xuICovXG5mdW5jdGlvbiBpc0hleFN0cmluZyh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8ICF2YWx1ZS5tYXRjaCgvXjB4WzAtOUEtRmEtZl0qJC8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggIT09IDIgKyAyICogbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhcnJheUNvbnRhaW5zQXJyYXk6IGFycmF5Q29udGFpbnNBcnJheSxcbiAgaW50VG9CdWZmZXI6IGludFRvQnVmZmVyLFxuICBnZXRCaW5hcnlTaXplOiBnZXRCaW5hcnlTaXplLFxuICBpc0hleFByZWZpeGVkOiBpc0hleFByZWZpeGVkLFxuICBzdHJpcEhleFByZWZpeDogc3RyaXBIZXhQcmVmaXgsXG4gIHBhZFRvRXZlbjogcGFkVG9FdmVuLFxuICBpbnRUb0hleDogaW50VG9IZXgsXG4gIGZyb21Bc2NpaTogZnJvbUFzY2lpLFxuICBmcm9tVXRmODogZnJvbVV0ZjgsXG4gIHRvQXNjaWk6IHRvQXNjaWksXG4gIHRvVXRmODogdG9VdGY4LFxuICBnZXRLZXlzOiBnZXRLZXlzLFxuICBpc0hleFN0cmluZzogaXNIZXhTdHJpbmdcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhhc2hQZXJzb25hbE1lc3NhZ2UgPSBleHBvcnRzLmlzVmFsaWRTaWduYXR1cmUgPSBleHBvcnRzLmZyb21ScGNTaWcgPSBleHBvcnRzLnRvQ29tcGFjdFNpZyA9IGV4cG9ydHMudG9ScGNTaWcgPSBleHBvcnRzLmVjcmVjb3ZlciA9IGV4cG9ydHMuZWNzaWduID0gdm9pZCAwO1xudmFyIHNlY3AyNTZrMV8xID0gcmVxdWlyZShcImV0aGVyZXVtLWNyeXB0b2dyYXBoeS9zZWNwMjU2azFcIik7XG52YXIgYm5fanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYm4uanNcIikpO1xudmFyIGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbnZhciBoYXNoXzEgPSByZXF1aXJlKFwiLi9oYXNoXCIpO1xudmFyIGhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuZnVuY3Rpb24gZWNzaWduKG1zZ0hhc2gsIHByaXZhdGVLZXksIGNoYWluSWQpIHtcbiAgICB2YXIgX2EgPSBzZWNwMjU2azFfMS5lY2RzYVNpZ24obXNnSGFzaCwgcHJpdmF0ZUtleSksIHNpZ25hdHVyZSA9IF9hLnNpZ25hdHVyZSwgcmVjb3ZlcnkgPSBfYS5yZWNpZDtcbiAgICB2YXIgciA9IEJ1ZmZlci5mcm9tKHNpZ25hdHVyZS5zbGljZSgwLCAzMikpO1xuICAgIHZhciBzID0gQnVmZmVyLmZyb20oc2lnbmF0dXJlLnNsaWNlKDMyLCA2NCkpO1xuICAgIGlmICghY2hhaW5JZCB8fCB0eXBlb2YgY2hhaW5JZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gcmV0dXJuIGxlZ2FjeSB0eXBlIEVDRFNBU2lnbmF0dXJlIChkZXByZWNhdGVkIGluIGZhdm9yIG9mIEVDRFNBU2lnbmF0dXJlQnVmZmVyIHRvIGhhbmRsZSBsYXJnZSBjaGFpbklkcylcbiAgICAgICAgaWYgKGNoYWluSWQgJiYgIU51bWJlci5pc1NhZmVJbnRlZ2VyKGNoYWluSWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBudW1iZXIgaXMgZ3JlYXRlciB0aGFuIE1BWF9TQUZFX0lOVEVHRVIgKHBsZWFzZSB1c2UgYW4gYWx0ZXJuYXRpdmUgaW5wdXQgdHlwZSknKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdl8xID0gY2hhaW5JZCA/IHJlY292ZXJ5ICsgKGNoYWluSWQgKiAyICsgMzUpIDogcmVjb3ZlcnkgKyAyNztcbiAgICAgICAgcmV0dXJuIHsgcjogciwgczogcywgdjogdl8xIH07XG4gICAgfVxuICAgIHZhciBjaGFpbklkQk4gPSB0eXBlc18xLnRvVHlwZShjaGFpbklkLCB0eXBlc18xLlR5cGVPdXRwdXQuQk4pO1xuICAgIHZhciB2ID0gY2hhaW5JZEJOLm11bG4oMikuYWRkbigzNSkuYWRkbihyZWNvdmVyeSkudG9BcnJheUxpa2UoQnVmZmVyKTtcbiAgICByZXR1cm4geyByOiByLCBzOiBzLCB2OiB2IH07XG59XG5leHBvcnRzLmVjc2lnbiA9IGVjc2lnbjtcbmZ1bmN0aW9uIGNhbGN1bGF0ZVNpZ1JlY292ZXJ5KHYsIGNoYWluSWQpIHtcbiAgICB2YXIgdkJOID0gdHlwZXNfMS50b1R5cGUodiwgdHlwZXNfMS5UeXBlT3V0cHV0LkJOKTtcbiAgICBpZiAoIWNoYWluSWQpIHtcbiAgICAgICAgcmV0dXJuIHZCTi5zdWJuKDI3KTtcbiAgICB9XG4gICAgdmFyIGNoYWluSWRCTiA9IHR5cGVzXzEudG9UeXBlKGNoYWluSWQsIHR5cGVzXzEuVHlwZU91dHB1dC5CTik7XG4gICAgcmV0dXJuIHZCTi5zdWIoY2hhaW5JZEJOLm11bG4oMikuYWRkbigzNSkpO1xufVxuZnVuY3Rpb24gaXNWYWxpZFNpZ1JlY292ZXJ5KHJlY292ZXJ5KSB7XG4gICAgdmFyIHJlYyA9IG5ldyBibl9qc18xLmRlZmF1bHQocmVjb3ZlcnkpO1xuICAgIHJldHVybiByZWMuZXFuKDApIHx8IHJlYy5lcW4oMSk7XG59XG4vKipcbiAqIEVDRFNBIHB1YmxpYyBrZXkgcmVjb3ZlcnkgZnJvbSBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBSZWNvdmVyZWQgcHVibGljIGtleVxuICovXG5leHBvcnRzLmVjcmVjb3ZlciA9IGZ1bmN0aW9uIChtc2dIYXNoLCB2LCByLCBzLCBjaGFpbklkKSB7XG4gICAgdmFyIHNpZ25hdHVyZSA9IEJ1ZmZlci5jb25jYXQoW2J5dGVzXzEuc2V0TGVuZ3RoTGVmdChyLCAzMiksIGJ5dGVzXzEuc2V0TGVuZ3RoTGVmdChzLCAzMildLCA2NCk7XG4gICAgdmFyIHJlY292ZXJ5ID0gY2FsY3VsYXRlU2lnUmVjb3ZlcnkodiwgY2hhaW5JZCk7XG4gICAgaWYgKCFpc1ZhbGlkU2lnUmVjb3ZlcnkocmVjb3ZlcnkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgdiB2YWx1ZScpO1xuICAgIH1cbiAgICB2YXIgc2VuZGVyUHViS2V5ID0gc2VjcDI1NmsxXzEuZWNkc2FSZWNvdmVyKHNpZ25hdHVyZSwgcmVjb3ZlcnkudG9OdW1iZXIoKSwgbXNnSGFzaCk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMV8xLnB1YmxpY0tleUNvbnZlcnQoc2VuZGVyUHViS2V5LCBmYWxzZSkuc2xpY2UoMSkpO1xufTtcbi8qKlxuICogQ29udmVydCBzaWduYXR1cmUgcGFyYW1ldGVycyBpbnRvIHRoZSBmb3JtYXQgb2YgYGV0aF9zaWduYCBSUEMgbWV0aG9kLlxuICogQHJldHVybnMgU2lnbmF0dXJlXG4gKi9cbmV4cG9ydHMudG9ScGNTaWcgPSBmdW5jdGlvbiAodiwgciwgcywgY2hhaW5JZCkge1xuICAgIHZhciByZWNvdmVyeSA9IGNhbGN1bGF0ZVNpZ1JlY292ZXJ5KHYsIGNoYWluSWQpO1xuICAgIGlmICghaXNWYWxpZFNpZ1JlY292ZXJ5KHJlY292ZXJ5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIHYgdmFsdWUnKTtcbiAgICB9XG4gICAgLy8gZ2V0aCAoYW5kIHRoZSBSUEMgZXRoX3NpZ24gbWV0aG9kKSB1c2VzIHRoZSA2NSBieXRlIGZvcm1hdCB1c2VkIGJ5IEJpdGNvaW5cbiAgICByZXR1cm4gYnl0ZXNfMS5idWZmZXJUb0hleChCdWZmZXIuY29uY2F0KFtieXRlc18xLnNldExlbmd0aExlZnQociwgMzIpLCBieXRlc18xLnNldExlbmd0aExlZnQocywgMzIpLCBieXRlc18xLnRvQnVmZmVyKHYpXSkpO1xufTtcbi8qKlxuICogQ29udmVydCBzaWduYXR1cmUgcGFyYW1ldGVycyBpbnRvIHRoZSBmb3JtYXQgb2YgQ29tcGFjdCBTaWduYXR1cmUgUmVwcmVzZW50YXRpb24gKEVJUC0yMDk4KS5cbiAqIEByZXR1cm5zIFNpZ25hdHVyZVxuICovXG5leHBvcnRzLnRvQ29tcGFjdFNpZyA9IGZ1bmN0aW9uICh2LCByLCBzLCBjaGFpbklkKSB7XG4gICAgdmFyIHJlY292ZXJ5ID0gY2FsY3VsYXRlU2lnUmVjb3ZlcnkodiwgY2hhaW5JZCk7XG4gICAgaWYgKCFpc1ZhbGlkU2lnUmVjb3ZlcnkocmVjb3ZlcnkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgdiB2YWx1ZScpO1xuICAgIH1cbiAgICB2YXIgdm4gPSB0eXBlc18xLnRvVHlwZSh2LCB0eXBlc18xLlR5cGVPdXRwdXQuTnVtYmVyKTtcbiAgICB2YXIgc3MgPSBzO1xuICAgIGlmICgodm4gPiAyOCAmJiB2biAlIDIgPT09IDEpIHx8IHZuID09PSAxIHx8IHZuID09PSAyOCkge1xuICAgICAgICBzcyA9IEJ1ZmZlci5mcm9tKHMpO1xuICAgICAgICBzc1swXSB8PSAweDgwO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXNfMS5idWZmZXJUb0hleChCdWZmZXIuY29uY2F0KFtieXRlc18xLnNldExlbmd0aExlZnQociwgMzIpLCBieXRlc18xLnNldExlbmd0aExlZnQoc3MsIDMyKV0pKTtcbn07XG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIGZvcm1hdCBvZiB0aGUgYGV0aF9zaWduYCBSUEMgbWV0aG9kIHRvIHNpZ25hdHVyZSBwYXJhbWV0ZXJzXG4gKiBOT1RFOiBhbGwgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBnZXRoOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vaXNzdWVzLzIwNTNcbiAqL1xuZXhwb3J0cy5mcm9tUnBjU2lnID0gZnVuY3Rpb24gKHNpZykge1xuICAgIHZhciBidWYgPSBieXRlc18xLnRvQnVmZmVyKHNpZyk7XG4gICAgdmFyIHI7XG4gICAgdmFyIHM7XG4gICAgdmFyIHY7XG4gICAgaWYgKGJ1Zi5sZW5ndGggPj0gNjUpIHtcbiAgICAgICAgciA9IGJ1Zi5zbGljZSgwLCAzMik7XG4gICAgICAgIHMgPSBidWYuc2xpY2UoMzIsIDY0KTtcbiAgICAgICAgdiA9IGJ5dGVzXzEuYnVmZmVyVG9JbnQoYnVmLnNsaWNlKDY0KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJ1Zi5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgIC8vIENvbXBhY3QgU2lnbmF0dXJlIFJlcHJlc2VudGF0aW9uIChodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTIwOTgpXG4gICAgICAgIHIgPSBidWYuc2xpY2UoMCwgMzIpO1xuICAgICAgICBzID0gYnVmLnNsaWNlKDMyLCA2NCk7XG4gICAgICAgIHYgPSBieXRlc18xLmJ1ZmZlclRvSW50KGJ1Zi5zbGljZSgzMiwgMzMpKSA+PiA3O1xuICAgICAgICBzWzBdICY9IDB4N2Y7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIGxlbmd0aCcpO1xuICAgIH1cbiAgICAvLyBzdXBwb3J0IGJvdGggdmVyc2lvbnMgb2YgYGV0aF9zaWduYCByZXNwb25zZXNcbiAgICBpZiAodiA8IDI3KSB7XG4gICAgICAgIHYgKz0gMjc7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHY6IHYsXG4gICAgICAgIHI6IHIsXG4gICAgICAgIHM6IHMsXG4gICAgfTtcbn07XG4vKipcbiAqIFZhbGlkYXRlIGEgRUNEU0Egc2lnbmF0dXJlLlxuICogQHBhcmFtIGhvbWVzdGVhZE9yTGF0ZXIgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBiZWluZyB1c2VkIG9uIGVpdGhlciB0aGUgaG9tZXN0ZWFkIGhhcmRmb3JrIG9yIGEgbGF0ZXIgb25lXG4gKi9cbmV4cG9ydHMuaXNWYWxpZFNpZ25hdHVyZSA9IGZ1bmN0aW9uICh2LCByLCBzLCBob21lc3RlYWRPckxhdGVyLCBjaGFpbklkKSB7XG4gICAgaWYgKGhvbWVzdGVhZE9yTGF0ZXIgPT09IHZvaWQgMCkgeyBob21lc3RlYWRPckxhdGVyID0gdHJ1ZTsgfVxuICAgIHZhciBTRUNQMjU2SzFfTl9ESVZfMiA9IG5ldyBibl9qc18xLmRlZmF1bHQoJzdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmNWQ1NzZlNzM1N2E0NTAxZGRmZTkyZjQ2NjgxYjIwYTAnLCAxNik7XG4gICAgdmFyIFNFQ1AyNTZLMV9OID0gbmV3IGJuX2pzXzEuZGVmYXVsdCgnZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScsIDE2KTtcbiAgICBpZiAoci5sZW5ndGggIT09IDMyIHx8IHMubGVuZ3RoICE9PSAzMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZFNpZ1JlY292ZXJ5KGNhbGN1bGF0ZVNpZ1JlY292ZXJ5KHYsIGNoYWluSWQpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciByQk4gPSBuZXcgYm5fanNfMS5kZWZhdWx0KHIpO1xuICAgIHZhciBzQk4gPSBuZXcgYm5fanNfMS5kZWZhdWx0KHMpO1xuICAgIGlmIChyQk4uaXNaZXJvKCkgfHwgckJOLmd0KFNFQ1AyNTZLMV9OKSB8fCBzQk4uaXNaZXJvKCkgfHwgc0JOLmd0KFNFQ1AyNTZLMV9OKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChob21lc3RlYWRPckxhdGVyICYmIHNCTi5jbXAoU0VDUDI1NksxX05fRElWXzIpID09PSAxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBrZWNjYWstMjU2IGhhc2ggb2YgYG1lc3NhZ2VgLCBwcmVmaXhlZCB3aXRoIHRoZSBoZWFkZXIgdXNlZCBieSB0aGUgYGV0aF9zaWduYCBSUEMgY2FsbC5cbiAqIFRoZSBvdXRwdXQgb2YgdGhpcyBmdW5jdGlvbiBjYW4gYmUgZmVkIGludG8gYGVjc2lnbmAgdG8gcHJvZHVjZSB0aGUgc2FtZSBzaWduYXR1cmUgYXMgdGhlIGBldGhfc2lnbmBcbiAqIGNhbGwgZm9yIGEgZ2l2ZW4gYG1lc3NhZ2VgLCBvciBmZWQgdG8gYGVjcmVjb3ZlcmAgYWxvbmcgd2l0aCBhIHNpZ25hdHVyZSB0byByZWNvdmVyIHRoZSBwdWJsaWMga2V5XG4gKiB1c2VkIHRvIHByb2R1Y2UgdGhlIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0cy5oYXNoUGVyc29uYWxNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIobWVzc2FnZSk7XG4gICAgdmFyIHByZWZpeCA9IEJ1ZmZlci5mcm9tKFwiXFx1MDAxOUV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxcblwiICsgbWVzc2FnZS5sZW5ndGgudG9TdHJpbmcoKSwgJ3V0Zi04Jyk7XG4gICAgcmV0dXJuIGhhc2hfMS5rZWNjYWsoQnVmZmVyLmNvbmNhdChbcHJlZml4LCBtZXNzYWdlXSkpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25hdHVyZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJscGhhc2ggPSBleHBvcnRzLnJpcGVtZDE2MEZyb21BcnJheSA9IGV4cG9ydHMucmlwZW1kMTYwRnJvbVN0cmluZyA9IGV4cG9ydHMucmlwZW1kMTYwID0gZXhwb3J0cy5zaGEyNTZGcm9tQXJyYXkgPSBleHBvcnRzLnNoYTI1NkZyb21TdHJpbmcgPSBleHBvcnRzLnNoYTI1NiA9IGV4cG9ydHMua2VjY2FrRnJvbUFycmF5ID0gZXhwb3J0cy5rZWNjYWtGcm9tSGV4U3RyaW5nID0gZXhwb3J0cy5rZWNjYWtGcm9tU3RyaW5nID0gZXhwb3J0cy5rZWNjYWsyNTYgPSBleHBvcnRzLmtlY2NhayA9IHZvaWQgMDtcbnZhciBrZWNjYWtfMSA9IHJlcXVpcmUoXCJldGhlcmV1bS1jcnlwdG9ncmFwaHkva2VjY2FrXCIpO1xudmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpO1xudmFyIHJscCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmxwXCIpKTtcbnZhciBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG52YXIgaGVscGVyc18xID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcbi8qKlxuICogQ3JlYXRlcyBLZWNjYWsgaGFzaCBvZiBhIEJ1ZmZlciBpbnB1dFxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKEJ1ZmZlcilcbiAqIEBwYXJhbSBiaXRzIChudW1iZXIgPSAyNTYpIFRoZSBLZWNjYWsgd2lkdGhcbiAqL1xuZXhwb3J0cy5rZWNjYWsgPSBmdW5jdGlvbiAoYSwgYml0cykge1xuICAgIGlmIChiaXRzID09PSB2b2lkIDApIHsgYml0cyA9IDI1NjsgfVxuICAgIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcihhKTtcbiAgICBzd2l0Y2ggKGJpdHMpIHtcbiAgICAgICAgY2FzZSAyMjQ6IHtcbiAgICAgICAgICAgIHJldHVybiBrZWNjYWtfMS5rZWNjYWsyMjQoYSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyNTY6IHtcbiAgICAgICAgICAgIHJldHVybiBrZWNjYWtfMS5rZWNjYWsyNTYoYSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAzODQ6IHtcbiAgICAgICAgICAgIHJldHVybiBrZWNjYWtfMS5rZWNjYWszODQoYSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSA1MTI6IHtcbiAgICAgICAgICAgIHJldHVybiBrZWNjYWtfMS5rZWNjYWs1MTIoYSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxkIGFsZ29yaXRobToga2VjY2FrXCIgKyBiaXRzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqIENyZWF0ZXMgS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBpbnB1dCwgYWxpYXMgZm9yIGtlY2NhayhhLCAyNTYpLlxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKEJ1ZmZlcilcbiAqL1xuZXhwb3J0cy5rZWNjYWsyNTYgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBleHBvcnRzLmtlY2NhayhhKTtcbn07XG4vKipcbiAqIENyZWF0ZXMgS2VjY2FrIGhhc2ggb2YgYSB1dGYtOCBzdHJpbmcgaW5wdXRcbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChTdHJpbmcpXG4gKiBAcGFyYW0gYml0cyAobnVtYmVyID0gMjU2KSBUaGUgS2VjY2FrIHdpZHRoXG4gKi9cbmV4cG9ydHMua2VjY2FrRnJvbVN0cmluZyA9IGZ1bmN0aW9uIChhLCBiaXRzKSB7XG4gICAgaWYgKGJpdHMgPT09IHZvaWQgMCkgeyBiaXRzID0gMjU2OyB9XG4gICAgaGVscGVyc18xLmFzc2VydElzU3RyaW5nKGEpO1xuICAgIHZhciBidWYgPSBCdWZmZXIuZnJvbShhLCAndXRmOCcpO1xuICAgIHJldHVybiBleHBvcnRzLmtlY2NhayhidWYsIGJpdHMpO1xufTtcbi8qKlxuICogQ3JlYXRlcyBLZWNjYWsgaGFzaCBvZiBhbiAweC1wcmVmaXhlZCBzdHJpbmcgaW5wdXRcbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChTdHJpbmcpXG4gKiBAcGFyYW0gYml0cyAobnVtYmVyID0gMjU2KSBUaGUgS2VjY2FrIHdpZHRoXG4gKi9cbmV4cG9ydHMua2VjY2FrRnJvbUhleFN0cmluZyA9IGZ1bmN0aW9uIChhLCBiaXRzKSB7XG4gICAgaWYgKGJpdHMgPT09IHZvaWQgMCkgeyBiaXRzID0gMjU2OyB9XG4gICAgaGVscGVyc18xLmFzc2VydElzSGV4U3RyaW5nKGEpO1xuICAgIHJldHVybiBleHBvcnRzLmtlY2NhayhieXRlc18xLnRvQnVmZmVyKGEpLCBiaXRzKTtcbn07XG4vKipcbiAqIENyZWF0ZXMgS2VjY2FrIGhhc2ggb2YgYSBudW1iZXIgYXJyYXkgaW5wdXRcbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChudW1iZXJbXSlcbiAqIEBwYXJhbSBiaXRzIChudW1iZXIgPSAyNTYpIFRoZSBLZWNjYWsgd2lkdGhcbiAqL1xuZXhwb3J0cy5rZWNjYWtGcm9tQXJyYXkgPSBmdW5jdGlvbiAoYSwgYml0cykge1xuICAgIGlmIChiaXRzID09PSB2b2lkIDApIHsgYml0cyA9IDI1NjsgfVxuICAgIGhlbHBlcnNfMS5hc3NlcnRJc0FycmF5KGEpO1xuICAgIHJldHVybiBleHBvcnRzLmtlY2NhayhieXRlc18xLnRvQnVmZmVyKGEpLCBiaXRzKTtcbn07XG4vKipcbiAqIENyZWF0ZXMgU0hBMjU2IGhhc2ggb2YgYW4gaW5wdXQuXG4gKiBAcGFyYW0gIGEgVGhlIGlucHV0IGRhdGEgKEJ1ZmZlcnxBcnJheXxTdHJpbmcpXG4gKi9cbnZhciBfc2hhMjU2ID0gZnVuY3Rpb24gKGEpIHtcbiAgICBhID0gYnl0ZXNfMS50b0J1ZmZlcihhKTtcbiAgICByZXR1cm4gY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKGEpLmRpZ2VzdCgpO1xufTtcbi8qKlxuICogQ3JlYXRlcyBTSEEyNTYgaGFzaCBvZiBhIEJ1ZmZlciBpbnB1dC5cbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChCdWZmZXIpXG4gKi9cbmV4cG9ydHMuc2hhMjU2ID0gZnVuY3Rpb24gKGEpIHtcbiAgICBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIoYSk7XG4gICAgcmV0dXJuIF9zaGEyNTYoYSk7XG59O1xuLyoqXG4gKiBDcmVhdGVzIFNIQTI1NiBoYXNoIG9mIGEgc3RyaW5nIGlucHV0LlxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKHN0cmluZylcbiAqL1xuZXhwb3J0cy5zaGEyNTZGcm9tU3RyaW5nID0gZnVuY3Rpb24gKGEpIHtcbiAgICBoZWxwZXJzXzEuYXNzZXJ0SXNTdHJpbmcoYSk7XG4gICAgcmV0dXJuIF9zaGEyNTYoYSk7XG59O1xuLyoqXG4gKiBDcmVhdGVzIFNIQTI1NiBoYXNoIG9mIGEgbnVtYmVyW10gaW5wdXQuXG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAobnVtYmVyW10pXG4gKi9cbmV4cG9ydHMuc2hhMjU2RnJvbUFycmF5ID0gZnVuY3Rpb24gKGEpIHtcbiAgICBoZWxwZXJzXzEuYXNzZXJ0SXNBcnJheShhKTtcbiAgICByZXR1cm4gX3NoYTI1NihhKTtcbn07XG4vKipcbiAqIENyZWF0ZXMgUklQRU1EMTYwIGhhc2ggb2YgdGhlIGlucHV0LlxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKEJ1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyKVxuICogQHBhcmFtIHBhZGRlZCBXaGV0aGVyIGl0IHNob3VsZCBiZSBwYWRkZWQgdG8gMjU2IGJpdHMgb3Igbm90XG4gKi9cbnZhciBfcmlwZW1kMTYwID0gZnVuY3Rpb24gKGEsIHBhZGRlZCkge1xuICAgIGEgPSBieXRlc18xLnRvQnVmZmVyKGEpO1xuICAgIHZhciBoYXNoID0gY3JlYXRlSGFzaCgncm1kMTYwJykudXBkYXRlKGEpLmRpZ2VzdCgpO1xuICAgIGlmIChwYWRkZWQgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzXzEuc2V0TGVuZ3RoTGVmdChoYXNoLCAzMik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG59O1xuLyoqXG4gKiBDcmVhdGVzIFJJUEVNRDE2MCBoYXNoIG9mIGEgQnVmZmVyIGlucHV0LlxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKEJ1ZmZlcilcbiAqIEBwYXJhbSBwYWRkZWQgV2hldGhlciBpdCBzaG91bGQgYmUgcGFkZGVkIHRvIDI1NiBiaXRzIG9yIG5vdFxuICovXG5leHBvcnRzLnJpcGVtZDE2MCA9IGZ1bmN0aW9uIChhLCBwYWRkZWQpIHtcbiAgICBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIoYSk7XG4gICAgcmV0dXJuIF9yaXBlbWQxNjAoYSwgcGFkZGVkKTtcbn07XG4vKipcbiAqIENyZWF0ZXMgUklQRU1EMTYwIGhhc2ggb2YgYSBzdHJpbmcgaW5wdXQuXG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAoU3RyaW5nKVxuICogQHBhcmFtIHBhZGRlZCBXaGV0aGVyIGl0IHNob3VsZCBiZSBwYWRkZWQgdG8gMjU2IGJpdHMgb3Igbm90XG4gKi9cbmV4cG9ydHMucmlwZW1kMTYwRnJvbVN0cmluZyA9IGZ1bmN0aW9uIChhLCBwYWRkZWQpIHtcbiAgICBoZWxwZXJzXzEuYXNzZXJ0SXNTdHJpbmcoYSk7XG4gICAgcmV0dXJuIF9yaXBlbWQxNjAoYSwgcGFkZGVkKTtcbn07XG4vKipcbiAqIENyZWF0ZXMgUklQRU1EMTYwIGhhc2ggb2YgYSBudW1iZXJbXSBpbnB1dC5cbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChudW1iZXJbXSlcbiAqIEBwYXJhbSBwYWRkZWQgV2hldGhlciBpdCBzaG91bGQgYmUgcGFkZGVkIHRvIDI1NiBiaXRzIG9yIG5vdFxuICovXG5leHBvcnRzLnJpcGVtZDE2MEZyb21BcnJheSA9IGZ1bmN0aW9uIChhLCBwYWRkZWQpIHtcbiAgICBoZWxwZXJzXzEuYXNzZXJ0SXNBcnJheShhKTtcbiAgICByZXR1cm4gX3JpcGVtZDE2MChhLCBwYWRkZWQpO1xufTtcbi8qKlxuICogQ3JlYXRlcyBTSEEtMyBoYXNoIG9mIHRoZSBSTFAgZW5jb2RlZCB2ZXJzaW9uIG9mIHRoZSBpbnB1dC5cbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhXG4gKi9cbmV4cG9ydHMucmxwaGFzaCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMua2VjY2FrKHJscC5lbmNvZGUoYSkpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2guanMubWFwIiwiaW1wb3J0IHsgTUFYX1NBRkVfQ0hBSU5fSUQgfSBmcm9tICcuLi9jb25zdGFudHMvbmV0d29yayc7XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIG51bWJlciBwcmltaXRpdmUgY2hhaW4gSUQgaXMgc2FmZS5cbiAqIEJlY2F1c2Ugc29tZSBjcnlwdG9ncmFwaGljIGxpYnJhcmllcyB3ZSB1c2UgZXhwZWN0IHRoZSBjaGFpbiBJRCB0byBiZSBhXG4gKiBudW1iZXIgcHJpbWl0aXZlLCBpdCBtdXN0IG5vdCBleGNlZWQgYSBjZXJ0YWluIHNpemUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNoYWluSWQgLSBUaGUgY2hhaW4gSUQgdG8gY2hlY2sgZm9yIHNhZmV0eS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBnaXZlbiBjaGFpbiBJRCBpcyBzYWZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTYWZlQ2hhaW5JZChjaGFpbklkKSB7XG4gIHJldHVybiAoXG4gICAgTnVtYmVyLmlzU2FmZUludGVnZXIoY2hhaW5JZCkgJiYgY2hhaW5JZCA+IDAgJiYgY2hhaW5JZCA8PSBNQVhfU0FGRV9DSEFJTl9JRFxuICApO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIDB4LXByZWZpeGVkLCBub24temVybywgbm9uLXplcm8tcGFkZGVkLFxuICogaGV4YWRlY2ltYWwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBhIGNvcnJlY3RseSBmb3JtYXR0ZWQgaGV4IHN0cmluZyxcbiAqIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUHJlZml4ZWRGb3JtYXR0ZWRIZXhTdHJpbmcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIC9eMHhbMS05YS1mXStbMC05YS1mXSokL2l1LnRlc3QodmFsdWUpO1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbmNvbnN0IFNhZmVFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdzYWZlLWV2ZW50LWVtaXR0ZXInKVxuXG5jbGFzcyBPYnNlcnZhYmxlU3RvcmUgZXh0ZW5kcyBTYWZlRXZlbnRFbWl0dGVyIHtcblxuICBjb25zdHJ1Y3RvciAoaW5pdFN0YXRlID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgLy8gc2V0IGluaXQgc3RhdGVcbiAgICB0aGlzLl9zdGF0ZSA9IGluaXRTdGF0ZVxuICB9XG5cbiAgLy8gd3JhcHBlciBhcm91bmQgaW50ZXJuYWwgZ2V0U3RhdGVcbiAgZ2V0U3RhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTdGF0ZSgpXG4gIH1cbiAgXG4gIC8vIHdyYXBwZXIgYXJvdW5kIGludGVybmFsIHB1dFN0YXRlXG4gIHB1dFN0YXRlIChuZXdTdGF0ZSkge1xuICAgIHRoaXMuX3B1dFN0YXRlKG5ld1N0YXRlKVxuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgbmV3U3RhdGUpXG4gIH1cblxuICB1cGRhdGVTdGF0ZSAocGFydGlhbFN0YXRlKSB7XG4gICAgLy8gaWYgbm9uLW51bGwgb2JqZWN0LCBtZXJnZVxuICAgIGlmIChwYXJ0aWFsU3RhdGUgJiYgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpXG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCBwYXJ0aWFsU3RhdGUpXG4gICAgICB0aGlzLnB1dFN0YXRlKG5ld1N0YXRlKVxuICAgIC8vIGlmIG5vdCBvYmplY3QsIHVzZSBuZXcgdmFsdWVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXRTdGF0ZShwYXJ0aWFsU3RhdGUpXG4gICAgfVxuICB9XG5cbiAgLy8gc3Vic2NyaWJlIHRvIGNoYW5nZXNcbiAgc3Vic2NyaWJlIChoYW5kbGVyKSB7XG4gICAgdGhpcy5vbigndXBkYXRlJywgaGFuZGxlcilcbiAgfVxuXG4gIC8vIHVuc3Vic2NyaWJlIHRvIGNoYW5nZXNcbiAgdW5zdWJzY3JpYmUgKGhhbmRsZXIpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCd1cGRhdGUnLCBoYW5kbGVyKVxuICB9XG5cbiAgLy9cbiAgLy8gcHJpdmF0ZVxuICAvL1xuXG4gIC8vIHJlYWQgZnJvbSBwZXJzaXN0ZW5jZVxuICBfZ2V0U3RhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZVxuICB9XG5cbiAgLy8gd3JpdGUgdG8gcGVyc2lzdGVuY2VcbiAgX3B1dFN0YXRlIChuZXdTdGF0ZSkge1xuICAgIHRoaXMuX3N0YXRlID0gbmV3U3RhdGVcbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gT2JzZXJ2YWJsZVN0b3JlXG4iLCJ2YXIgVW5pYmFiZWwgPSByZXF1aXJlKCdicm93c2VyaWZ5LXVuaWJhYmVsJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLy8gU2ltcGxlIGVuY3J5cHRpb24gbWV0aG9kczpcbiAgZW5jcnlwdCxcbiAgZGVjcnlwdCxcblxuICAvLyBNb3JlIGFkdmFuY2VkIGVuY3J5cHRpb24gbWV0aG9kczpcbiAga2V5RnJvbVBhc3N3b3JkLFxuICBlbmNyeXB0V2l0aEtleSxcbiAgZGVjcnlwdFdpdGhLZXksXG5cbiAgLy8gQnVmZmVyIDwtPiBIZXggc3RyaW5nIG1ldGhvZHNcbiAgc2VyaWFsaXplQnVmZmVyRm9yU3RvcmFnZSxcbiAgc2VyaWFsaXplQnVmZmVyRnJvbVN0b3JhZ2UsXG5cbiAgZ2VuZXJhdGVTYWx0LFxufVxuXG4vLyBUYWtlcyBhIFBvam8sIHJldHVybnMgY3lwaGVyIHRleHQuXG5mdW5jdGlvbiBlbmNyeXB0IChwYXNzd29yZCwgZGF0YU9iaikge1xuICB2YXIgc2FsdCA9IGdlbmVyYXRlU2FsdCgpXG5cbiAgcmV0dXJuIGtleUZyb21QYXNzd29yZChwYXNzd29yZCwgc2FsdClcbiAgLnRoZW4oZnVuY3Rpb24gKHBhc3N3b3JkRGVyaXZlZEtleSkge1xuICAgIHJldHVybiBlbmNyeXB0V2l0aEtleShwYXNzd29yZERlcml2ZWRLZXksIGRhdGFPYmopXG4gIH0pXG4gIC50aGVuKGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgcGF5bG9hZC5zYWx0ID0gc2FsdFxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKVxuICB9KVxufVxuXG5mdW5jdGlvbiBlbmNyeXB0V2l0aEtleSAoa2V5LCBkYXRhT2JqKSB7XG4gIHZhciBkYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YU9iailcbiAgdmFyIGRhdGFCdWZmZXIgPSBVbmliYWJlbC51dGY4VG9CdWZmZXIoZGF0YSlcbiAgdmFyIHZlY3RvciA9IGdsb2JhbC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDE2KSlcbiAgcmV0dXJuIGdsb2JhbC5jcnlwdG8uc3VidGxlLmVuY3J5cHQoe1xuICAgIG5hbWU6ICdBRVMtR0NNJyxcbiAgICBpdjogdmVjdG9yLFxuICB9LCBrZXksIGRhdGFCdWZmZXIpLnRoZW4oZnVuY3Rpb24gKGJ1Zikge1xuICAgIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgdmFyIHZlY3RvclN0ciA9IFVuaWJhYmVsLmJ1ZmZlclRvQmFzZTY0KHZlY3RvcilcbiAgICB2YXIgdmF1bHRTdHIgPSBVbmliYWJlbC5idWZmZXJUb0Jhc2U2NChidWZmZXIpXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHZhdWx0U3RyLFxuICAgICAgaXY6IHZlY3RvclN0cixcbiAgICB9XG4gIH0pXG59XG5cbi8vIFRha2VzIGVuY3J5cHRlZCB0ZXh0LCByZXR1cm5zIHRoZSByZXN0b3JlZCBQb2pvLlxuZnVuY3Rpb24gZGVjcnlwdCAocGFzc3dvcmQsIHRleHQpIHtcbiAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UodGV4dClcbiAgY29uc3Qgc2FsdCA9IHBheWxvYWQuc2FsdFxuICByZXR1cm4ga2V5RnJvbVBhc3N3b3JkKHBhc3N3b3JkLCBzYWx0KVxuICAudGhlbihmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGRlY3J5cHRXaXRoS2V5KGtleSwgcGF5bG9hZClcbiAgfSlcbn1cblxuZnVuY3Rpb24gZGVjcnlwdFdpdGhLZXkgKGtleSwgcGF5bG9hZCkge1xuICBjb25zdCBlbmNyeXB0ZWREYXRhID0gVW5pYmFiZWwuYmFzZTY0VG9CdWZmZXIocGF5bG9hZC5kYXRhKVxuICBjb25zdCB2ZWN0b3IgPSBVbmliYWJlbC5iYXNlNjRUb0J1ZmZlcihwYXlsb2FkLml2KVxuICByZXR1cm4gY3J5cHRvLnN1YnRsZS5kZWNyeXB0KHtuYW1lOiAnQUVTLUdDTScsIGl2OiB2ZWN0b3J9LCBrZXksIGVuY3J5cHRlZERhdGEpXG4gIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICBjb25zdCBkZWNyeXB0ZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KVxuICAgIGNvbnN0IGRlY3J5cHRlZFN0ciA9IFVuaWJhYmVsLmJ1ZmZlclRvVXRmOChkZWNyeXB0ZWREYXRhKVxuICAgIGNvbnN0IGRlY3J5cHRlZE9iaiA9IEpTT04ucGFyc2UoZGVjcnlwdGVkU3RyKVxuICAgIHJldHVybiBkZWNyeXB0ZWRPYmpcbiAgfSlcbiAgLmNhdGNoKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBwYXNzd29yZCcpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGtleUZyb21QYXNzd29yZCAocGFzc3dvcmQsIHNhbHQpIHtcbiAgdmFyIHBhc3NCdWZmZXIgPSBVbmliYWJlbC51dGY4VG9CdWZmZXIocGFzc3dvcmQpXG4gIHZhciBzYWx0QnVmZmVyID0gVW5pYmFiZWwuYmFzZTY0VG9CdWZmZXIoc2FsdClcblxuICByZXR1cm4gZ2xvYmFsLmNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgICdyYXcnLFxuICAgIHBhc3NCdWZmZXIsXG4gICAgeyBuYW1lOiAnUEJLREYyJyB9LFxuICAgIGZhbHNlLFxuICAgIFsnZGVyaXZlQml0cycsICdkZXJpdmVLZXknXVxuICApLnRoZW4oZnVuY3Rpb24gKGtleSkge1xuXG4gICAgcmV0dXJuIGdsb2JhbC5jcnlwdG8uc3VidGxlLmRlcml2ZUtleShcbiAgICAgIHsgbmFtZTogJ1BCS0RGMicsXG4gICAgICAgIHNhbHQ6IHNhbHRCdWZmZXIsXG4gICAgICAgIGl0ZXJhdGlvbnM6IDEwMDAwLFxuICAgICAgICBoYXNoOiAnU0hBLTI1NicsXG4gICAgICB9LFxuICAgICAga2V5LFxuICAgICAgeyBuYW1lOiAnQUVTLUdDTScsIGxlbmd0aDogMjU2IH0sXG4gICAgICBmYWxzZSxcbiAgICAgIFsnZW5jcnlwdCcsICdkZWNyeXB0J11cbiAgICApXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUJ1ZmZlckZyb21TdG9yYWdlIChzdHIpIHtcbiAgdmFyIHN0cmlwU3RyID0gKHN0ci5zbGljZSgwLCAyKSA9PT0gJzB4JykgPyBzdHIuc2xpY2UoMikgOiBzdHJcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHN0cmlwU3RyLmxlbmd0aCAvIDIpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaXBTdHIubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgc2VnID0gc3RyaXBTdHIuc3Vic3RyKGksIDIpXG4gICAgYnVmW2kgLyAyXSA9IHBhcnNlSW50KHNlZywgMTYpXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG4vLyBTaG91bGQgcmV0dXJuIGEgc3RyaW5nLCByZWFkeSBmb3Igc3RvcmFnZSwgaW4gaGV4IGZvcm1hdC5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUJ1ZmZlckZvclN0b3JhZ2UgKGJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gJzB4J1xuICB2YXIgbGVuID0gYnVmZmVyLmxlbmd0aCB8fCBidWZmZXIuYnl0ZUxlbmd0aFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IHVucHJlZml4ZWRIZXgoYnVmZmVyW2ldKVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gdW5wcmVmaXhlZEhleCAobnVtKSB7XG4gIHZhciBoZXggPSBudW0udG9TdHJpbmcoMTYpXG4gIHdoaWxlIChoZXgubGVuZ3RoIDwgMikge1xuICAgIGhleCA9ICcwJyArIGhleFxuICB9XG4gIHJldHVybiBoZXhcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVTYWx0IChieXRlQ291bnQgPSAzMikge1xuICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ5dGVDb3VudClcbiAgZ2xvYmFsLmNyeXB0by5nZXRSYW5kb21WYWx1ZXModmlldylcbiAgdmFyIGI2NGVuY29kZWQgPSBidG9hKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdmlldykpXG4gIHJldHVybiBiNjRlbmNvZGVkXG59XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKVxudmFyIHBia2RmMiA9IHJlcXVpcmUoJ3Bia2RmMicpLnBia2RmMlN5bmNcbnZhciByYW5kb21CeXRlcyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJylcblxuLy8gdXNlIHVub3JtIHVudGlsIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplIGdldHMgYmV0dGVyIGJyb3dzZXIgc3VwcG9ydFxudmFyIHVub3JtID0gcmVxdWlyZSgndW5vcm0nKVxuXG52YXIgQ0hJTkVTRV9TSU1QTElGSUVEX1dPUkRMSVNUID0gcmVxdWlyZSgnLi93b3JkbGlzdHMvY2hpbmVzZV9zaW1wbGlmaWVkLmpzb24nKVxudmFyIENISU5FU0VfVFJBRElUSU9OQUxfV09SRExJU1QgPSByZXF1aXJlKCcuL3dvcmRsaXN0cy9jaGluZXNlX3RyYWRpdGlvbmFsLmpzb24nKVxudmFyIEVOR0xJU0hfV09SRExJU1QgPSByZXF1aXJlKCcuL3dvcmRsaXN0cy9lbmdsaXNoLmpzb24nKVxudmFyIEZSRU5DSF9XT1JETElTVCA9IHJlcXVpcmUoJy4vd29yZGxpc3RzL2ZyZW5jaC5qc29uJylcbnZhciBJVEFMSUFOX1dPUkRMSVNUID0gcmVxdWlyZSgnLi93b3JkbGlzdHMvaXRhbGlhbi5qc29uJylcbnZhciBKQVBBTkVTRV9XT1JETElTVCA9IHJlcXVpcmUoJy4vd29yZGxpc3RzL2phcGFuZXNlLmpzb24nKVxudmFyIEtPUkVBTl9XT1JETElTVCA9IHJlcXVpcmUoJy4vd29yZGxpc3RzL2tvcmVhbi5qc29uJylcbnZhciBTUEFOSVNIX1dPUkRMSVNUID0gcmVxdWlyZSgnLi93b3JkbGlzdHMvc3BhbmlzaC5qc29uJylcbnZhciBERUZBVUxUX1dPUkRMSVNUID0gRU5HTElTSF9XT1JETElTVFxuXG52YXIgSU5WQUxJRF9NTkVNT05JQyA9ICdJbnZhbGlkIG1uZW1vbmljJ1xudmFyIElOVkFMSURfRU5UUk9QWSA9ICdJbnZhbGlkIGVudHJvcHknXG52YXIgSU5WQUxJRF9DSEVDS1NVTSA9ICdJbnZhbGlkIG1uZW1vbmljIGNoZWNrc3VtJ1xuXG5mdW5jdGlvbiBscGFkIChzdHIsIHBhZFN0cmluZywgbGVuZ3RoKSB7XG4gIHdoaWxlIChzdHIubGVuZ3RoIDwgbGVuZ3RoKSBzdHIgPSBwYWRTdHJpbmcgKyBzdHJcbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBiaW5hcnlUb0J5dGUgKGJpbikge1xuICByZXR1cm4gcGFyc2VJbnQoYmluLCAyKVxufVxuXG5mdW5jdGlvbiBieXRlc1RvQmluYXJ5IChieXRlcykge1xuICByZXR1cm4gYnl0ZXMubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIGxwYWQoeC50b1N0cmluZygyKSwgJzAnLCA4KVxuICB9KS5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBkZXJpdmVDaGVja3N1bUJpdHMgKGVudHJvcHlCdWZmZXIpIHtcbiAgdmFyIEVOVCA9IGVudHJvcHlCdWZmZXIubGVuZ3RoICogOFxuICB2YXIgQ1MgPSBFTlQgLyAzMlxuICB2YXIgaGFzaCA9IGNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShlbnRyb3B5QnVmZmVyKS5kaWdlc3QoKVxuXG4gIHJldHVybiBieXRlc1RvQmluYXJ5KFtdLnNsaWNlLmNhbGwoaGFzaCkpLnNsaWNlKDAsIENTKVxufVxuXG5mdW5jdGlvbiBzYWx0IChwYXNzd29yZCkge1xuICByZXR1cm4gJ21uZW1vbmljJyArIChwYXNzd29yZCB8fCAnJylcbn1cblxuZnVuY3Rpb24gbW5lbW9uaWNUb1NlZWQgKG1uZW1vbmljLCBwYXNzd29yZCkge1xuICB2YXIgbW5lbW9uaWNCdWZmZXIgPSB0eXBlb2YgbW5lbW9uaWMgPT09ICdzdHJpbmcnXG4gICAgPyBCdWZmZXIuZnJvbSh1bm9ybS5uZmtkKG1uZW1vbmljKSwgJ3V0ZjgnKVxuICAgIDogbW5lbW9uaWNcbiAgdmFyIHNhbHRCdWZmZXIgPSBCdWZmZXIuZnJvbShzYWx0KHVub3JtLm5ma2QocGFzc3dvcmQpKSwgJ3V0ZjgnKVxuXG4gIHJldHVybiBwYmtkZjIobW5lbW9uaWNCdWZmZXIsIHNhbHRCdWZmZXIsIDIwNDgsIDY0LCAnc2hhNTEyJylcbn1cblxuZnVuY3Rpb24gbW5lbW9uaWNUb1NlZWRIZXggKG1uZW1vbmljLCBwYXNzd29yZCkge1xuICByZXR1cm4gbW5lbW9uaWNUb1NlZWQobW5lbW9uaWMsIHBhc3N3b3JkKS50b1N0cmluZygnaGV4Jylcbn1cblxuZnVuY3Rpb24gbW5lbW9uaWNUb0VudHJvcHkgKG1uZW1vbmljLCB3b3JkbGlzdCkge1xuICB3b3JkbGlzdCA9IHdvcmRsaXN0IHx8IERFRkFVTFRfV09SRExJU1RcblxuICB2YXIgbW5lbW9uaWNBc0J1ZmZlciA9IHR5cGVvZiBtbmVtb25pYyA9PT0gJ3N0cmluZydcbiAgICA/IEJ1ZmZlci5mcm9tKHVub3JtLm5ma2QobW5lbW9uaWMpLCAndXRmOCcpXG4gICAgOiBtbmVtb25pY1xuXG4gIHZhciB3b3JkcyA9IFtdO1xuICB2YXIgY3VycmVudFdvcmQgPSBbXTtcbiAgZm9yIChjb25zdCBieXRlIG9mIG1uZW1vbmljQXNCdWZmZXIudmFsdWVzKCkpIHtcbiAgICAvLyBzcGxpdCBhdCBzcGFjZSBvciBcXHUzMDAwIChpZGVvZ3JhcGhpYyBzcGFjZSwgZm9yIEphcGFuZXNlIHdvcmRsaXN0cylcbiAgICBpZiAoYnl0ZSA9PT0gMHgyMCB8fCBieXRlID09PSAweDMwMDApIHtcbiAgICAgIHdvcmRzLnB1c2goQnVmZmVyLmZyb20oY3VycmVudFdvcmQpKTtcbiAgICAgIGN1cnJlbnRXb3JkID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRXb3JkLnB1c2goYnl0ZSk7XG4gICAgfVxuICB9XG4gIHdvcmRzLnB1c2goQnVmZmVyLmZyb20oY3VycmVudFdvcmQpKTtcblxuICBpZiAod29yZHMubGVuZ3RoICUgMyAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfTU5FTU9OSUMpXG5cbiAgLy8gY29udmVydCB3b3JkIGluZGljZXMgdG8gMTEgYml0IGJpbmFyeSBzdHJpbmdzXG4gIHZhciBiaXRzID0gd29yZHMubWFwKGZ1bmN0aW9uICh3b3JkKSB7XG4gICAgdmFyIGluZGV4ID0gd29yZGxpc3QuaW5kZXhPZih3b3JkLnRvU3RyaW5nKCd1dGY4JykpXG4gICAgaWYgKGluZGV4ID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfTU5FTU9OSUMpXG5cbiAgICByZXR1cm4gbHBhZChpbmRleC50b1N0cmluZygyKSwgJzAnLCAxMSlcbiAgfSkuam9pbignJylcblxuICAvLyBzcGxpdCB0aGUgYmluYXJ5IHN0cmluZyBpbnRvIEVOVC9DU1xuICB2YXIgZGl2aWRlckluZGV4ID0gTWF0aC5mbG9vcihiaXRzLmxlbmd0aCAvIDMzKSAqIDMyXG4gIHZhciBlbnRyb3B5Qml0cyA9IGJpdHMuc2xpY2UoMCwgZGl2aWRlckluZGV4KVxuICB2YXIgY2hlY2tzdW1CaXRzID0gYml0cy5zbGljZShkaXZpZGVySW5kZXgpXG5cbiAgLy8gY2FsY3VsYXRlIHRoZSBjaGVja3N1bSBhbmQgY29tcGFyZVxuICB2YXIgZW50cm9weUJ5dGVzID0gZW50cm9weUJpdHMubWF0Y2goLyguezEsOH0pL2cpLm1hcChiaW5hcnlUb0J5dGUpXG4gIGlmIChlbnRyb3B5Qnl0ZXMubGVuZ3RoIDwgMTYpIHRocm93IG5ldyBFcnJvcihJTlZBTElEX0VOVFJPUFkpXG4gIGlmIChlbnRyb3B5Qnl0ZXMubGVuZ3RoID4gMzIpIHRocm93IG5ldyBFcnJvcihJTlZBTElEX0VOVFJPUFkpXG4gIGlmIChlbnRyb3B5Qnl0ZXMubGVuZ3RoICUgNCAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfRU5UUk9QWSlcblxuICB2YXIgZW50cm9weSA9IEJ1ZmZlci5mcm9tKGVudHJvcHlCeXRlcylcbiAgdmFyIG5ld0NoZWNrc3VtID0gZGVyaXZlQ2hlY2tzdW1CaXRzKGVudHJvcHkpXG4gIGlmIChuZXdDaGVja3N1bSAhPT0gY2hlY2tzdW1CaXRzKSB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9DSEVDS1NVTSlcblxuICByZXR1cm4gZW50cm9weS50b1N0cmluZygnaGV4Jylcbn1cblxuZnVuY3Rpb24gZW50cm9weVRvTW5lbW9uaWMgKGVudHJvcHksIHdvcmRsaXN0KSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGVudHJvcHkpKSBlbnRyb3B5ID0gQnVmZmVyLmZyb20oZW50cm9weSwgJ2hleCcpXG4gIHdvcmRsaXN0ID0gd29yZGxpc3QgfHwgREVGQVVMVF9XT1JETElTVFxuXG4gIC8vIDEyOCA8PSBFTlQgPD0gMjU2XG4gIGlmIChlbnRyb3B5Lmxlbmd0aCA8IDE2KSB0aHJvdyBuZXcgVHlwZUVycm9yKElOVkFMSURfRU5UUk9QWSlcbiAgaWYgKGVudHJvcHkubGVuZ3RoID4gMzIpIHRocm93IG5ldyBUeXBlRXJyb3IoSU5WQUxJRF9FTlRST1BZKVxuICBpZiAoZW50cm9weS5sZW5ndGggJSA0ICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKElOVkFMSURfRU5UUk9QWSlcblxuICB2YXIgZW50cm9weUJpdHMgPSBieXRlc1RvQmluYXJ5KFtdLnNsaWNlLmNhbGwoZW50cm9weSkpXG4gIHZhciBjaGVja3N1bUJpdHMgPSBkZXJpdmVDaGVja3N1bUJpdHMoZW50cm9weSlcblxuICB2YXIgYml0cyA9IGVudHJvcHlCaXRzICsgY2hlY2tzdW1CaXRzXG4gIHZhciBjaHVua3MgPSBiaXRzLm1hdGNoKC8oLnsxLDExfSkvZylcbiAgdmFyIHdvcmRzQXNCdWZmZXJzID0gY2h1bmtzLm1hcChmdW5jdGlvbiAoYmluYXJ5KSB7XG4gICAgdmFyIGluZGV4ID0gYmluYXJ5VG9CeXRlKGJpbmFyeSlcbiAgICByZXR1cm4gQnVmZmVyLmZyb20od29yZGxpc3RbaW5kZXhdLCAndXRmOCcpXG4gIH0pXG5cbiAgdmFyIGJ1ZmZlclNpemUgPSB3b3Jkc0FzQnVmZmVycy5yZWR1Y2UoZnVuY3Rpb24gKGJ1ZmZlclNpemUsIHdvcmRBc0J1ZmZlciwgaSkge1xuICAgIHZhciBzaG91bGRBZGRTZXBhcmF0b3IgPSBpIDwgd29yZHNBc0J1ZmZlcnMubGVuZ3RoIC0gMVxuICAgIHJldHVybiAoXG4gICAgICBidWZmZXJTaXplICtcbiAgICAgIHdvcmRBc0J1ZmZlci5sZW5ndGggK1xuICAgICAgKHNob3VsZEFkZFNlcGFyYXRvciA/IDEgOiAwKVxuICAgIClcbiAgfSwgMClcbiAgdmFyIHNlcGFyYXRvciA9IHdvcmRsaXN0ID09PSBKQVBBTkVTRV9XT1JETElTVCA/ICdcXHUzMDAwJyA6ICcgJ1xuICB2YXIgcmVzdWx0ID0gd29yZHNBc0J1ZmZlcnMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIHdvcmRBc0J1ZmZlciwgaSkge1xuICAgIHZhciBzaG91bGRBZGRTZXBhcmF0b3IgPSBpIDwgd29yZHNBc0J1ZmZlcnMubGVuZ3RoIC0gMVxuICAgIHJlc3VsdC53b3JraW5nQnVmZmVyLnNldCh3b3JkQXNCdWZmZXIsIHJlc3VsdC5vZmZzZXQpXG4gICAgaWYgKHNob3VsZEFkZFNlcGFyYXRvcikge1xuICAgICAgcmVzdWx0LndvcmtpbmdCdWZmZXIud3JpdGUoXG4gICAgICAgIHNlcGFyYXRvcixcbiAgICAgICAgcmVzdWx0Lm9mZnNldCArIHdvcmRBc0J1ZmZlci5sZW5ndGgsXG4gICAgICAgIHNlcGFyYXRvci5sZW5ndGgsXG4gICAgICAgICd1dGY4J1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgd29ya2luZ0J1ZmZlcjogcmVzdWx0LndvcmtpbmdCdWZmZXIsXG4gICAgICBvZmZzZXQ6IChcbiAgICAgICAgcmVzdWx0Lm9mZnNldCArXG4gICAgICAgIHdvcmRBc0J1ZmZlci5sZW5ndGggK1xuICAgICAgICAoc2hvdWxkQWRkU2VwYXJhdG9yID8gMSA6IDApXG4gICAgICApXG4gICAgfVxuICB9LCB7IHdvcmtpbmdCdWZmZXI6IEJ1ZmZlci5hbGxvYyhidWZmZXJTaXplKSwgb2Zmc2V0OiAwIH0pXG4gIHJldHVybiByZXN1bHQud29ya2luZ0J1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVNbmVtb25pYyAoc3RyZW5ndGgsIHJuZywgd29yZGxpc3QpIHtcbiAgc3RyZW5ndGggPSBzdHJlbmd0aCB8fCAxMjhcbiAgaWYgKHN0cmVuZ3RoICUgMzIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoSU5WQUxJRF9FTlRST1BZKVxuICBybmcgPSBybmcgfHwgcmFuZG9tQnl0ZXNcblxuICByZXR1cm4gZW50cm9weVRvTW5lbW9uaWMocm5nKHN0cmVuZ3RoIC8gOCksIHdvcmRsaXN0KVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU1uZW1vbmljIChtbmVtb25pYywgd29yZGxpc3QpIHtcbiAgdHJ5IHtcbiAgICBtbmVtb25pY1RvRW50cm9weShtbmVtb25pYywgd29yZGxpc3QpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmxvZygnY291bGQgbm90IHZhbGlkYXRlIG1uZW1vbmljJywgZSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtbmVtb25pY1RvU2VlZDogbW5lbW9uaWNUb1NlZWQsXG4gIG1uZW1vbmljVG9TZWVkSGV4OiBtbmVtb25pY1RvU2VlZEhleCxcbiAgbW5lbW9uaWNUb0VudHJvcHk6IG1uZW1vbmljVG9FbnRyb3B5LFxuICBlbnRyb3B5VG9NbmVtb25pYzogZW50cm9weVRvTW5lbW9uaWMsXG4gIGdlbmVyYXRlTW5lbW9uaWM6IGdlbmVyYXRlTW5lbW9uaWMsXG4gIHZhbGlkYXRlTW5lbW9uaWM6IHZhbGlkYXRlTW5lbW9uaWMsXG4gIHdvcmRsaXN0czoge1xuICAgIEVOOiBFTkdMSVNIX1dPUkRMSVNULFxuICAgIEpBOiBKQVBBTkVTRV9XT1JETElTVCxcblxuICAgIGNoaW5lc2Vfc2ltcGxpZmllZDogQ0hJTkVTRV9TSU1QTElGSUVEX1dPUkRMSVNULFxuICAgIGNoaW5lc2VfdHJhZGl0aW9uYWw6IENISU5FU0VfVFJBRElUSU9OQUxfV09SRExJU1QsXG4gICAgZW5nbGlzaDogRU5HTElTSF9XT1JETElTVCxcbiAgICBmcmVuY2g6IEZSRU5DSF9XT1JETElTVCxcbiAgICBpdGFsaWFuOiBJVEFMSUFOX1dPUkRMSVNULFxuICAgIGphcGFuZXNlOiBKQVBBTkVTRV9XT1JETElTVCxcbiAgICBrb3JlYW46IEtPUkVBTl9XT1JETElTVCxcbiAgICBzcGFuaXNoOiBTUEFOSVNIX1dPUkRMSVNUXG4gIH1cbn1cbiIsImNvbnN0IHsgaGRrZXkgfSA9IHJlcXVpcmUoJ2V0aGVyZXVtanMtd2FsbGV0JylcbmNvbnN0IFNpbXBsZUtleXJpbmcgPSByZXF1aXJlKCdldGgtc2ltcGxlLWtleXJpbmcnKVxuY29uc3QgYmlwMzkgPSByZXF1aXJlKCdiaXAzOScpXG5jb25zdCBzaWdVdGlsID0gcmVxdWlyZSgnZXRoLXNpZy11dGlsJylcblxuLy8gT3B0aW9uczpcbmNvbnN0IGhkUGF0aFN0cmluZyA9IGBtLzQ0Jy82MCcvMCcvMGBcbmNvbnN0IHR5cGUgPSAnSEQgS2V5IFRyZWUnXG5cbmNsYXNzIEhkS2V5cmluZyBleHRlbmRzIFNpbXBsZUtleXJpbmcge1xuXG4gIC8qIFBVQkxJQyBNRVRIT0RTICovXG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy50eXBlID0gdHlwZVxuICAgIHRoaXMuZGVzZXJpYWxpemUob3B0cylcbiAgfVxuXG4gIHNlcmlhbGl6ZSAoKSB7XG4gICAgY29uc3QgbW5lbW9uaWNBc0J1ZmZlciA9IHR5cGVvZiB0aGlzLm1uZW1vbmljID09PSAnc3RyaW5nJ1xuICAgICAgPyBCdWZmZXIuZnJvbSh0aGlzLm1uZW1vbmljLCAndXRmOCcpXG4gICAgICA6IHRoaXMubW5lbW9uaWNcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIG1uZW1vbmljOiBBcnJheS5mcm9tKG1uZW1vbmljQXNCdWZmZXIudmFsdWVzKCkpLFxuICAgICAgbnVtYmVyT2ZBY2NvdW50czogdGhpcy53YWxsZXRzLmxlbmd0aCxcbiAgICAgIGhkUGF0aDogdGhpcy5oZFBhdGgsXG4gICAgfSlcbiAgfVxuXG4gIGRlc2VyaWFsaXplIChvcHRzID0ge30pIHtcbiAgICB0aGlzLm9wdHMgPSBvcHRzIHx8IHt9XG4gICAgdGhpcy53YWxsZXRzID0gW11cbiAgICB0aGlzLm1uZW1vbmljID0gbnVsbFxuICAgIHRoaXMucm9vdCA9IG51bGxcbiAgICB0aGlzLmhkUGF0aCA9IG9wdHMuaGRQYXRoIHx8IGhkUGF0aFN0cmluZ1xuXG4gICAgaWYgKG9wdHMubW5lbW9uaWMpIHtcbiAgICAgIHRoaXMuX2luaXRGcm9tTW5lbW9uaWMob3B0cy5tbmVtb25pYylcbiAgICB9XG5cbiAgICBpZiAob3B0cy5udW1iZXJPZkFjY291bnRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGRBY2NvdW50cyhvcHRzLm51bWJlck9mQWNjb3VudHMpXG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSlcbiAgfVxuXG4gIGFkZEFjY291bnRzIChudW1iZXJPZkFjY291bnRzID0gMSkge1xuICAgIGlmICghdGhpcy5yb290KSB7XG4gICAgICB0aGlzLl9pbml0RnJvbU1uZW1vbmljKGJpcDM5LmdlbmVyYXRlTW5lbW9uaWMoKSlcbiAgICB9XG5cbiAgICBjb25zdCBvbGRMZW4gPSB0aGlzLndhbGxldHMubGVuZ3RoXG4gICAgY29uc3QgbmV3V2FsbGV0cyA9IFtdXG4gICAgZm9yIChsZXQgaSA9IG9sZExlbjsgaSA8IG51bWJlck9mQWNjb3VudHMgKyBvbGRMZW47IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLnJvb3QuZGVyaXZlQ2hpbGQoaSlcbiAgICAgIGNvbnN0IHdhbGxldCA9IGNoaWxkLmdldFdhbGxldCgpXG4gICAgICBuZXdXYWxsZXRzLnB1c2god2FsbGV0KVxuICAgICAgdGhpcy53YWxsZXRzLnB1c2god2FsbGV0KVxuICAgIH1cbiAgICBjb25zdCBoZXhXYWxsZXRzID0gbmV3V2FsbGV0cy5tYXAoKHcpID0+IHtcbiAgICAgIHJldHVybiBzaWdVdGlsLm5vcm1hbGl6ZSh3LmdldEFkZHJlc3MoKS50b1N0cmluZygnaGV4JykpXG4gICAgfSlcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGhleFdhbGxldHMpXG4gIH1cblxuICBnZXRBY2NvdW50cyAoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLndhbGxldHMubWFwKCh3KSA9PiB7XG4gICAgICByZXR1cm4gc2lnVXRpbC5ub3JtYWxpemUody5nZXRBZGRyZXNzKCkudG9TdHJpbmcoJ2hleCcpKVxuICAgIH0pKVxuICB9XG5cbiAgLyogUFJJVkFURSBNRVRIT0RTICovXG5cbiAgLyoqXG4gICAqIFNldHMgYXBwcm9wcmlhdGUgcHJvcGVydGllcyBmb3IgdGhlIGtleXJpbmcgYmFzZWQgb24gdGhlIGdpdmVuXG4gICAqIEJJUDM5LWNvbXBsaWFudCBtbmVtb25pYy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8bnVtYmVyPnxCdWZmZXJ9IG1uZW1vbmljIC0gQSBzZWVkIHBocmFzZSByZXByZXNlbnRlZFxuICAgKiBhcyBhIHN0cmluZywgYW4gYXJyYXkgb2YgVVRGLTggYnl0ZXMsIG9yIGEgQnVmZmVyLlxuICAgKi9cbiAgX2luaXRGcm9tTW5lbW9uaWMobW5lbW9uaWMpIHtcbiAgICBpZiAodHlwZW9mIG1uZW1vbmljID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5tbmVtb25pYyA9IEJ1ZmZlci5mcm9tKG1uZW1vbmljLCAndXRmOCcpXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1uZW1vbmljKSkge1xuICAgICAgdGhpcy5tbmVtb25pYyA9IEJ1ZmZlci5mcm9tKG1uZW1vbmljKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1uZW1vbmljID0gbW5lbW9uaWNcbiAgICB9XG4gICAgY29uc3Qgc2VlZCA9IGJpcDM5Lm1uZW1vbmljVG9TZWVkKHRoaXMubW5lbW9uaWMpXG4gICAgdGhpcy5oZFdhbGxldCA9IGhka2V5LmZyb21NYXN0ZXJTZWVkKHNlZWQpXG4gICAgdGhpcy5yb290ID0gdGhpcy5oZFdhbGxldC5kZXJpdmVQYXRoKHRoaXMuaGRQYXRoKVxuICB9XG59XG5cbkhkS2V5cmluZy50eXBlID0gdHlwZVxubW9kdWxlLmV4cG9ydHMgPSBIZEtleXJpbmdcbiIsImNvbnN0IHsgRXZlbnRFbWl0dGVyIH0gPSByZXF1aXJlKCdldmVudHMnKVxuY29uc3QgV2FsbGV0ID0gcmVxdWlyZSgnZXRoZXJldW1qcy13YWxsZXQnKS5kZWZhdWx0XG5jb25zdCBldGhVdGlsID0gcmVxdWlyZSgnZXRoZXJldW1qcy11dGlsJylcblxuY29uc3QgdHlwZSA9ICdTaW1wbGUgS2V5IFBhaXInXG5jb25zdCBzaWdVdGlsID0gcmVxdWlyZSgnZXRoLXNpZy11dGlsJylcblxuY2xhc3MgU2ltcGxlS2V5cmluZyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy50eXBlID0gdHlwZVxuICAgIHRoaXMud2FsbGV0cyA9IFtdXG4gICAgdGhpcy5kZXNlcmlhbGl6ZShvcHRzKVxuICB9XG5cbiAgc2VyaWFsaXplICgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMud2FsbGV0cy5tYXAoKHcpID0+IHcuZ2V0UHJpdmF0ZUtleSgpLnRvU3RyaW5nKCdoZXgnKSkpXG4gIH1cblxuICBkZXNlcmlhbGl6ZSAocHJpdmF0ZUtleXMgPSBbXSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLndhbGxldHMgPSBwcml2YXRlS2V5cy5tYXAoKHByaXZhdGVLZXkpID0+IHtcbiAgICAgICAgICBjb25zdCBzdHJpcHBlZCA9IGV0aFV0aWwuc3RyaXBIZXhQcmVmaXgocHJpdmF0ZUtleSlcbiAgICAgICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShzdHJpcHBlZCwgJ2hleCcpXG4gICAgICAgICAgY29uc3Qgd2FsbGV0ID0gV2FsbGV0LmZyb21Qcml2YXRlS2V5KGJ1ZmZlcilcbiAgICAgICAgICByZXR1cm4gd2FsbGV0XG4gICAgICAgIH0pXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKVxuICAgICAgfVxuICAgICAgcmVzb2x2ZSgpXG4gICAgfSlcbiAgfVxuXG4gIGFkZEFjY291bnRzIChuID0gMSkge1xuICAgIGNvbnN0IG5ld1dhbGxldHMgPSBbXVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBuZXdXYWxsZXRzLnB1c2goV2FsbGV0LmdlbmVyYXRlKCkpXG4gICAgfVxuICAgIHRoaXMud2FsbGV0cyA9IHRoaXMud2FsbGV0cy5jb25jYXQobmV3V2FsbGV0cylcbiAgICBjb25zdCBoZXhXYWxsZXRzID0gbmV3V2FsbGV0cy5tYXAoKHcpID0+IGV0aFV0aWwuYnVmZmVyVG9IZXgody5nZXRBZGRyZXNzKCkpKVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaGV4V2FsbGV0cylcbiAgfVxuXG4gIGdldEFjY291bnRzICgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMud2FsbGV0cy5tYXAoKHcpID0+IGV0aFV0aWwuYnVmZmVyVG9IZXgody5nZXRBZGRyZXNzKCkpKSlcbiAgfVxuXG4gIC8vIHR4IGlzIGFuIGluc3RhbmNlIG9mIHRoZSBldGhlcmV1bWpzLXRyYW5zYWN0aW9uIGNsYXNzLlxuICBzaWduVHJhbnNhY3Rpb24gKGFkZHJlc3MsIHR4LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBwcml2S2V5ID0gdGhpcy5nZXRQcml2YXRlS2V5Rm9yKGFkZHJlc3MsIG9wdHMpXG4gICAgY29uc3Qgc2lnbmVkVHggPSB0eC5zaWduKHByaXZLZXkpXG4gICAgLy8gTmV3ZXIgdmVyc2lvbnMgb2YgRXRoZXJldW1qcy10eCBhcmUgaW1tdXRhYmxlIGFuZCByZXR1cm4gYSBuZXcgdHggb2JqZWN0XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzaWduZWRUeCA9PT0gdW5kZWZpbmVkID8gdHggOiBzaWduZWRUeClcbiAgfVxuXG4gIC8vIEZvciBldGhfc2lnbiwgd2UgbmVlZCB0byBzaWduIGFyYml0cmFyeSBkYXRhOlxuICBzaWduTWVzc2FnZSAoYWRkcmVzcywgZGF0YSwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGV0aFV0aWwuc3RyaXBIZXhQcmVmaXgoZGF0YSlcbiAgICBjb25zdCBwcml2S2V5ID0gdGhpcy5nZXRQcml2YXRlS2V5Rm9yKGFkZHJlc3MsIG9wdHMpXG4gICAgY29uc3QgbXNnU2lnID0gZXRoVXRpbC5lY3NpZ24oQnVmZmVyLmZyb20obWVzc2FnZSwgJ2hleCcpLCBwcml2S2V5KVxuICAgIGNvbnN0IHJhd01zZ1NpZyA9IHNpZ1V0aWwuY29uY2F0U2lnKG1zZ1NpZy52LCBtc2dTaWcuciwgbXNnU2lnLnMpXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyYXdNc2dTaWcpXG4gIH1cblxuICAvLyBGb3IgZXRoX3NpZ24sIHdlIG5lZWQgdG8gc2lnbiB0cmFuc2FjdGlvbnM6XG4gIG5ld0dldGhTaWduTWVzc2FnZSAod2l0aEFjY291bnQsIG1zZ0hleCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgcHJpdktleSA9IHRoaXMuZ2V0UHJpdmF0ZUtleUZvcih3aXRoQWNjb3VudCwgb3B0cylcbiAgICBjb25zdCBtc2dCdWZmZXIgPSBldGhVdGlsLnRvQnVmZmVyKG1zZ0hleClcbiAgICBjb25zdCBtc2dIYXNoID0gZXRoVXRpbC5oYXNoUGVyc29uYWxNZXNzYWdlKG1zZ0J1ZmZlcilcbiAgICBjb25zdCBtc2dTaWcgPSBldGhVdGlsLmVjc2lnbihtc2dIYXNoLCBwcml2S2V5KVxuICAgIGNvbnN0IHJhd01zZ1NpZyA9IHNpZ1V0aWwuY29uY2F0U2lnKG1zZ1NpZy52LCBtc2dTaWcuciwgbXNnU2lnLnMpXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyYXdNc2dTaWcpXG4gIH1cblxuICAvLyBGb3IgcGVyc29uYWxfc2lnbiwgd2UgbmVlZCB0byBwcmVmaXggdGhlIG1lc3NhZ2U6XG4gIHNpZ25QZXJzb25hbE1lc3NhZ2UgKGFkZHJlc3MsIG1zZ0hleCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgcHJpdktleSA9IHRoaXMuZ2V0UHJpdmF0ZUtleUZvcihhZGRyZXNzLCBvcHRzKVxuICAgIGNvbnN0IHByaXZLZXlCdWZmZXIgPSBCdWZmZXIuZnJvbShwcml2S2V5LCAnaGV4JylcbiAgICBjb25zdCBzaWcgPSBzaWdVdGlsLnBlcnNvbmFsU2lnbihwcml2S2V5QnVmZmVyLCB7IGRhdGE6IG1zZ0hleCB9KVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2lnKVxuICB9XG5cbiAgLy8gRm9yIGV0aF9kZWNyeXB0TWVzc2FnZTpcbiAgZGVjcnlwdE1lc3NhZ2UgKHdpdGhBY2NvdW50LCBlbmNyeXB0ZWREYXRhKSB7XG4gICAgY29uc3Qgd2FsbGV0ID0gdGhpcy5fZ2V0V2FsbGV0Rm9yQWNjb3VudCh3aXRoQWNjb3VudClcbiAgICBjb25zdCBwcml2S2V5ID0gZXRoVXRpbC5zdHJpcEhleFByZWZpeCh3YWxsZXQuZ2V0UHJpdmF0ZUtleSgpKVxuICAgIGNvbnN0IHNpZyA9IHNpZ1V0aWwuZGVjcnlwdChlbmNyeXB0ZWREYXRhLCBwcml2S2V5KVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2lnKVxuICB9XG5cbiAgLy8gcGVyc29uYWxfc2lnblR5cGVkRGF0YSwgc2lnbnMgZGF0YSBhbG9uZyB3aXRoIHRoZSBzY2hlbWFcbiAgc2lnblR5cGVkRGF0YSAod2l0aEFjY291bnQsIHR5cGVkRGF0YSwgb3B0cyA9IHsgdmVyc2lvbjogJ1YxJyB9KSB7XG4gICAgc3dpdGNoIChvcHRzLnZlcnNpb24pIHtcbiAgICAgIGNhc2UgJ1YxJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnblR5cGVkRGF0YV92MSh3aXRoQWNjb3VudCwgdHlwZWREYXRhLCBvcHRzKVxuICAgICAgY2FzZSAnVjMnOlxuICAgICAgICByZXR1cm4gdGhpcy5zaWduVHlwZWREYXRhX3YzKHdpdGhBY2NvdW50LCB0eXBlZERhdGEsIG9wdHMpXG4gICAgICBjYXNlICdWNCc6XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25UeXBlZERhdGFfdjQod2l0aEFjY291bnQsIHR5cGVkRGF0YSwgb3B0cylcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25UeXBlZERhdGFfdjEod2l0aEFjY291bnQsIHR5cGVkRGF0YSwgb3B0cylcbiAgICB9XG4gIH1cblxuICAvLyBwZXJzb25hbF9zaWduVHlwZWREYXRhLCBzaWducyBkYXRhIGFsb25nIHdpdGggdGhlIHNjaGVtYVxuICBzaWduVHlwZWREYXRhX3YxICh3aXRoQWNjb3VudCwgdHlwZWREYXRhLCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBwcml2S2V5ID0gdGhpcy5nZXRQcml2YXRlS2V5Rm9yKHdpdGhBY2NvdW50LCBvcHRzKVxuICAgIGNvbnN0IHNpZyA9IHNpZ1V0aWwuc2lnblR5cGVkRGF0YUxlZ2FjeShwcml2S2V5LCB7IGRhdGE6IHR5cGVkRGF0YSB9KVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2lnKVxuICB9XG5cbiAgLy8gcGVyc29uYWxfc2lnblR5cGVkRGF0YSwgc2lnbnMgZGF0YSBhbG9uZyB3aXRoIHRoZSBzY2hlbWFcbiAgc2lnblR5cGVkRGF0YV92MyAod2l0aEFjY291bnQsIHR5cGVkRGF0YSwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgcHJpdktleSA9IHRoaXMuZ2V0UHJpdmF0ZUtleUZvcih3aXRoQWNjb3VudCwgb3B0cylcbiAgICBjb25zdCBzaWcgPSBzaWdVdGlsLnNpZ25UeXBlZERhdGEocHJpdktleSwgeyBkYXRhOiB0eXBlZERhdGEgfSlcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNpZylcbiAgfVxuXG4gIC8vIHBlcnNvbmFsX3NpZ25UeXBlZERhdGEsIHNpZ25zIGRhdGEgYWxvbmcgd2l0aCB0aGUgc2NoZW1hXG4gIHNpZ25UeXBlZERhdGFfdjQgKHdpdGhBY2NvdW50LCB0eXBlZERhdGEsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHByaXZLZXkgPSB0aGlzLmdldFByaXZhdGVLZXlGb3Iod2l0aEFjY291bnQsIG9wdHMpXG4gICAgY29uc3Qgc2lnID0gc2lnVXRpbC5zaWduVHlwZWREYXRhX3Y0KHByaXZLZXksIHsgZGF0YTogdHlwZWREYXRhIH0pXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzaWcpXG4gIH1cblxuICAvLyBnZXQgcHVibGljIGtleSBmb3IgbmFjbFxuICBnZXRFbmNyeXB0aW9uUHVibGljS2V5ICh3aXRoQWNjb3VudCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgcHJpdktleSA9IHRoaXMuZ2V0UHJpdmF0ZUtleUZvcih3aXRoQWNjb3VudCwgb3B0cylcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBzaWdVdGlsLmdldEVuY3J5cHRpb25QdWJsaWNLZXkocHJpdktleSlcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHB1YmxpY0tleSlcbiAgfVxuXG4gIGdldFByaXZhdGVLZXlGb3IgKGFkZHJlc3MsIG9wdHMgPSB7fSkge1xuICAgIGlmICghYWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHNwZWNpZnkgYWRkcmVzcy4nKVxuICAgIH1cbiAgICBjb25zdCB3YWxsZXQgPSB0aGlzLl9nZXRXYWxsZXRGb3JBY2NvdW50KGFkZHJlc3MsIG9wdHMpXG4gICAgY29uc3QgcHJpdktleSA9IGV0aFV0aWwudG9CdWZmZXIod2FsbGV0LmdldFByaXZhdGVLZXkoKSlcbiAgICByZXR1cm4gcHJpdktleVxuICB9XG5cbiAgLy8gcmV0dXJucyBhbiBhZGRyZXNzIHNwZWNpZmljIHRvIGFuIGFwcFxuICBnZXRBcHBLZXlBZGRyZXNzIChhZGRyZXNzLCBvcmlnaW4pIHtcbiAgICBpZiAoXG4gICAgICAhb3JpZ2luIHx8XG4gICAgICB0eXBlb2Ygb3JpZ2luICE9PSAnc3RyaW5nJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAnb3JpZ2luJyBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZ2ApXG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB3YWxsZXQgPSB0aGlzLl9nZXRXYWxsZXRGb3JBY2NvdW50KGFkZHJlc3MsIHtcbiAgICAgICAgICB3aXRoQXBwS2V5T3JpZ2luOiBvcmlnaW4sXG4gICAgICAgIH0pXG4gICAgICAgIGNvbnN0IGFwcEtleUFkZHJlc3MgPSBzaWdVdGlsLm5vcm1hbGl6ZSh3YWxsZXQuZ2V0QWRkcmVzcygpLnRvU3RyaW5nKCdoZXgnKSlcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoYXBwS2V5QWRkcmVzcylcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvLyBleHBvcnRBY2NvdW50IHNob3VsZCByZXR1cm4gYSBoZXgtZW5jb2RlZCBwcml2YXRlIGtleTpcbiAgZXhwb3J0QWNjb3VudCAoYWRkcmVzcywgb3B0cyA9IHt9KSB7XG4gICAgY29uc3Qgd2FsbGV0ID0gdGhpcy5fZ2V0V2FsbGV0Rm9yQWNjb3VudChhZGRyZXNzLCBvcHRzKVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUod2FsbGV0LmdldFByaXZhdGVLZXkoKS50b1N0cmluZygnaGV4JykpXG4gIH1cblxuICByZW1vdmVBY2NvdW50IChhZGRyZXNzKSB7XG4gICAgaWYgKCF0aGlzLndhbGxldHMubWFwKCh3KSA9PiBldGhVdGlsLmJ1ZmZlclRvSGV4KHcuZ2V0QWRkcmVzcygpKS50b0xvd2VyQ2FzZSgpKS5pbmNsdWRlcyhhZGRyZXNzLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFkZHJlc3MgJHthZGRyZXNzfSBub3QgZm91bmQgaW4gdGhpcyBrZXlyaW5nYClcbiAgICB9XG4gICAgdGhpcy53YWxsZXRzID0gdGhpcy53YWxsZXRzLmZpbHRlcigodykgPT4gZXRoVXRpbC5idWZmZXJUb0hleCh3LmdldEFkZHJlc3MoKSkudG9Mb3dlckNhc2UoKSAhPT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0V2FsbGV0Rm9yQWNjb3VudCAoYWNjb3VudCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgYWRkcmVzcyA9IHNpZ1V0aWwubm9ybWFsaXplKGFjY291bnQpXG4gICAgbGV0IHdhbGxldCA9IHRoaXMud2FsbGV0cy5maW5kKCh3KSA9PiBldGhVdGlsLmJ1ZmZlclRvSGV4KHcuZ2V0QWRkcmVzcygpKSA9PT0gYWRkcmVzcylcbiAgICBpZiAoIXdhbGxldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaW1wbGUgS2V5cmluZyAtIFVuYWJsZSB0byBmaW5kIG1hdGNoaW5nIGFkZHJlc3MuJylcbiAgICB9XG5cbiAgICBpZiAob3B0cy53aXRoQXBwS2V5T3JpZ2luKSB7XG4gICAgICBjb25zdCBwcml2S2V5ID0gd2FsbGV0LmdldFByaXZhdGVLZXkoKVxuICAgICAgY29uc3QgYXBwS2V5T3JpZ2luQnVmZmVyID0gQnVmZmVyLmZyb20ob3B0cy53aXRoQXBwS2V5T3JpZ2luLCAndXRmOCcpXG4gICAgICBjb25zdCBhcHBLZXlCdWZmZXIgPSBCdWZmZXIuY29uY2F0KFtwcml2S2V5LCBhcHBLZXlPcmlnaW5CdWZmZXJdKVxuICAgICAgY29uc3QgYXBwS2V5UHJpdktleSA9IGV0aFV0aWwua2VjY2FrKGFwcEtleUJ1ZmZlciwgMjU2KVxuICAgICAgd2FsbGV0ID0gV2FsbGV0LmZyb21Qcml2YXRlS2V5KGFwcEtleVByaXZLZXkpXG4gICAgfVxuXG4gICAgcmV0dXJuIHdhbGxldFxuICB9XG5cbn1cblxuU2ltcGxlS2V5cmluZy50eXBlID0gdHlwZVxubW9kdWxlLmV4cG9ydHMgPSBTaW1wbGVLZXlyaW5nXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4vKipcbiAqIENvbnRyb2xsZXIgY2xhc3MgdGhhdCBwcm92aWRlcyBjb25maWd1cmF0aW9uLCBzdGF0ZSBtYW5hZ2VtZW50LCBhbmQgc3Vic2NyaXB0aW9uc1xuICovXG5jbGFzcyBCYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIEJhc2VDb250cm9sbGVyIGluc3RhbmNlLiBCb3RoIGluaXRpYWwgc3RhdGUgYW5kIGluaXRpYWxcbiAgICAgKiBjb25maWd1cmF0aW9uIG9wdGlvbnMgYXJlIG1lcmdlZCB3aXRoIGRlZmF1bHRzIHVwb24gaW5pdGlhbGl6YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30sIHN0YXRlID0ge30pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmF1bHQgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGlzIGNvbnRyb2xsZXJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVmYXVsdENvbmZpZyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCBzdGF0ZSBzZXQgb24gdGhpcyBjb250cm9sbGVyXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyBpZiBsaXN0ZW5lcnMgYXJlIG5vdGlmaWVkIG9mIHN0YXRlIGNoYW5nZXNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhpcyBjb250cm9sbGVyIHVzZWQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnQmFzZUNvbnRyb2xsZXInO1xuICAgICAgICB0aGlzLmludGVybmFsQ29uZmlnID0gdGhpcy5kZWZhdWx0Q29uZmlnO1xuICAgICAgICB0aGlzLmludGVybmFsU3RhdGUgPSB0aGlzLmRlZmF1bHRTdGF0ZTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbExpc3RlbmVycyA9IFtdO1xuICAgICAgICAvLyBVc2UgYXNzaWduIHNpbmNlIGdlbmVyaWNzIGNhbid0IGJlIHNwcmVhZDogaHR0cHM6Ly9naXQuaW8vdnBSaFlcbiAgICAgICAgdGhpcy5pbml0aWFsU3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5pbml0aWFsQ29uZmlnID0gY29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHRoZSBjb250cm9sbGVyLiBUaGlzIHNldHMgZWFjaCBjb25maWcgb3B0aW9uIGFzIGEgbWVtYmVyXG4gICAgICogdmFyaWFibGUgb24gdGhpcyBpbnN0YW5jZSBhbmQgdHJpZ2dlcnMgYW55IGRlZmluZWQgc2V0dGVycy4gVGhpc1xuICAgICAqIGFsc28gc2V0cyBpbml0aWFsIHN0YXRlIGFuZCB0cmlnZ2VycyBhbnkgbGlzdGVuZXJzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhpcyBjb250cm9sbGVyIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxTdGF0ZSA9IHRoaXMuZGVmYXVsdFN0YXRlO1xuICAgICAgICB0aGlzLmludGVybmFsQ29uZmlnID0gdGhpcy5kZWZhdWx0Q29uZmlnO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZSh0aGlzLmluaXRpYWxDb25maWcpO1xuICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLmluaXRpYWxTdGF0ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgY3VycmVudCBjb250cm9sbGVyIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IGNvbmZpZ3VyYXRpb24uXG4gICAgICovXG4gICAgZ2V0IGNvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxDb25maWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBjdXJyZW50IGNvbnRyb2xsZXIgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBzdGF0ZS5cbiAgICAgKi9cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsU3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY29udHJvbGxlciBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIE5ldyBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG92ZXJ3cml0ZSAtIE92ZXJ3cml0ZSBjb25maWcgaW5zdGVhZCBvZiBtZXJnaW5nLlxuICAgICAqIEBwYXJhbSBmdWxsVXBkYXRlIC0gQm9vbGVhbiB0aGF0IGRlZmluZXMgaWYgdGhlIHVwZGF0ZSBpcyBwYXJ0aWFsIG9yIG5vdC5cbiAgICAgKi9cbiAgICBjb25maWd1cmUoY29uZmlnLCBvdmVyd3JpdGUgPSBmYWxzZSwgZnVsbFVwZGF0ZSA9IHRydWUpIHtcbiAgICAgICAgaWYgKGZ1bGxVcGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxDb25maWcgPSBvdmVyd3JpdGVcbiAgICAgICAgICAgICAgICA/IGNvbmZpZ1xuICAgICAgICAgICAgICAgIDogT2JqZWN0LmFzc2lnbih0aGlzLmludGVybmFsQ29uZmlnLCBjb25maWcpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5pbnRlcm5hbENvbmZpZykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5pbnRlcm5hbENvbmZpZ1trZXldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSB0aGlzLmludGVybmFsQ29uZmlnW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuaW50ZXJuYWxDb25maWdba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcm5hbENvbmZpZ1trZXldID0gY29uZmlnW2tleV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IGNvbmZpZ1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3RpZmllcyBhbGwgc3Vic2NyaWJlZCBsaXN0ZW5lcnMgb2YgY3VycmVudCBzdGF0ZS5cbiAgICAgKi9cbiAgICBub3RpZnkoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnRlcm5hbExpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXIodGhpcy5pbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgbmV3IGxpc3RlbmVyIHRvIGJlIG5vdGlmaWVkIG9mIHN0YXRlIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBUaGUgY2FsbGJhY2sgdHJpZ2dlcmVkIHdoZW4gc3RhdGUgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBleGlzdGluZyBsaXN0ZW5lciBmcm9tIHJlY2VpdmluZyBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIC0gVGhlIGNhbGxiYWNrIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYSBsaXN0ZW5lciBpcyBmb3VuZCBhbmQgdW5zdWJzY3JpYmVkLlxuICAgICAqL1xuICAgIHVuc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbnRlcm5hbExpc3RlbmVycy5maW5kSW5kZXgoKGNiKSA9PiBsaXN0ZW5lciA9PT0gY2IpO1xuICAgICAgICBpbmRleCA+IC0xICYmIHRoaXMuaW50ZXJuYWxMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID4gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY29udHJvbGxlciBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIFRoZSBuZXcgc3RhdGUuXG4gICAgICogQHBhcmFtIG92ZXJ3cml0ZSAtIE92ZXJ3cml0ZSBzdGF0ZSBpbnN0ZWFkIG9mIG1lcmdpbmcuXG4gICAgICovXG4gICAgdXBkYXRlKHN0YXRlLCBvdmVyd3JpdGUgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmludGVybmFsU3RhdGUgPSBvdmVyd3JpdGVcbiAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpXG4gICAgICAgICAgICA6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaW50ZXJuYWxTdGF0ZSwgc3RhdGUpO1xuICAgICAgICB0aGlzLm5vdGlmeSgpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUNvbnRyb2xsZXIgPSBCYXNlQ29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IEJhc2VDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZUNvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbnRyb2xsZXJNZXNzZW5nZXIgPSBleHBvcnRzLlJlc3RyaWN0ZWRDb250cm9sbGVyTWVzc2VuZ2VyID0gdm9pZCAwO1xuLyoqXG4gKiBBIHJlc3RyaWN0ZWQgY29udHJvbGxlciBtZXNzZW5nZXIuXG4gKlxuICogVGhpcyBhY3RzIGFzIGEgd3JhcHBlciBhcm91bmQgdGhlIGNvbnRyb2xsZXIgbWVzc2VuZ2VyIGluc3RhbmNlIHRoYXQgcmVzdHJpY3RzIGFjY2VzcyB0byBhY3Rpb25zXG4gKiBhbmQgZXZlbnRzLlxuICpcbiAqIEB0ZW1wbGF0ZSBOIC0gVGhlIG5hbWVzcGFjZSBmb3IgdGhpcyBtZXNzZW5nZXIuIFR5cGljYWxseSB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBjb250cm9sbGVyIG9yXG4gKiBtb2R1bGUgdGhhdCB0aGlzIG1lc3NlbmdlciBoYXMgYmVlbiBjcmVhdGVkIGZvci4gVGhlIGF1dGhvcml0eSB0byBwdWJsaXNoIGV2ZW50cyBhbmQgcmVnaXN0ZXJcbiAqIGFjdGlvbnMgdW5kZXIgdGhpcyBuYW1lc3BhY2UgaXMgZ3JhbnRlZCB0byB0aGlzIHJlc3RyaWN0ZWQgbWVzc2VuZ2VyIGluc3RhbmNlLlxuICogQHRlbXBsYXRlIEFjdGlvbiAtIEEgdHlwZSB1bmlvbiBvZiBhbGwgQWN0aW9uIHR5cGVzLlxuICogQHRlbXBsYXRlIEV2ZW50IC0gQSB0eXBlIHVuaW9uIG9mIGFsbCBFdmVudCB0eXBlcy5cbiAqIEB0ZW1wbGF0ZSBBbGxvd2VkQWN0aW9uIC0gQSB0eXBlIHVuaW9uIG9mIHRoZSAndHlwZScgc3RyaW5nIGZvciBhbnkgYWxsb3dlZCBhY3Rpb25zLlxuICogQHRlbXBsYXRlIEFsbG93ZWRFdmVudCAtIEEgdHlwZSB1bmlvbiBvZiB0aGUgJ3R5cGUnIHN0cmluZyBmb3IgYW55IGFsbG93ZWQgZXZlbnRzLlxuICovXG5jbGFzcyBSZXN0cmljdGVkQ29udHJvbGxlck1lc3NlbmdlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIHJlc3RyaWN0ZWQgY29udHJvbGxlciBtZXNzZW5nZXJcbiAgICAgKlxuICAgICAqIFRoZSBwcm92aWRlZCBhbGxvd2xpc3RzIGdyYW50IHRoZSBhYmlsaXR5IHRvIGNhbGwgdGhlIGxpc3RlZCBhY3Rpb25zIGFuZCBzdWJzY3JpYmUgdG8gdGhlXG4gICAgICogbGlzdGVkIGV2ZW50cy4gVGhlIFwibmFtZVwiIHByb3ZpZGVkIGdyYW50cyBvd25lcnNoaXAgb2YgYW55IGFjdGlvbnMgYW5kIGV2ZW50cyB1bmRlciB0aGF0XG4gICAgICogbmFtZXNwYWNlLiBPd25lcnNoaXAgYWxsb3dzIHJlZ2lzdGVyaW5nIGFjdGlvbnMgYW5kIHB1Ymxpc2hpbmcgZXZlbnRzLCBhcyB3ZWxsIGFzXG4gICAgICogdW5yZWdpc3RlcmluZyBhY3Rpb25zIGFuZCBjbGVhcmluZyBldmVudCBzdWJzY3JpcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgY29udHJvbGxlciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvbnRyb2xsZXJNZXNzZW5nZXIgLSBUaGUgY29udHJvbGxlciBtZXNzZW5nZXIgaW5zdGFuY2UgdGhhdCBpcyBiZWluZyB3cmFwcGVkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdGhpbmcgdGhpcyBtZXNzZW5nZXIgd2lsbCBiZSBoYW5kZWQgdG8gKGUuZy4gdGhlXG4gICAgICogY29udHJvbGxlciBuYW1lKS4gVGhpcyBncmFudHMgXCJvd25lcnNoaXBcIiBvZiBhY3Rpb25zIGFuZCBldmVudHMgdW5kZXIgdGhpcyBuYW1lc3BhY2UgdG8gdGhlXG4gICAgICogcmVzdHJpY3RlZCBjb250cm9sbGVyIG1lc3NlbmdlciByZXR1cm5lZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hbGxvd2VkQWN0aW9ucyAtIFRoZSBsaXN0IG9mIGFjdGlvbnMgdGhhdCB0aGlzIHJlc3RyaWN0ZWQgY29udHJvbGxlciBtZXNzZW5nZXJcbiAgICAgKiBzaG91bGQgYmUgYWxvd2VkIHRvIGNhbGwuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYWxsb3dlZEV2ZW50cyAtIFRoZSBsaXN0IG9mIGV2ZW50cyB0aGF0IHRoaXMgcmVzdHJpY3RlZCBjb250cm9sbGVyIG1lc3NlbmdlclxuICAgICAqIHNob3VsZCBiZSBhbGxvd2VkIHRvIHN1YnNjcmliZSB0by5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGNvbnRyb2xsZXJNZXNzZW5nZXIsIG5hbWUsIGFsbG93ZWRBY3Rpb25zLCBhbGxvd2VkRXZlbnRzLCB9KSB7XG4gICAgICAgIHRoaXMuY29udHJvbGxlck1lc3NlbmdlciA9IGNvbnRyb2xsZXJNZXNzZW5nZXI7XG4gICAgICAgIHRoaXMuY29udHJvbGxlck5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmFsbG93ZWRBY3Rpb25zID0gYWxsb3dlZEFjdGlvbnMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5hbGxvd2VkRXZlbnRzID0gYWxsb3dlZEV2ZW50cyB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhbiBhY3Rpb24gaGFuZGxlci5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBtYWtlIHRoZSByZWdpc3RlcmVkIGZ1bmN0aW9uIGF2YWlsYWJsZSB0byBjYWxsIHZpYSB0aGUgYGNhbGxgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIFRoZSBhY3Rpb24gdHlwZSB0aGlzIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCB1bmRlciAqbXVzdCogYmUgaW4gdGhlIGN1cnJlbnQgbmFtZXNwYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFjdGlvbiAtIFRoZSBhY3Rpb24gdHlwZS4gVGhpcyBpcyBhIHVucWl1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGFjdGlvbi5cbiAgICAgKiBAcGFyYW0gaGFuZGxlciAtIFRoZSBhY3Rpb24gaGFuZGxlci4gVGhpcyBmdW5jdGlvbiBnZXRzIGNhbGxlZCB3aGVuIHRoZSBgY2FsbGAgbWV0aG9kIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRoZSBnaXZlbiBhY3Rpb24gdHlwZS5cbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgd2hlbiBhIGhhbmRsZXIgaGFzIGJlZW4gcmVnaXN0ZXJlZCBmb3IgdGhpcyBhY3Rpb24gdHlwZSBhbHJlYWR5LlxuICAgICAqIEB0ZW1wbGF0ZSBUIC0gQSB0eXBlIHVuaW9uIG9mIEFjdGlvbiB0eXBlIHN0cmluZ3MgdGhhdCBhcmUgbmFtZXNwYWNlZCBieSBOLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyQWN0aW9uSGFuZGxlcihhY3Rpb24sIGhhbmRsZXIpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovIC8vIEJyYW5jaCB1bnJlYWNoYWJsZSB3aXRoIHZhbGlkIHR5cGVzXG4gICAgICAgIGlmICghYWN0aW9uLnN0YXJ0c1dpdGgoYCR7dGhpcy5jb250cm9sbGVyTmFtZX06YCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT25seSBhbGxvd2VkIHJlZ2lzdGVyaW5nIGFjdGlvbiBoYW5kbGVycyBwcmVmaXhlZCBieSAnJHt0aGlzLmNvbnRyb2xsZXJOYW1lfTonYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihhY3Rpb24sIGhhbmRsZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnJlZ2lzdGVyIGFuIGFjdGlvbiBoYW5kbGVyLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIHByZXZlbnQgdGhpcyBhY3Rpb24gZnJvbSBiZWluZyBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBUaGUgYWN0aW9uIHR5cGUgYmVpbmcgdW5yZWdpc3RlcmVkICptdXN0KiBiZSBpbiB0aGUgY3VycmVudCBuYW1lc3BhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWN0aW9uIC0gVGhlIGFjdGlvbiB0eXBlLiBUaGlzIGlzIGEgdW5xaXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgYWN0aW9uLlxuICAgICAqIEB0ZW1wbGF0ZSBUIC0gQSB0eXBlIHVuaW9uIG9mIEFjdGlvbiB0eXBlIHN0cmluZ3MgdGhhdCBhcmUgbmFtZXNwYWNlZCBieSBOLlxuICAgICAqL1xuICAgIHVucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGFjdGlvbikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gLy8gQnJhbmNoIHVucmVhY2hhYmxlIHdpdGggdmFsaWQgdHlwZXNcbiAgICAgICAgaWYgKCFhY3Rpb24uc3RhcnRzV2l0aChgJHt0aGlzLmNvbnRyb2xsZXJOYW1lfTpgKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPbmx5IGFsbG93ZWQgdW5yZWdpc3RlcmluZyBhY3Rpb24gaGFuZGxlcnMgcHJlZml4ZWQgYnkgJyR7dGhpcy5jb250cm9sbGVyTmFtZX06J2ApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci51bnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihhY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIGFuIGFjdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBjYWxsIHRoZSBhY3Rpb24gaGFuZGxlciBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBhY3Rpb24gdHlwZSwgcGFzc2luZ1xuICAgICAqIGFsb25nIGFueSBwYXJhbWV0ZXJzIGdpdmVuLlxuICAgICAqXG4gICAgICogVGhlIGFjdGlvbiB0eXBlIGJlaW5nIGNhbGxlZCBtdXN0IGJlIG9uIHRoZSBhY3Rpb24gYWxsb3dsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFjdGlvbiAtIFRoZSBhY3Rpb24gdHlwZS4gVGhpcyBpcyBhIHVucWl1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGFjdGlvbi5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIGFjdGlvbiBwYXJhbWV0ZXJzLiBUaGVzZSBtdXN0IG1hdGNoIHRoZSB0eXBlIG9mIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZVxuICAgICAqIHJlZ2lzdGVyZWQgYWN0aW9uIGhhbmRsZXIuXG4gICAgICogQHRocm93cyBXaWxsIHRocm93IHdoZW4gbm8gaGFuZGxlciBoYXMgYmVlbiByZWdpc3RlcmVkIGZvciB0aGUgZ2l2ZW4gdHlwZS5cbiAgICAgKiBAdGVtcGxhdGUgVCAtIEEgdHlwZSB1bmlvbiBvZiBhbGxvd2VkIEFjdGlvbiB0eXBlIHN0cmluZ3MuXG4gICAgICogQHJldHVybnMgVGhlIGFjdGlvbiByZXR1cm4gdmFsdWUuXG4gICAgICovXG4gICAgY2FsbChhY3Rpb24sIC4uLnBhcmFtcykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyAvLyBCcmFuY2hlcyB1bnJlYWNoYWJsZSB3aXRoIHZhbGlkIHR5cGVzXG4gICAgICAgIGlmICh0aGlzLmFsbG93ZWRBY3Rpb25zID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjdGlvbnMgYWxsb3dlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmFsbG93ZWRBY3Rpb25zLmluY2x1ZGVzKGFjdGlvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQWN0aW9uIG1pc3NpbmcgZnJvbSBhbGxvdyBsaXN0OiAke2FjdGlvbn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLmNhbGwoYWN0aW9uLCAuLi5wYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaXNoIGFuIGV2ZW50LlxuICAgICAqXG4gICAgICogUHVibGlzaGVzIHRoZSBnaXZlbiBwYXlsb2FkIHRvIGFsbCBzdWJzY3JpYmVycyBvZiB0aGUgZ2l2ZW4gZXZlbnQgdHlwZS5cbiAgICAgKlxuICAgICAqIFRoZSBldmVudCB0eXBlIGJlaW5nIHB1Ymxpc2hlZCAqbXVzdCogYmUgaW4gdGhlIGN1cnJlbnQgbmFtZXNwYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIGV2ZW50IHR5cGUuIFRoaXMgaXMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBldmVudC5cbiAgICAgKiBAcGFyYW0gcGF5bG9hZCAtIFRoZSBldmVudCBwYXlsb2FkLiBUaGUgdHlwZSBvZiB0aGUgcGFyYW1ldGVycyBmb3IgZWFjaCBldmVudCBoYW5kbGVyIG11c3RcbiAgICAgKiBtYXRjaCB0aGUgdHlwZSBvZiB0aGlzIHBheWxvYWQuXG4gICAgICogQHRlbXBsYXRlIEUgLSBBIHR5cGUgdW5pb24gb2YgRXZlbnQgdHlwZSBzdHJpbmdzIHRoYXQgYXJlIG5hbWVzcGFjZWQgYnkgTi5cbiAgICAgKi9cbiAgICBwdWJsaXNoKGV2ZW50LCAuLi5wYXlsb2FkKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyAvLyBCcmFuY2ggdW5yZWFjaGFibGUgd2l0aCB2YWxpZCB0eXBlc1xuICAgICAgICBpZiAoIWV2ZW50LnN0YXJ0c1dpdGgoYCR7dGhpcy5jb250cm9sbGVyTmFtZX06YCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT25seSBhbGxvd2VkIHB1Ymxpc2hpbmcgZXZlbnRzIHByZWZpeGVkIGJ5ICcke3RoaXMuY29udHJvbGxlck5hbWV9OidgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIucHVibGlzaChldmVudCwgLi4ucGF5bG9hZCk7XG4gICAgfVxuICAgIHN1YnNjcmliZShldmVudCwgaGFuZGxlciwgc2VsZWN0b3IpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gLy8gQnJhbmNoZXMgdW5yZWFjaGFibGUgd2l0aCB2YWxpZCB0eXBlc1xuICAgICAgICBpZiAodGhpcy5hbGxvd2VkRXZlbnRzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGV2ZW50cyBhbGxvd2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuYWxsb3dlZEV2ZW50cy5pbmNsdWRlcyhldmVudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXZlbnQgbWlzc2luZyBmcm9tIGFsbG93IGxpc3Q6ICR7ZXZlbnR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLnN1YnNjcmliZShldmVudCwgaGFuZGxlciwgc2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIuc3Vic2NyaWJlKGV2ZW50LCBoYW5kbGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmUgZnJvbSBhbiBldmVudC5cbiAgICAgKlxuICAgICAqIFVucmVnaXN0ZXJzIHRoZSBnaXZlbiBmdW5jdGlvbiBhcyBhbiBldmVudCBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBUaGUgZXZlbnQgdHlwZSBiZWluZyB1bnN1YnNjcmliZWQgdG8gbXVzdCBiZSBvbiB0aGUgZXZlbnQgYWxsb3dsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIGV2ZW50IHR5cGUuIFRoaXMgaXMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBldmVudC5cbiAgICAgKiBAcGFyYW0gaGFuZGxlciAtIFRoZSBldmVudCBoYW5kbGVyIHRvIHVucmVnaXN0ZXIuXG4gICAgICogQHRocm93cyBXaWxsIHRocm93IHdoZW4gdGhlIGdpdmVuIGV2ZW50IGhhbmRsZXIgaXMgbm90IHJlZ2lzdGVyZWQgZm9yIHRoaXMgZXZlbnQuXG4gICAgICogQHRlbXBsYXRlIFQgLSBBIHR5cGUgdW5pb24gb2YgYWxsb3dlZCBFdmVudCB0eXBlIHN0cmluZ3MuXG4gICAgICovXG4gICAgdW5zdWJzY3JpYmUoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gLy8gQnJhbmNoZXMgdW5yZWFjaGFibGUgd2l0aCB2YWxpZCB0eXBlc1xuICAgICAgICBpZiAodGhpcy5hbGxvd2VkRXZlbnRzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGV2ZW50cyBhbGxvd2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuYWxsb3dlZEV2ZW50cy5pbmNsdWRlcyhldmVudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXZlbnQgbWlzc2luZyBmcm9tIGFsbG93IGxpc3Q6ICR7ZXZlbnR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLnVuc3Vic2NyaWJlKGV2ZW50LCBoYW5kbGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXIgc3Vic2NyaXB0aW9ucyBmb3IgYSBzcGVjaWZpYyBldmVudC5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCByZW1vdmUgYWxsIHN1YnNjcmliZWQgaGFuZGxlcnMgZm9yIHRoaXMgZXZlbnQuXG4gICAgICpcbiAgICAgKiBUaGUgZXZlbnQgdHlwZSBiZWluZyBjbGVhcmVkICptdXN0KiBiZSBpbiB0aGUgY3VycmVudCBuYW1lc3BhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgZXZlbnQgdHlwZS4gVGhpcyBpcyBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGV2ZW50LlxuICAgICAqIEB0ZW1wbGF0ZSBFIC0gQSB0eXBlIHVuaW9uIG9mIEV2ZW50IHR5cGUgc3RyaW5ncyB0aGF0IGFyZSBuYW1lc3BhY2VkIGJ5IE4uXG4gICAgICovXG4gICAgY2xlYXJFdmVudFN1YnNjcmlwdGlvbnMoZXZlbnQpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovIC8vIEJyYW5jaCB1bnJlYWNoYWJsZSB3aXRoIHZhbGlkIHR5cGVzXG4gICAgICAgIGlmICghZXZlbnQuc3RhcnRzV2l0aChgJHt0aGlzLmNvbnRyb2xsZXJOYW1lfTpgKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPbmx5IGFsbG93ZWQgY2xlYXJpbmcgZXZlbnRzIHByZWZpeGVkIGJ5ICcke3RoaXMuY29udHJvbGxlck5hbWV9OidgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIuY2xlYXJFdmVudFN1YnNjcmlwdGlvbnMoZXZlbnQpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVzdHJpY3RlZENvbnRyb2xsZXJNZXNzZW5nZXIgPSBSZXN0cmljdGVkQ29udHJvbGxlck1lc3Nlbmdlcjtcbi8qKlxuICogQSBtZXNzYWdpbmcgc3lzdGVtIGZvciBjb250cm9sbGVycy5cbiAqXG4gKiBUaGUgY29udHJvbGxlciBtZXNzZW5nZXIgYWxsb3dzIHJlZ2lzdGVyaW5nIGZ1bmN0aW9ucyBhcyAnYWN0aW9ucycgdGhhdCBjYW4gYmUgY2FsbGVkIGVsc2V3aGVyZSxcbiAqIGFuZCBpdCBhbGxvd3MgcHVibGlzaGluZyBhbmQgc3Vic2NyaWJpbmcgdG8gZXZlbnRzLiBCb3RoIGFjdGlvbnMgYW5kIGV2ZW50cyBhcmUgaWRlbnRpZmllZCBieVxuICogdW5pcXVlIHN0cmluZ3MuXG4gKlxuICogQHRlbXBsYXRlIEFjdGlvbiAtIEEgdHlwZSB1bmlvbiBvZiBhbGwgQWN0aW9uIHR5cGVzLlxuICogQHRlbXBsYXRlIEV2ZW50IC0gQSB0eXBlIHVuaW9uIG9mIGFsbCBFdmVudCB0eXBlcy5cbiAqL1xuY2xhc3MgQ29udHJvbGxlck1lc3NlbmdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNhY2hlIG9mIHNlbGVjdG9yIHJldHVybiB2YWx1ZXMgZm9yIHRoZWlyIHJlc3BlY3RpdmUgaGFuZGxlcnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV2ZW50UGF5bG9hZENhY2hlID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhbiBhY3Rpb24gaGFuZGxlci5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBtYWtlIHRoZSByZWdpc3RlcmVkIGZ1bmN0aW9uIGF2YWlsYWJsZSB0byBjYWxsIHZpYSB0aGUgYGNhbGxgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY3Rpb25UeXBlIC0gVGhlIGFjdGlvbiB0eXBlLiBUaGlzIGlzIGEgdW5xaXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgYWN0aW9uLlxuICAgICAqIEBwYXJhbSBoYW5kbGVyIC0gVGhlIGFjdGlvbiBoYW5kbGVyLiBUaGlzIGZ1bmN0aW9uIGdldHMgY2FsbGVkIHdoZW4gdGhlIGBjYWxsYCBtZXRob2QgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhlIGdpdmVuIGFjdGlvbiB0eXBlLlxuICAgICAqIEB0aHJvd3MgV2lsbCB0aHJvdyB3aGVuIGEgaGFuZGxlciBoYXMgYmVlbiByZWdpc3RlcmVkIGZvciB0aGlzIGFjdGlvbiB0eXBlIGFscmVhZHkuXG4gICAgICogQHRlbXBsYXRlIFQgLSBBIHR5cGUgdW5pb24gb2YgQWN0aW9uIHR5cGUgc3RyaW5ncy5cbiAgICAgKi9cbiAgICByZWdpc3RlckFjdGlvbkhhbmRsZXIoYWN0aW9uVHlwZSwgaGFuZGxlcikge1xuICAgICAgICBpZiAodGhpcy5hY3Rpb25zLmhhcyhhY3Rpb25UeXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIGhhbmRsZXIgZm9yICR7YWN0aW9uVHlwZX0gaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3Rpb25zLnNldChhY3Rpb25UeXBlLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5yZWdpc3RlciBhbiBhY3Rpb24gaGFuZGxlci5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBwcmV2ZW50IHRoaXMgYWN0aW9uIGZyb20gYmVpbmcgY2FsbGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFjdGlvblR5cGUgLSBUaGUgYWN0aW9uIHR5cGUuIFRoaXMgaXMgYSB1bnFpdWUgaWRlbnRpZmllciBmb3IgdGhpcyBhY3Rpb24uXG4gICAgICogQHRlbXBsYXRlIFQgLSBBIHR5cGUgdW5pb24gb2YgQWN0aW9uIHR5cGUgc3RyaW5ncy5cbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihhY3Rpb25UeXBlKSB7XG4gICAgICAgIHRoaXMuYWN0aW9ucy5kZWxldGUoYWN0aW9uVHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucmVnaXN0ZXIgYWxsIGFjdGlvbiBoYW5kbGVycy5cbiAgICAgKlxuICAgICAqIFRoaXMgcHJldmVudHMgYWxsIGFjdGlvbnMgZnJvbSBiZWluZyBjYWxsZWQuXG4gICAgICovXG4gICAgY2xlYXJBY3Rpb25zKCkge1xuICAgICAgICB0aGlzLmFjdGlvbnMuY2xlYXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCBhbiBhY3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgY2FsbCB0aGUgYWN0aW9uIGhhbmRsZXIgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gYWN0aW9uIHR5cGUsIHBhc3NpbmdcbiAgICAgKiBhbG9uZyBhbnkgcGFyYW1ldGVycyBnaXZlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY3Rpb25UeXBlIC0gVGhlIGFjdGlvbiB0eXBlLiBUaGlzIGlzIGEgdW5xaXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgYWN0aW9uLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgYWN0aW9uIHBhcmFtZXRlcnMuIFRoZXNlIG11c3QgbWF0Y2ggdGhlIHR5cGUgb2YgdGhlIHBhcmFtZXRlcnMgb2YgdGhlXG4gICAgICogcmVnaXN0ZXJlZCBhY3Rpb24gaGFuZGxlci5cbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgd2hlbiBubyBoYW5kbGVyIGhhcyBiZWVuIHJlZ2lzdGVyZWQgZm9yIHRoZSBnaXZlbiB0eXBlLlxuICAgICAqIEB0ZW1wbGF0ZSBUIC0gQSB0eXBlIHVuaW9uIG9mIEFjdGlvbiB0eXBlIHN0cmluZ3MuXG4gICAgICogQHJldHVybnMgVGhlIGFjdGlvbiByZXR1cm4gdmFsdWUuXG4gICAgICovXG4gICAgY2FsbChhY3Rpb25UeXBlLCAuLi5wYXJhbXMpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuYWN0aW9ucy5nZXQoYWN0aW9uVHlwZSk7XG4gICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIGhhbmRsZXIgZm9yICR7YWN0aW9uVHlwZX0gaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWRgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlciguLi5wYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaXNoIGFuIGV2ZW50LlxuICAgICAqXG4gICAgICogUHVibGlzaGVzIHRoZSBnaXZlbiBwYXlsb2FkIHRvIGFsbCBzdWJzY3JpYmVycyBvZiB0aGUgZ2l2ZW4gZXZlbnQgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgLSBUaGUgZXZlbnQgdHlwZS4gVGhpcyBpcyBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGV2ZW50LlxuICAgICAqIEBwYXJhbSBwYXlsb2FkIC0gVGhlIGV2ZW50IHBheWxvYWQuIFRoZSB0eXBlIG9mIHRoZSBwYXJhbWV0ZXJzIGZvciBlYWNoIGV2ZW50IGhhbmRsZXIgbXVzdFxuICAgICAqIG1hdGNoIHRoZSB0eXBlIG9mIHRoaXMgcGF5bG9hZC5cbiAgICAgKiBAdGVtcGxhdGUgRSAtIEEgdHlwZSB1bmlvbiBvZiBFdmVudCB0eXBlIHN0cmluZ3MuXG4gICAgICovXG4gICAgcHVibGlzaChldmVudFR5cGUsIC4uLnBheWxvYWQpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlcnMgPSB0aGlzLmV2ZW50cy5nZXQoZXZlbnRUeXBlKTtcbiAgICAgICAgaWYgKHN1YnNjcmliZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtoYW5kbGVyLCBzZWxlY3Rvcl0gb2Ygc3Vic2NyaWJlcnMuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB0aGlzLmV2ZW50UGF5bG9hZENhY2hlLmdldChoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBzZWxlY3RvciguLi5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBwcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50UGF5bG9hZENhY2hlLnNldChoYW5kbGVyLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKG5ld1ZhbHVlLCBwcmV2aW91c1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlciguLi5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Vic2NyaWJlKGV2ZW50VHlwZSwgaGFuZGxlciwgc2VsZWN0b3IpIHtcbiAgICAgICAgbGV0IHN1YnNjcmliZXJzID0gdGhpcy5ldmVudHMuZ2V0KGV2ZW50VHlwZSk7XG4gICAgICAgIGlmICghc3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5ldmVudHMuc2V0KGV2ZW50VHlwZSwgc3Vic2NyaWJlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXJzLnNldChoYW5kbGVyLCBzZWxlY3Rvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlIGZyb20gYW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBVbnJlZ2lzdGVycyB0aGUgZ2l2ZW4gZnVuY3Rpb24gYXMgYW4gZXZlbnQgaGFuZGxlciBmb3IgdGhlIGdpdmVuIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSAtIFRoZSBldmVudCB0eXBlLiBUaGlzIGlzIGEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgZXZlbnQuXG4gICAgICogQHBhcmFtIGhhbmRsZXIgLSBUaGUgZXZlbnQgaGFuZGxlciB0byB1bnJlZ2lzdGVyLlxuICAgICAqIEB0aHJvd3MgV2lsbCB0aHJvdyB3aGVuIHRoZSBnaXZlbiBldmVudCBoYW5kbGVyIGlzIG5vdCByZWdpc3RlcmVkIGZvciB0aGlzIGV2ZW50LlxuICAgICAqIEB0ZW1wbGF0ZSBFIC0gQSB0eXBlIHVuaW9uIG9mIEV2ZW50IHR5cGUgc3RyaW5ncy5cbiAgICAgKi9cbiAgICB1bnN1YnNjcmliZShldmVudFR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlcnMgPSB0aGlzLmV2ZW50cy5nZXQoZXZlbnRUeXBlKTtcbiAgICAgICAgaWYgKCFzdWJzY3JpYmVycyB8fCAhc3Vic2NyaWJlcnMuaGFzKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN1YnNjcmlwdGlvbiBub3QgZm91bmQgZm9yIGV2ZW50OiAke2V2ZW50VHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWxlY3RvciA9IHN1YnNjcmliZXJzLmdldChoYW5kbGVyKTtcbiAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50UGF5bG9hZENhY2hlLmRlbGV0ZShoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmVycy5kZWxldGUoaGFuZGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIHN1YnNjcmlwdGlvbnMgZm9yIGEgc3BlY2lmaWMgZXZlbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgcmVtb3ZlIGFsbCBzdWJzY3JpYmVkIGhhbmRsZXJzIGZvciB0aGlzIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSAtIFRoZSBldmVudCB0eXBlLiBUaGlzIGlzIGEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgZXZlbnQuXG4gICAgICogQHRlbXBsYXRlIEUgLSBBIHR5cGUgdW5pb24gb2YgRXZlbnQgdHlwZSBzdHJpbmdzLlxuICAgICAqL1xuICAgIGNsZWFyRXZlbnRTdWJzY3JpcHRpb25zKGV2ZW50VHlwZSkge1xuICAgICAgICB0aGlzLmV2ZW50cy5kZWxldGUoZXZlbnRUeXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIHN1YnNjcmlwdGlvbnMuXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgcmVtb3ZlIGFsbCBzdWJzY3JpYmVkIGhhbmRsZXJzIGZvciBhbGwgZXZlbnRzLlxuICAgICAqL1xuICAgIGNsZWFyU3Vic2NyaXB0aW9ucygpIHtcbiAgICAgICAgdGhpcy5ldmVudHMuY2xlYXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgcmVzdHJpY3RlZCBjb250cm9sbGVyIG1lc3NlbmdlclxuICAgICAqXG4gICAgICogUmV0dXJucyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBjb250cm9sbGVyIG1lc3NlbmdlciBpbnN0YW5jZSB0aGF0IHJlc3RyaWN0cyBhY2Nlc3MgdG8gYWN0aW9uc1xuICAgICAqIGFuZCBldmVudHMuIFRoZSBwcm92aWRlZCBhbGxvd2xpc3RzIGdyYW50IHRoZSBhYmlsaXR5IHRvIGNhbGwgdGhlIGxpc3RlZCBhY3Rpb25zIGFuZCBzdWJzY3JpYmVcbiAgICAgKiB0byB0aGUgbGlzdGVkIGV2ZW50cy4gVGhlIFwibmFtZVwiIHByb3ZpZGVkIGdyYW50cyBvd25lcnNoaXAgb2YgYW55IGFjdGlvbnMgYW5kIGV2ZW50cyB1bmRlclxuICAgICAqIHRoYXQgbmFtZXNwYWNlLiBPd25lcnNoaXAgYWxsb3dzIHJlZ2lzdGVyaW5nIGFjdGlvbnMgYW5kIHB1Ymxpc2hpbmcgZXZlbnRzLCBhcyB3ZWxsIGFzXG4gICAgICogdW5yZWdpc3RlcmluZyBhY3Rpb25zIGFuZCBjbGVhcmluZyBldmVudCBzdWJzY3JpcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBDb250cm9sbGVyIG1lc3NlbmdlciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdGhpbmcgdGhpcyBtZXNzZW5nZXIgd2lsbCBiZSBoYW5kZWQgdG8gKGUuZy4gdGhlXG4gICAgICogY29udHJvbGxlciBuYW1lKS4gVGhpcyBncmFudHMgXCJvd25lcnNoaXBcIiBvZiBhY3Rpb25zIGFuZCBldmVudHMgdW5kZXIgdGhpcyBuYW1lc3BhY2UgdG8gdGhlXG4gICAgICogcmVzdHJpY3RlZCBjb250cm9sbGVyIG1lc3NlbmdlciByZXR1cm5lZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hbGxvd2VkQWN0aW9ucyAtIFRoZSBsaXN0IG9mIGFjdGlvbnMgdGhhdCB0aGlzIHJlc3RyaWN0ZWQgY29udHJvbGxlciBtZXNzZW5nZXJcbiAgICAgKiBzaG91bGQgYmUgYWxvd2VkIHRvIGNhbGwuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYWxsb3dlZEV2ZW50cyAtIFRoZSBsaXN0IG9mIGV2ZW50cyB0aGF0IHRoaXMgcmVzdHJpY3RlZCBjb250cm9sbGVyIG1lc3NlbmdlclxuICAgICAqIHNob3VsZCBiZSBhbGxvd2VkIHRvIHN1YnNjcmliZSB0by5cbiAgICAgKiBAdGVtcGxhdGUgTiAtIFRoZSBuYW1lc3BhY2UgZm9yIHRoaXMgbWVzc2VuZ2VyLiBUeXBpY2FsbHkgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgY29udHJvbGxlciBvclxuICAgICAqIG1vZHVsZSB0aGF0IHRoaXMgbWVzc2VuZ2VyIGhhcyBiZWVuIGNyZWF0ZWQgZm9yLiBUaGUgYXV0aG9yaXR5IHRvIHB1Ymxpc2ggZXZlbnRzIGFuZCByZWdpc3RlclxuICAgICAqIGFjdGlvbnMgdW5kZXIgdGhpcyBuYW1lc3BhY2UgaXMgZ3JhbnRlZCB0byB0aGlzIHJlc3RyaWN0ZWQgbWVzc2VuZ2VyIGluc3RhbmNlLlxuICAgICAqIEB0ZW1wbGF0ZSBBbGxvd2VkQWN0aW9uIC0gQSB0eXBlIHVuaW9uIG9mIHRoZSAndHlwZScgc3RyaW5nIGZvciBhbnkgYWxsb3dlZCBhY3Rpb25zLlxuICAgICAqIEB0ZW1wbGF0ZSBBbGxvd2VkRXZlbnQgLSBBIHR5cGUgdW5pb24gb2YgdGhlICd0eXBlJyBzdHJpbmcgZm9yIGFueSBhbGxvd2VkIGV2ZW50cy5cbiAgICAgKiBAcmV0dXJucyBUaGUgcmVzdHJpY3RlZCBjb250cm9sbGVyIG1lc3Nlbmdlci5cbiAgICAgKi9cbiAgICBnZXRSZXN0cmljdGVkKHsgbmFtZSwgYWxsb3dlZEFjdGlvbnMsIGFsbG93ZWRFdmVudHMsIH0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXN0cmljdGVkQ29udHJvbGxlck1lc3Nlbmdlcih7XG4gICAgICAgICAgICBjb250cm9sbGVyTWVzc2VuZ2VyOiB0aGlzLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGFsbG93ZWRBY3Rpb25zLFxuICAgICAgICAgICAgYWxsb3dlZEV2ZW50cyxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Db250cm9sbGVyTWVzc2VuZ2VyID0gQ29udHJvbGxlck1lc3Nlbmdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbnRyb2xsZXJNZXNzZW5nZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbXBvc2FibGVDb250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VDb250cm9sbGVyXCIpO1xuLyoqXG4gKiBDb250cm9sbGVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gY29tcG9zZSBtdWx0aXBsZSBjb250cm9sbGVycyB0b2dldGhlclxuICovXG5jbGFzcyBDb21wb3NhYmxlQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBDb21wb3NhYmxlQ29udHJvbGxlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250cm9sbGVycyAtIE1hcCBvZiBuYW1lcyB0byBjb250cm9sbGVyIGluc3RhbmNlcy5cbiAgICAgKiBAcGFyYW0gbWVzc2VuZ2VyIC0gVGhlIGNvbnRyb2xsZXIgbWVzc2FnaW5nIHN5c3RlbSwgdXNlZCBmb3IgY29tbXVuaWNhdGluZyB3aXRoIEJhc2VDb250cm9sbGVyVjIgY29udHJvbGxlcnMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29udHJvbGxlcnMsIG1lc3Nlbmdlcikge1xuICAgICAgICBzdXBlcih1bmRlZmluZWQsIGNvbnRyb2xsZXJzLnJlZHVjZSgoc3RhdGUsIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgICAgIHN0YXRlW2NvbnRyb2xsZXIubmFtZV0gPSBjb250cm9sbGVyLnN0YXRlO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9LCB7fSkpO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXJzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ0NvbXBvc2FibGVDb250cm9sbGVyJztcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIHRoaXMuY29udHJvbGxlcnMgPSBjb250cm9sbGVycztcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0gPSBtZXNzZW5nZXI7XG4gICAgICAgIHRoaXMuY29udHJvbGxlcnMuZm9yRWFjaCgoY29udHJvbGxlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lIH0gPSBjb250cm9sbGVyO1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuc3Vic2NyaWJlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLnN1YnNjcmliZSgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBbbmFtZV06IHN0YXRlIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tZXNzYWdpbmdTeXN0ZW0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5zdWJzY3JpYmUoYCR7bmFtZX06c3RhdGVDaGFuZ2VgLCAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBbbmFtZV06IHN0YXRlIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZXNzYWdpbmcgc3lzdGVtIHJlcXVpcmVkIGlmIGFueSBCYXNlQ29udHJvbGxlclYyIGNvbnRyb2xsZXJzIGFyZSB1c2VkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGbGF0IHN0YXRlIHJlcHJlc2VudGF0aW9uLCBvbmUgdGhhdCBpc24ndCBrZXllZFxuICAgICAqIG9mIGNvbnRyb2xsZXIgbmFtZS4gSW5zdGVhZCwgYWxsIGNoaWxkIGNvbnRyb2xsZXIgc3RhdGUgaXMgbWVyZ2VkXG4gICAgICogdG9nZXRoZXIgaW50byBhIHNpbmdsZSwgZmxhdCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBNZXJnZWQgc3RhdGUgcmVwcmVzZW50YXRpb24gb2YgYWxsIGNoaWxkIGNvbnRyb2xsZXJzLlxuICAgICAqL1xuICAgIGdldCBmbGF0U3RhdGUoKSB7XG4gICAgICAgIGxldCBmbGF0U3RhdGUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIHRoaXMuY29udHJvbGxlcnMpIHtcbiAgICAgICAgICAgIGZsYXRTdGF0ZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmxhdFN0YXRlKSwgY29udHJvbGxlci5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYXRTdGF0ZTtcbiAgICB9XG59XG5leHBvcnRzLkNvbXBvc2FibGVDb250cm9sbGVyID0gQ29tcG9zYWJsZUNvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBDb21wb3NhYmxlQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbXBvc2FibGVDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZGRyZXNzQm9va0NvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IEJhc2VDb250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vQmFzZUNvbnRyb2xsZXJcIik7XG4vKipcbiAqIENvbnRyb2xsZXIgdGhhdCBtYW5hZ2VzIGEgbGlzdCBvZiByZWNpcGllbnQgYWRkcmVzc2VzIGFzc29jaWF0ZWQgd2l0aCBuaWNrbmFtZXNcbiAqL1xuY2xhc3MgQWRkcmVzc0Jvb2tDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBBZGRyZXNzQm9va0NvbnRyb2xsZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBzdGF0ZSkge1xuICAgICAgICBzdXBlcihjb25maWcsIHN0YXRlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhpcyBjb250cm9sbGVyIHVzZWQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnQWRkcmVzc0Jvb2tDb250cm9sbGVyJztcbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7IGFkZHJlc3NCb29rOiB7fSB9O1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBjb250cmFjdCBlbnRyaWVzLlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IGFkZHJlc3NCb29rOiB7fSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgY29udHJhY3QgZW50cnkgYnkgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFpbklkIC0gQ2hhaW4gaWQgaWRlbnRpZmllcyB0aGUgY3VycmVudCBjaGFpbi5cbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIFJlY2lwaWVudCBhZGRyZXNzIHRvIGRlbGV0ZS5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBlbnRyeSB3YXMgZGVsZXRlZC5cbiAgICAgKi9cbiAgICBkZWxldGUoY2hhaW5JZCwgYWRkcmVzcykge1xuICAgICAgICBhZGRyZXNzID0gdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBpZiAoIXV0aWxfMS5pc1ZhbGlkSGV4QWRkcmVzcyhhZGRyZXNzKSB8fFxuICAgICAgICAgICAgIXRoaXMuc3RhdGUuYWRkcmVzc0Jvb2tbY2hhaW5JZF0gfHxcbiAgICAgICAgICAgICF0aGlzLnN0YXRlLmFkZHJlc3NCb29rW2NoYWluSWRdW2FkZHJlc3NdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzc0Jvb2sgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlLmFkZHJlc3NCb29rKTtcbiAgICAgICAgZGVsZXRlIGFkZHJlc3NCb29rW2NoYWluSWRdW2FkZHJlc3NdO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoYWRkcmVzc0Jvb2tbY2hhaW5JZF0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIGFkZHJlc3NCb29rW2NoYWluSWRdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKHsgYWRkcmVzc0Jvb2sgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgb3IgdXBkYXRlIGEgY29udGFjdCBlbnRyeSBieSBhZGRyZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBSZWNpcGllbnQgYWRkcmVzcyB0byBhZGQgb3IgdXBkYXRlLlxuICAgICAqIEBwYXJhbSBuYW1lIC0gTmlja25hbWUgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSBjaGFpbklkIC0gQ2hhaW4gaWQgaWRlbnRpZmllcyB0aGUgY3VycmVudCBjaGFpbi5cbiAgICAgKiBAcGFyYW0gbWVtbyAtIFVzZXIncyBub3RlIGFib3V0IGFkZHJlc3MuXG4gICAgICogQHJldHVybnMgQm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBhZGRyZXNzIHdhcyBzdWNjZXNzZnVsbHkgc2V0LlxuICAgICAqL1xuICAgIHNldChhZGRyZXNzLCBuYW1lLCBjaGFpbklkID0gJzEnLCBtZW1vID0gJycpIHtcbiAgICAgICAgYWRkcmVzcyA9IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgaWYgKCF1dGlsXzEuaXNWYWxpZEhleEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgaXNFbnM6IGZhbHNlLFxuICAgICAgICAgICAgbWVtbyxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVuc05hbWUgPSB1dGlsXzEubm9ybWFsaXplRW5zTmFtZShuYW1lKTtcbiAgICAgICAgaWYgKGVuc05hbWUpIHtcbiAgICAgICAgICAgIGVudHJ5Lm5hbWUgPSBlbnNOYW1lO1xuICAgICAgICAgICAgZW50cnkuaXNFbnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgIGFkZHJlc3NCb29rOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RhdGUuYWRkcmVzc0Jvb2spLCB7IFtjaGFpbklkXTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlLmFkZHJlc3NCb29rW2NoYWluSWRdKSwgeyBbYWRkcmVzc106IGVudHJ5IH0pIH0pLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZXhwb3J0cy5BZGRyZXNzQm9va0NvbnRyb2xsZXIgPSBBZGRyZXNzQm9va0NvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBBZGRyZXNzQm9va0NvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BZGRyZXNzQm9va0NvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByZWZlcmVuY2VzQ29udHJvbGxlciA9IHZvaWQgMDtcbmNvbnN0IEJhc2VDb250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vQmFzZUNvbnRyb2xsZXJcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbi8qKlxuICogQ29udHJvbGxlciB0aGF0IHN0b3JlcyBzaGFyZWQgc2V0dGluZ3MgYW5kIGV4cG9zZXMgY29udmVuaWVuY2UgbWV0aG9kc1xuICovXG5jbGFzcyBQcmVmZXJlbmNlc0NvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlcl8xLkJhc2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgUHJlZmVyZW5jZXNDb250cm9sbGVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIEluaXRpYWwgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICogQHBhcmFtIHN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgc3RhdGUpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzdGF0ZSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ1ByZWZlcmVuY2VzQ29udHJvbGxlcic7XG4gICAgICAgIHRoaXMuZGVmYXVsdFN0YXRlID0ge1xuICAgICAgICAgICAgZmVhdHVyZUZsYWdzOiB7fSxcbiAgICAgICAgICAgIGZyZXF1ZW50UnBjTGlzdDogW10sXG4gICAgICAgICAgICBpZGVudGl0aWVzOiB7fSxcbiAgICAgICAgICAgIGlwZnNHYXRld2F5OiAnaHR0cHM6Ly9pcGZzLmlvL2lwZnMvJyxcbiAgICAgICAgICAgIGxvc3RJZGVudGl0aWVzOiB7fSxcbiAgICAgICAgICAgIHNlbGVjdGVkQWRkcmVzczogJycsXG4gICAgICAgICAgICB1c2VTdGF0aWNUb2tlbkxpc3Q6IGZhbHNlLFxuICAgICAgICAgICAgdXNlQ29sbGVjdGlibGVEZXRlY3Rpb246IGZhbHNlLFxuICAgICAgICAgICAgb3BlblNlYUVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBpZGVudGl0aWVzIHRvIHN0YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3NlcyAtIExpc3Qgb2YgYWRkcmVzc2VzIHRvIHVzZSB0byBnZW5lcmF0ZSBuZXcgaWRlbnRpdGllcy5cbiAgICAgKi9cbiAgICBhZGRJZGVudGl0aWVzKGFkZHJlc3Nlcykge1xuICAgICAgICBjb25zdCB7IGlkZW50aXRpZXMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGFkZHJlc3Nlcy5mb3JFYWNoKChhZGRyZXNzKSA9PiB7XG4gICAgICAgICAgICBhZGRyZXNzID0gdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICAgICAgaWYgKGlkZW50aXRpZXNbYWRkcmVzc10pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpZGVudGl0eUNvdW50ID0gT2JqZWN0LmtleXMoaWRlbnRpdGllcykubGVuZ3RoO1xuICAgICAgICAgICAgaWRlbnRpdGllc1thZGRyZXNzXSA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBgQWNjb3VudCAke2lkZW50aXR5Q291bnQgKyAxfWAsXG4gICAgICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgICAgICBpbXBvcnRUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlKHsgaWRlbnRpdGllczogT2JqZWN0LmFzc2lnbih7fSwgaWRlbnRpdGllcykgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gaWRlbnRpdHkgZnJvbSBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gQWRkcmVzcyBvZiB0aGUgaWRlbnRpdHkgdG8gcmVtb3ZlLlxuICAgICAqL1xuICAgIHJlbW92ZUlkZW50aXR5KGFkZHJlc3MpIHtcbiAgICAgICAgYWRkcmVzcyA9IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgY29uc3QgeyBpZGVudGl0aWVzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBpZiAoIWlkZW50aXRpZXNbYWRkcmVzc10pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgaWRlbnRpdGllc1thZGRyZXNzXTtcbiAgICAgICAgdGhpcy51cGRhdGUoeyBpZGVudGl0aWVzOiBPYmplY3QuYXNzaWduKHt9LCBpZGVudGl0aWVzKSB9KTtcbiAgICAgICAgaWYgKGFkZHJlc3MgPT09IHRoaXMuc3RhdGUuc2VsZWN0ZWRBZGRyZXNzKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IHNlbGVjdGVkQWRkcmVzczogT2JqZWN0LmtleXMoaWRlbnRpdGllcylbMF0gfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzb2NpYXRlcyBhIG5ldyBsYWJlbCB3aXRoIGFuIGlkZW50aXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBBZGRyZXNzIG9mIHRoZSBpZGVudGl0eSB0byBhc3NvY2lhdGUuXG4gICAgICogQHBhcmFtIGxhYmVsIC0gTmV3IGxhYmVsIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBzZXRBY2NvdW50TGFiZWwoYWRkcmVzcywgbGFiZWwpIHtcbiAgICAgICAgYWRkcmVzcyA9IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgY29uc3QgeyBpZGVudGl0aWVzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBpZGVudGl0aWVzW2FkZHJlc3NdID0gaWRlbnRpdGllc1thZGRyZXNzXSB8fCB7fTtcbiAgICAgICAgaWRlbnRpdGllc1thZGRyZXNzXS5uYW1lID0gbGFiZWw7XG4gICAgICAgIHRoaXMudXBkYXRlKHsgaWRlbnRpdGllczogT2JqZWN0LmFzc2lnbih7fSwgaWRlbnRpdGllcykgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIGEgc3BlY2lmaWMgZmVhdHVyZSBmbGFnLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZlYXR1cmUgLSBGZWF0dXJlIHRvIHRvZ2dsZS5cbiAgICAgKiBAcGFyYW0gYWN0aXZhdGVkIC0gVmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIHNldEZlYXR1cmVGbGFnKGZlYXR1cmUsIGFjdGl2YXRlZCkge1xuICAgICAgICBjb25zdCBvbGRGZWF0dXJlRmxhZ3MgPSB0aGlzLnN0YXRlLmZlYXR1cmVGbGFncztcbiAgICAgICAgY29uc3QgZmVhdHVyZUZsYWdzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvbGRGZWF0dXJlRmxhZ3MpLCB7IFtmZWF0dXJlXTogYWN0aXZhdGVkIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IGZlYXR1cmVGbGFnczogT2JqZWN0LmFzc2lnbih7fSwgZmVhdHVyZUZsYWdzKSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3luY2hyb25pemVzIHRoZSBjdXJyZW50IGlkZW50aXR5IGxpc3Qgd2l0aCBuZXcgaWRlbnRpdGllcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzZXMgLSBMaXN0IG9mIGFkZHJlc3NlcyBjb3JyZXNwb25kaW5nIHRvIGlkZW50aXRpZXMgdG8gc3luYy5cbiAgICAgKiBAcmV0dXJucyBOZXdseS1zZWxlY3RlZCBhZGRyZXNzIGFmdGVyIHN5bmNpbmcuXG4gICAgICovXG4gICAgc3luY0lkZW50aXRpZXMoYWRkcmVzc2VzKSB7XG4gICAgICAgIGFkZHJlc3NlcyA9IGFkZHJlc3Nlcy5tYXAoKGFkZHJlc3MpID0+IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKSk7XG4gICAgICAgIGNvbnN0IHsgaWRlbnRpdGllcywgbG9zdElkZW50aXRpZXMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IG5ld2x5TG9zdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGlkZW50aXR5IGluIGlkZW50aXRpZXMpIHtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzZXMuaW5kZXhPZihpZGVudGl0eSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbmV3bHlMb3N0W2lkZW50aXR5XSA9IGlkZW50aXRpZXNbaWRlbnRpdHldO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpZGVudGl0aWVzW2lkZW50aXR5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMobmV3bHlMb3N0KS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXdseUxvc3QpIHtcbiAgICAgICAgICAgICAgICBsb3N0SWRlbnRpdGllc1trZXldID0gbmV3bHlMb3N0W2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgaWRlbnRpdGllczogT2JqZWN0LmFzc2lnbih7fSwgaWRlbnRpdGllcyksXG4gICAgICAgICAgICBsb3N0SWRlbnRpdGllczogT2JqZWN0LmFzc2lnbih7fSwgbG9zdElkZW50aXRpZXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZGRJZGVudGl0aWVzKGFkZHJlc3Nlcyk7XG4gICAgICAgIGlmIChhZGRyZXNzZXMuaW5kZXhPZih0aGlzLnN0YXRlLnNlbGVjdGVkQWRkcmVzcykgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IHNlbGVjdGVkQWRkcmVzczogYWRkcmVzc2VzWzBdIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnNlbGVjdGVkQWRkcmVzcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGFuZCBzdG9yZXMgYSBuZXcgbGlzdCBvZiBzdG9yZWQgaWRlbnRpdGllcyBiYXNlZCBvbiBhZGRyZXNzLiBJZiB0aGUgc2VsZWN0ZWQgYWRkcmVzc1xuICAgICAqIGlzIHVuc2V0LCBvciBpZiBpdCByZWZlcnMgdG8gYW4gaWRlbnRpdHkgdGhhdCB3YXMgcmVtb3ZlZCwgaXQgd2lsbCBiZSBzZXQgdG8gdGhlIGZpcnN0XG4gICAgICogaWRlbnRpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzc2VzIC0gTGlzdCBvZiBhZGRyZXNzZXMgdG8gdXNlIGFzIGEgYmFzaXMgZm9yIGVhY2ggaWRlbnRpdHkuXG4gICAgICovXG4gICAgdXBkYXRlSWRlbnRpdGllcyhhZGRyZXNzZXMpIHtcbiAgICAgICAgYWRkcmVzc2VzID0gYWRkcmVzc2VzLm1hcCgoYWRkcmVzcykgPT4gdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpKTtcbiAgICAgICAgY29uc3Qgb2xkSWRlbnRpdGllcyA9IHRoaXMuc3RhdGUuaWRlbnRpdGllcztcbiAgICAgICAgY29uc3QgaWRlbnRpdGllcyA9IGFkZHJlc3Nlcy5yZWR1Y2UoKGlkcywgYWRkcmVzcywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlkc1thZGRyZXNzXSA9IG9sZElkZW50aXRpZXNbYWRkcmVzc10gfHwge1xuICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgbmFtZTogYEFjY291bnQgJHtpbmRleCArIDF9YCxcbiAgICAgICAgICAgICAgICBpbXBvcnRUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBpZHM7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgbGV0IHsgc2VsZWN0ZWRBZGRyZXNzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGlkZW50aXRpZXMpLmluY2x1ZGVzKHNlbGVjdGVkQWRkcmVzcykpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkQWRkcmVzcyA9IE9iamVjdC5rZXlzKGlkZW50aXRpZXMpWzBdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKHsgaWRlbnRpdGllczogT2JqZWN0LmFzc2lnbih7fSwgaWRlbnRpdGllcyksIHNlbGVjdGVkQWRkcmVzcyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBjdXN0b20gUlBDIFVSTCB0byBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmwgLSBUaGUgY3VzdG9tIFJQQyBVUkwuXG4gICAgICogQHBhcmFtIGNoYWluSWQgLSBUaGUgY2hhaW4gSUQgb2YgdGhlIG5ldHdvcmssIGFzIHBlciBFSVAtMTU1LlxuICAgICAqIEBwYXJhbSB0aWNrZXIgLSBDdXJyZW5jeSB0aWNrZXIuXG4gICAgICogQHBhcmFtIG5pY2tuYW1lIC0gUGVyc29uYWxpemVkIG5ldHdvcmsgbmFtZS5cbiAgICAgKiBAcGFyYW0gcnBjUHJlZnMgLSBQZXJzb25hbGl6ZWQgcHJlZmVyZW5jZXMuXG4gICAgICovXG4gICAgYWRkVG9GcmVxdWVudFJwY0xpc3QodXJsLCBjaGFpbklkLCB0aWNrZXIsIG5pY2tuYW1lLCBycGNQcmVmcykge1xuICAgICAgICBjb25zdCB7IGZyZXF1ZW50UnBjTGlzdCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBmcmVxdWVudFJwY0xpc3QuZmluZEluZGV4KCh7IHJwY1VybCB9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcnBjVXJsID09PSB1cmw7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBmcmVxdWVudFJwY0xpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdGcmVxdWVzdFJwYyA9IHtcbiAgICAgICAgICAgIHJwY1VybDogdXJsLFxuICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgIHRpY2tlcixcbiAgICAgICAgICAgIG5pY2tuYW1lLFxuICAgICAgICAgICAgcnBjUHJlZnMsXG4gICAgICAgIH07XG4gICAgICAgIGZyZXF1ZW50UnBjTGlzdC5wdXNoKG5ld0ZyZXF1ZXN0UnBjKTtcbiAgICAgICAgdGhpcy51cGRhdGUoeyBmcmVxdWVudFJwY0xpc3Q6IFsuLi5mcmVxdWVudFJwY0xpc3RdIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGN1c3RvbSBSUEMgVVJMIGZyb20gc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsIC0gQ3VzdG9tIFJQQyBVUkwuXG4gICAgICovXG4gICAgcmVtb3ZlRnJvbUZyZXF1ZW50UnBjTGlzdCh1cmwpIHtcbiAgICAgICAgY29uc3QgeyBmcmVxdWVudFJwY0xpc3QgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZnJlcXVlbnRScGNMaXN0LmZpbmRJbmRleCgoeyBycGNVcmwgfSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJwY1VybCA9PT0gdXJsO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgZnJlcXVlbnRScGNMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoeyBmcmVxdWVudFJwY0xpc3Q6IFsuLi5mcmVxdWVudFJwY0xpc3RdIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHNlbGVjdGVkIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2VsZWN0ZWRBZGRyZXNzIC0gRXRoZXJldW0gYWRkcmVzcy5cbiAgICAgKi9cbiAgICBzZXRTZWxlY3RlZEFkZHJlc3Moc2VsZWN0ZWRBZGRyZXNzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKHsgc2VsZWN0ZWRBZGRyZXNzOiB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3Moc2VsZWN0ZWRBZGRyZXNzKSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBuZXcgSVBGUyBnYXRld2F5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlwZnNHYXRld2F5IC0gSVBGUyBnYXRld2F5IHN0cmluZy5cbiAgICAgKi9cbiAgICBzZXRJcGZzR2F0ZXdheShpcGZzR2F0ZXdheSkge1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IGlwZnNHYXRld2F5IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgdGhlIHRva2VuIGRldGVjdGlvbiBzZXR0aW5nIHRvIHVzZSBkeW5hbWljIHRva2VuIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlU3RhdGljVG9rZW5MaXN0IC0gQm9vbGVhbiBpbmRpY2F0aW5nIHVzZXIgcHJlZmVyZW5jZSBvbiB0b2tlbiBkZXRlY3Rpb24uXG4gICAgICovXG4gICAgc2V0VXNlU3RhdGljVG9rZW5MaXN0KHVzZVN0YXRpY1Rva2VuTGlzdCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IHVzZVN0YXRpY1Rva2VuTGlzdCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHRoZSBjb2xsZWN0aWJsZSBkZXRlY3Rpb24gc2V0dGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VDb2xsZWN0aWJsZURldGVjdGlvbiAtIEJvb2xlYW4gaW5kaWNhdGluZyB1c2VyIHByZWZlcmVuY2Ugb24gY29sbGVjdGlibGUgZGV0ZWN0aW9uLlxuICAgICAqL1xuICAgIHNldFVzZUNvbGxlY3RpYmxlRGV0ZWN0aW9uKHVzZUNvbGxlY3RpYmxlRGV0ZWN0aW9uKSB7XG4gICAgICAgIGlmICh1c2VDb2xsZWN0aWJsZURldGVjdGlvbiAmJiAhdGhpcy5zdGF0ZS5vcGVuU2VhRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2VDb2xsZWN0aWJsZURldGVjdGlvbiBjYW5ub3QgYmUgZW5hYmxlZCBpZiBvcGVuU2VhRW5hYmxlZCBpcyBmYWxzZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKHsgdXNlQ29sbGVjdGlibGVEZXRlY3Rpb24gfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSB0aGUgb3BlbnNlYSBlbmFibGVkIHNldHRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3BlblNlYUVuYWJsZWQgLSBCb29sZWFuIGluZGljYXRpbmcgdXNlciBwcmVmZXJlbmNlIG9uIHVzaW5nIE9wZW5TZWEncyBBUEkuXG4gICAgICovXG4gICAgc2V0T3BlblNlYUVuYWJsZWQob3BlblNlYUVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoeyBvcGVuU2VhRW5hYmxlZCB9KTtcbiAgICAgICAgaWYgKCFvcGVuU2VhRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoeyB1c2VDb2xsZWN0aWJsZURldGVjdGlvbjogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlByZWZlcmVuY2VzQ29udHJvbGxlciA9IFByZWZlcmVuY2VzQ29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IFByZWZlcmVuY2VzQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVByZWZlcmVuY2VzQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTm90aWZpY2F0aW9uQ29udHJvbGxlciA9IHZvaWQgMDtcbmNvbnN0IEJhc2VDb250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vQmFzZUNvbnRyb2xsZXJcIik7XG5jb25zdCBkZWZhdWx0U3RhdGUgPSB7XG4gICAgbm90aWZpY2F0aW9uczoge30sXG59O1xuLyoqXG4gKiBDb250cm9sbGVyIGZvciBtYW5hZ2luZyBpbi1hcHAgYW5ub3VuY2VtZW50IG5vdGlmaWNhdGlvbnMuXG4gKi9cbmNsYXNzIE5vdGlmaWNhdGlvbkNvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlcl8xLkJhc2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTm90aWZpY2F0aW9uQ29udHJvbGxlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyLlxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc3RhdGUgfHwgZGVmYXVsdFN0YXRlKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIHRoaXMuX2FkZE5vdGlmaWNhdGlvbnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdGhlIG5vdGlmaWNhdGlvbnMgaW4gc3RhdGUgd2l0aCB0aGUgbm90aWZpY2F0aW9ucyBmcm9tIGZpbGVcbiAgICAgKiB0byBjaGVjayBpZiB0aGVyZSBhcmUgYW55IG5ldyBub3RpZmljYXRpb25zL2Fubm91bmNlbWVudHNcbiAgICAgKiBpZiB5ZXMsIHRoZSBuZXcgbm90aWZpY2F0aW9uIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHN0YXRlIHdpdGggYSBmbGFnIGluZGljYXRpbmdcbiAgICAgKiB0aGF0IHRoZSBub3RpZmljYXRpb24gaXMgbm90IHNlZW4gYnkgdGhlIHVzZXIuXG4gICAgICovXG4gICAgX2FkZE5vdGlmaWNhdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IG5ld05vdGlmaWNhdGlvbnMgPSB7fTtcbiAgICAgICAgY29uc3QgeyBhbGxOb3RpZmljYXRpb25zIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhhbGxOb3RpZmljYXRpb25zKS5mb3JFYWNoKChub3RpZmljYXRpb24pID0+IHtcbiAgICAgICAgICAgIG5ld05vdGlmaWNhdGlvbnNbbm90aWZpY2F0aW9uLmlkXSA9IHRoaXMuc3RhdGUubm90aWZpY2F0aW9uc1tub3RpZmljYXRpb24uaWRdXG4gICAgICAgICAgICAgICAgPyB0aGlzLnN0YXRlLm5vdGlmaWNhdGlvbnNbbm90aWZpY2F0aW9uLmlkXVxuICAgICAgICAgICAgICAgIDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBub3RpZmljYXRpb24pLCB7IGlzU2hvd246IGZhbHNlIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGUoeyBub3RpZmljYXRpb25zOiBuZXdOb3RpZmljYXRpb25zIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBzdGF0dXMgb2YgdGhlIHN0YXR1cyBvZiB0aGUgc3BlY2lmaWVkIG5vdGlmaWNhdGlvbnNcbiAgICAgKiBvbmNlIGl0IGlzIHJlYWQgYnkgdGhlIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmlld2VkSWRzIC0gVGhlIG5vdGlmaWNhdGlvbiBJRHMgdG8gbWFyayBhcyB2aWV3ZWQuXG4gICAgICovXG4gICAgdXBkYXRlVmlld2VkKHZpZXdlZElkcykge1xuICAgICAgICBjb25zdCBzdGF0ZU5vdGlmaWNhdGlvbnMgPSB0aGlzLnN0YXRlLm5vdGlmaWNhdGlvbnM7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgT2JqZWN0LmtleXModmlld2VkSWRzKS5tYXAoTnVtYmVyKSkge1xuICAgICAgICAgICAgc3RhdGVOb3RpZmljYXRpb25zW2lkXS5pc1Nob3duID0gdmlld2VkSWRzW2lkXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZSh7IG5vdGlmaWNhdGlvbnM6IHN0YXRlTm90aWZpY2F0aW9ucyB9LCB0cnVlKTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvbkNvbnRyb2xsZXIgPSBOb3RpZmljYXRpb25Db250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tm90aWZpY2F0aW9uQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ub2tlbkRldGVjdGlvbkNvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCBCYXNlQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG5jb25zdCBERUZBVUxUX0lOVEVSVkFMID0gMTgwMDAwO1xuLyoqXG4gKiBDb250cm9sbGVyIHRoYXQgcGFzc2l2ZWx5IHBvbGxzIG9uIGEgc2V0IGludGVydmFsIGZvciBUb2tlbnMgYXV0byBkZXRlY3Rpb25cbiAqL1xuY2xhc3MgVG9rZW5EZXRlY3Rpb25Db250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFRva2VuRGV0ZWN0aW9uQ29udHJvbGxlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGNvbnRyb2xsZXIgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vblRva2Vuc1N0YXRlQ2hhbmdlIC0gQWxsb3dzIHN1YnNjcmliaW5nIHRvIHRva2VucyBjb250cm9sbGVyIHN0YXRlIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMub25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlIC0gQWxsb3dzIHN1YnNjcmliaW5nIHRvIHByZWZlcmVuY2VzIGNvbnRyb2xsZXIgc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vbk5ldHdvcmtTdGF0ZUNoYW5nZSAtIEFsbG93cyBzdWJzY3JpYmluZyB0byBuZXR3b3JrIGNvbnRyb2xsZXIgc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRCYWxhbmNlc0luU2luZ2xlQ2FsbCAtIEdldHMgdGhlIGJhbGFuY2VzIG9mIGEgbGlzdCBvZiB0b2tlbnMgZm9yIHRoZSBnaXZlbiBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFkZFRva2VucyAtIEFkZCBhIGxpc3Qgb2YgdG9rZW5zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldFRva2VuTGlzdFN0YXRlIC0gR2V0cyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgVG9rZW5MaXN0IGNvbnRyb2xsZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2V0VG9rZW5zU3RhdGUgLSBHZXRzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBUb2tlbnMgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBvblRva2Vuc1N0YXRlQ2hhbmdlLCBvblByZWZlcmVuY2VzU3RhdGVDaGFuZ2UsIG9uTmV0d29ya1N0YXRlQ2hhbmdlLCBnZXRCYWxhbmNlc0luU2luZ2xlQ2FsbCwgYWRkVG9rZW5zLCBnZXRUb2tlbkxpc3RTdGF0ZSwgZ2V0VG9rZW5zU3RhdGUsIH0sIGNvbmZpZywgc3RhdGUpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzdGF0ZSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ1Rva2VuRGV0ZWN0aW9uQ29udHJvbGxlcic7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3Mgd2hldGhlciBuZXR3b3JrIGlzIG1haW5uZXQgb3Igbm90LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBXaGV0aGVyIGN1cnJlbnQgbmV0d29yayBpcyBtYWlubmV0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc01haW5uZXQgPSAoKSA9PiB0aGlzLmNvbmZpZy5uZXR3b3JrVHlwZSA9PT0gY29uc3RhbnRzXzEuTUFJTk5FVDtcbiAgICAgICAgdGhpcy5kZWZhdWx0Q29uZmlnID0ge1xuICAgICAgICAgICAgaW50ZXJ2YWw6IERFRkFVTFRfSU5URVJWQUwsXG4gICAgICAgICAgICBuZXR3b3JrVHlwZTogY29uc3RhbnRzXzEuTUFJTk5FVCxcbiAgICAgICAgICAgIHNlbGVjdGVkQWRkcmVzczogJycsXG4gICAgICAgICAgICB0b2tlbnM6IFtdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgdGhpcy5nZXRUb2tlbnNTdGF0ZSA9IGdldFRva2Vuc1N0YXRlO1xuICAgICAgICB0aGlzLmdldFRva2VuTGlzdFN0YXRlID0gZ2V0VG9rZW5MaXN0U3RhdGU7XG4gICAgICAgIHRoaXMuYWRkVG9rZW5zID0gYWRkVG9rZW5zO1xuICAgICAgICBvblRva2Vuc1N0YXRlQ2hhbmdlKCh7IHRva2VucyB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZSh7IHRva2VucyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uUHJlZmVyZW5jZXNTdGF0ZUNoYW5nZSgoeyBzZWxlY3RlZEFkZHJlc3MgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWN0dWFsU2VsZWN0ZWRBZGRyZXNzID0gdGhpcy5jb25maWcuc2VsZWN0ZWRBZGRyZXNzO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkQWRkcmVzcyAhPT0gYWN0dWFsU2VsZWN0ZWRBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmUoeyBzZWxlY3RlZEFkZHJlc3MgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXRlY3RUb2tlbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG9uTmV0d29ya1N0YXRlQ2hhbmdlKCh7IHByb3ZpZGVyIH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJlKHsgbmV0d29ya1R5cGU6IHByb3ZpZGVyLnR5cGUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdldEJhbGFuY2VzSW5TaW5nbGVDYWxsID0gZ2V0QmFsYW5jZXNJblNpbmdsZUNhbGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHBvbGxpbmcgZm9yIHRoZSBjdXJyZW5jeSByYXRlLlxuICAgICAqL1xuICAgIHN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzTWFpbm5ldCgpIHx8IHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnN0YXJ0UG9sbGluZygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcCBwb2xsaW5nIGZvciB0aGUgY3VycmVuY3kgcmF0ZS5cbiAgICAgKi9cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLnN0b3BQb2xsaW5nKCk7XG4gICAgfVxuICAgIHN0b3BQb2xsaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnZhbElkKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGEgbmV3IHBvbGxpbmcgaW50ZXJ2YWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW50ZXJ2YWwgLSBBbiBpbnRlcnZhbCBvbiB3aGljaCB0byBwb2xsLlxuICAgICAqL1xuICAgIHN0YXJ0UG9sbGluZyhpbnRlcnZhbCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaW50ZXJ2YWwgJiYgdGhpcy5jb25maWd1cmUoeyBpbnRlcnZhbCB9LCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5zdG9wUG9sbGluZygpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5kZXRlY3RUb2tlbnMoKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmRldGVjdFRva2VucygpO1xuICAgICAgICAgICAgfSksIHRoaXMuY29uZmlnLmludGVydmFsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGFzc2V0IEVSQzIwIHRva2VuIGF1dG8gZGV0ZWN0aW9uIGZvciBlYWNoIGNvbnRyYWN0IGFkZHJlc3MgaW4gY29udHJhY3QgbWV0YWRhdGEgb24gbWFpbm5ldC5cbiAgICAgKi9cbiAgICBkZXRlY3RUb2tlbnMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy5pc01haW5uZXQoKSB8fCB0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG9rZW5zQWRkcmVzc2VzID0gdGhpcy5jb25maWcudG9rZW5zLm1hcChcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0Ki8gKHRva2VuKSA9PiB0b2tlbi5hZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgY29uc3QgeyB0b2tlbkxpc3QgfSA9IHRoaXMuZ2V0VG9rZW5MaXN0U3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHRva2Vuc1RvRGV0ZWN0ID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFkZHJlc3MgaW4gdG9rZW5MaXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbnNBZGRyZXNzZXMuaW5jbHVkZXMoYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zVG9EZXRlY3QucHVzaChhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzbGljZU9mVG9rZW5zVG9EZXRlY3QgPSBbXTtcbiAgICAgICAgICAgIHNsaWNlT2ZUb2tlbnNUb0RldGVjdFswXSA9IHRva2Vuc1RvRGV0ZWN0LnNsaWNlKDAsIDEwMDApO1xuICAgICAgICAgICAgc2xpY2VPZlRva2Vuc1RvRGV0ZWN0WzFdID0gdG9rZW5zVG9EZXRlY3Quc2xpY2UoMTAwMCwgdG9rZW5zVG9EZXRlY3QubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBjb25zdCB7IHNlbGVjdGVkQWRkcmVzcyB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKCFzZWxlY3RlZEFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRva2Vuc1NsaWNlIG9mIHNsaWNlT2ZUb2tlbnNUb0RldGVjdCkge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbnNTbGljZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFsYW5jZXMgPSB5aWVsZCB0aGlzLmdldEJhbGFuY2VzSW5TaW5nbGVDYWxsKHNlbGVjdGVkQWRkcmVzcywgdG9rZW5zU2xpY2UpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbnNUb0FkZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRva2VuQWRkcmVzcyBpbiBiYWxhbmNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlnbm9yZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBpZ25vcmVkVG9rZW5zIH0gPSB0aGlzLmdldFRva2Vuc1N0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlZFRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmVkID0gaWdub3JlZFRva2Vucy5maW5kKChpZ25vcmVkVG9rZW5BZGRyZXNzKSA9PiBpZ25vcmVkVG9rZW5BZGRyZXNzID09PSB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3ModG9rZW5BZGRyZXNzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXNlSW5zZW5zaXRpdmVUb2tlbktleSA9IE9iamVjdC5rZXlzKHRva2VuTGlzdCkuZmluZCgoaSkgPT4gaS50b0xvd2VyQ2FzZSgpID09PSB0b2tlbkFkZHJlc3MudG9Mb3dlckNhc2UoKSkgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zVG9BZGQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRva2VuQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHM6IHRva2VuTGlzdFtjYXNlSW5zZW5zaXRpdmVUb2tlbktleV0uZGVjaW1hbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbDogdG9rZW5MaXN0W2Nhc2VJbnNlbnNpdGl2ZVRva2VuS2V5XS5zeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2Vuc1RvQWRkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5hZGRUb2tlbnModG9rZW5zVG9BZGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlRva2VuRGV0ZWN0aW9uQ29udHJvbGxlciA9IFRva2VuRGV0ZWN0aW9uQ29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IFRva2VuRGV0ZWN0aW9uQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRva2VuRGV0ZWN0aW9uQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db2xsZWN0aWJsZURldGVjdGlvbkNvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCBCYXNlQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG5jb25zdCBERUZBVUxUX0lOVEVSVkFMID0gMTgwMDAwO1xuLyoqXG4gKiBDb250cm9sbGVyIHRoYXQgcGFzc2l2ZWx5IHBvbGxzIG9uIGEgc2V0IGludGVydmFsIGZvciBDb2xsZWN0aWJsZXMgYXV0byBkZXRlY3Rpb25cbiAqL1xuY2xhc3MgQ29sbGVjdGlibGVEZXRlY3Rpb25Db250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIENvbGxlY3RpYmxlRGV0ZWN0aW9uQ29udHJvbGxlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGNvbnRyb2xsZXIgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vbkNvbGxlY3RpYmxlc1N0YXRlQ2hhbmdlIC0gQWxsb3dzIHN1YnNjcmliaW5nIHRvIGFzc2V0cyBjb250cm9sbGVyIHN0YXRlIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMub25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlIC0gQWxsb3dzIHN1YnNjcmliaW5nIHRvIHByZWZlcmVuY2VzIGNvbnRyb2xsZXIgc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vbk5ldHdvcmtTdGF0ZUNoYW5nZSAtIEFsbG93cyBzdWJzY3JpYmluZyB0byBuZXR3b3JrIGNvbnRyb2xsZXIgc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRPcGVuU2VhQXBpS2V5IC0gR2V0cyB0aGUgT3BlblNlYSBBUEkga2V5LCBpZiBvbmUgaXMgc2V0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFkZENvbGxlY3RpYmxlIC0gQWRkIGEgY29sbGVjdGlibGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2V0Q29sbGVjdGlibGVzU3RhdGUgLSBHZXRzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBBc3NldHMgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBvblByZWZlcmVuY2VzU3RhdGVDaGFuZ2UsIG9uTmV0d29ya1N0YXRlQ2hhbmdlLCBnZXRPcGVuU2VhQXBpS2V5LCBhZGRDb2xsZWN0aWJsZSwgZ2V0Q29sbGVjdGlibGVzU3RhdGUsIH0sIGNvbmZpZywgc3RhdGUpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzdGF0ZSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ0NvbGxlY3RpYmxlRGV0ZWN0aW9uQ29udHJvbGxlcic7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3Mgd2hldGhlciBuZXR3b3JrIGlzIG1haW5uZXQgb3Igbm90LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBXaGV0aGVyIGN1cnJlbnQgbmV0d29yayBpcyBtYWlubmV0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc01haW5uZXQgPSAoKSA9PiB0aGlzLmNvbmZpZy5uZXR3b3JrVHlwZSA9PT0gY29uc3RhbnRzXzEuTUFJTk5FVDtcbiAgICAgICAgdGhpcy5kZWZhdWx0Q29uZmlnID0ge1xuICAgICAgICAgICAgaW50ZXJ2YWw6IERFRkFVTFRfSU5URVJWQUwsXG4gICAgICAgICAgICBuZXR3b3JrVHlwZTogY29uc3RhbnRzXzEuTUFJTk5FVCxcbiAgICAgICAgICAgIGNoYWluSWQ6ICcxJyxcbiAgICAgICAgICAgIHNlbGVjdGVkQWRkcmVzczogJycsXG4gICAgICAgICAgICBkaXNhYmxlZDogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIHRoaXMuZ2V0Q29sbGVjdGlibGVzU3RhdGUgPSBnZXRDb2xsZWN0aWJsZXNTdGF0ZTtcbiAgICAgICAgb25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlKCh7IHNlbGVjdGVkQWRkcmVzcywgdXNlQ29sbGVjdGlibGVEZXRlY3Rpb24gfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBzZWxlY3RlZEFkZHJlc3M6IHByZXZpb3VzbHlTZWxlY3RlZEFkZHJlc3MsIGRpc2FibGVkLCB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRBZGRyZXNzICE9PSBwcmV2aW91c2x5U2VsZWN0ZWRBZGRyZXNzIHx8XG4gICAgICAgICAgICAgICAgIXVzZUNvbGxlY3RpYmxlRGV0ZWN0aW9uICE9PSBkaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJlKHsgc2VsZWN0ZWRBZGRyZXNzLCBkaXNhYmxlZDogIXVzZUNvbGxlY3RpYmxlRGV0ZWN0aW9uIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVzZUNvbGxlY3RpYmxlRGV0ZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodXNlQ29sbGVjdGlibGVEZXRlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgb25OZXR3b3JrU3RhdGVDaGFuZ2UoKHsgcHJvdmlkZXIgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmUoe1xuICAgICAgICAgICAgICAgIG5ldHdvcmtUeXBlOiBwcm92aWRlci50eXBlLFxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IHByb3ZpZGVyLmNoYWluSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZ2V0T3BlblNlYUFwaUtleSA9IGdldE9wZW5TZWFBcGlLZXk7XG4gICAgICAgIHRoaXMuYWRkQ29sbGVjdGlibGUgPSBhZGRDb2xsZWN0aWJsZTtcbiAgICB9XG4gICAgZ2V0T3duZXJDb2xsZWN0aWJsZXNBcGkoYWRkcmVzcywgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBgaHR0cHM6Ly9hcGkub3BlbnNlYS5pby9hcGkvdjEvYXNzZXRzP293bmVyPSR7YWRkcmVzc30mb2Zmc2V0PSR7b2Zmc2V0fSZsaW1pdD01MGA7XG4gICAgfVxuICAgIGdldE93bmVyQ29sbGVjdGlibGVzKGFkZHJlc3MpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICAgICAgbGV0IGNvbGxlY3RpYmxlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3Qgb3BlblNlYUFwaUtleSA9IHRoaXMuZ2V0T3BlblNlYUFwaUtleSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgcGFnaW5nRmluaXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcGkgPSB0aGlzLmdldE93bmVyQ29sbGVjdGlibGVzQXBpKGFkZHJlc3MsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0geWllbGQgdXRpbF8xLnRpbWVvdXRGZXRjaChhcGksIG9wZW5TZWFBcGlLZXkgPyB7IGhlYWRlcnM6IHsgJ1gtQVBJLUtFWSc6IG9wZW5TZWFBcGlLZXkgfSB9IDoge30sIDE1MDAwKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGlibGVzQXJyYXkgPSB5aWVsZCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgICAgICgoX2EgPSBjb2xsZWN0aWJsZXNBcnJheS5hc3NldHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpICE9PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICA/IChjb2xsZWN0aWJsZXMgPSBbLi4uY29sbGVjdGlibGVzLCAuLi5jb2xsZWN0aWJsZXNBcnJheS5hc3NldHNdKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAocGFnaW5nRmluaXNoID0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSA1MDtcbiAgICAgICAgICAgICAgICB9IHdoaWxlICghcGFnaW5nRmluaXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdGlibGVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgcG9sbGluZyBmb3IgdGhlIGN1cnJlbmN5IHJhdGUuXG4gICAgICovXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNNYWlubmV0KCkgfHwgdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIHRoaXMuc3RhcnRQb2xsaW5nKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wIHBvbGxpbmcgZm9yIHRoZSBjdXJyZW5jeSByYXRlLlxuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuc3RvcFBvbGxpbmcoKTtcbiAgICB9XG4gICAgc3RvcFBvbGxpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVydmFsSWQpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgYSBuZXcgcG9sbGluZyBpbnRlcnZhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnRlcnZhbCAtIEFuIGludGVydmFsIG9uIHdoaWNoIHRvIHBvbGwuXG4gICAgICovXG4gICAgc3RhcnRQb2xsaW5nKGludGVydmFsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpbnRlcnZhbCAmJiB0aGlzLmNvbmZpZ3VyZSh7IGludGVydmFsIH0sIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnN0b3BQb2xsaW5nKCk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmRldGVjdENvbGxlY3RpYmxlcygpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZGV0ZWN0Q29sbGVjdGlibGVzKCk7XG4gICAgICAgICAgICB9KSwgdGhpcy5jb25maWcuaW50ZXJ2YWwpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgYXNzZXQgRVJDNzIxIHRva2VuIGF1dG8gZGV0ZWN0aW9uIG9uIG1haW5uZXQuIEFueSBuZXdseSBkZXRlY3RlZCBjb2xsZWN0aWJsZXMgYXJlXG4gICAgICogYWRkZWQuXG4gICAgICovXG4gICAgZGV0ZWN0Q29sbGVjdGlibGVzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNNYWlubmV0KCkgfHwgdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0ZWRBZGRyZXNzLCBjaGFpbklkIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAoIXNlbGVjdGVkQWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcGlDb2xsZWN0aWJsZXMgPSB5aWVsZCB0aGlzLmdldE93bmVyQ29sbGVjdGlibGVzKHNlbGVjdGVkQWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkQ29sbGVjdGlibGVzUHJvbWlzZXMgPSBhcGlDb2xsZWN0aWJsZXMubWFwKChjb2xsZWN0aWJsZSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRva2VuX2lkLCBudW1fc2FsZXMsIGJhY2tncm91bmRfY29sb3IsIGltYWdlX3VybCwgaW1hZ2VfcHJldmlld191cmwsIGltYWdlX3RodW1ibmFpbF91cmwsIGltYWdlX29yaWdpbmFsX3VybCwgYW5pbWF0aW9uX3VybCwgYW5pbWF0aW9uX29yaWdpbmFsX3VybCwgbmFtZSwgZGVzY3JpcHRpb24sIGV4dGVybmFsX2xpbmssIGNyZWF0b3IsIGFzc2V0X2NvbnRyYWN0OiB7IGFkZHJlc3MsIHNjaGVtYV9uYW1lIH0sIGxhc3Rfc2FsZSwgfSA9IGNvbGxlY3RpYmxlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaWdub3JlZDtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBpZ25vcmVkQ29sbGVjdGlibGVzIH0gPSB0aGlzLmdldENvbGxlY3RpYmxlc1N0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmVkQ29sbGVjdGlibGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlZCA9IGlnbm9yZWRDb2xsZWN0aWJsZXMuZmluZCgoYykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjLmFkZHJlc3MgPT09IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnRva2VuSWQgPT09IHRva2VuX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgICAgIGlmICghaWdub3JlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxlY3RpYmxlTWV0YWRhdGEgPSBPYmplY3QuYXNzaWduKHt9LCB7IG5hbWUgfSwgY3JlYXRvciAmJiB7IGNyZWF0b3IgfSwgZGVzY3JpcHRpb24gJiYgeyBkZXNjcmlwdGlvbiB9LCBpbWFnZV91cmwgJiYgeyBpbWFnZTogaW1hZ2VfdXJsIH0sIG51bV9zYWxlcyAmJiB7IG51bWJlck9mU2FsZXM6IG51bV9zYWxlcyB9LCBiYWNrZ3JvdW5kX2NvbG9yICYmIHsgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kX2NvbG9yIH0sIGltYWdlX3ByZXZpZXdfdXJsICYmIHsgaW1hZ2VQcmV2aWV3OiBpbWFnZV9wcmV2aWV3X3VybCB9LCBpbWFnZV90aHVtYm5haWxfdXJsICYmIHsgaW1hZ2VUaHVtYm5haWw6IGltYWdlX3RodW1ibmFpbF91cmwgfSwgaW1hZ2Vfb3JpZ2luYWxfdXJsICYmIHsgaW1hZ2VPcmlnaW5hbDogaW1hZ2Vfb3JpZ2luYWxfdXJsIH0sIGFuaW1hdGlvbl91cmwgJiYgeyBhbmltYXRpb246IGFuaW1hdGlvbl91cmwgfSwgYW5pbWF0aW9uX29yaWdpbmFsX3VybCAmJiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uT3JpZ2luYWw6IGFuaW1hdGlvbl9vcmlnaW5hbF91cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBzY2hlbWFfbmFtZSAmJiB7IHN0YW5kYXJkOiBzY2hlbWFfbmFtZSB9LCBleHRlcm5hbF9saW5rICYmIHsgZXh0ZXJuYWxMaW5rOiBleHRlcm5hbF9saW5rIH0sIGxhc3Rfc2FsZSAmJiB7IGxhc3RTYWxlOiBsYXN0X3NhbGUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmFkZENvbGxlY3RpYmxlKGFkZHJlc3MsIHRva2VuX2lkLCBjb2xsZWN0aWJsZU1ldGFkYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlckFkZHJlc3M6IHNlbGVjdGVkQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBjaGFpbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwoYWRkQ29sbGVjdGlibGVzUHJvbWlzZXMpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkNvbGxlY3RpYmxlRGV0ZWN0aW9uQ29udHJvbGxlciA9IENvbGxlY3RpYmxlRGV0ZWN0aW9uQ29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IENvbGxlY3RpYmxlRGV0ZWN0aW9uQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbGxlY3RpYmxlRGV0ZWN0aW9uQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ub2tlblJhdGVzQ29udHJvbGxlciA9IHZvaWQgMDtcbmNvbnN0IEJhc2VDb250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vQmFzZUNvbnRyb2xsZXJcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbmNvbnN0IGNyeXB0b19jb21wYXJlXzEgPSByZXF1aXJlKFwiLi4vYXBpcy9jcnlwdG8tY29tcGFyZVwiKTtcbmNvbnN0IENvaW5HZWNrb0FwaSA9IHtcbiAgICBCQVNFX1VSTDogJ2h0dHBzOi8vYXBpLmNvaW5nZWNrby5jb20vYXBpL3YzJyxcbiAgICBnZXRUb2tlblByaWNlVVJMKGNoYWluU2x1ZywgcXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuQkFTRV9VUkx9L3NpbXBsZS90b2tlbl9wcmljZS8ke2NoYWluU2x1Z30/JHtxdWVyeX1gO1xuICAgIH0sXG4gICAgZ2V0UGxhdGZvcm1zVVJMKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5CQVNFX1VSTH0vYXNzZXRfcGxhdGZvcm1zYDtcbiAgICB9LFxuICAgIGdldFN1cHBvcnRlZFZzQ3VycmVuY2llcygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuQkFTRV9VUkx9L3NpbXBsZS9zdXBwb3J0ZWRfdnNfY3VycmVuY2llc2A7XG4gICAgfSxcbn07XG4vKipcbiAqIEZpbmRzIHRoZSBjaGFpbiBzbHVnIGluIHRoZSBkYXRhIGFycmF5IGdpdmVuIGEgY2hhaW5JZC5cbiAqXG4gKiBAcGFyYW0gY2hhaW5JZCAtIFRoZSBjdXJyZW50IGNoYWluIElELlxuICogQHBhcmFtIGRhdGEgLSBBIGxpc3QgcGxhdGZvcm1zIHN1cHBvcnRlZCBieSB0aGUgQ29pbkdlY2tvIEFQSS5cbiAqIEByZXR1cm5zIFRoZSBDb2luR2Vja28gc2x1ZyBmb3IgdGhlIGdpdmVuIGNoYWluIElELCBvciBgbnVsbGAgaWYgdGhlIHNsdWcgd2FzIG5vdCBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gZmluZENoYWluU2x1ZyhjaGFpbklkLCBkYXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY2hhaW4gPSAoX2EgPSBkYXRhLmZpbmQoKHsgY2hhaW5faWRlbnRpZmllciB9KSA9PiBjaGFpbl9pZGVudGlmaWVyICE9PSBudWxsICYmIFN0cmluZyhjaGFpbl9pZGVudGlmaWVyKSA9PT0gY2hhaW5JZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG4gICAgcmV0dXJuIChjaGFpbiA9PT0gbnVsbCB8fCBjaGFpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hhaW4uaWQpIHx8IG51bGw7XG59XG4vKipcbiAqIENvbnRyb2xsZXIgdGhhdCBwYXNzaXZlbHkgcG9sbHMgb24gYSBzZXQgaW50ZXJ2YWwgZm9yIHRva2VuLXRvLWZpYXQgZXhjaGFuZ2UgcmF0ZXNcbiAqIGZvciB0b2tlbnMgc3RvcmVkIGluIHRoZSBUb2tlbnNDb250cm9sbGVyXG4gKi9cbmNsYXNzIFRva2VuUmF0ZXNDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFRva2VuUmF0ZXNDb250cm9sbGVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgY29udHJvbGxlciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm9uVG9rZW5zU3RhdGVDaGFuZ2UgLSBBbGxvd3Mgc3Vic2NyaWJpbmcgdG8gdG9rZW4gY29udHJvbGxlciBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm9uQ3VycmVuY3lSYXRlU3RhdGVDaGFuZ2UgLSBBbGxvd3Mgc3Vic2NyaWJpbmcgdG8gY3VycmVuY3kgcmF0ZSBjb250cm9sbGVyIHN0YXRlIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMub25OZXR3b3JrU3RhdGVDaGFuZ2UgLSBBbGxvd3Mgc3Vic2NyaWJpbmcgdG8gbmV0d29yayBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyLlxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IG9uVG9rZW5zU3RhdGVDaGFuZ2UsIG9uQ3VycmVuY3lSYXRlU3RhdGVDaGFuZ2UsIG9uTmV0d29ya1N0YXRlQ2hhbmdlLCB9LCBjb25maWcsIHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc3RhdGUpO1xuICAgICAgICB0aGlzLnRva2VuTGlzdCA9IFtdO1xuICAgICAgICB0aGlzLnN1cHBvcnRlZENoYWlucyA9IHtcbiAgICAgICAgICAgIHRpbWVzdGFtcDogMCxcbiAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3VwcG9ydGVkVnNDdXJyZW5jaWVzID0ge1xuICAgICAgICAgICAgdGltZXN0YW1wOiAwLFxuICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ1Rva2VuUmF0ZXNDb250cm9sbGVyJztcbiAgICAgICAgdGhpcy5kZWZhdWx0Q29uZmlnID0ge1xuICAgICAgICAgICAgZGlzYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICBpbnRlcnZhbDogMyAqIDYwICogMTAwMCxcbiAgICAgICAgICAgIG5hdGl2ZUN1cnJlbmN5OiAnZXRoJyxcbiAgICAgICAgICAgIGNoYWluSWQ6ICcnLFxuICAgICAgICAgICAgdG9rZW5zOiBbXSxcbiAgICAgICAgICAgIHRocmVzaG9sZDogNiAqIDYwICogNjAgKiAxMDAwLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IHtcbiAgICAgICAgICAgIGNvbnRyYWN0RXhjaGFuZ2VSYXRlczoge30sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZSh7IGRpc2FibGVkOiBmYWxzZSB9LCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICBvblRva2Vuc1N0YXRlQ2hhbmdlKCh0b2tlbnNTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmUoeyB0b2tlbnM6IHRva2Vuc1N0YXRlLnRva2VucyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uQ3VycmVuY3lSYXRlU3RhdGVDaGFuZ2UoKGN1cnJlbmN5UmF0ZVN0YXRlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZSh7IG5hdGl2ZUN1cnJlbmN5OiBjdXJyZW5jeVJhdGVTdGF0ZS5uYXRpdmVDdXJyZW5jeSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uTmV0d29ya1N0YXRlQ2hhbmdlKCh7IHByb3ZpZGVyIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhaW5JZCB9ID0gcHJvdmlkZXI7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IGNvbnRyYWN0RXhjaGFuZ2VSYXRlczoge30gfSk7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZSh7IGNoYWluSWQgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG5ldyBwb2xsaW5nIGludGVydmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGludGVydmFsIC0gUG9sbGluZyBpbnRlcnZhbCB1c2VkIHRvIGZldGNoIG5ldyB0b2tlbiByYXRlcy5cbiAgICAgKi9cbiAgICBwb2xsKGludGVydmFsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpbnRlcnZhbCAmJiB0aGlzLmNvbmZpZ3VyZSh7IGludGVydmFsIH0sIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZSAmJiBjbGVhclRpbWVvdXQodGhpcy5oYW5kbGUpO1xuICAgICAgICAgICAgeWllbGQgdXRpbF8xLnNhZmVseUV4ZWN1dGUoKCkgPT4gdGhpcy51cGRhdGVFeGNoYW5nZVJhdGVzKCkpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvbGwodGhpcy5jb25maWcuaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfSwgdGhpcy5jb25maWcuaW50ZXJ2YWwpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG5ldyBjaGFpbklkLlxuICAgICAqXG4gICAgICogVE9ETzogUmVwbGFjZSB0aGlzIHdpdGggYSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gX2NoYWluSWQgLSBUaGUgY3VycmVudCBjaGFpbiBJRC5cbiAgICAgKi9cbiAgICBzZXQgY2hhaW5JZChfY2hhaW5JZCkge1xuICAgICAgICAhdGhpcy5kaXNhYmxlZCAmJiB1dGlsXzEuc2FmZWx5RXhlY3V0ZSgoKSA9PiB0aGlzLnVwZGF0ZUV4Y2hhbmdlUmF0ZXMoKSk7XG4gICAgfVxuICAgIGdldCBjaGFpbklkKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IG9ubHkgdXNlZCBmb3Igc2V0dGluZycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbmV3IHRva2VuIGxpc3QgdG8gdHJhY2sgcHJpY2VzLlxuICAgICAqXG4gICAgICogVE9ETzogUmVwbGFjZSB0aGlzIHdpdGggYSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9rZW5zIC0gTGlzdCBvZiB0b2tlbnMgdG8gdHJhY2sgZXhjaGFuZ2UgcmF0ZXMgZm9yLlxuICAgICAqL1xuICAgIHNldCB0b2tlbnModG9rZW5zKSB7XG4gICAgICAgIHRoaXMudG9rZW5MaXN0ID0gdG9rZW5zO1xuICAgICAgICAhdGhpcy5kaXNhYmxlZCAmJiB1dGlsXzEuc2FmZWx5RXhlY3V0ZSgoKSA9PiB0aGlzLnVwZGF0ZUV4Y2hhbmdlUmF0ZXMoKSk7XG4gICAgfVxuICAgIGdldCB0b2tlbnMoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgb25seSB1c2VkIGZvciBzZXR0aW5nJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBwYWlycyBvZiB0b2tlbiBhZGRyZXNzIGFuZCBuYXRpdmUgY3VycmVuY3kuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhaW5TbHVnIC0gQ2hhaW4gc3RyaW5nIGlkZW50aWZpZXIuXG4gICAgICogQHBhcmFtIHZzQ3VycmVuY3kgLSBRdWVyeSBhY2NvcmRpbmcgdG8gdG9rZW5zIGluIHRva2VuTGlzdCBhbmQgbmF0aXZlIGN1cnJlbmN5LlxuICAgICAqIEByZXR1cm5zIFRoZSBleGNoYW5nZSByYXRlcyBmb3IgdGhlIGdpdmVuIHBhaXJzLlxuICAgICAqL1xuICAgIGZldGNoRXhjaGFuZ2VSYXRlKGNoYWluU2x1ZywgdnNDdXJyZW5jeSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5QYWlycyA9IHRoaXMudG9rZW5MaXN0Lm1hcCgodG9rZW4pID0+IHRva2VuLmFkZHJlc3MpLmpvaW4oJywnKTtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5ID0gYGNvbnRyYWN0X2FkZHJlc3Nlcz0ke3Rva2VuUGFpcnN9JnZzX2N1cnJlbmNpZXM9JHt2c0N1cnJlbmN5LnRvTG93ZXJDYXNlKCl9YDtcbiAgICAgICAgICAgIHJldHVybiB1dGlsXzEuaGFuZGxlRmV0Y2goQ29pbkdlY2tvQXBpLmdldFRva2VuUHJpY2VVUkwoY2hhaW5TbHVnLCBxdWVyeSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IG5hdGl2ZSBjdXJyZW5jeSBpcyBhIHN1cHBvcnRlZCB2cyBjdXJyZW5jeSB0byB1c2VcbiAgICAgKiB0byBxdWVyeSBmb3IgdG9rZW4gZXhjaGFuZ2UgcmF0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmF0aXZlQ3VycmVuY3kgLSBUaGUgbmF0aXZlIGN1cnJlbmN5IG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIG5ldHdvcmsuXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpdCdzIGEgc3VwcG9ydGVkIHZzQ3VycmVuY3kuXG4gICAgICovXG4gICAgY2hlY2tJc1N1cHBvcnRlZFZzQ3VycmVuY3kobmF0aXZlQ3VycmVuY3kpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdGhyZXNob2xkIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgIGNvbnN0IHsgdGltZXN0YW1wLCBkYXRhIH0gPSB0aGlzLnN1cHBvcnRlZFZzQ3VycmVuY2llcztcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBpZiAobm93IC0gdGltZXN0YW1wID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVuY2llcyA9IHlpZWxkIHV0aWxfMS5oYW5kbGVGZXRjaChDb2luR2Vja29BcGkuZ2V0U3VwcG9ydGVkVnNDdXJyZW5jaWVzKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3VwcG9ydGVkVnNDdXJyZW5jaWVzID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdXJyZW5jaWVzLFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVuY2llcy5pbmNsdWRlcyhuYXRpdmVDdXJyZW5jeS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhLmluY2x1ZGVzKG5hdGl2ZUN1cnJlbmN5LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBjdXJyZW50IGNoYWluIElEIHNsdWcgZnJvbSBjYWNoZWQgc3VwcG9ydGVkIHBsYXRmb3JtcyBDb2luR2Vja28gQVBJIHJlc3BvbnNlLlxuICAgICAqIElmIGNhY2hlZCBzdXBwb3J0ZWQgcGxhdGZvcm1zIHJlc3BvbnNlIGlzIHN0YWxlLCBmZXRjaGVzIGFuZCB1cGRhdGVzIGl0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIENvaW5HZWNrbyBzbHVnIGZvciB0aGUgY3VycmVudCBjaGFpbiBJRC5cbiAgICAgKi9cbiAgICBnZXRDaGFpblNsdWcoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHRocmVzaG9sZCwgY2hhaW5JZCB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIHRpbWVzdGFtcCB9ID0gdGhpcy5zdXBwb3J0ZWRDaGFpbnM7XG4gICAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgaWYgKG5vdyAtIHRpbWVzdGFtcCA+IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBsYXRmb3JtcyA9IHlpZWxkIHV0aWxfMS5oYW5kbGVGZXRjaChDb2luR2Vja29BcGkuZ2V0UGxhdGZvcm1zVVJMKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3VwcG9ydGVkQ2hhaW5zID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBwbGF0Zm9ybXMsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBmaW5kQ2hhaW5TbHVnKGNoYWluSWQsIHBsYXRmb3Jtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmluZENoYWluU2x1ZyhjaGFpbklkLCBkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgZXhjaGFuZ2UgcmF0ZXMgZm9yIGFsbCB0b2tlbnMuXG4gICAgICovXG4gICAgdXBkYXRlRXhjaGFuZ2VSYXRlcygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRva2VuTGlzdC5sZW5ndGggPT09IDAgfHwgdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNsdWcgPSB5aWVsZCB0aGlzLmdldENoYWluU2x1ZygpO1xuICAgICAgICAgICAgbGV0IG5ld0NvbnRyYWN0RXhjaGFuZ2VSYXRlcyA9IHt9O1xuICAgICAgICAgICAgaWYgKCFzbHVnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b2tlbkxpc3QuZm9yRWFjaCgodG9rZW4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyh0b2tlbi5hZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udHJhY3RFeGNoYW5nZVJhdGVzW2FkZHJlc3NdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBuYXRpdmVDdXJyZW5jeSB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICAgICAgbmV3Q29udHJhY3RFeGNoYW5nZVJhdGVzID0geWllbGQgdGhpcy5mZXRjaEFuZE1hcEV4Y2hhbmdlUmF0ZXMobmF0aXZlQ3VycmVuY3ksIHNsdWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBjb250cmFjdEV4Y2hhbmdlUmF0ZXM6IG5ld0NvbnRyYWN0RXhjaGFuZ2VSYXRlcyB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgYWN0aXZlIG5ldHdvcmsncyBuYXRpdmUgY3VycmVuY3kgaXMgc3VwcG9ydGVkIGJ5IHRoZSBjb2luZ2Vja28gQVBJLlxuICAgICAqIElmIHN1cHBvcnRlZCwgaXQgZmV0Y2hlcyBhbmQgbWFwcyBjb250cmFjdEV4Y2hhbmdlIHJhdGVzIHRvIGEgZm9ybWF0IHRvIGJlIGNvbnN1bWVkIGJ5IHRoZSBVSS5cbiAgICAgKiBJZiBub3Qgc3VwcG9ydGVkLCBpdCBmZXRjaGVzIGNvbnRyYWN0RXhjaGFuZ2UgcmF0ZXMgYW5kIG1hcHMgdGhlbSBmcm9tIHRva2VuL2ZhbGxiYWNrLWN1cnJlbmN5XG4gICAgICogdG8gdG9rZW4vbmF0aXZlQ3VycmVuY3kuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmF0aXZlQ3VycmVuY3kgLSBUaGUgbmF0aXZlIGN1cnJlbmN5IG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIG5ldHdvcmsuXG4gICAgICogQHBhcmFtIHNsdWcgLSBUaGUgdW5pcXVlIHNsdWcgdXNlZCB0byBpZCB0aGUgY2hhaW4gYnkgdGhlIGNvaW5nZWNrbyBhcGlcbiAgICAgKiBzaG91bGQgYmUgdXNlZCB0byBxdWVyeSB0b2tlbiBleGNoYW5nZSByYXRlcy5cbiAgICAgKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCBjb252ZXJzaW9uIHJhdGVzIGZvciBlYWNoIHRva2VuXG4gICAgICogcmVsYXRlZCB0byB0aGUgbmV0d29yaydzIG5hdGl2ZSBjdXJyZW5jeS5cbiAgICAgKi9cbiAgICBmZXRjaEFuZE1hcEV4Y2hhbmdlUmF0ZXMobmF0aXZlQ3VycmVuY3ksIHNsdWcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0RXhjaGFuZ2VSYXRlcyA9IHt9O1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgbmF0aXZlIGN1cnJlbmN5IGlzIHN1cHBvcnRlZCBhcyBhIHZzX2N1cnJlbmN5IGJ5IHRoZSBBUElcbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZUN1cnJlbmN5U3VwcG9ydGVkID0geWllbGQgdGhpcy5jaGVja0lzU3VwcG9ydGVkVnNDdXJyZW5jeShuYXRpdmVDdXJyZW5jeSk7XG4gICAgICAgICAgICBpZiAobmF0aXZlQ3VycmVuY3lTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCBpcyB3ZSBjYW4gZG8gYSBzaW1wbGUgZmV0Y2ggYWdhaW5zdCB0aGUgQ29pbkdlY2tvIEFQSVxuICAgICAgICAgICAgICAgIGNvbnN0IHByaWNlcyA9IHlpZWxkIHRoaXMuZmV0Y2hFeGNoYW5nZVJhdGUoc2x1ZywgbmF0aXZlQ3VycmVuY3kpO1xuICAgICAgICAgICAgICAgIHRoaXMudG9rZW5MaXN0LmZvckVhY2goKHRva2VuKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByaWNlID0gcHJpY2VzW3Rva2VuLmFkZHJlc3MudG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0RXhjaGFuZ2VSYXRlc1t1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3ModG9rZW4uYWRkcmVzcyldID0gcHJpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcHJpY2VbbmF0aXZlQ3VycmVuY3kudG9Mb3dlckNhc2UoKV1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmIG5hdGl2ZSBjdXJyZW5jeSBpcyBub3Qgc3VwcG9ydGVkIHdlIG5lZWQgdG8gdXNlIGEgZmFsbGJhY2sgdnNDdXJyZW5jeSwgZ2V0IHRoZSBleGNoYW5nZSByYXRlc1xuICAgICAgICAgICAgICAgIC8vIGluIHRva2VuL2ZhbGxiYWNrLWN1cnJlbmN5IGZvcm1hdCBhbmQgY29udmVydCB0aGVtIHRvIGV4cGVjdGVkIHRva2VuL25hdGl2ZUN1cnJlbmN5IGZvcm1hdC5cbiAgICAgICAgICAgICAgICBsZXQgdG9rZW5FeGNoYW5nZVJhdGVzO1xuICAgICAgICAgICAgICAgIGxldCB2c0N1cnJlbmN5VG9OYXRpdmVDdXJyZW5jeUNvbnZlcnNpb25SYXRlID0gMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbkV4Y2hhbmdlUmF0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGNvbnZlcnNpb25SYXRlOiB2c0N1cnJlbmN5VG9OYXRpdmVDdXJyZW5jeUNvbnZlcnNpb25SYXRlIH0sXG4gICAgICAgICAgICAgICAgICAgIF0gPSB5aWVsZCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZldGNoRXhjaGFuZ2VSYXRlKHNsdWcsIGNvbnN0YW50c18xLkZBTExfQkFDS19WU19DVVJSRU5DWSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjcnlwdG9fY29tcGFyZV8xLmZldGNoRXhjaGFuZ2VSYXRlKG5hdGl2ZUN1cnJlbmN5LCBjb25zdGFudHNfMS5GQUxMX0JBQ0tfVlNfQ1VSUkVOQ1ksIGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnbWFya2V0IGRvZXMgbm90IGV4aXN0IGZvciB0aGlzIGNvaW4gcGFpcicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW3Rva2VuQWRkcmVzcywgY29udmVyc2lvbl0gb2YgT2JqZWN0LmVudHJpZXModG9rZW5FeGNoYW5nZVJhdGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlblRvVnNDdXJyZW5jeUNvbnZlcnNpb25SYXRlID0gY29udmVyc2lvbltjb25zdGFudHNfMS5GQUxMX0JBQ0tfVlNfQ1VSUkVOQ1kudG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0RXhjaGFuZ2VSYXRlc1t1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3ModG9rZW5BZGRyZXNzKV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5Ub1ZzQ3VycmVuY3lDb252ZXJzaW9uUmF0ZSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdnNDdXJyZW5jeVRvTmF0aXZlQ3VycmVuY3lDb252ZXJzaW9uUmF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udHJhY3RFeGNoYW5nZVJhdGVzO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlRva2VuUmF0ZXNDb250cm9sbGVyID0gVG9rZW5SYXRlc0NvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBUb2tlblJhdGVzQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRva2VuUmF0ZXNDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCBhc3luY19tdXRleF8xID0gcmVxdWlyZShcImFzeW5jLW11dGV4XCIpO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJWMl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyVjJcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IGNyeXB0b19jb21wYXJlXzEgPSByZXF1aXJlKFwiLi4vYXBpcy9jcnlwdG8tY29tcGFyZVwiKTtcbmNvbnN0IG5hbWUgPSAnQ3VycmVuY3lSYXRlQ29udHJvbGxlcic7XG5jb25zdCBtZXRhZGF0YSA9IHtcbiAgICBjb252ZXJzaW9uRGF0ZTogeyBwZXJzaXN0OiB0cnVlLCBhbm9ueW1vdXM6IHRydWUgfSxcbiAgICBjb252ZXJzaW9uUmF0ZTogeyBwZXJzaXN0OiB0cnVlLCBhbm9ueW1vdXM6IHRydWUgfSxcbiAgICBjdXJyZW50Q3VycmVuY3k6IHsgcGVyc2lzdDogdHJ1ZSwgYW5vbnltb3VzOiB0cnVlIH0sXG4gICAgbmF0aXZlQ3VycmVuY3k6IHsgcGVyc2lzdDogdHJ1ZSwgYW5vbnltb3VzOiB0cnVlIH0sXG4gICAgcGVuZGluZ0N1cnJlbnRDdXJyZW5jeTogeyBwZXJzaXN0OiBmYWxzZSwgYW5vbnltb3VzOiB0cnVlIH0sXG4gICAgcGVuZGluZ05hdGl2ZUN1cnJlbmN5OiB7IHBlcnNpc3Q6IGZhbHNlLCBhbm9ueW1vdXM6IHRydWUgfSxcbiAgICB1c2RDb252ZXJzaW9uUmF0ZTogeyBwZXJzaXN0OiB0cnVlLCBhbm9ueW1vdXM6IHRydWUgfSxcbn07XG5jb25zdCBkZWZhdWx0U3RhdGUgPSB7XG4gICAgY29udmVyc2lvbkRhdGU6IDAsXG4gICAgY29udmVyc2lvblJhdGU6IDAsXG4gICAgY3VycmVudEN1cnJlbmN5OiAndXNkJyxcbiAgICBuYXRpdmVDdXJyZW5jeTogJ0VUSCcsXG4gICAgcGVuZGluZ0N1cnJlbnRDdXJyZW5jeTogbnVsbCxcbiAgICBwZW5kaW5nTmF0aXZlQ3VycmVuY3k6IG51bGwsXG4gICAgdXNkQ29udmVyc2lvblJhdGU6IG51bGwsXG59O1xuLyoqXG4gKiBDb250cm9sbGVyIHRoYXQgcGFzc2l2ZWx5IHBvbGxzIG9uIGEgc2V0IGludGVydmFsIGZvciBhbiBleGNoYW5nZSByYXRlIGZyb20gdGhlIGN1cnJlbnQgYmFzZVxuICogYXNzZXQgdG8gdGhlIGN1cnJlbnQgY3VycmVuY3lcbiAqL1xuY2xhc3MgQ3VycmVuY3lSYXRlQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyVjJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIEN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIENvbnN0cnVjdG9yIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaW5jbHVkZVVzZFJhdGUgLSBLZWVwIHRyYWNrIG9mIHRoZSBVU0QgcmF0ZSBpbiBhZGRpdGlvbiB0byB0aGUgY3VycmVudCBjdXJyZW5jeSByYXRlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmludGVydmFsIC0gVGhlIHBvbGxpbmcgaW50ZXJ2YWwsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5tZXNzZW5nZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgbWVzc2FnaW5nIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5mZXRjaEV4Y2hhbmdlUmF0ZSAtIEZldGNoZXMgdGhlIGV4Y2hhbmdlIHJhdGUgZnJvbSBhbiBleHRlcm5hbCBBUEkuIFRoaXMgb3B0aW9uIGlzIHByaW1hcmlseSBtZWFudCBmb3IgdXNlIGluIHVuaXQgdGVzdHMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBpbmNsdWRlVXNkUmF0ZSA9IGZhbHNlLCBpbnRlcnZhbCA9IDE4MDAwMCwgbWVzc2VuZ2VyLCBzdGF0ZSwgZmV0Y2hFeGNoYW5nZVJhdGUgPSBjcnlwdG9fY29tcGFyZV8xLmZldGNoRXhjaGFuZ2VSYXRlLCB9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgIG1lc3NlbmdlcixcbiAgICAgICAgICAgIHN0YXRlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRTdGF0ZSksIHN0YXRlKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubXV0ZXggPSBuZXcgYXN5bmNfbXV0ZXhfMS5NdXRleCgpO1xuICAgICAgICB0aGlzLmluY2x1ZGVVc2RSYXRlID0gaW5jbHVkZVVzZFJhdGU7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxEZWxheSA9IGludGVydmFsO1xuICAgICAgICB0aGlzLmZldGNoRXhjaGFuZ2VSYXRlID0gZmV0Y2hFeGNoYW5nZVJhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHBvbGxpbmcgZm9yIHRoZSBjdXJyZW5jeSByYXRlLlxuICAgICAqL1xuICAgIHN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5zdGFydFBvbGxpbmcoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3AgcG9sbGluZyBmb3IgdGhlIGN1cnJlbmN5IHJhdGUuXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5zdG9wUG9sbGluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHRvIGRpc2NhcmQgdGhpcyBjb250cm9sbGVyLlxuICAgICAqXG4gICAgICogVGhpcyBzdG9wcyBhbnkgYWN0aXZlIHBvbGxpbmcuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnN0b3BQb2xsaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBjdXJyZW5jeSB0byB0cmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjdXJyZW50Q3VycmVuY3kgLSBJU08gNDIxNyBjdXJyZW5jeSBjb2RlLlxuICAgICAqL1xuICAgIHNldEN1cnJlbnRDdXJyZW5jeShjdXJyZW50Q3VycmVuY3kpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXRlLnBlbmRpbmdDdXJyZW50Q3VycmVuY3kgPSBjdXJyZW50Q3VycmVuY3k7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMudXBkYXRlRXhjaGFuZ2VSYXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbmV3IG5hdGl2ZSBjdXJyZW5jeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzeW1ib2wgLSBTeW1ib2wgZm9yIHRoZSBiYXNlIGFzc2V0LlxuICAgICAqL1xuICAgIHNldE5hdGl2ZUN1cnJlbmN5KHN5bWJvbCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgc3RhdGUucGVuZGluZ05hdGl2ZUN1cnJlbmN5ID0gc3ltYm9sO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnVwZGF0ZUV4Y2hhbmdlUmF0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RvcFBvbGxpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVydmFsSWQpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgYSBuZXcgcG9sbGluZyBpbnRlcnZhbC5cbiAgICAgKi9cbiAgICBzdGFydFBvbGxpbmcoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BQb2xsaW5nKCk7XG4gICAgICAgICAgICAvLyBUT0RPOiBFeHBvc2UgcG9sbGluZyBjdXJyZW5jeSByYXRlIHVwZGF0ZSBlcnJvcnNcbiAgICAgICAgICAgIHlpZWxkIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IHRoaXMudXBkYXRlRXhjaGFuZ2VSYXRlKCkpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IHRoaXMudXBkYXRlRXhjaGFuZ2VSYXRlKCkpO1xuICAgICAgICAgICAgfSksIHRoaXMuaW50ZXJ2YWxEZWxheSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGV4Y2hhbmdlIHJhdGUgZm9yIHRoZSBjdXJyZW50IGN1cnJlbmN5LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGNvbnRyb2xsZXIgc3RhdGUuXG4gICAgICovXG4gICAgdXBkYXRlRXhjaGFuZ2VSYXRlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVsZWFzZUxvY2sgPSB5aWVsZCB0aGlzLm11dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgY3VycmVudEN1cnJlbmN5OiBzdGF0ZUN1cnJlbnRDdXJyZW5jeSwgbmF0aXZlQ3VycmVuY3k6IHN0YXRlTmF0aXZlQ3VycmVuY3ksIHBlbmRpbmdDdXJyZW50Q3VycmVuY3ksIHBlbmRpbmdOYXRpdmVDdXJyZW5jeSwgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBsZXQgY29udmVyc2lvbkRhdGUgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGNvbnZlcnNpb25SYXRlID0gbnVsbDtcbiAgICAgICAgICAgIGxldCB1c2RDb252ZXJzaW9uUmF0ZSA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Q3VycmVuY3kgPSBwZW5kaW5nQ3VycmVudEN1cnJlbmN5ICE9PSBudWxsICYmIHBlbmRpbmdDdXJyZW50Q3VycmVuY3kgIT09IHZvaWQgMCA/IHBlbmRpbmdDdXJyZW50Q3VycmVuY3kgOiBzdGF0ZUN1cnJlbnRDdXJyZW5jeTtcbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZUN1cnJlbmN5ID0gcGVuZGluZ05hdGl2ZUN1cnJlbmN5ICE9PSBudWxsICYmIHBlbmRpbmdOYXRpdmVDdXJyZW5jeSAhPT0gdm9pZCAwID8gcGVuZGluZ05hdGl2ZUN1cnJlbmN5IDogc3RhdGVOYXRpdmVDdXJyZW5jeTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDdXJyZW5jeSAmJlxuICAgICAgICAgICAgICAgICAgICBuYXRpdmVDdXJyZW5jeSAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBlaXRoZXIgY3VycmVuY3kgaXMgYW4gZW1wdHkgc3RyaW5nIHdlIGNhbiBza2lwIHRoZSBjb21wYXJpc29uXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgaXQgd2lsbCByZXN1bHQgaW4gYW4gZXJyb3IgZnJvbSB0aGUgYXBpIGFuZCB1bHRpbWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgIC8vIGEgbnVsbCBjb252ZXJzaW9uUmF0ZSBlaXRoZXIgd2F5LlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q3VycmVuY3kgIT09ICcnICYmXG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUN1cnJlbmN5ICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAoeyBjb252ZXJzaW9uUmF0ZSwgdXNkQ29udmVyc2lvblJhdGUgfSA9IHlpZWxkIHRoaXMuZmV0Y2hFeGNoYW5nZVJhdGUoY3VycmVudEN1cnJlbmN5LCBuYXRpdmVDdXJyZW5jeSwgdGhpcy5pbmNsdWRlVXNkUmF0ZSkpO1xuICAgICAgICAgICAgICAgICAgICBjb252ZXJzaW9uRGF0ZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICghZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnbWFya2V0IGRvZXMgbm90IGV4aXN0IGZvciB0aGlzIGNvaW4gcGFpcicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVyc2lvbkRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVyc2lvblJhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgY3VycmVudGx5IGFsbG93IGFuZCBoYW5kbGUgYW4gZW1wdHkgc3RyaW5nIGFzIGEgdmFsaWQgbmF0aXZlQ3VycmVuY3lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBjYXNlcyB3aGVyZSBhIHVzZXIgaGFzIG5vdCBlbnRlcmVkIGEgbmF0aXZlIHRpY2tlciBzeW1ib2wgZm9yIGEgY3VzdG9tIG5ldHdvcmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50Q3VycmVuY3kgaXMgbm90IGZyb20gdXNlciBpbnB1dCBidXQgdGhpcyBwcm90ZWN0cyB1cyBmcm9tIHVuZXhwZWN0ZWQgY2hhbmdlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVDdXJyZW5jeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q3VycmVuY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0N1cnJlbnRDdXJyZW5jeTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nTmF0aXZlQ3VycmVuY3k6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNkQ29udmVyc2lvblJhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQ3VycmVuY3lSYXRlQ29udHJvbGxlciA9IEN1cnJlbmN5UmF0ZUNvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBDdXJyZW5jeVJhdGVDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3VycmVuY3lSYXRlQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BY2NvdW50VHJhY2tlckNvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCBldGhfcXVlcnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZXRoLXF1ZXJ5XCIpKTtcbmNvbnN0IGFzeW5jX211dGV4XzEgPSByZXF1aXJlKFwiYXN5bmMtbXV0ZXhcIik7XG5jb25zdCBCYXNlQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG4vKipcbiAqIENvbnRyb2xsZXIgdGhhdCB0cmFja3MgaW5mb3JtYXRpb24gZm9yIGFsbCBhY2NvdW50cyBpbiB0aGUgY3VycmVudCBrZXljaGFpblxuICovXG5jbGFzcyBBY2NvdW50VHJhY2tlckNvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlcl8xLkJhc2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIEFjY291bnRUcmFja2VyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgY29udHJvbGxlciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm9uUHJlZmVyZW5jZXNTdGF0ZUNoYW5nZSAtIEFsbG93cyBzdWJzY3JpYmluZyB0byBwcmVmZXJlbmNlIGNvbnRyb2xsZXIgc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRJZGVudGl0aWVzIC0gR2V0cyB0aGUgaWRlbnRpdGllcyBmcm9tIHRoZSBQcmVmZXJlbmNlcyBzdG9yZS5cbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBvblByZWZlcmVuY2VzU3RhdGVDaGFuZ2UsIGdldElkZW50aXRpZXMsIH0sIGNvbmZpZywgc3RhdGUpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzdGF0ZSk7XG4gICAgICAgIHRoaXMubXV0ZXggPSBuZXcgYXN5bmNfbXV0ZXhfMS5NdXRleCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICdBY2NvdW50VHJhY2tlckNvbnRyb2xsZXInO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmcmVzaGVzIGFsbCBhY2NvdW50cyBpbiB0aGUgY3VycmVudCBrZXljaGFpbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVmcmVzaCA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuc3luY0FjY291bnRzKCk7XG4gICAgICAgICAgICBjb25zdCB7IGFjY291bnRzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBhZGRyZXNzIGluIGFjY291bnRzKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdXRpbF8xLnNhZmVseUV4ZWN1dGVXaXRoVGltZW91dCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhbGFuY2UgPSB5aWVsZCB1dGlsXzEucXVlcnkodGhpcy5ldGhRdWVyeSwgJ2dldEJhbGFuY2UnLCBbYWRkcmVzc10pO1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50c1thZGRyZXNzXSA9IHsgYmFsYW5jZTogdXRpbF8xLkJOVG9IZXgoYmFsYW5jZSkgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBhY2NvdW50czogT2JqZWN0LmFzc2lnbih7fSwgYWNjb3VudHMpIH0pO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVmYXVsdENvbmZpZyA9IHtcbiAgICAgICAgICAgIGludGVydmFsOiAxMDAwMCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7IGFjY291bnRzOiB7fSB9O1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgdGhpcy5nZXRJZGVudGl0aWVzID0gZ2V0SWRlbnRpdGllcztcbiAgICAgICAgb25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgfVxuICAgIHN5bmNBY2NvdW50cygpIHtcbiAgICAgICAgY29uc3QgeyBhY2NvdW50cyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gT2JqZWN0LmtleXModGhpcy5nZXRJZGVudGl0aWVzKCkpO1xuICAgICAgICBjb25zdCBleGlzdGluZyA9IE9iamVjdC5rZXlzKGFjY291bnRzKTtcbiAgICAgICAgY29uc3QgbmV3QWRkcmVzc2VzID0gYWRkcmVzc2VzLmZpbHRlcigoYWRkcmVzcykgPT4gZXhpc3RpbmcuaW5kZXhPZihhZGRyZXNzKSA9PT0gLTEpO1xuICAgICAgICBjb25zdCBvbGRBZGRyZXNzZXMgPSBleGlzdGluZy5maWx0ZXIoKGFkZHJlc3MpID0+IGFkZHJlc3Nlcy5pbmRleE9mKGFkZHJlc3MpID09PSAtMSk7XG4gICAgICAgIG5ld0FkZHJlc3Nlcy5mb3JFYWNoKChhZGRyZXNzKSA9PiB7XG4gICAgICAgICAgICBhY2NvdW50c1thZGRyZXNzXSA9IHsgYmFsYW5jZTogJzB4MCcgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9sZEFkZHJlc3Nlcy5mb3JFYWNoKChhZGRyZXNzKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgYWNjb3VudHNbYWRkcmVzc107XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IGFjY291bnRzOiBPYmplY3QuYXNzaWduKHt9LCBhY2NvdW50cykgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBuZXcgcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBUT0RPOiBSZXBsYWNlIHRoaXMgd3RoIGEgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHByb3ZpZGVyIC0gUHJvdmlkZXIgdXNlZCB0byBjcmVhdGUgYSBuZXcgdW5kZXJseWluZyBFdGhRdWVyeSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzZXQgcHJvdmlkZXIocHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5ldGhRdWVyeSA9IG5ldyBldGhfcXVlcnlfMS5kZWZhdWx0KHByb3ZpZGVyKTtcbiAgICB9XG4gICAgZ2V0IHByb3ZpZGVyKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IG9ubHkgdXNlZCBmb3Igc2V0dGluZycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgYSBuZXcgcG9sbGluZyBpbnRlcnZhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnRlcnZhbCAtIFBvbGxpbmcgaW50ZXJ2YWwgdHJpZ2dlciBhICdyZWZyZXNoJy5cbiAgICAgKi9cbiAgICBwb2xsKGludGVydmFsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZWxlYXNlTG9jayA9IHlpZWxkIHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICAgICAgaW50ZXJ2YWwgJiYgdGhpcy5jb25maWd1cmUoeyBpbnRlcnZhbCB9LCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGUgJiYgY2xlYXJUaW1lb3V0KHRoaXMuaGFuZGxlKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICByZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9sbCh0aGlzLmNvbmZpZy5pbnRlcnZhbCk7XG4gICAgICAgICAgICB9LCB0aGlzLmNvbmZpZy5pbnRlcnZhbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQWNjb3VudFRyYWNrZXJDb250cm9sbGVyID0gQWNjb3VudFRyYWNrZXJDb250cm9sbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gQWNjb3VudFRyYWNrZXJDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWNjb3VudFRyYWNrZXJDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QZXJzb25hbE1lc3NhZ2VNYW5hZ2VyID0gdm9pZCAwO1xuY29uc3QgdXVpZF8xID0gcmVxdWlyZShcInV1aWRcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IEFic3RyYWN0TWVzc2FnZU1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0TWVzc2FnZU1hbmFnZXJcIik7XG4vKipcbiAqIENvbnRyb2xsZXIgaW4gY2hhcmdlIG9mIG1hbmFnaW5nIC0gc3RvcmluZywgYWRkaW5nLCByZW1vdmluZywgdXBkYXRpbmcgLSBNZXNzYWdlcy5cbiAqL1xuY2xhc3MgUGVyc29uYWxNZXNzYWdlTWFuYWdlciBleHRlbmRzIEFic3RyYWN0TWVzc2FnZU1hbmFnZXJfMS5BYnN0cmFjdE1lc3NhZ2VNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhpcyBjb250cm9sbGVyIHVzZWQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnUGVyc29uYWxNZXNzYWdlTWFuYWdlcic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgTWVzc2FnZSB3aXRoIGFuICd1bmFwcHJvdmVkJyBzdGF0dXMgdXNpbmcgdGhlIHBhc3NlZCBtZXNzYWdlUGFyYW1zLlxuICAgICAqIHRoaXMuYWRkTWVzc2FnZSBpcyBjYWxsZWQgdG8gYWRkIHRoZSBuZXcgTWVzc2FnZSB0byB0aGlzLm1lc3NhZ2VzLCBhbmQgdG8gc2F2ZSB0aGUgdW5hcHByb3ZlZCBNZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlUGFyYW1zIC0gVGhlIHBhcmFtcyBmb3IgdGhlIHBlcnNvbmFsX3NpZ24gY2FsbCB0byBiZSBtYWRlIGFmdGVyIHRoZSBtZXNzYWdlIGlzIGFwcHJvdmVkLlxuICAgICAqIEBwYXJhbSByZXEgLSBUaGUgb3JpZ2luYWwgcmVxdWVzdCBvYmplY3QgcG9zc2libHkgY29udGFpbmluZyB0aGUgb3JpZ2luLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSByYXcgZGF0YSBvZiB0aGUgc2lnbmF0dXJlIHJlcXVlc3QuXG4gICAgICovXG4gICAgYWRkVW5hcHByb3ZlZE1lc3NhZ2VBc3luYyhtZXNzYWdlUGFyYW1zLCByZXEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHV0aWxfMS52YWxpZGF0ZVNpZ25NZXNzYWdlRGF0YShtZXNzYWdlUGFyYW1zKTtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VJZCA9IHRoaXMuYWRkVW5hcHByb3ZlZE1lc3NhZ2UobWVzc2FnZVBhcmFtcywgcmVxKTtcbiAgICAgICAgICAgIHRoaXMuaHViLm9uY2UoYCR7bWVzc2FnZUlkfTpmaW5pc2hlZGAsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChkYXRhLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzaWduZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZGF0YS5yYXdTaWcpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdyZWplY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTWV0YU1hc2sgUGVyc29uYWwgTWVzc2FnZSBTaWduYXR1cmU6IFVzZXIgZGVuaWVkIG1lc3NhZ2Ugc2lnbmF0dXJlLicpKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKGBNZXRhTWFzayBQZXJzb25hbCBNZXNzYWdlIFNpZ25hdHVyZTogVW5rbm93biBwcm9ibGVtOiAke0pTT04uc3RyaW5naWZ5KG1lc3NhZ2VQYXJhbXMpfWApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgTWVzc2FnZSB3aXRoIGFuICd1bmFwcHJvdmVkJyBzdGF0dXMgdXNpbmcgdGhlIHBhc3NlZCBtZXNzYWdlUGFyYW1zLlxuICAgICAqIHRoaXMuYWRkTWVzc2FnZSBpcyBjYWxsZWQgdG8gYWRkIHRoZSBuZXcgTWVzc2FnZSB0byB0aGlzLm1lc3NhZ2VzLCBhbmQgdG8gc2F2ZSB0aGVcbiAgICAgKiB1bmFwcHJvdmVkIE1lc3NhZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VQYXJhbXMgLSBUaGUgcGFyYW1zIGZvciB0aGUgcGVyc29uYWxfc2lnbiBjYWxsIHRvIGJlIG1hZGUgYWZ0ZXIgdGhlIG1lc3NhZ2VcbiAgICAgKiBpcyBhcHByb3ZlZC5cbiAgICAgKiBAcGFyYW0gcmVxIC0gVGhlIG9yaWdpbmFsIHJlcXVlc3Qgb2JqZWN0IHBvc3NpYmx5IGNvbnRhaW5pbmcgdGhlIG9yaWdpbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgaWQgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBhZGRVbmFwcHJvdmVkTWVzc2FnZShtZXNzYWdlUGFyYW1zLCByZXEpIHtcbiAgICAgICAgaWYgKHJlcSkge1xuICAgICAgICAgICAgbWVzc2FnZVBhcmFtcy5vcmlnaW4gPSByZXEub3JpZ2luO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2VQYXJhbXMuZGF0YSA9IHV0aWxfMS5ub3JtYWxpemVNZXNzYWdlRGF0YShtZXNzYWdlUGFyYW1zLmRhdGEpO1xuICAgICAgICBjb25zdCBtZXNzYWdlSWQgPSB1dWlkXzEudjEoKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZURhdGEgPSB7XG4gICAgICAgICAgICBpZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyxcbiAgICAgICAgICAgIHN0YXR1czogJ3VuYXBwcm92ZWQnLFxuICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHR5cGU6ICdwZXJzb25hbF9zaWduJyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRNZXNzYWdlKG1lc3NhZ2VEYXRhKTtcbiAgICAgICAgdGhpcy5odWIuZW1pdChgdW5hcHByb3ZlZE1lc3NhZ2VgLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1lc3NhZ2VQYXJhbXMpLCB7IG1ldGFtYXNrSWQ6IG1lc3NhZ2VJZCB9KSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlSWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIG1ldGFtYXNrSWQgcHJvcGVydHkgZnJvbSBwYXNzZWQgbWVzc2FnZVBhcmFtcyBhbmQgcmV0dXJucyBhIHByb21pc2Ugd2hpY2hcbiAgICAgKiByZXNvbHZlcyB0aGUgdXBkYXRlZCBtZXNzYWdlUGFyYW1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VQYXJhbXMgLSBUaGUgbWVzc2FnZVBhcmFtcyB0byBtb2RpZnkuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIG1lc3NhZ2VQYXJhbXMgd2l0aCB0aGUgbWV0YW1hc2tJZCBwcm9wZXJ0eSByZW1vdmVkLlxuICAgICAqL1xuICAgIHByZXBNZXNzYWdlRm9yU2lnbmluZyhtZXNzYWdlUGFyYW1zKSB7XG4gICAgICAgIGRlbGV0ZSBtZXNzYWdlUGFyYW1zLm1ldGFtYXNrSWQ7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWVzc2FnZVBhcmFtcyk7XG4gICAgfVxufVxuZXhwb3J0cy5QZXJzb25hbE1lc3NhZ2VNYW5hZ2VyID0gUGVyc29uYWxNZXNzYWdlTWFuYWdlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IFBlcnNvbmFsTWVzc2FnZU1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QZXJzb25hbE1lc3NhZ2VNYW5hZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NZXNzYWdlTWFuYWdlciA9IHZvaWQgMDtcbmNvbnN0IHV1aWRfMSA9IHJlcXVpcmUoXCJ1dWlkXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCBBYnN0cmFjdE1lc3NhZ2VNYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi9BYnN0cmFjdE1lc3NhZ2VNYW5hZ2VyXCIpO1xuLyoqXG4gKiBDb250cm9sbGVyIGluIGNoYXJnZSBvZiBtYW5hZ2luZyAtIHN0b3JpbmcsIGFkZGluZywgcmVtb3ZpbmcsIHVwZGF0aW5nIC0gTWVzc2FnZXMuXG4gKi9cbmNsYXNzIE1lc3NhZ2VNYW5hZ2VyIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlTWFuYWdlcl8xLkFic3RyYWN0TWVzc2FnZU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICdNZXNzYWdlTWFuYWdlcic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgTWVzc2FnZSB3aXRoIGFuICd1bmFwcHJvdmVkJyBzdGF0dXMgdXNpbmcgdGhlIHBhc3NlZCBtZXNzYWdlUGFyYW1zLlxuICAgICAqIHRoaXMuYWRkTWVzc2FnZSBpcyBjYWxsZWQgdG8gYWRkIHRoZSBuZXcgTWVzc2FnZSB0byB0aGlzLm1lc3NhZ2VzLCBhbmQgdG8gc2F2ZSB0aGUgdW5hcHByb3ZlZCBNZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlUGFyYW1zIC0gVGhlIHBhcmFtcyBmb3IgdGhlIGV0aF9zaWduIGNhbGwgdG8gYmUgbWFkZSBhZnRlciB0aGUgbWVzc2FnZSBpcyBhcHByb3ZlZC5cbiAgICAgKiBAcGFyYW0gcmVxIC0gVGhlIG9yaWdpbmFsIHJlcXVlc3Qgb2JqZWN0IHBvc3NpYmx5IGNvbnRhaW5pbmcgdGhlIG9yaWdpbi5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgcmF3IGRhdGEgb2YgdGhlIHNpZ25hdHVyZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIGFkZFVuYXBwcm92ZWRNZXNzYWdlQXN5bmMobWVzc2FnZVBhcmFtcywgcmVxKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB1dGlsXzEudmFsaWRhdGVTaWduTWVzc2FnZURhdGEobWVzc2FnZVBhcmFtcyk7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlSWQgPSB0aGlzLmFkZFVuYXBwcm92ZWRNZXNzYWdlKG1lc3NhZ2VQYXJhbXMsIHJlcSk7XG4gICAgICAgICAgICB0aGlzLmh1Yi5vbmNlKGAke21lc3NhZ2VJZH06ZmluaXNoZWRgLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZGF0YS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2lnbmVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGRhdGEucmF3U2lnKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVqZWN0ZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ01ldGFNYXNrIE1lc3NhZ2UgU2lnbmF0dXJlOiBVc2VyIGRlbmllZCBtZXNzYWdlIHNpZ25hdHVyZS4nKSk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihgTWV0YU1hc2sgTWVzc2FnZSBTaWduYXR1cmU6IFVua25vd24gcHJvYmxlbTogJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlUGFyYW1zKX1gKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE1lc3NhZ2Ugd2l0aCBhbiAndW5hcHByb3ZlZCcgc3RhdHVzIHVzaW5nIHRoZSBwYXNzZWQgbWVzc2FnZVBhcmFtcy5cbiAgICAgKiB0aGlzLmFkZE1lc3NhZ2UgaXMgY2FsbGVkIHRvIGFkZCB0aGUgbmV3IE1lc3NhZ2UgdG8gdGhpcy5tZXNzYWdlcywgYW5kIHRvIHNhdmUgdGhlXG4gICAgICogdW5hcHByb3ZlZCBNZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlUGFyYW1zIC0gVGhlIHBhcmFtcyBmb3IgdGhlIGV0aF9zaWduIGNhbGwgdG8gYmUgbWFkZSBhZnRlciB0aGUgbWVzc2FnZVxuICAgICAqIGlzIGFwcHJvdmVkLlxuICAgICAqIEBwYXJhbSByZXEgLSBUaGUgb3JpZ2luYWwgcmVxdWVzdCBvYmplY3QgcG9zc2libHkgY29udGFpbmluZyB0aGUgb3JpZ2luLlxuICAgICAqIEByZXR1cm5zIFRoZSBpZCBvZiB0aGUgbmV3bHkgY3JlYXRlZCBtZXNzYWdlLlxuICAgICAqL1xuICAgIGFkZFVuYXBwcm92ZWRNZXNzYWdlKG1lc3NhZ2VQYXJhbXMsIHJlcSkge1xuICAgICAgICBpZiAocmVxKSB7XG4gICAgICAgICAgICBtZXNzYWdlUGFyYW1zLm9yaWdpbiA9IHJlcS5vcmlnaW47XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZVBhcmFtcy5kYXRhID0gdXRpbF8xLm5vcm1hbGl6ZU1lc3NhZ2VEYXRhKG1lc3NhZ2VQYXJhbXMuZGF0YSk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VJZCA9IHV1aWRfMS52MSgpO1xuICAgICAgICBjb25zdCBtZXNzYWdlRGF0YSA9IHtcbiAgICAgICAgICAgIGlkOiBtZXNzYWdlSWQsXG4gICAgICAgICAgICBtZXNzYWdlUGFyYW1zLFxuICAgICAgICAgICAgc3RhdHVzOiAndW5hcHByb3ZlZCcsXG4gICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgdHlwZTogJ2V0aF9zaWduJyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRNZXNzYWdlKG1lc3NhZ2VEYXRhKTtcbiAgICAgICAgdGhpcy5odWIuZW1pdChgdW5hcHByb3ZlZE1lc3NhZ2VgLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1lc3NhZ2VQYXJhbXMpLCB7IG1ldGFtYXNrSWQ6IG1lc3NhZ2VJZCB9KSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlSWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIG1ldGFtYXNrSWQgcHJvcGVydHkgZnJvbSBwYXNzZWQgbWVzc2FnZVBhcmFtcyBhbmQgcmV0dXJucyBhIHByb21pc2Ugd2hpY2hcbiAgICAgKiByZXNvbHZlcyB0aGUgdXBkYXRlZCBtZXNzYWdlUGFyYW1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VQYXJhbXMgLSBUaGUgbWVzc2FnZVBhcmFtcyB0byBtb2RpZnkuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIG1lc3NhZ2VQYXJhbXMgd2l0aCB0aGUgbWV0YW1hc2tJZCBwcm9wZXJ0eSByZW1vdmVkLlxuICAgICAqL1xuICAgIHByZXBNZXNzYWdlRm9yU2lnbmluZyhtZXNzYWdlUGFyYW1zKSB7XG4gICAgICAgIGRlbGV0ZSBtZXNzYWdlUGFyYW1zLm1ldGFtYXNrSWQ7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWVzc2FnZVBhcmFtcyk7XG4gICAgfVxufVxuZXhwb3J0cy5NZXNzYWdlTWFuYWdlciA9IE1lc3NhZ2VNYW5hZ2VyO1xuZXhwb3J0cy5kZWZhdWx0ID0gTWVzc2FnZU1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXNzYWdlTWFuYWdlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHlwZWRNZXNzYWdlTWFuYWdlciA9IHZvaWQgMDtcbmNvbnN0IHV1aWRfMSA9IHJlcXVpcmUoXCJ1dWlkXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCBBYnN0cmFjdE1lc3NhZ2VNYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi9BYnN0cmFjdE1lc3NhZ2VNYW5hZ2VyXCIpO1xuLyoqXG4gKiBDb250cm9sbGVyIGluIGNoYXJnZSBvZiBtYW5hZ2luZyAtIHN0b3JpbmcsIGFkZGluZywgcmVtb3ZpbmcsIHVwZGF0aW5nIC0gVHlwZWRNZXNzYWdlcy5cbiAqL1xuY2xhc3MgVHlwZWRNZXNzYWdlTWFuYWdlciBleHRlbmRzIEFic3RyYWN0TWVzc2FnZU1hbmFnZXJfMS5BYnN0cmFjdE1lc3NhZ2VNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhpcyBjb250cm9sbGVyIHVzZWQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnVHlwZWRNZXNzYWdlTWFuYWdlcic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVHlwZWRNZXNzYWdlIHdpdGggYW4gJ3VuYXBwcm92ZWQnIHN0YXR1cyB1c2luZyB0aGUgcGFzc2VkIG1lc3NhZ2VQYXJhbXMuXG4gICAgICogdGhpcy5hZGRNZXNzYWdlIGlzIGNhbGxlZCB0byBhZGQgdGhlIG5ldyBUeXBlZE1lc3NhZ2UgdG8gdGhpcy5tZXNzYWdlcywgYW5kIHRvIHNhdmUgdGhlIHVuYXBwcm92ZWQgVHlwZWRNZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlUGFyYW1zIC0gVGhlIHBhcmFtcyBmb3IgdGhlIGV0aF9zaWduVHlwZWREYXRhIGNhbGwgdG8gYmUgbWFkZSBhZnRlciB0aGUgbWVzc2FnZSBpcyBhcHByb3ZlZC5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiAtIENvbXBhdGliaWxpdHkgdmVyc2lvbiBFSVA3MTIuXG4gICAgICogQHBhcmFtIHJlcSAtIFRoZSBvcmlnaW5hbCByZXF1ZXN0IG9iamVjdCBwb3NzaWJseSBjb250YWluaW5nIHRoZSBvcmlnaW4uXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHJhdyBkYXRhIG9mIHRoZSBzaWduYXR1cmUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBhZGRVbmFwcHJvdmVkTWVzc2FnZUFzeW5jKG1lc3NhZ2VQYXJhbXMsIHZlcnNpb24sIHJlcSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZlcnNpb24gPT09ICdWMScpIHtcbiAgICAgICAgICAgICAgICB1dGlsXzEudmFsaWRhdGVUeXBlZFNpZ25NZXNzYWdlRGF0YVYxKG1lc3NhZ2VQYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZlcnNpb24gPT09ICdWMycpIHtcbiAgICAgICAgICAgICAgICB1dGlsXzEudmFsaWRhdGVUeXBlZFNpZ25NZXNzYWdlRGF0YVYzKG1lc3NhZ2VQYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZUlkID0gdGhpcy5hZGRVbmFwcHJvdmVkTWVzc2FnZShtZXNzYWdlUGFyYW1zLCB2ZXJzaW9uLCByZXEpO1xuICAgICAgICAgICAgdGhpcy5odWIub25jZShgJHttZXNzYWdlSWR9OmZpbmlzaGVkYCwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGRhdGEuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NpZ25lZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShkYXRhLnJhd1NpZyk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlamVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdNZXRhTWFzayBUeXBlZCBNZXNzYWdlIFNpZ25hdHVyZTogVXNlciBkZW5pZWQgbWVzc2FnZSBzaWduYXR1cmUuJykpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdlcnJvcmVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKGBNZXRhTWFzayBUeXBlZCBNZXNzYWdlIFNpZ25hdHVyZTogJHtkYXRhLmVycm9yfWApKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKGBNZXRhTWFzayBUeXBlZCBNZXNzYWdlIFNpZ25hdHVyZTogVW5rbm93biBwcm9ibGVtOiAke0pTT04uc3RyaW5naWZ5KG1lc3NhZ2VQYXJhbXMpfWApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVHlwZWRNZXNzYWdlIHdpdGggYW4gJ3VuYXBwcm92ZWQnIHN0YXR1cyB1c2luZyB0aGUgcGFzc2VkIG1lc3NhZ2VQYXJhbXMuXG4gICAgICogdGhpcy5hZGRNZXNzYWdlIGlzIGNhbGxlZCB0byBhZGQgdGhlIG5ldyBUeXBlZE1lc3NhZ2UgdG8gdGhpcy5tZXNzYWdlcywgYW5kIHRvIHNhdmUgdGhlXG4gICAgICogdW5hcHByb3ZlZCBUeXBlZE1lc3NhZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VQYXJhbXMgLSBUaGUgcGFyYW1zIGZvciB0aGUgJ2V0aF9zaWduVHlwZWREYXRhJyBjYWxsIHRvIGJlIG1hZGUgYWZ0ZXIgdGhlIG1lc3NhZ2VcbiAgICAgKiBpcyBhcHByb3ZlZC5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiAtIENvbXBhdGliaWxpdHkgdmVyc2lvbiBFSVA3MTIuXG4gICAgICogQHBhcmFtIHJlcSAtIFRoZSBvcmlnaW5hbCByZXF1ZXN0IG9iamVjdCBwb3NzaWJseSBjb250YWluaW5nIHRoZSBvcmlnaW4uXG4gICAgICogQHJldHVybnMgVGhlIGlkIG9mIHRoZSBuZXdseSBjcmVhdGVkIFR5cGVkTWVzc2FnZS5cbiAgICAgKi9cbiAgICBhZGRVbmFwcHJvdmVkTWVzc2FnZShtZXNzYWdlUGFyYW1zLCB2ZXJzaW9uLCByZXEpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZUlkID0gdXVpZF8xLnYxKCk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VQYXJhbXNNZXRhbWFzayA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWVzc2FnZVBhcmFtcyksIHsgbWV0YW1hc2tJZDogbWVzc2FnZUlkLCB2ZXJzaW9uIH0pO1xuICAgICAgICBpZiAocmVxKSB7XG4gICAgICAgICAgICBtZXNzYWdlUGFyYW1zLm9yaWdpbiA9IHJlcS5vcmlnaW47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZURhdGEgPSB7XG4gICAgICAgICAgICBpZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyxcbiAgICAgICAgICAgIHN0YXR1czogJ3VuYXBwcm92ZWQnLFxuICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHR5cGU6ICdldGhfc2lnblR5cGVkRGF0YScsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkTWVzc2FnZShtZXNzYWdlRGF0YSk7XG4gICAgICAgIHRoaXMuaHViLmVtaXQoYHVuYXBwcm92ZWRNZXNzYWdlYCwgbWVzc2FnZVBhcmFtc01ldGFtYXNrKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIFR5cGVkTWVzc2FnZSBzdGF0dXMgdG8gJ2Vycm9yZWQnIHZpYSBhIGNhbGwgdG8gdGhpcy5zZXRNZXNzYWdlU3RhdHVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VJZCAtIFRoZSBpZCBvZiB0aGUgVHlwZWRNZXNzYWdlIHRvIGVycm9yLlxuICAgICAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciB0byBiZSBpbmNsdWRlZCBpbiBUeXBlZE1lc3NhZ2UuXG4gICAgICovXG4gICAgc2V0TWVzc2FnZVN0YXR1c0Vycm9yZWQobWVzc2FnZUlkLCBlcnJvcikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5nZXRNZXNzYWdlKG1lc3NhZ2VJZCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMudXBkYXRlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5zZXRNZXNzYWdlU3RhdHVzKG1lc3NhZ2VJZCwgJ2Vycm9yZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgbWV0YW1hc2tJZCBhbmQgdmVyc2lvbiBwcm9wZXJ0aWVzIGZyb20gcGFzc2VkIG1lc3NhZ2VQYXJhbXMgYW5kIHJldHVybnMgYSBwcm9taXNlIHdoaWNoXG4gICAgICogcmVzb2x2ZXMgdGhlIHVwZGF0ZWQgbWVzc2FnZVBhcmFtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlUGFyYW1zIC0gVGhlIG1lc3NhZ2VQYXJhbXMgdG8gbW9kaWZ5LlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBtZXNzYWdlUGFyYW1zIHdpdGggdGhlIG1ldGFtYXNrSWQgYW5kIHZlcnNpb24gcHJvcGVydGllcyByZW1vdmVkLlxuICAgICAqL1xuICAgIHByZXBNZXNzYWdlRm9yU2lnbmluZyhtZXNzYWdlUGFyYW1zKSB7XG4gICAgICAgIGRlbGV0ZSBtZXNzYWdlUGFyYW1zLm1ldGFtYXNrSWQ7XG4gICAgICAgIGRlbGV0ZSBtZXNzYWdlUGFyYW1zLnZlcnNpb247XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWVzc2FnZVBhcmFtcyk7XG4gICAgfVxufVxuZXhwb3J0cy5UeXBlZE1lc3NhZ2VNYW5hZ2VyID0gVHlwZWRNZXNzYWdlTWFuYWdlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IFR5cGVkTWVzc2FnZU1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UeXBlZE1lc3NhZ2VNYW5hZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRva2VuQmFsYW5jZXNDb250cm9sbGVyID0gZXhwb3J0cy5CTiA9IHZvaWQgMDtcbmNvbnN0IGV0aGVyZXVtanNfdXRpbF8xID0gcmVxdWlyZShcImV0aGVyZXVtanMtdXRpbFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJOXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldGhlcmV1bWpzX3V0aWxfMS5CTjsgfSB9KTtcbmNvbnN0IEJhc2VDb250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vQmFzZUNvbnRyb2xsZXJcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbi8qKlxuICogQ29udHJvbGxlciB0aGF0IHBhc3NpdmVseSBwb2xscyBvbiBhIHNldCBpbnRlcnZhbCB0b2tlbiBiYWxhbmNlc1xuICogZm9yIHRva2VucyBzdG9yZWQgaW4gdGhlIFRva2Vuc0NvbnRyb2xsZXJcbiAqL1xuY2xhc3MgVG9rZW5CYWxhbmNlc0NvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlcl8xLkJhc2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVG9rZW5CYWxhbmNlc0NvbnRyb2xsZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBjb250cm9sbGVyIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMub25Ub2tlbnNTdGF0ZUNoYW5nZSAtIEFsbG93cyBzdWJzY3JpYmluZyB0byBhc3NldHMgY29udHJvbGxlciBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldFNlbGVjdGVkQWRkcmVzcyAtIEdldHMgdGhlIGN1cnJlbnQgc2VsZWN0ZWQgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRFUkMyMEJhbGFuY2VPZiAtIEdldHMgdGhlIGJhbGFuY2Ugb2YgdGhlIGdpdmVuIGFjY291bnQgYXQgdGhlIGdpdmVuIGNvbnRyYWN0IGFkZHJlc3MuXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIEluaXRpYWwgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICogQHBhcmFtIHN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgb25Ub2tlbnNTdGF0ZUNoYW5nZSwgZ2V0U2VsZWN0ZWRBZGRyZXNzLCBnZXRFUkMyMEJhbGFuY2VPZiwgfSwgY29uZmlnLCBzdGF0ZSkge1xuICAgICAgICBzdXBlcihjb25maWcsIHN0YXRlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhpcyBjb250cm9sbGVyIHVzZWQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnVG9rZW5CYWxhbmNlc0NvbnRyb2xsZXInO1xuICAgICAgICB0aGlzLmRlZmF1bHRDb25maWcgPSB7XG4gICAgICAgICAgICBpbnRlcnZhbDogMTgwMDAwLFxuICAgICAgICAgICAgdG9rZW5zOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7IGNvbnRyYWN0QmFsYW5jZXM6IHt9IH07XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICBvblRva2Vuc1N0YXRlQ2hhbmdlKCh7IHRva2VucyB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZSh7IHRva2VucyB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQmFsYW5jZXMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZ2V0U2VsZWN0ZWRBZGRyZXNzID0gZ2V0U2VsZWN0ZWRBZGRyZXNzO1xuICAgICAgICB0aGlzLmdldEVSQzIwQmFsYW5jZU9mID0gZ2V0RVJDMjBCYWxhbmNlT2Y7XG4gICAgICAgIHRoaXMucG9sbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgYSBuZXcgcG9sbGluZyBpbnRlcnZhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnRlcnZhbCAtIFBvbGxpbmcgaW50ZXJ2YWwgdXNlZCB0byBmZXRjaCBuZXcgdG9rZW4gYmFsYW5jZXMuXG4gICAgICovXG4gICAgcG9sbChpbnRlcnZhbCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaW50ZXJ2YWwgJiYgdGhpcy5jb25maWd1cmUoeyBpbnRlcnZhbCB9LCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGUgJiYgY2xlYXJUaW1lb3V0KHRoaXMuaGFuZGxlKTtcbiAgICAgICAgICAgIHlpZWxkIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IHRoaXMudXBkYXRlQmFsYW5jZXMoKSk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucG9sbCh0aGlzLmNvbmZpZy5pbnRlcnZhbCk7XG4gICAgICAgICAgICB9LCB0aGlzLmNvbmZpZy5pbnRlcnZhbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGJhbGFuY2VzIGZvciBhbGwgdG9rZW5zLlxuICAgICAqL1xuICAgIHVwZGF0ZUJhbGFuY2VzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHRva2VucyB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICBjb25zdCBuZXdDb250cmFjdEJhbGFuY2VzID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGkgaW4gdG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhZGRyZXNzIH0gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udHJhY3RCYWxhbmNlc1thZGRyZXNzXSA9IHlpZWxkIHRoaXMuZ2V0RVJDMjBCYWxhbmNlT2YoYWRkcmVzcywgdGhpcy5nZXRTZWxlY3RlZEFkZHJlc3MoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vuc1tpXS5iYWxhbmNlRXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udHJhY3RCYWxhbmNlc1thZGRyZXNzXSA9IG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTigwKTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zW2ldLmJhbGFuY2VFcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgY29udHJhY3RCYWxhbmNlczogbmV3Q29udHJhY3RCYWxhbmNlcyB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ub2tlbkJhbGFuY2VzQ29udHJvbGxlciA9IFRva2VuQmFsYW5jZXNDb250cm9sbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gVG9rZW5CYWxhbmNlc0NvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ub2tlbkJhbGFuY2VzQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db2xsZWN0aWJsZXNDb250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgZXRoZXJldW1qc191dGlsXzEgPSByZXF1aXJlKFwiZXRoZXJldW1qcy11dGlsXCIpO1xuY29uc3QgYXN5bmNfbXV0ZXhfMSA9IHJlcXVpcmUoXCJhc3luYy1tdXRleFwiKTtcbmNvbnN0IEJhc2VDb250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vQmFzZUNvbnRyb2xsZXJcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbmNvbnN0IGFzc2V0c1V0aWxfMSA9IHJlcXVpcmUoXCIuL2Fzc2V0c1V0aWxcIik7XG5jb25zdCBBTExfQ09MTEVDVElCTEVTX1NUQVRFX0tFWSA9ICdhbGxDb2xsZWN0aWJsZXMnO1xuY29uc3QgQUxMX0NPTExFQ1RJQkxFU19DT05UUkFDVFNfU1RBVEVfS0VZID0gJ2FsbENvbGxlY3RpYmxlQ29udHJhY3RzJztcbi8qKlxuICogQ29udHJvbGxlciB0aGF0IHN0b3JlcyBhc3NldHMgYW5kIGV4cG9zZXMgY29udmVuaWVuY2UgbWV0aG9kc1xuICovXG5jbGFzcyBDb2xsZWN0aWJsZXNDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIENvbGxlY3RpYmxlc0NvbnRyb2xsZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBjb250cm9sbGVyIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMub25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlIC0gQWxsb3dzIHN1YnNjcmliaW5nIHRvIHByZWZlcmVuY2UgY29udHJvbGxlciBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm9uTmV0d29ya1N0YXRlQ2hhbmdlIC0gQWxsb3dzIHN1YnNjcmliaW5nIHRvIG5ldHdvcmsgY29udHJvbGxlciBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldEVSQzcyMUFzc2V0TmFtZSAtIEdldHMgdGhlIG5hbWUgb2YgdGhlIGFzc2V0IGF0IHRoZSBnaXZlbiBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldEVSQzcyMUFzc2V0U3ltYm9sIC0gR2V0cyB0aGUgc3ltYm9sIG9mIHRoZSBhc3NldCBhdCB0aGUgZ2l2ZW4gYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRFUkM3MjFUb2tlblVSSSAtIEdldHMgdGhlIFVSSSBvZiB0aGUgRVJDNzIxIHRva2VuIGF0IHRoZSBnaXZlbiBhZGRyZXNzLCB3aXRoIHRoZSBnaXZlbiBJRC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRFUkM3MjFPd25lck9mIC0gR2V0IHRoZSBvd25lciBvZiBhIEVSQy03MjEgY29sbGVjdGlibGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2V0RVJDMTE1NUJhbGFuY2VPZiAtIEdldHMgYmFsYW5jZSBvZiBhIEVSQy0xMTU1IGNvbGxlY3RpYmxlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldEVSQzExNTVUb2tlblVSSSAtIEdldHMgdGhlIFVSSSBvZiB0aGUgRVJDMTE1NSB0b2tlbiBhdCB0aGUgZ2l2ZW4gYWRkcmVzcywgd2l0aCB0aGUgZ2l2ZW4gSUQuXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIEluaXRpYWwgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICogQHBhcmFtIHN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgb25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlLCBvbk5ldHdvcmtTdGF0ZUNoYW5nZSwgZ2V0RVJDNzIxQXNzZXROYW1lLCBnZXRFUkM3MjFBc3NldFN5bWJvbCwgZ2V0RVJDNzIxVG9rZW5VUkksIGdldEVSQzcyMU93bmVyT2YsIGdldEVSQzExNTVCYWxhbmNlT2YsIGdldEVSQzExNTVUb2tlblVSSSwgfSwgY29uZmlnLCBzdGF0ZSkge1xuICAgICAgICBzdXBlcihjb25maWcsIHN0YXRlKTtcbiAgICAgICAgdGhpcy5tdXRleCA9IG5ldyBhc3luY19tdXRleF8xLk11dGV4KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudEVtaXR0ZXIgaW5zdGFuY2UgdXNlZCB0byBsaXN0ZW4gdG8gc3BlY2lmaWMgRUlQNzQ3IGV2ZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5odWIgPSBuZXcgZXZlbnRzXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ0NvbGxlY3RpYmxlc0NvbnRyb2xsZXInO1xuICAgICAgICB0aGlzLmRlZmF1bHRDb25maWcgPSB7XG4gICAgICAgICAgICBuZXR3b3JrVHlwZTogY29uc3RhbnRzXzEuTUFJTk5FVCxcbiAgICAgICAgICAgIHNlbGVjdGVkQWRkcmVzczogJycsXG4gICAgICAgICAgICBjaGFpbklkOiAnJyxcbiAgICAgICAgICAgIGlwZnNHYXRld2F5OiBjb25zdGFudHNfMS5JUEZTX0RFRkFVTFRfR0FURVdBWV9VUkwsXG4gICAgICAgICAgICBvcGVuU2VhRW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICB1c2VJUEZTU3ViZG9tYWluczogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7XG4gICAgICAgICAgICBhbGxDb2xsZWN0aWJsZUNvbnRyYWN0czoge30sXG4gICAgICAgICAgICBhbGxDb2xsZWN0aWJsZXM6IHt9LFxuICAgICAgICAgICAgaWdub3JlZENvbGxlY3RpYmxlczogW10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB0aGlzLmdldEVSQzcyMUFzc2V0TmFtZSA9IGdldEVSQzcyMUFzc2V0TmFtZTtcbiAgICAgICAgdGhpcy5nZXRFUkM3MjFBc3NldFN5bWJvbCA9IGdldEVSQzcyMUFzc2V0U3ltYm9sO1xuICAgICAgICB0aGlzLmdldEVSQzcyMVRva2VuVVJJID0gZ2V0RVJDNzIxVG9rZW5VUkk7XG4gICAgICAgIHRoaXMuZ2V0RVJDNzIxT3duZXJPZiA9IGdldEVSQzcyMU93bmVyT2Y7XG4gICAgICAgIHRoaXMuZ2V0RVJDMTE1NUJhbGFuY2VPZiA9IGdldEVSQzExNTVCYWxhbmNlT2Y7XG4gICAgICAgIHRoaXMuZ2V0RVJDMTE1NVRva2VuVVJJID0gZ2V0RVJDMTE1NVRva2VuVVJJO1xuICAgICAgICBvblByZWZlcmVuY2VzU3RhdGVDaGFuZ2UoKHsgc2VsZWN0ZWRBZGRyZXNzLCBpcGZzR2F0ZXdheSwgb3BlblNlYUVuYWJsZWQgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmUoeyBzZWxlY3RlZEFkZHJlc3MsIGlwZnNHYXRld2F5LCBvcGVuU2VhRW5hYmxlZCB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uTmV0d29ya1N0YXRlQ2hhbmdlKCh7IHByb3ZpZGVyIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhaW5JZCB9ID0gcHJvdmlkZXI7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZSh7IGNoYWluSWQgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDb2xsZWN0aWJsZUFwaShjb250cmFjdEFkZHJlc3MsIHRva2VuSWQpIHtcbiAgICAgICAgY29uc3QgeyBjaGFpbklkIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgc3dpdGNoIChjaGFpbklkKSB7XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLlJJTktFQllfQ0hBSU5fSUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBodHRwczovL3Rlc3RuZXRzLWFwaS5vcGVuc2VhLmlvL2FwaS92MS9hc3NldC8ke2NvbnRyYWN0QWRkcmVzc30vJHt0b2tlbklkfWA7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBgaHR0cHM6Ly9hcGkub3BlbnNlYS5pby9hcGkvdjEvYXNzZXQvJHtjb250cmFjdEFkZHJlc3N9LyR7dG9rZW5JZH1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldENvbGxlY3RpYmxlQ29udHJhY3RJbmZvcm1hdGlvbkFwaShjb250cmFjdEFkZHJlc3MpIHtcbiAgICAgICAgY29uc3QgeyBjaGFpbklkIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgc3dpdGNoIChjaGFpbklkKSB7XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLlJJTktFQllfQ0hBSU5fSUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBodHRwczovL3Rlc3RuZXRzLWFwaS5vcGVuc2VhLmlvL2FwaS92MS9hc3NldF9jb250cmFjdC8ke2NvbnRyYWN0QWRkcmVzc31gO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYGh0dHBzOi8vYXBpLm9wZW5zZWEuaW8vYXBpL3YxL2Fzc2V0X2NvbnRyYWN0LyR7Y29udHJhY3RBZGRyZXNzfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byB1cGRhdGUgbmVzdGVkIHN0YXRlIGZvciBhbGxDb2xsZWN0aWJsZXMgYW5kIGFsbENvbGxlY3RpYmxlQ29udHJhY3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld0NvbGxlY3Rpb24gLSB0aGUgbW9kaWZpZWQgcGllY2Ugb2Ygc3RhdGUgdG8gdXBkYXRlIGluIHRoZSBjb250cm9sbGVyJ3Mgc3RvcmVcbiAgICAgKiBAcGFyYW0gYmFzZVN0YXRlS2V5IC0gVGhlIHJvb3Qga2V5IGluIHRoZSBzdG9yZSB0byB1cGRhdGUuXG4gICAgICogQHBhcmFtIHBhc3NlZENvbmZpZyAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBzZWxlY3RlZEFkZHJlc3MgYW5kIGNoYWluSWQgdGhhdCBhcmUgcGFzc2VkIHRocm91Z2ggdGhlIGF1dG8tZGV0ZWN0aW9uIGZsb3cuXG4gICAgICogQHBhcmFtIHBhc3NlZENvbmZpZy51c2VyQWRkcmVzcyAtIHRoZSBhZGRyZXNzIHBhc3NlZCB0aHJvdWdoIHRoZSBjb2xsZWN0aWJsZSBkZXRlY3Rpb24gZmxvdyB0byBlbnN1cmUgZGV0ZWN0ZWQgYXNzZXRzIGFyZSBzdG9yZWQgdG8gdGhlIGNvcnJlY3QgYWNjb3VudFxuICAgICAqIEBwYXJhbSBwYXNzZWRDb25maWcuY2hhaW5JZCAtIHRoZSBjaGFpbklkIHBhc3NlZCB0aHJvdWdoIHRoZSBjb2xsZWN0aWJsZSBkZXRlY3Rpb24gZmxvdyB0byBlbnN1cmUgZGV0ZWN0ZWQgYXNzZXRzIGFyZSBzdG9yZWQgdG8gdGhlIGNvcnJlY3QgYWNjb3VudFxuICAgICAqL1xuICAgIHVwZGF0ZU5lc3RlZENvbGxlY3RpYmxlU3RhdGUobmV3Q29sbGVjdGlvbiwgYmFzZVN0YXRlS2V5LCB7IHVzZXJBZGRyZXNzLCBjaGFpbklkIH0gPSB7XG4gICAgICAgIHVzZXJBZGRyZXNzOiB0aGlzLmNvbmZpZy5zZWxlY3RlZEFkZHJlc3MsXG4gICAgICAgIGNoYWluSWQ6IHRoaXMuY29uZmlnLmNoYWluSWQsXG4gICAgfSkge1xuICAgICAgICBjb25zdCB7IFtiYXNlU3RhdGVLZXldOiBvbGRTdGF0ZSB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgYWRkcmVzc1N0YXRlID0gb2xkU3RhdGVbdXNlckFkZHJlc3NdO1xuICAgICAgICBjb25zdCBuZXdBZGRyZXNzU3RhdGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFkZHJlc3NTdGF0ZSksIHsgW2NoYWluSWRdOiBuZXdDb2xsZWN0aW9uIH0pO1xuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb2xkU3RhdGUpLCB7IFt1c2VyQWRkcmVzc106IG5ld0FkZHJlc3NTdGF0ZSB9KTtcbiAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgW2Jhc2VTdGF0ZUtleV06IG5ld1N0YXRlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBpbmRpdmlkdWFsIGNvbGxlY3RpYmxlIGluZm9ybWF0aW9uIGZyb20gT3BlblNlYSBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIC0gSGV4IGFkZHJlc3Mgb2YgdGhlIGNvbGxlY3RpYmxlIGNvbnRyYWN0LlxuICAgICAqIEBwYXJhbSB0b2tlbklkIC0gVGhlIGNvbGxlY3RpYmxlIGlkZW50aWZpZXIuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGN1cnJlbnQgY29sbGVjdGlibGUgbmFtZSBhbmQgaW1hZ2UuXG4gICAgICovXG4gICAgZ2V0Q29sbGVjdGlibGVJbmZvcm1hdGlvbkZyb21BcGkoY29udHJhY3RBZGRyZXNzLCB0b2tlbklkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlblVSSSA9IHRoaXMuZ2V0Q29sbGVjdGlibGVBcGkoY29udHJhY3RBZGRyZXNzLCB0b2tlbklkKTtcbiAgICAgICAgICAgIGxldCBjb2xsZWN0aWJsZUluZm9ybWF0aW9uO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5vcGVuU2VhQXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlibGVJbmZvcm1hdGlvbiA9IHlpZWxkIHV0aWxfMS5oYW5kbGVGZXRjaCh0b2tlblVSSSwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdYLUFQSS1LRVknOiB0aGlzLm9wZW5TZWFBcGlLZXkgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbGxlY3RpYmxlSW5mb3JtYXRpb24gPSB5aWVsZCB1dGlsXzEuaGFuZGxlRmV0Y2godG9rZW5VUkkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBudW1fc2FsZXMsIGJhY2tncm91bmRfY29sb3IsIGltYWdlX3VybCwgaW1hZ2VfcHJldmlld191cmwsIGltYWdlX3RodW1ibmFpbF91cmwsIGltYWdlX29yaWdpbmFsX3VybCwgYW5pbWF0aW9uX3VybCwgYW5pbWF0aW9uX29yaWdpbmFsX3VybCwgbmFtZSwgZGVzY3JpcHRpb24sIGV4dGVybmFsX2xpbmssIGNyZWF0b3IsIGxhc3Rfc2FsZSwgYXNzZXRfY29udHJhY3Q6IHsgc2NoZW1hX25hbWUgfSwgfSA9IGNvbGxlY3RpYmxlSW5mb3JtYXRpb247XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgY29uc3QgY29sbGVjdGlibGVNZXRhZGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIHsgbmFtZTogbmFtZSB8fCBudWxsIH0sIHsgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uIHx8IG51bGwgfSwgeyBpbWFnZTogaW1hZ2VfdXJsIHx8IG51bGwgfSwgY3JlYXRvciAmJiB7IGNyZWF0b3IgfSwgbnVtX3NhbGVzICYmIHsgbnVtYmVyT2ZTYWxlczogbnVtX3NhbGVzIH0sIGJhY2tncm91bmRfY29sb3IgJiYgeyBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRfY29sb3IgfSwgaW1hZ2VfcHJldmlld191cmwgJiYgeyBpbWFnZVByZXZpZXc6IGltYWdlX3ByZXZpZXdfdXJsIH0sIGltYWdlX3RodW1ibmFpbF91cmwgJiYgeyBpbWFnZVRodW1ibmFpbDogaW1hZ2VfdGh1bWJuYWlsX3VybCB9LCBpbWFnZV9vcmlnaW5hbF91cmwgJiYgeyBpbWFnZU9yaWdpbmFsOiBpbWFnZV9vcmlnaW5hbF91cmwgfSwgYW5pbWF0aW9uX3VybCAmJiB7IGFuaW1hdGlvbjogYW5pbWF0aW9uX3VybCB9LCBhbmltYXRpb25fb3JpZ2luYWxfdXJsICYmIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25PcmlnaW5hbDogYW5pbWF0aW9uX29yaWdpbmFsX3VybCxcbiAgICAgICAgICAgIH0sIGV4dGVybmFsX2xpbmsgJiYgeyBleHRlcm5hbExpbms6IGV4dGVybmFsX2xpbmsgfSwgbGFzdF9zYWxlICYmIHsgbGFzdFNhbGU6IGxhc3Rfc2FsZSB9LCBzY2hlbWFfbmFtZSAmJiB7IHN0YW5kYXJkOiBzY2hlbWFfbmFtZSB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aWJsZU1ldGFkYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBpbmRpdmlkdWFsIGNvbGxlY3RpYmxlIGluZm9ybWF0aW9uIGZyb20gY29udHJhY3RzIHRoYXQgZm9sbG93cyBNZXRhZGF0YSBJbnRlcmZhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIC0gSGV4IGFkZHJlc3Mgb2YgdGhlIGNvbGxlY3RpYmxlIGNvbnRyYWN0LlxuICAgICAqIEBwYXJhbSB0b2tlbklkIC0gVGhlIGNvbGxlY3RpYmxlIGlkZW50aWZpZXIuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGN1cnJlbnQgY29sbGVjdGlibGUgbmFtZSBhbmQgaW1hZ2UuXG4gICAgICovXG4gICAgZ2V0Q29sbGVjdGlibGVJbmZvcm1hdGlvbkZyb21Ub2tlblVSSShjb250cmFjdEFkZHJlc3MsIHRva2VuSWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaXBmc0dhdGV3YXksIHVzZUlQRlNTdWJkb21haW5zIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMuZ2V0Q29sbGVjdGlibGVVUklBbmRTdGFuZGFyZChjb250cmFjdEFkZHJlc3MsIHRva2VuSWQpO1xuICAgICAgICAgICAgbGV0IHRva2VuVVJJID0gcmVzdWx0WzBdO1xuICAgICAgICAgICAgY29uc3Qgc3RhbmRhcmQgPSByZXN1bHRbMV07XG4gICAgICAgICAgICBpZiAodG9rZW5VUkkuc3RhcnRzV2l0aCgnaXBmczovLycpKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5VUkkgPSB1dGlsXzEuZ2V0Rm9ybWF0dGVkSXBmc1VybChpcGZzR2F0ZXdheSwgdG9rZW5VUkksIHVzZUlQRlNTdWJkb21haW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqZWN0ID0geWllbGQgdXRpbF8xLmhhbmRsZUZldGNoKHRva2VuVVJJKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBDaGVjayBpbWFnZV91cmwgZXhpc3RlbmNlLiBUaGlzIGlzIG5vdCBwYXJ0IG9mIEVJUDcyMSBub3IgRUlQMTE1NVxuICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ2ltYWdlJylcbiAgICAgICAgICAgICAgICAgICAgPyAnaW1hZ2UnXG4gICAgICAgICAgICAgICAgICAgIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gJ2ltYWdlX3VybCc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IG9iamVjdFtpbWFnZV0sXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG9iamVjdC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogb2JqZWN0LmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzdGFuZGFyZCxcbiAgICAgICAgICAgICAgICAgICAgZmF2b3JpdGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN0YW5kYXJkOiBzdGFuZGFyZCB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICBmYXZvcml0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGNvbGxlY3RpYmxlIHVyaSB3aXRoICBtZXRhZGF0YS4gVE9ETyBVcGRhdGUgbWV0aG9kIHRvIHVzZSBJUEZTLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIENvbGxlY3RpYmxlIGNvbnRyYWN0IGFkZHJlc3MuXG4gICAgICogQHBhcmFtIHRva2VuSWQgLSBDb2xsZWN0aWJsZSB0b2tlbiBpZC5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyBjb2xsZWN0aWJsZSB1cmkgYW5kIHRva2VuIHN0YW5kYXJkLlxuICAgICAqL1xuICAgIGdldENvbGxlY3RpYmxlVVJJQW5kU3RhbmRhcmQoY29udHJhY3RBZGRyZXNzLCB0b2tlbklkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyB0cnkgRVJDNzIxIHVyaVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmkgPSB5aWVsZCB0aGlzLmdldEVSQzcyMVRva2VuVVJJKGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt1cmksIGNvbnN0YW50c18xLkVSQzcyMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRyeSBFUkMxMTU1IHVyaVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlblVSSSA9IHlpZWxkIHRoaXMuZ2V0RVJDMTE1NVRva2VuVVJJKGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCk7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQWNjb3JkaW5nIHRvIEVJUDExNTUgdGhlIFVSSSB2YWx1ZSBhbGxvd3MgZm9yIElEIHN1YnN0aXR1dGlvblxuICAgICAgICAgICAgICAgICAqIGluIGNhc2UgdGhlIHN0cmluZyBge2lkfWAgZXhpc3RzLlxuICAgICAgICAgICAgICAgICAqIGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTE1NSNtZXRhZGF0YVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW5VUkkuaW5jbHVkZXMoJ3tpZH0nKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3Rva2VuVVJJLCBjb25zdGFudHNfMS5FUkMxMTU1XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaGV4VG9rZW5JZCA9IGV0aGVyZXVtanNfdXRpbF8xLnN0cmlwSGV4UHJlZml4KHV0aWxfMS5CTlRvSGV4KG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTih0b2tlbklkKSkpXG4gICAgICAgICAgICAgICAgICAgIC5wYWRTdGFydCg2NCwgJzAnKVxuICAgICAgICAgICAgICAgICAgICAudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3Rva2VuVVJJLnJlcGxhY2UoJ3tpZH0nLCBoZXhUb2tlbklkKSwgY29uc3RhbnRzXzEuRVJDMTE1NV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2IpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbJycsICcnXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgaW5kaXZpZHVhbCBjb2xsZWN0aWJsZSBpbmZvcm1hdGlvbiAobmFtZSwgaW1hZ2UgdXJsIGFuZCBkZXNjcmlwdGlvbikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIC0gSGV4IGFkZHJlc3Mgb2YgdGhlIGNvbGxlY3RpYmxlIGNvbnRyYWN0LlxuICAgICAqIEBwYXJhbSB0b2tlbklkIC0gVGhlIGNvbGxlY3RpYmxlIGlkZW50aWZpZXIuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGN1cnJlbnQgY29sbGVjdGlibGUgbmFtZSBhbmQgaW1hZ2UuXG4gICAgICovXG4gICAgZ2V0Q29sbGVjdGlibGVJbmZvcm1hdGlvbihjb250cmFjdEFkZHJlc3MsIHRva2VuSWQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrY2hhaW5NZXRhZGF0YSA9IHlpZWxkIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5nZXRDb2xsZWN0aWJsZUluZm9ybWF0aW9uRnJvbVRva2VuVVJJKGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBsZXQgb3BlblNlYU1ldGFkYXRhO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLm9wZW5TZWFFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgb3BlblNlYU1ldGFkYXRhID0geWllbGQgdXRpbF8xLnNhZmVseUV4ZWN1dGUoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5nZXRDb2xsZWN0aWJsZUluZm9ybWF0aW9uRnJvbUFwaShjb250cmFjdEFkZHJlc3MsIHRva2VuSWQpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wZW5TZWFNZXRhZGF0YSksIHsgbmFtZTogKF9iID0gKF9hID0gYmxvY2tjaGFpbk1ldGFkYXRhLm5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG9wZW5TZWFNZXRhZGF0YSA9PT0gbnVsbCB8fCBvcGVuU2VhTWV0YWRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wZW5TZWFNZXRhZGF0YS5uYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsLCBkZXNjcmlwdGlvbjogKF9kID0gKF9jID0gYmxvY2tjaGFpbk1ldGFkYXRhLmRlc2NyaXB0aW9uKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBvcGVuU2VhTWV0YWRhdGEgPT09IG51bGwgfHwgb3BlblNlYU1ldGFkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcGVuU2VhTWV0YWRhdGEuZGVzY3JpcHRpb24pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IG51bGwsIGltYWdlOiAoX2YgPSAoX2UgPSBibG9ja2NoYWluTWV0YWRhdGEuaW1hZ2UpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IG9wZW5TZWFNZXRhZGF0YSA9PT0gbnVsbCB8fCBvcGVuU2VhTWV0YWRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wZW5TZWFNZXRhZGF0YS5pbWFnZSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogbnVsbCwgc3RhbmRhcmQ6IChfaCA9IChfZyA9IGJsb2NrY2hhaW5NZXRhZGF0YS5zdGFuZGFyZCkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogb3BlblNlYU1ldGFkYXRhID09PSBudWxsIHx8IG9wZW5TZWFNZXRhZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3BlblNlYU1ldGFkYXRhLnN0YW5kYXJkKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiBudWxsIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBjb2xsZWN0aWJsZSBjb250cmFjdCBpbmZvcm1hdGlvbiBmcm9tIE9wZW5TZWEgQVBJLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIEhleCBhZGRyZXNzIG9mIHRoZSBjb2xsZWN0aWJsZSBjb250cmFjdC5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3VycmVudCBjb2xsZWN0aWJsZSBuYW1lIGFuZCBpbWFnZS5cbiAgICAgKi9cbiAgICBnZXRDb2xsZWN0aWJsZUNvbnRyYWN0SW5mb3JtYXRpb25Gcm9tQXBpKGNvbnRyYWN0QWRkcmVzcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYXBpID0gdGhpcy5nZXRDb2xsZWN0aWJsZUNvbnRyYWN0SW5mb3JtYXRpb25BcGkoY29udHJhY3RBZGRyZXNzKTtcbiAgICAgICAgICAgIGxldCBhcGlDb2xsZWN0aWJsZUNvbnRyYWN0T2JqZWN0O1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5vcGVuU2VhQXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgYXBpQ29sbGVjdGlibGVDb250cmFjdE9iamVjdCA9IHlpZWxkIHV0aWxfMS5oYW5kbGVGZXRjaChhcGksIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogeyAnWC1BUEktS0VZJzogdGhpcy5vcGVuU2VhQXBpS2V5IH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcGlDb2xsZWN0aWJsZUNvbnRyYWN0T2JqZWN0ID0geWllbGQgdXRpbF8xLmhhbmRsZUZldGNoKGFwaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXBpQ29sbGVjdGlibGVDb250cmFjdE9iamVjdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgY29sbGVjdGlibGUgY29udHJhY3QgaW5mb3JtYXRpb24gZnJvbSB0aGUgY29udHJhY3QgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIEhleCBhZGRyZXNzIG9mIHRoZSBjb2xsZWN0aWJsZSBjb250cmFjdC5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3VycmVudCBjb2xsZWN0aWJsZSBuYW1lIGFuZCBpbWFnZS5cbiAgICAgKi9cbiAgICBnZXRDb2xsZWN0aWJsZUNvbnRyYWN0SW5mb3JtYXRpb25Gcm9tQ29udHJhY3QoY29udHJhY3RBZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0geWllbGQgdGhpcy5nZXRFUkM3MjFBc3NldE5hbWUoY29udHJhY3RBZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IHN5bWJvbCA9IHlpZWxkIHRoaXMuZ2V0RVJDNzIxQXNzZXRTeW1ib2woY29udHJhY3RBZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbjogeyBuYW1lIH0sXG4gICAgICAgICAgICAgICAgc3ltYm9sLFxuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGNvbGxlY3RpYmxlIGNvbnRyYWN0IGluZm9ybWF0aW9uIGZyb20gT3BlblNlYSBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIC0gSGV4IGFkZHJlc3Mgb2YgdGhlIGNvbGxlY3RpYmxlIGNvbnRyYWN0LlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjb2xsZWN0aWJsZSBjb250cmFjdCBuYW1lLCBpbWFnZSBhbmQgZGVzY3JpcHRpb24uXG4gICAgICovXG4gICAgZ2V0Q29sbGVjdGlibGVDb250cmFjdEluZm9ybWF0aW9uKGNvbnRyYWN0QWRkcmVzcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2tjaGFpbkNvbnRyYWN0RGF0YSA9IHlpZWxkIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5nZXRDb2xsZWN0aWJsZUNvbnRyYWN0SW5mb3JtYXRpb25Gcm9tQ29udHJhY3QoY29udHJhY3RBZGRyZXNzKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGxldCBvcGVuU2VhQ29udHJhY3REYXRhO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLm9wZW5TZWFFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgb3BlblNlYUNvbnRyYWN0RGF0YSA9IHlpZWxkIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZ2V0Q29sbGVjdGlibGVDb250cmFjdEluZm9ybWF0aW9uRnJvbUFwaShjb250cmFjdEFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChibG9ja2NoYWluQ29udHJhY3REYXRhIHx8IG9wZW5TZWFDb250cmFjdERhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wZW5TZWFDb250cmFjdERhdGEpLCBibG9ja2NoYWluQ29udHJhY3REYXRhKSwgeyBjb2xsZWN0aW9uOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBpbWFnZV91cmw6IG51bGwgfSwgb3BlblNlYUNvbnRyYWN0RGF0YSA9PT0gbnVsbCB8fCBvcGVuU2VhQ29udHJhY3REYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcGVuU2VhQ29udHJhY3REYXRhLmNvbGxlY3Rpb24pLCBibG9ja2NoYWluQ29udHJhY3REYXRhID09PSBudWxsIHx8IGJsb2NrY2hhaW5Db250cmFjdERhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJsb2NrY2hhaW5Db250cmFjdERhdGEuY29sbGVjdGlvbikgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBjb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgYXNzZXRfY29udHJhY3RfdHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgICBjcmVhdGVkX2RhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgc2NoZW1hX25hbWU6IG51bGwsXG4gICAgICAgICAgICAgICAgc3ltYm9sOiBudWxsLFxuICAgICAgICAgICAgICAgIHRvdGFsX3N1cHBseTogbnVsbCxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICBleHRlcm5hbF9saW5rOiBudWxsLFxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb246IHsgbmFtZTogbnVsbCwgaW1hZ2VfdXJsOiBudWxsIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBpbmRpdmlkdWFsIGNvbGxlY3RpYmxlIHRvIHRoZSBzdG9yZWQgY29sbGVjdGlibGUgbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gSGV4IGFkZHJlc3Mgb2YgdGhlIGNvbGxlY3RpYmxlIGNvbnRyYWN0LlxuICAgICAqIEBwYXJhbSB0b2tlbklkIC0gVGhlIGNvbGxlY3RpYmxlIGlkZW50aWZpZXIuXG4gICAgICogQHBhcmFtIGNvbGxlY3RpYmxlTWV0YWRhdGEgLSBDb2xsZWN0aWJsZSBvcHRpb25hbCBpbmZvcm1hdGlvbiAobmFtZSwgaW1hZ2UgYW5kIGRlc2NyaXB0aW9uKS5cbiAgICAgKiBAcGFyYW0gZGV0ZWN0aW9uIC0gVGhlIGNoYWluIElEIGFuZCBhZGRyZXNzIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbmV0d29yayBhbmQgYWNjb3VudCBhdCB0aGUgbW9tZW50IHRoZSBjb2xsZWN0aWJsZSB3YXMgZGV0ZWN0ZWQuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGN1cnJlbnQgY29sbGVjdGlibGUgbGlzdC5cbiAgICAgKi9cbiAgICBhZGRJbmRpdmlkdWFsQ29sbGVjdGlibGUoYWRkcmVzcywgdG9rZW5JZCwgY29sbGVjdGlibGVNZXRhZGF0YSwgZGV0ZWN0aW9uKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSB1bnVzZWQgcmV0dXJuXG4gICAgICAgICAgICBjb25zdCByZWxlYXNlTG9jayA9IHlpZWxkIHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYWxsQ29sbGVjdGlibGVzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgICAgIGxldCBjaGFpbklkLCBzZWxlY3RlZEFkZHJlc3M7XG4gICAgICAgICAgICAgICAgaWYgKGRldGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjaGFpbklkID0gZGV0ZWN0aW9uLmNoYWluSWQ7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkQWRkcmVzcyA9IGRldGVjdGlvbi51c2VyQWRkcmVzcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQgPSB0aGlzLmNvbmZpZy5jaGFpbklkO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEFkZHJlc3MgPSB0aGlzLmNvbmZpZy5zZWxlY3RlZEFkZHJlc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxlY3RpYmxlcyA9ICgoX2EgPSBhbGxDb2xsZWN0aWJsZXNbc2VsZWN0ZWRBZGRyZXNzXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2NoYWluSWRdKSB8fCBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ0VudHJ5ID0gY29sbGVjdGlibGVzLmZpbmQoKGNvbGxlY3RpYmxlKSA9PiBjb2xsZWN0aWJsZS5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSAmJlxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aWJsZS50b2tlbklkID09PSB0b2tlbklkKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWZmZXJlbnRNZXRhZGF0YSA9IGFzc2V0c1V0aWxfMS5jb21wYXJlQ29sbGVjdGlibGVzTWV0YWRhdGEoY29sbGVjdGlibGVNZXRhZGF0YSwgZXhpc3RpbmdFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaWZmZXJlbnRNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogU3dpdGNoIHRvIGluZGV4VG9VcGRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4VG9SZW1vdmUgPSBjb2xsZWN0aWJsZXMuZmluZEluZGV4KChjb2xsZWN0aWJsZSkgPT4gY29sbGVjdGlibGUuYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aWJsZS50b2tlbklkID09PSB0b2tlbklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXhUb1JlbW92ZSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aWJsZXMuc3BsaWNlKGluZGV4VG9SZW1vdmUsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RpYmxlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdFbnRyeSA9IE9iamVjdC5hc3NpZ24oeyBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbklkLCBmYXZvcml0ZTogKGV4aXN0aW5nRW50cnkgPT09IG51bGwgfHwgZXhpc3RpbmdFbnRyeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhpc3RpbmdFbnRyeS5mYXZvcml0ZSkgfHwgZmFsc2UsIGlzQ3VycmVudGx5T3duZWQ6IHRydWUgfSwgY29sbGVjdGlibGVNZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Q29sbGVjdGlibGVzID0gWy4uLmNvbGxlY3RpYmxlcywgbmV3RW50cnldO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTmVzdGVkQ29sbGVjdGlibGVTdGF0ZShuZXdDb2xsZWN0aWJsZXMsIEFMTF9DT0xMRUNUSUJMRVNfU1RBVEVfS0VZLCB7IGNoYWluSWQsIHVzZXJBZGRyZXNzOiBzZWxlY3RlZEFkZHJlc3MgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0NvbGxlY3RpYmxlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgY29sbGVjdGlibGUgY29udHJhY3QgdG8gdGhlIHN0b3JlZCBjb2xsZWN0aWJsZSBjb250cmFjdHMgbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gSGV4IGFkZHJlc3Mgb2YgdGhlIGNvbGxlY3RpYmxlIGNvbnRyYWN0LlxuICAgICAqIEBwYXJhbSBkZXRlY3Rpb24gLSBUaGUgY2hhaW4gSUQgYW5kIGFkZHJlc3Mgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBuZXR3b3JrIGFuZCBhY2NvdW50IGF0IHRoZSBtb21lbnQgdGhlIGNvbGxlY3RpYmxlIHdhcyBkZXRlY3RlZC5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3VycmVudCBjb2xsZWN0aWJsZSBjb250cmFjdHMgbGlzdC5cbiAgICAgKi9cbiAgICBhZGRDb2xsZWN0aWJsZUNvbnRyYWN0KGFkZHJlc3MsIGRldGVjdGlvbikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZWxlYXNlTG9jayA9IHlpZWxkIHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYWxsQ29sbGVjdGlibGVDb250cmFjdHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICAgICAgbGV0IGNoYWluSWQsIHNlbGVjdGVkQWRkcmVzcztcbiAgICAgICAgICAgICAgICBpZiAoZGV0ZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQgPSBkZXRlY3Rpb24uY2hhaW5JZDtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRBZGRyZXNzID0gZGV0ZWN0aW9uLnVzZXJBZGRyZXNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZCA9IHRoaXMuY29uZmlnLmNoYWluSWQ7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkQWRkcmVzcyA9IHRoaXMuY29uZmlnLnNlbGVjdGVkQWRkcmVzcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGlibGVDb250cmFjdHMgPSAoKF9hID0gYWxsQ29sbGVjdGlibGVDb250cmFjdHNbc2VsZWN0ZWRBZGRyZXNzXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2NoYWluSWRdKSB8fCBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ0VudHJ5ID0gY29sbGVjdGlibGVDb250cmFjdHMuZmluZCgoY29sbGVjdGlibGVDb250cmFjdCkgPT4gY29sbGVjdGlibGVDb250cmFjdC5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RpYmxlQ29udHJhY3RzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb250cmFjdEluZm9ybWF0aW9uID0geWllbGQgdGhpcy5nZXRDb2xsZWN0aWJsZUNvbnRyYWN0SW5mb3JtYXRpb24oYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhc3NldF9jb250cmFjdF90eXBlLCBjcmVhdGVkX2RhdGUsIHNjaGVtYV9uYW1lLCBzeW1ib2wsIHRvdGFsX3N1cHBseSwgZGVzY3JpcHRpb24sIGV4dGVybmFsX2xpbmssIGNvbGxlY3Rpb246IHsgbmFtZSwgaW1hZ2VfdXJsIH0sIH0gPSBjb250cmFjdEluZm9ybWF0aW9uO1xuICAgICAgICAgICAgICAgIC8vIElmIGJlaW5nIGF1dG8tZGV0ZWN0ZWQgb3BlbnNlYSBpbmZvcm1hdGlvbiBpcyBleHBlY3RlZFxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBhdCBsZWFzdCBuYW1lIGFuZCBzeW1ib2wgZnJvbSBjb250cmFjdCBpcyBuZWVkZWRcbiAgICAgICAgICAgICAgICBpZiAoKGRldGVjdGlvbiAmJiAhbmFtZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoY29udHJhY3RJbmZvcm1hdGlvbikubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aWJsZUNvbnRyYWN0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdFbnRyeSA9IE9iamVjdC5hc3NpZ24oe30sIHsgYWRkcmVzcyB9LCBkZXNjcmlwdGlvbiAmJiB7IGRlc2NyaXB0aW9uIH0sIG5hbWUgJiYgeyBuYW1lIH0sIGltYWdlX3VybCAmJiB7IGxvZ286IGltYWdlX3VybCB9LCBzeW1ib2wgJiYgeyBzeW1ib2wgfSwgdG90YWxfc3VwcGx5ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0b3RhbF9zdXBwbHkgIT09ICd1bmRlZmluZWQnICYmIHsgdG90YWxTdXBwbHk6IHRvdGFsX3N1cHBseSB9LCBhc3NldF9jb250cmFjdF90eXBlICYmIHsgYXNzZXRDb250cmFjdFR5cGU6IGFzc2V0X2NvbnRyYWN0X3R5cGUgfSwgY3JlYXRlZF9kYXRlICYmIHsgY3JlYXRlZERhdGU6IGNyZWF0ZWRfZGF0ZSB9LCBzY2hlbWFfbmFtZSAmJiB7IHNjaGVtYU5hbWU6IHNjaGVtYV9uYW1lIH0sIGV4dGVybmFsX2xpbmsgJiYgeyBleHRlcm5hbExpbms6IGV4dGVybmFsX2xpbmsgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Q29sbGVjdGlibGVDb250cmFjdHMgPSBbLi4uY29sbGVjdGlibGVDb250cmFjdHMsIG5ld0VudHJ5XTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU5lc3RlZENvbGxlY3RpYmxlU3RhdGUobmV3Q29sbGVjdGlibGVDb250cmFjdHMsIEFMTF9DT0xMRUNUSUJMRVNfQ09OVFJBQ1RTX1NUQVRFX0tFWSwgeyBjaGFpbklkLCB1c2VyQWRkcmVzczogc2VsZWN0ZWRBZGRyZXNzIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdDb2xsZWN0aWJsZUNvbnRyYWN0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGluZGl2aWR1YWwgY29sbGVjdGlibGUgZnJvbSB0aGUgc3RvcmVkIHRva2VuIGxpc3QgYW5kIHNhdmVzIGl0IGluIGlnbm9yZWQgY29sbGVjdGlibGVzIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEhleCBhZGRyZXNzIG9mIHRoZSBjb2xsZWN0aWJsZSBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gdG9rZW5JZCAtIFRva2VuIGlkZW50aWZpZXIgb2YgdGhlIGNvbGxlY3RpYmxlLlxuICAgICAqL1xuICAgIHJlbW92ZUFuZElnbm9yZUluZGl2aWR1YWxDb2xsZWN0aWJsZShhZGRyZXNzLCB0b2tlbklkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgYWRkcmVzcyA9IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgY29uc3QgeyBhbGxDb2xsZWN0aWJsZXMsIGlnbm9yZWRDb2xsZWN0aWJsZXMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgY2hhaW5JZCwgc2VsZWN0ZWRBZGRyZXNzIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgY29uc3QgbmV3SWdub3JlZENvbGxlY3RpYmxlcyA9IFsuLi5pZ25vcmVkQ29sbGVjdGlibGVzXTtcbiAgICAgICAgY29uc3QgY29sbGVjdGlibGVzID0gKChfYSA9IGFsbENvbGxlY3RpYmxlc1tzZWxlY3RlZEFkZHJlc3NdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbY2hhaW5JZF0pIHx8IFtdO1xuICAgICAgICBjb25zdCBuZXdDb2xsZWN0aWJsZXMgPSBjb2xsZWN0aWJsZXMuZmlsdGVyKChjb2xsZWN0aWJsZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbGxlY3RpYmxlLmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpICYmXG4gICAgICAgICAgICAgICAgY29sbGVjdGlibGUudG9rZW5JZCA9PT0gdG9rZW5JZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFscmVhZHlJZ25vcmVkID0gbmV3SWdub3JlZENvbGxlY3RpYmxlcy5maW5kKChjKSA9PiBjLmFkZHJlc3MgPT09IGFkZHJlc3MgJiYgYy50b2tlbklkID09PSB0b2tlbklkKTtcbiAgICAgICAgICAgICAgICAhYWxyZWFkeUlnbm9yZWQgJiYgbmV3SWdub3JlZENvbGxlY3RpYmxlcy5wdXNoKGNvbGxlY3RpYmxlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlTmVzdGVkQ29sbGVjdGlibGVTdGF0ZShuZXdDb2xsZWN0aWJsZXMsIEFMTF9DT0xMRUNUSUJMRVNfU1RBVEVfS0VZKTtcbiAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgaWdub3JlZENvbGxlY3RpYmxlczogbmV3SWdub3JlZENvbGxlY3RpYmxlcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gaW5kaXZpZHVhbCBjb2xsZWN0aWJsZSBmcm9tIHRoZSBzdG9yZWQgdG9rZW4gbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gSGV4IGFkZHJlc3Mgb2YgdGhlIGNvbGxlY3RpYmxlIGNvbnRyYWN0LlxuICAgICAqIEBwYXJhbSB0b2tlbklkIC0gVG9rZW4gaWRlbnRpZmllciBvZiB0aGUgY29sbGVjdGlibGUuXG4gICAgICovXG4gICAgcmVtb3ZlSW5kaXZpZHVhbENvbGxlY3RpYmxlKGFkZHJlc3MsIHRva2VuSWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBhZGRyZXNzID0gdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBjb25zdCB7IGFsbENvbGxlY3RpYmxlcyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBjaGFpbklkLCBzZWxlY3RlZEFkZHJlc3MgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICBjb25zdCBjb2xsZWN0aWJsZXMgPSAoKF9hID0gYWxsQ29sbGVjdGlibGVzW3NlbGVjdGVkQWRkcmVzc10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtjaGFpbklkXSkgfHwgW107XG4gICAgICAgIGNvbnN0IG5ld0NvbGxlY3RpYmxlcyA9IGNvbGxlY3RpYmxlcy5maWx0ZXIoKGNvbGxlY3RpYmxlKSA9PiAhKGNvbGxlY3RpYmxlLmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpICYmXG4gICAgICAgICAgICBjb2xsZWN0aWJsZS50b2tlbklkID09PSB0b2tlbklkKSk7XG4gICAgICAgIHRoaXMudXBkYXRlTmVzdGVkQ29sbGVjdGlibGVTdGF0ZShuZXdDb2xsZWN0aWJsZXMsIEFMTF9DT0xMRUNUSUJMRVNfU1RBVEVfS0VZKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNvbGxlY3RpYmxlIGNvbnRyYWN0IHRvIHRoZSBzdG9yZWQgY29sbGVjdGlibGUgY29udHJhY3RzIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEhleCBhZGRyZXNzIG9mIHRoZSBjb2xsZWN0aWJsZSBjb250cmFjdC5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3VycmVudCBjb2xsZWN0aWJsZSBjb250cmFjdHMgbGlzdC5cbiAgICAgKi9cbiAgICByZW1vdmVDb2xsZWN0aWJsZUNvbnRyYWN0KGFkZHJlc3MpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBhZGRyZXNzID0gdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBjb25zdCB7IGFsbENvbGxlY3RpYmxlQ29udHJhY3RzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCB7IGNoYWluSWQsIHNlbGVjdGVkQWRkcmVzcyB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgIGNvbnN0IGNvbGxlY3RpYmxlQ29udHJhY3RzID0gKChfYSA9IGFsbENvbGxlY3RpYmxlQ29udHJhY3RzW3NlbGVjdGVkQWRkcmVzc10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtjaGFpbklkXSkgfHwgW107XG4gICAgICAgIGNvbnN0IG5ld0NvbGxlY3RpYmxlQ29udHJhY3RzID0gY29sbGVjdGlibGVDb250cmFjdHMuZmlsdGVyKChjb2xsZWN0aWJsZUNvbnRyYWN0KSA9PiAhKGNvbGxlY3RpYmxlQ29udHJhY3QuYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgdGhpcy51cGRhdGVOZXN0ZWRDb2xsZWN0aWJsZVN0YXRlKG5ld0NvbGxlY3RpYmxlQ29udHJhY3RzLCBBTExfQ09MTEVDVElCTEVTX0NPTlRSQUNUU19TVEFURV9LRVkpO1xuICAgICAgICByZXR1cm4gbmV3Q29sbGVjdGlibGVDb250cmFjdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYW4gT3BlblNlYSBBUEkga2V5IHRvIHJldHJpZXZlIGNvbGxlY3RpYmxlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wZW5TZWFBcGlLZXkgLSBPcGVuU2VhIEFQSSBrZXkuXG4gICAgICovXG4gICAgc2V0QXBpS2V5KG9wZW5TZWFBcGlLZXkpIHtcbiAgICAgICAgdGhpcy5vcGVuU2VhQXBpS2V5ID0gb3BlblNlYUFwaUtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoZSBvd25lcnNoaXAgb2YgYSBFUkMtNzIxIG9yIEVSQy0xMTU1IGNvbGxlY3RpYmxlIGZvciBhIGdpdmVuIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3duZXJBZGRyZXNzIC0gVXNlciBwdWJsaWMgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gY29sbGVjdGlibGVBZGRyZXNzIC0gQ29sbGVjdGlibGUgY29udHJhY3QgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gY29sbGVjdGlibGVJZCAtIENvbGxlY3RpYmxlIHRva2VuIElELlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRoZSBjb2xsZWN0aWJsZSBvd25lcnNoaXAuXG4gICAgICovXG4gICAgaXNDb2xsZWN0aWJsZU93bmVyKG93bmVyQWRkcmVzcywgY29sbGVjdGlibGVBZGRyZXNzLCBjb2xsZWN0aWJsZUlkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBDaGVja3MgdGhlIG93bmVyc2hpcCBmb3IgRVJDLTcyMS5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3duZXIgPSB5aWVsZCB0aGlzLmdldEVSQzcyMU93bmVyT2YoY29sbGVjdGlibGVBZGRyZXNzLCBjb2xsZWN0aWJsZUlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3duZXJBZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IG93bmVyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgRVJDLTcyMSBjb250cmFjdCBlcnJvclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2tzIHRoZSBvd25lcnNoaXAgZm9yIEVSQy0xMTU1LlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYWxhbmNlID0geWllbGQgdGhpcy5nZXRFUkMxMTU1QmFsYW5jZU9mKG93bmVyQWRkcmVzcywgY29sbGVjdGlibGVBZGRyZXNzLCBjb2xsZWN0aWJsZUlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFsYW5jZSA+IDA7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2IpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgRVJDLTExNTUgY29udHJhY3QgZXJyb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHZlcmlmeSBvd25lcnNoaXAuIFByb2JhYmx5IGJlY2F1c2UgdGhlIHN0YW5kYXJkIGlzIG5vdCBzdXBwb3J0ZWQgb3IgdGhlIGNoYWluIGlzIGluY29ycmVjdC4nKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGN1cnJlbnRseSBzZWxlY3RlZCBhZGRyZXNzIG93bnMgZW50ZXJlZCBjb2xsZWN0aWJsZSBhZGRyZXNzL3Rva2VuSWQgY29tYm8gYW5kXG4gICAgICogYWRkcyB0aGUgY29sbGVjdGlibGUgYW5kIHJlc3BlY3RpdmUgY29sbGVjdGlibGUgY29udHJhY3QgdG8gdGhlIHN0b3JlZCBjb2xsZWN0aWJsZSBhbmQgY29sbGVjdGlibGUgY29udHJhY3RzIGxpc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBIZXggYWRkcmVzcyBvZiB0aGUgY29sbGVjdGlibGUgY29udHJhY3QuXG4gICAgICogQHBhcmFtIHRva2VuSWQgLSBUaGUgY29sbGVjdGlibGUgaWRlbnRpZmllci5cbiAgICAgKi9cbiAgICBhZGRDb2xsZWN0aWJsZVZlcmlmeU93bmVyc2hpcChhZGRyZXNzLCB0b2tlbklkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNlbGVjdGVkQWRkcmVzcyB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICBpZiAoISh5aWVsZCB0aGlzLmlzQ29sbGVjdGlibGVPd25lcihzZWxlY3RlZEFkZHJlc3MsIGFkZHJlc3MsIHRva2VuSWQpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBjb2xsZWN0aWJsZSBpcyBub3Qgb3duZWQgYnkgdGhlIHVzZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIHRoaXMuYWRkQ29sbGVjdGlibGUoYWRkcmVzcywgdG9rZW5JZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgY29sbGVjdGlibGUgYW5kIHJlc3BlY3RpdmUgY29sbGVjdGlibGUgY29udHJhY3QgdG8gdGhlIHN0b3JlZCBjb2xsZWN0aWJsZSBhbmQgY29sbGVjdGlibGUgY29udHJhY3RzIGxpc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBIZXggYWRkcmVzcyBvZiB0aGUgY29sbGVjdGlibGUgY29udHJhY3QuXG4gICAgICogQHBhcmFtIHRva2VuSWQgLSBUaGUgY29sbGVjdGlibGUgaWRlbnRpZmllci5cbiAgICAgKiBAcGFyYW0gY29sbGVjdGlibGVNZXRhZGF0YSAtIENvbGxlY3RpYmxlIG9wdGlvbmFsIG1ldGFkYXRhLlxuICAgICAqIEBwYXJhbSBkZXRlY3Rpb24gLSBUaGUgY2hhaW4gSUQgYW5kIGFkZHJlc3Mgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBuZXR3b3JrIGFuZCBhY2NvdW50IGF0IHRoZSBtb21lbnQgdGhlIGNvbGxlY3RpYmxlIHdhcyBkZXRlY3RlZC5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3VycmVudCBjb2xsZWN0aWJsZSBsaXN0LlxuICAgICAqL1xuICAgIGFkZENvbGxlY3RpYmxlKGFkZHJlc3MsIHRva2VuSWQsIGNvbGxlY3RpYmxlTWV0YWRhdGEsIGRldGVjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgYWRkcmVzcyA9IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbGxlY3RpYmxlQ29udHJhY3RzID0geWllbGQgdGhpcy5hZGRDb2xsZWN0aWJsZUNvbnRyYWN0KGFkZHJlc3MsIGRldGVjdGlvbik7XG4gICAgICAgICAgICBjb2xsZWN0aWJsZU1ldGFkYXRhID1cbiAgICAgICAgICAgICAgICBjb2xsZWN0aWJsZU1ldGFkYXRhIHx8XG4gICAgICAgICAgICAgICAgICAgICh5aWVsZCB0aGlzLmdldENvbGxlY3RpYmxlSW5mb3JtYXRpb24oYWRkcmVzcywgdG9rZW5JZCkpO1xuICAgICAgICAgICAgLy8gSWYgY29sbGVjdGlibGUgY29udHJhY3Qgd2FzIG5vdCBhZGRlZCwgZG8gbm90IGFkZCBpbmRpdmlkdWFsIGNvbGxlY3RpYmxlXG4gICAgICAgICAgICBjb25zdCBjb2xsZWN0aWJsZUNvbnRyYWN0ID0gbmV3Q29sbGVjdGlibGVDb250cmFjdHMuZmluZCgoY29udHJhY3QpID0+IGNvbnRyYWN0LmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIC8vIElmIGNvbGxlY3RpYmxlIGNvbnRyYWN0IGluZm9ybWF0aW9uLCBhZGQgaW5kaXZpZHVhbCBjb2xsZWN0aWJsZVxuICAgICAgICAgICAgaWYgKGNvbGxlY3RpYmxlQ29udHJhY3QpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmFkZEluZGl2aWR1YWxDb2xsZWN0aWJsZShhZGRyZXNzLCB0b2tlbklkLCBjb2xsZWN0aWJsZU1ldGFkYXRhLCBkZXRlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNvbGxlY3RpYmxlIGZyb20gdGhlIHN0b3JlZCB0b2tlbiBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBIZXggYWRkcmVzcyBvZiB0aGUgY29sbGVjdGlibGUgY29udHJhY3QuXG4gICAgICogQHBhcmFtIHRva2VuSWQgLSBUb2tlbiBpZGVudGlmaWVyIG9mIHRoZSBjb2xsZWN0aWJsZS5cbiAgICAgKi9cbiAgICByZW1vdmVDb2xsZWN0aWJsZShhZGRyZXNzLCB0b2tlbklkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgYWRkcmVzcyA9IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgdGhpcy5yZW1vdmVJbmRpdmlkdWFsQ29sbGVjdGlibGUoYWRkcmVzcywgdG9rZW5JZCk7XG4gICAgICAgIGNvbnN0IHsgYWxsQ29sbGVjdGlibGVzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCB7IGNoYWluSWQsIHNlbGVjdGVkQWRkcmVzcyB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgIGNvbnN0IGNvbGxlY3RpYmxlcyA9ICgoX2EgPSBhbGxDb2xsZWN0aWJsZXNbc2VsZWN0ZWRBZGRyZXNzXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2NoYWluSWRdKSB8fCBbXTtcbiAgICAgICAgY29uc3QgcmVtYWluaW5nQ29sbGVjdGlibGUgPSBjb2xsZWN0aWJsZXMuZmluZCgoY29sbGVjdGlibGUpID0+IGNvbGxlY3RpYmxlLmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgaWYgKCFyZW1haW5pbmdDb2xsZWN0aWJsZSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVDb2xsZWN0aWJsZUNvbnRyYWN0KGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjb2xsZWN0aWJsZSBmcm9tIHRoZSBzdG9yZWQgdG9rZW4gbGlzdCBhbmQgc2F2ZXMgaXQgaW4gaWdub3JlZCBjb2xsZWN0aWJsZXMgbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gSGV4IGFkZHJlc3Mgb2YgdGhlIGNvbGxlY3RpYmxlIGNvbnRyYWN0LlxuICAgICAqIEBwYXJhbSB0b2tlbklkIC0gVG9rZW4gaWRlbnRpZmllciBvZiB0aGUgY29sbGVjdGlibGUuXG4gICAgICovXG4gICAgcmVtb3ZlQW5kSWdub3JlQ29sbGVjdGlibGUoYWRkcmVzcywgdG9rZW5JZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGFkZHJlc3MgPSB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIHRoaXMucmVtb3ZlQW5kSWdub3JlSW5kaXZpZHVhbENvbGxlY3RpYmxlKGFkZHJlc3MsIHRva2VuSWQpO1xuICAgICAgICBjb25zdCB7IGFsbENvbGxlY3RpYmxlcyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBjaGFpbklkLCBzZWxlY3RlZEFkZHJlc3MgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICBjb25zdCBjb2xsZWN0aWJsZXMgPSAoKF9hID0gYWxsQ29sbGVjdGlibGVzW3NlbGVjdGVkQWRkcmVzc10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtjaGFpbklkXSkgfHwgW107XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZ0NvbGxlY3RpYmxlID0gY29sbGVjdGlibGVzLmZpbmQoKGNvbGxlY3RpYmxlKSA9PiBjb2xsZWN0aWJsZS5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGlmICghcmVtYWluaW5nQ29sbGVjdGlibGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ29sbGVjdGlibGVDb250cmFjdChhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBjb2xsZWN0aWJsZXMgZnJvbSB0aGUgaWdub3JlZCBsaXN0LlxuICAgICAqL1xuICAgIGNsZWFySWdub3JlZENvbGxlY3RpYmxlcygpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoeyBpZ25vcmVkQ29sbGVjdGlibGVzOiBbXSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgaW5wdXQgY29sbGVjdGlibGUgaXMgc3RpbGwgb3duZWQgYnkgdGhlIHVzZXJcbiAgICAgKiBBbmQgdXBkYXRlcyB0aGUgaXNDdXJyZW50bHlPd25lZCB2YWx1ZSBvbiB0aGUgY29sbGVjdGlibGUgb2JqZWN0IGFjY29yZGluZ2x5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbGxlY3RpYmxlIC0gVGhlIGNvbGxlY3RpYmxlIG9iamVjdCB0byBjaGVjayBhbmQgdXBkYXRlLlxuICAgICAqIEBwYXJhbSBiYXRjaCAtIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBtZXRob2QgaXMgYmVpbmcgY2FsbGVkIGFzIHBhcnQgb2YgYSBiYXRjaCBvciBzaW5nbGUgdXBkYXRlLlxuICAgICAqIEBwYXJhbSBhY2NvdW50UGFyYW1zIC0gVGhlIHVzZXJBZGRyZXNzIGFuZCBjaGFpbklkIHRvIGNoZWNrIG93bmVyc2hpcCBhZ2FpbnN0XG4gICAgICogQHBhcmFtIGFjY291bnRQYXJhbXMudXNlckFkZHJlc3MgLSB0aGUgYWRkcmVzcyBwYXNzZWQgdGhyb3VnaCB0aGUgY29uZmlybWVkIHRyYW5zYWN0aW9uIGZsb3cgdG8gZW5zdXJlIGRldGVjdGVkIGFzc2V0cyBhcmUgc3RvcmVkIHRvIHRoZSBjb3JyZWN0IGFjY291bnRcbiAgICAgKiBAcGFyYW0gYWNjb3VudFBhcmFtcy5jaGFpbklkIC0gdGhlIGNoYWluSWQgcGFzc2VkIHRocm91Z2ggdGhlIGNvbmZpcm1lZCB0cmFuc2FjdGlvbiBmbG93IHRvIGVuc3VyZSBkZXRlY3RlZCBhc3NldHMgYXJlIHN0b3JlZCB0byB0aGUgY29ycmVjdCBhY2NvdW50XG4gICAgICogQHJldHVybnMgdGhlIGNvbGxlY3RpYmxlIHdpdGggdGhlIHVwZGF0ZWQgaXNDdXJyZW50bHlPd25lZCB2YWx1ZVxuICAgICAqL1xuICAgIGNoZWNrQW5kVXBkYXRlU2luZ2xlQ29sbGVjdGlibGVPd25lcnNoaXBTdGF0dXMoY29sbGVjdGlibGUsIGJhdGNoLCB7IHVzZXJBZGRyZXNzLCBjaGFpbklkIH0gPSB7XG4gICAgICAgIHVzZXJBZGRyZXNzOiB0aGlzLmNvbmZpZy5zZWxlY3RlZEFkZHJlc3MsXG4gICAgICAgIGNoYWluSWQ6IHRoaXMuY29uZmlnLmNoYWluSWQsXG4gICAgfSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGFkZHJlc3MsIHRva2VuSWQgfSA9IGNvbGxlY3RpYmxlO1xuICAgICAgICAgICAgbGV0IGlzT3duZWQgPSBjb2xsZWN0aWJsZS5pc0N1cnJlbnRseU93bmVkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpc093bmVkID0geWllbGQgdGhpcy5pc0NvbGxlY3RpYmxlT3duZXIodXNlckFkZHJlc3MsIGFkZHJlc3MsIHRva2VuSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdVbmFibGUgdG8gdmVyaWZ5IG93bmVyc2hpcCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbGxlY3RpYmxlLmlzQ3VycmVudGx5T3duZWQgPSBpc093bmVkO1xuICAgICAgICAgICAgaWYgKGJhdGNoID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RpYmxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBub3QgcGFydCBvZiBhIGJhdGNoZWQgdXBkYXRlIHdlIHVwZGF0ZSB0aGlzIG9uZSBjb2xsZWN0aWJsZSBpbiBzdGF0ZVxuICAgICAgICAgICAgY29uc3QgeyBhbGxDb2xsZWN0aWJsZXMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBjb2xsZWN0aWJsZXMgPSAoKF9hID0gYWxsQ29sbGVjdGlibGVzW3VzZXJBZGRyZXNzXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2NoYWluSWRdKSB8fCBbXTtcbiAgICAgICAgICAgIGNvbnN0IGNvbGxlY3RpYmxlVG9VcGRhdGUgPSBjb2xsZWN0aWJsZXMuZmluZCgoaXRlbSkgPT4gaXRlbS50b2tlbklkID09PSB0b2tlbklkICYmXG4gICAgICAgICAgICAgICAgaXRlbS5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICBpZiAoY29sbGVjdGlibGVUb1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbGxlY3RpYmxlVG9VcGRhdGUuaXNDdXJyZW50bHlPd25lZCA9IGlzT3duZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVOZXN0ZWRDb2xsZWN0aWJsZVN0YXRlKGNvbGxlY3RpYmxlcywgQUxMX0NPTExFQ1RJQkxFU19TVEFURV9LRVksIHsgdXNlckFkZHJlc3MsIGNoYWluSWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdGlibGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBDb2xsZWN0aWJsZXMgYXNzb2NpYXRlZCB3aXRoIGN1cnJlbnQgc2VsZWN0ZWRBZGRyZXNzL2NoYWluSWQgY29tYmluYXRpb24gYXJlIHN0aWxsIG93bmVkIGJ5IHRoZSB1c2VyXG4gICAgICogQW5kIHVwZGF0ZXMgdGhlIGlzQ3VycmVudGx5T3duZWQgdmFsdWUgb24gZWFjaCBhY2NvcmRpbmdseS5cbiAgICAgKi9cbiAgICBjaGVja0FuZFVwZGF0ZUFsbENvbGxlY3RpYmxlc093bmVyc2hpcFN0YXR1cygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhbGxDb2xsZWN0aWJsZXMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCB7IGNoYWluSWQsIHNlbGVjdGVkQWRkcmVzcyB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICBjb25zdCBjb2xsZWN0aWJsZXMgPSAoKF9hID0gYWxsQ29sbGVjdGlibGVzW3NlbGVjdGVkQWRkcmVzc10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtjaGFpbklkXSkgfHwgW107XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkQ29sbGVjdGlibGVzID0geWllbGQgUHJvbWlzZS5hbGwoY29sbGVjdGlibGVzLm1hcCgoY29sbGVjdGlibGUpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2I7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoX2IgPSAoeWllbGQgdGhpcy5jaGVja0FuZFVwZGF0ZVNpbmdsZUNvbGxlY3RpYmxlT3duZXJzaGlwU3RhdHVzKGNvbGxlY3RpYmxlLCB0cnVlKSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGNvbGxlY3RpYmxlKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU5lc3RlZENvbGxlY3RpYmxlU3RhdGUodXBkYXRlZENvbGxlY3RpYmxlcywgQUxMX0NPTExFQ1RJQkxFU19TVEFURV9LRVkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGNvbGxlY3RpYmxlIGZhdm9yaXRlIHN0YXR1cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gSGV4IGFkZHJlc3Mgb2YgdGhlIGNvbGxlY3RpYmxlIGNvbnRyYWN0LlxuICAgICAqIEBwYXJhbSB0b2tlbklkIC0gSGV4IGFkZHJlc3Mgb2YgdGhlIGNvbGxlY3RpYmxlIGNvbnRyYWN0LlxuICAgICAqIEBwYXJhbSBmYXZvcml0ZSAtIENvbGxlY3RpYmxlIG5ldyBmYXZvcml0ZSBzdGF0dXMuXG4gICAgICovXG4gICAgdXBkYXRlQ29sbGVjdGlibGVGYXZvcml0ZVN0YXR1cyhhZGRyZXNzLCB0b2tlbklkLCBmYXZvcml0ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgYWxsQ29sbGVjdGlibGVzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCB7IGNoYWluSWQsIHNlbGVjdGVkQWRkcmVzcyB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgIGNvbnN0IGNvbGxlY3RpYmxlcyA9ICgoX2EgPSBhbGxDb2xsZWN0aWJsZXNbc2VsZWN0ZWRBZGRyZXNzXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2NoYWluSWRdKSB8fCBbXTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBjb2xsZWN0aWJsZXMuZmluZEluZGV4KChjb2xsZWN0aWJsZSkgPT4gY29sbGVjdGlibGUuYWRkcmVzcyA9PT0gYWRkcmVzcyAmJiBjb2xsZWN0aWJsZS50b2tlbklkID09PSB0b2tlbklkKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRDb2xsZWN0aWJsZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29sbGVjdGlibGVzW2luZGV4XSksIHsgZmF2b3JpdGUgfSk7XG4gICAgICAgIC8vIFVwZGF0ZSBDb2xsZWN0aWJsZXMgYXJyYXlcbiAgICAgICAgY29sbGVjdGlibGVzW2luZGV4XSA9IHVwZGF0ZWRDb2xsZWN0aWJsZTtcbiAgICAgICAgdGhpcy51cGRhdGVOZXN0ZWRDb2xsZWN0aWJsZVN0YXRlKGNvbGxlY3RpYmxlcywgQUxMX0NPTExFQ1RJQkxFU19TVEFURV9LRVkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29sbGVjdGlibGVzQ29udHJvbGxlciA9IENvbGxlY3RpYmxlc0NvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBDb2xsZWN0aWJsZXNDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29sbGVjdGlibGVzQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXBwcm92YWxDb250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgZXRoX3JwY19lcnJvcnNfMSA9IHJlcXVpcmUoXCJldGgtcnBjLWVycm9yc1wiKTtcbmNvbnN0IG5hbm9pZF8xID0gcmVxdWlyZShcIm5hbm9pZFwiKTtcbmNvbnN0IEJhc2VDb250cm9sbGVyVjJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclYyXCIpO1xuY29uc3QgY29udHJvbGxlck5hbWUgPSAnQXBwcm92YWxDb250cm9sbGVyJztcbmNvbnN0IHN0YXRlTWV0YWRhdGEgPSB7XG4gICAgcGVuZGluZ0FwcHJvdmFsczogeyBwZXJzaXN0OiBmYWxzZSwgYW5vbnltb3VzOiB0cnVlIH0sXG4gICAgcGVuZGluZ0FwcHJvdmFsQ291bnQ6IHsgcGVyc2lzdDogZmFsc2UsIGFub255bW91czogZmFsc2UgfSxcbn07XG5jb25zdCBnZXRBbHJlYWR5UGVuZGluZ01lc3NhZ2UgPSAob3JpZ2luLCB0eXBlKSA9PiBgUmVxdWVzdCBvZiB0eXBlICcke3R5cGV9JyBhbHJlYWR5IHBlbmRpbmcgZm9yIG9yaWdpbiAke29yaWdpbn0uIFBsZWFzZSB3YWl0LmA7XG5jb25zdCBnZXREZWZhdWx0U3RhdGUgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGVuZGluZ0FwcHJvdmFsczoge30sXG4gICAgICAgIHBlbmRpbmdBcHByb3ZhbENvdW50OiAwLFxuICAgIH07XG59O1xuLyoqXG4gKiBDb250cm9sbGVyIGZvciBtYW5hZ2luZyByZXF1ZXN0cyB0aGF0IHJlcXVpcmUgdXNlciBhcHByb3ZhbC5cbiAqXG4gKiBFbmFibGVzIGxpbWl0aW5nIHRoZSBudW1iZXIgb2YgcGVuZGluZyByZXF1ZXN0cyBieSBvcmlnaW4gYW5kIHR5cGUsIGNvdW50aW5nXG4gKiBwZW5kaW5nIHJlcXVlc3RzLCBhbmQgbW9yZS5cbiAqXG4gKiBBZGRpbmcgYSByZXF1ZXN0IHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgb3IgcmVqZWN0cyB3aGVuIHRoZSByZXF1ZXN0XG4gKiBpcyBhcHByb3ZlZCBvciBkZW5pZWQsIHJlc3BlY3RpdmVseS5cbiAqL1xuY2xhc3MgQXBwcm92YWxDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJWMl8xLkJhc2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYW4gQXBwcm92YWwgY29udHJvbGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGNvbnRyb2xsZXIgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zaG93QXBwcm92YWxSZXF1ZXN0IC0gRnVuY3Rpb24gZm9yIG9wZW5pbmcgdGhlIFVJIHN1Y2ggdGhhdFxuICAgICAqIHRoZSByZXF1ZXN0IGNhbiBiZSBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubWVzc2VuZ2VyIC0gVGhlIHJlc3RyaWN0ZWQgY29udHJvbGxlciBtZXNzZW5nZXIgZm9yIHRoZSBBcHByb3ZhbCBjb250cm9sbGVyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnN0YXRlIC0gVGhlIGluaXRpYWwgY29udHJvbGxlciBzdGF0ZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IG1lc3Nlbmdlciwgc2hvd0FwcHJvdmFsUmVxdWVzdCwgc3RhdGUgPSB7fSwgfSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBuYW1lOiBjb250cm9sbGVyTmFtZSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBzdGF0ZU1ldGFkYXRhLFxuICAgICAgICAgICAgbWVzc2VuZ2VyLFxuICAgICAgICAgICAgc3RhdGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZ2V0RGVmYXVsdFN0YXRlKCkpLCBzdGF0ZSksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9hcHByb3ZhbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX29yaWdpbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3Nob3dBcHByb3ZhbFJlcXVlc3QgPSBzaG93QXBwcm92YWxSZXF1ZXN0O1xuICAgICAgICB0aGlzLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXJzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGhlbHBlciBmb3IgcmVnaXN0ZXJpbmcgdGhpcyBjb250cm9sbGVyJ3MgbWVzc2FnaW5nIHN5c3RlbVxuICAgICAqIGFjdGlvbnMuXG4gICAgICovXG4gICAgcmVnaXN0ZXJNZXNzYWdlSGFuZGxlcnMoKSB7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06Y2xlYXJSZXF1ZXN0c2AsIHRoaXMuY2xlYXIuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06YWRkUmVxdWVzdGAsIChvcHRzLCBzaG91bGRTaG93UmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNob3VsZFNob3dSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkQW5kU2hvd0FwcHJvdmFsUmVxdWVzdChvcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvcHRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06aGFzUmVxdWVzdGAsIHRoaXMuaGFzLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYCR7Y29udHJvbGxlck5hbWV9OmFjY2VwdFJlcXVlc3RgLCB0aGlzLmFjY2VwdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke2NvbnRyb2xsZXJOYW1lfTpyZWplY3RSZXF1ZXN0YCwgdGhpcy5yZWplY3QuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gYXBwcm92YWwgcmVxdWVzdCBwZXIgdGhlIGdpdmVuIGFyZ3VtZW50cywgY2FsbHMgdGhlIHNob3cgYXBwcm92YWxcbiAgICAgKiByZXF1ZXN0IGZ1bmN0aW9uLCBhbmQgcmV0dXJucyB0aGUgYXNzb2NpYXRlZCBhcHByb3ZhbCBwcm9taXNlLlxuICAgICAqXG4gICAgICogVGhlcmUgY2FuIG9ubHkgYmUgb25lIGFwcHJvdmFsIHBlciBvcmlnaW4gYW5kIHR5cGUuIEFuIGVycm9yIGlzIHRocm93biBpZlxuICAgICAqIGF0dGVtcHRpbmcgdG8gYWRkIGFuIGludmFsaWQgb3IgZHVwbGljYXRlIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgYmFnLlxuICAgICAqIEBwYXJhbSBvcHRzLmlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LiBBIHJhbmRvbSBpZCB3aWxsIGJlXG4gICAgICogZ2VuZXJhdGVkIGlmIG5vbmUgaXMgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIG9wdHMub3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gb3B0cy50eXBlIC0gVGhlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBvcHRzLnJlcXVlc3REYXRhIC0gQWRkaXRpb25hbCBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVxdWVzdCxcbiAgICAgKiBpZiBhbnkuXG4gICAgICogQHJldHVybnMgVGhlIGFwcHJvdmFsIHByb21pc2UuXG4gICAgICovXG4gICAgYWRkQW5kU2hvd0FwcHJvdmFsUmVxdWVzdChvcHRzKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLl9hZGQob3B0cy5vcmlnaW4sIG9wdHMudHlwZSwgb3B0cy5pZCwgb3B0cy5yZXF1ZXN0RGF0YSk7XG4gICAgICAgIHRoaXMuX3Nob3dBcHByb3ZhbFJlcXVlc3QoKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gYXBwcm92YWwgcmVxdWVzdCBwZXIgdGhlIGdpdmVuIGFyZ3VtZW50cyBhbmQgcmV0dXJucyB0aGUgYXBwcm92YWxcbiAgICAgKiBwcm9taXNlLlxuICAgICAqXG4gICAgICogVGhlcmUgY2FuIG9ubHkgYmUgb25lIGFwcHJvdmFsIHBlciBvcmlnaW4gYW5kIHR5cGUuIEFuIGVycm9yIGlzIHRocm93biBpZlxuICAgICAqIGF0dGVtcHRpbmcgdG8gYWRkIGFuIGludmFsaWQgb3IgZHVwbGljYXRlIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgYmFnLlxuICAgICAqIEBwYXJhbSBvcHRzLmlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LiBBIHJhbmRvbSBpZCB3aWxsIGJlXG4gICAgICogZ2VuZXJhdGVkIGlmIG5vbmUgaXMgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIG9wdHMub3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gb3B0cy50eXBlIC0gVGhlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBvcHRzLnJlcXVlc3REYXRhIC0gQWRkaXRpb25hbCBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVxdWVzdCxcbiAgICAgKiBpZiBhbnkuXG4gICAgICogQHJldHVybnMgVGhlIGFwcHJvdmFsIHByb21pc2UuXG4gICAgICovXG4gICAgYWRkKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZChvcHRzLm9yaWdpbiwgb3B0cy50eXBlLCBvcHRzLmlkLCBvcHRzLnJlcXVlc3REYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5mbyBmb3IgdGhlIGFwcHJvdmFsIHJlcXVlc3Qgd2l0aCB0aGUgZ2l2ZW4gaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMgVGhlIGFwcHJvdmFsIHJlcXVlc3QgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGlkLlxuICAgICAqL1xuICAgIGdldChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5wZW5kaW5nQXBwcm92YWxzW2lkXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIHBlbmRpbmcgYXBwcm92YWxzLCBieSBvcmlnaW4gYW5kL29yIHR5cGUuXG4gICAgICpcbiAgICAgKiBJZiBvbmx5IGBvcmlnaW5gIGlzIHNwZWNpZmllZCwgYWxsIGFwcHJvdmFscyBmb3IgdGhhdCBvcmlnaW4gd2lsbCBiZVxuICAgICAqIGNvdW50ZWQsIHJlZ2FyZGxlc3Mgb2YgdHlwZS5cbiAgICAgKiBJZiBvbmx5IGB0eXBlYCBpcyBzcGVjaWZpZWQsIGFsbCBhcHByb3ZhbHMgZm9yIHRoYXQgdHlwZSB3aWxsIGJlIGNvdW50ZWQsXG4gICAgICogcmVnYXJkbGVzcyBvZiBvcmlnaW4uXG4gICAgICogSWYgYm90aCBgb3JpZ2luYCBhbmQgYHR5cGVgIGFyZSBzcGVjaWZpZWQsIDAgb3IgMSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgLSBUaGUgYXBwcm92YWwgY291bnQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0cy5vcmlnaW4gLSBBbiBhcHByb3ZhbCBvcmlnaW4uXG4gICAgICogQHBhcmFtIG9wdHMudHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IGFwcHJvdmFsIHJlcXVlc3QgY291bnQgZm9yIHRoZSBnaXZlbiBvcmlnaW4gYW5kL29yXG4gICAgICogdHlwZS5cbiAgICAgKi9cbiAgICBnZXRBcHByb3ZhbENvdW50KG9wdHMgPSB7fSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoIW9wdHMub3JpZ2luICYmICFvcHRzLnR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzcGVjaWZ5IG9yaWdpbiwgdHlwZSwgb3IgYm90aC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG9yaWdpbiwgdHlwZTogX3R5cGUgfSA9IG9wdHM7XG4gICAgICAgIGlmIChvcmlnaW4gJiYgX3R5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIoQm9vbGVhbigoX2EgPSB0aGlzLl9vcmlnaW5zLmdldChvcmlnaW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFzKF90eXBlKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgICAgIHJldHVybiAoKF9iID0gdGhpcy5fb3JpZ2lucy5nZXQob3JpZ2luKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNpemUpIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBcInR5cGVcIiB3YXMgc3BlY2lmaWVkXG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgYXBwcm92YWwgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLnN0YXRlLnBlbmRpbmdBcHByb3ZhbHMpKSB7XG4gICAgICAgICAgICBpZiAoYXBwcm92YWwudHlwZSA9PT0gX3R5cGUpIHtcbiAgICAgICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0b3RhbCBjb3VudCBvZiBhbGwgcGVuZGluZyBhcHByb3ZhbCByZXF1ZXN0cyBmb3IgYWxsIG9yaWdpbnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgdG90YWwgcGVuZGluZyBhcHByb3ZhbCByZXF1ZXN0IGNvdW50LlxuICAgICAqL1xuICAgIGdldFRvdGFsQXBwcm92YWxDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucGVuZGluZ0FwcHJvdmFsQ291bnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGVyZSdzIGEgcGVuZGluZyBhcHByb3ZhbCByZXF1ZXN0IHBlciB0aGUgZ2l2ZW4gcGFyYW1ldGVycy5cbiAgICAgKiBBdCBsZWFzdCBvbmUgcGFyYW1ldGVyIG11c3QgYmUgc3BlY2lmaWVkLiBBbiBlcnJvciB3aWxsIGJlIHRocm93biBpZiB0aGVcbiAgICAgKiBwYXJhbWV0ZXJzIGFyZSBpbnZhbGlkLlxuICAgICAqXG4gICAgICogSWYgYGlkYCBpcyBzcGVjaWZpZWQsIGFsbCBvdGhlciBwYXJhbWV0ZXJzIHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKiBJZiBgaWRgIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBtZXRob2Qgd2lsbCBjaGVjayBmb3IgcmVxdWVzdHMgdGhhdCBtYXRjaFxuICAgICAqIGFsbCBvZiB0aGUgc3BlY2lmaWVkIHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgYmFnLlxuICAgICAqIEBwYXJhbSBvcHRzLmlkIC0gVGhlIElEIHRvIGNoZWNrIGZvci5cbiAgICAgKiBAcGFyYW0gb3B0cy5vcmlnaW4gLSBUaGUgb3JpZ2luIHRvIGNoZWNrIGZvci5cbiAgICAgKiBAcGFyYW0gb3B0cy50eXBlIC0gVGhlIHR5cGUgdG8gY2hlY2sgZm9yLlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiBhIG1hdGNoaW5nIGFwcHJvdmFsIGlzIGZvdW5kLCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaGFzKG9wdHMgPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgaWQsIG9yaWdpbiwgdHlwZTogX3R5cGUgfSA9IG9wdHM7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01heSBub3Qgc3BlY2lmeSBub24tc3RyaW5nIGlkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FwcHJvdmFscy5oYXMoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdHlwZSAmJiB0eXBlb2YgX3R5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01heSBub3Qgc3BlY2lmeSBub24tc3RyaW5nIHR5cGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWdpbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXkgbm90IHNwZWNpZnkgbm9uLXN0cmluZyBvcmlnaW4uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBvcmlnaW4gYW5kIHR5cGUgcGFpciBpZiB0eXBlIGFsc28gc3BlY2lmaWVkXG4gICAgICAgICAgICBpZiAoX3R5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbigoX2EgPSB0aGlzLl9vcmlnaW5zLmdldChvcmlnaW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFzKF90eXBlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JpZ2lucy5oYXMob3JpZ2luKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3R5cGUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXBwcm92YWwgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLnN0YXRlLnBlbmRpbmdBcHByb3ZhbHMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFwcHJvdmFsLnR5cGUgPT09IF90eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3BlY2lmeSBhIHZhbGlkIGNvbWJpbmF0aW9uIG9mIGlkLCBvcmlnaW4sIGFuZCB0eXBlLicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgcHJvbWlzZSBvZiB0aGUgYXBwcm92YWwgd2l0aCB0aGUgZ2l2ZW4gaWQsIGFuZCBkZWxldGVzIHRoZVxuICAgICAqIGFwcHJvdmFsLiBUaHJvd3MgYW4gZXJyb3IgaWYgbm8gc3VjaCBhcHByb3ZhbCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJlc29sdmUgdGhlIGFwcHJvdmFsIHByb21pc2Ugd2l0aC5cbiAgICAgKi9cbiAgICBhY2NlcHQoaWQsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2RlbGV0ZUFwcHJvdmFsQW5kR2V0Q2FsbGJhY2tzKGlkKS5yZXNvbHZlKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVqZWN0cyB0aGUgcHJvbWlzZSBvZiB0aGUgYXBwcm92YWwgd2l0aCB0aGUgZ2l2ZW4gaWQsIGFuZCBkZWxldGVzIHRoZVxuICAgICAqIGFwcHJvdmFsLiBUaHJvd3MgYW4gZXJyb3IgaWYgbm8gc3VjaCBhcHByb3ZhbCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIHRvIHJlamVjdCB0aGUgYXBwcm92YWwgcHJvbWlzZSB3aXRoLlxuICAgICAqL1xuICAgIHJlamVjdChpZCwgZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fZGVsZXRlQXBwcm92YWxBbmRHZXRDYWxsYmFja3MoaWQpLnJlamVjdChlcnJvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlamVjdHMgYW5kIGRlbGV0ZXMgYWxsIGFwcHJvdmFsIHJlcXVlc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlamVjdGlvbkVycm9yIC0gVGhlIEV0aGVyZXVtUnBjRXJyb3IgdG8gcmVqZWN0IHRoZSBhcHByb3ZhbFxuICAgICAqIHJlcXVlc3RzIHdpdGguXG4gICAgICovXG4gICAgY2xlYXIocmVqZWN0aW9uRXJyb3IpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiB0aGlzLl9hcHByb3ZhbHMua2V5cygpKSB7XG4gICAgICAgICAgICB0aGlzLnJlamVjdChpZCwgcmVqZWN0aW9uRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29yaWdpbnMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy51cGRhdGUoKCkgPT4gZ2V0RGVmYXVsdFN0YXRlKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRhdGlvbiBvZiBhZGQgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBhc3NvY2lhdGVkIHdpdGggdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSByZXF1ZXN0RGF0YSAtIFRoZSByZXF1ZXN0IGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBhcHByb3ZhbCBwcm9taXNlLlxuICAgICAqL1xuICAgIF9hZGQob3JpZ2luLCB0eXBlLCBpZCA9IG5hbm9pZF8xLm5hbm9pZCgpLCByZXF1ZXN0RGF0YSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlQWRkUGFyYW1zKGlkLCBvcmlnaW4sIHR5cGUsIHJlcXVlc3REYXRhKTtcbiAgICAgICAgaWYgKChfYSA9IHRoaXMuX29yaWdpbnMuZ2V0KG9yaWdpbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYXModHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5yZXNvdXJjZVVuYXZhaWxhYmxlKGdldEFscmVhZHlQZW5kaW5nTWVzc2FnZShvcmlnaW4sIHR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgcGVuZGluZyBhcHByb3ZhbFxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fYXBwcm92YWxzLnNldChpZCwgeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgICAgICAgICB0aGlzLl9hZGRQZW5kaW5nQXBwcm92YWxPcmlnaW4ob3JpZ2luLCB0eXBlKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZFRvU3RvcmUoaWQsIG9yaWdpbiwgdHlwZSwgcmVxdWVzdERhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHBhcmFtZXRlcnMgdG8gdGhlIGFkZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBhc3NvY2lhdGVkIHdpdGggdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHJlcXVlc3REYXRhIC0gVGhlIHJlcXVlc3QgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICovXG4gICAgX3ZhbGlkYXRlQWRkUGFyYW1zKGlkLCBvcmlnaW4sIHR5cGUsIHJlcXVlc3REYXRhKSB7XG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBudWxsO1xuICAgICAgICBpZiAoIWlkIHx8IHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICdNdXN0IHNwZWNpZnkgbm9uLWVtcHR5IHN0cmluZyBpZC4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2FwcHJvdmFscy5oYXMoaWQpKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBgQXBwcm92YWwgcmVxdWVzdCB3aXRoIGlkICcke2lkfScgYWxyZWFkeSBleGlzdHMuYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghb3JpZ2luIHx8IHR5cGVvZiBvcmlnaW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSAnTXVzdCBzcGVjaWZ5IG5vbi1lbXB0eSBzdHJpbmcgb3JpZ2luLic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXR5cGUgfHwgdHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSAnTXVzdCBzcGVjaWZ5IG5vbi1lbXB0eSBzdHJpbmcgdHlwZS4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlcXVlc3REYXRhICYmXG4gICAgICAgICAgICAodHlwZW9mIHJlcXVlc3REYXRhICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KHJlcXVlc3REYXRhKSkpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICdSZXF1ZXN0IGRhdGEgbXVzdCBiZSBhIHBsYWluIG9iamVjdCBpZiBzcGVjaWZpZWQuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW50ZXJuYWwoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGVudHJ5IHRvIF9vcmlnaW5zLlxuICAgICAqIFBlcmZvcm1zIG5vIHZhbGlkYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBfYWRkUGVuZGluZ0FwcHJvdmFsT3JpZ2luKG9yaWdpbiwgdHlwZSkge1xuICAgICAgICBjb25zdCBvcmlnaW5TZXQgPSB0aGlzLl9vcmlnaW5zLmdldChvcmlnaW4pIHx8IG5ldyBTZXQoKTtcbiAgICAgICAgb3JpZ2luU2V0LmFkZCh0eXBlKTtcbiAgICAgICAgaWYgKCF0aGlzLl9vcmlnaW5zLmhhcyhvcmlnaW4pKSB7XG4gICAgICAgICAgICB0aGlzLl9vcmlnaW5zLnNldChvcmlnaW4sIG9yaWdpblNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBlbnRyeSB0byB0aGUgc3RvcmUuXG4gICAgICogUGVyZm9ybXMgbm8gdmFsaWRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdERhdGEgLSBUaGUgcmVxdWVzdCBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBfYWRkVG9TdG9yZShpZCwgb3JpZ2luLCB0eXBlLCByZXF1ZXN0RGF0YSkge1xuICAgICAgICBjb25zdCBhcHByb3ZhbCA9IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICByZXF1ZXN0RGF0YTogcmVxdWVzdERhdGEgfHwgbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGUoKGRyYWZ0U3RhdGUpID0+IHtcbiAgICAgICAgICAgIC8vIFR5cGVjYXN0OiB0cygyNTg5KVxuICAgICAgICAgICAgZHJhZnRTdGF0ZS5wZW5kaW5nQXBwcm92YWxzW2lkXSA9IGFwcHJvdmFsO1xuICAgICAgICAgICAgZHJhZnRTdGF0ZS5wZW5kaW5nQXBwcm92YWxDb3VudCA9IE9iamVjdC5rZXlzKGRyYWZ0U3RhdGUucGVuZGluZ0FwcHJvdmFscykubGVuZ3RoO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgYXBwcm92YWwgd2l0aCB0aGUgZ2l2ZW4gaWQuIFRoZSBhcHByb3ZhbCBwcm9taXNlIG11c3QgYmVcbiAgICAgKiByZXNvbHZlZCBvciByZWplY3QgYmVmb3JlIHRoaXMgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgKiBEZWxldGlvbiBpcyBhbiBpbnRlcm5hbCBvcGVyYXRpb24gYmVjYXVzZSBhcHByb3ZhbCBzdGF0ZSBpcyBzb2xlbHlcbiAgICAgKiBtYW5hZ2VkIGJ5IHRoaXMgY29udHJvbGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdCB0byBiZSBkZWxldGVkLlxuICAgICAqL1xuICAgIF9kZWxldGUoaWQpIHtcbiAgICAgICAgdGhpcy5fYXBwcm92YWxzLmRlbGV0ZShpZCk7XG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIG9ubHkgY2FsbGVkIGFmdGVyIHZlcmlmeWluZyB0aGF0IHRoZSBhcHByb3ZhbCB3aXRoIHRoZVxuICAgICAgICAvLyBzcGVjaWZpZWQgaWQgZXhpc3RzLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBjb25zdCB7IG9yaWdpbiwgdHlwZSB9ID0gdGhpcy5zdGF0ZS5wZW5kaW5nQXBwcm92YWxzW2lkXTtcbiAgICAgICAgdGhpcy5fb3JpZ2lucy5nZXQob3JpZ2luKS5kZWxldGUodHlwZSk7XG4gICAgICAgIGlmICh0aGlzLl9pc0VtcHR5T3JpZ2luKG9yaWdpbikpIHtcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbnMuZGVsZXRlKG9yaWdpbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoKGRyYWZ0U3RhdGUpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSBkcmFmdFN0YXRlLnBlbmRpbmdBcHByb3ZhbHNbaWRdO1xuICAgICAgICAgICAgZHJhZnRTdGF0ZS5wZW5kaW5nQXBwcm92YWxDb3VudCA9IE9iamVjdC5rZXlzKGRyYWZ0U3RhdGUucGVuZGluZ0FwcHJvdmFscykubGVuZ3RoO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm92YWwgY2FsbGJhY2tzIGZvciB0aGUgZ2l2ZW4gaWQsIGRlbGV0ZXMgdGhlIGVudHJ5LCBhbmQgdGhlblxuICAgICAqIHJldHVybnMgdGhlIGNhbGxiYWNrcyBmb3IgcHJvbWlzZSByZXNvbHV0aW9uLlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiBubyBhcHByb3ZhbCBpcyBmb3VuZCBmb3IgdGhlIGdpdmVuIGlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBwcm9taXNlIGNhbGxiYWNrcyBhc3NvY2lhdGVkIHdpdGggdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICovXG4gICAgX2RlbGV0ZUFwcHJvdmFsQW5kR2V0Q2FsbGJhY2tzKGlkKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuX2FwcHJvdmFscy5nZXQoaWQpO1xuICAgICAgICBpZiAoIWNhbGxiYWNrcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBcHByb3ZhbCByZXF1ZXN0IHdpdGggaWQgJyR7aWR9JyBub3QgZm91bmQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGVsZXRlKGlkKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlcmUgYXJlIGFueSBhcHByb3ZhbHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlblxuICAgICAqIG9yaWdpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG9yaWdpbiBoYXMgbm8gYXBwcm92YWxzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgX2lzRW1wdHlPcmlnaW4ob3JpZ2luKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICEoKF9hID0gdGhpcy5fb3JpZ2lucy5nZXQob3JpZ2luKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpemUpO1xuICAgIH1cbn1cbmV4cG9ydHMuQXBwcm92YWxDb250cm9sbGVyID0gQXBwcm92YWxDb250cm9sbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXBwcm92YWxDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXBwcm92YWxDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRQZXJzaXN0ZW50U3RhdGUgPSBleHBvcnRzLmdldEFub255bWl6ZWRTdGF0ZSA9IGV4cG9ydHMuQmFzZUNvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCBpbW1lcl8xID0gcmVxdWlyZShcImltbWVyXCIpO1xuaW1tZXJfMS5lbmFibGVQYXRjaGVzKCk7XG4vKipcbiAqIENvbnRyb2xsZXIgY2xhc3MgdGhhdCBwcm92aWRlcyBzdGF0ZSBtYW5hZ2VtZW50LCBzdWJzY3JpcHRpb25zLCBhbmQgc3RhdGUgbWV0YWRhdGFcbiAqL1xuY2xhc3MgQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBCYXNlQ29udHJvbGxlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQ29udHJvbGxlciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm1lc3NlbmdlciAtIENvbnRyb2xsZXIgbWVzc2FnaW5nIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5tZXRhZGF0YSAtIFN0YXRlIG1ldGFkYXRhLCBkZXNjcmliaW5nIGhvdyB0byBcImFub255bWl6ZVwiIHRoZSBzdGF0ZSwgYW5kIHdoaWNoXG4gICAgICogcGFydHMgc2hvdWxkIGJlIHBlcnNpc3RlZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNvbnRyb2xsZXIsIHVzZWQgYXMgYSBuYW1lc3BhY2UgZm9yIGV2ZW50cyBhbmQgYWN0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zdGF0ZSAtIEluaXRpYWwgY29udHJvbGxlciBzdGF0ZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IG1lc3NlbmdlciwgbWV0YWRhdGEsIG5hbWUsIHN0YXRlLCB9KSB7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtID0gbWVzc2VuZ2VyO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmludGVybmFsU3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYCR7bmFtZX06Z2V0U3RhdGVgLCAoKSA9PiB0aGlzLnN0YXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGN1cnJlbnQgY29udHJvbGxlciBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAqL1xuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdGF0ZTtcbiAgICB9XG4gICAgc2V0IHN0YXRlKF8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb250cm9sbGVyIHN0YXRlIGNhbm5vdCBiZSBkaXJlY3RseSBtdXRhdGVkOyB1c2UgJ3VwZGF0ZScgbWV0aG9kIGluc3RlYWQuYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY29udHJvbGxlciBzdGF0ZS4gQWNjZXB0cyBhIGNhbGxiYWNrIHRoYXQgaXMgcGFzc2VkIGEgZHJhZnQgY29weVxuICAgICAqIG9mIHRoZSBjb250cm9sbGVyIHN0YXRlLiBJZiBhIHZhbHVlIGlzIHJldHVybmVkLCBpdCBpcyBzZXQgYXMgdGhlIG5ld1xuICAgICAqIHN0YXRlLiBPdGhlcndpc2UsIGFueSBjaGFuZ2VzIG1hZGUgd2l0aGluIHRoYXQgY2FsbGJhY2sgdG8gdGhlIGRyYWZ0IGFyZVxuICAgICAqIGFwcGxpZWQgdG8gdGhlIGNvbnRyb2xsZXIgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBDYWxsYmFjayBmb3IgdXBkYXRpbmcgc3RhdGUsIHBhc3NlZCBhIGRyYWZ0IHN0YXRlXG4gICAgICogb2JqZWN0LiBSZXR1cm4gYSBuZXcgc3RhdGUgb2JqZWN0IG9yIG11dGF0ZSB0aGUgZHJhZnQgdG8gdXBkYXRlIHN0YXRlLlxuICAgICAqL1xuICAgIHVwZGF0ZShjYWxsYmFjaykge1xuICAgICAgICAvLyBXZSBydW4gaW50byB0czI1ODksIFwiaW5maW5pdGUgdHlwZSBkZXB0aFwiLCBpZiB3ZSBkb24ndCBjYXN0XG4gICAgICAgIC8vIHByb2R1Y2VXaXRoUGF0Y2hlcyBoZXJlLlxuICAgICAgICAvLyBUaGUgZmluYWwsIG9taXR0ZWQgbWVtYmVyIG9mIHRoZSByZXR1cm5lZCB0dXBsZSBhcmUgdGhlIGludmVyc2UgcGF0Y2hlcy5cbiAgICAgICAgY29uc3QgW25leHRTdGF0ZSwgcGF0Y2hlc10gPSBpbW1lcl8xLnByb2R1Y2VXaXRoUGF0Y2hlcyh0aGlzLmludGVybmFsU3RhdGUsIGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5wdWJsaXNoKGAke3RoaXMubmFtZX06c3RhdGVDaGFuZ2VgLCBuZXh0U3RhdGUsIHBhdGNoZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlcyB0aGUgY29udHJvbGxlciBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLiBUaGlzIHNob3VsZCBiZSBleHRlbmRlZFxuICAgICAqIGJ5IGFueSBzdWJjbGFzc2VzIHRvIGNsZWFuIHVwIGFueSBhZGRpdGlvbmFsIGNvbm5lY3Rpb25zIG9yIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIFRoZSBvbmx5IGNsZWFudXAgcGVyZm9ybWVkIGhlcmUgaXMgdG8gcmVtb3ZlIGxpc3RlbmVycy4gV2hpbGUgdGVjaG5pY2FsbHlcbiAgICAgKiB0aGlzIGlzIG5vdCByZXF1aXJlZCB0byBlbnN1cmUgdGhpcyBpbnN0YW5jZSBpcyBnYXJiYWdlIGNvbGxlY3RlZCwgaXQgYXRcbiAgICAgKiBsZWFzdCBlbnN1cmVzIHRoaXMgaW5zdGFuY2Ugd29uJ3QgYmUgcmVzcG9uc2libGUgZm9yIHByZXZlbnRpbmcgdGhlXG4gICAgICogbGlzdGVuZXJzIGZyb20gYmVpbmcgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0uY2xlYXJFdmVudFN1YnNjcmlwdGlvbnMoYCR7dGhpcy5uYW1lfTpzdGF0ZUNoYW5nZWApO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUNvbnRyb2xsZXIgPSBCYXNlQ29udHJvbGxlcjtcbi8qKlxuICogUmV0dXJucyBhbiBhbm9ueW1pemVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb250cm9sbGVyIHN0YXRlLlxuICpcbiAqIEJ5IFwiYW5vbnltaXplZFwiIHdlIG1lYW4gdGhhdCBpdCBzaG91bGQgbm90IGNvbnRhaW4gYW55IGluZm9ybWF0aW9uIHRoYXQgY291bGQgYmUgcGVyc29uYWxseVxuICogaWRlbnRpZmlhYmxlLlxuICpcbiAqIEBwYXJhbSBzdGF0ZSAtIFRoZSBjb250cm9sbGVyIHN0YXRlLlxuICogQHBhcmFtIG1ldGFkYXRhIC0gVGhlIGNvbnRyb2xsZXIgc3RhdGUgbWV0YWRhdGEsIHdoaWNoIGRlc2NyaWJlcyBob3cgdG8gZGVyaXZlIHRoZVxuICogYW5vbnltaXplZCBzdGF0ZS5cbiAqIEByZXR1cm5zIFRoZSBhbm9ueW1pemVkIGNvbnRyb2xsZXIgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIGdldEFub255bWl6ZWRTdGF0ZShzdGF0ZSwgbWV0YWRhdGEpIHtcbiAgICByZXR1cm4gZGVyaXZlU3RhdGVGcm9tTWV0YWRhdGEoc3RhdGUsIG1ldGFkYXRhLCAnYW5vbnltb3VzJyk7XG59XG5leHBvcnRzLmdldEFub255bWl6ZWRTdGF0ZSA9IGdldEFub255bWl6ZWRTdGF0ZTtcbi8qKlxuICogUmV0dXJucyB0aGUgc3Vic2V0IG9mIHN0YXRlIHRoYXQgc2hvdWxkIGJlIHBlcnNpc3RlZC5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgLSBUaGUgY29udHJvbGxlciBzdGF0ZS5cbiAqIEBwYXJhbSBtZXRhZGF0YSAtIFRoZSBjb250cm9sbGVyIHN0YXRlIG1ldGFkYXRhLCB3aGljaCBkZXNjcmliZXMgd2hpY2ggcGllY2VzIG9mIHN0YXRlIHNob3VsZCBiZSBwZXJzaXN0ZWQuXG4gKiBAcmV0dXJucyBUaGUgc3Vic2V0IG9mIGNvbnRyb2xsZXIgc3RhdGUgdGhhdCBzaG91bGQgYmUgcGVyc2lzdGVkLlxuICovXG5mdW5jdGlvbiBnZXRQZXJzaXN0ZW50U3RhdGUoc3RhdGUsIG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIGRlcml2ZVN0YXRlRnJvbU1ldGFkYXRhKHN0YXRlLCBtZXRhZGF0YSwgJ3BlcnNpc3QnKTtcbn1cbmV4cG9ydHMuZ2V0UGVyc2lzdGVudFN0YXRlID0gZ2V0UGVyc2lzdGVudFN0YXRlO1xuLyoqXG4gKiBVc2UgdGhlIG1ldGFkYXRhIHRvIGRlcml2ZSBzdGF0ZSBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIG1ldGFkYXRhIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSBzdGF0ZSAtIFRoZSBmdWxsIGNvbnRyb2xsZXIgc3RhdGUuXG4gKiBAcGFyYW0gbWV0YWRhdGEgLSBUaGUgY29udHJvbGxlciBtZXRhZGF0YS5cbiAqIEBwYXJhbSBtZXRhZGF0YVByb3BlcnR5IC0gVGhlIG1ldGFkYXRhIHByb3BlcnR5IHRvIHVzZSB0byBkZXJpdmUgc3RhdGUuXG4gKiBAcmV0dXJucyBUaGUgbWV0YWRhdGEtZGVyaXZlZCBjb250cm9sbGVyIHN0YXRlLlxuICovXG5mdW5jdGlvbiBkZXJpdmVTdGF0ZUZyb21NZXRhZGF0YShzdGF0ZSwgbWV0YWRhdGEsIG1ldGFkYXRhUHJvcGVydHkpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc3RhdGUpLnJlZHVjZSgocGVyc2lzdGVkU3RhdGUsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCBwcm9wZXJ0eU1ldGFkYXRhID0gbWV0YWRhdGFba2V5XVttZXRhZGF0YVByb3BlcnR5XTtcbiAgICAgICAgY29uc3Qgc3RhdGVQcm9wZXJ0eSA9IHN0YXRlW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHlNZXRhZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcGVyc2lzdGVkU3RhdGVba2V5XSA9IHByb3BlcnR5TWV0YWRhdGEoc3RhdGVQcm9wZXJ0eSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvcGVydHlNZXRhZGF0YSkge1xuICAgICAgICAgICAgcGVyc2lzdGVkU3RhdGVba2V5XSA9IHN0YXRlUHJvcGVydHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBlcnNpc3RlZFN0YXRlO1xuICAgIH0sIHt9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhc2VDb250cm9sbGVyVjIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVG9rZW5MaXN0Q29udHJvbGxlciA9IHZvaWQgMDtcbmNvbnN0IGNvbnRyYWN0X21ldGFkYXRhXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBtZXRhbWFzay9jb250cmFjdC1tZXRhZGF0YVwiKSk7XG5jb25zdCBhc3luY19tdXRleF8xID0gcmVxdWlyZShcImFzeW5jLW11dGV4XCIpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1uYW1lZC1hcy1kZWZhdWx0XG5jb25zdCBhYm9ydF9jb250cm9sbGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFib3J0LWNvbnRyb2xsZXJcIikpO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJWMl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyVjJcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IHRva2VuX3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9hcGlzL3Rva2VuLXNlcnZpY2VcIik7XG5jb25zdCBERUZBVUxUX0lOVEVSVkFMID0gNjAgKiA2MCAqIDEwMDA7XG5jb25zdCBERUZBVUxUX1RIUkVTSE9MRCA9IDYwICogMzAgKiAxMDAwO1xuY29uc3QgbmFtZSA9ICdUb2tlbkxpc3RDb250cm9sbGVyJztcbmNvbnN0IG1ldGFkYXRhID0ge1xuICAgIHRva2VuTGlzdDogeyBwZXJzaXN0OiB0cnVlLCBhbm9ueW1vdXM6IHRydWUgfSxcbiAgICB0b2tlbnNDaGFpbnNDYWNoZTogeyBwZXJzaXN0OiB0cnVlLCBhbm9ueW1vdXM6IHRydWUgfSxcbn07XG5jb25zdCBkZWZhdWx0U3RhdGUgPSB7XG4gICAgdG9rZW5MaXN0OiB7fSxcbiAgICB0b2tlbnNDaGFpbnNDYWNoZToge30sXG59O1xuLyoqXG4gKiBDb250cm9sbGVyIHRoYXQgcGFzc2l2ZWx5IHBvbGxzIG9uIGEgc2V0IGludGVydmFsIGZvciB0aGUgbGlzdCBvZiB0b2tlbnMgZnJvbSBtZXRhc3dhcHMgYXBpXG4gKi9cbmNsYXNzIFRva2VuTGlzdENvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlclYyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8vIHByaXZhdGUgYWJvcnRTaWduYWw6IEFib3J0U2lnbmFsO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBUb2tlbkxpc3RDb250cm9sbGVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgY29udHJvbGxlciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNoYWluSWQgLSBUaGUgY2hhaW4gSUQgb2YgdGhlIGN1cnJlbnQgbmV0d29yay5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy51c2VTdGF0aWNUb2tlbkxpc3QgLSBJbmRpY2F0ZXMgd2hldGhlciB0byB1c2UgdGhlIHN0YXRpYyB0b2tlbiBsaXN0IG9yIG5vdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vbk5ldHdvcmtTdGF0ZUNoYW5nZSAtIEEgZnVuY3Rpb24gZm9yIHJlZ2lzdGVyaW5nIGFuIGV2ZW50IGhhbmRsZXIgZm9yIG5ldHdvcmsgc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vblByZWZlcmVuY2VzU3RhdGVDaGFuZ2UgLUEgZnVuY3Rpb24gZm9yIHJlZ2lzdGVyaW5nIGFuIGV2ZW50IGhhbmRsZXIgZm9yIHByZWZlcmVuY2Ugc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pbnRlcnZhbCAtIFRoZSBwb2xsaW5nIGludGVydmFsLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY2FjaGVSZWZyZXNoVGhyZXNob2xkIC0gVGhlIHRva2VuIGNhY2hlIGV4cGlyeSB0aW1lLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubWVzc2VuZ2VyIC0gQSByZXN0cmljdGVkIGNvbnRyb2xsZXIgbWVzc2VuZ2VyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgY2hhaW5JZCwgdXNlU3RhdGljVG9rZW5MaXN0LCBvbk5ldHdvcmtTdGF0ZUNoYW5nZSwgb25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlLCBpbnRlcnZhbCA9IERFRkFVTFRfSU5URVJWQUwsIGNhY2hlUmVmcmVzaFRocmVzaG9sZCA9IERFRkFVTFRfVEhSRVNIT0xELCBtZXNzZW5nZXIsIHN0YXRlLCB9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgIG1lc3NlbmdlcixcbiAgICAgICAgICAgIHN0YXRlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRTdGF0ZSksIHN0YXRlKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubXV0ZXggPSBuZXcgYXN5bmNfbXV0ZXhfMS5NdXRleCgpO1xuICAgICAgICB0aGlzLmludGVydmFsRGVsYXkgPSBpbnRlcnZhbDtcbiAgICAgICAgdGhpcy5jYWNoZVJlZnJlc2hUaHJlc2hvbGQgPSBjYWNoZVJlZnJlc2hUaHJlc2hvbGQ7XG4gICAgICAgIHRoaXMuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgICAgIHRoaXMudXNlU3RhdGljVG9rZW5MaXN0ID0gdXNlU3RhdGljVG9rZW5MaXN0O1xuICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IG5ldyBhYm9ydF9jb250cm9sbGVyXzEuZGVmYXVsdCgpO1xuICAgICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZSgobmV0d29ya1N0YXRlKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFpbklkICE9PSBuZXR3b3JrU3RhdGUucHJvdmlkZXIuY2hhaW5JZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBuZXcgYWJvcnRfY29udHJvbGxlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYWluSWQgPSBuZXR3b3JrU3RhdGUucHJvdmlkZXIuY2hhaW5JZDtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnJlc3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBvblByZWZlcmVuY2VzU3RhdGVDaGFuZ2UoKHByZWZlcmVuY2VzU3RhdGUpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnVzZVN0YXRpY1Rva2VuTGlzdCAhPT0gcHJlZmVyZW5jZXNTdGF0ZS51c2VTdGF0aWNUb2tlbkxpc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gbmV3IGFib3J0X2NvbnRyb2xsZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy51c2VTdGF0aWNUb2tlbkxpc3QgPSBwcmVmZXJlbmNlc1N0YXRlLnVzZVN0YXRpY1Rva2VuTGlzdDtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnJlc3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBwb2xsaW5nIGZvciB0aGUgdG9rZW4gbGlzdC5cbiAgICAgKi9cbiAgICBzdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuc3RhcnRQb2xsaW5nKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXN0YXJ0IHBvbGxpbmcgZm9yIHRoZSB0b2tlbiBsaXN0LlxuICAgICAqL1xuICAgIHJlc3RhcnQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BQb2xsaW5nKCk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnN0YXJ0UG9sbGluZygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcCBwb2xsaW5nIGZvciB0aGUgdG9rZW4gbGlzdC5cbiAgICAgKi9cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLnN0b3BQb2xsaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdG8gZGlzY2FyZCB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIHN0b3BzIGFueSBhY3RpdmUgcG9sbGluZy5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc3RvcFBvbGxpbmcoKTtcbiAgICB9XG4gICAgc3RvcFBvbGxpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVydmFsSWQpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgYSBuZXcgcG9sbGluZyBpbnRlcnZhbC5cbiAgICAgKi9cbiAgICBzdGFydFBvbGxpbmcoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB1dGlsXzEuc2FmZWx5RXhlY3V0ZSgoKSA9PiB0aGlzLmZldGNoVG9rZW5MaXN0KCkpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IHRoaXMuZmV0Y2hUb2tlbkxpc3QoKSk7XG4gICAgICAgICAgICB9KSwgdGhpcy5pbnRlcnZhbERlbGF5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoaW5nIHRva2VuIGxpc3QuXG4gICAgICovXG4gICAgZmV0Y2hUb2tlbkxpc3QoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy51c2VTdGF0aWNUb2tlbkxpc3QpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmZldGNoRnJvbVN0YXRpY1Rva2VuTGlzdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5mZXRjaEZyb21EeW5hbWljVG9rZW5MaXN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGluZyB0b2tlbiBsaXN0IGZyb20gdGhlIGNvbnRyYWN0LW1ldGFkYXRhIGFzIGEgZmFsbGJhY2suXG4gICAgICovXG4gICAgZmV0Y2hGcm9tU3RhdGljVG9rZW5MaXN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5MaXN0ID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRva2VuQWRkcmVzcyBpbiBjb250cmFjdF9tZXRhZGF0YV8xLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBfYSA9IGNvbnRyYWN0X21ldGFkYXRhXzEuZGVmYXVsdFt0b2tlbkFkZHJlc3NdLCB7IGVyYzIwLCBsb2dvOiBmaWxlUGF0aCB9ID0gX2EsIHRva2VuID0gX19yZXN0KF9hLCBbXCJlcmMyMFwiLCBcImxvZ29cIl0pO1xuICAgICAgICAgICAgICAgIGlmIChlcmMyMCkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbkxpc3RbdG9rZW5BZGRyZXNzXSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdG9rZW4pLCB7IGFkZHJlc3M6IHRva2VuQWRkcmVzcywgaWNvblVybDogZmlsZVBhdGgsIG9jY3VycmVuY2VzOiBudWxsIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbkxpc3QsXG4gICAgICAgICAgICAgICAgICAgIHRva2Vuc0NoYWluc0NhY2hlOiB7fSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGluZyB0b2tlbiBsaXN0IGZyb20gdGhlIFRva2VuIFNlcnZpY2UgQVBJLlxuICAgICAqL1xuICAgIGZldGNoRnJvbUR5bmFtaWNUb2tlbkxpc3QoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZWxlYXNlTG9jayA9IHlpZWxkIHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWRUb2tlbnMgPSB5aWVsZCB1dGlsXzEuc2FmZWx5RXhlY3V0ZSgoKSA9PiB0aGlzLmZldGNoRnJvbUNhY2hlKCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IF9hID0gdGhpcy5zdGF0ZSwgeyB0b2tlbnNDaGFpbnNDYWNoZSB9ID0gX2EsIHRva2Vuc0RhdGEgPSBfX3Jlc3QoX2EsIFtcInRva2Vuc0NoYWluc0NhY2hlXCJdKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbkxpc3QgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgY2FjaGVkVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbkxpc3RbdG9rZW4uYWRkcmVzc10gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5zRnJvbUFQSSA9IHlpZWxkIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IHRva2VuX3NlcnZpY2VfMS5mZXRjaFRva2VuTGlzdCh0aGlzLmNoYWluSWQsIHRoaXMuYWJvcnRDb250cm9sbGVyLnNpZ25hbCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRva2Vuc0Zyb21BUEkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhY2t1cFRva2VuTGlzdCA9IHRva2Vuc0NoYWluc0NhY2hlW3RoaXMuY2hhaW5JZF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRva2Vuc0NoYWluc0NhY2hlW3RoaXMuY2hhaW5JZF0uZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIGJhY2t1cFRva2VuTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuTGlzdFt0b2tlbi5hZGRyZXNzXSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRva2Vuc0RhdGEpLCB7IHRva2VuTGlzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zQ2hhaW5zQ2FjaGUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBmaWx0ZXJpbmcgb3V0IHRva2VucyB3aXRoIGxlc3MgdGhhbiAyIG9jY3VycmVuY2VzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkVG9rZW5MaXN0ID0gdG9rZW5zRnJvbUFQSS5maWx0ZXIoKHRva2VuKSA9PiB0b2tlbi5vY2N1cnJlbmNlcyAmJiB0b2tlbi5vY2N1cnJlbmNlcyA+PSAyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZpbmcgdGhlIHRva2VucyB3aXRoIHN5bWJvbCBjb25mbGljdHNcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ltYm9sc0xpc3QgPSBmaWx0ZXJlZFRva2VuTGlzdC5tYXAoKHRva2VuKSA9PiB0b2tlbi5zeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkdXBsaWNhdGVTeW1ib2xzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ubmV3IFNldChzeW1ib2xzTGlzdC5maWx0ZXIoKHN5bWJvbCwgaW5kZXgpID0+IHN5bWJvbHNMaXN0LmluZGV4T2Yoc3ltYm9sKSAhPT0gaW5kZXgpKSxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5pcXVlVG9rZW5MaXN0ID0gZmlsdGVyZWRUb2tlbkxpc3QuZmlsdGVyKCh0b2tlbikgPT4gIWR1cGxpY2F0ZVN5bWJvbHMuaW5jbHVkZXModG9rZW4uc3ltYm9sKSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdW5pcXVlVG9rZW5MaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbkxpc3RbdG9rZW4uYWRkcmVzc10gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkVG9rZW5zQ2hhaW5zQ2FjaGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRva2Vuc0NoYWluc0NhY2hlKSwgeyBbdGhpcy5jaGFpbklkXToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LnZhbHVlcyh0b2tlbkxpc3QpLFxuICAgICAgICAgICAgICAgICAgICB9IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdG9rZW5zRGF0YSksIHsgdG9rZW5MaXN0LCB0b2tlbnNDaGFpbnNDYWNoZTogdXBkYXRlZFRva2Vuc0NoYWluc0NhY2hlIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgQ2FjaGUgdGltZXN0YW1wIGlzIHZhbGlkLFxuICAgICAqIGlmIHllcyBkYXRhIGluIGNhY2hlIHdpbGwgYmUgcmV0dXJuZWRcbiAgICAgKiBvdGhlcndpc2UgbnVsbCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGNhY2hlZCBkYXRhLCBvciBgbnVsbGAgaWYgdGhlIGNhY2hlIHdhcyBleHBpcmVkLlxuICAgICAqL1xuICAgIGZldGNoRnJvbUNhY2hlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyB0b2tlbnNDaGFpbnNDYWNoZSB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFDYWNoZSA9IHRva2Vuc0NoYWluc0NhY2hlW3RoaXMuY2hhaW5JZF07XG4gICAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgaWYgKChkYXRhQ2FjaGUgPT09IG51bGwgfHwgZGF0YUNhY2hlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhQ2FjaGUuZGF0YSkgJiZcbiAgICAgICAgICAgICAgICBub3cgLSAoZGF0YUNhY2hlID09PSBudWxsIHx8IGRhdGFDYWNoZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YUNhY2hlLnRpbWVzdGFtcCkgPCB0aGlzLmNhY2hlUmVmcmVzaFRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhQ2FjaGUuZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggbWV0YWRhdGEgZm9yIGEgdG9rZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9rZW5BZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIHRva2VuLlxuICAgICAqIEByZXR1cm5zIFRoZSB0b2tlbiBtZXRhZGF0YS5cbiAgICAgKi9cbiAgICBmZXRjaFRva2VuTWV0YWRhdGEodG9rZW5BZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZWxlYXNlTG9jayA9IHlpZWxkIHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbiA9ICh5aWVsZCB0b2tlbl9zZXJ2aWNlXzEuZmV0Y2hUb2tlbk1ldGFkYXRhKHRoaXMuY2hhaW5JZCwgdG9rZW5BZGRyZXNzLCB0aGlzLmFib3J0Q29udHJvbGxlci5zaWduYWwpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlRva2VuTGlzdENvbnRyb2xsZXIgPSBUb2tlbkxpc3RDb250cm9sbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gVG9rZW5MaXN0Q29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRva2VuTGlzdENvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVG9rZW5zQ29udHJvbGxlciA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IGNvbnRyYWN0X21ldGFkYXRhXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBtZXRhbWFzay9jb250cmFjdC1tZXRhZGF0YVwiKSk7XG5jb25zdCBtZXRhbWFza19ldGhfYWJpc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay9tZXRhbWFzay1ldGgtYWJpc1wiKTtcbmNvbnN0IHV1aWRfMSA9IHJlcXVpcmUoXCJ1dWlkXCIpO1xuY29uc3QgYXN5bmNfbXV0ZXhfMSA9IHJlcXVpcmUoXCJhc3luYy1tdXRleFwiKTtcbmNvbnN0IGV0aGVyc18xID0gcmVxdWlyZShcImV0aGVyc1wiKTtcbmNvbnN0IEJhc2VDb250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vQmFzZUNvbnRyb2xsZXJcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbnZhciBTdWdnZXN0ZWRBc3NldFN0YXR1cztcbihmdW5jdGlvbiAoU3VnZ2VzdGVkQXNzZXRTdGF0dXMpIHtcbiAgICBTdWdnZXN0ZWRBc3NldFN0YXR1c1tcImFjY2VwdGVkXCJdID0gXCJhY2NlcHRlZFwiO1xuICAgIFN1Z2dlc3RlZEFzc2V0U3RhdHVzW1wiZmFpbGVkXCJdID0gXCJmYWlsZWRcIjtcbiAgICBTdWdnZXN0ZWRBc3NldFN0YXR1c1tcInBlbmRpbmdcIl0gPSBcInBlbmRpbmdcIjtcbiAgICBTdWdnZXN0ZWRBc3NldFN0YXR1c1tcInJlamVjdGVkXCJdID0gXCJyZWplY3RlZFwiO1xufSkoU3VnZ2VzdGVkQXNzZXRTdGF0dXMgfHwgKFN1Z2dlc3RlZEFzc2V0U3RhdHVzID0ge30pKTtcbi8qKlxuICogQ29udHJvbGxlciB0aGF0IHN0b3JlcyBhc3NldHMgYW5kIGV4cG9zZXMgY29udmVuaWVuY2UgbWV0aG9kc1xuICovXG5jbGFzcyBUb2tlbnNDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFRva2Vuc0NvbnRyb2xsZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBjb250cm9sbGVyIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMub25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlIC0gQWxsb3dzIHN1YnNjcmliaW5nIHRvIHByZWZlcmVuY2UgY29udHJvbGxlciBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm9uTmV0d29ya1N0YXRlQ2hhbmdlIC0gQWxsb3dzIHN1YnNjcmliaW5nIHRvIG5ldHdvcmsgY29udHJvbGxlciBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvbmZpZyAtIEluaXRpYWwgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBvblByZWZlcmVuY2VzU3RhdGVDaGFuZ2UsIG9uTmV0d29ya1N0YXRlQ2hhbmdlLCBjb25maWcsIHN0YXRlLCB9KSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc3RhdGUpO1xuICAgICAgICB0aGlzLm11dGV4ID0gbmV3IGFzeW5jX211dGV4XzEuTXV0ZXgoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50RW1pdHRlciBpbnN0YW5jZSB1c2VkIHRvIGxpc3RlbiB0byBzcGVjaWZpYyBFSVA3NDcgZXZlbnRzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmh1YiA9IG5ldyBldmVudHNfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhpcyBjb250cm9sbGVyIHVzZWQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnVG9rZW5zQ29udHJvbGxlcic7XG4gICAgICAgIHRoaXMuZGVmYXVsdENvbmZpZyA9IE9iamVjdC5hc3NpZ24oeyBuZXR3b3JrVHlwZTogY29uc3RhbnRzXzEuTUFJTk5FVCwgc2VsZWN0ZWRBZGRyZXNzOiAnJywgY2hhaW5JZDogJycsIHByb3ZpZGVyOiB1bmRlZmluZWQgfSwgY29uZmlnKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUgPSBPYmplY3QuYXNzaWduKHsgYWxsVG9rZW5zOiB7fSwgYWxsSWdub3JlZFRva2Vuczoge30sIGlnbm9yZWRUb2tlbnM6IFtdLCBzdWdnZXN0ZWRBc3NldHM6IFtdLCB0b2tlbnM6IFtdIH0sIHN0YXRlKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIG9uUHJlZmVyZW5jZXNTdGF0ZUNoYW5nZSgoeyBzZWxlY3RlZEFkZHJlc3MgfSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IHsgYWxsVG9rZW5zLCBhbGxJZ25vcmVkVG9rZW5zIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY29uc3QgeyBjaGFpbklkIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJlKHsgc2VsZWN0ZWRBZGRyZXNzIH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgICAgIHRva2VuczogKChfYSA9IGFsbFRva2Vuc1tjaGFpbklkXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3NlbGVjdGVkQWRkcmVzc10pIHx8IFtdLFxuICAgICAgICAgICAgICAgIGlnbm9yZWRUb2tlbnM6ICgoX2IgPSBhbGxJZ25vcmVkVG9rZW5zW2NoYWluSWRdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Jbc2VsZWN0ZWRBZGRyZXNzXSkgfHwgW10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uTmV0d29ya1N0YXRlQ2hhbmdlKCh7IHByb3ZpZGVyIH0pID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb25zdCB7IGFsbFRva2VucywgYWxsSWdub3JlZFRva2VucyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0ZWRBZGRyZXNzIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhaW5JZCB9ID0gcHJvdmlkZXI7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZSh7IGNoYWluSWQgfSk7XG4gICAgICAgICAgICB0aGlzLmV0aGVyc1Byb3ZpZGVyID0gdGhpcy5faW5zdGFudGlhdGVOZXdFdGhlcnNQcm92aWRlcigpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgICAgIHRva2VuczogKChfYSA9IGFsbFRva2Vuc1tjaGFpbklkXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3NlbGVjdGVkQWRkcmVzc10pIHx8IFtdLFxuICAgICAgICAgICAgICAgIGlnbm9yZWRUb2tlbnM6ICgoX2IgPSBhbGxJZ25vcmVkVG9rZW5zW2NoYWluSWRdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Jbc2VsZWN0ZWRBZGRyZXNzXSkgfHwgW10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZhaWxTdWdnZXN0ZWRBc3NldChzdWdnZXN0ZWRBc3NldE1ldGEsIGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGZhaWxlZFN1Z2dlc3RlZEFzc2V0TWV0YSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3VnZ2VzdGVkQXNzZXRNZXRhKSwgeyBzdGF0dXM6IFN1Z2dlc3RlZEFzc2V0U3RhdHVzLmZhaWxlZCwgZXJyb3IgfSk7XG4gICAgICAgIHRoaXMuaHViLmVtaXQoYCR7c3VnZ2VzdGVkQXNzZXRNZXRhLmlkfTpmaW5pc2hlZGAsIGZhaWxlZFN1Z2dlc3RlZEFzc2V0TWV0YSk7XG4gICAgfVxuICAgIF9pbnN0YW50aWF0ZU5ld0V0aGVyc1Byb3ZpZGVyKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBuZXcgZXRoZXJzXzEuZXRoZXJzLnByb3ZpZGVycy5XZWIzUHJvdmlkZXIoKF9hID0gdGhpcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcm92aWRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB0b2tlbiB0byB0aGUgc3RvcmVkIHRva2VuIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEhleCBhZGRyZXNzIG9mIHRoZSB0b2tlbiBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gc3ltYm9sIC0gU3ltYm9sIG9mIHRoZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0gZGVjaW1hbHMgLSBOdW1iZXIgb2YgZGVjaW1hbHMgdGhlIHRva2VuIHVzZXMuXG4gICAgICogQHBhcmFtIGltYWdlIC0gSW1hZ2Ugb2YgdGhlIHRva2VuLlxuICAgICAqIEByZXR1cm5zIEN1cnJlbnQgdG9rZW4gbGlzdC5cbiAgICAgKi9cbiAgICBhZGRUb2tlbihhZGRyZXNzLCBzeW1ib2wsIGRlY2ltYWxzLCBpbWFnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVsZWFzZUxvY2sgPSB5aWVsZCB0aGlzLm11dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzcyA9IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRva2VucywgaWdub3JlZFRva2VucyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0VSQzcyMSA9IHlpZWxkIHRoaXMuX2RldGVjdElzRVJDNzIxKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0VudHJ5ID0geyBhZGRyZXNzLCBzeW1ib2wsIGRlY2ltYWxzLCBpbWFnZSwgaXNFUkM3MjEgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0VudHJ5ID0gdG9rZW5zLmZpbmQoKHRva2VuKSA9PiB0b2tlbi5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRva2Vucy5pbmRleE9mKHByZXZpb3VzRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnNbcHJldmlvdXNJbmRleF0gPSBuZXdFbnRyeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKG5ld0VudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3SWdub3JlZFRva2VucyA9IGlnbm9yZWRUb2tlbnMuZmlsdGVyKCh0b2tlbkFkZHJlc3MpID0+IHRva2VuQWRkcmVzcy50b0xvd2VyQ2FzZSgpICE9PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbmV3QWxsVG9rZW5zLCBuZXdBbGxJZ25vcmVkVG9rZW5zIH0gPSB0aGlzLl9nZXROZXdBbGxUb2tlbnNTdGF0ZSh0b2tlbnMsIG5ld0lnbm9yZWRUb2tlbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgYWxsVG9rZW5zOiBuZXdBbGxUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgIHRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgYWxsSWdub3JlZFRva2VuczogbmV3QWxsSWdub3JlZFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgaWdub3JlZFRva2VuczogbmV3SWdub3JlZFRva2VucyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBiYXRjaCBvZiB0b2tlbnMgdG8gdGhlIHN0b3JlZCB0b2tlbiBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRva2Vuc1RvQWRkIC0gQXJyYXkgb2YgVG9rZW5zIHRvIGJlIGFkZGVkIG9yIHVwZGF0ZWQuXG4gICAgICogQHJldHVybnMgQ3VycmVudCB0b2tlbiBsaXN0LlxuICAgICAqL1xuICAgIGFkZFRva2Vucyh0b2tlbnNUb0FkZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVsZWFzZUxvY2sgPSB5aWVsZCB0aGlzLm11dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgdG9rZW5zLCBpZ25vcmVkVG9rZW5zIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0b2tlbnNUb0FkZCA9IHlpZWxkIFByb21pc2UuYWxsKHRva2Vuc1RvQWRkLm1hcCgodG9rZW4pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4uaXNFUkM3MjEgPSB5aWVsZCB0aGlzLl9kZXRlY3RJc0VSQzcyMSh0b2tlbi5hZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICAgICAgbGV0IG5ld0lnbm9yZWRUb2tlbnMgPSBpZ25vcmVkVG9rZW5zO1xuICAgICAgICAgICAgICAgIHRva2Vuc1RvQWRkLmZvckVhY2goKHRva2VuVG9BZGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBhZGRyZXNzLCBzeW1ib2wsIGRlY2ltYWxzLCBpbWFnZSwgaXNFUkM3MjEgfSA9IHRva2VuVG9BZGQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrc3VtQWRkcmVzcyA9IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3RW50cnkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNpbWFscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNFUkM3MjEsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzRW50cnkgPSB0b2tlbnMuZmluZCgodG9rZW4pID0+IHRva2VuLmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gY2hlY2tzdW1BZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRva2Vucy5pbmRleE9mKHByZXZpb3VzRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zW3ByZXZpb3VzSW5kZXhdID0gbmV3RW50cnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaChuZXdFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV3SWdub3JlZFRva2VucyA9IG5ld0lnbm9yZWRUb2tlbnMuZmlsdGVyKCh0b2tlbkFkZHJlc3MpID0+IHRva2VuQWRkcmVzcy50b0xvd2VyQ2FzZSgpICE9PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbmV3QWxsVG9rZW5zLCBuZXdBbGxJZ25vcmVkVG9rZW5zIH0gPSB0aGlzLl9nZXROZXdBbGxUb2tlbnNTdGF0ZSh0b2tlbnMsIG5ld0lnbm9yZWRUb2tlbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICBhbGxUb2tlbnM6IG5ld0FsbFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgYWxsSWdub3JlZFRva2VuczogbmV3QWxsSWdub3JlZFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgaWdub3JlZFRva2VuczogbmV3SWdub3JlZFRva2VucyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgaXNFUkM3MjEgZmllbGQgdG8gdG9rZW4gb2JqZWN0LiBUaGlzIGlzIGNhbGxlZCB3aGVuIGEgdXNlciBhdHRlbXB0cyB0byBhZGQgdG9rZW5zIHRoYXRcbiAgICAgKiB3ZXJlIHByZXZpb3VzbHkgYWRkZWQgd2hpY2ggZG8gbm90IHlldCBoYWQgaXNFUkM3MjEgZmllbGQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9rZW5BZGRyZXNzIC0gVGhlIGNvbnRyYWN0IGFkZHJlc3Mgb2YgdGhlIHRva2VuIHJlcXVpcmluZyB0aGUgaXNFUkM3MjEgZmllbGQgYWRkZWQuXG4gICAgICogQHJldHVybnMgVGhlIG5ldyB0b2tlbiBvYmplY3Qgd2l0aCB0aGUgYWRkZWQgaXNFUkM3MjEgZmllbGQuXG4gICAgICovXG4gICAgdXBkYXRlVG9rZW5UeXBlKHRva2VuQWRkcmVzcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgaXNFUkM3MjEgPSB5aWVsZCB0aGlzLl9kZXRlY3RJc0VSQzcyMSh0b2tlbkFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3QgeyB0b2tlbnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCB0b2tlbkluZGV4ID0gdG9rZW5zLmZpbmRJbmRleCgodG9rZW4pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4uYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSB0b2tlbkFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuSW5kZXhdLmlzRVJDNzIxID0gaXNFUkM3MjE7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IHRva2VucyB9KTtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbnNbdG9rZW5JbmRleF07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlY3RzIHdoZXRoZXIgb3Igbm90IGEgdG9rZW4gaXMgRVJDLTcyMSBjb21wYXRpYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRva2VuQWRkcmVzcyAtIFRoZSB0b2tlbiBjb250cmFjdCBhZGRyZXNzLlxuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHRva2VuIGFkZHJlc3MgcGFzc2VkIGluIHN1cHBvcnRzIHRoZSBFSVAtNzIxXG4gICAgICogaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIF9kZXRlY3RJc0VSQzcyMSh0b2tlbkFkZHJlc3MpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrc3VtQWRkcmVzcyA9IHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcyh0b2tlbkFkZHJlc3MpO1xuICAgICAgICAgICAgLy8gaWYgdGhpcyB0b2tlbiBpcyBhbHJlYWR5IGluIG91ciBjb250cmFjdCBtZXRhZGF0YSBtYXAgd2UgZG9uJ3QgbmVlZFxuICAgICAgICAgICAgLy8gdG8gY2hlY2sgYWdhaW5zdCB0aGUgY29udHJhY3RcbiAgICAgICAgICAgIGlmICgoKF9hID0gY29udHJhY3RfbWV0YWRhdGFfMS5kZWZhdWx0W2NoZWNrc3VtQWRkcmVzc10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lcmM3MjEpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCgoX2IgPSBjb250cmFjdF9tZXRhZGF0YV8xLmRlZmF1bHRbY2hlY2tzdW1BZGRyZXNzXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmVyYzIwKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG9rZW5Db250cmFjdCA9IHlpZWxkIHRoaXMuX2NyZWF0ZUV0aGVyc0NvbnRyYWN0KHRva2VuQWRkcmVzcywgbWV0YW1hc2tfZXRoX2FiaXNfMS5hYmlFUkM3MjEsIHRoaXMuZXRoZXJzUHJvdmlkZXIpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdG9rZW5Db250cmFjdC5zdXBwb3J0c0ludGVyZmFjZShjb25zdGFudHNfMS5FUkM3MjFfSU5URVJGQUNFX0lEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnRseSB3ZSBzZWUgYSB2YXJpZXR5IG9mIGVycm9ycyBhY3Jvc3MgZGlmZmVyZW50IG5ldHdvcmtzIHdoZW5cbiAgICAgICAgICAgICAgICAvLyB0b2tlbiBjb250cmFjdHMgYXJlIG5vdCBFUkM3MjEgY29tcGF0aWJsZS4gV2UgbmVlZCB0byBmaWd1cmUgb3V0IGEgYmV0dGVyXG4gICAgICAgICAgICAgICAgLy8gd2F5IG9mIGRpZmZlcmVudGlhdGluZyB0b2tlbiBpbnRlcmZhY2UgdHlwZXMgYnV0IGZvciBub3cgaWYgd2UgZ2V0IGFuIGVycm9yXG4gICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byBhc3N1bWUgdGhlIHRva2VuIGlzIG5vdCBFUkM3MjEgY29tcGF0aWJsZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfY3JlYXRlRXRoZXJzQ29udHJhY3QodG9rZW5BZGRyZXNzLCBhYmksIGV0aGVyc1Byb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbkNvbnRyYWN0ID0geWllbGQgbmV3IGV0aGVyc18xLmV0aGVycy5Db250cmFjdCh0b2tlbkFkZHJlc3MsIGFiaSwgZXRoZXJzUHJvdmlkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuQ29udHJhY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2VuZXJhdGVSYW5kb21JZCgpIHtcbiAgICAgICAgcmV0dXJuIHV1aWRfMS52MSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IHN1Z2dlc3RlZEFzc2V0IHRvIHN0YXRlLiBQYXJhbWV0ZXJzIHdpbGwgYmUgdmFsaWRhdGVkIGFjY29yZGluZyB0b1xuICAgICAqIGFzc2V0IHR5cGUgYmVpbmcgd2F0Y2hlZC4gQSBgPHN1Z2dlc3RlZEFzc2V0TWV0YS5pZD46cGVuZGluZ2AgaHViIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCBvbmNlIGFkZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2V0IC0gVGhlIGFzc2V0IHRvIGJlIHdhdGNoZWQuIEZvciBub3cgb25seSBFUkMyMCB0b2tlbnMgYXJlIGFjY2VwdGVkLlxuICAgICAqIEBwYXJhbSB0eXBlIC0gVGhlIGFzc2V0IHR5cGUuXG4gICAgICogQHJldHVybnMgT2JqZWN0IGNvbnRhaW5pbmcgYSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgc3VnZ2VzdGVkQXNzZXQgYWRkcmVzcyBpZiBhY2NlcHRlZC5cbiAgICAgKi9cbiAgICB3YXRjaEFzc2V0KGFzc2V0LCB0eXBlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBzdWdnZXN0ZWRBc3NldE1ldGEgPSB7XG4gICAgICAgICAgICAgICAgYXNzZXQsXG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuX2dlbmVyYXRlUmFuZG9tSWQoKSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFN1Z2dlc3RlZEFzc2V0U3RhdHVzLnBlbmRpbmcsXG4gICAgICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0VSQzIwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxfMS52YWxpZGF0ZVRva2VuVG9XYXRjaChhc3NldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXNzZXQgb2YgdHlwZSAke3R5cGV9IG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZhaWxTdWdnZXN0ZWRBc3NldChzdWdnZXN0ZWRBc3NldE1ldGEsIGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaHViLm9uY2UoYCR7c3VnZ2VzdGVkQXNzZXRNZXRhLmlkfTpmaW5pc2hlZGAsIChtZXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobWV0YS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3VnZ2VzdGVkQXNzZXRTdGF0dXMuYWNjZXB0ZWQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobWV0YS5hc3NldC5hZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3VnZ2VzdGVkQXNzZXRTdGF0dXMucmVqZWN0ZWQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ1VzZXIgcmVqZWN0ZWQgdG8gd2F0Y2ggdGhlIGFzc2V0LicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3VnZ2VzdGVkQXNzZXRTdGF0dXMuZmFpbGVkOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKG1ldGEuZXJyb3IubWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoYFVua25vd24gc3RhdHVzOiAke21ldGEuc3RhdHVzfWApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB7IHN1Z2dlc3RlZEFzc2V0cyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIHN1Z2dlc3RlZEFzc2V0cy5wdXNoKHN1Z2dlc3RlZEFzc2V0TWV0YSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IHN1Z2dlc3RlZEFzc2V0czogWy4uLnN1Z2dlc3RlZEFzc2V0c10gfSk7XG4gICAgICAgICAgICB0aGlzLmh1Yi5lbWl0KCdwZW5kaW5nU3VnZ2VzdGVkQXNzZXQnLCBzdWdnZXN0ZWRBc3NldE1ldGEpO1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0LCBzdWdnZXN0ZWRBc3NldE1ldGEgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjY2VwdHMgdG8gd2F0Y2ggYW4gYXNzZXQgYW5kIHVwZGF0ZXMgaXQncyBzdGF0dXMgYW5kIGRlbGV0ZXMgdGhlIHN1Z2dlc3RlZEFzc2V0IGZyb20gc3RhdGUsXG4gICAgICogYWRkaW5nIHRoZSBhc3NldCB0byBjb3JyZXNwb25kaW5nIGFzc2V0IHN0YXRlLiBJbiB0aGlzIGNhc2UgRVJDMjAgdG9rZW5zLlxuICAgICAqIEEgYDxzdWdnZXN0ZWRBc3NldE1ldGEuaWQ+OmZpbmlzaGVkYCBodWIgZXZlbnQgaXMgZmlyZWQgYWZ0ZXIgYWNjZXB0ZWQgb3IgZmFpbHVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWdnZXN0ZWRBc3NldElEIC0gVGhlIElEIG9mIHRoZSBzdWdnZXN0ZWRBc3NldCB0byBhY2NlcHQuXG4gICAgICovXG4gICAgYWNjZXB0V2F0Y2hBc3NldChzdWdnZXN0ZWRBc3NldElEKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHN1Z2dlc3RlZEFzc2V0cyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3VnZ2VzdGVkQXNzZXRzLmZpbmRJbmRleCgoeyBpZCB9KSA9PiBzdWdnZXN0ZWRBc3NldElEID09PSBpZCk7XG4gICAgICAgICAgICBjb25zdCBzdWdnZXN0ZWRBc3NldE1ldGEgPSBzdWdnZXN0ZWRBc3NldHNbaW5kZXhdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHN1Z2dlc3RlZEFzc2V0TWV0YS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0VSQzIwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgYWRkcmVzcywgc3ltYm9sLCBkZWNpbWFscywgaW1hZ2UgfSA9IHN1Z2dlc3RlZEFzc2V0TWV0YS5hc3NldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuYWRkVG9rZW4oYWRkcmVzcywgc3ltYm9sLCBkZWNpbWFscywgaW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkQXNzZXRNZXRhLnN0YXR1cyA9IFN1Z2dlc3RlZEFzc2V0U3RhdHVzLmFjY2VwdGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5odWIuZW1pdChgJHtzdWdnZXN0ZWRBc3NldE1ldGEuaWR9OmZpbmlzaGVkYCwgc3VnZ2VzdGVkQXNzZXRNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc3NldCBvZiB0eXBlICR7c3VnZ2VzdGVkQXNzZXRNZXRhLnR5cGV9IG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZhaWxTdWdnZXN0ZWRBc3NldChzdWdnZXN0ZWRBc3NldE1ldGEsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ld1N1Z2dlc3RlZEFzc2V0cyA9IHN1Z2dlc3RlZEFzc2V0cy5maWx0ZXIoKHsgaWQgfSkgPT4gaWQgIT09IHN1Z2dlc3RlZEFzc2V0SUQpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBzdWdnZXN0ZWRBc3NldHM6IFsuLi5uZXdTdWdnZXN0ZWRBc3NldHNdIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVqZWN0cyBhIHdhdGNoQXNzZXQgcmVxdWVzdCBiYXNlZCBvbiBpdHMgSUQgYnkgc2V0dGluZyBpdHMgc3RhdHVzIHRvIFwicmVqZWN0ZWRcIlxuICAgICAqIGFuZCBlbWl0dGluZyBhIGA8c3VnZ2VzdGVkQXNzZXRNZXRhLmlkPjpmaW5pc2hlZGAgaHViIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN1Z2dlc3RlZEFzc2V0SUQgLSBUaGUgSUQgb2YgdGhlIHN1Z2dlc3RlZEFzc2V0IHRvIGFjY2VwdC5cbiAgICAgKi9cbiAgICByZWplY3RXYXRjaEFzc2V0KHN1Z2dlc3RlZEFzc2V0SUQpIHtcbiAgICAgICAgY29uc3QgeyBzdWdnZXN0ZWRBc3NldHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gc3VnZ2VzdGVkQXNzZXRzLmZpbmRJbmRleCgoeyBpZCB9KSA9PiBzdWdnZXN0ZWRBc3NldElEID09PSBpZCk7XG4gICAgICAgIGNvbnN0IHN1Z2dlc3RlZEFzc2V0TWV0YSA9IHN1Z2dlc3RlZEFzc2V0c1tpbmRleF07XG4gICAgICAgIGlmICghc3VnZ2VzdGVkQXNzZXRNZXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3VnZ2VzdGVkQXNzZXRNZXRhLnN0YXR1cyA9IFN1Z2dlc3RlZEFzc2V0U3RhdHVzLnJlamVjdGVkO1xuICAgICAgICB0aGlzLmh1Yi5lbWl0KGAke3N1Z2dlc3RlZEFzc2V0TWV0YS5pZH06ZmluaXNoZWRgLCBzdWdnZXN0ZWRBc3NldE1ldGEpO1xuICAgICAgICBjb25zdCBuZXdTdWdnZXN0ZWRBc3NldHMgPSBzdWdnZXN0ZWRBc3NldHMuZmlsdGVyKCh7IGlkIH0pID0+IGlkICE9PSBzdWdnZXN0ZWRBc3NldElEKTtcbiAgICAgICAgdGhpcy51cGRhdGUoeyBzdWdnZXN0ZWRBc3NldHM6IFsuLi5uZXdTdWdnZXN0ZWRBc3NldHNdIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgdG9rZW4gZnJvbSB0aGUgc3RvcmVkIHRva2VuIGxpc3QgYW5kIHNhdmVzIGl0IGluIGlnbm9yZWQgdG9rZW5zIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIFRoZSBoZXggYWRkcmVzcyBvZiB0aGUgdG9rZW4gY29udHJhY3QuXG4gICAgICovXG4gICAgcmVtb3ZlQW5kSWdub3JlVG9rZW4oYWRkcmVzcykge1xuICAgICAgICBhZGRyZXNzID0gdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBjb25zdCB7IHRva2VucywgaWdub3JlZFRva2VucyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgYWxyZWFkeUlnbm9yZWQgPSBpZ25vcmVkVG9rZW5zLmZpbmQoKHRva2VuQWRkcmVzcykgPT4gdG9rZW5BZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGNvbnN0IG5ld1Rva2VucyA9IHRva2Vucy5maWx0ZXIoKHRva2VuKSA9PiB7XG4gICAgICAgICAgICBpZiAodG9rZW4uYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAhYWxyZWFkeUlnbm9yZWQgJiYgaWdub3JlZFRva2Vucy5wdXNoKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBuZXdBbGxUb2tlbnMsIG5ld0FsbElnbm9yZWRUb2tlbnMgfSA9IHRoaXMuX2dldE5ld0FsbFRva2Vuc1N0YXRlKG5ld1Rva2VucywgaWdub3JlZFRva2Vucyk7XG4gICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgIGFsbFRva2VuczogbmV3QWxsVG9rZW5zLFxuICAgICAgICAgICAgdG9rZW5zOiBuZXdUb2tlbnMsXG4gICAgICAgICAgICBhbGxJZ25vcmVkVG9rZW5zOiBuZXdBbGxJZ25vcmVkVG9rZW5zLFxuICAgICAgICAgICAgaWdub3JlZFRva2VucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgbmV3IHRva2VucyBhbmQgaWdub3JlZFRva2VucyBhcnJheSBmb3IgdGhlIGN1cnJlbnQgbmV0d29yay9hY2NvdW50IGNvbWJpbmF0aW9uXG4gICAgICogYW5kIHJldHVybnMgbmV3IGFsbFRva2VucyBhbmQgYWxsSWdub3JlZFRva2VucyBzdGF0ZSB0byB1cGRhdGUgdG8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV3VG9rZW5zIC0gVGhlIG5ldyB0b2tlbnMgdG8gc2V0IGZvciB0aGUgY3VycmVudCBuZXR3b3JrIGFuZCBzZWxlY3RlZCBhY2NvdW50LlxuICAgICAqIEBwYXJhbSBuZXdJZ25vcmVkVG9rZW5zIC0gVGhlIG5ldyBpZ25vcmVkIHRva2VucyB0byBzZXQgZm9yIHRoZSBjdXJyZW50IG5ldHdvcmsgYW5kIHNlbGVjdGVkIGFjY291bnQuXG4gICAgICogQHJldHVybnMgVGhlIHVwZGF0ZWQgYGFsbFRva2Vuc2AgYW5kIGBhbGxJZ25vcmVkVG9rZW5zYCBzdGF0ZS5cbiAgICAgKi9cbiAgICBfZ2V0TmV3QWxsVG9rZW5zU3RhdGUobmV3VG9rZW5zLCBuZXdJZ25vcmVkVG9rZW5zKSB7XG4gICAgICAgIGNvbnN0IHsgYWxsVG9rZW5zLCBhbGxJZ25vcmVkVG9rZW5zIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCB7IGNoYWluSWQsIHNlbGVjdGVkQWRkcmVzcyB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtUb2tlbnMgPSBhbGxUb2tlbnNbY2hhaW5JZF07XG4gICAgICAgIGNvbnN0IG5ldHdvcmtJZ25vcmVkVG9rZW5zID0gYWxsSWdub3JlZFRva2Vuc1tjaGFpbklkXTtcbiAgICAgICAgY29uc3QgbmV3TmV0d29ya1Rva2VucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbmV0d29ya1Rva2VucyksIHsgW3NlbGVjdGVkQWRkcmVzc106IG5ld1Rva2VucyB9KTtcbiAgICAgICAgY29uc3QgbmV3SWdub3JlZE5ldHdvcmtUb2tlbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG5ldHdvcmtJZ25vcmVkVG9rZW5zKSwgeyBbc2VsZWN0ZWRBZGRyZXNzXTogbmV3SWdub3JlZFRva2VucyB9KTtcbiAgICAgICAgY29uc3QgbmV3QWxsVG9rZW5zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhbGxUb2tlbnMpLCB7IFtjaGFpbklkXTogbmV3TmV0d29ya1Rva2VucyB9KTtcbiAgICAgICAgY29uc3QgbmV3QWxsSWdub3JlZFRva2VucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWxsSWdub3JlZFRva2VucyksIHsgW2NoYWluSWRdOiBuZXdJZ25vcmVkTmV0d29ya1Rva2VucyB9KTtcbiAgICAgICAgcmV0dXJuIHsgbmV3QWxsVG9rZW5zLCBuZXdBbGxJZ25vcmVkVG9rZW5zIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRva2VucyBmcm9tIHRoZSBpZ25vcmVkIGxpc3QuXG4gICAgICovXG4gICAgY2xlYXJJZ25vcmVkVG9rZW5zKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IGlnbm9yZWRUb2tlbnM6IFtdLCBhbGxJZ25vcmVkVG9rZW5zOiB7fSB9KTtcbiAgICB9XG59XG5leHBvcnRzLlRva2Vuc0NvbnRyb2xsZXIgPSBUb2tlbnNDb250cm9sbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gVG9rZW5zQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRva2Vuc0NvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR2FzRmVlQ29udHJvbGxlciA9IGV4cG9ydHMuR0FTX0VTVElNQVRFX1RZUEVTID0gZXhwb3J0cy5MRUdBQ1lfR0FTX1BSSUNFU19BUElfVVJMID0gdm9pZCAwO1xuY29uc3QgZXRoX3F1ZXJ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImV0aC1xdWVyeVwiKSk7XG5jb25zdCB1dWlkXzEgPSByZXF1aXJlKFwidXVpZFwiKTtcbmNvbnN0IGV0aGVyZXVtanNfdXRpbF8xID0gcmVxdWlyZShcImV0aGVyZXVtanMtdXRpbFwiKTtcbmNvbnN0IEJhc2VDb250cm9sbGVyVjJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclYyXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCBnYXNfdXRpbF8xID0gcmVxdWlyZShcIi4vZ2FzLXV0aWxcIik7XG5jb25zdCBkZXRlcm1pbmVHYXNGZWVDYWxjdWxhdGlvbnNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9kZXRlcm1pbmVHYXNGZWVDYWxjdWxhdGlvbnNcIikpO1xuY29uc3QgZmV0Y2hHYXNFc3RpbWF0ZXNWaWFFdGhGZWVIaXN0b3J5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZmV0Y2hHYXNFc3RpbWF0ZXNWaWFFdGhGZWVIaXN0b3J5XCIpKTtcbmNvbnN0IEdBU19GRUVfQVBJID0gJ2h0dHBzOi8vbW9jay1nYXMtc2VydmVyLmhlcm9rdWFwcC5jb20vJztcbmV4cG9ydHMuTEVHQUNZX0dBU19QUklDRVNfQVBJX1VSTCA9IGBodHRwczovL2FwaS5tZXRhc3dhcC5jb2RlZmkubmV0d29yay9nYXNQcmljZXNgO1xuLyoqXG4gKiBJbmRpY2F0ZXMgd2hpY2ggdHlwZSBvZiBnYXNFc3RpbWF0ZSB0aGUgY29udHJvbGxlciBpcyBjdXJyZW50bHkgcmV0dXJuaW5nLlxuICogVGhpcyBpcyB1c2VmdWwgYXMgYSB3YXkgb2YgYXNzZXJ0aW5nIHRoYXQgdGhlIHNoYXBlIG9mIGdhc0VzdGltYXRlcyBtYXRjaGVzXG4gKiBleHBlY3RhdGlvbnMuIE5PTkUgaXMgYSBzcGVjaWFsIGNhc2UgaW5kaWNhdGluZyB0aGF0IG5vIHByZXZpb3VzIGdhc0VzdGltYXRlXG4gKiBoYXMgYmVlbiBmZXRjaGVkLlxuICovXG5leHBvcnRzLkdBU19FU1RJTUFURV9UWVBFUyA9IHtcbiAgICBGRUVfTUFSS0VUOiAnZmVlLW1hcmtldCcsXG4gICAgTEVHQUNZOiAnbGVnYWN5JyxcbiAgICBFVEhfR0FTUFJJQ0U6ICdldGhfZ2FzUHJpY2UnLFxuICAgIE5PTkU6ICdub25lJyxcbn07XG5jb25zdCBtZXRhZGF0YSA9IHtcbiAgICBnYXNGZWVFc3RpbWF0ZXM6IHsgcGVyc2lzdDogdHJ1ZSwgYW5vbnltb3VzOiBmYWxzZSB9LFxuICAgIGVzdGltYXRlZEdhc0ZlZVRpbWVCb3VuZHM6IHsgcGVyc2lzdDogdHJ1ZSwgYW5vbnltb3VzOiBmYWxzZSB9LFxuICAgIGdhc0VzdGltYXRlVHlwZTogeyBwZXJzaXN0OiB0cnVlLCBhbm9ueW1vdXM6IGZhbHNlIH0sXG59O1xuY29uc3QgbmFtZSA9ICdHYXNGZWVDb250cm9sbGVyJztcbmNvbnN0IGRlZmF1bHRTdGF0ZSA9IHtcbiAgICBnYXNGZWVFc3RpbWF0ZXM6IHt9LFxuICAgIGVzdGltYXRlZEdhc0ZlZVRpbWVCb3VuZHM6IHt9LFxuICAgIGdhc0VzdGltYXRlVHlwZTogZXhwb3J0cy5HQVNfRVNUSU1BVEVfVFlQRVMuTk9ORSxcbn07XG4vKipcbiAqIENvbnRyb2xsZXIgdGhhdCByZXRyaWV2ZXMgZ2FzIGZlZSBlc3RpbWF0ZSBkYXRhIGFuZCBwb2xscyBmb3IgdXBkYXRlZCBkYXRhIG9uIGEgc2V0IGludGVydmFsXG4gKi9cbmNsYXNzIEdhc0ZlZUNvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlclYyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBHYXNGZWVDb250cm9sbGVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgY29udHJvbGxlciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmludGVydmFsIC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmV0d2VlbiBwb2xscy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5tZXNzZW5nZXIgLSBUaGUgY29udHJvbGxlciBtZXNzZW5nZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc3RhdGUgLSBUaGUgaW5pdGlhbCBzdGF0ZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRDdXJyZW50TmV0d29ya0VJUDE1NTlDb21wYXRpYmlsaXR5IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGUgY3VycmVudFxuICAgICAqIG5ldHdvcmsgaXMgRUlQLTE1NTkgY29tcGF0aWJsZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRDdXJyZW50TmV0d29ya0xlZ2FjeUdhc0FQSUNvbXBhdGliaWxpdHkgLSBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRoZVxuICAgICAqIGN1cnJlbnQgbmV0d29yayBpcyBjb21wYXRpYmxlIHdpdGggdGhlIGxlZ2FjeSBnYXMgcHJpY2UgQVBJLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldEN1cnJlbnRBY2NvdW50RUlQMTU1OUNvbXBhdGliaWxpdHkgLSBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRoZSBjdXJyZW50XG4gICAgICogYWNjb3VudCBpcyBFSVAtMTU1OSBjb21wYXRpYmxlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldENoYWluSWQgLSBSZXR1cm5zIHRoZSBjdXJyZW50IGNoYWluIElELlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldFByb3ZpZGVyIC0gUmV0dXJucyBhIG5ldHdvcmsgcHJvdmlkZXIgZm9yIHRoZSBjdXJyZW50IG5ldHdvcmsuXG4gICAgICogQHBhcmFtIG9wdGlvbnMub25OZXR3b3JrU3RhdGVDaGFuZ2UgLSBBIGZ1bmN0aW9uIGZvciByZWdpc3RlcmluZyBhbiBldmVudCBoYW5kbGVyIGZvciB0aGVcbiAgICAgKiBuZXR3b3JrIHN0YXRlIGNoYW5nZSBldmVudC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5sZWdhY3lBUElFbmRwb2ludCAtIFRoZSBsZWdhY3kgZ2FzIHByaWNlIEFQSSBVUkwuIFRoaXMgb3B0aW9uIGlzIHByaW1hcmlseSBmb3JcbiAgICAgKiB0ZXN0aW5nIHB1cnBvc2VzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLkVJUDE1NTlBUElFbmRwb2ludCAtIFRoZSBFSVAtMTU1OSBnYXMgcHJpY2UgQVBJIFVSTC4gVGhpcyBvcHRpb24gaXMgcHJpbWFyaWx5XG4gICAgICogZm9yIHRlc3RpbmcgcHVycG9zZXMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY2xpZW50SWQgLSBUaGUgY2xpZW50IElEIHVzZWQgdG8gaWRlbnRpZnkgdG8gdGhlIGdhcyBlc3RpbWF0aW9uIEFQSSB3aG8gaXNcbiAgICAgKiBhc2tpbmcgZm9yIGVzdGltYXRlcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGludGVydmFsID0gMTUwMDAsIG1lc3Nlbmdlciwgc3RhdGUsIGdldEN1cnJlbnROZXR3b3JrRUlQMTU1OUNvbXBhdGliaWxpdHksIGdldEN1cnJlbnRBY2NvdW50RUlQMTU1OUNvbXBhdGliaWxpdHksIGdldENoYWluSWQsIGdldEN1cnJlbnROZXR3b3JrTGVnYWN5R2FzQVBJQ29tcGF0aWJpbGl0eSwgZ2V0UHJvdmlkZXIsIG9uTmV0d29ya1N0YXRlQ2hhbmdlLCBsZWdhY3lBUElFbmRwb2ludCA9IGV4cG9ydHMuTEVHQUNZX0dBU19QUklDRVNfQVBJX1VSTCwgRUlQMTU1OUFQSUVuZHBvaW50ID0gR0FTX0ZFRV9BUEksIGNsaWVudElkLCB9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgIG1lc3NlbmdlcixcbiAgICAgICAgICAgIHN0YXRlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRTdGF0ZSksIHN0YXRlKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxEZWxheSA9IGludGVydmFsO1xuICAgICAgICB0aGlzLnBvbGxUb2tlbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudE5ldHdvcmtFSVAxNTU5Q29tcGF0aWJpbGl0eSA9IGdldEN1cnJlbnROZXR3b3JrRUlQMTU1OUNvbXBhdGliaWxpdHk7XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudE5ldHdvcmtMZWdhY3lHYXNBUElDb21wYXRpYmlsaXR5ID0gZ2V0Q3VycmVudE5ldHdvcmtMZWdhY3lHYXNBUElDb21wYXRpYmlsaXR5O1xuICAgICAgICB0aGlzLmdldEN1cnJlbnRBY2NvdW50RUlQMTU1OUNvbXBhdGliaWxpdHkgPSBnZXRDdXJyZW50QWNjb3VudEVJUDE1NTlDb21wYXRpYmlsaXR5O1xuICAgICAgICB0aGlzLkVJUDE1NTlBUElFbmRwb2ludCA9IEVJUDE1NTlBUElFbmRwb2ludDtcbiAgICAgICAgdGhpcy5sZWdhY3lBUElFbmRwb2ludCA9IGxlZ2FjeUFQSUVuZHBvaW50O1xuICAgICAgICB0aGlzLmdldENoYWluSWQgPSBnZXRDaGFpbklkO1xuICAgICAgICB0aGlzLmN1cnJlbnRDaGFpbklkID0gdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgdGhpcy5ldGhRdWVyeSA9IG5ldyBldGhfcXVlcnlfMS5kZWZhdWx0KHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZSgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdQcm92aWRlciA9IGdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICBjb25zdCBuZXdDaGFpbklkID0gdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgICAgICAgICB0aGlzLmV0aFF1ZXJ5ID0gbmV3IGV0aF9xdWVyeV8xLmRlZmF1bHQobmV3UHJvdmlkZXIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudENoYWluSWQgIT09IG5ld0NoYWluSWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGFpbklkID0gbmV3Q2hhaW5JZDtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnJlc2V0UG9sbGluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJlc2V0UG9sbGluZygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvbGxUb2tlbnMuc2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VucyA9IEFycmF5LmZyb20odGhpcy5wb2xsVG9rZW5zKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BQb2xsaW5nKCk7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5nZXRHYXNGZWVFc3RpbWF0ZXNBbmRTdGFydFBvbGxpbmcodG9rZW5zWzBdKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMuc2xpY2UoMSkuZm9yRWFjaCgodG9rZW4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2xsVG9rZW5zLmFkZCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmZXRjaEdhc0ZlZUVzdGltYXRlcyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5fZmV0Y2hHYXNGZWVFc3RpbWF0ZURhdGEob3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRHYXNGZWVFc3RpbWF0ZXNBbmRTdGFydFBvbGxpbmcocG9sbFRva2VuKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBfcG9sbFRva2VuID0gcG9sbFRva2VuIHx8IHV1aWRfMS52MSgpO1xuICAgICAgICAgICAgdGhpcy5wb2xsVG9rZW5zLmFkZChfcG9sbFRva2VuKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvbGxUb2tlbnMuc2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuX2ZldGNoR2FzRmVlRXN0aW1hdGVEYXRhKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9sbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9wb2xsVG9rZW47XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGFuZCBzZXRzIGdhc0ZlZUVzdGltYXRlcyBpbiBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGdhcyBmZWUgZXN0aW1hdGUgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zaG91bGRVcGRhdGVTdGF0ZSAtIERldGVybWluZXMgd2hldGhlciB0aGUgc3RhdGUgc2hvdWxkIGJlIHVwZGF0ZWQgd2l0aCB0aGVcbiAgICAgKiB1cGRhdGVkIGdhcyBlc3RpbWF0ZXMuXG4gICAgICogQHJldHVybnMgVGhlIGdhcyBmZWUgZXN0aW1hdGVzLlxuICAgICAqL1xuICAgIF9mZXRjaEdhc0ZlZUVzdGltYXRlRGF0YShvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2hvdWxkVXBkYXRlU3RhdGUgPSB0cnVlIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgbGV0IGlzRUlQMTU1OUNvbXBhdGlibGU7XG4gICAgICAgICAgICBjb25zdCBpc0xlZ2FjeUdhc0FQSUNvbXBhdGlibGUgPSB0aGlzLmdldEN1cnJlbnROZXR3b3JrTGVnYWN5R2FzQVBJQ29tcGF0aWJpbGl0eSgpO1xuICAgICAgICAgICAgbGV0IGNoYWluSWQgPSB0aGlzLmdldENoYWluSWQoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhaW5JZCA9PT0gJ3N0cmluZycgJiYgZXRoZXJldW1qc191dGlsXzEuaXNIZXhTdHJpbmcoY2hhaW5JZCkpIHtcbiAgICAgICAgICAgICAgICBjaGFpbklkID0gcGFyc2VJbnQoY2hhaW5JZCwgMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpc0VJUDE1NTlDb21wYXRpYmxlID0geWllbGQgdGhpcy5nZXRFSVAxNTU5Q29tcGF0aWJpbGl0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgIGlzRUlQMTU1OUNvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGdhc0ZlZUNhbGN1bGF0aW9ucyA9IHlpZWxkIGRldGVybWluZUdhc0ZlZUNhbGN1bGF0aW9uc18xLmRlZmF1bHQoe1xuICAgICAgICAgICAgICAgIGlzRUlQMTU1OUNvbXBhdGlibGUsXG4gICAgICAgICAgICAgICAgaXNMZWdhY3lHYXNBUElDb21wYXRpYmxlLFxuICAgICAgICAgICAgICAgIGZldGNoR2FzRXN0aW1hdGVzOiBnYXNfdXRpbF8xLmZldGNoR2FzRXN0aW1hdGVzLFxuICAgICAgICAgICAgICAgIGZldGNoR2FzRXN0aW1hdGVzVXJsOiB0aGlzLkVJUDE1NTlBUElFbmRwb2ludC5yZXBsYWNlKCc8Y2hhaW5faWQ+JywgYCR7Y2hhaW5JZH1gKSxcbiAgICAgICAgICAgICAgICBmZXRjaEdhc0VzdGltYXRlc1ZpYUV0aEZlZUhpc3Rvcnk6IGZldGNoR2FzRXN0aW1hdGVzVmlhRXRoRmVlSGlzdG9yeV8xLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgZmV0Y2hMZWdhY3lHYXNQcmljZUVzdGltYXRlczogZ2FzX3V0aWxfMS5mZXRjaExlZ2FjeUdhc1ByaWNlRXN0aW1hdGVzLFxuICAgICAgICAgICAgICAgIGZldGNoTGVnYWN5R2FzUHJpY2VFc3RpbWF0ZXNVcmw6IHRoaXMubGVnYWN5QVBJRW5kcG9pbnQucmVwbGFjZSgnPGNoYWluX2lkPicsIGAke2NoYWluSWR9YCksXG4gICAgICAgICAgICAgICAgZmV0Y2hFdGhHYXNQcmljZUVzdGltYXRlOiBnYXNfdXRpbF8xLmZldGNoRXRoR2FzUHJpY2VFc3RpbWF0ZSxcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVUaW1lRXN0aW1hdGU6IGdhc191dGlsXzEuY2FsY3VsYXRlVGltZUVzdGltYXRlLFxuICAgICAgICAgICAgICAgIGNsaWVudElkOiB0aGlzLmNsaWVudElkLFxuICAgICAgICAgICAgICAgIGV0aFF1ZXJ5OiB0aGlzLmV0aFF1ZXJ5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlU3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZ2FzRmVlRXN0aW1hdGVzID0gZ2FzRmVlQ2FsY3VsYXRpb25zLmdhc0ZlZUVzdGltYXRlcztcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZXN0aW1hdGVkR2FzRmVlVGltZUJvdW5kcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICBnYXNGZWVDYWxjdWxhdGlvbnMuZXN0aW1hdGVkR2FzRmVlVGltZUJvdW5kcztcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZ2FzRXN0aW1hdGVUeXBlID0gZ2FzRmVlQ2FsY3VsYXRpb25zLmdhc0VzdGltYXRlVHlwZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnYXNGZWVDYWxjdWxhdGlvbnM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIHBvbGwgdG9rZW4sIGFuZCBzdG9wIHBvbGxpbmcgaWYgdGhlIHNldCBvZiBwb2xsIHRva2VucyBpcyBlbXB0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwb2xsVG9rZW4gLSBUaGUgcG9sbCB0b2tlbiB0byBkaXNjb25uZWN0LlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3RQb2xsZXIocG9sbFRva2VuKSB7XG4gICAgICAgIHRoaXMucG9sbFRva2Vucy5kZWxldGUocG9sbFRva2VuKTtcbiAgICAgICAgaWYgKHRoaXMucG9sbFRva2Vucy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BQb2xsaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RvcFBvbGxpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVydmFsSWQpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvbGxUb2tlbnMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5yZXNldFN0YXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdG8gZGlzY2FyZCB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIHN0b3BzIGFueSBhY3RpdmUgcG9sbGluZy5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc3RvcFBvbGxpbmcoKTtcbiAgICB9XG4gICAgX3BvbGwoKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVydmFsSWQpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB1dGlsXzEuc2FmZWx5RXhlY3V0ZSgoKSA9PiB0aGlzLl9mZXRjaEdhc0ZlZUVzdGltYXRlRGF0YSgpKTtcbiAgICAgICAgfSksIHRoaXMuaW50ZXJ2YWxEZWxheSk7XG4gICAgfVxuICAgIHJlc2V0U3RhdGUoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U3RhdGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRFSVAxNTU5Q29tcGF0aWJpbGl0eSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnROZXR3b3JrSXNFSVAxNTU5Q29tcGF0aWJsZSA9IHlpZWxkIHRoaXMuZ2V0Q3VycmVudE5ldHdvcmtFSVAxNTU5Q29tcGF0aWJpbGl0eSgpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEFjY291bnRJc0VJUDE1NTlDb21wYXRpYmxlID0gKF9iID0gKF9hID0gdGhpcy5nZXRDdXJyZW50QWNjb3VudEVJUDE1NTlDb21wYXRpYmlsaXR5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiAoY3VycmVudE5ldHdvcmtJc0VJUDE1NTlDb21wYXRpYmxlICYmIGN1cnJlbnRBY2NvdW50SXNFSVAxNTU5Q29tcGF0aWJsZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRUaW1lRXN0aW1hdGUobWF4UHJpb3JpdHlGZWVQZXJHYXMsIG1heEZlZVBlckdhcykge1xuICAgICAgICBpZiAoIXRoaXMuc3RhdGUuZ2FzRmVlRXN0aW1hdGVzIHx8XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmdhc0VzdGltYXRlVHlwZSAhPT0gZXhwb3J0cy5HQVNfRVNUSU1BVEVfVFlQRVMuRkVFX01BUktFVCkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnYXNfdXRpbF8xLmNhbGN1bGF0ZVRpbWVFc3RpbWF0ZShtYXhQcmlvcml0eUZlZVBlckdhcywgbWF4RmVlUGVyR2FzLCB0aGlzLnN0YXRlLmdhc0ZlZUVzdGltYXRlcyk7XG4gICAgfVxufVxuZXhwb3J0cy5HYXNGZWVDb250cm9sbGVyID0gR2FzRmVlQ29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IEdhc0ZlZUNvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HYXNGZWVDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEZvcm1hdHRlZElwZnNVcmwgPSBleHBvcnRzLmFkZFVybFByb3RvY29sUHJlZml4ID0gZXhwb3J0cy5nZXRJcGZzQ0lEdjFBbmRQYXRoID0gZXhwb3J0cy5yZW1vdmVJcGZzUHJvdG9jb2xQcmVmaXggPSBleHBvcnRzLnZhbGlkYXRlTWluaW11bUluY3JlYXNlID0gZXhwb3J0cy5pc0dhc1ByaWNlVmFsdWUgPSBleHBvcnRzLmlzRmVlTWFya2V0RUlQMTU1OVZhbHVlcyA9IGV4cG9ydHMudmFsaWRhdGVHYXNWYWx1ZXMgPSBleHBvcnRzLmdldEluY3JlYXNlZFByaWNlRnJvbUV4aXN0aW5nID0gZXhwb3J0cy5nZXRJbmNyZWFzZWRQcmljZUhleCA9IGV4cG9ydHMuY29udmVydFByaWNlVG9EZWNpbWFsID0gZXhwb3J0cy5pc0VJUDE1NTlUcmFuc2FjdGlvbiA9IGV4cG9ydHMucXVlcnkgPSBleHBvcnRzLm5vcm1hbGl6ZUVuc05hbWUgPSBleHBvcnRzLnRpbWVvdXRGZXRjaCA9IGV4cG9ydHMuaGFuZGxlRmV0Y2ggPSBleHBvcnRzLnN1Y2Nlc3NmdWxGZXRjaCA9IGV4cG9ydHMuaXNTbWFydENvbnRyYWN0Q29kZSA9IGV4cG9ydHMudmFsaWRhdGVUb2tlblRvV2F0Y2ggPSBleHBvcnRzLnZhbGlkYXRlVHlwZWRTaWduTWVzc2FnZURhdGFWMyA9IGV4cG9ydHMudmFsaWRhdGVUeXBlZFNpZ25NZXNzYWdlRGF0YVYxID0gZXhwb3J0cy52YWxpZGF0ZVNpZ25NZXNzYWdlRGF0YSA9IGV4cG9ydHMubm9ybWFsaXplTWVzc2FnZURhdGEgPSBleHBvcnRzLnZhbGlkYXRlVHJhbnNhY3Rpb24gPSBleHBvcnRzLmlzVmFsaWRIZXhBZGRyZXNzID0gZXhwb3J0cy50b0NoZWNrc3VtSGV4QWRkcmVzcyA9IGV4cG9ydHMuc2FmZWx5RXhlY3V0ZVdpdGhUaW1lb3V0ID0gZXhwb3J0cy5zYWZlbHlFeGVjdXRlID0gZXhwb3J0cy5ub3JtYWxpemVUcmFuc2FjdGlvbiA9IGV4cG9ydHMudG9IZXggPSBleHBvcnRzLmZyb21IZXggPSBleHBvcnRzLmhleFRvVGV4dCA9IGV4cG9ydHMuaGV4VG9CTiA9IGV4cG9ydHMuaGFuZGxlVHJhbnNhY3Rpb25GZXRjaCA9IGV4cG9ydHMuZ2V0RXRoZXJzY2FuQXBpVXJsID0gZXhwb3J0cy5nZXRCdXlVUkwgPSBleHBvcnRzLndlaUhleFRvR3dlaURlYyA9IGV4cG9ydHMuZ3dlaURlY1RvV0VJQk4gPSBleHBvcnRzLmZyYWN0aW9uQk4gPSBleHBvcnRzLkJOVG9IZXggPSB2b2lkIDA7XG5jb25zdCBldGhlcmV1bWpzX3V0aWxfMSA9IHJlcXVpcmUoXCJldGhlcmV1bWpzLXV0aWxcIik7XG5jb25zdCBldGhqc191bml0XzEgPSByZXF1aXJlKFwiZXRoanMtdW5pdFwiKTtcbmNvbnN0IGV0aF9ycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiZXRoLXJwYy1lcnJvcnNcIik7XG5jb25zdCBldGhfZW5zX25hbWVoYXNoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImV0aC1lbnMtbmFtZWhhc2hcIikpO1xuY29uc3QgZXRoX3NpZ191dGlsXzEgPSByZXF1aXJlKFwiZXRoLXNpZy11dGlsXCIpO1xuY29uc3QganNvbnNjaGVtYV8xID0gcmVxdWlyZShcImpzb25zY2hlbWFcIik7XG5jb25zdCBjaWRfMSA9IHJlcXVpcmUoXCJtdWx0aWZvcm1hdHMvY2lkXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBoZXhSZSA9IC9eWzAtOUEtRmEtZl0rJC9ndTtcbmNvbnN0IE5PUk1BTElaRVJTID0ge1xuICAgIGRhdGE6IChkYXRhKSA9PiBldGhlcmV1bWpzX3V0aWxfMS5hZGRIZXhQcmVmaXgoZGF0YSksXG4gICAgZnJvbTogKGZyb20pID0+IGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeChmcm9tKS50b0xvd2VyQ2FzZSgpLFxuICAgIGdhczogKGdhcykgPT4gZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KGdhcyksXG4gICAgZ2FzUHJpY2U6IChnYXNQcmljZSkgPT4gZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KGdhc1ByaWNlKSxcbiAgICBub25jZTogKG5vbmNlKSA9PiBldGhlcmV1bWpzX3V0aWxfMS5hZGRIZXhQcmVmaXgobm9uY2UpLFxuICAgIHRvOiAodG8pID0+IGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeCh0bykudG9Mb3dlckNhc2UoKSxcbiAgICB2YWx1ZTogKHZhbHVlKSA9PiBldGhlcmV1bWpzX3V0aWxfMS5hZGRIZXhQcmVmaXgodmFsdWUpLFxuICAgIG1heEZlZVBlckdhczogKG1heEZlZVBlckdhcykgPT4gZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KG1heEZlZVBlckdhcyksXG4gICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IChtYXhQcmlvcml0eUZlZVBlckdhcykgPT4gZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KG1heFByaW9yaXR5RmVlUGVyR2FzKSxcbiAgICBlc3RpbWF0ZWRCYXNlRmVlOiAobWF4UHJpb3JpdHlGZWVQZXJHYXMpID0+IGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeChtYXhQcmlvcml0eUZlZVBlckdhcyksXG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIEJOIG9iamVjdCB0byBhIGhleCBzdHJpbmcgd2l0aCBhICcweCcgcHJlZml4LlxuICpcbiAqIEBwYXJhbSBpbnB1dEJuIC0gQk4gaW5zdGFuY2UgdG8gY29udmVydCB0byBhIGhleCBzdHJpbmcuXG4gKiBAcmV0dXJucyBBICcweCctcHJlZml4ZWQgaGV4IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gQk5Ub0hleChpbnB1dEJuKSB7XG4gICAgcmV0dXJuIGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeChpbnB1dEJuLnRvU3RyaW5nKDE2KSk7XG59XG5leHBvcnRzLkJOVG9IZXggPSBCTlRvSGV4O1xuLyoqXG4gKiBVc2VkIHRvIG11bHRpcGx5IGEgQk4gYnkgYSBmcmFjdGlvbi5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0Qk4gLSBOdW1iZXIgdG8gbXVsdGlwbHkgYnkgYSBmcmFjdGlvbi5cbiAqIEBwYXJhbSBudW1lcmF0b3IgLSBOdW1lcmF0b3Igb2YgdGhlIGZyYWN0aW9uIG11bHRpcGxpZXIuXG4gKiBAcGFyYW0gZGVub21pbmF0b3IgLSBEZW5vbWluYXRvciBvZiB0aGUgZnJhY3Rpb24gbXVsdGlwbGllci5cbiAqIEByZXR1cm5zIFByb2R1Y3Qgb2YgdGhlIG11bHRpcGxpY2F0aW9uLlxuICovXG5mdW5jdGlvbiBmcmFjdGlvbkJOKHRhcmdldEJOLCBudW1lcmF0b3IsIGRlbm9taW5hdG9yKSB7XG4gICAgY29uc3QgbnVtQk4gPSBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4obnVtZXJhdG9yKTtcbiAgICBjb25zdCBkZW5vbUJOID0gbmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKGRlbm9taW5hdG9yKTtcbiAgICByZXR1cm4gdGFyZ2V0Qk4ubXVsKG51bUJOKS5kaXYoZGVub21CTik7XG59XG5leHBvcnRzLmZyYWN0aW9uQk4gPSBmcmFjdGlvbkJOO1xuLyoqXG4gKiBVc2VkIHRvIGNvbnZlcnQgYSBiYXNlLTEwIG51bWJlciBmcm9tIEdXRUkgdG8gV0VJLiBDYW4gaGFuZGxlIG51bWJlcnMgd2l0aCBkZWNpbWFsIHBhcnRzLlxuICpcbiAqIEBwYXJhbSBuIC0gVGhlIGJhc2UgMTAgbnVtYmVyIHRvIGNvbnZlcnQgdG8gV0VJLlxuICogQHJldHVybnMgVGhlIG51bWJlciBpbiBXRUksIGFzIGEgQk4uXG4gKi9cbmZ1bmN0aW9uIGd3ZWlEZWNUb1dFSUJOKG4pIHtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKG4pKSB7XG4gICAgICAgIHJldHVybiBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4oMCk7XG4gICAgfVxuICAgIGNvbnN0IHBhcnRzID0gbi50b1N0cmluZygpLnNwbGl0KCcuJyk7XG4gICAgY29uc3Qgd2hvbGVQYXJ0ID0gcGFydHNbMF0gfHwgJzAnO1xuICAgIGxldCBkZWNpbWFsUGFydCA9IHBhcnRzWzFdIHx8ICcnO1xuICAgIGlmICghZGVjaW1hbFBhcnQpIHtcbiAgICAgICAgcmV0dXJuIGV0aGpzX3VuaXRfMS50b1dlaSh3aG9sZVBhcnQsICdnd2VpJyk7XG4gICAgfVxuICAgIGlmIChkZWNpbWFsUGFydC5sZW5ndGggPD0gOSkge1xuICAgICAgICByZXR1cm4gZXRoanNfdW5pdF8xLnRvV2VpKGAke3dob2xlUGFydH0uJHtkZWNpbWFsUGFydH1gLCAnZ3dlaScpO1xuICAgIH1cbiAgICBjb25zdCBkZWNpbWFsUGFydFRvUmVtb3ZlID0gZGVjaW1hbFBhcnQuc2xpY2UoOSk7XG4gICAgY29uc3QgZGVjaW1hbFJvdW5kaW5nRGlnaXQgPSBkZWNpbWFsUGFydFRvUmVtb3ZlWzBdO1xuICAgIGRlY2ltYWxQYXJ0ID0gZGVjaW1hbFBhcnQuc2xpY2UoMCwgOSk7XG4gICAgbGV0IHdlaSA9IGV0aGpzX3VuaXRfMS50b1dlaShgJHt3aG9sZVBhcnR9LiR7ZGVjaW1hbFBhcnR9YCwgJ2d3ZWknKTtcbiAgICBpZiAoTnVtYmVyKGRlY2ltYWxSb3VuZGluZ0RpZ2l0KSA+PSA1KSB7XG4gICAgICAgIHdlaSA9IHdlaS5hZGQobmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHdlaTtcbn1cbmV4cG9ydHMuZ3dlaURlY1RvV0VJQk4gPSBnd2VpRGVjVG9XRUlCTjtcbi8qKlxuICogVXNlZCB0byBjb252ZXJ0IHZhbHVlcyBmcm9tIHdlaSBoZXggZm9ybWF0IHRvIGRlYyBnd2VpIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gaGV4IC0gVGhlIHZhbHVlIGluIGhleCB3ZWkuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgaW4gZGVjIGd3ZWkgYXMgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB3ZWlIZXhUb0d3ZWlEZWMoaGV4KSB7XG4gICAgY29uc3QgaGV4V2VpID0gbmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKGV0aGVyZXVtanNfdXRpbF8xLnN0cmlwSGV4UHJlZml4KGhleCksIDE2KTtcbiAgICByZXR1cm4gZXRoanNfdW5pdF8xLmZyb21XZWkoaGV4V2VpLCAnZ3dlaScpLnRvU3RyaW5nKDEwKTtcbn1cbmV4cG9ydHMud2VpSGV4VG9Hd2VpRGVjID0gd2VpSGV4VG9Hd2VpRGVjO1xuLyoqXG4gKiBSZXR1cm4gYSBVUkwgdGhhdCBjYW4gYmUgdXNlZCB0byBvYnRhaW4gRVRIIGZvciBhIGdpdmVuIG5ldHdvcmsuXG4gKlxuICogQHBhcmFtIG5ldHdvcmtDb2RlIC0gTmV0d29yayBjb2RlIG9mIGRlc2lyZWQgbmV0d29yay5cbiAqIEBwYXJhbSBhZGRyZXNzIC0gQWRkcmVzcyB0byBkZXBvc2l0IG9idGFpbmVkIEVUSC5cbiAqIEBwYXJhbSBhbW91bnQgLSBIb3cgbXVjaCBFVEggaXMgZGVzaXJlZC5cbiAqIEByZXR1cm5zIFVSTCB0byBidXkgRVRIIGJhc2VkIG9uIG5ldHdvcmsuXG4gKi9cbmZ1bmN0aW9uIGdldEJ1eVVSTChuZXR3b3JrQ29kZSA9ICcxJywgYWRkcmVzcywgYW1vdW50ID0gNSkge1xuICAgIHN3aXRjaCAobmV0d29ya0NvZGUpIHtcbiAgICAgICAgY2FzZSAnMSc6XG4gICAgICAgICAgICByZXR1cm4gYGh0dHBzOi8vYnV5LmNvaW5iYXNlLmNvbS8/Y29kZT05ZWM1NmQwMS03ZTgxLTUwMTctOTMwYy01MTNkYWEyN2JiNmEmYW1vdW50PSR7YW1vdW50fSZhZGRyZXNzPSR7YWRkcmVzc30mY3J5cHRvX2N1cnJlbmN5PUVUSGA7XG4gICAgICAgIGNhc2UgJzMnOlxuICAgICAgICAgICAgcmV0dXJuICdodHRwczovL2ZhdWNldC5tZXRhbWFzay5pby8nO1xuICAgICAgICBjYXNlICc0JzpcbiAgICAgICAgICAgIHJldHVybiAnaHR0cHM6Ly93d3cucmlua2VieS5pby8nO1xuICAgICAgICBjYXNlICc1JzpcbiAgICAgICAgICAgIHJldHVybiAnaHR0cHM6Ly9nb2VybGktZmF1Y2V0LnNsb2NrLml0Lyc7XG4gICAgICAgIGNhc2UgJzQyJzpcbiAgICAgICAgICAgIHJldHVybiAnaHR0cHM6Ly9naXRodWIuY29tL2tvdmFuLXRlc3RuZXQvZmF1Y2V0JztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRCdXlVUkwgPSBnZXRCdXlVUkw7XG4vKipcbiAqIFJldHVybiBhIFVSTCB0aGF0IGNhbiBiZSB1c2VkIHRvIGZldGNoIEVUSCB0cmFuc2FjdGlvbnMuXG4gKlxuICogQHBhcmFtIG5ldHdvcmtUeXBlIC0gTmV0d29yayB0eXBlIG9mIGRlc2lyZWQgbmV0d29yay5cbiAqIEBwYXJhbSB1cmxQYXJhbXMgLSBUaGUgcGFyYW1ldGVycyB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgVVJMLlxuICogQHJldHVybnMgVVJMIHRvIGZldGNoIHRoZSBhY2Nlc3MgdGhlIGVuZHBvaW50LlxuICovXG5mdW5jdGlvbiBnZXRFdGhlcnNjYW5BcGlVcmwobmV0d29ya1R5cGUsIHVybFBhcmFtcykge1xuICAgIGxldCBldGhlcnNjYW5TdWJkb21haW4gPSAnYXBpJztcbiAgICBpZiAobmV0d29ya1R5cGUgIT09IGNvbnN0YW50c18xLk1BSU5ORVQpIHtcbiAgICAgICAgZXRoZXJzY2FuU3ViZG9tYWluID0gYGFwaS0ke25ldHdvcmtUeXBlfWA7XG4gICAgfVxuICAgIGNvbnN0IGFwaVVybCA9IGBodHRwczovLyR7ZXRoZXJzY2FuU3ViZG9tYWlufS5ldGhlcnNjYW4uaW9gO1xuICAgIGxldCB1cmwgPSBgJHthcGlVcmx9L2FwaT9gO1xuICAgIGZvciAoY29uc3QgcGFyYW1LZXkgaW4gdXJsUGFyYW1zKSB7XG4gICAgICAgIGlmICh1cmxQYXJhbXNbcGFyYW1LZXldKSB7XG4gICAgICAgICAgICB1cmwgKz0gYCR7cGFyYW1LZXl9PSR7dXJsUGFyYW1zW3BhcmFtS2V5XX0mYDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cmwgKz0gJ3RhZz1sYXRlc3QmcGFnZT0xJztcbiAgICByZXR1cm4gdXJsO1xufVxuZXhwb3J0cy5nZXRFdGhlcnNjYW5BcGlVcmwgPSBnZXRFdGhlcnNjYW5BcGlVcmw7XG4vKipcbiAqIEhhbmRsZXMgdGhlIGZldGNoIG9mIGluY29taW5nIHRyYW5zYWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0gbmV0d29ya1R5cGUgLSBOZXR3b3JrIHR5cGUgb2YgZGVzaXJlZCBuZXR3b3JrLlxuICogQHBhcmFtIGFkZHJlc3MgLSBBZGRyZXNzIHRvIGdldCB0aGUgdHJhbnNhY3Rpb25zIGZyb20uXG4gKiBAcGFyYW0gdHhIaXN0b3J5TGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgdHJhbnNhY3Rpb25zIHRvIGZldGNoLlxuICogQHBhcmFtIG9wdCAtIE9iamVjdCB0aGF0IGNhbiBjb250YWluIGZyb21CbG9jayBhbmQgRXRoZXJzY2FuIHNlcnZpY2UgQVBJIGtleS5cbiAqIEByZXR1cm5zIFJlc3BvbnNlcyBmb3IgYm90aCBFVEggYW5kIEVSQzIwIHRva2VuIHRyYW5zYWN0aW9ucy5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlVHJhbnNhY3Rpb25GZXRjaChuZXR3b3JrVHlwZSwgYWRkcmVzcywgdHhIaXN0b3J5TGltaXQsIG9wdCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIC8vIHRyYW5zYWN0aW9uc1xuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSB7XG4gICAgICAgICAgICBtb2R1bGU6ICdhY2NvdW50JyxcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBzdGFydEJsb2NrOiBvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQuZnJvbUJsb2NrLFxuICAgICAgICAgICAgYXBpa2V5OiBvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQuZXRoZXJzY2FuQXBpS2V5LFxuICAgICAgICAgICAgb2Zmc2V0OiB0eEhpc3RvcnlMaW1pdC50b1N0cmluZygpLFxuICAgICAgICAgICAgb3JkZXI6ICdkZXNjJyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXRoZXJzY2FuVHhVcmwgPSBnZXRFdGhlcnNjYW5BcGlVcmwobmV0d29ya1R5cGUsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdXJsUGFyYW1zKSwgeyBhY3Rpb246ICd0eGxpc3QnIH0pKTtcbiAgICAgICAgY29uc3QgZXRoZXJzY2FuVHhSZXNwb25zZVByb21pc2UgPSBoYW5kbGVGZXRjaChldGhlcnNjYW5UeFVybCk7XG4gICAgICAgIC8vIHRva2Vuc1xuICAgICAgICBjb25zdCBldGhlcnNjYW5Ub2tlblVybCA9IGdldEV0aGVyc2NhbkFwaVVybChuZXR3b3JrVHlwZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB1cmxQYXJhbXMpLCB7IGFjdGlvbjogJ3Rva2VudHgnIH0pKTtcbiAgICAgICAgY29uc3QgZXRoZXJzY2FuVG9rZW5SZXNwb25zZVByb21pc2UgPSBoYW5kbGVGZXRjaChldGhlcnNjYW5Ub2tlblVybCk7XG4gICAgICAgIGxldCBbZXRoZXJzY2FuVHhSZXNwb25zZSwgZXRoZXJzY2FuVG9rZW5SZXNwb25zZV0gPSB5aWVsZCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBldGhlcnNjYW5UeFJlc3BvbnNlUHJvbWlzZSxcbiAgICAgICAgICAgIGV0aGVyc2NhblRva2VuUmVzcG9uc2VQcm9taXNlLFxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKGV0aGVyc2NhblR4UmVzcG9uc2Uuc3RhdHVzID09PSAnMCcgfHxcbiAgICAgICAgICAgIGV0aGVyc2NhblR4UmVzcG9uc2UucmVzdWx0Lmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICBldGhlcnNjYW5UeFJlc3BvbnNlID0geyBzdGF0dXM6IGV0aGVyc2NhblR4UmVzcG9uc2Uuc3RhdHVzLCByZXN1bHQ6IFtdIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV0aGVyc2NhblRva2VuUmVzcG9uc2Uuc3RhdHVzID09PSAnMCcgfHxcbiAgICAgICAgICAgIGV0aGVyc2NhblRva2VuUmVzcG9uc2UucmVzdWx0Lmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICBldGhlcnNjYW5Ub2tlblJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogZXRoZXJzY2FuVG9rZW5SZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtldGhlcnNjYW5UeFJlc3BvbnNlLCBldGhlcnNjYW5Ub2tlblJlc3BvbnNlXTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuaGFuZGxlVHJhbnNhY3Rpb25GZXRjaCA9IGhhbmRsZVRyYW5zYWN0aW9uRmV0Y2g7XG4vKipcbiAqIENvbnZlcnRzIGEgaGV4IHN0cmluZyB0byBhIEJOIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gaW5wdXRIZXggLSBOdW1iZXIgcmVwcmVzZW50ZWQgYXMgYSBoZXggc3RyaW5nLlxuICogQHJldHVybnMgQSBCTiBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGV4VG9CTihpbnB1dEhleCkge1xuICAgIHJldHVybiBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4oZXRoZXJldW1qc191dGlsXzEuc3RyaXBIZXhQcmVmaXgoaW5wdXRIZXgpLCAxNik7XG59XG5leHBvcnRzLmhleFRvQk4gPSBoZXhUb0JOO1xuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IGNvbnZlcnRzIGhleCBkYXRhIHRvIGh1bWFuIHJlYWRhYmxlIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gaGV4IC0gVGhlIGhleCBzdHJpbmcgdG8gY29udmVydCB0byBzdHJpbmcuXG4gKiBAcmV0dXJucyBBIGh1bWFuIHJlYWRhYmxlIHN0cmluZyBjb252ZXJzaW9uLlxuICovXG5mdW5jdGlvbiBoZXhUb1RleHQoaGV4KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RyaXBwZWQgPSBldGhlcmV1bWpzX3V0aWxfMS5zdHJpcEhleFByZWZpeChoZXgpO1xuICAgICAgICBjb25zdCBidWZmID0gQnVmZmVyLmZyb20oc3RyaXBwZWQsICdoZXgnKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmYudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIGhleDtcbiAgICB9XG59XG5leHBvcnRzLmhleFRvVGV4dCA9IGhleFRvVGV4dDtcbi8qKlxuICogUGFyc2VzIGEgaGV4IHN0cmluZyBhbmQgY29udmVydHMgaXQgaW50byBhIG51bWJlciB0aGF0IGNhbiBiZSBvcGVyYXRlZCBvbiBpbiBhIGJpZ251bS1zYWZlLFxuICogYmFzZS0xMCB3YXkuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gQSBiYXNlLTE2IG51bWJlciBlbmNvZGVkIGFzIGEgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIG51bWJlciBhcyBhIEJOIG9iamVjdCBpbiBiYXNlLTE2IG1vZGUuXG4gKi9cbmZ1bmN0aW9uIGZyb21IZXgodmFsdWUpIHtcbiAgICBpZiAoZXRoZXJldW1qc191dGlsXzEuQk4uaXNCTih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKGhleFRvQk4odmFsdWUpLnRvU3RyaW5nKDEwKSk7XG59XG5leHBvcnRzLmZyb21IZXggPSBmcm9tSGV4O1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBpbnRlZ2VyIHRvIGEgaGV4YWRlY2ltYWwgcmVwcmVzZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gQW4gaW50ZWdlciwgYW4gaW50ZWdlciBlbmNvZGVkIGFzIGEgYmFzZS0xMCBzdHJpbmcsIG9yIGEgQk4uXG4gKiBAcmV0dXJucyBUaGUgaW50ZWdlciBlbmNvZGVkIGFzIGEgaGV4IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9IZXgodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBldGhlcmV1bWpzX3V0aWxfMS5pc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBoZXhTdHJpbmcgPSBldGhlcmV1bWpzX3V0aWxfMS5CTi5pc0JOKHZhbHVlKVxuICAgICAgICA/IHZhbHVlLnRvU3RyaW5nKDE2KVxuICAgICAgICA6IG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTih2YWx1ZS50b1N0cmluZygpLCAxMCkudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBgMHgke2hleFN0cmluZ31gO1xufVxuZXhwb3J0cy50b0hleCA9IHRvSGV4O1xuLyoqXG4gKiBOb3JtYWxpemVzIHByb3BlcnRpZXMgb24gYSBUcmFuc2FjdGlvbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVHJhbnNhY3Rpb24gb2JqZWN0IHRvIG5vcm1hbGl6ZS5cbiAqIEByZXR1cm5zIE5vcm1hbGl6ZWQgVHJhbnNhY3Rpb24gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRUcmFuc2FjdGlvbiA9IHsgZnJvbTogJycgfTtcbiAgICBsZXQga2V5O1xuICAgIGZvciAoa2V5IGluIE5PUk1BTElaRVJTKSB7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbltrZXldKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkVHJhbnNhY3Rpb25ba2V5XSA9IE5PUk1BTElaRVJTW2tleV0odHJhbnNhY3Rpb25ba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRUcmFuc2FjdGlvbjtcbn1cbmV4cG9ydHMubm9ybWFsaXplVHJhbnNhY3Rpb24gPSBub3JtYWxpemVUcmFuc2FjdGlvbjtcbi8qKlxuICogRXhlY3V0ZSBhbmQgcmV0dXJuIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24gd2l0aG91dCB0aHJvd2luZyBlcnJvcnMuXG4gKlxuICogQHBhcmFtIG9wZXJhdGlvbiAtIEZ1bmN0aW9uIHJldHVybmluZyBhIFByb21pc2UuXG4gKiBAcGFyYW0gbG9nRXJyb3IgLSBEZXRlcm1pbmVzIGlmIHRoZSBlcnJvciBzaG91bGQgYmUgbG9nZ2VkLlxuICogQHBhcmFtIHJldHJ5IC0gRnVuY3Rpb24gY2FsbGVkIGlmIGFuIGVycm9yIGlzIGNhdWdodC5cbiAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSByZXN1bHQgb2YgdGhlIGFzeW5jIG9wZXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2FmZWx5RXhlY3V0ZShvcGVyYXRpb24sIGxvZ0Vycm9yID0gZmFsc2UsIHJldHJ5KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCBvcGVyYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAobG9nRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHJ5ID09PSBudWxsIHx8IHJldHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXRyeShlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLnNhZmVseUV4ZWN1dGUgPSBzYWZlbHlFeGVjdXRlO1xuLyoqXG4gKiBFeGVjdXRlIGFuZCByZXR1cm4gYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aXRoIGEgdGltZW91dC5cbiAqXG4gKiBAcGFyYW0gb3BlcmF0aW9uIC0gRnVuY3Rpb24gcmV0dXJuaW5nIGEgUHJvbWlzZS5cbiAqIEBwYXJhbSBsb2dFcnJvciAtIERldGVybWluZXMgaWYgdGhlIGVycm9yIHNob3VsZCBiZSBsb2dnZWQuXG4gKiBAcGFyYW0gdGltZW91dCAtIFRpbWVvdXQgdG8gZmFpbCB0aGUgb3BlcmF0aW9uLlxuICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHJlc3VsdCBvZiB0aGUgYXN5bmMgb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiBzYWZlbHlFeGVjdXRlV2l0aFRpbWVvdXQob3BlcmF0aW9uLCBsb2dFcnJvciA9IGZhbHNlLCB0aW1lb3V0ID0gNTAwKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbigpLFxuICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCd0aW1lb3V0JykpO1xuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpKSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGlmIChsb2dFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5zYWZlbHlFeGVjdXRlV2l0aFRpbWVvdXQgPSBzYWZlbHlFeGVjdXRlV2l0aFRpbWVvdXQ7XG4vKipcbiAqIENvbnZlcnQgYW4gYWRkcmVzcyB0byBhIGNoZWNrc3VtbWVkIGhleGlkZWNpbWFsIGFkZHJlc3MuXG4gKlxuICogQHBhcmFtIGFkZHJlc3MgLSBUaGUgYWRkcmVzcyB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQSAweC1wcmVmaXhlZCBoZXhpZGVjaW1hbCBjaGVja3N1bW1lZCBhZGRyZXNzLlxuICovXG5mdW5jdGlvbiB0b0NoZWNrc3VtSGV4QWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgY29uc3QgaGV4UHJlZml4ZWQgPSBldGhlcmV1bWpzX3V0aWxfMS5hZGRIZXhQcmVmaXgoYWRkcmVzcyk7XG4gICAgaWYgKCFldGhlcmV1bWpzX3V0aWxfMS5pc0hleFN0cmluZyhoZXhQcmVmaXhlZCkpIHtcbiAgICAgICAgLy8gVmVyc2lvbiA1LjEgb2YgZXRoZXJldW1qcy11dGlscyB3b3VsZCBoYXZlIHJldHVybmVkICcweFknIGZvciBpbnB1dCAneSdcbiAgICAgICAgLy8gYnV0IHdlIHNob3VsZG4ndCB3YXN0ZSBlZmZvcnQgdHJ5aW5nIHRvIGNoYW5nZSBjYXNlIG9uIGEgY2xlYXJseSBpbnZhbGlkXG4gICAgICAgIC8vIHN0cmluZy4gSW5zdGVhZCBqdXN0IHJldHVybiB0aGUgaGV4IHByZWZpeGVkIG9yaWdpbmFsIHN0cmluZyB3aGljaCBtb3N0XG4gICAgICAgIC8vIGNsb3NlbHkgbWltaWNzIHRoZSBvcmlnaW5hbCBiZWhhdmlvci5cbiAgICAgICAgcmV0dXJuIGhleFByZWZpeGVkO1xuICAgIH1cbiAgICByZXR1cm4gZXRoZXJldW1qc191dGlsXzEudG9DaGVja3N1bUFkZHJlc3MoaGV4UHJlZml4ZWQpO1xufVxuZXhwb3J0cy50b0NoZWNrc3VtSGV4QWRkcmVzcyA9IHRvQ2hlY2tzdW1IZXhBZGRyZXNzO1xuLyoqXG4gKiBWYWxpZGF0ZXMgdGhhdCB0aGUgaW5wdXQgaXMgYSBoZXggYWRkcmVzcy4gVGhpcyB1dGlsaXR5IG1ldGhvZCBpcyBhIHRoaW5cbiAqIHdyYXBwZXIgYXJvdW5kIGV0aGVyZXVtanMtdXRpbC5pc1ZhbGlkQWRkcmVzcywgd2l0aCB0aGUgZXhjZXB0aW9uIHRoYXQgaXRcbiAqIGRvZXMgbm90IHRocm93IGFuIGVycm9yIHdoZW4gcHJvdmlkZWQgdmFsdWVzIHRoYXQgYXJlIG5vdCBoZXggc3RyaW5ncy4gSW5cbiAqIGFkZGl0aW9uLCBhbmQgYnkgZGVmYXVsdCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gdHJ1ZSBmb3IgaGV4IHN0cmluZ3MgdGhhdFxuICogbWVldCB0aGUgbGVuZ3RoIHJlcXVpcmVtZW50IG9mIGEgaGV4IGFkZHJlc3MsIGJ1dCBhcmUgbm90IHByZWZpeGVkIHdpdGggYDB4YFxuICogRmluYWxseSwgaWYgdGhlIG1peGVkQ2FzZVVzZUNoZWNrc3VtIGZsYWcgaXMgdHJ1ZSBhbmQgYSBtaXhlZCBjYXNlIHN0cmluZyBpc1xuICogcHJvdmlkZWQgdGhpcyBtZXRob2Qgd2lsbCB2YWxpZGF0ZSBpdCBoYXMgdGhlIHByb3BlciBjaGVja3N1bSBmb3JtYXR0aW5nLlxuICpcbiAqIEBwYXJhbSBwb3NzaWJsZUFkZHJlc3MgLSBJbnB1dCBwYXJhbWV0ZXIgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHZhbGlkYXRpb24gb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zLmFsbG93Tm9uUHJlZml4ZWQgLSBJZiB0cnVlIHdpbGwgZmlyc3QgZW5zdXJlICcweCcgaXMgcHJlcGVuZGVkIHRvIHRoZSBzdHJpbmcuXG4gKiBAcmV0dXJucyBXaGV0aGVyIG9yIG5vdCB0aGUgaW5wdXQgaXMgYSB2YWxpZCBoZXggYWRkcmVzcy5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEhleEFkZHJlc3MocG9zc2libGVBZGRyZXNzLCB7IGFsbG93Tm9uUHJlZml4ZWQgPSB0cnVlIH0gPSB7fSkge1xuICAgIGNvbnN0IGFkZHJlc3NUb0NoZWNrID0gYWxsb3dOb25QcmVmaXhlZFxuICAgICAgICA/IGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeChwb3NzaWJsZUFkZHJlc3MpXG4gICAgICAgIDogcG9zc2libGVBZGRyZXNzO1xuICAgIGlmICghZXRoZXJldW1qc191dGlsXzEuaXNIZXhTdHJpbmcoYWRkcmVzc1RvQ2hlY2spKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGV0aGVyZXVtanNfdXRpbF8xLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3NUb0NoZWNrKTtcbn1cbmV4cG9ydHMuaXNWYWxpZEhleEFkZHJlc3MgPSBpc1ZhbGlkSGV4QWRkcmVzcztcbi8qKlxuICogVmFsaWRhdGVzIGEgVHJhbnNhY3Rpb24gb2JqZWN0IGZvciByZXF1aXJlZCBwcm9wZXJ0aWVzIGFuZCB0aHJvd3MgaW5cbiAqIHRoZSBldmVudCBvZiBhbnkgdmFsaWRhdGlvbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSBUcmFuc2FjdGlvbiBvYmplY3QgdG8gdmFsaWRhdGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICBpZiAoIXRyYW5zYWN0aW9uLmZyb20gfHxcbiAgICAgICAgdHlwZW9mIHRyYW5zYWN0aW9uLmZyb20gIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICFpc1ZhbGlkSGV4QWRkcmVzcyh0cmFuc2FjdGlvbi5mcm9tKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXCJmcm9tXCIgYWRkcmVzczogJHt0cmFuc2FjdGlvbi5mcm9tfSBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nLmApO1xuICAgIH1cbiAgICBpZiAodHJhbnNhY3Rpb24udG8gPT09ICcweCcgfHwgdHJhbnNhY3Rpb24udG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24uZGF0YSkge1xuICAgICAgICAgICAgZGVsZXRlIHRyYW5zYWN0aW9uLnRvO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwidG9cIiBhZGRyZXNzOiAke3RyYW5zYWN0aW9uLnRvfSBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHRyYW5zYWN0aW9uLnRvICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgIWlzVmFsaWRIZXhBZGRyZXNzKHRyYW5zYWN0aW9uLnRvKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXCJ0b1wiIGFkZHJlc3M6ICR7dHJhbnNhY3Rpb24udG99IG11c3QgYmUgYSB2YWxpZCBzdHJpbmcuYCk7XG4gICAgfVxuICAgIGlmICh0cmFuc2FjdGlvbi52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdHJhbnNhY3Rpb24udmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKCctJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcInZhbHVlXCI6ICR7dmFsdWV9IGlzIG5vdCBhIHBvc2l0aXZlIG51bWJlci5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwidmFsdWVcIjogJHt2YWx1ZX0gbnVtYmVyIG11c3QgYmUgZGVub21pbmF0ZWQgaW4gd2VpLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodHJhbnNhY3Rpb24udmFsdWUsIDEwKTtcbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IE51bWJlci5pc0Zpbml0ZShpbnRWYWx1ZSkgJiZcbiAgICAgICAgICAgICFOdW1iZXIuaXNOYU4oaW50VmFsdWUpICYmXG4gICAgICAgICAgICAhaXNOYU4oTnVtYmVyKHZhbHVlKSkgJiZcbiAgICAgICAgICAgIE51bWJlci5pc1NhZmVJbnRlZ2VyKGludFZhbHVlKTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXCJ2YWx1ZVwiOiAke3ZhbHVlfSBudW1iZXIgbXVzdCBiZSBhIHZhbGlkIG51bWJlci5gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVUcmFuc2FjdGlvbiA9IHZhbGlkYXRlVHJhbnNhY3Rpb247XG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgY29udmVydHMgcmF3bWVzc2FnZURhdGEgYnVmZmVyIGRhdGEgdG8gYSBoZXgsIG9yIGp1c3QgcmV0dXJucyB0aGUgZGF0YSBpZlxuICogaXQgaXMgYWxyZWFkeSBmb3JtYXR0ZWQgYXMgYSBoZXguXG4gKlxuICogQHBhcmFtIGRhdGEgLSBUaGUgYnVmZmVyIGRhdGEgdG8gY29udmVydCB0byBhIGhleC5cbiAqIEByZXR1cm5zIEEgaGV4IHN0cmluZyBjb252ZXJzaW9uIG9mIHRoZSBidWZmZXIgZGF0YS5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplTWVzc2FnZURhdGEoZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN0cmlwcGVkID0gZXRoZXJldW1qc191dGlsXzEuc3RyaXBIZXhQcmVmaXgoZGF0YSk7XG4gICAgICAgIGlmIChzdHJpcHBlZC5tYXRjaChoZXhSZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBldGhlcmV1bWpzX3V0aWxfMS5hZGRIZXhQcmVmaXgoc3RyaXBwZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgfVxuICAgIHJldHVybiBldGhlcmV1bWpzX3V0aWxfMS5idWZmZXJUb0hleChCdWZmZXIuZnJvbShkYXRhLCAndXRmOCcpKTtcbn1cbmV4cG9ydHMubm9ybWFsaXplTWVzc2FnZURhdGEgPSBub3JtYWxpemVNZXNzYWdlRGF0YTtcbi8qKlxuICogVmFsaWRhdGVzIGEgUGVyc29uYWxNZXNzYWdlUGFyYW1zIGFuZCBNZXNzYWdlUGFyYW1zIG9iamVjdHMgZm9yIHJlcXVpcmVkIHByb3BlcnRpZXMgYW5kIHRocm93cyBpblxuICogdGhlIGV2ZW50IG9mIGFueSB2YWxpZGF0aW9uIGVycm9yLlxuICpcbiAqIEBwYXJhbSBtZXNzYWdlRGF0YSAtIFBlcnNvbmFsTWVzc2FnZVBhcmFtcyBvYmplY3QgdG8gdmFsaWRhdGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU2lnbk1lc3NhZ2VEYXRhKG1lc3NhZ2VEYXRhKSB7XG4gICAgY29uc3QgeyBmcm9tLCBkYXRhIH0gPSBtZXNzYWdlRGF0YTtcbiAgICBpZiAoIWZyb20gfHwgdHlwZW9mIGZyb20gIT09ICdzdHJpbmcnIHx8ICFpc1ZhbGlkSGV4QWRkcmVzcyhmcm9tKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXCJmcm9tXCIgYWRkcmVzczogJHtmcm9tfSBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nLmApO1xuICAgIH1cbiAgICBpZiAoIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtZXNzYWdlIFwiZGF0YVwiOiAke2RhdGF9IG11c3QgYmUgYSB2YWxpZCBzdHJpbmcuYCk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVNpZ25NZXNzYWdlRGF0YSA9IHZhbGlkYXRlU2lnbk1lc3NhZ2VEYXRhO1xuLyoqXG4gKiBWYWxpZGF0ZXMgYSBUeXBlZE1lc3NhZ2VQYXJhbXMgb2JqZWN0IGZvciByZXF1aXJlZCBwcm9wZXJ0aWVzIGFuZCB0aHJvd3MgaW5cbiAqIHRoZSBldmVudCBvZiBhbnkgdmFsaWRhdGlvbiBlcnJvciBmb3IgZXRoX3NpZ25UeXBlZE1lc3NhZ2VfVjEuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2VEYXRhIC0gVHlwZWRNZXNzYWdlUGFyYW1zIG9iamVjdCB0byB2YWxpZGF0ZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVUeXBlZFNpZ25NZXNzYWdlRGF0YVYxKG1lc3NhZ2VEYXRhKSB7XG4gICAgaWYgKCFtZXNzYWdlRGF0YS5mcm9tIHx8XG4gICAgICAgIHR5cGVvZiBtZXNzYWdlRGF0YS5mcm9tICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAhaXNWYWxpZEhleEFkZHJlc3MobWVzc2FnZURhdGEuZnJvbSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwiZnJvbVwiIGFkZHJlc3M6ICR7bWVzc2FnZURhdGEuZnJvbX0gbXVzdCBiZSBhIHZhbGlkIHN0cmluZy5gKTtcbiAgICB9XG4gICAgaWYgKCFtZXNzYWdlRGF0YS5kYXRhIHx8ICFBcnJheS5pc0FycmF5KG1lc3NhZ2VEYXRhLmRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtZXNzYWdlIFwiZGF0YVwiOiAke21lc3NhZ2VEYXRhLmRhdGF9IG11c3QgYmUgYSB2YWxpZCBhcnJheS5gKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gdHlwZWRTaWduYXR1cmVIYXNoIHdpbGwgdGhyb3cgaWYgdGhlIGRhdGEgaXMgaW52YWxpZC5cbiAgICAgICAgZXRoX3NpZ191dGlsXzEudHlwZWRTaWduYXR1cmVIYXNoKG1lc3NhZ2VEYXRhLmRhdGEpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIEVJUDcxMiB0eXBlZCBkYXRhLmApO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVUeXBlZFNpZ25NZXNzYWdlRGF0YVYxID0gdmFsaWRhdGVUeXBlZFNpZ25NZXNzYWdlRGF0YVYxO1xuLyoqXG4gKiBWYWxpZGF0ZXMgYSBUeXBlZE1lc3NhZ2VQYXJhbXMgb2JqZWN0IGZvciByZXF1aXJlZCBwcm9wZXJ0aWVzIGFuZCB0aHJvd3MgaW5cbiAqIHRoZSBldmVudCBvZiBhbnkgdmFsaWRhdGlvbiBlcnJvciBmb3IgZXRoX3NpZ25UeXBlZE1lc3NhZ2VfVjMuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2VEYXRhIC0gVHlwZWRNZXNzYWdlUGFyYW1zIG9iamVjdCB0byB2YWxpZGF0ZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVUeXBlZFNpZ25NZXNzYWdlRGF0YVYzKG1lc3NhZ2VEYXRhKSB7XG4gICAgaWYgKCFtZXNzYWdlRGF0YS5mcm9tIHx8XG4gICAgICAgIHR5cGVvZiBtZXNzYWdlRGF0YS5mcm9tICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAhaXNWYWxpZEhleEFkZHJlc3MobWVzc2FnZURhdGEuZnJvbSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwiZnJvbVwiIGFkZHJlc3M6ICR7bWVzc2FnZURhdGEuZnJvbX0gbXVzdCBiZSBhIHZhbGlkIHN0cmluZy5gKTtcbiAgICB9XG4gICAgaWYgKCFtZXNzYWdlRGF0YS5kYXRhIHx8IHR5cGVvZiBtZXNzYWdlRGF0YS5kYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWVzc2FnZSBcImRhdGFcIjogJHttZXNzYWdlRGF0YS5kYXRhfSBtdXN0IGJlIGEgdmFsaWQgYXJyYXkuYCk7XG4gICAgfVxuICAgIGxldCBkYXRhO1xuICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKG1lc3NhZ2VEYXRhLmRhdGEpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgbXVzdCBiZSBwYXNzZWQgYXMgYSB2YWxpZCBKU09OIHN0cmluZy4nKTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdGlvbiA9IGpzb25zY2hlbWFfMS52YWxpZGF0ZShkYXRhLCBldGhfc2lnX3V0aWxfMS5UWVBFRF9NRVNTQUdFX1NDSEVNQSk7XG4gICAgaWYgKHZhbGlkYXRpb24uZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIG11c3QgY29uZm9ybSB0byBFSVAtNzEyIHNjaGVtYS4gU2VlIGh0dHBzOi8vZ2l0LmlvL2ZOdGN4LicpO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVUeXBlZFNpZ25NZXNzYWdlRGF0YVYzID0gdmFsaWRhdGVUeXBlZFNpZ25NZXNzYWdlRGF0YVYzO1xuLyoqXG4gKiBWYWxpZGF0ZXMgYSBFUkMyMCB0b2tlbiB0byBiZSBhZGRlZCB3aXRoIEVJUDc0Ny5cbiAqXG4gKiBAcGFyYW0gdG9rZW4gLSBUb2tlbiBvYmplY3QgdG8gdmFsaWRhdGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlVG9rZW5Ub1dhdGNoKHRva2VuKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBzeW1ib2wsIGRlY2ltYWxzIH0gPSB0b2tlbjtcbiAgICBpZiAoIWFkZHJlc3MgfHwgIXN5bWJvbCB8fCB0eXBlb2YgZGVjaW1hbHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKGBNdXN0IHNwZWNpZnkgYWRkcmVzcywgc3ltYm9sLCBhbmQgZGVjaW1hbHMuYCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3ltYm9sICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyhgSW52YWxpZCBzeW1ib2w6IG5vdCBhIHN0cmluZy5gKTtcbiAgICB9XG4gICAgaWYgKHN5bWJvbC5sZW5ndGggPiAxMSkge1xuICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyhgSW52YWxpZCBzeW1ib2wgXCIke3N5bWJvbH1cIjogbG9uZ2VyIHRoYW4gMTEgY2hhcmFjdGVycy5gKTtcbiAgICB9XG4gICAgY29uc3QgbnVtRGVjaW1hbHMgPSBwYXJzZUludChkZWNpbWFscywgMTApO1xuICAgIGlmIChpc05hTihudW1EZWNpbWFscykgfHwgbnVtRGVjaW1hbHMgPiAzNiB8fCBudW1EZWNpbWFscyA8IDApIHtcbiAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoYEludmFsaWQgZGVjaW1hbHMgXCIke2RlY2ltYWxzfVwiOiBtdXN0IGJlIDAgPD0gMzYuYCk7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZEhleEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoYEludmFsaWQgYWRkcmVzcyBcIiR7YWRkcmVzc31cIi5gKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlVG9rZW5Ub1dhdGNoID0gdmFsaWRhdGVUb2tlblRvV2F0Y2g7XG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gY29kZSBjb3JyZXNwb25kcyB0byBhIHNtYXJ0IGNvbnRyYWN0LlxuICpcbiAqIEBwYXJhbSBjb2RlIC0gVGhlIHBvdGVudGlhbCBzbWFydCBjb250cmFjdCBjb2RlLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgY29kZSB3YXMgc21hcnQgY29udHJhY3QgY29kZSBvciBub3QuXG4gKi9cbmZ1bmN0aW9uIGlzU21hcnRDb250cmFjdENvZGUoY29kZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY29kZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEdldGggd2lsbCByZXR1cm4gJzB4JywgYW5kIGdhbmFjaGUtY29yZSB2Mi4yLjEgd2lsbCByZXR1cm4gJzB4MCdcbiAgICBjb25zdCBzbWFydENvbnRyYWN0Q29kZSA9IGNvZGUgIT09ICcweCcgJiYgY29kZSAhPT0gJzB4MCc7XG4gICAgcmV0dXJuIHNtYXJ0Q29udHJhY3RDb2RlO1xufVxuZXhwb3J0cy5pc1NtYXJ0Q29udHJhY3RDb2RlID0gaXNTbWFydENvbnRyYWN0Q29kZTtcbi8qKlxuICogRXhlY3V0ZSBmZXRjaCBhbmQgdmVyaWZ5IHRoYXQgdGhlIHJlc3BvbnNlIHdhcyBzdWNjZXNzZnVsLlxuICpcbiAqIEBwYXJhbSByZXF1ZXN0IC0gUmVxdWVzdCBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRmV0Y2ggb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBmZXRjaCByZXNwb25zZS5cbiAqL1xuZnVuY3Rpb24gc3VjY2Vzc2Z1bEZldGNoKHJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGZldGNoKHJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZldGNoIGZhaWxlZCB3aXRoIHN0YXR1cyAnJHtyZXNwb25zZS5zdGF0dXN9JyBmb3IgcmVxdWVzdCAnJHtyZXF1ZXN0fSdgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSk7XG59XG5leHBvcnRzLnN1Y2Nlc3NmdWxGZXRjaCA9IHN1Y2Nlc3NmdWxGZXRjaDtcbi8qKlxuICogRXhlY3V0ZSBmZXRjaCBhbmQgcmV0dXJuIG9iamVjdCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0gcmVxdWVzdCAtIFRoZSByZXF1ZXN0IGluZm9ybWF0aW9uLlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgZmV0Y2ggb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBmZXRjaCByZXNwb25zZSBKU09OIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUZldGNoKHJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHN1Y2Nlc3NmdWxGZXRjaChyZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0geWllbGQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xufVxuZXhwb3J0cy5oYW5kbGVGZXRjaCA9IGhhbmRsZUZldGNoO1xuLyoqXG4gKiBGZXRjaCB0aGF0IGZhaWxzIGFmdGVyIHRpbWVvdXQuXG4gKlxuICogQHBhcmFtIHVybCAtIFVybCB0byBmZXRjaC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBzZW5kIHdpdGggdGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0gdGltZW91dCAtIFRpbWVvdXQgdG8gZmFpbCByZXF1ZXN0LlxuICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdGhlIHJlcXVlc3QuXG4gKi9cbmZ1bmN0aW9uIHRpbWVvdXRGZXRjaCh1cmwsIG9wdGlvbnMsIHRpbWVvdXQgPSA1MDApIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgIHN1Y2Nlc3NmdWxGZXRjaCh1cmwsIG9wdGlvbnMpLFxuICAgICAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcigndGltZW91dCcpKTtcbiAgICAgICAgICAgIH0sIHRpbWVvdXQpKSxcbiAgICAgICAgXSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnRpbWVvdXRGZXRjaCA9IHRpbWVvdXRGZXRjaDtcbi8qKlxuICogTm9ybWFsaXplcyB0aGUgZ2l2ZW4gRU5TIG5hbWUuXG4gKlxuICogQHBhcmFtIGVuc05hbWUgLSBUaGUgRU5TIG5hbWUuXG4gKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCBFTlMgbmFtZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuc05hbWUoZW5zTmFtZSkge1xuICAgIGlmIChlbnNOYW1lICYmIHR5cGVvZiBlbnNOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGV0aF9lbnNfbmFtZWhhc2hfMS5kZWZhdWx0Lm5vcm1hbGl6ZShlbnNOYW1lLnRyaW0oKSk7XG4gICAgICAgICAgICAvLyB0aGlzIHJlZ2V4IGlzIG9ubHkgc3VmZmljaWVudCB3aXRoIHRoZSBhYm92ZSBjYWxsIHRvIGVuc05hbWVoYXNoLm5vcm1hbGl6ZVxuICAgICAgICAgICAgLy8gVE9ETzogY2hhbmdlIDcgaW4gcmVnZXggdG8gMyB3aGVuIHNob3J0ZXIgRU5TIGRvbWFpbnMgYXJlIGxpdmVcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkLm1hdGNoKC9eKChbXFx3XFxkLV0rKVxcLikqW1xcd1xcZC1dezcsfVxcLihldGh8dGVzdCkkL3UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMubm9ybWFsaXplRW5zTmFtZSA9IG5vcm1hbGl6ZUVuc05hbWU7XG4vKipcbiAqIFdyYXBwZXIgbWV0aG9kIHRvIGhhbmRsZSBFdGhRdWVyeSByZXF1ZXN0cy5cbiAqXG4gKiBAcGFyYW0gZXRoUXVlcnkgLSBFdGhRdWVyeSBvYmplY3QgaW5pdGlhbGl6ZWQgd2l0aCBhIHByb3ZpZGVyLlxuICogQHBhcmFtIG1ldGhvZCAtIE1ldGhvZCB0byByZXF1ZXN0LlxuICogQHBhcmFtIGFyZ3MgLSBBcmd1bWVudHMgdG8gc2VuZC5cbiAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRoZSByZXF1ZXN0LlxuICovXG5mdW5jdGlvbiBxdWVyeShldGhRdWVyeSwgbWV0aG9kLCBhcmdzID0gW10pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBjYiA9IChlcnJvciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBldGhRdWVyeVttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBldGhRdWVyeVttZXRob2RdKC4uLmFyZ3MsIGNiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV0aFF1ZXJ5LnNlbmRBc3luYyh7IG1ldGhvZCwgcGFyYW1zOiBhcmdzIH0sIGNiKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5xdWVyeSA9IHF1ZXJ5O1xuLyoqXG4gKiBDaGVja3MgaWYgYSB0cmFuc2FjdGlvbiBpcyBFSVAtMTU1OSBieSBjaGVja2luZyBmb3IgdGhlIGV4aXN0ZW5jZSBvZlxuICogbWF4RmVlUGVyR2FzIGFuZCBtYXhQcmlvcml0eUZlZVBlckdhcyB3aXRoaW4gaXRzIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVHJhbnNhY3Rpb24gb2JqZWN0IHRvIGFkZC5cbiAqIEByZXR1cm5zIEJvb2xlYW4gdGhhdCBpcyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBFSVAtMTU1OSAoaGFzIG1heEZlZVBlckdhcyBhbmQgbWF4UHJpb3JpdHlGZWVQZXJHYXMpLCBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cbiAqL1xuY29uc3QgaXNFSVAxNTU5VHJhbnNhY3Rpb24gPSAodHJhbnNhY3Rpb24pID0+IHtcbiAgICBjb25zdCBoYXNPd25Qcm9wID0gKG9iaiwga2V5KSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICAgIHJldHVybiAoaGFzT3duUHJvcCh0cmFuc2FjdGlvbiwgJ21heEZlZVBlckdhcycpICYmXG4gICAgICAgIGhhc093blByb3AodHJhbnNhY3Rpb24sICdtYXhQcmlvcml0eUZlZVBlckdhcycpKTtcbn07XG5leHBvcnRzLmlzRUlQMTU1OVRyYW5zYWN0aW9uID0gaXNFSVAxNTU5VHJhbnNhY3Rpb247XG5jb25zdCBjb252ZXJ0UHJpY2VUb0RlY2ltYWwgPSAodmFsdWUpID0+IHBhcnNlSW50KHZhbHVlID09PSB1bmRlZmluZWQgPyAnMHgwJyA6IHZhbHVlLCAxNik7XG5leHBvcnRzLmNvbnZlcnRQcmljZVRvRGVjaW1hbCA9IGNvbnZlcnRQcmljZVRvRGVjaW1hbDtcbmNvbnN0IGdldEluY3JlYXNlZFByaWNlSGV4ID0gKHZhbHVlLCByYXRlKSA9PiBldGhlcmV1bWpzX3V0aWxfMS5hZGRIZXhQcmVmaXgoYCR7cGFyc2VJbnQoYCR7dmFsdWUgKiByYXRlfWAsIDEwKS50b1N0cmluZygxNil9YCk7XG5leHBvcnRzLmdldEluY3JlYXNlZFByaWNlSGV4ID0gZ2V0SW5jcmVhc2VkUHJpY2VIZXg7XG5jb25zdCBnZXRJbmNyZWFzZWRQcmljZUZyb21FeGlzdGluZyA9ICh2YWx1ZSwgcmF0ZSkgPT4ge1xuICAgIHJldHVybiBleHBvcnRzLmdldEluY3JlYXNlZFByaWNlSGV4KGV4cG9ydHMuY29udmVydFByaWNlVG9EZWNpbWFsKHZhbHVlKSwgcmF0ZSk7XG59O1xuZXhwb3J0cy5nZXRJbmNyZWFzZWRQcmljZUZyb21FeGlzdGluZyA9IGdldEluY3JlYXNlZFByaWNlRnJvbUV4aXN0aW5nO1xuY29uc3QgdmFsaWRhdGVHYXNWYWx1ZXMgPSAoZ2FzVmFsdWVzKSA9PiB7XG4gICAgT2JqZWN0LmtleXMoZ2FzVmFsdWVzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnYXNWYWx1ZXNba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgIWV0aGVyZXVtanNfdXRpbF8xLmlzSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgaGV4IHN0cmluZyBmb3IgJHtrZXl9IGJ1dCByZWNlaXZlZDogJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmV4cG9ydHMudmFsaWRhdGVHYXNWYWx1ZXMgPSB2YWxpZGF0ZUdhc1ZhbHVlcztcbmNvbnN0IGlzRmVlTWFya2V0RUlQMTU1OVZhbHVlcyA9IChnYXNWYWx1ZXMpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoKF9hID0gZ2FzVmFsdWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWF4RmVlUGVyR2FzKSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICgoX2IgPSBnYXNWYWx1ZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tYXhQcmlvcml0eUZlZVBlckdhcykgIT09IHVuZGVmaW5lZDtcbn07XG5leHBvcnRzLmlzRmVlTWFya2V0RUlQMTU1OVZhbHVlcyA9IGlzRmVlTWFya2V0RUlQMTU1OVZhbHVlcztcbmNvbnN0IGlzR2FzUHJpY2VWYWx1ZSA9IChnYXNWYWx1ZXMpID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IGdhc1ZhbHVlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdhc1ByaWNlKSAhPT0gdW5kZWZpbmVkOyB9O1xuZXhwb3J0cy5pc0dhc1ByaWNlVmFsdWUgPSBpc0dhc1ByaWNlVmFsdWU7XG4vKipcbiAqIFZhbGlkYXRlcyB0aGF0IHRoZSBwcm9wb3NlZCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG1pbmltdW0gdmFsdWUuXG4gKlxuICogQHBhcmFtIHByb3Bvc2VkIC0gVGhlIHByb3Bvc2VkIHZhbHVlLlxuICogQHBhcmFtIG1pbiAtIFRoZSBtaW5pbXVtIHZhbHVlLlxuICogQHJldHVybnMgVGhlIHByb3Bvc2VkIHZhbHVlLlxuICogQHRocm93cyBXaWxsIHRocm93IGlmIHRoZSBwcm9wb3NlZCB2YWx1ZSBpcyB0b28gbG93LlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU1pbmltdW1JbmNyZWFzZShwcm9wb3NlZCwgbWluKSB7XG4gICAgY29uc3QgcHJvcG9zZWREZWNpbWFsID0gZXhwb3J0cy5jb252ZXJ0UHJpY2VUb0RlY2ltYWwocHJvcG9zZWQpO1xuICAgIGNvbnN0IG1pbkRlY2ltYWwgPSBleHBvcnRzLmNvbnZlcnRQcmljZVRvRGVjaW1hbChtaW4pO1xuICAgIGlmIChwcm9wb3NlZERlY2ltYWwgPj0gbWluRGVjaW1hbCkge1xuICAgICAgICByZXR1cm4gcHJvcG9zZWQ7XG4gICAgfVxuICAgIGNvbnN0IGVycm9yTXNnID0gYFRoZSBwcm9wb3NlZCB2YWx1ZTogJHtwcm9wb3NlZERlY2ltYWx9IHNob3VsZCBtZWV0IG9yIGV4Y2VlZCB0aGUgbWluaW11bSB2YWx1ZTogJHttaW5EZWNpbWFsfWA7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTtcbn1cbmV4cG9ydHMudmFsaWRhdGVNaW5pbXVtSW5jcmVhc2UgPSB2YWxpZGF0ZU1pbmltdW1JbmNyZWFzZTtcbi8qKlxuICogUmVtb3ZlcyBJUEZTIHByb3RvY29sIHByZWZpeCBmcm9tIGlucHV0IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gaXBmc1VybCAtIEFuIElQRlMgdXJsIChlLmcuIGlwZnM6Ly97Y29udGVudCBpZH0pXG4gKiBAcmV0dXJucyBJUEZTIGNvbnRlbnQgaWRlbnRpZmllciBhbmQgKHBvc3NpYmx5KSBwYXRoIGluIGEgc3RyaW5nXG4gKiBAdGhyb3dzIFdpbGwgdGhyb3cgaWYgdGhlIHVybCBwYXNzZWQgaXMgbm90IElQRlMuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUlwZnNQcm90b2NvbFByZWZpeChpcGZzVXJsKSB7XG4gICAgaWYgKGlwZnNVcmwuc3RhcnRzV2l0aCgnaXBmczovL2lwZnMvJykpIHtcbiAgICAgICAgcmV0dXJuIGlwZnNVcmwucmVwbGFjZSgnaXBmczovL2lwZnMvJywgJycpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpcGZzVXJsLnN0YXJ0c1dpdGgoJ2lwZnM6Ly8nKSkge1xuICAgICAgICByZXR1cm4gaXBmc1VybC5yZXBsYWNlKCdpcGZzOi8vJywgJycpO1xuICAgIH1cbiAgICAvLyB0aGlzIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQgd2l0aCBub24taXBmcyB1cmxzIChpLmUuIHN0YXJ0c1dpdGgoJ2lwZnM6Ly8nKSA9PT0gdHJ1ZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoaXMgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZCB3aXRoIG5vbiBpcGZzIHVybHMnKTtcbn1cbmV4cG9ydHMucmVtb3ZlSXBmc1Byb3RvY29sUHJlZml4ID0gcmVtb3ZlSXBmc1Byb3RvY29sUHJlZml4O1xuLyoqXG4gKiBFeHRyYWN0cyBjb250ZW50IGlkZW50aWZpZXIgYW5kIHBhdGggZnJvbSBhbiBpbnB1dCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGlwZnNVcmwgLSBBbiBJUEZTIFVSTCBtaW51cyB0aGUgSVBGUyBwcm90b2NvbCBwcmVmaXhcbiAqIEByZXR1cm5zIElGUFMgY29udGVudCBpZGVudGlmaWVyIChjaWQpIGFuZCBzdWIgcGF0aCBhcyBzdHJpbmcuXG4gKiBAdGhyb3dzIFdpbGwgdGhyb3cgaWYgdGhlIHVybCBwYXNzZWQgaXMgbm90IGlwZnMuXG4gKi9cbmZ1bmN0aW9uIGdldElwZnNDSUR2MUFuZFBhdGgoaXBmc1VybCkge1xuICAgIGNvbnN0IHVybCA9IHJlbW92ZUlwZnNQcm90b2NvbFByZWZpeChpcGZzVXJsKTtcbiAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyBhIHBhdGhcbiAgICAvLyAoQ0lEIGlzIGV2ZXJ5dGhpbmcgcHJlY2VkaW5nIGZpcnN0IGZvcndhcmQgc2xhc2gsIHBhdGggaXMgZXZlcnl0aGluZyBhZnRlcilcbiAgICBjb25zdCBpbmRleCA9IHVybC5pbmRleE9mKCcvJyk7XG4gICAgY29uc3QgY2lkID0gaW5kZXggIT09IC0xID8gdXJsLnN1YnN0cmluZygwLCBpbmRleCkgOiB1cmw7XG4gICAgY29uc3QgcGF0aCA9IGluZGV4ICE9PSAtMSA/IHVybC5zdWJzdHJpbmcoaW5kZXgpIDogdW5kZWZpbmVkO1xuICAgIC8vIFdlIHdhbnQgdG8gZW5zdXJlIHRoYXQgdGhlIENJRCBpcyB2MSAoaHR0cHM6Ly9kb2NzLmlwZnMuaW8vY29uY2VwdHMvY29udGVudC1hZGRyZXNzaW5nLyNpZGVudGlmaWVyLWZvcm1hdHMpXG4gICAgLy8gYmVjYXVzZSBtb3N0IGNpZCB2MHMgYXBwZWFyIHRvIGJlIGluY29tcGF0aWJsZSB3aXRoIElQRlMgc3ViZG9tYWluc1xuICAgIHJldHVybiB7XG4gICAgICAgIGNpZDogY2lkXzEuQ0lELnBhcnNlKGNpZCkudG9WMSgpLnRvU3RyaW5nKCksXG4gICAgICAgIHBhdGgsXG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0SXBmc0NJRHYxQW5kUGF0aCA9IGdldElwZnNDSUR2MUFuZFBhdGg7XG4vKipcbiAqIEFkZHMgVVJMIHByb3RvY29sIHByZWZpeCB0byBpbnB1dCBVUkwgc3RyaW5nIGlmIG1pc3NpbmcuXG4gKlxuICogQHBhcmFtIHVybFN0cmluZyAtIEFuIElQRlMgVVJMLlxuICogQHJldHVybnMgQSBVUkwgd2l0aCBhIGh0dHBzOi8vIHByZXBlbmRlZC5cbiAqL1xuZnVuY3Rpb24gYWRkVXJsUHJvdG9jb2xQcmVmaXgodXJsU3RyaW5nKSB7XG4gICAgaWYgKCF1cmxTdHJpbmcubWF0Y2goLyheaHR0cDpcXC9cXC8pfCheaHR0cHM6XFwvXFwvKS91KSkge1xuICAgICAgICByZXR1cm4gYGh0dHBzOi8vJHt1cmxTdHJpbmd9YDtcbiAgICB9XG4gICAgcmV0dXJuIHVybFN0cmluZztcbn1cbmV4cG9ydHMuYWRkVXJsUHJvdG9jb2xQcmVmaXggPSBhZGRVcmxQcm90b2NvbFByZWZpeDtcbi8qKlxuICogRm9ybWF0cyBVUkwgY29ycmVjdGx5IGZvciB1c2UgcmV0cmlldmluZyBhc3NldHMgaG9zdGVkIG9uIElQRlMuXG4gKlxuICogQHBhcmFtIGlwZnNHYXRld2F5IC0gVGhlIHVzZXJzIHByZWZlcnJlZCBJUEZTIGdhdGV3YXkgKGZ1bGwgVVJMIG9yIGp1c3QgaG9zdCkuXG4gKiBAcGFyYW0gaXBmc1VybCAtIFRoZSBJRlBTIFVSTCBwb2ludGVkIGF0IHRoZSBhc3NldC5cbiAqIEBwYXJhbSBzdWJkb21haW5TdXBwb3J0ZWQgLSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgVVJMIHNob3VsZCBiZSBmb3JtYXR0ZWQgd2l0aCBzdWJkb21haW5zIG9yIG5vdC5cbiAqIEByZXR1cm5zIEEgZm9ybWF0dGVkIFVSTCwgd2l0aCB0aGUgdXNlcidzIHByZWZlcnJlZCBJUEZTIGdhdGV3YXkgYW5kIGZvcm1hdCAoc3ViZG9tYWluIG9yIG5vdCksIHBvaW50aW5nIHRvIGFuIGFzc2V0IGhvc3RlZCBvbiBJUEZTLlxuICovXG5mdW5jdGlvbiBnZXRGb3JtYXR0ZWRJcGZzVXJsKGlwZnNHYXRld2F5LCBpcGZzVXJsLCBzdWJkb21haW5TdXBwb3J0ZWQpIHtcbiAgICBjb25zdCB7IGhvc3QsIHByb3RvY29sLCBvcmlnaW4gfSA9IG5ldyBVUkwoYWRkVXJsUHJvdG9jb2xQcmVmaXgoaXBmc0dhdGV3YXkpKTtcbiAgICBpZiAoc3ViZG9tYWluU3VwcG9ydGVkKSB7XG4gICAgICAgIGNvbnN0IHsgY2lkLCBwYXRoIH0gPSBnZXRJcGZzQ0lEdjFBbmRQYXRoKGlwZnNVcmwpO1xuICAgICAgICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2NpZH0uaXBmcy4ke2hvc3R9JHtwYXRoICE9PSBudWxsICYmIHBhdGggIT09IHZvaWQgMCA/IHBhdGggOiAnJ31gO1xuICAgIH1cbiAgICBjb25zdCBjaWRBbmRQYXRoID0gcmVtb3ZlSXBmc1Byb3RvY29sUHJlZml4KGlwZnNVcmwpO1xuICAgIHJldHVybiBgJHtvcmlnaW59L2lwZnMvJHtjaWRBbmRQYXRofWA7XG59XG5leHBvcnRzLmdldEZvcm1hdHRlZElwZnNVcmwgPSBnZXRGb3JtYXR0ZWRJcGZzVXJsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QaGlzaGluZ0NvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCBwdW55Y29kZV8xID0gcmVxdWlyZShcInB1bnljb2RlL1wiKTtcbmNvbnN0IGNvbmZpZ19qc29uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImV0aC1waGlzaGluZy1kZXRlY3Qvc3JjL2NvbmZpZy5qc29uXCIpKTtcbmNvbnN0IGRldGVjdG9yXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImV0aC1waGlzaGluZy1kZXRlY3Qvc3JjL2RldGVjdG9yXCIpKTtcbmNvbnN0IEJhc2VDb250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vQmFzZUNvbnRyb2xsZXJcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbi8qKlxuICogQ29udHJvbGxlciB0aGF0IHBhc3NpdmVseSBwb2xscyBvbiBhIHNldCBpbnRlcnZhbCBmb3IgYXBwcm92ZWQgYW5kIHVuYXBwcm92ZWQgd2Vic2l0ZSBvcmlnaW5zXG4gKi9cbmNsYXNzIFBoaXNoaW5nQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBQaGlzaGluZ0NvbnRyb2xsZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBzdGF0ZSkge1xuICAgICAgICBzdXBlcihjb25maWcsIHN0YXRlKTtcbiAgICAgICAgdGhpcy5jb25maWdVcmwgPSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL01ldGFNYXNrL2V0aC1waGlzaGluZy1kZXRlY3RAbWFzdGVyL3NyYy9jb25maWcuanNvbic7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ1BoaXNoaW5nQ29udHJvbGxlcic7XG4gICAgICAgIHRoaXMuZGVmYXVsdENvbmZpZyA9IHsgaW50ZXJ2YWw6IDYwICogNjAgKiAxMDAwIH07XG4gICAgICAgIHRoaXMuZGVmYXVsdFN0YXRlID0ge1xuICAgICAgICAgICAgcGhpc2hpbmc6IGNvbmZpZ19qc29uXzEuZGVmYXVsdCxcbiAgICAgICAgICAgIHdoaXRlbGlzdDogW10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGV0ZWN0b3IgPSBuZXcgZGV0ZWN0b3JfMS5kZWZhdWx0KHRoaXMuZGVmYXVsdFN0YXRlLnBoaXNoaW5nKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIHRoaXMucG9sbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgYSBuZXcgcG9sbGluZyBpbnRlcnZhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnRlcnZhbCAtIFBvbGxpbmcgaW50ZXJ2YWwgdXNlZCB0byBmZXRjaCBuZXcgYXBwcm92YWwgbGlzdHMuXG4gICAgICovXG4gICAgcG9sbChpbnRlcnZhbCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaW50ZXJ2YWwgJiYgdGhpcy5jb25maWd1cmUoeyBpbnRlcnZhbCB9LCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGUgJiYgY2xlYXJUaW1lb3V0KHRoaXMuaGFuZGxlKTtcbiAgICAgICAgICAgIHlpZWxkIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IHRoaXMudXBkYXRlUGhpc2hpbmdMaXN0cygpKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2xsKHRoaXMuY29uZmlnLmludGVydmFsKTtcbiAgICAgICAgICAgIH0sIHRoaXMuY29uZmlnLmludGVydmFsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBnaXZlbiBvcmlnaW4gaXMgdW5hcHByb3ZlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBEb21haW4gb3JpZ2luIG9mIGEgd2Vic2l0ZS5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBvcmlnaW4gaXMgYW4gdW5hcHByb3ZlZCBvcmlnaW4uXG4gICAgICovXG4gICAgdGVzdChvcmlnaW4pIHtcbiAgICAgICAgY29uc3QgcHVueWNvZGVPcmlnaW4gPSBwdW55Y29kZV8xLnRvQVNDSUkob3JpZ2luKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUud2hpdGVsaXN0LmluZGV4T2YocHVueWNvZGVPcmlnaW4pICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRldGVjdG9yLmNoZWNrKHB1bnljb2RlT3JpZ2luKS5yZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlbXBvcmFyaWx5IG1hcmtzIGEgZ2l2ZW4gb3JpZ2luIGFzIGFwcHJvdmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gdG8gbWFyayBhcyBhcHByb3ZlZC5cbiAgICAgKi9cbiAgICBieXBhc3Mob3JpZ2luKSB7XG4gICAgICAgIGNvbnN0IHB1bnljb2RlT3JpZ2luID0gcHVueWNvZGVfMS50b0FTQ0lJKG9yaWdpbik7XG4gICAgICAgIGNvbnN0IHsgd2hpdGVsaXN0IH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBpZiAod2hpdGVsaXN0LmluZGV4T2YocHVueWNvZGVPcmlnaW4pICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKHsgd2hpdGVsaXN0OiBbLi4ud2hpdGVsaXN0LCBwdW55Y29kZU9yaWdpbl0gfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgbGlzdHMgb2YgYXBwcm92ZWQgYW5kIHVuYXBwcm92ZWQgd2Vic2l0ZSBvcmlnaW5zLlxuICAgICAqL1xuICAgIHVwZGF0ZVBoaXNoaW5nTGlzdHMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBoaXNoaW5nT3B0cyA9IHlpZWxkIHRoaXMucXVlcnlDb25maWcodGhpcy5jb25maWdVcmwpO1xuICAgICAgICAgICAgaWYgKHBoaXNoaW5nT3B0cykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0ZWN0b3IgPSBuZXcgZGV0ZWN0b3JfMS5kZWZhdWx0KHBoaXNoaW5nT3B0cyk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgICAgICAgICBwaGlzaGluZzogcGhpc2hpbmdPcHRzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcXVlcnlDb25maWcoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgZmV0Y2goaW5wdXQsIHsgY2FjaGU6ICduby1jYWNoZScgfSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHJlc3BvbnNlLnN0YXR1cykge1xuICAgICAgICAgICAgICAgIGNhc2UgMjAwOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMzA0OlxuICAgICAgICAgICAgICAgIGNhc2UgNDAzOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmV0Y2ggZmFpbGVkIHdpdGggc3RhdHVzICcke3Jlc3BvbnNlLnN0YXR1c30nIGZvciByZXF1ZXN0ICcke2lucHV0fSdgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuUGhpc2hpbmdDb250cm9sbGVyID0gUGhpc2hpbmdDb250cm9sbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gUGhpc2hpbmdDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGhpc2hpbmdDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuS2V5cmluZ0NvbnRyb2xsZXIgPSBleHBvcnRzLlNpZ25UeXBlZERhdGFWZXJzaW9uID0gZXhwb3J0cy5BY2NvdW50SW1wb3J0U3RyYXRlZ3kgPSBleHBvcnRzLktleXJpbmdUeXBlcyA9IHZvaWQgMDtcbmNvbnN0IGV0aGVyZXVtanNfdXRpbF8xID0gcmVxdWlyZShcImV0aGVyZXVtanMtdXRpbFwiKTtcbmNvbnN0IGV0aF9zaWdfdXRpbF8xID0gcmVxdWlyZShcImV0aC1zaWctdXRpbFwiKTtcbmNvbnN0IGV0aGVyZXVtanNfd2FsbGV0XzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImV0aGVyZXVtanMtd2FsbGV0XCIpKTtcbmNvbnN0IGV0aF9rZXlyaW5nX2NvbnRyb2xsZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZXRoLWtleXJpbmctY29udHJvbGxlclwiKSk7XG5jb25zdCBhc3luY19tdXRleF8xID0gcmVxdWlyZShcImFzeW5jLW11dGV4XCIpO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgcHJpdmF0ZXMgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBBdmFpbGFibGUga2V5cmluZyB0eXBlc1xuICovXG52YXIgS2V5cmluZ1R5cGVzO1xuKGZ1bmN0aW9uIChLZXlyaW5nVHlwZXMpIHtcbiAgICBLZXlyaW5nVHlwZXNbXCJzaW1wbGVcIl0gPSBcIlNpbXBsZSBLZXkgUGFpclwiO1xuICAgIEtleXJpbmdUeXBlc1tcImhkXCJdID0gXCJIRCBLZXkgVHJlZVwiO1xufSkoS2V5cmluZ1R5cGVzID0gZXhwb3J0cy5LZXlyaW5nVHlwZXMgfHwgKGV4cG9ydHMuS2V5cmluZ1R5cGVzID0ge30pKTtcbi8qKlxuICogQSBzdHJhdGVneSBmb3IgaW1wb3J0aW5nIGFuIGFjY291bnRcbiAqL1xudmFyIEFjY291bnRJbXBvcnRTdHJhdGVneTtcbihmdW5jdGlvbiAoQWNjb3VudEltcG9ydFN0cmF0ZWd5KSB7XG4gICAgQWNjb3VudEltcG9ydFN0cmF0ZWd5W1wicHJpdmF0ZUtleVwiXSA9IFwicHJpdmF0ZUtleVwiO1xuICAgIEFjY291bnRJbXBvcnRTdHJhdGVneVtcImpzb25cIl0gPSBcImpzb25cIjtcbn0pKEFjY291bnRJbXBvcnRTdHJhdGVneSA9IGV4cG9ydHMuQWNjb3VudEltcG9ydFN0cmF0ZWd5IHx8IChleHBvcnRzLkFjY291bnRJbXBvcnRTdHJhdGVneSA9IHt9KSk7XG4vKipcbiAqIFRoZSBgc2lnblR5cGVkTWVzc2FnZWAgdmVyc2lvblxuICpcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLm1ldGFtYXNrLmlvL2d1aWRlL3NpZ25pbmctZGF0YS5odG1sXG4gKi9cbnZhciBTaWduVHlwZWREYXRhVmVyc2lvbjtcbihmdW5jdGlvbiAoU2lnblR5cGVkRGF0YVZlcnNpb24pIHtcbiAgICBTaWduVHlwZWREYXRhVmVyc2lvbltcIlYxXCJdID0gXCJWMVwiO1xuICAgIFNpZ25UeXBlZERhdGFWZXJzaW9uW1wiVjNcIl0gPSBcIlYzXCI7XG4gICAgU2lnblR5cGVkRGF0YVZlcnNpb25bXCJWNFwiXSA9IFwiVjRcIjtcbn0pKFNpZ25UeXBlZERhdGFWZXJzaW9uID0gZXhwb3J0cy5TaWduVHlwZWREYXRhVmVyc2lvbiB8fCAoZXhwb3J0cy5TaWduVHlwZWREYXRhVmVyc2lvbiA9IHt9KSk7XG4vKipcbiAqIENvbnRyb2xsZXIgcmVzcG9uc2libGUgZm9yIGVzdGFibGlzaGluZyBhbmQgbWFuYWdpbmcgdXNlciBpZGVudGl0eVxuICovXG5jbGFzcyBLZXlyaW5nQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBLZXlyaW5nQ29udHJvbGxlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGNvbnRyb2xsZXIgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZW1vdmVJZGVudGl0eSAtIFJlbW92ZSB0aGUgaWRlbnRpdHkgd2l0aCB0aGUgZ2l2ZW4gYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zeW5jSWRlbnRpdGllcyAtIFN5bmMgaWRlbnRpdGllcyB3aXRoIHRoZSBnaXZlbiBsaXN0IG9mIGFkZHJlc3Nlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy51cGRhdGVJZGVudGl0aWVzIC0gR2VuZXJhdGUgYW4gaWRlbnRpdHkgZm9yIGVhY2ggYWRkcmVzcyBnaXZlbiB0aGF0IGRvZXNuJ3QgYWxyZWFkeSBoYXZlIGFuIGlkZW50aXR5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnNldFNlbGVjdGVkQWRkcmVzcyAtIFNldCB0aGUgc2VsZWN0ZWQgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyByZW1vdmVJZGVudGl0eSwgc3luY0lkZW50aXRpZXMsIHVwZGF0ZUlkZW50aXRpZXMsIHNldFNlbGVjdGVkQWRkcmVzcywgfSwgY29uZmlnLCBzdGF0ZSkge1xuICAgICAgICBzdXBlcihjb25maWcsIHN0YXRlKTtcbiAgICAgICAgdGhpcy5tdXRleCA9IG5ldyBhc3luY19tdXRleF8xLk11dGV4KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ0tleXJpbmdDb250cm9sbGVyJztcbiAgICAgICAgcHJpdmF0ZXMuc2V0KHRoaXMsIHtcbiAgICAgICAgICAgIGtleXJpbmc6IG5ldyBldGhfa2V5cmluZ19jb250cm9sbGVyXzEuZGVmYXVsdChPYmplY3QuYXNzaWduKHsgaW5pdFN0YXRlOiBzdGF0ZSB9LCBjb25maWcpKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVmYXVsdFN0YXRlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5zdG9yZS5nZXRTdGF0ZSgpKSwgeyBrZXlyaW5nczogW10gfSk7XG4gICAgICAgIHRoaXMucmVtb3ZlSWRlbnRpdHkgPSByZW1vdmVJZGVudGl0eTtcbiAgICAgICAgdGhpcy5zeW5jSWRlbnRpdGllcyA9IHN5bmNJZGVudGl0aWVzO1xuICAgICAgICB0aGlzLnVwZGF0ZUlkZW50aXRpZXMgPSB1cGRhdGVJZGVudGl0aWVzO1xuICAgICAgICB0aGlzLnNldFNlbGVjdGVkQWRkcmVzcyA9IHNldFNlbGVjdGVkQWRkcmVzcztcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIHRoaXMuZnVsbFVwZGF0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGFjY291bnQgdG8gdGhlIGRlZmF1bHQgKGZpcnN0KSBIRCBzZWVkIHBocmFzZSBrZXlyaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gY3VycmVudCBzdGF0ZSB3aGVuIHRoZSBhY2NvdW50IGlzIGFkZGVkLlxuICAgICAqL1xuICAgIGFkZE5ld0FjY291bnQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwcmltYXJ5S2V5cmluZyA9IHByaXZhdGVzXG4gICAgICAgICAgICAgICAgLmdldCh0aGlzKVxuICAgICAgICAgICAgICAgIC5rZXlyaW5nLmdldEtleXJpbmdzQnlUeXBlKCdIRCBLZXkgVHJlZScpWzBdO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoIXByaW1hcnlLZXlyaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBIRCBrZXlyaW5nIGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvbGRBY2NvdW50cyA9IHlpZWxkIHByaXZhdGVzLmdldCh0aGlzKS5rZXlyaW5nLmdldEFjY291bnRzKCk7XG4gICAgICAgICAgICB5aWVsZCBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5hZGROZXdBY2NvdW50KHByaW1hcnlLZXlyaW5nKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0FjY291bnRzID0geWllbGQgcHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcuZ2V0QWNjb3VudHMoKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMudmVyaWZ5U2VlZFBocmFzZSgpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJZGVudGl0aWVzKG5ld0FjY291bnRzKTtcbiAgICAgICAgICAgIG5ld0FjY291bnRzLmZvckVhY2goKHNlbGVjdGVkQWRkcmVzcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghb2xkQWNjb3VudHMuaW5jbHVkZXMoc2VsZWN0ZWRBZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGVkQWRkcmVzcyhzZWxlY3RlZEFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVsbFVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBhY2NvdW50IHRvIHRoZSBkZWZhdWx0IChmaXJzdCkgSEQgc2VlZCBwaHJhc2Uga2V5cmluZyB3aXRob3V0IHVwZGF0aW5nIGlkZW50aXRpZXMgaW4gcHJlZmVyZW5jZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBjdXJyZW50IHN0YXRlIHdoZW4gdGhlIGFjY291bnQgaXMgYWRkZWQuXG4gICAgICovXG4gICAgYWRkTmV3QWNjb3VudFdpdGhvdXRVcGRhdGUoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwcmltYXJ5S2V5cmluZyA9IHByaXZhdGVzXG4gICAgICAgICAgICAgICAgLmdldCh0aGlzKVxuICAgICAgICAgICAgICAgIC5rZXlyaW5nLmdldEtleXJpbmdzQnlUeXBlKCdIRCBLZXkgVHJlZScpWzBdO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoIXByaW1hcnlLZXlyaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBIRCBrZXlyaW5nIGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5hZGROZXdBY2NvdW50KHByaW1hcnlLZXlyaW5nKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMudmVyaWZ5U2VlZFBocmFzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVsbFVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRWZmZWN0aXZlbHkgdGhlIHNhbWUgYXMgY3JlYXRpbmcgYSBuZXcga2V5Y2hhaW4gdGhlbiBwb3B1bGF0aW5nIGl0XG4gICAgICogdXNpbmcgdGhlIGdpdmVuIHNlZWQgcGhyYXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhc3N3b3JkIC0gUGFzc3dvcmQgdG8gdW5sb2NrIGtleWNoYWluLlxuICAgICAqIEBwYXJhbSBzZWVkIC0gU2VlZCBwaHJhc2UgdG8gcmVzdG9yZSBrZXljaGFpbi5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aCByZXN0b3JlZCBrZXljaGFpbiBvYmplY3QuXG4gICAgICovXG4gICAgY3JlYXRlTmV3VmF1bHRBbmRSZXN0b3JlKHBhc3N3b3JkLCBzZWVkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZWxlYXNlTG9jayA9IHlpZWxkIHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUlkZW50aXRpZXMoW10pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhdWx0ID0geWllbGQgcHJpdmF0ZXNcbiAgICAgICAgICAgICAgICAgICAgLmdldCh0aGlzKVxuICAgICAgICAgICAgICAgICAgICAua2V5cmluZy5jcmVhdGVOZXdWYXVsdEFuZFJlc3RvcmUocGFzc3dvcmQsIHNlZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSWRlbnRpdGllcyh5aWVsZCBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5nZXRBY2NvdW50cygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZ1bGxVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmF1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHByaW1hcnkga2V5Y2hhaW4gYW5kIHdpcGUgYW55IHByZXZpb3VzIGtleWNoYWlucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXNzd29yZCAtIFBhc3N3b3JkIHRvIHVubG9jayB0aGUgbmV3IHZhdWx0LlxuICAgICAqIEByZXR1cm5zIE5ld2x5LWNyZWF0ZWQga2V5Y2hhaW4gb2JqZWN0LlxuICAgICAqL1xuICAgIGNyZWF0ZU5ld1ZhdWx0QW5kS2V5Y2hhaW4ocGFzc3dvcmQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VMb2NrID0geWllbGQgdGhpcy5tdXRleC5hY3F1aXJlKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhdWx0ID0geWllbGQgcHJpdmF0ZXNcbiAgICAgICAgICAgICAgICAgICAgLmdldCh0aGlzKVxuICAgICAgICAgICAgICAgICAgICAua2V5cmluZy5jcmVhdGVOZXdWYXVsdEFuZEtleWNoYWluKHBhc3N3b3JkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUlkZW50aXRpZXMoeWllbGQgcHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcuZ2V0QWNjb3VudHMoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mdWxsVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN0YXR1cyBvZiB0aGUgdmF1bHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBCb29sZWFuIHJldHVybmluZyB0cnVlIGlmIHRoZSB2YXVsdCBpcyB1bmxvY2tlZC5cbiAgICAgKi9cbiAgICBpc1VubG9ja2VkKCkge1xuICAgICAgICByZXR1cm4gcHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcubWVtU3RvcmUuZ2V0U3RhdGUoKS5pc1VubG9ja2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzZWVkIHBocmFzZSBvZiB0aGUgSEQga2V5cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXNzd29yZCAtIFBhc3N3b3JkIG9mIHRoZSBrZXlyaW5nLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBzZWVkIHBocmFzZS5cbiAgICAgKi9cbiAgICBleHBvcnRTZWVkUGhyYXNlKHBhc3N3b3JkKSB7XG4gICAgICAgIGlmIChwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5wYXNzd29yZCA9PT0gcGFzc3dvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5rZXlyaW5nc1swXS5tbmVtb25pYztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFzc3dvcmQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcHJpdmF0ZSBrZXkgZnJvbSB0aGUga2V5cmluZyBjb250cm9sbGluZyBhbiBhZGRyZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhc3N3b3JkIC0gUGFzc3dvcmQgb2YgdGhlIGtleXJpbmcuXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBBZGRyZXNzIHRvIGV4cG9ydC5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgcHJpdmF0ZSBrZXkgZm9yIGFuIGFkZHJlc3MuXG4gICAgICovXG4gICAgZXhwb3J0QWNjb3VudChwYXNzd29yZCwgYWRkcmVzcykge1xuICAgICAgICBpZiAocHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcucGFzc3dvcmQgPT09IHBhc3N3b3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcuZXhwb3J0QWNjb3VudChhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFzc3dvcmQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHVibGljIGFkZHJlc3NlcyBvZiBhbGwgYWNjb3VudHMgZm9yIHRoZSBjdXJyZW50IGtleXJpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgcmVzb2x2aW5nIHRvIGFuIGFycmF5IG9mIGFkZHJlc3Nlcy5cbiAgICAgKi9cbiAgICBnZXRBY2NvdW50cygpIHtcbiAgICAgICAgcmV0dXJuIHByaXZhdGVzLmdldCh0aGlzKS5rZXlyaW5nLmdldEFjY291bnRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEltcG9ydHMgYW4gYWNjb3VudCB3aXRoIHRoZSBzcGVjaWZpZWQgaW1wb3J0IHN0cmF0ZWd5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0cmF0ZWd5IC0gSW1wb3J0IHN0cmF0ZWd5IG5hbWUuXG4gICAgICogQHBhcmFtIGFyZ3MgLSBBcnJheSBvZiBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgdW5kZXJseWluZyBzdGF0ZWd5LlxuICAgICAqIEB0aHJvd3MgV2lsbCB0aHJvdyB3aGVuIHBhc3NlZCBhbiB1bnJlY29nbml6ZWQgc3RyYXRlZ3kuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gY3VycmVudCBzdGF0ZSB3aGVuIHRoZSBpbXBvcnQgaXMgY29tcGxldGUuXG4gICAgICovXG4gICAgaW1wb3J0QWNjb3VudFdpdGhTdHJhdGVneShzdHJhdGVneSwgYXJncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IHByaXZhdGVLZXk7XG4gICAgICAgICAgICBzd2l0Y2ggKHN0cmF0ZWd5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncHJpdmF0ZUtleSc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtpbXBvcnRlZEtleV0gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWltcG9ydGVkS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbXBvcnQgYW4gZW1wdHkga2V5LicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWZpeGVkID0gZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KGltcG9ydGVkS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmICghZXRoZXJldW1qc191dGlsXzEuaXNWYWxpZFByaXZhdGUoZXRoZXJldW1qc191dGlsXzEudG9CdWZmZXIocHJlZml4ZWQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW1wb3J0IGludmFsaWQgcHJpdmF0ZSBrZXkuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJpdmF0ZUtleSA9IGV0aGVyZXVtanNfdXRpbF8xLnN0cmlwSGV4UHJlZml4KHByZWZpeGVkKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB3YWxsZXQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtpbnB1dCwgcGFzc3dvcmRdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhbGxldCA9IGV0aGVyZXVtanNfd2FsbGV0XzEudGhpcmRwYXJ0eS5mcm9tRXRoZXJXYWxsZXQoaW5wdXQsIHBhc3N3b3JkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FsbGV0ID0gd2FsbGV0IHx8ICh5aWVsZCBldGhlcmV1bWpzX3dhbGxldF8xLmRlZmF1bHQuZnJvbVYzKGlucHV0LCBwYXNzd29yZCwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByaXZhdGVLZXkgPSBldGhlcmV1bWpzX3V0aWxfMS5idWZmZXJUb0hleCh3YWxsZXQuZ2V0UHJpdmF0ZUtleSgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGltcG9ydCBzdHJhdGVneTogJyR7c3RyYXRlZ3l9J2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV3S2V5cmluZyA9IHlpZWxkIHByaXZhdGVzXG4gICAgICAgICAgICAgICAgLmdldCh0aGlzKVxuICAgICAgICAgICAgICAgIC5rZXlyaW5nLmFkZE5ld0tleXJpbmcoS2V5cmluZ1R5cGVzLnNpbXBsZSwgW3ByaXZhdGVLZXldKTtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0geWllbGQgbmV3S2V5cmluZy5nZXRBY2NvdW50cygpO1xuICAgICAgICAgICAgY29uc3QgYWxsQWNjb3VudHMgPSB5aWVsZCBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5nZXRBY2NvdW50cygpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJZGVudGl0aWVzKGFsbEFjY291bnRzKTtcbiAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0ZWRBZGRyZXNzKGFjY291bnRzWzBdKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bGxVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gYWNjb3VudCBmcm9tIGtleXJpbmcgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIGN1cnJlbnQgc3RhdGUgd2hlbiB0aGlzIGFjY291bnQgcmVtb3ZhbCBjb21wbGV0ZXMuXG4gICAgICovXG4gICAgcmVtb3ZlQWNjb3VudChhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUlkZW50aXR5KGFkZHJlc3MpO1xuICAgICAgICAgICAgeWllbGQgcHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcucmVtb3ZlQWNjb3VudChhZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bGxVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlYWxsb2NhdGVzIGFsbCBzZWNyZXRzIGFuZCBsb2NrcyB0aGUgd2FsbGV0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gY3VycmVudCBzdGF0ZS5cbiAgICAgKi9cbiAgICBzZXRMb2NrZWQoKSB7XG4gICAgICAgIHJldHVybiBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5zZXRMb2NrZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgbWVzc2FnZSBieSBjYWxsaW5nIGRvd24gaW50byBhIHNwZWNpZmljIGtleXJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZVBhcmFtcyAtIFBlcnNvbmFsTWVzc2FnZVBhcmFtcyBvYmplY3QgdG8gc2lnbi5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhIHNpZ25lZCBtZXNzYWdlIHN0cmluZy5cbiAgICAgKi9cbiAgICBzaWduTWVzc2FnZShtZXNzYWdlUGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5zaWduTWVzc2FnZShtZXNzYWdlUGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgcGVyc29uYWwgbWVzc2FnZSBieSBjYWxsaW5nIGRvd24gaW50byBhIHNwZWNpZmljIGtleXJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZVBhcmFtcyAtIFBlcnNvbmFsTWVzc2FnZVBhcmFtcyBvYmplY3QgdG8gc2lnbi5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhIHNpZ25lZCBtZXNzYWdlIHN0cmluZy5cbiAgICAgKi9cbiAgICBzaWduUGVyc29uYWxNZXNzYWdlKG1lc3NhZ2VQYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHByaXZhdGVzLmdldCh0aGlzKS5rZXlyaW5nLnNpZ25QZXJzb25hbE1lc3NhZ2UobWVzc2FnZVBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25zIHR5cGVkIG1lc3NhZ2UgYnkgY2FsbGluZyBkb3duIGludG8gYSBzcGVjaWZpYyBrZXlyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VQYXJhbXMgLSBUeXBlZE1lc3NhZ2VQYXJhbXMgb2JqZWN0IHRvIHNpZ24uXG4gICAgICogQHBhcmFtIHZlcnNpb24gLSBDb21wYXRpYmlsaXR5IHZlcnNpb24gRUlQNzEyLlxuICAgICAqIEB0aHJvd3MgV2lsbCB0aHJvdyB3aGVuIHBhc3NlZCBhbiB1bnJlY29nbml6ZWQgdmVyc2lvbi5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhIHNpZ25lZCBtZXNzYWdlIHN0cmluZyBvciBhbiBlcnJvciBpZiBhbnkuXG4gICAgICovXG4gICAgc2lnblR5cGVkTWVzc2FnZShtZXNzYWdlUGFyYW1zLCB2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBldGhfc2lnX3V0aWxfMS5ub3JtYWxpemUobWVzc2FnZVBhcmFtcy5mcm9tKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhc3N3b3JkIH0gPSBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZztcbiAgICAgICAgICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0geWllbGQgdGhpcy5leHBvcnRBY2NvdW50KHBhc3N3b3JkLCBhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcml2YXRlS2V5QnVmZmVyID0gZXRoZXJldW1qc191dGlsXzEudG9CdWZmZXIoZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KHByaXZhdGVLZXkpKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTaWduVHlwZWREYXRhVmVyc2lvbi5WMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpZ25UeXBlZERhdGFMZWdhY3kgd2lsbCB0aHJvdyBpZiB0aGUgZGF0YSBpcyBpbnZhbGlkLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV0aF9zaWdfdXRpbF8xLnNpZ25UeXBlZERhdGFMZWdhY3kocHJpdmF0ZUtleUJ1ZmZlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2VQYXJhbXMuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFNpZ25UeXBlZERhdGFWZXJzaW9uLlYzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV0aF9zaWdfdXRpbF8xLnNpZ25UeXBlZERhdGEocHJpdmF0ZUtleUJ1ZmZlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IEpTT04ucGFyc2UobWVzc2FnZVBhcmFtcy5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFNpZ25UeXBlZERhdGFWZXJzaW9uLlY0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV0aF9zaWdfdXRpbF8xLnNpZ25UeXBlZERhdGFfdjQocHJpdmF0ZUtleUJ1ZmZlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IEpTT04ucGFyc2UobWVzc2FnZVBhcmFtcy5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHNpZ25UeXBlZE1lc3NhZ2UgdmVyc2lvbjogJyR7dmVyc2lvbn0nYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXlyaW5nIENvbnRyb2xsZXIgc2lnblR5cGVkTWVzc2FnZTogJHtlcnJvcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25zIGEgdHJhbnNhY3Rpb24gYnkgY2FsbGluZyBkb3duIGludG8gYSBzcGVjaWZpYyBrZXlyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVHJhbnNhY3Rpb24gb2JqZWN0IHRvIHNpZ24uIE11c3QgYmUgYSBgZXRoZXJldW1qcy10eGAgdHJhbnNhY3Rpb24gaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIGZyb20gLSBBZGRyZXNzIHRvIHNpZ24gZnJvbSwgc2hvdWxkIGJlIGluIGtleWNoYWluLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGEgc2lnbmVkIHRyYW5zYWN0aW9uIHN0cmluZy5cbiAgICAgKi9cbiAgICBzaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGZyb20pIHtcbiAgICAgICAgcmV0dXJuIHByaXZhdGVzLmdldCh0aGlzKS5rZXlyaW5nLnNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGRlY3J5cHQgdGhlIGN1cnJlbnQgdmF1bHQgYW5kIGxvYWQgaXRzIGtleXJpbmdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhc3N3b3JkIC0gUGFzc3dvcmQgdG8gdW5sb2NrIHRoZSBrZXljaGFpbi5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAgKi9cbiAgICBzdWJtaXRQYXNzd29yZChwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgcHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcuc3VibWl0UGFzc3dvcmQocGFzc3dvcmQpO1xuICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSB5aWVsZCBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5nZXRBY2NvdW50cygpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5zeW5jSWRlbnRpdGllcyhhY2NvdW50cyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mdWxsVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIG5ldyBsaXN0ZW5lciB0byBiZSBub3RpZmllZCBvZiBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIC0gQ2FsbGJhY2sgdHJpZ2dlcmVkIHdoZW4gc3RhdGUgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICAgICAgcHJpdmF0ZXMuZ2V0KHRoaXMpLmtleXJpbmcuc3RvcmUuc3Vic2NyaWJlKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBleGlzdGluZyBsaXN0ZW5lciBmcm9tIHJlY2VpdmluZyBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIC0gQ2FsbGJhY2sgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgYSBsaXN0ZW5lciBpcyBmb3VuZCBhbmQgdW5zdWJzY3JpYmVkLlxuICAgICAqL1xuICAgIHVuc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5zdG9yZS51bnN1YnNjcmliZShsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgbmV3IGxpc3RlbmVyIHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIHdhbGxldCBpcyBsb2NrZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBDYWxsYmFjayB0cmlnZ2VyZWQgd2hlbiB3YWxsZXQgaXMgbG9ja2VkLlxuICAgICAqIEByZXR1cm5zIEV2ZW50RW1pdHRlciBpZiBsaXN0ZW5lciBhZGRlZC5cbiAgICAgKi9cbiAgICBvbkxvY2sobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHByaXZhdGVzLmdldCh0aGlzKS5rZXlyaW5nLm9uKCdsb2NrJywgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIG5ldyBsaXN0ZW5lciB0byBiZSBub3RpZmllZCB3aGVuIHRoZSB3YWxsZXQgaXMgdW5sb2NrZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBDYWxsYmFjayB0cmlnZ2VyZWQgd2hlbiB3YWxsZXQgaXMgdW5sb2NrZWQuXG4gICAgICogQHJldHVybnMgRXZlbnRFbWl0dGVyIGlmIGxpc3RlbmVyIGFkZGVkLlxuICAgICAqL1xuICAgIG9uVW5sb2NrKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5vbigndW5sb2NrJywgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyB0aGUgdGhhdCB0aGUgc2VlZCBwaHJhc2UgcmVzdG9yZXMgdGhlIGN1cnJlbnQga2V5Y2hhaW4ncyBhY2NvdW50cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZlcmlmaWNhdGlvbiBzdWNjZWVkcy5cbiAgICAgKi9cbiAgICB2ZXJpZnlTZWVkUGhyYXNlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcHJpbWFyeUtleXJpbmcgPSBwcml2YXRlc1xuICAgICAgICAgICAgICAgIC5nZXQodGhpcylcbiAgICAgICAgICAgICAgICAua2V5cmluZy5nZXRLZXlyaW5nc0J5VHlwZShLZXlyaW5nVHlwZXMuaGQpWzBdO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoIXByaW1hcnlLZXlyaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBIRCBrZXlyaW5nIGZvdW5kLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2VlZFdvcmRzID0gKHlpZWxkIHByaW1hcnlLZXlyaW5nLnNlcmlhbGl6ZSgpKS5tbmVtb25pYztcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0geWllbGQgcHJpbWFyeUtleXJpbmcuZ2V0QWNjb3VudHMoKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKGFjY291bnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHZlcmlmeSBhbiBlbXB0eSBrZXlyaW5nLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgVGVzdEtleXJpbmdDbGFzcyA9IHByaXZhdGVzXG4gICAgICAgICAgICAgICAgLmdldCh0aGlzKVxuICAgICAgICAgICAgICAgIC5rZXlyaW5nLmdldEtleXJpbmdDbGFzc0ZvclR5cGUoS2V5cmluZ1R5cGVzLmhkKTtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RLZXlyaW5nID0gbmV3IFRlc3RLZXlyaW5nQ2xhc3Moe1xuICAgICAgICAgICAgICAgIG1uZW1vbmljOiBzZWVkV29yZHMsXG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZBY2NvdW50czogYWNjb3VudHMubGVuZ3RoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0ZXN0QWNjb3VudHMgPSB5aWVsZCB0ZXN0S2V5cmluZy5nZXRBY2NvdW50cygpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGVzdEFjY291bnRzLmxlbmd0aCAhPT0gYWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWVkIHBocmFzZSBpbXBvcnRlZCBpbmNvcnJlY3QgbnVtYmVyIG9mIGFjY291bnRzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVzdEFjY291bnRzLmZvckVhY2goKGFjY291bnQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoYWNjb3VudC50b0xvd2VyQ2FzZSgpICE9PSBhY2NvdW50c1tpXS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2VlZCBwaHJhc2UgaW1wb3J0ZWQgZGlmZmVyZW50IGFjY291bnRzLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHNlZWRXb3JkcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBrZXlyaW5ncyBpbiBzdGF0ZSBhbmQgY2FsbHMgS2V5cmluZ0NvbnRyb2xsZXIgZnVsbFVwZGF0ZSBtZXRob2QgcmV0dXJuaW5nIGN1cnJlbnQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBzdGF0ZS5cbiAgICAgKi9cbiAgICBmdWxsVXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qga2V5cmluZ3MgPSB5aWVsZCBQcm9taXNlLmFsbChwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5rZXlyaW5ncy5tYXAoKGtleXJpbmcsIGluZGV4KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5cmluZ0FjY291bnRzID0geWllbGQga2V5cmluZy5nZXRBY2NvdW50cygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gQXJyYXkuaXNBcnJheShrZXlyaW5nQWNjb3VudHMpXG4gICAgICAgICAgICAgICAgICAgID8ga2V5cmluZ0FjY291bnRzLm1hcCgoYWRkcmVzcykgPT4gdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpKVxuICAgICAgICAgICAgICAgICAgICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFtdO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRzLFxuICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZToga2V5cmluZy50eXBlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBrZXlyaW5nczogWy4uLmtleXJpbmdzXSB9KTtcbiAgICAgICAgICAgIHJldHVybiBwcml2YXRlcy5nZXQodGhpcykua2V5cmluZy5mdWxsVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuS2V5cmluZ0NvbnRyb2xsZXIgPSBLZXlyaW5nQ29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IEtleXJpbmdDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9S2V5cmluZ0NvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXNzZXRzQ29udHJhY3RDb250cm9sbGVyID0gdm9pZCAwO1xuY29uc3Qgd2ViM18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ3ZWIzXCIpKTtcbmNvbnN0IHNpbmdsZV9jYWxsX2JhbGFuY2VfY2hlY2tlcl9hYmlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwic2luZ2xlLWNhbGwtYmFsYW5jZS1jaGVja2VyLWFiaVwiKSk7XG5jb25zdCBCYXNlQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyXCIpO1xuY29uc3QgRVJDNzIxU3RhbmRhcmRfMSA9IHJlcXVpcmUoXCIuL1N0YW5kYXJkcy9Db2xsZWN0aWJsZVN0YW5kYXJkcy9FUkM3MjEvRVJDNzIxU3RhbmRhcmRcIik7XG5jb25zdCBFUkMxMTU1U3RhbmRhcmRfMSA9IHJlcXVpcmUoXCIuL1N0YW5kYXJkcy9Db2xsZWN0aWJsZVN0YW5kYXJkcy9FUkMxMTU1L0VSQzExNTVTdGFuZGFyZFwiKTtcbmNvbnN0IEVSQzIwU3RhbmRhcmRfMSA9IHJlcXVpcmUoXCIuL1N0YW5kYXJkcy9FUkMyMFN0YW5kYXJkXCIpO1xuY29uc3QgU0lOR0xFX0NBTExfQkFMQU5DRVNfQUREUkVTUyA9ICcweGIxZjhlNTVjN2Y2NGQyMDNjMTQwMGI5ZDg1NTVkMDUwZjk0YWRmMzknO1xuY29uc3QgTUlTU0lOR19QUk9WSURFUl9FUlJPUiA9ICdBc3NldHNDb250cmFjdENvbnRyb2xsZXIgZmFpbGVkIHRvIHNldCB0aGUgcHJvdmlkZXIgY29ycmVjdGx5LiBBIHByb3ZpZGVyIG11c3QgYmUgc2V0IGZvciB0aGlzIG1ldGhvZCB0byBiZSBhdmFpbGFibGUnO1xuLyoqXG4gKiBDb250cm9sbGVyIHRoYXQgaW50ZXJhY3RzIHdpdGggY29udHJhY3RzIG9uIG1haW5uZXQgdGhyb3VnaCB3ZWIzXG4gKi9cbmNsYXNzIEFzc2V0c0NvbnRyYWN0Q29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBBc3NldHNDb250cmFjdENvbnRyb2xsZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBzdGF0ZSkge1xuICAgICAgICBzdXBlcihjb25maWcsIHN0YXRlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhpcyBjb250cm9sbGVyIHVzZWQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXNzZXRzQ29udHJhY3RDb250cm9sbGVyJztcbiAgICAgICAgdGhpcy5kZWZhdWx0Q29uZmlnID0ge1xuICAgICAgICAgICAgcHJvdmlkZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBuZXcgcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBUT0RPOiBSZXBsYWNlIHRoaXMgd3RoIGEgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHByb3ZpZGVyIC0gUHJvdmlkZXIgdXNlZCB0byBjcmVhdGUgYSBuZXcgdW5kZXJseWluZyBXZWIzIGluc3RhbmNlXG4gICAgICovXG4gICAgc2V0IHByb3ZpZGVyKHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMud2ViMyA9IG5ldyB3ZWIzXzEuZGVmYXVsdChwcm92aWRlcik7XG4gICAgICAgIHRoaXMuZXJjNzIxU3RhbmRhcmQgPSBuZXcgRVJDNzIxU3RhbmRhcmRfMS5FUkM3MjFTdGFuZGFyZCh0aGlzLndlYjMpO1xuICAgICAgICB0aGlzLmVyYzExNTVTdGFuZGFyZCA9IG5ldyBFUkMxMTU1U3RhbmRhcmRfMS5FUkMxMTU1U3RhbmRhcmQodGhpcy53ZWIzKTtcbiAgICAgICAgdGhpcy5lcmMyMFN0YW5kYXJkID0gbmV3IEVSQzIwU3RhbmRhcmRfMS5FUkMyMFN0YW5kYXJkKHRoaXMud2ViMyk7XG4gICAgfVxuICAgIGdldCBwcm92aWRlcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBvbmx5IHVzZWQgZm9yIHNldHRpbmcnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGJhbGFuY2Ugb3IgY291bnQgZm9yIGN1cnJlbnQgYWNjb3VudCBvbiBzcGVjaWZpYyBhc3NldCBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gQXNzZXQgRVJDMjAgY29udHJhY3QgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gc2VsZWN0ZWRBZGRyZXNzIC0gQ3VycmVudCBhY2NvdW50IHB1YmxpYyBhZGRyZXNzLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIEJOIG9iamVjdCBjb250YWluaW5nIGJhbGFuY2UgZm9yIGN1cnJlbnQgYWNjb3VudCBvbiBzcGVjaWZpYyBhc3NldCBjb250cmFjdC5cbiAgICAgKi9cbiAgICBnZXRFUkMyMEJhbGFuY2VPZihhZGRyZXNzLCBzZWxlY3RlZEFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5lcmMyMFN0YW5kYXJkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKE1JU1NJTkdfUFJPVklERVJfRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJjMjBTdGFuZGFyZC5nZXRCYWxhbmNlT2YoYWRkcmVzcywgc2VsZWN0ZWRBZGRyZXNzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IGZvciB0aGUgZGVjaW1hbHMgZm9yIGEgZ2l2ZW4gRVJDMjAgYXNzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEVSQzIwIGFzc2V0IGNvbnRyYWN0IGFkZHJlc3MuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlICdkZWNpbWFscycuXG4gICAgICovXG4gICAgZ2V0RVJDMjBUb2tlbkRlY2ltYWxzKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVyYzIwU3RhbmRhcmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihNSVNTSU5HX1BST1ZJREVSX0VSUk9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmVyYzIwU3RhbmRhcmQuZ2V0VG9rZW5EZWNpbWFscyhhZGRyZXNzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVudW1lcmF0ZSBhc3NldHMgYXNzaWduZWQgdG8gYW4gb3duZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEVSQzcyMSBhc3NldCBjb250cmFjdCBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSBzZWxlY3RlZEFkZHJlc3MgLSBDdXJyZW50IGFjY291bnQgcHVibGljIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIGluZGV4IC0gQSBjb2xsZWN0aWJsZSBjb3VudGVyIGxlc3MgdGhhbiBgYmFsYW5jZU9mKHNlbGVjdGVkQWRkcmVzcylgLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRva2VuIGlkZW50aWZpZXIgZm9yIHRoZSAnaW5kZXgndGggYXNzZXQgYXNzaWduZWQgdG8gJ3NlbGVjdGVkQWRkcmVzcycuXG4gICAgICovXG4gICAgZ2V0RVJDNzIxQ29sbGVjdGlibGVUb2tlbklkKGFkZHJlc3MsIHNlbGVjdGVkQWRkcmVzcywgaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJjNzIxU3RhbmRhcmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKE1JU1NJTkdfUFJPVklERVJfRVJST1IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVyYzcyMVN0YW5kYXJkLmdldENvbGxlY3RpYmxlVG9rZW5JZChhZGRyZXNzLCBzZWxlY3RlZEFkZHJlc3MsIGluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW51bWVyYXRlIGFzc2V0cyBhc3NpZ25lZCB0byBhbiBvd25lci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b2tlbkFkZHJlc3MgLSBFUkM3MjEgYXNzZXQgY29udHJhY3QgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gdXNlckFkZHJlc3MgLSBDdXJyZW50IGFjY291bnQgcHVibGljIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIHRva2VuSWQgLSBFUkM3MjEgYXNzZXQgaWRlbnRpZmllci5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgdG9rZW4gc3RhbmRhcmQgYW5kIGEgc2V0IG9mIGRldGFpbHMgd2hpY2ggZGVwZW5kIG9uIHdoaWNoIHN0YW5kYXJkIHRoZSB0b2tlbiBzdXBwb3J0cy5cbiAgICAgKi9cbiAgICBnZXRUb2tlblN0YW5kYXJkQW5kRGV0YWlscyh0b2tlbkFkZHJlc3MsIHVzZXJBZGRyZXNzLCB0b2tlbklkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lcmM3MjFTdGFuZGFyZCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5lcmMxMTU1U3RhbmRhcmQgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuZXJjMjBTdGFuZGFyZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKE1JU1NJTkdfUFJPVklERVJfRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRVJDNzIxXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCAoeWllbGQgdGhpcy5lcmM3MjFTdGFuZGFyZC5nZXREZXRhaWxzKHRva2VuQWRkcmVzcywgdG9rZW5JZCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRVJDMTE1NVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgKHlpZWxkIHRoaXMuZXJjMTE1NVN0YW5kYXJkLmdldERldGFpbHModG9rZW5BZGRyZXNzLCB0b2tlbklkKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9iKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFUkMyMFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgKHlpZWxkIHRoaXMuZXJjMjBTdGFuZGFyZC5nZXREZXRhaWxzKHRva2VuQWRkcmVzcywgdXNlckFkZHJlc3MpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2MpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGRldGVybWluZSBjb250cmFjdCBzdGFuZGFyZCcpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcnkgZm9yIHRva2VuVVJJIGZvciBhIGdpdmVuIEVSQzcyMSBhc3NldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gRVJDNzIxIGFzc2V0IGNvbnRyYWN0IGFkZHJlc3MuXG4gICAgICogQHBhcmFtIHRva2VuSWQgLSBFUkM3MjEgYXNzZXQgaWRlbnRpZmllci5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgJ3Rva2VuVVJJJy5cbiAgICAgKi9cbiAgICBnZXRFUkM3MjFUb2tlblVSSShhZGRyZXNzLCB0b2tlbklkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lcmM3MjFTdGFuZGFyZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKE1JU1NJTkdfUFJPVklERVJfRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJjNzIxU3RhbmRhcmQuZ2V0VG9rZW5VUkkoYWRkcmVzcywgdG9rZW5JZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyeSBmb3IgbmFtZSBmb3IgYSBnaXZlbiBhc3NldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gRVJDNzIxIG9yIEVSQzIwIGFzc2V0IGNvbnRyYWN0IGFkZHJlc3MuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlICduYW1lJy5cbiAgICAgKi9cbiAgICBnZXRFUkM3MjFBc3NldE5hbWUoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXJjNzIxU3RhbmRhcmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihNSVNTSU5HX1BST1ZJREVSX0VSUk9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVyYzcyMVN0YW5kYXJkLmdldEFzc2V0TmFtZShhZGRyZXNzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IGZvciBzeW1ib2wgZm9yIGEgZ2l2ZW4gYXNzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEVSQzcyMSBvciBFUkMyMCBhc3NldCBjb250cmFjdCBhZGRyZXNzLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSAnc3ltYm9sJy5cbiAgICAgKi9cbiAgICBnZXRFUkM3MjFBc3NldFN5bWJvbChhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lcmM3MjFTdGFuZGFyZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKE1JU1NJTkdfUFJPVklERVJfRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJjNzIxU3RhbmRhcmQuZ2V0QXNzZXRTeW1ib2woYWRkcmVzcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyeSBmb3Igb3duZXIgZm9yIGEgZ2l2ZW4gRVJDNzIxIGFzc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBFUkM3MjEgYXNzZXQgY29udHJhY3QgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gdG9rZW5JZCAtIEVSQzcyMSBhc3NldCBpZGVudGlmaWVyLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBvd25lciBhZGRyZXNzLlxuICAgICAqL1xuICAgIGdldEVSQzcyMU93bmVyT2YoYWRkcmVzcywgdG9rZW5JZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXJjNzIxU3RhbmRhcmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihNSVNTSU5HX1BST1ZJREVSX0VSUk9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVyYzcyMVN0YW5kYXJkLmdldE93bmVyT2YoYWRkcmVzcywgdG9rZW5JZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyeSBmb3IgdG9rZW5VUkkgZm9yIGEgZ2l2ZW4gYXNzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEVSQzExNTUgYXNzZXQgY29udHJhY3QgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gdG9rZW5JZCAtIEVSQzExNTUgYXNzZXQgaWRlbnRpZmllci5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgJ3Rva2VuVVJJJy5cbiAgICAgKi9cbiAgICBnZXRFUkMxMTU1VG9rZW5VUkkoYWRkcmVzcywgdG9rZW5JZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXJjMTE1NVN0YW5kYXJkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoTUlTU0lOR19QUk9WSURFUl9FUlJPUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcmMxMTU1U3RhbmRhcmQuZ2V0VG9rZW5VUkkoYWRkcmVzcywgdG9rZW5JZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyeSBmb3IgYmFsYW5jZSBvZiBhIGdpdmVuIEVSQyAxMTU1IHRva2VuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXJBZGRyZXNzIC0gV2FsbGV0IHB1YmxpYyBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSBjb2xsZWN0aWJsZUFkZHJlc3MgLSBFUkMxMTU1IGFzc2V0IGNvbnRyYWN0IGFkZHJlc3MuXG4gICAgICogQHBhcmFtIGNvbGxlY3RpYmxlSWQgLSBFUkMxMTU1IGFzc2V0IGlkZW50aWZpZXIuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlICdiYWxhbmNlT2YnLlxuICAgICAqL1xuICAgIGdldEVSQzExNTVCYWxhbmNlT2YodXNlckFkZHJlc3MsIGNvbGxlY3RpYmxlQWRkcmVzcywgY29sbGVjdGlibGVJZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXJjMTE1NVN0YW5kYXJkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoTUlTU0lOR19QUk9WSURFUl9FUlJPUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5lcmMxMTU1U3RhbmRhcmQuZ2V0QmFsYW5jZU9mKGNvbGxlY3RpYmxlQWRkcmVzcywgdXNlckFkZHJlc3MsIGNvbGxlY3RpYmxlSWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmZXIgc2luZ2xlIEVSQzExNTUgdG9rZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sbGVjdGlibGVBZGRyZXNzIC0gRVJDMTE1NSB0b2tlbiBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSBzZW5kZXJBZGRyZXNzIC0gRVJDMTE1NSB0b2tlbiBzZW5kZXIuXG4gICAgICogQHBhcmFtIHJlY2lwaWVudEFkZHJlc3MgLSBFUkMxMTU1IHRva2VuIHJlY2lwaWVudC5cbiAgICAgKiBAcGFyYW0gY29sbGVjdGlibGVJZCAtIEVSQzExNTUgdG9rZW4gaWQuXG4gICAgICogQHBhcmFtIHF0eSAtIFF1YW50aXR5IG9mIHRva2VucyB0byBiZSBzZW50LlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSAndHJhbnNmZXJTaW5nbGUnIEVSQzExNTUgdG9rZW4uXG4gICAgICovXG4gICAgdHJhbnNmZXJTaW5nbGVFUkMxMTU1KGNvbGxlY3RpYmxlQWRkcmVzcywgc2VuZGVyQWRkcmVzcywgcmVjaXBpZW50QWRkcmVzcywgY29sbGVjdGlibGVJZCwgcXR5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lcmMxMTU1U3RhbmRhcmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihNSVNTSU5HX1BST1ZJREVSX0VSUk9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmVyYzExNTVTdGFuZGFyZC50cmFuc2ZlclNpbmdsZShjb2xsZWN0aWJsZUFkZHJlc3MsIHNlbmRlckFkZHJlc3MsIHJlY2lwaWVudEFkZHJlc3MsIGNvbGxlY3RpYmxlSWQsIHF0eSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRva2VuIGJhbGFuY2UgZm9yIGEgbGlzdCBvZiB0b2tlbiBhZGRyZXNzZXMgaW4gYSBzaW5nbGUgY2FsbC4gT25seSBub24temVybyBiYWxhbmNlc1xuICAgICAqIGFyZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWxlY3RlZEFkZHJlc3MgLSBUaGUgYWRkcmVzcyB0byBjaGVjayB0b2tlbiBiYWxhbmNlcyBmb3IuXG4gICAgICogQHBhcmFtIHRva2Vuc1RvRGV0ZWN0IC0gVGhlIHRva2VuIGFkZHJlc3NlcyB0byBkZXRlY3QgYmFsYW5jZXMgZm9yLlxuICAgICAqIEByZXR1cm5zIFRoZSBsaXN0IG9mIG5vbi16ZXJvIHRva2VuIGJhbGFuY2VzLlxuICAgICAqL1xuICAgIGdldEJhbGFuY2VzSW5TaW5nbGVDYWxsKHNlbGVjdGVkQWRkcmVzcywgdG9rZW5zVG9EZXRlY3QpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gdGhpcy53ZWIzLmV0aFxuICAgICAgICAgICAgICAgIC5jb250cmFjdChzaW5nbGVfY2FsbF9iYWxhbmNlX2NoZWNrZXJfYWJpXzEuZGVmYXVsdClcbiAgICAgICAgICAgICAgICAuYXQoU0lOR0xFX0NBTExfQkFMQU5DRVNfQUREUkVTUyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRyYWN0LmJhbGFuY2VzKFtzZWxlY3RlZEFkZHJlc3NdLCB0b2tlbnNUb0RldGVjdCwgKGVycm9yLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBub25aZXJvQmFsYW5jZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnNUb0RldGVjdC5mb3JFYWNoKCh0b2tlbkFkZHJlc3MsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IHJlc3VsdFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJhbGFuY2UuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uWmVyb0JhbGFuY2VzW3Rva2VuQWRkcmVzc10gPSBiYWxhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobm9uWmVyb0JhbGFuY2VzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkFzc2V0c0NvbnRyYWN0Q29udHJvbGxlciA9IEFzc2V0c0NvbnRyYWN0Q29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IEFzc2V0c0NvbnRyYWN0Q29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzc2V0c0NvbnRyYWN0Q29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OZXR3b3JrQ29udHJvbGxlciA9IGV4cG9ydHMuTmV0d29ya3NDaGFpbklkID0gdm9pZCAwO1xuY29uc3QgZXRoX3F1ZXJ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImV0aC1xdWVyeVwiKSk7XG5jb25zdCBwcm92aWRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ3ZWIzLXByb3ZpZGVyLWVuZ2luZS9zdWJwcm92aWRlcnMvcHJvdmlkZXJcIikpO1xuY29uc3QgY3JlYXRlUHJvdmlkZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZXRoLWpzb24tcnBjLWluZnVyYS9zcmMvY3JlYXRlUHJvdmlkZXJcIikpO1xuY29uc3QgemVyb18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ3ZWIzLXByb3ZpZGVyLWVuZ2luZS96ZXJvXCIpKTtcbmNvbnN0IGFzeW5jX211dGV4XzEgPSByZXF1aXJlKFwiYXN5bmMtbXV0ZXhcIik7XG5jb25zdCBCYXNlQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xudmFyIE5ldHdvcmtzQ2hhaW5JZDtcbihmdW5jdGlvbiAoTmV0d29ya3NDaGFpbklkKSB7XG4gICAgTmV0d29ya3NDaGFpbklkW1wibWFpbm5ldFwiXSA9IFwiMVwiO1xuICAgIE5ldHdvcmtzQ2hhaW5JZFtcImtvdmFuXCJdID0gXCI0MlwiO1xuICAgIE5ldHdvcmtzQ2hhaW5JZFtcInJpbmtlYnlcIl0gPSBcIjRcIjtcbiAgICBOZXR3b3Jrc0NoYWluSWRbXCJnb2VybGlcIl0gPSBcIjVcIjtcbiAgICBOZXR3b3Jrc0NoYWluSWRbXCJyb3BzdGVuXCJdID0gXCIzXCI7XG4gICAgTmV0d29ya3NDaGFpbklkW1wibG9jYWxob3N0XCJdID0gXCJcIjtcbiAgICBOZXR3b3Jrc0NoYWluSWRbXCJycGNcIl0gPSBcIlwiO1xuICAgIE5ldHdvcmtzQ2hhaW5JZFtcIm9wdGltaXNtXCJdID0gXCIxMFwiO1xuICAgIE5ldHdvcmtzQ2hhaW5JZFtcIm9wdGltaXNtVGVzdFwiXSA9IFwiNjlcIjtcbn0pKE5ldHdvcmtzQ2hhaW5JZCA9IGV4cG9ydHMuTmV0d29ya3NDaGFpbklkIHx8IChleHBvcnRzLk5ldHdvcmtzQ2hhaW5JZCA9IHt9KSk7XG5jb25zdCBMT0NBTEhPU1RfUlBDX1VSTCA9ICdodHRwOi8vbG9jYWxob3N0Ojg1NDUnO1xuLyoqXG4gKiBDb250cm9sbGVyIHRoYXQgY3JlYXRlcyBhbmQgbWFuYWdlcyBhbiBFdGhlcmV1bSBuZXR3b3JrIHByb3ZpZGVyXG4gKi9cbmNsYXNzIE5ldHdvcmtDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIE5ldHdvcmtDb250cm9sbGVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIEluaXRpYWwgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICogQHBhcmFtIHN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgc3RhdGUpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzdGF0ZSk7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxQcm92aWRlckNvbmZpZyA9IHt9O1xuICAgICAgICB0aGlzLm11dGV4ID0gbmV3IGFzeW5jX211dGV4XzEuTXV0ZXgoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhpcyBjb250cm9sbGVyIHVzZWQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnTmV0d29ya0NvbnRyb2xsZXInO1xuICAgICAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IHtcbiAgICAgICAgICAgIG5ldHdvcms6ICdsb2FkaW5nJyxcbiAgICAgICAgICAgIGlzQ3VzdG9tTmV0d29yazogZmFsc2UsXG4gICAgICAgICAgICBwcm92aWRlcjogeyB0eXBlOiBjb25zdGFudHNfMS5NQUlOTkVULCBjaGFpbklkOiBOZXR3b3Jrc0NoYWluSWQubWFpbm5ldCB9LFxuICAgICAgICAgICAgcHJvcGVydGllczogeyBpc0VJUDE1NTlDb21wYXRpYmxlOiBmYWxzZSB9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgdGhpcy5nZXRFSVAxNTU5Q29tcGF0aWJpbGl0eSgpO1xuICAgIH1cbiAgICBpbml0aWFsaXplUHJvdmlkZXIodHlwZSwgcnBjVGFyZ2V0LCBjaGFpbklkLCB0aWNrZXIsIG5pY2tuYW1lKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKHsgaXNDdXN0b21OZXR3b3JrOiB0aGlzLmdldElzQ3VzdG9tTmV0d29yayhjaGFpbklkKSB9KTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdrb3Zhbic6XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLk1BSU5ORVQ6XG4gICAgICAgICAgICBjYXNlICdyaW5rZWJ5JzpcbiAgICAgICAgICAgIGNhc2UgJ2dvZXJsaSc6XG4gICAgICAgICAgICBjYXNlICdvcHRpbWlzbSc6XG4gICAgICAgICAgICBjYXNlICdvcHRpbWlzbVRlc3QnOlxuICAgICAgICAgICAgY2FzZSAncm9wc3Rlbic6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR1cEluZnVyYVByb3ZpZGVyKHR5cGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbG9jYWxob3N0JzpcbiAgICAgICAgICAgICAgICB0aGlzLnNldHVwU3RhbmRhcmRQcm92aWRlcihMT0NBTEhPU1RfUlBDX1VSTCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLlJQQzpcbiAgICAgICAgICAgICAgICBycGNUYXJnZXQgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR1cFN0YW5kYXJkUHJvdmlkZXIocnBjVGFyZ2V0LCBjaGFpbklkLCB0aWNrZXIsIG5pY2tuYW1lKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgbmV0d29yayB0eXBlOiAnJHt0eXBlfSdgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWZyZXNoTmV0d29yaygpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoeyBuZXR3b3JrOiAnbG9hZGluZycsIHByb3BlcnRpZXM6IHt9IH0pO1xuICAgICAgICBjb25zdCB7IHJwY1RhcmdldCwgdHlwZSwgY2hhaW5JZCwgdGlja2VyIH0gPSB0aGlzLnN0YXRlLnByb3ZpZGVyO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVQcm92aWRlcih0eXBlLCBycGNUYXJnZXQsIGNoYWluSWQsIHRpY2tlcik7XG4gICAgICAgIHRoaXMubG9va3VwTmV0d29yaygpO1xuICAgIH1cbiAgICByZWdpc3RlclByb3ZpZGVyKCkge1xuICAgICAgICB0aGlzLnByb3ZpZGVyLm9uKCdlcnJvcicsIHRoaXMudmVyaWZ5TmV0d29yay5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5ldGhRdWVyeSA9IG5ldyBldGhfcXVlcnlfMS5kZWZhdWx0KHRoaXMucHJvdmlkZXIpO1xuICAgIH1cbiAgICBzZXR1cEluZnVyYVByb3ZpZGVyKHR5cGUpIHtcbiAgICAgICAgY29uc3QgaW5mdXJhUHJvdmlkZXIgPSBjcmVhdGVQcm92aWRlcl8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgbmV0d29yazogdHlwZSxcbiAgICAgICAgICAgIHByb2plY3RJZDogdGhpcy5jb25maWcuaW5mdXJhUHJvamVjdElkLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaW5mdXJhU3VicHJvdmlkZXIgPSBuZXcgcHJvdmlkZXJfMS5kZWZhdWx0KGluZnVyYVByb3ZpZGVyKTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmludGVybmFsUHJvdmlkZXJDb25maWcpLCB7XG4gICAgICAgICAgICBkYXRhU3VicHJvdmlkZXI6IGluZnVyYVN1YnByb3ZpZGVyLFxuICAgICAgICAgICAgZW5naW5lUGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgYmxvY2tUcmFja2VyUHJvdmlkZXI6IGluZnVyYVByb3ZpZGVyLFxuICAgICAgICAgICAgICAgIHBvbGxpbmdJbnRlcnZhbDogMTIwMDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVQcm92aWRlcih6ZXJvXzEuZGVmYXVsdChjb25maWcpKTtcbiAgICB9XG4gICAgZ2V0SXNDdXN0b21OZXR3b3JrKGNoYWluSWQpIHtcbiAgICAgICAgcmV0dXJuIChjaGFpbklkICE9PSBOZXR3b3Jrc0NoYWluSWQubWFpbm5ldCAmJlxuICAgICAgICAgICAgY2hhaW5JZCAhPT0gTmV0d29ya3NDaGFpbklkLmtvdmFuICYmXG4gICAgICAgICAgICBjaGFpbklkICE9PSBOZXR3b3Jrc0NoYWluSWQucmlua2VieSAmJlxuICAgICAgICAgICAgY2hhaW5JZCAhPT0gTmV0d29ya3NDaGFpbklkLmdvZXJsaSAmJlxuICAgICAgICAgICAgY2hhaW5JZCAhPT0gTmV0d29ya3NDaGFpbklkLnJvcHN0ZW4gJiZcbiAgICAgICAgICAgIGNoYWluSWQgIT09IE5ldHdvcmtzQ2hhaW5JZC5sb2NhbGhvc3QpO1xuICAgIH1cbiAgICBzZXR1cFN0YW5kYXJkUHJvdmlkZXIocnBjVGFyZ2V0LCBjaGFpbklkLCB0aWNrZXIsIG5pY2tuYW1lKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5pbnRlcm5hbFByb3ZpZGVyQ29uZmlnKSwge1xuICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgIGVuZ2luZVBhcmFtczogeyBwb2xsaW5nSW50ZXJ2YWw6IDEyMDAwIH0sXG4gICAgICAgICAgICBuaWNrbmFtZSxcbiAgICAgICAgICAgIHJwY1VybDogcnBjVGFyZ2V0LFxuICAgICAgICAgICAgdGlja2VyLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVQcm92aWRlcih6ZXJvXzEuZGVmYXVsdChjb25maWcpKTtcbiAgICB9XG4gICAgdXBkYXRlUHJvdmlkZXIocHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5zYWZlbHlTdG9wUHJvdmlkZXIodGhpcy5wcm92aWRlcik7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy5yZWdpc3RlclByb3ZpZGVyKCk7XG4gICAgfVxuICAgIHNhZmVseVN0b3BQcm92aWRlcihwcm92aWRlcikge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHByb3ZpZGVyID09PSBudWxsIHx8IHByb3ZpZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm92aWRlci5zdG9wKCk7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgfVxuICAgIHZlcmlmeU5ldHdvcmsoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUubmV0d29yayA9PT0gJ2xvYWRpbmcnICYmIHRoaXMubG9va3VwTmV0d29yaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbmV3IGNvbmZpZ3VyYXRpb24gZm9yIHdlYjMtcHJvdmlkZXItZW5naW5lLlxuICAgICAqXG4gICAgICogVE9ETzogUmVwbGFjZSB0aGlzIHd0aCBhIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm92aWRlckNvbmZpZyAtIFRoZSB3ZWIzLXByb3ZpZGVyLWVuZ2luZSBjb25maWd1cmF0aW9uLlxuICAgICAqL1xuICAgIHNldCBwcm92aWRlckNvbmZpZyhwcm92aWRlckNvbmZpZykge1xuICAgICAgICB0aGlzLmludGVybmFsUHJvdmlkZXJDb25maWcgPSBwcm92aWRlckNvbmZpZztcbiAgICAgICAgY29uc3QgeyB0eXBlLCBycGNUYXJnZXQsIGNoYWluSWQsIHRpY2tlciwgbmlja25hbWUgfSA9IHRoaXMuc3RhdGUucHJvdmlkZXI7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVByb3ZpZGVyKHR5cGUsIHJwY1RhcmdldCwgY2hhaW5JZCwgdGlja2VyLCBuaWNrbmFtZSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJQcm92aWRlcigpO1xuICAgICAgICB0aGlzLmxvb2t1cE5ldHdvcmsoKTtcbiAgICB9XG4gICAgZ2V0IHByb3ZpZGVyQ29uZmlnKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IG9ubHkgdXNlZCBmb3Igc2V0dGluZycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWZyZXNoZXMgdGhlIGN1cnJlbnQgbmV0d29yayBjb2RlLlxuICAgICAqL1xuICAgIGxvb2t1cE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy5ldGhRdWVyeSB8fCAhdGhpcy5ldGhRdWVyeS5zZW5kQXN5bmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWxlYXNlTG9jayA9IHlpZWxkIHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICAgICAgdGhpcy5ldGhRdWVyeS5zZW5kQXN5bmMoeyBtZXRob2Q6ICduZXRfdmVyc2lvbicgfSwgKGVycm9yLCBuZXR3b3JrKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrOiBlcnJvciA/IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0Ki8gJ2xvYWRpbmcnIDogbmV0d29yayxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gdXBkYXRlIHByb3ZpZGVyIG5ldHdvcmsgdHlwZSBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlIC0gSHVtYW4gcmVhZGFibGUgbmV0d29yayBuYW1lLlxuICAgICAqL1xuICAgIHNldFByb3ZpZGVyVHlwZSh0eXBlKSB7XG4gICAgICAgIGNvbnN0IF9hID0gdGhpcy5zdGF0ZS5wcm92aWRlciwgeyBycGNUYXJnZXQsIGNoYWluSWQsIG5pY2tuYW1lIH0gPSBfYSwgcHJvdmlkZXJTdGF0ZSA9IF9fcmVzdChfYSwgW1wicnBjVGFyZ2V0XCIsIFwiY2hhaW5JZFwiLCBcIm5pY2tuYW1lXCJdKTtcbiAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgcHJvdmlkZXI6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvdmlkZXJTdGF0ZSksIHsgdHlwZSwgdGlja2VyOiAnRVRIJywgY2hhaW5JZDogTmV0d29ya3NDaGFpbklkW3R5cGVdIH0pLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWZyZXNoTmV0d29yaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gdXBkYXRlIHByb3ZpZGVyIFJQQyBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBycGNUYXJnZXQgLSBUaGUgUlBDIGVuZHBvaW50IFVSTC5cbiAgICAgKiBAcGFyYW0gY2hhaW5JZCAtIFRoZSBjaGFpbiBJRCBhcyBwZXIgRUlQLTE1NS5cbiAgICAgKiBAcGFyYW0gdGlja2VyIC0gVGhlIGN1cnJlbmN5IHRpY2tlci5cbiAgICAgKiBAcGFyYW0gbmlja25hbWUgLSBQZXJzb25hbGl6ZWQgbmV0d29yayBuYW1lLlxuICAgICAqL1xuICAgIHNldFJwY1RhcmdldChycGNUYXJnZXQsIGNoYWluSWQsIHRpY2tlciwgbmlja25hbWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgcHJvdmlkZXI6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zdGF0ZS5wcm92aWRlciksIHsgdHlwZTogY29uc3RhbnRzXzEuUlBDLCB0aWNrZXIsIHJwY1RhcmdldCwgY2hhaW5JZCwgbmlja25hbWUgfSksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZnJlc2hOZXR3b3JrKCk7XG4gICAgfVxuICAgIGdldEVJUDE1NTlDb21wYXRpYmlsaXR5KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgcHJvcGVydGllcyA9IHt9IH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBpZiAoIXByb3BlcnRpZXMuaXNFSVAxNTU5Q29tcGF0aWJsZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoKF9hID0gdGhpcy5ldGhRdWVyeSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlbmRBc3luYykgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmV0aFF1ZXJ5LnNlbmRBc3luYyh7IG1ldGhvZDogJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJywgcGFyYW1zOiBbJ2xhdGVzdCcsIGZhbHNlXSB9LCAoZXJyb3IsIGJsb2NrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzRUlQMTU1OUNvbXBhdGlibGUgPSB0eXBlb2YgYmxvY2suYmFzZUZlZVBlckdhcyAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5pc0VJUDE1NTlDb21wYXRpYmxlICE9PSBpc0VJUDE1NTlDb21wYXRpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0VJUDE1NTlDb21wYXRpYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShpc0VJUDE1NTlDb21wYXRpYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICB9XG59XG5leHBvcnRzLk5ldHdvcmtDb250cm9sbGVyID0gTmV0d29ya0NvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBOZXR3b3JrQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5ldHdvcmtDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRyYW5zYWN0aW9uQ29udHJvbGxlciA9IGV4cG9ydHMuU1BFRURfVVBfUkFURSA9IGV4cG9ydHMuQ0FOQ0VMX1JBVEUgPSBleHBvcnRzLldhbGxldERldmljZSA9IGV4cG9ydHMuVHJhbnNhY3Rpb25TdGF0dXMgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBldGhlcmV1bWpzX3V0aWxfMSA9IHJlcXVpcmUoXCJldGhlcmV1bWpzLXV0aWxcIik7XG5jb25zdCBldGhfcnBjX2Vycm9yc18xID0gcmVxdWlyZShcImV0aC1ycGMtZXJyb3JzXCIpO1xuY29uc3QgZXRoX21ldGhvZF9yZWdpc3RyeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJldGgtbWV0aG9kLXJlZ2lzdHJ5XCIpKTtcbmNvbnN0IGV0aF9xdWVyeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJldGgtcXVlcnlcIikpO1xuY29uc3QgY29tbW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBldGhlcmV1bWpzL2NvbW1vblwiKSk7XG5jb25zdCB0eF8xID0gcmVxdWlyZShcIkBldGhlcmV1bWpzL3R4XCIpO1xuY29uc3QgdXVpZF8xID0gcmVxdWlyZShcInV1aWRcIik7XG5jb25zdCBhc3luY19tdXRleF8xID0gcmVxdWlyZShcImFzeW5jLW11dGV4XCIpO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuY29uc3QgSEFSREZPUksgPSAnbG9uZG9uJztcbi8qKlxuICogVGhlIHN0YXR1cyBvZiB0aGUgdHJhbnNhY3Rpb24uIEVhY2ggc3RhdHVzIHJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSB0cmFuc2FjdGlvbiBpbnRlcm5hbGx5XG4gKiBpbiB0aGUgd2FsbGV0LiBTb21lIG9mIHRoZXNlIGNvcnJlc3BvbmQgd2l0aCB0aGUgc3RhdGUgb2YgdGhlIHRyYW5zYWN0aW9uIG9uIHRoZSBuZXR3b3JrLCBidXRcbiAqIHNvbWUgYXJlIHdhbGxldC1zcGVjaWZpYy5cbiAqL1xudmFyIFRyYW5zYWN0aW9uU3RhdHVzO1xuKGZ1bmN0aW9uIChUcmFuc2FjdGlvblN0YXR1cykge1xuICAgIFRyYW5zYWN0aW9uU3RhdHVzW1wiYXBwcm92ZWRcIl0gPSBcImFwcHJvdmVkXCI7XG4gICAgVHJhbnNhY3Rpb25TdGF0dXNbXCJjYW5jZWxsZWRcIl0gPSBcImNhbmNlbGxlZFwiO1xuICAgIFRyYW5zYWN0aW9uU3RhdHVzW1wiY29uZmlybWVkXCJdID0gXCJjb25maXJtZWRcIjtcbiAgICBUcmFuc2FjdGlvblN0YXR1c1tcImZhaWxlZFwiXSA9IFwiZmFpbGVkXCI7XG4gICAgVHJhbnNhY3Rpb25TdGF0dXNbXCJyZWplY3RlZFwiXSA9IFwicmVqZWN0ZWRcIjtcbiAgICBUcmFuc2FjdGlvblN0YXR1c1tcInNpZ25lZFwiXSA9IFwic2lnbmVkXCI7XG4gICAgVHJhbnNhY3Rpb25TdGF0dXNbXCJzdWJtaXR0ZWRcIl0gPSBcInN1Ym1pdHRlZFwiO1xuICAgIFRyYW5zYWN0aW9uU3RhdHVzW1widW5hcHByb3ZlZFwiXSA9IFwidW5hcHByb3ZlZFwiO1xufSkoVHJhbnNhY3Rpb25TdGF0dXMgPSBleHBvcnRzLlRyYW5zYWN0aW9uU3RhdHVzIHx8IChleHBvcnRzLlRyYW5zYWN0aW9uU3RhdHVzID0ge30pKTtcbi8qKlxuICogT3B0aW9ucyBmb3Igd2FsbGV0IGRldmljZS5cbiAqL1xudmFyIFdhbGxldERldmljZTtcbihmdW5jdGlvbiAoV2FsbGV0RGV2aWNlKSB7XG4gICAgV2FsbGV0RGV2aWNlW1wiTU1fTU9CSUxFXCJdID0gXCJtZXRhbWFza19tb2JpbGVcIjtcbiAgICBXYWxsZXREZXZpY2VbXCJNTV9FWFRFTlNJT05cIl0gPSBcIm1ldGFtYXNrX2V4dGVuc2lvblwiO1xuICAgIFdhbGxldERldmljZVtcIk9USEVSXCJdID0gXCJvdGhlcl9kZXZpY2VcIjtcbn0pKFdhbGxldERldmljZSA9IGV4cG9ydHMuV2FsbGV0RGV2aWNlIHx8IChleHBvcnRzLldhbGxldERldmljZSA9IHt9KSk7XG4vKipcbiAqIE11bHRpcGxpZXIgdXNlZCB0byBkZXRlcm1pbmUgYSB0cmFuc2FjdGlvbidzIGluY3JlYXNlZCBnYXMgZmVlIGR1cmluZyBjYW5jZWxsYXRpb25cbiAqL1xuZXhwb3J0cy5DQU5DRUxfUkFURSA9IDEuNTtcbi8qKlxuICogTXVsdGlwbGllciB1c2VkIHRvIGRldGVybWluZSBhIHRyYW5zYWN0aW9uJ3MgaW5jcmVhc2VkIGdhcyBmZWUgZHVyaW5nIHNwZWVkIHVwXG4gKi9cbmV4cG9ydHMuU1BFRURfVVBfUkFURSA9IDEuMTtcbi8qKlxuICogQ29udHJvbGxlciByZXNwb25zaWJsZSBmb3Igc3VibWl0dGluZyBhbmQgbWFuYWdpbmcgdHJhbnNhY3Rpb25zXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBjb250cm9sbGVyIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2V0TmV0d29ya1N0YXRlIC0gR2V0cyB0aGUgc3RhdGUgb2YgdGhlIG5ldHdvcmsgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vbk5ldHdvcmtTdGF0ZUNoYW5nZSAtIEFsbG93cyBzdWJzY3JpYmluZyB0byBuZXR3b3JrIGNvbnRyb2xsZXIgc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRQcm92aWRlciAtIFJldHVybnMgYSBwcm92aWRlciBmb3IgdGhlIGN1cnJlbnQgbmV0d29yay5cbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBnZXROZXR3b3JrU3RhdGUsIG9uTmV0d29ya1N0YXRlQ2hhbmdlLCBnZXRQcm92aWRlciwgfSwgY29uZmlnLCBzdGF0ZSkge1xuICAgICAgICBzdXBlcihjb25maWcsIHN0YXRlKTtcbiAgICAgICAgdGhpcy5tdXRleCA9IG5ldyBhc3luY19tdXRleF8xLk11dGV4KCk7XG4gICAgICAgIHRoaXMubm9ybWFsaXplVG9rZW5UeCA9ICh0eE1ldGEsIGN1cnJlbnROZXR3b3JrSUQsIGN1cnJlbnRDaGFpbklkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lID0gcGFyc2VJbnQodHhNZXRhLnRpbWVTdGFtcCwgMTApICogMTAwMDtcbiAgICAgICAgICAgIGNvbnN0IHsgdG8sIGZyb20sIGdhcywgZ2FzUHJpY2UsIGdhc1VzZWQsIGhhc2gsIGNvbnRyYWN0QWRkcmVzcywgdG9rZW5EZWNpbWFsLCB0b2tlblN5bWJvbCwgdmFsdWUsIH0gPSB0eE1ldGE7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiB1dWlkXzEudjEoeyBtc2VjczogdGltZSB9KSxcbiAgICAgICAgICAgICAgICBpc1RyYW5zZmVyOiB0cnVlLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtJRDogY3VycmVudE5ldHdvcmtJRCxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBjdXJyZW50Q2hhaW5JZCxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFRyYW5zYWN0aW9uU3RhdHVzLmNvbmZpcm1lZCxcbiAgICAgICAgICAgICAgICB0aW1lLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IDEsXG4gICAgICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgICAgIGdhcyxcbiAgICAgICAgICAgICAgICAgICAgZ2FzUHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIGdhc1VzZWQsXG4gICAgICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogaGFzaCxcbiAgICAgICAgICAgICAgICB0cmFuc2ZlckluZm9ybWF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHM6IE51bWJlcih0b2tlbkRlY2ltYWwpLFxuICAgICAgICAgICAgICAgICAgICBzeW1ib2w6IHRva2VuU3ltYm9sLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmVyaWZpZWRPbkJsb2NrY2hhaW46IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50RW1pdHRlciBpbnN0YW5jZSB1c2VkIHRvIGxpc3RlbiB0byBzcGVjaWZpYyB0cmFuc2FjdGlvbmFsIGV2ZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5odWIgPSBuZXcgZXZlbnRzXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ1RyYW5zYWN0aW9uQ29udHJvbGxlcic7XG4gICAgICAgIHRoaXMuZGVmYXVsdENvbmZpZyA9IHtcbiAgICAgICAgICAgIGludGVydmFsOiAxNTAwMCxcbiAgICAgICAgICAgIHR4SGlzdG9yeUxpbWl0OiA0MCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7XG4gICAgICAgICAgICBtZXRob2REYXRhOiB7fSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uczogW10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKCk7XG4gICAgICAgIHRoaXMuZ2V0TmV0d29ya1N0YXRlID0gZ2V0TmV0d29ya1N0YXRlO1xuICAgICAgICB0aGlzLmV0aFF1ZXJ5ID0gbmV3IGV0aF9xdWVyeV8xLmRlZmF1bHQocHJvdmlkZXIpO1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5ID0gbmV3IGV0aF9tZXRob2RfcmVnaXN0cnlfMS5kZWZhdWx0KHsgcHJvdmlkZXIgfSk7XG4gICAgICAgIG9uTmV0d29ya1N0YXRlQ2hhbmdlKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb3ZpZGVyID0gZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZXRoUXVlcnkgPSBuZXcgZXRoX3F1ZXJ5XzEuZGVmYXVsdChuZXdQcm92aWRlcik7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdHJ5ID0gbmV3IGV0aF9tZXRob2RfcmVnaXN0cnlfMS5kZWZhdWx0KHsgcHJvdmlkZXI6IG5ld1Byb3ZpZGVyIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgfVxuICAgIGZhaWxUcmFuc2FjdGlvbih0cmFuc2FjdGlvbk1ldGEsIGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG5ld1RyYW5zYWN0aW9uTWV0YSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdHJhbnNhY3Rpb25NZXRhKSwgeyBlcnJvciwgc3RhdHVzOiBUcmFuc2FjdGlvblN0YXR1cy5mYWlsZWQgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNhY3Rpb24obmV3VHJhbnNhY3Rpb25NZXRhKTtcbiAgICAgICAgdGhpcy5odWIuZW1pdChgJHt0cmFuc2FjdGlvbk1ldGEuaWR9OmZpbmlzaGVkYCwgbmV3VHJhbnNhY3Rpb25NZXRhKTtcbiAgICB9XG4gICAgcmVnaXN0cnlMb29rdXAoZm91ckJ5dGVQcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lzdHJ5TWV0aG9kID0geWllbGQgdGhpcy5yZWdpc3RyeS5sb29rdXAoZm91ckJ5dGVQcmVmaXgpO1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkUmVnaXN0cnlNZXRob2QgPSB0aGlzLnJlZ2lzdHJ5LnBhcnNlKHJlZ2lzdHJ5TWV0aG9kKTtcbiAgICAgICAgICAgIHJldHVybiB7IHJlZ2lzdHJ5TWV0aG9kLCBwYXJzZWRSZWdpc3RyeU1ldGhvZCB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyB0aGUgdHJhbnNhY3Rpb24gaW5mb3JtYXRpb24gZnJvbSBldGhlcnNjYW5cbiAgICAgKiB0byBiZSBjb21wYXRpYmxlIHdpdGggdGhlIFRyYW5zYWN0aW9uTWV0YSBpbnRlcmZhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHhNZXRhIC0gVGhlIHRyYW5zYWN0aW9uLlxuICAgICAqIEBwYXJhbSBjdXJyZW50TmV0d29ya0lEIC0gVGhlIGN1cnJlbnQgbmV0d29yayBJRC5cbiAgICAgKiBAcGFyYW0gY3VycmVudENoYWluSWQgLSBUaGUgY3VycmVudCBjaGFpbiBJRC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBub3JtYWxpemVUeCh0eE1ldGEsIGN1cnJlbnROZXR3b3JrSUQsIGN1cnJlbnRDaGFpbklkKSB7XG4gICAgICAgIGNvbnN0IHRpbWUgPSBwYXJzZUludCh0eE1ldGEudGltZVN0YW1wLCAxMCkgKiAxMDAwO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkVHJhbnNhY3Rpb25CYXNlID0ge1xuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHR4TWV0YS5ibG9ja051bWJlcixcbiAgICAgICAgICAgIGlkOiB1dWlkXzEudjEoeyBtc2VjczogdGltZSB9KSxcbiAgICAgICAgICAgIG5ldHdvcmtJRDogY3VycmVudE5ldHdvcmtJRCxcbiAgICAgICAgICAgIGNoYWluSWQ6IGN1cnJlbnRDaGFpbklkLFxuICAgICAgICAgICAgdGltZSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgZGF0YTogdHhNZXRhLmlucHV0LFxuICAgICAgICAgICAgICAgIGZyb206IHR4TWV0YS5mcm9tLFxuICAgICAgICAgICAgICAgIGdhczogdXRpbF8xLkJOVG9IZXgobmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKHR4TWV0YS5nYXMpKSxcbiAgICAgICAgICAgICAgICBnYXNQcmljZTogdXRpbF8xLkJOVG9IZXgobmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKHR4TWV0YS5nYXNQcmljZSkpLFxuICAgICAgICAgICAgICAgIGdhc1VzZWQ6IHV0aWxfMS5CTlRvSGV4KG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTih0eE1ldGEuZ2FzVXNlZCkpLFxuICAgICAgICAgICAgICAgIG5vbmNlOiB1dGlsXzEuQk5Ub0hleChuZXcgZXRoZXJldW1qc191dGlsXzEuQk4odHhNZXRhLm5vbmNlKSksXG4gICAgICAgICAgICAgICAgdG86IHR4TWV0YS50byxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdXRpbF8xLkJOVG9IZXgobmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKHR4TWV0YS52YWx1ZSkpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogdHhNZXRhLmhhc2gsXG4gICAgICAgICAgICB2ZXJpZmllZE9uQmxvY2tjaGFpbjogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmICh0eE1ldGEuaXNFcnJvciA9PT0gJzAnKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBub3JtYWxpemVkVHJhbnNhY3Rpb25CYXNlKSwgeyBzdGF0dXM6IFRyYW5zYWN0aW9uU3RhdHVzLmNvbmZpcm1lZCB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBub3JtYWxpemVkVHJhbnNhY3Rpb25CYXNlKSwgeyBlcnJvcjogbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBmYWlsZWQnKSwgc3RhdHVzOiBUcmFuc2FjdGlvblN0YXR1cy5mYWlsZWQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBhIG5ldyBwb2xsaW5nIGludGVydmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGludGVydmFsIC0gVGhlIHBvbGxpbmcgaW50ZXJ2YWwgdXNlZCB0byBmZXRjaCBuZXcgdHJhbnNhY3Rpb24gc3RhdHVzZXMuXG4gICAgICovXG4gICAgcG9sbChpbnRlcnZhbCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaW50ZXJ2YWwgJiYgdGhpcy5jb25maWd1cmUoeyBpbnRlcnZhbCB9LCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGUgJiYgY2xlYXJUaW1lb3V0KHRoaXMuaGFuZGxlKTtcbiAgICAgICAgICAgIHlpZWxkIHV0aWxfMS5zYWZlbHlFeGVjdXRlKCgpID0+IHRoaXMucXVlcnlUcmFuc2FjdGlvblN0YXR1c2VzKCkpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvbGwodGhpcy5jb25maWcuaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfSwgdGhpcy5jb25maWcuaW50ZXJ2YWwpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIG5ldyBtZXRob2QgZGF0YSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvdXJCeXRlUHJlZml4IC0gVGhlIG1ldGhvZCBwcmVmaXguXG4gICAgICogQHJldHVybnMgVGhlIG1ldGhvZCBkYXRhIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBzaWduYXR1cmUgcHJlZml4LlxuICAgICAqL1xuICAgIGhhbmRsZU1ldGhvZERhdGEoZm91ckJ5dGVQcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VMb2NrID0geWllbGQgdGhpcy5tdXRleC5hY3F1aXJlKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbWV0aG9kRGF0YSB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBrbm93bk1ldGhvZCA9IE9iamVjdC5rZXlzKG1ldGhvZERhdGEpLmZpbmQoKGtub3duRm91ckJ5dGVQcmVmaXgpID0+IGZvdXJCeXRlUHJlZml4ID09PSBrbm93bkZvdXJCeXRlUHJlZml4KTtcbiAgICAgICAgICAgICAgICBpZiAoa25vd25NZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZERhdGFbZm91ckJ5dGVQcmVmaXhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZWdpc3RyeSA9IHlpZWxkIHRoaXMucmVnaXN0cnlMb29rdXAoZm91ckJ5dGVQcmVmaXgpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kRGF0YTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtZXRob2REYXRhKSwgeyBbZm91ckJ5dGVQcmVmaXhdOiByZWdpc3RyeSB9KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVnaXN0cnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgbmV3IHVuYXBwcm92ZWQgdHJhbnNhY3Rpb24gdG8gc3RhdGUuIFBhcmFtZXRlcnMgd2lsbCBiZSB2YWxpZGF0ZWQsIGFcbiAgICAgKiB1bmlxdWUgdHJhbnNhY3Rpb24gaWQgd2lsbCBiZSBnZW5lcmF0ZWQsIGFuZCBnYXMgYW5kIGdhc1ByaWNlIHdpbGwgYmUgY2FsY3VsYXRlZFxuICAgICAqIGlmIG5vdCBwcm92aWRlZC4gSWYgQSBgPHR4LmlkPjp1bmFwcHJvdmVkYCBodWIgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIG9uY2UgYWRkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSBUaGUgdHJhbnNhY3Rpb24gb2JqZWN0IHRvIGFkZC5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIGRvbWFpbiBvcmlnaW4gdG8gYXBwZW5kIHRvIHRoZSBnZW5lcmF0ZWQgVHJhbnNhY3Rpb25NZXRhLlxuICAgICAqIEBwYXJhbSBkZXZpY2VDb25maXJtZWRPbiAtIEFuIGVudW0gdG8gaW5kaWNhdGUgd2hhdCBkZXZpY2UgdGhlIHRyYW5zYWN0aW9uIHdhcyBjb25maXJtZWQgdG8gYXBwZW5kIHRvIHRoZSBnZW5lcmF0ZWQgVHJhbnNhY3Rpb25NZXRhLlxuICAgICAqIEByZXR1cm5zIE9iamVjdCBjb250YWluaW5nIGEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHRyYW5zYWN0aW9uIGhhc2ggaWYgYXBwcm92ZWQuXG4gICAgICovXG4gICAgYWRkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIG9yaWdpbiwgZGV2aWNlQ29uZmlybWVkT24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvdmlkZXIsIG5ldHdvcmsgfSA9IHRoaXMuZ2V0TmV0d29ya1N0YXRlKCk7XG4gICAgICAgICAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gdXRpbF8xLm5vcm1hbGl6ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIHV0aWxfMS52YWxpZGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uTWV0YSA9IHtcbiAgICAgICAgICAgICAgICBpZDogdXVpZF8xLnYxKCksXG4gICAgICAgICAgICAgICAgbmV0d29ya0lEOiBuZXR3b3JrLFxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IHByb3ZpZGVyLmNoYWluSWQsXG4gICAgICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgICAgIHN0YXR1czogVHJhbnNhY3Rpb25TdGF0dXMudW5hcHByb3ZlZCxcbiAgICAgICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgIGRldmljZUNvbmZpcm1lZE9uLFxuICAgICAgICAgICAgICAgIHZlcmlmaWVkT25CbG9ja2NoYWluOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZ2FzIH0gPSB5aWVsZCB0aGlzLmVzdGltYXRlR2FzKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5nYXMgPSBnYXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZhaWxUcmFuc2FjdGlvbih0cmFuc2FjdGlvbk1ldGEsIGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaHViLm9uY2UoYCR7dHJhbnNhY3Rpb25NZXRhLmlkfTpmaW5pc2hlZGAsIChtZXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobWV0YS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVHJhbnNhY3Rpb25TdGF0dXMuc3VibWl0dGVkOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG1ldGEudHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVHJhbnNhY3Rpb25TdGF0dXMucmVqZWN0ZWQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0KCdVc2VyIHJlamVjdGVkIHRoZSB0cmFuc2FjdGlvbicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVHJhbnNhY3Rpb25TdGF0dXMuY2FuY2VsbGVkOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludGVybmFsKCdVc2VyIGNhbmNlbGxlZCB0aGUgdHJhbnNhY3Rpb24nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdHVzLmZhaWxlZDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbChtZXRhLmVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludGVybmFsKGBNZXRhTWFzayBUeCBTaWduYXR1cmU6IFVua25vd24gcHJvYmxlbTogJHtKU09OLnN0cmluZ2lmeShtZXRhKX1gKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25zLnB1c2godHJhbnNhY3Rpb25NZXRhKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgdHJhbnNhY3Rpb25zOiB0aGlzLnRyaW1UcmFuc2FjdGlvbnNGb3JTdGF0ZSh0cmFuc2FjdGlvbnMpIH0pO1xuICAgICAgICAgICAgdGhpcy5odWIuZW1pdChgdW5hcHByb3ZlZFRyYW5zYWN0aW9uYCwgdHJhbnNhY3Rpb25NZXRhKTtcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdCwgdHJhbnNhY3Rpb25NZXRhIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwcmVwYXJlVW5zaWduZWRFdGhUeCh0eFBhcmFtcykge1xuICAgICAgICByZXR1cm4gdHhfMS5UcmFuc2FjdGlvbkZhY3RvcnkuZnJvbVR4RGF0YSh0eFBhcmFtcywge1xuICAgICAgICAgICAgY29tbW9uOiB0aGlzLmdldENvbW1vbkNvbmZpZ3VyYXRpb24oKSxcbiAgICAgICAgICAgIGZyZWV6ZTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgQGV0aGVyZXVtanMvdHhgIHVzZXMgYEBldGhlcmV1bWpzL2NvbW1vbmAgYXMgYSBjb25maWd1cmF0aW9uIHRvb2wgZm9yXG4gICAgICogc3BlY2lmeWluZyB3aGljaCBjaGFpbiwgbmV0d29yaywgaGFyZGZvcmsgYW5kIEVJUHMgdG8gc3VwcG9ydCBmb3JcbiAgICAgKiBhIHRyYW5zYWN0aW9uLiBCeSByZWZlcmVuY2luZyB0aGlzIGNvbmZpZ3VyYXRpb24sIGFuZCBhbmFseXppbmcgdGhlIGZpZWxkc1xuICAgICAqIHNwZWNpZmllZCBpbiB0eFBhcmFtcywgQGV0aGVyZXVtanMvdHggaXMgYWJsZSB0byBkZXRlcm1pbmUgd2hpY2ggRUlQLTI3MThcbiAgICAgKiB0cmFuc2FjdGlvbiB0eXBlIHRvIHVzZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb21tb259IGNvbW1vbiBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAqL1xuICAgIGdldENvbW1vbkNvbmZpZ3VyYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHsgbmV0d29yazogbmV0d29ya0lkLCBwcm92aWRlcjogeyB0eXBlOiBjaGFpbiwgY2hhaW5JZCwgbmlja25hbWU6IG5hbWUgfSwgfSA9IHRoaXMuZ2V0TmV0d29ya1N0YXRlKCk7XG4gICAgICAgIGlmIChjaGFpbiAhPT0gY29uc3RhbnRzXzEuUlBDKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNvbW1vbl8xLmRlZmF1bHQoeyBjaGFpbiwgaGFyZGZvcms6IEhBUkRGT1JLIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1c3RvbUNoYWluUGFyYW1zID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGNoYWluSWQ6IHBhcnNlSW50KGNoYWluSWQsIHVuZGVmaW5lZCksXG4gICAgICAgICAgICBuZXR3b3JrSWQ6IHBhcnNlSW50KG5ldHdvcmtJZCwgdW5kZWZpbmVkKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmRlZmF1bHQuZm9yQ3VzdG9tQ2hhaW4oY29uc3RhbnRzXzEuTUFJTk5FVCwgY3VzdG9tQ2hhaW5QYXJhbXMsIEhBUkRGT1JLKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwcm92ZXMgYSB0cmFuc2FjdGlvbiBhbmQgdXBkYXRlcyBpdCdzIHN0YXR1cyBpbiBzdGF0ZS4gSWYgdGhpcyBpcyBub3QgYVxuICAgICAqIHJldHJ5IHRyYW5zYWN0aW9uLCBhIG5vbmNlIHdpbGwgYmUgZ2VuZXJhdGVkLiBUaGUgdHJhbnNhY3Rpb24gaXMgc2lnbmVkXG4gICAgICogdXNpbmcgdGhlIHNpZ24gY29uZmlndXJhdGlvbiBwcm9wZXJ0eSwgdGhlbiBwdWJsaXNoZWQgdG8gdGhlIGJsb2NrY2hhaW4uXG4gICAgICogQSBgPHR4LmlkPjpmaW5pc2hlZGAgaHViIGV2ZW50IGlzIGZpcmVkIGFmdGVyIHN1Y2Nlc3Mgb3IgZmFpbHVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbklEIC0gVGhlIElEIG9mIHRoZSB0cmFuc2FjdGlvbiB0byBhcHByb3ZlLlxuICAgICAqL1xuICAgIGFwcHJvdmVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbklEKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VMb2NrID0geWllbGQgdGhpcy5tdXRleC5hY3F1aXJlKCk7XG4gICAgICAgICAgICBjb25zdCB7IHByb3ZpZGVyIH0gPSB0aGlzLmdldE5ldHdvcmtTdGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgeyBjaGFpbklkOiBjdXJyZW50Q2hhaW5JZCB9ID0gcHJvdmlkZXI7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRyYW5zYWN0aW9ucy5maW5kSW5kZXgoKHsgaWQgfSkgPT4gdHJhbnNhY3Rpb25JRCA9PT0gaWQpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25NZXRhID0gdHJhbnNhY3Rpb25zW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9uY2UgfSA9IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBmcm9tIH0gPSB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25NZXRhLCBuZXcgRXJyb3IoJ05vIHNpZ24gbWV0aG9kIGRlZmluZWQuJykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFjdXJyZW50Q2hhaW5JZCkge1xuICAgICAgICAgICAgICAgICAgICByZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxUcmFuc2FjdGlvbih0cmFuc2FjdGlvbk1ldGEsIG5ldyBFcnJvcignTm8gY2hhaW5JZCBkZWZpbmVkLicpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjaGFpbklkID0gcGFyc2VJbnQoY3VycmVudENoYWluSWQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhcHByb3ZlZDogc3RhdHVzIH0gPSBUcmFuc2FjdGlvblN0YXR1cztcbiAgICAgICAgICAgICAgICBjb25zdCB0eE5vbmNlID0gbm9uY2UgfHxcbiAgICAgICAgICAgICAgICAgICAgKHlpZWxkIHV0aWxfMS5xdWVyeSh0aGlzLmV0aFF1ZXJ5LCAnZ2V0VHJhbnNhY3Rpb25Db3VudCcsIFtmcm9tLCAncGVuZGluZyddKSk7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25NZXRhLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24ubm9uY2UgPSB0eE5vbmNlO1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbi5jaGFpbklkID0gY2hhaW5JZDtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlVHhQYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbiksIHsgZ2FzTGltaXQ6IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbi5nYXMsIGNoYWluSWQsIG5vbmNlOiB0eE5vbmNlLCBzdGF0dXMgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNFSVAxNTU5ID0gdXRpbF8xLmlzRUlQMTU1OVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgY29uc3QgdHhQYXJhbXMgPSBpc0VJUDE1NTlcbiAgICAgICAgICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJhc2VUeFBhcmFtcyksIHsgbWF4RmVlUGVyR2FzOiB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhczogdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLm1heFByaW9yaXR5RmVlUGVyR2FzLCBlc3RpbWF0ZWRCYXNlRmVlOiB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24uZXN0aW1hdGVkQmFzZUZlZSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZ5IHR5cGUgMiBpZiBtYXhGZWVQZXJHYXMgYW5kIG1heFByaW9yaXR5RmVlUGVyR2FzIGFyZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IDIgfSkgOiBiYXNlVHhQYXJhbXM7XG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIGdhc1ByaWNlIGlmIG1heEZlZVBlckdhcyBhbmQgbWF4UHJpb3JpdHlGZWVQZXJHYXMgYXJlIHNldFxuICAgICAgICAgICAgICAgIGlmIChpc0VJUDE1NTkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHR4UGFyYW1zLmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB1bnNpZ25lZEV0aFR4ID0gdGhpcy5wcmVwYXJlVW5zaWduZWRFdGhUeCh0eFBhcmFtcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbmVkVHggPSB5aWVsZCB0aGlzLnNpZ24odW5zaWduZWRFdGhUeCwgZnJvbSk7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25NZXRhLnN0YXR1cyA9IFRyYW5zYWN0aW9uU3RhdHVzLnNpZ25lZDtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uTWV0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3VHJhbnNhY3Rpb24gPSBldGhlcmV1bWpzX3V0aWxfMS5idWZmZXJUb0hleChzaWduZWRUeC5zZXJpYWxpemUoKSk7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25NZXRhLnJhd1RyYW5zYWN0aW9uID0gcmF3VHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbk1ldGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSGFzaCA9IHlpZWxkIHV0aWxfMS5xdWVyeSh0aGlzLmV0aFF1ZXJ5LCAnc2VuZFJhd1RyYW5zYWN0aW9uJywgW1xuICAgICAgICAgICAgICAgICAgICByYXdUcmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb25IYXNoID0gdHJhbnNhY3Rpb25IYXNoO1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uTWV0YS5zdGF0dXMgPSBUcmFuc2FjdGlvblN0YXR1cy5zdWJtaXR0ZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbk1ldGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuaHViLmVtaXQoYCR7dHJhbnNhY3Rpb25NZXRhLmlkfTpmaW5pc2hlZGAsIHRyYW5zYWN0aW9uTWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZhaWxUcmFuc2FjdGlvbih0cmFuc2FjdGlvbk1ldGEsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIGEgdHJhbnNhY3Rpb24gYmFzZWQgb24gaXRzIElEIGJ5IHNldHRpbmcgaXRzIHN0YXR1cyB0byBcInJlamVjdGVkXCJcbiAgICAgKiBhbmQgZW1pdHRpbmcgYSBgPHR4LmlkPjpmaW5pc2hlZGAgaHViIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uSUQgLSBUaGUgSUQgb2YgdGhlIHRyYW5zYWN0aW9uIHRvIGNhbmNlbC5cbiAgICAgKi9cbiAgICBjYW5jZWxUcmFuc2FjdGlvbih0cmFuc2FjdGlvbklEKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uTWV0YSA9IHRoaXMuc3RhdGUudHJhbnNhY3Rpb25zLmZpbmQoKHsgaWQgfSkgPT4gaWQgPT09IHRyYW5zYWN0aW9uSUQpO1xuICAgICAgICBpZiAoIXRyYW5zYWN0aW9uTWV0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zYWN0aW9uTWV0YS5zdGF0dXMgPSBUcmFuc2FjdGlvblN0YXR1cy5yZWplY3RlZDtcbiAgICAgICAgdGhpcy5odWIuZW1pdChgJHt0cmFuc2FjdGlvbk1ldGEuaWR9OmZpbmlzaGVkYCwgdHJhbnNhY3Rpb25NZXRhKTtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25zID0gdGhpcy5zdGF0ZS50cmFuc2FjdGlvbnMuZmlsdGVyKCh7IGlkIH0pID0+IGlkICE9PSB0cmFuc2FjdGlvbklEKTtcbiAgICAgICAgdGhpcy51cGRhdGUoeyB0cmFuc2FjdGlvbnM6IHRoaXMudHJpbVRyYW5zYWN0aW9uc0ZvclN0YXRlKHRyYW5zYWN0aW9ucykgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGNhbmNlbCBhIHRyYW5zYWN0aW9uIGJhc2VkIG9uIGl0cyBJRCBieSBzZXR0aW5nIGl0cyBzdGF0dXMgdG8gXCJyZWplY3RlZFwiXG4gICAgICogYW5kIGVtaXR0aW5nIGEgYDx0eC5pZD46ZmluaXNoZWRgIGh1YiBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbklEIC0gVGhlIElEIG9mIHRoZSB0cmFuc2FjdGlvbiB0byBjYW5jZWwuXG4gICAgICogQHBhcmFtIGdhc1ZhbHVlcyAtIFRoZSBnYXMgdmFsdWVzIHRvIHVzZSBmb3IgdGhlIGNhbmNlbGxhdGlvbiB0cmFuc2F0aW9uLlxuICAgICAqL1xuICAgIHN0b3BUcmFuc2FjdGlvbih0cmFuc2FjdGlvbklELCBnYXNWYWx1ZXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChnYXNWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICB1dGlsXzEudmFsaWRhdGVHYXNWYWx1ZXMoZ2FzVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uTWV0YSA9IHRoaXMuc3RhdGUudHJhbnNhY3Rpb25zLmZpbmQoKHsgaWQgfSkgPT4gaWQgPT09IHRyYW5zYWN0aW9uSUQpO1xuICAgICAgICAgICAgaWYgKCF0cmFuc2FjdGlvbk1ldGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2lnbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbiBtZXRob2QgZGVmaW5lZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGdhc1ByaWNlIChsZWdhY3kgbm9uIEVJUDE1NTkpXG4gICAgICAgICAgICBjb25zdCBtaW5HYXNQcmljZSA9IHV0aWxfMS5nZXRJbmNyZWFzZWRQcmljZUZyb21FeGlzdGluZyh0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24uZ2FzUHJpY2UsIGV4cG9ydHMuQ0FOQ0VMX1JBVEUpO1xuICAgICAgICAgICAgY29uc3QgZ2FzUHJpY2VGcm9tVmFsdWVzID0gdXRpbF8xLmlzR2FzUHJpY2VWYWx1ZShnYXNWYWx1ZXMpICYmIGdhc1ZhbHVlcy5nYXNQcmljZTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0dhc1ByaWNlID0gKGdhc1ByaWNlRnJvbVZhbHVlcyAmJlxuICAgICAgICAgICAgICAgIHV0aWxfMS52YWxpZGF0ZU1pbmltdW1JbmNyZWFzZShnYXNQcmljZUZyb21WYWx1ZXMsIG1pbkdhc1ByaWNlKSkgfHxcbiAgICAgICAgICAgICAgICBtaW5HYXNQcmljZTtcbiAgICAgICAgICAgIC8vIG1heEZlZVBlckdhcyAoRUlQMTU1OSlcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nTWF4RmVlUGVyR2FzID0gKF9hID0gdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgY29uc3QgbWluTWF4RmVlUGVyR2FzID0gdXRpbF8xLmdldEluY3JlYXNlZFByaWNlRnJvbUV4aXN0aW5nKGV4aXN0aW5nTWF4RmVlUGVyR2FzLCBleHBvcnRzLkNBTkNFTF9SQVRFKTtcbiAgICAgICAgICAgIGNvbnN0IG1heEZlZVBlckdhc1ZhbHVlcyA9IHV0aWxfMS5pc0ZlZU1hcmtldEVJUDE1NTlWYWx1ZXMoZ2FzVmFsdWVzKSAmJiBnYXNWYWx1ZXMubWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgY29uc3QgbmV3TWF4RmVlUGVyR2FzID0gKG1heEZlZVBlckdhc1ZhbHVlcyAmJlxuICAgICAgICAgICAgICAgIHV0aWxfMS52YWxpZGF0ZU1pbmltdW1JbmNyZWFzZShtYXhGZWVQZXJHYXNWYWx1ZXMsIG1pbk1heEZlZVBlckdhcykpIHx8XG4gICAgICAgICAgICAgICAgKGV4aXN0aW5nTWF4RmVlUGVyR2FzICYmIG1pbk1heEZlZVBlckdhcyk7XG4gICAgICAgICAgICAvLyBtYXhQcmlvcml0eUZlZVBlckdhcyAoRUlQMTU1OSlcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nTWF4UHJpb3JpdHlGZWVQZXJHYXMgPSAoX2IgPSB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgIGNvbnN0IG1pbk1heFByaW9yaXR5RmVlUGVyR2FzID0gdXRpbF8xLmdldEluY3JlYXNlZFByaWNlRnJvbUV4aXN0aW5nKGV4aXN0aW5nTWF4UHJpb3JpdHlGZWVQZXJHYXMsIGV4cG9ydHMuQ0FOQ0VMX1JBVEUpO1xuICAgICAgICAgICAgY29uc3QgbWF4UHJpb3JpdHlGZWVQZXJHYXNWYWx1ZXMgPSB1dGlsXzEuaXNGZWVNYXJrZXRFSVAxNTU5VmFsdWVzKGdhc1ZhbHVlcykgJiYgZ2FzVmFsdWVzLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgY29uc3QgbmV3TWF4UHJpb3JpdHlGZWVQZXJHYXMgPSAobWF4UHJpb3JpdHlGZWVQZXJHYXNWYWx1ZXMgJiZcbiAgICAgICAgICAgICAgICB1dGlsXzEudmFsaWRhdGVNaW5pbXVtSW5jcmVhc2UobWF4UHJpb3JpdHlGZWVQZXJHYXNWYWx1ZXMsIG1pbk1heFByaW9yaXR5RmVlUGVyR2FzKSkgfHxcbiAgICAgICAgICAgICAgICAoZXhpc3RpbmdNYXhQcmlvcml0eUZlZVBlckdhcyAmJiBtaW5NYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgICAgICAgICBjb25zdCB0eFBhcmFtcyA9IG5ld01heEZlZVBlckdhcyAmJiBuZXdNYXhQcmlvcml0eUZlZVBlckdhc1xuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBmcm9tOiB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24uZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgZ2FzTGltaXQ6IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbi5nYXMsXG4gICAgICAgICAgICAgICAgICAgIG1heEZlZVBlckdhczogbmV3TWF4RmVlUGVyR2FzLFxuICAgICAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogbmV3TWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IDIsXG4gICAgICAgICAgICAgICAgICAgIG5vbmNlOiB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24ubm9uY2UsXG4gICAgICAgICAgICAgICAgICAgIHRvOiB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24uZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICcweDAnLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLmZyb20sXG4gICAgICAgICAgICAgICAgICAgIGdhc0xpbWl0OiB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24uZ2FzLFxuICAgICAgICAgICAgICAgICAgICBnYXNQcmljZTogbmV3R2FzUHJpY2UsXG4gICAgICAgICAgICAgICAgICAgIG5vbmNlOiB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24ubm9uY2UsXG4gICAgICAgICAgICAgICAgICAgIHRvOiB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24uZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICcweDAnLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB1bnNpZ25lZEV0aFR4ID0gdGhpcy5wcmVwYXJlVW5zaWduZWRFdGhUeCh0eFBhcmFtcyk7XG4gICAgICAgICAgICBjb25zdCBzaWduZWRUeCA9IHlpZWxkIHRoaXMuc2lnbih1bnNpZ25lZEV0aFR4LCB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24uZnJvbSk7XG4gICAgICAgICAgICBjb25zdCByYXdUcmFuc2FjdGlvbiA9IGV0aGVyZXVtanNfdXRpbF8xLmJ1ZmZlclRvSGV4KHNpZ25lZFR4LnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgICAgIHlpZWxkIHV0aWxfMS5xdWVyeSh0aGlzLmV0aFF1ZXJ5LCAnc2VuZFJhd1RyYW5zYWN0aW9uJywgW3Jhd1RyYW5zYWN0aW9uXSk7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbk1ldGEuc3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXMuY2FuY2VsbGVkO1xuICAgICAgICAgICAgdGhpcy5odWIuZW1pdChgJHt0cmFuc2FjdGlvbk1ldGEuaWR9OmZpbmlzaGVkYCwgdHJhbnNhY3Rpb25NZXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHMgdG8gc3BlZWQgdXAgYSB0cmFuc2FjdGlvbiBpbmNyZWFzaW5nIHRyYW5zYWN0aW9uIGdhc1ByaWNlIGJ5IHRlbiBwZXJjZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uSUQgLSBUaGUgSUQgb2YgdGhlIHRyYW5zYWN0aW9uIHRvIHNwZWVkIHVwLlxuICAgICAqIEBwYXJhbSBnYXNWYWx1ZXMgLSBUaGUgZ2FzIHZhbHVlcyB0byB1c2UgZm9yIHRoZSBzcGVlZCB1cCB0cmFuc2F0aW9uLlxuICAgICAqL1xuICAgIHNwZWVkVXBUcmFuc2FjdGlvbih0cmFuc2FjdGlvbklELCBnYXNWYWx1ZXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChnYXNWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICB1dGlsXzEudmFsaWRhdGVHYXNWYWx1ZXMoZ2FzVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uTWV0YSA9IHRoaXMuc3RhdGUudHJhbnNhY3Rpb25zLmZpbmQoKHsgaWQgfSkgPT4gaWQgPT09IHRyYW5zYWN0aW9uSUQpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGlmICghdHJhbnNhY3Rpb25NZXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy5zaWduKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzaWduIG1ldGhvZCBkZWZpbmVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICAvLyBnYXNQcmljZSAobGVnYWN5IG5vbiBFSVAxNTU5KVxuICAgICAgICAgICAgY29uc3QgbWluR2FzUHJpY2UgPSB1dGlsXzEuZ2V0SW5jcmVhc2VkUHJpY2VGcm9tRXhpc3RpbmcodHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLmdhc1ByaWNlLCBleHBvcnRzLlNQRUVEX1VQX1JBVEUpO1xuICAgICAgICAgICAgY29uc3QgZ2FzUHJpY2VGcm9tVmFsdWVzID0gdXRpbF8xLmlzR2FzUHJpY2VWYWx1ZShnYXNWYWx1ZXMpICYmIGdhc1ZhbHVlcy5nYXNQcmljZTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0dhc1ByaWNlID0gKGdhc1ByaWNlRnJvbVZhbHVlcyAmJlxuICAgICAgICAgICAgICAgIHV0aWxfMS52YWxpZGF0ZU1pbmltdW1JbmNyZWFzZShnYXNQcmljZUZyb21WYWx1ZXMsIG1pbkdhc1ByaWNlKSkgfHxcbiAgICAgICAgICAgICAgICBtaW5HYXNQcmljZTtcbiAgICAgICAgICAgIC8vIG1heEZlZVBlckdhcyAoRUlQMTU1OSlcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nTWF4RmVlUGVyR2FzID0gKF9hID0gdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgY29uc3QgbWluTWF4RmVlUGVyR2FzID0gdXRpbF8xLmdldEluY3JlYXNlZFByaWNlRnJvbUV4aXN0aW5nKGV4aXN0aW5nTWF4RmVlUGVyR2FzLCBleHBvcnRzLlNQRUVEX1VQX1JBVEUpO1xuICAgICAgICAgICAgY29uc3QgbWF4RmVlUGVyR2FzVmFsdWVzID0gdXRpbF8xLmlzRmVlTWFya2V0RUlQMTU1OVZhbHVlcyhnYXNWYWx1ZXMpICYmIGdhc1ZhbHVlcy5tYXhGZWVQZXJHYXM7XG4gICAgICAgICAgICBjb25zdCBuZXdNYXhGZWVQZXJHYXMgPSAobWF4RmVlUGVyR2FzVmFsdWVzICYmXG4gICAgICAgICAgICAgICAgdXRpbF8xLnZhbGlkYXRlTWluaW11bUluY3JlYXNlKG1heEZlZVBlckdhc1ZhbHVlcywgbWluTWF4RmVlUGVyR2FzKSkgfHxcbiAgICAgICAgICAgICAgICAoZXhpc3RpbmdNYXhGZWVQZXJHYXMgJiYgbWluTWF4RmVlUGVyR2FzKTtcbiAgICAgICAgICAgIC8vIG1heFByaW9yaXR5RmVlUGVyR2FzIChFSVAxNTU5KVxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdNYXhQcmlvcml0eUZlZVBlckdhcyA9IChfYiA9IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgY29uc3QgbWluTWF4UHJpb3JpdHlGZWVQZXJHYXMgPSB1dGlsXzEuZ2V0SW5jcmVhc2VkUHJpY2VGcm9tRXhpc3RpbmcoZXhpc3RpbmdNYXhQcmlvcml0eUZlZVBlckdhcywgZXhwb3J0cy5TUEVFRF9VUF9SQVRFKTtcbiAgICAgICAgICAgIGNvbnN0IG1heFByaW9yaXR5RmVlUGVyR2FzVmFsdWVzID0gdXRpbF8xLmlzRmVlTWFya2V0RUlQMTU1OVZhbHVlcyhnYXNWYWx1ZXMpICYmIGdhc1ZhbHVlcy5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgIGNvbnN0IG5ld01heFByaW9yaXR5RmVlUGVyR2FzID0gKG1heFByaW9yaXR5RmVlUGVyR2FzVmFsdWVzICYmXG4gICAgICAgICAgICAgICAgdXRpbF8xLnZhbGlkYXRlTWluaW11bUluY3JlYXNlKG1heFByaW9yaXR5RmVlUGVyR2FzVmFsdWVzLCBtaW5NYXhQcmlvcml0eUZlZVBlckdhcykpIHx8XG4gICAgICAgICAgICAgICAgKGV4aXN0aW5nTWF4UHJpb3JpdHlGZWVQZXJHYXMgJiYgbWluTWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgICAgICAgY29uc3QgdHhQYXJhbXMgPSBuZXdNYXhGZWVQZXJHYXMgJiYgbmV3TWF4UHJpb3JpdHlGZWVQZXJHYXNcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uKSwgeyBnYXNMaW1pdDogdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLmdhcywgbWF4RmVlUGVyR2FzOiBuZXdNYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzOiBuZXdNYXhQcmlvcml0eUZlZVBlckdhcywgdHlwZTogMiB9KSA6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uKSwgeyBnYXNMaW1pdDogdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLmdhcywgZ2FzUHJpY2U6IG5ld0dhc1ByaWNlIH0pO1xuICAgICAgICAgICAgY29uc3QgdW5zaWduZWRFdGhUeCA9IHRoaXMucHJlcGFyZVVuc2lnbmVkRXRoVHgodHhQYXJhbXMpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmVkVHggPSB5aWVsZCB0aGlzLnNpZ24odW5zaWduZWRFdGhUeCwgdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLmZyb20pO1xuICAgICAgICAgICAgY29uc3QgcmF3VHJhbnNhY3Rpb24gPSBldGhlcmV1bWpzX3V0aWxfMS5idWZmZXJUb0hleChzaWduZWRUeC5zZXJpYWxpemUoKSk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbkhhc2ggPSB5aWVsZCB1dGlsXzEucXVlcnkodGhpcy5ldGhRdWVyeSwgJ3NlbmRSYXdUcmFuc2FjdGlvbicsIFtcbiAgICAgICAgICAgICAgICByYXdUcmFuc2FjdGlvbixcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgY29uc3QgYmFzZVRyYW5zYWN0aW9uTWV0YSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdHJhbnNhY3Rpb25NZXRhKSwgeyBpZDogdXVpZF8xLnYxKCksIHRpbWU6IERhdGUubm93KCksIHRyYW5zYWN0aW9uSGFzaCB9KTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1RyYW5zYWN0aW9uTWV0YSA9IG5ld01heEZlZVBlckdhcyAmJiBuZXdNYXhQcmlvcml0eUZlZVBlckdhc1xuICAgICAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBiYXNlVHJhbnNhY3Rpb25NZXRhKSwgeyB0cmFuc2FjdGlvbjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24pLCB7IG1heEZlZVBlckdhczogbmV3TWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhczogbmV3TWF4UHJpb3JpdHlGZWVQZXJHYXMgfSkgfSkgOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJhc2VUcmFuc2FjdGlvbk1ldGEpLCB7IHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbiksIHsgZ2FzUHJpY2U6IG5ld0dhc1ByaWNlIH0pIH0pO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25zLnB1c2gobmV3VHJhbnNhY3Rpb25NZXRhKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgdHJhbnNhY3Rpb25zOiB0aGlzLnRyaW1UcmFuc2FjdGlvbnNGb3JTdGF0ZSh0cmFuc2FjdGlvbnMpIH0pO1xuICAgICAgICAgICAgdGhpcy5odWIuZW1pdChgJHt0cmFuc2FjdGlvbk1ldGEuaWR9OnNwZWVkdXBgLCBuZXdUcmFuc2FjdGlvbk1ldGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXN0aW1hdGVzIHJlcXVpcmVkIGdhcyBmb3IgYSBnaXZlbiB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbiAtIFRoZSB0cmFuc2FjdGlvbiB0byBlc3RpbWF0ZSBnYXMgZm9yLlxuICAgICAqIEByZXR1cm5zIFRoZSBnYXMgYW5kIGdhcyBwcmljZS5cbiAgICAgKi9cbiAgICBlc3RpbWF0ZUdhcyh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZXN0aW1hdGVkVHJhbnNhY3Rpb24gPSBPYmplY3QuYXNzaWduKHt9LCB0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICBjb25zdCB7IGdhcywgZ2FzUHJpY2U6IHByb3ZpZGVkR2FzUHJpY2UsIHRvLCB2YWx1ZSwgZGF0YSwgfSA9IGVzdGltYXRlZFRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgZ2FzUHJpY2UgPSB0eXBlb2YgcHJvdmlkZWRHYXNQcmljZSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/IHlpZWxkIHV0aWxfMS5xdWVyeSh0aGlzLmV0aFF1ZXJ5LCAnZ2FzUHJpY2UnKVxuICAgICAgICAgICAgICAgIDogcHJvdmlkZWRHYXNQcmljZTtcbiAgICAgICAgICAgIGNvbnN0IHsgaXNDdXN0b21OZXR3b3JrIH0gPSB0aGlzLmdldE5ldHdvcmtTdGF0ZSgpO1xuICAgICAgICAgICAgLy8gMS4gSWYgZ2FzIGlzIGFscmVhZHkgZGVmaW5lZCBvbiB0aGUgdHJhbnNhY3Rpb24sIHVzZSBpdFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBnYXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZ2FzLCBnYXNQcmljZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBnYXNMaW1pdCB9ID0geWllbGQgdXRpbF8xLnF1ZXJ5KHRoaXMuZXRoUXVlcnksICdnZXRCbG9ja0J5TnVtYmVyJywgW1xuICAgICAgICAgICAgICAgICdsYXRlc3QnLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAvLyAyLiBJZiB0byBpcyBub3QgZGVmaW5lZCBvciB0aGlzIGlzIG5vdCBhIGNvbnRyYWN0IGFkZHJlc3MsIGFuZCB0aGVyZSBpcyBubyBkYXRhIHVzZSAweDUyMDggLyAyMTAwMC5cbiAgICAgICAgICAgIC8vIElmIHRoZSBuZXd0d29yayBpcyBhIGN1c3RvbSBuZXR3b3JrIHRoZW4gYnlwYXNzIHRoaXMgY2hlY2sgYW5kIGZldGNoICdlc3RpbWF0ZUdhcycuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHRvID8geWllbGQgdXRpbF8xLnF1ZXJ5KHRoaXMuZXRoUXVlcnksICdnZXRDb2RlJywgW3RvXSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKCFpc0N1c3RvbU5ldHdvcmsgJiZcbiAgICAgICAgICAgICAgICAoIXRvIHx8ICh0byAmJiAhZGF0YSAmJiAoIWNvZGUgfHwgY29kZSA9PT0gJzB4JykpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGdhczogJzB4NTIwOCcsIGdhc1ByaWNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBkYXRhLCBzaG91bGQgYmUgaGV4IHN0cmluZyBmb3JtYXRcbiAgICAgICAgICAgIGVzdGltYXRlZFRyYW5zYWN0aW9uLmRhdGEgPSAhZGF0YVxuICAgICAgICAgICAgICAgID8gZGF0YVxuICAgICAgICAgICAgICAgIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KGRhdGEpO1xuICAgICAgICAgICAgLy8gMy4gSWYgdGhpcyBpcyBhIGNvbnRyYWN0IGFkZHJlc3MsIHNhZmVseSBlc3RpbWF0ZSBnYXMgdXNpbmcgUlBDXG4gICAgICAgICAgICBlc3RpbWF0ZWRUcmFuc2FjdGlvbi52YWx1ZSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICcweDAnIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdmFsdWU7XG4gICAgICAgICAgICBjb25zdCBnYXNMaW1pdEJOID0gdXRpbF8xLmhleFRvQk4oZ2FzTGltaXQpO1xuICAgICAgICAgICAgZXN0aW1hdGVkVHJhbnNhY3Rpb24uZ2FzID0gdXRpbF8xLkJOVG9IZXgodXRpbF8xLmZyYWN0aW9uQk4oZ2FzTGltaXRCTiwgMTksIDIwKSk7XG4gICAgICAgICAgICBjb25zdCBnYXNIZXggPSB5aWVsZCB1dGlsXzEucXVlcnkodGhpcy5ldGhRdWVyeSwgJ2VzdGltYXRlR2FzJywgW1xuICAgICAgICAgICAgICAgIGVzdGltYXRlZFRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAvLyA0LiBQYWQgZXN0aW1hdGVkIGdhcyB3aXRob3V0IGV4Y2VlZGluZyB0aGUgbW9zdCByZWNlbnQgYmxvY2sgZ2FzTGltaXQuIElmIHRoZSBuZXR3b3JrIGlzIGFcbiAgICAgICAgICAgIC8vIGEgY3VzdG9tIG5ldHdvcmsgdGhlbiByZXR1cm4gdGhlIGV0aF9lc3RpbWF0ZUdhcyB2YWx1ZS5cbiAgICAgICAgICAgIGNvbnN0IGdhc0JOID0gdXRpbF8xLmhleFRvQk4oZ2FzSGV4KTtcbiAgICAgICAgICAgIGNvbnN0IG1heEdhc0JOID0gZ2FzTGltaXRCTi5tdWxuKDAuOSk7XG4gICAgICAgICAgICBjb25zdCBwYWRkZWRHYXNCTiA9IGdhc0JOLm11bG4oMS41KTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAoZ2FzQk4uZ3QobWF4R2FzQk4pIHx8IGlzQ3VzdG9tTmV0d29yaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGdhczogZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KGdhc0hleCksIGdhc1ByaWNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKHBhZGRlZEdhc0JOLmx0KG1heEdhc0JOKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGdhczogZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KHV0aWxfMS5CTlRvSGV4KHBhZGRlZEdhc0JOKSksIGdhc1ByaWNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBnYXM6IGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeCh1dGlsXzEuQk5Ub0hleChtYXhHYXNCTikpLCBnYXNQcmljZSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhlIHN0YXR1cyBvZiBzdWJtaXR0ZWQgdHJhbnNhY3Rpb25zIG9uIHRoZSBuZXR3b3JrIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZXkgaGF2ZVxuICAgICAqIGJlZW4gaW5jbHVkZWQgaW4gYSBibG9jay4gQW55IHRoYXQgaGF2ZSBiZWVuIGluY2x1ZGVkIGluIGEgYmxvY2sgYXJlIG1hcmtlZCBhcyBjb25maXJtZWQuXG4gICAgICovXG4gICAgcXVlcnlUcmFuc2FjdGlvblN0YXR1c2VzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCB7IHByb3ZpZGVyLCBuZXR3b3JrOiBjdXJyZW50TmV0d29ya0lEIH0gPSB0aGlzLmdldE5ldHdvcmtTdGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgeyBjaGFpbklkOiBjdXJyZW50Q2hhaW5JZCB9ID0gcHJvdmlkZXI7XG4gICAgICAgICAgICBsZXQgZ290VXBkYXRlcyA9IGZhbHNlO1xuICAgICAgICAgICAgeWllbGQgdXRpbF8xLnNhZmVseUV4ZWN1dGUoKCkgPT4gUHJvbWlzZS5hbGwodHJhbnNhY3Rpb25zLm1hcCgobWV0YSwgaW5kZXgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2luZyBmYWxsYmFjayB0byBuZXR3b3JrSUQgb25seSB3aGVuIHRoZXJlIGlzIG5vIGNoYWluSWQgcHJlc2VudC5cbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgYmUgcmVtb3ZlZCB3aGVuIG5ldHdvcmtJRCBpcyBjb21wbGV0ZWx5IHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgY29uc3QgdHhCZWxvbmdzVG9DdXJyZW50Q2hhaW4gPSBtZXRhLmNoYWluSWQgPT09IGN1cnJlbnRDaGFpbklkIHx8XG4gICAgICAgICAgICAgICAgICAgICghbWV0YS5jaGFpbklkICYmIG1ldGEubmV0d29ya0lEID09PSBjdXJyZW50TmV0d29ya0lEKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1ldGEudmVyaWZpZWRPbkJsb2NrY2hhaW4gJiYgdHhCZWxvbmdzVG9DdXJyZW50Q2hhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW3JlY29uY2lsZWRUeCwgdXBkYXRlUmVxdWlyZWQsXSA9IHlpZWxkIHRoaXMuYmxvY2tjaGFpblRyYW5zYWN0aW9uU3RhdGVSZWNvbmNpbGVyKG1ldGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlUmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uc1tpbmRleF0gPSByZWNvbmNpbGVkVHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RVcGRhdGVzID0gdXBkYXRlUmVxdWlyZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSkpKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAoZ290VXBkYXRlcykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiB0aGlzLnRyaW1UcmFuc2FjdGlvbnNGb3JTdGF0ZSh0cmFuc2FjdGlvbnMpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhbiBleGlzdGluZyB0cmFuc2FjdGlvbiBpbiBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbk1ldGEgLSBUaGUgbmV3IHRyYW5zYWN0aW9uIHRvIHN0b3JlIGluIHN0YXRlLlxuICAgICAqL1xuICAgIHVwZGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uTWV0YSkge1xuICAgICAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uID0gdXRpbF8xLm5vcm1hbGl6ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbik7XG4gICAgICAgIHV0aWxfMS52YWxpZGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbik7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdHJhbnNhY3Rpb25zLmZpbmRJbmRleCgoeyBpZCB9KSA9PiB0cmFuc2FjdGlvbk1ldGEuaWQgPT09IGlkKTtcbiAgICAgICAgdHJhbnNhY3Rpb25zW2luZGV4XSA9IHRyYW5zYWN0aW9uTWV0YTtcbiAgICAgICAgdGhpcy51cGRhdGUoeyB0cmFuc2FjdGlvbnM6IHRoaXMudHJpbVRyYW5zYWN0aW9uc0ZvclN0YXRlKHRyYW5zYWN0aW9ucykgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRyYW5zYWN0aW9ucyBmcm9tIHN0YXRlLCBvcHRpb25hbGx5IGJhc2VkIG9uIHRoZSBjdXJyZW50IG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWdub3JlTmV0d29yayAtIERldGVybWluZXMgd2hldGhlciB0byB3aXBlIGFsbCB0cmFuc2FjdGlvbnMsIG9yIGp1c3QgdGhvc2Ugb24gdGhlXG4gICAgICogY3VycmVudCBuZXR3b3JrLiBJZiBgdHJ1ZWAsIGFsbCB0cmFuc2FjdGlvbnMgYXJlIHdpcGVkLlxuICAgICAqL1xuICAgIHdpcGVUcmFuc2FjdGlvbnMoaWdub3JlTmV0d29yaykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAoaWdub3JlTmV0d29yaykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoeyB0cmFuc2FjdGlvbnM6IFtdIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcHJvdmlkZXIsIG5ldHdvcms6IGN1cnJlbnROZXR3b3JrSUQgfSA9IHRoaXMuZ2V0TmV0d29ya1N0YXRlKCk7XG4gICAgICAgIGNvbnN0IHsgY2hhaW5JZDogY3VycmVudENoYWluSWQgfSA9IHByb3ZpZGVyO1xuICAgICAgICBjb25zdCBuZXdUcmFuc2FjdGlvbnMgPSB0aGlzLnN0YXRlLnRyYW5zYWN0aW9ucy5maWx0ZXIoKHsgbmV0d29ya0lELCBjaGFpbklkIH0pID0+IHtcbiAgICAgICAgICAgIC8vIFVzaW5nIGZhbGxiYWNrIHRvIG5ldHdvcmtJRCBvbmx5IHdoZW4gdGhlcmUgaXMgbm8gY2hhaW5JZCBwcmVzZW50LiBTaG91bGQgYmUgcmVtb3ZlZCB3aGVuIG5ldHdvcmtJRCBpcyBjb21wbGV0ZWx5IHJlbW92ZWQuXG4gICAgICAgICAgICBjb25zdCBpc0N1cnJlbnROZXR3b3JrID0gY2hhaW5JZCA9PT0gY3VycmVudENoYWluSWQgfHxcbiAgICAgICAgICAgICAgICAoIWNoYWluSWQgJiYgbmV0d29ya0lEID09PSBjdXJyZW50TmV0d29ya0lEKTtcbiAgICAgICAgICAgIHJldHVybiAhaXNDdXJyZW50TmV0d29yaztcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uczogdGhpcy50cmltVHJhbnNhY3Rpb25zRm9yU3RhdGUobmV3VHJhbnNhY3Rpb25zKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0cmFuc2FjdGlvbnMgZnJvbSBFdGhlcnNjYW4gZm9yIHRoZSBnaXZlbiBhZGRyZXNzLiBCeSBkZWZhdWx0IGFsbCB0cmFuc2FjdGlvbnMgYXJlXG4gICAgICogcmV0dXJuZWQsIGJ1dCB0aGUgYGZyb21CbG9ja2Agb3B0aW9uIGNhbiBiZSBnaXZlbiB0byBmaWx0ZXIganVzdCBmb3IgdHJhbnNhY3Rpb25zIGZyb20gYVxuICAgICAqIHNwZWNpZmljIGJsb2NrIG9ud2FyZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIHRyYW5zYWN0aW9ucyBmb3IuXG4gICAgICogQHBhcmFtIG9wdCAtIE9iamVjdCBjb250YWluaW5nIG9wdGlvbmFsIGRhdGEsIGZyb21CbG9jayBhbmQgRXRoZXJzY2FuIEFQSSBrZXkuXG4gICAgICogQHJldHVybnMgVGhlIGJsb2NrIG51bWJlciBvZiB0aGUgbGF0ZXN0IGluY29taW5nIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGZldGNoQWxsKGFkZHJlc3MsIG9wdCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBwcm92aWRlciwgbmV0d29yazogY3VycmVudE5ldHdvcmtJRCB9ID0gdGhpcy5nZXROZXR3b3JrU3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhaW5JZDogY3VycmVudENoYWluSWQsIHR5cGU6IG5ldHdvcmtUeXBlIH0gPSBwcm92aWRlcjtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY29uc3Qgc3VwcG9ydGVkTmV0d29ya0lkcyA9IFsnMScsICczJywgJzQnLCAnNDInXTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAoc3VwcG9ydGVkTmV0d29ya0lkcy5pbmRleE9mKGN1cnJlbnROZXR3b3JrSUQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbZXRoZXJzY2FuVHhSZXNwb25zZSwgZXRoZXJzY2FuVG9rZW5SZXNwb25zZSxdID0geWllbGQgdXRpbF8xLmhhbmRsZVRyYW5zYWN0aW9uRmV0Y2gobmV0d29ya1R5cGUsIGFkZHJlc3MsIHRoaXMuY29uZmlnLnR4SGlzdG9yeUxpbWl0LCBvcHQpO1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZFR4cyA9IGV0aGVyc2NhblR4UmVzcG9uc2UucmVzdWx0Lm1hcCgodHgpID0+IHRoaXMubm9ybWFsaXplVHgodHgsIGN1cnJlbnROZXR3b3JrSUQsIGN1cnJlbnRDaGFpbklkKSk7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkVG9rZW5UeHMgPSBldGhlcnNjYW5Ub2tlblJlc3BvbnNlLnJlc3VsdC5tYXAoKHR4KSA9PiB0aGlzLm5vcm1hbGl6ZVRva2VuVHgodHgsIGN1cnJlbnROZXR3b3JrSUQsIGN1cnJlbnRDaGFpbklkKSk7XG4gICAgICAgICAgICBjb25zdCBbdXBkYXRlUmVxdWlyZWQsIGFsbFR4c10gPSB0aGlzLmV0aGVyc2NhblRyYW5zYWN0aW9uU3RhdGVSZWNvbmNpbGVyKFsuLi5ub3JtYWxpemVkVHhzLCAuLi5ub3JtYWxpemVkVG9rZW5UeHNdLCB0cmFuc2FjdGlvbnMpO1xuICAgICAgICAgICAgYWxsVHhzLnNvcnQoKGEsIGIpID0+IChhLnRpbWUgPCBiLnRpbWUgPyAtMSA6IDEpKTtcbiAgICAgICAgICAgIGxldCBsYXRlc3RJbmNvbWluZ1R4QmxvY2tOdW1iZXI7XG4gICAgICAgICAgICBhbGxUeHMuZm9yRWFjaCgodHgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAvLyBVc2luZyBmYWxsYmFjayB0byBuZXR3b3JrSUQgb25seSB3aGVuIHRoZXJlIGlzIG5vIGNoYWluSWQgcHJlc2VudC4gU2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBuZXR3b3JrSUQgaXMgY29tcGxldGVseSByZW1vdmVkLlxuICAgICAgICAgICAgICAgICh0eC5jaGFpbklkID09PSBjdXJyZW50Q2hhaW5JZCB8fFxuICAgICAgICAgICAgICAgICAgICAoIXR4LmNoYWluSWQgJiYgdHgubmV0d29ya0lEID09PSBjdXJyZW50TmV0d29ya0lEKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgdHgudHJhbnNhY3Rpb24udG8gJiZcbiAgICAgICAgICAgICAgICAgICAgdHgudHJhbnNhY3Rpb24udG8udG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eC5ibG9ja051bWJlciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFsYXRlc3RJbmNvbWluZ1R4QmxvY2tOdW1iZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUludChsYXRlc3RJbmNvbWluZ1R4QmxvY2tOdW1iZXIsIDEwKSA8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KHR4LmJsb2NrTnVtYmVyLCAxMCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXRlc3RJbmNvbWluZ1R4QmxvY2tOdW1iZXIgPSB0eC5ibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmICh0eC50b1NtYXJ0Q29udHJhY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBub3QgYHRvYCBpcyBhIGNvbnRyYWN0IGRlcGxveSwgaWYgbm90IGBkYXRhYCBpcyBzZW5kIGV0aFxuICAgICAgICAgICAgICAgICAgICBpZiAodHgudHJhbnNhY3Rpb24udG8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICghdHgudHJhbnNhY3Rpb24uZGF0YSB8fCB0eC50cmFuc2FjdGlvbi5kYXRhICE9PSAnMHgnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IHlpZWxkIHV0aWxfMS5xdWVyeSh0aGlzLmV0aFF1ZXJ5LCAnZ2V0Q29kZScsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC50cmFuc2FjdGlvbi50byxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHgudG9TbWFydENvbnRyYWN0ID0gdXRpbF8xLmlzU21hcnRDb250cmFjdENvZGUoY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eC50b1NtYXJ0Q29udHJhY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBzdGF0ZSBvbmx5IGlmIG5ldyB0cmFuc2FjdGlvbnMgd2VyZSBmZXRjaGVkIG9yXG4gICAgICAgICAgICAvLyB0aGUgc3RhdHVzIG9yIGdhcyBkYXRhIG9mIGEgdHJhbnNhY3Rpb24gaGFzIGNoYW5nZWRcbiAgICAgICAgICAgIGlmICh1cGRhdGVSZXF1aXJlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgdHJhbnNhY3Rpb25zOiB0aGlzLnRyaW1UcmFuc2FjdGlvbnNGb3JTdGF0ZShhbGxUeHMpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxhdGVzdEluY29taW5nVHhCbG9ja051bWJlcjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaW0gdGhlIGFtb3VudCBvZiB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgc2V0IG9uIHRoZSBzdGF0ZS4gQ2hlY2tzXG4gICAgICogaWYgdGhlIGxlbmd0aCBvZiB0aGUgdHggaGlzdG9yeSBpcyBsb25nZXIgdGhlbiBkZXNpcmVkIHBlcnNpc3RlbmNlXG4gICAgICogbGltaXQgYW5kIHRoZW4gaWYgaXQgaXMgcmVtb3ZlcyB0aGUgb2xkZXN0IGNvbmZpcm1lZCBvciByZWplY3RlZCB0eC5cbiAgICAgKiBQZW5kaW5nIG9yIHVuYXBwcm92ZWQgdHJhbnNhY3Rpb25zIHdpbGwgbm90IGJlIHJlbW92ZWQgYnkgdGhpc1xuICAgICAqIG9wZXJhdGlvbi4gRm9yIHNhZmV0eSBvZiBwcmVzZW50aW5nIGEgZnVsbHkgZnVuY3Rpb25hbCB0cmFuc2FjdGlvbiBVSVxuICAgICAqIHJlcHJlc2VudGF0aW9uLCB0aGlzIGZ1bmN0aW9uIHdpbGwgbm90IGJyZWFrIGFwYXJ0IHRyYW5zYWN0aW9ucyB3aXRoIHRoZVxuICAgICAqIHNhbWUgbm9uY2UsIGNyZWF0ZWQgb24gdGhlIHNhbWUgZGF5LCBwZXIgbmV0d29yay4gTm90IGFjY291bnRpbmcgZm9yIHRyYW5zYWN0aW9ucyBvZiB0aGUgc2FtZVxuICAgICAqIG5vbmNlLCBzYW1lIGRheSBhbmQgbmV0d29yayBjb21ibyBjYW4gcmVzdWx0IGluIGNvbmZ1c2luZyBvciBicm9rZW4gZXhwZXJpZW5jZXNcbiAgICAgKiBpbiB0aGUgVUkuIFRoZSB0cmFuc2FjdGlvbnMgYXJlIHRoZW4gdXBkYXRlZCB1c2luZyB0aGUgQmFzZUNvbnRyb2xsZXIgdXBkYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9ucyAtIFRoZSB0cmFuc2FjdGlvbnMgdG8gYmUgYXBwbGllZCB0byB0aGUgc3RhdGUuXG4gICAgICogQHJldHVybnMgVGhlIHRyaW1tZWQgbGlzdCBvZiB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgdHJpbVRyYW5zYWN0aW9uc0ZvclN0YXRlKHRyYW5zYWN0aW9ucykge1xuICAgICAgICBjb25zdCBub25jZU5ldHdvcmtTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IHR4c1RvS2VlcCA9IHRyYW5zYWN0aW9ucy5yZXZlcnNlKCkuZmlsdGVyKCh0eCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBjaGFpbklkLCBuZXR3b3JrSUQsIHN0YXR1cywgdHJhbnNhY3Rpb24sIHRpbWUgfSA9IHR4O1xuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7dHJhbnNhY3Rpb24ubm9uY2V9LSR7Y2hhaW5JZCAhPT0gbnVsbCAmJiBjaGFpbklkICE9PSB2b2lkIDAgPyBjaGFpbklkIDogbmV0d29ya0lEfS0ke25ldyBEYXRlKHRpbWUpLnRvRGF0ZVN0cmluZygpfWA7XG4gICAgICAgICAgICAgICAgaWYgKG5vbmNlTmV0d29ya1NldC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9uY2VOZXR3b3JrU2V0LnNpemUgPCB0aGlzLmNvbmZpZy50eEhpc3RvcnlMaW1pdCB8fFxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5pc0ZpbmFsU3RhdGUoc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICBub25jZU5ldHdvcmtTZXQuYWRkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHR4c1RvS2VlcC5yZXZlcnNlKCk7XG4gICAgICAgIHJldHVybiB0eHNUb0tlZXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGluIGEgZmluYWwgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdHVzIC0gVGhlIHRyYW5zYWN0aW9uIHN0YXR1cy5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB0cmFuc2FjdGlvbiBpcyBpbiBhIGZpbmFsIHN0YXRlLlxuICAgICAqL1xuICAgIGlzRmluYWxTdGF0ZShzdGF0dXMpIHtcbiAgICAgICAgcmV0dXJuIChzdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLnJlamVjdGVkIHx8XG4gICAgICAgICAgICBzdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLmNvbmZpcm1lZCB8fFxuICAgICAgICAgICAgc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5mYWlsZWQgfHxcbiAgICAgICAgICAgIHN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuY2FuY2VsbGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIHZlcmlmeSB0aGUgc3RhdGUgb2YgYSB0cmFuc2FjdGlvbiB1c2luZyB0aGUgQmxvY2tjaGFpbiBhcyBhIHNvdXJjZSBvZiB0cnV0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXRhIC0gVGhlIGxvY2FsIHRyYW5zYWN0aW9uIHRvIHZlcmlmeSBvbiB0aGUgYmxvY2tjaGFpbi5cbiAgICAgKiBAcmV0dXJucyBBIHR1cGxlIGNvbnRhaW5pbmcgdGhlIHVwZGF0ZWQgdHJhbnNhY3Rpb24sIGFuZCB3aGV0aGVyIG9yIG5vdCBhbiB1cGRhdGUgd2FzIHJlcXVpcmVkLlxuICAgICAqL1xuICAgIGJsb2NrY2hhaW5UcmFuc2FjdGlvblN0YXRlUmVjb25jaWxlcihtZXRhKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHN0YXR1cywgdHJhbnNhY3Rpb25IYXNoIH0gPSBtZXRhO1xuICAgICAgICAgICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdHVzLmNvbmZpcm1lZDpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHhSZWNlaXB0ID0geWllbGQgdXRpbF8xLnF1ZXJ5KHRoaXMuZXRoUXVlcnksICdnZXRUcmFuc2FjdGlvblJlY2VpcHQnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXR4UmVjZWlwdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFttZXRhLCBmYWxzZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWV0YS52ZXJpZmllZE9uQmxvY2tjaGFpbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG1ldGEudHJhbnNhY3Rpb24uZ2FzVXNlZCA9IHR4UmVjZWlwdC5nYXNVc2VkO1xuICAgICAgICAgICAgICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIFdlYjMgZG9jczpcbiAgICAgICAgICAgICAgICAgICAgLy8gVFJVRSBpZiB0aGUgdHJhbnNhY3Rpb24gd2FzIHN1Y2Nlc3NmdWwsIEZBTFNFIGlmIHRoZSBFVk0gcmV2ZXJ0ZWQgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBpZiAoTnVtYmVyKHR4UmVjZWlwdC5zdGF0dXMpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gZmFpbGVkLiBUaGUgdHJhbnNhY3Rpb24gd2FzIHJldmVyc2VkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxUcmFuc2FjdGlvbihtZXRhLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW21ldGEsIGZhbHNlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW21ldGEsIHRydWVdO1xuICAgICAgICAgICAgICAgIGNhc2UgVHJhbnNhY3Rpb25TdGF0dXMuc3VibWl0dGVkOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eE9iaiA9IHlpZWxkIHV0aWxfMS5xdWVyeSh0aGlzLmV0aFF1ZXJ5LCAnZ2V0VHJhbnNhY3Rpb25CeUhhc2gnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXR4T2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNlaXB0U2hvd3NGYWlsZWRTdGF0dXMgPSB5aWVsZCB0aGlzLmNoZWNrVHhSZWNlaXB0U3RhdHVzSXNGYWlsZWQodHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhc2UgdGhlIHR4T2JqIGlzIGV2YWx1YXRlZCBhcyBmYWxzZSwgYSBzZWNvbmQgY2hlY2sgd2lsbFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIHRoZSB0eCBmYWlsZWQgb3IgaXQgaXMgcGVuZGluZyBvciBjb25maXJtZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0U2hvd3NGYWlsZWRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gZmFpbGVkLiBUaGUgdHJhbnNhY3Rpb24gd2FzIGRyb3BwZWQgb3IgcmVwbGFjZWQgYnkgYSBuZXcgb25lJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsVHJhbnNhY3Rpb24obWV0YSwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eE9iaiA9PT0gbnVsbCB8fCB0eE9iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHhPYmouYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGEuc3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXMuY29uZmlybWVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5odWIuZW1pdChgJHttZXRhLmlkfTpjb25maXJtZWRgLCBtZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbbWV0YSwgdHJ1ZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFttZXRhLCBmYWxzZV07XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFttZXRhLCBmYWxzZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gY2hlY2sgaWYgYSB0eCBoYXMgZmFpbGVkIGFjY29yZGluZyB0byB0aGVpciByZWNlaXB0XG4gICAgICogQWNjb3JkaW5nIHRvIHRoZSBXZWIzIGRvY3M6XG4gICAgICogVFJVRSBpZiB0aGUgdHJhbnNhY3Rpb24gd2FzIHN1Y2Nlc3NmdWwsIEZBTFNFIGlmIHRoZSBFVk0gcmV2ZXJ0ZWQgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqIFRoZSByZWNlaXB0IGlzIG5vdCBhdmFpbGFibGUgZm9yIHBlbmRpbmcgdHJhbnNhY3Rpb25zIGFuZCByZXR1cm5zIG51bGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHhIYXNoIC0gVGhlIHRyYW5zYWN0aW9uIGhhc2guXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgdHJhbnNhY3Rpb24gaGFzIGZhaWxlZC5cbiAgICAgKi9cbiAgICBjaGVja1R4UmVjZWlwdFN0YXR1c0lzRmFpbGVkKHR4SGFzaCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdHhSZWNlaXB0ID0geWllbGQgdXRpbF8xLnF1ZXJ5KHRoaXMuZXRoUXVlcnksICdnZXRUcmFuc2FjdGlvblJlY2VpcHQnLCBbXG4gICAgICAgICAgICAgICAgdHhIYXNoLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBpZiAoIXR4UmVjZWlwdCkge1xuICAgICAgICAgICAgICAgIC8vIFRyYW5zYWN0aW9uIGlzIHBlbmRpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHR4UmVjZWlwdC5zdGF0dXMpID09PSAwO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIHZlcmlmeSB0aGUgc3RhdGUgb2YgdHJhbnNhY3Rpb25zIHVzaW5nIEV0aGVyc2NhbiBhcyBhIHNvdXJjZSBvZiB0cnV0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZW1vdGVUeHMgLSBUcmFuc2FjdGlvbnMgdG8gcmVjb25jaWxlIHRoYXQgYXJlIGZyb20gYSByZW1vdGUgc291cmNlLlxuICAgICAqIEBwYXJhbSBsb2NhbFR4cyAtIFRyYW5zYWN0aW9ucyB0byByZWNvbmNpbGUgdGhhdCBhcmUgbG9jYWwuXG4gICAgICogQHJldHVybnMgQSB0dXBsZSBjb250YWluaW5nIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IGFuIHVwZGF0ZSB3YXMgcmVxdWlyZWQsIGFuZCB0aGUgdXBkYXRlZCB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBldGhlcnNjYW5UcmFuc2FjdGlvblN0YXRlUmVjb25jaWxlcihyZW1vdGVUeHMsIGxvY2FsVHhzKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRUeHMgPSB0aGlzLmdldFVwZGF0ZWRUcmFuc2FjdGlvbnMocmVtb3RlVHhzLCBsb2NhbFR4cyk7XG4gICAgICAgIGNvbnN0IG5ld1R4cyA9IHRoaXMuZ2V0TmV3VHJhbnNhY3Rpb25zKHJlbW90ZVR4cywgbG9jYWxUeHMpO1xuICAgICAgICBjb25zdCB1cGRhdGVkTG9jYWxUeHMgPSBsb2NhbFR4cy5tYXAoKHR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0eElkeCA9IHVwZGF0ZWRUeHMuZmluZEluZGV4KCh7IHRyYW5zYWN0aW9uSGFzaCB9KSA9PiB0cmFuc2FjdGlvbkhhc2ggPT09IHR4LnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gdHhJZHggPT09IC0xID8gdHggOiB1cGRhdGVkVHhzW3R4SWR4XTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZVJlcXVpcmVkID0gbmV3VHhzLmxlbmd0aCA+IDAgfHwgdXBkYXRlZExvY2FsVHhzLmxlbmd0aCA+IDA7XG4gICAgICAgIHJldHVybiBbdXBkYXRlUmVxdWlyZWQsIFsuLi5uZXdUeHMsIC4uLnVwZGF0ZWRMb2NhbFR4c11dO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHRyYW5zYWN0aW9ucyB0aGF0IGFyZSBpbiB0aGUgcmVtb3RlIHRyYW5zYWN0aW9ucyBhcnJheVxuICAgICAqIGJ1dCBub3QgaW4gdGhlIGxvY2FsIHRyYW5zYWN0aW9ucyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZW1vdGVUeHMgLSBBcnJheSBvZiB0cmFuc2FjdGlvbnMgZnJvbSByZW1vdGUgc291cmNlLlxuICAgICAqIEBwYXJhbSBsb2NhbFR4cyAtIEFycmF5IG9mIHRyYW5zYWN0aW9ucyBzdG9yZWQgbG9jYWxseS5cbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3IHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBnZXROZXdUcmFuc2FjdGlvbnMocmVtb3RlVHhzLCBsb2NhbFR4cykge1xuICAgICAgICByZXR1cm4gcmVtb3RlVHhzLmZpbHRlcigodHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFscmVhZHlJblRyYW5zYWN0aW9ucyA9IGxvY2FsVHhzLmZpbmQoKHsgdHJhbnNhY3Rpb25IYXNoIH0pID0+IHRyYW5zYWN0aW9uSGFzaCA9PT0gdHgudHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgIHJldHVybiAhYWxyZWFkeUluVHJhbnNhY3Rpb25zO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCB0aGUgdHJhbnNhY3Rpb25zIHRoYXQgYXJlIGxvY2FsbHkgb3V0ZGF0ZWQgd2l0aCByZXNwZWN0XG4gICAgICogdG8gYSByZW1vdGUgc291cmNlIChldGhlcnNjYW4gb3IgYmxvY2tjaGFpbikuIFRoZSByZXR1cm5lZCBhcnJheVxuICAgICAqIGNvbnRhaW5zIHRoZSB0cmFuc2FjdGlvbnMgd2l0aCB0aGUgdXBkYXRlZCBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlbW90ZVR4cyAtIEFycmF5IG9mIHRyYW5zYWN0aW9ucyBmcm9tIHJlbW90ZSBzb3VyY2UuXG4gICAgICogQHBhcmFtIGxvY2FsVHhzIC0gQXJyYXkgb2YgdHJhbnNhY3Rpb25zIHN0b3JlZCBsb2NhbGx5LlxuICAgICAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBnZXRVcGRhdGVkVHJhbnNhY3Rpb25zKHJlbW90ZVR4cywgbG9jYWxUeHMpIHtcbiAgICAgICAgcmV0dXJuIHJlbW90ZVR4cy5maWx0ZXIoKHJlbW90ZVR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc1R4T3V0ZGF0ZWQgPSBsb2NhbFR4cy5maW5kKChsb2NhbFR4KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChyZW1vdGVUeC50cmFuc2FjdGlvbkhhc2ggPT09IGxvY2FsVHgudHJhbnNhY3Rpb25IYXNoICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNUcmFuc2FjdGlvbk91dGRhdGVkKHJlbW90ZVR4LCBsb2NhbFR4KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBpc1R4T3V0ZGF0ZWQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBpZiBhIGxvY2FsIHRyYW5zYWN0aW9uIGlzIG91dGRhdGVkIHdpdGggcmVzcGVjdCB0byB0aGUgcmVtb3RlIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlbW90ZVR4IC0gVGhlIHJlbW90ZSB0cmFuc2FjdGlvbiBmcm9tIEV0aGVyc2Nhbi5cbiAgICAgKiBAcGFyYW0gbG9jYWxUeCAtIFRoZSBsb2NhbCB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB0cmFuc2FjdGlvbiBpcyBvdXRkYXRlZC5cbiAgICAgKi9cbiAgICBpc1RyYW5zYWN0aW9uT3V0ZGF0ZWQocmVtb3RlVHgsIGxvY2FsVHgpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzT3V0ZGF0ZWQgPSB0aGlzLmlzU3RhdHVzT3V0ZGF0ZWQocmVtb3RlVHgudHJhbnNhY3Rpb25IYXNoLCBsb2NhbFR4LnRyYW5zYWN0aW9uSGFzaCwgcmVtb3RlVHguc3RhdHVzLCBsb2NhbFR4LnN0YXR1cyk7XG4gICAgICAgIGNvbnN0IGdhc0RhdGFPdXRkYXRlZCA9IHRoaXMuaXNHYXNEYXRhT3V0ZGF0ZWQocmVtb3RlVHgudHJhbnNhY3Rpb24uZ2FzVXNlZCwgbG9jYWxUeC50cmFuc2FjdGlvbi5nYXNVc2VkKTtcbiAgICAgICAgcmV0dXJuIHN0YXR1c091dGRhdGVkIHx8IGdhc0RhdGFPdXRkYXRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgaWYgdGhlIHN0YXR1cyBvZiBhIGxvY2FsIHRyYW5zYWN0aW9uIGlzIG91dGRhdGVkIHdpdGggcmVzcGVjdCB0byB0aGUgcmVtb3RlIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlbW90ZVR4SGFzaCAtIFJlbW90ZSB0cmFuc2FjdGlvbiBoYXNoLlxuICAgICAqIEBwYXJhbSBsb2NhbFR4SGFzaCAtIExvY2FsIHRyYW5zYWN0aW9uIGhhc2guXG4gICAgICogQHBhcmFtIHJlbW90ZVR4U3RhdHVzIC0gUmVtb3RlIHRyYW5zYWN0aW9uIHN0YXR1cy5cbiAgICAgKiBAcGFyYW0gbG9jYWxUeFN0YXR1cyAtIExvY2FsIHRyYW5zYWN0aW9uIHN0YXR1cy5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzdGF0dXMgaXMgb3V0ZGF0ZWQuXG4gICAgICovXG4gICAgaXNTdGF0dXNPdXRkYXRlZChyZW1vdGVUeEhhc2gsIGxvY2FsVHhIYXNoLCByZW1vdGVUeFN0YXR1cywgbG9jYWxUeFN0YXR1cykge1xuICAgICAgICByZXR1cm4gcmVtb3RlVHhIYXNoID09PSBsb2NhbFR4SGFzaCAmJiByZW1vdGVUeFN0YXR1cyAhPT0gbG9jYWxUeFN0YXR1cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgaWYgdGhlIGdhcyBkYXRhIG9mIGEgbG9jYWwgdHJhbnNhY3Rpb24gaXMgb3V0ZGF0ZWQgd2l0aCByZXNwZWN0IHRvIHRoZSByZW1vdGUgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVtb3RlR2FzVXNlZCAtIFJlbW90ZSBnYXMgdXNlZCBpbiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICogQHBhcmFtIGxvY2FsR2FzVXNlZCAtIExvY2FsIGdhcyB1c2VkIGluIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnYXMgZGF0YSBpcyBvdXRkYXRlZC5cbiAgICAgKi9cbiAgICBpc0dhc0RhdGFPdXRkYXRlZChyZW1vdGVHYXNVc2VkLCBsb2NhbEdhc1VzZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlbW90ZUdhc1VzZWQgIT09IGxvY2FsR2FzVXNlZDtcbiAgICB9XG59XG5leHBvcnRzLlRyYW5zYWN0aW9uQ29udHJvbGxlciA9IFRyYW5zYWN0aW9uQ29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IFRyYW5zYWN0aW9uQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyYW5zYWN0aW9uQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UHJlZml4Rm9yQ2hhaW4oY2hhaW5JZCkge1xuICAgIGxldCBwcmVmaXg7XG4gICAgc3dpdGNoIChjaGFpbklkKSB7XG4gICAgICAgIGNhc2UgJzB4MSc6IC8vIG1haW4gbmV0XG4gICAgICAgICAgICBwcmVmaXggPSAnJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcweDMnOiAvLyByb3BzdGVuIHRlc3QgbmV0XG4gICAgICAgICAgICBwcmVmaXggPSAncm9wc3Rlbi4nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzB4NCc6IC8vIHJpbmtlYnkgdGVzdCBuZXRcbiAgICAgICAgICAgIHByZWZpeCA9ICdyaW5rZWJ5Lic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMHg1JzogLy8gZ29lcmxpIHRlc3QgbmV0XG4gICAgICAgICAgICBwcmVmaXggPSAnZ29lcmxpLic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMHgyYSc6IC8vIGtvdmFuIHRlc3QgbmV0XG4gICAgICAgICAgICBwcmVmaXggPSAna292YW4uJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcHJlZml4ID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHByZWZpeDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVmaXgtZm9yLWNoYWluLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGRQYXRoVG9VcmwgPSB2b2lkIDA7XG5leHBvcnRzLmFkZFBhdGhUb1VybCA9IChjdXN0b21OZXR3b3JrVXJsLCBsaW5rVHlwZSwgc3VmZml4VHlwZSkgPT4ge1xuICAgIGNvbnN0IHsgdXNlcm5hbWUsIHBhc3N3b3JkLCBwcm90b2NvbCwgaG9zdCwgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCB9ID0gbmV3IFVSTChjdXN0b21OZXR3b3JrVXJsKTtcbiAgICBjb25zdCBuZXdQYXRoID0gcGF0aG5hbWUuZW5kc1dpdGgoJy8nKSA/IGAke3BhdGhuYW1lfSR7bGlua1R5cGV9LyR7c3VmZml4VHlwZX1gIDogYCR7cGF0aG5hbWV9LyR7bGlua1R5cGV9LyR7c3VmZml4VHlwZX1gO1xuICAgIGNvbnN0IGF1dGggPSB1c2VybmFtZSA/IGAke3VzZXJuYW1lfToke3Bhc3N3b3JkfWAgOiAnJztcbiAgICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKGAke3Byb3RvY29sfS8vJHthdXRofSR7aG9zdH0ke25ld1BhdGh9JHtzZWFyY2h9JHtoYXNofWApO1xuICAgIHJldHVybiBwYXJzZWRVcmwudG9TdHJpbmcoKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQcmVmaXhGb3JOZXR3b3JrKG5ldHdvcmtJZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByYWRpeFxuICAgIGNvbnN0IG5ldCA9IHBhcnNlSW50KG5ldHdvcmtJZCk7XG4gICAgbGV0IHByZWZpeDtcbiAgICBzd2l0Y2ggKG5ldCkge1xuICAgICAgICBjYXNlIDE6IC8vIG1haW4gbmV0XG4gICAgICAgICAgICBwcmVmaXggPSAnJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6IC8vIHJvcHN0ZW4gdGVzdCBuZXRcbiAgICAgICAgICAgIHByZWZpeCA9ICdyb3BzdGVuLic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OiAvLyByaW5rZWJ5IHRlc3QgbmV0XG4gICAgICAgICAgICBwcmVmaXggPSAncmlua2VieS4nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTogLy8gZ29lcmxpIHRlc3QgbmV0XG4gICAgICAgICAgICBwcmVmaXggPSAnZ29lcmxpLic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0MjogLy8ga292YW4gdGVzdCBuZXRcbiAgICAgICAgICAgIHByZWZpeCA9ICdrb3Zhbi4nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBwcmVmaXggPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcHJlZml4O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWZpeC1mb3ItbmV0d29yay5qcy5tYXAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAhcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0geyBuZXh0VGljazogbmV4dFRpY2sgfTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzc1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG5cbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIgJiYgKCF0aGlzLl93cml0YWJsZVN0YXRlIHx8ICF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIF90aGlzLCBlcnIpO1xuICAgICAgaWYgKF90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzdHJveTogZGVzdHJveSxcbiAgdW5kZXN0cm95OiB1bmRlc3Ryb3lcbn07IiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgc3JjLmNvcHkodGFyZ2V0LCBvZmZzZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG5cbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2godikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAtLXRoaXMubGVuZ3RoO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihzKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgICB9cmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQobikge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAocCkge1xuICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICBwID0gcC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpO1xuXG5pZiAodXRpbCAmJiB1dGlsLmluc3BlY3QgJiYgdXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICBtb2R1bGUuZXhwb3J0cy5wcm90b3R5cGVbdXRpbC5pbnNwZWN0LmN1c3RvbV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHV0aWwuaW5zcGVjdCh7IGxlbmd0aDogdGhpcy5sZW5ndGggfSk7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZSArICcgJyArIG9iajtcbiAgfTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XG4gIHZhciByZXRyaWVkO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuICd1dGY4JztcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xuICByZXR1cm4gbmVuYyB8fCBlbmM7XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy5cbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XG4gIHZhciBuYjtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcbiAgICAgIG5iID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcbiAgICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcbn1cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciByO1xuICB2YXIgaTtcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XG4gIHJldHVybiByIHx8ICcnO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcblxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59O1xuXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXG4vLyBjb250aW51YXRpb24gYnl0ZS4gSWYgYW4gaW52YWxpZCBieXRlIGlzIGRldGVjdGVkLCAtMiBpcyByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcbiAgcmV0dXJuIGJ5dGUgPj4gNiA9PT0gMHgwMiA/IC0xIDogLTI7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIGEgc2luZ2xlIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoJ1xcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcbi8vIGxvb3AuXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XG4gICAgcmV0dXJuICdcXHVmZmZkJztcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgfVxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcbiAgICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBhZGRlZCB3aGVuIGVuZGluZyBvbiBhIHBhcnRpYWxcbi8vIGNoYXJhY3Rlci5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iLCJmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFNlc3Npb24gU3RhdHVzXG4gKi9cbnZhciBTZXNzaW9uU3RhdHVzO1xuKGZ1bmN0aW9uIChTZXNzaW9uU3RhdHVzKSB7XG4gICAgLyoqIEpTRG9jICovXG4gICAgU2Vzc2lvblN0YXR1c1tcIk9rXCJdID0gXCJva1wiO1xuICAgIC8qKiBKU0RvYyAqL1xuICAgIFNlc3Npb25TdGF0dXNbXCJFeGl0ZWRcIl0gPSBcImV4aXRlZFwiO1xuICAgIC8qKiBKU0RvYyAqL1xuICAgIFNlc3Npb25TdGF0dXNbXCJDcmFzaGVkXCJdID0gXCJjcmFzaGVkXCI7XG4gICAgLyoqIEpTRG9jICovXG4gICAgU2Vzc2lvblN0YXR1c1tcIkFibm9ybWFsXCJdID0gXCJhYm5vcm1hbFwiO1xufSkoU2Vzc2lvblN0YXR1cyA9IGV4cG9ydHMuU2Vzc2lvblN0YXR1cyB8fCAoZXhwb3J0cy5TZXNzaW9uU3RhdHVzID0ge30pKTtcbnZhciBSZXF1ZXN0U2Vzc2lvblN0YXR1cztcbihmdW5jdGlvbiAoUmVxdWVzdFNlc3Npb25TdGF0dXMpIHtcbiAgICAvKiogSlNEb2MgKi9cbiAgICBSZXF1ZXN0U2Vzc2lvblN0YXR1c1tcIk9rXCJdID0gXCJva1wiO1xuICAgIC8qKiBKU0RvYyAqL1xuICAgIFJlcXVlc3RTZXNzaW9uU3RhdHVzW1wiRXJyb3JlZFwiXSA9IFwiZXJyb3JlZFwiO1xuICAgIC8qKiBKU0RvYyAqL1xuICAgIFJlcXVlc3RTZXNzaW9uU3RhdHVzW1wiQ3Jhc2hlZFwiXSA9IFwiY3Jhc2hlZFwiO1xufSkoUmVxdWVzdFNlc3Npb25TdGF0dXMgPSBleHBvcnRzLlJlcXVlc3RTZXNzaW9uU3RhdHVzIHx8IChleHBvcnRzLlJlcXVlc3RTZXNzaW9uU3RhdHVzID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlc3Npb24uanMubWFwIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIENvbnNvbGUgbG9nZ2luZyB2ZXJib3NpdHkgZm9yIHRoZSBTREsuICovXG52YXIgTG9nTGV2ZWw7XG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XG4gICAgLyoqIE5vIGxvZ3Mgd2lsbCBiZSBnZW5lcmF0ZWQuICovXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgICAvKiogT25seSBTREsgaW50ZXJuYWwgZXJyb3JzIHdpbGwgYmUgbG9nZ2VkLiAqL1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRXJyb3JcIl0gPSAxXSA9IFwiRXJyb3JcIjtcbiAgICAvKiogSW5mb3JtYXRpb24gdXNlZnVsIGZvciBkZWJ1Z2dpbmcgdGhlIFNESyB3aWxsIGJlIGxvZ2dlZC4gKi9cbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkRlYnVnXCJdID0gMl0gPSBcIkRlYnVnXCI7XG4gICAgLyoqIEFsbCBTREsgYWN0aW9ucyB3aWxsIGJlIGxvZ2dlZC4gKi9cbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIlZlcmJvc2VcIl0gPSAzXSA9IFwiVmVyYm9zZVwiO1xufSkoTG9nTGV2ZWwgPSBleHBvcnRzLkxvZ0xldmVsIHx8IChleHBvcnRzLkxvZ0xldmVsID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2xldmVsLmpzLm1hcCIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBUcmFuc2FjdGlvblNhbXBsaW5nTWV0aG9kO1xuKGZ1bmN0aW9uIChUcmFuc2FjdGlvblNhbXBsaW5nTWV0aG9kKSB7XG4gICAgVHJhbnNhY3Rpb25TYW1wbGluZ01ldGhvZFtcIkV4cGxpY2l0XCJdID0gXCJleHBsaWNpdGx5X3NldFwiO1xuICAgIFRyYW5zYWN0aW9uU2FtcGxpbmdNZXRob2RbXCJTYW1wbGVyXCJdID0gXCJjbGllbnRfc2FtcGxlclwiO1xuICAgIFRyYW5zYWN0aW9uU2FtcGxpbmdNZXRob2RbXCJSYXRlXCJdID0gXCJjbGllbnRfcmF0ZVwiO1xuICAgIFRyYW5zYWN0aW9uU2FtcGxpbmdNZXRob2RbXCJJbmhlcml0YW5jZVwiXSA9IFwiaW5oZXJpdGFuY2VcIjtcbn0pKFRyYW5zYWN0aW9uU2FtcGxpbmdNZXRob2QgPSBleHBvcnRzLlRyYW5zYWN0aW9uU2FtcGxpbmdNZXRob2QgfHwgKGV4cG9ydHMuVHJhbnNhY3Rpb25TYW1wbGluZ01ldGhvZCA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2FjdGlvbi5qcy5tYXAiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogSlNEb2MgKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvZXhwb3J0XG52YXIgU2V2ZXJpdHk7XG4oZnVuY3Rpb24gKFNldmVyaXR5KSB7XG4gICAgLyoqIEpTRG9jICovXG4gICAgU2V2ZXJpdHlbXCJGYXRhbFwiXSA9IFwiZmF0YWxcIjtcbiAgICAvKiogSlNEb2MgKi9cbiAgICBTZXZlcml0eVtcIkVycm9yXCJdID0gXCJlcnJvclwiO1xuICAgIC8qKiBKU0RvYyAqL1xuICAgIFNldmVyaXR5W1wiV2FybmluZ1wiXSA9IFwid2FybmluZ1wiO1xuICAgIC8qKiBKU0RvYyAqL1xuICAgIFNldmVyaXR5W1wiTG9nXCJdID0gXCJsb2dcIjtcbiAgICAvKiogSlNEb2MgKi9cbiAgICBTZXZlcml0eVtcIkluZm9cIl0gPSBcImluZm9cIjtcbiAgICAvKiogSlNEb2MgKi9cbiAgICBTZXZlcml0eVtcIkRlYnVnXCJdID0gXCJkZWJ1Z1wiO1xuICAgIC8qKiBKU0RvYyAqL1xuICAgIFNldmVyaXR5W1wiQ3JpdGljYWxcIl0gPSBcImNyaXRpY2FsXCI7XG59KShTZXZlcml0eSA9IGV4cG9ydHMuU2V2ZXJpdHkgfHwgKGV4cG9ydHMuU2V2ZXJpdHkgPSB7fSkpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1uYW1lc3BhY2UsIGltcG9ydC9leHBvcnRcbihmdW5jdGlvbiAoU2V2ZXJpdHkpIHtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHN0cmluZy1iYXNlZCBsZXZlbCBpbnRvIGEge0BsaW5rIFNldmVyaXR5fS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsZXZlbCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgU2V2ZXJpdHlcbiAgICAgKiBAcmV0dXJucyBTZXZlcml0eVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcobGV2ZWwpIHtcbiAgICAgICAgc3dpdGNoIChsZXZlbCkge1xuICAgICAgICAgICAgY2FzZSAnZGVidWcnOlxuICAgICAgICAgICAgICAgIHJldHVybiBTZXZlcml0eS5EZWJ1ZztcbiAgICAgICAgICAgIGNhc2UgJ2luZm8nOlxuICAgICAgICAgICAgICAgIHJldHVybiBTZXZlcml0eS5JbmZvO1xuICAgICAgICAgICAgY2FzZSAnd2Fybic6XG4gICAgICAgICAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gU2V2ZXJpdHkuV2FybmluZztcbiAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gU2V2ZXJpdHkuRXJyb3I7XG4gICAgICAgICAgICBjYXNlICdmYXRhbCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNldmVyaXR5LkZhdGFsO1xuICAgICAgICAgICAgY2FzZSAnY3JpdGljYWwnOlxuICAgICAgICAgICAgICAgIHJldHVybiBTZXZlcml0eS5Dcml0aWNhbDtcbiAgICAgICAgICAgIGNhc2UgJ2xvZyc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBTZXZlcml0eS5Mb2c7XG4gICAgICAgIH1cbiAgICB9XG4gICAgU2V2ZXJpdHkuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XG59KShTZXZlcml0eSA9IGV4cG9ydHMuU2V2ZXJpdHkgfHwgKGV4cG9ydHMuU2V2ZXJpdHkgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V2ZXJpdHkuanMubWFwIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE91dGNvbWU7XG4oZnVuY3Rpb24gKE91dGNvbWUpIHtcbiAgICBPdXRjb21lW1wiQmVmb3JlU2VuZFwiXSA9IFwiYmVmb3JlX3NlbmRcIjtcbiAgICBPdXRjb21lW1wiRXZlbnRQcm9jZXNzb3JcIl0gPSBcImV2ZW50X3Byb2Nlc3NvclwiO1xuICAgIE91dGNvbWVbXCJOZXR3b3JrRXJyb3JcIl0gPSBcIm5ldHdvcmtfZXJyb3JcIjtcbiAgICBPdXRjb21lW1wiUXVldWVPdmVyZmxvd1wiXSA9IFwicXVldWVfb3ZlcmZsb3dcIjtcbiAgICBPdXRjb21lW1wiUmF0ZUxpbWl0QmFja29mZlwiXSA9IFwicmF0ZWxpbWl0X2JhY2tvZmZcIjtcbiAgICBPdXRjb21lW1wiU2FtcGxlUmF0ZVwiXSA9IFwic2FtcGxlX3JhdGVcIjtcbn0pKE91dGNvbWUgPSBleHBvcnRzLk91dGNvbWUgfHwgKGV4cG9ydHMuT3V0Y29tZSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc3BvcnQuanMubWFwIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIFRoZSBzdGF0dXMgb2YgYW4gZXZlbnQuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L2V4cG9ydFxudmFyIFN0YXR1cztcbihmdW5jdGlvbiAoU3RhdHVzKSB7XG4gICAgLyoqIFRoZSBzdGF0dXMgY291bGQgbm90IGJlIGRldGVybWluZWQuICovXG4gICAgU3RhdHVzW1wiVW5rbm93blwiXSA9IFwidW5rbm93blwiO1xuICAgIC8qKiBUaGUgZXZlbnQgd2FzIHNraXBwZWQgZHVlIHRvIGNvbmZpZ3VyYXRpb24gb3IgY2FsbGJhY2tzLiAqL1xuICAgIFN0YXR1c1tcIlNraXBwZWRcIl0gPSBcInNraXBwZWRcIjtcbiAgICAvKiogVGhlIGV2ZW50IHdhcyBzZW50IHRvIFNlbnRyeSBzdWNjZXNzZnVsbHkuICovXG4gICAgU3RhdHVzW1wiU3VjY2Vzc1wiXSA9IFwic3VjY2Vzc1wiO1xuICAgIC8qKiBUaGUgY2xpZW50IGlzIGN1cnJlbnRseSByYXRlIGxpbWl0ZWQgYW5kIHdpbGwgdHJ5IGFnYWluIGxhdGVyLiAqL1xuICAgIFN0YXR1c1tcIlJhdGVMaW1pdFwiXSA9IFwicmF0ZV9saW1pdFwiO1xuICAgIC8qKiBUaGUgZXZlbnQgY291bGQgbm90IGJlIHByb2Nlc3NlZC4gKi9cbiAgICBTdGF0dXNbXCJJbnZhbGlkXCJdID0gXCJpbnZhbGlkXCI7XG4gICAgLyoqIEEgc2VydmVyLXNpZGUgZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHN1Ym1pc3Npb24uICovXG4gICAgU3RhdHVzW1wiRmFpbGVkXCJdID0gXCJmYWlsZWRcIjtcbn0pKFN0YXR1cyA9IGV4cG9ydHMuU3RhdHVzIHx8IChleHBvcnRzLlN0YXR1cyA9IHt9KSk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5hbWVzcGFjZSwgaW1wb3J0L2V4cG9ydFxuKGZ1bmN0aW9uIChTdGF0dXMpIHtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIEhUVFAgc3RhdHVzIGNvZGUgaW50byBhIHtAbGluayBTdGF0dXN9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvZGUgVGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGUuXG4gICAgICogQHJldHVybnMgVGhlIHNlbmQgc3RhdHVzIG9yIHtAbGluayBTdGF0dXMuVW5rbm93bn0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbUh0dHBDb2RlKGNvZGUpIHtcbiAgICAgICAgaWYgKGNvZGUgPj0gMjAwICYmIGNvZGUgPCAzMDApIHtcbiAgICAgICAgICAgIHJldHVybiBTdGF0dXMuU3VjY2VzcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZSA9PT0gNDI5KSB7XG4gICAgICAgICAgICByZXR1cm4gU3RhdHVzLlJhdGVMaW1pdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZSA+PSA0MDAgJiYgY29kZSA8IDUwMCkge1xuICAgICAgICAgICAgcmV0dXJuIFN0YXR1cy5JbnZhbGlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlID49IDUwMCkge1xuICAgICAgICAgICAgcmV0dXJuIFN0YXR1cy5GYWlsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0YXR1cy5Vbmtub3duO1xuICAgIH1cbiAgICBTdGF0dXMuZnJvbUh0dHBDb2RlID0gZnJvbUh0dHBDb2RlO1xufSkoU3RhdHVzID0gZXhwb3J0cy5TdGF0dXMgfHwgKGV4cG9ydHMuU3RhdHVzID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXR1cy5qcy5tYXAiLCIvKipcbiAqIFRoaXMgd2FzIG9yaWdpbmFsbHkgZm9ya2VkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL29jYy9UcmFjZUtpdCwgYnV0IGhhcyBzaW5jZSBiZWVuXG4gKiBsYXJnZWx5IG1vZGlmaWVkIGFuZCBpcyBub3cgbWFpbnRhaW5lZCBhcyBwYXJ0IG9mIFNlbnRyeSBKUyBTREsuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuLy8gZ2xvYmFsIHJlZmVyZW5jZSB0byBzbGljZVxudmFyIFVOS05PV05fRlVOQ1RJT04gPSAnPyc7XG4vLyBDaHJvbWl1bSBiYXNlZCBicm93c2VyczogQ2hyb21lLCBCcmF2ZSwgbmV3IE9wZXJhLCBuZXcgRWRnZVxudmFyIGNocm9tZSA9IC9eXFxzKmF0ICg/OiguKj8pID9cXCgpPygoPzpmaWxlfGh0dHBzP3xibG9ifGNocm9tZS1leHRlbnNpb258YWRkcmVzc3xuYXRpdmV8ZXZhbHx3ZWJwYWNrfDxhbm9ueW1vdXM+fFstYS16XSs6fC4qYnVuZGxlfFxcLykuKj8pKD86OihcXGQrKSk/KD86OihcXGQrKSk/XFwpP1xccyokL2k7XG4vLyBnZWNrbyByZWdleDogYCg/OmJ1bmRsZXxcXGQrXFwuanMpYDogYGJ1bmRsZWAgaXMgZm9yIHJlYWN0IG5hdGl2ZSwgYFxcZCtcXC5qc2AgYWxzbyBidXQgc3BlY2lmaWNhbGx5IGZvciByYW0gYnVuZGxlcyBiZWNhdXNlIGl0XG4vLyBnZW5lcmF0ZXMgZmlsZW5hbWVzIHdpdGhvdXQgYSBwcmVmaXggbGlrZSBgZmlsZTovL2AgdGhlIGZpbGVuYW1lcyBpbiB0aGUgc3RhY2t0cmFjZSBhcmUganVzdCA0Mi5qc1xuLy8gV2UgbmVlZCB0aGlzIHNwZWNpZmljIGNhc2UgZm9yIG5vdyBiZWNhdXNlIHdlIHdhbnQgbm8gb3RoZXIgcmVnZXggdG8gbWF0Y2guXG52YXIgZ2Vja28gPSAvXlxccyooLio/KSg/OlxcKCguKj8pXFwpKT8oPzpefEApPygoPzpmaWxlfGh0dHBzP3xibG9ifGNocm9tZXx3ZWJwYWNrfHJlc291cmNlfG1vei1leHRlbnNpb258Y2FwYWNpdG9yKS4qPzpcXC8uKj98XFxbbmF0aXZlIGNvZGVcXF18W15AXSooPzpidW5kbGV8XFxkK1xcLmpzKXxcXC9bXFx3XFwtLiAvPV0rKSg/OjooXFxkKykpPyg/OjooXFxkKykpP1xccyokL2k7XG52YXIgd2luanMgPSAvXlxccyphdCAoPzooKD86XFxbb2JqZWN0IG9iamVjdFxcXSk/LispICk/XFwoPygoPzpmaWxlfG1zLWFwcHh8aHR0cHM/fHdlYnBhY2t8YmxvYik6Lio/KTooXFxkKykoPzo6KFxcZCspKT9cXCk/XFxzKiQvaTtcbnZhciBnZWNrb0V2YWwgPSAvKFxcUyspIGxpbmUgKFxcZCspKD86ID4gZXZhbCBsaW5lIFxcZCspKiA+IGV2YWwvaTtcbnZhciBjaHJvbWVFdmFsID0gL1xcKChcXFMqKSg/OjooXFxkKykpKD86OihcXGQrKSlcXCkvO1xuLy8gQmFzZWQgb24gb3VyIG93biBtYXBwaW5nIHBhdHRlcm4gLSBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS9ibG9iLzlmMDgzMDVlMDk4NjZjOGJkNmQwYzI0ZjViMGFhYmRkN2RkNmM1OWMvc3JjL3NlbnRyeS9sYW5nL2phdmFzY3JpcHQvZXJyb3JtYXBwaW5nLnB5I0w4My1MMTA4XG52YXIgcmVhY3RNaW5pZmllZFJlZ2V4cCA9IC9NaW5pZmllZCBSZWFjdCBlcnJvciAjXFxkKzsvaTtcbi8qKiBKU0RvYyAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmZ1bmN0aW9uIGNvbXB1dGVTdGFja1RyYWNlKGV4KSB7XG4gICAgdmFyIHN0YWNrID0gbnVsbDtcbiAgICB2YXIgcG9wU2l6ZSA9IDA7XG4gICAgaWYgKGV4KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXguZnJhbWVzVG9Qb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBwb3BTaXplID0gZXguZnJhbWVzVG9Qb3A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVhY3RNaW5pZmllZFJlZ2V4cC50ZXN0KGV4Lm1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBwb3BTaXplID0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIG11c3QgYmUgdHJpZWQgZmlyc3QgYmVjYXVzZSBPcGVyYSAxMCAqZGVzdHJveXMqXG4gICAgICAgIC8vIGl0cyBzdGFja3RyYWNlIHByb3BlcnR5IGlmIHlvdSB0cnkgdG8gYWNjZXNzIHRoZSBzdGFja1xuICAgICAgICAvLyBwcm9wZXJ0eSBmaXJzdCEhXG4gICAgICAgIHN0YWNrID0gY29tcHV0ZVN0YWNrVHJhY2VGcm9tU3RhY2t0cmFjZVByb3AoZXgpO1xuICAgICAgICBpZiAoc3RhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBwb3BGcmFtZXMoc3RhY2ssIHBvcFNpemUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIG5vLWVtcHR5XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHN0YWNrID0gY29tcHV0ZVN0YWNrVHJhY2VGcm9tU3RhY2tQcm9wKGV4KTtcbiAgICAgICAgaWYgKHN0YWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9wRnJhbWVzKHN0YWNrLCBwb3BTaXplKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBuby1lbXB0eVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBtZXNzYWdlOiBleHRyYWN0TWVzc2FnZShleCksXG4gICAgICAgIG5hbWU6IGV4ICYmIGV4Lm5hbWUsXG4gICAgICAgIHN0YWNrOiBbXSxcbiAgICAgICAgZmFpbGVkOiB0cnVlLFxuICAgIH07XG59XG5leHBvcnRzLmNvbXB1dGVTdGFja1RyYWNlID0gY29tcHV0ZVN0YWNrVHJhY2U7XG4vKiogSlNEb2MgKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBjb21wbGV4aXR5XG5mdW5jdGlvbiBjb21wdXRlU3RhY2tUcmFjZUZyb21TdGFja1Byb3AoZXgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICghZXggfHwgIWV4LnN0YWNrKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICB2YXIgbGluZXMgPSBleC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgdmFyIGlzRXZhbDtcbiAgICB2YXIgc3VibWF0Y2g7XG4gICAgdmFyIHBhcnRzO1xuICAgIHZhciBlbGVtZW50O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKChwYXJ0cyA9IGNocm9tZS5leGVjKGxpbmVzW2ldKSkpIHtcbiAgICAgICAgICAgIHZhciBpc05hdGl2ZSA9IHBhcnRzWzJdICYmIHBhcnRzWzJdLmluZGV4T2YoJ25hdGl2ZScpID09PSAwOyAvLyBzdGFydCBvZiBsaW5lXG4gICAgICAgICAgICBpc0V2YWwgPSBwYXJ0c1syXSAmJiBwYXJ0c1syXS5pbmRleE9mKCdldmFsJykgPT09IDA7IC8vIHN0YXJ0IG9mIGxpbmVcbiAgICAgICAgICAgIGlmIChpc0V2YWwgJiYgKHN1Ym1hdGNoID0gY2hyb21lRXZhbC5leGVjKHBhcnRzWzJdKSkpIHtcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBvdXQgZXZhbCBsaW5lL2NvbHVtbiBhbmQgdXNlIHRvcC1tb3N0IGxpbmUvY29sdW1uIG51bWJlclxuICAgICAgICAgICAgICAgIHBhcnRzWzJdID0gc3VibWF0Y2hbMV07IC8vIHVybFxuICAgICAgICAgICAgICAgIHBhcnRzWzNdID0gc3VibWF0Y2hbMl07IC8vIGxpbmVcbiAgICAgICAgICAgICAgICBwYXJ0c1s0XSA9IHN1Ym1hdGNoWzNdOyAvLyBjb2x1bW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFycGFkOiBXb3JraW5nIHdpdGggdGhlIHJlZ2V4cCBhYm92ZSBpcyBzdXBlciBwYWluZnVsLiBpdCBpcyBxdWl0ZSBhIGhhY2ssIGJ1dCBqdXN0IHN0cmlwcGluZyB0aGUgYGFkZHJlc3MgYXQgYFxuICAgICAgICAgICAgLy8gcHJlZml4IGhlcmUgc2VlbXMgbGlrZSB0aGUgcXVpY2tlc3Qgc29sdXRpb24gZm9yIG5vdy5cbiAgICAgICAgICAgIHZhciB1cmwgPSBwYXJ0c1syXSAmJiBwYXJ0c1syXS5pbmRleE9mKCdhZGRyZXNzIGF0ICcpID09PSAwID8gcGFydHNbMl0uc3Vic3RyKCdhZGRyZXNzIGF0ICcubGVuZ3RoKSA6IHBhcnRzWzJdO1xuICAgICAgICAgICAgLy8gS2FtaWw6IE9uZSBtb3JlIGhhY2sgd29uJ3QgaHVydCB1cyByaWdodD8gVW5kZXJzdGFuZGluZyBhbmQgYWRkaW5nIG1vcmUgcnVsZXMgb24gdG9wIG9mIHRoZXNlIHJlZ2V4cHMgcmlnaHQgbm93XG4gICAgICAgICAgICAvLyB3b3VsZCBiZSB3YXkgdG9vIHRpbWUgY29uc3VtaW5nLiAoVE9ETzogUmV3cml0ZSB3aG9sZSBSZWdFeHAgdG8gYmUgbW9yZSByZWFkYWJsZSlcbiAgICAgICAgICAgIHZhciBmdW5jID0gcGFydHNbMV0gfHwgVU5LTk9XTl9GVU5DVElPTjtcbiAgICAgICAgICAgIF9hID0gdHNsaWJfMS5fX3JlYWQoZXh0cmFjdFNhZmFyaUV4dGVuc2lvbkRldGFpbHMoZnVuYywgdXJsKSwgMiksIGZ1bmMgPSBfYVswXSwgdXJsID0gX2FbMV07XG4gICAgICAgICAgICBlbGVtZW50ID0ge1xuICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgIGZ1bmM6IGZ1bmMsXG4gICAgICAgICAgICAgICAgYXJnczogaXNOYXRpdmUgPyBbcGFydHNbMl1dIDogW10sXG4gICAgICAgICAgICAgICAgbGluZTogcGFydHNbM10gPyArcGFydHNbM10gOiBudWxsLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogcGFydHNbNF0gPyArcGFydHNbNF0gOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgocGFydHMgPSB3aW5qcy5leGVjKGxpbmVzW2ldKSkpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiBwYXJ0c1syXSxcbiAgICAgICAgICAgICAgICBmdW5jOiBwYXJ0c1sxXSB8fCBVTktOT1dOX0ZVTkNUSU9OLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgIGxpbmU6ICtwYXJ0c1szXSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IHBhcnRzWzRdID8gK3BhcnRzWzRdIDogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHBhcnRzID0gZ2Vja28uZXhlYyhsaW5lc1tpXSkpKSB7XG4gICAgICAgICAgICBpc0V2YWwgPSBwYXJ0c1szXSAmJiBwYXJ0c1szXS5pbmRleE9mKCcgPiBldmFsJykgPiAtMTtcbiAgICAgICAgICAgIGlmIChpc0V2YWwgJiYgKHN1Ym1hdGNoID0gZ2Vja29FdmFsLmV4ZWMocGFydHNbM10pKSkge1xuICAgICAgICAgICAgICAgIC8vIHRocm93IG91dCBldmFsIGxpbmUvY29sdW1uIGFuZCB1c2UgdG9wLW1vc3QgbGluZSBudW1iZXJcbiAgICAgICAgICAgICAgICBwYXJ0c1sxXSA9IHBhcnRzWzFdIHx8IFwiZXZhbFwiO1xuICAgICAgICAgICAgICAgIHBhcnRzWzNdID0gc3VibWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgcGFydHNbNF0gPSBzdWJtYXRjaFsyXTtcbiAgICAgICAgICAgICAgICBwYXJ0c1s1XSA9ICcnOyAvLyBubyBjb2x1bW4gd2hlbiBldmFsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpID09PSAwICYmICFwYXJ0c1s1XSAmJiBleC5jb2x1bW5OdW1iZXIgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIC8vIEZpcmVGb3ggdXNlcyB0aGlzIGF3ZXNvbWUgY29sdW1uTnVtYmVyIHByb3BlcnR5IGZvciBpdHMgdG9wIGZyYW1lXG4gICAgICAgICAgICAgICAgLy8gQWxzbyBub3RlLCBGaXJlZm94J3MgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkIGFuZCBldmVyeXRoaW5nIGVsc2UgZXhwZWN0cyAxLWJhc2VkLFxuICAgICAgICAgICAgICAgIC8vIHNvIGFkZGluZyAxXG4gICAgICAgICAgICAgICAgLy8gTk9URTogdGhpcyBoYWNrIGRvZXNuJ3Qgd29yayBpZiB0b3AtbW9zdCBmcmFtZSBpcyBldmFsXG4gICAgICAgICAgICAgICAgc3RhY2tbMF0uY29sdW1uID0gZXguY29sdW1uTnVtYmVyICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB1cmwgPSBwYXJ0c1szXTtcbiAgICAgICAgICAgIHZhciBmdW5jID0gcGFydHNbMV0gfHwgVU5LTk9XTl9GVU5DVElPTjtcbiAgICAgICAgICAgIF9iID0gdHNsaWJfMS5fX3JlYWQoZXh0cmFjdFNhZmFyaUV4dGVuc2lvbkRldGFpbHMoZnVuYywgdXJsKSwgMiksIGZ1bmMgPSBfYlswXSwgdXJsID0gX2JbMV07XG4gICAgICAgICAgICBlbGVtZW50ID0ge1xuICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgIGZ1bmM6IGZ1bmMsXG4gICAgICAgICAgICAgICAgYXJnczogcGFydHNbMl0gPyBwYXJ0c1syXS5zcGxpdCgnLCcpIDogW10sXG4gICAgICAgICAgICAgICAgbGluZTogcGFydHNbNF0gPyArcGFydHNbNF0gOiBudWxsLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogcGFydHNbNV0gPyArcGFydHNbNV0gOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZWxlbWVudC5mdW5jICYmIGVsZW1lbnQubGluZSkge1xuICAgICAgICAgICAgZWxlbWVudC5mdW5jID0gVU5LTk9XTl9GVU5DVElPTjtcbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAoIXN0YWNrLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWVzc2FnZTogZXh0cmFjdE1lc3NhZ2UoZXgpLFxuICAgICAgICBuYW1lOiBleC5uYW1lLFxuICAgICAgICBzdGFjazogc3RhY2ssXG4gICAgfTtcbn1cbi8qKiBKU0RvYyAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGNvbXB1dGVTdGFja1RyYWNlRnJvbVN0YWNrdHJhY2VQcm9wKGV4KSB7XG4gICAgaWYgKCFleCB8fCAhZXguc3RhY2t0cmFjZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gQWNjZXNzIGFuZCBzdG9yZSB0aGUgc3RhY2t0cmFjZSBwcm9wZXJ0eSBiZWZvcmUgZG9pbmcgQU5ZVEhJTkdcbiAgICAvLyBlbHNlIHRvIGl0IGJlY2F1c2UgT3BlcmEgaXMgbm90IHZlcnkgZ29vZCBhdCBwcm92aWRpbmcgaXRcbiAgICAvLyByZWxpYWJseSBpbiBvdGhlciBjaXJjdW1zdGFuY2VzLlxuICAgIHZhciBzdGFja3RyYWNlID0gZXguc3RhY2t0cmFjZTtcbiAgICB2YXIgb3BlcmExMFJlZ2V4ID0gLyBsaW5lIChcXGQrKS4qc2NyaXB0ICg/OmluICk/KFxcUyspKD86OiBpbiBmdW5jdGlvbiAoXFxTKykpPyQvaTtcbiAgICB2YXIgb3BlcmExMVJlZ2V4ID0gLyBsaW5lIChcXGQrKSwgY29sdW1uIChcXGQrKVxccyooPzppbiAoPzo8YW5vbnltb3VzIGZ1bmN0aW9uOiAoW14+XSspPnwoW14pXSspKVxcKCguKilcXCkpPyBpbiAoLiopOlxccyokL2k7XG4gICAgdmFyIGxpbmVzID0gc3RhY2t0cmFjZS5zcGxpdCgnXFxuJyk7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIHBhcnRzO1xuICAgIGZvciAodmFyIGxpbmUgPSAwOyBsaW5lIDwgbGluZXMubGVuZ3RoOyBsaW5lICs9IDIpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBudWxsO1xuICAgICAgICBpZiAoKHBhcnRzID0gb3BlcmExMFJlZ2V4LmV4ZWMobGluZXNbbGluZV0pKSkge1xuICAgICAgICAgICAgZWxlbWVudCA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IHBhcnRzWzJdLFxuICAgICAgICAgICAgICAgIGZ1bmM6IHBhcnRzWzNdLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgIGxpbmU6ICtwYXJ0c1sxXSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChwYXJ0cyA9IG9wZXJhMTFSZWdleC5leGVjKGxpbmVzW2xpbmVdKSkpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiBwYXJ0c1s2XSxcbiAgICAgICAgICAgICAgICBmdW5jOiBwYXJ0c1szXSB8fCBwYXJ0c1s0XSxcbiAgICAgICAgICAgICAgICBhcmdzOiBwYXJ0c1s1XSA/IHBhcnRzWzVdLnNwbGl0KCcsJykgOiBbXSxcbiAgICAgICAgICAgICAgICBsaW5lOiArcGFydHNbMV0sXG4gICAgICAgICAgICAgICAgY29sdW1uOiArcGFydHNbMl0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQuZnVuYyAmJiBlbGVtZW50LmxpbmUpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmZ1bmMgPSBVTktOT1dOX0ZVTkNUSU9OO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXN0YWNrLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWVzc2FnZTogZXh0cmFjdE1lc3NhZ2UoZXgpLFxuICAgICAgICBuYW1lOiBleC5uYW1lLFxuICAgICAgICBzdGFjazogc3RhY2ssXG4gICAgfTtcbn1cbi8qKlxuICogU2FmYXJpIHdlYiBleHRlbnNpb25zLCBzdGFydGluZyB2ZXJzaW9uIHVua25vd24sIGNhbiBwcm9kdWNlIFwiZnJhbWVzLW9ubHlcIiBzdGFja3RyYWNlcy5cbiAqIFdoYXQgaXQgbWVhbnMsIGlzIHRoYXQgaW5zdGVhZCBvZiBmb3JtYXQgbGlrZTpcbiAqXG4gKiBFcnJvcjogd2F0XG4gKiAgIGF0IGZ1bmN0aW9uQHVybDpyb3c6Y29sXG4gKiAgIGF0IGZ1bmN0aW9uQHVybDpyb3c6Y29sXG4gKiAgIGF0IGZ1bmN0aW9uQHVybDpyb3c6Y29sXG4gKlxuICogaXQgcHJvZHVjZXMgc29tZXRoaW5nIGxpa2U6XG4gKlxuICogICBmdW5jdGlvbkB1cmw6cm93OmNvbFxuICogICBmdW5jdGlvbkB1cmw6cm93OmNvbFxuICogICBmdW5jdGlvbkB1cmw6cm93OmNvbFxuICpcbiAqIEJlY2F1c2Ugb2YgdGhhdCwgaXQgd29uJ3QgYmUgY2FwdHVyZWQgYnkgYGNocm9tZWAgUmVnRXhwIGFuZCB3aWxsIGZhbGwgaW50byBgR2Vja29gIGJyYW5jaC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgZXh0cmFjdGVkIHNvIHRoYXQgd2UgY2FuIHVzZSBpdCBpbiBib3RoIHBsYWNlcyB3aXRob3V0IGR1cGxpY2F0aW5nIHRoZSBsb2dpYy5cbiAqIFVuZm9ydHVuYXRlbGx5IFwianVzdFwiIGNoYW5naW5nIFJlZ0V4cCBpcyB0b28gY29tcGxpY2F0ZWQgbm93IGFuZCBtYWtpbmcgaXQgcGFzcyBhbGwgdGVzdHNcbiAqIGFuZCBmaXggdGhpcyBjYXNlIHNlZW1zIGxpa2UgYW4gaW1wb3NzaWJsZSwgb3IgYXQgbGVhc3Qgd2F5IHRvbyB0aW1lLWNvbnN1bWluZyB0YXNrLlxuICovXG52YXIgZXh0cmFjdFNhZmFyaUV4dGVuc2lvbkRldGFpbHMgPSBmdW5jdGlvbiAoZnVuYywgdXJsKSB7XG4gICAgdmFyIGlzU2FmYXJpRXh0ZW5zaW9uID0gZnVuYy5pbmRleE9mKCdzYWZhcmktZXh0ZW5zaW9uJykgIT09IC0xO1xuICAgIHZhciBpc1NhZmFyaVdlYkV4dGVuc2lvbiA9IGZ1bmMuaW5kZXhPZignc2FmYXJpLXdlYi1leHRlbnNpb24nKSAhPT0gLTE7XG4gICAgcmV0dXJuIGlzU2FmYXJpRXh0ZW5zaW9uIHx8IGlzU2FmYXJpV2ViRXh0ZW5zaW9uXG4gICAgICAgID8gW1xuICAgICAgICAgICAgZnVuYy5pbmRleE9mKCdAJykgIT09IC0xID8gZnVuYy5zcGxpdCgnQCcpWzBdIDogVU5LTk9XTl9GVU5DVElPTixcbiAgICAgICAgICAgIGlzU2FmYXJpRXh0ZW5zaW9uID8gXCJzYWZhcmktZXh0ZW5zaW9uOlwiICsgdXJsIDogXCJzYWZhcmktd2ViLWV4dGVuc2lvbjpcIiArIHVybCxcbiAgICAgICAgXVxuICAgICAgICA6IFtmdW5jLCB1cmxdO1xufTtcbi8qKiBSZW1vdmUgTiBudW1iZXIgb2YgZnJhbWVzIGZyb20gdGhlIHN0YWNrICovXG5mdW5jdGlvbiBwb3BGcmFtZXMoc3RhY2t0cmFjZSwgcG9wU2l6ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24oe30sIHN0YWNrdHJhY2UpLCB7IHN0YWNrOiBzdGFja3RyYWNlLnN0YWNrLnNsaWNlKHBvcFNpemUpIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gc3RhY2t0cmFjZTtcbiAgICB9XG59XG4vKipcbiAqIFRoZXJlIGFyZSBjYXNlcyB3aGVyZSBzdGFja3RyYWNlLm1lc3NhZ2UgaXMgYW4gRXZlbnQgb2JqZWN0XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0L2lzc3Vlcy8xOTQ5XG4gKiBJbiB0aGlzIHNwZWNpZmljIGNhc2Ugd2UgdHJ5IHRvIGV4dHJhY3Qgc3RhY2t0cmFjZS5tZXNzYWdlLmVycm9yLm1lc3NhZ2VcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGV4dHJhY3RNZXNzYWdlKGV4KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBleCAmJiBleC5tZXNzYWdlO1xuICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gJ05vIGVycm9yIG1lc3NhZ2UnO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5lcnJvciAmJiB0eXBlb2YgbWVzc2FnZS5lcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbWVzc2FnZS5lcnJvci5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYWNla2l0LmpzLm1hcCIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIkBzZW50cnkvdXRpbHNcIik7XG52YXIgdHJhY2VraXRfMSA9IHJlcXVpcmUoXCIuL3RyYWNla2l0XCIpO1xudmFyIFNUQUNLVFJBQ0VfTElNSVQgPSA1MDtcbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGFuIGV4Y2VwdGlvbiBmcm9tIGFuIFRyYWNlS2l0U3RhY2tUcmFjZVxuICogQHBhcmFtIHN0YWNrdHJhY2UgVHJhY2VLaXRTdGFja1RyYWNlIHRoYXQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYW4gZXhjZXB0aW9uXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGV4Y2VwdGlvbkZyb21TdGFja3RyYWNlKHN0YWNrdHJhY2UpIHtcbiAgICB2YXIgZnJhbWVzID0gcHJlcGFyZUZyYW1lc0ZvckV2ZW50KHN0YWNrdHJhY2Uuc3RhY2spO1xuICAgIHZhciBleGNlcHRpb24gPSB7XG4gICAgICAgIHR5cGU6IHN0YWNrdHJhY2UubmFtZSxcbiAgICAgICAgdmFsdWU6IHN0YWNrdHJhY2UubWVzc2FnZSxcbiAgICB9O1xuICAgIGlmIChmcmFtZXMgJiYgZnJhbWVzLmxlbmd0aCkge1xuICAgICAgICBleGNlcHRpb24uc3RhY2t0cmFjZSA9IHsgZnJhbWVzOiBmcmFtZXMgfTtcbiAgICB9XG4gICAgaWYgKGV4Y2VwdGlvbi50eXBlID09PSB1bmRlZmluZWQgJiYgZXhjZXB0aW9uLnZhbHVlID09PSAnJykge1xuICAgICAgICBleGNlcHRpb24udmFsdWUgPSAnVW5yZWNvdmVyYWJsZSBlcnJvciBjYXVnaHQnO1xuICAgIH1cbiAgICByZXR1cm4gZXhjZXB0aW9uO1xufVxuZXhwb3J0cy5leGNlcHRpb25Gcm9tU3RhY2t0cmFjZSA9IGV4Y2VwdGlvbkZyb21TdGFja3RyYWNlO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGV2ZW50RnJvbVBsYWluT2JqZWN0KGV4Y2VwdGlvbiwgc3ludGhldGljRXhjZXB0aW9uLCByZWplY3Rpb24pIHtcbiAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgIGV4Y2VwdGlvbjoge1xuICAgICAgICAgICAgdmFsdWVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB1dGlsc18xLmlzRXZlbnQoZXhjZXB0aW9uKSA/IGV4Y2VwdGlvbi5jb25zdHJ1Y3Rvci5uYW1lIDogcmVqZWN0aW9uID8gJ1VuaGFuZGxlZFJlamVjdGlvbicgOiAnRXJyb3InLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJOb24tRXJyb3IgXCIgKyAocmVqZWN0aW9uID8gJ3Byb21pc2UgcmVqZWN0aW9uJyA6ICdleGNlcHRpb24nKSArIFwiIGNhcHR1cmVkIHdpdGgga2V5czogXCIgKyB1dGlsc18xLmV4dHJhY3RFeGNlcHRpb25LZXlzRm9yTWVzc2FnZShleGNlcHRpb24pLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICBleHRyYToge1xuICAgICAgICAgICAgX19zZXJpYWxpemVkX186IHV0aWxzXzEubm9ybWFsaXplVG9TaXplKGV4Y2VwdGlvbiksXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBpZiAoc3ludGhldGljRXhjZXB0aW9uKSB7XG4gICAgICAgIHZhciBzdGFja3RyYWNlID0gdHJhY2VraXRfMS5jb21wdXRlU3RhY2tUcmFjZShzeW50aGV0aWNFeGNlcHRpb24pO1xuICAgICAgICB2YXIgZnJhbWVzXzEgPSBwcmVwYXJlRnJhbWVzRm9yRXZlbnQoc3RhY2t0cmFjZS5zdGFjayk7XG4gICAgICAgIGV2ZW50LnN0YWNrdHJhY2UgPSB7XG4gICAgICAgICAgICBmcmFtZXM6IGZyYW1lc18xLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnQ7XG59XG5leHBvcnRzLmV2ZW50RnJvbVBsYWluT2JqZWN0ID0gZXZlbnRGcm9tUGxhaW5PYmplY3Q7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gZXZlbnRGcm9tU3RhY2t0cmFjZShzdGFja3RyYWNlKSB7XG4gICAgdmFyIGV4Y2VwdGlvbiA9IGV4Y2VwdGlvbkZyb21TdGFja3RyYWNlKHN0YWNrdHJhY2UpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGV4Y2VwdGlvbjoge1xuICAgICAgICAgICAgdmFsdWVzOiBbZXhjZXB0aW9uXSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0cy5ldmVudEZyb21TdGFja3RyYWNlID0gZXZlbnRGcm9tU3RhY2t0cmFjZTtcbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBwcmVwYXJlRnJhbWVzRm9yRXZlbnQoc3RhY2spIHtcbiAgICBpZiAoIXN0YWNrIHx8ICFzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB2YXIgbG9jYWxTdGFjayA9IHN0YWNrO1xuICAgIHZhciBmaXJzdEZyYW1lRnVuY3Rpb24gPSBsb2NhbFN0YWNrWzBdLmZ1bmMgfHwgJyc7XG4gICAgdmFyIGxhc3RGcmFtZUZ1bmN0aW9uID0gbG9jYWxTdGFja1tsb2NhbFN0YWNrLmxlbmd0aCAtIDFdLmZ1bmMgfHwgJyc7XG4gICAgLy8gSWYgc3RhY2sgc3RhcnRzIHdpdGggb25lIG9mIG91ciBBUEkgY2FsbHMsIHJlbW92ZSBpdCAoc3RhcnRzLCBtZWFuaW5nIGl0J3MgdGhlIHRvcCBvZiB0aGUgc3RhY2sgLSBha2EgbGFzdCBjYWxsKVxuICAgIGlmIChmaXJzdEZyYW1lRnVuY3Rpb24uaW5kZXhPZignY2FwdHVyZU1lc3NhZ2UnKSAhPT0gLTEgfHwgZmlyc3RGcmFtZUZ1bmN0aW9uLmluZGV4T2YoJ2NhcHR1cmVFeGNlcHRpb24nKSAhPT0gLTEpIHtcbiAgICAgICAgbG9jYWxTdGFjayA9IGxvY2FsU3RhY2suc2xpY2UoMSk7XG4gICAgfVxuICAgIC8vIElmIHN0YWNrIGVuZHMgd2l0aCBvbmUgb2Ygb3VyIGludGVybmFsIEFQSSBjYWxscywgcmVtb3ZlIGl0IChlbmRzLCBtZWFuaW5nIGl0J3MgdGhlIGJvdHRvbSBvZiB0aGUgc3RhY2sgLSBha2EgdG9wLW1vc3QgY2FsbClcbiAgICBpZiAobGFzdEZyYW1lRnVuY3Rpb24uaW5kZXhPZignc2VudHJ5V3JhcHBlZCcpICE9PSAtMSkge1xuICAgICAgICBsb2NhbFN0YWNrID0gbG9jYWxTdGFjay5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIC8vIFRoZSBmcmFtZSB3aGVyZSB0aGUgY3Jhc2ggaGFwcGVuZWQsIHNob3VsZCBiZSB0aGUgbGFzdCBlbnRyeSBpbiB0aGUgYXJyYXlcbiAgICByZXR1cm4gbG9jYWxTdGFja1xuICAgICAgICAuc2xpY2UoMCwgU1RBQ0tUUkFDRV9MSU1JVClcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoZnJhbWUpIHsgcmV0dXJuICh7XG4gICAgICAgIGNvbG5vOiBmcmFtZS5jb2x1bW4gPT09IG51bGwgPyB1bmRlZmluZWQgOiBmcmFtZS5jb2x1bW4sXG4gICAgICAgIGZpbGVuYW1lOiBmcmFtZS51cmwgfHwgbG9jYWxTdGFja1swXS51cmwsXG4gICAgICAgIGZ1bmN0aW9uOiBmcmFtZS5mdW5jIHx8ICc/JyxcbiAgICAgICAgaW5fYXBwOiB0cnVlLFxuICAgICAgICBsaW5lbm86IGZyYW1lLmxpbmUgPT09IG51bGwgPyB1bmRlZmluZWQgOiBmcmFtZS5saW5lLFxuICAgIH0pOyB9KVxuICAgICAgICAucmV2ZXJzZSgpO1xufVxuZXhwb3J0cy5wcmVwYXJlRnJhbWVzRm9yRXZlbnQgPSBwcmVwYXJlRnJhbWVzRm9yRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZXJzLmpzLm1hcCIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCJAc2VudHJ5L2NvcmVcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCJAc2VudHJ5L3R5cGVzXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiQHNlbnRyeS91dGlsc1wiKTtcbnZhciBldmVudGJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL2V2ZW50YnVpbGRlclwiKTtcbnZhciB0cmFuc3BvcnRzXzEgPSByZXF1aXJlKFwiLi90cmFuc3BvcnRzXCIpO1xuLyoqXG4gKiBUaGUgU2VudHJ5IEJyb3dzZXIgU0RLIEJhY2tlbmQuXG4gKiBAaGlkZGVuXG4gKi9cbnZhciBCcm93c2VyQmFja2VuZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhCcm93c2VyQmFja2VuZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCcm93c2VyQmFja2VuZCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIEJyb3dzZXJCYWNrZW5kLnByb3RvdHlwZS5ldmVudEZyb21FeGNlcHRpb24gPSBmdW5jdGlvbiAoZXhjZXB0aW9uLCBoaW50KSB7XG4gICAgICAgIHJldHVybiBldmVudGJ1aWxkZXJfMS5ldmVudEZyb21FeGNlcHRpb24odGhpcy5fb3B0aW9ucywgZXhjZXB0aW9uLCBoaW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgQnJvd3NlckJhY2tlbmQucHJvdG90eXBlLmV2ZW50RnJvbU1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSwgbGV2ZWwsIGhpbnQpIHtcbiAgICAgICAgaWYgKGxldmVsID09PSB2b2lkIDApIHsgbGV2ZWwgPSB0eXBlc18xLlNldmVyaXR5LkluZm87IH1cbiAgICAgICAgcmV0dXJuIGV2ZW50YnVpbGRlcl8xLmV2ZW50RnJvbU1lc3NhZ2UodGhpcy5fb3B0aW9ucywgbWVzc2FnZSwgbGV2ZWwsIGhpbnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBCcm93c2VyQmFja2VuZC5wcm90b3R5cGUuX3NldHVwVHJhbnNwb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX29wdGlvbnMuZHNuKSB7XG4gICAgICAgICAgICAvLyBXZSByZXR1cm4gdGhlIG5vb3AgdHJhbnNwb3J0IGhlcmUgaW4gY2FzZSB0aGVyZSBpcyBubyBEc24uXG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5fc2V0dXBUcmFuc3BvcnQuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHJhbnNwb3J0T3B0aW9ucyA9IHRzbGliXzEuX19hc3NpZ24odHNsaWJfMS5fX2Fzc2lnbih7fSwgdGhpcy5fb3B0aW9ucy50cmFuc3BvcnRPcHRpb25zKSwgeyBkc246IHRoaXMuX29wdGlvbnMuZHNuLCB0dW5uZWw6IHRoaXMuX29wdGlvbnMudHVubmVsLCBzZW5kQ2xpZW50UmVwb3J0czogdGhpcy5fb3B0aW9ucy5zZW5kQ2xpZW50UmVwb3J0cywgX21ldGFkYXRhOiB0aGlzLl9vcHRpb25zLl9tZXRhZGF0YSB9KTtcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMudHJhbnNwb3J0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuX29wdGlvbnMudHJhbnNwb3J0KHRyYW5zcG9ydE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1dGlsc18xLnN1cHBvcnRzRmV0Y2goKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0cmFuc3BvcnRzXzEuRmV0Y2hUcmFuc3BvcnQodHJhbnNwb3J0T3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyB0cmFuc3BvcnRzXzEuWEhSVHJhbnNwb3J0KHRyYW5zcG9ydE9wdGlvbnMpO1xuICAgIH07XG4gICAgcmV0dXJuIEJyb3dzZXJCYWNrZW5kO1xufShjb3JlXzEuQmFzZUJhY2tlbmQpKTtcbmV4cG9ydHMuQnJvd3NlckJhY2tlbmQgPSBCcm93c2VyQmFja2VuZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhY2tlbmQuanMubWFwIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSA/IHNldFByb3RvT2YgOiBtaXhpblByb3BlcnRpZXMpO1xuLyoqXG4gKiBzZXRQcm90b3R5cGVPZiBwb2x5ZmlsbCB1c2luZyBfX3Byb3RvX19cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbmZ1bmN0aW9uIHNldFByb3RvT2Yob2JqLCBwcm90bykge1xuICAgIC8vIEB0cy1pZ25vcmUgX19wcm90b19fIGRvZXMgbm90IGV4aXN0IG9uIG9ialxuICAgIG9iai5fX3Byb3RvX18gPSBwcm90bztcbiAgICByZXR1cm4gb2JqO1xufVxuLyoqXG4gKiBzZXRQcm90b3R5cGVPZiBwb2x5ZmlsbCB1c2luZyBtaXhpblxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuZnVuY3Rpb24gbWl4aW5Qcm9wZXJ0aWVzKG9iaiwgcHJvdG8pIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIHByb3RvKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdHlwZXNjcmlwdCBjb21wbGFpbnMgYWJvdXQgaW5kZXhpbmcgc28gd2UgcmVtb3ZlXG4gICAgICAgICAgICBvYmpbcHJvcF0gPSBwcm90b1twcm9wXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9seWZpbGwuanMubWFwIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiQHNlbnRyeS91dGlsc1wiKTtcbnZhciBnbG9iYWwgPSB1dGlsc18xLmdldEdsb2JhbE9iamVjdCgpO1xudmFyIGNhY2hlZEZldGNoSW1wbDtcbi8qKlxuICogQSBzcGVjaWFsIHVzZWNhc2UgZm9yIGluY29ycmVjdGx5IHdyYXBwZWQgRmV0Y2ggQVBJcyBpbiBjb25qdW5jdGlvbiB3aXRoIGFkLWJsb2NrZXJzLlxuICogV2hlbmV2ZXIgc29tZW9uZSB3cmFwcyB0aGUgRmV0Y2ggQVBJIGFuZCByZXR1cm5zIHRoZSB3cm9uZyBwcm9taXNlIGNoYWluLFxuICogdGhpcyBjaGFpbiBiZWNvbWVzIG9ycGhhbmVkIGFuZCB0aGVyZSBpcyBubyBwb3NzaWJsZSB3YXkgdG8gY2FwdHVyZSBpdCdzIHJlamVjdGlvbnNcbiAqIG90aGVyIHRoYW4gYWxsb3dpbmcgaXQgYnViYmxlIHVwIHRvIHRoaXMgdmVyeSBoYW5kbGVyLiBlZy5cbiAqXG4gKiBjb25zdCBmID0gd2luZG93LmZldGNoO1xuICogd2luZG93LmZldGNoID0gZnVuY3Rpb24gKCkge1xuICogICBjb25zdCBwID0gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICpcbiAqICAgcC50aGVuKGZ1bmN0aW9uKCkge1xuICogICAgIGNvbnNvbGUubG9nKCdoaS4nKTtcbiAqICAgfSk7XG4gKlxuICogICByZXR1cm4gcDtcbiAqIH1cbiAqXG4gKiBgcC50aGVuKGZ1bmN0aW9uICgpIHsgLi4uIH0pYCBpcyBwcm9kdWNpbmcgYSBjb21wbGV0ZWx5IHNlcGFyYXRlIHByb21pc2UgY2hhaW4sXG4gKiBob3dldmVyLCB3aGF0J3MgcmV0dXJuZWQgaXMgYHBgIC0gdGhlIHJlc3VsdCBvZiBvcmlnaW5hbCBgZmV0Y2hgIGNhbGwuXG4gKlxuICogVGhpcyBtZWFuLCB0aGF0IHdoZW5ldmVyIHdlIHVzZSB0aGUgRmV0Y2ggQVBJIHRvIHNlbmQgb3VyIG93biByZXF1ZXN0cywgX2FuZF9cbiAqIHNvbWUgYWQtYmxvY2tlciBibG9ja3MgaXQsIHRoaXMgb3JwaGFuZWQgY2hhaW4gd2lsbCBfYWx3YXlzXyByZWplY3QsXG4gKiBlZmZlY3RpdmVseSBjYXVzaW5nIGFub3RoZXIgZXZlbnQgdG8gYmUgY2FwdHVyZWQuXG4gKiBUaGlzIG1ha2VzIGEgd2hvbGUgcHJvY2VzcyBiZWNvbWUgYW4gaW5maW5pdGUgbG9vcCwgd2hpY2ggd2UgbmVlZCB0byBzb21laG93XG4gKiBkZWFsIHdpdGgsIGFuZCBicmVhayBpdCBpbiBvbmUgd2F5IG9yIGFub3RoZXIuXG4gKlxuICogVG8gZGVhbCB3aXRoIHRoaXMgaXNzdWUsIHdlIGFyZSBtYWtpbmcgc3VyZSB0aGF0IHdlIF9hbHdheXNfIHVzZSB0aGUgcmVhbFxuICogYnJvd3NlciBGZXRjaCBBUEksIGluc3RlYWQgb2YgcmVseWluZyBvbiB3aGF0IGB3aW5kb3cuZmV0Y2hgIGV4cG9zZXMuXG4gKiBUaGUgb25seSBkb3duc2lkZSB0byB0aGlzIHdvdWxkIGJlIG1pc3Npbmcgb3VyIG93biByZXF1ZXN0cyBhcyBicmVhZGNydW1icyxcbiAqIGJ1dCBiZWNhdXNlIHdlIGFyZSBhbHJlYWR5IG5vdCBkb2luZyB0aGlzLCBpdCBzaG91bGQgYmUganVzdCBmaW5lLlxuICpcbiAqIFBvc3NpYmxlIGZhaWxlZCBmZXRjaCBlcnJvciBtZXNzYWdlcyBwZXItYnJvd3NlcjpcbiAqXG4gKiBDaHJvbWU6ICBGYWlsZWQgdG8gZmV0Y2hcbiAqIEVkZ2U6ICAgIEZhaWxlZCB0byBGZXRjaFxuICogRmlyZWZveDogTmV0d29ya0Vycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBmZXRjaCByZXNvdXJjZVxuICogU2FmYXJpOiAgcmVzb3VyY2UgYmxvY2tlZCBieSBjb250ZW50IGJsb2NrZXJcbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlRmV0Y2hJbXBsZW1lbnRhdGlvbigpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmIChjYWNoZWRGZXRjaEltcGwpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZEZldGNoSW1wbDtcbiAgICB9XG4gICAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kICovXG4gICAgLy8gRmFzdCBwYXRoIHRvIGF2b2lkIERPTSBJL09cbiAgICBpZiAodXRpbHNfMS5pc05hdGl2ZUZldGNoKGdsb2JhbC5mZXRjaCkpIHtcbiAgICAgICAgcmV0dXJuIChjYWNoZWRGZXRjaEltcGwgPSBnbG9iYWwuZmV0Y2guYmluZChnbG9iYWwpKTtcbiAgICB9XG4gICAgdmFyIGRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciBmZXRjaEltcGwgPSBnbG9iYWwuZmV0Y2g7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgaWYgKHR5cGVvZiAoKF9hID0gZG9jdW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jcmVhdGVFbGVtZW50KSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgc2FuZGJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICAgICAgc2FuZGJveC5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzYW5kYm94KTtcbiAgICAgICAgICAgIGlmICgoX2IgPSBzYW5kYm94LmNvbnRlbnRXaW5kb3cpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5mZXRjaCkge1xuICAgICAgICAgICAgICAgIGZldGNoSW1wbCA9IHNhbmRib3guY29udGVudFdpbmRvdy5mZXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvY3VtZW50LmhlYWQucmVtb3ZlQ2hpbGQoc2FuZGJveCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHV0aWxzXzEubG9nZ2VyLndhcm4oJ0NvdWxkIG5vdCBjcmVhdGUgc2FuZGJveCBpZnJhbWUgZm9yIHB1cmUgZmV0Y2ggY2hlY2ssIGJhaWxpbmcgdG8gd2luZG93LmZldGNoOiAnLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKGNhY2hlZEZldGNoSW1wbCA9IGZldGNoSW1wbC5iaW5kKGdsb2JhbCkpO1xuICAgIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kICovXG59XG5leHBvcnRzLmdldE5hdGl2ZUZldGNoSW1wbGVtZW50YXRpb24gPSBnZXROYXRpdmVGZXRjaEltcGxlbWVudGF0aW9uO1xuLyoqXG4gKiBTZW5kcyBzZGsgY2xpZW50IHJlcG9ydCB1c2luZyBzZW5kQmVhY29uIG9yIGZldGNoIGFzIGEgZmFsbGJhY2sgaWYgYXZhaWxhYmxlXG4gKlxuICogQHBhcmFtIHVybCByZXBvcnQgZW5kcG9pbnRcbiAqIEBwYXJhbSBib2R5IHJlcG9ydCBwYXlsb2FkXG4gKi9cbmZ1bmN0aW9uIHNlbmRSZXBvcnQodXJsLCBib2R5KSB7XG4gICAgdmFyIGlzUmVhbE5hdmlnYXRvciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChnbG9iYWwgJiYgZ2xvYmFsLm5hdmlnYXRvcikgPT09ICdbb2JqZWN0IE5hdmlnYXRvcl0nO1xuICAgIHZhciBoYXNTZW5kQmVhY29uID0gaXNSZWFsTmF2aWdhdG9yICYmIHR5cGVvZiBnbG9iYWwubmF2aWdhdG9yLnNlbmRCZWFjb24gPT09ICdmdW5jdGlvbic7XG4gICAgaWYgKGhhc1NlbmRCZWFjb24pIHtcbiAgICAgICAgLy8gUHJldmVudCBpbGxlZ2FsIGludm9jYXRpb25zIC0gaHR0cHM6Ly94Z3dhbmcubWUvcG9zdHMveW91LW1heS1ub3Qta25vdy1iZWFjb24vI2l0LW1heS10aHJvdy1lcnJvciUyQy1iZS1zdXJlLXRvLWNhdGNoXG4gICAgICAgIHZhciBzZW5kQmVhY29uID0gZ2xvYmFsLm5hdmlnYXRvci5zZW5kQmVhY29uLmJpbmQoZ2xvYmFsLm5hdmlnYXRvcik7XG4gICAgICAgIHJldHVybiBzZW5kQmVhY29uKHVybCwgYm9keSk7XG4gICAgfVxuICAgIGlmICh1dGlsc18xLnN1cHBvcnRzRmV0Y2goKSkge1xuICAgICAgICB2YXIgZmV0Y2hfMSA9IGdldE5hdGl2ZUZldGNoSW1wbGVtZW50YXRpb24oKTtcbiAgICAgICAgcmV0dXJuIHV0aWxzXzEuZm9yZ2V0KGZldGNoXzEodXJsLCB7XG4gICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBjcmVkZW50aWFsczogJ29taXQnLFxuICAgICAgICAgICAga2VlcGFsaXZlOiB0cnVlLFxuICAgICAgICB9KSk7XG4gICAgfVxufVxuZXhwb3J0cy5zZW5kUmVwb3J0ID0gc2VuZFJlcG9ydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGh1Yl8xID0gcmVxdWlyZShcIkBzZW50cnkvaHViXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiQHNlbnRyeS91dGlsc1wiKTtcbmV4cG9ydHMuaW5zdGFsbGVkSW50ZWdyYXRpb25zID0gW107XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGZpbHRlckR1cGxpY2F0ZXMoaW50ZWdyYXRpb25zKSB7XG4gICAgcmV0dXJuIGludGVncmF0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgaW50ZWdyYXRpb25zKSB7XG4gICAgICAgIGlmIChhY2MuZXZlcnkoZnVuY3Rpb24gKGFjY0ludGVncmF0aW9uKSB7IHJldHVybiBpbnRlZ3JhdGlvbnMubmFtZSAhPT0gYWNjSW50ZWdyYXRpb24ubmFtZTsgfSkpIHtcbiAgICAgICAgICAgIGFjYy5wdXNoKGludGVncmF0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG59XG4vKiogR2V0cyBpbnRlZ3JhdGlvbiB0byBpbnN0YWxsICovXG5mdW5jdGlvbiBnZXRJbnRlZ3JhdGlvbnNUb1NldHVwKG9wdGlvbnMpIHtcbiAgICB2YXIgZGVmYXVsdEludGVncmF0aW9ucyA9IChvcHRpb25zLmRlZmF1bHRJbnRlZ3JhdGlvbnMgJiYgdHNsaWJfMS5fX3NwcmVhZChvcHRpb25zLmRlZmF1bHRJbnRlZ3JhdGlvbnMpKSB8fCBbXTtcbiAgICB2YXIgdXNlckludGVncmF0aW9ucyA9IG9wdGlvbnMuaW50ZWdyYXRpb25zO1xuICAgIHZhciBpbnRlZ3JhdGlvbnMgPSB0c2xpYl8xLl9fc3ByZWFkKGZpbHRlckR1cGxpY2F0ZXMoZGVmYXVsdEludGVncmF0aW9ucykpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHVzZXJJbnRlZ3JhdGlvbnMpKSB7XG4gICAgICAgIC8vIEZpbHRlciBvdXQgaW50ZWdyYXRpb25zIHRoYXQgYXJlIGFsc28gaW5jbHVkZWQgaW4gdXNlciBvcHRpb25zXG4gICAgICAgIGludGVncmF0aW9ucyA9IHRzbGliXzEuX19zcHJlYWQoaW50ZWdyYXRpb25zLmZpbHRlcihmdW5jdGlvbiAoaW50ZWdyYXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlckludGVncmF0aW9ucy5ldmVyeShmdW5jdGlvbiAodXNlckludGVncmF0aW9uKSB7IHJldHVybiB1c2VySW50ZWdyYXRpb24ubmFtZSAhPT0gaW50ZWdyYXRpb25zLm5hbWU7IH0pO1xuICAgICAgICB9KSwgZmlsdGVyRHVwbGljYXRlcyh1c2VySW50ZWdyYXRpb25zKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB1c2VySW50ZWdyYXRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGludGVncmF0aW9ucyA9IHVzZXJJbnRlZ3JhdGlvbnMoaW50ZWdyYXRpb25zKTtcbiAgICAgICAgaW50ZWdyYXRpb25zID0gQXJyYXkuaXNBcnJheShpbnRlZ3JhdGlvbnMpID8gaW50ZWdyYXRpb25zIDogW2ludGVncmF0aW9uc107XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGlmIHByZXNlbnQsIGBEZWJ1Z2AgaW50ZWdyYXRpb24gd2lsbCBhbHdheXMgcnVuIGxhc3RcbiAgICB2YXIgaW50ZWdyYXRpb25zTmFtZXMgPSBpbnRlZ3JhdGlvbnMubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBpLm5hbWU7IH0pO1xuICAgIHZhciBhbHdheXNMYXN0VG9SdW4gPSAnRGVidWcnO1xuICAgIGlmIChpbnRlZ3JhdGlvbnNOYW1lcy5pbmRleE9mKGFsd2F5c0xhc3RUb1J1bikgIT09IC0xKSB7XG4gICAgICAgIGludGVncmF0aW9ucy5wdXNoLmFwcGx5KGludGVncmF0aW9ucywgdHNsaWJfMS5fX3NwcmVhZChpbnRlZ3JhdGlvbnMuc3BsaWNlKGludGVncmF0aW9uc05hbWVzLmluZGV4T2YoYWx3YXlzTGFzdFRvUnVuKSwgMSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGludGVncmF0aW9ucztcbn1cbmV4cG9ydHMuZ2V0SW50ZWdyYXRpb25zVG9TZXR1cCA9IGdldEludGVncmF0aW9uc1RvU2V0dXA7XG4vKiogU2V0dXAgZ2l2ZW4gaW50ZWdyYXRpb24gKi9cbmZ1bmN0aW9uIHNldHVwSW50ZWdyYXRpb24oaW50ZWdyYXRpb24pIHtcbiAgICBpZiAoZXhwb3J0cy5pbnN0YWxsZWRJbnRlZ3JhdGlvbnMuaW5kZXhPZihpbnRlZ3JhdGlvbi5uYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnRlZ3JhdGlvbi5zZXR1cE9uY2UoaHViXzEuYWRkR2xvYmFsRXZlbnRQcm9jZXNzb3IsIGh1Yl8xLmdldEN1cnJlbnRIdWIpO1xuICAgIGV4cG9ydHMuaW5zdGFsbGVkSW50ZWdyYXRpb25zLnB1c2goaW50ZWdyYXRpb24ubmFtZSk7XG4gICAgdXRpbHNfMS5sb2dnZXIubG9nKFwiSW50ZWdyYXRpb24gaW5zdGFsbGVkOiBcIiArIGludGVncmF0aW9uLm5hbWUpO1xufVxuZXhwb3J0cy5zZXR1cEludGVncmF0aW9uID0gc2V0dXBJbnRlZ3JhdGlvbjtcbi8qKlxuICogR2l2ZW4gYSBsaXN0IG9mIGludGVncmF0aW9uIGluc3RhbmNlcyB0aGlzIGluc3RhbGxzIHRoZW0gYWxsLiBXaGVuIGB3aXRoRGVmYXVsdHNgIGlzIHNldCB0byBgdHJ1ZWAgdGhlbiBhbGwgZGVmYXVsdFxuICogaW50ZWdyYXRpb25zIGFyZSBhZGRlZCB1bmxlc3MgdGhleSB3ZXJlIGFscmVhZHkgcHJvdmlkZWQgYmVmb3JlLlxuICogQHBhcmFtIGludGVncmF0aW9ucyBhcnJheSBvZiBpbnRlZ3JhdGlvbiBpbnN0YW5jZXNcbiAqIEBwYXJhbSB3aXRoRGVmYXVsdCBzaG91bGQgZW5hYmxlIGRlZmF1bHQgaW50ZWdyYXRpb25zXG4gKi9cbmZ1bmN0aW9uIHNldHVwSW50ZWdyYXRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgaW50ZWdyYXRpb25zID0ge307XG4gICAgZ2V0SW50ZWdyYXRpb25zVG9TZXR1cChvcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlZ3JhdGlvbikge1xuICAgICAgICBpbnRlZ3JhdGlvbnNbaW50ZWdyYXRpb24ubmFtZV0gPSBpbnRlZ3JhdGlvbjtcbiAgICAgICAgc2V0dXBJbnRlZ3JhdGlvbihpbnRlZ3JhdGlvbik7XG4gICAgfSk7XG4gICAgLy8gc2V0IHRoZSBgaW5pdGlhbGl6ZWRgIGZsYWcgc28gd2UgZG9uJ3QgcnVuIHRocm91Z2ggdGhlIHByb2Nlc3MgYWdhaW4gdW5lY2Vzc2FyaWx5OyB1c2UgYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWBcbiAgICAvLyBiZWNhdXNlIGJ5IGRlZmF1bHQgaXQgY3JlYXRlcyBhIHByb3BlcnR5IHdoaWNoIGlzIG5vbmVudW1lcmFibGUsIHdoaWNoIHdlIHdhbnQgc2luY2UgYGluaXRpYWxpemVkYCBzaG91bGRuJ3QgYmVcbiAgICAvLyBjb25zaWRlcmVkIGEgbWVtYmVyIG9mIHRoZSBpbmRleCB0aGUgd2F5IHRoZSBhY3R1YWwgaW50ZWdyYXRpb25zIGFyZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnRlZ3JhdGlvbnMsICdpbml0aWFsaXplZCcsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgcmV0dXJuIGludGVncmF0aW9ucztcbn1cbmV4cG9ydHMuc2V0dXBJbnRlZ3JhdGlvbnMgPSBzZXR1cEludGVncmF0aW9ucztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVncmF0aW9uLmpzLm1hcCIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBvcmlnaW5hbEZ1bmN0aW9uVG9TdHJpbmc7XG4vKiogUGF0Y2ggdG9TdHJpbmcgY2FsbHMgdG8gcmV0dXJuIHByb3BlciBuYW1lIGZvciB3cmFwcGVkIGZ1bmN0aW9ucyAqL1xudmFyIEZ1bmN0aW9uVG9TdHJpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnVuY3Rpb25Ub1N0cmluZygpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbmhlcml0RG9jXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSBGdW5jdGlvblRvU3RyaW5nLmlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIEZ1bmN0aW9uVG9TdHJpbmcucHJvdG90eXBlLnNldHVwT25jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICBvcmlnaW5hbEZ1bmN0aW9uVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5fX3NlbnRyeV9vcmlnaW5hbF9fIHx8IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxGdW5jdGlvblRvU3RyaW5nLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBGdW5jdGlvblRvU3RyaW5nLmlkID0gJ0Z1bmN0aW9uVG9TdHJpbmcnO1xuICAgIHJldHVybiBGdW5jdGlvblRvU3RyaW5nO1xufSgpKTtcbmV4cG9ydHMuRnVuY3Rpb25Ub1N0cmluZyA9IEZ1bmN0aW9uVG9TdHJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mdW5jdGlvbnRvc3RyaW5nLmpzLm1hcCIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGh1Yl8xID0gcmVxdWlyZShcIkBzZW50cnkvaHViXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiQHNlbnRyeS91dGlsc1wiKTtcbi8vIFwiU2NyaXB0IGVycm9yLlwiIGlzIGhhcmQgY29kZWQgaW50byBicm93c2VycyBmb3IgZXJyb3JzIHRoYXQgaXQgY2FuJ3QgcmVhZC5cbi8vIHRoaXMgaXMgdGhlIHJlc3VsdCBvZiBhIHNjcmlwdCBiZWluZyBwdWxsZWQgaW4gZnJvbSBhbiBleHRlcm5hbCBkb21haW4gYW5kIENPUlMuXG52YXIgREVGQVVMVF9JR05PUkVfRVJST1JTID0gWy9eU2NyaXB0IGVycm9yXFwuPyQvLCAvXkphdmFzY3JpcHQgZXJyb3I6IFNjcmlwdCBlcnJvclxcLj8gb24gbGluZSAwJC9dO1xuLyoqIEluYm91bmQgZmlsdGVycyBjb25maWd1cmFibGUgYnkgdGhlIHVzZXIgKi9cbnZhciBJbmJvdW5kRmlsdGVycyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbmJvdW5kRmlsdGVycyhfb3B0aW9ucykge1xuICAgICAgICBpZiAoX29wdGlvbnMgPT09IHZvaWQgMCkgeyBfb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfb3B0aW9ucztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbmhlcml0RG9jXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSBJbmJvdW5kRmlsdGVycy5pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBJbmJvdW5kRmlsdGVycy5wcm90b3R5cGUuc2V0dXBPbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodWJfMS5hZGRHbG9iYWxFdmVudFByb2Nlc3NvcihmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBodWIgPSBodWJfMS5nZXRDdXJyZW50SHViKCk7XG4gICAgICAgICAgICBpZiAoIWh1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzZWxmID0gaHViLmdldEludGVncmF0aW9uKEluYm91bmRGaWx0ZXJzKTtcbiAgICAgICAgICAgIGlmIChzZWxmKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsaWVudCA9IGh1Yi5nZXRDbGllbnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgY2xpZW50T3B0aW9ucyA9IGNsaWVudCA/IGNsaWVudC5nZXRPcHRpb25zKCkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNoZWNrcyBwcmV2ZW50cyBtb3N0IG9mIHRoZSBvY2N1cnJlbmNlcyBvZiB0aGUgYnVnIGxpbmtlZCBiZWxvdzpcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0L2lzc3Vlcy8yNjIyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGJ1ZyBpcyBjYXVzZWQgYnkgbXVsdGlwbGUgU0RLIGluc3RhbmNlcywgd2hlcmUgb25lIGlzIG1pbmlmaWVkIGFuZCBvbmUgaXMgdXNpbmcgbm9uLW1hbmdsZWQgY29kZS5cbiAgICAgICAgICAgICAgICAvLyBVbmZvcnR1bmF0ZWxseSB3ZSBjYW5ub3QgZml4IGl0IHJlbGlhYmx5ICh0aHVzIHJlc2VydmVkIHByb3BlcnR5IGluIHJvbGx1cCdzIHRlcnNlciBjb25maWcpLFxuICAgICAgICAgICAgICAgIC8vIGFzIHdlIGNhbm5vdCBmb3JjZSBwZW9wbGUgdXNpbmcgbXVsdGlwbGUgaW5zdGFuY2VzIGluIHRoZWlyIGFwcHMgdG8gc3luYyBTREsgdmVyc2lvbnMuXG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2VsZi5fbWVyZ2VPcHRpb25zID09PSAnZnVuY3Rpb24nID8gc2VsZi5fbWVyZ2VPcHRpb25zKGNsaWVudE9wdGlvbnMpIDoge307XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLl9zaG91bGREcm9wRXZlbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fc2hvdWxkRHJvcEV2ZW50KGV2ZW50LCBvcHRpb25zKSA/IG51bGwgOiBldmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogSlNEb2MgKi9cbiAgICBJbmJvdW5kRmlsdGVycy5wcm90b3R5cGUuX3Nob3VsZERyb3BFdmVudCA9IGZ1bmN0aW9uIChldmVudCwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5faXNTZW50cnlFcnJvcihldmVudCwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgIHV0aWxzXzEubG9nZ2VyLndhcm4oXCJFdmVudCBkcm9wcGVkIGR1ZSB0byBiZWluZyBpbnRlcm5hbCBTZW50cnkgRXJyb3IuXFxuRXZlbnQ6IFwiICsgdXRpbHNfMS5nZXRFdmVudERlc2NyaXB0aW9uKGV2ZW50KSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faXNJZ25vcmVkRXJyb3IoZXZlbnQsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICB1dGlsc18xLmxvZ2dlci53YXJuKFwiRXZlbnQgZHJvcHBlZCBkdWUgdG8gYmVpbmcgbWF0Y2hlZCBieSBgaWdub3JlRXJyb3JzYCBvcHRpb24uXFxuRXZlbnQ6IFwiICsgdXRpbHNfMS5nZXRFdmVudERlc2NyaXB0aW9uKGV2ZW50KSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faXNEZW5pZWRVcmwoZXZlbnQsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICB1dGlsc18xLmxvZ2dlci53YXJuKFwiRXZlbnQgZHJvcHBlZCBkdWUgdG8gYmVpbmcgbWF0Y2hlZCBieSBgZGVueVVybHNgIG9wdGlvbi5cXG5FdmVudDogXCIgKyB1dGlsc18xLmdldEV2ZW50RGVzY3JpcHRpb24oZXZlbnQpICsgXCIuXFxuVXJsOiBcIiArIHRoaXMuX2dldEV2ZW50RmlsdGVyVXJsKGV2ZW50KSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2lzQWxsb3dlZFVybChldmVudCwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgIHV0aWxzXzEubG9nZ2VyLndhcm4oXCJFdmVudCBkcm9wcGVkIGR1ZSB0byBub3QgYmVpbmcgbWF0Y2hlZCBieSBgYWxsb3dVcmxzYCBvcHRpb24uXFxuRXZlbnQ6IFwiICsgdXRpbHNfMS5nZXRFdmVudERlc2NyaXB0aW9uKGV2ZW50KSArIFwiLlxcblVybDogXCIgKyB0aGlzLl9nZXRFdmVudEZpbHRlclVybChldmVudCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqIEpTRG9jICovXG4gICAgSW5ib3VuZEZpbHRlcnMucHJvdG90eXBlLl9pc1NlbnRyeUVycm9yID0gZnVuY3Rpb24gKGV2ZW50LCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5pZ25vcmVJbnRlcm5hbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gKChldmVudCAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmV4Y2VwdGlvbiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmV4Y2VwdGlvbi52YWx1ZXMgJiZcbiAgICAgICAgICAgICAgICBldmVudC5leGNlcHRpb24udmFsdWVzWzBdICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZXhjZXB0aW9uLnZhbHVlc1swXS50eXBlID09PSAnU2VudHJ5RXJyb3InKSB8fFxuICAgICAgICAgICAgICAgIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX29PKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBKU0RvYyAqL1xuICAgIEluYm91bmRGaWx0ZXJzLnByb3RvdHlwZS5faXNJZ25vcmVkRXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmlnbm9yZUVycm9ycyB8fCAhb3B0aW9ucy5pZ25vcmVFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFBvc3NpYmxlRXZlbnRNZXNzYWdlcyhldmVudCkuc29tZShmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgLy8gTm90IHN1cmUgd2h5IFR5cGVTY3JpcHQgY29tcGxhaW5zIGhlcmUuLi5cbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmlnbm9yZUVycm9ycy5zb21lKGZ1bmN0aW9uIChwYXR0ZXJuKSB7IHJldHVybiB1dGlsc18xLmlzTWF0Y2hpbmdQYXR0ZXJuKG1lc3NhZ2UsIHBhdHRlcm4pOyB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogSlNEb2MgKi9cbiAgICBJbmJvdW5kRmlsdGVycy5wcm90b3R5cGUuX2lzRGVuaWVkVXJsID0gZnVuY3Rpb24gKGV2ZW50LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIFRPRE86IFVzZSBHbG9iIGluc3RlYWQ/XG4gICAgICAgIGlmICghb3B0aW9ucy5kZW55VXJscyB8fCAhb3B0aW9ucy5kZW55VXJscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXJsID0gdGhpcy5fZ2V0RXZlbnRGaWx0ZXJVcmwoZXZlbnQpO1xuICAgICAgICByZXR1cm4gIXVybCA/IGZhbHNlIDogb3B0aW9ucy5kZW55VXJscy5zb21lKGZ1bmN0aW9uIChwYXR0ZXJuKSB7IHJldHVybiB1dGlsc18xLmlzTWF0Y2hpbmdQYXR0ZXJuKHVybCwgcGF0dGVybik7IH0pO1xuICAgIH07XG4gICAgLyoqIEpTRG9jICovXG4gICAgSW5ib3VuZEZpbHRlcnMucHJvdG90eXBlLl9pc0FsbG93ZWRVcmwgPSBmdW5jdGlvbiAoZXZlbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gVE9ETzogVXNlIEdsb2IgaW5zdGVhZD9cbiAgICAgICAgaWYgKCFvcHRpb25zLmFsbG93VXJscyB8fCAhb3B0aW9ucy5hbGxvd1VybHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXJsID0gdGhpcy5fZ2V0RXZlbnRGaWx0ZXJVcmwoZXZlbnQpO1xuICAgICAgICByZXR1cm4gIXVybCA/IHRydWUgOiBvcHRpb25zLmFsbG93VXJscy5zb21lKGZ1bmN0aW9uIChwYXR0ZXJuKSB7IHJldHVybiB1dGlsc18xLmlzTWF0Y2hpbmdQYXR0ZXJuKHVybCwgcGF0dGVybik7IH0pO1xuICAgIH07XG4gICAgLyoqIEpTRG9jICovXG4gICAgSW5ib3VuZEZpbHRlcnMucHJvdG90eXBlLl9tZXJnZU9wdGlvbnMgPSBmdW5jdGlvbiAoY2xpZW50T3B0aW9ucykge1xuICAgICAgICBpZiAoY2xpZW50T3B0aW9ucyA9PT0gdm9pZCAwKSB7IGNsaWVudE9wdGlvbnMgPSB7fTsgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWxsb3dVcmxzOiB0c2xpYl8xLl9fc3ByZWFkKCh0aGlzLl9vcHRpb25zLndoaXRlbGlzdFVybHMgfHwgW10pLCAodGhpcy5fb3B0aW9ucy5hbGxvd1VybHMgfHwgW10pLCAoY2xpZW50T3B0aW9ucy53aGl0ZWxpc3RVcmxzIHx8IFtdKSwgKGNsaWVudE9wdGlvbnMuYWxsb3dVcmxzIHx8IFtdKSksXG4gICAgICAgICAgICBkZW55VXJsczogdHNsaWJfMS5fX3NwcmVhZCgodGhpcy5fb3B0aW9ucy5ibGFja2xpc3RVcmxzIHx8IFtdKSwgKHRoaXMuX29wdGlvbnMuZGVueVVybHMgfHwgW10pLCAoY2xpZW50T3B0aW9ucy5ibGFja2xpc3RVcmxzIHx8IFtdKSwgKGNsaWVudE9wdGlvbnMuZGVueVVybHMgfHwgW10pKSxcbiAgICAgICAgICAgIGlnbm9yZUVycm9yczogdHNsaWJfMS5fX3NwcmVhZCgodGhpcy5fb3B0aW9ucy5pZ25vcmVFcnJvcnMgfHwgW10pLCAoY2xpZW50T3B0aW9ucy5pZ25vcmVFcnJvcnMgfHwgW10pLCBERUZBVUxUX0lHTk9SRV9FUlJPUlMpLFxuICAgICAgICAgICAgaWdub3JlSW50ZXJuYWw6IHR5cGVvZiB0aGlzLl9vcHRpb25zLmlnbm9yZUludGVybmFsICE9PSAndW5kZWZpbmVkJyA/IHRoaXMuX29wdGlvbnMuaWdub3JlSW50ZXJuYWwgOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqIEpTRG9jICovXG4gICAgSW5ib3VuZEZpbHRlcnMucHJvdG90eXBlLl9nZXRQb3NzaWJsZUV2ZW50TWVzc2FnZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBbZXZlbnQubWVzc2FnZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmV4Y2VwdGlvbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSAoZXZlbnQuZXhjZXB0aW9uLnZhbHVlcyAmJiBldmVudC5leGNlcHRpb24udmFsdWVzWzBdKSB8fCB7fSwgX2IgPSBfYS50eXBlLCB0eXBlID0gX2IgPT09IHZvaWQgMCA/ICcnIDogX2IsIF9jID0gX2EudmFsdWUsIHZhbHVlID0gX2MgPT09IHZvaWQgMCA/ICcnIDogX2M7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcIlwiICsgdmFsdWUsIHR5cGUgKyBcIjogXCIgKyB2YWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAob08pIHtcbiAgICAgICAgICAgICAgICB1dGlsc18xLmxvZ2dlci5lcnJvcihcIkNhbm5vdCBleHRyYWN0IG1lc3NhZ2UgZm9yIGV2ZW50IFwiICsgdXRpbHNfMS5nZXRFdmVudERlc2NyaXB0aW9uKGV2ZW50KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIC8qKiBKU0RvYyAqL1xuICAgIEluYm91bmRGaWx0ZXJzLnByb3RvdHlwZS5fZ2V0TGFzdFZhbGlkVXJsID0gZnVuY3Rpb24gKGZyYW1lcykge1xuICAgICAgICBpZiAoZnJhbWVzID09PSB2b2lkIDApIHsgZnJhbWVzID0gW107IH1cbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgZm9yICh2YXIgaSA9IGZyYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIGZyYW1lID0gZnJhbWVzW2ldO1xuICAgICAgICAgICAgaWYgKCgoX2EgPSBmcmFtZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbGVuYW1lKSAhPT0gJzxhbm9ueW1vdXM+JyAmJiAoKF9iID0gZnJhbWUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5maWxlbmFtZSkgIT09ICdbbmF0aXZlIGNvZGVdJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcmFtZS5maWxlbmFtZSB8fCBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqIEpTRG9jICovXG4gICAgSW5ib3VuZEZpbHRlcnMucHJvdG90eXBlLl9nZXRFdmVudEZpbHRlclVybCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnN0YWNrdHJhY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVzXzEgPSBldmVudC5zdGFja3RyYWNlLmZyYW1lcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TGFzdFZhbGlkVXJsKGZyYW1lc18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldmVudC5leGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVzXzIgPSBldmVudC5leGNlcHRpb24udmFsdWVzICYmIGV2ZW50LmV4Y2VwdGlvbi52YWx1ZXNbMF0uc3RhY2t0cmFjZSAmJiBldmVudC5leGNlcHRpb24udmFsdWVzWzBdLnN0YWNrdHJhY2UuZnJhbWVzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRMYXN0VmFsaWRVcmwoZnJhbWVzXzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKG9PKSB7XG4gICAgICAgICAgICB1dGlsc18xLmxvZ2dlci5lcnJvcihcIkNhbm5vdCBleHRyYWN0IHVybCBmb3IgZXZlbnQgXCIgKyB1dGlsc18xLmdldEV2ZW50RGVzY3JpcHRpb24oZXZlbnQpKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIEluYm91bmRGaWx0ZXJzLmlkID0gJ0luYm91bmRGaWx0ZXJzJztcbiAgICByZXR1cm4gSW5ib3VuZEZpbHRlcnM7XG59KCkpO1xuZXhwb3J0cy5JbmJvdW5kRmlsdGVycyA9IEluYm91bmRGaWx0ZXJzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5ib3VuZGZpbHRlcnMuanMubWFwIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiQHNlbnRyeS90eXBlc1wiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIkBzZW50cnkvdXRpbHNcIik7XG52YXIgaHViXzEgPSByZXF1aXJlKFwiLi9odWJcIik7XG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbnZhciBTZXNzaW9uRmx1c2hlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXNzaW9uRmx1c2hlcih0cmFuc3BvcnQsIGF0dHJzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZmx1c2hUaW1lb3V0ID0gNjA7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdBZ2dyZWdhdGVzID0ge307XG4gICAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgLy8gQ2FsbCB0byBzZXRJbnRlcnZhbCwgc28gdGhhdCBmbHVzaCBpcyBjYWxsZWQgZXZlcnkgNjAgc2Vjb25kc1xuICAgICAgICB0aGlzLl9pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZmx1c2goKTsgfSwgdGhpcy5mbHVzaFRpbWVvdXQgKiAxMDAwKTtcbiAgICAgICAgdGhpcy5fc2Vzc2lvbkF0dHJzID0gYXR0cnM7XG4gICAgfVxuICAgIC8qKiBTZW5kcyBzZXNzaW9uIGFnZ3JlZ2F0ZXMgdG8gVHJhbnNwb3J0ICovXG4gICAgU2Vzc2lvbkZsdXNoZXIucHJvdG90eXBlLnNlbmRTZXNzaW9uQWdncmVnYXRlcyA9IGZ1bmN0aW9uIChzZXNzaW9uQWdncmVnYXRlcykge1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydC5zZW5kU2Vzc2lvbikge1xuICAgICAgICAgICAgdXRpbHNfMS5sb2dnZXIud2FybihcIkRyb3BwaW5nIHNlc3Npb24gYmVjYXVzZSBjdXN0b20gdHJhbnNwb3J0IGRvZXNuJ3QgaW1wbGVtZW50IHNlbmRTZXNzaW9uXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZvaWQgdGhpcy5fdHJhbnNwb3J0LnNlbmRTZXNzaW9uKHNlc3Npb25BZ2dyZWdhdGVzKS50aGVuKG51bGwsIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgIHV0aWxzXzEubG9nZ2VyLmVycm9yKFwiRXJyb3Igd2hpbGUgc2VuZGluZyBzZXNzaW9uOiBcIiArIHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIENoZWNrcyBpZiBgcGVuZGluZ0FnZ3JlZ2F0ZXNgIGhhcyBlbnRyaWVzLCBhbmQgaWYgaXQgZG9lcyBmbHVzaGVzIHRoZW0gYnkgY2FsbGluZyBgc2VuZFNlc3Npb25zYCAqL1xuICAgIFNlc3Npb25GbHVzaGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlc3Npb25BZ2dyZWdhdGVzID0gdGhpcy5nZXRTZXNzaW9uQWdncmVnYXRlcygpO1xuICAgICAgICBpZiAoc2Vzc2lvbkFnZ3JlZ2F0ZXMuYWdncmVnYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wZW5kaW5nQWdncmVnYXRlcyA9IHt9O1xuICAgICAgICB0aGlzLnNlbmRTZXNzaW9uQWdncmVnYXRlcyhzZXNzaW9uQWdncmVnYXRlcyk7XG4gICAgfTtcbiAgICAvKiogTWFzc2FnZXMgdGhlIGVudHJpZXMgaW4gYHBlbmRpbmdBZ2dyZWdhdGVzYCBhbmQgcmV0dXJucyBhZ2dyZWdhdGVkIHNlc3Npb25zICovXG4gICAgU2Vzc2lvbkZsdXNoZXIucHJvdG90eXBlLmdldFNlc3Npb25BZ2dyZWdhdGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYWdncmVnYXRlcyA9IE9iamVjdC5rZXlzKHRoaXMuX3BlbmRpbmdBZ2dyZWdhdGVzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9wZW5kaW5nQWdncmVnYXRlc1twYXJzZUludChrZXkpXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzZXNzaW9uQWdncmVnYXRlcyA9IHtcbiAgICAgICAgICAgIGF0dHJzOiB0aGlzLl9zZXNzaW9uQXR0cnMsXG4gICAgICAgICAgICBhZ2dyZWdhdGVzOiBhZ2dyZWdhdGVzLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdXRpbHNfMS5kcm9wVW5kZWZpbmVkS2V5cyhzZXNzaW9uQWdncmVnYXRlcyk7XG4gICAgfTtcbiAgICAvKiogSlNEb2MgKi9cbiAgICBTZXNzaW9uRmx1c2hlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWxJZCk7XG4gICAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXcmFwcGVyIGZ1bmN0aW9uIGZvciBfaW5jcmVtZW50U2Vzc2lvblN0YXR1c0NvdW50IHRoYXQgY2hlY2tzIGlmIHRoZSBpbnN0YW5jZSBvZiBTZXNzaW9uRmx1c2hlciBpcyBlbmFibGVkIHRoZW5cbiAgICAgKiBmZXRjaGVzIHRoZSBzZXNzaW9uIHN0YXR1cyBvZiB0aGUgcmVxdWVzdCBmcm9tIGBTY29wZS5nZXRSZXF1ZXN0U2Vzc2lvbigpLnN0YXR1c2Agb24gdGhlIHNjb3BlIGFuZCBwYXNzZXMgdGhlbSB0b1xuICAgICAqIGBfaW5jcmVtZW50U2Vzc2lvblN0YXR1c0NvdW50YCBhbG9uZyB3aXRoIHRoZSBzdGFydCBkYXRlXG4gICAgICovXG4gICAgU2Vzc2lvbkZsdXNoZXIucHJvdG90eXBlLmluY3JlbWVudFNlc3Npb25TdGF0dXNDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NvcGUgPSBodWJfMS5nZXRDdXJyZW50SHViKCkuZ2V0U2NvcGUoKTtcbiAgICAgICAgdmFyIHJlcXVlc3RTZXNzaW9uID0gKF9hID0gc2NvcGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRSZXF1ZXN0U2Vzc2lvbigpO1xuICAgICAgICBpZiAocmVxdWVzdFNlc3Npb24gJiYgcmVxdWVzdFNlc3Npb24uc3RhdHVzKSB7XG4gICAgICAgICAgICB0aGlzLl9pbmNyZW1lbnRTZXNzaW9uU3RhdHVzQ291bnQocmVxdWVzdFNlc3Npb24uc3RhdHVzLCBuZXcgRGF0ZSgpKTtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgbm90IGVudGlyZWx5IG5lY2Vzc2FyaWx5IGJ1dCBpcyBhZGRlZCBhcyBhIHNhZmUgZ3VhcmQgdG8gaW5kaWNhdGUgdGhlIGJvdW5kcyBvZiBhIHJlcXVlc3QgYW5kIHNvIGluXG4gICAgICAgICAgICAvLyBjYXNlIGNhcHR1cmVSZXF1ZXN0U2Vzc2lvbiBpcyBjYWxsZWQgbW9yZSB0aGFuIG9uY2UgdG8gcHJldmVudCBkb3VibGUgY291bnRcbiAgICAgICAgICAgIChfYiA9IHNjb3BlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2V0UmVxdWVzdFNlc3Npb24odW5kZWZpbmVkKTtcbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzICovXG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluY3JlbWVudHMgc3RhdHVzIGJ1Y2tldCBpbiBwZW5kaW5nQWdncmVnYXRlcyBidWZmZXIgKGludGVybmFsIHN0YXRlKSBjb3JyZXNwb25kaW5nIHRvIHN0YXR1cyBvZlxuICAgICAqIHRoZSBzZXNzaW9uIHJlY2VpdmVkXG4gICAgICovXG4gICAgU2Vzc2lvbkZsdXNoZXIucHJvdG90eXBlLl9pbmNyZW1lbnRTZXNzaW9uU3RhdHVzQ291bnQgPSBmdW5jdGlvbiAoc3RhdHVzLCBkYXRlKSB7XG4gICAgICAgIC8vIFRydW5jYXRlIG1pbnV0ZXMgYW5kIHNlY29uZHMgb24gU2Vzc2lvbiBTdGFydGVkIGF0dHJpYnV0ZSB0byBoYXZlIG9uZSBtaW51dGUgYnVja2V0IGtleXNcbiAgICAgICAgdmFyIHNlc3Npb25TdGFydGVkVHJ1bmMgPSBuZXcgRGF0ZShkYXRlKS5zZXRTZWNvbmRzKDAsIDApO1xuICAgICAgICB0aGlzLl9wZW5kaW5nQWdncmVnYXRlc1tzZXNzaW9uU3RhcnRlZFRydW5jXSA9IHRoaXMuX3BlbmRpbmdBZ2dyZWdhdGVzW3Nlc3Npb25TdGFydGVkVHJ1bmNdIHx8IHt9O1xuICAgICAgICAvLyBjb3JyZXNwb25kcyB0byBhZ2dyZWdhdGVkIHNlc3Npb25zIGluIG9uZSBzcGVjaWZpYyBtaW51dGUgYnVja2V0XG4gICAgICAgIC8vIGZvciBleGFtcGxlLCB7XCJzdGFydGVkXCI6XCIyMDIxLTAzLTE2VDA4OjAwOjAwLjAwMFpcIixcImV4aXRlZFwiOjQsIFwiZXJyb3JlZFwiOiAxfVxuICAgICAgICB2YXIgYWdncmVnYXRpb25Db3VudHMgPSB0aGlzLl9wZW5kaW5nQWdncmVnYXRlc1tzZXNzaW9uU3RhcnRlZFRydW5jXTtcbiAgICAgICAgaWYgKCFhZ2dyZWdhdGlvbkNvdW50cy5zdGFydGVkKSB7XG4gICAgICAgICAgICBhZ2dyZWdhdGlvbkNvdW50cy5zdGFydGVkID0gbmV3IERhdGUoc2Vzc2lvblN0YXJ0ZWRUcnVuYykudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlJlcXVlc3RTZXNzaW9uU3RhdHVzLkVycm9yZWQ6XG4gICAgICAgICAgICAgICAgYWdncmVnYXRpb25Db3VudHMuZXJyb3JlZCA9IChhZ2dyZWdhdGlvbkNvdW50cy5lcnJvcmVkIHx8IDApICsgMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWdncmVnYXRpb25Db3VudHMuZXJyb3JlZDtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5SZXF1ZXN0U2Vzc2lvblN0YXR1cy5PazpcbiAgICAgICAgICAgICAgICBhZ2dyZWdhdGlvbkNvdW50cy5leGl0ZWQgPSAoYWdncmVnYXRpb25Db3VudHMuZXhpdGVkIHx8IDApICsgMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWdncmVnYXRpb25Db3VudHMuZXhpdGVkO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlJlcXVlc3RTZXNzaW9uU3RhdHVzLkNyYXNoZWQ6XG4gICAgICAgICAgICAgICAgYWdncmVnYXRpb25Db3VudHMuY3Jhc2hlZCA9IChhZ2dyZWdhdGlvbkNvdW50cy5jcmFzaGVkIHx8IDApICsgMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWdncmVnYXRpb25Db3VudHMuY3Jhc2hlZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNlc3Npb25GbHVzaGVyO1xufSgpKTtcbmV4cG9ydHMuU2Vzc2lvbkZsdXNoZXIgPSBTZXNzaW9uRmx1c2hlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlc3Npb25mbHVzaGVyLmpzLm1hcCIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiQHNlbnRyeS91dGlsc1wiKTtcbi8qKlxuICogQWJzb2x1dGUgbWF4aW11bSBudW1iZXIgb2YgYnJlYWRjcnVtYnMgYWRkZWQgdG8gYW4gZXZlbnQuXG4gKiBUaGUgYG1heEJyZWFkY3J1bWJzYCBvcHRpb24gY2Fubm90IGJlIGhpZ2hlciB0aGFuIHRoaXMgdmFsdWUuXG4gKi9cbnZhciBNQVhfQlJFQURDUlVNQlMgPSAxMDA7XG4vKipcbiAqIEhvbGRzIGFkZGl0aW9uYWwgZXZlbnQgaW5mb3JtYXRpb24uIHtAbGluayBTY29wZS5hcHBseVRvRXZlbnR9IHdpbGwgYmVcbiAqIGNhbGxlZCBieSB0aGUgY2xpZW50IGJlZm9yZSBhbiBldmVudCB3aWxsIGJlIHNlbnQuXG4gKi9cbnZhciBTY29wZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY29wZSgpIHtcbiAgICAgICAgLyoqIEZsYWcgaWYgbm90aWZ5aW5nIGlzIGhhcHBlbmluZy4gKi9cbiAgICAgICAgdGhpcy5fbm90aWZ5aW5nTGlzdGVuZXJzID0gZmFsc2U7XG4gICAgICAgIC8qKiBDYWxsYmFjayBmb3IgY2xpZW50IHRvIHJlY2VpdmUgc2NvcGUgY2hhbmdlcy4gKi9cbiAgICAgICAgdGhpcy5fc2NvcGVMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgLyoqIENhbGxiYWNrIGxpc3QgdGhhdCB3aWxsIGJlIGNhbGxlZCBhZnRlciB7QGxpbmsgYXBwbHlUb0V2ZW50fS4gKi9cbiAgICAgICAgdGhpcy5fZXZlbnRQcm9jZXNzb3JzID0gW107XG4gICAgICAgIC8qKiBBcnJheSBvZiBicmVhZGNydW1icy4gKi9cbiAgICAgICAgdGhpcy5fYnJlYWRjcnVtYnMgPSBbXTtcbiAgICAgICAgLyoqIFVzZXIgKi9cbiAgICAgICAgdGhpcy5fdXNlciA9IHt9O1xuICAgICAgICAvKiogVGFncyAqL1xuICAgICAgICB0aGlzLl90YWdzID0ge307XG4gICAgICAgIC8qKiBFeHRyYSAqL1xuICAgICAgICB0aGlzLl9leHRyYSA9IHt9O1xuICAgICAgICAvKiogQ29udGV4dHMgKi9cbiAgICAgICAgdGhpcy5fY29udGV4dHMgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5oZXJpdCB2YWx1ZXMgZnJvbSB0aGUgcGFyZW50IHNjb3BlLlxuICAgICAqIEBwYXJhbSBzY29wZSB0byBjbG9uZS5cbiAgICAgKi9cbiAgICBTY29wZS5jbG9uZSA9IGZ1bmN0aW9uIChzY29wZSkge1xuICAgICAgICB2YXIgbmV3U2NvcGUgPSBuZXcgU2NvcGUoKTtcbiAgICAgICAgaWYgKHNjb3BlKSB7XG4gICAgICAgICAgICBuZXdTY29wZS5fYnJlYWRjcnVtYnMgPSB0c2xpYl8xLl9fc3ByZWFkKHNjb3BlLl9icmVhZGNydW1icyk7XG4gICAgICAgICAgICBuZXdTY29wZS5fdGFncyA9IHRzbGliXzEuX19hc3NpZ24oe30sIHNjb3BlLl90YWdzKTtcbiAgICAgICAgICAgIG5ld1Njb3BlLl9leHRyYSA9IHRzbGliXzEuX19hc3NpZ24oe30sIHNjb3BlLl9leHRyYSk7XG4gICAgICAgICAgICBuZXdTY29wZS5fY29udGV4dHMgPSB0c2xpYl8xLl9fYXNzaWduKHt9LCBzY29wZS5fY29udGV4dHMpO1xuICAgICAgICAgICAgbmV3U2NvcGUuX3VzZXIgPSBzY29wZS5fdXNlcjtcbiAgICAgICAgICAgIG5ld1Njb3BlLl9sZXZlbCA9IHNjb3BlLl9sZXZlbDtcbiAgICAgICAgICAgIG5ld1Njb3BlLl9zcGFuID0gc2NvcGUuX3NwYW47XG4gICAgICAgICAgICBuZXdTY29wZS5fc2Vzc2lvbiA9IHNjb3BlLl9zZXNzaW9uO1xuICAgICAgICAgICAgbmV3U2NvcGUuX3RyYW5zYWN0aW9uTmFtZSA9IHNjb3BlLl90cmFuc2FjdGlvbk5hbWU7XG4gICAgICAgICAgICBuZXdTY29wZS5fZmluZ2VycHJpbnQgPSBzY29wZS5fZmluZ2VycHJpbnQ7XG4gICAgICAgICAgICBuZXdTY29wZS5fZXZlbnRQcm9jZXNzb3JzID0gdHNsaWJfMS5fX3NwcmVhZChzY29wZS5fZXZlbnRQcm9jZXNzb3JzKTtcbiAgICAgICAgICAgIG5ld1Njb3BlLl9yZXF1ZXN0U2Vzc2lvbiA9IHNjb3BlLl9yZXF1ZXN0U2Vzc2lvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U2NvcGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgaW50ZXJuYWwgb24gY2hhbmdlIGxpc3RlbmVyLiBVc2VkIGZvciBzdWIgU0RLcyB0aGF0IG5lZWQgdG8gc3RvcmUgdGhlIHNjb3BlLlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBTY29wZS5wcm90b3R5cGUuYWRkU2NvcGVMaXN0ZW5lciA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9zY29wZUxpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgU2NvcGUucHJvdG90eXBlLmFkZEV2ZW50UHJvY2Vzc29yID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50UHJvY2Vzc29ycy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFNjb3BlLnByb3RvdHlwZS5zZXRVc2VyID0gZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgdGhpcy5fdXNlciA9IHVzZXIgfHwge307XG4gICAgICAgIGlmICh0aGlzLl9zZXNzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXNzaW9uLnVwZGF0ZSh7IHVzZXI6IHVzZXIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFNjb3BlLnByb3RvdHlwZS5nZXRVc2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXNlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgU2NvcGUucHJvdG90eXBlLmdldFJlcXVlc3RTZXNzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdFNlc3Npb247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFNjb3BlLnByb3RvdHlwZS5zZXRSZXF1ZXN0U2Vzc2lvbiA9IGZ1bmN0aW9uIChyZXF1ZXN0U2Vzc2lvbikge1xuICAgICAgICB0aGlzLl9yZXF1ZXN0U2Vzc2lvbiA9IHJlcXVlc3RTZXNzaW9uO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgU2NvcGUucHJvdG90eXBlLnNldFRhZ3MgPSBmdW5jdGlvbiAodGFncykge1xuICAgICAgICB0aGlzLl90YWdzID0gdHNsaWJfMS5fX2Fzc2lnbih0c2xpYl8xLl9fYXNzaWduKHt9LCB0aGlzLl90YWdzKSwgdGFncyk7XG4gICAgICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBTY29wZS5wcm90b3R5cGUuc2V0VGFnID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLl90YWdzID0gdHNsaWJfMS5fX2Fzc2lnbih0c2xpYl8xLl9fYXNzaWduKHt9LCB0aGlzLl90YWdzKSwgKF9hID0ge30sIF9hW2tleV0gPSB2YWx1ZSwgX2EpKTtcbiAgICAgICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFNjb3BlLnByb3RvdHlwZS5zZXRFeHRyYXMgPSBmdW5jdGlvbiAoZXh0cmFzKSB7XG4gICAgICAgIHRoaXMuX2V4dHJhID0gdHNsaWJfMS5fX2Fzc2lnbih0c2xpYl8xLl9fYXNzaWduKHt9LCB0aGlzLl9leHRyYSksIGV4dHJhcyk7XG4gICAgICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBTY29wZS5wcm90b3R5cGUuc2V0RXh0cmEgPSBmdW5jdGlvbiAoa2V5LCBleHRyYSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuX2V4dHJhID0gdHNsaWJfMS5fX2Fzc2lnbih0c2xpYl8xLl9fYXNzaWduKHt9LCB0aGlzLl9leHRyYSksIChfYSA9IHt9LCBfYVtrZXldID0gZXh0cmEsIF9hKSk7XG4gICAgICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBTY29wZS5wcm90b3R5cGUuc2V0RmluZ2VycHJpbnQgPSBmdW5jdGlvbiAoZmluZ2VycHJpbnQpIHtcbiAgICAgICAgdGhpcy5fZmluZ2VycHJpbnQgPSBmaW5nZXJwcmludDtcbiAgICAgICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFNjb3BlLnByb3RvdHlwZS5zZXRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICB0aGlzLl9sZXZlbCA9IGxldmVsO1xuICAgICAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgU2NvcGUucHJvdG90eXBlLnNldFRyYW5zYWN0aW9uTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uTmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FuIGJlIHJlbW92ZWQgaW4gbWFqb3IgdmVyc2lvbi5cbiAgICAgKiBAZGVwcmVjYXRlZCBpbiBmYXZvciBvZiB7QGxpbmsgdGhpcy5zZXRUcmFuc2FjdGlvbk5hbWV9XG4gICAgICovXG4gICAgU2NvcGUucHJvdG90eXBlLnNldFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0VHJhbnNhY3Rpb25OYW1lKG5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBTY29wZS5wcm90b3R5cGUuc2V0Q29udGV4dCA9IGZ1bmN0aW9uIChrZXksIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1keW5hbWljLWRlbGV0ZVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NvbnRleHRzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0cyA9IHRzbGliXzEuX19hc3NpZ24odHNsaWJfMS5fX2Fzc2lnbih7fSwgdGhpcy5fY29udGV4dHMpLCAoX2EgPSB7fSwgX2Fba2V5XSA9IGNvbnRleHQsIF9hKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFNjb3BlLnByb3RvdHlwZS5zZXRTcGFuID0gZnVuY3Rpb24gKHNwYW4pIHtcbiAgICAgICAgdGhpcy5fc3BhbiA9IHNwYW47XG4gICAgICAgIHRoaXMuX25vdGlmeVNjb3BlTGlzdGVuZXJzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBTY29wZS5wcm90b3R5cGUuZ2V0U3BhbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NwYW47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFNjb3BlLnByb3RvdHlwZS5nZXRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAvLyBvZnRlbiwgdGhpcyBzcGFuIHdpbGwgYmUgYSB0cmFuc2FjdGlvbiwgYnV0IGl0J3Mgbm90IGd1YXJhbnRlZWQgdG8gYmVcbiAgICAgICAgdmFyIHNwYW4gPSB0aGlzLmdldFNwYW4oKTtcbiAgICAgICAgLy8gdHJ5IGl0IHRoZSBuZXcgd2F5IGZpcnN0XG4gICAgICAgIGlmICgoX2EgPSBzcGFuKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAoX2IgPSBzcGFuKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudHJhbnNhY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gdGhlIG9sZCB3YXkgKGtub3duIGJ1ZzogdGhpcyBvbmx5IGZpbmRzIHRyYW5zYWN0aW9ucyB3aXRoIHNhbXBsZWQgPSB0cnVlKVxuICAgICAgICBpZiAoKF9kID0gKF9jID0gc3BhbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNwYW5SZWNvcmRlcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnNwYW5zWzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gc3Bhbi5zcGFuUmVjb3JkZXIuc3BhbnNbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gbmVpdGhlciB3YXkgZm91bmQgYSB0cmFuc2FjdGlvblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBTY29wZS5wcm90b3R5cGUuc2V0U2Vzc2lvbiA9IGZ1bmN0aW9uIChzZXNzaW9uKSB7XG4gICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3Nlc3Npb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgU2NvcGUucHJvdG90eXBlLmdldFNlc3Npb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXNzaW9uO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBTY29wZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGNhcHR1cmVDb250ZXh0KSB7XG4gICAgICAgIGlmICghY2FwdHVyZUNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FwdHVyZUNvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciB1cGRhdGVkU2NvcGUgPSBjYXB0dXJlQ29udGV4dCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVkU2NvcGUgaW5zdGFuY2VvZiBTY29wZSA/IHVwZGF0ZWRTY29wZSA6IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhcHR1cmVDb250ZXh0IGluc3RhbmNlb2YgU2NvcGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhZ3MgPSB0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24oe30sIHRoaXMuX3RhZ3MpLCBjYXB0dXJlQ29udGV4dC5fdGFncyk7XG4gICAgICAgICAgICB0aGlzLl9leHRyYSA9IHRzbGliXzEuX19hc3NpZ24odHNsaWJfMS5fX2Fzc2lnbih7fSwgdGhpcy5fZXh0cmEpLCBjYXB0dXJlQ29udGV4dC5fZXh0cmEpO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dHMgPSB0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24oe30sIHRoaXMuX2NvbnRleHRzKSwgY2FwdHVyZUNvbnRleHQuX2NvbnRleHRzKTtcbiAgICAgICAgICAgIGlmIChjYXB0dXJlQ29udGV4dC5fdXNlciAmJiBPYmplY3Qua2V5cyhjYXB0dXJlQ29udGV4dC5fdXNlcikubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXNlciA9IGNhcHR1cmVDb250ZXh0Ll91c2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhcHR1cmVDb250ZXh0Ll9sZXZlbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xldmVsID0gY2FwdHVyZUNvbnRleHQuX2xldmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhcHR1cmVDb250ZXh0Ll9maW5nZXJwcmludCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmdlcnByaW50ID0gY2FwdHVyZUNvbnRleHQuX2ZpbmdlcnByaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhcHR1cmVDb250ZXh0Ll9yZXF1ZXN0U2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RTZXNzaW9uID0gY2FwdHVyZUNvbnRleHQuX3JlcXVlc3RTZXNzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHV0aWxzXzEuaXNQbGFpbk9iamVjdChjYXB0dXJlQ29udGV4dCkpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgY2FwdHVyZUNvbnRleHQgPSBjYXB0dXJlQ29udGV4dDtcbiAgICAgICAgICAgIHRoaXMuX3RhZ3MgPSB0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24oe30sIHRoaXMuX3RhZ3MpLCBjYXB0dXJlQ29udGV4dC50YWdzKTtcbiAgICAgICAgICAgIHRoaXMuX2V4dHJhID0gdHNsaWJfMS5fX2Fzc2lnbih0c2xpYl8xLl9fYXNzaWduKHt9LCB0aGlzLl9leHRyYSksIGNhcHR1cmVDb250ZXh0LmV4dHJhKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHRzID0gdHNsaWJfMS5fX2Fzc2lnbih0c2xpYl8xLl9fYXNzaWduKHt9LCB0aGlzLl9jb250ZXh0cyksIGNhcHR1cmVDb250ZXh0LmNvbnRleHRzKTtcbiAgICAgICAgICAgIGlmIChjYXB0dXJlQ29udGV4dC51c2VyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXNlciA9IGNhcHR1cmVDb250ZXh0LnVzZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FwdHVyZUNvbnRleHQubGV2ZWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sZXZlbCA9IGNhcHR1cmVDb250ZXh0LmxldmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhcHR1cmVDb250ZXh0LmZpbmdlcnByaW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmluZ2VycHJpbnQgPSBjYXB0dXJlQ29udGV4dC5maW5nZXJwcmludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYXB0dXJlQ29udGV4dC5yZXF1ZXN0U2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RTZXNzaW9uID0gY2FwdHVyZUNvbnRleHQucmVxdWVzdFNlc3Npb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFNjb3BlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYnJlYWRjcnVtYnMgPSBbXTtcbiAgICAgICAgdGhpcy5fdGFncyA9IHt9O1xuICAgICAgICB0aGlzLl9leHRyYSA9IHt9O1xuICAgICAgICB0aGlzLl91c2VyID0ge307XG4gICAgICAgIHRoaXMuX2NvbnRleHRzID0ge307XG4gICAgICAgIHRoaXMuX2xldmVsID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbk5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2ZpbmdlcnByaW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0U2Vzc2lvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc3BhbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc2Vzc2lvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFNjb3BlLnByb3RvdHlwZS5hZGRCcmVhZGNydW1iID0gZnVuY3Rpb24gKGJyZWFkY3J1bWIsIG1heEJyZWFkY3J1bWJzKSB7XG4gICAgICAgIHZhciBtYXhDcnVtYnMgPSB0eXBlb2YgbWF4QnJlYWRjcnVtYnMgPT09ICdudW1iZXInID8gTWF0aC5taW4obWF4QnJlYWRjcnVtYnMsIE1BWF9CUkVBRENSVU1CUykgOiBNQVhfQlJFQURDUlVNQlM7XG4gICAgICAgIC8vIE5vIGRhdGEgaGFzIGJlZW4gY2hhbmdlZCwgc28gZG9uJ3Qgbm90aWZ5IHNjb3BlIGxpc3RlbmVyc1xuICAgICAgICBpZiAobWF4Q3J1bWJzIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZXJnZWRCcmVhZGNydW1iID0gdHNsaWJfMS5fX2Fzc2lnbih7IHRpbWVzdGFtcDogdXRpbHNfMS5kYXRlVGltZXN0YW1wSW5TZWNvbmRzKCkgfSwgYnJlYWRjcnVtYik7XG4gICAgICAgIHRoaXMuX2JyZWFkY3J1bWJzID0gdHNsaWJfMS5fX3NwcmVhZCh0aGlzLl9icmVhZGNydW1icywgW21lcmdlZEJyZWFkY3J1bWJdKS5zbGljZSgtbWF4Q3J1bWJzKTtcbiAgICAgICAgdGhpcy5fbm90aWZ5U2NvcGVMaXN0ZW5lcnMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFNjb3BlLnByb3RvdHlwZS5jbGVhckJyZWFkY3J1bWJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9icmVhZGNydW1icyA9IFtdO1xuICAgICAgICB0aGlzLl9ub3RpZnlTY29wZUxpc3RlbmVycygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIGN1cnJlbnQgY29udGV4dCBhbmQgZmluZ2VycHJpbnQgdG8gdGhlIGV2ZW50LlxuICAgICAqIE5vdGUgdGhhdCBicmVhZGNydW1icyB3aWxsIGJlIGFkZGVkIGJ5IHRoZSBjbGllbnQuXG4gICAgICogQWxzbyBpZiB0aGUgZXZlbnQgaGFzIGFscmVhZHkgYnJlYWRjcnVtYnMgb24gaXQsIHdlIGRvIG5vdCBtZXJnZSB0aGVtLlxuICAgICAqIEBwYXJhbSBldmVudCBFdmVudFxuICAgICAqIEBwYXJhbSBoaW50IE1heSBjb250YWluIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9yaWdpbmFsIGV4Y2VwdGlvbi5cbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgU2NvcGUucHJvdG90eXBlLmFwcGx5VG9FdmVudCA9IGZ1bmN0aW9uIChldmVudCwgaGludCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLl9leHRyYSAmJiBPYmplY3Qua2V5cyh0aGlzLl9leHRyYSkubGVuZ3RoKSB7XG4gICAgICAgICAgICBldmVudC5leHRyYSA9IHRzbGliXzEuX19hc3NpZ24odHNsaWJfMS5fX2Fzc2lnbih7fSwgdGhpcy5fZXh0cmEpLCBldmVudC5leHRyYSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3RhZ3MgJiYgT2JqZWN0LmtleXModGhpcy5fdGFncykubGVuZ3RoKSB7XG4gICAgICAgICAgICBldmVudC50YWdzID0gdHNsaWJfMS5fX2Fzc2lnbih0c2xpYl8xLl9fYXNzaWduKHt9LCB0aGlzLl90YWdzKSwgZXZlbnQudGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3VzZXIgJiYgT2JqZWN0LmtleXModGhpcy5fdXNlcikubGVuZ3RoKSB7XG4gICAgICAgICAgICBldmVudC51c2VyID0gdHNsaWJfMS5fX2Fzc2lnbih0c2xpYl8xLl9fYXNzaWduKHt9LCB0aGlzLl91c2VyKSwgZXZlbnQudXNlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NvbnRleHRzICYmIE9iamVjdC5rZXlzKHRoaXMuX2NvbnRleHRzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGV2ZW50LmNvbnRleHRzID0gdHNsaWJfMS5fX2Fzc2lnbih0c2xpYl8xLl9fYXNzaWduKHt9LCB0aGlzLl9jb250ZXh0cyksIGV2ZW50LmNvbnRleHRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbGV2ZWwpIHtcbiAgICAgICAgICAgIGV2ZW50LmxldmVsID0gdGhpcy5fbGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uTmFtZSkge1xuICAgICAgICAgICAgZXZlbnQudHJhbnNhY3Rpb24gPSB0aGlzLl90cmFuc2FjdGlvbk5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Ugd2FudCB0byBzZXQgdGhlIHRyYWNlIGNvbnRleHQgZm9yIG5vcm1hbCBldmVudHMgb25seSBpZiB0aGVyZSBpc24ndCBhbHJlYWR5XG4gICAgICAgIC8vIGEgdHJhY2UgY29udGV4dCBvbiB0aGUgZXZlbnQuIFRoZXJlIGlzIGEgcHJvZHVjdCBmZWF0dXJlIGluIHBsYWNlIHdoZXJlIHdlIGxpbmtcbiAgICAgICAgLy8gZXJyb3JzIHdpdGggdHJhbnNhY3Rpb24gYW5kIGl0IHJlbGllcyBvbiB0aGF0LlxuICAgICAgICBpZiAodGhpcy5fc3Bhbikge1xuICAgICAgICAgICAgZXZlbnQuY29udGV4dHMgPSB0c2xpYl8xLl9fYXNzaWduKHsgdHJhY2U6IHRoaXMuX3NwYW4uZ2V0VHJhY2VDb250ZXh0KCkgfSwgZXZlbnQuY29udGV4dHMpO1xuICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uTmFtZSA9IChfYSA9IHRoaXMuX3NwYW4udHJhbnNhY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lO1xuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uTmFtZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhZ3MgPSB0c2xpYl8xLl9fYXNzaWduKHsgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uTmFtZSB9LCBldmVudC50YWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hcHBseUZpbmdlcnByaW50KGV2ZW50KTtcbiAgICAgICAgZXZlbnQuYnJlYWRjcnVtYnMgPSB0c2xpYl8xLl9fc3ByZWFkKChldmVudC5icmVhZGNydW1icyB8fCBbXSksIHRoaXMuX2JyZWFkY3J1bWJzKTtcbiAgICAgICAgZXZlbnQuYnJlYWRjcnVtYnMgPSBldmVudC5icmVhZGNydW1icy5sZW5ndGggPiAwID8gZXZlbnQuYnJlYWRjcnVtYnMgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub3RpZnlFdmVudFByb2Nlc3NvcnModHNsaWJfMS5fX3NwcmVhZChnZXRHbG9iYWxFdmVudFByb2Nlc3NvcnMoKSwgdGhpcy5fZXZlbnRQcm9jZXNzb3JzKSwgZXZlbnQsIGhpbnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyB3aWxsIGJlIGNhbGxlZCBhZnRlciB7QGxpbmsgYXBwbHlUb0V2ZW50fSBpcyBmaW5pc2hlZC5cbiAgICAgKi9cbiAgICBTY29wZS5wcm90b3R5cGUuX25vdGlmeUV2ZW50UHJvY2Vzc29ycyA9IGZ1bmN0aW9uIChwcm9jZXNzb3JzLCBldmVudCwgaGludCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSAwOyB9XG4gICAgICAgIHJldHVybiBuZXcgdXRpbHNfMS5TeW5jUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgcHJvY2Vzc29yID0gcHJvY2Vzc29yc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoZXZlbnQgPT09IG51bGwgfHwgdHlwZW9mIHByb2Nlc3NvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHByb2Nlc3Nvcih0c2xpYl8xLl9fYXNzaWduKHt9LCBldmVudCksIGhpbnQpO1xuICAgICAgICAgICAgICAgIGlmICh1dGlsc18xLmlzVGhlbmFibGUocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICB2b2lkIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGZpbmFsKSB7IHJldHVybiBfdGhpcy5fbm90aWZ5RXZlbnRQcm9jZXNzb3JzKHByb2Nlc3NvcnMsIGZpbmFsLCBoaW50LCBpbmRleCArIDEpLnRoZW4ocmVzb2x2ZSk7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihudWxsLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdm9pZCBfdGhpcy5fbm90aWZ5RXZlbnRQcm9jZXNzb3JzKHByb2Nlc3NvcnMsIHJlc3VsdCwgaGludCwgaW5kZXggKyAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKG51bGwsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgd2lsbCBiZSBjYWxsZWQgb24gZXZlcnkgc2V0IGNhbGwuXG4gICAgICovXG4gICAgU2NvcGUucHJvdG90eXBlLl9ub3RpZnlTY29wZUxpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gV2UgbmVlZCB0aGlzIGNoZWNrIGZvciB0aGlzLl9ub3RpZnlpbmdMaXN0ZW5lcnMgdG8gYmUgYWJsZSB0byB3b3JrIG9uIHNjb3BlIGR1cmluZyB1cGRhdGVzXG4gICAgICAgIC8vIElmIHRoaXMgY2hlY2sgaXMgbm90IGhlcmUgd2UnbGwgcHJvZHVjZSBlbmRsZXNzIHJlY3Vyc2lvbiB3aGVuIHNvbWV0aGluZyBpcyBkb25lIHdpdGggdGhlIHNjb3BlXG4gICAgICAgIC8vIGR1cmluZyB0aGUgY2FsbGJhY2suXG4gICAgICAgIGlmICghdGhpcy5fbm90aWZ5aW5nTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB0aGlzLl9ub3RpZnlpbmdMaXN0ZW5lcnMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fc2NvcGVMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhfdGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX25vdGlmeWluZ0xpc3RlbmVycyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbmdlcnByaW50IGZyb20gdGhlIHNjb3BlIHRvIHRoZSBldmVudCBpZiB0aGVyZSdzIG9uZSxcbiAgICAgKiB1c2VzIG1lc3NhZ2UgaWYgdGhlcmUncyBvbmUgaW5zdGVhZCBvciBnZXQgcmlkIG9mIGVtcHR5IGZpbmdlcnByaW50XG4gICAgICovXG4gICAgU2NvcGUucHJvdG90eXBlLl9hcHBseUZpbmdlcnByaW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBpdCdzIGFuIGFycmF5IGZpcnN0IGFuZCB3ZSBhY3R1YWxseSBoYXZlIHNvbWV0aGluZyBpbiBwbGFjZVxuICAgICAgICBldmVudC5maW5nZXJwcmludCA9IGV2ZW50LmZpbmdlcnByaW50XG4gICAgICAgICAgICA/IEFycmF5LmlzQXJyYXkoZXZlbnQuZmluZ2VycHJpbnQpXG4gICAgICAgICAgICAgICAgPyBldmVudC5maW5nZXJwcmludFxuICAgICAgICAgICAgICAgIDogW2V2ZW50LmZpbmdlcnByaW50XVxuICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBzb21ldGhpbmcgb24gdGhlIHNjb3BlLCB0aGVuIG1lcmdlIGl0IHdpdGggZXZlbnRcbiAgICAgICAgaWYgKHRoaXMuX2ZpbmdlcnByaW50KSB7XG4gICAgICAgICAgICBldmVudC5maW5nZXJwcmludCA9IGV2ZW50LmZpbmdlcnByaW50LmNvbmNhdCh0aGlzLl9maW5nZXJwcmludCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBubyBkYXRhIGF0IGFsbCwgcmVtb3ZlIGVtcHR5IGFycmF5IGRlZmF1bHRcbiAgICAgICAgaWYgKGV2ZW50LmZpbmdlcnByaW50ICYmICFldmVudC5maW5nZXJwcmludC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudC5maW5nZXJwcmludDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNjb3BlO1xufSgpKTtcbmV4cG9ydHMuU2NvcGUgPSBTY29wZTtcbi8qKlxuICogUmV0dXJucyB0aGUgZ2xvYmFsIGV2ZW50IHByb2Nlc3NvcnMuXG4gKi9cbmZ1bmN0aW9uIGdldEdsb2JhbEV2ZW50UHJvY2Vzc29ycygpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MgICovXG4gICAgdmFyIGdsb2JhbCA9IHV0aWxzXzEuZ2V0R2xvYmFsT2JqZWN0KCk7XG4gICAgZ2xvYmFsLl9fU0VOVFJZX18gPSBnbG9iYWwuX19TRU5UUllfXyB8fCB7fTtcbiAgICBnbG9iYWwuX19TRU5UUllfXy5nbG9iYWxFdmVudFByb2Nlc3NvcnMgPSBnbG9iYWwuX19TRU5UUllfXy5nbG9iYWxFdmVudFByb2Nlc3NvcnMgfHwgW107XG4gICAgcmV0dXJuIGdsb2JhbC5fX1NFTlRSWV9fLmdsb2JhbEV2ZW50UHJvY2Vzc29ycztcbiAgICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyAqL1xufVxuLyoqXG4gKiBBZGQgYSBFdmVudFByb2Nlc3NvciB0byBiZSBrZXB0IGdsb2JhbGx5LlxuICogQHBhcmFtIGNhbGxiYWNrIEV2ZW50UHJvY2Vzc29yIHRvIGFkZFxuICovXG5mdW5jdGlvbiBhZGRHbG9iYWxFdmVudFByb2Nlc3NvcihjYWxsYmFjaykge1xuICAgIGdldEdsb2JhbEV2ZW50UHJvY2Vzc29ycygpLnB1c2goY2FsbGJhY2spO1xufVxuZXhwb3J0cy5hZGRHbG9iYWxFdmVudFByb2Nlc3NvciA9IGFkZEdsb2JhbEV2ZW50UHJvY2Vzc29yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NvcGUuanMubWFwIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiQHNlbnRyeS90eXBlc1wiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIkBzZW50cnkvdXRpbHNcIik7XG4vKipcbiAqIEBpbmhlcml0ZG9jXG4gKi9cbnZhciBTZXNzaW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlc3Npb24oY29udGV4dCkge1xuICAgICAgICB0aGlzLmVycm9ycyA9IDA7XG4gICAgICAgIHRoaXMuc2lkID0gdXRpbHNfMS51dWlkNCgpO1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gMDtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSB0eXBlc18xLlNlc3Npb25TdGF0dXMuT2s7XG4gICAgICAgIHRoaXMuaW5pdCA9IHRydWU7XG4gICAgICAgIHRoaXMuaWdub3JlRHVyYXRpb24gPSBmYWxzZTtcbiAgICAgICAgLy8gQm90aCB0aW1lc3RhbXAgYW5kIHN0YXJ0ZWQgYXJlIGluIHNlY29uZHMgc2luY2UgdGhlIFVOSVggZXBvY2guXG4gICAgICAgIHZhciBzdGFydGluZ1RpbWUgPSB1dGlsc18xLnRpbWVzdGFtcEluU2Vjb25kcygpO1xuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHN0YXJ0aW5nVGltZTtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gc3RhcnRpbmdUaW1lO1xuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEpTRG9jICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgICBTZXNzaW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSB7fTsgfVxuICAgICAgICBpZiAoY29udGV4dC51c2VyKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXBBZGRyZXNzICYmIGNvbnRleHQudXNlci5pcF9hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pcEFkZHJlc3MgPSBjb250ZXh0LnVzZXIuaXBfYWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5kaWQgJiYgIWNvbnRleHQuZGlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWQgPSBjb250ZXh0LnVzZXIuaWQgfHwgY29udGV4dC51c2VyLmVtYWlsIHx8IGNvbnRleHQudXNlci51c2VybmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IGNvbnRleHQudGltZXN0YW1wIHx8IHV0aWxzXzEudGltZXN0YW1wSW5TZWNvbmRzKCk7XG4gICAgICAgIGlmIChjb250ZXh0Lmlnbm9yZUR1cmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZUR1cmF0aW9uID0gY29udGV4dC5pZ25vcmVEdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dC5zaWQpIHtcbiAgICAgICAgICAgIC8vIEdvb2QgZW5vdWdoIHV1aWQgdmFsaWRhdGlvbi4g4oCUIEthbWlsXG4gICAgICAgICAgICB0aGlzLnNpZCA9IGNvbnRleHQuc2lkLmxlbmd0aCA9PT0gMzIgPyBjb250ZXh0LnNpZCA6IHV0aWxzXzEudXVpZDQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dC5pbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdCA9IGNvbnRleHQuaW5pdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZGlkICYmIGNvbnRleHQuZGlkKSB7XG4gICAgICAgICAgICB0aGlzLmRpZCA9IFwiXCIgKyBjb250ZXh0LmRpZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuc3RhcnRlZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IGNvbnRleHQuc3RhcnRlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pZ25vcmVEdXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5kdXJhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY29udGV4dC5kdXJhdGlvbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuZHVyYXRpb24gPSBjb250ZXh0LmR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy50aW1lc3RhbXAgLSB0aGlzLnN0YXJ0ZWQ7XG4gICAgICAgICAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb24gPj0gMCA/IGR1cmF0aW9uIDogMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dC5yZWxlYXNlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbGVhc2UgPSBjb250ZXh0LnJlbGVhc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQuZW52aXJvbm1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZW52aXJvbm1lbnQgPSBjb250ZXh0LmVudmlyb25tZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pcEFkZHJlc3MgJiYgY29udGV4dC5pcEFkZHJlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuaXBBZGRyZXNzID0gY29udGV4dC5pcEFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnVzZXJBZ2VudCAmJiBjb250ZXh0LnVzZXJBZ2VudCkge1xuICAgICAgICAgICAgdGhpcy51c2VyQWdlbnQgPSBjb250ZXh0LnVzZXJBZ2VudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuZXJyb3JzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSBjb250ZXh0LmVycm9ycztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dC5zdGF0dXMpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gY29udGV4dC5zdGF0dXM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBKU0RvYyAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IHN0YXR1czogc3RhdHVzIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdHVzID09PSB0eXBlc18xLlNlc3Npb25TdGF0dXMuT2spIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgc3RhdHVzOiB0eXBlc18xLlNlc3Npb25TdGF0dXMuRXhpdGVkIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEpTRG9jICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdXRpbHNfMS5kcm9wVW5kZWZpbmVkS2V5cyh7XG4gICAgICAgICAgICBzaWQ6IFwiXCIgKyB0aGlzLnNpZCxcbiAgICAgICAgICAgIGluaXQ6IHRoaXMuaW5pdCxcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHNlYyBpcyBjb252ZXJ0ZWQgdG8gbXMgZm9yIGRhdGUgY29uc3RydWN0b3JcbiAgICAgICAgICAgIHN0YXJ0ZWQ6IG5ldyBEYXRlKHRoaXMuc3RhcnRlZCAqIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKHRoaXMudGltZXN0YW1wICogMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgICAgICBlcnJvcnM6IHRoaXMuZXJyb3JzLFxuICAgICAgICAgICAgZGlkOiB0eXBlb2YgdGhpcy5kaWQgPT09ICdudW1iZXInIHx8IHR5cGVvZiB0aGlzLmRpZCA9PT0gJ3N0cmluZycgPyBcIlwiICsgdGhpcy5kaWQgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIGF0dHJzOiB1dGlsc18xLmRyb3BVbmRlZmluZWRLZXlzKHtcbiAgICAgICAgICAgICAgICByZWxlYXNlOiB0aGlzLnJlbGVhc2UsXG4gICAgICAgICAgICAgICAgZW52aXJvbm1lbnQ6IHRoaXMuZW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgaXBfYWRkcmVzczogdGhpcy5pcEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgdXNlcl9hZ2VudDogdGhpcy51c2VyQWdlbnQsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gU2Vzc2lvbjtcbn0oKSk7XG5leHBvcnRzLlNlc3Npb24gPSBTZXNzaW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2Vzc2lvbi5qcy5tYXAiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbi8qIGVzbGludC1kaXNhYmxlIG1heC1saW5lcyAqL1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiQHNlbnRyeS90eXBlc1wiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIkBzZW50cnkvdXRpbHNcIik7XG52YXIgc2NvcGVfMSA9IHJlcXVpcmUoXCIuL3Njb3BlXCIpO1xudmFyIHNlc3Npb25fMSA9IHJlcXVpcmUoXCIuL3Nlc3Npb25cIik7XG4vKipcbiAqIEFQSSBjb21wYXRpYmlsaXR5IHZlcnNpb24gb2YgdGhpcyBodWIuXG4gKlxuICogV0FSTklORzogVGhpcyBudW1iZXIgc2hvdWxkIG9ubHkgYmUgaW5jcmVhc2VkIHdoZW4gdGhlIGdsb2JhbCBpbnRlcmZhY2VcbiAqIGNoYW5nZXMgYW5kIG5ldyBtZXRob2RzIGFyZSBpbnRyb2R1Y2VkLlxuICpcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0cy5BUElfVkVSU0lPTiA9IDQ7XG4vKipcbiAqIERlZmF1bHQgbWF4aW11bSBudW1iZXIgb2YgYnJlYWRjcnVtYnMgYWRkZWQgdG8gYW4gZXZlbnQuIENhbiBiZSBvdmVyd3JpdHRlblxuICogd2l0aCB7QGxpbmsgT3B0aW9ucy5tYXhCcmVhZGNydW1ic30uXG4gKi9cbnZhciBERUZBVUxUX0JSRUFEQ1JVTUJTID0gMTAwO1xuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG52YXIgSHViID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGh1Yiwgd2lsbCBwdXNoIG9uZSB7QGxpbmsgTGF5ZXJ9IGludG8gdGhlXG4gICAgICogaW50ZXJuYWwgc3RhY2sgb24gY3JlYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2xpZW50IGJvdW5kIHRvIHRoZSBodWIuXG4gICAgICogQHBhcmFtIHNjb3BlIGJvdW5kIHRvIHRoZSBodWIuXG4gICAgICogQHBhcmFtIHZlcnNpb24gbnVtYmVyLCBoaWdoZXIgbnVtYmVyIG1lYW5zIGhpZ2hlciBwcmlvcml0eS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBIdWIoY2xpZW50LCBzY29wZSwgX3ZlcnNpb24pIHtcbiAgICAgICAgaWYgKHNjb3BlID09PSB2b2lkIDApIHsgc2NvcGUgPSBuZXcgc2NvcGVfMS5TY29wZSgpOyB9XG4gICAgICAgIGlmIChfdmVyc2lvbiA9PT0gdm9pZCAwKSB7IF92ZXJzaW9uID0gZXhwb3J0cy5BUElfVkVSU0lPTjsgfVxuICAgICAgICB0aGlzLl92ZXJzaW9uID0gX3ZlcnNpb247XG4gICAgICAgIC8qKiBJcyBhIHtAbGluayBMYXllcn1bXSBjb250YWluaW5nIHRoZSBjbGllbnQgYW5kIHNjb3BlICovXG4gICAgICAgIHRoaXMuX3N0YWNrID0gW3t9XTtcbiAgICAgICAgdGhpcy5nZXRTdGFja1RvcCgpLnNjb3BlID0gc2NvcGU7XG4gICAgICAgIGlmIChjbGllbnQpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZENsaWVudChjbGllbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgSHViLnByb3RvdHlwZS5pc09sZGVyVGhhbiA9IGZ1bmN0aW9uICh2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92ZXJzaW9uIDwgdmVyc2lvbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgSHViLnByb3RvdHlwZS5iaW5kQ2xpZW50ID0gZnVuY3Rpb24gKGNsaWVudCkge1xuICAgICAgICB2YXIgdG9wID0gdGhpcy5nZXRTdGFja1RvcCgpO1xuICAgICAgICB0b3AuY2xpZW50ID0gY2xpZW50O1xuICAgICAgICBpZiAoY2xpZW50ICYmIGNsaWVudC5zZXR1cEludGVncmF0aW9ucykge1xuICAgICAgICAgICAgY2xpZW50LnNldHVwSW50ZWdyYXRpb25zKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgSHViLnByb3RvdHlwZS5wdXNoU2NvcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gY2xvbmUgdGhlIGNvbnRlbnQgb2YgcHJldiBzY29wZVxuICAgICAgICB2YXIgc2NvcGUgPSBzY29wZV8xLlNjb3BlLmNsb25lKHRoaXMuZ2V0U2NvcGUoKSk7XG4gICAgICAgIHRoaXMuZ2V0U3RhY2soKS5wdXNoKHtcbiAgICAgICAgICAgIGNsaWVudDogdGhpcy5nZXRDbGllbnQoKSxcbiAgICAgICAgICAgIHNjb3BlOiBzY29wZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzY29wZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgSHViLnByb3RvdHlwZS5wb3BTY29wZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0U3RhY2soKS5sZW5ndGggPD0gMSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5nZXRTdGFjaygpLnBvcCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBIdWIucHJvdG90eXBlLndpdGhTY29wZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzLnB1c2hTY29wZSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2FsbGJhY2soc2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5wb3BTY29wZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIEh1Yi5wcm90b3R5cGUuZ2V0Q2xpZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGFja1RvcCgpLmNsaWVudDtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIHRoZSBzY29wZSBvZiB0aGUgdG9wIHN0YWNrLiAqL1xuICAgIEh1Yi5wcm90b3R5cGUuZ2V0U2NvcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YWNrVG9wKCkuc2NvcGU7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyB0aGUgc2NvcGUgc3RhY2sgZm9yIGRvbWFpbnMgb3IgdGhlIHByb2Nlc3MuICovXG4gICAgSHViLnByb3RvdHlwZS5nZXRTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YWNrO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgdGhlIHRvcG1vc3Qgc2NvcGUgbGF5ZXIgaW4gdGhlIG9yZGVyIGRvbWFpbiA+IGxvY2FsID4gcHJvY2Vzcy4gKi9cbiAgICBIdWIucHJvdG90eXBlLmdldFN0YWNrVG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhY2tbdGhpcy5fc3RhY2subGVuZ3RoIC0gMV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG4gICAgSHViLnByb3RvdHlwZS5jYXB0dXJlRXhjZXB0aW9uID0gZnVuY3Rpb24gKGV4Y2VwdGlvbiwgaGludCkge1xuICAgICAgICB2YXIgZXZlbnRJZCA9ICh0aGlzLl9sYXN0RXZlbnRJZCA9IHV0aWxzXzEudXVpZDQoKSk7XG4gICAgICAgIHZhciBmaW5hbEhpbnQgPSBoaW50O1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGV4cGxpY2l0IGhpbnQgcHJvdmlkZWQsIG1pbWljIHRoZSBzYW1lIHRoaW5nIHRoYXQgd291bGQgaGFwcGVuXG4gICAgICAgIC8vIGluIHRoZSBtaW5pbWFsIGl0c2VsZiB0byBjcmVhdGUgYSBjb25zaXN0ZW50IGJlaGF2aW9yLlxuICAgICAgICAvLyBXZSBkb24ndCBkbyB0aGlzIGluIHRoZSBjbGllbnQsIGFzIGl0J3MgdGhlIGxvd2VzdCBsZXZlbCBBUEksIGFuZCBkb2luZyB0aGlzLFxuICAgICAgICAvLyB3b3VsZCBwcmV2ZW50IHVzZXIgZnJvbSBoYXZpbmcgZnVsbCBjb250cm9sIG92ZXIgZGlyZWN0IGNhbGxzLlxuICAgICAgICBpZiAoIWhpbnQpIHtcbiAgICAgICAgICAgIHZhciBzeW50aGV0aWNFeGNlcHRpb24gPSB2b2lkIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2VudHJ5IHN5bnRoZXRpY0V4Y2VwdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgIHN5bnRoZXRpY0V4Y2VwdGlvbiA9IGV4Y2VwdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsSGludCA9IHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV4Y2VwdGlvbjogZXhjZXB0aW9uLFxuICAgICAgICAgICAgICAgIHN5bnRoZXRpY0V4Y2VwdGlvbjogc3ludGhldGljRXhjZXB0aW9uLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnZva2VDbGllbnQoJ2NhcHR1cmVFeGNlcHRpb24nLCBleGNlcHRpb24sIHRzbGliXzEuX19hc3NpZ24odHNsaWJfMS5fX2Fzc2lnbih7fSwgZmluYWxIaW50KSwgeyBldmVudF9pZDogZXZlbnRJZCB9KSk7XG4gICAgICAgIHJldHVybiBldmVudElkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBIdWIucHJvdG90eXBlLmNhcHR1cmVNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGxldmVsLCBoaW50KSB7XG4gICAgICAgIHZhciBldmVudElkID0gKHRoaXMuX2xhc3RFdmVudElkID0gdXRpbHNfMS51dWlkNCgpKTtcbiAgICAgICAgdmFyIGZpbmFsSGludCA9IGhpbnQ7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gZXhwbGljaXQgaGludCBwcm92aWRlZCwgbWltaWMgdGhlIHNhbWUgdGhpbmcgdGhhdCB3b3VsZCBoYXBwZW5cbiAgICAgICAgLy8gaW4gdGhlIG1pbmltYWwgaXRzZWxmIHRvIGNyZWF0ZSBhIGNvbnNpc3RlbnQgYmVoYXZpb3IuXG4gICAgICAgIC8vIFdlIGRvbid0IGRvIHRoaXMgaW4gdGhlIGNsaWVudCwgYXMgaXQncyB0aGUgbG93ZXN0IGxldmVsIEFQSSwgYW5kIGRvaW5nIHRoaXMsXG4gICAgICAgIC8vIHdvdWxkIHByZXZlbnQgdXNlciBmcm9tIGhhdmluZyBmdWxsIGNvbnRyb2wgb3ZlciBkaXJlY3QgY2FsbHMuXG4gICAgICAgIGlmICghaGludCkge1xuICAgICAgICAgICAgdmFyIHN5bnRoZXRpY0V4Y2VwdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgIHN5bnRoZXRpY0V4Y2VwdGlvbiA9IGV4Y2VwdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsSGludCA9IHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV4Y2VwdGlvbjogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICBzeW50aGV0aWNFeGNlcHRpb246IHN5bnRoZXRpY0V4Y2VwdGlvbixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW52b2tlQ2xpZW50KCdjYXB0dXJlTWVzc2FnZScsIG1lc3NhZ2UsIGxldmVsLCB0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24oe30sIGZpbmFsSGludCksIHsgZXZlbnRfaWQ6IGV2ZW50SWQgfSkpO1xuICAgICAgICByZXR1cm4gZXZlbnRJZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgSHViLnByb3RvdHlwZS5jYXB0dXJlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQsIGhpbnQpIHtcbiAgICAgICAgdmFyIGV2ZW50SWQgPSB1dGlsc18xLnV1aWQ0KCk7XG4gICAgICAgIGlmIChldmVudC50eXBlICE9PSAndHJhbnNhY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0RXZlbnRJZCA9IGV2ZW50SWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW52b2tlQ2xpZW50KCdjYXB0dXJlRXZlbnQnLCBldmVudCwgdHNsaWJfMS5fX2Fzc2lnbih0c2xpYl8xLl9fYXNzaWduKHt9LCBoaW50KSwgeyBldmVudF9pZDogZXZlbnRJZCB9KSk7XG4gICAgICAgIHJldHVybiBldmVudElkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBIdWIucHJvdG90eXBlLmxhc3RFdmVudElkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGFzdEV2ZW50SWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIEh1Yi5wcm90b3R5cGUuYWRkQnJlYWRjcnVtYiA9IGZ1bmN0aW9uIChicmVhZGNydW1iLCBoaW50KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0U3RhY2tUb3AoKSwgc2NvcGUgPSBfYS5zY29wZSwgY2xpZW50ID0gX2EuY2xpZW50O1xuICAgICAgICBpZiAoIXNjb3BlIHx8ICFjbGllbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgICAgdmFyIF9iID0gKGNsaWVudC5nZXRPcHRpb25zICYmIGNsaWVudC5nZXRPcHRpb25zKCkpIHx8IHt9LCBfYyA9IF9iLmJlZm9yZUJyZWFkY3J1bWIsIGJlZm9yZUJyZWFkY3J1bWIgPSBfYyA9PT0gdm9pZCAwID8gbnVsbCA6IF9jLCBfZCA9IF9iLm1heEJyZWFkY3J1bWJzLCBtYXhCcmVhZGNydW1icyA9IF9kID09PSB2b2lkIDAgPyBERUZBVUxUX0JSRUFEQ1JVTUJTIDogX2Q7XG4gICAgICAgIGlmIChtYXhCcmVhZGNydW1icyA8PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgdGltZXN0YW1wID0gdXRpbHNfMS5kYXRlVGltZXN0YW1wSW5TZWNvbmRzKCk7XG4gICAgICAgIHZhciBtZXJnZWRCcmVhZGNydW1iID0gdHNsaWJfMS5fX2Fzc2lnbih7IHRpbWVzdGFtcDogdGltZXN0YW1wIH0sIGJyZWFkY3J1bWIpO1xuICAgICAgICB2YXIgZmluYWxCcmVhZGNydW1iID0gYmVmb3JlQnJlYWRjcnVtYlxuICAgICAgICAgICAgPyB1dGlsc18xLmNvbnNvbGVTYW5kYm94KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJlZm9yZUJyZWFkY3J1bWIobWVyZ2VkQnJlYWRjcnVtYiwgaGludCk7IH0pXG4gICAgICAgICAgICA6IG1lcmdlZEJyZWFkY3J1bWI7XG4gICAgICAgIGlmIChmaW5hbEJyZWFkY3J1bWIgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNjb3BlLmFkZEJyZWFkY3J1bWIoZmluYWxCcmVhZGNydW1iLCBtYXhCcmVhZGNydW1icyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIEh1Yi5wcm90b3R5cGUuc2V0VXNlciA9IGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHZhciBzY29wZSA9IHRoaXMuZ2V0U2NvcGUoKTtcbiAgICAgICAgaWYgKHNjb3BlKVxuICAgICAgICAgICAgc2NvcGUuc2V0VXNlcih1c2VyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgSHViLnByb3RvdHlwZS5zZXRUYWdzID0gZnVuY3Rpb24gKHRhZ3MpIHtcbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcy5nZXRTY29wZSgpO1xuICAgICAgICBpZiAoc2NvcGUpXG4gICAgICAgICAgICBzY29wZS5zZXRUYWdzKHRhZ3MpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBIdWIucHJvdG90eXBlLnNldEV4dHJhcyA9IGZ1bmN0aW9uIChleHRyYXMpIHtcbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcy5nZXRTY29wZSgpO1xuICAgICAgICBpZiAoc2NvcGUpXG4gICAgICAgICAgICBzY29wZS5zZXRFeHRyYXMoZXh0cmFzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgSHViLnByb3RvdHlwZS5zZXRUYWcgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzLmdldFNjb3BlKCk7XG4gICAgICAgIGlmIChzY29wZSlcbiAgICAgICAgICAgIHNjb3BlLnNldFRhZyhrZXksIHZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgSHViLnByb3RvdHlwZS5zZXRFeHRyYSA9IGZ1bmN0aW9uIChrZXksIGV4dHJhKSB7XG4gICAgICAgIHZhciBzY29wZSA9IHRoaXMuZ2V0U2NvcGUoKTtcbiAgICAgICAgaWYgKHNjb3BlKVxuICAgICAgICAgICAgc2NvcGUuc2V0RXh0cmEoa2V5LCBleHRyYSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgSHViLnByb3RvdHlwZS5zZXRDb250ZXh0ID0gZnVuY3Rpb24gKG5hbWUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcy5nZXRTY29wZSgpO1xuICAgICAgICBpZiAoc2NvcGUpXG4gICAgICAgICAgICBzY29wZS5zZXRDb250ZXh0KG5hbWUsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBIdWIucHJvdG90eXBlLmNvbmZpZ3VyZVNjb3BlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0U3RhY2tUb3AoKSwgc2NvcGUgPSBfYS5zY29wZSwgY2xpZW50ID0gX2EuY2xpZW50O1xuICAgICAgICBpZiAoc2NvcGUgJiYgY2xpZW50KSB7XG4gICAgICAgICAgICBjYWxsYmFjayhzY29wZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgSHViLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9sZEh1YiA9IG1ha2VNYWluKHRoaXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2FsbGJhY2sodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBtYWtlTWFpbihvbGRIdWIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIEh1Yi5wcm90b3R5cGUuZ2V0SW50ZWdyYXRpb24gPSBmdW5jdGlvbiAoaW50ZWdyYXRpb24pIHtcbiAgICAgICAgdmFyIGNsaWVudCA9IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgICAgIGlmICghY2xpZW50KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gY2xpZW50LmdldEludGVncmF0aW9uKGludGVncmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX29PKSB7XG4gICAgICAgICAgICB1dGlsc18xLmxvZ2dlci53YXJuKFwiQ2Fubm90IHJldHJpZXZlIGludGVncmF0aW9uIFwiICsgaW50ZWdyYXRpb24uaWQgKyBcIiBmcm9tIHRoZSBjdXJyZW50IEh1YlwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIEh1Yi5wcm90b3R5cGUuc3RhcnRTcGFuID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxFeHRlbnNpb25NZXRob2QoJ3N0YXJ0U3BhbicsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBIdWIucHJvdG90eXBlLnN0YXJ0VHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoY29udGV4dCwgY3VzdG9tU2FtcGxpbmdDb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsRXh0ZW5zaW9uTWV0aG9kKCdzdGFydFRyYW5zYWN0aW9uJywgY29udGV4dCwgY3VzdG9tU2FtcGxpbmdDb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgSHViLnByb3RvdHlwZS50cmFjZUhlYWRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsRXh0ZW5zaW9uTWV0aG9kKCd0cmFjZUhlYWRlcnMnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgSHViLnByb3RvdHlwZS5jYXB0dXJlU2Vzc2lvbiA9IGZ1bmN0aW9uIChlbmRTZXNzaW9uKSB7XG4gICAgICAgIGlmIChlbmRTZXNzaW9uID09PSB2b2lkIDApIHsgZW5kU2Vzc2lvbiA9IGZhbHNlOyB9XG4gICAgICAgIC8vIGJvdGggc2VuZCB0aGUgdXBkYXRlIGFuZCBwdWxsIHRoZSBzZXNzaW9uIGZyb20gdGhlIHNjb3BlXG4gICAgICAgIGlmIChlbmRTZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmRTZXNzaW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb25seSBzZW5kIHRoZSB1cGRhdGVcbiAgICAgICAgdGhpcy5fc2VuZFNlc3Npb25VcGRhdGUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgSHViLnByb3RvdHlwZS5lbmRTZXNzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLmdldFN0YWNrVG9wKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zY29wZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldFNlc3Npb24oKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX3NlbmRTZXNzaW9uVXBkYXRlKCk7XG4gICAgICAgIC8vIHRoZSBzZXNzaW9uIGlzIG92ZXI7IHRha2UgaXQgb2ZmIG9mIHRoZSBzY29wZVxuICAgICAgICAoX2UgPSAoX2QgPSB0aGlzLmdldFN0YWNrVG9wKCkpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5zY29wZSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnNldFNlc3Npb24oKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgSHViLnByb3RvdHlwZS5zdGFydFNlc3Npb24gPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmdldFN0YWNrVG9wKCksIHNjb3BlID0gX2Euc2NvcGUsIGNsaWVudCA9IF9hLmNsaWVudDtcbiAgICAgICAgdmFyIF9iID0gKGNsaWVudCAmJiBjbGllbnQuZ2V0T3B0aW9ucygpKSB8fCB7fSwgcmVsZWFzZSA9IF9iLnJlbGVhc2UsIGVudmlyb25tZW50ID0gX2IuZW52aXJvbm1lbnQ7XG4gICAgICAgIC8vIFdpbGwgZmV0Y2ggdXNlckFnZW50IGlmIGNhbGxlZCBmcm9tIGJyb3dzZXIgc2RrXG4gICAgICAgIHZhciBnbG9iYWwgPSB1dGlsc18xLmdldEdsb2JhbE9iamVjdCgpO1xuICAgICAgICB2YXIgdXNlckFnZW50ID0gKGdsb2JhbC5uYXZpZ2F0b3IgfHwge30pLnVzZXJBZ2VudDtcbiAgICAgICAgdmFyIHNlc3Npb24gPSBuZXcgc2Vzc2lvbl8xLlNlc3Npb24odHNsaWJfMS5fX2Fzc2lnbih0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24oeyByZWxlYXNlOiByZWxlYXNlLFxuICAgICAgICAgICAgZW52aXJvbm1lbnQ6IGVudmlyb25tZW50IH0sIChzY29wZSAmJiB7IHVzZXI6IHNjb3BlLmdldFVzZXIoKSB9KSksICh1c2VyQWdlbnQgJiYgeyB1c2VyQWdlbnQ6IHVzZXJBZ2VudCB9KSksIGNvbnRleHQpKTtcbiAgICAgICAgaWYgKHNjb3BlKSB7XG4gICAgICAgICAgICAvLyBFbmQgZXhpc3Rpbmcgc2Vzc2lvbiBpZiB0aGVyZSdzIG9uZVxuICAgICAgICAgICAgdmFyIGN1cnJlbnRTZXNzaW9uID0gc2NvcGUuZ2V0U2Vzc2lvbiAmJiBzY29wZS5nZXRTZXNzaW9uKCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFNlc3Npb24gJiYgY3VycmVudFNlc3Npb24uc3RhdHVzID09PSB0eXBlc18xLlNlc3Npb25TdGF0dXMuT2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbi51cGRhdGUoeyBzdGF0dXM6IHR5cGVzXzEuU2Vzc2lvblN0YXR1cy5FeGl0ZWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVuZFNlc3Npb24oKTtcbiAgICAgICAgICAgIC8vIEFmdGVyd2FyZHMgd2Ugc2V0IHRoZSBuZXcgc2Vzc2lvbiBvbiB0aGUgc2NvcGVcbiAgICAgICAgICAgIHNjb3BlLnNldFNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlc3Npb247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kcyB0aGUgY3VycmVudCBTZXNzaW9uIG9uIHRoZSBzY29wZVxuICAgICAqL1xuICAgIEh1Yi5wcm90b3R5cGUuX3NlbmRTZXNzaW9uVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmdldFN0YWNrVG9wKCksIHNjb3BlID0gX2Euc2NvcGUsIGNsaWVudCA9IF9hLmNsaWVudDtcbiAgICAgICAgaWYgKCFzY29wZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHNlc3Npb24gPSBzY29wZS5nZXRTZXNzaW9uICYmIHNjb3BlLmdldFNlc3Npb24oKTtcbiAgICAgICAgaWYgKHNlc3Npb24pIHtcbiAgICAgICAgICAgIGlmIChjbGllbnQgJiYgY2xpZW50LmNhcHR1cmVTZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgY2xpZW50LmNhcHR1cmVTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gdG8gY2FsbCBhIG1ldGhvZCBvbiB0aGUgdG9wIGNsaWVudCBpZiBpdCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWV0aG9kIFRoZSBtZXRob2QgdG8gY2FsbCBvbiB0aGUgY2xpZW50LlxuICAgICAqIEBwYXJhbSBhcmdzIEFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBjbGllbnQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBIdWIucHJvdG90eXBlLl9pbnZva2VDbGllbnQgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9iID0gdGhpcy5nZXRTdGFja1RvcCgpLCBzY29wZSA9IF9iLnNjb3BlLCBjbGllbnQgPSBfYi5jbGllbnQ7XG4gICAgICAgIGlmIChjbGllbnQgJiYgY2xpZW50W21ldGhvZF0pIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIChfYSA9IGNsaWVudClbbWV0aG9kXS5hcHBseShfYSwgdHNsaWJfMS5fX3NwcmVhZChhcmdzLCBbc2NvcGVdKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxzIGdsb2JhbCBleHRlbnNpb24gbWV0aG9kIGFuZCBiaW5kaW5nIGN1cnJlbnQgaW5zdGFuY2UgdG8gdGhlIGZ1bmN0aW9uIGNhbGxcbiAgICAgKi9cbiAgICAvLyBAdHMtaWdub3JlIEZ1bmN0aW9uIGxhY2tzIGVuZGluZyByZXR1cm4gc3RhdGVtZW50IGFuZCByZXR1cm4gdHlwZSBkb2VzIG5vdCBpbmNsdWRlICd1bmRlZmluZWQnLiB0cygyMzY2KVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgSHViLnByb3RvdHlwZS5fY2FsbEV4dGVuc2lvbk1ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhcnJpZXIgPSBnZXRNYWluQ2FycmllcigpO1xuICAgICAgICB2YXIgc2VudHJ5ID0gY2Fycmllci5fX1NFTlRSWV9fO1xuICAgICAgICBpZiAoc2VudHJ5ICYmIHNlbnRyeS5leHRlbnNpb25zICYmIHR5cGVvZiBzZW50cnkuZXh0ZW5zaW9uc1ttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VudHJ5LmV4dGVuc2lvbnNbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsc18xLmxvZ2dlci53YXJuKFwiRXh0ZW5zaW9uIG1ldGhvZCBcIiArIG1ldGhvZCArIFwiIGNvdWxkbid0IGJlIGZvdW5kLCBkb2luZyBub3RoaW5nLlwiKTtcbiAgICB9O1xuICAgIHJldHVybiBIdWI7XG59KCkpO1xuZXhwb3J0cy5IdWIgPSBIdWI7XG4vKipcbiAqIFJldHVybnMgdGhlIGdsb2JhbCBzaGltIHJlZ2lzdHJ5LlxuICpcbiAqIEZJWE1FOiBUaGlzIGZ1bmN0aW9uIGlzIHByb2JsZW1hdGljLCBiZWNhdXNlIGRlc3BpdGUgYWx3YXlzIHJldHVybmluZyBhIHZhbGlkIENhcnJpZXIsXG4gKiBpdCBoYXMgYW4gb3B0aW9uYWwgYF9fU0VOVFJZX19gIHByb3BlcnR5LCB3aGljaCB0aGVuIGluIHR1cm4gcmVxdWlyZXMgdXMgdG8gYWx3YXlzIHBlcmZvcm0gYW4gdW5uZWNlc3NhcnkgY2hlY2tcbiAqIGF0IHRoZSBjYWxsLXNpdGUuIFdlIGFsd2F5cyBhY2Nlc3MgdGhlIGNhcnJpZXIgdGhyb3VnaCB0aGlzIGZ1bmN0aW9uLCBzbyB3ZSBjYW4gZ3VhcmFudGVlIHRoYXQgYF9fU0VOVFJZX19gIGlzIHRoZXJlLlxuICoqL1xuZnVuY3Rpb24gZ2V0TWFpbkNhcnJpZXIoKSB7XG4gICAgdmFyIGNhcnJpZXIgPSB1dGlsc18xLmdldEdsb2JhbE9iamVjdCgpO1xuICAgIGNhcnJpZXIuX19TRU5UUllfXyA9IGNhcnJpZXIuX19TRU5UUllfXyB8fCB7XG4gICAgICAgIGV4dGVuc2lvbnM6IHt9LFxuICAgICAgICBodWI6IHVuZGVmaW5lZCxcbiAgICB9O1xuICAgIHJldHVybiBjYXJyaWVyO1xufVxuZXhwb3J0cy5nZXRNYWluQ2FycmllciA9IGdldE1haW5DYXJyaWVyO1xuLyoqXG4gKiBSZXBsYWNlcyB0aGUgY3VycmVudCBtYWluIGh1YiB3aXRoIHRoZSBwYXNzZWQgb25lIG9uIHRoZSBnbG9iYWwgb2JqZWN0XG4gKlxuICogQHJldHVybnMgVGhlIG9sZCByZXBsYWNlZCBodWJcbiAqL1xuZnVuY3Rpb24gbWFrZU1haW4oaHViKSB7XG4gICAgdmFyIHJlZ2lzdHJ5ID0gZ2V0TWFpbkNhcnJpZXIoKTtcbiAgICB2YXIgb2xkSHViID0gZ2V0SHViRnJvbUNhcnJpZXIocmVnaXN0cnkpO1xuICAgIHNldEh1Yk9uQ2FycmllcihyZWdpc3RyeSwgaHViKTtcbiAgICByZXR1cm4gb2xkSHViO1xufVxuZXhwb3J0cy5tYWtlTWFpbiA9IG1ha2VNYWluO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBkZWZhdWx0IGh1YiBpbnN0YW5jZS5cbiAqXG4gKiBJZiBhIGh1YiBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQgaW4gdGhlIGdsb2JhbCBjYXJyaWVyIGJ1dCB0aGlzIG1vZHVsZVxuICogY29udGFpbnMgYSBtb3JlIHJlY2VudCB2ZXJzaW9uLCBpdCByZXBsYWNlcyB0aGUgcmVnaXN0ZXJlZCB2ZXJzaW9uLlxuICogT3RoZXJ3aXNlLCB0aGUgY3VycmVudGx5IHJlZ2lzdGVyZWQgaHViIHdpbGwgYmUgcmV0dXJuZWQuXG4gKi9cbmZ1bmN0aW9uIGdldEN1cnJlbnRIdWIoKSB7XG4gICAgLy8gR2V0IG1haW4gY2FycmllciAoZ2xvYmFsIGZvciBldmVyeSBlbnZpcm9ubWVudClcbiAgICB2YXIgcmVnaXN0cnkgPSBnZXRNYWluQ2FycmllcigpO1xuICAgIC8vIElmIHRoZXJlJ3Mgbm8gaHViLCBvciBpdHMgYW4gb2xkIEFQSSwgYXNzaWduIGEgbmV3IG9uZVxuICAgIGlmICghaGFzSHViT25DYXJyaWVyKHJlZ2lzdHJ5KSB8fCBnZXRIdWJGcm9tQ2FycmllcihyZWdpc3RyeSkuaXNPbGRlclRoYW4oZXhwb3J0cy5BUElfVkVSU0lPTikpIHtcbiAgICAgICAgc2V0SHViT25DYXJyaWVyKHJlZ2lzdHJ5LCBuZXcgSHViKCkpO1xuICAgIH1cbiAgICAvLyBQcmVmZXIgZG9tYWlucyBvdmVyIGdsb2JhbCBpZiB0aGV5IGFyZSB0aGVyZSAoYXBwbGljYWJsZSBvbmx5IHRvIE5vZGUgZW52aXJvbm1lbnQpXG4gICAgaWYgKHV0aWxzXzEuaXNOb2RlRW52KCkpIHtcbiAgICAgICAgcmV0dXJuIGdldEh1YkZyb21BY3RpdmVEb21haW4ocmVnaXN0cnkpO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gaHViIHRoYXQgbGl2ZXMgb24gYSBnbG9iYWwgb2JqZWN0XG4gICAgcmV0dXJuIGdldEh1YkZyb21DYXJyaWVyKHJlZ2lzdHJ5KTtcbn1cbmV4cG9ydHMuZ2V0Q3VycmVudEh1YiA9IGdldEN1cnJlbnRIdWI7XG4vKipcbiAqIFJldHVybnMgdGhlIGFjdGl2ZSBkb21haW4sIGlmIG9uZSBleGlzdHNcbiAqIEBkZXByZWNhdGVkIE5vIGxvbmdlciB1c2VkOyByZW1vdmUgaW4gdjdcbiAqIEByZXR1cm5zIFRoZSBkb21haW4sIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBhY3RpdmUgZG9tYWluXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuZnVuY3Rpb24gZ2V0QWN0aXZlRG9tYWluKCkge1xuICAgIHV0aWxzXzEubG9nZ2VyLndhcm4oJ0Z1bmN0aW9uIGBnZXRBY3RpdmVEb21haW5gIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLicpO1xuICAgIHZhciBzZW50cnkgPSBnZXRNYWluQ2FycmllcigpLl9fU0VOVFJZX187XG4gICAgcmV0dXJuIHNlbnRyeSAmJiBzZW50cnkuZXh0ZW5zaW9ucyAmJiBzZW50cnkuZXh0ZW5zaW9ucy5kb21haW4gJiYgc2VudHJ5LmV4dGVuc2lvbnMuZG9tYWluLmFjdGl2ZTtcbn1cbmV4cG9ydHMuZ2V0QWN0aXZlRG9tYWluID0gZ2V0QWN0aXZlRG9tYWluO1xuLyoqXG4gKiBUcnkgdG8gcmVhZCB0aGUgaHViIGZyb20gYW4gYWN0aXZlIGRvbWFpbiwgYW5kIGZhbGxiYWNrIHRvIHRoZSByZWdpc3RyeSBpZiBvbmUgZG9lc24ndCBleGlzdFxuICogQHJldHVybnMgZGlzY292ZXJlZCBodWJcbiAqL1xuZnVuY3Rpb24gZ2V0SHViRnJvbUFjdGl2ZURvbWFpbihyZWdpc3RyeSkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBhY3RpdmVEb21haW4gPSAoX2MgPSAoX2IgPSAoX2EgPSBnZXRNYWluQ2FycmllcigpLl9fU0VOVFJZX18pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5leHRlbnNpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZG9tYWluKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYWN0aXZlO1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGFjdGl2ZSBkb21haW4sIGp1c3QgcmV0dXJuIGdsb2JhbCBodWJcbiAgICAgICAgaWYgKCFhY3RpdmVEb21haW4pIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRIdWJGcm9tQ2FycmllcihyZWdpc3RyeSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBodWIgb24gY3VycmVudCBkb21haW4sIG9yIGl0J3MgYW4gb2xkIEFQSSwgYXNzaWduIGEgbmV3IG9uZVxuICAgICAgICBpZiAoIWhhc0h1Yk9uQ2FycmllcihhY3RpdmVEb21haW4pIHx8IGdldEh1YkZyb21DYXJyaWVyKGFjdGl2ZURvbWFpbikuaXNPbGRlclRoYW4oZXhwb3J0cy5BUElfVkVSU0lPTikpIHtcbiAgICAgICAgICAgIHZhciByZWdpc3RyeUh1YlRvcFN0YWNrID0gZ2V0SHViRnJvbUNhcnJpZXIocmVnaXN0cnkpLmdldFN0YWNrVG9wKCk7XG4gICAgICAgICAgICBzZXRIdWJPbkNhcnJpZXIoYWN0aXZlRG9tYWluLCBuZXcgSHViKHJlZ2lzdHJ5SHViVG9wU3RhY2suY2xpZW50LCBzY29wZV8xLlNjb3BlLmNsb25lKHJlZ2lzdHJ5SHViVG9wU3RhY2suc2NvcGUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIGh1YiB0aGF0IGxpdmVzIG9uIGEgZG9tYWluXG4gICAgICAgIHJldHVybiBnZXRIdWJGcm9tQ2FycmllcihhY3RpdmVEb21haW4pO1xuICAgIH1cbiAgICBjYXRjaCAoX09vKSB7XG4gICAgICAgIC8vIFJldHVybiBodWIgdGhhdCBsaXZlcyBvbiBhIGdsb2JhbCBvYmplY3RcbiAgICAgICAgcmV0dXJuIGdldEh1YkZyb21DYXJyaWVyKHJlZ2lzdHJ5KTtcbiAgICB9XG59XG4vKipcbiAqIFRoaXMgd2lsbCB0ZWxsIHdoZXRoZXIgYSBjYXJyaWVyIGhhcyBhIGh1YiBvbiBpdCBvciBub3RcbiAqIEBwYXJhbSBjYXJyaWVyIG9iamVjdFxuICovXG5mdW5jdGlvbiBoYXNIdWJPbkNhcnJpZXIoY2Fycmllcikge1xuICAgIHJldHVybiAhIShjYXJyaWVyICYmIGNhcnJpZXIuX19TRU5UUllfXyAmJiBjYXJyaWVyLl9fU0VOVFJZX18uaHViKTtcbn1cbi8qKlxuICogVGhpcyB3aWxsIGNyZWF0ZSBhIG5ldyB7QGxpbmsgSHVifSBhbmQgYWRkIHRvIHRoZSBwYXNzZWQgb2JqZWN0IG9uXG4gKiBfX1NFTlRSWV9fLmh1Yi5cbiAqIEBwYXJhbSBjYXJyaWVyIG9iamVjdFxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBnZXRIdWJGcm9tQ2FycmllcihjYXJyaWVyKSB7XG4gICAgaWYgKGNhcnJpZXIgJiYgY2Fycmllci5fX1NFTlRSWV9fICYmIGNhcnJpZXIuX19TRU5UUllfXy5odWIpXG4gICAgICAgIHJldHVybiBjYXJyaWVyLl9fU0VOVFJZX18uaHViO1xuICAgIGNhcnJpZXIuX19TRU5UUllfXyA9IGNhcnJpZXIuX19TRU5UUllfXyB8fCB7fTtcbiAgICBjYXJyaWVyLl9fU0VOVFJZX18uaHViID0gbmV3IEh1YigpO1xuICAgIHJldHVybiBjYXJyaWVyLl9fU0VOVFJZX18uaHViO1xufVxuZXhwb3J0cy5nZXRIdWJGcm9tQ2FycmllciA9IGdldEh1YkZyb21DYXJyaWVyO1xuLyoqXG4gKiBUaGlzIHdpbGwgc2V0IHBhc3NlZCB7QGxpbmsgSHVifSBvbiB0aGUgcGFzc2VkIG9iamVjdCdzIF9fU0VOVFJZX18uaHViIGF0dHJpYnV0ZVxuICogQHBhcmFtIGNhcnJpZXIgb2JqZWN0XG4gKiBAcGFyYW0gaHViIEh1YlxuICogQHJldHVybnMgQSBib29sZWFuIGluZGljYXRpbmcgc3VjY2VzcyBvciBmYWlsdXJlXG4gKi9cbmZ1bmN0aW9uIHNldEh1Yk9uQ2FycmllcihjYXJyaWVyLCBodWIpIHtcbiAgICBpZiAoIWNhcnJpZXIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjYXJyaWVyLl9fU0VOVFJZX18gPSBjYXJyaWVyLl9fU0VOVFJZX18gfHwge307XG4gICAgY2Fycmllci5fX1NFTlRSWV9fLmh1YiA9IGh1YjtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuc2V0SHViT25DYXJyaWVyID0gc2V0SHViT25DYXJyaWVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHViLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHByb21pc2VUb0NhbGxiYWNrID0gcmVxdWlyZSgncHJvbWlzZS10by1jYWxsYmFjaycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV0aFJQQztcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIHRoZSBFdGhSUEMgaW5zdGFuY2VcbiAqXG4gKiBAbWV0aG9kIEV0aFJQQ1xuICogQHBhcmFtIHtPYmplY3R9IGNwcm92aWRlciB0aGUgZXRoIHJwYyBwcm92aWRlciB3ZWIzIHN0YW5kYXJkLi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zLCBpZiBhbnlcbiAqIEByZXR1cm5zIHtPYmplY3R9IGV0aHJwYyBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBFdGhSUEMoY3Byb3ZpZGVyLCBvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIG9wdGlvbnNPYmplY3QgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFdGhSUEMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtcnBjXSB0aGUgRXRoUlBDIG9iamVjdCByZXF1aXJlcyB0aGUgXCJuZXdcIiBmbGFnIGluIG9yZGVyIHRvIGZ1bmN0aW9uIG5vcm1hbGx5IChpLmUuIGBjb25zdCBldGggPSBuZXcgRXRoUlBDKHByb3ZpZGVyKTtgKS4nKTtcbiAgfVxuXG4gIHNlbGYub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIGpzb25TcGFjZTogb3B0aW9uc09iamVjdC5qc29uU3BhY2UgfHwgMCxcbiAgICBtYXg6IG9wdGlvbnNPYmplY3QubWF4IHx8IDk5OTk5OTk5OTk5OTlcbiAgfSk7XG4gIHNlbGYuaWRDb3VudGVyID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogc2VsZi5vcHRpb25zLm1heCk7XG4gIHNlbGYuc2V0UHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICBpZiAodHlwZW9mIHByb3ZpZGVyICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtcnBjXSB0aGUgRXRoUlBDIG9iamVjdCByZXF1aXJlcyB0aGF0IHRoZSBmaXJzdCBpbnB1dCBcXCdwcm92aWRlclxcJyBtdXN0IGJlIGFuIG9iamVjdCwgZ290IFxcJycgKyB0eXBlb2YgcHJvdmlkZXIgKyAnXFwnIChpLmUuIFxcJ2NvbnN0IGV0aCA9IG5ldyBFdGhSUEMocHJvdmlkZXIpO1xcJyknKTtcbiAgICB9XG5cbiAgICBzZWxmLmN1cnJlbnRQcm92aWRlciA9IHByb3ZpZGVyO1xuICB9O1xuICBzZWxmLnNldFByb3ZpZGVyKGNwcm92aWRlcik7XG59XG5cbi8qKlxuICogVGhlIG1haW4gc2VuZCBhc3luYyBtZXRob2RcbiAqXG4gKiBAbWV0aG9kIHNlbmRBc3luY1xuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgdGhlIHJwYyBwYXlsb2FkIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgdGhlIGFzeW5jIHN0YW5kYXJkIGNhbGxiYWNrXG4gKiBAY2FsbGJhY2sge09iamVjdHxBcnJheXxCb29sZWFufFN0cmluZ30gdmFyeSByZXN1bHQgaW5zdGFuY2Ugb3V0cHV0XG4gKi9cbkV0aFJQQy5wcm90b3R5cGUuc2VuZEFzeW5jID0gZnVuY3Rpb24gc2VuZEFzeW5jKHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5pZENvdW50ZXIgPSBzZWxmLmlkQ291bnRlciAlIHNlbGYub3B0aW9ucy5tYXg7XG4gIHZhciBwYXJzZWRQYXlsb2FkID0gY3JlYXRlUGF5bG9hZChwYXlsb2FkLCBzZWxmLmlkQ291bnRlcisrKTtcblxuICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBzZWxmLmN1cnJlbnRQcm92aWRlci5zZW5kQXN5bmMocGFyc2VkUGF5bG9hZCwgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2UpIHtcbiAgICAgIHZhciByZXNwb25zZU9iamVjdCA9IHJlc3BvbnNlIHx8IHt9O1xuXG4gICAgICBpZiAoZXJyIHx8IHJlc3BvbnNlT2JqZWN0LmVycm9yKSB7XG4gICAgICAgIHZhciBwYXlsb2FkRXJyb3JNZXNzYWdlID0gJ1tldGhqcy1ycGNdICcgKyAocmVzcG9uc2VPYmplY3QuZXJyb3IgJiYgJ3JwYycgfHwgJycpICsgJyBlcnJvciB3aXRoIHBheWxvYWQgJyArIEpTT04uc3RyaW5naWZ5KHBhcnNlZFBheWxvYWQsIG51bGwsIHNlbGYub3B0aW9ucy5qc29uU3BhY2UpICsgJyAnICsgKGVyciA/IFN0cmluZyhlcnIpIDogSlNPTi5zdHJpbmdpZnkocmVzcG9uc2VPYmplY3QuZXJyb3IsIG51bGwsIHNlbGYub3B0aW9ucy5qc29uU3BhY2UpKTtcbiAgICAgICAgdmFyIHBheWxvYWRFcnJvciA9IG5ldyBFcnJvcihwYXlsb2FkRXJyb3JNZXNzYWdlKTtcbiAgICAgICAgcGF5bG9hZEVycm9yLnZhbHVlID0gZXJyIHx8IHJlc3BvbnNlT2JqZWN0LmVycm9yO1xuICAgICAgICByZWplY3QocGF5bG9hZEVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlKHJlc3BvbnNlT2JqZWN0LnJlc3VsdCk7XG4gICAgICByZXR1cm47XG4gICAgfSk7XG4gIH0pO1xuXG4gIGlmIChjYWxsYmFjaykge1xuICAgIC8vIGNvbm5lY3QgcHJvbWlzZSByZXNvbHZlIGhhbmRsZXJzIHRvIGNhbGxiYWNrXG4gICAgcmV0dXJuIHByb21pc2VUb0NhbGxiYWNrKHByb21pc2UpKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIG9ubHkgcmV0dXJuIHByb21pc2UgaWYgbm8gY2FsbGJhY2sgc3BlY2lmaWVkXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuLyoqXG4gKiBBIHNpbXBsZSBjcmVhdGUgcGF5bG9hZCBtZXRob2RcbiAqXG4gKiBAbWV0aG9kIGNyZWF0ZVBheWxvYWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIHRoZSBycGMgcGF5bG9hZCBkYXRhXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgdGhlIHJwYyBkYXRhIHBheWxvYWQgSURcbiAqIEByZXR1cm5zIHtPYmplY3R9IHBheWxvYWQgdGhlIGNvbXBsZXRlZCBwYXlsb2FkIG9iamVjdFxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXlsb2FkKGRhdGEsIGlkKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgaWQ6IGlkLFxuICAgIGpzb25ycGM6ICcyLjAnLFxuICAgIHBhcmFtczogW11cbiAgfSwgZGF0YSk7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2NoZW1hID0gcmVxdWlyZSgnZXRoanMtc2NoZW1hJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ2V0aGpzLXV0aWwnKTtcbnZhciBudW1iZXJUb0JOID0gcmVxdWlyZSgnbnVtYmVyLXRvLWJuJyk7XG52YXIgc3RyaXBIZXhQcmVmaXggPSByZXF1aXJlKCdzdHJpcC1oZXgtcHJlZml4Jyk7XG52YXIgcGFkVG9FdmVuID0gdXRpbC5wYWRUb0V2ZW47XG52YXIgYXJyYXlDb250YWluc0FycmF5ID0gdXRpbC5hcnJheUNvbnRhaW5zQXJyYXk7XG52YXIgZ2V0QmluYXJ5U2l6ZSA9IHV0aWwuZ2V0QmluYXJ5U2l6ZTtcblxuLyoqXG4gKiBGb3JtYXQgcXVhbnRpdHkgdmFsdWVzLCBlaXRoZXIgZW5jb2RlIHRvIGhleCBvciBkZWNvZGUgdG8gQmlnTnVtYmVyXG4gKiBzaG91bGQgaW50YWtlIG51bGwsIHN0cmluZ051bWJlciwgbnVtYmVyLCBCTlxuICpcbiAqIEBtZXRob2QgZm9ybWF0UXVhbnRpdHlcbiAqIEBwYXJhbSB7U3RyaW5nfEJpZ051bWJlcnxOdW1iZXJ9IHZhbHVlIHF1YW50aXR5IG9yIHRhZyB0byBjb252ZXJ0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IGVuY29kZSB0byBoZXggb3IgZGVjb2RlIHRvIEJpZ051bWJlclxuICogQHJldHVybnMge09wdGlvbmFsfSBvdXRwdXQgdG8gQmlnTnVtYmVyIG9yIHN0cmluZ1xuICogQHRocm93cyBlcnJvciBpZiB2YWx1ZSBpcyBhIGZsb2F0XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFF1YW50aXR5KHZhbHVlLCBlbmNvZGUsIHBhZCkge1xuICBpZiAoWydzdHJpbmcnLCAnbnVtYmVyJywgJ29iamVjdCddLmluZGV4T2YodHlwZW9mIHZhbHVlKSA9PT0gLTEgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICB2YXIgbnVtYmVyVmFsdWUgPSBudW1iZXJUb0JOKHZhbHVlKTtcbiAgdmFyIG51bVBhZGRpbmcgPSBwYWQgJiYgbnVtYmVyVmFsdWUudG9TdHJpbmcoMTYpLmxlbmd0aCAlIDIgPyAnMCcgOiAnJztcblxuICBpZiAobnVtYmVyVG9CTih2YWx1ZSkuaXNOZWcoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLWZvcm1hdF0gd2hpbGUgZm9ybWF0dGluZyBxdWFudGl0eSBcXCcnICsgbnVtYmVyVmFsdWUudG9TdHJpbmcoMTApICsgJ1xcJywgaW52YWxpZCBuZWdhdGl2ZSBudW1iZXIuIE51bWJlciBtdXN0IGJlIHBvc2l0aXZlIG9yIHplcm8uJyk7XG4gIH1cblxuICByZXR1cm4gZW5jb2RlID8gJzB4JyArIG51bVBhZGRpbmcgKyBudW1iZXJWYWx1ZS50b1N0cmluZygxNikgOiBudW1iZXJWYWx1ZTtcbn1cblxuLyoqXG4gKiBGb3JtYXQgcXVhbnRpdHkgb3IgdGFnLCBpZiB0YWcgYnlwYXNzIHJldHVybiwgZWxzZSBmb3JtYXQgcXVhbnRpdHlcbiAqIHNob3VsZCBpbnRha2UgbnVsbCwgc3RyaW5nTnVtYmVyLCBudW1iZXIsIEJOLCBzdHJpbmcgdGFnXG4gKlxuICogQG1ldGhvZCBmb3JtYXRRdWFudGl0eU9yVGFnXG4gKiBAcGFyYW0ge1N0cmluZ3xCaWdOdW1iZXJ8TnVtYmVyfSB2YWx1ZSBxdWFudGl0eSBvciB0YWcgdG8gY29udmVydFxuICogQHBhcmFtIHtCb29sZWFufSBlbmNvZGUgZW5jb2RlIHRoZSBudW1iZXIgdG8gaGV4IG9yIGRlY29kZSB0byBCaWdOdW1iZXJcbiAqIEByZXR1cm5zIHtPYmplY3R8U3RyaW5nfSBvdXRwdXQgdG8gQmlnTnVtYmVyIG9yIHN0cmluZ1xuICogQHRocm93cyBlcnJvciBpZiB2YWx1ZSBpcyBhIGZsb2F0XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFF1YW50aXR5T3JUYWcodmFsdWUsIGVuY29kZSkge1xuICB2YXIgb3V0cHV0ID0gdmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAvLyBpZiB0aGUgdmFsdWUgaXMgYSB0YWcsIGJ5cGFzc1xuICBpZiAoc2NoZW1hLnRhZ3MuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0UXVhbnRpdHkodmFsdWUsIGVuY29kZSk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIEZvcm1hdERhdGEgdW5kZXIgc3RyaWN0IGNvbmRpdGlvbnMgaGV4IHByZWZpeFxuICpcbiAqIEBtZXRob2QgZm9ybWF0RGF0YVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIHRoZSBieXRlcyBkYXRhIHRvIGJlIGZvcm1hdHRlZFxuICogQHBhcmFtIHtOdW1iZXJ9IGJ5dGVMZW5ndGggdGhlIHJlcXVpcmVkIGJ5dGUgbGVuZ3RoICh1c3VhbGx5IDIwIG9yIDMyKVxuICogQHJldHVybnMge1N0cmluZ30gb3V0cHV0IG91dHB1dCBmb3JtYXR0ZWQgZGF0YVxuICogQHRocm93cyBlcnJvciBpZiBtaW5pbXVtIGxlbmd0aCBpc250IG1ldFxuICovXG5mdW5jdGlvbiBmb3JtYXREYXRhKHZhbHVlLCBieXRlTGVuZ3RoKSB7XG4gIHZhciBvdXRwdXQgPSB2YWx1ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB2YXIgb3V0cHV0Qnl0ZUxlbmd0aCA9IDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAvLyBwcmVmaXggb25seSB1bmRlciBzdHJpY3QgY29uZGl0aW9ucywgZWxzZSBieXBhc3NcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBvdXRwdXQgPSAnMHgnICsgcGFkVG9FdmVuKHN0cmlwSGV4UHJlZml4KHZhbHVlKSk7XG4gICAgb3V0cHV0Qnl0ZUxlbmd0aCA9IGdldEJpbmFyeVNpemUob3V0cHV0KTtcbiAgfVxuXG4gIC8vIGZvcm1hdCBkb3VibGUgcGFkZGVkIHplcm9zLlxuICBpZiAob3V0cHV0ID09PSAnMHgwMCcpIHtcbiAgICBvdXRwdXQgPSAnMHgwJztcbiAgfVxuXG4gIC8vIHRocm93IGlmIGJ5dGVsZW5ndGggaXMgbm90IGNvcnJlY3RcbiAgaWYgKHR5cGVvZiBieXRlTGVuZ3RoID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBvdXRwdXQgIT09ICcweCcgJiYgb3V0cHV0ICE9PSAnMHgwJyAvLyBzdXBwb3J0IGVtcHR5IHZhbHVlc1xuICAmJiAoIS9eWzAtOUEtRmEtZl0rJC8udGVzdChzdHJpcEhleFByZWZpeChvdXRwdXQpKSB8fCBvdXRwdXRCeXRlTGVuZ3RoICE9PSAyICsgYnl0ZUxlbmd0aCAqIDIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtZm9ybWF0XSBoZXggc3RyaW5nIFxcJycgKyBvdXRwdXQgKyAnXFwnIG11c3QgYmUgYW4gYWxwaGFudW1lcmljICcgKyAoMiArIGJ5dGVMZW5ndGggKiAyKSArICcgdXRmOCBieXRlIGhleCAoY2hhcnM6IGEtZkEtRikgc3RyaW5nLCBpcyAnICsgb3V0cHV0Qnl0ZUxlbmd0aCArICcgYnl0ZXMnKTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogRm9ybWF0IG9iamVjdCwgZXZlbiB3aXRoIHJhbmRvbSBSUEMgY2F2aWV0c1xuICpcbiAqIEBtZXRob2QgZm9ybWF0T2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gZm9ybWF0dGVyIHRoZSB1bml0IHRvIGNvbnZlcnQgdG8sIGRlZmF1bHQgZXRoZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSB0aGUgb2JqZWN0IHZhbHVlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGVuY29kZSBlbmNvZGUgdG8gaGV4IG9yIGRlY29kZSB0byBCaWdOdW1iZXJcbiAqIEByZXR1cm5zIHtPYmplY3R9IG91dHB1dCBvYmplY3RcbiAqIEB0aHJvd3MgZXJyb3IgaWYgdmFsdWUgaXMgYSBmbG9hdFxuICovXG5mdW5jdGlvbiBmb3JtYXRPYmplY3QoZm9ybWF0dGVyLCB2YWx1ZSwgZW5jb2RlKSB7XG4gIHZhciBvdXRwdXQgPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgdmFyIGZvcm1hdE9iamVjdCA9IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAvLyBpZiB0aGUgb2JqZWN0IGlzIGEgc3RyaW5nIGZsYWcsIHRoZW4gcmV0cmVpdmUgdGhlIG9iamVjdFxuICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoZm9ybWF0dGVyID09PSAnQm9vbGVhbnxFdGhTeW5jaW5nJykge1xuICAgICAgZm9ybWF0T2JqZWN0ID0gT2JqZWN0LmFzc2lnbih7fSwgc2NoZW1hLm9iamVjdHMuRXRoU3luY2luZyk7XG4gICAgfSBlbHNlIGlmIChmb3JtYXR0ZXIgPT09ICdEQVRBfFRyYW5zYWN0aW9uJykge1xuICAgICAgZm9ybWF0T2JqZWN0ID0gT2JqZWN0LmFzc2lnbih7fSwgc2NoZW1hLm9iamVjdHMuVHJhbnNhY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JtYXRPYmplY3QgPSBPYmplY3QuYXNzaWduKHt9LCBzY2hlbWEub2JqZWN0c1tmb3JtYXR0ZXJdKTtcbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayBpZiBhbGwgcmVxdWlyZWQgZGF0YSBrZXlzIGFyZSBmdWxmaWxsZWRcbiAgaWYgKCFhcnJheUNvbnRhaW5zQXJyYXkoT2JqZWN0LmtleXModmFsdWUpLCBmb3JtYXRPYmplY3QuX19yZXF1aXJlZCkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtZm9ybWF0XSBvYmplY3QgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICcgbXVzdCBjb250YWluIHByb3BlcnRpZXM6ICcgKyBmb3JtYXRPYmplY3QuX19yZXF1aXJlZC5qb2luKCcsICcpKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB9XG5cbiAgLy8gYXNzdW1lIGZvcm1hdE9iamVjdCBpcyBhbiBvYmplY3QsIGdvIHRocm91Z2gga2V5cyBhbmQgZm9ybWF0IGVhY2hcbiAgT2JqZWN0LmtleXMoZm9ybWF0T2JqZWN0KS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZUtleSkge1xuICAgIGlmICh2YWx1ZUtleSAhPT0gJ19fcmVxdWlyZWQnICYmIHR5cGVvZiB2YWx1ZVt2YWx1ZUtleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvdXRwdXRbdmFsdWVLZXldID0gZm9ybWF0KGZvcm1hdE9iamVjdFt2YWx1ZUtleV0sIHZhbHVlW3ZhbHVlS2V5XSwgZW5jb2RlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogRm9ybWF0IGFycmF5XG4gKlxuICogQG1ldGhvZCBmb3JtYXRBcnJheVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGZvcm1hdHRlciB0aGUgdW5pdCB0byBjb252ZXJ0IHRvLCBkZWZhdWx0IGV0aGVyXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgdGhlIHZhbHVlIGluIHF1ZXN0aW9uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGVuY29kZSBlbmNvZGUgdG8gaGV4IG9yIGRlY29kZSB0byBCaWdOdW1iZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGhSZXF1aXJlbWVudCB0aGUgcmVxdWlyZWQgbWluaW11bSBhcnJheSBsZW5ndGhcbiAqIEByZXR1cm5zIHtPYmplY3R9IG91dHB1dCBvYmplY3RcbiAqIEB0aHJvd3MgZXJyb3IgaWYgbWluaW11bSBsZW5ndGggaXNudCBtZXRcbiAqL1xuZnVuY3Rpb24gZm9ybWF0QXJyYXkoZm9ybWF0dGVyLCB2YWx1ZSwgZW5jb2RlLCBsZW5ndGhSZXF1aXJlbWVudCkge1xuICB2YXIgb3V0cHV0ID0gdmFsdWUuc2xpY2UoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB2YXIgZm9ybWF0T2JqZWN0ID0gZm9ybWF0dGVyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgLy8gaWYgdGhlIGZvcm1hdHRlciBpcyBhbiBhcnJheSBvciBkYXRhLCB0aGVuIG1ha2UgZm9ybWF0IG9iamVjdCBhbiBhcnJheSBkYXRhXG4gIGlmIChmb3JtYXR0ZXIgPT09ICdBcnJheXxEQVRBJykge1xuICAgIGZvcm1hdE9iamVjdCA9IFsnRCddO1xuICB9XG5cbiAgLy8gaWYgZm9ybWF0dGVyIGlzIGEgRmlsdGVyQ2hhbmdlIGFuZCBhY3RzIGxpa2UgYSBCbG9ja0ZpbHRlclxuICAvLyBvciBQZW5kaW5nVHggY2hhbmdlIGZvcm1hdCBvYmplY3QgdG8gdHggaGFzaCBhcnJheVxuICBpZiAoZm9ybWF0dGVyID09PSAnRmlsdGVyQ2hhbmdlJyAmJiB0eXBlb2YgdmFsdWVbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgZm9ybWF0T2JqZWN0ID0gWydEMzInXTtcbiAgfVxuXG4gIC8vIGVuZm9yY2UgbWluaW11bSB2YWx1ZSBsZW5ndGggcmVxdWlyZW1lbnRzXG4gIGlmIChlbmNvZGUgPT09IHRydWUgJiYgdHlwZW9mIGxlbmd0aFJlcXVpcmVtZW50ID09PSAnbnVtYmVyJyAmJiB2YWx1ZS5sZW5ndGggPCBsZW5ndGhSZXF1aXJlbWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYXJyYXkgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICcgbXVzdCBjb250YWluIGF0IGxlYXN0ICcgKyBsZW5ndGhSZXF1aXJlbWVudCArICcgcGFyYW1zLCBidXQgb25seSBjb250YWlucyAnICsgdmFsdWUubGVuZ3RoICsgJy4nKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB9XG5cbiAgLy8gbWFrZSBuZXcgYXJyYXksIGF2b2lkIG11dGF0aW9uXG4gIGZvcm1hdE9iamVjdCA9IGZvcm1hdE9iamVjdC5zbGljZSgpO1xuXG4gIC8vIGFzc3VtZSBmb3JtYXRPYmplY3QgaXMgYW4gb2JqZWN0LCBnbyB0aHJvdWdoIGtleXMgYW5kIGZvcm1hdCBlYWNoXG4gIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlS2V5LCB2YWx1ZUluZGV4KSB7XG4gICAgLy8gdXNlIGtleSB6ZXJvIGFzIGZvcm1hdHRlciBmb3IgYWxsIHZhbHVlcywgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWRcbiAgICB2YXIgZm9ybWF0T2JqZWN0S2V5ID0gMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgLy8gaWYgZm9ybWF0IGFycmF5IGlzIGV4YWN0LCBjaGVjayBlYWNoIGFyZ3VtZW50IGFnYWluc3QgZm9ybWF0dGVyIGFyZ3VtZW50XG4gICAgaWYgKGZvcm1hdE9iamVjdC5sZW5ndGggPiAxKSB7XG4gICAgICBmb3JtYXRPYmplY3RLZXkgPSB2YWx1ZUluZGV4O1xuICAgIH1cblxuICAgIG91dHB1dFt2YWx1ZUluZGV4XSA9IGZvcm1hdChmb3JtYXRPYmplY3RbZm9ybWF0T2JqZWN0S2V5XSwgdmFsdWVLZXksIGVuY29kZSk7XG4gIH0pO1xuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogRm9ybWF0IHZhcmlvdXMga2luZHMgb2YgZGF0YSB0byBSUEMgc3BlYyBvciBpbnRvIGRpZ2VzdGFibGUgSlMgb2JqZWN0c1xuICpcbiAqIEBtZXRob2QgZm9ybWF0XG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gZm9ybWF0dGVyIHRoZSBkYXRhIGZvcm1hdHRlclxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl8T2JqZWN0fE51bGx8TnVtYmVyfSB2YWx1ZSB0aGUgZGF0YSB2YWx1ZSBpbnB1dFxuICogQHBhcmFtIHtCb29sZWFufSBlbmNvZGUgZW5jb2RlIHRvIGhleCBvciBkZWNvZGUgdG8gQmlnTnVtYmVycywgU3RyaW5ncywgQm9vbGVhbnMsIE51bGxcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGhSZXF1aXJlbWVudCB0aGUgbWluaW11bSBkYXRhIGxlbmd0aCByZXF1aXJlbWVudFxuICogQHRocm93cyBlcnJvciBpZiBtaW5pbXVtIGxlbmd0aCBpc250IG1ldFxuICovXG5mdW5jdGlvbiBmb3JtYXQoZm9ybWF0dGVyLCB2YWx1ZSwgZW5jb2RlLCBsZW5ndGhSZXF1aXJlbWVudCkge1xuICB2YXIgb3V0cHV0ID0gdmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAvLyBpZiBmb3JtYXR0ZXIgaXMgcXVhbnRpdHkgb3IgcXVhbnRpdHkgb3IgdGFnXG4gIGlmIChmb3JtYXR0ZXIgPT09ICdRJykge1xuICAgIG91dHB1dCA9IGZvcm1hdFF1YW50aXR5KHZhbHVlLCBlbmNvZGUpO1xuICB9IGVsc2UgaWYgKGZvcm1hdHRlciA9PT0gJ1FQJykge1xuICAgIG91dHB1dCA9IGZvcm1hdFF1YW50aXR5KHZhbHVlLCBlbmNvZGUsIHRydWUpO1xuICB9IGVsc2UgaWYgKGZvcm1hdHRlciA9PT0gJ1F8VCcpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRRdWFudGl0eU9yVGFnKHZhbHVlLCBlbmNvZGUpO1xuICB9IGVsc2UgaWYgKGZvcm1hdHRlciA9PT0gJ0QnKSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0RGF0YSh2YWx1ZSk7IC8vIGRvbnQgZm9ybWF0IGRhdGEgZmxhZ2dlZCBvYmplY3RzIGxpa2UgY29tcGlsZXIgb3V0cHV0XG4gIH0gZWxzZSBpZiAoZm9ybWF0dGVyID09PSAnRDIwJykge1xuICAgIG91dHB1dCA9IGZvcm1hdERhdGEodmFsdWUsIDIwKTsgLy8gZG9udCBmb3JtYXQgZGF0YSBmbGFnZ2VkIG9iamVjdHMgbGlrZSBjb21waWxlciBvdXRwdXRcbiAgfSBlbHNlIGlmIChmb3JtYXR0ZXIgPT09ICdEMzInKSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0RGF0YSh2YWx1ZSwgMzIpOyAvLyBkb250IGZvcm1hdCBkYXRhIGZsYWdnZWQgb2JqZWN0cyBsaWtlIGNvbXBpbGVyIG91dHB1dFxuICB9IGVsc2Uge1xuICAgIC8vIGlmIHZhbHVlIGlzIGFuIG9iamVjdCBvciBhcnJheVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIEFycmF5LmlzQXJyYXkodmFsdWUpID09PSBmYWxzZSkge1xuICAgICAgb3V0cHV0ID0gZm9ybWF0T2JqZWN0KGZvcm1hdHRlciwgdmFsdWUsIGVuY29kZSk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoZm9ybWF0dGVyLCB2YWx1ZSwgZW5jb2RlLCBsZW5ndGhSZXF1aXJlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBGb3JtYXQgUlBDIGlucHV0cyBnZW5lcmFsbHkgdG8gdGhlIG5vZGUgb3IgVGVzdFJQQ1xuICpcbiAqIEBtZXRob2QgZm9ybWF0SW5wdXRzXG4gKiBAcGFyYW0ge09iamVjdH0gbWV0aG9kIHRoZSBkYXRhIGZvcm1hdHRlclxuICogQHBhcmFtIHtBcnJheX0gaW5wdXRzIHRoZSBkYXRhIGlucHV0c1xuICogQHJldHVybnMge0FycmF5fSBvdXRwdXQgdGhlIGZvcm1hdHRlZCBpbnB1dHMgYXJyYXlcbiAqIEB0aHJvd3MgZXJyb3IgaWYgbWluaW11bSBsZW5ndGggaXNudCBtZXRcbiAqL1xuZnVuY3Rpb24gZm9ybWF0SW5wdXRzKG1ldGhvZCwgaW5wdXRzKSB7XG4gIHJldHVybiBmb3JtYXQoc2NoZW1hLm1ldGhvZHNbbWV0aG9kXVswXSwgaW5wdXRzLCB0cnVlLCBzY2hlbWEubWV0aG9kc1ttZXRob2RdWzJdKTtcbn1cblxuLyoqXG4gKiBGb3JtYXQgUlBDIG91dHB1dHMgZ2VuZXJhbGx5IGZyb20gdGhlIG5vZGUgb3IgVGVzdFJQQ1xuICpcbiAqIEBtZXRob2QgZm9ybWF0T3V0cHV0c1xuICogQHBhcmFtIHtPYmplY3R9IG1ldGhvZCB0aGUgZGF0YSBmb3JtYXR0ZXJcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfE51bGx8Qm9vbGVhbnxPYmplY3R9IG91dHB1dHMgdGhlIGRhdGEgaW5wdXRzXG4gKiBAcmV0dXJucyB7QXJyYXl8U3RyaW5nfE51bGx8Qm9vbGVhbnxPYmplY3R9IG91dHB1dCB0aGUgZm9ybWF0dGVkIGRhdGFcbiAqL1xuZnVuY3Rpb24gZm9ybWF0T3V0cHV0cyhtZXRob2QsIG91dHB1dHMpIHtcbiAgcmV0dXJuIGZvcm1hdChzY2hlbWEubWV0aG9kc1ttZXRob2RdWzFdLCBvdXRwdXRzLCBmYWxzZSk7XG59XG5cbi8vIGV4cG9ydCBmb3JtYXR0ZXJzXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2NoZW1hOiBzY2hlbWEsXG4gIGZvcm1hdFF1YW50aXR5OiBmb3JtYXRRdWFudGl0eSxcbiAgZm9ybWF0UXVhbnRpdHlPclRhZzogZm9ybWF0UXVhbnRpdHlPclRhZyxcbiAgZm9ybWF0T2JqZWN0OiBmb3JtYXRPYmplY3QsXG4gIGZvcm1hdEFycmF5OiBmb3JtYXRBcnJheSxcbiAgZm9ybWF0OiBmb3JtYXQsXG4gIGZvcm1hdElucHV0czogZm9ybWF0SW5wdXRzLFxuICBmb3JtYXRPdXRwdXRzOiBmb3JtYXRPdXRwdXRzXG59OyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY29uc3RydWN0RmlsdGVyKGZpbHRlck5hbWUsIHF1ZXJ5KSB7XG4gIGZ1bmN0aW9uIEZpbHRlcihvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuZmlsdGVySWQgPSBudWxsO1xuICAgIHNlbGYub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgZGVsYXk6IDMwMCxcbiAgICAgIGRlY29kZXI6IGZ1bmN0aW9uIGRlY29kZURhdGEoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0sXG4gICAgICBkZWZhdWx0RmlsdGVyT2JqZWN0OiB7fVxuICAgIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gICAgc2VsZi53YXRjaGVycyA9IHt9O1xuICAgIHNlbGYuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5maWx0ZXJJZCAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyhzZWxmLndhdGNoZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHF1ZXJ5LmdldEZpbHRlckNoYW5nZXMoc2VsZi5maWx0ZXJJZCwgZnVuY3Rpb24gKGNoYW5nZUVycm9yLCBjaGFuZ2VSZXN1bHQpIHtcbiAgICAgICAgICB2YXIgZGVjb2RlZENoYW5nZVJlc3VsdHMgPSBbXTtcbiAgICAgICAgICB2YXIgZGVjb2RpbmdFcnJvciA9IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgICAgIGlmICghY2hhbmdlRXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNoYW5nZVJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChsb2csIGxvZ0luZGV4KSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlZENoYW5nZVJlc3VsdHNbbG9nSW5kZXhdID0gY2hhbmdlUmVzdWx0W2xvZ0luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNoYW5nZVJlc3VsdFtsb2dJbmRleF0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhbmdlUmVzdWx0c1tsb2dJbmRleF0uZGF0YSA9IHNlbGYub3B0aW9ucy5kZWNvZGVyKGRlY29kZWRDaGFuZ2VSZXN1bHRzW2xvZ0luZGV4XS5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZGVjb2RpbmdFcnJvck1lc2FnZSkge1xuICAgICAgICAgICAgICBkZWNvZGluZ0Vycm9yID0gbmV3IEVycm9yKCdbZXRoanMtZmlsdGVyXSB3aGlsZSBkZWNvZGluZyBmaWx0ZXIgY2hhbmdlIGV2ZW50IGRhdGEgZnJvbSBSUEMgXFwnJyArIEpTT04uc3RyaW5naWZ5KGRlY29kZWRDaGFuZ2VSZXN1bHRzKSArICdcXCc6ICcgKyBkZWNvZGluZ0Vycm9yTWVzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBPYmplY3Qua2V5cyhzZWxmLndhdGNoZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgdmFyIHdhdGNoZXIgPSBzZWxmLndhdGNoZXJzW2lkXTtcbiAgICAgICAgICAgIGlmICh3YXRjaGVyLnN0b3AgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHNlbGYud2F0Y2hlcnNbaWRdO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZWNvZGluZ0Vycm9yKSB7XG4gICAgICAgICAgICAgIHdhdGNoZXIuY2FsbGJhY2soZGVjb2RpbmdFcnJvciwgbnVsbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY2hhbmdlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB3YXRjaGVyLmNhbGxiYWNrKGNoYW5nZUVycm9yLCBudWxsKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRlY29kZWRDaGFuZ2VSZXN1bHRzKSAmJiBjaGFuZ2VSZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHdhdGNoZXIuY2FsbGJhY2soY2hhbmdlRXJyb3IsIGRlY29kZWRDaGFuZ2VSZXN1bHRzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBzZWxmLm9wdGlvbnMuZGVsYXkpO1xuICB9XG5cbiAgRmlsdGVyLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIGF0RmlsdGVyKGZpbHRlcklkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuZmlsdGVySWQgPSBmaWx0ZXJJZDtcbiAgfTtcblxuICBGaWx0ZXIucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24gd2F0Y2hGaWx0ZXIod2F0Y2hDYWxsYmFja0lucHV0KSB7XG4gICAgdmFyIGNhbGxiYWNrID0gd2F0Y2hDYWxsYmFja0lucHV0IHx8IGZ1bmN0aW9uICgpIHt9OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KTtcbiAgICBzZWxmLndhdGNoZXJzW2lkXSA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBzdG9wOiBmYWxzZSwgc3RvcFdhdGNoaW5nOiBmdW5jdGlvbiBzdG9wV2F0Y2hpbmcoKSB7XG4gICAgICAgIHNlbGYud2F0Y2hlcnNbaWRdLnN0b3AgPSB0cnVlO1xuICAgICAgfSB9O1xuXG4gICAgcmV0dXJuIHNlbGYud2F0Y2hlcnNbaWRdO1xuICB9O1xuXG4gIEZpbHRlci5wcm90b3R5cGUudW5pbnN0YWxsID0gZnVuY3Rpb24gdW5pbnN0YWxsRmlsdGVyKGNiKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYWxsYmFjayA9IGNiIHx8IG51bGw7XG4gICAgc2VsZi53YXRjaGVycyA9IE9iamVjdC5hc3NpZ24oe30pO1xuICAgIGNsZWFySW50ZXJ2YWwoc2VsZi5pbnRlcnZhbCk7XG5cbiAgICB2YXIgcHJvbSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHF1ZXJ5LnVuaW5zdGFsbEZpbHRlcihzZWxmLmZpbHRlcklkLCBmdW5jdGlvbiAodW5pbnN0YWxsRXJyb3IsIHVuaW5zdGFsbFJlc2lsdCkge1xuICAgICAgICBpZiAodW5pbnN0YWxsRXJyb3IpIHtcbiAgICAgICAgICByZWplY3QodW5pbnN0YWxsRXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUodW5pbnN0YWxsUmVzaWx0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHByb20udGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXMpO1xuICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24gKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjYWxsYmFjayA/IG51bGwgOiBwcm9tO1xuICB9O1xuXG4gIEZpbHRlci5wcm90b3R5cGVbJ25ldyddID0gZnVuY3Rpb24gbmV3RmlsdGVyKCkge1xuICAgIHZhciBjYWxsYmFjayA9IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGZpbHRlcklucHV0cyA9IFtdO1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgLy8gcG9wIGNhbGxiYWNrIGlmIHByb3ZpZGVkXG4gICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICB9XG5cbiAgICAvLyBpZiBhIHBhcmFtIG9iamVjdCB3YXMgcHJlc2VudGVkLCBwdXNoIHRoYXQgaW50byB0aGUgaW5wdXRzXG4gICAgaWYgKGZpbHRlck5hbWUgPT09ICdGaWx0ZXInKSB7XG4gICAgICBmaWx0ZXJJbnB1dHMucHVzaChPYmplY3QuYXNzaWduKHNlbGYub3B0aW9ucy5kZWZhdWx0RmlsdGVyT2JqZWN0LCBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gfHwge30pKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvbSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIC8vIGFkZCBjb21wbGV4IGNhbGxiYWNrXG4gICAgICBmaWx0ZXJJbnB1dHMucHVzaChmdW5jdGlvbiAoc2V0dXBFcnJvciwgZmlsdGVySWQpIHtcbiAgICAgICAgaWYgKCFzZXR1cEVycm9yKSB7XG4gICAgICAgICAgc2VsZi5maWx0ZXJJZCA9IGZpbHRlcklkO1xuICAgICAgICAgIHJlc29sdmUoZmlsdGVySWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChzZXR1cEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIGFwcGx5IGZpbHRlciwgY2FsbCBuZXcuLiBmaWx0ZXIgbWV0aG9kXG4gICAgICBxdWVyeVsnbmV3JyArIGZpbHRlck5hbWVdLmFwcGx5KHF1ZXJ5LCBmaWx0ZXJJbnB1dHMpO1xuICAgIH0pO1xuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBwcm9tLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgICAgIH0pWydjYXRjaCddKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FsbGJhY2sgPyBudWxsIDogcHJvbTtcbiAgfTtcblxuICByZXR1cm4gRmlsdGVyO1xufVxuXG4vKipcbiAqIEV0aEZpbHRlciBjb25zdHJ1Y3RvciwgaW50YWtlcyBhIHF1ZXJ5LCBoZWxwcyBtYW5hZ2UgZmlsdGVyIGV2ZW50IHBvbGxpbmdcbiAqXG4gKiBAbWV0aG9kIEV0aEZpbHRlclxuICogQHBhcmFtIHtPYmplY3R9IHF1ZXJ5IHRoZSBgZXRoanMtcXVlcnlgIG9yIGBldGgtcXVlcnlgIG9iamVjdFxuICogQHJldHVybnMge09iamVjdH0gb3V0cHV0IGFuIEV0aEZpbHRlciBpbnN0YW5jZVxuICogQHRocm93cyBlcnJvciBpZiBuZXcgaXMgbm90IHVzZWRcbiAqL1xuXG5mdW5jdGlvbiBFdGhGaWx0ZXIocXVlcnkpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoIShzZWxmIGluc3RhbmNlb2YgRXRoRmlsdGVyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndGhlIEV0aEZpbHRlciBvYmplY3QgbXVzdCBiZSBpbnN0YW50aWF0ZWQgd2l0aCBgbmV3YCBmbGFnLi4gKGUuZy4gYGNvbnN0IGZpbHRlcnMgPSBuZXcgRXRoRmlsdGVyKHF1ZXJ5KTtgKScpO1xuICB9XG4gIGlmICh0eXBlb2YgcXVlcnkgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgRXRoRmlsdGVyIG9iamVjdCBtdXN0IGJlIGluc3RhbnRpYXRlZCB3aXRoIGFuIEV0aFF1ZXJ5IGluc3RhbmNlIChlLmcuIGBjb25zdCBmaWx0ZXJzID0gbmV3IEV0aEZpbHRlcihuZXcgRXRoUXVlcnkocHJvdmlkZXIpKTtgKS4gU2VlIGdpdGh1Yi5jb20vZXRoanMvZXRoanMtcXVlcnkgZm9yIG1vcmUgZGV0YWlscy4uJyk7XG4gIH1cblxuICBzZWxmLkZpbHRlciA9IGNvbnN0cnVjdEZpbHRlcignRmlsdGVyJywgcXVlcnkpO1xuICBzZWxmLkJsb2NrRmlsdGVyID0gY29uc3RydWN0RmlsdGVyKCdCbG9ja0ZpbHRlcicsIHF1ZXJ5KTtcbiAgc2VsZi5QZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXIgPSBjb25zdHJ1Y3RGaWx0ZXIoJ1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlcicsIHF1ZXJ5KTtcbn1cblxuLy8gZXhwb3J0IEV0aEZpbHRlclxubW9kdWxlLmV4cG9ydHMgPSBFdGhGaWx0ZXI7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNIZXhQcmVmaXhlZCA9IHJlcXVpcmUoJ2lzLWhleC1wcmVmaXhlZCcpO1xudmFyIHN0cmlwSGV4UHJlZml4ID0gcmVxdWlyZSgnc3RyaXAtaGV4LXByZWZpeCcpO1xuXG4vKipcbiAqIFBhZHMgYSBgU3RyaW5nYCB0byBoYXZlIGFuIGV2ZW4gbGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge1N0cmluZ30gb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIHBhZFRvRXZlbih2YWx1ZSkge1xuICB2YXIgYSA9IHZhbHVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgaWYgKHR5cGVvZiBhICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIHdoaWxlIHBhZGRpbmcgdG8gZXZlbiwgdmFsdWUgbXVzdCBiZSBzdHJpbmcsIGlzIGN1cnJlbnRseSAnICsgdHlwZW9mIGEgKyAnLCB3aGlsZSBwYWRUb0V2ZW4uJyk7XG4gIH1cblxuICBpZiAoYS5sZW5ndGggJSAyKSB7XG4gICAgYSA9ICcwJyArIGE7XG4gIH1cblxuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGBOdW1iZXJgIGludG8gYSBoZXggYFN0cmluZ2BcbiAqIEBwYXJhbSB7TnVtYmVyfSBpXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGludFRvSGV4KGkpIHtcbiAgdmFyIGhleCA9IGkudG9TdHJpbmcoMTYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgcmV0dXJuICcweCcgKyBwYWRUb0V2ZW4oaGV4KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBgTnVtYmVyYCB0byBhIGBCdWZmZXJgXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBpbnRUb0J1ZmZlcihpKSB7XG4gIHZhciBoZXggPSBpbnRUb0hleChpKTtcblxuICByZXR1cm4gQnVmZmVyLmZyb20oaGV4LnNsaWNlKDIpLCAnaGV4Jyk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBiaW5hcnkgc2l6ZSBvZiBhIHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRCaW5hcnlTaXplKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSB3aGlsZSBnZXR0aW5nIGJpbmFyeSBzaXplLCBtZXRob2QgZ2V0QmluYXJ5U2l6ZSByZXF1aXJlcyBpbnB1dCBcXCdzdHJcXCcgdG8gYmUgdHlwZSBTdHJpbmcsIGdvdCBcXCcnICsgdHlwZW9mIHN0ciArICdcXCcuJyk7XG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyLCAndXRmOCcpO1xufVxuXG4vKipcbiAqIFJldHVybnMgVFJVRSBpZiB0aGUgZmlyc3Qgc3BlY2lmaWVkIGFycmF5IGNvbnRhaW5zIGFsbCBlbGVtZW50c1xuICogZnJvbSB0aGUgc2Vjb25kIG9uZS4gRkFMU0Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IHN1cGVyc2V0XG4gKiBAcGFyYW0ge2FycmF5fSBzdWJzZXRcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gYXJyYXlDb250YWluc0FycmF5KHN1cGVyc2V0LCBzdWJzZXQsIHNvbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3VwZXJzZXQpICE9PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGFycmF5Q29udGFpbnNBcnJheSByZXF1aXJlcyBpbnB1dCBcXCdzdXBlcnNldFxcJyB0byBiZSBhbiBhcnJheSBnb3QgdHlwZSBcXCcnICsgdHlwZW9mIHN1cGVyc2V0ICsgJ1xcJycpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHN1YnNldCkgIT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgYXJyYXlDb250YWluc0FycmF5IHJlcXVpcmVzIGlucHV0IFxcJ3N1YnNldFxcJyB0byBiZSBhbiBhcnJheSBnb3QgdHlwZSBcXCcnICsgdHlwZW9mIHN1YnNldCArICdcXCcnKTtcbiAgfVxuXG4gIHJldHVybiBzdWJzZXRbQm9vbGVhbihzb21lKSAmJiAnc29tZScgfHwgJ2V2ZXJ5J10oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHN1cGVyc2V0LmluZGV4T2YodmFsdWUpID49IDA7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IHV0ZjggZnJvbSBpdCdzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2QgdG9VdGY4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIGluIGhleFxuICogQHJldHVybnMge1N0cmluZ30gYXNjaWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGhleCB2YWx1ZVxuICovXG5mdW5jdGlvbiB0b1V0ZjgoaGV4KSB7XG4gIHZhciBidWZmZXJWYWx1ZSA9IG5ldyBCdWZmZXIocGFkVG9FdmVuKHN0cmlwSGV4UHJlZml4KGhleCkucmVwbGFjZSgvXjArfDArJC9nLCAnJykpLCAnaGV4Jyk7XG5cbiAgcmV0dXJuIGJ1ZmZlclZhbHVlLnRvU3RyaW5nKCd1dGY4Jyk7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgYXNjaWkgZnJvbSBpdCdzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2QgdG9Bc2NpaVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBpbiBoZXhcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGFzY2lpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBoZXggdmFsdWVcbiAqL1xuZnVuY3Rpb24gdG9Bc2NpaShoZXgpIHtcbiAgdmFyIHN0ciA9ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIHZhciBpID0gMCxcbiAgICAgIGwgPSBoZXgubGVuZ3RoOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgaWYgKGhleC5zdWJzdHJpbmcoMCwgMikgPT09ICcweCcpIHtcbiAgICBpID0gMjtcbiAgfVxuXG4gIGZvciAoOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgdmFyIGNvZGUgPSBwYXJzZUludChoZXguc3Vic3RyKGksIDIpLCAxNik7XG4gICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIHV0Zjggc3RyaW5nXG4gKlxuICogQG1ldGhvZCBmcm9tVXRmOFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbmFsIHBhZGRpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZnJvbVV0Zjgoc3RyaW5nVmFsdWUpIHtcbiAgdmFyIHN0ciA9IG5ldyBCdWZmZXIoc3RyaW5nVmFsdWUsICd1dGY4Jyk7XG5cbiAgcmV0dXJuICcweCcgKyBwYWRUb0V2ZW4oc3RyLnRvU3RyaW5nKCdoZXgnKSkucmVwbGFjZSgvXjArfDArJC9nLCAnJyk7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgYXNjaWkgc3RyaW5nXG4gKlxuICogQG1ldGhvZCBmcm9tQXNjaWlcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25hbCBwYWRkaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGZyb21Bc2NpaShzdHJpbmdWYWx1ZSkge1xuICB2YXIgaGV4ID0gJyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmdWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB2YXIgY29kZSA9IHN0cmluZ1ZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgdmFyIG4gPSBjb2RlLnRvU3RyaW5nKDE2KTtcbiAgICBoZXggKz0gbi5sZW5ndGggPCAyID8gJzAnICsgbiA6IG47XG4gIH1cblxuICByZXR1cm4gJzB4JyArIGhleDtcbn1cblxuLyoqXG4gKiBnZXRLZXlzKFt7YTogMSwgYjogMn0sIHthOiAzLCBiOiA0fV0sICdhJykgPT4gWzEsIDNdXG4gKlxuICogQG1ldGhvZCBnZXRLZXlzIGdldCBzcGVjaWZpYyBrZXkgZnJvbSBpbm5lciBvYmplY3QgYXJyYXkgb2Ygb2JqZWN0c1xuICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtc1xuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtCb29sZWFufSBhbGxvd0VtcHR5XG4gKiBAcmV0dXJucyB7QXJyYXl9IG91dHB1dCBqdXN0IGEgc2ltcGxlIGFycmF5IG9mIG91dHB1dCBrZXlzXG4gKi9cbmZ1bmN0aW9uIGdldEtleXMocGFyYW1zLCBrZXksIGFsbG93RW1wdHkpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgZ2V0S2V5cyBleHBlY3RpbmcgdHlwZSBBcnJheSBhcyBcXCdwYXJhbXNcXCcgaW5wdXQsIGdvdCBcXCcnICsgdHlwZW9mIHBhcmFtcyArICdcXCcnKTtcbiAgfVxuICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgZ2V0S2V5cyBleHBlY3RpbmcgdHlwZSBTdHJpbmcgZm9yIGlucHV0IFxcJ2tleVxcJyBnb3QgXFwnJyArIHR5cGVvZiBrZXkgKyAnXFwnLicpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdmFyIHZhbHVlID0gcGFyYW1zW2ldW2tleV07IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBpZiAoYWxsb3dFbXB0eSAmJiAhdmFsdWUpIHtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWJpJyk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogSXMgdGhlIHN0cmluZyBhIGhleCBzdHJpbmcuXG4gKlxuICogQG1ldGhvZCBjaGVjayBpZiBzdHJpbmcgaXMgaGV4IHN0cmluZyBvZiBzcGVjaWZpYyBsZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxuICogQHJldHVybnMge0Jvb2xlYW59IG91dHB1dCB0aGUgc3RyaW5nIGlzIGEgaGV4IHN0cmluZ1xuICovXG5mdW5jdGlvbiBpc0hleFN0cmluZyh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8ICF2YWx1ZS5tYXRjaCgvXjB4WzAtOUEtRmEtZl0qJC8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggIT09IDIgKyAyICogbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhcnJheUNvbnRhaW5zQXJyYXk6IGFycmF5Q29udGFpbnNBcnJheSxcbiAgaW50VG9CdWZmZXI6IGludFRvQnVmZmVyLFxuICBnZXRCaW5hcnlTaXplOiBnZXRCaW5hcnlTaXplLFxuICBpc0hleFByZWZpeGVkOiBpc0hleFByZWZpeGVkLFxuICBzdHJpcEhleFByZWZpeDogc3RyaXBIZXhQcmVmaXgsXG4gIHBhZFRvRXZlbjogcGFkVG9FdmVuLFxuICBpbnRUb0hleDogaW50VG9IZXgsXG4gIGZyb21Bc2NpaTogZnJvbUFzY2lpLFxuICBmcm9tVXRmODogZnJvbVV0ZjgsXG4gIHRvQXNjaWk6IHRvQXNjaWksXG4gIHRvVXRmODogdG9VdGY4LFxuICBnZXRLZXlzOiBnZXRLZXlzLFxuICBpc0hleFN0cmluZzogaXNIZXhTdHJpbmdcbn07IiwiLyoqXHJcbiAqIFtqcy1zaGEzXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZW1uMTc4L2pzLXNoYTN9XHJcbiAqXHJcbiAqIEB2ZXJzaW9uIDAuNS41XHJcbiAqIEBhdXRob3IgQ2hlbiwgWWktQ3l1YW4gW2VtbjE3OEBnbWFpbC5jb21dXHJcbiAqIEBjb3B5cmlnaHQgQ2hlbiwgWWktQ3l1YW4gMjAxNS0yMDE2XHJcbiAqIEBsaWNlbnNlIE1JVFxyXG4gKi9cclxuKGZ1bmN0aW9uIChyb290KSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICB2YXIgTk9ERV9KUyA9IHR5cGVvZiBwcm9jZXNzID09ICdvYmplY3QnICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlO1xyXG4gIGlmIChOT0RFX0pTKSB7XHJcbiAgICByb290ID0gZ2xvYmFsO1xyXG4gIH1cclxuICB2YXIgQ09NTU9OX0pTID0gIXJvb3QuSlNfU0hBM19URVNUICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHM7XHJcbiAgdmFyIEhFWF9DSEFSUyA9ICcwMTIzNDU2Nzg5YWJjZGVmJy5zcGxpdCgnJyk7XHJcbiAgdmFyIFNIQUtFX1BBRERJTkcgPSBbMzEsIDc5MzYsIDIwMzE2MTYsIDUyMDA5MzY5Nl07XHJcbiAgdmFyIEtFQ0NBS19QQURESU5HID0gWzEsIDI1NiwgNjU1MzYsIDE2Nzc3MjE2XTtcclxuICB2YXIgUEFERElORyA9IFs2LCAxNTM2LCAzOTMyMTYsIDEwMDY2MzI5Nl07XHJcbiAgdmFyIFNISUZUID0gWzAsIDgsIDE2LCAyNF07XHJcbiAgdmFyIFJDID0gWzEsIDAsIDMyODk4LCAwLCAzMjkwNiwgMjE0NzQ4MzY0OCwgMjE0NzUxNjQxNiwgMjE0NzQ4MzY0OCwgMzI5MDcsIDAsIDIxNDc0ODM2NDksXHJcbiAgICAgICAgICAgIDAsIDIxNDc1MTY1NDUsIDIxNDc0ODM2NDgsIDMyNzc3LCAyMTQ3NDgzNjQ4LCAxMzgsIDAsIDEzNiwgMCwgMjE0NzUxNjQyNSwgMCwgXHJcbiAgICAgICAgICAgIDIxNDc0ODM2NTgsIDAsIDIxNDc1MTY1NTUsIDAsIDEzOSwgMjE0NzQ4MzY0OCwgMzI5MDUsIDIxNDc0ODM2NDgsIDMyNzcxLCBcclxuICAgICAgICAgICAgMjE0NzQ4MzY0OCwgMzI3NzAsIDIxNDc0ODM2NDgsIDEyOCwgMjE0NzQ4MzY0OCwgMzI3NzgsIDAsIDIxNDc0ODM2NTgsIDIxNDc0ODM2NDgsXHJcbiAgICAgICAgICAgIDIxNDc1MTY1NDUsIDIxNDc0ODM2NDgsIDMyODk2LCAyMTQ3NDgzNjQ4LCAyMTQ3NDgzNjQ5LCAwLCAyMTQ3NTE2NDI0LCAyMTQ3NDgzNjQ4XTtcclxuICB2YXIgQklUUyA9IFsyMjQsIDI1NiwgMzg0LCA1MTJdO1xyXG4gIHZhciBTSEFLRV9CSVRTID0gWzEyOCwgMjU2XTtcclxuICB2YXIgT1VUUFVUX1RZUEVTID0gWydoZXgnLCAnYnVmZmVyJywgJ2FycmF5QnVmZmVyJywgJ2FycmF5J107XHJcblxyXG4gIHZhciBjcmVhdGVPdXRwdXRNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZywgb3V0cHV0VHlwZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIGJpdHMpLnVwZGF0ZShtZXNzYWdlKVtvdXRwdXRUeXBlXSgpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHZhciBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nLCBvdXRwdXRUeXBlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIG91dHB1dEJpdHMpIHtcclxuICAgICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cykudXBkYXRlKG1lc3NhZ2UpW291dHB1dFR5cGVdKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nKSB7XHJcbiAgICB2YXIgbWV0aG9kID0gY3JlYXRlT3V0cHV0TWV0aG9kKGJpdHMsIHBhZGRpbmcsICdoZXgnKTtcclxuICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIGJpdHMpO1xyXG4gICAgfTtcclxuICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgICByZXR1cm4gbWV0aG9kLmNyZWF0ZSgpLnVwZGF0ZShtZXNzYWdlKTtcclxuICAgIH07XHJcbiAgICBmb3IgKHZhciBpID0gMDtpIDwgT1VUUFVUX1RZUEVTLmxlbmd0aDsrK2kpIHtcclxuICAgICAgdmFyIHR5cGUgPSBPVVRQVVRfVFlQRVNbaV07XHJcbiAgICAgIG1ldGhvZFt0eXBlXSA9IGNyZWF0ZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCB0eXBlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtZXRob2Q7XHJcbiAgfTtcclxuXHJcbiAgdmFyIGNyZWF0ZVNoYWtlTWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcpIHtcclxuICAgIHZhciBtZXRob2QgPSBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCAnaGV4Jyk7XHJcbiAgICBtZXRob2QuY3JlYXRlID0gZnVuY3Rpb24gKG91dHB1dEJpdHMpIHtcclxuICAgICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cyk7XHJcbiAgICB9O1xyXG4gICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvdXRwdXRCaXRzKSB7XHJcbiAgICAgIHJldHVybiBtZXRob2QuY3JlYXRlKG91dHB1dEJpdHMpLnVwZGF0ZShtZXNzYWdlKTtcclxuICAgIH07XHJcbiAgICBmb3IgKHZhciBpID0gMDtpIDwgT1VUUFVUX1RZUEVTLmxlbmd0aDsrK2kpIHtcclxuICAgICAgdmFyIHR5cGUgPSBPVVRQVVRfVFlQRVNbaV07XHJcbiAgICAgIG1ldGhvZFt0eXBlXSA9IGNyZWF0ZVNoYWtlT3V0cHV0TWV0aG9kKGJpdHMsIHBhZGRpbmcsIHR5cGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1ldGhvZDtcclxuICB9O1xyXG5cclxuICB2YXIgYWxnb3JpdGhtcyA9IFtcclxuICAgIHtuYW1lOiAna2VjY2FrJywgcGFkZGluZzogS0VDQ0FLX1BBRERJTkcsIGJpdHM6IEJJVFMsIGNyZWF0ZU1ldGhvZDogY3JlYXRlTWV0aG9kfSxcclxuICAgIHtuYW1lOiAnc2hhMycsIHBhZGRpbmc6IFBBRERJTkcsIGJpdHM6IEJJVFMsIGNyZWF0ZU1ldGhvZDogY3JlYXRlTWV0aG9kfSxcclxuICAgIHtuYW1lOiAnc2hha2UnLCBwYWRkaW5nOiBTSEFLRV9QQURESU5HLCBiaXRzOiBTSEFLRV9CSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZVNoYWtlTWV0aG9kfVxyXG4gIF07XHJcblxyXG4gIHZhciBtZXRob2RzID0ge307XHJcblxyXG4gIGZvciAodmFyIGkgPSAwO2kgPCBhbGdvcml0aG1zLmxlbmd0aDsrK2kpIHtcclxuICAgIHZhciBhbGdvcml0aG0gPSBhbGdvcml0aG1zW2ldO1xyXG4gICAgdmFyIGJpdHMgID0gYWxnb3JpdGhtLmJpdHM7XHJcbiAgICBmb3IgKHZhciBqID0gMDtqIDwgYml0cy5sZW5ndGg7KytqKSB7XHJcbiAgICAgIG1ldGhvZHNbYWxnb3JpdGhtLm5hbWUgKydfJyArIGJpdHNbal1dID0gYWxnb3JpdGhtLmNyZWF0ZU1ldGhvZChiaXRzW2pdLCBhbGdvcml0aG0ucGFkZGluZyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBLZWNjYWsoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cykge1xyXG4gICAgdGhpcy5ibG9ja3MgPSBbXTtcclxuICAgIHRoaXMucyA9IFtdO1xyXG4gICAgdGhpcy5wYWRkaW5nID0gcGFkZGluZztcclxuICAgIHRoaXMub3V0cHV0Qml0cyA9IG91dHB1dEJpdHM7XHJcbiAgICB0aGlzLnJlc2V0ID0gdHJ1ZTtcclxuICAgIHRoaXMuYmxvY2sgPSAwO1xyXG4gICAgdGhpcy5zdGFydCA9IDA7XHJcbiAgICB0aGlzLmJsb2NrQ291bnQgPSAoMTYwMCAtIChiaXRzIDw8IDEpKSA+PiA1O1xyXG4gICAgdGhpcy5ieXRlQ291bnQgPSB0aGlzLmJsb2NrQ291bnQgPDwgMjtcclxuICAgIHRoaXMub3V0cHV0QmxvY2tzID0gb3V0cHV0Qml0cyA+PiA1O1xyXG4gICAgdGhpcy5leHRyYUJ5dGVzID0gKG91dHB1dEJpdHMgJiAzMSkgPj4gMztcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDtpIDwgNTA7KytpKSB7XHJcbiAgICAgIHRoaXMuc1tpXSA9IDA7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgS2VjY2FrLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgdmFyIG5vdFN0cmluZyA9IHR5cGVvZiBtZXNzYWdlICE9ICdzdHJpbmcnO1xyXG4gICAgaWYgKG5vdFN0cmluZyAmJiBtZXNzYWdlLmNvbnN0cnVjdG9yID09IHJvb3QuQXJyYXlCdWZmZXIpIHtcclxuICAgICAgbWVzc2FnZSA9IG5ldyBVaW50OEFycmF5KG1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gICAgdmFyIGxlbmd0aCA9IG1lc3NhZ2UubGVuZ3RoLCBibG9ja3MgPSB0aGlzLmJsb2NrcywgYnl0ZUNvdW50ID0gdGhpcy5ieXRlQ291bnQsIFxyXG4gICAgICAgIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIGluZGV4ID0gMCwgcyA9IHRoaXMucywgaSwgY29kZTtcclxuICAgIFxyXG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgIGlmICh0aGlzLnJlc2V0KSB7XHJcbiAgICAgICAgdGhpcy5yZXNldCA9IGZhbHNlO1xyXG4gICAgICAgIGJsb2Nrc1swXSA9IHRoaXMuYmxvY2s7XHJcbiAgICAgICAgZm9yIChpID0gMTtpIDwgYmxvY2tDb3VudCArIDE7KytpKSB7XHJcbiAgICAgICAgICBibG9ja3NbaV0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAobm90U3RyaW5nKSB7XHJcbiAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDtpbmRleCA8IGxlbmd0aCAmJiBpIDwgYnl0ZUNvdW50OysraW5kZXgpIHtcclxuICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9IG1lc3NhZ2VbaW5kZXhdIDw8IFNISUZUW2krKyAmIDNdO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmb3IgKGkgPSB0aGlzLnN0YXJ0O2luZGV4IDwgbGVuZ3RoICYmIGkgPCBieXRlQ291bnQ7KytpbmRleCkge1xyXG4gICAgICAgICAgY29kZSA9IG1lc3NhZ2UuY2hhckNvZGVBdChpbmRleCk7XHJcbiAgICAgICAgICBpZiAoY29kZSA8IDB4ODApIHtcclxuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gY29kZSA8PCBTSElGVFtpKysgJiAzXTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ODAwKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGMwIHwgKGNvZGUgPj4gNikpIDw8IFNISUZUW2krKyAmIDNdO1xyXG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHhkODAwIHx8IGNvZGUgPj0gMHhlMDAwKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGUwIHwgKGNvZGUgPj4gMTIpKSA8PCBTSElGVFtpKysgJiAzXTtcclxuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XHJcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb2RlID0gMHgxMDAwMCArICgoKGNvZGUgJiAweDNmZikgPDwgMTApIHwgKG1lc3NhZ2UuY2hhckNvZGVBdCgrK2luZGV4KSAmIDB4M2ZmKSk7XHJcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGYwIHwgKGNvZGUgPj4gMTgpKSA8PCBTSElGVFtpKysgJiAzXTtcclxuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gMTIpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xyXG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcclxuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5sYXN0Qnl0ZUluZGV4ID0gaTtcclxuICAgICAgaWYgKGkgPj0gYnl0ZUNvdW50KSB7XHJcbiAgICAgICAgdGhpcy5zdGFydCA9IGkgLSBieXRlQ291bnQ7XHJcbiAgICAgICAgdGhpcy5ibG9jayA9IGJsb2Nrc1tibG9ja0NvdW50XTtcclxuICAgICAgICBmb3IgKGkgPSAwO2kgPCBibG9ja0NvdW50OysraSkge1xyXG4gICAgICAgICAgc1tpXSBePSBibG9ja3NbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGYocyk7XHJcbiAgICAgICAgdGhpcy5yZXNldCA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5zdGFydCA9IGk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIEtlY2Nhay5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYmxvY2tzID0gdGhpcy5ibG9ja3MsIGkgPSB0aGlzLmxhc3RCeXRlSW5kZXgsIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIHMgPSB0aGlzLnM7XHJcbiAgICBibG9ja3NbaSA+PiAyXSB8PSB0aGlzLnBhZGRpbmdbaSAmIDNdO1xyXG4gICAgaWYgKHRoaXMubGFzdEJ5dGVJbmRleCA9PSB0aGlzLmJ5dGVDb3VudCkge1xyXG4gICAgICBibG9ja3NbMF0gPSBibG9ja3NbYmxvY2tDb3VudF07XHJcbiAgICAgIGZvciAoaSA9IDE7aSA8IGJsb2NrQ291bnQgKyAxOysraSkge1xyXG4gICAgICAgIGJsb2Nrc1tpXSA9IDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGJsb2Nrc1tibG9ja0NvdW50IC0gMV0gfD0gMHg4MDAwMDAwMDtcclxuICAgIGZvciAoaSA9IDA7aSA8IGJsb2NrQ291bnQ7KytpKSB7XHJcbiAgICAgIHNbaV0gXj0gYmxvY2tzW2ldO1xyXG4gICAgfVxyXG4gICAgZihzKTtcclxuICB9O1xyXG5cclxuICBLZWNjYWsucHJvdG90eXBlLnRvU3RyaW5nID0gS2VjY2FrLnByb3RvdHlwZS5oZXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmZpbmFsaXplKCk7XHJcblxyXG4gICAgdmFyIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIHMgPSB0aGlzLnMsIG91dHB1dEJsb2NrcyA9IHRoaXMub3V0cHV0QmxvY2tzLCBcclxuICAgICAgICBleHRyYUJ5dGVzID0gdGhpcy5leHRyYUJ5dGVzLCBpID0gMCwgaiA9IDA7XHJcbiAgICB2YXIgaGV4ID0gJycsIGJsb2NrO1xyXG4gICAgd2hpbGUgKGogPCBvdXRwdXRCbG9ja3MpIHtcclxuICAgICAgZm9yIChpID0gMDtpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOysraSwgKytqKSB7XHJcbiAgICAgICAgYmxvY2sgPSBzW2ldO1xyXG4gICAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbYmxvY2sgJiAweDBGXSArXHJcbiAgICAgICAgICAgICAgIEhFWF9DSEFSU1soYmxvY2sgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDgpICYgMHgwRl0gK1xyXG4gICAgICAgICAgICAgICBIRVhfQ0hBUlNbKGJsb2NrID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiAxNikgJiAweDBGXSArXHJcbiAgICAgICAgICAgICAgIEhFWF9DSEFSU1soYmxvY2sgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDI0KSAmIDB4MEZdO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChqICUgYmxvY2tDb3VudCA9PSAwKSB7XHJcbiAgICAgICAgZihzKTtcclxuICAgICAgICBpID0gMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGV4dHJhQnl0ZXMpIHtcclxuICAgICAgYmxvY2sgPSBzW2ldO1xyXG4gICAgICBpZiAoZXh0cmFCeXRlcyA+IDApIHtcclxuICAgICAgICBoZXggKz0gSEVYX0NIQVJTWyhibG9jayA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2Jsb2NrICYgMHgwRl07XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAxKSB7XHJcbiAgICAgICAgaGV4ICs9IEhFWF9DSEFSU1soYmxvY2sgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDgpICYgMHgwRl07XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAyKSB7XHJcbiAgICAgICAgaGV4ICs9IEhFWF9DSEFSU1soYmxvY2sgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDE2KSAmIDB4MEZdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGV4O1xyXG4gIH07XHJcblxyXG4gIEtlY2Nhay5wcm90b3R5cGUuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmZpbmFsaXplKCk7XHJcblxyXG4gICAgdmFyIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIHMgPSB0aGlzLnMsIG91dHB1dEJsb2NrcyA9IHRoaXMub3V0cHV0QmxvY2tzLCBcclxuICAgICAgICBleHRyYUJ5dGVzID0gdGhpcy5leHRyYUJ5dGVzLCBpID0gMCwgaiA9IDA7XHJcbiAgICB2YXIgYnl0ZXMgPSB0aGlzLm91dHB1dEJpdHMgPj4gMztcclxuICAgIHZhciBidWZmZXI7XHJcbiAgICBpZiAoZXh0cmFCeXRlcykge1xyXG4gICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoKG91dHB1dEJsb2NrcyArIDEpIDw8IDIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVzKTtcclxuICAgIH1cclxuICAgIHZhciBhcnJheSA9IG5ldyBVaW50MzJBcnJheShidWZmZXIpO1xyXG4gICAgd2hpbGUgKGogPCBvdXRwdXRCbG9ja3MpIHtcclxuICAgICAgZm9yIChpID0gMDtpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOysraSwgKytqKSB7XHJcbiAgICAgICAgYXJyYXlbal0gPSBzW2ldO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChqICUgYmxvY2tDb3VudCA9PSAwKSB7XHJcbiAgICAgICAgZihzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGV4dHJhQnl0ZXMpIHtcclxuICAgICAgYXJyYXlbaV0gPSBzW2ldO1xyXG4gICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoMCwgYnl0ZXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJ1ZmZlcjtcclxuICB9O1xyXG5cclxuICBLZWNjYWsucHJvdG90eXBlLmJ1ZmZlciA9IEtlY2Nhay5wcm90b3R5cGUuYXJyYXlCdWZmZXI7XHJcblxyXG4gIEtlY2Nhay5wcm90b3R5cGUuZGlnZXN0ID0gS2VjY2FrLnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuZmluYWxpemUoKTtcclxuXHJcbiAgICB2YXIgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucywgb3V0cHV0QmxvY2tzID0gdGhpcy5vdXRwdXRCbG9ja3MsIFxyXG4gICAgICAgIGV4dHJhQnl0ZXMgPSB0aGlzLmV4dHJhQnl0ZXMsIGkgPSAwLCBqID0gMDtcclxuICAgIHZhciBhcnJheSA9IFtdLCBvZmZzZXQsIGJsb2NrO1xyXG4gICAgd2hpbGUgKGogPCBvdXRwdXRCbG9ja3MpIHtcclxuICAgICAgZm9yIChpID0gMDtpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOysraSwgKytqKSB7XHJcbiAgICAgICAgb2Zmc2V0ID0gaiA8PCAyO1xyXG4gICAgICAgIGJsb2NrID0gc1tpXTtcclxuICAgICAgICBhcnJheVtvZmZzZXRdID0gYmxvY2sgJiAweEZGO1xyXG4gICAgICAgIGFycmF5W29mZnNldCArIDFdID0gKGJsb2NrID4+IDgpICYgMHhGRjtcclxuICAgICAgICBhcnJheVtvZmZzZXQgKyAyXSA9IChibG9jayA+PiAxNikgJiAweEZGO1xyXG4gICAgICAgIGFycmF5W29mZnNldCArIDNdID0gKGJsb2NrID4+IDI0KSAmIDB4RkY7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGogJSBibG9ja0NvdW50ID09IDApIHtcclxuICAgICAgICBmKHMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoZXh0cmFCeXRlcykge1xyXG4gICAgICBvZmZzZXQgPSBqIDw8IDI7XHJcbiAgICAgIGJsb2NrID0gc1tpXTtcclxuICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAwKSB7XHJcbiAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IGJsb2NrICYgMHhGRjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZXh0cmFCeXRlcyA+IDEpIHtcclxuICAgICAgICBhcnJheVtvZmZzZXQgKyAxXSA9IChibG9jayA+PiA4KSAmIDB4RkY7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAyKSB7XHJcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMl0gPSAoYmxvY2sgPj4gMTYpICYgMHhGRjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFycmF5O1xyXG4gIH07XHJcblxyXG4gIHZhciBmID0gZnVuY3Rpb24gKHMpIHtcclxuICAgIHZhciBoLCBsLCBuLCBjMCwgYzEsIGMyLCBjMywgYzQsIGM1LCBjNiwgYzcsIGM4LCBjOSwgXHJcbiAgICAgICAgYjAsIGIxLCBiMiwgYjMsIGI0LCBiNSwgYjYsIGI3LCBiOCwgYjksIGIxMCwgYjExLCBiMTIsIGIxMywgYjE0LCBiMTUsIGIxNiwgYjE3LCBcclxuICAgICAgICBiMTgsIGIxOSwgYjIwLCBiMjEsIGIyMiwgYjIzLCBiMjQsIGIyNSwgYjI2LCBiMjcsIGIyOCwgYjI5LCBiMzAsIGIzMSwgYjMyLCBiMzMsIFxyXG4gICAgICAgIGIzNCwgYjM1LCBiMzYsIGIzNywgYjM4LCBiMzksIGI0MCwgYjQxLCBiNDIsIGI0MywgYjQ0LCBiNDUsIGI0NiwgYjQ3LCBiNDgsIGI0OTtcclxuICAgIGZvciAobiA9IDA7biA8IDQ4O24gKz0gMikge1xyXG4gICAgICBjMCA9IHNbMF0gXiBzWzEwXSBeIHNbMjBdIF4gc1szMF0gXiBzWzQwXTtcclxuICAgICAgYzEgPSBzWzFdIF4gc1sxMV0gXiBzWzIxXSBeIHNbMzFdIF4gc1s0MV07XHJcbiAgICAgIGMyID0gc1syXSBeIHNbMTJdIF4gc1syMl0gXiBzWzMyXSBeIHNbNDJdO1xyXG4gICAgICBjMyA9IHNbM10gXiBzWzEzXSBeIHNbMjNdIF4gc1szM10gXiBzWzQzXTtcclxuICAgICAgYzQgPSBzWzRdIF4gc1sxNF0gXiBzWzI0XSBeIHNbMzRdIF4gc1s0NF07XHJcbiAgICAgIGM1ID0gc1s1XSBeIHNbMTVdIF4gc1syNV0gXiBzWzM1XSBeIHNbNDVdO1xyXG4gICAgICBjNiA9IHNbNl0gXiBzWzE2XSBeIHNbMjZdIF4gc1szNl0gXiBzWzQ2XTtcclxuICAgICAgYzcgPSBzWzddIF4gc1sxN10gXiBzWzI3XSBeIHNbMzddIF4gc1s0N107XHJcbiAgICAgIGM4ID0gc1s4XSBeIHNbMThdIF4gc1syOF0gXiBzWzM4XSBeIHNbNDhdO1xyXG4gICAgICBjOSA9IHNbOV0gXiBzWzE5XSBeIHNbMjldIF4gc1szOV0gXiBzWzQ5XTtcclxuXHJcbiAgICAgIGggPSBjOCBeICgoYzIgPDwgMSkgfCAoYzMgPj4+IDMxKSk7XHJcbiAgICAgIGwgPSBjOSBeICgoYzMgPDwgMSkgfCAoYzIgPj4+IDMxKSk7XHJcbiAgICAgIHNbMF0gXj0gaDtcclxuICAgICAgc1sxXSBePSBsO1xyXG4gICAgICBzWzEwXSBePSBoO1xyXG4gICAgICBzWzExXSBePSBsO1xyXG4gICAgICBzWzIwXSBePSBoO1xyXG4gICAgICBzWzIxXSBePSBsO1xyXG4gICAgICBzWzMwXSBePSBoO1xyXG4gICAgICBzWzMxXSBePSBsO1xyXG4gICAgICBzWzQwXSBePSBoO1xyXG4gICAgICBzWzQxXSBePSBsO1xyXG4gICAgICBoID0gYzAgXiAoKGM0IDw8IDEpIHwgKGM1ID4+PiAzMSkpO1xyXG4gICAgICBsID0gYzEgXiAoKGM1IDw8IDEpIHwgKGM0ID4+PiAzMSkpO1xyXG4gICAgICBzWzJdIF49IGg7XHJcbiAgICAgIHNbM10gXj0gbDtcclxuICAgICAgc1sxMl0gXj0gaDtcclxuICAgICAgc1sxM10gXj0gbDtcclxuICAgICAgc1syMl0gXj0gaDtcclxuICAgICAgc1syM10gXj0gbDtcclxuICAgICAgc1szMl0gXj0gaDtcclxuICAgICAgc1szM10gXj0gbDtcclxuICAgICAgc1s0Ml0gXj0gaDtcclxuICAgICAgc1s0M10gXj0gbDtcclxuICAgICAgaCA9IGMyIF4gKChjNiA8PCAxKSB8IChjNyA+Pj4gMzEpKTtcclxuICAgICAgbCA9IGMzIF4gKChjNyA8PCAxKSB8IChjNiA+Pj4gMzEpKTtcclxuICAgICAgc1s0XSBePSBoO1xyXG4gICAgICBzWzVdIF49IGw7XHJcbiAgICAgIHNbMTRdIF49IGg7XHJcbiAgICAgIHNbMTVdIF49IGw7XHJcbiAgICAgIHNbMjRdIF49IGg7XHJcbiAgICAgIHNbMjVdIF49IGw7XHJcbiAgICAgIHNbMzRdIF49IGg7XHJcbiAgICAgIHNbMzVdIF49IGw7XHJcbiAgICAgIHNbNDRdIF49IGg7XHJcbiAgICAgIHNbNDVdIF49IGw7XHJcbiAgICAgIGggPSBjNCBeICgoYzggPDwgMSkgfCAoYzkgPj4+IDMxKSk7XHJcbiAgICAgIGwgPSBjNSBeICgoYzkgPDwgMSkgfCAoYzggPj4+IDMxKSk7XHJcbiAgICAgIHNbNl0gXj0gaDtcclxuICAgICAgc1s3XSBePSBsO1xyXG4gICAgICBzWzE2XSBePSBoO1xyXG4gICAgICBzWzE3XSBePSBsO1xyXG4gICAgICBzWzI2XSBePSBoO1xyXG4gICAgICBzWzI3XSBePSBsO1xyXG4gICAgICBzWzM2XSBePSBoO1xyXG4gICAgICBzWzM3XSBePSBsO1xyXG4gICAgICBzWzQ2XSBePSBoO1xyXG4gICAgICBzWzQ3XSBePSBsO1xyXG4gICAgICBoID0gYzYgXiAoKGMwIDw8IDEpIHwgKGMxID4+PiAzMSkpO1xyXG4gICAgICBsID0gYzcgXiAoKGMxIDw8IDEpIHwgKGMwID4+PiAzMSkpO1xyXG4gICAgICBzWzhdIF49IGg7XHJcbiAgICAgIHNbOV0gXj0gbDtcclxuICAgICAgc1sxOF0gXj0gaDtcclxuICAgICAgc1sxOV0gXj0gbDtcclxuICAgICAgc1syOF0gXj0gaDtcclxuICAgICAgc1syOV0gXj0gbDtcclxuICAgICAgc1szOF0gXj0gaDtcclxuICAgICAgc1szOV0gXj0gbDtcclxuICAgICAgc1s0OF0gXj0gaDtcclxuICAgICAgc1s0OV0gXj0gbDtcclxuXHJcbiAgICAgIGIwID0gc1swXTtcclxuICAgICAgYjEgPSBzWzFdO1xyXG4gICAgICBiMzIgPSAoc1sxMV0gPDwgNCkgfCAoc1sxMF0gPj4+IDI4KTtcclxuICAgICAgYjMzID0gKHNbMTBdIDw8IDQpIHwgKHNbMTFdID4+PiAyOCk7XHJcbiAgICAgIGIxNCA9IChzWzIwXSA8PCAzKSB8IChzWzIxXSA+Pj4gMjkpO1xyXG4gICAgICBiMTUgPSAoc1syMV0gPDwgMykgfCAoc1syMF0gPj4+IDI5KTtcclxuICAgICAgYjQ2ID0gKHNbMzFdIDw8IDkpIHwgKHNbMzBdID4+PiAyMyk7XHJcbiAgICAgIGI0NyA9IChzWzMwXSA8PCA5KSB8IChzWzMxXSA+Pj4gMjMpO1xyXG4gICAgICBiMjggPSAoc1s0MF0gPDwgMTgpIHwgKHNbNDFdID4+PiAxNCk7XHJcbiAgICAgIGIyOSA9IChzWzQxXSA8PCAxOCkgfCAoc1s0MF0gPj4+IDE0KTtcclxuICAgICAgYjIwID0gKHNbMl0gPDwgMSkgfCAoc1szXSA+Pj4gMzEpO1xyXG4gICAgICBiMjEgPSAoc1szXSA8PCAxKSB8IChzWzJdID4+PiAzMSk7XHJcbiAgICAgIGIyID0gKHNbMTNdIDw8IDEyKSB8IChzWzEyXSA+Pj4gMjApO1xyXG4gICAgICBiMyA9IChzWzEyXSA8PCAxMikgfCAoc1sxM10gPj4+IDIwKTtcclxuICAgICAgYjM0ID0gKHNbMjJdIDw8IDEwKSB8IChzWzIzXSA+Pj4gMjIpO1xyXG4gICAgICBiMzUgPSAoc1syM10gPDwgMTApIHwgKHNbMjJdID4+PiAyMik7XHJcbiAgICAgIGIxNiA9IChzWzMzXSA8PCAxMykgfCAoc1szMl0gPj4+IDE5KTtcclxuICAgICAgYjE3ID0gKHNbMzJdIDw8IDEzKSB8IChzWzMzXSA+Pj4gMTkpO1xyXG4gICAgICBiNDggPSAoc1s0Ml0gPDwgMikgfCAoc1s0M10gPj4+IDMwKTtcclxuICAgICAgYjQ5ID0gKHNbNDNdIDw8IDIpIHwgKHNbNDJdID4+PiAzMCk7XHJcbiAgICAgIGI0MCA9IChzWzVdIDw8IDMwKSB8IChzWzRdID4+PiAyKTtcclxuICAgICAgYjQxID0gKHNbNF0gPDwgMzApIHwgKHNbNV0gPj4+IDIpO1xyXG4gICAgICBiMjIgPSAoc1sxNF0gPDwgNikgfCAoc1sxNV0gPj4+IDI2KTtcclxuICAgICAgYjIzID0gKHNbMTVdIDw8IDYpIHwgKHNbMTRdID4+PiAyNik7XHJcbiAgICAgIGI0ID0gKHNbMjVdIDw8IDExKSB8IChzWzI0XSA+Pj4gMjEpO1xyXG4gICAgICBiNSA9IChzWzI0XSA8PCAxMSkgfCAoc1syNV0gPj4+IDIxKTtcclxuICAgICAgYjM2ID0gKHNbMzRdIDw8IDE1KSB8IChzWzM1XSA+Pj4gMTcpO1xyXG4gICAgICBiMzcgPSAoc1szNV0gPDwgMTUpIHwgKHNbMzRdID4+PiAxNyk7XHJcbiAgICAgIGIxOCA9IChzWzQ1XSA8PCAyOSkgfCAoc1s0NF0gPj4+IDMpO1xyXG4gICAgICBiMTkgPSAoc1s0NF0gPDwgMjkpIHwgKHNbNDVdID4+PiAzKTtcclxuICAgICAgYjEwID0gKHNbNl0gPDwgMjgpIHwgKHNbN10gPj4+IDQpO1xyXG4gICAgICBiMTEgPSAoc1s3XSA8PCAyOCkgfCAoc1s2XSA+Pj4gNCk7XHJcbiAgICAgIGI0MiA9IChzWzE3XSA8PCAyMykgfCAoc1sxNl0gPj4+IDkpO1xyXG4gICAgICBiNDMgPSAoc1sxNl0gPDwgMjMpIHwgKHNbMTddID4+PiA5KTtcclxuICAgICAgYjI0ID0gKHNbMjZdIDw8IDI1KSB8IChzWzI3XSA+Pj4gNyk7XHJcbiAgICAgIGIyNSA9IChzWzI3XSA8PCAyNSkgfCAoc1syNl0gPj4+IDcpO1xyXG4gICAgICBiNiA9IChzWzM2XSA8PCAyMSkgfCAoc1szN10gPj4+IDExKTtcclxuICAgICAgYjcgPSAoc1szN10gPDwgMjEpIHwgKHNbMzZdID4+PiAxMSk7XHJcbiAgICAgIGIzOCA9IChzWzQ3XSA8PCAyNCkgfCAoc1s0Nl0gPj4+IDgpO1xyXG4gICAgICBiMzkgPSAoc1s0Nl0gPDwgMjQpIHwgKHNbNDddID4+PiA4KTtcclxuICAgICAgYjMwID0gKHNbOF0gPDwgMjcpIHwgKHNbOV0gPj4+IDUpO1xyXG4gICAgICBiMzEgPSAoc1s5XSA8PCAyNykgfCAoc1s4XSA+Pj4gNSk7XHJcbiAgICAgIGIxMiA9IChzWzE4XSA8PCAyMCkgfCAoc1sxOV0gPj4+IDEyKTtcclxuICAgICAgYjEzID0gKHNbMTldIDw8IDIwKSB8IChzWzE4XSA+Pj4gMTIpO1xyXG4gICAgICBiNDQgPSAoc1syOV0gPDwgNykgfCAoc1syOF0gPj4+IDI1KTtcclxuICAgICAgYjQ1ID0gKHNbMjhdIDw8IDcpIHwgKHNbMjldID4+PiAyNSk7XHJcbiAgICAgIGIyNiA9IChzWzM4XSA8PCA4KSB8IChzWzM5XSA+Pj4gMjQpO1xyXG4gICAgICBiMjcgPSAoc1szOV0gPDwgOCkgfCAoc1szOF0gPj4+IDI0KTtcclxuICAgICAgYjggPSAoc1s0OF0gPDwgMTQpIHwgKHNbNDldID4+PiAxOCk7XHJcbiAgICAgIGI5ID0gKHNbNDldIDw8IDE0KSB8IChzWzQ4XSA+Pj4gMTgpO1xyXG5cclxuICAgICAgc1swXSA9IGIwIF4gKH5iMiAmIGI0KTtcclxuICAgICAgc1sxXSA9IGIxIF4gKH5iMyAmIGI1KTtcclxuICAgICAgc1sxMF0gPSBiMTAgXiAofmIxMiAmIGIxNCk7XHJcbiAgICAgIHNbMTFdID0gYjExIF4gKH5iMTMgJiBiMTUpO1xyXG4gICAgICBzWzIwXSA9IGIyMCBeICh+YjIyICYgYjI0KTtcclxuICAgICAgc1syMV0gPSBiMjEgXiAofmIyMyAmIGIyNSk7XHJcbiAgICAgIHNbMzBdID0gYjMwIF4gKH5iMzIgJiBiMzQpO1xyXG4gICAgICBzWzMxXSA9IGIzMSBeICh+YjMzICYgYjM1KTtcclxuICAgICAgc1s0MF0gPSBiNDAgXiAofmI0MiAmIGI0NCk7XHJcbiAgICAgIHNbNDFdID0gYjQxIF4gKH5iNDMgJiBiNDUpO1xyXG4gICAgICBzWzJdID0gYjIgXiAofmI0ICYgYjYpO1xyXG4gICAgICBzWzNdID0gYjMgXiAofmI1ICYgYjcpO1xyXG4gICAgICBzWzEyXSA9IGIxMiBeICh+YjE0ICYgYjE2KTtcclxuICAgICAgc1sxM10gPSBiMTMgXiAofmIxNSAmIGIxNyk7XHJcbiAgICAgIHNbMjJdID0gYjIyIF4gKH5iMjQgJiBiMjYpO1xyXG4gICAgICBzWzIzXSA9IGIyMyBeICh+YjI1ICYgYjI3KTtcclxuICAgICAgc1szMl0gPSBiMzIgXiAofmIzNCAmIGIzNik7XHJcbiAgICAgIHNbMzNdID0gYjMzIF4gKH5iMzUgJiBiMzcpO1xyXG4gICAgICBzWzQyXSA9IGI0MiBeICh+YjQ0ICYgYjQ2KTtcclxuICAgICAgc1s0M10gPSBiNDMgXiAofmI0NSAmIGI0Nyk7XHJcbiAgICAgIHNbNF0gPSBiNCBeICh+YjYgJiBiOCk7XHJcbiAgICAgIHNbNV0gPSBiNSBeICh+YjcgJiBiOSk7XHJcbiAgICAgIHNbMTRdID0gYjE0IF4gKH5iMTYgJiBiMTgpO1xyXG4gICAgICBzWzE1XSA9IGIxNSBeICh+YjE3ICYgYjE5KTtcclxuICAgICAgc1syNF0gPSBiMjQgXiAofmIyNiAmIGIyOCk7XHJcbiAgICAgIHNbMjVdID0gYjI1IF4gKH5iMjcgJiBiMjkpO1xyXG4gICAgICBzWzM0XSA9IGIzNCBeICh+YjM2ICYgYjM4KTtcclxuICAgICAgc1szNV0gPSBiMzUgXiAofmIzNyAmIGIzOSk7XHJcbiAgICAgIHNbNDRdID0gYjQ0IF4gKH5iNDYgJiBiNDgpO1xyXG4gICAgICBzWzQ1XSA9IGI0NSBeICh+YjQ3ICYgYjQ5KTtcclxuICAgICAgc1s2XSA9IGI2IF4gKH5iOCAmIGIwKTtcclxuICAgICAgc1s3XSA9IGI3IF4gKH5iOSAmIGIxKTtcclxuICAgICAgc1sxNl0gPSBiMTYgXiAofmIxOCAmIGIxMCk7XHJcbiAgICAgIHNbMTddID0gYjE3IF4gKH5iMTkgJiBiMTEpO1xyXG4gICAgICBzWzI2XSA9IGIyNiBeICh+YjI4ICYgYjIwKTtcclxuICAgICAgc1syN10gPSBiMjcgXiAofmIyOSAmIGIyMSk7XHJcbiAgICAgIHNbMzZdID0gYjM2IF4gKH5iMzggJiBiMzApO1xyXG4gICAgICBzWzM3XSA9IGIzNyBeICh+YjM5ICYgYjMxKTtcclxuICAgICAgc1s0Nl0gPSBiNDYgXiAofmI0OCAmIGI0MCk7XHJcbiAgICAgIHNbNDddID0gYjQ3IF4gKH5iNDkgJiBiNDEpO1xyXG4gICAgICBzWzhdID0gYjggXiAofmIwICYgYjIpO1xyXG4gICAgICBzWzldID0gYjkgXiAofmIxICYgYjMpO1xyXG4gICAgICBzWzE4XSA9IGIxOCBeICh+YjEwICYgYjEyKTtcclxuICAgICAgc1sxOV0gPSBiMTkgXiAofmIxMSAmIGIxMyk7XHJcbiAgICAgIHNbMjhdID0gYjI4IF4gKH5iMjAgJiBiMjIpO1xyXG4gICAgICBzWzI5XSA9IGIyOSBeICh+YjIxICYgYjIzKTtcclxuICAgICAgc1szOF0gPSBiMzggXiAofmIzMCAmIGIzMik7XHJcbiAgICAgIHNbMzldID0gYjM5IF4gKH5iMzEgJiBiMzMpO1xyXG4gICAgICBzWzQ4XSA9IGI0OCBeICh+YjQwICYgYjQyKTtcclxuICAgICAgc1s0OV0gPSBiNDkgXiAofmI0MSAmIGI0Myk7XHJcblxyXG4gICAgICBzWzBdIF49IFJDW25dO1xyXG4gICAgICBzWzFdIF49IFJDW24gKyAxXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChDT01NT05fSlMpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gbWV0aG9kcztcclxuICB9IGVsc2UgaWYgKHJvb3QpIHtcclxuICAgIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XHJcbiAgICAgIHJvb3Rba2V5XSA9IG1ldGhvZHNba2V5XTtcclxuICAgIH1cclxuICB9XHJcbn0odGhpcykpO1xyXG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvaW5kZXguanMnKTtcbnZhciB1aW50MjU2Q29kZXIgPSB1dGlscy51aW50MjU2Q29kZXI7XG52YXIgY29kZXJCb29sZWFuID0gdXRpbHMuY29kZXJCb29sZWFuO1xudmFyIGNvZGVyRml4ZWRCeXRlcyA9IHV0aWxzLmNvZGVyRml4ZWRCeXRlcztcbnZhciBjb2RlckFkZHJlc3MgPSB1dGlscy5jb2RlckFkZHJlc3M7XG52YXIgY29kZXJEeW5hbWljQnl0ZXMgPSB1dGlscy5jb2RlckR5bmFtaWNCeXRlcztcbnZhciBjb2RlclN0cmluZyA9IHV0aWxzLmNvZGVyU3RyaW5nO1xudmFyIGNvZGVyQXJyYXkgPSB1dGlscy5jb2RlckFycmF5O1xudmFyIHBhcmFtVHlwZVBhcnQgPSB1dGlscy5wYXJhbVR5cGVQYXJ0O1xudmFyIGdldFBhcmFtQ29kZXIgPSB1dGlscy5nZXRQYXJhbUNvZGVyO1xuXG5mdW5jdGlvbiBSZXN1bHQoKSB7fVxuXG5mdW5jdGlvbiBlbmNvZGVQYXJhbXModHlwZXMsIHZhbHVlcykge1xuICBpZiAodHlwZXMubGVuZ3RoICE9PSB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtYWJpXSB3aGlsZSBlbmNvZGluZyBwYXJhbXMsIHR5cGVzL3ZhbHVlcyBtaXNtYXRjaCwgWW91ciBjb250cmFjdCByZXF1aXJlcyAnICsgdHlwZXMubGVuZ3RoICsgJyB0eXBlcyAoYXJndW1lbnRzKSwgYW5kIHlvdSBwYXNzZWQgaW4gJyArIHZhbHVlcy5sZW5ndGgpO1xuICB9XG5cbiAgdmFyIHBhcnRzID0gW107XG5cbiAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSwgaW5kZXgpIHtcbiAgICB2YXIgY29kZXIgPSBnZXRQYXJhbUNvZGVyKHR5cGUpO1xuICAgIHBhcnRzLnB1c2goeyBkeW5hbWljOiBjb2Rlci5keW5hbWljLCB2YWx1ZTogY29kZXIuZW5jb2RlKHZhbHVlc1tpbmRleF0pIH0pO1xuICB9KTtcblxuICBmdW5jdGlvbiBhbGlnblNpemUoc2l6ZSkge1xuICAgIHJldHVybiBwYXJzZUludCgzMiAqIE1hdGguY2VpbChzaXplIC8gMzIpKTtcbiAgfVxuXG4gIHZhciBzdGF0aWNTaXplID0gMCxcbiAgICAgIGR5bmFtaWNTaXplID0gMDtcbiAgcGFydHMuZm9yRWFjaChmdW5jdGlvbiAocGFydCkge1xuICAgIGlmIChwYXJ0LmR5bmFtaWMpIHtcbiAgICAgIHN0YXRpY1NpemUgKz0gMzI7XG4gICAgICBkeW5hbWljU2l6ZSArPSBhbGlnblNpemUocGFydC52YWx1ZS5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0aWNTaXplICs9IGFsaWduU2l6ZShwYXJ0LnZhbHVlLmxlbmd0aCk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgb2Zmc2V0ID0gMCxcbiAgICAgIGR5bmFtaWNPZmZzZXQgPSBzdGF0aWNTaXplO1xuICB2YXIgZGF0YSA9IG5ldyBCdWZmZXIoc3RhdGljU2l6ZSArIGR5bmFtaWNTaXplKTtcblxuICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0LCBpbmRleCkge1xuICAgIGlmIChwYXJ0LmR5bmFtaWMpIHtcbiAgICAgIHVpbnQyNTZDb2Rlci5lbmNvZGUoZHluYW1pY09mZnNldCkuY29weShkYXRhLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IDMyO1xuXG4gICAgICBwYXJ0LnZhbHVlLmNvcHkoZGF0YSwgZHluYW1pY09mZnNldCk7XG4gICAgICBkeW5hbWljT2Zmc2V0ICs9IGFsaWduU2l6ZShwYXJ0LnZhbHVlLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnQudmFsdWUuY29weShkYXRhLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IGFsaWduU2l6ZShwYXJ0LnZhbHVlLmxlbmd0aCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gJzB4JyArIGRhdGEudG9TdHJpbmcoJ2hleCcpO1xufVxuXG4vLyBkZWNvZGUgYnl0ZWNvZGUgZGF0YSBmcm9tIG91dHB1dCBuYW1lcyBhbmQgdHlwZXNcbmZ1bmN0aW9uIGRlY29kZVBhcmFtcyhuYW1lcywgdHlwZXMsIGRhdGEpIHtcbiAgdmFyIHVzZU51bWJlcmVkUGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuXG4gIC8vIE5hbWVzIGlzIG9wdGlvbmFsLCBzbyBzaGlmdCBvdmVyIGFsbCB0aGUgcGFyYW1ldGVycyBpZiBub3QgcHJvdmlkZWRcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgZGF0YSA9IHR5cGVzO1xuICAgIHR5cGVzID0gbmFtZXM7XG4gICAgbmFtZXMgPSBbXTtcbiAgfVxuXG4gIGRhdGEgPSB1dGlscy5oZXhPckJ1ZmZlcihkYXRhKTtcbiAgdmFyIHZhbHVlcyA9IG5ldyBSZXN1bHQoKTtcblxuICB2YXIgb2Zmc2V0ID0gMDtcbiAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSwgaW5kZXgpIHtcbiAgICB2YXIgY29kZXIgPSBnZXRQYXJhbUNvZGVyKHR5cGUpO1xuICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG4gICAgICB2YXIgZHluYW1pY09mZnNldCA9IHVpbnQyNTZDb2Rlci5kZWNvZGUoZGF0YSwgb2Zmc2V0KTtcbiAgICAgIHZhciByZXN1bHQgPSBjb2Rlci5kZWNvZGUoZGF0YSwgZHluYW1pY09mZnNldC52YWx1ZS50b051bWJlcigpKTtcbiAgICAgIG9mZnNldCArPSBkeW5hbWljT2Zmc2V0LmNvbnN1bWVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY29kZXIuZGVjb2RlKGRhdGEsIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gcmVzdWx0LmNvbnN1bWVkO1xuICAgIH1cbiAgICBpZiAodXNlTnVtYmVyZWRQYXJhbXMpIHZhbHVlc1tpbmRleF0gPSByZXN1bHQudmFsdWU7XG4gICAgaWYgKG5hbWVzW2luZGV4XSkge1xuICAgICAgdmFsdWVzW25hbWVzW2luZGV4XV0gPSByZXN1bHQudmFsdWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHZhbHVlcztcbn1cblxuLy8gZW5jb2RlIG1ldGhvZCBBQkkgb2JqZWN0IHdpdGggdmFsdWVzIGluIGFuIGFycmF5LCBvdXRwdXQgYnl0ZWNvZGVcbmZ1bmN0aW9uIGVuY29kZU1ldGhvZChtZXRob2QsIHZhbHVlcykge1xuICB2YXIgc2lnbmF0dXJlID0gbWV0aG9kLm5hbWUgKyAnKCcgKyB1dGlscy5nZXRLZXlzKG1ldGhvZC5pbnB1dHMsICd0eXBlJykuam9pbignLCcpICsgJyknO1xuICB2YXIgc2lnbmF0dXJlRW5jb2RlZCA9ICcweCcgKyBuZXcgQnVmZmVyKHV0aWxzLmtlY2NhazI1NihzaWduYXR1cmUpLCAnaGV4Jykuc2xpY2UoMCwgNCkudG9TdHJpbmcoJ2hleCcpO1xuICB2YXIgcGFyYW1zRW5jb2RlZCA9IGVuY29kZVBhcmFtcyh1dGlscy5nZXRLZXlzKG1ldGhvZC5pbnB1dHMsICd0eXBlJyksIHZhbHVlcykuc3Vic3RyaW5nKDIpO1xuXG4gIHJldHVybiAnJyArIHNpZ25hdHVyZUVuY29kZWQgKyBwYXJhbXNFbmNvZGVkO1xufVxuXG4vLyBkZWNvZGUgbWV0aG9kIGRhdGEgYnl0ZWNvZGUsIGZyb20gbWV0aG9kIEFCSSBvYmplY3RcbmZ1bmN0aW9uIGRlY29kZU1ldGhvZChtZXRob2QsIGRhdGEpIHtcbiAgdmFyIG91dHB1dE5hbWVzID0gdXRpbHMuZ2V0S2V5cyhtZXRob2Qub3V0cHV0cywgJ25hbWUnLCB0cnVlKTtcbiAgdmFyIG91dHB1dFR5cGVzID0gdXRpbHMuZ2V0S2V5cyhtZXRob2Qub3V0cHV0cywgJ3R5cGUnKTtcblxuICByZXR1cm4gZGVjb2RlUGFyYW1zKG91dHB1dE5hbWVzLCBvdXRwdXRUeXBlcywgdXRpbHMuaGV4T3JCdWZmZXIoZGF0YSkpO1xufVxuXG4vLyBkZWNvZGUgbWV0aG9kIGRhdGEgYnl0ZWNvZGUsIGZyb20gbWV0aG9kIEFCSSBvYmplY3RcbmZ1bmN0aW9uIGVuY29kZUV2ZW50KGV2ZW50T2JqZWN0LCB2YWx1ZXMpIHtcbiAgcmV0dXJuIGVuY29kZU1ldGhvZChldmVudE9iamVjdCwgdmFsdWVzKTtcbn1cblxuZnVuY3Rpb24gZXZlbnRTaWduYXR1cmUoZXZlbnRPYmplY3QpIHtcbiAgdmFyIHNpZ25hdHVyZSA9IGV2ZW50T2JqZWN0Lm5hbWUgKyAnKCcgKyB1dGlscy5nZXRLZXlzKGV2ZW50T2JqZWN0LmlucHV0cywgJ3R5cGUnKS5qb2luKCcsJykgKyAnKSc7XG4gIHJldHVybiAnMHgnICsgdXRpbHMua2VjY2FrMjU2KHNpZ25hdHVyZSk7XG59XG5cbi8vIGRlY29kZSBtZXRob2QgZGF0YSBieXRlY29kZSwgZnJvbSBtZXRob2QgQUJJIG9iamVjdFxuZnVuY3Rpb24gZGVjb2RlRXZlbnQoZXZlbnRPYmplY3QsIGRhdGEsIHRvcGljcykge1xuICB2YXIgdXNlTnVtYmVyZWRQYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRydWU7XG5cbiAgdmFyIG5vbkluZGV4ZWQgPSBldmVudE9iamVjdC5pbnB1dHMuZmlsdGVyKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHJldHVybiAhaW5wdXQuaW5kZXhlZDtcbiAgfSk7XG4gIHZhciBub25JbmRleGVkTmFtZXMgPSB1dGlscy5nZXRLZXlzKG5vbkluZGV4ZWQsICduYW1lJywgdHJ1ZSk7XG4gIHZhciBub25JbmRleGVkVHlwZXMgPSB1dGlscy5nZXRLZXlzKG5vbkluZGV4ZWQsICd0eXBlJyk7XG4gIHZhciBldmVudCA9IGRlY29kZVBhcmFtcyhub25JbmRleGVkTmFtZXMsIG5vbkluZGV4ZWRUeXBlcywgdXRpbHMuaGV4T3JCdWZmZXIoZGF0YSksIHVzZU51bWJlcmVkUGFyYW1zKTtcbiAgdmFyIHRvcGljT2Zmc2V0ID0gZXZlbnRPYmplY3QuYW5vbnltb3VzID8gMCA6IDE7XG4gIGV2ZW50T2JqZWN0LmlucHV0cy5maWx0ZXIoZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LmluZGV4ZWQ7XG4gIH0pLm1hcChmdW5jdGlvbiAoaW5wdXQsIGkpIHtcbiAgICB2YXIgdG9waWMgPSBuZXcgQnVmZmVyKHRvcGljc1tpICsgdG9waWNPZmZzZXRdLnNsaWNlKDIpLCAnaGV4Jyk7XG4gICAgdmFyIGNvZGVyID0gZ2V0UGFyYW1Db2RlcihpbnB1dC50eXBlKTtcbiAgICBldmVudFtpbnB1dC5uYW1lXSA9IGNvZGVyLmRlY29kZSh0b3BpYywgMCkudmFsdWU7XG4gIH0pO1xuICBldmVudC5fZXZlbnROYW1lID0gZXZlbnRPYmplY3QubmFtZTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vLyBEZWNvZGUgYSBzcGVjaWZpYyBsb2cgaXRlbSB3aXRoIGEgc3BlY2lmaWMgZXZlbnQgYWJpXG5mdW5jdGlvbiBkZWNvZGVMb2dJdGVtKGV2ZW50T2JqZWN0LCBsb2cpIHtcbiAgdmFyIHVzZU51bWJlcmVkUGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuXG4gIGlmIChldmVudE9iamVjdCAmJiBsb2cudG9waWNzWzBdID09PSBldmVudFNpZ25hdHVyZShldmVudE9iamVjdCkpIHtcbiAgICByZXR1cm4gZGVjb2RlRXZlbnQoZXZlbnRPYmplY3QsIGxvZy5kYXRhLCBsb2cudG9waWNzLCB1c2VOdW1iZXJlZFBhcmFtcyk7XG4gIH1cbn1cblxuLy8gQ3JlYXRlIGEgZGVjb2RlciBmb3IgYWxsIGV2ZW50cyBkZWZpbmVkIGluIGFuIGFiaS4gSXQgcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZFxuLy8gb24gYW4gYXJyYXkgb2YgbG9nIGVudHJpZXMgc3VjaCBhcyByZWNlaXZlZCBmcm9tIGdldExvZ3Mgb3IgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0IGFuZCBwYXJzZXNcbi8vIGFueSBtYXRjaGluZyBsb2cgZW50cmllc1xuZnVuY3Rpb24gbG9nRGVjb2RlcihhYmkpIHtcbiAgdmFyIHVzZU51bWJlcmVkUGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gIHZhciBldmVudE1hcCA9IHt9O1xuICBhYmkuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0udHlwZSA9PT0gJ2V2ZW50JztcbiAgfSkubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgZXZlbnRNYXBbZXZlbnRTaWduYXR1cmUoaXRlbSldID0gaXRlbTtcbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbiAobG9nSXRlbXMpIHtcbiAgICByZXR1cm4gbG9nSXRlbXMubWFwKGZ1bmN0aW9uIChsb2cpIHtcbiAgICAgIHJldHVybiBkZWNvZGVMb2dJdGVtKGV2ZW50TWFwW2xvZy50b3BpY3NbMF1dLCBsb2csIHVzZU51bWJlcmVkUGFyYW1zKTtcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH0pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZW5jb2RlUGFyYW1zOiBlbmNvZGVQYXJhbXMsXG4gIGRlY29kZVBhcmFtczogZGVjb2RlUGFyYW1zLFxuICBlbmNvZGVNZXRob2Q6IGVuY29kZU1ldGhvZCxcbiAgZGVjb2RlTWV0aG9kOiBkZWNvZGVNZXRob2QsXG4gIGVuY29kZUV2ZW50OiBlbmNvZGVFdmVudCxcbiAgZGVjb2RlRXZlbnQ6IGRlY29kZUV2ZW50LFxuICBkZWNvZGVMb2dJdGVtOiBkZWNvZGVMb2dJdGVtLFxuICBsb2dEZWNvZGVyOiBsb2dEZWNvZGVyLFxuICBldmVudFNpZ25hdHVyZTogZXZlbnRTaWduYXR1cmVcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ25cIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yJyk7XG5cbnZhciBfcmVnZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVnZW5lcmF0b3IpO1xuXG52YXIgX3N0cmluZ2lmeSA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeScpO1xuXG52YXIgX3N0cmluZ2lmeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdHJpbmdpZnkpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3InKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FzeW5jVG9HZW5lcmF0b3IyKTtcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbicpO1xuXG52YXIgX2Fzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3NpZ24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBhYmkgPSByZXF1aXJlKCdldGhqcy1hYmknKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxudmFyIEV0aEZpbHRlciA9IHJlcXVpcmUoJ2V0aGpzLWZpbHRlcicpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJ2V0aGpzLXV0aWwnKS5nZXRLZXlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG52YXIga2VjY2FrMjU2ID0gcmVxdWlyZSgnanMtc2hhMycpLmtlY2Nha18yNTY7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbnZhciBoYXNUcmFuc2FjdGlvbk9iamVjdCA9IHJlcXVpcmUoJy4vaGFzLXR4LW9iamVjdCcpO1xudmFyIHByb21pc2VUb0NhbGxiYWNrID0gcmVxdWlyZSgncHJvbWlzZS10by1jYWxsYmFjaycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRyYWN0O1xuXG5mdW5jdGlvbiBDb250cmFjdCgpIHtcbiAgdmFyIHBlcmZvcm1DYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjNbJ2RlZmF1bHQnXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3IyWydkZWZhdWx0J10ubWFyayhmdW5jdGlvbiBfY2FsbGVlKF9yZWYpIHtcbiAgICAgIHZhciBtZXRob2RPYmplY3QgPSBfcmVmLm1ldGhvZE9iamVjdCxcbiAgICAgICAgICBtZXRob2RBcmdzID0gX3JlZi5tZXRob2RBcmdzO1xuICAgICAgdmFyIHF1ZXJ5TWV0aG9kLCBwcm92aWRlZFR4T2JqZWN0LCBtZXRob2RUeE9iamVjdCwgcXVlcnlSZXN1bHQsIGRlY29kZWRNZXRob2RSZXN1bHQsIGRlY29kaW5nRXJyb3I7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yMlsnZGVmYXVsdCddLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHF1ZXJ5TWV0aG9kID0gJ2NhbGwnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICAgICAgICAgICAgcHJvdmlkZWRUeE9iamVjdCA9IHt9OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICAgICAgICAgICAgaWYgKGhhc1RyYW5zYWN0aW9uT2JqZWN0KG1ldGhvZEFyZ3MpKSBwcm92aWRlZFR4T2JqZWN0ID0gbWV0aG9kQXJncy5wb3AoKTtcbiAgICAgICAgICAgICAgbWV0aG9kVHhPYmplY3QgPSAoMCwgX2Fzc2lnbjJbJ2RlZmF1bHQnXSkoe30sIHNlbGYuZGVmYXVsdFR4T2JqZWN0LCBwcm92aWRlZFR4T2JqZWN0LCB7XG4gICAgICAgICAgICAgICAgdG86IHNlbGYuYWRkcmVzc1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBtZXRob2RUeE9iamVjdC5kYXRhID0gYWJpLmVuY29kZU1ldGhvZChtZXRob2RPYmplY3QsIG1ldGhvZEFyZ3MpO1xuXG4gICAgICAgICAgICAgIGlmIChtZXRob2RPYmplY3QuY29uc3RhbnQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlNZXRob2QgPSAnc2VuZFRyYW5zYWN0aW9uJztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA4O1xuICAgICAgICAgICAgICByZXR1cm4gc2VsZi5xdWVyeVtxdWVyeU1ldGhvZF0obWV0aG9kVHhPYmplY3QpO1xuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIHF1ZXJ5UmVzdWx0ID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgICBpZiAoIShxdWVyeU1ldGhvZCA9PT0gJ2NhbGwnKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxMDtcbiAgICAgICAgICAgICAgZGVjb2RlZE1ldGhvZFJlc3VsdCA9IGFiaS5kZWNvZGVNZXRob2QobWV0aG9kT2JqZWN0LCBxdWVyeVJlc3VsdCk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoJ3JldHVybicsIGRlY29kZWRNZXRob2RSZXN1bHQpO1xuXG4gICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTU7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbJ2NhdGNoJ10oMTApO1xuICAgICAgICAgICAgICBkZWNvZGluZ0Vycm9yID0gbmV3IEVycm9yKCdbZXRoanMtY29udHJhY3RdIHdoaWxlIGZvcm1hdHRpbmcgaW5jb21pbmcgcmF3IGNhbGwgZGF0YSAnICsgKDAsIF9zdHJpbmdpZnkyWydkZWZhdWx0J10pKHF1ZXJ5UmVzdWx0KSArICcgJyArIF9jb250ZXh0LnQwKTtcbiAgICAgICAgICAgICAgdGhyb3cgZGVjb2RpbmdFcnJvcjtcblxuICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgncmV0dXJuJywgcXVlcnlSZXN1bHQpO1xuXG4gICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUsIHRoaXMsIFtbMTAsIDE1XV0pO1xuICAgIH0pKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBwZXJmb3JtQ2FsbChfeDIpIHtcbiAgICAgIHJldHVybiBfcmVmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLmFiaSA9IG9wdHMuY29udHJhY3RBQkkgfHwgW107XG4gIHNlbGYucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuICBzZWxmLmFkZHJlc3MgPSBvcHRzLmFkZHJlc3MgfHwgJzB4JztcbiAgc2VsZi5ieXRlY29kZSA9IG9wdHMuY29udHJhY3RCeXRlY29kZSB8fCAnMHgnO1xuICBzZWxmLmRlZmF1bHRUeE9iamVjdCA9IG9wdHMuY29udHJhY3REZWZhdWx0VHhPYmplY3QgfHwge307XG4gIHNlbGYuZmlsdGVycyA9IG5ldyBFdGhGaWx0ZXIoc2VsZi5xdWVyeSk7XG5cbiAgZ2V0Q2FsbGFibGVNZXRob2RzRnJvbUFCSShzZWxmLmFiaSkuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kT2JqZWN0KSB7XG4gICAgaWYgKG1ldGhvZE9iamVjdC50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzZWxmW21ldGhvZE9iamVjdC5uYW1lXSA9IGNyZWF0ZUNvbnRyYWN0RnVuY3Rpb24obWV0aG9kT2JqZWN0KTtcbiAgICB9IGVsc2UgaWYgKG1ldGhvZE9iamVjdC50eXBlID09PSAnZXZlbnQnKSB7XG4gICAgICBzZWxmW21ldGhvZE9iamVjdC5uYW1lXSA9IGNyZWF0ZUNvbnRyYWN0RXZlbnQobWV0aG9kT2JqZWN0KTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbnRyYWN0RXZlbnQobWV0aG9kT2JqZWN0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNvbnRyYWN0RXZlbnQoKSB7XG4gICAgICB2YXIgbWV0aG9kQXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgICB2YXIgZmlsdGVySW5wdXRUeXBlcyA9IGdldEtleXMobWV0aG9kT2JqZWN0LmlucHV0cywgJ3R5cGUnLCBmYWxzZSk7XG4gICAgICB2YXIgZmlsdGVyVG9waWMgPSAnMHgnICsga2VjY2FrMjU2KG1ldGhvZE9iamVjdC5uYW1lICsgJygnICsgZmlsdGVySW5wdXRUeXBlcy5qb2luKCcsJykgKyAnKScpO1xuICAgICAgdmFyIGZpbHRlclRvcGNpcyA9IFtmaWx0ZXJUb3BpY107XG4gICAgICB2YXIgYXJnc09iamVjdCA9ICgwLCBfYXNzaWduMlsnZGVmYXVsdCddKSh7fSwgbWV0aG9kQXJnc1swXSkgfHwge307XG5cbiAgICAgIHZhciBkZWZhdWx0RmlsdGVyT2JqZWN0ID0gKDAsIF9hc3NpZ24yWydkZWZhdWx0J10pKHt9LCBtZXRob2RBcmdzWzBdIHx8IHt9LCB7XG4gICAgICAgIHRvOiBzZWxmLmFkZHJlc3MsXG4gICAgICAgIHRvcGljczogZmlsdGVyVG9wY2lzXG4gICAgICB9KTtcbiAgICAgIHZhciBmaWx0ZXJPcHRzID0gKDAsIF9hc3NpZ24yWydkZWZhdWx0J10pKHt9LCBhcmdzT2JqZWN0LCB7XG4gICAgICAgIGRlY29kZXI6IGZ1bmN0aW9uIGRlY29kZXIobG9nRGF0YSkge1xuICAgICAgICAgIHJldHVybiBhYmkuZGVjb2RlRXZlbnQobWV0aG9kT2JqZWN0LCBsb2dEYXRhLCBmaWx0ZXJUb3BjaXMpO1xuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0RmlsdGVyT2JqZWN0OiBkZWZhdWx0RmlsdGVyT2JqZWN0XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG5ldyBzZWxmLmZpbHRlcnMuRmlsdGVyKGZpbHRlck9wdHMpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb250cmFjdEZ1bmN0aW9uKG1ldGhvZE9iamVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBjb250cmFjdEZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1ldGhvZENhbGxiYWNrID0gdm9pZCAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICB2YXIgbWV0aG9kQXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgaWYgKHR5cGVvZiBtZXRob2RBcmdzW21ldGhvZEFyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbWV0aG9kQ2FsbGJhY2sgPSBtZXRob2RBcmdzLnBvcCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvbWlzZSA9IHBlcmZvcm1DYWxsKHsgbWV0aG9kT2JqZWN0OiBtZXRob2RPYmplY3QsIG1ldGhvZEFyZ3M6IG1ldGhvZEFyZ3MgfSk7XG5cbiAgICAgIGlmIChtZXRob2RDYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gcHJvbWlzZVRvQ2FsbGJhY2socHJvbWlzZSkobWV0aG9kQ2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldENhbGxhYmxlTWV0aG9kc0Zyb21BQkkoY29udHJhY3RBQkkpIHtcbiAgcmV0dXJuIGNvbnRyYWN0QUJJLmZpbHRlcihmdW5jdGlvbiAoanNvbikge1xuICAgIHJldHVybiAoanNvbi50eXBlID09PSAnZnVuY3Rpb24nIHx8IGpzb24udHlwZSA9PT0gJ2V2ZW50JykgJiYganNvbi5uYW1lLmxlbmd0aCA+IDA7XG4gIH0pO1xufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9rZXlzID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzJyk7XG5cbnZhciBfa2V5czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgdHhPYmplY3RQcm9wZXJ0aWVzID0gWydmcm9tJywgJ3RvJywgJ2RhdGEnLCAndmFsdWUnLCAnZ2FzUHJpY2UnLCAnZ2FzJ107XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzVHJhbnNhY3Rpb25PYmplY3Q7XG5cbmZ1bmN0aW9uIGhhc1RyYW5zYWN0aW9uT2JqZWN0KGFyZ3MpIHtcbiAgLy8gYmFkL2VtcHR5IGFyZ3M6IGJhZFxuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJncykgfHwgYXJncy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RBcmcgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gIC8vIG1pc3Npbmcgb3Igbm9uLW9iamVjdDogYmFkXG4gIGlmICghbGFzdEFyZykgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGxhc3RBcmcgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGVtcHR5IG9iamVjdDogZ29vZFxuICBpZiAoKDAsIF9rZXlzMlsnZGVmYXVsdCddKShsYXN0QXJnKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyB0eFBhcmFtcyBvYmplY3Q6IGdvb2RcbiAgdmFyIGtleXMgPSAoMCwgX2tleXMyWydkZWZhdWx0J10pKGxhc3RBcmcpO1xuICB2YXIgaGFzTWF0Y2hpbmdLZXlzID0gdHhPYmplY3RQcm9wZXJ0aWVzLnNvbWUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGtleXMuaW5jbHVkZXModmFsdWUpO1xuICB9KTtcbiAgaWYgKGhhc01hdGNoaW5nS2V5cykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIG5vIG1hdGNoXG4gIHJldHVybiBmYWxzZTtcbn0iLCIvKipcclxuICogW2pzLXNoYTNde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9lbW4xNzgvanMtc2hhM31cclxuICpcclxuICogQHZlcnNpb24gMC41LjdcclxuICogQGF1dGhvciBDaGVuLCBZaS1DeXVhbiBbZW1uMTc4QGdtYWlsLmNvbV1cclxuICogQGNvcHlyaWdodCBDaGVuLCBZaS1DeXVhbiAyMDE1LTIwMTZcclxuICogQGxpY2Vuc2UgTUlUXHJcbiAqL1xyXG4vKmpzbGludCBiaXR3aXNlOiB0cnVlICovXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICB2YXIgcm9vdCA9IHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnID8gd2luZG93IDoge307XHJcbiAgdmFyIE5PREVfSlMgPSAhcm9vdC5KU19TSEEzX05PX05PREVfSlMgJiYgdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlO1xyXG4gIGlmIChOT0RFX0pTKSB7XHJcbiAgICByb290ID0gZ2xvYmFsO1xyXG4gIH1cclxuICB2YXIgQ09NTU9OX0pTID0gIXJvb3QuSlNfU0hBM19OT19DT01NT05fSlMgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHM7XHJcbiAgdmFyIEhFWF9DSEFSUyA9ICcwMTIzNDU2Nzg5YWJjZGVmJy5zcGxpdCgnJyk7XHJcbiAgdmFyIFNIQUtFX1BBRERJTkcgPSBbMzEsIDc5MzYsIDIwMzE2MTYsIDUyMDA5MzY5Nl07XHJcbiAgdmFyIEtFQ0NBS19QQURESU5HID0gWzEsIDI1NiwgNjU1MzYsIDE2Nzc3MjE2XTtcclxuICB2YXIgUEFERElORyA9IFs2LCAxNTM2LCAzOTMyMTYsIDEwMDY2MzI5Nl07XHJcbiAgdmFyIFNISUZUID0gWzAsIDgsIDE2LCAyNF07XHJcbiAgdmFyIFJDID0gWzEsIDAsIDMyODk4LCAwLCAzMjkwNiwgMjE0NzQ4MzY0OCwgMjE0NzUxNjQxNiwgMjE0NzQ4MzY0OCwgMzI5MDcsIDAsIDIxNDc0ODM2NDksXHJcbiAgICAgICAgICAgIDAsIDIxNDc1MTY1NDUsIDIxNDc0ODM2NDgsIDMyNzc3LCAyMTQ3NDgzNjQ4LCAxMzgsIDAsIDEzNiwgMCwgMjE0NzUxNjQyNSwgMCxcclxuICAgICAgICAgICAgMjE0NzQ4MzY1OCwgMCwgMjE0NzUxNjU1NSwgMCwgMTM5LCAyMTQ3NDgzNjQ4LCAzMjkwNSwgMjE0NzQ4MzY0OCwgMzI3NzEsXHJcbiAgICAgICAgICAgIDIxNDc0ODM2NDgsIDMyNzcwLCAyMTQ3NDgzNjQ4LCAxMjgsIDIxNDc0ODM2NDgsIDMyNzc4LCAwLCAyMTQ3NDgzNjU4LCAyMTQ3NDgzNjQ4LFxyXG4gICAgICAgICAgICAyMTQ3NTE2NTQ1LCAyMTQ3NDgzNjQ4LCAzMjg5NiwgMjE0NzQ4MzY0OCwgMjE0NzQ4MzY0OSwgMCwgMjE0NzUxNjQyNCwgMjE0NzQ4MzY0OF07XHJcbiAgdmFyIEJJVFMgPSBbMjI0LCAyNTYsIDM4NCwgNTEyXTtcclxuICB2YXIgU0hBS0VfQklUUyA9IFsxMjgsIDI1Nl07XHJcbiAgdmFyIE9VVFBVVF9UWVBFUyA9IFsnaGV4JywgJ2J1ZmZlcicsICdhcnJheUJ1ZmZlcicsICdhcnJheSddO1xyXG5cclxuICB2YXIgY3JlYXRlT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcsIG91dHB1dFR5cGUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBiaXRzKS51cGRhdGUobWVzc2FnZSlbb3V0cHV0VHlwZV0oKTtcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgdmFyIGNyZWF0ZVNoYWtlT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcsIG91dHB1dFR5cGUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwgb3V0cHV0Qml0cykge1xyXG4gICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKS51cGRhdGUobWVzc2FnZSlbb3V0cHV0VHlwZV0oKTtcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgdmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nKSB7XHJcbiAgICB2YXIgbWV0aG9kID0gY3JlYXRlT3V0cHV0TWV0aG9kKGJpdHMsIHBhZGRpbmcsICdoZXgnKTtcclxuICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIGJpdHMpO1xyXG4gICAgfTtcclxuICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgICByZXR1cm4gbWV0aG9kLmNyZWF0ZSgpLnVwZGF0ZShtZXNzYWdlKTtcclxuICAgIH07XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE9VVFBVVF9UWVBFUy5sZW5ndGg7ICsraSkge1xyXG4gICAgICB2YXIgdHlwZSA9IE9VVFBVVF9UWVBFU1tpXTtcclxuICAgICAgbWV0aG9kW3R5cGVdID0gY3JlYXRlT3V0cHV0TWV0aG9kKGJpdHMsIHBhZGRpbmcsIHR5cGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1ldGhvZDtcclxuICB9O1xyXG5cclxuICB2YXIgY3JlYXRlU2hha2VNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZykge1xyXG4gICAgdmFyIG1ldGhvZCA9IGNyZWF0ZVNoYWtlT3V0cHV0TWV0aG9kKGJpdHMsIHBhZGRpbmcsICdoZXgnKTtcclxuICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAob3V0cHV0Qml0cykge1xyXG4gICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKTtcclxuICAgIH07XHJcbiAgICBtZXRob2QudXBkYXRlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG91dHB1dEJpdHMpIHtcclxuICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUob3V0cHV0Qml0cykudXBkYXRlKG1lc3NhZ2UpO1xyXG4gICAgfTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgT1VUUFVUX1RZUEVTLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIHZhciB0eXBlID0gT1VUUFVUX1RZUEVTW2ldO1xyXG4gICAgICBtZXRob2RbdHlwZV0gPSBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCB0eXBlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtZXRob2Q7XHJcbiAgfTtcclxuXHJcbiAgdmFyIGFsZ29yaXRobXMgPSBbXHJcbiAgICB7bmFtZTogJ2tlY2NhaycsIHBhZGRpbmc6IEtFQ0NBS19QQURESU5HLCBiaXRzOiBCSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZU1ldGhvZH0sXHJcbiAgICB7bmFtZTogJ3NoYTMnLCBwYWRkaW5nOiBQQURESU5HLCBiaXRzOiBCSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZU1ldGhvZH0sXHJcbiAgICB7bmFtZTogJ3NoYWtlJywgcGFkZGluZzogU0hBS0VfUEFERElORywgYml0czogU0hBS0VfQklUUywgY3JlYXRlTWV0aG9kOiBjcmVhdGVTaGFrZU1ldGhvZH1cclxuICBdO1xyXG5cclxuICB2YXIgbWV0aG9kcyA9IHt9LCBtZXRob2ROYW1lcyA9IFtdO1xyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsZ29yaXRobXMubGVuZ3RoOyArK2kpIHtcclxuICAgIHZhciBhbGdvcml0aG0gPSBhbGdvcml0aG1zW2ldO1xyXG4gICAgdmFyIGJpdHMgID0gYWxnb3JpdGhtLmJpdHM7XHJcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJpdHMubGVuZ3RoOyArK2opIHtcclxuICAgICAgdmFyIG1ldGhvZE5hbWUgPSBhbGdvcml0aG0ubmFtZSArJ18nICsgYml0c1tqXTtcclxuICAgICAgbWV0aG9kTmFtZXMucHVzaChtZXRob2ROYW1lKTtcclxuICAgICAgbWV0aG9kc1ttZXRob2ROYW1lXSA9IGFsZ29yaXRobS5jcmVhdGVNZXRob2QoYml0c1tqXSwgYWxnb3JpdGhtLnBhZGRpbmcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gS2VjY2FrKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpIHtcclxuICAgIHRoaXMuYmxvY2tzID0gW107XHJcbiAgICB0aGlzLnMgPSBbXTtcclxuICAgIHRoaXMucGFkZGluZyA9IHBhZGRpbmc7XHJcbiAgICB0aGlzLm91dHB1dEJpdHMgPSBvdXRwdXRCaXRzO1xyXG4gICAgdGhpcy5yZXNldCA9IHRydWU7XHJcbiAgICB0aGlzLmJsb2NrID0gMDtcclxuICAgIHRoaXMuc3RhcnQgPSAwO1xyXG4gICAgdGhpcy5ibG9ja0NvdW50ID0gKDE2MDAgLSAoYml0cyA8PCAxKSkgPj4gNTtcclxuICAgIHRoaXMuYnl0ZUNvdW50ID0gdGhpcy5ibG9ja0NvdW50IDw8IDI7XHJcbiAgICB0aGlzLm91dHB1dEJsb2NrcyA9IG91dHB1dEJpdHMgPj4gNTtcclxuICAgIHRoaXMuZXh0cmFCeXRlcyA9IChvdXRwdXRCaXRzICYgMzEpID4+IDM7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1MDsgKytpKSB7XHJcbiAgICAgIHRoaXMuc1tpXSA9IDA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBLZWNjYWsucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICB2YXIgbm90U3RyaW5nID0gdHlwZW9mIG1lc3NhZ2UgIT09ICdzdHJpbmcnO1xyXG4gICAgaWYgKG5vdFN0cmluZyAmJiBtZXNzYWdlLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcikge1xyXG4gICAgICBtZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkobWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICB2YXIgbGVuZ3RoID0gbWVzc2FnZS5sZW5ndGgsIGJsb2NrcyA9IHRoaXMuYmxvY2tzLCBieXRlQ291bnQgPSB0aGlzLmJ5dGVDb3VudCxcclxuICAgICAgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgaW5kZXggPSAwLCBzID0gdGhpcy5zLCBpLCBjb2RlO1xyXG5cclxuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgICBpZiAodGhpcy5yZXNldCkge1xyXG4gICAgICAgIHRoaXMucmVzZXQgPSBmYWxzZTtcclxuICAgICAgICBibG9ja3NbMF0gPSB0aGlzLmJsb2NrO1xyXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBibG9ja0NvdW50ICsgMTsgKytpKSB7XHJcbiAgICAgICAgICBibG9ja3NbaV0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAobm90U3RyaW5nKSB7XHJcbiAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IGJ5dGVDb3VudDsgKytpbmRleCkge1xyXG4gICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gbWVzc2FnZVtpbmRleF0gPDwgU0hJRlRbaSsrICYgM107XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAoaSA9IHRoaXMuc3RhcnQ7IGluZGV4IDwgbGVuZ3RoICYmIGkgPCBieXRlQ291bnQ7ICsraW5kZXgpIHtcclxuICAgICAgICAgIGNvZGUgPSBtZXNzYWdlLmNoYXJDb2RlQXQoaW5kZXgpO1xyXG4gICAgICAgICAgaWYgKGNvZGUgPCAweDgwKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9IGNvZGUgPDwgU0hJRlRbaSsrICYgM107XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweDgwMCkge1xyXG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhjMCB8IChjb2RlID4+IDYpKSA8PCBTSElGVFtpKysgJiAzXTtcclxuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ZDgwMCB8fCBjb2RlID49IDB4ZTAwMCkge1xyXG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhlMCB8IChjb2RlID4+IDEyKSkgPDwgU0hJRlRbaSsrICYgM107XHJcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDYpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xyXG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29kZSA9IDB4MTAwMDAgKyAoKChjb2RlICYgMHgzZmYpIDw8IDEwKSB8IChtZXNzYWdlLmNoYXJDb2RlQXQoKytpbmRleCkgJiAweDNmZikpO1xyXG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhmMCB8IChjb2RlID4+IDE4KSkgPDwgU0hJRlRbaSsrICYgM107XHJcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDEyKSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcclxuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XHJcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubGFzdEJ5dGVJbmRleCA9IGk7XHJcbiAgICAgIGlmIChpID49IGJ5dGVDb3VudCkge1xyXG4gICAgICAgIHRoaXMuc3RhcnQgPSBpIC0gYnl0ZUNvdW50O1xyXG4gICAgICAgIHRoaXMuYmxvY2sgPSBibG9ja3NbYmxvY2tDb3VudF07XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJsb2NrQ291bnQ7ICsraSkge1xyXG4gICAgICAgICAgc1tpXSBePSBibG9ja3NbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGYocyk7XHJcbiAgICAgICAgdGhpcy5yZXNldCA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5zdGFydCA9IGk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIEtlY2Nhay5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYmxvY2tzID0gdGhpcy5ibG9ja3MsIGkgPSB0aGlzLmxhc3RCeXRlSW5kZXgsIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIHMgPSB0aGlzLnM7XHJcbiAgICBibG9ja3NbaSA+PiAyXSB8PSB0aGlzLnBhZGRpbmdbaSAmIDNdO1xyXG4gICAgaWYgKHRoaXMubGFzdEJ5dGVJbmRleCA9PT0gdGhpcy5ieXRlQ291bnQpIHtcclxuICAgICAgYmxvY2tzWzBdID0gYmxvY2tzW2Jsb2NrQ291bnRdO1xyXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgYmxvY2tDb3VudCArIDE7ICsraSkge1xyXG4gICAgICAgIGJsb2Nrc1tpXSA9IDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGJsb2Nrc1tibG9ja0NvdW50IC0gMV0gfD0gMHg4MDAwMDAwMDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja0NvdW50OyArK2kpIHtcclxuICAgICAgc1tpXSBePSBibG9ja3NbaV07XHJcbiAgICB9XHJcbiAgICBmKHMpO1xyXG4gIH07XHJcblxyXG4gIEtlY2Nhay5wcm90b3R5cGUudG9TdHJpbmcgPSBLZWNjYWsucHJvdG90eXBlLmhleCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuZmluYWxpemUoKTtcclxuXHJcbiAgICB2YXIgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucywgb3V0cHV0QmxvY2tzID0gdGhpcy5vdXRwdXRCbG9ja3MsXHJcbiAgICAgICAgZXh0cmFCeXRlcyA9IHRoaXMuZXh0cmFCeXRlcywgaSA9IDAsIGogPSAwO1xyXG4gICAgdmFyIGhleCA9ICcnLCBibG9jaztcclxuICAgIHdoaWxlIChqIDwgb3V0cHV0QmxvY2tzKSB7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja0NvdW50ICYmIGogPCBvdXRwdXRCbG9ja3M7ICsraSwgKytqKSB7XHJcbiAgICAgICAgYmxvY2sgPSBzW2ldO1xyXG4gICAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbYmxvY2sgJiAweDBGXSArXHJcbiAgICAgICAgICAgICAgIEhFWF9DSEFSU1soYmxvY2sgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDgpICYgMHgwRl0gK1xyXG4gICAgICAgICAgICAgICBIRVhfQ0hBUlNbKGJsb2NrID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiAxNikgJiAweDBGXSArXHJcbiAgICAgICAgICAgICAgIEhFWF9DSEFSU1soYmxvY2sgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDI0KSAmIDB4MEZdO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChqICUgYmxvY2tDb3VudCA9PT0gMCkge1xyXG4gICAgICAgIGYocyk7XHJcbiAgICAgICAgaSA9IDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChleHRyYUJ5dGVzKSB7XHJcbiAgICAgIGJsb2NrID0gc1tpXTtcclxuICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAwKSB7XHJcbiAgICAgICAgaGV4ICs9IEhFWF9DSEFSU1soYmxvY2sgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1tibG9jayAmIDB4MEZdO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChleHRyYUJ5dGVzID4gMSkge1xyXG4gICAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiA4KSAmIDB4MEZdO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChleHRyYUJ5dGVzID4gMikge1xyXG4gICAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiAxNikgJiAweDBGXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhleDtcclxuICB9O1xyXG5cclxuICBLZWNjYWsucHJvdG90eXBlLmFycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5maW5hbGl6ZSgpO1xyXG5cclxuICAgIHZhciBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zLCBvdXRwdXRCbG9ja3MgPSB0aGlzLm91dHB1dEJsb2NrcyxcclxuICAgICAgICBleHRyYUJ5dGVzID0gdGhpcy5leHRyYUJ5dGVzLCBpID0gMCwgaiA9IDA7XHJcbiAgICB2YXIgYnl0ZXMgPSB0aGlzLm91dHB1dEJpdHMgPj4gMztcclxuICAgIHZhciBidWZmZXI7XHJcbiAgICBpZiAoZXh0cmFCeXRlcykge1xyXG4gICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoKG91dHB1dEJsb2NrcyArIDEpIDw8IDIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVzKTtcclxuICAgIH1cclxuICAgIHZhciBhcnJheSA9IG5ldyBVaW50MzJBcnJheShidWZmZXIpO1xyXG4gICAgd2hpbGUgKGogPCBvdXRwdXRCbG9ja3MpIHtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGJsb2NrQ291bnQgJiYgaiA8IG91dHB1dEJsb2NrczsgKytpLCArK2opIHtcclxuICAgICAgICBhcnJheVtqXSA9IHNbaV07XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGogJSBibG9ja0NvdW50ID09PSAwKSB7XHJcbiAgICAgICAgZihzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGV4dHJhQnl0ZXMpIHtcclxuICAgICAgYXJyYXlbaV0gPSBzW2ldO1xyXG4gICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoMCwgYnl0ZXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJ1ZmZlcjtcclxuICB9O1xyXG5cclxuICBLZWNjYWsucHJvdG90eXBlLmJ1ZmZlciA9IEtlY2Nhay5wcm90b3R5cGUuYXJyYXlCdWZmZXI7XHJcblxyXG4gIEtlY2Nhay5wcm90b3R5cGUuZGlnZXN0ID0gS2VjY2FrLnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuZmluYWxpemUoKTtcclxuXHJcbiAgICB2YXIgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucywgb3V0cHV0QmxvY2tzID0gdGhpcy5vdXRwdXRCbG9ja3MsXHJcbiAgICAgICAgZXh0cmFCeXRlcyA9IHRoaXMuZXh0cmFCeXRlcywgaSA9IDAsIGogPSAwO1xyXG4gICAgdmFyIGFycmF5ID0gW10sIG9mZnNldCwgYmxvY2s7XHJcbiAgICB3aGlsZSAoaiA8IG91dHB1dEJsb2Nrcykge1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOyArK2ksICsraikge1xyXG4gICAgICAgIG9mZnNldCA9IGogPDwgMjtcclxuICAgICAgICBibG9jayA9IHNbaV07XHJcbiAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IGJsb2NrICYgMHhGRjtcclxuICAgICAgICBhcnJheVtvZmZzZXQgKyAxXSA9IChibG9jayA+PiA4KSAmIDB4RkY7XHJcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMl0gPSAoYmxvY2sgPj4gMTYpICYgMHhGRjtcclxuICAgICAgICBhcnJheVtvZmZzZXQgKyAzXSA9IChibG9jayA+PiAyNCkgJiAweEZGO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChqICUgYmxvY2tDb3VudCA9PT0gMCkge1xyXG4gICAgICAgIGYocyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChleHRyYUJ5dGVzKSB7XHJcbiAgICAgIG9mZnNldCA9IGogPDwgMjtcclxuICAgICAgYmxvY2sgPSBzW2ldO1xyXG4gICAgICBpZiAoZXh0cmFCeXRlcyA+IDApIHtcclxuICAgICAgICBhcnJheVtvZmZzZXRdID0gYmxvY2sgJiAweEZGO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChleHRyYUJ5dGVzID4gMSkge1xyXG4gICAgICAgIGFycmF5W29mZnNldCArIDFdID0gKGJsb2NrID4+IDgpICYgMHhGRjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZXh0cmFCeXRlcyA+IDIpIHtcclxuICAgICAgICBhcnJheVtvZmZzZXQgKyAyXSA9IChibG9jayA+PiAxNikgJiAweEZGO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJyYXk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIGYgPSBmdW5jdGlvbiAocykge1xyXG4gICAgdmFyIGgsIGwsIG4sIGMwLCBjMSwgYzIsIGMzLCBjNCwgYzUsIGM2LCBjNywgYzgsIGM5LFxyXG4gICAgICAgIGIwLCBiMSwgYjIsIGIzLCBiNCwgYjUsIGI2LCBiNywgYjgsIGI5LCBiMTAsIGIxMSwgYjEyLCBiMTMsIGIxNCwgYjE1LCBiMTYsIGIxNyxcclxuICAgICAgICBiMTgsIGIxOSwgYjIwLCBiMjEsIGIyMiwgYjIzLCBiMjQsIGIyNSwgYjI2LCBiMjcsIGIyOCwgYjI5LCBiMzAsIGIzMSwgYjMyLCBiMzMsXHJcbiAgICAgICAgYjM0LCBiMzUsIGIzNiwgYjM3LCBiMzgsIGIzOSwgYjQwLCBiNDEsIGI0MiwgYjQzLCBiNDQsIGI0NSwgYjQ2LCBiNDcsIGI0OCwgYjQ5O1xyXG4gICAgZm9yIChuID0gMDsgbiA8IDQ4OyBuICs9IDIpIHtcclxuICAgICAgYzAgPSBzWzBdIF4gc1sxMF0gXiBzWzIwXSBeIHNbMzBdIF4gc1s0MF07XHJcbiAgICAgIGMxID0gc1sxXSBeIHNbMTFdIF4gc1syMV0gXiBzWzMxXSBeIHNbNDFdO1xyXG4gICAgICBjMiA9IHNbMl0gXiBzWzEyXSBeIHNbMjJdIF4gc1szMl0gXiBzWzQyXTtcclxuICAgICAgYzMgPSBzWzNdIF4gc1sxM10gXiBzWzIzXSBeIHNbMzNdIF4gc1s0M107XHJcbiAgICAgIGM0ID0gc1s0XSBeIHNbMTRdIF4gc1syNF0gXiBzWzM0XSBeIHNbNDRdO1xyXG4gICAgICBjNSA9IHNbNV0gXiBzWzE1XSBeIHNbMjVdIF4gc1szNV0gXiBzWzQ1XTtcclxuICAgICAgYzYgPSBzWzZdIF4gc1sxNl0gXiBzWzI2XSBeIHNbMzZdIF4gc1s0Nl07XHJcbiAgICAgIGM3ID0gc1s3XSBeIHNbMTddIF4gc1syN10gXiBzWzM3XSBeIHNbNDddO1xyXG4gICAgICBjOCA9IHNbOF0gXiBzWzE4XSBeIHNbMjhdIF4gc1szOF0gXiBzWzQ4XTtcclxuICAgICAgYzkgPSBzWzldIF4gc1sxOV0gXiBzWzI5XSBeIHNbMzldIF4gc1s0OV07XHJcblxyXG4gICAgICBoID0gYzggXiAoKGMyIDw8IDEpIHwgKGMzID4+PiAzMSkpO1xyXG4gICAgICBsID0gYzkgXiAoKGMzIDw8IDEpIHwgKGMyID4+PiAzMSkpO1xyXG4gICAgICBzWzBdIF49IGg7XHJcbiAgICAgIHNbMV0gXj0gbDtcclxuICAgICAgc1sxMF0gXj0gaDtcclxuICAgICAgc1sxMV0gXj0gbDtcclxuICAgICAgc1syMF0gXj0gaDtcclxuICAgICAgc1syMV0gXj0gbDtcclxuICAgICAgc1szMF0gXj0gaDtcclxuICAgICAgc1szMV0gXj0gbDtcclxuICAgICAgc1s0MF0gXj0gaDtcclxuICAgICAgc1s0MV0gXj0gbDtcclxuICAgICAgaCA9IGMwIF4gKChjNCA8PCAxKSB8IChjNSA+Pj4gMzEpKTtcclxuICAgICAgbCA9IGMxIF4gKChjNSA8PCAxKSB8IChjNCA+Pj4gMzEpKTtcclxuICAgICAgc1syXSBePSBoO1xyXG4gICAgICBzWzNdIF49IGw7XHJcbiAgICAgIHNbMTJdIF49IGg7XHJcbiAgICAgIHNbMTNdIF49IGw7XHJcbiAgICAgIHNbMjJdIF49IGg7XHJcbiAgICAgIHNbMjNdIF49IGw7XHJcbiAgICAgIHNbMzJdIF49IGg7XHJcbiAgICAgIHNbMzNdIF49IGw7XHJcbiAgICAgIHNbNDJdIF49IGg7XHJcbiAgICAgIHNbNDNdIF49IGw7XHJcbiAgICAgIGggPSBjMiBeICgoYzYgPDwgMSkgfCAoYzcgPj4+IDMxKSk7XHJcbiAgICAgIGwgPSBjMyBeICgoYzcgPDwgMSkgfCAoYzYgPj4+IDMxKSk7XHJcbiAgICAgIHNbNF0gXj0gaDtcclxuICAgICAgc1s1XSBePSBsO1xyXG4gICAgICBzWzE0XSBePSBoO1xyXG4gICAgICBzWzE1XSBePSBsO1xyXG4gICAgICBzWzI0XSBePSBoO1xyXG4gICAgICBzWzI1XSBePSBsO1xyXG4gICAgICBzWzM0XSBePSBoO1xyXG4gICAgICBzWzM1XSBePSBsO1xyXG4gICAgICBzWzQ0XSBePSBoO1xyXG4gICAgICBzWzQ1XSBePSBsO1xyXG4gICAgICBoID0gYzQgXiAoKGM4IDw8IDEpIHwgKGM5ID4+PiAzMSkpO1xyXG4gICAgICBsID0gYzUgXiAoKGM5IDw8IDEpIHwgKGM4ID4+PiAzMSkpO1xyXG4gICAgICBzWzZdIF49IGg7XHJcbiAgICAgIHNbN10gXj0gbDtcclxuICAgICAgc1sxNl0gXj0gaDtcclxuICAgICAgc1sxN10gXj0gbDtcclxuICAgICAgc1syNl0gXj0gaDtcclxuICAgICAgc1syN10gXj0gbDtcclxuICAgICAgc1szNl0gXj0gaDtcclxuICAgICAgc1szN10gXj0gbDtcclxuICAgICAgc1s0Nl0gXj0gaDtcclxuICAgICAgc1s0N10gXj0gbDtcclxuICAgICAgaCA9IGM2IF4gKChjMCA8PCAxKSB8IChjMSA+Pj4gMzEpKTtcclxuICAgICAgbCA9IGM3IF4gKChjMSA8PCAxKSB8IChjMCA+Pj4gMzEpKTtcclxuICAgICAgc1s4XSBePSBoO1xyXG4gICAgICBzWzldIF49IGw7XHJcbiAgICAgIHNbMThdIF49IGg7XHJcbiAgICAgIHNbMTldIF49IGw7XHJcbiAgICAgIHNbMjhdIF49IGg7XHJcbiAgICAgIHNbMjldIF49IGw7XHJcbiAgICAgIHNbMzhdIF49IGg7XHJcbiAgICAgIHNbMzldIF49IGw7XHJcbiAgICAgIHNbNDhdIF49IGg7XHJcbiAgICAgIHNbNDldIF49IGw7XHJcblxyXG4gICAgICBiMCA9IHNbMF07XHJcbiAgICAgIGIxID0gc1sxXTtcclxuICAgICAgYjMyID0gKHNbMTFdIDw8IDQpIHwgKHNbMTBdID4+PiAyOCk7XHJcbiAgICAgIGIzMyA9IChzWzEwXSA8PCA0KSB8IChzWzExXSA+Pj4gMjgpO1xyXG4gICAgICBiMTQgPSAoc1syMF0gPDwgMykgfCAoc1syMV0gPj4+IDI5KTtcclxuICAgICAgYjE1ID0gKHNbMjFdIDw8IDMpIHwgKHNbMjBdID4+PiAyOSk7XHJcbiAgICAgIGI0NiA9IChzWzMxXSA8PCA5KSB8IChzWzMwXSA+Pj4gMjMpO1xyXG4gICAgICBiNDcgPSAoc1szMF0gPDwgOSkgfCAoc1szMV0gPj4+IDIzKTtcclxuICAgICAgYjI4ID0gKHNbNDBdIDw8IDE4KSB8IChzWzQxXSA+Pj4gMTQpO1xyXG4gICAgICBiMjkgPSAoc1s0MV0gPDwgMTgpIHwgKHNbNDBdID4+PiAxNCk7XHJcbiAgICAgIGIyMCA9IChzWzJdIDw8IDEpIHwgKHNbM10gPj4+IDMxKTtcclxuICAgICAgYjIxID0gKHNbM10gPDwgMSkgfCAoc1syXSA+Pj4gMzEpO1xyXG4gICAgICBiMiA9IChzWzEzXSA8PCAxMikgfCAoc1sxMl0gPj4+IDIwKTtcclxuICAgICAgYjMgPSAoc1sxMl0gPDwgMTIpIHwgKHNbMTNdID4+PiAyMCk7XHJcbiAgICAgIGIzNCA9IChzWzIyXSA8PCAxMCkgfCAoc1syM10gPj4+IDIyKTtcclxuICAgICAgYjM1ID0gKHNbMjNdIDw8IDEwKSB8IChzWzIyXSA+Pj4gMjIpO1xyXG4gICAgICBiMTYgPSAoc1szM10gPDwgMTMpIHwgKHNbMzJdID4+PiAxOSk7XHJcbiAgICAgIGIxNyA9IChzWzMyXSA8PCAxMykgfCAoc1szM10gPj4+IDE5KTtcclxuICAgICAgYjQ4ID0gKHNbNDJdIDw8IDIpIHwgKHNbNDNdID4+PiAzMCk7XHJcbiAgICAgIGI0OSA9IChzWzQzXSA8PCAyKSB8IChzWzQyXSA+Pj4gMzApO1xyXG4gICAgICBiNDAgPSAoc1s1XSA8PCAzMCkgfCAoc1s0XSA+Pj4gMik7XHJcbiAgICAgIGI0MSA9IChzWzRdIDw8IDMwKSB8IChzWzVdID4+PiAyKTtcclxuICAgICAgYjIyID0gKHNbMTRdIDw8IDYpIHwgKHNbMTVdID4+PiAyNik7XHJcbiAgICAgIGIyMyA9IChzWzE1XSA8PCA2KSB8IChzWzE0XSA+Pj4gMjYpO1xyXG4gICAgICBiNCA9IChzWzI1XSA8PCAxMSkgfCAoc1syNF0gPj4+IDIxKTtcclxuICAgICAgYjUgPSAoc1syNF0gPDwgMTEpIHwgKHNbMjVdID4+PiAyMSk7XHJcbiAgICAgIGIzNiA9IChzWzM0XSA8PCAxNSkgfCAoc1szNV0gPj4+IDE3KTtcclxuICAgICAgYjM3ID0gKHNbMzVdIDw8IDE1KSB8IChzWzM0XSA+Pj4gMTcpO1xyXG4gICAgICBiMTggPSAoc1s0NV0gPDwgMjkpIHwgKHNbNDRdID4+PiAzKTtcclxuICAgICAgYjE5ID0gKHNbNDRdIDw8IDI5KSB8IChzWzQ1XSA+Pj4gMyk7XHJcbiAgICAgIGIxMCA9IChzWzZdIDw8IDI4KSB8IChzWzddID4+PiA0KTtcclxuICAgICAgYjExID0gKHNbN10gPDwgMjgpIHwgKHNbNl0gPj4+IDQpO1xyXG4gICAgICBiNDIgPSAoc1sxN10gPDwgMjMpIHwgKHNbMTZdID4+PiA5KTtcclxuICAgICAgYjQzID0gKHNbMTZdIDw8IDIzKSB8IChzWzE3XSA+Pj4gOSk7XHJcbiAgICAgIGIyNCA9IChzWzI2XSA8PCAyNSkgfCAoc1syN10gPj4+IDcpO1xyXG4gICAgICBiMjUgPSAoc1syN10gPDwgMjUpIHwgKHNbMjZdID4+PiA3KTtcclxuICAgICAgYjYgPSAoc1szNl0gPDwgMjEpIHwgKHNbMzddID4+PiAxMSk7XHJcbiAgICAgIGI3ID0gKHNbMzddIDw8IDIxKSB8IChzWzM2XSA+Pj4gMTEpO1xyXG4gICAgICBiMzggPSAoc1s0N10gPDwgMjQpIHwgKHNbNDZdID4+PiA4KTtcclxuICAgICAgYjM5ID0gKHNbNDZdIDw8IDI0KSB8IChzWzQ3XSA+Pj4gOCk7XHJcbiAgICAgIGIzMCA9IChzWzhdIDw8IDI3KSB8IChzWzldID4+PiA1KTtcclxuICAgICAgYjMxID0gKHNbOV0gPDwgMjcpIHwgKHNbOF0gPj4+IDUpO1xyXG4gICAgICBiMTIgPSAoc1sxOF0gPDwgMjApIHwgKHNbMTldID4+PiAxMik7XHJcbiAgICAgIGIxMyA9IChzWzE5XSA8PCAyMCkgfCAoc1sxOF0gPj4+IDEyKTtcclxuICAgICAgYjQ0ID0gKHNbMjldIDw8IDcpIHwgKHNbMjhdID4+PiAyNSk7XHJcbiAgICAgIGI0NSA9IChzWzI4XSA8PCA3KSB8IChzWzI5XSA+Pj4gMjUpO1xyXG4gICAgICBiMjYgPSAoc1szOF0gPDwgOCkgfCAoc1szOV0gPj4+IDI0KTtcclxuICAgICAgYjI3ID0gKHNbMzldIDw8IDgpIHwgKHNbMzhdID4+PiAyNCk7XHJcbiAgICAgIGI4ID0gKHNbNDhdIDw8IDE0KSB8IChzWzQ5XSA+Pj4gMTgpO1xyXG4gICAgICBiOSA9IChzWzQ5XSA8PCAxNCkgfCAoc1s0OF0gPj4+IDE4KTtcclxuXHJcbiAgICAgIHNbMF0gPSBiMCBeICh+YjIgJiBiNCk7XHJcbiAgICAgIHNbMV0gPSBiMSBeICh+YjMgJiBiNSk7XHJcbiAgICAgIHNbMTBdID0gYjEwIF4gKH5iMTIgJiBiMTQpO1xyXG4gICAgICBzWzExXSA9IGIxMSBeICh+YjEzICYgYjE1KTtcclxuICAgICAgc1syMF0gPSBiMjAgXiAofmIyMiAmIGIyNCk7XHJcbiAgICAgIHNbMjFdID0gYjIxIF4gKH5iMjMgJiBiMjUpO1xyXG4gICAgICBzWzMwXSA9IGIzMCBeICh+YjMyICYgYjM0KTtcclxuICAgICAgc1szMV0gPSBiMzEgXiAofmIzMyAmIGIzNSk7XHJcbiAgICAgIHNbNDBdID0gYjQwIF4gKH5iNDIgJiBiNDQpO1xyXG4gICAgICBzWzQxXSA9IGI0MSBeICh+YjQzICYgYjQ1KTtcclxuICAgICAgc1syXSA9IGIyIF4gKH5iNCAmIGI2KTtcclxuICAgICAgc1szXSA9IGIzIF4gKH5iNSAmIGI3KTtcclxuICAgICAgc1sxMl0gPSBiMTIgXiAofmIxNCAmIGIxNik7XHJcbiAgICAgIHNbMTNdID0gYjEzIF4gKH5iMTUgJiBiMTcpO1xyXG4gICAgICBzWzIyXSA9IGIyMiBeICh+YjI0ICYgYjI2KTtcclxuICAgICAgc1syM10gPSBiMjMgXiAofmIyNSAmIGIyNyk7XHJcbiAgICAgIHNbMzJdID0gYjMyIF4gKH5iMzQgJiBiMzYpO1xyXG4gICAgICBzWzMzXSA9IGIzMyBeICh+YjM1ICYgYjM3KTtcclxuICAgICAgc1s0Ml0gPSBiNDIgXiAofmI0NCAmIGI0Nik7XHJcbiAgICAgIHNbNDNdID0gYjQzIF4gKH5iNDUgJiBiNDcpO1xyXG4gICAgICBzWzRdID0gYjQgXiAofmI2ICYgYjgpO1xyXG4gICAgICBzWzVdID0gYjUgXiAofmI3ICYgYjkpO1xyXG4gICAgICBzWzE0XSA9IGIxNCBeICh+YjE2ICYgYjE4KTtcclxuICAgICAgc1sxNV0gPSBiMTUgXiAofmIxNyAmIGIxOSk7XHJcbiAgICAgIHNbMjRdID0gYjI0IF4gKH5iMjYgJiBiMjgpO1xyXG4gICAgICBzWzI1XSA9IGIyNSBeICh+YjI3ICYgYjI5KTtcclxuICAgICAgc1szNF0gPSBiMzQgXiAofmIzNiAmIGIzOCk7XHJcbiAgICAgIHNbMzVdID0gYjM1IF4gKH5iMzcgJiBiMzkpO1xyXG4gICAgICBzWzQ0XSA9IGI0NCBeICh+YjQ2ICYgYjQ4KTtcclxuICAgICAgc1s0NV0gPSBiNDUgXiAofmI0NyAmIGI0OSk7XHJcbiAgICAgIHNbNl0gPSBiNiBeICh+YjggJiBiMCk7XHJcbiAgICAgIHNbN10gPSBiNyBeICh+YjkgJiBiMSk7XHJcbiAgICAgIHNbMTZdID0gYjE2IF4gKH5iMTggJiBiMTApO1xyXG4gICAgICBzWzE3XSA9IGIxNyBeICh+YjE5ICYgYjExKTtcclxuICAgICAgc1syNl0gPSBiMjYgXiAofmIyOCAmIGIyMCk7XHJcbiAgICAgIHNbMjddID0gYjI3IF4gKH5iMjkgJiBiMjEpO1xyXG4gICAgICBzWzM2XSA9IGIzNiBeICh+YjM4ICYgYjMwKTtcclxuICAgICAgc1szN10gPSBiMzcgXiAofmIzOSAmIGIzMSk7XHJcbiAgICAgIHNbNDZdID0gYjQ2IF4gKH5iNDggJiBiNDApO1xyXG4gICAgICBzWzQ3XSA9IGI0NyBeICh+YjQ5ICYgYjQxKTtcclxuICAgICAgc1s4XSA9IGI4IF4gKH5iMCAmIGIyKTtcclxuICAgICAgc1s5XSA9IGI5IF4gKH5iMSAmIGIzKTtcclxuICAgICAgc1sxOF0gPSBiMTggXiAofmIxMCAmIGIxMik7XHJcbiAgICAgIHNbMTldID0gYjE5IF4gKH5iMTEgJiBiMTMpO1xyXG4gICAgICBzWzI4XSA9IGIyOCBeICh+YjIwICYgYjIyKTtcclxuICAgICAgc1syOV0gPSBiMjkgXiAofmIyMSAmIGIyMyk7XHJcbiAgICAgIHNbMzhdID0gYjM4IF4gKH5iMzAgJiBiMzIpO1xyXG4gICAgICBzWzM5XSA9IGIzOSBeICh+YjMxICYgYjMzKTtcclxuICAgICAgc1s0OF0gPSBiNDggXiAofmI0MCAmIGI0Mik7XHJcbiAgICAgIHNbNDldID0gYjQ5IF4gKH5iNDEgJiBiNDMpO1xyXG5cclxuICAgICAgc1swXSBePSBSQ1tuXTtcclxuICAgICAgc1sxXSBePSBSQ1tuICsgMV07XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgaWYgKENPTU1PTl9KUykge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtZXRob2RzO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZE5hbWVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIHJvb3RbbWV0aG9kTmFtZXNbaV1dID0gbWV0aG9kc1ttZXRob2ROYW1lc1tpXV07XHJcbiAgICB9XHJcbiAgfVxyXG59KSgpO1xyXG4iLCIoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsncHVueWNvZGUnLCAnLi9pZG5hLW1hcCddLCBmdW5jdGlvbihwdW55Y29kZSwgaWRuYV9tYXApIHtcbiAgICAgIHJldHVybiBmYWN0b3J5KHB1bnljb2RlLCBpZG5hX21hcCk7XG4gICAgfSk7XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ3B1bnljb2RlJyksIHJlcXVpcmUoJy4vaWRuYS1tYXAnKSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcm9vdC51dHM0NiA9IGZhY3Rvcnkocm9vdC5wdW55Y29kZSwgcm9vdC5pZG5hX21hcCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24ocHVueWNvZGUsIGlkbmFfbWFwKSB7XG5cbiAgZnVuY3Rpb24gbWFwTGFiZWwobGFiZWwsIHVzZVN0ZDNBU0NJSSwgdHJhbnNpdGlvbmFsKSB7XG4gICAgdmFyIG1hcHBlZCA9IFtdO1xuICAgIHZhciBjaGFycyA9IHB1bnljb2RlLnVjczIuZGVjb2RlKGxhYmVsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY3AgPSBjaGFyc1tpXTtcbiAgICAgIHZhciBjaCA9IHB1bnljb2RlLnVjczIuZW5jb2RlKFtjaGFyc1tpXV0pO1xuICAgICAgdmFyIGNvbXBvc2l0ZSA9IGlkbmFfbWFwLm1hcENoYXIoY3ApO1xuICAgICAgdmFyIGZsYWdzID0gKGNvbXBvc2l0ZSA+PiAyMyk7XG4gICAgICB2YXIga2luZCA9IChjb21wb3NpdGUgPj4gMjEpICYgMztcbiAgICAgIHZhciBpbmRleCA9IChjb21wb3NpdGUgPj4gNSkgJiAweGZmZmY7XG4gICAgICB2YXIgbGVuZ3RoID0gY29tcG9zaXRlICYgMHgxZjtcbiAgICAgIHZhciB2YWx1ZSA9IGlkbmFfbWFwLm1hcFN0ci5zdWJzdHIoaW5kZXgsIGxlbmd0aCk7XG4gICAgICBpZiAoa2luZCA9PT0gMCB8fCAodXNlU3RkM0FTQ0lJICYmIChmbGFncyAmIDEpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGNoYXIgXCIgKyBjaCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChraW5kID09PSAxKSB7XG4gICAgICAgIG1hcHBlZC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGtpbmQgPT09IDIpIHtcbiAgICAgICAgbWFwcGVkLnB1c2godHJhbnNpdGlvbmFsID8gdmFsdWUgOiBjaCk7XG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgZWxzZSBpZiAoa2luZCA9PT0gMykge1xuICAgICAgICBtYXBwZWQucHVzaChjaCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5ld0xhYmVsID0gbWFwcGVkLmpvaW4oXCJcIikubm9ybWFsaXplKFwiTkZDXCIpO1xuICAgIHJldHVybiBuZXdMYWJlbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3MoZG9tYWluLCB0cmFuc2l0aW9uYWwsIHVzZVN0ZDNBU0NJSSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh1c2VTdGQzQVNDSUkgPT09IHVuZGVmaW5lZClcbiAgICAgIHVzZVN0ZDNBU0NJSSA9IGZhbHNlO1xuICAgIHZhciBtYXBwZWRJRE5BID0gbWFwTGFiZWwoZG9tYWluLCB1c2VTdGQzQVNDSUksIHRyYW5zaXRpb25hbCk7XG5cbiAgICAvLyBTdGVwIDMuIEJyZWFrXG4gICAgdmFyIGxhYmVscyA9IG1hcHBlZElETkEuc3BsaXQoXCIuXCIpO1xuXG4gICAgLy8gU3RlcCA0LiBDb252ZXJ0L1ZhbGlkYXRlXG4gICAgbGFiZWxzID0gbGFiZWxzLm1hcChmdW5jdGlvbihsYWJlbCkge1xuICAgICAgaWYgKGxhYmVsLnN0YXJ0c1dpdGgoXCJ4bi0tXCIpKSB7XG4gICAgICAgIGxhYmVsID0gcHVueWNvZGUuZGVjb2RlKGxhYmVsLnN1YnN0cmluZyg0KSk7XG4gICAgICAgIHZhbGlkYXRlTGFiZWwobGFiZWwsIHVzZVN0ZDNBU0NJSSwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhbGlkYXRlTGFiZWwobGFiZWwsIHVzZVN0ZDNBU0NJSSwgdHJhbnNpdGlvbmFsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYWJlbDtcbiAgICB9KTtcblxuICAgIHJldHVybiBsYWJlbHMuam9pbihcIi5cIik7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZUxhYmVsKGxhYmVsLCB1c2VTdGQzQVNDSUksIHRyYW5zaXRpb25hbCkge1xuICAgIC8vIDIuIFRoZSBsYWJlbCBtdXN0IG5vdCBjb250YWluIGEgVSswMDJEIEhZUEhFTi1NSU5VUyBjaGFyYWN0ZXIgaW4gYm90aCB0aGVcbiAgICAvLyB0aGlyZCBwb3NpdGlvbiBhbmQgZm91cnRoIHBvc2l0aW9ucy5cbiAgICBpZiAobGFiZWxbMl0gPT09ICctJyAmJiBsYWJlbFszXSA9PT0gJy0nKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHZhbGlkYXRlIFwiICsgbGFiZWwpO1xuXG4gICAgLy8gMy4gVGhlIGxhYmVsIG11c3QgbmVpdGhlciBiZWdpbiBub3IgZW5kIHdpdGggYSBVKzAwMkQgSFlQSEVOLU1JTlVTXG4gICAgLy8gY2hhcmFjdGVyLlxuICAgIGlmIChsYWJlbC5zdGFydHNXaXRoKCctJykgfHwgbGFiZWwuZW5kc1dpdGgoJy0nKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byB2YWxpZGF0ZSBcIiArIGxhYmVsKTtcblxuICAgIC8vIDQuIFRoZSBsYWJlbCBtdXN0IG5vdCBjb250YWluIGEgVSswMDJFICggLiApIEZVTEwgU1RPUC5cbiAgICAvLyB0aGlzIHNob3VsZCBuZXJ2ZXIgaGFwcGVuIGFzIGxhYmVsIGlzIGNodW5rZWQgaW50ZXJuYWxseSBieSB0aGlzIGNoYXJhY3RlclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChsYWJlbC5pbmNsdWRlcygnLicpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHZhbGlkYXRlIFwiICsgbGFiZWwpO1xuXG4gICAgaWYgKG1hcExhYmVsKGxhYmVsLCB1c2VTdGQzQVNDSUksIHRyYW5zaXRpb25hbCkgIT09IGxhYmVsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHZhbGlkYXRlIFwiICsgbGFiZWwpO1xuXG4gICAgLy8gNS4gVGhlIGxhYmVsIG11c3Qgbm90IGJlZ2luIHdpdGggYSBjb21iaW5pbmcgbWFyaywgdGhhdCBpczpcbiAgICAvLyBHZW5lcmFsX0NhdGVnb3J5PU1hcmsuXG4gICAgdmFyIGNoID0gbGFiZWwuY29kZVBvaW50QXQoMCk7XG4gICAgaWYgKGlkbmFfbWFwLm1hcENoYXIoY2gpICYgKDB4MiA8PCAyMykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMYWJlbCBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlcjogXCIgKyBjaCk7XG4gIH1cblxuICBmdW5jdGlvbiB0b0FzY2lpKGRvbWFpbiwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpXG4gICAgICBvcHRpb25zID0ge307XG4gICAgdmFyIHRyYW5zaXRpb25hbCA9ICd0cmFuc2l0aW9uYWwnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRyYW5zaXRpb25hbCA6IHRydWU7XG4gICAgdmFyIHVzZVN0ZDNBU0NJSSA9ICd1c2VTdGQzQVNDSUknIGluIG9wdGlvbnMgPyBvcHRpb25zLnVzZVN0ZDNBU0NJSSA6IGZhbHNlO1xuICAgIHZhciB2ZXJpZnlEbnNMZW5ndGggPSAndmVyaWZ5RG5zTGVuZ3RoJyBpbiBvcHRpb25zID8gb3B0aW9ucy52ZXJpZnlEbnNMZW5ndGggOiBmYWxzZTtcbiAgICB2YXIgbGFiZWxzID0gcHJvY2Vzcyhkb21haW4sIHRyYW5zaXRpb25hbCwgdXNlU3RkM0FTQ0lJKS5zcGxpdCgnLicpO1xuICAgIHZhciBhc2NpaUxhYmVscyA9IGxhYmVscy5tYXAocHVueWNvZGUudG9BU0NJSSk7XG4gICAgdmFyIGFzY2lpU3RyaW5nID0gYXNjaWlMYWJlbHMuam9pbignLicpO1xuICAgIHZhciBpO1xuICAgIGlmICh2ZXJpZnlEbnNMZW5ndGgpIHtcbiAgICAgIGlmIChhc2NpaVN0cmluZy5sZW5ndGggPCAxIHx8IGFzY2lpU3RyaW5nLmxlbmd0aCA+IDI1Mykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJETlMgbmFtZSBoYXMgd3JvbmcgbGVuZ3RoOiBcIiArIGFzY2lpU3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhc2NpaUxhYmVscy5sZW5ndGg7IGkrKykgey8vZm9yIC4uIG9mIHJlcGxhY2VtZW50XG4gICAgICAgIHZhciBsYWJlbCA9IGFzY2lpTGFiZWxzW2ldO1xuICAgICAgICBpZiAobGFiZWwubGVuZ3RoIDwgMSB8fCBsYWJlbC5sZW5ndGggPiA2MylcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJETlMgbGFiZWwgaGFzIHdyb25nIGxlbmd0aDogXCIgKyBsYWJlbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhc2NpaVN0cmluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvVW5pY29kZShkb21haW4sIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKVxuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIHZhciB1c2VTdGQzQVNDSUkgPSAndXNlU3RkM0FTQ0lJJyBpbiBvcHRpb25zID8gb3B0aW9ucy51c2VTdGQzQVNDSUkgOiBmYWxzZTtcbiAgICByZXR1cm4gcHJvY2Vzcyhkb21haW4sIGZhbHNlLCB1c2VTdGQzQVNDSUkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b1VuaWNvZGU6IHRvVW5pY29kZSxcbiAgICB0b0FzY2lpOiB0b0FzY2lpLFxuICB9O1xufSkpO1xuIiwiZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKC4uLmFyZ3VtZW50cylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZXh0ZW5kcztcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJleHBvcnQgKiBmcm9tICcuL2NvbmZpcm0tdHJhbnNhY3Rpb24nO1xuZXhwb3J0ICogZnJvbSAnLi9jdXN0b20tZ2FzJztcbmV4cG9ydCAqIGZyb20gJy4vZmlyc3QtdGltZS1mbG93JztcbmV4cG9ydCAqIGZyb20gJy4vbWV0YW1ldHJpY3MnO1xuZXhwb3J0ICogZnJvbSAnLi9wZXJtaXNzaW9ucyc7XG5leHBvcnQgKiBmcm9tICcuL3NlbGVjdG9ycyc7XG5leHBvcnQgKiBmcm9tICcuL3RyYW5zYWN0aW9ucyc7XG4iLCJ2YXIgZm9ybWF0dGVyID0gcmVxdWlyZSgnLi9pbmRleCcpXG5cbi8qKlxuICogVGhpcyBtb2R1bGUgZXhpc3RzIHB1cmVseSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcmVhc29ucy4gSGlzdG9yaWNhbGx5LCB0aGUgY3VycmVuY2llc1xuICogd291bGQgYmUgc3RvcmVkIGluIGFuIGFycmF5IGF2YWlsYWJsZSB0aHJvdWdoIHRoZSBkZWZhdWx0IGV4cG9ydCBmcm9tIHRoaXMgZXhhY3QgZmlsZS5cbiAqIFdlJ3ZlIG9wdGVkIHRvIHN0b3JlIGN1cnJlbmNpZXMgaW4gYSBKU09OIG9iamVjdCBub3cgKGN1cnJlbmNpZXMuanNvbikuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZm9ybWF0dGVyLmN1cnJlbmNpZXMiLCJ2YXIgYWNjb3VudGluZyA9IHJlcXVpcmUoJ2FjY291bnRpbmcnKVxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKVxudmFyIGxvY2FsZUN1cnJlbmN5ID0gcmVxdWlyZSgnbG9jYWxlLWN1cnJlbmN5JylcbnZhciBjdXJyZW5jaWVzID0gcmVxdWlyZSgnLi9jdXJyZW5jaWVzLmpzb24nKVxudmFyIGxvY2FsZUZvcm1hdHMgPSByZXF1aXJlKCcuL2xvY2FsZUZvcm1hdHMuanNvbicpXG5cbnZhciBkZWZhdWx0Q3VycmVuY3kgPSB7XG4gIHN5bWJvbDogJycsXG4gIHRob3VzYW5kc1NlcGFyYXRvcjogJywnLFxuICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXG4gIHN5bWJvbE9uTGVmdDogdHJ1ZSxcbiAgc3BhY2VCZXR3ZWVuQW1vdW50QW5kU3ltYm9sOiBmYWxzZSxcbiAgZGVjaW1hbERpZ2l0czogMlxufVxuXG52YXIgZGVmYXVsdExvY2FsZUZvcm1hdCA9IHt9XG5cbnZhciBmb3JtYXRNYXBwaW5nID0gW1xuICB7XG4gICAgc3ltYm9sT25MZWZ0OiB0cnVlLFxuICAgIHNwYWNlQmV0d2VlbkFtb3VudEFuZFN5bWJvbDogZmFsc2UsXG4gICAgZm9ybWF0OiB7XG4gICAgICBwb3M6ICclcyV2JyxcbiAgICAgIG5lZzogJy0lcyV2JyxcbiAgICAgIHplcm86ICclcyV2J1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHN5bWJvbE9uTGVmdDogdHJ1ZSxcbiAgICBzcGFjZUJldHdlZW5BbW91bnRBbmRTeW1ib2w6IHRydWUsXG4gICAgZm9ybWF0OiB7XG4gICAgICBwb3M6ICclc8KgJXYnLFxuICAgICAgbmVnOiAnLSVzwqAldicsXG4gICAgICB6ZXJvOiAnJXPCoCV2J1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHN5bWJvbE9uTGVmdDogZmFsc2UsXG4gICAgc3BhY2VCZXR3ZWVuQW1vdW50QW5kU3ltYm9sOiBmYWxzZSxcbiAgICBmb3JtYXQ6IHtcbiAgICAgIHBvczogJyV2JXMnLFxuICAgICAgbmVnOiAnLSV2JXMnLFxuICAgICAgemVybzogJyV2JXMnXG4gICAgfVxuICB9LFxuICB7XG4gICAgc3ltYm9sT25MZWZ0OiBmYWxzZSxcbiAgICBzcGFjZUJldHdlZW5BbW91bnRBbmRTeW1ib2w6IHRydWUsXG4gICAgZm9ybWF0OiB7XG4gICAgICBwb3M6ICcldsKgJXMnLFxuICAgICAgbmVnOiAnLSV2wqAlcycsXG4gICAgICB6ZXJvOiAnJXbCoCVzJ1xuICAgIH1cbiAgfVxuXVxuXG5mdW5jdGlvbiBmb3JtYXQodmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIGNvZGUgPSBvcHRpb25zLmNvZGUgfHwgKG9wdGlvbnMubG9jYWxlICYmIGxvY2FsZUN1cnJlbmN5LmdldEN1cnJlbmN5KG9wdGlvbnMubG9jYWxlKSlcbiAgdmFyIGxvY2FsZU1hdGNoID0gL14oW2Etel0rKShbXy1dKFthLXpdKykpPyQvaS5leGVjKG9wdGlvbnMubG9jYWxlKSB8fCBbXVxuICB2YXIgbGFuZ3VhZ2UgPSBsb2NhbGVNYXRjaFsxXVxuICB2YXIgcmVnaW9uID0gbG9jYWxlTWF0Y2hbM11cbiAgdmFyIGxvY2FsZUZvcm1hdCA9IGFzc2lnbih7fSwgZGVmYXVsdExvY2FsZUZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGb3JtYXRzW2xhbmd1YWdlXSB8fCB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGb3JtYXRzW2xhbmd1YWdlICsgJy0nICsgcmVnaW9uXSB8fCB7fSlcbiAgdmFyIGN1cnJlbmN5ID0gYXNzaWduKHt9LCBkZWZhdWx0Q3VycmVuY3ksIGZpbmRDdXJyZW5jeShjb2RlKSwgbG9jYWxlRm9ybWF0KVxuICBcbiAgdmFyIHN5bWJvbE9uTGVmdCA9IGN1cnJlbmN5LnN5bWJvbE9uTGVmdFxuICB2YXIgc3BhY2VCZXR3ZWVuQW1vdW50QW5kU3ltYm9sID0gY3VycmVuY3kuc3BhY2VCZXR3ZWVuQW1vdW50QW5kU3ltYm9sXG5cbiAgdmFyIGZvcm1hdCA9IGZvcm1hdE1hcHBpbmcuZmlsdGVyKGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gZi5zeW1ib2xPbkxlZnQgPT0gc3ltYm9sT25MZWZ0ICYmIGYuc3BhY2VCZXR3ZWVuQW1vdW50QW5kU3ltYm9sID09IHNwYWNlQmV0d2VlbkFtb3VudEFuZFN5bWJvbFxuICB9KVswXS5mb3JtYXRcblxuICByZXR1cm4gYWNjb3VudGluZy5mb3JtYXRNb25leSh2YWx1ZSwge1xuICAgIHN5bWJvbDogaXNVbmRlZmluZWQob3B0aW9ucy5zeW1ib2wpXG4gICAgICAgICAgICAgID8gY3VycmVuY3kuc3ltYm9sXG4gICAgICAgICAgICAgIDogb3B0aW9ucy5zeW1ib2wsXG5cbiAgICBkZWNpbWFsOiBpc1VuZGVmaW5lZChvcHRpb25zLmRlY2ltYWwpXG4gICAgICAgICAgICAgID8gY3VycmVuY3kuZGVjaW1hbFNlcGFyYXRvclxuICAgICAgICAgICAgICA6IG9wdGlvbnMuZGVjaW1hbCxcblxuICAgIHRob3VzYW5kOiBpc1VuZGVmaW5lZChvcHRpb25zLnRob3VzYW5kKVxuICAgICAgICAgICAgICA/IGN1cnJlbmN5LnRob3VzYW5kc1NlcGFyYXRvclxuICAgICAgICAgICAgICA6IG9wdGlvbnMudGhvdXNhbmQsXG5cbiAgICBwcmVjaXNpb246IHR5cGVvZiBvcHRpb25zLnByZWNpc2lvbiA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgPyBvcHRpb25zLnByZWNpc2lvblxuICAgICAgICAgICAgICA6IGN1cnJlbmN5LmRlY2ltYWxEaWdpdHMsXG5cbiAgICBmb3JtYXQ6IFsnc3RyaW5nJywgJ29iamVjdCddLmluZGV4T2YodHlwZW9mIG9wdGlvbnMuZm9ybWF0KSA+IC0xXG4gICAgICAgICAgICAgID8gb3B0aW9ucy5mb3JtYXRcbiAgICAgICAgICAgICAgOiBmb3JtYXRcbiAgfSlcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbmN5IChjdXJyZW5jeUNvZGUpIHtcbiAgcmV0dXJuIGN1cnJlbmNpZXNbY3VycmVuY3lDb2RlXVxufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCAodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJ1xufVxuXG5mdW5jdGlvbiB1bmZvcm1hdCh2YWx1ZSwgb3B0aW9ucykge1xuICB2YXIgY29kZSA9IG9wdGlvbnMuY29kZSB8fCAob3B0aW9ucy5sb2NhbGUgJiYgbG9jYWxlQ3VycmVuY3kuZ2V0Q3VycmVuY3kob3B0aW9ucy5sb2NhbGUpKVxuICB2YXIgbG9jYWxlRm9ybWF0ID0gbG9jYWxlRm9ybWF0c1tvcHRpb25zLmxvY2FsZV0gfHwgZGVmYXVsdExvY2FsZUZvcm1hdFxuICB2YXIgY3VycmVuY3kgPSBhc3NpZ24oe30sIGRlZmF1bHRDdXJyZW5jeSwgZmluZEN1cnJlbmN5KGNvZGUpLCBsb2NhbGVGb3JtYXQpXG4gIHZhciBkZWNpbWFsID0gaXNVbmRlZmluZWQob3B0aW9ucy5kZWNpbWFsKSA/IGN1cnJlbmN5LmRlY2ltYWxTZXBhcmF0b3IgOiBvcHRpb25zLmRlY2ltYWxcbiAgcmV0dXJuIGFjY291bnRpbmcudW5mb3JtYXQodmFsdWUsIGRlY2ltYWwpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZWZhdWx0Q3VycmVuY3k6IGRlZmF1bHRDdXJyZW5jeSxcbiAgZ2V0IGN1cnJlbmNpZXMoKSB7XG4gICAgLy8gSW4gZmF2b3Igb2YgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHRoZSBjdXJyZW5jaWVzIG1hcCBpcyBjb252ZXJ0ZWQgdG8gYW4gYXJyYXkgaGVyZVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhjdXJyZW5jaWVzKS5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gY3VycmVuY2llc1trZXldXG4gICAgfSlcbiAgfSxcbiAgZmluZEN1cnJlbmN5OiBmaW5kQ3VycmVuY3ksXG4gIGZvcm1hdDogZm9ybWF0LFxuICB1bmZvcm1hdDogdW5mb3JtYXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZVNjYWZmb2xkTWlkZGxld2FyZSAoaGFuZGxlcnMpIHtcbiAgcmV0dXJuIChyZXEsIHJlcywgbmV4dCwgZW5kKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3JlcS5tZXRob2RdXG4gICAgLy8gaWYgbm8gaGFuZGxlciwgcmV0dXJuXG4gICAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5leHQoKVxuICAgIH1cbiAgICAvLyBpZiBoYW5kbGVyIGlzIGZuLCBjYWxsIGFzIG1pZGRsZXdhcmVcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBoYW5kbGVyKHJlcSwgcmVzLCBuZXh0LCBlbmQpXG4gICAgfVxuICAgIC8vIGlmIGhhbmRsZXIgaXMgc29tZSBvdGhlciB2YWx1ZSwgdXNlIGFzIHJlc3VsdFxuICAgIHJlcy5yZXN1bHQgPSBoYW5kbGVyXG4gICAgcmV0dXJuIGVuZCgpXG4gIH1cbn1cbiIsImNvbnN0IFNhZmVFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdzYWZlLWV2ZW50LWVtaXR0ZXInKVxuXG5jbGFzcyBCYXNlRmlsdGVyIGV4dGVuZHMgU2FmZUV2ZW50RW1pdHRlciB7XG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLnVwZGF0ZXMgPSBbXVxuICB9XG5cbiAgYXN5bmMgaW5pdGlhbGl6ZSAoKSB7fVxuXG4gIGFzeW5jIHVwZGF0ZSAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCYXNlRmlsdGVyIC0gbm8gdXBkYXRlIG1ldGhvZCBzcGVjaWZpZWQnKVxuICB9XG5cbiAgYWRkUmVzdWx0cyAobmV3UmVzdWx0cykge1xuICAgIHRoaXMudXBkYXRlcyA9IHRoaXMudXBkYXRlcy5jb25jYXQobmV3UmVzdWx0cylcbiAgICBuZXdSZXN1bHRzLmZvckVhY2gocmVzdWx0ID0+IHRoaXMuZW1pdCgndXBkYXRlJywgcmVzdWx0KSlcbiAgfVxuXG4gIGFkZEluaXRpYWxSZXN1bHRzIChuZXdSZXN1bHRzKSB7fVxuXG4gIGdldENoYW5nZXNBbmRDbGVhciAoKSB7XG4gICAgY29uc3QgdXBkYXRlcyA9IHRoaXMudXBkYXRlc1xuICAgIHRoaXMudXBkYXRlcyA9IFtdXG4gICAgcmV0dXJuIHVwZGF0ZXNcbiAgfVxuICBcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlRmlsdGVyXG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHByb2Nlc3NGbiA9IChmbiwgb3B0cykgPT4gZnVuY3Rpb24gKCkge1xuXHRjb25zdCBQID0gb3B0cy5wcm9taXNlTW9kdWxlO1xuXHRjb25zdCBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0YXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcblx0fVxuXG5cdHJldHVybiBuZXcgUCgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0aWYgKG9wdHMuZXJyb3JGaXJzdCkge1xuXHRcdFx0YXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuXHRcdFx0XHRpZiAob3B0cy5tdWx0aUFyZ3MpIHtcblx0XHRcdFx0XHRjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzLnVuc2hpZnQoZXJyKTtcblx0XHRcdFx0XHRcdHJlamVjdChyZXN1bHRzKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHRzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoZXJyKSB7XG5cdFx0XHRcdFx0cmVqZWN0KGVycik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YXJncy5wdXNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0XHRcdFx0aWYgKG9wdHMubXVsdGlBcmdzKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0cmVzdWx0c1tpXSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdHMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Zm4uYXBwbHkodGhpcywgYXJncyk7XG5cdH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAob2JqLCBvcHRzKSA9PiB7XG5cdG9wdHMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRleGNsdWRlOiBbLy4rKFN5bmN8U3RyZWFtKSQvXSxcblx0XHRlcnJvckZpcnN0OiB0cnVlLFxuXHRcdHByb21pc2VNb2R1bGU6IFByb21pc2Vcblx0fSwgb3B0cyk7XG5cblx0Y29uc3QgZmlsdGVyID0ga2V5ID0+IHtcblx0XHRjb25zdCBtYXRjaCA9IHBhdHRlcm4gPT4gdHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnID8ga2V5ID09PSBwYXR0ZXJuIDogcGF0dGVybi50ZXN0KGtleSk7XG5cdFx0cmV0dXJuIG9wdHMuaW5jbHVkZSA/IG9wdHMuaW5jbHVkZS5zb21lKG1hdGNoKSA6ICFvcHRzLmV4Y2x1ZGUuc29tZShtYXRjaCk7XG5cdH07XG5cblx0bGV0IHJldDtcblx0aWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAob3B0cy5leGNsdWRlTWFpbikge1xuXHRcdFx0XHRyZXR1cm4gb2JqLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwcm9jZXNzRm4ob2JqLCBvcHRzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSk7XG5cdH1cblxuXHRmb3IgKGNvbnN0IGtleSBpbiBvYmopIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBndWFyZC1mb3ItaW5cblx0XHRjb25zdCB4ID0gb2JqW2tleV07XG5cdFx0cmV0W2tleV0gPSB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyAmJiBmaWx0ZXIoa2V5KSA/IHByb2Nlc3NGbih4LCBvcHRzKSA6IHg7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcbiIsImNvbnN0IEJhc2VGaWx0ZXIgPSByZXF1aXJlKCcuL2Jhc2UtZmlsdGVyJylcblxuLy8gdHJhY2tzIGFsbCByZXN1bHRzIGV2ZXIgcmVjb3JkZWRcbmNsYXNzIEJhc2VGaWx0ZXJXaXRoSGlzdG9yeSBleHRlbmRzIEJhc2VGaWx0ZXIge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5hbGxSZXN1bHRzID0gW11cbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZSAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCYXNlRmlsdGVyV2l0aEhpc3RvcnkgLSBubyB1cGRhdGUgbWV0aG9kIHNwZWNpZmllZCcpXG4gIH1cblxuICBhZGRSZXN1bHRzIChuZXdSZXN1bHRzKSB7XG4gICAgdGhpcy5hbGxSZXN1bHRzID0gdGhpcy5hbGxSZXN1bHRzLmNvbmNhdChuZXdSZXN1bHRzKVxuICAgIHN1cGVyLmFkZFJlc3VsdHMobmV3UmVzdWx0cylcbiAgfVxuXG4gIGFkZEluaXRpYWxSZXN1bHRzIChuZXdSZXN1bHRzKSB7XG4gICAgdGhpcy5hbGxSZXN1bHRzID0gdGhpcy5hbGxSZXN1bHRzLmNvbmNhdChuZXdSZXN1bHRzKVxuICAgIHN1cGVyLmFkZEluaXRpYWxSZXN1bHRzKG5ld1Jlc3VsdHMpXG4gIH1cblxuICBnZXRBbGxSZXN1bHRzICgpIHtcbiAgICByZXR1cm4gdGhpcy5hbGxSZXN1bHRzXG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VGaWx0ZXJXaXRoSGlzdG9yeSIsIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjb21wYXJpc29uIHN0eWxlcy4gKi9cbnZhciBVTk9SREVSRURfQ09NUEFSRV9GTEFHID0gMSxcbiAgICBQQVJUSUFMX0NPTVBBUkVfRkxBRyA9IDI7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC8sXG4gICAgcmVMZWFkaW5nRG90ID0gL15cXC4vLFxuICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0IGluIElFIDwgOS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSG9zdE9iamVjdCh2YWx1ZSkge1xuICAvLyBNYW55IGhvc3Qgb2JqZWN0cyBhcmUgYE9iamVjdGAgb2JqZWN0cyB0aGF0IGNhbiBjb2VyY2UgdG8gc3RyaW5nc1xuICAvLyBkZXNwaXRlIGhhdmluZyBpbXByb3Blcmx5IGRlZmluZWQgYHRvU3RyaW5nYCBtZXRob2RzLlxuICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9ICEhKHZhbHVlICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sLFxuICAgIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXksXG4gICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZSxcbiAgICBzcHJlYWRhYmxlU3ltYm9sID0gU3ltYm9sID8gU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3JyksXG4gICAgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyksXG4gICAgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKSxcbiAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyksXG4gICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICByZXR1cm4gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLnNldChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA/IHZhbHVlcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fWydkZWxldGUnXShrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGNhY2hlID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGNhY2hlIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gY2FjaGUuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNhY2hlID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgY2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICAvLyBTYWZhcmkgOC4xIG1ha2VzIGBhcmd1bWVudHMuY2FsbGVlYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICAvLyBTYWZhcmkgOSBtYWtlcyBgYXJndW1lbnRzLmxlbmd0aGAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgdmFyIHJlc3VsdCA9IChpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpXG4gICAgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpXG4gICAgOiBbXTtcblxuICB2YXIgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aCxcbiAgICAgIHNraXBJbmRleGVzID0gISFsZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoa2V5ID09ICdsZW5ndGgnIHx8IGlzSW5kZXgoa2V5LCBsZW5ndGgpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKi9cbnZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gaXNLZXkocGF0aCwgb2JqZWN0KSA/IFtwYXRoXSA6IGNhc3RQYXRoKHBhdGgpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2JpdG1hc2tdIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuXG4gKiAgVGhlIGJpdG1hc2sgbWF5IGJlIGNvbXBvc2VkIG9mIHRoZSBmb2xsb3dpbmcgZmxhZ3M6XG4gKiAgICAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgICAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3QodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiYXNlSXNFcXVhbCwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IFtiaXRtYXNrXSBUaGUgYml0bWFzayBvZiBjb21wYXJpc29uIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYFxuICogIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IGFycmF5VGFnLFxuICAgICAgb3RoVGFnID0gYXJyYXlUYWc7XG5cbiAgaWYgKCFvYmpJc0Fycikge1xuICAgIG9ialRhZyA9IGdldFRhZyhvYmplY3QpO1xuICAgIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICB9XG4gIGlmICghb3RoSXNBcnIpIHtcbiAgICBvdGhUYWcgPSBnZXRUYWcob3RoZXIpO1xuICAgIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuICB9XG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcgJiYgIWlzSG9zdE9iamVjdChvYmplY3QpLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnICYmICFpc0hvc3RPYmplY3Qob3RoZXIpLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBQQVJUSUFMX0NPTVBBUkVfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBjdXN0b21pemVyLCBVTk9SREVSRURfQ09NUEFSRV9GTEFHIHwgUEFSVElBTF9DT01QQVJFX0ZMQUcsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKV07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIHVuZGVmaW5lZCwgVU5PUkRFUkVEX0NPTVBBUkVfRkxBRyB8IFBBUlRJQUxfQ09NUEFSRV9GTEFHKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IHN0cmluZ1RvUGF0aCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgXG4gKiAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIFBBUlRJQUxfQ09NUEFSRV9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBVTk9SREVSRURfQ09NUEFSRV9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIXNlZW4uaGFzKG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5hZGQob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBjb21wYXJpc29uIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYFxuICogIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgUEFSVElBTF9DT01QQVJFX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBVTk9SREVSRURfQ09NUEFSRV9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgXG4gKiAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBQQVJUSUFMX0NPTVBBUkVfRkxBRyxcbiAgICAgIG9ialByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBrZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEsXG4vLyBmb3IgZGF0YSB2aWV3cyBpbiBFZGdlIDwgMTQsIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzLlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBpc0tleShwYXRoLCBvYmplY3QpID8gW3BhdGhdIDogY2FzdFBhdGgocGF0aCk7XG5cbiAgdmFyIHJlc3VsdCxcbiAgICAgIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IG9iamVjdCA/IG9iamVjdC5sZW5ndGggOiAwO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgJiZcbiAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemUoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAocmVMZWFkaW5nRG90LnRlc3Qoc3RyaW5nKSkge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmbGF0dGVuZWQgYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYFxuICogdGhydSBgaXRlcmF0ZWVgIGFuZCBmbGF0dGVuaW5nIHRoZSBtYXBwZWQgcmVzdWx0cy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XVxuICogIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gKiAgIHJldHVybiBbbiwgbl07XG4gKiB9XG4gKlxuICogXy5mbGF0TWFwKFsxLCAyXSwgZHVwbGljYXRlKTtcbiAqIC8vID0+IFsxLCAxLCAyLCAyXVxuICovXG5mdW5jdGlvbiBmbGF0TWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCAxKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydVxuICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gKiBgXy5ldmVyeWAsIGBfLmZpbHRlcmAsIGBfLm1hcGAsIGBfLm1hcFZhbHVlc2AsIGBfLnJlamVjdGAsIGFuZCBgXy5zb21lYC5cbiAqXG4gKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAqIGBhcnlgLCBgY2h1bmtgLCBgY3VycnlgLCBgY3VycnlSaWdodGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBldmVyeWAsXG4gKiBgZmlsbGAsIGBpbnZlcnRgLCBgcGFyc2VJbnRgLCBgcmFuZG9tYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVwZWF0YCxcbiAqIGBzYW1wbGVTaXplYCwgYHNsaWNlYCwgYHNvbWVgLCBgc29ydEJ5YCwgYHNwbGl0YCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAqIGB0ZW1wbGF0ZWAsIGB0cmltYCwgYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYW5kIGB3b3Jkc2BcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gKiAgIHJldHVybiBuICogbjtcbiAqIH1cbiAqXG4gKiBfLm1hcChbNCwgOF0sIHNxdWFyZSk7XG4gKiAvLyA9PiBbMTYsIDY0XVxuICpcbiAqIF8ubWFwKHsgJ2EnOiA0LCAnYic6IDggfSwgc3F1YXJlKTtcbiAqIC8vID0+IFsxNiwgNjRdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gKiBdO1xuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5tYXAodXNlcnMsICd1c2VyJyk7XG4gKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAqL1xuZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5TWFwIDogYmFzZU1hcDtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gQXNzaWduIGNhY2hlIHRvIGBfLm1lbW9pemVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAoIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKSB8fCBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOC05IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdE1hcDtcbiIsIi8qIVxuICogd2ViMy5qcyAtIEV0aGVyZXVtIEphdmFTY3JpcHQgQVBJXG4gKlxuICogQGxpY2Vuc2UgbGdwbC0zLjBcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dlYjMuanNcbiovXG5cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuICogXG4gKiB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAqIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4gKiBcbiAqIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gKiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqIFxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4gKlxuICogQGZpbGUgd2ViMy5qc1xuICogQGF1dGhvcnM6XG4gKiAgIEplZmZyZXkgV2lsY2tlIDxqZWZmQGV0aGRldi5jb20+XG4gKiAgIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogICBNYXJpYW4gT2FuY2VhIDxtYXJpYW5AZXRoZGV2LmNvbT5cbiAqICAgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGRldi5jb20+XG4gKiAgIEdhdiBXb29kIDxnQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE0XG4gKi9cblxudmFyIFJlcXVlc3RNYW5hZ2VyID0gcmVxdWlyZSgnLi93ZWIzL3JlcXVlc3RtYW5hZ2VyJyk7XG52YXIgSWJhbiA9IHJlcXVpcmUoJy4vd2ViMy9pYmFuJyk7XG52YXIgRXRoID0gcmVxdWlyZSgnLi93ZWIzL21ldGhvZHMvZXRoJyk7XG52YXIgREIgPSByZXF1aXJlKCcuL3dlYjMvbWV0aG9kcy9kYicpO1xudmFyIFNoaCA9IHJlcXVpcmUoJy4vd2ViMy9tZXRob2RzL3NoaCcpO1xudmFyIE5ldCA9IHJlcXVpcmUoJy4vd2ViMy9tZXRob2RzL25ldCcpO1xudmFyIFBlcnNvbmFsID0gcmVxdWlyZSgnLi93ZWIzL21ldGhvZHMvcGVyc29uYWwnKTtcbnZhciBTd2FybSA9IHJlcXVpcmUoJy4vd2ViMy9tZXRob2RzL3N3YXJtJyk7XG52YXIgU2V0dGluZ3MgPSByZXF1aXJlKCcuL3dlYjMvc2V0dGluZ3MnKTtcbnZhciB2ZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uLmpzb24nKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXRpbHMnKTtcbnZhciBzaGEzID0gcmVxdWlyZSgnLi91dGlscy9zaGEzJyk7XG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnLi93ZWIzL2V4dGVuZCcpO1xudmFyIEJhdGNoID0gcmVxdWlyZSgnLi93ZWIzL2JhdGNoJyk7XG52YXIgUHJvcGVydHkgPSByZXF1aXJlKCcuL3dlYjMvcHJvcGVydHknKTtcbnZhciBIdHRwUHJvdmlkZXIgPSByZXF1aXJlKCcuL3dlYjMvaHR0cHByb3ZpZGVyJyk7XG52YXIgSXBjUHJvdmlkZXIgPSByZXF1aXJlKCcuL3dlYjMvaXBjcHJvdmlkZXInKTtcbnZhciBCaWdOdW1iZXIgPSByZXF1aXJlKCdiaWdudW1iZXIuanMnKTtcblxuXG5cbmZ1bmN0aW9uIFdlYjMgKHByb3ZpZGVyKSB7XG4gICAgdGhpcy5fcmVxdWVzdE1hbmFnZXIgPSBuZXcgUmVxdWVzdE1hbmFnZXIocHJvdmlkZXIpO1xuICAgIHRoaXMuY3VycmVudFByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgdGhpcy5ldGggPSBuZXcgRXRoKHRoaXMpO1xuICAgIHRoaXMuZGIgPSBuZXcgREIodGhpcyk7XG4gICAgdGhpcy5zaGggPSBuZXcgU2hoKHRoaXMpO1xuICAgIHRoaXMubmV0ID0gbmV3IE5ldCh0aGlzKTtcbiAgICB0aGlzLnBlcnNvbmFsID0gbmV3IFBlcnNvbmFsKHRoaXMpO1xuICAgIHRoaXMuYnp6ID0gbmV3IFN3YXJtKHRoaXMpO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3MoKTtcbiAgICB0aGlzLnZlcnNpb24gPSB7XG4gICAgICAgIGFwaTogdmVyc2lvbi52ZXJzaW9uXG4gICAgfTtcbiAgICB0aGlzLnByb3ZpZGVycyA9IHtcbiAgICAgICAgSHR0cFByb3ZpZGVyOiBIdHRwUHJvdmlkZXIsXG4gICAgICAgIElwY1Byb3ZpZGVyOiBJcGNQcm92aWRlclxuICAgIH07XG4gICAgdGhpcy5fZXh0ZW5kID0gZXh0ZW5kKHRoaXMpO1xuICAgIHRoaXMuX2V4dGVuZCh7XG4gICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXMoKVxuICAgIH0pO1xufVxuXG4vLyBleHBvc2UgcHJvdmlkZXJzIG9uIHRoZSBjbGFzc1xuV2ViMy5wcm92aWRlcnMgPSB7XG4gICAgSHR0cFByb3ZpZGVyOiBIdHRwUHJvdmlkZXIsXG4gICAgSXBjUHJvdmlkZXI6IElwY1Byb3ZpZGVyXG59O1xuXG5XZWIzLnByb3RvdHlwZS5zZXRQcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgIHRoaXMuX3JlcXVlc3RNYW5hZ2VyLnNldFByb3ZpZGVyKHByb3ZpZGVyKTtcbiAgICB0aGlzLmN1cnJlbnRQcm92aWRlciA9IHByb3ZpZGVyO1xufTtcblxuV2ViMy5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoa2VlcElzU3luY2luZykge1xuICAgIHRoaXMuX3JlcXVlc3RNYW5hZ2VyLnJlc2V0KGtlZXBJc1N5bmNpbmcpO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3MoKTtcbn07XG5cbldlYjMucHJvdG90eXBlLkJpZ051bWJlciA9IEJpZ051bWJlcjtcbldlYjMucHJvdG90eXBlLnRvSGV4ID0gdXRpbHMudG9IZXg7XG5XZWIzLnByb3RvdHlwZS50b0FzY2lpID0gdXRpbHMudG9Bc2NpaTtcbldlYjMucHJvdG90eXBlLnRvVXRmOCA9IHV0aWxzLnRvVXRmODtcbldlYjMucHJvdG90eXBlLmZyb21Bc2NpaSA9IHV0aWxzLmZyb21Bc2NpaTtcbldlYjMucHJvdG90eXBlLmZyb21VdGY4ID0gdXRpbHMuZnJvbVV0Zjg7XG5XZWIzLnByb3RvdHlwZS50b0RlY2ltYWwgPSB1dGlscy50b0RlY2ltYWw7XG5XZWIzLnByb3RvdHlwZS5mcm9tRGVjaW1hbCA9IHV0aWxzLmZyb21EZWNpbWFsO1xuV2ViMy5wcm90b3R5cGUudG9CaWdOdW1iZXIgPSB1dGlscy50b0JpZ051bWJlcjtcbldlYjMucHJvdG90eXBlLnRvV2VpID0gdXRpbHMudG9XZWk7XG5XZWIzLnByb3RvdHlwZS5mcm9tV2VpID0gdXRpbHMuZnJvbVdlaTtcbldlYjMucHJvdG90eXBlLmlzQWRkcmVzcyA9IHV0aWxzLmlzQWRkcmVzcztcbldlYjMucHJvdG90eXBlLmlzQ2hlY2tzdW1BZGRyZXNzID0gdXRpbHMuaXNDaGVja3N1bUFkZHJlc3M7XG5XZWIzLnByb3RvdHlwZS50b0NoZWNrc3VtQWRkcmVzcyA9IHV0aWxzLnRvQ2hlY2tzdW1BZGRyZXNzO1xuV2ViMy5wcm90b3R5cGUuaXNJQkFOID0gdXRpbHMuaXNJQkFOO1xuV2ViMy5wcm90b3R5cGUucGFkTGVmdCA9IHV0aWxzLnBhZExlZnQ7XG5XZWIzLnByb3RvdHlwZS5wYWRSaWdodCA9IHV0aWxzLnBhZFJpZ2h0O1xuXG5cbldlYjMucHJvdG90eXBlLnNoYTMgPSBmdW5jdGlvbihzdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gJzB4JyArIHNoYTMoc3RyaW5nLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyBkaXJlY3QgaWNhcCB0byBhZGRyZXNzXG4gKi9cbldlYjMucHJvdG90eXBlLmZyb21JQ0FQID0gZnVuY3Rpb24gKGljYXApIHtcbiAgICB2YXIgaWJhbiA9IG5ldyBJYmFuKGljYXApO1xuICAgIHJldHVybiBpYmFuLmFkZHJlc3MoKTtcbn07XG5cbnZhciBwcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAndmVyc2lvbi5ub2RlJyxcbiAgICAgICAgICAgIGdldHRlcjogJ3dlYjNfY2xpZW50VmVyc2lvbidcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAndmVyc2lvbi5uZXR3b3JrJyxcbiAgICAgICAgICAgIGdldHRlcjogJ25ldF92ZXJzaW9uJyxcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiB1dGlscy50b0RlY2ltYWxcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAndmVyc2lvbi5ldGhlcmV1bScsXG4gICAgICAgICAgICBnZXR0ZXI6ICdldGhfcHJvdG9jb2xWZXJzaW9uJyxcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiB1dGlscy50b0RlY2ltYWxcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAndmVyc2lvbi53aGlzcGVyJyxcbiAgICAgICAgICAgIGdldHRlcjogJ3NoaF92ZXJzaW9uJyxcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiB1dGlscy50b0RlY2ltYWxcbiAgICAgICAgfSlcbiAgICBdO1xufTtcblxuV2ViMy5wcm90b3R5cGUuaXNDb25uZWN0ZWQgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50UHJvdmlkZXIgJiYgdGhpcy5jdXJyZW50UHJvdmlkZXIuaXNDb25uZWN0ZWQoKSk7XG59O1xuXG5XZWIzLnByb3RvdHlwZS5jcmVhdGVCYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IEJhdGNoKHRoaXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWIzO1xuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2luZGV4LmpzJylcbiIsIi8vIFdyaXR0ZW4gaW4gMjAxNC0yMDE2IGJ5IERtaXRyeSBDaGVzdG55a2ggYW5kIERldmkgTWFuZGlyaS5cbi8vIFB1YmxpYyBkb21haW4uXG4oZnVuY3Rpb24ocm9vdCwgZikge1xuICAndXNlIHN0cmljdCc7XG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHMgPSBmKCk7XG4gIGVsc2UgaWYgKHJvb3QubmFjbCkgcm9vdC5uYWNsLnV0aWwgPSBmKCk7XG4gIGVsc2Uge1xuICAgIHJvb3QubmFjbCA9IHt9O1xuICAgIHJvb3QubmFjbC51dGlsID0gZigpO1xuICB9XG59KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHV0aWwgPSB7fTtcblxuICBmdW5jdGlvbiB2YWxpZGF0ZUJhc2U2NChzKSB7XG4gICAgaWYgKCEoL14oPzpbQS1aYS16MC05K1xcL117Mn1bQS1aYS16MC05K1xcL117Mn0pKig/OltBLVphLXowLTkrXFwvXXsyfT09fFtBLVphLXowLTkrXFwvXXszfT0pPyQvLnRlc3QocykpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGVuY29kaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgdXRpbC5kZWNvZGVVVEY4ID0gZnVuY3Rpb24ocykge1xuICAgIGlmICh0eXBlb2YgcyAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHN0cmluZycpO1xuICAgIHZhciBpLCBkID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHMpKSwgYiA9IG5ldyBVaW50OEFycmF5KGQubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZC5sZW5ndGg7IGkrKykgYltpXSA9IGQuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYjtcbiAgfTtcblxuICB1dGlsLmVuY29kZVVURjggPSBmdW5jdGlvbihhcnIpIHtcbiAgICB2YXIgaSwgcyA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGFycltpXSkpO1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHMuam9pbignJykpKTtcbiAgfTtcblxuICBpZiAodHlwZW9mIGF0b2IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gTm9kZS5qc1xuXG4gICAgaWYgKHR5cGVvZiBCdWZmZXIuZnJvbSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAvLyBOb2RlIHY2IGFuZCBsYXRlclxuICAgICAgdXRpbC5lbmNvZGVCYXNlNjQgPSBmdW5jdGlvbiAoYXJyKSB7IC8vIHY2IGFuZCBsYXRlclxuICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShhcnIpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgIH07XG5cbiAgICAgIHV0aWwuZGVjb2RlQmFzZTY0ID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdmFsaWRhdGVCYXNlNjQocyk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChCdWZmZXIuZnJvbShzLCAnYmFzZTY0JyksIDApKTtcbiAgICAgIH07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm9kZSBlYXJsaWVyIHRoYW4gdjZcbiAgICAgIHV0aWwuZW5jb2RlQmFzZTY0ID0gZnVuY3Rpb24gKGFycikgeyAvLyB2NiBhbmQgbGF0ZXJcbiAgICAgICAgcmV0dXJuIChuZXcgQnVmZmVyKGFycikpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgIH07XG5cbiAgICAgIHV0aWwuZGVjb2RlQmFzZTY0ID0gZnVuY3Rpb24ocykge1xuICAgICAgICB2YWxpZGF0ZUJhc2U2NChzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG5ldyBCdWZmZXIocywgJ2Jhc2U2NCcpLCAwKSk7XG4gICAgICB9O1xuICAgIH1cblxuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXJzXG5cbiAgICB1dGlsLmVuY29kZUJhc2U2NCA9IGZ1bmN0aW9uKGFycikge1xuICAgICAgdmFyIGksIHMgPSBbXSwgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykgcy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyW2ldKSk7XG4gICAgICByZXR1cm4gYnRvYShzLmpvaW4oJycpKTtcbiAgICB9O1xuXG4gICAgdXRpbC5kZWNvZGVCYXNlNjQgPSBmdW5jdGlvbihzKSB7XG4gICAgICB2YWxpZGF0ZUJhc2U2NChzKTtcbiAgICAgIHZhciBpLCBkID0gYXRvYihzKSwgYiA9IG5ldyBVaW50OEFycmF5KGQubGVuZ3RoKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBkLmxlbmd0aDsgaSsrKSBiW2ldID0gZC5jaGFyQ29kZUF0KGkpO1xuICAgICAgcmV0dXJuIGI7XG4gICAgfTtcblxuICB9XG5cbiAgcmV0dXJuIHV0aWw7XG5cbn0pKTtcbiIsIihmdW5jdGlvbihuYWNsKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFBvcnRlZCBpbiAyMDE0IGJ5IERtaXRyeSBDaGVzdG55a2ggYW5kIERldmkgTWFuZGlyaS5cbi8vIFB1YmxpYyBkb21haW4uXG4vL1xuLy8gSW1wbGVtZW50YXRpb24gZGVyaXZlZCBmcm9tIFR3ZWV0TmFDbCB2ZXJzaW9uIDIwMTQwNDI3LlxuLy8gU2VlIGZvciBkZXRhaWxzOiBodHRwOi8vdHdlZXRuYWNsLmNyLnlwLnRvL1xuXG52YXIgZ2YgPSBmdW5jdGlvbihpbml0KSB7XG4gIHZhciBpLCByID0gbmV3IEZsb2F0NjRBcnJheSgxNik7XG4gIGlmIChpbml0KSBmb3IgKGkgPSAwOyBpIDwgaW5pdC5sZW5ndGg7IGkrKykgcltpXSA9IGluaXRbaV07XG4gIHJldHVybiByO1xufTtcblxuLy8gIFBsdWdnYWJsZSwgaW5pdGlhbGl6ZWQgaW4gaGlnaC1sZXZlbCBBUEkgYmVsb3cuXG52YXIgcmFuZG9tYnl0ZXMgPSBmdW5jdGlvbigvKiB4LCBuICovKSB7IHRocm93IG5ldyBFcnJvcignbm8gUFJORycpOyB9O1xuXG52YXIgXzAgPSBuZXcgVWludDhBcnJheSgxNik7XG52YXIgXzkgPSBuZXcgVWludDhBcnJheSgzMik7IF85WzBdID0gOTtcblxudmFyIGdmMCA9IGdmKCksXG4gICAgZ2YxID0gZ2YoWzFdKSxcbiAgICBfMTIxNjY1ID0gZ2YoWzB4ZGI0MSwgMV0pLFxuICAgIEQgPSBnZihbMHg3OGEzLCAweDEzNTksIDB4NGRjYSwgMHg3NWViLCAweGQ4YWIsIDB4NDE0MSwgMHgwYTRkLCAweDAwNzAsIDB4ZTg5OCwgMHg3Nzc5LCAweDQwNzksIDB4OGNjNywgMHhmZTczLCAweDJiNmYsIDB4NmNlZSwgMHg1MjAzXSksXG4gICAgRDIgPSBnZihbMHhmMTU5LCAweDI2YjIsIDB4OWI5NCwgMHhlYmQ2LCAweGIxNTYsIDB4ODI4MywgMHgxNDlhLCAweDAwZTAsIDB4ZDEzMCwgMHhlZWYzLCAweDgwZjIsIDB4MTk4ZSwgMHhmY2U3LCAweDU2ZGYsIDB4ZDlkYywgMHgyNDA2XSksXG4gICAgWCA9IGdmKFsweGQ1MWEsIDB4OGYyNSwgMHgyZDYwLCAweGM5NTYsIDB4YTdiMiwgMHg5NTI1LCAweGM3NjAsIDB4NjkyYywgMHhkYzVjLCAweGZkZDYsIDB4ZTIzMSwgMHhjMGE0LCAweDUzZmUsIDB4Y2Q2ZSwgMHgzNmQzLCAweDIxNjldKSxcbiAgICBZID0gZ2YoWzB4NjY1OCwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2Nl0pLFxuICAgIEkgPSBnZihbMHhhMGIwLCAweDRhMGUsIDB4MWIyNywgMHhjNGVlLCAweGU0NzgsIDB4YWQyZiwgMHgxODA2LCAweDJmNDMsIDB4ZDdhNywgMHgzZGZiLCAweDAwOTksIDB4MmI0ZCwgMHhkZjBiLCAweDRmYzEsIDB4MjQ4MCwgMHgyYjgzXSk7XG5cbmZ1bmN0aW9uIHRzNjQoeCwgaSwgaCwgbCkge1xuICB4W2ldICAgPSAoaCA+PiAyNCkgJiAweGZmO1xuICB4W2krMV0gPSAoaCA+PiAxNikgJiAweGZmO1xuICB4W2krMl0gPSAoaCA+PiAgOCkgJiAweGZmO1xuICB4W2krM10gPSBoICYgMHhmZjtcbiAgeFtpKzRdID0gKGwgPj4gMjQpICAmIDB4ZmY7XG4gIHhbaSs1XSA9IChsID4+IDE2KSAgJiAweGZmO1xuICB4W2krNl0gPSAobCA+PiAgOCkgICYgMHhmZjtcbiAgeFtpKzddID0gbCAmIDB4ZmY7XG59XG5cbmZ1bmN0aW9uIHZuKHgsIHhpLCB5LCB5aSwgbikge1xuICB2YXIgaSxkID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgZCB8PSB4W3hpK2ldXnlbeWkraV07XG4gIHJldHVybiAoMSAmICgoZCAtIDEpID4+PiA4KSkgLSAxO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fdmVyaWZ5XzE2KHgsIHhpLCB5LCB5aSkge1xuICByZXR1cm4gdm4oeCx4aSx5LHlpLDE2KTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3ZlcmlmeV8zMih4LCB4aSwgeSwgeWkpIHtcbiAgcmV0dXJuIHZuKHgseGkseSx5aSwzMik7XG59XG5cbmZ1bmN0aW9uIGNvcmVfc2Fsc2EyMChvLCBwLCBrLCBjKSB7XG4gIHZhciBqMCAgPSBjWyAwXSAmIDB4ZmYgfCAoY1sgMV0gJiAweGZmKTw8OCB8IChjWyAyXSAmIDB4ZmYpPDwxNiB8IChjWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxICA9IGtbIDBdICYgMHhmZiB8IChrWyAxXSAmIDB4ZmYpPDw4IHwgKGtbIDJdICYgMHhmZik8PDE2IHwgKGtbIDNdICYgMHhmZik8PDI0LFxuICAgICAgajIgID0ga1sgNF0gJiAweGZmIHwgKGtbIDVdICYgMHhmZik8PDggfCAoa1sgNl0gJiAweGZmKTw8MTYgfCAoa1sgN10gJiAweGZmKTw8MjQsXG4gICAgICBqMyAgPSBrWyA4XSAmIDB4ZmYgfCAoa1sgOV0gJiAweGZmKTw8OCB8IChrWzEwXSAmIDB4ZmYpPDwxNiB8IChrWzExXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo0ICA9IGtbMTJdICYgMHhmZiB8IChrWzEzXSAmIDB4ZmYpPDw4IHwgKGtbMTRdICYgMHhmZik8PDE2IHwgKGtbMTVdICYgMHhmZik8PDI0LFxuICAgICAgajUgID0gY1sgNF0gJiAweGZmIHwgKGNbIDVdICYgMHhmZik8PDggfCAoY1sgNl0gJiAweGZmKTw8MTYgfCAoY1sgN10gJiAweGZmKTw8MjQsXG4gICAgICBqNiAgPSBwWyAwXSAmIDB4ZmYgfCAocFsgMV0gJiAweGZmKTw8OCB8IChwWyAyXSAmIDB4ZmYpPDwxNiB8IChwWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo3ICA9IHBbIDRdICYgMHhmZiB8IChwWyA1XSAmIDB4ZmYpPDw4IHwgKHBbIDZdICYgMHhmZik8PDE2IHwgKHBbIDddICYgMHhmZik8PDI0LFxuICAgICAgajggID0gcFsgOF0gJiAweGZmIHwgKHBbIDldICYgMHhmZik8PDggfCAocFsxMF0gJiAweGZmKTw8MTYgfCAocFsxMV0gJiAweGZmKTw8MjQsXG4gICAgICBqOSAgPSBwWzEyXSAmIDB4ZmYgfCAocFsxM10gJiAweGZmKTw8OCB8IChwWzE0XSAmIDB4ZmYpPDwxNiB8IChwWzE1XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMCA9IGNbIDhdICYgMHhmZiB8IChjWyA5XSAmIDB4ZmYpPDw4IHwgKGNbMTBdICYgMHhmZik8PDE2IHwgKGNbMTFdICYgMHhmZik8PDI0LFxuICAgICAgajExID0ga1sxNl0gJiAweGZmIHwgKGtbMTddICYgMHhmZik8PDggfCAoa1sxOF0gJiAweGZmKTw8MTYgfCAoa1sxOV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTIgPSBrWzIwXSAmIDB4ZmYgfCAoa1syMV0gJiAweGZmKTw8OCB8IChrWzIyXSAmIDB4ZmYpPDwxNiB8IChrWzIzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMyA9IGtbMjRdICYgMHhmZiB8IChrWzI1XSAmIDB4ZmYpPDw4IHwgKGtbMjZdICYgMHhmZik8PDE2IHwgKGtbMjddICYgMHhmZik8PDI0LFxuICAgICAgajE0ID0ga1syOF0gJiAweGZmIHwgKGtbMjldICYgMHhmZik8PDggfCAoa1szMF0gJiAweGZmKTw8MTYgfCAoa1szMV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTUgPSBjWzEyXSAmIDB4ZmYgfCAoY1sxM10gJiAweGZmKTw8OCB8IChjWzE0XSAmIDB4ZmYpPDwxNiB8IChjWzE1XSAmIDB4ZmYpPDwyNDtcblxuICB2YXIgeDAgPSBqMCwgeDEgPSBqMSwgeDIgPSBqMiwgeDMgPSBqMywgeDQgPSBqNCwgeDUgPSBqNSwgeDYgPSBqNiwgeDcgPSBqNyxcbiAgICAgIHg4ID0gajgsIHg5ID0gajksIHgxMCA9IGoxMCwgeDExID0gajExLCB4MTIgPSBqMTIsIHgxMyA9IGoxMywgeDE0ID0gajE0LFxuICAgICAgeDE1ID0gajE1LCB1O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjA7IGkgKz0gMikge1xuICAgIHUgPSB4MCArIHgxMiB8IDA7XG4gICAgeDQgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg0ICsgeDAgfCAwO1xuICAgIHg4IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4OCArIHg0IHwgMDtcbiAgICB4MTIgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDEyICsgeDggfCAwO1xuICAgIHgwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDUgKyB4MSB8IDA7XG4gICAgeDkgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg5ICsgeDUgfCAwO1xuICAgIHgxMyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDEzICsgeDkgfCAwO1xuICAgIHgxIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxICsgeDEzIHwgMDtcbiAgICB4NSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxMCArIHg2IHwgMDtcbiAgICB4MTQgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxNCArIHgxMCB8IDA7XG4gICAgeDIgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgyICsgeDE0IHwgMDtcbiAgICB4NiBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4NiArIHgyIHwgMDtcbiAgICB4MTAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTUgKyB4MTEgfCAwO1xuICAgIHgzIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MyArIHgxNSB8IDA7XG4gICAgeDcgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg3ICsgeDMgfCAwO1xuICAgIHgxMSBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTEgKyB4NyB8IDA7XG4gICAgeDE1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDAgKyB4MyB8IDA7XG4gICAgeDEgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxICsgeDAgfCAwO1xuICAgIHgyIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MiArIHgxIHwgMDtcbiAgICB4MyBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MyArIHgyIHwgMDtcbiAgICB4MCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHg1ICsgeDQgfCAwO1xuICAgIHg2IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4NiArIHg1IHwgMDtcbiAgICB4NyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDcgKyB4NiB8IDA7XG4gICAgeDQgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDQgKyB4NyB8IDA7XG4gICAgeDUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTAgKyB4OSB8IDA7XG4gICAgeDExIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTEgKyB4MTAgfCAwO1xuICAgIHg4IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4OCArIHgxMSB8IDA7XG4gICAgeDkgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDkgKyB4OCB8IDA7XG4gICAgeDEwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDE1ICsgeDE0IHwgMDtcbiAgICB4MTIgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxMiArIHgxNSB8IDA7XG4gICAgeDEzIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MTMgKyB4MTIgfCAwO1xuICAgIHgxNCBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTQgKyB4MTMgfCAwO1xuICAgIHgxNSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuICB9XG4gICB4MCA9ICB4MCArICBqMCB8IDA7XG4gICB4MSA9ICB4MSArICBqMSB8IDA7XG4gICB4MiA9ICB4MiArICBqMiB8IDA7XG4gICB4MyA9ICB4MyArICBqMyB8IDA7XG4gICB4NCA9ICB4NCArICBqNCB8IDA7XG4gICB4NSA9ICB4NSArICBqNSB8IDA7XG4gICB4NiA9ICB4NiArICBqNiB8IDA7XG4gICB4NyA9ICB4NyArICBqNyB8IDA7XG4gICB4OCA9ICB4OCArICBqOCB8IDA7XG4gICB4OSA9ICB4OSArICBqOSB8IDA7XG4gIHgxMCA9IHgxMCArIGoxMCB8IDA7XG4gIHgxMSA9IHgxMSArIGoxMSB8IDA7XG4gIHgxMiA9IHgxMiArIGoxMiB8IDA7XG4gIHgxMyA9IHgxMyArIGoxMyB8IDA7XG4gIHgxNCA9IHgxNCArIGoxNCB8IDA7XG4gIHgxNSA9IHgxNSArIGoxNSB8IDA7XG5cbiAgb1sgMF0gPSB4MCA+Pj4gIDAgJiAweGZmO1xuICBvWyAxXSA9IHgwID4+PiAgOCAmIDB4ZmY7XG4gIG9bIDJdID0geDAgPj4+IDE2ICYgMHhmZjtcbiAgb1sgM10gPSB4MCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bIDRdID0geDEgPj4+ICAwICYgMHhmZjtcbiAgb1sgNV0gPSB4MSA+Pj4gIDggJiAweGZmO1xuICBvWyA2XSA9IHgxID4+PiAxNiAmIDB4ZmY7XG4gIG9bIDddID0geDEgPj4+IDI0ICYgMHhmZjtcblxuICBvWyA4XSA9IHgyID4+PiAgMCAmIDB4ZmY7XG4gIG9bIDldID0geDIgPj4+ICA4ICYgMHhmZjtcbiAgb1sxMF0gPSB4MiA+Pj4gMTYgJiAweGZmO1xuICBvWzExXSA9IHgyID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sxMl0gPSB4MyA+Pj4gIDAgJiAweGZmO1xuICBvWzEzXSA9IHgzID4+PiAgOCAmIDB4ZmY7XG4gIG9bMTRdID0geDMgPj4+IDE2ICYgMHhmZjtcbiAgb1sxNV0gPSB4MyA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMTZdID0geDQgPj4+ICAwICYgMHhmZjtcbiAgb1sxN10gPSB4NCA+Pj4gIDggJiAweGZmO1xuICBvWzE4XSA9IHg0ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMTldID0geDQgPj4+IDI0ICYgMHhmZjtcblxuICBvWzIwXSA9IHg1ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMjFdID0geDUgPj4+ICA4ICYgMHhmZjtcbiAgb1syMl0gPSB4NSA+Pj4gMTYgJiAweGZmO1xuICBvWzIzXSA9IHg1ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1syNF0gPSB4NiA+Pj4gIDAgJiAweGZmO1xuICBvWzI1XSA9IHg2ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMjZdID0geDYgPj4+IDE2ICYgMHhmZjtcbiAgb1syN10gPSB4NiA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMjhdID0geDcgPj4+ICAwICYgMHhmZjtcbiAgb1syOV0gPSB4NyA+Pj4gIDggJiAweGZmO1xuICBvWzMwXSA9IHg3ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMzFdID0geDcgPj4+IDI0ICYgMHhmZjtcblxuICBvWzMyXSA9IHg4ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMzNdID0geDggPj4+ICA4ICYgMHhmZjtcbiAgb1szNF0gPSB4OCA+Pj4gMTYgJiAweGZmO1xuICBvWzM1XSA9IHg4ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1szNl0gPSB4OSA+Pj4gIDAgJiAweGZmO1xuICBvWzM3XSA9IHg5ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMzhdID0geDkgPj4+IDE2ICYgMHhmZjtcbiAgb1szOV0gPSB4OSA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bNDBdID0geDEwID4+PiAgMCAmIDB4ZmY7XG4gIG9bNDFdID0geDEwID4+PiAgOCAmIDB4ZmY7XG4gIG9bNDJdID0geDEwID4+PiAxNiAmIDB4ZmY7XG4gIG9bNDNdID0geDEwID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1s0NF0gPSB4MTEgPj4+ICAwICYgMHhmZjtcbiAgb1s0NV0gPSB4MTEgPj4+ICA4ICYgMHhmZjtcbiAgb1s0Nl0gPSB4MTEgPj4+IDE2ICYgMHhmZjtcbiAgb1s0N10gPSB4MTEgPj4+IDI0ICYgMHhmZjtcblxuICBvWzQ4XSA9IHgxMiA+Pj4gIDAgJiAweGZmO1xuICBvWzQ5XSA9IHgxMiA+Pj4gIDggJiAweGZmO1xuICBvWzUwXSA9IHgxMiA+Pj4gMTYgJiAweGZmO1xuICBvWzUxXSA9IHgxMiA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bNTJdID0geDEzID4+PiAgMCAmIDB4ZmY7XG4gIG9bNTNdID0geDEzID4+PiAgOCAmIDB4ZmY7XG4gIG9bNTRdID0geDEzID4+PiAxNiAmIDB4ZmY7XG4gIG9bNTVdID0geDEzID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1s1Nl0gPSB4MTQgPj4+ICAwICYgMHhmZjtcbiAgb1s1N10gPSB4MTQgPj4+ICA4ICYgMHhmZjtcbiAgb1s1OF0gPSB4MTQgPj4+IDE2ICYgMHhmZjtcbiAgb1s1OV0gPSB4MTQgPj4+IDI0ICYgMHhmZjtcblxuICBvWzYwXSA9IHgxNSA+Pj4gIDAgJiAweGZmO1xuICBvWzYxXSA9IHgxNSA+Pj4gIDggJiAweGZmO1xuICBvWzYyXSA9IHgxNSA+Pj4gMTYgJiAweGZmO1xuICBvWzYzXSA9IHgxNSA+Pj4gMjQgJiAweGZmO1xufVxuXG5mdW5jdGlvbiBjb3JlX2hzYWxzYTIwKG8scCxrLGMpIHtcbiAgdmFyIGowICA9IGNbIDBdICYgMHhmZiB8IChjWyAxXSAmIDB4ZmYpPDw4IHwgKGNbIDJdICYgMHhmZik8PDE2IHwgKGNbIDNdICYgMHhmZik8PDI0LFxuICAgICAgajEgID0ga1sgMF0gJiAweGZmIHwgKGtbIDFdICYgMHhmZik8PDggfCAoa1sgMl0gJiAweGZmKTw8MTYgfCAoa1sgM10gJiAweGZmKTw8MjQsXG4gICAgICBqMiAgPSBrWyA0XSAmIDB4ZmYgfCAoa1sgNV0gJiAweGZmKTw8OCB8IChrWyA2XSAmIDB4ZmYpPDwxNiB8IChrWyA3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGozICA9IGtbIDhdICYgMHhmZiB8IChrWyA5XSAmIDB4ZmYpPDw4IHwgKGtbMTBdICYgMHhmZik8PDE2IHwgKGtbMTFdICYgMHhmZik8PDI0LFxuICAgICAgajQgID0ga1sxMl0gJiAweGZmIHwgKGtbMTNdICYgMHhmZik8PDggfCAoa1sxNF0gJiAweGZmKTw8MTYgfCAoa1sxNV0gJiAweGZmKTw8MjQsXG4gICAgICBqNSAgPSBjWyA0XSAmIDB4ZmYgfCAoY1sgNV0gJiAweGZmKTw8OCB8IChjWyA2XSAmIDB4ZmYpPDwxNiB8IChjWyA3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo2ICA9IHBbIDBdICYgMHhmZiB8IChwWyAxXSAmIDB4ZmYpPDw4IHwgKHBbIDJdICYgMHhmZik8PDE2IHwgKHBbIDNdICYgMHhmZik8PDI0LFxuICAgICAgajcgID0gcFsgNF0gJiAweGZmIHwgKHBbIDVdICYgMHhmZik8PDggfCAocFsgNl0gJiAweGZmKTw8MTYgfCAocFsgN10gJiAweGZmKTw8MjQsXG4gICAgICBqOCAgPSBwWyA4XSAmIDB4ZmYgfCAocFsgOV0gJiAweGZmKTw8OCB8IChwWzEwXSAmIDB4ZmYpPDwxNiB8IChwWzExXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo5ICA9IHBbMTJdICYgMHhmZiB8IChwWzEzXSAmIDB4ZmYpPDw4IHwgKHBbMTRdICYgMHhmZik8PDE2IHwgKHBbMTVdICYgMHhmZik8PDI0LFxuICAgICAgajEwID0gY1sgOF0gJiAweGZmIHwgKGNbIDldICYgMHhmZik8PDggfCAoY1sxMF0gJiAweGZmKTw8MTYgfCAoY1sxMV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTEgPSBrWzE2XSAmIDB4ZmYgfCAoa1sxN10gJiAweGZmKTw8OCB8IChrWzE4XSAmIDB4ZmYpPDwxNiB8IChrWzE5XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMiA9IGtbMjBdICYgMHhmZiB8IChrWzIxXSAmIDB4ZmYpPDw4IHwgKGtbMjJdICYgMHhmZik8PDE2IHwgKGtbMjNdICYgMHhmZik8PDI0LFxuICAgICAgajEzID0ga1syNF0gJiAweGZmIHwgKGtbMjVdICYgMHhmZik8PDggfCAoa1syNl0gJiAweGZmKTw8MTYgfCAoa1syN10gJiAweGZmKTw8MjQsXG4gICAgICBqMTQgPSBrWzI4XSAmIDB4ZmYgfCAoa1syOV0gJiAweGZmKTw8OCB8IChrWzMwXSAmIDB4ZmYpPDwxNiB8IChrWzMxXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxNSA9IGNbMTJdICYgMHhmZiB8IChjWzEzXSAmIDB4ZmYpPDw4IHwgKGNbMTRdICYgMHhmZik8PDE2IHwgKGNbMTVdICYgMHhmZik8PDI0O1xuXG4gIHZhciB4MCA9IGowLCB4MSA9IGoxLCB4MiA9IGoyLCB4MyA9IGozLCB4NCA9IGo0LCB4NSA9IGo1LCB4NiA9IGo2LCB4NyA9IGo3LFxuICAgICAgeDggPSBqOCwgeDkgPSBqOSwgeDEwID0gajEwLCB4MTEgPSBqMTEsIHgxMiA9IGoxMiwgeDEzID0gajEzLCB4MTQgPSBqMTQsXG4gICAgICB4MTUgPSBqMTUsIHU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyMDsgaSArPSAyKSB7XG4gICAgdSA9IHgwICsgeDEyIHwgMDtcbiAgICB4NCBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDQgKyB4MCB8IDA7XG4gICAgeDggXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg4ICsgeDQgfCAwO1xuICAgIHgxMiBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTIgKyB4OCB8IDA7XG4gICAgeDAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4NSArIHgxIHwgMDtcbiAgICB4OSBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDkgKyB4NSB8IDA7XG4gICAgeDEzIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MTMgKyB4OSB8IDA7XG4gICAgeDEgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDEgKyB4MTMgfCAwO1xuICAgIHg1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDEwICsgeDYgfCAwO1xuICAgIHgxNCBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDE0ICsgeDEwIHwgMDtcbiAgICB4MiBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDIgKyB4MTQgfCAwO1xuICAgIHg2IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHg2ICsgeDIgfCAwO1xuICAgIHgxMCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxNSArIHgxMSB8IDA7XG4gICAgeDMgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgzICsgeDE1IHwgMDtcbiAgICB4NyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDcgKyB4MyB8IDA7XG4gICAgeDExIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxMSArIHg3IHwgMDtcbiAgICB4MTUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MCArIHgzIHwgMDtcbiAgICB4MSBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDEgKyB4MCB8IDA7XG4gICAgeDIgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgyICsgeDEgfCAwO1xuICAgIHgzIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgzICsgeDIgfCAwO1xuICAgIHgwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDUgKyB4NCB8IDA7XG4gICAgeDYgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg2ICsgeDUgfCAwO1xuICAgIHg3IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4NyArIHg2IHwgMDtcbiAgICB4NCBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4NCArIHg3IHwgMDtcbiAgICB4NSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxMCArIHg5IHwgMDtcbiAgICB4MTEgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxMSArIHgxMCB8IDA7XG4gICAgeDggXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg4ICsgeDExIHwgMDtcbiAgICB4OSBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4OSArIHg4IHwgMDtcbiAgICB4MTAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTUgKyB4MTQgfCAwO1xuICAgIHgxMiBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDEyICsgeDE1IHwgMDtcbiAgICB4MTMgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgxMyArIHgxMiB8IDA7XG4gICAgeDE0IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxNCArIHgxMyB8IDA7XG4gICAgeDE1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG4gIH1cblxuICBvWyAwXSA9IHgwID4+PiAgMCAmIDB4ZmY7XG4gIG9bIDFdID0geDAgPj4+ICA4ICYgMHhmZjtcbiAgb1sgMl0gPSB4MCA+Pj4gMTYgJiAweGZmO1xuICBvWyAzXSA9IHgwID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sgNF0gPSB4NSA+Pj4gIDAgJiAweGZmO1xuICBvWyA1XSA9IHg1ID4+PiAgOCAmIDB4ZmY7XG4gIG9bIDZdID0geDUgPj4+IDE2ICYgMHhmZjtcbiAgb1sgN10gPSB4NSA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bIDhdID0geDEwID4+PiAgMCAmIDB4ZmY7XG4gIG9bIDldID0geDEwID4+PiAgOCAmIDB4ZmY7XG4gIG9bMTBdID0geDEwID4+PiAxNiAmIDB4ZmY7XG4gIG9bMTFdID0geDEwID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sxMl0gPSB4MTUgPj4+ICAwICYgMHhmZjtcbiAgb1sxM10gPSB4MTUgPj4+ICA4ICYgMHhmZjtcbiAgb1sxNF0gPSB4MTUgPj4+IDE2ICYgMHhmZjtcbiAgb1sxNV0gPSB4MTUgPj4+IDI0ICYgMHhmZjtcblxuICBvWzE2XSA9IHg2ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMTddID0geDYgPj4+ICA4ICYgMHhmZjtcbiAgb1sxOF0gPSB4NiA+Pj4gMTYgJiAweGZmO1xuICBvWzE5XSA9IHg2ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1syMF0gPSB4NyA+Pj4gIDAgJiAweGZmO1xuICBvWzIxXSA9IHg3ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMjJdID0geDcgPj4+IDE2ICYgMHhmZjtcbiAgb1syM10gPSB4NyA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMjRdID0geDggPj4+ICAwICYgMHhmZjtcbiAgb1syNV0gPSB4OCA+Pj4gIDggJiAweGZmO1xuICBvWzI2XSA9IHg4ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMjddID0geDggPj4+IDI0ICYgMHhmZjtcblxuICBvWzI4XSA9IHg5ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMjldID0geDkgPj4+ICA4ICYgMHhmZjtcbiAgb1szMF0gPSB4OSA+Pj4gMTYgJiAweGZmO1xuICBvWzMxXSA9IHg5ID4+PiAyNCAmIDB4ZmY7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19jb3JlX3NhbHNhMjAob3V0LGlucCxrLGMpIHtcbiAgY29yZV9zYWxzYTIwKG91dCxpbnAsayxjKTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2NvcmVfaHNhbHNhMjAob3V0LGlucCxrLGMpIHtcbiAgY29yZV9oc2Fsc2EyMChvdXQsaW5wLGssYyk7XG59XG5cbnZhciBzaWdtYSA9IG5ldyBVaW50OEFycmF5KFsxMDEsIDEyMCwgMTEyLCA5NywgMTEwLCAxMDAsIDMyLCA1MSwgNTAsIDQ1LCA5OCwgMTIxLCAxMTYsIDEwMSwgMzIsIDEwN10pO1xuICAgICAgICAgICAgLy8gXCJleHBhbmQgMzItYnl0ZSBrXCJcblxuZnVuY3Rpb24gY3J5cHRvX3N0cmVhbV9zYWxzYTIwX3hvcihjLGNwb3MsbSxtcG9zLGIsbixrKSB7XG4gIHZhciB6ID0gbmV3IFVpbnQ4QXJyYXkoMTYpLCB4ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICB2YXIgdSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHpbaV0gPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgODsgaSsrKSB6W2ldID0gbltpXTtcbiAgd2hpbGUgKGIgPj0gNjQpIHtcbiAgICBjcnlwdG9fY29yZV9zYWxzYTIwKHgseixrLHNpZ21hKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgY1tjcG9zK2ldID0gbVttcG9zK2ldIF4geFtpXTtcbiAgICB1ID0gMTtcbiAgICBmb3IgKGkgPSA4OyBpIDwgMTY7IGkrKykge1xuICAgICAgdSA9IHUgKyAoeltpXSAmIDB4ZmYpIHwgMDtcbiAgICAgIHpbaV0gPSB1ICYgMHhmZjtcbiAgICAgIHUgPj4+PSA4O1xuICAgIH1cbiAgICBiIC09IDY0O1xuICAgIGNwb3MgKz0gNjQ7XG4gICAgbXBvcyArPSA2NDtcbiAgfVxuICBpZiAoYiA+IDApIHtcbiAgICBjcnlwdG9fY29yZV9zYWxzYTIwKHgseixrLHNpZ21hKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYjsgaSsrKSBjW2Nwb3MraV0gPSBtW21wb3MraV0gXiB4W2ldO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc3RyZWFtX3NhbHNhMjAoYyxjcG9zLGIsbixrKSB7XG4gIHZhciB6ID0gbmV3IFVpbnQ4QXJyYXkoMTYpLCB4ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICB2YXIgdSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHpbaV0gPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgODsgaSsrKSB6W2ldID0gbltpXTtcbiAgd2hpbGUgKGIgPj0gNjQpIHtcbiAgICBjcnlwdG9fY29yZV9zYWxzYTIwKHgseixrLHNpZ21hKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgY1tjcG9zK2ldID0geFtpXTtcbiAgICB1ID0gMTtcbiAgICBmb3IgKGkgPSA4OyBpIDwgMTY7IGkrKykge1xuICAgICAgdSA9IHUgKyAoeltpXSAmIDB4ZmYpIHwgMDtcbiAgICAgIHpbaV0gPSB1ICYgMHhmZjtcbiAgICAgIHUgPj4+PSA4O1xuICAgIH1cbiAgICBiIC09IDY0O1xuICAgIGNwb3MgKz0gNjQ7XG4gIH1cbiAgaWYgKGIgPiAwKSB7XG4gICAgY3J5cHRvX2NvcmVfc2Fsc2EyMCh4LHosayxzaWdtYSk7XG4gICAgZm9yIChpID0gMDsgaSA8IGI7IGkrKykgY1tjcG9zK2ldID0geFtpXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3N0cmVhbShjLGNwb3MsZCxuLGspIHtcbiAgdmFyIHMgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGNyeXB0b19jb3JlX2hzYWxzYTIwKHMsbixrLHNpZ21hKTtcbiAgdmFyIHNuID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSBzbltpXSA9IG5baSsxNl07XG4gIHJldHVybiBjcnlwdG9fc3RyZWFtX3NhbHNhMjAoYyxjcG9zLGQsc24scyk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zdHJlYW1feG9yKGMsY3BvcyxtLG1wb3MsZCxuLGspIHtcbiAgdmFyIHMgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGNyeXB0b19jb3JlX2hzYWxzYTIwKHMsbixrLHNpZ21hKTtcbiAgdmFyIHNuID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSBzbltpXSA9IG5baSsxNl07XG4gIHJldHVybiBjcnlwdG9fc3RyZWFtX3NhbHNhMjBfeG9yKGMsY3BvcyxtLG1wb3MsZCxzbixzKTtcbn1cblxuLypcbiogUG9ydCBvZiBBbmRyZXcgTW9vbidzIFBvbHkxMzA1LWRvbm5hLTE2LiBQdWJsaWMgZG9tYWluLlxuKiBodHRwczovL2dpdGh1Yi5jb20vZmxvb2R5YmVycnkvcG9seTEzMDUtZG9ubmFcbiovXG5cbnZhciBwb2x5MTMwNSA9IGZ1bmN0aW9uKGtleSkge1xuICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgdGhpcy5yID0gbmV3IFVpbnQxNkFycmF5KDEwKTtcbiAgdGhpcy5oID0gbmV3IFVpbnQxNkFycmF5KDEwKTtcbiAgdGhpcy5wYWQgPSBuZXcgVWludDE2QXJyYXkoOCk7XG4gIHRoaXMubGVmdG92ZXIgPSAwO1xuICB0aGlzLmZpbiA9IDA7XG5cbiAgdmFyIHQwLCB0MSwgdDIsIHQzLCB0NCwgdDUsIHQ2LCB0NztcblxuICB0MCA9IGtleVsgMF0gJiAweGZmIHwgKGtleVsgMV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbMF0gPSAoIHQwICAgICAgICAgICAgICAgICAgICAgKSAmIDB4MWZmZjtcbiAgdDEgPSBrZXlbIDJdICYgMHhmZiB8IChrZXlbIDNdICYgMHhmZikgPDwgODsgdGhpcy5yWzFdID0gKCh0MCA+Pj4gMTMpIHwgKHQxIDw8ICAzKSkgJiAweDFmZmY7XG4gIHQyID0ga2V5WyA0XSAmIDB4ZmYgfCAoa2V5WyA1XSAmIDB4ZmYpIDw8IDg7IHRoaXMuclsyXSA9ICgodDEgPj4+IDEwKSB8ICh0MiA8PCAgNikpICYgMHgxZjAzO1xuICB0MyA9IGtleVsgNl0gJiAweGZmIHwgKGtleVsgN10gJiAweGZmKSA8PCA4OyB0aGlzLnJbM10gPSAoKHQyID4+PiAgNykgfCAodDMgPDwgIDkpKSAmIDB4MWZmZjtcbiAgdDQgPSBrZXlbIDhdICYgMHhmZiB8IChrZXlbIDldICYgMHhmZikgPDwgODsgdGhpcy5yWzRdID0gKCh0MyA+Pj4gIDQpIHwgKHQ0IDw8IDEyKSkgJiAweDAwZmY7XG4gIHRoaXMucls1XSA9ICgodDQgPj4+ICAxKSkgJiAweDFmZmU7XG4gIHQ1ID0ga2V5WzEwXSAmIDB4ZmYgfCAoa2V5WzExXSAmIDB4ZmYpIDw8IDg7IHRoaXMucls2XSA9ICgodDQgPj4+IDE0KSB8ICh0NSA8PCAgMikpICYgMHgxZmZmO1xuICB0NiA9IGtleVsxMl0gJiAweGZmIHwgKGtleVsxM10gJiAweGZmKSA8PCA4OyB0aGlzLnJbN10gPSAoKHQ1ID4+PiAxMSkgfCAodDYgPDwgIDUpKSAmIDB4MWY4MTtcbiAgdDcgPSBrZXlbMTRdICYgMHhmZiB8IChrZXlbMTVdICYgMHhmZikgPDwgODsgdGhpcy5yWzhdID0gKCh0NiA+Pj4gIDgpIHwgKHQ3IDw8ICA4KSkgJiAweDFmZmY7XG4gIHRoaXMucls5XSA9ICgodDcgPj4+ICA1KSkgJiAweDAwN2Y7XG5cbiAgdGhpcy5wYWRbMF0gPSBrZXlbMTZdICYgMHhmZiB8IChrZXlbMTddICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbMV0gPSBrZXlbMThdICYgMHhmZiB8IChrZXlbMTldICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbMl0gPSBrZXlbMjBdICYgMHhmZiB8IChrZXlbMjFdICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbM10gPSBrZXlbMjJdICYgMHhmZiB8IChrZXlbMjNdICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbNF0gPSBrZXlbMjRdICYgMHhmZiB8IChrZXlbMjVdICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbNV0gPSBrZXlbMjZdICYgMHhmZiB8IChrZXlbMjddICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbNl0gPSBrZXlbMjhdICYgMHhmZiB8IChrZXlbMjldICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbN10gPSBrZXlbMzBdICYgMHhmZiB8IChrZXlbMzFdICYgMHhmZikgPDwgODtcbn07XG5cbnBvbHkxMzA1LnByb3RvdHlwZS5ibG9ja3MgPSBmdW5jdGlvbihtLCBtcG9zLCBieXRlcykge1xuICB2YXIgaGliaXQgPSB0aGlzLmZpbiA/IDAgOiAoMSA8PCAxMSk7XG4gIHZhciB0MCwgdDEsIHQyLCB0MywgdDQsIHQ1LCB0NiwgdDcsIGM7XG4gIHZhciBkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOTtcblxuICB2YXIgaDAgPSB0aGlzLmhbMF0sXG4gICAgICBoMSA9IHRoaXMuaFsxXSxcbiAgICAgIGgyID0gdGhpcy5oWzJdLFxuICAgICAgaDMgPSB0aGlzLmhbM10sXG4gICAgICBoNCA9IHRoaXMuaFs0XSxcbiAgICAgIGg1ID0gdGhpcy5oWzVdLFxuICAgICAgaDYgPSB0aGlzLmhbNl0sXG4gICAgICBoNyA9IHRoaXMuaFs3XSxcbiAgICAgIGg4ID0gdGhpcy5oWzhdLFxuICAgICAgaDkgPSB0aGlzLmhbOV07XG5cbiAgdmFyIHIwID0gdGhpcy5yWzBdLFxuICAgICAgcjEgPSB0aGlzLnJbMV0sXG4gICAgICByMiA9IHRoaXMuclsyXSxcbiAgICAgIHIzID0gdGhpcy5yWzNdLFxuICAgICAgcjQgPSB0aGlzLnJbNF0sXG4gICAgICByNSA9IHRoaXMucls1XSxcbiAgICAgIHI2ID0gdGhpcy5yWzZdLFxuICAgICAgcjcgPSB0aGlzLnJbN10sXG4gICAgICByOCA9IHRoaXMucls4XSxcbiAgICAgIHI5ID0gdGhpcy5yWzldO1xuXG4gIHdoaWxlIChieXRlcyA+PSAxNikge1xuICAgIHQwID0gbVttcG9zKyAwXSAmIDB4ZmYgfCAobVttcG9zKyAxXSAmIDB4ZmYpIDw8IDg7IGgwICs9ICggdDAgICAgICAgICAgICAgICAgICAgICApICYgMHgxZmZmO1xuICAgIHQxID0gbVttcG9zKyAyXSAmIDB4ZmYgfCAobVttcG9zKyAzXSAmIDB4ZmYpIDw8IDg7IGgxICs9ICgodDAgPj4+IDEzKSB8ICh0MSA8PCAgMykpICYgMHgxZmZmO1xuICAgIHQyID0gbVttcG9zKyA0XSAmIDB4ZmYgfCAobVttcG9zKyA1XSAmIDB4ZmYpIDw8IDg7IGgyICs9ICgodDEgPj4+IDEwKSB8ICh0MiA8PCAgNikpICYgMHgxZmZmO1xuICAgIHQzID0gbVttcG9zKyA2XSAmIDB4ZmYgfCAobVttcG9zKyA3XSAmIDB4ZmYpIDw8IDg7IGgzICs9ICgodDIgPj4+ICA3KSB8ICh0MyA8PCAgOSkpICYgMHgxZmZmO1xuICAgIHQ0ID0gbVttcG9zKyA4XSAmIDB4ZmYgfCAobVttcG9zKyA5XSAmIDB4ZmYpIDw8IDg7IGg0ICs9ICgodDMgPj4+ICA0KSB8ICh0NCA8PCAxMikpICYgMHgxZmZmO1xuICAgIGg1ICs9ICgodDQgPj4+ICAxKSkgJiAweDFmZmY7XG4gICAgdDUgPSBtW21wb3MrMTBdICYgMHhmZiB8IChtW21wb3MrMTFdICYgMHhmZikgPDwgODsgaDYgKz0gKCh0NCA+Pj4gMTQpIHwgKHQ1IDw8ICAyKSkgJiAweDFmZmY7XG4gICAgdDYgPSBtW21wb3MrMTJdICYgMHhmZiB8IChtW21wb3MrMTNdICYgMHhmZikgPDwgODsgaDcgKz0gKCh0NSA+Pj4gMTEpIHwgKHQ2IDw8ICA1KSkgJiAweDFmZmY7XG4gICAgdDcgPSBtW21wb3MrMTRdICYgMHhmZiB8IChtW21wb3MrMTVdICYgMHhmZikgPDwgODsgaDggKz0gKCh0NiA+Pj4gIDgpIHwgKHQ3IDw8ICA4KSkgJiAweDFmZmY7XG4gICAgaDkgKz0gKCh0NyA+Pj4gNSkpIHwgaGliaXQ7XG5cbiAgICBjID0gMDtcblxuICAgIGQwID0gYztcbiAgICBkMCArPSBoMCAqIHIwO1xuICAgIGQwICs9IGgxICogKDUgKiByOSk7XG4gICAgZDAgKz0gaDIgKiAoNSAqIHI4KTtcbiAgICBkMCArPSBoMyAqICg1ICogcjcpO1xuICAgIGQwICs9IGg0ICogKDUgKiByNik7XG4gICAgYyA9IChkMCA+Pj4gMTMpOyBkMCAmPSAweDFmZmY7XG4gICAgZDAgKz0gaDUgKiAoNSAqIHI1KTtcbiAgICBkMCArPSBoNiAqICg1ICogcjQpO1xuICAgIGQwICs9IGg3ICogKDUgKiByMyk7XG4gICAgZDAgKz0gaDggKiAoNSAqIHIyKTtcbiAgICBkMCArPSBoOSAqICg1ICogcjEpO1xuICAgIGMgKz0gKGQwID4+PiAxMyk7IGQwICY9IDB4MWZmZjtcblxuICAgIGQxID0gYztcbiAgICBkMSArPSBoMCAqIHIxO1xuICAgIGQxICs9IGgxICogcjA7XG4gICAgZDEgKz0gaDIgKiAoNSAqIHI5KTtcbiAgICBkMSArPSBoMyAqICg1ICogcjgpO1xuICAgIGQxICs9IGg0ICogKDUgKiByNyk7XG4gICAgYyA9IChkMSA+Pj4gMTMpOyBkMSAmPSAweDFmZmY7XG4gICAgZDEgKz0gaDUgKiAoNSAqIHI2KTtcbiAgICBkMSArPSBoNiAqICg1ICogcjUpO1xuICAgIGQxICs9IGg3ICogKDUgKiByNCk7XG4gICAgZDEgKz0gaDggKiAoNSAqIHIzKTtcbiAgICBkMSArPSBoOSAqICg1ICogcjIpO1xuICAgIGMgKz0gKGQxID4+PiAxMyk7IGQxICY9IDB4MWZmZjtcblxuICAgIGQyID0gYztcbiAgICBkMiArPSBoMCAqIHIyO1xuICAgIGQyICs9IGgxICogcjE7XG4gICAgZDIgKz0gaDIgKiByMDtcbiAgICBkMiArPSBoMyAqICg1ICogcjkpO1xuICAgIGQyICs9IGg0ICogKDUgKiByOCk7XG4gICAgYyA9IChkMiA+Pj4gMTMpOyBkMiAmPSAweDFmZmY7XG4gICAgZDIgKz0gaDUgKiAoNSAqIHI3KTtcbiAgICBkMiArPSBoNiAqICg1ICogcjYpO1xuICAgIGQyICs9IGg3ICogKDUgKiByNSk7XG4gICAgZDIgKz0gaDggKiAoNSAqIHI0KTtcbiAgICBkMiArPSBoOSAqICg1ICogcjMpO1xuICAgIGMgKz0gKGQyID4+PiAxMyk7IGQyICY9IDB4MWZmZjtcblxuICAgIGQzID0gYztcbiAgICBkMyArPSBoMCAqIHIzO1xuICAgIGQzICs9IGgxICogcjI7XG4gICAgZDMgKz0gaDIgKiByMTtcbiAgICBkMyArPSBoMyAqIHIwO1xuICAgIGQzICs9IGg0ICogKDUgKiByOSk7XG4gICAgYyA9IChkMyA+Pj4gMTMpOyBkMyAmPSAweDFmZmY7XG4gICAgZDMgKz0gaDUgKiAoNSAqIHI4KTtcbiAgICBkMyArPSBoNiAqICg1ICogcjcpO1xuICAgIGQzICs9IGg3ICogKDUgKiByNik7XG4gICAgZDMgKz0gaDggKiAoNSAqIHI1KTtcbiAgICBkMyArPSBoOSAqICg1ICogcjQpO1xuICAgIGMgKz0gKGQzID4+PiAxMyk7IGQzICY9IDB4MWZmZjtcblxuICAgIGQ0ID0gYztcbiAgICBkNCArPSBoMCAqIHI0O1xuICAgIGQ0ICs9IGgxICogcjM7XG4gICAgZDQgKz0gaDIgKiByMjtcbiAgICBkNCArPSBoMyAqIHIxO1xuICAgIGQ0ICs9IGg0ICogcjA7XG4gICAgYyA9IChkNCA+Pj4gMTMpOyBkNCAmPSAweDFmZmY7XG4gICAgZDQgKz0gaDUgKiAoNSAqIHI5KTtcbiAgICBkNCArPSBoNiAqICg1ICogcjgpO1xuICAgIGQ0ICs9IGg3ICogKDUgKiByNyk7XG4gICAgZDQgKz0gaDggKiAoNSAqIHI2KTtcbiAgICBkNCArPSBoOSAqICg1ICogcjUpO1xuICAgIGMgKz0gKGQ0ID4+PiAxMyk7IGQ0ICY9IDB4MWZmZjtcblxuICAgIGQ1ID0gYztcbiAgICBkNSArPSBoMCAqIHI1O1xuICAgIGQ1ICs9IGgxICogcjQ7XG4gICAgZDUgKz0gaDIgKiByMztcbiAgICBkNSArPSBoMyAqIHIyO1xuICAgIGQ1ICs9IGg0ICogcjE7XG4gICAgYyA9IChkNSA+Pj4gMTMpOyBkNSAmPSAweDFmZmY7XG4gICAgZDUgKz0gaDUgKiByMDtcbiAgICBkNSArPSBoNiAqICg1ICogcjkpO1xuICAgIGQ1ICs9IGg3ICogKDUgKiByOCk7XG4gICAgZDUgKz0gaDggKiAoNSAqIHI3KTtcbiAgICBkNSArPSBoOSAqICg1ICogcjYpO1xuICAgIGMgKz0gKGQ1ID4+PiAxMyk7IGQ1ICY9IDB4MWZmZjtcblxuICAgIGQ2ID0gYztcbiAgICBkNiArPSBoMCAqIHI2O1xuICAgIGQ2ICs9IGgxICogcjU7XG4gICAgZDYgKz0gaDIgKiByNDtcbiAgICBkNiArPSBoMyAqIHIzO1xuICAgIGQ2ICs9IGg0ICogcjI7XG4gICAgYyA9IChkNiA+Pj4gMTMpOyBkNiAmPSAweDFmZmY7XG4gICAgZDYgKz0gaDUgKiByMTtcbiAgICBkNiArPSBoNiAqIHIwO1xuICAgIGQ2ICs9IGg3ICogKDUgKiByOSk7XG4gICAgZDYgKz0gaDggKiAoNSAqIHI4KTtcbiAgICBkNiArPSBoOSAqICg1ICogcjcpO1xuICAgIGMgKz0gKGQ2ID4+PiAxMyk7IGQ2ICY9IDB4MWZmZjtcblxuICAgIGQ3ID0gYztcbiAgICBkNyArPSBoMCAqIHI3O1xuICAgIGQ3ICs9IGgxICogcjY7XG4gICAgZDcgKz0gaDIgKiByNTtcbiAgICBkNyArPSBoMyAqIHI0O1xuICAgIGQ3ICs9IGg0ICogcjM7XG4gICAgYyA9IChkNyA+Pj4gMTMpOyBkNyAmPSAweDFmZmY7XG4gICAgZDcgKz0gaDUgKiByMjtcbiAgICBkNyArPSBoNiAqIHIxO1xuICAgIGQ3ICs9IGg3ICogcjA7XG4gICAgZDcgKz0gaDggKiAoNSAqIHI5KTtcbiAgICBkNyArPSBoOSAqICg1ICogcjgpO1xuICAgIGMgKz0gKGQ3ID4+PiAxMyk7IGQ3ICY9IDB4MWZmZjtcblxuICAgIGQ4ID0gYztcbiAgICBkOCArPSBoMCAqIHI4O1xuICAgIGQ4ICs9IGgxICogcjc7XG4gICAgZDggKz0gaDIgKiByNjtcbiAgICBkOCArPSBoMyAqIHI1O1xuICAgIGQ4ICs9IGg0ICogcjQ7XG4gICAgYyA9IChkOCA+Pj4gMTMpOyBkOCAmPSAweDFmZmY7XG4gICAgZDggKz0gaDUgKiByMztcbiAgICBkOCArPSBoNiAqIHIyO1xuICAgIGQ4ICs9IGg3ICogcjE7XG4gICAgZDggKz0gaDggKiByMDtcbiAgICBkOCArPSBoOSAqICg1ICogcjkpO1xuICAgIGMgKz0gKGQ4ID4+PiAxMyk7IGQ4ICY9IDB4MWZmZjtcblxuICAgIGQ5ID0gYztcbiAgICBkOSArPSBoMCAqIHI5O1xuICAgIGQ5ICs9IGgxICogcjg7XG4gICAgZDkgKz0gaDIgKiByNztcbiAgICBkOSArPSBoMyAqIHI2O1xuICAgIGQ5ICs9IGg0ICogcjU7XG4gICAgYyA9IChkOSA+Pj4gMTMpOyBkOSAmPSAweDFmZmY7XG4gICAgZDkgKz0gaDUgKiByNDtcbiAgICBkOSArPSBoNiAqIHIzO1xuICAgIGQ5ICs9IGg3ICogcjI7XG4gICAgZDkgKz0gaDggKiByMTtcbiAgICBkOSArPSBoOSAqIHIwO1xuICAgIGMgKz0gKGQ5ID4+PiAxMyk7IGQ5ICY9IDB4MWZmZjtcblxuICAgIGMgPSAoKChjIDw8IDIpICsgYykpIHwgMDtcbiAgICBjID0gKGMgKyBkMCkgfCAwO1xuICAgIGQwID0gYyAmIDB4MWZmZjtcbiAgICBjID0gKGMgPj4+IDEzKTtcbiAgICBkMSArPSBjO1xuXG4gICAgaDAgPSBkMDtcbiAgICBoMSA9IGQxO1xuICAgIGgyID0gZDI7XG4gICAgaDMgPSBkMztcbiAgICBoNCA9IGQ0O1xuICAgIGg1ID0gZDU7XG4gICAgaDYgPSBkNjtcbiAgICBoNyA9IGQ3O1xuICAgIGg4ID0gZDg7XG4gICAgaDkgPSBkOTtcblxuICAgIG1wb3MgKz0gMTY7XG4gICAgYnl0ZXMgLT0gMTY7XG4gIH1cbiAgdGhpcy5oWzBdID0gaDA7XG4gIHRoaXMuaFsxXSA9IGgxO1xuICB0aGlzLmhbMl0gPSBoMjtcbiAgdGhpcy5oWzNdID0gaDM7XG4gIHRoaXMuaFs0XSA9IGg0O1xuICB0aGlzLmhbNV0gPSBoNTtcbiAgdGhpcy5oWzZdID0gaDY7XG4gIHRoaXMuaFs3XSA9IGg3O1xuICB0aGlzLmhbOF0gPSBoODtcbiAgdGhpcy5oWzldID0gaDk7XG59O1xuXG5wb2x5MTMwNS5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24obWFjLCBtYWNwb3MpIHtcbiAgdmFyIGcgPSBuZXcgVWludDE2QXJyYXkoMTApO1xuICB2YXIgYywgbWFzaywgZiwgaTtcblxuICBpZiAodGhpcy5sZWZ0b3Zlcikge1xuICAgIGkgPSB0aGlzLmxlZnRvdmVyO1xuICAgIHRoaXMuYnVmZmVyW2krK10gPSAxO1xuICAgIGZvciAoOyBpIDwgMTY7IGkrKykgdGhpcy5idWZmZXJbaV0gPSAwO1xuICAgIHRoaXMuZmluID0gMTtcbiAgICB0aGlzLmJsb2Nrcyh0aGlzLmJ1ZmZlciwgMCwgMTYpO1xuICB9XG5cbiAgYyA9IHRoaXMuaFsxXSA+Pj4gMTM7XG4gIHRoaXMuaFsxXSAmPSAweDFmZmY7XG4gIGZvciAoaSA9IDI7IGkgPCAxMDsgaSsrKSB7XG4gICAgdGhpcy5oW2ldICs9IGM7XG4gICAgYyA9IHRoaXMuaFtpXSA+Pj4gMTM7XG4gICAgdGhpcy5oW2ldICY9IDB4MWZmZjtcbiAgfVxuICB0aGlzLmhbMF0gKz0gKGMgKiA1KTtcbiAgYyA9IHRoaXMuaFswXSA+Pj4gMTM7XG4gIHRoaXMuaFswXSAmPSAweDFmZmY7XG4gIHRoaXMuaFsxXSArPSBjO1xuICBjID0gdGhpcy5oWzFdID4+PiAxMztcbiAgdGhpcy5oWzFdICY9IDB4MWZmZjtcbiAgdGhpcy5oWzJdICs9IGM7XG5cbiAgZ1swXSA9IHRoaXMuaFswXSArIDU7XG4gIGMgPSBnWzBdID4+PiAxMztcbiAgZ1swXSAmPSAweDFmZmY7XG4gIGZvciAoaSA9IDE7IGkgPCAxMDsgaSsrKSB7XG4gICAgZ1tpXSA9IHRoaXMuaFtpXSArIGM7XG4gICAgYyA9IGdbaV0gPj4+IDEzO1xuICAgIGdbaV0gJj0gMHgxZmZmO1xuICB9XG4gIGdbOV0gLT0gKDEgPDwgMTMpO1xuXG4gIG1hc2sgPSAoYyBeIDEpIC0gMTtcbiAgZm9yIChpID0gMDsgaSA8IDEwOyBpKyspIGdbaV0gJj0gbWFzaztcbiAgbWFzayA9IH5tYXNrO1xuICBmb3IgKGkgPSAwOyBpIDwgMTA7IGkrKykgdGhpcy5oW2ldID0gKHRoaXMuaFtpXSAmIG1hc2spIHwgZ1tpXTtcblxuICB0aGlzLmhbMF0gPSAoKHRoaXMuaFswXSAgICAgICApIHwgKHRoaXMuaFsxXSA8PCAxMykgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFsxXSA9ICgodGhpcy5oWzFdID4+PiAgMykgfCAodGhpcy5oWzJdIDw8IDEwKSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzJdID0gKCh0aGlzLmhbMl0gPj4+ICA2KSB8ICh0aGlzLmhbM10gPDwgIDcpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbM10gPSAoKHRoaXMuaFszXSA+Pj4gIDkpIHwgKHRoaXMuaFs0XSA8PCAgNCkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFs0XSA9ICgodGhpcy5oWzRdID4+PiAxMikgfCAodGhpcy5oWzVdIDw8ICAxKSB8ICh0aGlzLmhbNl0gPDwgMTQpKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzVdID0gKCh0aGlzLmhbNl0gPj4+ICAyKSB8ICh0aGlzLmhbN10gPDwgMTEpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbNl0gPSAoKHRoaXMuaFs3XSA+Pj4gIDUpIHwgKHRoaXMuaFs4XSA8PCAgOCkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFs3XSA9ICgodGhpcy5oWzhdID4+PiAgOCkgfCAodGhpcy5oWzldIDw8ICA1KSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcblxuICBmID0gdGhpcy5oWzBdICsgdGhpcy5wYWRbMF07XG4gIHRoaXMuaFswXSA9IGYgJiAweGZmZmY7XG4gIGZvciAoaSA9IDE7IGkgPCA4OyBpKyspIHtcbiAgICBmID0gKCgodGhpcy5oW2ldICsgdGhpcy5wYWRbaV0pIHwgMCkgKyAoZiA+Pj4gMTYpKSB8IDA7XG4gICAgdGhpcy5oW2ldID0gZiAmIDB4ZmZmZjtcbiAgfVxuXG4gIG1hY1ttYWNwb3MrIDBdID0gKHRoaXMuaFswXSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyAxXSA9ICh0aGlzLmhbMF0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysgMl0gPSAodGhpcy5oWzFdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDNdID0gKHRoaXMuaFsxXSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA0XSA9ICh0aGlzLmhbMl0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgNV0gPSAodGhpcy5oWzJdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDZdID0gKHRoaXMuaFszXSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA3XSA9ICh0aGlzLmhbM10gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysgOF0gPSAodGhpcy5oWzRdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDldID0gKHRoaXMuaFs0XSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzEwXSA9ICh0aGlzLmhbNV0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysxMV0gPSAodGhpcy5oWzVdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTJdID0gKHRoaXMuaFs2XSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzEzXSA9ICh0aGlzLmhbNl0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysxNF0gPSAodGhpcy5oWzddID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTVdID0gKHRoaXMuaFs3XSA+Pj4gOCkgJiAweGZmO1xufTtcblxucG9seTEzMDUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG0sIG1wb3MsIGJ5dGVzKSB7XG4gIHZhciBpLCB3YW50O1xuXG4gIGlmICh0aGlzLmxlZnRvdmVyKSB7XG4gICAgd2FudCA9ICgxNiAtIHRoaXMubGVmdG92ZXIpO1xuICAgIGlmICh3YW50ID4gYnl0ZXMpXG4gICAgICB3YW50ID0gYnl0ZXM7XG4gICAgZm9yIChpID0gMDsgaSA8IHdhbnQ7IGkrKylcbiAgICAgIHRoaXMuYnVmZmVyW3RoaXMubGVmdG92ZXIgKyBpXSA9IG1bbXBvcytpXTtcbiAgICBieXRlcyAtPSB3YW50O1xuICAgIG1wb3MgKz0gd2FudDtcbiAgICB0aGlzLmxlZnRvdmVyICs9IHdhbnQ7XG4gICAgaWYgKHRoaXMubGVmdG92ZXIgPCAxNilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmJsb2Nrcyh0aGlzLmJ1ZmZlciwgMCwgMTYpO1xuICAgIHRoaXMubGVmdG92ZXIgPSAwO1xuICB9XG5cbiAgaWYgKGJ5dGVzID49IDE2KSB7XG4gICAgd2FudCA9IGJ5dGVzIC0gKGJ5dGVzICUgMTYpO1xuICAgIHRoaXMuYmxvY2tzKG0sIG1wb3MsIHdhbnQpO1xuICAgIG1wb3MgKz0gd2FudDtcbiAgICBieXRlcyAtPSB3YW50O1xuICB9XG5cbiAgaWYgKGJ5dGVzKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGJ5dGVzOyBpKyspXG4gICAgICB0aGlzLmJ1ZmZlclt0aGlzLmxlZnRvdmVyICsgaV0gPSBtW21wb3MraV07XG4gICAgdGhpcy5sZWZ0b3ZlciArPSBieXRlcztcbiAgfVxufTtcblxuZnVuY3Rpb24gY3J5cHRvX29uZXRpbWVhdXRoKG91dCwgb3V0cG9zLCBtLCBtcG9zLCBuLCBrKSB7XG4gIHZhciBzID0gbmV3IHBvbHkxMzA1KGspO1xuICBzLnVwZGF0ZShtLCBtcG9zLCBuKTtcbiAgcy5maW5pc2gob3V0LCBvdXRwb3MpO1xuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX29uZXRpbWVhdXRoX3ZlcmlmeShoLCBocG9zLCBtLCBtcG9zLCBuLCBrKSB7XG4gIHZhciB4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICBjcnlwdG9fb25ldGltZWF1dGgoeCwwLG0sbXBvcyxuLGspO1xuICByZXR1cm4gY3J5cHRvX3ZlcmlmeV8xNihoLGhwb3MseCwwKTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NlY3JldGJveChjLG0sZCxuLGspIHtcbiAgdmFyIGk7XG4gIGlmIChkIDwgMzIpIHJldHVybiAtMTtcbiAgY3J5cHRvX3N0cmVhbV94b3IoYywwLG0sMCxkLG4sayk7XG4gIGNyeXB0b19vbmV0aW1lYXV0aChjLCAxNiwgYywgMzIsIGQgLSAzMiwgYyk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSBjW2ldID0gMDtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zZWNyZXRib3hfb3BlbihtLGMsZCxuLGspIHtcbiAgdmFyIGk7XG4gIHZhciB4ID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBpZiAoZCA8IDMyKSByZXR1cm4gLTE7XG4gIGNyeXB0b19zdHJlYW0oeCwwLDMyLG4sayk7XG4gIGlmIChjcnlwdG9fb25ldGltZWF1dGhfdmVyaWZ5KGMsIDE2LGMsIDMyLGQgLSAzMix4KSAhPT0gMCkgcmV0dXJuIC0xO1xuICBjcnlwdG9fc3RyZWFtX3hvcihtLDAsYywwLGQsbixrKTtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIG1baV0gPSAwO1xuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gc2V0MjU1MTkociwgYSkge1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHJbaV0gPSBhW2ldfDA7XG59XG5cbmZ1bmN0aW9uIGNhcjI1NTE5KG8pIHtcbiAgdmFyIGksIHYsIGMgPSAxO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIHYgPSBvW2ldICsgYyArIDY1NTM1O1xuICAgIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7XG4gICAgb1tpXSA9IHYgLSBjICogNjU1MzY7XG4gIH1cbiAgb1swXSArPSBjLTEgKyAzNyAqIChjLTEpO1xufVxuXG5mdW5jdGlvbiBzZWwyNTUxOShwLCBxLCBiKSB7XG4gIHZhciB0LCBjID0gfihiLTEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB0ID0gYyAmIChwW2ldIF4gcVtpXSk7XG4gICAgcFtpXSBePSB0O1xuICAgIHFbaV0gXj0gdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYWNrMjU1MTkobywgbikge1xuICB2YXIgaSwgaiwgYjtcbiAgdmFyIG0gPSBnZigpLCB0ID0gZ2YoKTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHRbaV0gPSBuW2ldO1xuICBjYXIyNTUxOSh0KTtcbiAgY2FyMjU1MTkodCk7XG4gIGNhcjI1NTE5KHQpO1xuICBmb3IgKGogPSAwOyBqIDwgMjsgaisrKSB7XG4gICAgbVswXSA9IHRbMF0gLSAweGZmZWQ7XG4gICAgZm9yIChpID0gMTsgaSA8IDE1OyBpKyspIHtcbiAgICAgIG1baV0gPSB0W2ldIC0gMHhmZmZmIC0gKChtW2ktMV0+PjE2KSAmIDEpO1xuICAgICAgbVtpLTFdICY9IDB4ZmZmZjtcbiAgICB9XG4gICAgbVsxNV0gPSB0WzE1XSAtIDB4N2ZmZiAtICgobVsxNF0+PjE2KSAmIDEpO1xuICAgIGIgPSAobVsxNV0+PjE2KSAmIDE7XG4gICAgbVsxNF0gJj0gMHhmZmZmO1xuICAgIHNlbDI1NTE5KHQsIG0sIDEtYik7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICBvWzIqaV0gPSB0W2ldICYgMHhmZjtcbiAgICBvWzIqaSsxXSA9IHRbaV0+Pjg7XG4gIH1cbn1cblxuZnVuY3Rpb24gbmVxMjU1MTkoYSwgYikge1xuICB2YXIgYyA9IG5ldyBVaW50OEFycmF5KDMyKSwgZCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgcGFjazI1NTE5KGMsIGEpO1xuICBwYWNrMjU1MTkoZCwgYik7XG4gIHJldHVybiBjcnlwdG9fdmVyaWZ5XzMyKGMsIDAsIGQsIDApO1xufVxuXG5mdW5jdGlvbiBwYXIyNTUxOShhKSB7XG4gIHZhciBkID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBwYWNrMjU1MTkoZCwgYSk7XG4gIHJldHVybiBkWzBdICYgMTtcbn1cblxuZnVuY3Rpb24gdW5wYWNrMjU1MTkobywgbikge1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIG9baV0gPSBuWzIqaV0gKyAoblsyKmkrMV0gPDwgOCk7XG4gIG9bMTVdICY9IDB4N2ZmZjtcbn1cblxuZnVuY3Rpb24gQShvLCBhLCBiKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykgb1tpXSA9IGFbaV0gKyBiW2ldO1xufVxuXG5mdW5jdGlvbiBaKG8sIGEsIGIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSBvW2ldID0gYVtpXSAtIGJbaV07XG59XG5cbmZ1bmN0aW9uIE0obywgYSwgYikge1xuICB2YXIgdiwgYyxcbiAgICAgdDAgPSAwLCAgdDEgPSAwLCAgdDIgPSAwLCAgdDMgPSAwLCAgdDQgPSAwLCAgdDUgPSAwLCAgdDYgPSAwLCAgdDcgPSAwLFxuICAgICB0OCA9IDAsICB0OSA9IDAsIHQxMCA9IDAsIHQxMSA9IDAsIHQxMiA9IDAsIHQxMyA9IDAsIHQxNCA9IDAsIHQxNSA9IDAsXG4gICAgdDE2ID0gMCwgdDE3ID0gMCwgdDE4ID0gMCwgdDE5ID0gMCwgdDIwID0gMCwgdDIxID0gMCwgdDIyID0gMCwgdDIzID0gMCxcbiAgICB0MjQgPSAwLCB0MjUgPSAwLCB0MjYgPSAwLCB0MjcgPSAwLCB0MjggPSAwLCB0MjkgPSAwLCB0MzAgPSAwLFxuICAgIGIwID0gYlswXSxcbiAgICBiMSA9IGJbMV0sXG4gICAgYjIgPSBiWzJdLFxuICAgIGIzID0gYlszXSxcbiAgICBiNCA9IGJbNF0sXG4gICAgYjUgPSBiWzVdLFxuICAgIGI2ID0gYls2XSxcbiAgICBiNyA9IGJbN10sXG4gICAgYjggPSBiWzhdLFxuICAgIGI5ID0gYls5XSxcbiAgICBiMTAgPSBiWzEwXSxcbiAgICBiMTEgPSBiWzExXSxcbiAgICBiMTIgPSBiWzEyXSxcbiAgICBiMTMgPSBiWzEzXSxcbiAgICBiMTQgPSBiWzE0XSxcbiAgICBiMTUgPSBiWzE1XTtcblxuICB2ID0gYVswXTtcbiAgdDAgKz0gdiAqIGIwO1xuICB0MSArPSB2ICogYjE7XG4gIHQyICs9IHYgKiBiMjtcbiAgdDMgKz0gdiAqIGIzO1xuICB0NCArPSB2ICogYjQ7XG4gIHQ1ICs9IHYgKiBiNTtcbiAgdDYgKz0gdiAqIGI2O1xuICB0NyArPSB2ICogYjc7XG4gIHQ4ICs9IHYgKiBiODtcbiAgdDkgKz0gdiAqIGI5O1xuICB0MTAgKz0gdiAqIGIxMDtcbiAgdDExICs9IHYgKiBiMTE7XG4gIHQxMiArPSB2ICogYjEyO1xuICB0MTMgKz0gdiAqIGIxMztcbiAgdDE0ICs9IHYgKiBiMTQ7XG4gIHQxNSArPSB2ICogYjE1O1xuICB2ID0gYVsxXTtcbiAgdDEgKz0gdiAqIGIwO1xuICB0MiArPSB2ICogYjE7XG4gIHQzICs9IHYgKiBiMjtcbiAgdDQgKz0gdiAqIGIzO1xuICB0NSArPSB2ICogYjQ7XG4gIHQ2ICs9IHYgKiBiNTtcbiAgdDcgKz0gdiAqIGI2O1xuICB0OCArPSB2ICogYjc7XG4gIHQ5ICs9IHYgKiBiODtcbiAgdDEwICs9IHYgKiBiOTtcbiAgdDExICs9IHYgKiBiMTA7XG4gIHQxMiArPSB2ICogYjExO1xuICB0MTMgKz0gdiAqIGIxMjtcbiAgdDE0ICs9IHYgKiBiMTM7XG4gIHQxNSArPSB2ICogYjE0O1xuICB0MTYgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMl07XG4gIHQyICs9IHYgKiBiMDtcbiAgdDMgKz0gdiAqIGIxO1xuICB0NCArPSB2ICogYjI7XG4gIHQ1ICs9IHYgKiBiMztcbiAgdDYgKz0gdiAqIGI0O1xuICB0NyArPSB2ICogYjU7XG4gIHQ4ICs9IHYgKiBiNjtcbiAgdDkgKz0gdiAqIGI3O1xuICB0MTAgKz0gdiAqIGI4O1xuICB0MTEgKz0gdiAqIGI5O1xuICB0MTIgKz0gdiAqIGIxMDtcbiAgdDEzICs9IHYgKiBiMTE7XG4gIHQxNCArPSB2ICogYjEyO1xuICB0MTUgKz0gdiAqIGIxMztcbiAgdDE2ICs9IHYgKiBiMTQ7XG4gIHQxNyArPSB2ICogYjE1O1xuICB2ID0gYVszXTtcbiAgdDMgKz0gdiAqIGIwO1xuICB0NCArPSB2ICogYjE7XG4gIHQ1ICs9IHYgKiBiMjtcbiAgdDYgKz0gdiAqIGIzO1xuICB0NyArPSB2ICogYjQ7XG4gIHQ4ICs9IHYgKiBiNTtcbiAgdDkgKz0gdiAqIGI2O1xuICB0MTAgKz0gdiAqIGI3O1xuICB0MTEgKz0gdiAqIGI4O1xuICB0MTIgKz0gdiAqIGI5O1xuICB0MTMgKz0gdiAqIGIxMDtcbiAgdDE0ICs9IHYgKiBiMTE7XG4gIHQxNSArPSB2ICogYjEyO1xuICB0MTYgKz0gdiAqIGIxMztcbiAgdDE3ICs9IHYgKiBiMTQ7XG4gIHQxOCArPSB2ICogYjE1O1xuICB2ID0gYVs0XTtcbiAgdDQgKz0gdiAqIGIwO1xuICB0NSArPSB2ICogYjE7XG4gIHQ2ICs9IHYgKiBiMjtcbiAgdDcgKz0gdiAqIGIzO1xuICB0OCArPSB2ICogYjQ7XG4gIHQ5ICs9IHYgKiBiNTtcbiAgdDEwICs9IHYgKiBiNjtcbiAgdDExICs9IHYgKiBiNztcbiAgdDEyICs9IHYgKiBiODtcbiAgdDEzICs9IHYgKiBiOTtcbiAgdDE0ICs9IHYgKiBiMTA7XG4gIHQxNSArPSB2ICogYjExO1xuICB0MTYgKz0gdiAqIGIxMjtcbiAgdDE3ICs9IHYgKiBiMTM7XG4gIHQxOCArPSB2ICogYjE0O1xuICB0MTkgKz0gdiAqIGIxNTtcbiAgdiA9IGFbNV07XG4gIHQ1ICs9IHYgKiBiMDtcbiAgdDYgKz0gdiAqIGIxO1xuICB0NyArPSB2ICogYjI7XG4gIHQ4ICs9IHYgKiBiMztcbiAgdDkgKz0gdiAqIGI0O1xuICB0MTAgKz0gdiAqIGI1O1xuICB0MTEgKz0gdiAqIGI2O1xuICB0MTIgKz0gdiAqIGI3O1xuICB0MTMgKz0gdiAqIGI4O1xuICB0MTQgKz0gdiAqIGI5O1xuICB0MTUgKz0gdiAqIGIxMDtcbiAgdDE2ICs9IHYgKiBiMTE7XG4gIHQxNyArPSB2ICogYjEyO1xuICB0MTggKz0gdiAqIGIxMztcbiAgdDE5ICs9IHYgKiBiMTQ7XG4gIHQyMCArPSB2ICogYjE1O1xuICB2ID0gYVs2XTtcbiAgdDYgKz0gdiAqIGIwO1xuICB0NyArPSB2ICogYjE7XG4gIHQ4ICs9IHYgKiBiMjtcbiAgdDkgKz0gdiAqIGIzO1xuICB0MTAgKz0gdiAqIGI0O1xuICB0MTEgKz0gdiAqIGI1O1xuICB0MTIgKz0gdiAqIGI2O1xuICB0MTMgKz0gdiAqIGI3O1xuICB0MTQgKz0gdiAqIGI4O1xuICB0MTUgKz0gdiAqIGI5O1xuICB0MTYgKz0gdiAqIGIxMDtcbiAgdDE3ICs9IHYgKiBiMTE7XG4gIHQxOCArPSB2ICogYjEyO1xuICB0MTkgKz0gdiAqIGIxMztcbiAgdDIwICs9IHYgKiBiMTQ7XG4gIHQyMSArPSB2ICogYjE1O1xuICB2ID0gYVs3XTtcbiAgdDcgKz0gdiAqIGIwO1xuICB0OCArPSB2ICogYjE7XG4gIHQ5ICs9IHYgKiBiMjtcbiAgdDEwICs9IHYgKiBiMztcbiAgdDExICs9IHYgKiBiNDtcbiAgdDEyICs9IHYgKiBiNTtcbiAgdDEzICs9IHYgKiBiNjtcbiAgdDE0ICs9IHYgKiBiNztcbiAgdDE1ICs9IHYgKiBiODtcbiAgdDE2ICs9IHYgKiBiOTtcbiAgdDE3ICs9IHYgKiBiMTA7XG4gIHQxOCArPSB2ICogYjExO1xuICB0MTkgKz0gdiAqIGIxMjtcbiAgdDIwICs9IHYgKiBiMTM7XG4gIHQyMSArPSB2ICogYjE0O1xuICB0MjIgKz0gdiAqIGIxNTtcbiAgdiA9IGFbOF07XG4gIHQ4ICs9IHYgKiBiMDtcbiAgdDkgKz0gdiAqIGIxO1xuICB0MTAgKz0gdiAqIGIyO1xuICB0MTEgKz0gdiAqIGIzO1xuICB0MTIgKz0gdiAqIGI0O1xuICB0MTMgKz0gdiAqIGI1O1xuICB0MTQgKz0gdiAqIGI2O1xuICB0MTUgKz0gdiAqIGI3O1xuICB0MTYgKz0gdiAqIGI4O1xuICB0MTcgKz0gdiAqIGI5O1xuICB0MTggKz0gdiAqIGIxMDtcbiAgdDE5ICs9IHYgKiBiMTE7XG4gIHQyMCArPSB2ICogYjEyO1xuICB0MjEgKz0gdiAqIGIxMztcbiAgdDIyICs9IHYgKiBiMTQ7XG4gIHQyMyArPSB2ICogYjE1O1xuICB2ID0gYVs5XTtcbiAgdDkgKz0gdiAqIGIwO1xuICB0MTAgKz0gdiAqIGIxO1xuICB0MTEgKz0gdiAqIGIyO1xuICB0MTIgKz0gdiAqIGIzO1xuICB0MTMgKz0gdiAqIGI0O1xuICB0MTQgKz0gdiAqIGI1O1xuICB0MTUgKz0gdiAqIGI2O1xuICB0MTYgKz0gdiAqIGI3O1xuICB0MTcgKz0gdiAqIGI4O1xuICB0MTggKz0gdiAqIGI5O1xuICB0MTkgKz0gdiAqIGIxMDtcbiAgdDIwICs9IHYgKiBiMTE7XG4gIHQyMSArPSB2ICogYjEyO1xuICB0MjIgKz0gdiAqIGIxMztcbiAgdDIzICs9IHYgKiBiMTQ7XG4gIHQyNCArPSB2ICogYjE1O1xuICB2ID0gYVsxMF07XG4gIHQxMCArPSB2ICogYjA7XG4gIHQxMSArPSB2ICogYjE7XG4gIHQxMiArPSB2ICogYjI7XG4gIHQxMyArPSB2ICogYjM7XG4gIHQxNCArPSB2ICogYjQ7XG4gIHQxNSArPSB2ICogYjU7XG4gIHQxNiArPSB2ICogYjY7XG4gIHQxNyArPSB2ICogYjc7XG4gIHQxOCArPSB2ICogYjg7XG4gIHQxOSArPSB2ICogYjk7XG4gIHQyMCArPSB2ICogYjEwO1xuICB0MjEgKz0gdiAqIGIxMTtcbiAgdDIyICs9IHYgKiBiMTI7XG4gIHQyMyArPSB2ICogYjEzO1xuICB0MjQgKz0gdiAqIGIxNDtcbiAgdDI1ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzExXTtcbiAgdDExICs9IHYgKiBiMDtcbiAgdDEyICs9IHYgKiBiMTtcbiAgdDEzICs9IHYgKiBiMjtcbiAgdDE0ICs9IHYgKiBiMztcbiAgdDE1ICs9IHYgKiBiNDtcbiAgdDE2ICs9IHYgKiBiNTtcbiAgdDE3ICs9IHYgKiBiNjtcbiAgdDE4ICs9IHYgKiBiNztcbiAgdDE5ICs9IHYgKiBiODtcbiAgdDIwICs9IHYgKiBiOTtcbiAgdDIxICs9IHYgKiBiMTA7XG4gIHQyMiArPSB2ICogYjExO1xuICB0MjMgKz0gdiAqIGIxMjtcbiAgdDI0ICs9IHYgKiBiMTM7XG4gIHQyNSArPSB2ICogYjE0O1xuICB0MjYgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTJdO1xuICB0MTIgKz0gdiAqIGIwO1xuICB0MTMgKz0gdiAqIGIxO1xuICB0MTQgKz0gdiAqIGIyO1xuICB0MTUgKz0gdiAqIGIzO1xuICB0MTYgKz0gdiAqIGI0O1xuICB0MTcgKz0gdiAqIGI1O1xuICB0MTggKz0gdiAqIGI2O1xuICB0MTkgKz0gdiAqIGI3O1xuICB0MjAgKz0gdiAqIGI4O1xuICB0MjEgKz0gdiAqIGI5O1xuICB0MjIgKz0gdiAqIGIxMDtcbiAgdDIzICs9IHYgKiBiMTE7XG4gIHQyNCArPSB2ICogYjEyO1xuICB0MjUgKz0gdiAqIGIxMztcbiAgdDI2ICs9IHYgKiBiMTQ7XG4gIHQyNyArPSB2ICogYjE1O1xuICB2ID0gYVsxM107XG4gIHQxMyArPSB2ICogYjA7XG4gIHQxNCArPSB2ICogYjE7XG4gIHQxNSArPSB2ICogYjI7XG4gIHQxNiArPSB2ICogYjM7XG4gIHQxNyArPSB2ICogYjQ7XG4gIHQxOCArPSB2ICogYjU7XG4gIHQxOSArPSB2ICogYjY7XG4gIHQyMCArPSB2ICogYjc7XG4gIHQyMSArPSB2ICogYjg7XG4gIHQyMiArPSB2ICogYjk7XG4gIHQyMyArPSB2ICogYjEwO1xuICB0MjQgKz0gdiAqIGIxMTtcbiAgdDI1ICs9IHYgKiBiMTI7XG4gIHQyNiArPSB2ICogYjEzO1xuICB0MjcgKz0gdiAqIGIxNDtcbiAgdDI4ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzE0XTtcbiAgdDE0ICs9IHYgKiBiMDtcbiAgdDE1ICs9IHYgKiBiMTtcbiAgdDE2ICs9IHYgKiBiMjtcbiAgdDE3ICs9IHYgKiBiMztcbiAgdDE4ICs9IHYgKiBiNDtcbiAgdDE5ICs9IHYgKiBiNTtcbiAgdDIwICs9IHYgKiBiNjtcbiAgdDIxICs9IHYgKiBiNztcbiAgdDIyICs9IHYgKiBiODtcbiAgdDIzICs9IHYgKiBiOTtcbiAgdDI0ICs9IHYgKiBiMTA7XG4gIHQyNSArPSB2ICogYjExO1xuICB0MjYgKz0gdiAqIGIxMjtcbiAgdDI3ICs9IHYgKiBiMTM7XG4gIHQyOCArPSB2ICogYjE0O1xuICB0MjkgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTVdO1xuICB0MTUgKz0gdiAqIGIwO1xuICB0MTYgKz0gdiAqIGIxO1xuICB0MTcgKz0gdiAqIGIyO1xuICB0MTggKz0gdiAqIGIzO1xuICB0MTkgKz0gdiAqIGI0O1xuICB0MjAgKz0gdiAqIGI1O1xuICB0MjEgKz0gdiAqIGI2O1xuICB0MjIgKz0gdiAqIGI3O1xuICB0MjMgKz0gdiAqIGI4O1xuICB0MjQgKz0gdiAqIGI5O1xuICB0MjUgKz0gdiAqIGIxMDtcbiAgdDI2ICs9IHYgKiBiMTE7XG4gIHQyNyArPSB2ICogYjEyO1xuICB0MjggKz0gdiAqIGIxMztcbiAgdDI5ICs9IHYgKiBiMTQ7XG4gIHQzMCArPSB2ICogYjE1O1xuXG4gIHQwICArPSAzOCAqIHQxNjtcbiAgdDEgICs9IDM4ICogdDE3O1xuICB0MiAgKz0gMzggKiB0MTg7XG4gIHQzICArPSAzOCAqIHQxOTtcbiAgdDQgICs9IDM4ICogdDIwO1xuICB0NSAgKz0gMzggKiB0MjE7XG4gIHQ2ICArPSAzOCAqIHQyMjtcbiAgdDcgICs9IDM4ICogdDIzO1xuICB0OCAgKz0gMzggKiB0MjQ7XG4gIHQ5ICArPSAzOCAqIHQyNTtcbiAgdDEwICs9IDM4ICogdDI2O1xuICB0MTEgKz0gMzggKiB0Mjc7XG4gIHQxMiArPSAzOCAqIHQyODtcbiAgdDEzICs9IDM4ICogdDI5O1xuICB0MTQgKz0gMzggKiB0MzA7XG4gIC8vIHQxNSBsZWZ0IGFzIGlzXG5cbiAgLy8gZmlyc3QgY2FyXG4gIGMgPSAxO1xuICB2ID0gIHQwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQxICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDUgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ2ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDYgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ3ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDcgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ4ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDggPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ5ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDkgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDExICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTUgPSB2IC0gYyAqIDY1NTM2O1xuICB0MCArPSBjLTEgKyAzNyAqIChjLTEpO1xuXG4gIC8vIHNlY29uZCBjYXJcbiAgYyA9IDE7XG4gIHYgPSAgdDAgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDEgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDIgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MiA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDMgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MyA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDQgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDUgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDYgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NiA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDcgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NyA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDggKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0OCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDkgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0OSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTAgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTEgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTIgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMiA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTMgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMyA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTQgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxNCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTUgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxNSA9IHYgLSBjICogNjU1MzY7XG4gIHQwICs9IGMtMSArIDM3ICogKGMtMSk7XG5cbiAgb1sgMF0gPSB0MDtcbiAgb1sgMV0gPSB0MTtcbiAgb1sgMl0gPSB0MjtcbiAgb1sgM10gPSB0MztcbiAgb1sgNF0gPSB0NDtcbiAgb1sgNV0gPSB0NTtcbiAgb1sgNl0gPSB0NjtcbiAgb1sgN10gPSB0NztcbiAgb1sgOF0gPSB0ODtcbiAgb1sgOV0gPSB0OTtcbiAgb1sxMF0gPSB0MTA7XG4gIG9bMTFdID0gdDExO1xuICBvWzEyXSA9IHQxMjtcbiAgb1sxM10gPSB0MTM7XG4gIG9bMTRdID0gdDE0O1xuICBvWzE1XSA9IHQxNTtcbn1cblxuZnVuY3Rpb24gUyhvLCBhKSB7XG4gIE0obywgYSwgYSk7XG59XG5cbmZ1bmN0aW9uIGludjI1NTE5KG8sIGkpIHtcbiAgdmFyIGMgPSBnZigpO1xuICB2YXIgYTtcbiAgZm9yIChhID0gMDsgYSA8IDE2OyBhKyspIGNbYV0gPSBpW2FdO1xuICBmb3IgKGEgPSAyNTM7IGEgPj0gMDsgYS0tKSB7XG4gICAgUyhjLCBjKTtcbiAgICBpZihhICE9PSAyICYmIGEgIT09IDQpIE0oYywgYywgaSk7XG4gIH1cbiAgZm9yIChhID0gMDsgYSA8IDE2OyBhKyspIG9bYV0gPSBjW2FdO1xufVxuXG5mdW5jdGlvbiBwb3cyNTIzKG8sIGkpIHtcbiAgdmFyIGMgPSBnZigpO1xuICB2YXIgYTtcbiAgZm9yIChhID0gMDsgYSA8IDE2OyBhKyspIGNbYV0gPSBpW2FdO1xuICBmb3IgKGEgPSAyNTA7IGEgPj0gMDsgYS0tKSB7XG4gICAgICBTKGMsIGMpO1xuICAgICAgaWYoYSAhPT0gMSkgTShjLCBjLCBpKTtcbiAgfVxuICBmb3IgKGEgPSAwOyBhIDwgMTY7IGErKykgb1thXSA9IGNbYV07XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zY2FsYXJtdWx0KHEsIG4sIHApIHtcbiAgdmFyIHogPSBuZXcgVWludDhBcnJheSgzMik7XG4gIHZhciB4ID0gbmV3IEZsb2F0NjRBcnJheSg4MCksIHIsIGk7XG4gIHZhciBhID0gZ2YoKSwgYiA9IGdmKCksIGMgPSBnZigpLFxuICAgICAgZCA9IGdmKCksIGUgPSBnZigpLCBmID0gZ2YoKTtcbiAgZm9yIChpID0gMDsgaSA8IDMxOyBpKyspIHpbaV0gPSBuW2ldO1xuICB6WzMxXT0oblszMV0mMTI3KXw2NDtcbiAgelswXSY9MjQ4O1xuICB1bnBhY2syNTUxOSh4LHApO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIGJbaV09eFtpXTtcbiAgICBkW2ldPWFbaV09Y1tpXT0wO1xuICB9XG4gIGFbMF09ZFswXT0xO1xuICBmb3IgKGk9MjU0OyBpPj0wOyAtLWkpIHtcbiAgICByPSh6W2k+Pj4zXT4+PihpJjcpKSYxO1xuICAgIHNlbDI1NTE5KGEsYixyKTtcbiAgICBzZWwyNTUxOShjLGQscik7XG4gICAgQShlLGEsYyk7XG4gICAgWihhLGEsYyk7XG4gICAgQShjLGIsZCk7XG4gICAgWihiLGIsZCk7XG4gICAgUyhkLGUpO1xuICAgIFMoZixhKTtcbiAgICBNKGEsYyxhKTtcbiAgICBNKGMsYixlKTtcbiAgICBBKGUsYSxjKTtcbiAgICBaKGEsYSxjKTtcbiAgICBTKGIsYSk7XG4gICAgWihjLGQsZik7XG4gICAgTShhLGMsXzEyMTY2NSk7XG4gICAgQShhLGEsZCk7XG4gICAgTShjLGMsYSk7XG4gICAgTShhLGQsZik7XG4gICAgTShkLGIseCk7XG4gICAgUyhiLGUpO1xuICAgIHNlbDI1NTE5KGEsYixyKTtcbiAgICBzZWwyNTUxOShjLGQscik7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB4W2krMTZdPWFbaV07XG4gICAgeFtpKzMyXT1jW2ldO1xuICAgIHhbaSs0OF09YltpXTtcbiAgICB4W2krNjRdPWRbaV07XG4gIH1cbiAgdmFyIHgzMiA9IHguc3ViYXJyYXkoMzIpO1xuICB2YXIgeDE2ID0geC5zdWJhcnJheSgxNik7XG4gIGludjI1NTE5KHgzMix4MzIpO1xuICBNKHgxNix4MTYseDMyKTtcbiAgcGFjazI1NTE5KHEseDE2KTtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UocSwgbikge1xuICByZXR1cm4gY3J5cHRvX3NjYWxhcm11bHQocSwgbiwgXzkpO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fYm94X2tleXBhaXIoeSwgeCkge1xuICByYW5kb21ieXRlcyh4LCAzMik7XG4gIHJldHVybiBjcnlwdG9fc2NhbGFybXVsdF9iYXNlKHksIHgpO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fYm94X2JlZm9yZW5tKGssIHksIHgpIHtcbiAgdmFyIHMgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGNyeXB0b19zY2FsYXJtdWx0KHMsIHgsIHkpO1xuICByZXR1cm4gY3J5cHRvX2NvcmVfaHNhbHNhMjAoaywgXzAsIHMsIHNpZ21hKTtcbn1cblxudmFyIGNyeXB0b19ib3hfYWZ0ZXJubSA9IGNyeXB0b19zZWNyZXRib3g7XG52YXIgY3J5cHRvX2JveF9vcGVuX2FmdGVybm0gPSBjcnlwdG9fc2VjcmV0Ym94X29wZW47XG5cbmZ1bmN0aW9uIGNyeXB0b19ib3goYywgbSwgZCwgbiwgeSwgeCkge1xuICB2YXIgayA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgY3J5cHRvX2JveF9iZWZvcmVubShrLCB5LCB4KTtcbiAgcmV0dXJuIGNyeXB0b19ib3hfYWZ0ZXJubShjLCBtLCBkLCBuLCBrKTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2JveF9vcGVuKG0sIGMsIGQsIG4sIHksIHgpIHtcbiAgdmFyIGsgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGNyeXB0b19ib3hfYmVmb3Jlbm0oaywgeSwgeCk7XG4gIHJldHVybiBjcnlwdG9fYm94X29wZW5fYWZ0ZXJubShtLCBjLCBkLCBuLCBrKTtcbn1cblxudmFyIEsgPSBbXG4gIDB4NDI4YTJmOTgsIDB4ZDcyOGFlMjIsIDB4NzEzNzQ0OTEsIDB4MjNlZjY1Y2QsXG4gIDB4YjVjMGZiY2YsIDB4ZWM0ZDNiMmYsIDB4ZTliNWRiYTUsIDB4ODE4OWRiYmMsXG4gIDB4Mzk1NmMyNWIsIDB4ZjM0OGI1MzgsIDB4NTlmMTExZjEsIDB4YjYwNWQwMTksXG4gIDB4OTIzZjgyYTQsIDB4YWYxOTRmOWIsIDB4YWIxYzVlZDUsIDB4ZGE2ZDgxMTgsXG4gIDB4ZDgwN2FhOTgsIDB4YTMwMzAyNDIsIDB4MTI4MzViMDEsIDB4NDU3MDZmYmUsXG4gIDB4MjQzMTg1YmUsIDB4NGVlNGIyOGMsIDB4NTUwYzdkYzMsIDB4ZDVmZmI0ZTIsXG4gIDB4NzJiZTVkNzQsIDB4ZjI3Yjg5NmYsIDB4ODBkZWIxZmUsIDB4M2IxNjk2YjEsXG4gIDB4OWJkYzA2YTcsIDB4MjVjNzEyMzUsIDB4YzE5YmYxNzQsIDB4Y2Y2OTI2OTQsXG4gIDB4ZTQ5YjY5YzEsIDB4OWVmMTRhZDIsIDB4ZWZiZTQ3ODYsIDB4Mzg0ZjI1ZTMsXG4gIDB4MGZjMTlkYzYsIDB4OGI4Y2Q1YjUsIDB4MjQwY2ExY2MsIDB4NzdhYzljNjUsXG4gIDB4MmRlOTJjNmYsIDB4NTkyYjAyNzUsIDB4NGE3NDg0YWEsIDB4NmVhNmU0ODMsXG4gIDB4NWNiMGE5ZGMsIDB4YmQ0MWZiZDQsIDB4NzZmOTg4ZGEsIDB4ODMxMTUzYjUsXG4gIDB4OTgzZTUxNTIsIDB4ZWU2NmRmYWIsIDB4YTgzMWM2NmQsIDB4MmRiNDMyMTAsXG4gIDB4YjAwMzI3YzgsIDB4OThmYjIxM2YsIDB4YmY1OTdmYzcsIDB4YmVlZjBlZTQsXG4gIDB4YzZlMDBiZjMsIDB4M2RhODhmYzIsIDB4ZDVhNzkxNDcsIDB4OTMwYWE3MjUsXG4gIDB4MDZjYTYzNTEsIDB4ZTAwMzgyNmYsIDB4MTQyOTI5NjcsIDB4MGEwZTZlNzAsXG4gIDB4MjdiNzBhODUsIDB4NDZkMjJmZmMsIDB4MmUxYjIxMzgsIDB4NWMyNmM5MjYsXG4gIDB4NGQyYzZkZmMsIDB4NWFjNDJhZWQsIDB4NTMzODBkMTMsIDB4OWQ5NWIzZGYsXG4gIDB4NjUwYTczNTQsIDB4OGJhZjYzZGUsIDB4NzY2YTBhYmIsIDB4M2M3N2IyYTgsXG4gIDB4ODFjMmM5MmUsIDB4NDdlZGFlZTYsIDB4OTI3MjJjODUsIDB4MTQ4MjM1M2IsXG4gIDB4YTJiZmU4YTEsIDB4NGNmMTAzNjQsIDB4YTgxYTY2NGIsIDB4YmM0MjMwMDEsXG4gIDB4YzI0YjhiNzAsIDB4ZDBmODk3OTEsIDB4Yzc2YzUxYTMsIDB4MDY1NGJlMzAsXG4gIDB4ZDE5MmU4MTksIDB4ZDZlZjUyMTgsIDB4ZDY5OTA2MjQsIDB4NTU2NWE5MTAsXG4gIDB4ZjQwZTM1ODUsIDB4NTc3MTIwMmEsIDB4MTA2YWEwNzAsIDB4MzJiYmQxYjgsXG4gIDB4MTlhNGMxMTYsIDB4YjhkMmQwYzgsIDB4MWUzNzZjMDgsIDB4NTE0MWFiNTMsXG4gIDB4Mjc0ODc3NGMsIDB4ZGY4ZWViOTksIDB4MzRiMGJjYjUsIDB4ZTE5YjQ4YTgsXG4gIDB4MzkxYzBjYjMsIDB4YzVjOTVhNjMsIDB4NGVkOGFhNGEsIDB4ZTM0MThhY2IsXG4gIDB4NWI5Y2NhNGYsIDB4Nzc2M2UzNzMsIDB4NjgyZTZmZjMsIDB4ZDZiMmI4YTMsXG4gIDB4NzQ4ZjgyZWUsIDB4NWRlZmIyZmMsIDB4NzhhNTYzNmYsIDB4NDMxNzJmNjAsXG4gIDB4ODRjODc4MTQsIDB4YTFmMGFiNzIsIDB4OGNjNzAyMDgsIDB4MWE2NDM5ZWMsXG4gIDB4OTBiZWZmZmEsIDB4MjM2MzFlMjgsIDB4YTQ1MDZjZWIsIDB4ZGU4MmJkZTksXG4gIDB4YmVmOWEzZjcsIDB4YjJjNjc5MTUsIDB4YzY3MTc4ZjIsIDB4ZTM3MjUzMmIsXG4gIDB4Y2EyNzNlY2UsIDB4ZWEyNjYxOWMsIDB4ZDE4NmI4YzcsIDB4MjFjMGMyMDcsXG4gIDB4ZWFkYTdkZDYsIDB4Y2RlMGViMWUsIDB4ZjU3ZDRmN2YsIDB4ZWU2ZWQxNzgsXG4gIDB4MDZmMDY3YWEsIDB4NzIxNzZmYmEsIDB4MGE2MzdkYzUsIDB4YTJjODk4YTYsXG4gIDB4MTEzZjk4MDQsIDB4YmVmOTBkYWUsIDB4MWI3MTBiMzUsIDB4MTMxYzQ3MWIsXG4gIDB4MjhkYjc3ZjUsIDB4MjMwNDdkODQsIDB4MzJjYWFiN2IsIDB4NDBjNzI0OTMsXG4gIDB4M2M5ZWJlMGEsIDB4MTVjOWJlYmMsIDB4NDMxZDY3YzQsIDB4OWMxMDBkNGMsXG4gIDB4NGNjNWQ0YmUsIDB4Y2IzZTQyYjYsIDB4NTk3ZjI5OWMsIDB4ZmM2NTdlMmEsXG4gIDB4NWZjYjZmYWIsIDB4M2FkNmZhZWMsIDB4NmM0NDE5OGMsIDB4NGE0NzU4MTdcbl07XG5cbmZ1bmN0aW9uIGNyeXB0b19oYXNoYmxvY2tzX2hsKGhoLCBobCwgbSwgbikge1xuICB2YXIgd2ggPSBuZXcgSW50MzJBcnJheSgxNiksIHdsID0gbmV3IEludDMyQXJyYXkoMTYpLFxuICAgICAgYmgwLCBiaDEsIGJoMiwgYmgzLCBiaDQsIGJoNSwgYmg2LCBiaDcsXG4gICAgICBibDAsIGJsMSwgYmwyLCBibDMsIGJsNCwgYmw1LCBibDYsIGJsNyxcbiAgICAgIHRoLCB0bCwgaSwgaiwgaCwgbCwgYSwgYiwgYywgZDtcblxuICB2YXIgYWgwID0gaGhbMF0sXG4gICAgICBhaDEgPSBoaFsxXSxcbiAgICAgIGFoMiA9IGhoWzJdLFxuICAgICAgYWgzID0gaGhbM10sXG4gICAgICBhaDQgPSBoaFs0XSxcbiAgICAgIGFoNSA9IGhoWzVdLFxuICAgICAgYWg2ID0gaGhbNl0sXG4gICAgICBhaDcgPSBoaFs3XSxcblxuICAgICAgYWwwID0gaGxbMF0sXG4gICAgICBhbDEgPSBobFsxXSxcbiAgICAgIGFsMiA9IGhsWzJdLFxuICAgICAgYWwzID0gaGxbM10sXG4gICAgICBhbDQgPSBobFs0XSxcbiAgICAgIGFsNSA9IGhsWzVdLFxuICAgICAgYWw2ID0gaGxbNl0sXG4gICAgICBhbDcgPSBobFs3XTtcblxuICB2YXIgcG9zID0gMDtcbiAgd2hpbGUgKG4gPj0gMTI4KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgIGogPSA4ICogaSArIHBvcztcbiAgICAgIHdoW2ldID0gKG1baiswXSA8PCAyNCkgfCAobVtqKzFdIDw8IDE2KSB8IChtW2orMl0gPDwgOCkgfCBtW2orM107XG4gICAgICB3bFtpXSA9IChtW2orNF0gPDwgMjQpIHwgKG1bais1XSA8PCAxNikgfCAobVtqKzZdIDw8IDgpIHwgbVtqKzddO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgYmgwID0gYWgwO1xuICAgICAgYmgxID0gYWgxO1xuICAgICAgYmgyID0gYWgyO1xuICAgICAgYmgzID0gYWgzO1xuICAgICAgYmg0ID0gYWg0O1xuICAgICAgYmg1ID0gYWg1O1xuICAgICAgYmg2ID0gYWg2O1xuICAgICAgYmg3ID0gYWg3O1xuXG4gICAgICBibDAgPSBhbDA7XG4gICAgICBibDEgPSBhbDE7XG4gICAgICBibDIgPSBhbDI7XG4gICAgICBibDMgPSBhbDM7XG4gICAgICBibDQgPSBhbDQ7XG4gICAgICBibDUgPSBhbDU7XG4gICAgICBibDYgPSBhbDY7XG4gICAgICBibDcgPSBhbDc7XG5cbiAgICAgIC8vIGFkZFxuICAgICAgaCA9IGFoNztcbiAgICAgIGwgPSBhbDc7XG5cbiAgICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgICAvLyBTaWdtYTFcbiAgICAgIGggPSAoKGFoNCA+Pj4gMTQpIHwgKGFsNCA8PCAoMzItMTQpKSkgXiAoKGFoNCA+Pj4gMTgpIHwgKGFsNCA8PCAoMzItMTgpKSkgXiAoKGFsNCA+Pj4gKDQxLTMyKSkgfCAoYWg0IDw8ICgzMi0oNDEtMzIpKSkpO1xuICAgICAgbCA9ICgoYWw0ID4+PiAxNCkgfCAoYWg0IDw8ICgzMi0xNCkpKSBeICgoYWw0ID4+PiAxOCkgfCAoYWg0IDw8ICgzMi0xOCkpKSBeICgoYWg0ID4+PiAoNDEtMzIpKSB8IChhbDQgPDwgKDMyLSg0MS0zMikpKSk7XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgLy8gQ2hcbiAgICAgIGggPSAoYWg0ICYgYWg1KSBeICh+YWg0ICYgYWg2KTtcbiAgICAgIGwgPSAoYWw0ICYgYWw1KSBeICh+YWw0ICYgYWw2KTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAvLyBLXG4gICAgICBoID0gS1tpKjJdO1xuICAgICAgbCA9IEtbaSoyKzFdO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIHdcbiAgICAgIGggPSB3aFtpJTE2XTtcbiAgICAgIGwgPSB3bFtpJTE2XTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICBiICs9IGEgPj4+IDE2O1xuICAgICAgYyArPSBiID4+PiAxNjtcbiAgICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICAgIHRoID0gYyAmIDB4ZmZmZiB8IGQgPDwgMTY7XG4gICAgICB0bCA9IGEgJiAweGZmZmYgfCBiIDw8IDE2O1xuXG4gICAgICAvLyBhZGRcbiAgICAgIGggPSB0aDtcbiAgICAgIGwgPSB0bDtcblxuICAgICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIFNpZ21hMFxuICAgICAgaCA9ICgoYWgwID4+PiAyOCkgfCAoYWwwIDw8ICgzMi0yOCkpKSBeICgoYWwwID4+PiAoMzQtMzIpKSB8IChhaDAgPDwgKDMyLSgzNC0zMikpKSkgXiAoKGFsMCA+Pj4gKDM5LTMyKSkgfCAoYWgwIDw8ICgzMi0oMzktMzIpKSkpO1xuICAgICAgbCA9ICgoYWwwID4+PiAyOCkgfCAoYWgwIDw8ICgzMi0yOCkpKSBeICgoYWgwID4+PiAoMzQtMzIpKSB8IChhbDAgPDwgKDMyLSgzNC0zMikpKSkgXiAoKGFoMCA+Pj4gKDM5LTMyKSkgfCAoYWwwIDw8ICgzMi0oMzktMzIpKSkpO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIE1halxuICAgICAgaCA9IChhaDAgJiBhaDEpIF4gKGFoMCAmIGFoMikgXiAoYWgxICYgYWgyKTtcbiAgICAgIGwgPSAoYWwwICYgYWwxKSBeIChhbDAgJiBhbDIpIF4gKGFsMSAmIGFsMik7XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgYiArPSBhID4+PiAxNjtcbiAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgICBiaDcgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgICBibDcgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICAgIC8vIGFkZFxuICAgICAgaCA9IGJoMztcbiAgICAgIGwgPSBibDM7XG5cbiAgICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgICBoID0gdGg7XG4gICAgICBsID0gdGw7XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgYiArPSBhID4+PiAxNjtcbiAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgICBiaDMgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgICBibDMgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICAgIGFoMSA9IGJoMDtcbiAgICAgIGFoMiA9IGJoMTtcbiAgICAgIGFoMyA9IGJoMjtcbiAgICAgIGFoNCA9IGJoMztcbiAgICAgIGFoNSA9IGJoNDtcbiAgICAgIGFoNiA9IGJoNTtcbiAgICAgIGFoNyA9IGJoNjtcbiAgICAgIGFoMCA9IGJoNztcblxuICAgICAgYWwxID0gYmwwO1xuICAgICAgYWwyID0gYmwxO1xuICAgICAgYWwzID0gYmwyO1xuICAgICAgYWw0ID0gYmwzO1xuICAgICAgYWw1ID0gYmw0O1xuICAgICAgYWw2ID0gYmw1O1xuICAgICAgYWw3ID0gYmw2O1xuICAgICAgYWwwID0gYmw3O1xuXG4gICAgICBpZiAoaSUxNiA9PT0gMTUpIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IDE2OyBqKyspIHtcbiAgICAgICAgICAvLyBhZGRcbiAgICAgICAgICBoID0gd2hbal07XG4gICAgICAgICAgbCA9IHdsW2pdO1xuXG4gICAgICAgICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICAgICAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgICAgICAgaCA9IHdoWyhqKzkpJTE2XTtcbiAgICAgICAgICBsID0gd2xbKGorOSklMTZdO1xuXG4gICAgICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgICAgIC8vIHNpZ21hMFxuICAgICAgICAgIHRoID0gd2hbKGorMSklMTZdO1xuICAgICAgICAgIHRsID0gd2xbKGorMSklMTZdO1xuICAgICAgICAgIGggPSAoKHRoID4+PiAxKSB8ICh0bCA8PCAoMzItMSkpKSBeICgodGggPj4+IDgpIHwgKHRsIDw8ICgzMi04KSkpIF4gKHRoID4+PiA3KTtcbiAgICAgICAgICBsID0gKCh0bCA+Pj4gMSkgfCAodGggPDwgKDMyLTEpKSkgXiAoKHRsID4+PiA4KSB8ICh0aCA8PCAoMzItOCkpKSBeICgodGwgPj4+IDcpIHwgKHRoIDw8ICgzMi03KSkpO1xuXG4gICAgICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgICAgIC8vIHNpZ21hMVxuICAgICAgICAgIHRoID0gd2hbKGorMTQpJTE2XTtcbiAgICAgICAgICB0bCA9IHdsWyhqKzE0KSUxNl07XG4gICAgICAgICAgaCA9ICgodGggPj4+IDE5KSB8ICh0bCA8PCAoMzItMTkpKSkgXiAoKHRsID4+PiAoNjEtMzIpKSB8ICh0aCA8PCAoMzItKDYxLTMyKSkpKSBeICh0aCA+Pj4gNik7XG4gICAgICAgICAgbCA9ICgodGwgPj4+IDE5KSB8ICh0aCA8PCAoMzItMTkpKSkgXiAoKHRoID4+PiAoNjEtMzIpKSB8ICh0bCA8PCAoMzItKDYxLTMyKSkpKSBeICgodGwgPj4+IDYpIHwgKHRoIDw8ICgzMi02KSkpO1xuXG4gICAgICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgICAgICAgYyArPSBiID4+PiAxNjtcbiAgICAgICAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgICAgICAgd2hbal0gPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgICAgICAgd2xbal0gPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGRcbiAgICBoID0gYWgwO1xuICAgIGwgPSBhbDA7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbMF07XG4gICAgbCA9IGhsWzBdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbMF0gPSBhaDAgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbMF0gPSBhbDAgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWgxO1xuICAgIGwgPSBhbDE7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbMV07XG4gICAgbCA9IGhsWzFdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbMV0gPSBhaDEgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbMV0gPSBhbDEgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWgyO1xuICAgIGwgPSBhbDI7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbMl07XG4gICAgbCA9IGhsWzJdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbMl0gPSBhaDIgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbMl0gPSBhbDIgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWgzO1xuICAgIGwgPSBhbDM7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbM107XG4gICAgbCA9IGhsWzNdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbM10gPSBhaDMgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbM10gPSBhbDMgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWg0O1xuICAgIGwgPSBhbDQ7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbNF07XG4gICAgbCA9IGhsWzRdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbNF0gPSBhaDQgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbNF0gPSBhbDQgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWg1O1xuICAgIGwgPSBhbDU7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbNV07XG4gICAgbCA9IGhsWzVdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbNV0gPSBhaDUgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbNV0gPSBhbDUgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWg2O1xuICAgIGwgPSBhbDY7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbNl07XG4gICAgbCA9IGhsWzZdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbNl0gPSBhaDYgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbNl0gPSBhbDYgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWg3O1xuICAgIGwgPSBhbDc7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbN107XG4gICAgbCA9IGhsWzddO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbN10gPSBhaDcgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbN10gPSBhbDcgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBwb3MgKz0gMTI4O1xuICAgIG4gLT0gMTI4O1xuICB9XG5cbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19oYXNoKG91dCwgbSwgbikge1xuICB2YXIgaGggPSBuZXcgSW50MzJBcnJheSg4KSxcbiAgICAgIGhsID0gbmV3IEludDMyQXJyYXkoOCksXG4gICAgICB4ID0gbmV3IFVpbnQ4QXJyYXkoMjU2KSxcbiAgICAgIGksIGIgPSBuO1xuXG4gIGhoWzBdID0gMHg2YTA5ZTY2NztcbiAgaGhbMV0gPSAweGJiNjdhZTg1O1xuICBoaFsyXSA9IDB4M2M2ZWYzNzI7XG4gIGhoWzNdID0gMHhhNTRmZjUzYTtcbiAgaGhbNF0gPSAweDUxMGU1MjdmO1xuICBoaFs1XSA9IDB4OWIwNTY4OGM7XG4gIGhoWzZdID0gMHgxZjgzZDlhYjtcbiAgaGhbN10gPSAweDViZTBjZDE5O1xuXG4gIGhsWzBdID0gMHhmM2JjYzkwODtcbiAgaGxbMV0gPSAweDg0Y2FhNzNiO1xuICBobFsyXSA9IDB4ZmU5NGY4MmI7XG4gIGhsWzNdID0gMHg1ZjFkMzZmMTtcbiAgaGxbNF0gPSAweGFkZTY4MmQxO1xuICBobFs1XSA9IDB4MmIzZTZjMWY7XG4gIGhsWzZdID0gMHhmYjQxYmQ2YjtcbiAgaGxbN10gPSAweDEzN2UyMTc5O1xuXG4gIGNyeXB0b19oYXNoYmxvY2tzX2hsKGhoLCBobCwgbSwgbik7XG4gIG4gJT0gMTI4O1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHhbaV0gPSBtW2ItbitpXTtcbiAgeFtuXSA9IDEyODtcblxuICBuID0gMjU2LTEyOCoobjwxMTI/MTowKTtcbiAgeFtuLTldID0gMDtcbiAgdHM2NCh4LCBuLTgsICAoYiAvIDB4MjAwMDAwMDApIHwgMCwgYiA8PCAzKTtcbiAgY3J5cHRvX2hhc2hibG9ja3NfaGwoaGgsIGhsLCB4LCBuKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgODsgaSsrKSB0czY0KG91dCwgOCppLCBoaFtpXSwgaGxbaV0pO1xuXG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBhZGQocCwgcSkge1xuICB2YXIgYSA9IGdmKCksIGIgPSBnZigpLCBjID0gZ2YoKSxcbiAgICAgIGQgPSBnZigpLCBlID0gZ2YoKSwgZiA9IGdmKCksXG4gICAgICBnID0gZ2YoKSwgaCA9IGdmKCksIHQgPSBnZigpO1xuXG4gIFooYSwgcFsxXSwgcFswXSk7XG4gIFoodCwgcVsxXSwgcVswXSk7XG4gIE0oYSwgYSwgdCk7XG4gIEEoYiwgcFswXSwgcFsxXSk7XG4gIEEodCwgcVswXSwgcVsxXSk7XG4gIE0oYiwgYiwgdCk7XG4gIE0oYywgcFszXSwgcVszXSk7XG4gIE0oYywgYywgRDIpO1xuICBNKGQsIHBbMl0sIHFbMl0pO1xuICBBKGQsIGQsIGQpO1xuICBaKGUsIGIsIGEpO1xuICBaKGYsIGQsIGMpO1xuICBBKGcsIGQsIGMpO1xuICBBKGgsIGIsIGEpO1xuXG4gIE0ocFswXSwgZSwgZik7XG4gIE0ocFsxXSwgaCwgZyk7XG4gIE0ocFsyXSwgZywgZik7XG4gIE0ocFszXSwgZSwgaCk7XG59XG5cbmZ1bmN0aW9uIGNzd2FwKHAsIHEsIGIpIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBzZWwyNTUxOShwW2ldLCBxW2ldLCBiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYWNrKHIsIHApIHtcbiAgdmFyIHR4ID0gZ2YoKSwgdHkgPSBnZigpLCB6aSA9IGdmKCk7XG4gIGludjI1NTE5KHppLCBwWzJdKTtcbiAgTSh0eCwgcFswXSwgemkpO1xuICBNKHR5LCBwWzFdLCB6aSk7XG4gIHBhY2syNTUxOShyLCB0eSk7XG4gIHJbMzFdIF49IHBhcjI1NTE5KHR4KSA8PCA3O1xufVxuXG5mdW5jdGlvbiBzY2FsYXJtdWx0KHAsIHEsIHMpIHtcbiAgdmFyIGIsIGk7XG4gIHNldDI1NTE5KHBbMF0sIGdmMCk7XG4gIHNldDI1NTE5KHBbMV0sIGdmMSk7XG4gIHNldDI1NTE5KHBbMl0sIGdmMSk7XG4gIHNldDI1NTE5KHBbM10sIGdmMCk7XG4gIGZvciAoaSA9IDI1NTsgaSA+PSAwOyAtLWkpIHtcbiAgICBiID0gKHNbKGkvOCl8MF0gPj4gKGkmNykpICYgMTtcbiAgICBjc3dhcChwLCBxLCBiKTtcbiAgICBhZGQocSwgcCk7XG4gICAgYWRkKHAsIHApO1xuICAgIGNzd2FwKHAsIHEsIGIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjYWxhcmJhc2UocCwgcykge1xuICB2YXIgcSA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXTtcbiAgc2V0MjU1MTkocVswXSwgWCk7XG4gIHNldDI1NTE5KHFbMV0sIFkpO1xuICBzZXQyNTUxOShxWzJdLCBnZjEpO1xuICBNKHFbM10sIFgsIFkpO1xuICBzY2FsYXJtdWx0KHAsIHEsIHMpO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2lnbl9rZXlwYWlyKHBrLCBzaywgc2VlZGVkKSB7XG4gIHZhciBkID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICB2YXIgcCA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXTtcbiAgdmFyIGk7XG5cbiAgaWYgKCFzZWVkZWQpIHJhbmRvbWJ5dGVzKHNrLCAzMik7XG4gIGNyeXB0b19oYXNoKGQsIHNrLCAzMik7XG4gIGRbMF0gJj0gMjQ4O1xuICBkWzMxXSAmPSAxMjc7XG4gIGRbMzFdIHw9IDY0O1xuXG4gIHNjYWxhcmJhc2UocCwgZCk7XG4gIHBhY2socGssIHApO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBza1tpKzMyXSA9IHBrW2ldO1xuICByZXR1cm4gMDtcbn1cblxudmFyIEwgPSBuZXcgRmxvYXQ2NEFycmF5KFsweGVkLCAweGQzLCAweGY1LCAweDVjLCAweDFhLCAweDYzLCAweDEyLCAweDU4LCAweGQ2LCAweDljLCAweGY3LCAweGEyLCAweGRlLCAweGY5LCAweGRlLCAweDE0LCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAweDEwXSk7XG5cbmZ1bmN0aW9uIG1vZEwociwgeCkge1xuICB2YXIgY2FycnksIGksIGosIGs7XG4gIGZvciAoaSA9IDYzOyBpID49IDMyOyAtLWkpIHtcbiAgICBjYXJyeSA9IDA7XG4gICAgZm9yIChqID0gaSAtIDMyLCBrID0gaSAtIDEyOyBqIDwgazsgKytqKSB7XG4gICAgICB4W2pdICs9IGNhcnJ5IC0gMTYgKiB4W2ldICogTFtqIC0gKGkgLSAzMildO1xuICAgICAgY2FycnkgPSBNYXRoLmZsb29yKCh4W2pdICsgMTI4KSAvIDI1Nik7XG4gICAgICB4W2pdIC09IGNhcnJ5ICogMjU2O1xuICAgIH1cbiAgICB4W2pdICs9IGNhcnJ5O1xuICAgIHhbaV0gPSAwO1xuICB9XG4gIGNhcnJ5ID0gMDtcbiAgZm9yIChqID0gMDsgaiA8IDMyOyBqKyspIHtcbiAgICB4W2pdICs9IGNhcnJ5IC0gKHhbMzFdID4+IDQpICogTFtqXTtcbiAgICBjYXJyeSA9IHhbal0gPj4gODtcbiAgICB4W2pdICY9IDI1NTtcbiAgfVxuICBmb3IgKGogPSAwOyBqIDwgMzI7IGorKykgeFtqXSAtPSBjYXJyeSAqIExbal07XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgeFtpKzFdICs9IHhbaV0gPj4gODtcbiAgICByW2ldID0geFtpXSAmIDI1NTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2Uocikge1xuICB2YXIgeCA9IG5ldyBGbG9hdDY0QXJyYXkoNjQpLCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgeFtpXSA9IHJbaV07XG4gIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSByW2ldID0gMDtcbiAgbW9kTChyLCB4KTtcbn1cblxuLy8gTm90ZTogZGlmZmVyZW5jZSBmcm9tIEMgLSBzbWxlbiByZXR1cm5lZCwgbm90IHBhc3NlZCBhcyBhcmd1bWVudC5cbmZ1bmN0aW9uIGNyeXB0b19zaWduKHNtLCBtLCBuLCBzaykge1xuICB2YXIgZCA9IG5ldyBVaW50OEFycmF5KDY0KSwgaCA9IG5ldyBVaW50OEFycmF5KDY0KSwgciA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIGksIGosIHggPSBuZXcgRmxvYXQ2NEFycmF5KDY0KTtcbiAgdmFyIHAgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG5cbiAgY3J5cHRvX2hhc2goZCwgc2ssIDMyKTtcbiAgZFswXSAmPSAyNDg7XG4gIGRbMzFdICY9IDEyNztcbiAgZFszMV0gfD0gNjQ7XG5cbiAgdmFyIHNtbGVuID0gbiArIDY0O1xuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBzbVs2NCArIGldID0gbVtpXTtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHNtWzMyICsgaV0gPSBkWzMyICsgaV07XG5cbiAgY3J5cHRvX2hhc2gociwgc20uc3ViYXJyYXkoMzIpLCBuKzMyKTtcbiAgcmVkdWNlKHIpO1xuICBzY2FsYXJiYXNlKHAsIHIpO1xuICBwYWNrKHNtLCBwKTtcblxuICBmb3IgKGkgPSAzMjsgaSA8IDY0OyBpKyspIHNtW2ldID0gc2tbaV07XG4gIGNyeXB0b19oYXNoKGgsIHNtLCBuICsgNjQpO1xuICByZWR1Y2UoaCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHhbaV0gPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykgeFtpXSA9IHJbaV07XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgZm9yIChqID0gMDsgaiA8IDMyOyBqKyspIHtcbiAgICAgIHhbaStqXSArPSBoW2ldICogZFtqXTtcbiAgICB9XG4gIH1cblxuICBtb2RMKHNtLnN1YmFycmF5KDMyKSwgeCk7XG4gIHJldHVybiBzbWxlbjtcbn1cblxuZnVuY3Rpb24gdW5wYWNrbmVnKHIsIHApIHtcbiAgdmFyIHQgPSBnZigpLCBjaGsgPSBnZigpLCBudW0gPSBnZigpLFxuICAgICAgZGVuID0gZ2YoKSwgZGVuMiA9IGdmKCksIGRlbjQgPSBnZigpLFxuICAgICAgZGVuNiA9IGdmKCk7XG5cbiAgc2V0MjU1MTkoclsyXSwgZ2YxKTtcbiAgdW5wYWNrMjU1MTkoclsxXSwgcCk7XG4gIFMobnVtLCByWzFdKTtcbiAgTShkZW4sIG51bSwgRCk7XG4gIFoobnVtLCBudW0sIHJbMl0pO1xuICBBKGRlbiwgclsyXSwgZGVuKTtcblxuICBTKGRlbjIsIGRlbik7XG4gIFMoZGVuNCwgZGVuMik7XG4gIE0oZGVuNiwgZGVuNCwgZGVuMik7XG4gIE0odCwgZGVuNiwgbnVtKTtcbiAgTSh0LCB0LCBkZW4pO1xuXG4gIHBvdzI1MjModCwgdCk7XG4gIE0odCwgdCwgbnVtKTtcbiAgTSh0LCB0LCBkZW4pO1xuICBNKHQsIHQsIGRlbik7XG4gIE0oclswXSwgdCwgZGVuKTtcblxuICBTKGNoaywgclswXSk7XG4gIE0oY2hrLCBjaGssIGRlbik7XG4gIGlmIChuZXEyNTUxOShjaGssIG51bSkpIE0oclswXSwgclswXSwgSSk7XG5cbiAgUyhjaGssIHJbMF0pO1xuICBNKGNoaywgY2hrLCBkZW4pO1xuICBpZiAobmVxMjU1MTkoY2hrLCBudW0pKSByZXR1cm4gLTE7XG5cbiAgaWYgKHBhcjI1NTE5KHJbMF0pID09PSAocFszMV0+PjcpKSBaKHJbMF0sIGdmMCwgclswXSk7XG5cbiAgTShyWzNdLCByWzBdLCByWzFdKTtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zaWduX29wZW4obSwgc20sIG4sIHBrKSB7XG4gIHZhciBpO1xuICB2YXIgdCA9IG5ldyBVaW50OEFycmF5KDMyKSwgaCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgdmFyIHAgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV0sXG4gICAgICBxID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldO1xuXG4gIGlmIChuIDwgNjQpIHJldHVybiAtMTtcblxuICBpZiAodW5wYWNrbmVnKHEsIHBrKSkgcmV0dXJuIC0xO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIG1baV0gPSBzbVtpXTtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIG1baSszMl0gPSBwa1tpXTtcbiAgY3J5cHRvX2hhc2goaCwgbSwgbik7XG4gIHJlZHVjZShoKTtcbiAgc2NhbGFybXVsdChwLCBxLCBoKTtcblxuICBzY2FsYXJiYXNlKHEsIHNtLnN1YmFycmF5KDMyKSk7XG4gIGFkZChwLCBxKTtcbiAgcGFjayh0LCBwKTtcblxuICBuIC09IDY0O1xuICBpZiAoY3J5cHRvX3ZlcmlmeV8zMihzbSwgMCwgdCwgMCkpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBtW2ldID0gMDtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBtW2ldID0gc21baSArIDY0XTtcbiAgcmV0dXJuIG47XG59XG5cbnZhciBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTID0gMzIsXG4gICAgY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTID0gMjQsXG4gICAgY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMgPSAzMixcbiAgICBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyA9IDE2LFxuICAgIGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTID0gMzIsXG4gICAgY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVMgPSAzMixcbiAgICBjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTID0gMzIsXG4gICAgY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUyA9IDMyLFxuICAgIGNyeXB0b19ib3hfTk9OQ0VCWVRFUyA9IGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUyxcbiAgICBjcnlwdG9fYm94X1pFUk9CWVRFUyA9IGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTLFxuICAgIGNyeXB0b19ib3hfQk9YWkVST0JZVEVTID0gY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMsXG4gICAgY3J5cHRvX3NpZ25fQllURVMgPSA2NCxcbiAgICBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTID0gNjQsXG4gICAgY3J5cHRvX3NpZ25fU0VFREJZVEVTID0gMzIsXG4gICAgY3J5cHRvX2hhc2hfQllURVMgPSA2NDtcblxubmFjbC5sb3dsZXZlbCA9IHtcbiAgY3J5cHRvX2NvcmVfaHNhbHNhMjA6IGNyeXB0b19jb3JlX2hzYWxzYTIwLFxuICBjcnlwdG9fc3RyZWFtX3hvcjogY3J5cHRvX3N0cmVhbV94b3IsXG4gIGNyeXB0b19zdHJlYW06IGNyeXB0b19zdHJlYW0sXG4gIGNyeXB0b19zdHJlYW1fc2Fsc2EyMF94b3I6IGNyeXB0b19zdHJlYW1fc2Fsc2EyMF94b3IsXG4gIGNyeXB0b19zdHJlYW1fc2Fsc2EyMDogY3J5cHRvX3N0cmVhbV9zYWxzYTIwLFxuICBjcnlwdG9fb25ldGltZWF1dGg6IGNyeXB0b19vbmV0aW1lYXV0aCxcbiAgY3J5cHRvX29uZXRpbWVhdXRoX3ZlcmlmeTogY3J5cHRvX29uZXRpbWVhdXRoX3ZlcmlmeSxcbiAgY3J5cHRvX3ZlcmlmeV8xNjogY3J5cHRvX3ZlcmlmeV8xNixcbiAgY3J5cHRvX3ZlcmlmeV8zMjogY3J5cHRvX3ZlcmlmeV8zMixcbiAgY3J5cHRvX3NlY3JldGJveDogY3J5cHRvX3NlY3JldGJveCxcbiAgY3J5cHRvX3NlY3JldGJveF9vcGVuOiBjcnlwdG9fc2VjcmV0Ym94X29wZW4sXG4gIGNyeXB0b19zY2FsYXJtdWx0OiBjcnlwdG9fc2NhbGFybXVsdCxcbiAgY3J5cHRvX3NjYWxhcm11bHRfYmFzZTogY3J5cHRvX3NjYWxhcm11bHRfYmFzZSxcbiAgY3J5cHRvX2JveF9iZWZvcmVubTogY3J5cHRvX2JveF9iZWZvcmVubSxcbiAgY3J5cHRvX2JveF9hZnRlcm5tOiBjcnlwdG9fYm94X2FmdGVybm0sXG4gIGNyeXB0b19ib3g6IGNyeXB0b19ib3gsXG4gIGNyeXB0b19ib3hfb3BlbjogY3J5cHRvX2JveF9vcGVuLFxuICBjcnlwdG9fYm94X2tleXBhaXI6IGNyeXB0b19ib3hfa2V5cGFpcixcbiAgY3J5cHRvX2hhc2g6IGNyeXB0b19oYXNoLFxuICBjcnlwdG9fc2lnbjogY3J5cHRvX3NpZ24sXG4gIGNyeXB0b19zaWduX2tleXBhaXI6IGNyeXB0b19zaWduX2tleXBhaXIsXG4gIGNyeXB0b19zaWduX29wZW46IGNyeXB0b19zaWduX29wZW4sXG5cbiAgY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUzogY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUyxcbiAgY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTOiBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMsXG4gIGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTOiBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyxcbiAgY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVM6IGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTLFxuICBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUzogY3J5cHRvX3NjYWxhcm11bHRfQllURVMsXG4gIGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTOiBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUyxcbiAgY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUzogY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUyxcbiAgY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUzogY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUyxcbiAgY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTOiBjcnlwdG9fYm94X0JFRk9SRU5NQllURVMsXG4gIGNyeXB0b19ib3hfTk9OQ0VCWVRFUzogY3J5cHRvX2JveF9OT05DRUJZVEVTLFxuICBjcnlwdG9fYm94X1pFUk9CWVRFUzogY3J5cHRvX2JveF9aRVJPQllURVMsXG4gIGNyeXB0b19ib3hfQk9YWkVST0JZVEVTOiBjcnlwdG9fYm94X0JPWFpFUk9CWVRFUyxcbiAgY3J5cHRvX3NpZ25fQllURVM6IGNyeXB0b19zaWduX0JZVEVTLFxuICBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUzogY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMsXG4gIGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTOiBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUyxcbiAgY3J5cHRvX3NpZ25fU0VFREJZVEVTOiBjcnlwdG9fc2lnbl9TRUVEQllURVMsXG4gIGNyeXB0b19oYXNoX0JZVEVTOiBjcnlwdG9faGFzaF9CWVRFUyxcblxuICBnZjogZ2YsXG4gIEQ6IEQsXG4gIEw6IEwsXG4gIHBhY2syNTUxOTogcGFjazI1NTE5LFxuICB1bnBhY2syNTUxOTogdW5wYWNrMjU1MTksXG4gIE06IE0sXG4gIEE6IEEsXG4gIFM6IFMsXG4gIFo6IFosXG4gIHBvdzI1MjM6IHBvdzI1MjMsXG4gIGFkZDogYWRkLFxuICBzZXQyNTUxOTogc2V0MjU1MTksXG4gIG1vZEw6IG1vZEwsXG4gIHNjYWxhcm11bHQ6IHNjYWxhcm11bHQsXG4gIHNjYWxhcmJhc2U6IHNjYWxhcmJhc2UsXG59O1xuXG4vKiBIaWdoLWxldmVsIEFQSSAqL1xuXG5mdW5jdGlvbiBjaGVja0xlbmd0aHMoaywgbikge1xuICBpZiAoay5sZW5ndGggIT09IGNyeXB0b19zZWNyZXRib3hfS0VZQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIGtleSBzaXplJyk7XG4gIGlmIChuLmxlbmd0aCAhPT0gY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBub25jZSBzaXplJyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQm94TGVuZ3Rocyhwaywgc2spIHtcbiAgaWYgKHBrLmxlbmd0aCAhPT0gY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgcHVibGljIGtleSBzaXplJyk7XG4gIGlmIChzay5sZW5ndGggIT09IGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xufVxuXG5mdW5jdGlvbiBjaGVja0FycmF5VHlwZXMoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCEoYXJndW1lbnRzW2ldIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmV4cGVjdGVkIHR5cGUsIHVzZSBVaW50OEFycmF5Jyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xlYW51cChhcnIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycltpXSA9IDA7XG59XG5cbm5hY2wucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihuKSB7XG4gIHZhciBiID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gIHJhbmRvbWJ5dGVzKGIsIG4pO1xuICByZXR1cm4gYjtcbn07XG5cbm5hY2wuc2VjcmV0Ym94ID0gZnVuY3Rpb24obXNnLCBub25jZSwga2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhtc2csIG5vbmNlLCBrZXkpO1xuICBjaGVja0xlbmd0aHMoa2V5LCBub25jZSk7XG4gIHZhciBtID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMgKyBtc2cubGVuZ3RoKTtcbiAgdmFyIGMgPSBuZXcgVWludDhBcnJheShtLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSBtW2krY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVNdID0gbXNnW2ldO1xuICBjcnlwdG9fc2VjcmV0Ym94KGMsIG0sIG0ubGVuZ3RoLCBub25jZSwga2V5KTtcbiAgcmV0dXJuIGMuc3ViYXJyYXkoY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMpO1xufTtcblxubmFjbC5zZWNyZXRib3gub3BlbiA9IGZ1bmN0aW9uKGJveCwgbm9uY2UsIGtleSkge1xuICBjaGVja0FycmF5VHlwZXMoYm94LCBub25jZSwga2V5KTtcbiAgY2hlY2tMZW5ndGhzKGtleSwgbm9uY2UpO1xuICB2YXIgYyA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTICsgYm94Lmxlbmd0aCk7XG4gIHZhciBtID0gbmV3IFVpbnQ4QXJyYXkoYy5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJveC5sZW5ndGg7IGkrKykgY1tpK2NyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTXSA9IGJveFtpXTtcbiAgaWYgKGMubGVuZ3RoIDwgMzIpIHJldHVybiBudWxsO1xuICBpZiAoY3J5cHRvX3NlY3JldGJveF9vcGVuKG0sIGMsIGMubGVuZ3RoLCBub25jZSwga2V5KSAhPT0gMCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiBtLnN1YmFycmF5KGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTKTtcbn07XG5cbm5hY2wuc2VjcmV0Ym94LmtleUxlbmd0aCA9IGNyeXB0b19zZWNyZXRib3hfS0VZQllURVM7XG5uYWNsLnNlY3JldGJveC5ub25jZUxlbmd0aCA9IGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUztcbm5hY2wuc2VjcmV0Ym94Lm92ZXJoZWFkTGVuZ3RoID0gY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVM7XG5cbm5hY2wuc2NhbGFyTXVsdCA9IGZ1bmN0aW9uKG4sIHApIHtcbiAgY2hlY2tBcnJheVR5cGVzKG4sIHApO1xuICBpZiAobi5sZW5ndGggIT09IGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBuIHNpemUnKTtcbiAgaWYgKHAubGVuZ3RoICE9PSBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgcCBzaXplJyk7XG4gIHZhciBxID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NjYWxhcm11bHRfQllURVMpO1xuICBjcnlwdG9fc2NhbGFybXVsdChxLCBuLCBwKTtcbiAgcmV0dXJuIHE7XG59O1xuXG5uYWNsLnNjYWxhck11bHQuYmFzZSA9IGZ1bmN0aW9uKG4pIHtcbiAgY2hlY2tBcnJheVR5cGVzKG4pO1xuICBpZiAobi5sZW5ndGggIT09IGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBuIHNpemUnKTtcbiAgdmFyIHEgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2NhbGFybXVsdF9CWVRFUyk7XG4gIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UocSwgbik7XG4gIHJldHVybiBxO1xufTtcblxubmFjbC5zY2FsYXJNdWx0LnNjYWxhckxlbmd0aCA9IGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTO1xubmFjbC5zY2FsYXJNdWx0Lmdyb3VwRWxlbWVudExlbmd0aCA9IGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTO1xuXG5uYWNsLmJveCA9IGZ1bmN0aW9uKG1zZywgbm9uY2UsIHB1YmxpY0tleSwgc2VjcmV0S2V5KSB7XG4gIHZhciBrID0gbmFjbC5ib3guYmVmb3JlKHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgcmV0dXJuIG5hY2wuc2VjcmV0Ym94KG1zZywgbm9uY2UsIGspO1xufTtcblxubmFjbC5ib3guYmVmb3JlID0gZnVuY3Rpb24ocHVibGljS2V5LCBzZWNyZXRLZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgY2hlY2tCb3hMZW5ndGhzKHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgdmFyIGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fYm94X0JFRk9SRU5NQllURVMpO1xuICBjcnlwdG9fYm94X2JlZm9yZW5tKGssIHB1YmxpY0tleSwgc2VjcmV0S2V5KTtcbiAgcmV0dXJuIGs7XG59O1xuXG5uYWNsLmJveC5hZnRlciA9IG5hY2wuc2VjcmV0Ym94O1xuXG5uYWNsLmJveC5vcGVuID0gZnVuY3Rpb24obXNnLCBub25jZSwgcHVibGljS2V5LCBzZWNyZXRLZXkpIHtcbiAgdmFyIGsgPSBuYWNsLmJveC5iZWZvcmUocHVibGljS2V5LCBzZWNyZXRLZXkpO1xuICByZXR1cm4gbmFjbC5zZWNyZXRib3gub3Blbihtc2csIG5vbmNlLCBrKTtcbn07XG5cbm5hY2wuYm94Lm9wZW4uYWZ0ZXIgPSBuYWNsLnNlY3JldGJveC5vcGVuO1xuXG5uYWNsLmJveC5rZXlQYWlyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMpO1xuICB2YXIgc2sgPSBuZXcgVWludDhBcnJheShjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTKTtcbiAgY3J5cHRvX2JveF9rZXlwYWlyKHBrLCBzayk7XG4gIHJldHVybiB7cHVibGljS2V5OiBwaywgc2VjcmV0S2V5OiBza307XG59O1xuXG5uYWNsLmJveC5rZXlQYWlyLmZyb21TZWNyZXRLZXkgPSBmdW5jdGlvbihzZWNyZXRLZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHNlY3JldEtleSk7XG4gIGlmIChzZWNyZXRLZXkubGVuZ3RoICE9PSBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTKTtcbiAgY3J5cHRvX3NjYWxhcm11bHRfYmFzZShwaywgc2VjcmV0S2V5KTtcbiAgcmV0dXJuIHtwdWJsaWNLZXk6IHBrLCBzZWNyZXRLZXk6IG5ldyBVaW50OEFycmF5KHNlY3JldEtleSl9O1xufTtcblxubmFjbC5ib3gucHVibGljS2V5TGVuZ3RoID0gY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUztcbm5hY2wuYm94LnNlY3JldEtleUxlbmd0aCA9IGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVM7XG5uYWNsLmJveC5zaGFyZWRLZXlMZW5ndGggPSBjcnlwdG9fYm94X0JFRk9SRU5NQllURVM7XG5uYWNsLmJveC5ub25jZUxlbmd0aCA9IGNyeXB0b19ib3hfTk9OQ0VCWVRFUztcbm5hY2wuYm94Lm92ZXJoZWFkTGVuZ3RoID0gbmFjbC5zZWNyZXRib3gub3ZlcmhlYWRMZW5ndGg7XG5cbm5hY2wuc2lnbiA9IGZ1bmN0aW9uKG1zZywgc2VjcmV0S2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhtc2csIHNlY3JldEtleSk7XG4gIGlmIChzZWNyZXRLZXkubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbiAgdmFyIHNpZ25lZE1zZyA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX0JZVEVTK21zZy5sZW5ndGgpO1xuICBjcnlwdG9fc2lnbihzaWduZWRNc2csIG1zZywgbXNnLmxlbmd0aCwgc2VjcmV0S2V5KTtcbiAgcmV0dXJuIHNpZ25lZE1zZztcbn07XG5cbm5hY2wuc2lnbi5vcGVuID0gZnVuY3Rpb24oc2lnbmVkTXNnLCBwdWJsaWNLZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHNpZ25lZE1zZywgcHVibGljS2V5KTtcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHB1YmxpYyBrZXkgc2l6ZScpO1xuICB2YXIgdG1wID0gbmV3IFVpbnQ4QXJyYXkoc2lnbmVkTXNnLmxlbmd0aCk7XG4gIHZhciBtbGVuID0gY3J5cHRvX3NpZ25fb3Blbih0bXAsIHNpZ25lZE1zZywgc2lnbmVkTXNnLmxlbmd0aCwgcHVibGljS2V5KTtcbiAgaWYgKG1sZW4gPCAwKSByZXR1cm4gbnVsbDtcbiAgdmFyIG0gPSBuZXcgVWludDhBcnJheShtbGVuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSBtW2ldID0gdG1wW2ldO1xuICByZXR1cm4gbTtcbn07XG5cbm5hY2wuc2lnbi5kZXRhY2hlZCA9IGZ1bmN0aW9uKG1zZywgc2VjcmV0S2V5KSB7XG4gIHZhciBzaWduZWRNc2cgPSBuYWNsLnNpZ24obXNnLCBzZWNyZXRLZXkpO1xuICB2YXIgc2lnID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fQllURVMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZy5sZW5ndGg7IGkrKykgc2lnW2ldID0gc2lnbmVkTXNnW2ldO1xuICByZXR1cm4gc2lnO1xufTtcblxubmFjbC5zaWduLmRldGFjaGVkLnZlcmlmeSA9IGZ1bmN0aW9uKG1zZywgc2lnLCBwdWJsaWNLZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKG1zZywgc2lnLCBwdWJsaWNLZXkpO1xuICBpZiAoc2lnLmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fQllURVMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2lnbmF0dXJlIHNpemUnKTtcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHB1YmxpYyBrZXkgc2l6ZScpO1xuICB2YXIgc20gPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9CWVRFUyArIG1zZy5sZW5ndGgpO1xuICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX0JZVEVTICsgbXNnLmxlbmd0aCk7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgY3J5cHRvX3NpZ25fQllURVM7IGkrKykgc21baV0gPSBzaWdbaV07XG4gIGZvciAoaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHNtW2krY3J5cHRvX3NpZ25fQllURVNdID0gbXNnW2ldO1xuICByZXR1cm4gKGNyeXB0b19zaWduX29wZW4obSwgc20sIHNtLmxlbmd0aCwgcHVibGljS2V5KSA+PSAwKTtcbn07XG5cbm5hY2wuc2lnbi5rZXlQYWlyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTKTtcbiAgdmFyIHNrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMpO1xuICBjcnlwdG9fc2lnbl9rZXlwYWlyKHBrLCBzayk7XG4gIHJldHVybiB7cHVibGljS2V5OiBwaywgc2VjcmV0S2V5OiBza307XG59O1xuXG5uYWNsLnNpZ24ua2V5UGFpci5mcm9tU2VjcmV0S2V5ID0gZnVuY3Rpb24oc2VjcmV0S2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhzZWNyZXRLZXkpO1xuICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gIHZhciBwayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBway5sZW5ndGg7IGkrKykgcGtbaV0gPSBzZWNyZXRLZXlbMzIraV07XG4gIHJldHVybiB7cHVibGljS2V5OiBwaywgc2VjcmV0S2V5OiBuZXcgVWludDhBcnJheShzZWNyZXRLZXkpfTtcbn07XG5cbm5hY2wuc2lnbi5rZXlQYWlyLmZyb21TZWVkID0gZnVuY3Rpb24oc2VlZCkge1xuICBjaGVja0FycmF5VHlwZXMoc2VlZCk7XG4gIGlmIChzZWVkLmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fU0VFREJZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlZWQgc2l6ZScpO1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyk7XG4gIHZhciBzayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSBza1tpXSA9IHNlZWRbaV07XG4gIGNyeXB0b19zaWduX2tleXBhaXIocGssIHNrLCB0cnVlKTtcbiAgcmV0dXJuIHtwdWJsaWNLZXk6IHBrLCBzZWNyZXRLZXk6IHNrfTtcbn07XG5cbm5hY2wuc2lnbi5wdWJsaWNLZXlMZW5ndGggPSBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUztcbm5hY2wuc2lnbi5zZWNyZXRLZXlMZW5ndGggPSBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUztcbm5hY2wuc2lnbi5zZWVkTGVuZ3RoID0gY3J5cHRvX3NpZ25fU0VFREJZVEVTO1xubmFjbC5zaWduLnNpZ25hdHVyZUxlbmd0aCA9IGNyeXB0b19zaWduX0JZVEVTO1xuXG5uYWNsLmhhc2ggPSBmdW5jdGlvbihtc2cpIHtcbiAgY2hlY2tBcnJheVR5cGVzKG1zZyk7XG4gIHZhciBoID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2hhc2hfQllURVMpO1xuICBjcnlwdG9faGFzaChoLCBtc2csIG1zZy5sZW5ndGgpO1xuICByZXR1cm4gaDtcbn07XG5cbm5hY2wuaGFzaC5oYXNoTGVuZ3RoID0gY3J5cHRvX2hhc2hfQllURVM7XG5cbm5hY2wudmVyaWZ5ID0gZnVuY3Rpb24oeCwgeSkge1xuICBjaGVja0FycmF5VHlwZXMoeCwgeSk7XG4gIC8vIFplcm8gbGVuZ3RoIGFyZ3VtZW50cyBhcmUgY29uc2lkZXJlZCBub3QgZXF1YWwuXG4gIGlmICh4Lmxlbmd0aCA9PT0gMCB8fCB5Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoeC5sZW5ndGggIT09IHkubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAodm4oeCwgMCwgeSwgMCwgeC5sZW5ndGgpID09PSAwKSA/IHRydWUgOiBmYWxzZTtcbn07XG5cbm5hY2wuc2V0UFJORyA9IGZ1bmN0aW9uKGZuKSB7XG4gIHJhbmRvbWJ5dGVzID0gZm47XG59O1xuXG4oZnVuY3Rpb24oKSB7XG4gIC8vIEluaXRpYWxpemUgUFJORyBpZiBlbnZpcm9ubWVudCBwcm92aWRlcyBDU1BSTkcuXG4gIC8vIElmIG5vdCwgbWV0aG9kcyBjYWxsaW5nIHJhbmRvbWJ5dGVzIHdpbGwgdGhyb3cuXG4gIHZhciBjcnlwdG8gPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyAoc2VsZi5jcnlwdG8gfHwgc2VsZi5tc0NyeXB0bykgOiBudWxsO1xuICBpZiAoY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBCcm93c2Vycy5cbiAgICB2YXIgUVVPVEEgPSA2NTUzNjtcbiAgICBuYWNsLnNldFBSTkcoZnVuY3Rpb24oeCwgbikge1xuICAgICAgdmFyIGksIHYgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpICs9IFFVT1RBKSB7XG4gICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXModi5zdWJhcnJheShpLCBpICsgTWF0aC5taW4obiAtIGksIFFVT1RBKSkpO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgeFtpXSA9IHZbaV07XG4gICAgICBjbGVhbnVwKHYpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE5vZGUuanMuXG4gICAgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG4gICAgaWYgKGNyeXB0byAmJiBjcnlwdG8ucmFuZG9tQnl0ZXMpIHtcbiAgICAgIG5hY2wuc2V0UFJORyhmdW5jdGlvbih4LCBuKSB7XG4gICAgICAgIHZhciBpLCB2ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKG4pO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB4W2ldID0gdltpXTtcbiAgICAgICAgY2xlYW51cCh2KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSkoKTtcblxufSkodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMgPyBtb2R1bGUuZXhwb3J0cyA6IChzZWxmLm5hY2wgPSBzZWxmLm5hY2wgfHwge30pKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgY3JlYXRlS2VjY2FrSGFzaCA9IHJlcXVpcmUoJ2tlY2NhaycpO1xudmFyIHNlY3AyNTZrMSA9IHJlcXVpcmUoJ3NlY3AyNTZrMScpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIHJscCA9IHJlcXVpcmUoJ3JscCcpO1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbk9iamVjdC5hc3NpZ24oZXhwb3J0cywgcmVxdWlyZSgnZXRoanMtdXRpbCcpKTtcblxuLyoqXG4gKiB0aGUgbWF4IGludGVnZXIgdGhhdCB0aGlzIFZNIGNhbiBoYW5kbGUgKGEgYGBgQk5gYGApXG4gKiBAdmFyIHtCTn0gTUFYX0lOVEVHRVJcbiAqL1xuZXhwb3J0cy5NQVhfSU5URUdFUiA9IG5ldyBCTignZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicsIDE2KTtcblxuLyoqXG4gKiAyXjI1NiAoYSBgYGBCTmBgYClcbiAqIEB2YXIge0JOfSBUV09fUE9XMjU2XG4gKi9cbmV4cG9ydHMuVFdPX1BPVzI1NiA9IG5ldyBCTignMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCAxNik7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIG51bGwgKGEgYGBgU3RyaW5nYGBgKVxuICogQHZhciB7U3RyaW5nfSBLRUNDQUsyNTZfTlVMTF9TXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUyA9ICdjNWQyNDYwMTg2ZjcyMzNjOTI3ZTdkYjJkY2M3MDNjMGU1MDBiNjUzY2E4MjI3M2I3YmZhZDgwNDVkODVhNDcwJztcbmV4cG9ydHMuU0hBM19OVUxMX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9OVUxMX1M7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIG51bGwgKGEgYGBgQnVmZmVyYGBgKVxuICogQHZhciB7QnVmZmVyfSBLRUNDQUsyNTZfTlVMTFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9OVUxMID0gQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TLCAnaGV4Jyk7XG5leHBvcnRzLlNIQTNfTlVMTCA9IGV4cG9ydHMuS0VDQ0FLMjU2X05VTEw7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBvZiBhbiBSTFAgb2YgYW4gZW1wdHkgYXJyYXkgKGEgYGBgU3RyaW5nYGBgKVxuICogQHZhciB7U3RyaW5nfSBLRUNDQUsyNTZfUkxQX0FSUkFZX1NcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MgPSAnMWRjYzRkZThkZWM3NWQ3YWFiODViNTY3YjZjY2Q0MWFkMzEyNDUxYjk0OGE3NDEzZjBhMTQyZmQ0MGQ0OTM0Nyc7XG5leHBvcnRzLlNIQTNfUkxQX0FSUkFZX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUztcblxuLyoqXG4gKiBLZWNjYWstMjU2IG9mIGFuIFJMUCBvZiBhbiBlbXB0eSBhcnJheSAoYSBgYGBCdWZmZXJgYGApXG4gKiBAdmFyIHtCdWZmZXJ9IEtFQ0NBSzI1Nl9STFBfQVJSQVlcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZID0gQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MsICdoZXgnKTtcbmV4cG9ydHMuU0hBM19STFBfQVJSQVkgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVk7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBSTFAgb2YgbnVsbCAgKGEgYGBgU3RyaW5nYGBgKVxuICogQHZhciB7U3RyaW5nfSBLRUNDQUsyNTZfUkxQX1NcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX1MgPSAnNTZlODFmMTcxYmNjNTVhNmZmODM0NWU2OTJjMGY4NmU1YjQ4ZTAxYjk5NmNhZGMwMDE2MjJmYjVlMzYzYjQyMSc7XG5leHBvcnRzLlNIQTNfUkxQX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfUztcblxuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIFJMUCBvZiBudWxsIChhIGBgYEJ1ZmZlcmBgYClcbiAqIEB2YXIge0J1ZmZlcn0gS0VDQ0FLMjU2X1JMUFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFAgPSBCdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9STFBfUywgJ2hleCcpO1xuZXhwb3J0cy5TSEEzX1JMUCA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUDtcblxuLyoqXG4gKiBbYEJOYF0oaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMpXG4gKiBAdmFyIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0cy5CTiA9IEJOO1xuXG4vKipcbiAqIFtgcmxwYF0oaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtanMvcmxwKVxuICogQHZhciB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydHMucmxwID0gcmxwO1xuXG4vKipcbiAqIFtgc2VjcDI1NmsxYF0oaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9zZWNwMjU2azEtbm9kZS8pXG4gKiBAdmFyIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuc2VjcDI1NmsxID0gc2VjcDI1NmsxO1xuXG4vKipcbiAqIFJldHVybnMgYSBidWZmZXIgZmlsbGVkIHdpdGggMHNcbiAqIEBtZXRob2QgemVyb3NcbiAqIEBwYXJhbSB7TnVtYmVyfSBieXRlcyAgdGhlIG51bWJlciBvZiBieXRlcyB0aGUgYnVmZmVyIHNob3VsZCBiZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnplcm9zID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoYnl0ZXMpLmZpbGwoMCk7XG59O1xuXG4vKipcbiAgKiBSZXR1cm5zIGEgemVybyBhZGRyZXNzXG4gICogQG1ldGhvZCB6ZXJvQWRkcmVzc1xuICAqIEByZXR1cm4ge1N0cmluZ31cbiAgKi9cbmV4cG9ydHMuemVyb0FkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhZGRyZXNzTGVuZ3RoID0gMjA7XG4gIHZhciB6ZXJvQWRkcmVzcyA9IGV4cG9ydHMuemVyb3MoYWRkcmVzc0xlbmd0aCk7XG4gIHJldHVybiBleHBvcnRzLmJ1ZmZlclRvSGV4KHplcm9BZGRyZXNzKTtcbn07XG5cbi8qKlxuICogTGVmdCBQYWRzIGFuIGBBcnJheWAgb3IgYEJ1ZmZlcmAgd2l0aCBsZWFkaW5nIHplcm9zIHRpbGwgaXQgaGFzIGBsZW5ndGhgIGJ5dGVzLlxuICogT3IgaXQgdHJ1bmNhdGVzIHRoZSBiZWdpbm5pbmcgaWYgaXQgZXhjZWVkcy5cbiAqIEBtZXRob2QgbHNldExlbmd0aFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl9IG1zZyB0aGUgdmFsdWUgdG8gcGFkXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIG91dHB1dCBzaG91bGQgYmVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JpZ2h0PWZhbHNlXSB3aGV0aGVyIHRvIHN0YXJ0IHBhZGRpbmcgZm9ybSB0aGUgbGVmdCBvciByaWdodFxuICogQHJldHVybiB7QnVmZmVyfEFycmF5fVxuICovXG5leHBvcnRzLnNldExlbmd0aExlZnQgPSBleHBvcnRzLnNldExlbmd0aCA9IGZ1bmN0aW9uIChtc2csIGxlbmd0aCwgcmlnaHQpIHtcbiAgdmFyIGJ1ZiA9IGV4cG9ydHMuemVyb3MobGVuZ3RoKTtcbiAgbXNnID0gZXhwb3J0cy50b0J1ZmZlcihtc2cpO1xuICBpZiAocmlnaHQpIHtcbiAgICBpZiAobXNnLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgbXNnLmNvcHkoYnVmKTtcbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIHJldHVybiBtc2cuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAobXNnLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgbXNnLmNvcHkoYnVmLCBsZW5ndGggLSBtc2cubGVuZ3RoKTtcbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIHJldHVybiBtc2cuc2xpY2UoLWxlbmd0aCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmlnaHQgUGFkcyBhbiBgQXJyYXlgIG9yIGBCdWZmZXJgIHdpdGggbGVhZGluZyB6ZXJvcyB0aWxsIGl0IGhhcyBgbGVuZ3RoYCBieXRlcy5cbiAqIE9yIGl0IHRydW5jYXRlcyB0aGUgYmVnaW5uaW5nIGlmIGl0IGV4Y2VlZHMuXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheX0gbXNnIHRoZSB2YWx1ZSB0byBwYWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxuICogQHJldHVybiB7QnVmZmVyfEFycmF5fVxuICovXG5leHBvcnRzLnNldExlbmd0aFJpZ2h0ID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoKSB7XG4gIHJldHVybiBleHBvcnRzLnNldExlbmd0aChtc2csIGxlbmd0aCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhIGBCdWZmZXJgIG9yIGFuIGBBcnJheWBcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ30gYVxuICogQHJldHVybiB7QnVmZmVyfEFycmF5fFN0cmluZ31cbiAqL1xuZXhwb3J0cy51bnBhZCA9IGV4cG9ydHMuc3RyaXBaZXJvcyA9IGZ1bmN0aW9uIChhKSB7XG4gIGEgPSBleHBvcnRzLnN0cmlwSGV4UHJlZml4KGEpO1xuICB2YXIgZmlyc3QgPSBhWzBdO1xuICB3aGlsZSAoYS5sZW5ndGggPiAwICYmIGZpcnN0LnRvU3RyaW5nKCkgPT09ICcwJykge1xuICAgIGEgPSBhLnNsaWNlKDEpO1xuICAgIGZpcnN0ID0gYVswXTtcbiAgfVxuICByZXR1cm4gYTtcbn07XG4vKipcbiAqIEF0dGVtcHRzIHRvIHR1cm4gYSB2YWx1ZSBpbnRvIGEgYEJ1ZmZlcmAuIEFzIGlucHV0IGl0IHN1cHBvcnRzIGBCdWZmZXJgLCBgU3RyaW5nYCwgYE51bWJlcmAsIG51bGwvdW5kZWZpbmVkLCBgQk5gIGFuZCBvdGhlciBvYmplY3RzIHdpdGggYSBgdG9BcnJheSgpYCBtZXRob2QuXG4gKiBAcGFyYW0geyp9IHYgdGhlIHZhbHVlXG4gKi9cbmV4cG9ydHMudG9CdWZmZXIgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2KSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICB2ID0gQnVmZmVyLmZyb20odik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChleHBvcnRzLmlzSGV4U3RyaW5nKHYpKSB7XG4gICAgICAgIHYgPSBCdWZmZXIuZnJvbShleHBvcnRzLnBhZFRvRXZlbihleHBvcnRzLnN0cmlwSGV4UHJlZml4KHYpKSwgJ2hleCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdiA9IEJ1ZmZlci5mcm9tKHYpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKSB7XG4gICAgICB2ID0gZXhwb3J0cy5pbnRUb0J1ZmZlcih2KTtcbiAgICB9IGVsc2UgaWYgKHYgPT09IG51bGwgfHwgdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICAgIH0gZWxzZSBpZiAoQk4uaXNCTih2KSkge1xuICAgICAgdiA9IHYudG9BcnJheUxpa2UoQnVmZmVyKTtcbiAgICB9IGVsc2UgaWYgKHYudG9BcnJheSkge1xuICAgICAgLy8gY29udmVydHMgYSBCTiB0byBhIEJ1ZmZlclxuICAgICAgdiA9IEJ1ZmZlci5mcm9tKHYudG9BcnJheSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHR5cGUnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHY7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgdG8gYSBgTnVtYmVyYFxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQHRocm93cyBJZiB0aGUgaW5wdXQgbnVtYmVyIGV4Y2VlZHMgNTMgYml0cy5cbiAqL1xuZXhwb3J0cy5idWZmZXJUb0ludCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgcmV0dXJuIG5ldyBCTihleHBvcnRzLnRvQnVmZmVyKGJ1ZikpLnRvTnVtYmVyKCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgaW50byBhIGhleCBgU3RyaW5nYFxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZlxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnRzLmJ1ZmZlclRvSGV4ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBidWYgPSBleHBvcnRzLnRvQnVmZmVyKGJ1Zik7XG4gIHJldHVybiAnMHgnICsgYnVmLnRvU3RyaW5nKCdoZXgnKTtcbn07XG5cbi8qKlxuICogSW50ZXJwcmV0cyBhIGBCdWZmZXJgIGFzIGEgc2lnbmVkIGludGVnZXIgYW5kIHJldHVybnMgYSBgQk5gLiBBc3N1bWVzIDI1Ni1iaXQgbnVtYmVycy5cbiAqIEBwYXJhbSB7QnVmZmVyfSBudW1cbiAqIEByZXR1cm4ge0JOfVxuICovXG5leHBvcnRzLmZyb21TaWduZWQgPSBmdW5jdGlvbiAobnVtKSB7XG4gIHJldHVybiBuZXcgQk4obnVtKS5mcm9tVHdvcygyNTYpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGBCTmAgdG8gYW4gdW5zaWduZWQgaW50ZWdlciBhbmQgcmV0dXJucyBpdCBhcyBhIGBCdWZmZXJgLiBBc3N1bWVzIDI1Ni1iaXQgbnVtYmVycy5cbiAqIEBwYXJhbSB7Qk59IG51bVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnRvVW5zaWduZWQgPSBmdW5jdGlvbiAobnVtKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShudW0udG9Ud29zKDI1NikudG9BcnJheSgpKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBLZWNjYWsgaGFzaCBvZiB0aGUgaW5wdXRcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBbYml0cz0yNTZdIHRoZSBLZWNjYWsgd2lkdGhcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5rZWNjYWsgPSBmdW5jdGlvbiAoYSwgYml0cykge1xuICBhID0gZXhwb3J0cy50b0J1ZmZlcihhKTtcbiAgaWYgKCFiaXRzKSBiaXRzID0gMjU2O1xuXG4gIHJldHVybiBjcmVhdGVLZWNjYWtIYXNoKCdrZWNjYWsnICsgYml0cykudXBkYXRlKGEpLmRpZ2VzdCgpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIEtlY2Nhay0yNTYgaGFzaCBvZiB0aGUgaW5wdXQsIGFsaWFzIGZvciBrZWNjYWsoYSwgMjU2KVxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLmtlY2NhazI1NiA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiBleHBvcnRzLmtlY2NhayhhKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBTSEEtMyAoS2VjY2FrKSBoYXNoIG9mIHRoZSBpbnB1dCBbT0JTT0xFVEVdXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcGFyYW0ge051bWJlcn0gW2JpdHM9MjU2XSB0aGUgU0hBLTMgd2lkdGhcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5zaGEzID0gZXhwb3J0cy5rZWNjYWs7XG5cbi8qKlxuICogQ3JlYXRlcyBTSEEyNTYgaGFzaCBvZiB0aGUgaW5wdXRcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5zaGEyNTYgPSBmdW5jdGlvbiAoYSkge1xuICBhID0gZXhwb3J0cy50b0J1ZmZlcihhKTtcbiAgcmV0dXJuIGNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShhKS5kaWdlc3QoKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBSSVBFTUQxNjAgaGFzaCBvZiB0aGUgaW5wdXRcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFkZGVkIHdoZXRoZXIgaXQgc2hvdWxkIGJlIHBhZGRlZCB0byAyNTYgYml0cyBvciBub3RcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5yaXBlbWQxNjAgPSBmdW5jdGlvbiAoYSwgcGFkZGVkKSB7XG4gIGEgPSBleHBvcnRzLnRvQnVmZmVyKGEpO1xuICB2YXIgaGFzaCA9IGNyZWF0ZUhhc2goJ3JtZDE2MCcpLnVwZGF0ZShhKS5kaWdlc3QoKTtcbiAgaWYgKHBhZGRlZCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBleHBvcnRzLnNldExlbmd0aChoYXNoLCAzMik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGhhc2g7XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBTSEEtMyBoYXNoIG9mIHRoZSBSTFAgZW5jb2RlZCB2ZXJzaW9uIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnJscGhhc2ggPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gZXhwb3J0cy5rZWNjYWsocmxwLmVuY29kZShhKSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJpdmF0ZSBrZXkgc2F0aXNmaWVzIHRoZSBydWxlcyBvZiB0aGUgY3VydmUgc2VjcDI1NmsxLlxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZFByaXZhdGUgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICByZXR1cm4gc2VjcDI1NmsxLnByaXZhdGVLZXlWZXJpZnkocHJpdmF0ZUtleSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHVibGljIGtleSBzYXRpc2ZpZXMgdGhlIHJ1bGVzIG9mIHRoZSBjdXJ2ZSBzZWNwMjU2azFcbiAqIGFuZCB0aGUgcmVxdWlyZW1lbnRzIG9mIEV0aGVyZXVtLlxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleSBUaGUgdHdvIHBvaW50cyBvZiBhbiB1bmNvbXByZXNzZWQga2V5LCB1bmxlc3Mgc2FuaXRpemUgaXMgZW5hYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBbc2FuaXRpemU9ZmFsc2VdIEFjY2VwdCBwdWJsaWMga2V5cyBpbiBvdGhlciBmb3JtYXRzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzVmFsaWRQdWJsaWMgPSBmdW5jdGlvbiAocHVibGljS2V5LCBzYW5pdGl6ZSkge1xuICBpZiAocHVibGljS2V5Lmxlbmd0aCA9PT0gNjQpIHtcbiAgICAvLyBDb252ZXJ0IHRvIFNFQzEgZm9yIHNlY3AyNTZrMVxuICAgIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5VmVyaWZ5KEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKFs0XSksIHB1YmxpY0tleV0pKTtcbiAgfVxuXG4gIGlmICghc2FuaXRpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShwdWJsaWNLZXkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBhZGRyZXNzIG9mIGEgZ2l2ZW4gcHVibGljIGtleS5cbiAqIEFjY2VwdHMgXCJFdGhlcmV1bSBwdWJsaWMga2V5c1wiIGFuZCBTRUMxIGVuY29kZWQga2V5cy5cbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJLZXkgVGhlIHR3byBwb2ludHMgb2YgYW4gdW5jb21wcmVzc2VkIGtleSwgdW5sZXNzIHNhbml0aXplIGlzIGVuYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Nhbml0aXplPWZhbHNlXSBBY2NlcHQgcHVibGljIGtleXMgaW4gb3RoZXIgZm9ybWF0c1xuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnB1YlRvQWRkcmVzcyA9IGV4cG9ydHMucHVibGljVG9BZGRyZXNzID0gZnVuY3Rpb24gKHB1YktleSwgc2FuaXRpemUpIHtcbiAgcHViS2V5ID0gZXhwb3J0cy50b0J1ZmZlcihwdWJLZXkpO1xuICBpZiAoc2FuaXRpemUgJiYgcHViS2V5Lmxlbmd0aCAhPT0gNjQpIHtcbiAgICBwdWJLZXkgPSBzZWNwMjU2azEucHVibGljS2V5Q29udmVydChwdWJLZXksIGZhbHNlKS5zbGljZSgxKTtcbiAgfVxuICBhc3NlcnQocHViS2V5Lmxlbmd0aCA9PT0gNjQpO1xuICAvLyBPbmx5IHRha2UgdGhlIGxvd2VyIDE2MGJpdHMgb2YgdGhlIGhhc2hcbiAgcmV0dXJuIGV4cG9ydHMua2VjY2FrKHB1YktleSkuc2xpY2UoLTIwKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZXRoZXJldW0gcHVibGljIGtleSBvZiBhIGdpdmVuIHByaXZhdGUga2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleSBBIHByaXZhdGUga2V5IG11c3QgYmUgMjU2IGJpdHMgd2lkZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHJpdmF0ZVRvUHVibGljID0gZXhwb3J0cy5wcml2YXRlVG9QdWJsaWMgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICBwcml2YXRlS2V5ID0gZXhwb3J0cy50b0J1ZmZlcihwcml2YXRlS2V5KTtcbiAgLy8gc2tpcCB0aGUgdHlwZSBmbGFnIGFuZCB1c2UgdGhlIFgsIFkgcG9pbnRzXG4gIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5Q3JlYXRlKHByaXZhdGVLZXksIGZhbHNlKS5zbGljZSgxKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBwdWJsaWMga2V5IHRvIHRoZSBFdGhlcmV1bSBmb3JtYXQuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuaW1wb3J0UHVibGljID0gZnVuY3Rpb24gKHB1YmxpY0tleSkge1xuICBwdWJsaWNLZXkgPSBleHBvcnRzLnRvQnVmZmVyKHB1YmxpY0tleSk7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgIHB1YmxpY0tleSA9IHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHB1YmxpY0tleSwgZmFsc2UpLnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBwdWJsaWNLZXk7XG59O1xuXG4vKipcbiAqIEVDRFNBIHNpZ25cbiAqIEBwYXJhbSB7QnVmZmVyfSBtc2dIYXNoXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5leHBvcnRzLmVjc2lnbiA9IGZ1bmN0aW9uIChtc2dIYXNoLCBwcml2YXRlS2V5KSB7XG4gIHZhciBzaWcgPSBzZWNwMjU2azEuc2lnbihtc2dIYXNoLCBwcml2YXRlS2V5KTtcblxuICB2YXIgcmV0ID0ge307XG4gIHJldC5yID0gc2lnLnNpZ25hdHVyZS5zbGljZSgwLCAzMik7XG4gIHJldC5zID0gc2lnLnNpZ25hdHVyZS5zbGljZSgzMiwgNjQpO1xuICByZXQudiA9IHNpZy5yZWNvdmVyeSArIDI3O1xuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBrZWNjYWstMjU2IGhhc2ggb2YgYG1lc3NhZ2VgLCBwcmVmaXhlZCB3aXRoIHRoZSBoZWFkZXIgdXNlZCBieSB0aGUgYGV0aF9zaWduYCBSUEMgY2FsbC5cbiAqIFRoZSBvdXRwdXQgb2YgdGhpcyBmdW5jdGlvbiBjYW4gYmUgZmVkIGludG8gYGVjc2lnbmAgdG8gcHJvZHVjZSB0aGUgc2FtZSBzaWduYXR1cmUgYXMgdGhlIGBldGhfc2lnbmBcbiAqIGNhbGwgZm9yIGEgZ2l2ZW4gYG1lc3NhZ2VgLCBvciBmZWQgdG8gYGVjcmVjb3ZlcmAgYWxvbmcgd2l0aCBhIHNpZ25hdHVyZSB0byByZWNvdmVyIHRoZSBwdWJsaWMga2V5XG4gKiB1c2VkIHRvIHByb2R1Y2UgdGhlIHNpZ25hdHVyZS5cbiAqIEBwYXJhbSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBoYXNoXG4gKi9cbmV4cG9ydHMuaGFzaFBlcnNvbmFsTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIHZhciBwcmVmaXggPSBleHBvcnRzLnRvQnVmZmVyKCdcXHgxOUV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxcbicgKyBtZXNzYWdlLmxlbmd0aC50b1N0cmluZygpKTtcbiAgcmV0dXJuIGV4cG9ydHMua2VjY2FrKEJ1ZmZlci5jb25jYXQoW3ByZWZpeCwgbWVzc2FnZV0pKTtcbn07XG5cbi8qKlxuICogRUNEU0EgcHVibGljIGtleSByZWNvdmVyeSBmcm9tIHNpZ25hdHVyZVxuICogQHBhcmFtIHtCdWZmZXJ9IG1zZ0hhc2hcbiAqIEBwYXJhbSB7TnVtYmVyfSB2XG4gKiBAcGFyYW0ge0J1ZmZlcn0gclxuICogQHBhcmFtIHtCdWZmZXJ9IHNcbiAqIEByZXR1cm4ge0J1ZmZlcn0gcHVibGljS2V5XG4gKi9cbmV4cG9ydHMuZWNyZWNvdmVyID0gZnVuY3Rpb24gKG1zZ0hhc2gsIHYsIHIsIHMpIHtcbiAgdmFyIHNpZ25hdHVyZSA9IEJ1ZmZlci5jb25jYXQoW2V4cG9ydHMuc2V0TGVuZ3RoKHIsIDMyKSwgZXhwb3J0cy5zZXRMZW5ndGgocywgMzIpXSwgNjQpO1xuICB2YXIgcmVjb3ZlcnkgPSB2IC0gMjc7XG4gIGlmIChyZWNvdmVyeSAhPT0gMCAmJiByZWNvdmVyeSAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgdiB2YWx1ZScpO1xuICB9XG4gIHZhciBzZW5kZXJQdWJLZXkgPSBzZWNwMjU2azEucmVjb3Zlcihtc2dIYXNoLCBzaWduYXR1cmUsIHJlY292ZXJ5KTtcbiAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHNlbmRlclB1YktleSwgZmFsc2UpLnNsaWNlKDEpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHNpZ25hdHVyZSBwYXJhbWV0ZXJzIGludG8gdGhlIGZvcm1hdCBvZiBgZXRoX3NpZ25gIFJQQyBtZXRob2RcbiAqIEBwYXJhbSB7TnVtYmVyfSB2XG4gKiBAcGFyYW0ge0J1ZmZlcn0gclxuICogQHBhcmFtIHtCdWZmZXJ9IHNcbiAqIEByZXR1cm4ge1N0cmluZ30gc2lnXG4gKi9cbmV4cG9ydHMudG9ScGNTaWcgPSBmdW5jdGlvbiAodiwgciwgcykge1xuICAvLyBOT1RFOiB3aXRoIHBvdGVudGlhbCBpbnRyb2R1Y3Rpb24gb2YgY2hhaW5JZCB0aGlzIG1pZ2h0IG5lZWQgdG8gYmUgdXBkYXRlZFxuICBpZiAodiAhPT0gMjcgJiYgdiAhPT0gMjgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVjb3ZlcnkgaWQnKTtcbiAgfVxuXG4gIC8vIGdldGggKGFuZCB0aGUgUlBDIGV0aF9zaWduIG1ldGhvZCkgdXNlcyB0aGUgNjUgYnl0ZSBmb3JtYXQgdXNlZCBieSBCaXRjb2luXG4gIC8vIEZJWE1FOiB0aGlzIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlIC0gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL2lzc3Vlcy8yMDUzXG4gIHJldHVybiBleHBvcnRzLmJ1ZmZlclRvSGV4KEJ1ZmZlci5jb25jYXQoW2V4cG9ydHMuc2V0TGVuZ3RoTGVmdChyLCAzMiksIGV4cG9ydHMuc2V0TGVuZ3RoTGVmdChzLCAzMiksIGV4cG9ydHMudG9CdWZmZXIodiAtIDI3KV0pKTtcbn07XG5cbi8qKlxuICogQ29udmVydCBzaWduYXR1cmUgZm9ybWF0IG9mIHRoZSBgZXRoX3NpZ25gIFJQQyBtZXRob2QgdG8gc2lnbmF0dXJlIHBhcmFtZXRlcnNcbiAqIE5PVEU6IGFsbCBiZWNhdXNlIG9mIGEgYnVnIGluIGdldGg6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9pc3N1ZXMvMjA1M1xuICogQHBhcmFtIHtTdHJpbmd9IHNpZ1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5leHBvcnRzLmZyb21ScGNTaWcgPSBmdW5jdGlvbiAoc2lnKSB7XG4gIHNpZyA9IGV4cG9ydHMudG9CdWZmZXIoc2lnKTtcblxuICAvLyBOT1RFOiB3aXRoIHBvdGVudGlhbCBpbnRyb2R1Y3Rpb24gb2YgY2hhaW5JZCB0aGlzIG1pZ2h0IG5lZWQgdG8gYmUgdXBkYXRlZFxuICBpZiAoc2lnLmxlbmd0aCAhPT0gNjUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIGxlbmd0aCcpO1xuICB9XG5cbiAgdmFyIHYgPSBzaWdbNjRdO1xuICAvLyBzdXBwb3J0IGJvdGggdmVyc2lvbnMgb2YgYGV0aF9zaWduYCByZXNwb25zZXNcbiAgaWYgKHYgPCAyNykge1xuICAgIHYgKz0gMjc7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHY6IHYsXG4gICAgcjogc2lnLnNsaWNlKDAsIDMyKSxcbiAgICBzOiBzaWcuc2xpY2UoMzIsIDY0KVxuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBhZGRyZXNzIG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5IEEgcHJpdmF0ZSBrZXkgbXVzdCBiZSAyNTYgYml0cyB3aWRlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucHJpdmF0ZVRvQWRkcmVzcyA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHJldHVybiBleHBvcnRzLnB1YmxpY1RvQWRkcmVzcyhwcml2YXRlVG9QdWJsaWMocHJpdmF0ZUtleSkpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGFkZHJlc3MgaXMgYSB2YWxpZC4gQWNjZXB0cyBjaGVja3N1bW1lZCBhZGRyZXNzZXMgdG9vXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIHJldHVybiAoL14weFswLTlhLWZBLUZdezQwfSQvLnRlc3QoYWRkcmVzcylcbiAgKTtcbn07XG5cbi8qKlxuICAqIENoZWNrcyBpZiBhIGdpdmVuIGFkZHJlc3MgaXMgYSB6ZXJvIGFkZHJlc3NcbiAgKiBAbWV0aG9kIGlzWmVyb0FkZHJlc3NcbiAgKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICovXG5leHBvcnRzLmlzWmVyb0FkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICB2YXIgemVyb0FkZHJlc3MgPSBleHBvcnRzLnplcm9BZGRyZXNzKCk7XG4gIHJldHVybiB6ZXJvQWRkcmVzcyA9PT0gZXhwb3J0cy5hZGRIZXhQcmVmaXgoYWRkcmVzcyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBjaGVja3N1bW1lZCBhZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgYWRkcmVzcyA9IGV4cG9ydHMuc3RyaXBIZXhQcmVmaXgoYWRkcmVzcykudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGhhc2ggPSBleHBvcnRzLmtlY2NhayhhZGRyZXNzKS50b1N0cmluZygnaGV4Jyk7XG4gIHZhciByZXQgPSAnMHgnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWRkcmVzcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwYXJzZUludChoYXNoW2ldLCAxNikgPj0gOCkge1xuICAgICAgcmV0ICs9IGFkZHJlc3NbaV0udG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0ICs9IGFkZHJlc3NbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBhZGRyZXNzIGlzIGEgdmFsaWQgY2hlY2tzdW1tZWQgYWRkcmVzc1xuICogQHBhcmFtIHtCdWZmZXJ9IGFkZHJlc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZENoZWNrc3VtQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIHJldHVybiBleHBvcnRzLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpICYmIGV4cG9ydHMudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcykgPT09IGFkZHJlc3M7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhZGRyZXNzIG9mIGEgbmV3bHkgY3JlYXRlZCBjb250cmFjdFxuICogQHBhcmFtIHtCdWZmZXJ9IGZyb20gdGhlIGFkZHJlc3Mgd2hpY2ggaXMgY3JlYXRpbmcgdGhpcyBuZXcgYWRkcmVzc1xuICogQHBhcmFtIHtCdWZmZXJ9IG5vbmNlIHRoZSBub25jZSBvZiB0aGUgZnJvbSBhY2NvdW50XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuZ2VuZXJhdGVBZGRyZXNzID0gZnVuY3Rpb24gKGZyb20sIG5vbmNlKSB7XG4gIGZyb20gPSBleHBvcnRzLnRvQnVmZmVyKGZyb20pO1xuICBub25jZSA9IG5ldyBCTihub25jZSk7XG5cbiAgaWYgKG5vbmNlLmlzWmVybygpKSB7XG4gICAgLy8gaW4gUkxQIHdlIHdhbnQgdG8gZW5jb2RlIG51bGwgaW4gdGhlIGNhc2Ugb2YgemVybyBub25jZVxuICAgIC8vIHJlYWQgdGhlIFJMUCBkb2N1bWVudGF0aW9uIGZvciBhbiBhbnN3ZXIgaWYgeW91IGRhcmVcbiAgICBub25jZSA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgbm9uY2UgPSBCdWZmZXIuZnJvbShub25jZS50b0FycmF5KCkpO1xuICB9XG5cbiAgLy8gT25seSB0YWtlIHRoZSBsb3dlciAxNjBiaXRzIG9mIHRoZSBoYXNoXG4gIHJldHVybiBleHBvcnRzLnJscGhhc2goW2Zyb20sIG5vbmNlXSkuc2xpY2UoLTIwKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzdXBwbGllZCBhZGRyZXNzIGJlbG9uZ3MgdG8gYSBwcmVjb21waWxlZCBhY2NvdW50IChCeXphbnRpdW0pXG4gKiBAcGFyYW0ge0J1ZmZlcnxTdHJpbmd9IGFkZHJlc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNQcmVjb21waWxlZCA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIHZhciBhID0gZXhwb3J0cy51bnBhZChhZGRyZXNzKTtcbiAgcmV0dXJuIGEubGVuZ3RoID09PSAxICYmIGFbMF0gPj0gMSAmJiBhWzBdIDw9IDg7XG59O1xuXG4vKipcbiAqIEFkZHMgXCIweFwiIHRvIGEgZ2l2ZW4gYFN0cmluZ2AgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBzdGFydCB3aXRoIFwiMHhcIlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnRzLmFkZEhleFByZWZpeCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLmlzSGV4UHJlZml4ZWQoc3RyKSA/IHN0ciA6ICcweCcgKyBzdHI7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIEVDRFNBIHNpZ25hdHVyZVxuICogQG1ldGhvZCBpc1ZhbGlkU2lnbmF0dXJlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gdlxuICogQHBhcmFtIHtCdWZmZXJ9IHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtob21lc3RlYWQ9dHJ1ZV1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZXhwb3J0cy5pc1ZhbGlkU2lnbmF0dXJlID0gZnVuY3Rpb24gKHYsIHIsIHMsIGhvbWVzdGVhZCkge1xuICB2YXIgU0VDUDI1NksxX05fRElWXzIgPSBuZXcgQk4oJzdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmNWQ1NzZlNzM1N2E0NTAxZGRmZTkyZjQ2NjgxYjIwYTAnLCAxNik7XG4gIHZhciBTRUNQMjU2SzFfTiA9IG5ldyBCTignZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScsIDE2KTtcblxuICBpZiAoci5sZW5ndGggIT09IDMyIHx8IHMubGVuZ3RoICE9PSAzMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh2ICE9PSAyNyAmJiB2ICE9PSAyOCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHIgPSBuZXcgQk4ocik7XG4gIHMgPSBuZXcgQk4ocyk7XG5cbiAgaWYgKHIuaXNaZXJvKCkgfHwgci5ndChTRUNQMjU2SzFfTikgfHwgcy5pc1plcm8oKSB8fCBzLmd0KFNFQ1AyNTZLMV9OKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChob21lc3RlYWQgPT09IGZhbHNlICYmIG5ldyBCTihzKS5jbXAoU0VDUDI1NksxX05fRElWXzIpID09PSAxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgb3IgYEFycmF5YCB0byBKU09OXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheX0gYmFcbiAqIEByZXR1cm4ge0FycmF5fFN0cmluZ3xudWxsfVxuICovXG5leHBvcnRzLmJhVG9KU09OID0gZnVuY3Rpb24gKGJhKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoYmEpKSB7XG4gICAgcmV0dXJuICcweCcgKyBiYS50b1N0cmluZygnaGV4Jyk7XG4gIH0gZWxzZSBpZiAoYmEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycmF5LnB1c2goZXhwb3J0cy5iYVRvSlNPTihiYVtpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbn07XG5cbi8qKlxuICogRGVmaW5lcyBwcm9wZXJ0aWVzIG9uIGEgYE9iamVjdGAuIEl0IG1ha2UgdGhlIGFzc3VtcHRpb24gdGhhdCB1bmRlcmx5aW5nIGRhdGEgaXMgYmluYXJ5LlxuICogQHBhcmFtIHtPYmplY3R9IHNlbGYgdGhlIGBPYmplY3RgIHRvIGRlZmluZSBwcm9wZXJ0aWVzIG9uXG4gKiBAcGFyYW0ge0FycmF5fSBmaWVsZHMgYW4gYXJyYXkgZmllbGRzIHRvIGRlZmluZS4gRmllbGRzIGNhbiBjb250YWluOlxuICogKiBgbmFtZWAgLSB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydGllc1xuICogKiBgbGVuZ3RoYCAtIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIGZpZWxkIGNhbiBoYXZlXG4gKiAqIGBhbGxvd0xlc3NgIC0gaWYgdGhlIGZpZWxkIGNhbiBiZSBsZXNzIHRoYW4gdGhlIGxlbmd0aFxuICogKiBgYWxsb3dFbXB0eWBcbiAqIEBwYXJhbSB7Kn0gZGF0YSBkYXRhIHRvIGJlIHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSBkZWZpbml0aW9uc1xuICovXG5leHBvcnRzLmRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoc2VsZiwgZmllbGRzLCBkYXRhKSB7XG4gIHNlbGYucmF3ID0gW107XG4gIHNlbGYuX2ZpZWxkcyA9IFtdO1xuXG4gIC8vIGF0dGFjaCB0aGUgYHRvSlNPTmBcbiAgc2VsZi50b0pTT04gPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICBpZiAobGFiZWwpIHtcbiAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgIHNlbGYuX2ZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICBvYmpbZmllbGRdID0gJzB4JyArIHNlbGZbZmllbGRdLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgcmV0dXJuIGV4cG9ydHMuYmFUb0pTT04odGhpcy5yYXcpO1xuICB9O1xuXG4gIHNlbGYuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHJldHVybiBybHAuZW5jb2RlKHNlbGYucmF3KTtcbiAgfTtcblxuICBmaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQsIGkpIHtcbiAgICBzZWxmLl9maWVsZHMucHVzaChmaWVsZC5uYW1lKTtcbiAgICBmdW5jdGlvbiBnZXR0ZXIoKSB7XG4gICAgICByZXR1cm4gc2VsZi5yYXdbaV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldHRlcih2KSB7XG4gICAgICB2ID0gZXhwb3J0cy50b0J1ZmZlcih2KTtcblxuICAgICAgaWYgKHYudG9TdHJpbmcoJ2hleCcpID09PSAnMDAnICYmICFmaWVsZC5hbGxvd1plcm8pIHtcbiAgICAgICAgdiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpZWxkLmFsbG93TGVzcyAmJiBmaWVsZC5sZW5ndGgpIHtcbiAgICAgICAgdiA9IGV4cG9ydHMuc3RyaXBaZXJvcyh2KTtcbiAgICAgICAgYXNzZXJ0KGZpZWxkLmxlbmd0aCA+PSB2Lmxlbmd0aCwgJ1RoZSBmaWVsZCAnICsgZmllbGQubmFtZSArICcgbXVzdCBub3QgaGF2ZSBtb3JlICcgKyBmaWVsZC5sZW5ndGggKyAnIGJ5dGVzJyk7XG4gICAgICB9IGVsc2UgaWYgKCEoZmllbGQuYWxsb3daZXJvICYmIHYubGVuZ3RoID09PSAwKSAmJiBmaWVsZC5sZW5ndGgpIHtcbiAgICAgICAgYXNzZXJ0KGZpZWxkLmxlbmd0aCA9PT0gdi5sZW5ndGgsICdUaGUgZmllbGQgJyArIGZpZWxkLm5hbWUgKyAnIG11c3QgaGF2ZSBieXRlIGxlbmd0aCBvZiAnICsgZmllbGQubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5yYXdbaV0gPSB2O1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBmaWVsZC5uYW1lLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBnZXR0ZXIsXG4gICAgICBzZXQ6IHNldHRlclxuICAgIH0pO1xuXG4gICAgaWYgKGZpZWxkLmRlZmF1bHQpIHtcbiAgICAgIHNlbGZbZmllbGQubmFtZV0gPSBmaWVsZC5kZWZhdWx0O1xuICAgIH1cblxuICAgIC8vIGF0dGFjaCBhbGlhc1xuICAgIGlmIChmaWVsZC5hbGlhcykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGZpZWxkLmFsaWFzLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHNldDogc2V0dGVyLFxuICAgICAgICBnZXQ6IGdldHRlclxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBpZiB0aGUgY29uc3R1Y3RvciBpcyBwYXNzZWQgZGF0YVxuICBpZiAoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShleHBvcnRzLnN0cmlwSGV4UHJlZml4KGRhdGEpLCAnaGV4Jyk7XG4gICAgfVxuXG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgZGF0YSA9IHJscC5kZWNvZGUoZGF0YSk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA+IHNlbGYuX2ZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBudW1iZXIgb2YgZmllbGRzIGluIGRhdGEnKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWFrZSBzdXJlIGFsbCB0aGUgaXRlbXMgYXJlIGJ1ZmZlcnNcbiAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICBzZWxmW3NlbGYuX2ZpZWxkc1tpXV0gPSBleHBvcnRzLnRvQnVmZmVyKGQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICgodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGRhdGEpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgICBmaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgaWYgKGtleXMuaW5kZXhPZihmaWVsZC5uYW1lKSAhPT0gLTEpIHNlbGZbZmllbGQubmFtZV0gPSBkYXRhW2ZpZWxkLm5hbWVdO1xuICAgICAgICBpZiAoa2V5cy5pbmRleE9mKGZpZWxkLmFsaWFzKSAhPT0gLTEpIHNlbGZbZmllbGQuYWxpYXNdID0gZGF0YVtmaWVsZC5hbGlhc107XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGRhdGEnKTtcbiAgICB9XG4gIH1cbn07IiwiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiIsIlxudmFyIHVyaWxpYiA9IHJlcXVpcmUoJ3VybCcpO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcblxubW9kdWxlLmV4cG9ydHMuU2NoZW1hU2NhblJlc3VsdCA9IFNjaGVtYVNjYW5SZXN1bHQ7XG5mdW5jdGlvbiBTY2hlbWFTY2FuUmVzdWx0KGZvdW5kLCByZWYpe1xuICB0aGlzLmlkID0gZm91bmQ7XG4gIHRoaXMucmVmID0gcmVmO1xufVxuXG4vKipcbiAqIEFkZHMgYSBzY2hlbWEgd2l0aCBhIGNlcnRhaW4gdXJuIHRvIHRoZSBWYWxpZGF0b3IgaW5zdGFuY2UuXG4gKiBAcGFyYW0gc3RyaW5nIHVyaVxuICogQHBhcmFtIG9iamVjdCBzY2hlbWFcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xubW9kdWxlLmV4cG9ydHMuc2NhbiA9IGZ1bmN0aW9uIHNjYW4oYmFzZSwgc2NoZW1hKXtcbiAgZnVuY3Rpb24gc2NhblNjaGVtYShiYXNldXJpLCBzY2hlbWEpe1xuICAgIGlmKCFzY2hlbWEgfHwgdHlwZW9mIHNjaGVtYSE9J29iamVjdCcpIHJldHVybjtcbiAgICAvLyBNYXJrIGFsbCByZWZlcmVuY2VkIHNjaGVtYXMgc28gd2UgY2FuIHRlbGwgbGF0ZXIgd2hpY2ggc2NoZW1hcyBhcmUgcmVmZXJyZWQgdG8sIGJ1dCBuZXZlciBkZWZpbmVkXG4gICAgaWYoc2NoZW1hLiRyZWYpe1xuICAgICAgdmFyIHJlc29sdmVkVXJpID0gdXJpbGliLnJlc29sdmUoYmFzZXVyaSwgc2NoZW1hLiRyZWYpO1xuICAgICAgcmVmW3Jlc29sdmVkVXJpXSA9IHJlZltyZXNvbHZlZFVyaV0gPyByZWZbcmVzb2x2ZWRVcmldKzEgOiAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgb3VyQmFzZSA9IHNjaGVtYS5pZCA/IHVyaWxpYi5yZXNvbHZlKGJhc2V1cmksIHNjaGVtYS5pZCkgOiBiYXNldXJpO1xuICAgIGlmIChvdXJCYXNlKSB7XG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIGZyYWdtZW50LCBhcHBlbmQgYW4gZW1wdHkgb25lXG4gICAgICBpZihvdXJCYXNlLmluZGV4T2YoJyMnKTwwKSBvdXJCYXNlICs9ICcjJztcbiAgICAgIGlmKGZvdW5kW291ckJhc2VdKXtcbiAgICAgICAgaWYoIWhlbHBlcnMuZGVlcENvbXBhcmVTdHJpY3QoZm91bmRbb3VyQmFzZV0sIHNjaGVtYSkpe1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2NoZW1hIDwnK3NjaGVtYSsnPiBhbHJlYWR5IGV4aXN0cyB3aXRoIGRpZmZlcmVudCBkZWZpbml0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kW291ckJhc2VdO1xuICAgICAgfVxuICAgICAgZm91bmRbb3VyQmFzZV0gPSBzY2hlbWE7XG4gICAgICAvLyBzdHJpcCB0cmFpbGluZyBmcmFnbWVudFxuICAgICAgaWYob3VyQmFzZVtvdXJCYXNlLmxlbmd0aC0xXT09JyMnKXtcbiAgICAgICAgZm91bmRbb3VyQmFzZS5zdWJzdHJpbmcoMCwgb3VyQmFzZS5sZW5ndGgtMSldID0gc2NoZW1hO1xuICAgICAgfVxuICAgIH1cbiAgICBzY2FuQXJyYXkob3VyQmFzZSsnL2l0ZW1zJywgKChzY2hlbWEuaXRlbXMgaW5zdGFuY2VvZiBBcnJheSk/c2NoZW1hLml0ZW1zOltzY2hlbWEuaXRlbXNdKSk7XG4gICAgc2NhbkFycmF5KG91ckJhc2UrJy9leHRlbmRzJywgKChzY2hlbWEuZXh0ZW5kcyBpbnN0YW5jZW9mIEFycmF5KT9zY2hlbWEuZXh0ZW5kczpbc2NoZW1hLmV4dGVuZHNdKSk7XG4gICAgc2NhblNjaGVtYShvdXJCYXNlKycvYWRkaXRpb25hbEl0ZW1zJywgc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyk7XG4gICAgc2Nhbk9iamVjdChvdXJCYXNlKycvcHJvcGVydGllcycsIHNjaGVtYS5wcm9wZXJ0aWVzKTtcbiAgICBzY2FuU2NoZW1hKG91ckJhc2UrJy9hZGRpdGlvbmFsUHJvcGVydGllcycsIHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyk7XG4gICAgc2Nhbk9iamVjdChvdXJCYXNlKycvZGVmaW5pdGlvbnMnLCBzY2hlbWEuZGVmaW5pdGlvbnMpO1xuICAgIHNjYW5PYmplY3Qob3VyQmFzZSsnL3BhdHRlcm5Qcm9wZXJ0aWVzJywgc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKTtcbiAgICBzY2FuT2JqZWN0KG91ckJhc2UrJy9kZXBlbmRlbmNpZXMnLCBzY2hlbWEuZGVwZW5kZW5jaWVzKTtcbiAgICBzY2FuQXJyYXkob3VyQmFzZSsnL2Rpc2FsbG93Jywgc2NoZW1hLmRpc2FsbG93KTtcbiAgICBzY2FuQXJyYXkob3VyQmFzZSsnL2FsbE9mJywgc2NoZW1hLmFsbE9mKTtcbiAgICBzY2FuQXJyYXkob3VyQmFzZSsnL2FueU9mJywgc2NoZW1hLmFueU9mKTtcbiAgICBzY2FuQXJyYXkob3VyQmFzZSsnL29uZU9mJywgc2NoZW1hLm9uZU9mKTtcbiAgICBzY2FuU2NoZW1hKG91ckJhc2UrJy9ub3QnLCBzY2hlbWEubm90KTtcbiAgfVxuICBmdW5jdGlvbiBzY2FuQXJyYXkoYmFzZXVyaSwgc2NoZW1hcyl7XG4gICAgaWYoIShzY2hlbWFzIGluc3RhbmNlb2YgQXJyYXkpKSByZXR1cm47XG4gICAgZm9yKHZhciBpPTA7IGk8c2NoZW1hcy5sZW5ndGg7IGkrKyl7XG4gICAgICBzY2FuU2NoZW1hKGJhc2V1cmkrJy8nK2ksIHNjaGVtYXNbaV0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzY2FuT2JqZWN0KGJhc2V1cmksIHNjaGVtYXMpe1xuICAgIGlmKCFzY2hlbWFzIHx8IHR5cGVvZiBzY2hlbWFzIT0nb2JqZWN0JykgcmV0dXJuO1xuICAgIGZvcih2YXIgcCBpbiBzY2hlbWFzKXtcbiAgICAgIHNjYW5TY2hlbWEoYmFzZXVyaSsnLycrcCwgc2NoZW1hc1twXSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZvdW5kID0ge307XG4gIHZhciByZWYgPSB7fTtcbiAgdmFyIHNjaGVtYVVyaSA9IGJhc2U7XG4gIHNjYW5TY2hlbWEoYmFzZSwgc2NoZW1hKTtcbiAgcmV0dXJuIG5ldyBTY2hlbWFTY2FuUmVzdWx0KGZvdW5kLCByZWYpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXJpbGliID0gcmVxdWlyZSgndXJsJyk7XG5cbnZhciBhdHRyaWJ1dGUgPSByZXF1aXJlKCcuL2F0dHJpYnV0ZScpO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcbnZhciBzY2FuU2NoZW1hID0gcmVxdWlyZSgnLi9zY2FuJykuc2NhbjtcbnZhciBWYWxpZGF0b3JSZXN1bHQgPSBoZWxwZXJzLlZhbGlkYXRvclJlc3VsdDtcbnZhciBTY2hlbWFFcnJvciA9IGhlbHBlcnMuU2NoZW1hRXJyb3I7XG52YXIgU2NoZW1hQ29udGV4dCA9IGhlbHBlcnMuU2NoZW1hQ29udGV4dDtcbi8vdmFyIGFub255bW91c0Jhc2UgPSAndm5kLmpzb25zY2hlbWE6Ly8vJztcbnZhciBhbm9ueW1vdXNCYXNlID0gJy8nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVmFsaWRhdG9yIG9iamVjdFxuICogQG5hbWUgVmFsaWRhdG9yXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFZhbGlkYXRvciA9IGZ1bmN0aW9uIFZhbGlkYXRvciAoKSB7XG4gIC8vIEFsbG93IGEgdmFsaWRhdG9yIGluc3RhbmNlIHRvIG92ZXJyaWRlIGdsb2JhbCBjdXN0b20gZm9ybWF0cyBvciB0byBoYXZlIHRoZWlyXG4gIC8vIG93biBjdXN0b20gZm9ybWF0cy5cbiAgdGhpcy5jdXN0b21Gb3JtYXRzID0gT2JqZWN0LmNyZWF0ZShWYWxpZGF0b3IucHJvdG90eXBlLmN1c3RvbUZvcm1hdHMpO1xuICB0aGlzLnNjaGVtYXMgPSB7fTtcbiAgdGhpcy51bnJlc29sdmVkUmVmcyA9IFtdO1xuXG4gIC8vIFVzZSBPYmplY3QuY3JlYXRlIHRvIG1ha2UgdGhpcyBleHRlbnNpYmxlIHdpdGhvdXQgVmFsaWRhdG9yIGluc3RhbmNlcyBzdGVwcGluZyBvbiBlYWNoIG90aGVyJ3MgdG9lcy5cbiAgdGhpcy50eXBlcyA9IE9iamVjdC5jcmVhdGUodHlwZXMpO1xuICB0aGlzLmF0dHJpYnV0ZXMgPSBPYmplY3QuY3JlYXRlKGF0dHJpYnV0ZS52YWxpZGF0b3JzKTtcbn07XG5cbi8vIEFsbG93IGZvcm1hdHMgdG8gYmUgcmVnaXN0ZXJlZCBnbG9iYWxseS5cblZhbGlkYXRvci5wcm90b3R5cGUuY3VzdG9tRm9ybWF0cyA9IHt9O1xuXG4vLyBIaW50IGF0IHRoZSBwcmVzZW5jZSBvZiBhIHByb3BlcnR5XG5WYWxpZGF0b3IucHJvdG90eXBlLnNjaGVtYXMgPSBudWxsO1xuVmFsaWRhdG9yLnByb3RvdHlwZS50eXBlcyA9IG51bGw7XG5WYWxpZGF0b3IucHJvdG90eXBlLmF0dHJpYnV0ZXMgPSBudWxsO1xuVmFsaWRhdG9yLnByb3RvdHlwZS51bnJlc29sdmVkUmVmcyA9IG51bGw7XG5cbi8qKlxuICogQWRkcyBhIHNjaGVtYSB3aXRoIGEgY2VydGFpbiB1cm4gdG8gdGhlIFZhbGlkYXRvciBpbnN0YW5jZS5cbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEBwYXJhbSB1cm5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuVmFsaWRhdG9yLnByb3RvdHlwZS5hZGRTY2hlbWEgPSBmdW5jdGlvbiBhZGRTY2hlbWEgKHNjaGVtYSwgYmFzZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICghc2NoZW1hKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHNjYW4gPSBzY2FuU2NoZW1hKGJhc2V8fGFub255bW91c0Jhc2UsIHNjaGVtYSk7XG4gIHZhciBvdXJVcmkgPSBiYXNlIHx8IHNjaGVtYS5pZDtcbiAgZm9yKHZhciB1cmkgaW4gc2Nhbi5pZCl7XG4gICAgdGhpcy5zY2hlbWFzW3VyaV0gPSBzY2FuLmlkW3VyaV07XG4gIH1cbiAgZm9yKHZhciB1cmkgaW4gc2Nhbi5yZWYpe1xuICAgIHRoaXMudW5yZXNvbHZlZFJlZnMucHVzaCh1cmkpO1xuICB9XG4gIHRoaXMudW5yZXNvbHZlZFJlZnMgPSB0aGlzLnVucmVzb2x2ZWRSZWZzLmZpbHRlcihmdW5jdGlvbih1cmkpe1xuICAgIHJldHVybiB0eXBlb2Ygc2VsZi5zY2hlbWFzW3VyaV09PT0ndW5kZWZpbmVkJztcbiAgfSk7XG4gIHJldHVybiB0aGlzLnNjaGVtYXNbb3VyVXJpXTtcbn07XG5cblZhbGlkYXRvci5wcm90b3R5cGUuYWRkU3ViU2NoZW1hQXJyYXkgPSBmdW5jdGlvbiBhZGRTdWJTY2hlbWFBcnJheShiYXNldXJpLCBzY2hlbWFzKSB7XG4gIGlmKCEoc2NoZW1hcyBpbnN0YW5jZW9mIEFycmF5KSkgcmV0dXJuO1xuICBmb3IodmFyIGk9MDsgaTxzY2hlbWFzLmxlbmd0aDsgaSsrKXtcbiAgICB0aGlzLmFkZFN1YlNjaGVtYShiYXNldXJpLCBzY2hlbWFzW2ldKTtcbiAgfVxufTtcblxuVmFsaWRhdG9yLnByb3RvdHlwZS5hZGRTdWJTY2hlbWFPYmplY3QgPSBmdW5jdGlvbiBhZGRTdWJTY2hlbWFBcnJheShiYXNldXJpLCBzY2hlbWFzKSB7XG4gIGlmKCFzY2hlbWFzIHx8IHR5cGVvZiBzY2hlbWFzIT0nb2JqZWN0JykgcmV0dXJuO1xuICBmb3IodmFyIHAgaW4gc2NoZW1hcyl7XG4gICAgdGhpcy5hZGRTdWJTY2hlbWEoYmFzZXVyaSwgc2NoZW1hc1twXSk7XG4gIH1cbn07XG5cblxuXG4vKipcbiAqIFNldHMgYWxsIHRoZSBzY2hlbWFzIG9mIHRoZSBWYWxpZGF0b3IgaW5zdGFuY2UuXG4gKiBAcGFyYW0gc2NoZW1hc1xuICovXG5WYWxpZGF0b3IucHJvdG90eXBlLnNldFNjaGVtYXMgPSBmdW5jdGlvbiBzZXRTY2hlbWFzIChzY2hlbWFzKSB7XG4gIHRoaXMuc2NoZW1hcyA9IHNjaGVtYXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHNjaGVtYSBvZiBhIGNlcnRhaW4gdXJuXG4gKiBAcGFyYW0gdXJuXG4gKi9cblZhbGlkYXRvci5wcm90b3R5cGUuZ2V0U2NoZW1hID0gZnVuY3Rpb24gZ2V0U2NoZW1hICh1cm4pIHtcbiAgcmV0dXJuIHRoaXMuc2NoZW1hc1t1cm5dO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgaW5zdGFuY2UgYWdhaW5zdCB0aGUgcHJvdmlkZWQgc2NoZW1hXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEBwYXJhbSBbb3B0aW9uc11cbiAqIEBwYXJhbSBbY3R4XVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICB2YXIgcHJvcGVydHlOYW1lID0gb3B0aW9ucy5wcm9wZXJ0eU5hbWUgfHwgJ2luc3RhbmNlJztcbiAgLy8gVGhpcyB3aWxsIHdvcmsgc28gbG9uZyBhcyB0aGUgZnVuY3Rpb24gYXQgdXJpLnJlc29sdmUoKSB3aWxsIHJlc29sdmUgYSByZWxhdGl2ZSBVUkkgdG8gYSByZWxhdGl2ZSBVUklcbiAgdmFyIGJhc2UgPSB1cmlsaWIucmVzb2x2ZShvcHRpb25zLmJhc2V8fGFub255bW91c0Jhc2UsIHNjaGVtYS5pZHx8JycpO1xuICBpZighY3R4KXtcbiAgICBjdHggPSBuZXcgU2NoZW1hQ29udGV4dChzY2hlbWEsIG9wdGlvbnMsIHByb3BlcnR5TmFtZSwgYmFzZSwgT2JqZWN0LmNyZWF0ZSh0aGlzLnNjaGVtYXMpKTtcbiAgICBpZiAoIWN0eC5zY2hlbWFzW2Jhc2VdKSB7XG4gICAgICBjdHguc2NoZW1hc1tiYXNlXSA9IHNjaGVtYTtcbiAgICB9XG4gICAgdmFyIGZvdW5kID0gc2NhblNjaGVtYShiYXNlLCBzY2hlbWEpO1xuICAgIGZvcih2YXIgbiBpbiBmb3VuZC5pZCl7XG4gICAgICB2YXIgc2NoID0gZm91bmQuaWRbbl07XG4gICAgICBjdHguc2NoZW1hc1tuXSA9IHNjaDtcbiAgICB9XG4gIH1cbiAgaWYgKHNjaGVtYSkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnZhbGlkYXRlU2NoZW1hKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVzdWx0IHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHRocm93IG5ldyBTY2hlbWFFcnJvcignbm8gc2NoZW1hIHNwZWNpZmllZCcsIHNjaGVtYSk7XG59O1xuXG4vKipcbiogQHBhcmFtIE9iamVjdCBzY2hlbWFcbiogQHJldHVybiBtaXhlZCBzY2hlbWEgdXJpIG9yIGZhbHNlXG4qL1xuZnVuY3Rpb24gc2hvdWxkUmVzb2x2ZShzY2hlbWEpIHtcbiAgdmFyIHJlZiA9ICh0eXBlb2Ygc2NoZW1hID09PSAnc3RyaW5nJykgPyBzY2hlbWEgOiBzY2hlbWEuJHJlZjtcbiAgaWYgKHR5cGVvZiByZWY9PSdzdHJpbmcnKSByZXR1cm4gcmVmO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIGFuIGluc3RhbmNlIGFnYWluc3QgdGhlIHNjaGVtYSAodGhlIGFjdHVhbCB3b3JrIGhvcnNlKVxuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIGN0eFxuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge1ZhbGlkYXRvclJlc3VsdH1cbiAqL1xuVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZVNjaGVtYSA9IGZ1bmN0aW9uIHZhbGlkYXRlU2NoZW1hIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcblxuICAgIC8vIFN1cHBvcnQgZm9yIHRoZSB0cnVlL2ZhbHNlIHNjaGVtYXNcbiAgaWYodHlwZW9mIHNjaGVtYT09PSdib29sZWFuJykge1xuICAgIGlmKHNjaGVtYT09PXRydWUpe1xuICAgICAgLy8gYHRydWVgIGlzIGFsd2F5cyB2YWxpZFxuICAgICAgc2NoZW1hID0ge307XG4gICAgfWVsc2UgaWYoc2NoZW1hPT09ZmFsc2Upe1xuICAgICAgLy8gYGZhbHNlYCBpcyBhbHdheXMgaW52YWxpZFxuICAgICAgc2NoZW1hID0ge3R5cGU6IFtdfTtcbiAgICB9XG4gIH1lbHNlIGlmKCFzY2hlbWEpe1xuICAgIC8vIFRoaXMgbWlnaHQgYmUgYSBzdHJpbmdcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgaXMgdW5kZWZpbmVkXCIpO1xuICB9XG5cbiAgaWYgKHNjaGVtYVsnZXh0ZW5kcyddKSB7XG4gICAgaWYgKHNjaGVtYVsnZXh0ZW5kcyddIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHZhciBzY2hlbWFvYmogPSB7c2NoZW1hOiBzY2hlbWEsIGN0eDogY3R4fTtcbiAgICAgIHNjaGVtYVsnZXh0ZW5kcyddLmZvckVhY2godGhpcy5zY2hlbWFUcmF2ZXJzZXIuYmluZCh0aGlzLCBzY2hlbWFvYmopKTtcbiAgICAgIHNjaGVtYSA9IHNjaGVtYW9iai5zY2hlbWE7XG4gICAgICBzY2hlbWFvYmouc2NoZW1hID0gbnVsbDtcbiAgICAgIHNjaGVtYW9iai5jdHggPSBudWxsO1xuICAgICAgc2NoZW1hb2JqID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZW1hID0gaGVscGVycy5kZWVwTWVyZ2Uoc2NoZW1hLCB0aGlzLnN1cGVyUmVzb2x2ZShzY2hlbWFbJ2V4dGVuZHMnXSwgY3R4KSk7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgcGFzc2VkIGEgc3RyaW5nIGFyZ3VtZW50LCBsb2FkIHRoYXQgc2NoZW1hIFVSSVxuICB2YXIgc3dpdGNoU2NoZW1hO1xuICBpZiAoc3dpdGNoU2NoZW1hID0gc2hvdWxkUmVzb2x2ZShzY2hlbWEpKSB7XG4gICAgdmFyIHJlc29sdmVkID0gdGhpcy5yZXNvbHZlKHNjaGVtYSwgc3dpdGNoU2NoZW1hLCBjdHgpO1xuICAgIHZhciBzdWJjdHggPSBuZXcgU2NoZW1hQ29udGV4dChyZXNvbHZlZC5zdWJzY2hlbWEsIG9wdGlvbnMsIGN0eC5wcm9wZXJ0eVBhdGgsIHJlc29sdmVkLnN3aXRjaFNjaGVtYSwgY3R4LnNjaGVtYXMpO1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlU2NoZW1hKGluc3RhbmNlLCByZXNvbHZlZC5zdWJzY2hlbWEsIG9wdGlvbnMsIHN1YmN0eCk7XG4gIH1cblxuICB2YXIgc2tpcEF0dHJpYnV0ZXMgPSBvcHRpb25zICYmIG9wdGlvbnMuc2tpcEF0dHJpYnV0ZXMgfHwgW107XG4gIC8vIFZhbGlkYXRlIGVhY2ggc2NoZW1hIGF0dHJpYnV0ZSBhZ2FpbnN0IHRoZSBpbnN0YW5jZVxuICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG4gICAgaWYgKCFhdHRyaWJ1dGUuaWdub3JlUHJvcGVydGllc1trZXldICYmIHNraXBBdHRyaWJ1dGVzLmluZGV4T2Yoa2V5KSA8IDApIHtcbiAgICAgIHZhciB2YWxpZGF0b3JFcnIgPSBudWxsO1xuICAgICAgdmFyIHZhbGlkYXRvciA9IHRoaXMuYXR0cmlidXRlc1trZXldO1xuICAgICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgICB2YWxpZGF0b3JFcnIgPSB2YWxpZGF0b3IuY2FsbCh0aGlzLCBpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmFsbG93VW5rbm93bkF0dHJpYnV0ZXMgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIFRoaXMgcmVwcmVzZW50cyBhbiBlcnJvciB3aXRoIHRoZSBzY2hlbWEgaXRzZWxmLCBub3QgYW4gaW52YWxpZCBpbnN0YW5jZVxuICAgICAgICB0aHJvdyBuZXcgU2NoZW1hRXJyb3IoXCJVbnN1cHBvcnRlZCBhdHRyaWJ1dGU6IFwiICsga2V5LCBzY2hlbWEpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbGlkYXRvckVycikge1xuICAgICAgICByZXN1bHQuaW1wb3J0RXJyb3JzKHZhbGlkYXRvckVycik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLnJld3JpdGUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMucmV3cml0ZS5jYWxsKHRoaXMsIGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gICAgcmVzdWx0Lmluc3RhbmNlID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuKiBAcHJpdmF0ZVxuKiBAcGFyYW0gT2JqZWN0IHNjaGVtYVxuKiBAcGFyYW0gU2NoZW1hQ29udGV4dCBjdHhcbiogQHJldHVybnMgT2JqZWN0IHNjaGVtYSBvciByZXNvbHZlZCBzY2hlbWFcbiovXG5WYWxpZGF0b3IucHJvdG90eXBlLnNjaGVtYVRyYXZlcnNlciA9IGZ1bmN0aW9uIHNjaGVtYVRyYXZlcnNlciAoc2NoZW1hb2JqLCBzKSB7XG4gIHNjaGVtYW9iai5zY2hlbWEgPSBoZWxwZXJzLmRlZXBNZXJnZShzY2hlbWFvYmouc2NoZW1hLCB0aGlzLnN1cGVyUmVzb2x2ZShzLCBzY2hlbWFvYmouY3R4KSk7XG59XG5cbi8qKlxuKiBAcHJpdmF0ZVxuKiBAcGFyYW0gT2JqZWN0IHNjaGVtYVxuKiBAcGFyYW0gU2NoZW1hQ29udGV4dCBjdHhcbiogQHJldHVybnMgT2JqZWN0IHNjaGVtYSBvciByZXNvbHZlZCBzY2hlbWFcbiovXG5WYWxpZGF0b3IucHJvdG90eXBlLnN1cGVyUmVzb2x2ZSA9IGZ1bmN0aW9uIHN1cGVyUmVzb2x2ZSAoc2NoZW1hLCBjdHgpIHtcbiAgdmFyIHJlZjtcbiAgaWYocmVmID0gc2hvdWxkUmVzb2x2ZShzY2hlbWEpKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZShzY2hlbWEsIHJlZiwgY3R4KS5zdWJzY2hlbWE7XG4gIH1cbiAgcmV0dXJuIHNjaGVtYTtcbn1cblxuLyoqXG4qIEBwcml2YXRlXG4qIEBwYXJhbSBPYmplY3Qgc2NoZW1hXG4qIEBwYXJhbSBPYmplY3Qgc3dpdGNoU2NoZW1hXG4qIEBwYXJhbSBTY2hlbWFDb250ZXh0IGN0eFxuKiBAcmV0dXJuIE9iamVjdCByZXNvbHZlZCBzY2hlbWFzIHtzdWJzY2hlbWE6U3RyaW5nLCBzd2l0Y2hTY2hlbWE6IFN0cmluZ31cbiogQHRocm93cyBTY2hlbWFFcnJvclxuKi9cblZhbGlkYXRvci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUgKHNjaGVtYSwgc3dpdGNoU2NoZW1hLCBjdHgpIHtcbiAgc3dpdGNoU2NoZW1hID0gY3R4LnJlc29sdmUoc3dpdGNoU2NoZW1hKTtcbiAgLy8gRmlyc3Qgc2VlIGlmIHRoZSBzY2hlbWEgZXhpc3RzIHVuZGVyIHRoZSBwcm92aWRlZCBVUklcbiAgaWYgKGN0eC5zY2hlbWFzW3N3aXRjaFNjaGVtYV0pIHtcbiAgICByZXR1cm4ge3N1YnNjaGVtYTogY3R4LnNjaGVtYXNbc3dpdGNoU2NoZW1hXSwgc3dpdGNoU2NoZW1hOiBzd2l0Y2hTY2hlbWF9O1xuICB9XG4gIC8vIEVsc2UgdHJ5IHdhbGtpbmcgdGhlIHByb3BlcnR5IHBvaW50ZXJcbiAgdmFyIHBhcnNlZCA9IHVyaWxpYi5wYXJzZShzd2l0Y2hTY2hlbWEpO1xuICB2YXIgZnJhZ21lbnQgPSBwYXJzZWQgJiYgcGFyc2VkLmhhc2g7XG4gIHZhciBkb2N1bWVudCA9IGZyYWdtZW50ICYmIGZyYWdtZW50Lmxlbmd0aCAmJiBzd2l0Y2hTY2hlbWEuc3Vic3RyKDAsIHN3aXRjaFNjaGVtYS5sZW5ndGggLSBmcmFnbWVudC5sZW5ndGgpO1xuICBpZiAoIWRvY3VtZW50IHx8ICFjdHguc2NoZW1hc1tkb2N1bWVudF0pIHtcbiAgICB0aHJvdyBuZXcgU2NoZW1hRXJyb3IoXCJubyBzdWNoIHNjaGVtYSA8XCIgKyBzd2l0Y2hTY2hlbWEgKyBcIj5cIiwgc2NoZW1hKTtcbiAgfVxuICB2YXIgc3Vic2NoZW1hID0gaGVscGVycy5vYmplY3RHZXRQYXRoKGN0eC5zY2hlbWFzW2RvY3VtZW50XSwgZnJhZ21lbnQuc3Vic3RyKDEpKTtcbiAgaWYoc3Vic2NoZW1hPT09dW5kZWZpbmVkKXtcbiAgICB0aHJvdyBuZXcgU2NoZW1hRXJyb3IoXCJubyBzdWNoIHNjaGVtYSBcIiArIGZyYWdtZW50ICsgXCIgbG9jYXRlZCBpbiA8XCIgKyBkb2N1bWVudCArIFwiPlwiLCBzY2hlbWEpO1xuICB9XG4gIHJldHVybiB7c3Vic2NoZW1hOiBzdWJzY2hlbWEsIHN3aXRjaFNjaGVtYTogc3dpdGNoU2NoZW1hfTtcbn07XG5cbi8qKlxuICogVGVzdHMgd2hldGhlciB0aGUgaW5zdGFuY2UgaWYgb2YgYSBjZXJ0YWluIHR5cGUuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIGN0eFxuICogQHBhcmFtIHR5cGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblZhbGlkYXRvci5wcm90b3R5cGUudGVzdFR5cGUgPSBmdW5jdGlvbiB2YWxpZGF0ZVR5cGUgKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCwgdHlwZSkge1xuICBpZiAodHlwZW9mIHRoaXMudHlwZXNbdHlwZV0gPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0aGlzLnR5cGVzW3R5cGVdLmNhbGwodGhpcywgaW5zdGFuY2UpO1xuICB9XG4gIGlmICh0eXBlICYmIHR5cGVvZiB0eXBlID09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHRoaXMudmFsaWRhdGVTY2hlbWEoaW5zdGFuY2UsIHR5cGUsIG9wdGlvbnMsIGN0eCk7XG4gICAgcmV0dXJuIHJlcyA9PT0gdW5kZWZpbmVkIHx8ICEocmVzICYmIHJlcy5lcnJvcnMubGVuZ3RoKTtcbiAgfVxuICAvLyBVbmRlZmluZWQgb3IgcHJvcGVydGllcyBub3Qgb24gdGhlIGxpc3QgYXJlIGFjY2VwdGFibGUsIHNhbWUgYXMgbm90IGJlaW5nIGRlZmluZWRcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgdHlwZXMgPSBWYWxpZGF0b3IucHJvdG90eXBlLnR5cGVzID0ge307XG50eXBlcy5zdHJpbmcgPSBmdW5jdGlvbiB0ZXN0U3RyaW5nIChpbnN0YW5jZSkge1xuICByZXR1cm4gdHlwZW9mIGluc3RhbmNlID09ICdzdHJpbmcnO1xufTtcbnR5cGVzLm51bWJlciA9IGZ1bmN0aW9uIHRlc3ROdW1iZXIgKGluc3RhbmNlKSB7XG4gIC8vIGlzRmluaXRlIHJldHVybnMgZmFsc2UgZm9yIE5hTiwgSW5maW5pdHksIGFuZCAtSW5maW5pdHlcbiAgcmV0dXJuIHR5cGVvZiBpbnN0YW5jZSA9PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZShpbnN0YW5jZSk7XG59O1xudHlwZXMuaW50ZWdlciA9IGZ1bmN0aW9uIHRlc3RJbnRlZ2VyIChpbnN0YW5jZSkge1xuICByZXR1cm4gKHR5cGVvZiBpbnN0YW5jZSA9PSAnbnVtYmVyJykgJiYgaW5zdGFuY2UgJSAxID09PSAwO1xufTtcbnR5cGVzLmJvb2xlYW4gPSBmdW5jdGlvbiB0ZXN0Qm9vbGVhbiAoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIHR5cGVvZiBpbnN0YW5jZSA9PSAnYm9vbGVhbic7XG59O1xudHlwZXMuYXJyYXkgPSBmdW5jdGlvbiB0ZXN0QXJyYXkgKGluc3RhbmNlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGluc3RhbmNlKTtcbn07XG50eXBlc1snbnVsbCddID0gZnVuY3Rpb24gdGVzdE51bGwgKGluc3RhbmNlKSB7XG4gIHJldHVybiBpbnN0YW5jZSA9PT0gbnVsbDtcbn07XG50eXBlcy5kYXRlID0gZnVuY3Rpb24gdGVzdERhdGUgKGluc3RhbmNlKSB7XG4gIHJldHVybiBpbnN0YW5jZSBpbnN0YW5jZW9mIERhdGU7XG59O1xudHlwZXMuYW55ID0gZnVuY3Rpb24gdGVzdEFueSAoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xudHlwZXMub2JqZWN0ID0gZnVuY3Rpb24gdGVzdE9iamVjdCAoaW5zdGFuY2UpIHtcbiAgLy8gVE9ETzogZml4IHRoaXMgLSBzZWUgIzE1XG4gIHJldHVybiBpbnN0YW5jZSAmJiAodHlwZW9mIGluc3RhbmNlKSA9PT0gJ29iamVjdCcgJiYgIShpbnN0YW5jZSBpbnN0YW5jZW9mIEFycmF5KSAmJiAhKGluc3RhbmNlIGluc3RhbmNlb2YgRGF0ZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZhbGlkYXRvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHVyaSA9IHJlcXVpcmUoJ3VybCcpO1xuXG52YXIgVmFsaWRhdGlvbkVycm9yID0gZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IgPSBmdW5jdGlvbiBWYWxpZGF0aW9uRXJyb3IgKG1lc3NhZ2UsIGluc3RhbmNlLCBzY2hlbWEsIHByb3BlcnR5UGF0aCwgbmFtZSwgYXJndW1lbnQpIHtcbiAgaWYgKHByb3BlcnR5UGF0aCkge1xuICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eVBhdGg7XG4gIH1cbiAgaWYgKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG4gIGlmIChzY2hlbWEpIHtcbiAgICBpZiAoc2NoZW1hLmlkKSB7XG4gICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYS5pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgfVxuICB9XG4gIGlmIChpbnN0YW5jZSkge1xuICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgfVxuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG4gIHRoaXMuc3RhY2sgPSB0aGlzLnRvU3RyaW5nKCk7XG59O1xuXG5WYWxpZGF0aW9uRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0aGlzLnByb3BlcnR5ICsgJyAnICsgdGhpcy5tZXNzYWdlO1xufTtcblxudmFyIFZhbGlkYXRvclJlc3VsdCA9IGV4cG9ydHMuVmFsaWRhdG9yUmVzdWx0ID0gZnVuY3Rpb24gVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICB0aGlzLnByb3BlcnR5UGF0aCA9IGN0eC5wcm9wZXJ0eVBhdGg7XG4gIHRoaXMuZXJyb3JzID0gW107XG4gIHRoaXMudGhyb3dFcnJvciA9IG9wdGlvbnMgJiYgb3B0aW9ucy50aHJvd0Vycm9yO1xuICB0aGlzLmRpc2FibGVGb3JtYXQgPSBvcHRpb25zICYmIG9wdGlvbnMuZGlzYWJsZUZvcm1hdCA9PT0gdHJ1ZTtcbn07XG5cblZhbGlkYXRvclJlc3VsdC5wcm90b3R5cGUuYWRkRXJyb3IgPSBmdW5jdGlvbiBhZGRFcnJvcihkZXRhaWwpIHtcbiAgdmFyIGVycjtcbiAgaWYgKHR5cGVvZiBkZXRhaWwgPT0gJ3N0cmluZycpIHtcbiAgICBlcnIgPSBuZXcgVmFsaWRhdGlvbkVycm9yKGRldGFpbCwgdGhpcy5pbnN0YW5jZSwgdGhpcy5zY2hlbWEsIHRoaXMucHJvcGVydHlQYXRoKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWRldGFpbCkgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGVycm9yIGRldGFpbCcpO1xuICAgIGlmICghZGV0YWlsLm1lc3NhZ2UpIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBlcnJvciBtZXNzYWdlJyk7XG4gICAgaWYgKCFkZXRhaWwubmFtZSkgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHZhbGlkYXRvciB0eXBlJyk7XG4gICAgZXJyID0gbmV3IFZhbGlkYXRpb25FcnJvcihkZXRhaWwubWVzc2FnZSwgdGhpcy5pbnN0YW5jZSwgdGhpcy5zY2hlbWEsIHRoaXMucHJvcGVydHlQYXRoLCBkZXRhaWwubmFtZSwgZGV0YWlsLmFyZ3VtZW50KTtcbiAgfVxuXG4gIGlmICh0aGlzLnRocm93RXJyb3IpIHtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgdGhpcy5lcnJvcnMucHVzaChlcnIpO1xuICByZXR1cm4gZXJyO1xufTtcblxuVmFsaWRhdG9yUmVzdWx0LnByb3RvdHlwZS5pbXBvcnRFcnJvcnMgPSBmdW5jdGlvbiBpbXBvcnRFcnJvcnMocmVzKSB7XG4gIGlmICh0eXBlb2YgcmVzID09ICdzdHJpbmcnIHx8IChyZXMgJiYgcmVzLnZhbGlkYXRvclR5cGUpKSB7XG4gICAgdGhpcy5hZGRFcnJvcihyZXMpO1xuICB9IGVsc2UgaWYgKHJlcyAmJiByZXMuZXJyb3JzKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5lcnJvcnMsIHJlcy5lcnJvcnMpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzdHJpbmdpemVyICh2LGkpe1xuICByZXR1cm4gaSsnOiAnK3YudG9TdHJpbmcoKSsnXFxuJztcbn1cblZhbGlkYXRvclJlc3VsdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhyZXMpIHtcbiAgcmV0dXJuIHRoaXMuZXJyb3JzLm1hcChzdHJpbmdpemVyKS5qb2luKCcnKTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWYWxpZGF0b3JSZXN1bHQucHJvdG90eXBlLCBcInZhbGlkXCIsIHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICF0aGlzLmVycm9ycy5sZW5ndGg7XG59IH0pO1xuXG4vKipcbiAqIERlc2NyaWJlcyBhIHByb2JsZW0gd2l0aCBhIFNjaGVtYSB3aGljaCBwcmV2ZW50cyB2YWxpZGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gKiBAbmFtZSBTY2hlbWFFcnJvclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBTY2hlbWFFcnJvciA9IGV4cG9ydHMuU2NoZW1hRXJyb3IgPSBmdW5jdGlvbiBTY2hlbWFFcnJvciAobXNnLCBzY2hlbWEpIHtcbiAgdGhpcy5tZXNzYWdlID0gbXNnO1xuICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgRXJyb3IuY2FsbCh0aGlzLCBtc2cpO1xuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBTY2hlbWFFcnJvcik7XG59O1xuU2NoZW1hRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUsXG4gIHsgY29uc3RydWN0b3I6IHt2YWx1ZTogU2NoZW1hRXJyb3IsIGVudW1lcmFibGU6IGZhbHNlfVxuICAsIG5hbWU6IHt2YWx1ZTogJ1NjaGVtYUVycm9yJywgZW51bWVyYWJsZTogZmFsc2V9XG4gIH0pO1xuXG52YXIgU2NoZW1hQ29udGV4dCA9IGV4cG9ydHMuU2NoZW1hQ29udGV4dCA9IGZ1bmN0aW9uIFNjaGVtYUNvbnRleHQgKHNjaGVtYSwgb3B0aW9ucywgcHJvcGVydHlQYXRoLCBiYXNlLCBzY2hlbWFzKSB7XG4gIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLnByb3BlcnR5UGF0aCA9IHByb3BlcnR5UGF0aDtcbiAgdGhpcy5iYXNlID0gYmFzZTtcbiAgdGhpcy5zY2hlbWFzID0gc2NoZW1hcztcbn07XG5cblNjaGVtYUNvbnRleHQucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlICh0YXJnZXQpIHtcbiAgcmV0dXJuIHVyaS5yZXNvbHZlKHRoaXMuYmFzZSwgdGFyZ2V0KTtcbn07XG5cblNjaGVtYUNvbnRleHQucHJvdG90eXBlLm1ha2VDaGlsZCA9IGZ1bmN0aW9uIG1ha2VDaGlsZChzY2hlbWEsIHByb3BlcnR5TmFtZSl7XG4gIHZhciBwcm9wZXJ0eVBhdGggPSAocHJvcGVydHlOYW1lPT09dW5kZWZpbmVkKSA/IHRoaXMucHJvcGVydHlQYXRoIDogdGhpcy5wcm9wZXJ0eVBhdGgrbWFrZVN1ZmZpeChwcm9wZXJ0eU5hbWUpO1xuICB2YXIgYmFzZSA9IHVyaS5yZXNvbHZlKHRoaXMuYmFzZSwgc2NoZW1hLmlkfHwnJyk7XG4gIHZhciBjdHggPSBuZXcgU2NoZW1hQ29udGV4dChzY2hlbWEsIHRoaXMub3B0aW9ucywgcHJvcGVydHlQYXRoLCBiYXNlLCBPYmplY3QuY3JlYXRlKHRoaXMuc2NoZW1hcykpO1xuICBpZihzY2hlbWEuaWQgJiYgIWN0eC5zY2hlbWFzW2Jhc2VdKXtcbiAgICBjdHguc2NoZW1hc1tiYXNlXSA9IHNjaGVtYTtcbiAgfVxuICByZXR1cm4gY3R4O1xufVxuXG52YXIgRk9STUFUX1JFR0VYUFMgPSBleHBvcnRzLkZPUk1BVF9SRUdFWFBTID0ge1xuICAnZGF0ZS10aW1lJzogL15cXGR7NH0tKD86MFswLTldezF9fDFbMC0yXXsxfSktKDNbMDFdfDBbMS05XXxbMTJdWzAtOV0pW3RUIF0oMlswLTRdfFswMV1bMC05XSk6KFswLTVdWzAtOV0pOig2MHxbMC01XVswLTldKShcXC5cXGQrKT8oW3paXXxbKy1dKFswLTVdWzAtOV0pOig2MHxbMC01XVswLTldKSkkLyxcbiAgJ2RhdGUnOiAvXlxcZHs0fS0oPzowWzAtOV17MX18MVswLTJdezF9KS0oM1swMV18MFsxLTldfFsxMl1bMC05XSkkLyxcbiAgJ3RpbWUnOiAvXigyWzAtNF18WzAxXVswLTldKTooWzAtNV1bMC05XSk6KDYwfFswLTVdWzAtOV0pJC8sXG5cbiAgJ2VtYWlsJzogL14oPzpbXFx3XFwhXFwjXFwkXFwlXFwmXFwnXFwqXFwrXFwtXFwvXFw9XFw/XFxeXFxgXFx7XFx8XFx9XFx+XStcXC4pKltcXHdcXCFcXCNcXCRcXCVcXCZcXCdcXCpcXCtcXC1cXC9cXD1cXD9cXF5cXGBcXHtcXHxcXH1cXH5dK0AoPzooPzooPzpbYS16QS1aMC05XSg/OlthLXpBLVowLTlcXC1dKD8hXFwuKSl7MCw2MX1bYS16QS1aMC05XT9cXC4pK1thLXpBLVowLTldKD86W2EtekEtWjAtOVxcLV0oPyEkKSl7MCw2MX1bYS16QS1aMC05XT8pfCg/OlxcWyg/Oig/OlswMV0/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pXFwuKXszfSg/OlswMV0/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pXFxdKSkkLyxcbiAgJ2lwLWFkZHJlc3MnOiAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KSQvLFxuICAnaXB2Nic6IC9eXFxzKigoKFswLTlBLUZhLWZdezEsNH06KXs3fShbMC05QS1GYS1mXXsxLDR9fDopKXwoKFswLTlBLUZhLWZdezEsNH06KXs2fSg6WzAtOUEtRmEtZl17MSw0fXwoKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezV9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsMn0pfDooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezR9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsM30pfCgoOlswLTlBLUZhLWZdezEsNH0pPzooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlBLUZhLWZdezEsNH06KXszfSgoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDR9KXwoKDpbMC05QS1GYS1mXXsxLDR9KXswLDJ9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezJ9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsNX0pfCgoOlswLTlBLUZhLWZdezEsNH0pezAsM306KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05QS1GYS1mXXsxLDR9Oil7MX0oKCg6WzAtOUEtRmEtZl17MSw0fSl7MSw2fSl8KCg6WzAtOUEtRmEtZl17MSw0fSl7MCw0fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoOigoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDd9KXwoKDpbMC05QS1GYS1mXXsxLDR9KXswLDV9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpKSglLispP1xccyokLyxcbiAgJ3VyaSc6IC9eW2EtekEtWl1bYS16QS1aMC05Ky0uXSo6W15cXHNdKiQvLFxuXG4gICdjb2xvcic6IC9eKCM/KFswLTlBLUZhLWZdezN9KXsxLDJ9XFxifGFxdWF8YmxhY2t8Ymx1ZXxmdWNoc2lhfGdyYXl8Z3JlZW58bGltZXxtYXJvb258bmF2eXxvbGl2ZXxvcmFuZ2V8cHVycGxlfHJlZHxzaWx2ZXJ8dGVhbHx3aGl0ZXx5ZWxsb3d8KHJnYlxcKFxccypcXGIoWzAtOV18WzEtOV1bMC05XXwxWzAtOV1bMC05XXwyWzAtNF1bMC05XXwyNVswLTVdKVxcYlxccyosXFxzKlxcYihbMC05XXxbMS05XVswLTldfDFbMC05XVswLTldfDJbMC00XVswLTldfDI1WzAtNV0pXFxiXFxzKixcXHMqXFxiKFswLTldfFsxLTldWzAtOV18MVswLTldWzAtOV18MlswLTRdWzAtOV18MjVbMC01XSlcXGJcXHMqXFwpKXwocmdiXFwoXFxzKihcXGQ/XFxkJXwxMDAlKStcXHMqLFxccyooXFxkP1xcZCV8MTAwJSkrXFxzKixcXHMqKFxcZD9cXGQlfDEwMCUpK1xccypcXCkpKSQvLFxuXG4gIC8vIGhvc3RuYW1lIHJlZ2V4IGZyb206IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE0MjAyMjUvNTYyOFxuICAnaG9zdG5hbWUnOiAvXig/PS57MSwyNTV9JClbMC05QS1aYS16XSg/Oig/OlswLTlBLVphLXpdfC0pezAsNjF9WzAtOUEtWmEtel0pPyg/OlxcLlswLTlBLVphLXpdKD86KD86WzAtOUEtWmEtel18LSl7MCw2MX1bMC05QS1aYS16XSk/KSpcXC4/JC8sXG4gICdob3N0LW5hbWUnOiAvXig/PS57MSwyNTV9JClbMC05QS1aYS16XSg/Oig/OlswLTlBLVphLXpdfC0pezAsNjF9WzAtOUEtWmEtel0pPyg/OlxcLlswLTlBLVphLXpdKD86KD86WzAtOUEtWmEtel18LSl7MCw2MX1bMC05QS1aYS16XSk/KSpcXC4/JC8sXG5cbiAgJ2FscGhhJzogL15bYS16QS1aXSskLyxcbiAgJ2FscGhhbnVtZXJpYyc6IC9eW2EtekEtWjAtOV0rJC8sXG4gICd1dGMtbWlsbGlzZWMnOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpICYmIHBhcnNlRmxvYXQoaW5wdXQpID09PSBwYXJzZUludChpbnB1dCwgMTApICYmICFpc05hTihpbnB1dCk7XG4gIH0sXG4gICdyZWdleCc6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICBuZXcgUmVnRXhwKGlucHV0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgJ3N0eWxlJzogL1xccyooLis/KTpcXHMqKFteO10rKTs/L2csXG4gICdwaG9uZSc6IC9eXFwrKD86WzAtOV0gPyl7NiwxNH1bMC05XSQvXG59O1xuXG5GT1JNQVRfUkVHRVhQUy5yZWdleHAgPSBGT1JNQVRfUkVHRVhQUy5yZWdleDtcbkZPUk1BVF9SRUdFWFBTLnBhdHRlcm4gPSBGT1JNQVRfUkVHRVhQUy5yZWdleDtcbkZPUk1BVF9SRUdFWFBTLmlwdjQgPSBGT1JNQVRfUkVHRVhQU1snaXAtYWRkcmVzcyddO1xuXG5leHBvcnRzLmlzRm9ybWF0ID0gZnVuY3Rpb24gaXNGb3JtYXQgKGlucHV0LCBmb3JtYXQsIHZhbGlkYXRvcikge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyAmJiBGT1JNQVRfUkVHRVhQU1tmb3JtYXRdICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoRk9STUFUX1JFR0VYUFNbZm9ybWF0XSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIEZPUk1BVF9SRUdFWFBTW2Zvcm1hdF0udGVzdChpbnB1dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgRk9STUFUX1JFR0VYUFNbZm9ybWF0XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIEZPUk1BVF9SRUdFWFBTW2Zvcm1hdF0oaW5wdXQpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2YWxpZGF0b3IgJiYgdmFsaWRhdG9yLmN1c3RvbUZvcm1hdHMgJiZcbiAgICAgIHR5cGVvZiB2YWxpZGF0b3IuY3VzdG9tRm9ybWF0c1tmb3JtYXRdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRvci5jdXN0b21Gb3JtYXRzW2Zvcm1hdF0oaW5wdXQpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIG1ha2VTdWZmaXggPSBleHBvcnRzLm1ha2VTdWZmaXggPSBmdW5jdGlvbiBtYWtlU3VmZml4IChrZXkpIHtcbiAga2V5ID0ga2V5LnRvU3RyaW5nKCk7XG4gIC8vIFRoaXMgZnVuY3Rpb24gY291bGQgYmUgY2FwYWJsZSBvZiBvdXRwdXR0aW5nIHZhbGlkIGEgRUNNQVNjcmlwdCBzdHJpbmcsIGJ1dCB0aGVcbiAgLy8gcmVzdWx0aW5nIGNvZGUgZm9yIHRlc3Rpbmcgd2hpY2ggZm9ybSB0byB1c2Ugd291bGQgYmUgdGVucyBvZiB0aG91c2FuZHMgb2YgY2hhcmFjdGVycyBsb25nXG4gIC8vIFRoYXQgbWVhbnMgdGhpcyB3aWxsIHVzZSB0aGUgbmFtZSBmb3JtIGZvciBzb21lIGlsbGVnYWwgZm9ybXNcbiAgaWYgKCFrZXkubWF0Y2goL1suXFxzXFxbXFxdXS8pICYmICFrZXkubWF0Y2goL15bXFxkXS8pKSB7XG4gICAgcmV0dXJuICcuJyArIGtleTtcbiAgfVxuICBpZiAoa2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgIHJldHVybiAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgcmV0dXJuICdbJyArIEpTT04uc3RyaW5naWZ5KGtleSkgKyAnXSc7XG59O1xuXG5leHBvcnRzLmRlZXBDb21wYXJlU3RyaWN0ID0gZnVuY3Rpb24gZGVlcENvbXBhcmVTdHJpY3QgKGEsIGIpIHtcbiAgaWYgKHR5cGVvZiBhICE9PSB0eXBlb2YgYikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgaWYgKCEoYiBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBhLmV2ZXJ5KGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICByZXR1cm4gZGVlcENvbXBhcmVTdHJpY3QoYVtpXSwgYltpXSk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0Jykge1xuICAgIGlmICghYSB8fCAhYikge1xuICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgfVxuICAgIHZhciBhS2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuICAgIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gYUtleXMuZXZlcnkoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiBkZWVwQ29tcGFyZVN0cmljdChhW3ZdLCBiW3ZdKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gYSA9PT0gYjtcbn07XG5cbmZ1bmN0aW9uIGRlZXBNZXJnZXIgKHRhcmdldCwgZHN0LCBlLCBpKSB7XG4gIGlmICh0eXBlb2YgZSA9PT0gJ29iamVjdCcpIHtcbiAgICBkc3RbaV0gPSBkZWVwTWVyZ2UodGFyZ2V0W2ldLCBlKVxuICB9IGVsc2Uge1xuICAgIGlmICh0YXJnZXQuaW5kZXhPZihlKSA9PT0gLTEpIHtcbiAgICAgIGRzdC5wdXNoKGUpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHlpc3QgKHNyYywgZHN0LCBrZXkpIHtcbiAgZHN0W2tleV0gPSBzcmNba2V5XTtcbn1cblxuZnVuY3Rpb24gY29weWlzdFdpdGhEZWVwTWVyZ2UgKHRhcmdldCwgc3JjLCBkc3QsIGtleSkge1xuICBpZiAodHlwZW9mIHNyY1trZXldICE9PSAnb2JqZWN0JyB8fCAhc3JjW2tleV0pIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldO1xuICB9XG4gIGVsc2Uge1xuICAgIGlmICghdGFyZ2V0W2tleV0pIHtcbiAgICAgIGRzdFtrZXldID0gc3JjW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRzdFtrZXldID0gZGVlcE1lcmdlKHRhcmdldFtrZXldLCBzcmNba2V5XSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVlcE1lcmdlICh0YXJnZXQsIHNyYykge1xuICB2YXIgYXJyYXkgPSBBcnJheS5pc0FycmF5KHNyYyk7XG4gIHZhciBkc3QgPSBhcnJheSAmJiBbXSB8fCB7fTtcblxuICBpZiAoYXJyYXkpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgW107XG4gICAgZHN0ID0gZHN0LmNvbmNhdCh0YXJnZXQpO1xuICAgIHNyYy5mb3JFYWNoKGRlZXBNZXJnZXIuYmluZChudWxsLCB0YXJnZXQsIGRzdCkpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIE9iamVjdC5rZXlzKHRhcmdldCkuZm9yRWFjaChjb3B5aXN0LmJpbmQobnVsbCwgdGFyZ2V0LCBkc3QpKTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMoc3JjKS5mb3JFYWNoKGNvcHlpc3RXaXRoRGVlcE1lcmdlLmJpbmQobnVsbCwgdGFyZ2V0LCBzcmMsIGRzdCkpO1xuICB9XG5cbiAgcmV0dXJuIGRzdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmRlZXBNZXJnZSA9IGRlZXBNZXJnZTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgaW5zdGFuY2UgYWdhaW5zdCB0aGUgcHJvdmlkZWQgc2NoZW1hXG4gKiBJbXBsZW1lbnRzIFVSSStKU09OIFBvaW50ZXIgZW5jb2RpbmcsIGUuZy4gXCIlN2VcIj1cIn4wXCI9PlwiflwiLCBcIn4xXCI9XCIlMmZcIj0+XCIvXCJcbiAqIEBwYXJhbSBvXG4gKiBAcGFyYW0gcyBUaGUgcGF0aCB0byB3YWxrIG8gYWxvbmdcbiAqIEByZXR1cm4gYW55XG4gKi9cbmV4cG9ydHMub2JqZWN0R2V0UGF0aCA9IGZ1bmN0aW9uIG9iamVjdEdldFBhdGgobywgcykge1xuICB2YXIgcGFydHMgPSBzLnNwbGl0KCcvJykuc2xpY2UoMSk7XG4gIHZhciBrO1xuICB3aGlsZSAodHlwZW9mIChrPXBhcnRzLnNoaWZ0KCkpID09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG4gPSBkZWNvZGVVUklDb21wb25lbnQoay5yZXBsYWNlKC9+MC8sJ34nKS5yZXBsYWNlKC9+MS9nLCcvJykpO1xuICAgIGlmICghKG4gaW4gbykpIHJldHVybjtcbiAgICBvID0gb1tuXTtcbiAgfVxuICByZXR1cm4gbztcbn07XG5cbmZ1bmN0aW9uIHBhdGhFbmNvZGVyICh2KSB7XG4gIHJldHVybiAnLycrZW5jb2RlVVJJQ29tcG9uZW50KHYpLnJlcGxhY2UoL34vZywnJTdFJyk7XG59XG4vKipcbiAqIEFjY2VwdCBhbiBBcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgcmV0dXJuIGEgSlNPTiBQb2ludGVyIFVSSSBmcmFnbWVudFxuICogQHBhcmFtIEFycmF5IGFcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0cy5lbmNvZGVQYXRoID0gZnVuY3Rpb24gZW5jb2RlUG9pbnRlcihhKXtcblx0Ly8gfiBtdXN0IGJlIGVuY29kZWQgZXhwbGljaXRseSBiZWNhdXNlIGhhY2tzXG5cdC8vIHRoZSBzbGFzaCBpcyBlbmNvZGVkIGJ5IGVuY29kZVVSSUNvbXBvbmVudFxuXHRyZXR1cm4gYS5tYXAocGF0aEVuY29kZXIpLmpvaW4oJycpO1xufTtcblxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGEgbnVtYmVyIHVzZXNcbiAqIFdlIG5lZWQgdGhpcyB0byBnZXQgY29ycmVjdCByZXN1bHRzIG91dCBvZiBtdWx0aXBsZU9mIGFuZCBkaXZpc2libGVCeVxuICogd2hlbiBlaXRoZXIgZmlndXJlIGlzIGhhcyBkZWNpbWFsIHBsYWNlcywgZHVlIHRvIElFRUUtNzU0IGZsb2F0IGlzc3Vlcy5cbiAqIEBwYXJhbSBudW1iZXJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydHMuZ2V0RGVjaW1hbFBsYWNlcyA9IGZ1bmN0aW9uIGdldERlY2ltYWxQbGFjZXMobnVtYmVyKSB7XG5cbiAgdmFyIGRlY2ltYWxQbGFjZXMgPSAwO1xuICBpZiAoaXNOYU4obnVtYmVyKSkgcmV0dXJuIGRlY2ltYWxQbGFjZXM7XG5cbiAgaWYgKHR5cGVvZiBudW1iZXIgIT09ICdudW1iZXInKSB7XG4gICAgbnVtYmVyID0gTnVtYmVyKG51bWJlcik7XG4gIH1cblxuICB2YXIgcGFydHMgPSBudW1iZXIudG9TdHJpbmcoKS5zcGxpdCgnZScpO1xuICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgaWYgKHBhcnRzWzFdWzBdICE9PSAnLScpIHtcbiAgICAgIHJldHVybiBkZWNpbWFsUGxhY2VzO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWNpbWFsUGxhY2VzID0gTnVtYmVyKHBhcnRzWzFdLnNsaWNlKDEpKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGVjaW1hbFBhcnRzID0gcGFydHNbMF0uc3BsaXQoJy4nKTtcbiAgaWYgKGRlY2ltYWxQYXJ0cy5sZW5ndGggPT09IDIpIHtcbiAgICBkZWNpbWFsUGxhY2VzICs9IGRlY2ltYWxQYXJ0c1sxXS5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gZGVjaW1hbFBsYWNlcztcbn07XG5cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldvcmRsaXN0ID0gZXhwb3J0cy52ZXJzaW9uID0gZXhwb3J0cy53b3JkbGlzdHMgPSBleHBvcnRzLnV0aWxzID0gZXhwb3J0cy5sb2dnZXIgPSBleHBvcnRzLmVycm9ycyA9IGV4cG9ydHMuY29uc3RhbnRzID0gZXhwb3J0cy5GaXhlZE51bWJlciA9IGV4cG9ydHMuQmlnTnVtYmVyID0gZXhwb3J0cy5Db250cmFjdEZhY3RvcnkgPSBleHBvcnRzLkNvbnRyYWN0ID0gZXhwb3J0cy5CYXNlQ29udHJhY3QgPSBleHBvcnRzLnByb3ZpZGVycyA9IGV4cG9ydHMuZ2V0RGVmYXVsdFByb3ZpZGVyID0gZXhwb3J0cy5Wb2lkU2lnbmVyID0gZXhwb3J0cy5XYWxsZXQgPSBleHBvcnRzLlNpZ25lciA9IHZvaWQgMDtcbnZhciBjb250cmFjdHNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9jb250cmFjdHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXNlQ29udHJhY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyYWN0c18xLkJhc2VDb250cmFjdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnRyYWN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb250cmFjdHNfMS5Db250cmFjdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnRyYWN0RmFjdG9yeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJhY3RzXzEuQ29udHJhY3RGYWN0b3J5OyB9IH0pO1xudmFyIGJpZ251bWJlcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJpZ051bWJlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmlnbnVtYmVyXzEuQmlnTnVtYmVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRml4ZWROdW1iZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpZ251bWJlcl8xLkZpeGVkTnVtYmVyOyB9IH0pO1xudmFyIGFic3RyYWN0X3NpZ25lcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXNpZ25lclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNpZ25lclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJzdHJhY3Rfc2lnbmVyXzEuU2lnbmVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVm9pZFNpZ25lclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJzdHJhY3Rfc2lnbmVyXzEuVm9pZFNpZ25lcjsgfSB9KTtcbnZhciB3YWxsZXRfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC93YWxsZXRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXYWxsZXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdhbGxldF8xLldhbGxldDsgfSB9KTtcbnZhciBjb25zdGFudHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2NvbnN0YW50c1wiKSk7XG5leHBvcnRzLmNvbnN0YW50cyA9IGNvbnN0YW50cztcbnZhciBwcm92aWRlcnMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3Byb3ZpZGVyc1wiKSk7XG5leHBvcnRzLnByb3ZpZGVycyA9IHByb3ZpZGVycztcbnZhciBwcm92aWRlcnNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9wcm92aWRlcnNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXREZWZhdWx0UHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyc18xLmdldERlZmF1bHRQcm92aWRlcjsgfSB9KTtcbnZhciB3b3JkbGlzdHNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC93b3JkbGlzdHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3JkbGlzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd29yZGxpc3RzXzEuV29yZGxpc3Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ3b3JkbGlzdHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdvcmRsaXN0c18xLndvcmRsaXN0czsgfSB9KTtcbnZhciB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsc1wiKSk7XG5leHBvcnRzLnV0aWxzID0gdXRpbHM7XG52YXIgbG9nZ2VyXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXJyb3JzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2dnZXJfMS5FcnJvckNvZGU7IH0gfSk7XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIENvbXBpbGUtVGltZSBDb25zdGFudHNcbi8vIFRoaXMgaXMgZ2VuZXJhdGVkIGJ5IFwibnBtIHJ1biBkaXN0XCJcbnZhciBfdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vX3ZlcnNpb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2ZXJzaW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdmVyc2lvbl8xLnZlcnNpb247IH0gfSk7XG52YXIgbG9nZ2VyID0gbmV3IGxvZ2dlcl8xLkxvZ2dlcihfdmVyc2lvbl8xLnZlcnNpb24pO1xuZXhwb3J0cy5sb2dnZXIgPSBsb2dnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldGhlcnMuanMubWFwIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwiMVwiOiBcIjB4NDQ2OTFCMzlkMWE3NWRDNEUwQTAzNDZDQkIxNUUzMTBlNkVEMUU4NlwiXG59XG4iLCJtb2R1bGUuZXhwb3J0cz1beyBcImNvbnN0YW50XCI6IGZhbHNlLCBcImlucHV0c1wiOiBbeyBcIm5hbWVcIjogXCJfbmV3XCIsIFwidHlwZVwiOiBcImFkZHJlc3NcIiB9XSwgXCJuYW1lXCI6IFwic2V0T3duZXJcIiwgXCJvdXRwdXRzXCI6IFtdLCBcInBheWFibGVcIjogZmFsc2UsIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIgfSwgeyBcImNvbnN0YW50XCI6IHRydWUsIFwiaW5wdXRzXCI6IFtdLCBcIm5hbWVcIjogXCJ0b3RhbFNpZ25hdHVyZXNcIiwgXCJvdXRwdXRzXCI6IFt7IFwibmFtZVwiOiBcIlwiLCBcInR5cGVcIjogXCJ1aW50MjU2XCIgfV0sIFwicGF5YWJsZVwiOiBmYWxzZSwgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiB9LCB7IFwiY29uc3RhbnRcIjogdHJ1ZSwgXCJpbnB1dHNcIjogW10sIFwibmFtZVwiOiBcIm93bmVyXCIsIFwib3V0cHV0c1wiOiBbeyBcIm5hbWVcIjogXCJcIiwgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiIH1dLCBcInBheWFibGVcIjogZmFsc2UsIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIgfSwgeyBcImNvbnN0YW50XCI6IGZhbHNlLCBcImlucHV0c1wiOiBbXSwgXCJuYW1lXCI6IFwiZHJhaW5cIiwgXCJvdXRwdXRzXCI6IFtdLCBcInBheWFibGVcIjogZmFsc2UsIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIgfSwgeyBcImNvbnN0YW50XCI6IHRydWUsIFwiaW5wdXRzXCI6IFt7IFwibmFtZVwiOiBcIlwiLCBcInR5cGVcIjogXCJieXRlczRcIiB9XSwgXCJuYW1lXCI6IFwiZW50cmllc1wiLCBcIm91dHB1dHNcIjogW3sgXCJuYW1lXCI6IFwiXCIsIFwidHlwZVwiOiBcInN0cmluZ1wiIH1dLCBcInBheWFibGVcIjogZmFsc2UsIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIgfSwgeyBcImNvbnN0YW50XCI6IGZhbHNlLCBcImlucHV0c1wiOiBbeyBcIm5hbWVcIjogXCJfbWV0aG9kXCIsIFwidHlwZVwiOiBcInN0cmluZ1wiIH1dLCBcIm5hbWVcIjogXCJyZWdpc3RlclwiLCBcIm91dHB1dHNcIjogW3sgXCJuYW1lXCI6IFwiXCIsIFwidHlwZVwiOiBcImJvb2xcIiB9XSwgXCJwYXlhYmxlXCI6IGZhbHNlLCBcInR5cGVcIjogXCJmdW5jdGlvblwiIH0sIHsgXCJpbnB1dHNcIjogW10sIFwidHlwZVwiOiBcImNvbnN0cnVjdG9yXCIgfSwgeyBcImFub255bW91c1wiOiBmYWxzZSwgXCJpbnB1dHNcIjogW3sgXCJpbmRleGVkXCI6IHRydWUsIFwibmFtZVwiOiBcImNyZWF0b3JcIiwgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiIH0sIHsgXCJpbmRleGVkXCI6IHRydWUsIFwibmFtZVwiOiBcInNpZ25hdHVyZVwiLCBcInR5cGVcIjogXCJieXRlczRcIiB9LCB7IFwiaW5kZXhlZFwiOiBmYWxzZSwgXCJuYW1lXCI6IFwibWV0aG9kXCIsIFwidHlwZVwiOiBcInN0cmluZ1wiIH1dLCBcIm5hbWVcIjogXCJSZWdpc3RlcmVkXCIsIFwidHlwZVwiOiBcImV2ZW50XCIgfSwgeyBcImFub255bW91c1wiOiBmYWxzZSwgXCJpbnB1dHNcIjogW3sgXCJpbmRleGVkXCI6IHRydWUsIFwibmFtZVwiOiBcIm9sZFwiLCBcInR5cGVcIjogXCJhZGRyZXNzXCIgfSwgeyBcImluZGV4ZWRcIjogdHJ1ZSwgXCJuYW1lXCI6IFwiY3VycmVudFwiLCBcInR5cGVcIjogXCJhZGRyZXNzXCIgfV0sIFwibmFtZVwiOiBcIk5ld093bmVyXCIsIFwidHlwZVwiOiBcImV2ZW50XCIgfV1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV0aFF1ZXJ5ID0gcmVxdWlyZSgnZXRoanMtcXVlcnknKTtcbnZhciBFdGhGaWx0ZXIgPSByZXF1aXJlKCdldGhqcy1maWx0ZXInKTtcbnZhciBFdGhDb250cmFjdCA9IHJlcXVpcmUoJ2V0aGpzLWNvbnRyYWN0Jyk7XG52YXIgSHR0cFByb3ZpZGVyID0gcmVxdWlyZSgnZXRoanMtcHJvdmlkZXItaHR0cCcpO1xudmFyIGFiaSA9IHJlcXVpcmUoJ2V0aGpzLWFiaScpO1xuLy8gY29uc3QgZ2V0VHhTdWNjZXNzID0gcmVxdWlyZSgnZXRoanMtdHJhbnNhY3Rpb24tc3VjY2VzcycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG52YXIgdW5pdCA9IHJlcXVpcmUoJ2V0aGpzLXVuaXQnKTtcbnZhciBrZWNjYWsyNTYgPSByZXF1aXJlKCdqcy1zaGEzJykua2VjY2FrXzI1NjtcbnZhciB0b0JOID0gcmVxdWlyZSgnbnVtYmVyLXRvLWJuJyk7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnZXRoanMtdXRpbCcpO1xudmFyIGdldFRyYW5zYWN0aW9uU3VjY2VzcyA9IHJlcXVpcmUoJy4vbGliL2dldFRyYW5zYWN0aW9uU3VjY2Vzcy5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV0aDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhqcyBFdGggaW5zdGFuY2UuXG4gKlxuICogQG1ldGhvZCBFdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBjcHJvdmlkZXIgdGhlIHdlYjMgc3RhbmRhcmQgcHJvdmlkZXIgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgRXRoIG9wdGlvbnMgb2JqZWN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBldGggRXRoIG9iamVjdCBpbnN0YW5jZVxuICogQHRocm93cyBpZiB0aGUgbmV3IGZsYWcgaXMgbm90IHVzZWQgaW4gY29uc3RydWN0aW9uXG4gKi9cblxuZnVuY3Rpb24gRXRoKGNwcm92aWRlciwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRXRoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzXSB0aGUgRXRoIG9iamVjdCByZXF1aXJlcyB5b3UgY29uc3RydWN0IGl0IHdpdGggdGhlIFwibmV3XCIgZmxhZyAoaS5lLiBgY29uc3QgZXRoID0gbmV3IEV0aCguLi4pO2ApLicpO1xuICB9XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHF1ZXJ5ID0gbmV3IEV0aFF1ZXJ5KGNwcm92aWRlciwgc2VsZi5vcHRpb25zLnF1ZXJ5KTtcbiAgT2JqZWN0LmtleXMoT2JqZWN0LmdldFByb3RvdHlwZU9mKHF1ZXJ5KSkuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgIHNlbGZbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcXVlcnlbbWV0aG9kTmFtZV0uYXBwbHkocXVlcnksIGFyZ3MpO1xuICAgIH07XG4gIH0pO1xuICBzZWxmLmZpbHRlciA9IG5ldyBFdGhGaWx0ZXIocXVlcnksIHNlbGYub3B0aW9ucy5xdWVyeSk7XG4gIHNlbGYuY29udHJhY3QgPSBuZXcgRXRoQ29udHJhY3QocXVlcnksIHNlbGYub3B0aW9ucy5xdWVyeSk7XG4gIHNlbGYuY3VycmVudFByb3ZpZGVyID0gcXVlcnkucnBjLmN1cnJlbnRQcm92aWRlcjtcbiAgc2VsZi5zZXRQcm92aWRlciA9IHF1ZXJ5LnNldFByb3ZpZGVyO1xuICBzZWxmLmdldFRyYW5zYWN0aW9uU3VjY2VzcyA9IGdldFRyYW5zYWN0aW9uU3VjY2VzcyhzZWxmKTtcbn1cblxuRXRoLkJOID0gQk47XG5FdGguaXNBZGRyZXNzID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdXRpbHMuaXNIZXhTdHJpbmcodmFsLCAyMCk7XG59O1xuRXRoLmtlY2NhazI1NiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuICcweCcgKyBrZWNjYWsyNTYodmFsKTtcbn07XG5FdGguQnVmZmVyID0gQnVmZmVyO1xuRXRoLmlzSGV4U3RyaW5nID0gdXRpbHMuaXNIZXhTdHJpbmc7XG5FdGguZnJvbVdlaSA9IHVuaXQuZnJvbVdlaTtcbkV0aC50b1dlaSA9IHVuaXQudG9XZWk7XG5FdGgudG9CTiA9IHRvQk47XG5FdGguYWJpID0gYWJpO1xuRXRoLmZyb21Bc2NpaSA9IHV0aWxzLmZyb21Bc2NpaTtcbkV0aC50b0FzY2lpID0gdXRpbHMudG9Bc2NpaTtcbkV0aC5mcm9tVXRmOCA9IHV0aWxzLmZyb21VdGY4O1xuRXRoLnRvVXRmOCA9IHV0aWxzLnRvVXRmODtcbkV0aC5IdHRwUHJvdmlkZXIgPSBIdHRwUHJvdmlkZXI7IiwiaW1wb3J0IGxvY2FsZm9yYWdlIGZyb20gJ2xvY2FsZm9yYWdlJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFN0b3JhZ2VJdGVtKGtleSkge1xuICB0cnkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWREYXRhID0gYXdhaXQgbG9jYWxmb3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgIGlmIChzZXJpYWxpemVkRGF0YSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gSlNPTi5wYXJzZShzZXJpYWxpemVkRGF0YSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNldFN0b3JhZ2VJdGVtKGtleSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzZXJpYWxpemVkRGF0YSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICBhd2FpdCBsb2NhbGZvcmFnZS5zZXRJdGVtKGtleSwgc2VyaWFsaXplZERhdGEpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLndhcm4oZXJyKTtcbiAgfVxufVxuIiwiLy8gRXh0ZXJuYWwgRGVwc1xuY29uc3QgRXRoID0gcmVxdWlyZSgnZXRoanMtcXVlcnknKVxuY29uc3QgRXRoQ29udHJhY3QgPSByZXF1aXJlKCdldGhqcy1jb250cmFjdCcpXG5jb25zdCBuYW1laGFzaCA9IHJlcXVpcmUoJ2V0aC1lbnMtbmFtZWhhc2gnKVxuXG4vLyBBQklzXG5jb25zdCByZWdpc3RyeUFiaSA9IHJlcXVpcmUoJy4vYWJpcy9yZWdpc3RyeS5qc29uJylcbmNvbnN0IHJlc29sdmVyQWJpID0gcmVxdWlyZSgnLi9hYmlzL3Jlc29sdmVyLmpzb24nKVxuXG4vLyBNYXAgbmV0d29yayB0byBrbm93biBFTlMgcmVnaXN0cmllc1xuY29uc3QgbmV0d29ya01hcCA9IHJlcXVpcmUoJ2V0aGVyZXVtLWVucy1uZXR3b3JrLW1hcCcpXG5jb25zdCBlbXB0eUhhc2ggPSAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuY29uc3QgZW1wdHlBZGRyID0gJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcblxuY29uc3QgTm90Rm91bmRFcnJvciA9IG5ldyBFcnJvcignRU5TIG5hbWUgbm90IGRlZmluZWQuJylcbmNvbnN0IEJhZENoYXJhY3RlckVycm9yID0gbmV3IEVycm9yKCdJbGxlZ2FsIENoYXJhY3RlciBmb3IgRU5TLicpXG5cbmNsYXNzIEVucyB7XG5cbiAgY29uc3RydWN0b3IgKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHsgcHJvdmlkZXIsIG5ldHdvcmsgfSA9IG9wdHNcbiAgICBsZXQgeyByZWdpc3RyeUFkZHJlc3MgfSA9IG9wdHNcblxuICAgIC8vIFZhbGlkYXRpb25zXG4gICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgRXRoSnNFTlMgQ29uc3RydWN0b3IgcmVxdWlyZXMgYSBwcm92aWRlci4nKVxuICAgIH1cblxuICAgIC8vIFJlcXVpcmVzIEVJVEhFUiBhIG5ldHdvcmsgb3IgYSByZWdpc3RyeUFkZHJlc3NcbiAgICBpZiAoIW5ldHdvcmsgJiYgIXJlZ2lzdHJ5QWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgRXRoSnNFTlMgQ29uc3RydWN0b3IgcmVxdWlyZXMgYSBuZXR3b3JrIG9yIHJlZ2lzdHJ5IGFkZHJlc3MuJylcbiAgICB9XG5cbiAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXJcbiAgICB0aGlzLmV0aCA9IG5ldyBFdGgodGhpcy5wcm92aWRlcilcbiAgICB0aGlzLmNvbnRyYWN0ID0gbmV3IEV0aENvbnRyYWN0KHRoaXMuZXRoKVxuICAgIHRoaXMubmFtZWhhc2ggPSBuYW1laGFzaFxuXG4gICAgLy8gTGluayB0byBSZWdpc3RyeVxuICAgIHRoaXMuUmVnaXN0cnkgPSB0aGlzLmNvbnRyYWN0KHJlZ2lzdHJ5QWJpKVxuICAgIGlmICghcmVnaXN0cnlBZGRyZXNzICYmIG5ldHdvcmspIHtcbiAgICAgIHJlZ2lzdHJ5QWRkcmVzcyA9IG5ldHdvcmtNYXBbbmV0d29ya11cbiAgICB9XG4gICAgdGhpcy5yZWdpc3RyeSA9IHRoaXMuUmVnaXN0cnkuYXQocmVnaXN0cnlBZGRyZXNzKVxuXG4gICAgLy8gQ3JlYXRlIFJlc29sdmVyIGNsYXNzXG4gICAgdGhpcy5SZXNvbHZlciA9IHRoaXMuY29udHJhY3QocmVzb2x2ZXJBYmkpXG4gIH1cblxuICBsb29rdXAgKG5hbWUgPSAnJykge1xuICAgIHJldHVybiB0aGlzLmdldE5hbWVoYXNoKG5hbWUpXG4gICAgLnRoZW4oKG5vZGUpID0+IHtcbiAgICAgIGlmIChub2RlID09PSBlbXB0eUhhc2gpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KE5vdEZvdW5kRXJyb3IpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yZXNvbHZlQWRkcmVzc0Zvck5vZGUobm9kZSlcbiAgICB9KVxuICB9XG5cbiAgZ2V0TmFtZWhhc2ggKG5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuYW1laGFzaChuYW1lKSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoQmFkQ2hhcmFjdGVyRXJyb3IpXG4gICAgfVxuICB9XG5cbiAgZ2V0T3duZXIgKG5hbWUgPSAnJykge1xuICAgIHJldHVybiB0aGlzLmdldE5hbWVoYXNoKG5hbWUpXG4gICAgLnRoZW4obm9kZSA9PiB0aGlzLmdldE93bmVyRm9yTm9kZShub2RlKSlcbiAgfVxuXG4gIGdldE93bmVyRm9yTm9kZSAobm9kZSkge1xuICAgIGlmIChub2RlID09PSBlbXB0eUhhc2gpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChOb3RGb3VuZEVycm9yKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZWdpc3RyeS5vd25lcihub2RlKVxuICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgIGNvbnN0IG93bmVyQWRkcmVzcyA9IHJlc3VsdFswXVxuICAgICAgaWYgKG93bmVyQWRkcmVzcyA9PT0gZW1wdHlBZGRyKSB7XG4gICAgICAgIHRocm93IE5vdEZvdW5kRXJyb3JcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG93bmVyQWRkcmVzc1xuICAgIH0pXG4gIH1cblxuICBnZXRSZXNvbHZlciAobmFtZSA9ICcnKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmFtZWhhc2gobmFtZSlcbiAgICAudGhlbihub2RlID0+IHRoaXMuZ2V0UmVzb2x2ZXJGb3JOb2RlKG5vZGUpKVxuICB9XG5cbiAgZ2V0UmVzb2x2ZXJBZGRyZXNzIChuYW1lID0gJycpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYW1laGFzaChuYW1lKVxuICAgIC50aGVuKG5vZGUgPT4gdGhpcy5nZXRSZXNvbHZlckFkZHJlc3NGb3JOb2RlKG5vZGUpKVxuICB9XG5cbiAgZ2V0UmVzb2x2ZXJGb3JOb2RlIChub2RlKSB7XG4gICAgaWYgKCFub2RlLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgIG5vZGUgPSBgMHgke25vZGV9YFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldFJlc29sdmVyQWRkcmVzc0Zvck5vZGUobm9kZSlcbiAgICAudGhlbigocmVzb2x2ZXJBZGRyZXNzKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5SZXNvbHZlci5hdChyZXNvbHZlckFkZHJlc3MpXG4gICAgfSlcbiAgfVxuXG4gIGdldFJlc29sdmVyQWRkcmVzc0Zvck5vZGUgKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3RyeS5yZXNvbHZlcihub2RlKVxuICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgIGNvbnN0IHJlc29sdmVyQWRkcmVzcyA9IHJlc3VsdFswXVxuICAgICAgaWYgKHJlc29sdmVyQWRkcmVzcyA9PT0gZW1wdHlBZGRyKSB7XG4gICAgICAgIHRocm93IE5vdEZvdW5kRXJyb3JcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNvbHZlckFkZHJlc3NcbiAgICB9KVxuICB9XG5cbiAgcmVzb2x2ZUFkZHJlc3NGb3JOb2RlIChub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmVzb2x2ZXJGb3JOb2RlKG5vZGUpXG4gICAgLnRoZW4oKHJlc29sdmVyKSA9PiB7XG4gICAgICByZXR1cm4gcmVzb2x2ZXIuYWRkcihub2RlKVxuICAgIH0pXG4gICAgLnRoZW4ocmVzdWx0ID0+IHJlc3VsdFswXSlcbiAgfVxuXG4gIHJldmVyc2UgKGFkZHJlc3MpIHtcbiAgICBpZiAoIWFkZHJlc3MpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ011c3Qgc3VwcGx5IGFuIGFkZHJlc3MgdG8gcmV2ZXJzZSBsb29rdXAuJykpXG4gICAgfVxuXG4gICAgaWYgKGFkZHJlc3Muc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMilcbiAgICB9XG5cbiAgICBjb25zdCBuYW1lID0gYCR7YWRkcmVzcy50b0xvd2VyQ2FzZSgpfS5hZGRyLnJldmVyc2VgXG4gICAgY29uc3Qgbm9kZSA9IG5hbWVoYXNoKG5hbWUpXG4gICAgcmV0dXJuIHRoaXMuZ2V0TmFtZWhhc2gobmFtZSlcbiAgICAudGhlbihub2RlID0+IHRoaXMuZ2V0UmVzb2x2ZXJGb3JOb2RlKG5vZGUpKVxuICAgIC50aGVuKHJlc29sdmVyID0+IHJlc29sdmVyLm5hbWUobm9kZSkpXG4gICAgLnRoZW4ocmVzdWx0cyA9PiByZXN1bHRzWzBdKVxuICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFbnNcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBNYWlubmV0XG4gICcxJzogJzB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZScsXG4gIC8vIFJvcHN0ZW5cbiAgJzMnOiAnMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlJyxcbiAgLy8gUmlua2VieVxuICAnNCc6ICcweDAwMDAwMDAwMDAwQzJFMDc0ZUM2OUEwZEZiMjk5N0JBNkM3ZDJlMWUnLFxuICAvLyBHb2VybGlcbiAgJzUnOiAnMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlJyxcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdE1lbW9pemUgPSBkZWZhdWx0TWVtb2l6ZTtcbmV4cG9ydHMuY3JlYXRlU2VsZWN0b3JDcmVhdG9yID0gY3JlYXRlU2VsZWN0b3JDcmVhdG9yO1xuZXhwb3J0cy5jcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IgPSBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3I7XG5mdW5jdGlvbiBkZWZhdWx0RXF1YWxpdHlDaGVjayhhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufVxuXG5mdW5jdGlvbiBhcmVBcmd1bWVudHNTaGFsbG93bHlFcXVhbChlcXVhbGl0eUNoZWNrLCBwcmV2LCBuZXh0KSB7XG4gIGlmIChwcmV2ID09PSBudWxsIHx8IG5leHQgPT09IG51bGwgfHwgcHJldi5sZW5ndGggIT09IG5leHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRG8gdGhpcyBpbiBhIGZvciBsb29wIChhbmQgbm90IGEgYGZvckVhY2hgIG9yIGFuIGBldmVyeWApIHNvIHdlIGNhbiBkZXRlcm1pbmUgZXF1YWxpdHkgYXMgZmFzdCBhcyBwb3NzaWJsZS5cbiAgdmFyIGxlbmd0aCA9IHByZXYubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFlcXVhbGl0eUNoZWNrKHByZXZbaV0sIG5leHRbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRNZW1vaXplKGZ1bmMpIHtcbiAgdmFyIGVxdWFsaXR5Q2hlY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGRlZmF1bHRFcXVhbGl0eUNoZWNrO1xuXG4gIHZhciBsYXN0QXJncyA9IG51bGw7XG4gIHZhciBsYXN0UmVzdWx0ID0gbnVsbDtcbiAgLy8gd2UgcmVmZXJlbmNlIGFyZ3VtZW50cyBpbnN0ZWFkIG9mIHNwcmVhZGluZyB0aGVtIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFhcmVBcmd1bWVudHNTaGFsbG93bHlFcXVhbChlcXVhbGl0eUNoZWNrLCBsYXN0QXJncywgYXJndW1lbnRzKSkge1xuICAgICAgLy8gYXBwbHkgYXJndW1lbnRzIGluc3RlYWQgb2Ygc3ByZWFkaW5nIGZvciBwZXJmb3JtYW5jZS5cbiAgICAgIGxhc3RSZXN1bHQgPSBmdW5jLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldERlcGVuZGVuY2llcyhmdW5jcykge1xuICB2YXIgZGVwZW5kZW5jaWVzID0gQXJyYXkuaXNBcnJheShmdW5jc1swXSkgPyBmdW5jc1swXSA6IGZ1bmNzO1xuXG4gIGlmICghZGVwZW5kZW5jaWVzLmV2ZXJ5KGZ1bmN0aW9uIChkZXApIHtcbiAgICByZXR1cm4gdHlwZW9mIGRlcCA9PT0gJ2Z1bmN0aW9uJztcbiAgfSkpIHtcbiAgICB2YXIgZGVwZW5kZW5jeVR5cGVzID0gZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGRlcDtcbiAgICB9KS5qb2luKCcsICcpO1xuICAgIHRocm93IG5ldyBFcnJvcignU2VsZWN0b3IgY3JlYXRvcnMgZXhwZWN0IGFsbCBpbnB1dC1zZWxlY3RvcnMgdG8gYmUgZnVuY3Rpb25zLCAnICsgKCdpbnN0ZWFkIHJlY2VpdmVkIHRoZSBmb2xsb3dpbmcgdHlwZXM6IFsnICsgZGVwZW5kZW5jeVR5cGVzICsgJ10nKSk7XG4gIH1cblxuICByZXR1cm4gZGVwZW5kZW5jaWVzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTZWxlY3RvckNyZWF0b3IobWVtb2l6ZSkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWVtb2l6ZU9wdGlvbnMgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgbWVtb2l6ZU9wdGlvbnNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmNzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGZ1bmNzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgdmFyIHJlY29tcHV0YXRpb25zID0gMDtcbiAgICB2YXIgcmVzdWx0RnVuYyA9IGZ1bmNzLnBvcCgpO1xuICAgIHZhciBkZXBlbmRlbmNpZXMgPSBnZXREZXBlbmRlbmNpZXMoZnVuY3MpO1xuXG4gICAgdmFyIG1lbW9pemVkUmVzdWx0RnVuYyA9IG1lbW9pemUuYXBwbHkodW5kZWZpbmVkLCBbZnVuY3Rpb24gKCkge1xuICAgICAgcmVjb21wdXRhdGlvbnMrKztcbiAgICAgIC8vIGFwcGx5IGFyZ3VtZW50cyBpbnN0ZWFkIG9mIHNwcmVhZGluZyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgICByZXR1cm4gcmVzdWx0RnVuYy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1dLmNvbmNhdChtZW1vaXplT3B0aW9ucykpO1xuXG4gICAgLy8gSWYgYSBzZWxlY3RvciBpcyBjYWxsZWQgd2l0aCB0aGUgZXhhY3Qgc2FtZSBhcmd1bWVudHMgd2UgZG9uJ3QgbmVlZCB0byB0cmF2ZXJzZSBvdXIgZGVwZW5kZW5jaWVzIGFnYWluLlxuICAgIHZhciBzZWxlY3RvciA9IGRlZmF1bHRNZW1vaXplKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgIHZhciBsZW5ndGggPSBkZXBlbmRlbmNpZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGFwcGx5IGFyZ3VtZW50cyBpbnN0ZWFkIG9mIHNwcmVhZGluZyBhbmQgbXV0YXRlIGEgbG9jYWwgbGlzdCBvZiBwYXJhbXMgZm9yIHBlcmZvcm1hbmNlLlxuICAgICAgICBwYXJhbXMucHVzaChkZXBlbmRlbmNpZXNbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IGFyZ3VtZW50cyBpbnN0ZWFkIG9mIHNwcmVhZGluZyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgICByZXR1cm4gbWVtb2l6ZWRSZXN1bHRGdW5jLmFwcGx5KG51bGwsIHBhcmFtcyk7XG4gICAgfSk7XG5cbiAgICBzZWxlY3Rvci5yZXN1bHRGdW5jID0gcmVzdWx0RnVuYztcbiAgICBzZWxlY3Rvci5yZWNvbXB1dGF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZWNvbXB1dGF0aW9ucztcbiAgICB9O1xuICAgIHNlbGVjdG9yLnJlc2V0UmVjb21wdXRhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVjb21wdXRhdGlvbnMgPSAwO1xuICAgIH07XG4gICAgcmV0dXJuIHNlbGVjdG9yO1xuICB9O1xufVxuXG52YXIgY3JlYXRlU2VsZWN0b3IgPSBleHBvcnRzLmNyZWF0ZVNlbGVjdG9yID0gY3JlYXRlU2VsZWN0b3JDcmVhdG9yKGRlZmF1bHRNZW1vaXplKTtcblxuZnVuY3Rpb24gY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yKHNlbGVjdG9ycykge1xuICB2YXIgc2VsZWN0b3JDcmVhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBjcmVhdGVTZWxlY3RvcjtcblxuICBpZiAodHlwZW9mIHNlbGVjdG9ycyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvciBleHBlY3RzIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCAnICsgKCd3aGVyZSBlYWNoIHByb3BlcnR5IGlzIGEgc2VsZWN0b3IsIGluc3RlYWQgcmVjZWl2ZWQgYSAnICsgdHlwZW9mIHNlbGVjdG9ycykpO1xuICB9XG4gIHZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMoc2VsZWN0b3JzKTtcbiAgcmV0dXJuIHNlbGVjdG9yQ3JlYXRvcihvYmplY3RLZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yc1trZXldO1xuICB9KSwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgIHZhbHVlc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZXMucmVkdWNlKGZ1bmN0aW9uIChjb21wb3NpdGlvbiwgdmFsdWUsIGluZGV4KSB7XG4gICAgICBjb21wb3NpdGlvbltvYmplY3RLZXlzW2luZGV4XV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiBjb21wb3NpdGlvbjtcbiAgICB9LCB7fSk7XG4gIH0pO1xufSJdLCJwcmVFeGlzdGluZ0NvbW1lbnQiOiIvLyMgc291cmNlTWFwcGluZ1VSTD1sdXhvbi5qcy5tYXAifQ==
